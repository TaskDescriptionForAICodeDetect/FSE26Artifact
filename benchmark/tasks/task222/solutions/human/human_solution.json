[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n\nstruct Edge {\n\tint to, dist, cap;\n\tEdge(int t, int d, int c) {\n\t\tto = t;\n\t\tdist = d;\n\t\tcap = c;\n\t}\n};\n\nstruct State {\n\tint pos, prev, v;\n\tdouble time;\n\tState(int p, int pr, int v_, double t) {\n\t\tpos = p;\n\t\tprev = pr;\n\t\tv = v_;\n\t\ttime = t;\n\t}\n\tbool operator<(const State& right) const {\n\t\treturn time > right.time;\n\t}\n};\n\ndouble min_time[32][32][32];\nbool visited[32][32][32];\n\nint main() {\n\twhile(true) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif (n == 0) break;\n\n\t\tint start, goal;\n\t\tcin >> start >> goal;\n\t\tstart--;\n\t\tgoal--;\n\n\t\tvector<vector<Edge>> G(n);\n\t\tfor (int i = 0; i<m; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tG[x].emplace_back(y, d, c);\n\t\t\tG[y].emplace_back(x, d, c);\n\t\t}\n\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tpriority_queue<State> que;\n\t\tfor (Edge& e : G[start]) {\n\t\t\tvisited[e.to][0][1] = true;\n\t\t\tmin_time[e.to][0][1] = e.dist;\n\t\t\tque.emplace(e.to, 0, 1, e.dist);\n\t\t}\n\n\t\tdouble ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\tauto s = que.top();\n\t\t\tque.pop();\n\t\t\tif (min_time[s.pos][s.prev][s.v] + 1e-8 <= s.time) continue;\n\t\t\tif (s.pos == goal && s.v == 1) {\n\t\t\t\tans = s.time;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int dv = -1; dv <= 1; dv++) {\n\t\t\t\tint nv = s.v + dv;\n\t\t\t\tfor (auto& e : G[s.pos]) {\n\t\t\t\t\tif (e.to == s.prev) continue;\n\t\t\t\t\tif (nv < 1 || e.cap < nv) continue;\n\t\t\t\t\tdouble nt = s.time + double(e.dist) / nv;\n\t\t\t\t\tif (!visited[e.to][s.pos][nv] || min_time[e.to][s.pos][nv] > nt) {\n\t\t\t\t\t\tvisited[e.to][s.pos][nv] = true;\n\t\t\t\t\t\tmin_time[e.to][s.pos][nv] = nt;\n\t\t\t\t\t\tque.emplace(e.to, s.pos, nv, nt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ans < 0) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t} else {\n\t\t\tprintf(\"%.5f\\n\", ans);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<functional>\n#include<iomanip>\nusing namespace std;\n\n#define MAX_N 110\n#define INF 999999999.99\n\nint N, M, S, G, a, b, c, d;\ndouble X[MAX_N][MAX_N][2];\ndouble dist[MAX_N][MAX_N][MAX_N];\n\npriority_queue<tuple<double, int, int, int>, vector<tuple<double, int, int, int>>, greater<tuple<double, int, int, int>>>Q;\n\ndouble dijkstra() {\n\tdist[S][0][0] = 0;\n\tQ.push(make_tuple(0.0, S, 0, 0));\n\n\twhile (!Q.empty())\n\t{\n\t\ttuple<double, int, int, int>tup = Q.top();\n\t\tQ.pop();\n\t\tdouble a1 = get<0>(tup);\n\t\tint a2 = get<1>(tup);\n\t\tint a3 = get<2>(tup);\n\t\tint a4 = get<3>(tup);\n\n\t\tfor (int i = 1; i <= N; i++)\n\t\t{\n\t\t\tif (i == a4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//X-1.\n\t\t\tif (a3 >= 1 && X[a2][i][1] >= a3 - 1)\n\t\t\t{\n\t\t\t\tdouble jikan = X[a2][i][0] / (a3 - 1);\n\n\t\t\t\tif (dist[i][a3 - 1][a2] > jikan + a1)\n\t\t\t\t{\n\t\t\t\t\tdist[i][a3 - 1][a2] = jikan + a1;\n\t\t\t\t\tQ.push(make_tuple(dist[i][a3 - 1][a2], i, a3 - 1, a2));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//X.\n\t\t\tif (X[a2][i][1] >= a3)\n\t\t\t{\n\t\t\t\tdouble jikan = X[a2][i][0] / a3;\n\n\t\t\t\tif (dist[i][a3][a2] > jikan + a1)\n\t\t\t\t{\n\t\t\t\t\tdist[i][a3][a2] = jikan + a1;\n\t\t\t\t\tQ.push(make_tuple(dist[i][a3][a2], i, a3, a2));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//X+1.\n\t\t\tif (X[a2][i][1] >= a3 + 1)\n\t\t\t{\n\t\t\t\tdouble jikan = X[a2][i][0] / (a3 + 1);\n\n\t\t\t\tif (dist[i][a3 + 1][a2] > jikan + a1)\n\t\t\t\t{\n\t\t\t\t\tdist[i][a3 + 1][a2] = jikan + a1;\n\t\t\t\t\tQ.push(make_tuple(dist[i][a3 + 1][a2], i, a3 + 1, a2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble RES = INF;\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tRES = min(RES, dist[G][1][i]);\n\t}\n\treturn RES;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) { break; }\n\t\tcin >> S >> G;\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tX[i][j][0] = INF;\n\t\t\t\tX[i][j][1] = 0.0;\n\t\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\t\tdist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tX[a][b][0] = c;\n\t\t\tX[b][a][0] = c;\n\t\t\tX[a][b][1] = d;\n\t\t\tX[b][a][1] = d;\n\t\t}\n\t\tdouble res1 = dijkstra();\n\t\tdouble res;\n\t\tres = res1;\n\t\tif (res > INF / 2) { cout << \"unreachable\" << endl; }\n\t\telse { cout << fixed << setprecision(15) << res << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst double INF = 1e10;\nstruct edge {\n\tint from;\n\tint to;\n\tint d;\n\tint c;\n\tedge() {}\n\tedge(int from, int to,int d, int c) :from(from), to(to),d(d), c(c) {}\n};\n\nstruct node {\n\tint n;\n\tint v;\n\tint rev;\n\n\tnode() {}\n\tnode(int n, int v, int rev) :n(n), v(v), rev(rev) {}\n\n\tbool operator ==(const node& o) const {\n\t\treturn (n == o.n) && (v == o.v) && (rev == o.rev);\n\t}\n};\n\nint dv[3] = { -1,0,1 };\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n, m;\n\twhile (cin >> n >> m, n | m) {\n\t\t/* input */\n\t\tint s, g; cin >> s >> g;\n\t\ts--; g--;\n\t\tvector<vector<edge>> G(n);\n\t\tfor (int i = 0; i < m;i++) {\n\t\t\tint x, y, d, c; cin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tG[x].push_back(edge(x, y, d, c));\n\t\t\tG[y].push_back(edge(y, x, d, c));\n\t\t}\n\n\t\t/* initialize */\n\t\tconst int MAX_V = 33;\n\t\tvector<vector<vector<double>>> dist(n,vector<vector<double>>(MAX_V,vector<double>(n,INF)));\n\t\tdist[s][0][s] = 0;\n\t\tqueue<node> q;\n\t\tq.push(node(s, 0, s));\n\n\t\t/* solve */\n\t\twhile (!q.empty()) {\n\t\t\tauto now = q.front(); q.pop();\n\t\t\tint now_n = now.n;\n\t\t\tint now_v = now.v;\n\t\t\tfor (auto e : G[now_n]) {\n\t\t\t\tif (now.rev == e.to) continue;\n\t\t\t\tfor (int i = 0; i < 3;i++) {\n\t\t\t\t\tif (now_v + dv[i] < 1) continue;\n\t\t\t\t\tif (now_v + dv[i] > e.c) continue;\n\t\t\t\t\tint next_v = now_v + dv[i];\n\t\t\t\t\tdouble cost = e.d / (double)next_v;\n\t\t\t\t\tif (dist[e.to][next_v][e.from] > dist[e.from][now_v][now.rev] + cost) {\n\t\t\t\t\t\tdist[e.to][next_v][e.from] = dist[e.from][now_v][now.rev] + cost;\n\t\t\t\t\t\tif (e.to == g && next_v == 1)continue;\n\t\t\t\t\t\tq.push(node(e.to, next_v, e.from));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = INF;\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tans = min(ans, dist[g][1][i]);\n\t\t}\n\t\tif (ans == INF) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << fixed << setprecision(7) << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 100\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc,i,j,k;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(i=1;i<=n;i++)for(j=1;j<=n;j++)for(k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    \n    while(que.size()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include <cstdio>\n#include <iomanip>\n\nusing namespace std;\n\nconst int MAX = 30 + 10;\nconst int MAX_V = 30 + 1;\nconst double INF = 100000000;\n\nclass Road {\npublic:\n\tint start;\n\tint end;\n\tint dist;\n\tint vLimit;\n\n};\n\nclass State {\npublic:\n\tint from;\n\tint end;\n\tint v;\n\tdouble time;\n\t\n\tbool operator<(const State&s)const {\n\t\treturn time > s.time;\n\t}\n};\n\nint changeV[3]{ -1, 0 ,1 };\n\n\nint main() {\n\tint city_num;\n\tint road_num;\n\n\twhile (cin >> city_num >> road_num) {\n\t\tif (!city_num && !road_num) return 0;\n\t\tint start;\n\t\tint end;\n\t\tcin >> start >> end;\n\t\tstart--;\n\t\tend--;\n\t\tvector<Road> map[MAX];\n\t\tdouble cost[MAX][MAX][MAX_V];\n\t\tif (road_num == 0) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < road_num; i++) {\n\t\t\t\tint from;\n\t\t\t\tint to;\n\t\t\t\tint dist;\n\t\t\t\tint vLimit;\n\t\t\t\tcin >> from >> to >> dist >> vLimit;\n\t\t\t\tfrom--;\n\t\t\t\tto--;\n\t\t\t\tRoad temp;\n\t\t\t\ttemp.start = from;\n\t\t\t\ttemp.end = to;\n\t\t\t\ttemp.dist = dist;\n\t\t\t\ttemp.vLimit = vLimit;\n\t\t\t\tmap[from].push_back(temp);\n\t\t\t\ttemp.start = to;\n\t\t\t\ttemp.end = from;\n\t\t\t\tmap[to].push_back(temp);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\t\tfor (int k = 0; k < MAX_V; k++) {\n\t\t\t\t\t\tcost[i][j][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpriority_queue<State> que;\n\t\t\tState tmp;\n\t\t\ttmp.from = start;\n\t\t\ttmp.end = start;\n\t\t\ttmp.time = 0;\n\t\t\ttmp.v = 0;\n\t\t\tque.push(tmp);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tState temp = que.top();\n\t\t\t\tque.pop();\t\n\t\t\t\tfor (int i = 0; i < map[temp.end].size(); i++) {\n\t\t\t\t\tRoad tp = map[temp.end][i];\n\t\t\t\t\tif (tp.end != temp.from) {\n\t\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\t\tint nowV = temp.v + changeV[j];\n\t\t\t\t\t\t\tif (nowV > 0 && nowV <= tp.vLimit) {\n\t\t\t\t\t\t\t\tif (temp.time + (double)tp.dist / nowV < cost[tp.start][tp.end][nowV]) {\n\t\t\t\t\t\t\t\t\tcost[tp.start][tp.end][nowV] = temp.time + (double)tp.dist / nowV;\n\t\t\t\t\t\t\t\t\tState tpp;\n\t\t\t\t\t\t\t\t\ttpp.from = tp.start;\n\t\t\t\t\t\t\t\t\ttpp.end = tp.end;\n\t\t\t\t\t\t\t\t\ttpp.v = nowV;\n\t\t\t\t\t\t\t\t\ttpp.time = cost[tp.start][tp.end][nowV];\n\t\t\t\t\t\t\t\t\tque.push(tpp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tdouble result = INF;\n\t\t\tfor (int i = 0; i < city_num; i++) {\n\t\t\t\tresult = min(result, cost[i][end][1]);\n\t\t\t}\n\n\t\t\tif (result == INF) {\n\t\t\t\tcout << \"unreachable\" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcout <<fixed<<setprecision(5)<< result << endl;\n\t\t}\n\t}\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];    \n    \n    int inx,iny,ind,inc;\n    double d[40][40][40];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\nstruct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n \n// (time,speed,node,pre_node)\nusing P = pair<pair<double,int>,pair<int,int>>;\n \n \nP makeP(double t,int s,int n,int np){\n    return make_pair(make_pair(t,s),make_pair(n,np));\n}\n \nvoid solve(int n,int m){\n    int start,goal; cin>>start>>goal;\n    start--;\n    goal--;\n    vector<vector<int>> g(n,vector<int>(n,INF));\n    vector<vector<int>> lim(n,vector<int>(n,0));\n    rep(i,m){\n        int x,y,d,c;\n        cin>>x>>y>>d>>c;\n        x--;\n        y--;\n        g[x][y] = d;\n        g[y][x] = d;\n        lim[x][y] = c;\n        lim[y][x] = c;\n    }\n \n    double visited[32][32][32];\n    rep(i,32) rep(j,32) rep(k,32) visited[i][j][k]=DBL_MAX/10;\n    visited[start][0][start] = 0;\n \n    priority_queue<P,vector<P>,greater<P>> que;\n    que.push(makeP(0,0,start,start));\n    while(!que.empty()){\n        auto p = que.top();\n        que.pop();\n        double ti = p.first.first;\n        int speed = p.first.second;\n        int node = p.second.first;\n        int pre = p.second.second;\n \n#ifdef DEBUG\n        cerr << \"time : \" << ti << \" \"  << \"node : \" << node+1 << \" \" << \"speed \" << speed << endl;\n#endif\n        if(node==goal and speed==1){\n            cout << Double(ti) << endl;\n            return;\n        }\n \n        if(ti > visited[node][speed][pre]) continue;\n \n        for(int next_node=0;next_node<n;next_node++){\n            if(next_node==node or next_node==pre or g[node][next_node]==INF) continue;\n            int d=g[node][next_node];\n            int c=lim[node][next_node];\n            for(int nspeed=speed-1;nspeed<=speed+1;nspeed++){\n                if(nspeed<=0 or nspeed>c) continue;\n                double nt = ti + (double)d/(double)nspeed;\n                if(nt < visited[next_node][nspeed][pre]){\n#ifdef DEBUG\n                    cerr << \"\\ttime \" << nt << \" \" << \"node \" << next_node+1 << \" speed \" << nspeed << endl;\n#endif\n                    visited[next_node][nspeed][node] = nt;\n                    que.push(makeP(nt,nspeed,next_node,node));\n                }\n            }\n        }\n    }\n    cout << \"unreachable\" << endl;\n}\n \nint main(){\n    int n,m;\n    while(cin>>n>>m){\n        if(n==0 && m==0) break;\n        solve(n,m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ndouble cut[32][32][32];\npair<int,int> way[32][32];\nint main() {\n\tint n, m, s, g;\n\twhile(cin >> n >> m, n) {\n\t\tcin >> s >> g;\n\t\tfill((double*)cut, (double*)cut + 32 * 1024, 1e100);\n\t\tfill((pair<int,int>*)way, (pair<int,int>*)way + 1024,make_pair(0,0));\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tway[x][y] = way[y][x] = make_pair(d,c);\n\t\t}\n\t\tpriority_queue<tuple<double, int, int>,vector<tuple<double, int, int>>,greater<tuple<double, int, int>>> que;\n\t\tque.push(make_tuple(0., s, 1));\n\t\twhile (!que.empty()&&(get<1>(que.top())!=g||get<2>(que.top())!=0)){\n\t\t\tauto a = que.top();\n\t\t\tque.pop();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (way[get<1>(a)][i].second == 0)continue;\n\t\t\t\tif (i == get<1>(a))continue;\n\t\t\t\tif (get<2>(a)>way[get<1>(a)][i].second)continue;\n\t\t\t\tif (get<2>(a) == 0)continue;\n\t\t\t\tfor (int j = max(0, get<2>(a)-1); j <= get<2>(a)+1; j++) {\n\t\t\t\t\tif (cut[i][j][get<1>(a)]>get<0>(a) + (double)way[get<1>(a)][i].first / get<2>(a)) {\n\t\t\t\t\t\tque.push(make_tuple(get<0>(a) + (double)way[get<1>(a)][i].first / get<2>(a), i, j));\n\t\t\t\t\t\tcut[i][j][get<1>(a)] = get<0>(a) + (double)way[get<1>(a)][i].first / get<2>(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (que.empty())cout << \"unreachable\" << endl;\n\t\telse cout << fixed << setprecision(10) << get<0>(que.top()) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <tuple>\n#include <climits>\n#define INF INT_MAX>>1\n \nusing namespace std;\n \nint main(void){\n    while(1){\n        int n, m; cin >> n >> m;\n        if(!n && !m) break;\n        int s, g; cin >> s >> g;\n        s--; g--;\n        pair<int, int> adjacent[35][35];//(距離, 制限速度)\n        fill(adjacent[0], adjacent[35], make_pair(-1, -1));\n        for(int i=0; i<m; i++){\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--; y--;\n            adjacent[x][y] = adjacent[y][x] = make_pair(d, c);\n        }\n \n        double dp[35][35][35];//dp[Node][speed][prev] = cost;\n        fill(dp[0][0], dp[35][0], INF);\n        dp[s][0][s] = 0.0;\n        priority_queue<tuple<int, double, int, int>, vector<tuple<int, double, int, int> >, greater<tuple<int, double, int, int> > > que;//(Node, cost, speed, prev)\n        //priority_queue<tuple<int, double, int, int> > que;//LTE(メモリ制限？)\n        que.push(make_tuple(s, 0, 0, s));\n        while(!que.empty()){\n            tuple<int, double, int, int> t = que.top();\n            que.pop();\n            int pos = get<0>(t);\n            double cost = get<1>(t);\n            int speed = get<2>(t);\n            int prev = get<3>(t);\n            if(cost != dp[pos][speed][prev]) continue;\n \n            for(int i=0; i<n; i++){\n                if(adjacent[pos][i].first != -1 && i != prev){\n                    int dist  = adjacent[pos][i].first;\n                    int limit = adjacent[pos][i].second;\n                    for(int ac=-1; ac<=1; ac++){\n                        int n_speed = speed + ac;\n                        if(n_speed <= 0 || limit < n_speed) continue;\n                        double n_cost = cost + double(dist)/n_speed;\n                        if(dp[i][n_speed][pos] > n_cost){\n                            dp[i][n_speed][pos] = n_cost;\n                            que.push(make_tuple(i, n_cost, n_speed, pos));\n                        }\n                    }\n                }\n            }\n        }\n \n        double ans = INF;\n        for(int i=0; i<n; i++){\n            ans = min((double)ans, dp[g][1][i]);\n        }\n        if(ans == INF) cout << \"unreachable\" << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\nconst double EPS = 1e-8;\n\nclass State{\npublic:\n  int pos, v, pre;\n  double time;\n  State(){}\n  State(int pos, int v, int pre, double time) : pos(pos), v(v), pre(pre), time(time) {}\n  bool operator < (const State& s) const { return time > s.time; }\n};\n\nint n, m, s, g;\nP edge[30][30];\ndouble vis[30][30][31];\n\nbool equals(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nvoid solve(){\n  State u, v;\n  bool reach = false;\n  u = State(s, 0, 0, 0.0);\n  priority_queue<State> que;\n  fill(vis[0][0], vis[30][0], (double)INF);\n  for(int i=0;i<n;i++){\n    if(edge[s][i].first != INF){\n      vis[s][i][1] = edge[s][i].first;\n      que.push(State(i, 1, s, (double)edge[s][i].first));\n    }\n  }\n  while(!que.empty()){\n    u = que.top(); que.pop();\n    //cout << u.pos << ' ' << u.v << ' ' << u.pre << ' ' << u.time << endl;\n    if(u.pos == g && u.v == 1){\n      printf(\"%.5f\\n\", u.time);\n      return;\n    }\n    for(int i=0;i<n;i++){\n      if(edge[u.pos][i].first == INF) continue;\n      if(u.pre == i) continue;\n      for(int k=-1;k<=1;k++){\n        if(u.v + k > edge[u.pos][i].second) continue;\n        if(u.v + k <= 0) continue;\n        v = State(i, u.v + k, u.pos, u.time + edge[u.pos][i].first / (double)(u.v + k));\n        //cout << '\\t' << v.pos << ' ' << v.v << ' ' << v.pre << ' ' << v.time << ' ' << vis[v.pre][v.pos][v.v] << endl;\n        if(vis[v.pre][v.pos][v.v] > v.time && 1){\n          vis[v.pre][v.pos][v.v] = v.time;\n          que.push(v);\n        }\n      }\n    }\n  }\n  printf(\"unreachable\\n\");\n}\n\nmain(){\n  while(scanf(\"%d%d\", &n, &m) && (n|m)){\n    scanf(\"%d%d\", &s, &g);\n    s--; g--;\n    fill(edge[0], edge[30], P(INF, 0));\n    for(int i=0;i<m;i++){\n      int a, b, c, d;\n      scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n      a--; b--;\n      edge[a][b] = edge[b][a] = P(c, d);\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<functional>\n#include<iomanip>\nusing namespace std;\n\n#define MAX_N 110\n#define INF 999999999.99\n\nint N, M, S, G, a, b, c, d;\ndouble X[MAX_N][MAX_N][2];\ndouble dist[MAX_N][MAX_N];\n\npriority_queue<tuple<double, int, int, int>, vector<tuple<double, int, int, int>>, greater<tuple<double, int, int, int>>>Q;\n\ndouble dijkstra() {\n\tdist[S][0] = 0;\n\tQ.push(make_tuple(0.0, S, 0, -1));\n\twhile (!Q.empty()) {\n\t\ttuple<double, int, int, int>tup = Q.top();\n\t\tQ.pop();\n\t\tdouble a1 = get<0>(tup);\n\t\tint a2 = get<1>(tup);\n\t\tint a3 = get<2>(tup);\n\t\tint a4 = get<3>(tup);\n\t\tfor (int i = 1; i <= N; i++)\n\t\t{\n\t\t\t//if (i != a4) {\n\t\t\t\t//X-1.\n\t\t\t\tif (a3 >= 1 && X[a2][i][1] >= a3 - 1) {\n\t\t\t\t\tif (dist[i][a3 - 1] > X[a2][i][0] / (a3 - 1) + a1) {\n\t\t\t\t\t\tdist[i][a3 - 1] = X[a2][i][0] / (a3 - 1) + a1;\n\t\t\t\t\t\tQ.push(make_tuple(dist[i][a3 - 1], i, a3 - 1, a2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//X.\n\t\t\t\tif (a3 >= 0 && X[a2][i][1] >= a3) {\n\t\t\t\t\tif (dist[i][a3] > X[a2][i][0] / a3 + a1) {\n\t\t\t\t\t\tdist[i][a3] = X[a2][i][0] / a3 + a1;\n\t\t\t\t\t\tQ.push(make_tuple(dist[i][a3], i, a3, a2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//X+1.\n\t\t\t\tif (a3 >= -1 && X[a2][i][1] >= a3 + 1) {\n\t\t\t\t\tif (dist[i][a3 + 1] > X[a2][i][0] / (a3 + 1) + a1) {\n\t\t\t\t\t\tdist[i][a3 + 1] = X[a2][i][0] / (a3 + 1) + a1;\n\t\t\t\t\t\tQ.push(make_tuple(dist[i][a3 + 1], i, a3 + 1, a2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t//}\n\t\t}\n\t}\n\treturn dist[G][1];\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) { break; }\n\t\tcin >> S >> G;\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tX[i][j][0] = INF;\n\t\t\t\tX[i][j][1] = 0.0;\n\t\t\t\tdist[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tX[a][b][0] = c;\n\t\t\tX[b][a][0] = c;\n\t\t\tX[a][b][1] = d;\n\t\t\tX[b][a][1] = d;\n\t\t}\n\t\tdouble res = dijkstra();\n\t\tif (res > INF / 2) { cout << \"unreachable\" << endl; }\n\t\telse { cout << fixed << setprecision(15) << res << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//1162\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nconst int MAX_N=30,MAX_C=30;\nconst double INF=1e8;\nconst double ESP=1e-8;\n\n#define EQ(a,b) fabs(a-b)<ESP\n\nint n,m;\nint s,g;\nstruct edge{\n\tint to,dist,c;\n};\nvector<edge> G[MAX_N];\n\nstruct S{\n\tint town,v,pre;\n\tdouble cost;\n\tbool operator<(const S &a) const{\n\t\treturn cost>a.cost;\n\t}\n};\n\ndouble cost[MAX_N][MAX_C+1][MAX_N];\n\nvoid dijkstra(){\n\tREP(i,n){\n\t\tREP(j,MAX_C+1){\n\t\t\tREP(k,n){\n\t\t\t\tcost[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<S> pq;\n\tpq.push(S{s,0,0,0.0});\n\tcost[s][0][0]=0;\n\twhile (!pq.empty()){\n\t\tS s=pq.top();\n\t\tpq.pop();\n\t\tif (cost[s.town][s.v][s.pre]<s.cost){\n\t\t\tcontinue;\n\t\t}\n\t\tFOR(acc,-1,1+1){\n\t\t\tif (s.v+acc<=0) continue;\n\t\t\tFOR(i,0,G[s.town].size()){\n\t\t\t\tedge e=G[s.town][i];\n\t\t\t\tif (s.v+acc>e.c){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (e.to==s.pre) continue;\n\t\t\t\tif (s.cost+(double)e.dist/(s.v+acc)<cost[e.to][s.v+acc][s.town]){\n\t\t\t\t\tcost[e.to][s.v+acc][s.town]=s.cost+(double)e.dist/(s.v+acc);\n\t\t\t\t\tpq.push(S{e.to,s.v+acc,s.town,cost[e.to][s.v+acc][s.town]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif (n){\n\t\t\tscanf(\"%d %d\",&s,&g);\n\t\t\ts--;\n\t\t\tg--;\n\t\t\tREP(i,n){\n\t\t\t\tG[i].clear();\n\t\t\t}\n\t\t\tREP(i,m){\n\t\t\t\tint x,y,d,c;\n\t\t\t\tscanf(\"%d %d %d %d\",&x,&y,&d,&c);\n\t\t\t\tx--;\n\t\t\t\ty--;\n\t\t\t\tG[x].push_back(edge{y,d,c});\n\t\t\t\tG[y].push_back(edge{x,d,c});\n\t\t\t}\n\t\t\tdijkstra();\n\t\t\tdouble ans=INF;\n\t\t\tREP(i,n){\n\t\t\t\tans=min(ans,cost[g][1][i]);\n\t\t\t}\n\t\t\tif (EQ(ans,INF)){\n\t\t\t\tprintf(\"unreachable\\n\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"%.6f\\n\",ans);\n\t\t\t}\n\t\t}\n\t}while (n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\nconst int MAX_V = 31;\nconst int MAX_S = 31;\nconst double INF = 9e9;\n\nint n,m,s,g;\n\nstruct edge{\n\tint to, dist, speed;\n\tedge(int t_to,int t_dist,int t_speed){\n\t\tto=t_to;dist=t_dist;speed=t_speed;\n\t}\n};\n\nstruct state{\n\tdouble cost;\n\tint c_v,p_v,speed;\n\tstate(int t_c_v,int t_p_v,double t_cost,int t_speed){ \n\t\tc_v=t_c_v;p_v=t_p_v;cost=t_cost;speed=t_speed;\n\t}\n\tbool operator>(const state& s) const {\n\t\treturn cost > s.cost;\n\t}\n\n};\n\nint ds[]={-1,0,1};\nvector< vector<edge> > G(MAX_V);\ndouble d[MAX_V][MAX_V][MAX_S];\n\nvoid dijkstra(){\n\tpriority_queue<state,vector<state>,greater<state> > que;\n\tfill_n((double *)d, sizeof(d)/sizeof(double),INF);\n\trep(i,G[s].size()){\n\t\tedge t_e=G[s][i];\n\t\tque.push(state(t_e.to,s,t_e.dist,1));\n\t\td[t_e.to][s][1]=(double)t_e.dist;\n\t}\n\n\twhile(!que.empty()){\n\t\tstate p = que.top(); que.pop();\n\t\tint c_v = p.c_v;\n\t\tint p_v = p.p_v;\n\n\t\tif( p.c_v == g && p.speed == 1 ){\n\t\t\tcout << p.cost << endl;\n\t\t\treturn;\n\t\t}\n\n\t\tif(d[c_v][p_v][p.speed]<p.cost) continue;\n\t\trep(i,G[c_v].size()){\n\t\t\tedge e = G[c_v][i];\n\t\t\tif(e.to==p_v) continue;\n\t\t\trep(j,3){\n\t\t\t\tif(p.speed+ds[j]>0&&p.speed+ds[j]<=e.speed){\n\t\t\t\t\tdouble cost=p.cost+((double)e.dist/(double)(p.speed+ds[j]));\n\t\t\t\t\tif(d[e.to][c_v][p.speed+ds[j]] > cost + 1e-8){\n\t\t\t\t\t\td[e.to][c_v][p.speed+ds[j]] = cost;\n\t\t\t\t\t\tque.push(state( e.to , c_v , cost , p.speed+ds[j] ));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"unreachable\" << endl;\n}\n\n\nint main(){\n\n\tcout << fixed << setprecision(6);\n\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\tcin >> s >> g;\t\n\t\ts--;g--;\n\n\t\tG.clear();\n\t\tG.resize(MAX_V);\n\n\t\trep(i,m){\n\t\t\tint a,b,dist,c;\n\t\t\tcin >> a >> b >> dist >> c;\n\t\t\ta--;b--;\n\t\t\tedge tmp1(b,dist,c);\n\t\t\tedge tmp2(a,dist,c);\n\t\t\tG[a].push_back(tmp1);\n\t\t\tG[b].push_back(tmp2);\n\t\t}\n\n\t\tdijkstra();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cout << x << \" \";} cout << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\n// typedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\n// const int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef tuple<double, int, int, int> TUPLE;\nconst double inf = 1e12;\n\nstruct edge {\n    int to, d, c;\n    edge(){}\n    edge(int _to, int _d, int _c) : to(_to), d(_d), c(_c) {}\n};\ntypedef vector<vector<edge>> Graph;\ndouble dijkstra(const Graph& G, int s, int g) {\n    int n = G.size();\n    priority_queue<TUPLE, vector<TUPLE>, greater<TUPLE>> pq;   // cost, i, j, pre\n    vector<vector<vector<double>>> d(n, vector<vector<double>>(31, vector<double>(n + 1, inf)));\n    d[s][0][n] = 0;\n    pq.push(make_tuple(0, s, 0, n));\n\n    while (!pq.empty()) {\n        double cost;\n        int i, j, pre;\n        tie(cost, i, j, pre) = pq.top(); pq.pop();\n        if (d[i][j][pre] < cost) continue;\n        for (const auto& e : G[i]) {\n            for (int k = -1; k <= 1; k++) {\n                if (e.to == pre) continue;\n                if (1 <= j + k && j + k <= e.c && d[e.to][j + k][i] > d[i][j][pre] + 1. * e.d / (j + k)) {\n                    d[e.to][j + k][i] = d[i][j][pre] + 1. * e.d / (j + k);\n                    pq.push(make_tuple(d[e.to][j + k][i], e.to, j + k, i));\n                }\n            }\n        }\n    }\n\n    return *min_element(all(d[g][1]));;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    int t = 0;\n    while (cin >> n >> m, n) {\n        int s, g;\n        cin >> s >> g;\n        s--, g--;\n        Graph G(n);\n        rep(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--, y--;\n            G[x].emplace_back(y, d, c);\n            G[y].emplace_back(x, d, c);\n        }\n\n        double ans = dijkstra(G, s, g);\n        if (ans < inf) {\n            cout << fixed << setprecision(10) << ans << endl;\n        } else {\n            cout << \"unreachable\" << endl;\n        }\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF 1000000007\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef pair<int,int>pi;\ntypedef pair<double,int>pd;\ntypedef pair<pd,pi>PP;\n\nstruct edge\n{\n    int to,dist,limit;\n};\n\nint n,m,s,g;\ndouble dp[31][31][31];\nvector<edge> G[31];\n\nvoid dijkstra()\n{\n    rep(i,n){\n        rep(j,n){\n            rep(k,31){\n                dp[i][j][k] = INF;\n            }\n        }\n    }\n    priority_queue<PP,vector<PP>,greater<PP> > que;\n    que.push(PP(pd(0.0,s),pi(0,0)));\n    dp[s][0][0] = 0.0;\n    while(!que.empty()){\n        PP pp = que.top();\n        pd p = pp.fi;\n        pi q = pp.se;\n        que.pop();\n        double cost = p.fi;\n        int v = p.se, prv = q.fi, sp = q.se;\n        if(dp[v][prv][sp] < cost) continue;\n        if(v == g && sp == 1){\n            printf(\"%.12lf\\n\",cost);\n            return;\n        }\n        for(int i=sp-1;i<=sp+1;i++){\n            if(i <= 0) continue;\n            for(auto& e : G[v]){\n                if(e.to != prv && i <= e.limit && dp[e.to][v][i] > cost+(double)e.dist/i){\n                    dp[e.to][v][i] = cost+(double)e.dist/i;\n                    que.push(PP(pd(dp[e.to][v][i],e.to),pi(v,i)));\n                }\n            }\n        }\n    }\n    printf(\"unreachble\\n\");\n}\n\nint main()\n{\n    while(1){\n        cin >> n >> m;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear();\n        }\n        cin >> s >> g;\n        s--,g--;\n        rep(i,m){\n            int a,b,c,d;\n            cin >> a >> b >> c >> d;\n            G[a-1].push_back((edge){b-1,c,d});\n            G[b-1].push_back((edge){a-1,c,d});\n        }\n        dijkstra();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n||m){\n    cin>>s>>g;\n    s--;g--;\n    int d[n][n],c[n][n];\n    memset(d,-1,sizeof(d));\n    memset(c,-1,sizeof(c));\n    int i,j,k,l,x,y;\n    for(i=0;i<m;i++){\n      cin>>x>>y>>j>>k;\n      x--;y--;\n      d[x][y]=d[y][x]=j;\n      c[x][y]=c[y][x]=k;\n    }\n    double v[n][50][n];\n    double inf=1<<28,p,ans=inf;\n    for(i=0;i<n;i++) for(j=0;j<50;j++) for(k=0;k<n;k++) v[i][j][k]=inf;\n    typedef pair<int,int> PPP;\n    typedef pair<int,PPP> P;\n    typedef pair<double,P> PP;\n    priority_queue<PP,vector<PP>,greater<PP> > q;\n    q.push(PP(0,P(s,PPP(1,-1))));\n    while(!q.empty()){\n      x=q.top().second.first;\n      y=q.top().second.second.first;\n      k=q.top().second.second.second;\n      p=q.top().first;q.pop();\n      if(v[x][y][k]<=p) continue;\n      v[x][y][k]=p;\n      if(x==g&&y==1) break;\n      for(i=0;i<n;i++){\n\tif(!~d[x][i]||i==k) continue;\n\tfor(j=-1;j<=1;j++){\n\t  if(k==-1&&j!=0) continue;\n\t  if(y+j<=0||c[x][i]<y+j) continue;\n\t  q.push(PP(p+(double)d[x][i]/(y+j),P(i,PPP(y+j,x))));\n\t}\n      }\n    }\n    for(i=0;i<n;i++) ans=min(ans,v[g][1][i]);\n    if(ans!=inf) printf(\"%.8f\\n\",ans);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repc(i, n) for (int i = 0; i <= int(n); i++)\n#define rrepc(i, n) for (int i = int(n); i >= 0; i--)\n#define repi(i, a, b) for (int i = int(a); i < int(b); i++)\n#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)\n#define each(x, y) for (auto &x : y)\n#define all(a) (a).begin(), (a).end()\n#define bit32(x) (1 << (x))\n#define bit64(x) (1ll << (x))\n#define sz(v) ((int) v.size())\n\nusing namespace std;\n\nusing i64 = long long;\nusing f80 = long double;\nusing vi32 = vector<int>;\nusing vi64 = vector<i64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n\ninline void yes() { cout << \"Yes\" << endl; exit(0); }\ninline void no() { cout << \"No\" << endl; exit(0); }\ntemplate <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate <typename T> inline void amax(T &x, T y) { x = max(x, y); }\ntemplate <typename T> inline void amin(T &x, T y) { x = min(x, y); }\ntemplate <typename T> inline T exp(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v) { each(x, v) is >> x; return is; }\ntemplate <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }\nvoid solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }\n\ndouble dp[31][31][31];\n\nvoid solve() {\n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0 && M == 0) {\n      return;\n    }\n    int s, g;\n    cin >> s >> g;\n    s--, g--;\n    vector<vector<tuple<int, int, int>>> graph(N);\n    rep(i, M) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      x--, y--;\n      graph[x].emplace_back(y, d, c);\n      graph[y].emplace_back(x, d, c);\n    }\n    repc(i, 30) repc(j, 30) repc(k, 30) {\n      dp[i][j][k] = 1e18;\n    }\n    pqasc<tuple<double, int, int, int>> q; // time, speed, vertex, parent\n    q.emplace(0, 0, s, 30);\n    while (sz(q)) {\n      double time;\n      int speed, u, par;\n      tie(time, speed, u, par) = q.top(), q.pop();\n      if (dp[u][par][speed] != 1e18) {\n        continue;\n      }\n      dp[u][par][speed] = time;\n      each(e, graph[u]) {\n        int v, d, c;\n        tie(v, d, c) = e;\n        if (v == par) continue;\n        if (speed + 1 <= c) {\n          int s = speed + 1;\n          if (dp[v][u][s] == 1e18) {\n            q.emplace(time + (double) d / s, s, v, u);\n          }\n        }\n        if (speed - 1 <= c && speed > 1) {\n          int s = speed - 1;\n          if (dp[v][u][s] == 1e18) {\n            q.emplace(time + (double) d / s, s, v, u);\n          }\n        }\n        if (speed <= c) {\n          int s = speed;\n          if (dp[v][u][s] == 1e18) {\n            q.emplace(time + (double) d / s, s, v, u);\n          }\n        }\n      }\n    }\n    double ans = 1e18;\n    rep(j, 30) amin(ans, dp[g][j][1]);\n    if (ans == 1e18) {\n      cout << \"unreachable\" << endl;\n    } else {\n      cout << ans << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<functional>\n\nint n, m, s, g;\nstruct load{\n\tint x;\n\tint y;\n\tint d;\n\tint c;\n};\nstruct P{\n\tdouble cost;\n\tint from;\n\tint now;\n\tint sp;\n\tbool operator > (const P& p) const{\n\t\treturn cost > p.cost;\n\t}\n};\n//vector<vector<vector<double>>> vvvi;\n\ndouble cost[31][31][31];//from now sp\n\n\nint main(){\n\n\n\twhile (cin >> n >> m, n | m){\n\t\tvector<load> L;\n\t\tcin >> s >> g;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tL.push_back({ x, y, d, c });\n\t\t\tL.push_back({ y, x, d, c });\n\t\t}\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\tq.push({ 0.0, s, s, 0 });\n\t\tcost[s][s][0] = 0.0;\n\n\t\tfor (int i = 0; i < 31; i++)\n\t\t\tfor (int j = 0; j < 31; j++)\n\t\t\t\tfor (int k = 0; k < 31; k++)\n\t\t\t\t\tcost[i][j][k] = 100000.0;\n\n\t\twhile (!q.empty()){\n\t\t\tif (q.top().now == g &&q.top().sp == 1)break;\n\t\t\tP q2 = q.top();\n\t\t\tq.pop();\n\t\t\tfor (int i = 0; i < (signed int)L.size(); i++){\n\t\t\t\tfor (int j = -1; j < 2; j++){\n\t\t\t\t\tif (q2.now == L[i].x&&q2.from != L[i].y&& L[i].c >= q2.sp + j)\n\t\t\t\t\t\tif (q2.sp + j>0)\n\t\t\t\t\t\t\tif (q2.cost + L[i].d / (double)(q2.sp + (j)) < cost[q2.now][L[i].y][q2.sp + (j)]){\n\t\t\t\t\t\t\t\tq.push({ q2.cost + L[i].d / (double)(q2.sp + (j)), q2.now, L[i].y, q2.sp + (j) });\n\t\t\t\t\t\t\t\tcost[q2.now][L[i].y][q2.sp + (j)] = q2.cost + L[i].d / (double)(q2.sp + (j));\n\t\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!q.empty())printf(\"%.5lf\\n\", q.top().cost);\n\t\telse cout << \"unreachable\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct state {\n\tint pos, speed, prev;\n\tdouble time;\n\tstate(int p, int pr, int s, double t):pos(p), prev(pr), speed(s), time(t){}\n\tbool operator>(const state& s) const {\n\t\treturn time > s.time;\n\t}\n};\n\nstruct edge {\n\tint to, cost, limit;\n\tedge(int t, int c, int l):to(t), cost(c), limit(l){}\n};\n\nvector<vector<edge> > es;\n\ndouble dijkstra(int s, int t) {\n\tpriority_queue<state, vector<state>, greater<state> > que;\n\tvector<vector<vector<double> > > dist(es.size(), vector<vector<double> >(es.size(), vector<double>(31, INT_MAX)));\n\tque.push(state(s, s, 0, 0.0));\n\tdist[s][s][0] = 0;\n\n\twhile(!que.empty()) {\n\t\tconst state s = que.top();\n\t\tque.pop();\n\n\t\tif(dist[s.pos][s.prev][s.speed] < s.time)\n\t\t\tcontinue;\n\n\t\tif(s.pos == t && s.speed == 1)\n\t\t\treturn s.time;\n\n\t\tfor(int i = 0; i < es[s.pos].size(); ++i) {\n\t\t\tconst edge& e = es[s.pos][i];\n\t\t\tif(e.to == s.prev)\n\t\t\t\tcontinue;\n\n\t\t\tfor(int j = max(1, s.speed - 1); j <= min(e.limit, s.speed + 1); ++j) {\n\t\t\t\tconst double tmp = s.time + (double)e.cost / j;\n\t\t\t\tif(dist[e.to][s.pos][j] > tmp) {\n\t\t\t\t\tdist[e.to][s.pos][j] = tmp;\n\t\t\t\t\tque.push(state(e.to, s.pos, j, tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1.0;\n}\n\n\nint main() {\n\tfor(int n, m; scanf(\"%d %d\", &n, &m), n;) {\n\t\tint s, g;\n\t\tscanf(\"%d %d\", &s, &g);\n\n\t\tes.clear();\n\t\tes.resize(n);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint x, y, d, c;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &d, &c);\n\t\t\tes[x - 1].push_back(edge(y - 1, d, c));\n\t\t\tes[y - 1].push_back(edge(x - 1, d, c));\n\t\t}\n\n\t\tconst double ans = dijkstra(s - 1, g - 1);\n\t\tif(ans < 0)\n\t\t\tputs(\"unreachable\");\n\t\telse\n\t\t\tprintf(\"%.10lf\\n\", ans);\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "//16\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  int c,p,s;\n  double t;\n  bool operator<(S a)const{\n    return t>a.t;\n  }\n};\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    int s,g;\n    cin>>s>>g;\n    int d[31][31]={{}};\n    int cs[31][31]={{}};\n    while(m--){\n      int x,y,di,ci;\n      cin>>x>>y>>di>>ci;\n      d[x][y]=d[y][x]=di;\n      cs[x][y]=cs[y][x]=ci;\n    }\n    bool p[31][31][31]={{{}}};\n    priority_queue<S> que;\n    S is={s,-1,0,0};\n    que.push(is);\n    while(!que.empty()){\n      S c=que.top();\n      if(c.c==g&&c.s==1)break;\n      que.pop();\n      if(p[c.c][c.p][c.s]++)continue;\n      for(int i=1;i<=n;i++){\n\tif(d[c.c][i]&&i!=c.p){\n\t  for(int a=-1;a<=1;a++){\n\t    S n;\n\t    n.c=i;\n\t    n.p=c.c;\n\t    n.s=c.s+a;\n\t    if(n.s>0&&n.s<=cs[c.c][i]){\n\t      n.t=c.t+d[c.c][i]*1./n.s;\n\t      que.push(n);\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(que.empty()){\n      cout<<\"unreachable\"<<endl;\n    }else{\n      cout<<fixed<<que.top().t<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\nstruct Edge {\n\tint v, s, p;\n\tdouble t;\n\tint d, c;\n\t\n\tEdge(int v_, int s_, int p_, double t_, int d_ = 0, int c_ = 0)\n\t: v(v_), s(s_), p(p_), t(t_), d(d_), c(c_) {}\n\t\n\tbool operator > (const Edge& e) const { return t > e.t; }\n};\n\nint n, m, s, g;\nvector< vector< Edge > > edges;\n\nvoid solve() {\n\tdouble time[33][33][33];\n\tfor_(i,0,33) for_(j,0,33) for_(k,0,33) time[i][j][k] = 1e9;\n\t\n\tpriority_queue< Edge, vector< Edge >, greater< Edge > > q;\n\tq.push(Edge(s, 0, 0, 0));\n\ttime[s][0][0] = 0;\n\t\n\twhile (!q.empty()) {\n\t\tEdge e = q.top(); q.pop();\n\t\t\n\t\tif (time[e.v][e.s][e.p] < e.t) continue;\n\t\t\n\t\tfor_(i,0,(int)edges[e.v].size()) {\n\t\t\tEdge ei = edges[e.v][i];\n\t\t\t\n\t\t\tif (ei.v != e.p) {\n\t\t\t\tfor_(d,-1,2) {\n\t\t\t\t\tint ns = e.s + d;\n\t\t\t\t\t\n\t\t\t\t\tif (ns > 0 && ei.c >= ns) {\n\t\t\t\t\t\tdouble nt = e.t + (double)ei.d / (double)ns;\n\t\t\t\t\t\tif (time[ei.v][ns][e.v] > nt) {\n\t\t\t\t\t\t\ttime[ei.v][ns][e.v] = nt;\n\t\t\t\t\t\t\tq.push(Edge(ei.v, ns, e.v, nt));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble ans = 1e9;\n\tfor_(k,0,33) ans = min(ans, time[g][1][k]);\n\tif (ans > 1e8) cout << \"unreachable\" << endl;\n\telse printf(\"%.9lf\\n\", ans);\n}\n\nint main() {\n\twhile (cin >> n >> m, n) {\n\t\tcin >> s >> g;\n\t\n\t\tedges.assign(n+1, vector< Edge >());\n\t\n\t\tfor_(i,0,m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tedges[x].push_back(Edge(y, 0, 0, 0, d, c));\n\t\t\tedges[y].push_back(Edge(x, 0, 0, 0, d, c));\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\nstruct E{int t,c,d;E(int t,int c,int d):t(t),c(c),d(d){}};\nvector<E>e[30];\nstruct S{double t;int cur,last,s;S(double t,int cur,int last,int s):t(t),cur(cur),last(last),s(s){}};\nstruct Cmp{bool operator()(const S&a,const S&b){return a.t>b.t;}};\ndouble F(int s,int g)\n{\n\tdouble time[31][30][30];\n\tint i,j,k;\n\tfill_n(&time[0][0][0],sizeof(time)/sizeof(double),1e99);\n\tpriority_queue<S,vector<S>,Cmp>q;\n\tq.push(S(0,s,s,1));\n\twhile(!q.empty())\n\t{\n\t\tS s=q.top();q.pop();\n\t\tif(time[s.s][s.cur][s.last]<=s.t)continue;\n\t\ttime[s.s][s.cur][s.last]=s.t;\n\t\tif(s.cur==g&&s.s==1)return s.t;\n\t\tfor(i=0;i<e[s.cur].size();++i)\n\t\t{\n\t\t\tE&r=e[s.cur][i];\n\t\t\tif(s.last==r.t)continue;\n\t\t\tif(s.cur==s.last)\n\t\t\t\tq.push(S(s.t+r.d/double(s.s),r.t,s.cur,s.s));\n\t\t\telse\n\t\t\t\tfor(j=(s.s-1?-1:0);j<2;++j)\n\t\t\t\t\tif(s.s+j<=r.c)\n\t\t\t\t\t\tq.push(S(s.t+r.d/double(s.s+j),r.t,s.cur,s.s+j));\n\t\t}\n\t}\n\treturn -1;\n}\nint main()\n{\n\tint n,m,s,g,x,y,d,c,i;\n\twhile(scanf(\"%d%d\",&n,&m),n)\n\t{\n\t\tfor(i=0;i<n;++i)e[i].clear();\n\t\tscanf(\"%d%d\",&s,&g);\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c);\n\t\t\t--x,--y;\n\t\t\te[x].push_back(E(y,c,d));\n\t\t\te[y].push_back(E(x,c,d));\n\t\t}\n\t\tdouble r=F(s-1,g-1);\n\t\tif(r<0)puts(\"unreachable\");\n\t\telse printf(\"%f\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\n#define INF 1e15\n\nint n, m;\n\nstruct edge{\n    int to;\n    double cost;\n    int limit;\n    edge(int t, double c, int l): to(t), cost(c), limit(l){}\n};\n\nstruct state{\n    int node, speed, prev;\n    double dist;\n    state(int n, int s, int p, double d): node(n), speed(s), prev(p), dist(d) {}\n    bool operator > (const state s) const {\n        return dist > s.dist;\n    }\n};\n \nvoid dijkstra(int start, vector<vector<vector<double> > > &d, vector<vector<edge> > graph){\n    d[start][0][start] = 0.0;\n    bool visit[31][31][31] = {};\n    priority_queue<state, vector<state>, greater<state> > q;\n    q.push(state(start, 0, start, 0.0));\n    while (!q.empty()){\n        state a = q.top();\n        q.pop();\n        int now = a.node, prev = a.prev, speed = a.speed;\n        if (visit[now][speed][prev]) continue;\n        visit[now][speed][prev] = 1;\n        // printf(\"%d %d %d\\n\", now, prev, speed);\n        if(d[now][speed][prev] < a.dist) continue;\n        REP(i,graph[now].size()){\n            edge e = graph[now][i];\n            int next = e.to, limit = e.limit;\n            if (next == prev) continue;\n            FOR(dif,-1,1){\n                int next_speed = speed + dif;\n                if (next_speed <= 0 || next_speed > limit) continue;\n                if (d[next][next_speed][now] > d[now][speed][prev] + e.cost/next_speed){\n                    d[next][next_speed][now] = d[now][speed][prev] + e.cost/next_speed;\n                    q.push(state(next, next_speed, now, d[next][next_speed][now]));\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    while (cin >> n >> m && n){\n        vector<vector<edge> > graph(n);\n        int s, g;\n        cin >> s >> g;\n        s--;\n        g--;\n        REP(i,m){\n            int x, y, c;\n            double d;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            graph[x].push_back(edge(y,d,c));\n            graph[y].push_back(edge(x,d,c));\n        }\n        vector<vector<vector<double> > > dist(n, vector<vector<double> > (31, vector<double> (n, INF)));\n        dijkstra(s, dist, graph);\n        double ans = INF;\n        REP(i,n) ans = min(ans, dist[g][1][i]);\n        if (ans == INF) cout << \"unreachable\" << endl;\n        else printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e10\nusing namespace std;\nstruct edge{\n  int to,limit;\n  double dist;\n};\nstruct Point{\n  int speed,prev,v;\n  double cost;\n  Point(){}\n  Point(int speed_,int prev_,int v_,double cost_)\n    :speed(speed_),prev(prev_),v(v_),cost(cost_){}\n  bool operator>(const Point &a)const{\n    return cost > a.cost;\n  }\n};\nvector<edge> G[100];\ndouble d[40][40][40];//speed,pos,prev\nbool used[40][40][40];\ntypedef pair<int,int> pii; //speed,prev\ntypedef pair<int,pii> PII;//to,speed,prev\ntypedef pair<double,PII> P;//cost,to,speed\n\ndouble dikstra(int s,int g){\n  int ds[3]={-1,0,1};\n  priority_queue<Point,vector<Point>,greater<Point> > que;\n  \n  for(int i=0;i<40;i++)\n    for(int j=0;j<40;j++)\n      for(int k=0;k<40;k++)\n\td[i][j][k]=INF;\n  \n  memset(used,0,sizeof(used));\n  d[0][s][0]=0;\n  Point tmp(0,0,s,0);\n  que.push(tmp);\n  \n  while(!que.empty()){\n    Point p=que.top();que.pop();\n    if(d[p.speed][p.v][p.prev]<p.cost)continue;\n    if(p.speed==1 && p.v==g)return p.cost;\n\n    for(int i=0;i<G[p.v].size();i++){\n\tedge e=G[p.v][i];\n      for(int j=0;j<3;j++){\n\tint ns=p.speed+ds[j];\n\tif(1<=ns && ns<= e.limit &&\n\t   used[ns][e.to][p.v]==false &&\n\t   e.to!=p.prev && \n\t   d[ns][e.to][p.v]>p.cost+e.dist/ns){\n\n\t  used[ns][e.to][p.v]=true;\n\t  Point tmp(ns,p.v,e.to,p.cost+e.dist/ns);\n\t  que.push(tmp);\n\t  d[ns][e.to][p.v]=p.cost+e.dist/ns;\n\t  //cout << \"d[\" << ns << \"][\" << e.to << \"][\" << p.v << \"]:\" << d[ns][e.to][p.v] << endl;\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n){\n    for(int i=0;i<100;i++)G[i].clear();\n    cin>>s>>g;\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      G[x].push_back((edge){y,c,d});\n      G[y].push_back((edge){x,c,d});\n    }\n    double ans=dikstra(s,g);\n    if(ans==-1)cout << \"unreachable\" << endl;\n    else printf(\"%.5lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<tuple<int,int,int>> City;//to,limit,distance\nvector<City> C;\ntypedef tuple<double,int,int,int> T;//time,cityid,speed,prev\npriority_queue<T,vector<T>,greater<T>> que;\ndouble memo[31][31][31];//[prev][cityid][speed]\n\nint main(){\n    cout.precision(5);\n    cout<<fixed;\n    int n,m;\n    while(cin>>n>>m,n){\n        int s,g;\n        cin>>s>>g;\n        C.clear();\n        for(int i=0;i<=n;i++) C.push_back(City());\n        for(int i=0;i<m;i++){\n            int x,y,d,c;\n            cin>>x>>y>>d>>c;\n            C[x].emplace_back(y,c,d);\n            C[y].emplace_back(x,c,d);\n        }\n        fill(memo[0][0],memo[31][0],1e8);\n        memo[0][s][0]=0;\n        while(!que.empty())que.pop();\n        que.emplace(0,s,0,0);\n        double ans=1e8;\n        while(!que.empty()){\n            T t=que.top(); que.pop();\n            double time=get<0>(t);\n            int cityid=get<1>(t);\n            int speed=get<2>(t);\n            int prev=get<3>(t);\n            if(time>memo[prev][cityid][speed]) continue;\n            if(cityid==g&&speed==1){\n                ans=time;\n                break;\n            }\n            for(auto& e:C[cityid]){\n                int to=get<0>(e);\n                int limit=get<1>(e);\n                double distance=get<2>(e);\n                if(to==prev)continue;\n                if(speed+1<=limit){\n                    if(memo[cityid][to][speed+1]>time+distance/(speed+1)){\n                        memo[cityid][to][speed+1]=time+distance/(speed+1);\n                        que.emplace(memo[cityid][to][speed+1],to,speed+1,cityid);\n                    }\n                }\n                if(speed<=limit&&speed>0){\n                    if(memo[cityid][to][speed]>time+distance/(speed)){\n                        memo[cityid][to][speed]=time+distance/(speed);\n                        que.emplace(memo[cityid][to][speed],to,speed,cityid);\n                    }\n                }\n                if(speed-1<=limit&&speed-1>0){\n                    if(memo[cityid][to][speed-1]>time+distance/(speed-1)){\n                        memo[cityid][to][speed-1]=time+distance/(speed-1);\n                        que.emplace(memo[cityid][to][speed-1],to,speed-1,cityid);\n                    }\n                }\n            }\n        }\n        if(ans==1e8){\n            cout<<\"unreachable\"<<endl;\n        }else{\n            cout<<ans<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n2017_04_24_AC\n<point>\n???(?????¨????????????????????¨??????????????¨???????????°???????????????)?????¶?????¨??????????????????????????????priority_queue???\n<caution>\n ???U?????????????????¶?????????????????????\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define D first\n#define C second\n\nusing namespace std;\n\nconst double INF = 1000000000.0;\n\ndouble d[35][35][35];\nbool visited[35][35][35];\nint N,M,S,G;\npair<int, int> p[35][35];\n\nstruct ST{\n  double ti;\n  int bn;\n  int cn;\n  int sp;\n  ST(double _ti, int _bn, int _cn, int _sp){\n    ti = _ti;\n    bn = _bn;\n    cn = _cn;\n    sp = _sp;\n  }\n\n  bool operator >(const ST &e) const{\n    return ti > e.ti;\n  }\n\n};\n\nint main() {\n  while(1){\n    cin>>N>>M;\n    if(N==0 && M==0) break;\n    cin>>S>>G;\n    S--; G--;\n\n    REP(i,0,N)REP(j,0,N)REP(k,0,35) d[i][j][k] = INF;\n    REP(i,0,N)REP(j,0,N)REP(k,0,35) visited[i][j][k] = false;\n    REP(i,0,N)REP(j,0,N) p[i][j].D = p[i][j].C = -1;\n\n    REP(i,0,M){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      p[x-1][y-1].D = p[y-1][x-1].D = d;\n      p[x-1][y-1].C = p[y-1][x-1].C = c;\n    }\n\n    d[S][S][0] = 0.0;\n\n    priority_queue< ST, vector<ST>, greater<ST> > PQ;\n    ST st(0.0,S,S,0);\n    PQ.push(st);\n\n    bool flag = true;\n    while(!PQ.empty()){\n      ST u = PQ.top(); PQ.pop();\n      double mtime = u.ti;\n      int ubn=u.bn, ucn=u.cn, usp=u.sp;\n      //visited[ubn][ucn][usp] = true;\n      if(d[ubn][ucn][usp] < mtime) continue;\n\n      if(ucn == G && usp == 1){\n        printf(\"%.5lf\\n\",d[ubn][ucn][usp]);\n        flag = false;\n        break;\n      }\n\n      visited[ubn][ucn][usp] = true;\n      for(int v = usp-1; v <= usp+1; v++){\n        if(v <= 0) continue;\n        REP(next,0,N){\n          if(/*visited[ucn][next][v] ||*/ p[ucn][next].D == -1 || p[ucn][next].C < v || ucn == next || ubn == next) continue;\n          if(d[ucn][next][v] > mtime + (double)p[ucn][next].D/(double)v){\n            d[ucn][next][v] = mtime + (double)p[ucn][next].D/(double)v;\n            ST tst(d[ucn][next][v], ucn,next,v);\n            PQ.push(tst);\n          }\n        }\n      }\n\n    }\n    if(flag){\n      cout<<\"unreachable\"<<endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define DBG(X) cout<<\" \"<<#X<<\" : \"<<X<<endl\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\n\nstruct Input\n{\n\tint n;char c;char str[1024];string s;ll l;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\nstruct Edge{\n\tint to, dist, limit;\n\tEdge(){};\n\tEdge(int t, int d, int l) : to(t), dist(d), limit(l){};\n};\n\nvector<Edge> e[50];\ndouble d[50][50];\n\nint main(){\n\twhile(1){\n\t\trep(i, 50) e[i].clear();\n\t\trep(i, 50) rep(j, 50) d[i][j] = 1e18;\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tif(n == 0 && m == 0) break;\n\t\tint s = in.nextInt(), g = in.nextInt();\n\t\trep(i, m) {\n\t\t\tint x = in.nextInt(), y = in.nextInt(), dist = in.nextInt(), c = in.nextInt();\n\t\t\te[x].pb({y, dist, c});\n\t\t\te[y].pb({x, dist, c});\n\t\t}\n\t\tauto dijkstra = [&]{\n\t\t\ttypedef pair<pair<double, int>, pii> P;\n\t\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\t\tP p;\n\t\t\td[s][0] = 0.0;\n\t\t\tq.push({{0.0, -1}, {s, 0}});\n\n\t\t\twhile(!q.empty()){\n\t\t\t\tp = q.top(); q.pop();\n\t\t\t\tint from = p.se.fi, v = p.se.se, prv = p.fi.se;\n\t\t\t\tdouble t = p.fi.fi;\n\t\t\t\tfor(auto ee : e[from]){\n\t\t\t\t\tint to = ee.to, dist = ee.dist, l = ee.limit;\n\t\t\t\t\tif(prv == to) continue;\n\t\t\t\t\tfor(int i = -1; i <= 1; i++){\n\t\t\t\t\t\tint nv = v + i;\n\t\t\t\t\t\tif(nv <= 0 || nv > l) continue;\n\t\t\t\t\t\tdouble tt = t + (double)dist / nv;\n\t\t\t\t\t\tif(d[to][nv] <= tt) continue;\n\t\t\t\t\t\td[to][nv] = tt;\n\t\t\t\t\t\tq.push({{tt, from}, {to, nv}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdijkstra();\n\t\t\n\t\tif(d[g][1] == 1e18) printf(\"unreachable\\n\");\n\t\telse printf(\"%.15lf\\n\", d[g][1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<functional>\n\nunsigned int n, m, s, g;\nstruct load{\n\tint x;\n\tint y;\n\tdouble d;\n\tint c;\n};\nstruct P{\n\tdouble cost;\n\tint from;\n\tint now;\n\tint sp;\n\tbool operator > (const P& p) const{\n\t\treturn cost > p.cost;\n\t}\n};\n//vector<vector<vector<double>>> vvvi;\n\ndouble cost[31][31][31];//from now sp\n\n\nint main(){\n\t\n\n\twhile (cin >> n >> m, n | m){\n\t\tvector<load> L;\n\t\tcin >> s >> g;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tunsigned int x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tL.push_back({ x, y, d, c });\n\t\t\tL.push_back({ y, x, d, c });\n\t\t}\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\tq.push({ 0.0, s, s, 0 });\n\t\tcost[s][s][0] = 0.0;\n\n\t\tfor (int i = 0; i < 31; i++)\n\t\t\tfor (int j = 0; j < 31; j++)\n\t\t\t\tfor (int k = 0; k < 31; k++)\n\t\t\t\t\tcost[i][j][k] = 100000.0;\n\n\t\twhile (!q.empty()){\n\t\t\tif (q.top().now == g &&q.top().sp == 1)break;\n\t\t\tP q2 = q.top();\n\t\t\t//printf(\"%lf:%d:%d\\n\", q2.cost, q2.from, q2.now);\n\t\t\tq.pop();\n\t\t\tfor (unsigned int i = 0; i < L.size(); i++){\n\t\t\t\tfor (int j = -1; j < 2; j++){\n\t\t\t\t\tif (q2.now == L[i].x&&q2.from != L[i].y&& L[i].c >= q2.sp + j)\n\t\t\t\t\t\tif (q2.sp + j>0)\n\t\t\t\t\t\t\tif (q2.cost + L[i].d / (double)(q2.sp + (j)) < cost[q2.now][L[i].y][q2.sp + (j)]){\n\t\t\t\t\t\t\t\tq.push({ q2.cost + L[i].d / (double)(q2.sp + (j)), q2.now, L[i].y, q2.sp + (j) });\n\t\t\t\t\t\t\t\tcost[q2.now][L[i].y][q2.sp + (j)] = q2.cost + L[i].d / (double)(q2.sp + (j));\n\t\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!q.empty())printf(\"%.5lf\\n\",q.top().cost);\n\t\telse cout << \"unreachable\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n\nstruct edge {\n    int dst;\n    int dist;\n    int limit;\n};\n\nstruct entry {\n    double cost;\n    int city;\n    int prev;\n    int vel;\n\n    bool operator<(const entry& rhs) const { return cost > rhs.cost; }\n};\n\ndouble costs[30][30][31];\nbool visit[30][30][31];\n\nint main()\n{\n    int n, m;\n    while (cin >> n >> m, n) {\n        int s, g; cin >> s >> g; --s; --g;\n\n        vector<vector<edge>> edges(n);\n        rep(i, m) {\n            int x, y, d, c; cin >> x >> y >> d >> c; --x; --y;\n            edges[x].push_back({ y, d, c });\n            edges[y].push_back({ x, d, c });\n        }\n\n        rep(i, n) rep(j, n) rep(k, 31) {\n            costs[i][j][k] = 1e10;\n            visit[i][j][k] = false;\n        }\n\n        priority_queue<entry> Q;\n        Q.push({ 0.0, s, s, 0 });\n        costs[s][s][0] = 0.0;\n        double ans = 1e10;\n\n        while (!Q.empty()) {\n            entry t = Q.top(); Q.pop();\n            if (visit[t.city][t.prev][t.vel])\n                continue;\n            visit[t.city][t.prev][t.vel] = true;\n            if (t.city == g && t.vel == 1) {\n                ans = costs[g][t.prev][1];\n                break;\n            }\n\n            for (const edge& e : edges[t.city]) {\n                if (e.dst == t.prev) continue;\n                for (int v = max(1, t.vel - 1); v <= min(30, t.vel + 1); ++v) {\n                    if (v > e.limit) continue;\n                    double new_cost = costs[t.city][t.prev][t.vel] + e.dist / double(v);\n                    if (new_cost < costs[e.dst][t.city][v]) {\n                        costs[e.dst][t.city][v] = new_cost;\n                        Q.push({ new_cost, e.dst, t.city, v });\n                    }\n                }\n            }\n        }\n\n        cout.precision(15);\n        if (ans == 1e10)\n            cout << \"unreachable\" << endl;\n        else\n            cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int INFINITY_HAHA = 999999;\n \ntypedef struct status {\n    int from, to, speed;\n    double time;\n    status(int x, int x2, double y, int z): from(x), to(x2), time(y), speed(z) {}\n    bool operator< (const status &b) const {\n        return time > b.time;\n    }\n} Status;\n\n\n\nint main() {\n    // freopen(\"input.txt\", \"r\", stdin);\n \n    int ncities, nroads;\n    while(scanf(\"%d%d\", &ncities, &nroads) != EOF && !(ncities == 0 && nroads == 0)) {\n \n        int visited[50][50][50];\n        priority_queue< Status> Q;\n \n        vector< vector<int> > path_cost(ncities + 1, vector<int>(ncities + 1, -1) );\n        vector< vector<int> > path_limit(ncities + 1, vector<int>(ncities + 1, -1) );\n \n        memset(visited, 0, sizeof(visited));\n \n        // Input\n        int start_index, end_index;\n        scanf(\"%d%d\" , &start_index, &end_index);\n \n        for(int n = 0; n < nroads; ++n) {\n            int x, y, d, c;\n            scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n            path_cost[x][y] = path_cost[y][x] = d;\n            path_limit[x][y] = path_limit[y][x] = c;\n        }\n \n        double minimun_v = 0;\n        Q.push(Status(start_index, start_index, 0.0, 0));\n \n        while(!Q.empty()) {\n            Status cs = Q.top();\n            Q.pop();\n \n            if(cs.to == end_index && cs.speed == 1) {\n                minimun_v = cs.time;\n                break;\n            }\n \n            if(visited[cs.from][cs.to][cs.speed]) continue;\n \n            visited[cs.from][cs.to][cs.speed] = 1;\n \n            for(int j = 1; j <= ncities; ++j) {\n                if(path_cost[cs.to][j] == -1) continue;\n                if(j == cs.from) continue;\n                 \n \n                for(int z = -1; z <= 1; ++z) {\n                    if(!visited[cs.to][j][cs.speed + z] && cs.speed + z >= 1 && cs.speed + z <= path_limit[cs.to][j]) {\n                        Q.push(Status(cs.to, j, cs.time + ((double)path_cost[cs.to][j])/(cs.speed + z), cs.speed + z));\n                    }\n                }\n            }\n        }\n \n        if(minimun_v) {\n            printf(\"%0.5lf\\n\", minimun_v);\n        } else {\n            printf(\"unreachable\\n\");\n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 100\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc,i,j,k;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(i=1;i<=n;i++)for(j=1;j<=n;j++)for(k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    \n    while(que.size()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntemplate<typename T> using VT = vector<T>\ntemplate<typename T> using VVT = vector<VT<T> >\ntemplate<typename T> using VVVT = vector<VVT<T> >\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst double eps = 1e-8, inf = 1e+8;\n\ntemplate<typename T> inline void chmin(T& t, T f){if(t > f)t = f;}\n\nstruct Edge {\n    int to; double wt; int cap;\n    Edge(int to, double wt, int cap):to(to), wt(wt), cap(cap){}\n};\n\nint n, m, s, g;\n\ndouble solve(vector<vector<Edge> >& G){\n    double res = inf;\n    VVVT<double> mem(n, VVT<double>(n, VT<double>(35, inf))); mem[s][s][0] = 0.;\n    typedef tuple<double, int, int, int> State;\n    priority_queue<State> q;\n    for(q.emplace(0., 0, s, s); !q.empty();){\n        double t; int v, u, p;\n        tie(t, v, u, p) = q.top(); q.pop();\n        if(mem[u][p][v] + t < -eps || res + t <= -eps)continue;\n        if(u == g && v == 1)chmin(res, -t);\n        for(auto e: G[u])if(e.to != p){\n            for(int dv=-1; dv<=1; ++dv){\n                int nv = v + dv <= 0? 1: v + dv;\n                double nt = e.wt / nv - t;\n                if(30 < nv || e.cap < nv || mem[e.to][u][nv] <= nt + eps)continue;\n                mem[e.to][u][nv] = nt;\n                q.emplace(-mem[e.to][u][nv], nv, e.to, u);\n            }\n        }\n    }\n    if(inf - res < eps)throw \"unreachable\";\n    return res;\n}\n\nint main(){\n    while(cin >> n >> m, n|m){\n        cin >> s >> g;\n        s--; g--;\n        vector<vector<Edge> > G(n);\n        rep(i, m){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            G[x].emplace_back(y, d, c);\n            G[y].emplace_back(x, d, c);\n        }\n        try{\n            cout << fixed << setprecision(5) << solve(G) << '\\n';\n        }\n        catch(const char* mes){\n            cout << mes << '\\n';\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int n, m; cin >> n >> m&&n;) {\n\t\tint s, g; cin >> s >> g;\n\t\tvector<vector<double>> D(n + 1, vector<double>(n + 1, INF));\n\t\tvector<vector<int>> C(n + 1, vector<int>(n + 1, 0));\n\t\trep(i, 0, m) {\n\t\t\tint x, y, d, c; cin >> x >> y >> d >> c;\n\t\t\tD[x][y] = D[y][x] = d;\n\t\t\tC[x][y] = C[y][x] = c;\n\t\t}\n\t\tstatic double dp[33][33][33];\n\t\trep(i, 0, 33)rep(j, 0, 33)rep(k, 0, 33)dp[i][j][k] = INF;\n\t\tusing T = tuple<int, int, int>;\n\t\tqueue<T> q;\n\t\tdp[s][0][0] = 0;\n\t\tq.emplace(s, 0, 0);\n\t\twhile (q.size()) {\n\t\t\tint cur, prev, e;\n\t\t\ttie(cur, prev, e) = q.front(); q.pop();\n\t\t\trep(next, 1, n + 1) {\n\t\t\t\tif (next == prev)continue;\n\t\t\t\tif (C[cur][next] == 0)continue;\n\t\t\t\trep(k, e - 1, e + 2) {\n\t\t\t\t\tif (k <= 0)continue;\n\t\t\t\t\tif (C[cur][next] < k)continue;\n\t\t\t\t\tif (chmin(dp[next][cur][k], dp[cur][prev][e] + D[cur][next] / k))\n\t\t\t\t\t\tq.emplace(next, cur, k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = INF;\n\t\trep(i, 1, n + 1) {\n\t\t\tif (chmin(ans, dp[g][i][1]))dump(ans);\n\t\t}\n\t\tcout << fixed << setprecision(10);\n\t\tif (ans == INF) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct S{\n  double t;\n  int v;\n  int p;\n  int from;\n  S(){}\n  S(double t, int v, int p,int from) :\n    t(t), v(v), p(p),from(from) {}\n};\nstruct edge{\n  int to, dist, lim;\n  edge(int to, int dist, int lim) :\n    to(to), dist(dist), lim(lim) {}\n};\ntypedef vector<edge> edges;\nbool operator < (const S& s, const S& t){\n  return s.t > t.t;\n}\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m>>s>>g, n){\n    s--; g--;\n    vector<edges> graph(n);\n    REP(i,m){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c; x--; y--;\n      graph[x].push_back(edge(y, d, c));\n      graph[y].push_back(edge(x, d, c));\n    }\n    priority_queue<S> que;\n    FORIT(it, graph[s]){\n      que.push(S(it->dist, 1, it->to, s));\n    }\n    bool used[40][40][40] = {};\n    double ans = -1;\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      //printf(\"quesize:%d time:%lf speed:%d point:%d\\n\",que.size(), s.t,s.v,s.p);\n      if(s.p == g && s.v == 1){\n        ans = s.t;\n        break;\n      }\n      if(used[s.v][s.p][s.from]) continue;\n      used[s.v][s.p][s.from] = true;\n      for(int nv = s.v - 1; nv <= s.v + 1; nv++)if(nv > 0){\n        FORIT(it, graph[s.p])if(it->lim >= nv && it->to != s.from){\n          que.push(S(s.t + (double)it->dist/nv, nv, it->to, s.from));\n        }\n      }\n    }\n    if(ans != -1) printf(\"%.5lf\\n\",ans);\n    else cout<<\"unreachable\"<<endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint n,m,s,g;\nmap<int, vector<TIII> > r;\nmap<pair<int, int>, double> v;\n\nint main(){\n\twhile(1){\n\t\tdouble ret = -1.0;\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)return 0;\n\t\tcin>>s>>g;\n\t\tr.clear();\n\t\tv.clear();\n\t\tREP(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tr[x].PB(MT(y,d,c));\n\t\t\tr[y].PB(MT(x,d,c));\n\t\t}\n\t\tpriority_queue<pair<double, pair<int, int> > , vector<pair<double, pair<int, int> > >, greater<pair<double, pair<int, int> > > > q;\n\t\tq.push(MP(0.0,MP(s, 0)));\n\t\twhile(!q.empty()){\n\t\t\tpair<double, pair<int, int> > tmp = q.top();\n\t\t\tq.pop();\n\t\t\tif(EXIST(v, tmp.second))continue;\n\t\t\tif(tmp.second == MP(g, 1)){\n\t\t\t\tret = tmp.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv[tmp.second]=tmp.first;\n\t\t\tint city = tmp.second.first;\n\t\t\tint speed = tmp.second.second;\n\t\t\tdouble now = tmp.first;\n\t\t\tREP(i, r[city].size()){\n\t\t\t\tFOR(sp, speed-1, speed+2){\n\t\t\t\t\tif(sp<1)continue;\n\t\t\t\t\tTIII f = r[city][i];\n\t\t\t\t\tif(f.second.second >= sp && sp > 0)q.push(MP(now+(f.second.first*1.0)/(sp*1.0), MP(f.first, sp)));\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ret < 0.0)cout << \"unreachable\" <<endl;\n\t\telse cout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define MAX 30\n#define INF 10000000.0\nstruct S{\n\tint e,s,b;\n};\n\nstruct S2{\n\tint d,c,to;\n};\n\nint main(){\n\n\tint n,m;\n\tint s,g;\n\tint x,y,d,c;\n\tfloat cost[MAX+1][MAX+1];\n\tS point,tmp;\n\tS2 nod;\n\tvector<S2> ed[MAX+1];\n\tqueue<S> no;\n\n\twhile(1){\n\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0) break;\n\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(!ed[i].empty()) ed[i].clear();\n\t\t}\n\n\t\tfor(int i=0;i<=30;i++){\n\t\t\tfor(int j=0;j<=30;j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\n\t\tcin>>s>>g;\n\t\tpoint.e=s,point.s=0,point.b=0;\n\t\tcost[0][s]=0;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tnod.c=c,nod.d=d,nod.to=y;;\n\t\t\ted[x].push_back(nod);\n\t\t\tnod.to=x;\n\t\t\ted[y].push_back(nod);\n\t\t}\n\n\t\tno.push(point);\n\t\twhile(!no.empty()){\n\t\t\tpoint=no.front();\n\t\t\tno.pop();\n\t\t\tfor(int i=0;i<ed[point.e].size();i++){\n\t\t\t\tif(point.b!=ed[point.e][i].to){\n\t\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\tif(point.s+j>0&&point.s+j<=30){\n\t\t\t\t\t\t\t//if(point.s+j==1&&ed[point.e][i].to==g) cout<<cost[point.s][point.e]+((double)ed[point.e][i].d/(point.s+j))<<endl;\n\t\t\t\t\t\t\tif(ed[point.e][i].c>=point.s+j){\n\t\t\t\t\t\t\t\t//cout<<point.e<<\",\"<<point.b<<\",\"<<point.s<<\",\"<<ed[point.e][i].to<<\",\"<<cost[point.s][point.e]<<\"^^\"<<cost[point.s][point.e]+(double)ed[point.e][i].d/(point.s+j)<<endl;\n\t\t\t\t\t\t\t\tif(cost[point.s+j][ed[point.e][i].to]>cost[point.s][point.e]+((float)ed[point.e][i].d/(point.s+j))){\n\t\t\t\t\t\t\t\t\tcost[point.s+j][ed[point.e][i].to]=cost[point.s][point.e]+((float)ed[point.e][i].d/(point.s+j));\n\t\t\t\t\t\t\t\t\ttmp.e=ed[point.e][i].to;\n\t\t\t\t\t\t\t\t\ttmp.s=point.s+j;\n\t\t\t\t\t\t\t\t\ttmp.b=point.e;\n\t\t\t\t\t\t\t\t\tno.push(tmp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cost[1][g]==INF) printf(\"unreachable\\n\");\n\t\telse printf(\"%.5f\\n\",cost[1][g]);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <queue>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst double INF = 1e+10;\n\ntypedef double Weight;\nstruct Edge{\n  int src, dest; Weight weight;\n  Edge(int src_, int dest_, Weight weight_):src(src_),dest(dest_),weight(weight_){}\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// Dijkstra (Verified: AOJ2005)\nvoid dijkstra(Graph &g, Array &d, int s) {\n  d.assign(g.size(), INF);\n  d[s] = 0;\n  typedef pair<Weight,int> P;\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    Weight dist = que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        que.push(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\nint main() {\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n)break;\n    int s,t;\n    cin>>s>>t;\n    --s;--t;\n    vector<int> x(m);\n    vector<int> y(m);\n    vector<int> d(m);\n    vector<int> c(m);\n    vector<int> ecnt(n);\n    REP(i,m){\n      cin>>x[i]>>y[i]>>d[i]>>c[i];\n      --x[i];--y[i];\n      ++ecnt[x[i]];\n      ++ecnt[y[i]];\n    }\n    vector<int> psum(n+1);\n    partial_sum(begin(ecnt),end(ecnt),begin(psum)+1);\n    Graph g(psum.back() * 31 * 2 + 1);\n    int half = psum.back() * 31;\n    vector<int> cpect = ecnt;\n    REP(i,m){\n      --ecnt[x[i]];\n      --ecnt[y[i]];\n      int index = psum[x[i]] + ecnt[x[i]];\n      int index_to = psum[y[i]] + ecnt[y[i]];\n      index *= 31;\n      index_to *= 31;\n      REP(j,c[i]+1){\n        if(j==0)continue;\n        g[index + j].emplace_back(index + j, index_to + j + half, double(d[i])/j);\n        g[index_to + j].emplace_back(index_to + j, index + j + half, double(d[i])/j);\n      }\n    }\n    REP(i,n){\n      REP(j,31){\n        if(j==0)continue;\n        REP(k,cpect[i])\n          REP(l,k){\n            int i_s = (psum[i] + k) * 31 + j;\n            int i_t = (psum[i] + l) * 31 + j;\n            g[i_s + half].emplace_back(i_s + half, i_t, 0);\n            g[i_t + half].emplace_back(i_t + half, i_s, 0);\n            if (j > 1) {\n              g[i_s + half].emplace_back(i_s + half, i_t - 1, 0);\n              g[i_t + half].emplace_back(i_t + half, i_s - 1, 0);\n            }\n            if (j < 30) {\n              g[i_s + half].emplace_back(i_s + half, i_t + 1, 0);\n              g[i_t + half].emplace_back(i_t + half, i_s + 1, 0);\n            }\n          }\n      }\n    }\n    double mint = INF;\n    REP(i,cpect[s]){\n      g[half * 2].emplace_back(half*2, (psum[s] + i)*31+1, 0);\n    }\n    Array dist(psum.back() * 31 * 2 + 1);\n    dijkstra(g, dist, half*2);\n    REP(i,cpect[t]){\n      mint = min(mint, dist[(psum[t]+i)*31+1 + half]);\n    }\n    if (mint < INF)\n      cout << setprecision(8) << fixed << mint << endl;\n    else\n      cout << \"unreachable\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nclass road{\npublic:\n  int x,y,d,c;\n};\n\nint main(){\n  int n,m,s,g;\n  road r[1000];\n  double t[31][31];\n  bool v[31][31];\n\n  for(;;){\n    scanf(\"%d %d\",&n,&m);\n    if(!n && !m)break;\n    scanf(\"%d %d\",&s,&g);\n\n    for(int i=0;i<m;i++)scanf(\"%d %d %d %d\",&r[i].x,&r[i].y,&r[i].d,&r[i].c);\n    \n    for(int i=0;i<=n;i++)\n      for(int j=0;j<=30;j++){\n\tt[i][j] = 1e10;\n\tv[i][j] = false;\n      }\n\n    t[s][0] = 0.0;\n\n    for(;;){\n      int x=-1,y=-1;\n      for(int i=1;i<=n;i++){\n\tfor(int j=0;j<=30;j++){\n\t  if(!v[i][j] && ( (x<0 && y<0) || t[x][y]>t[i][j]) ){\n\t    x = i;\n\t    y = j;\n\t  }\n\t}\n      }\n      if(x<0 && y<0)break;\n      v[x][y] = true;\n\n      for(int i=0;i<m;i++){\n\tif(r[i].x == x){\n\t  if(y+1<=r[i].c && t[r[i].y][y+1] > t[x][y]+(double)r[i].d/(y+1) ){\n\t    t[r[i].y][y+1] = t[x][y]+(double)r[i].d/(y+1);\n\t  }\n\t  if(y && y<=r[i].c && t[r[i].y][y] > t[x][y]+(double)r[i].d/(y) ){\n\t    t[r[i].y][y] = t[x][y]+(double)r[i].d/y;\n\t  }\n\t  if(y>0 && y-1<=r[i].c && t[r[i].y][y-1] > t[x][y]+(double)r[i].d/(y-1) ){\n\t    t[r[i].y][y-1] = t[x][y]+(double)r[i].d/(y-1);\n\t  }\n\t}else if(r[i].y == x){\n\t  if(y+1<=r[i].c && t[r[i].x][y+1] > t[x][y]+(double)r[i].d/(y+1) ){\n\t    t[r[i].x][y+1] = t[x][y]+(double)r[i].d/(y+1);\n\t  }\n\t  if(y && y<=r[i].c && t[r[i].x][y] > t[x][y]+(double)r[i].d/(y) ){\n\t    t[r[i].x][y] = t[x][y]+(double)r[i].d/y;\n\t  }\n\t  if(y>0 && y-1<=r[i].c && t[r[i].x][y-1] > t[x][y]+(double)r[i].d/(y-1) ){\n\t    t[r[i].x][y-1] = t[x][y]+(double)r[i].d/(y-1);\n\t  }\n\t}\n      }\n    }\n\n    if(t[g][1]>=1e10)printf(\"unreachable\\n\");\n    else printf(\"%.5lf\\n\",t[g][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n#define INF INT_MAX/3\n#define EPS 1e-14\n\ntypedef long long int lli;\ntypedef tuple<int,double,int> Road; // node/distance/limit\ntypedef tuple<double, int, int, int> Dat; \n  // time/current node/verocity/previous node\n\nconst int NMAX = 32, CMAX = 32;\ndouble dp[NMAX][CMAX];\nint n, m, s, g;\n\nint main() {\n  while (cin >> n >> m and n) {\n    cin >> s >> g;\n    vector<vector<Road>> G(n + 1);\n    REP(i, m) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      G[x].push_back(Road(y, d, c));\n      G[y].push_back(Road(x, d, c));\n    }\n    REP(i, NMAX) REP(j, CMAX) { dp[i][j] = INF; }\n    priority_queue<Dat,vector<Dat>, greater<Dat>> que;\n    que.push(Dat(0, s, 1, INF));\n    dp[s][1] = 0;\n    while (!que.empty()) {\n      Dat dat = que.top(); que.pop();\n      double cost = get<0>(dat);\n      int v = get<1>(dat), speed = get<2>(dat), from = get<3>(dat);\n      printf(\"(%d->%d, %fs,\\t%dm/s)\\n\", from, v, cost, speed);\n      if (cost > dp[v][speed]) continue;\n      for (Road r : G[v]) FOR(dv, -1, 2) {\n        int to = get<0>(r), limit = get<2>(r);\n        double dist = get<1>(r);\n        if (to == from or speed <= 0 or limit < speed) continue;\n        double newtime = dp[v][speed] + dist / speed;\n        if (dp[to][speed + dv] > newtime) {\n          dp[to][speed + dv] = newtime;\n          que.push(Dat(newtime, to, speed + dv, v));\n          printf(\"push (%d->%d, %fs,\\t%dm/s)\\n\", v, to, newtime, speed);\n        }\n      }\n    }\n    if (dp[g][0] > INF / 2) {\n      cout << \"unreachable\" << endl;\n    } else {\n      cout << fixed << setprecision(6) << dp[g][0] << endl;\n    }\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong double memo[10000][32];\nstruct edge {\n\tint id;\n\tint from;\n\tint to;\n\tint lim;\n\tlong double dis;\n};\nstruct aa {\n\tint id;\n\tint speed;\n\tlong double  time;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nint main() {\n\tcout << fixed << setprecision(12);\n\twhile (1) {\n\t\tmemset(memo, 9999999, sizeof(memo));\n\t\tint n, m; cin >> n >> m;\n\t\tif (!n)break;\n\t\tint s, g; cin >> s >> g; s--; g--;\n\t\tvector<edge>edges;\n\t\tvector<vector<int>>edgeids(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tlong double d;\n\t\t\tint x, y, c; cin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tedges.push_back(edge{ 2*i,x,y,c,d });\n\t\t\tedges.push_back(edge{ 2*i+1,y,x,c,d });\n\t\t\tedgeids[x].push_back(2 * i);\n\t\t\tedgeids[y].push_back(2 * i + 1);\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tfor (auto i : edgeids[s]) {\n\n\t\t\tque.push(aa{ i,1,edges[i].dis });\n\t\t\tmemo[i][1] = edges[i].dis;\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst edge oldedge(edges[atop.id]);\n\t\t\tconst int oldsp(atop.speed);\n\t\t\tconst long double oldtime(atop.time);\n\t\t\tfor (auto i : edgeids[oldedge.to]) {\n\t\t\t\tconst edge nextedge(edges[i]);\n\t\t\t\tif (nextedge.to == oldedge.from)continue;\n\t\t\t\telse {\n\t\t\t\t\tfor (int change = -1; change <= 1; ++change) {\n\t\t\t\t\t\tconst int nextsp = oldsp + change;\n\t\t\t\t\t\tif (nextsp == 0)continue;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (nextsp <= nextedge.lim) {\n\t\t\t\t\t\t\t\tconst long double nexttime= nextedge.dis / nextsp + oldtime;\n\t\t\t\t\t\t\t\tif (memo[i][nextsp] > nexttime) {\n\t\t\t\t\t\t\t\t\tmemo[i][nextsp] = nexttime;\n\t\t\t\t\t\t\t\t\tque.push(aa{ i,nextsp,nexttime });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong double amin = 999999999;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tif (edges[i].to == g) {\n\t\t\t\tamin = min(amin, memo[i][1]);\n\t\t\t}\n\t\t}\n\t\tif (amin > 99999999) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << amin << endl;\n\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nint n, m, s, g;\nconst int INF = 1e9;\n\nstruct edge {\n\tint to;\n\tint cost;\n\tint lim;\n};\n\nstruct va {\n\tdouble dist;\n\tint now;\n\tint speed;\n\tint prev;\n\tbool operator < (const va& o) const {\n\t\treturn dist > o.dist;\n\t}\n};\n\n\nint main() {\n\twhile (cin >> n >> m >> s >> g, n) {\n\t\ts--; g--;\n\t\tvector <vector <edge>> G(n);\n\t\trep (i, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tG[x].push_back({y, d, c});\n\t\t\tG[y].push_back({x, d, c});\n\t\t}\n\t\t// 頂点, speed, prev\n\n\t\tvector <vector <vector <int>>> used(50, vector <vector <int>> (50, vector <int> (50, false)));\n\t\tvector <vector <vector <double>>> list(50, vector <vector <double>> (50, vector <double> (50, INF)));\n\t\tpriority_queue <va> que;\n\t\tque.push({0.0, s, 0, s});\n\t\tlist[s][0][s] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tva tmp = que.top(); que.pop();\n\t\t\tif (used[tmp.now][tmp.speed][tmp.prev] == true) continue;\n\t\t\tused[tmp.now][tmp.speed][tmp.prev] = true;\n\n\t\t\trep (i, G[tmp.now].size()) {\n\t\t\t\tif (G[tmp.now][i].to == tmp.prev) continue;\n\t\t\t\tfor (auto ds : {-1, 0, 1}) {\n\t\t\t\t\tint tmpDs = tmp.speed + ds;\n\t\t\t\t\tif (tmpDs < 1 || tmpDs > 30 || tmpDs > G[tmp.now][i].lim) continue;\n\t\t\t\t\tif (list[G[tmp.now][i].to][tmpDs][tmp.now] > tmp.dist + 1.0 * G[tmp.now][i].cost / tmpDs) {\n\t\t\t\t\t\tlist[G[tmp.now][i].to][tmpDs][tmp.now] = tmp.dist + 1.0 * G[tmp.now][i].cost / tmpDs;\n\t\t\t\t\t\tque.push({tmp.dist + 1.0 * G[tmp.now][i].cost / tmpDs, G[tmp.now][i].to, tmpDs, tmp.now});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = INF;\n\t\trep (i, n) ans = min(ans, list[g][1][i]);\n\t\tcout << (ans == INF ? \"unreachable\" : to_string(ans)) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cxxabi.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    ((ll)1ll<60)\n#define INF     ((int)1<<30)\n#define EPS     (1e-9)\n#define MOD     (1000000007)\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\n//template<class S>auto&operator<<(ostream&os,vector<S>t){bool b=1;for(auto s:t)os<<(exchange(b,0)||strlen(abi::__cxa_demangle(typeid(S).name(),0,0,0))>20?\"\":\" \")<<s;return os<<endl;}\n\ntemplate<class E, class Q,typename C=typename remove_reference<decltype(get<0>(declval<Q&>()))>::type>\nstruct Dijkstra{\n    C maxVal=numeric_limits<C>::max();\n    int n;\n    vector<vector<E>> edge;\n    vector<vector<vector<C>>> distance;\n    Dijkstra(int N):n(N){\n        edge.resize(n);\n        distance=vector<vector<vector<C>>>(n,vector<vector<C>>(n,vector<C>(31,maxVal)));\n    }\n    void add(int a, E stat, bool dir=true){\n        edge[a].push_back(stat);\n        if(!dir)return;\n        swap(a,get<0>(stat));\n        edge[a].push_back(stat);\n    }\n    C dist(int s,int g){\n        auto cmp=[](Q a,Q b){return get<0>(a)>get<0>(b);};\n        priority_queue<Q,vector<Q>,decltype(cmp)> pq(cmp);\n        C ret=maxVal;\n        pq.emplace(0,s,s,0); /*初期値*/\n        while(!pq.empty()){ /*中身は自分で書く*/\n            double cost;\n            int prev,curr,spd;\n            tie(cost,prev,curr,spd)=pq.top(); pq.pop();\n            if(distance[curr][prev][spd]!=maxVal) continue;\n            distance[curr][prev][spd]=cost;\n            if(curr==g and spd==1){\n                ret=cost;\n                break;\n            }\n            for(auto e:edge[curr]){\n                int next,len,limit;\n                tie(next,len,limit)=e;\n                if(next==prev)continue;\n                if(spd+1<=limit and distance[next][curr][spd+1]==maxVal)\n                    pq.emplace(cost+(C)len/(spd+1),curr,next,spd+1);\n                if(spd<=limit and distance[next][curr][spd]==maxVal)\n                    pq.emplace(cost+(C)len/(spd),curr,next,spd);\n                if(spd-1<=limit and spd-1>0 and distance[next][curr][spd-1]==maxVal)\n                    pq.emplace(cost+(C)len/(spd-1),curr,next,spd-1);\n            }\n        }\n        return ret;\n    }\n};\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t    int s,g; cin>>s>>g;\n\t    Dijkstra<tuple<int,int,int>,tuple<double,int,int,int>> ds(n+1);\n\t    rep(i,m){\n\t        int x,y,d,c;\n\t        cin>>x>>y>>d>>c;\n\t        ds.add(x,make_tuple(y,d,c));\n\t    }\n\t    cout<<ds.dist(s,g)<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,0,-1,1,-1,-1,1,2,0,-2,0};\nconst int dy[]={0,1,-1,0,1,1,-1,-1,0,2,0,-2};\nconst int INF = 1<<30;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define reps(i,j,k) for(int i = (j); i < (k); ++i)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\nstruct node{\n\tint id;\n\tint dist;\n\tint v;\n\tnode(){}\n\tnode(int _id,int _dist,int _v){\n\t\tid = _id;\n\t\tdist = _dist;\n\t\tv = _v;\n\t}\n};\nstruct data{\n\tint id;\n\tint prev;\n\tdouble t;\n\tint v;\n\tdata(){}\n\tdata(int _id,int _prev,double _t,int _v){\n\t\tid = _id;\n\t\tt = _t;\n\t\tprev = _prev;\n\t\tv = _v;\n\t}\n\tbool operator<(const data &a)const{\n\t\tif(t == a.t)return v > a.v;\n\t\treturn t > a.t;\n\t}\n};\nvector <node> Graph[32];\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m),(n|m)){\n\t\trep(i,32){\n\t\t\tGraph[i].clear();\n\t\t}\n\t\tint s,g;\n\t\tscanf(\"%d%d\",&s,&g);\n\t\t--s;--g;\n\t\trep(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c);\n\t\t\t--x;--y;\n\t\t\tGraph[x].PB(node(y,d,c));\n\t\t\tGraph[y].PB(node(x,d,c));\n\t\t}\n\n\t\tpriority_queue <data> Q;\n\t\tdouble memo[32][32][32];\n\t\trep(i,32){\n\t\t\trep(j,32){\n\t\t\t\trep(k,32){\n\t\t\t\t\tmemo[i][j][k] = 99999999.9;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.push(data(s,s,0.0,0));\n\t\twhile(!Q.empty()){\n\t\t\tdata d = Q.top();Q.pop();\n\t\t\t//cout <<\"# \" << d.id << \" \" << d.t << \" \" << d.v << \"\\n\";\n\t\t\tif(memo[d.id][d.prev][d.v] < 99999999.9)continue;\n\t\t\tmemo[d.id][d.prev][d.v] = (double)d.t;\n\t\t\trep(i,Graph[d.id].size()){\n\t\t\t\tif(Graph[d.id][i].id == d.prev)continue;\n\t\t\t\treps(k,-1,2){\n\t\t\t\t\tif(d.v+k <= 0)continue;\n\t\t\t\t\tif(Graph[d.id][i].v >= d.v+k){\n\t\t\t\t\t\tQ.push(data(Graph[d.id][i].id,d.id,(double)d.t+(double)Graph[d.id][i].dist/(double)(d.v+k),d.v+k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = 99999999.9;\n\t\trep(i,n){\n\t\t\tans = min(ans,memo[g][i][1]);\n\t\t}\n\t\tif(ans == 99999999.9){\n\t\t\tputs(\"unreachable\");\n\t\t}\n\t\telse cout << fixed << setprecision(5) << ans << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\nstruct edge {\n    int to;\n    double cost;\n};\n\nint V;\nvector<edge> G[1000000];\ndouble d[1000000];\n\nvoid addedge(int st, int ed, double co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    G[st].push_back(e);\n}\n\nvoid dijkstra(int s) {\n    priority_queue<pdlg, vector<pdlg>, greater<pdlg> > que;\n    fill(d, d + V + 10, llmax);\n    d[s] = 0;\n    que.push(pdlg(0, s));\n\n    while (!que.empty()) {\n        pdlg p = que.top();\n        que.pop();\n        ll v = p.second;\n        if (d[v] < p.first) {\n            continue;\n        }\n        int len = G[v].size();\n        for (int i = 0; i < len; i++) {\n            edge e = G[v][i];\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                que.push(pdlg(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nint main() {\n    cout << fixed;\n    cout << setprecision(7);\n    while (1) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0) {\n            break;\n        }\n        V = n * 30 * n + 1;\n        for (int i = 0; i < V; i++) {\n            G[i].clear();\n        }\n        int st, ed;\n        cin >> st >> ed;\n        for (int i = 0; i < m; i++) {\n            int x, y, c;\n            double d;\n            cin >> x >> y >> d >> c;\n            for (int j = 0; j < 30; j++) {\n                for (int k = 0; k < n; k++) {\n                    if (k != y - 1 && k != x - 1) {\n                        if (j < c) {\n                            addedge(k * 30 * n + j * n + (x - 1),\n                                    (x - 1) * 30 * n + j * n + (y - 1),\n                                    d / (j + 1) * 1.0);\n                        }\n                        if (j + 1 < c) {\n                            addedge(k * 30 * n + j * n + (x - 1),\n                                    (x - 1) * 30 * n + (j + 1) * n + (y - 1),\n                                    d / (j + 2) * 1.0);\n                        }\n                        if (j - 1 >= 0 && j - 1 < c) {\n                            addedge(k * 30 * n + j * n + (x - 1),\n                                    (x - 1) * 30 * n + (j - 1) * n + (y - 1),\n                                    d / j * 1.0);\n                        }\n                    }\n                }\n            }\n            if (x == st) {\n                addedge(V - 1, (x - 1) * 30 * n + 0 * n + (y - 1), d);\n            }\n            for (int j = 0; j < 30; j++) {\n                for (int k = 0; k < n; k++) {\n                    if (k != y - 1 && k != x - 1) {\n                        if (j < c) {\n                            addedge(k * 30 * n + j * n + (y - 1),\n                                    (y - 1) * 30 * n + j * n + (x - 1),\n                                    d / (j + 1) * 1.0);\n                        }\n                        if (j + 1 < c) {\n                            addedge(k * 30 * n + j * n + (y - 1),\n                                    (y - 1) * 30 * n + (j + 1) * n + (x - 1),\n                                    d / (j + 2) * 1.0);\n                        }\n                        if (j - 1 >= 0 && j - 1 < c) {\n                            addedge(k * 30 * n + j * n + (y - 1),\n                                    (y - 1) * 30 * n + (j - 1) * n + (x - 1),\n                                    d / j * 1.0);\n                        }\n                    }\n                }\n            }\n            if (y == st) {\n                addedge(V - 1, (y - 1) * 30 * n + 0 * n + (x - 1), d);\n            }\n        }\n        dijkstra(V - 1);\n        // for (int i = 0; i < n; i++) {\n        //     for (int j = 0; j < n * 30; j++) {\n        //         if (d[i * n * 30 + j] != llmax) {\n        //             cout << d[i * n * 30 + j] << \" \";\n        //         }\n        //     }\n        //     cout << \"aaa\" << i << endl;\n        // }\n        // cout << d[V - 1] << endl;\n        double ans = llmax;\n        for (int i = 0; i < n; i++) {\n            if (d[i * 30 * n + 0 * n + (ed - 1)] < ans) {\n                ans = d[i * 30 * n + 0 * n + (ed - 1)];\n            }\n        }\n        if (ans < llmax) {\n            cout << ans << endl;\n        } else {\n            cout << \"unreachable\" << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n,m;\nint d[35][35];\nint c[35][35];\n\ndouble dist[35][35];\n\ntypedef tuple<double,int,int,int> state;\n\ndouble dijkstra(int src,int dest){\n\trep(i,35)rep(j,35) dist[i][j]=inf;\n\tdist[src][0]=0.0;\n\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\n\tstate init(0.0,src,-1,0);\n\tq.push(init);\n\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\tdouble distance;\n\t\tint v,p,s;\n\t\ttie(distance,v,p,s)=cur;\n\t\trep(i,n){\n\t\t\tif(d[v][i]==-1)\n\t\t\t\tcontinue;\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tint nv=i;\n\t\t\t\tint ns=s+j;\n\t\t\t\tif(ns<=0||c[v][i]<ns) continue;\n\t\t\t\tdouble nd=distance+(1.0*d[v][i]/ns);\n\t\t\t\tif(dist[nv][ns]>nd){\n\t\t\t\t\tdist[nv][ns]=nd;\n\t\t\t\t\tstate next(nd,nv,v,ns);\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (dist[dest][1]>=inf)?-1:dist[dest][1];\n}\n\nint main(void){\n\twhile(cin >> n >> m){\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tclr(d,-1);\n\t\tint s,g;\n\t\tcin >> s >> g;\n\t\ts--,g--;\n\t\trep(i,m){\n\t\t\tint x,y,dd,cc;\n\t\t\tcin >> x >> y >> dd >> cc;\n\t\t\tx--,y--;\n\t\t\td[x][y]=d[y][x]=dd;\n\t\t\tc[x][y]=c[y][x]=cc;\n\t\t}\n\t\tcout.precision(9);\n\t\tdouble ans=dijkstra(s,g);\n\t\tif(ans==-1.0)\n\t\t\tcout << \"unreachable\" << endl;\n\t\telse\n\t\t\tcout << fixed << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n\nconst int NIL = -1;\n\nclass Node {\npublic:\n    int vertex;\n    int last;\n    double speed;\n    double cost;\n    Node(int v, int l, double s, double c) :vertex(v), last(l), speed(s), cost(c) {}\n    bool operator>(const Node& n) const {return cost > n.cost;}\n};\n\nclass Key {\npublic:\n    int vertex;\n    int last;\n    double speed;\n    Key(int v, int l, double s) :vertex(v), last(l), speed(s) {}\n    bool operator<(const Key& k) const {\n        if(vertex != k.vertex) return vertex < k.vertex;\n        if(last != k.last) return last < k.last;\n        return speed < k.speed;\n    }\n};\n\nint n, m;\nint s, g;\nvector<vector<double>> cost;\nvector<vector<double>> limit;\n\ndouble Dijkstra() {\n    map<Key, double> memo;\n    double result = NIL;\n\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    for(int j = 0; j < n; ++j) {\n        if(cost[s][j] == NIL) continue;\n        if(limit[s][j] < 1.0) continue;\n        q.push(Node(j, s, 1.0, cost[s][j]));\n    }\n\n    while(!q.empty()) {\n        Node current = q.top();\n        q.pop();\n        if(result != NIL && result <= current.cost) continue;\n        Key key(current.vertex, current.last, current.speed);\n        if(memo.count(key)) continue;\n        if(key.vertex == g && key.speed == 1.0) result = (result == NIL ? current.cost : min(result, current.cost));\n        memo[key] = current.cost;\n        for(int j = 0; j < n; ++j) {\n            if(cost[current.vertex][j] == NIL) continue;\n            if(current.last == j) continue;\n            for(double ds: {-1.0, 0.0, 1.0}) {\n                if(current.speed + ds <= 0.0) continue;\n                if(current.speed + ds > limit[current.vertex][j]) continue;\n                double next_speed = current.speed + ds;\n                double next_cost = current.cost + cost[current.vertex][j] / next_speed;\n                q.push(Node(j, current.vertex, next_speed, next_cost));\n            }\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    while(cin >> n >> m, n | m) {\n        cost.clear();\n        cost.resize(n);\n        for(auto& c: cost) c.resize(n, NIL);\n        limit.clear();\n        limit.resize(n);\n        for(auto& l: limit) l.resize(n, NIL);\n\n        cin >> s >> g;\n        --s; --g;\n\n        for(int i = 0; i < m; ++i) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--; --y;\n            cost[x][y] = cost[y][x] = d;\n            limit[x][y] = limit[y][x] = c;\n        }\n\n        double answer = Dijkstra();\n        if(answer == NIL) cout << \"unreachable\" << endl;\n        else cout << setprecision(5) << fixed << answer << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1162\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1162&lang=jp\n\n#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\nconst double inf = (double)(1<<24);\n\nclass Node {\npublic:\n    double time;\n    int v, town, prev;\n    Node() {}\n    Node( double time_, int v_, int town_, int prev_ ) \n    {\n        time = time_;\n        v = v_;\n        town = town_;\n        prev = prev_;\n    }\n    bool operator > ( const Node& right ) const\n    {\n        return time > right.time;\n    }\n};\ntypedef priority_queue <Node, vector <Node>, greater<Node> > QUEUE;\nconst int size = 31;\n\nint n, m;\nbool P[size][size];\ndouble G[size][size];\ndouble MC[size][size];\nint L[size][size];\nint CN[size][size];\nint CN_count[size];\n\n// dijkstra\nvoid solve( int start, int goal )\n{\n    // init\n    QUEUE Q;\n    Node start_node( 0.0, 0, start, -1 );\n    Q.push( start_node );\n    MC[0][start] = 0.0;\n\n    // proc\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        // proc init\n        double time = node.time;\n        int v = node.v;\n        int town = node.town;\n        int prev = node.prev;\n\n        // goal\n        if ( town == goal && v == 1 ) {\n            printf( \"%.5f\\n\", time );\n            return;\n        }\n\n        // move\n        for ( int i = 0; i < CN_count[town]; i++ ) {\n            int next_town = CN[town][i];\n            if ( next_town == prev ) continue;\n            for ( int j = 1; j >= -1; j-- ) {\n                int next_v = v + j;\n                if ( prev == -1 && next_v != 1 ) continue;\n                if ( next_v <= 0 || next_v > L[town][next_town] ) continue;\n                double cost = (double)G[town][next_town] / next_v;\n                double next_time = time + cost;\n                int next_prev = town;\n\n                if ( next_time > MC[next_v][next_town] || fabs( next_time - MC[next_v][next_town] ) < eps ) continue;\n                MC[next_v][next_town] = next_time;\n                Node next_node( next_time, next_v, next_town, next_prev );\n                Q.push( next_node );\n            }\n        }\n    }\n\n    cout << \"unreachable\" << endl;\n}\n\nint main( void )\n{\n    while ( cin >> n >> m ) {\n        // quit\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        for ( int i = 0; i < size; i++ ) {\n            CN_count[i] = 0;\n            for ( int j = 0; j < size; j++ ) {\n                P[i][j] = false;\n                MC[i][j] = inf;\n                G[i][j] = inf;\n                L[i][j] = 0;\n            }\n        }\n\n        // input\n        int s, g;\n        cin >> s >> g;\n        for ( int i = 0; i < m; i++ ) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n\n            P[x][y] = P[y][x] = true;\n            G[x][y] = G[y][x] = d;\n            L[x][y] = L[y][x] = c;\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( i == j ) continue;\n                if ( P[i][j] ) CN[i][CN_count[i]++] = j;\n            }\n        }\n\n        solve( s-1, g-1 );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vd = std::vector<double>;\n\tusing v2d = std::vector<vd>;\n\tusing v3d = std::vector<v2d>;\n\t\n\tstruct Edge {\n\t\tint to, limit;\n\t\tdouble distance;\n\t};\n\tusing Edges = std::vector<std::vector<Edge>>;\n\n\tusing i3 = std::array<int, 3>;\n\tusing pdi3 = std::pair<double, i3>;\n\n\tEdges inputEdge(int n, int m)\n\t{\n\t\tEdges edge(n);\n\t\tfor (int i{}; i < m; i++)\n\t\t{\n\t\t\tint x, y, c;\n\t\t\tdouble d;\n\t\t\tscanf(\"%d%d%lf%d\", &x, &y, &d, &c);\n\t\t\tx--; y--;\n\t\t\tedge[x].push_back({y, c, d});\n\t\t\tedge[y].push_back({x, c, d});\n\t\t}\n\t\treturn std::move(edge);\n\t}\n\n\tdouble& getReference(v3d& distance, const i3& index)\n\t{\n\t\treturn distance[index[0]][index[1]][index[2]];\n\t}\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n == 0 && m == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tint s, g;\n\t\tscanf(\"%d%d\", &s, &g);\n\t\ts--; g--;\n\t\t// edge[from][i] = {to, distance, limit}\n\t\tconst Edges edge(inputEdge(n, m));\n\n\t\t// distance[頂点][来た速度][来た頂点] = 最短距離\n\t\tv3d distance(n, v2d(31, vd(n, 1e9)));\n\t\tstd::fill(distance[s][0].begin(), distance[s][0].end(), 0);\n\t\t// {距離、{頂点、来た速度、来た頂点}\n\t\tstd::priority_queue<pdi3, std::vector<pdi3>, std::greater<pdi3>> dij;\n\t\tdij.push({0, {s, 0, s}});\n\t\twhile (!dij.empty())\n\t\t{\n\t\t\tconst double now_dist{dij.top().first};\n\t\t\tconst i3 now_vertex{dij.top().second};\n\t\t\tdij.pop();\n\t\t\tif (now_dist > getReference(distance, now_vertex))\n\t\t\t\tcontinue;\n\n\t\t\tfor (const auto& road: edge[now_vertex[0]])\n\t\t\t{\n\t\t\t\tif (road.to == now_vertex[2]) continue;\n\t\t\t\tfor (int add{-1}; add <= 1; add++)\n\t\t\t\t{\n\t\t\t\t\t// {to, velocity, from}\n\t\t\t\t\tconst i3 next_vertex{road.to, now_vertex[1] + add, now_vertex[0]};\n\t\t\t\t\tif (next_vertex[1] <= 0 || road.limit < next_vertex[1]) continue;\n\t\t\n\t\t\t\t\tconst double next_dist{now_dist + road.distance / next_vertex[1]};\n\t\t\t\t\tauto& table_dist{getReference(distance, next_vertex)};\n\t\t\t\t\tif (next_dist >= table_dist) continue;\n\n\t\t\t\t\ttable_dist = next_dist;\n\t\t\t\t\tdij.push({next_dist, next_vertex});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst double min{*std::min_element(distance[g][1].begin(), distance[g][1].end())};\n\t\tif (min == 1e9) puts(\"unreachable\");\n\t\telse printf(\"%.4lf\\n\", min);\n\t}\n\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<iomanip>\n#include<deque>\n#define F first\n#define S second\n#define MAX_N 32\n#define MAX_D 32\n#define INF (1<<28)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef pair<int,P> iP;\ntypedef pair<int,int> iiP;\ntypedef pair<iiP,P> PP;\ntypedef vector<vector<iP> > VViP;\nint n,m,s,g;\nVViP G;\ndouble mincost[MAX_N][MAX_N][MAX_D]; // mincost[from][to][speed]\nint sp[] = {-1,0,+1};\n\nvoid dijkstra()\n{\n\n  queue<PP> deq; // iiPP(iiP(now,pre),P(cost,speed))\n\n  \n  deq.push(PP(iiP(s,s),P(0,1)));\n\n  mincost[s][s][1] = 0; \n  double ans = INF;  \n\n  \n  while(!deq.empty())\n    {\n      PP p = deq.front(); deq.pop();\n      int now,pre;\n      double cost,speed;\n      now = p.F.F, pre = p.F.S;\n      cost = p.S.F, speed = p.S.S;\n\n      \n      if(now == g && speed == 1)\n\t{\n\t  ans = min(ans,cost);\t\n\t  continue;\n\t}\t\n\n      for(int i=0;i<G[now].size();i++)\n\t{\n\t  iP ip = G[now][i]; // VViP -> iP(to,P(distance,limit))\n\t  int to = ip.F;\n\t  double dis,lim;\n\t  dis = ip.S.F, lim = ip.S.S;\n\t  if(pre == to)\n\t    continue;\n\n\t  for(int j=0;j<3;j++)\n\t    {\n\t      double new_speed = speed + sp[j];\n\t      if(new_speed <= 0 || new_speed > lim)\n\t\tcontinue;\n\n\t      if(now == s && pre == s && new_speed != 1)\n\t\tcontinue;\n\n\n\t      if(mincost[now][to][(int)new_speed] > cost + (double)dis/new_speed)\n\t\t{\n\t\t  mincost[now][to][(int)new_speed] = cost + (double)dis/new_speed;\n\t\t  deq.push(PP(iiP(to,now),P(mincost[now][to][(int)new_speed],new_speed)));\n\t\t}\n\t    }\n\n\t}\n\n    }\n  \n\n  if(ans == INF)\n    cout << \"unreachable\" << endl;\n  else \n    cout << setiosflags(ios::fixed) << setprecision(5) << ans << endl;\n  \n}\n\nint main()\n{\n\n  while(true)\n    {\n      cin >> n >> m;\n      if(n+m == 0)\n\tbreak;\n      G.clear();\n      G.resize(n+1);\n      rep(i,n+1)\n\trep(j,n+1)\n\t  rep(k,31)\n\t    mincost[i][j][k] = INF;\n\n      cin >> s >> g;\n      rep(i,m)\n\t{\n\t  int x,y;\n\t  double d,c;\n\t  cin >> x >> y >> d >> c;\n\t  G[x].push_back(iP(y,P(d,c)));\n\t  G[y].push_back(iP(x,P(d,c)));\n\t}\n      \n      dijkstra();\n  \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\nconst int MAX_V = 101;\nconst int MAX_SPEED = 31;\nconst double INF = 1e9;\n\nint n,m;\nint ds[]={-1,0,1};\n\nstruct edge{\n\tint to;\n\tdouble dist, speed;\n\tedge(int t_to,double t_dist,double t_speed){\n\t\tto=t_to;dist=t_dist;speed=t_speed;\n\t}\n};\n\nstruct state{\n\tdouble cost,speed;\n\tint v;\n\tstate(double t_cost,int t_v,double t_speed){\n\t\tcost=t_cost;v=t_v;speed=t_speed;\n\t}\n\tbool operator>(const state& s)const{\n\t\treturn cost > s.cost;\n\t}\n};\n\n\nvector< vector<edge> > G(MAX_V);\ndouble d[MAX_V][MAX_SPEED];\n\nvoid dijkstra(int s){\n\tpriority_queue<state,vector<state>,greater<state> > que;\n\tfill_n((double *)d, sizeof(d)/sizeof(double),INF);\n\td[s][0] = 0.0;\n\tque.push(state(0.0,s,0.0));\n\n\n\twhile(!que.empty()){\n\t\tstate p = que.top(); que.pop();\n\t\tint v = p.v;\n\t\tif(d[v][(int)p.speed]<p.cost) continue;\n\t\trep(i,G[v].size()){\n\t\t\tedge e = G[v][i];\n\t\t\trep(j,3){\n\t\t\t\tdouble p_s=(p.speed+ds[j]);\n\t\t\t\tif(p_s > 0 && e.speed >= p_s && d[e.to][(int)p_s] > d[v][(int)p.speed] + (e.dist/p_s)){\n\t\t\t\t\n\t\t\t\t\td[e.to][(int)p_s] = d[v][(int)p.speed] + (e.dist/p_s);\n\t\t\t\t\tque.push(state(d[e.to][(int)p_s],e.to,p_s));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\twhile(1){\n\n\t\tG.clear();\n\t\tG.resize(MAX_V);\n\n\t\tint s,g;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\tcin >> s >> g;\n\t\ts--;g--;\n\t\trep(i,m){\n\t\t\tint a,b;\n\t\t\tdouble d,c;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--;b--;\n\t\t\tedge tmp1(b,d,c);\n\t\t\tedge tmp2(a,d,c);\n\t\t\tG[a].push_back(tmp1);\n\t\t\tG[b].push_back(tmp2);\n\t\t}\n\n\t\tdijkstra(s);\n\n\t\tif(d[g][1]==INF) cout << \"unreachable\" << endl;\n\t\telse cout << d[g][1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\nint n,m;\npair<int,int> pass[32][32];\n\ndouble d[32][32][32];\nbool used[32][32][32];\n\ndouble dijk(int s,int g){\n    bool f=false;\n    rep(i,32)rep(j,32)rep(k,32)d[i][j][k]=INF;\n    rep(i,32)rep(j,32)rep(k,32)used[i][j][k]=false;\n    d[s][1][31]=0;\n    \n    while(1){\n        int v=-1,w=-1,x=-1;\n        rep(u,n){\n            rep(i,32){\n                rep(j,32){\n                    if(!used[u][i][j]&&(v==-1||d[u][i][j]<d[v][w][x]))v=u,w=i,x=j;\n                }\n            }\n        }\n        if(v==-1)break;\n        \n        used[v][w][x]=true;\n        rep(u,n){\n            if(pass[v][u].first==INF)continue;\n            d[u][w][v]   = min(d[u][w][v]   , d[v][w][x]+((double)pass[v][u].first / w     ));\n\n            if( w+1<=pass[v][u].second && f )\n                d[u][w+1][v] = min(d[u][w+1][v] , d[v][w][x]+((double)pass[v][u].first / (w+1) ));\n\n            if( w-1>=0 && f )\n                d[u][w-1][v] = min(d[u][w-1][v] , d[v][w][x]+((double)pass[v][u].first / (w-1) ));\n        }\n        f=true;\n    }\n    double ret = INF;\n    rep(i,32){\n        ret = min(ret, d[g][1][i]);\n    }\n    return ret;\n}\n\n\nint main(){\n    int s,g;\n    \n    while(cin>>n>>m){\n        if(n==0&&m==0)break;\n        \n        rep(i,32)rep(j,32)pass[i][j]=make_pair(INF,-1);\n        cin>>s>>g;\n        s--,g--;\n        rep(i,m){\n            int x,y,d,c;\n            cin>>x>>y>>d>>c;\n            x--,y--;\n            pass[x][y] = pass[y][x] = make_pair(d,c);\n        }\n        double res = dijk(s,g);\n        if(res==INF)cout<<\"unreachable\"<<endl;\n        else printf(\"%.10lf\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\nint n,m,s,g;\ndouble d[40][40][40];\n\nint main(){\n  int inx,iny,ind,inc;\n  while(true){\n    cin >> n >> m;\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n\n    cin >> s >> g;\n    for(int i=0;i<31;i++)for(int j=0;j<31;j++)for(int k=0;k<31;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n      cin >> inx >> iny >> ind >> inc;\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n    \n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else cout << \"unreachable\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        vector<vector<tuple<int,long double,long double>>> graph(n);\n        int s,g;\n        cin >> s >> g;\n        --s;\n        --g;\n        rep(i,0,m){\n            int x,y;\n            long double d,c;\n            cin >> x >> y >> d >> c;\n            --x;\n            --y;\n            graph[x].emplace_back(make_tuple(y,d,c));\n            graph[y].emplace_back(make_tuple(x,d,c));\n        }\n\n        vector<vector<long double>> dist(n,vector<long double>(31,inf));\n        priority_queue<tuple<long double,int,int>,vector<tuple<long double,int,int>>,greater<tuple<long double,int,int>>> que;\n        dist[s][0]=0;\n        que.push(make_tuple(0,s,0));\n        while(!que.empty()){\n            const tuple<long double,int,int> tup=que.top();\n            que.pop();\n            const long double d=get<0>(tup);\n            const int v=get<1>(tup),spd=get<2>(tup);\n            if(d>dist[v][spd]) continue;\n            for(const auto& e:graph[v]){\n                const auto w=get<0>(e);\n                rep(i,-1,2){\n                    const int next_spd=spd+i;\n                    if(next_spd<=0 or next_spd>get<2>(e)) continue;\n                    const long double tmp_d=d+get<1>(e)/next_spd;\n                    if(tmp_d>=dist[w][next_spd]) continue;\n                    dist[w][next_spd]=tmp_d;\n                    que.push(make_tuple(tmp_d,w,next_spd));\n                }\n            }\n        }\n\n        if(dist[g][1]==inf) cout << \"unreachable\" << endl;\n        else cout << dist[g][1] << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//1162\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nconst int MAX_N=30,MAX_C=30;\nconst double INF=1e8;\nconst double ESP=1e-8;\n\n#define EQ(a,b) fabs(a-b)<ESP\n\nint n,m;\nint s,g;\nstruct edge{\n\tint to,dist,c;\n};\nvector<edge> G[MAX_N];\n\nstruct S{\n\tint town,v,pre;\n\tdouble cost;\n\tbool operator<(const S &a) const{\n\t\treturn cost>a.cost;\n\t}\n};\n\ndouble cost[MAX_N][MAX_C+1];\n\nvoid dijkstra(){\n\tREP(i,n){\n\t\tREP(j,MAX_C+1){\n\t\t\tcost[i][j]=INF;\n\t\t}\n\t}\n\tpriority_queue<S> pq;\n\tpq.push(S{s,0,-1,0.0});\n\tcost[s][0]=0;\n\twhile (!pq.empty()){\n\t\tS s=pq.top();\n\t\tpq.pop();\n\t\tif (cost[s.town][s.v]<s.cost){\n\t\t\tcontinue;\n\t\t}\n\t\tFOR(acc,-1,1+1){\n\t\t\tif (s.v+acc<=0) continue;\n\t\t\tFOR(i,0,G[s.town].size()){\n\t\t\t\tedge e=G[s.town][i];\n\t\t\t\tif (s.v+acc>e.c){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (e.to==s.pre) continue;\n\t\t\t\tif (s.cost+(double)e.dist/(s.v+acc)<cost[e.to][s.v+acc]){\n\t\t\t\t\tcost[e.to][s.v+acc]=s.cost+(double)e.dist/(s.v+acc);\n\t\t\t\t\tpq.push(S{e.to,s.v+acc,s.town,cost[e.to][s.v+acc]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif (n){\n\t\t\tscanf(\"%d %d\",&s,&g);\n\t\t\ts--;\n\t\t\tg--;\n\t\t\tREP(i,n){\n\t\t\t\tG[i].clear();\n\t\t\t}\n\t\t\tREP(i,m){\n\t\t\t\tint x,y,d,c;\n\t\t\t\tscanf(\"%d %d %d %d\",&x,&y,&d,&c);\n\t\t\t\tx--;\n\t\t\t\ty--;\n\t\t\t\tG[x].push_back(edge{y,d,c});\n\t\t\t\tG[y].push_back(edge{x,d,c});\n\t\t\t}\n\t\t\tdijkstra();\n\t\t\tif (EQ(cost[g][1],INF)){\n\t\t\t\tprintf(\"unreachable\\n\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"%.6f\\n\",cost[g][1]);\n\t\t\t}\n\t\t}\n\t}while (n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <iomanip>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n\nusing namespace std;\n\ntypedef long long int lli;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\n\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nstruct Edge {\n    int to, mxspeed, cost;\n    Edge(int t, int m, int c)\n        : to(t), mxspeed(m), cost(c) {}\n    Edge() {}\n};\n\nstruct Data {\n    int to, spd, lst;\n    double cost;\n    Data(int t, int s, int lt, double c)\n        : to(t), spd(s), lst(lt), cost(c) {}\n    Data() {}\n    bool operator<(const Data &d1) const {\n        return cost > d1.cost;\n    }\n};\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n + m) {\n        vector<vector<Edge>> G(n);\n        int s, g;\n        cin >> s >> g;\n        s--;\n        g--;\n        REP(i, 0, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            G[x].push_back(Edge(y, c, d));\n            G[y].push_back(Edge(x, c, d));\n        }\n        priority_queue<Data, vector<Data>> pq;\n        const double inf = 1e+15;\n        vector<vector<double>> Cost(n, vector<double>(110, inf));\n        vector<vector<bool>> used(n, vector<bool>(110, false));\n        pq.emplace(s, 0, -1, 0.0);\n        while (pq.size()) {\n            auto d = pq.top();\n            pq.pop();\n            if (used[d.to][d.spd]) continue;\n            used[d.to][d.spd] = true;\n            for (auto &e : G[d.to]) {\n                if (e.to == d.lst) continue;\n                REP(i, -1, 2) {\n                    int ns = d.spd + i;\n                    if (ns <= 0 || ns > e.mxspeed) continue;\n                    double nc = d.cost + (double)e.cost / ns;\n                    if (Cost[e.to][ns] > nc) {\n                        Cost[e.to][ns] = nc;\n                        pq.emplace(e.to, ns, d.to, nc);\n                    }\n                }\n            }\n        }\n        if (used[g][1]) {\n            cout << fixed << setprecision(10) << Cost[g][1] << endl;\n        } else {\n            cout << \"unreachable\" << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\nint n,m,s,g;\ndouble d[40][40][40];\n\nint main(){\n  int inx,iny,ind,inc;\n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n\n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=0;i<31;i++)for(int j=0;j<31;j++)for(int k=0;k<31;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n    \n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nconst int MAX = 35;\nconst int INF = (1<<25);\nint n,m;\n\nstruct Edge{\n  int to;\n  double dis,lim;\n  Edge(int a, double b, double c):to(a),dis(b),lim(c){}\n};\n\nstruct State{\n  int pos,from;\n  double speed,t;\n  State(int a, double b, double c, int f):pos(a),speed(b),t(c),from(f){}\n  bool operator < (const State& s) const{ return t > s.t;}\n};\n\nvector<Edge> E[MAX];\ndouble T[MAX][MAX][MAX];\n//T[i][j][k] := shortest time from i to j with speed k.\n\n\nvoid init(){\n  for(int i = 0; i < MAX; i++){\n    for(int j = 0; j < MAX; j++)\n      for(int k = 0; k < MAX; k++) T[i][j][k] = INF;\n    E[i].clear();\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++){\n    int x,y;\n    double d,c;\n    cin >> x >> y >> d >> c;\n    //   cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    E[x].push_back(Edge(y,d,c));\n    E[y].push_back(Edge(x,d,c));\n  }\n}\n\nvoid solve(int s, int g){\n\n  priority_queue<State> Q;\n  T[0][s][0] = 0;\n  Q.push(State(s,0,0,-1));\n\n  while(!Q.empty()){\n    State sta = Q.top();\n    Q.pop();\n\n    if(sta.t > T[sta.from][sta.pos][(int)sta.speed]) continue;\n\n    for(int i = 0; i < E[sta.pos].size(); i++){\n      int np = E[sta.pos][i].to;\n\n      if(np == sta.from) continue;\n\n      double sp[] = {-1,0,1};\n      \n      for(int j = 0; j < 3; j++){\n\tdouble ns = sta.speed+sp[j];\n\tif(ns <= 0 || ns > E[sta.pos][i].lim) continue;\n\tdouble nt = sta.t+E[sta.pos][i].dis/ns;\n\tif(T[sta.pos][np][(int)ns] > nt){\n\t  T[sta.pos][np][(int)ns] = nt;\n\t  Q.push(State(np,ns,nt,sta.pos));\n\t}\n      }\n    }\n  }\n\n  cerr << \"come \" << endl;\n\n  double ans = INF;\n\n  for(int i = 0; i < MAX; i++)\n    ans = min(ans,T[i][g][1]);\n  \n\n  if(ans == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.5f\\n\",ans);\n}\n\nint main(){\n\n  while(cin >> n >> m && n+m){\n    init();\n    int s,g;\n    cin >> s >> g;\n    input();\n    solve(s,g);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 35\n#define INF 1e9\n#define F first\n#define S second\ntypedef pair<double,int> pdi;\ntypedef pair<int,int> pii;\ntypedef pair<pdi,pii> State;\n \nstruct Edge{\n  int to,d,c;\n  Edge(int to,int d,int c) : to(to),d(d),c(c) {}\n};\n \nint N,M,s,g;\nvector<Edge> G[MAX];\n \ndouble dijkstra(){\n  priority_queue<State,vector<State>,greater<State> > Q;\n  Q.push(State(pdi(0,s),pii(1,N)));\n  double Time[MAX][MAX][MAX];\n  fill(Time[0][0],Time[0][0]+MAX*MAX*MAX,INF);   \n  Time[s][1][N] = 0;\n \n  while(!Q.empty()){\n    State p = Q.top(); Q.pop();\n    int v = p.F.S, vel = p.S.F;\n    if(Time[v][vel][p.S.S] < p.F.F) continue;\n\n    if(v == g && vel == 1){\n      return Time[g][1][p.S.S];\n    }\n \n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      for(int j = -1 ; j <= 1 ; j++){\n        if(vel+j <= 0) continue;\n        if(Time[v][vel][p.S.S] == 0 && j){\n          continue;\n        }\n        Edge e = G[v][i];\n        if(e.to == p.S.S) continue;\n        double t = (double)e.d/(vel+j);\n        if(vel+j <= e.c && \n           Time[v][vel][p.S.S] + t < Time[e.to][vel+j][v]){\n          Time[e.to][vel+j][v] = Time[v][vel][p.S.S] + t;\n          Q.push(State(pdi(Time[e.to][vel+j][v],e.to),pii(vel+j,v)));\n        }\n      }\n    }\n  }\n  return INF;\n}\n \nint main(){\n  int x,y,d,c;\n  while(cin >> N >> M, N){\n    for(int i = 0 ; i < MAX ; i++){\n      G[i].clear();\n    }\n    cin >> s >> g; s--; g--;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> d >> c;\n      x--; y--;\n      G[x].push_back(Edge(y,d,c));\n      G[y].push_back(Edge(x,d,c));\n    }\n    double res = dijkstra();\n    if(res == INF){\n      cout << \"unreachable\" << endl;\n    }else{\n      printf(\"%.8f\\n\",res);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\nstruct E{int t,c,d;E(int t,int c,int d):t(t),c(c),d(d){}};\nvector<E>e[30];\nstruct S{double t;int cur,last,s;S(double t,int cur,int last,int s):t(t),cur(cur),last(last),s(s){}};\nstruct Cmp{bool operator()(const S&a,const S&b){return a.t>b.t;}};\ndouble F(int s,int g)\n{\n\tdouble time[31][30][30];\n\tint i,j,k;\n\tfill_n(&time[0][0][0],sizeof(time)/sizeof(double),1e99);\n\tpriority_queue<S,vector<S>,Cmp>q;\n\tq.push(S(0,s,s,1));\n\twhile(!q.empty())\n\t{\n\t\tS s=q.top();q.pop();\n\t\tif(time[s.s][s.cur][s.last]<=s.t)continue;\n\t\ttime[s.s][s.cur][s.last]=s.t;\n\t\tif(s.cur==g&&s.s==1)return s.t;\n\t\tfor(i=0;i<e[s.cur].size();++i)\n\t\t{\n\t\t\tE&r=e[s.cur][i];\n\t\t\tif(s.last==r.t)continue;\n\t\t\tif(s.cur==s.last)\n\t\t\t\tq.push(S(s.t+r.d/double(s.s),r.t,s.cur,s.s));\n\t\t\telse\n\t\t\t\tfor(j=(s.s-1?-1:0);j<2;++j)\n\t\t\t\t\tif(s.s+j<=r.c&&time[s.s+j][r.t][s.cur]>s.t+r.d/double(s.s+j))\n\t\t\t\t\t\tq.push(S(s.t+r.d/double(s.s+j),r.t,s.cur,s.s+j));\n\t\t}\n\t}\n\treturn -1;\n}\nint main()\n{\n\tint n,m,s,g,x,y,d,c,i;\n\twhile(scanf(\"%d%d\",&n,&m),n)\n\t{\n\t\tfor(i=0;i<n;++i)e[i].clear();\n\t\tscanf(\"%d%d\",&s,&g);\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c);\n\t\t\t--x,--y;\n\t\t\te[x].push_back(E(y,c,d));\n\t\t\te[y].push_back(E(x,c,d));\n\t\t}\n\t\tdouble r=F(s-1,g-1);\n\t\tif(r<0)puts(\"unreachable\");\n\t\telse printf(\"%f\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\n\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<VVD> VVVD;\n\n/*\n\nDijstra\n頂点を拡張して属性を持たせる\nノード番号・直前の道・速度 := 時間\n終点の速度 1の状態から min_element\n\n\n元・行先・距離・制限速度\n\n*/\n\nstruct Edge\n{\n\tint to, dist, c;\n\tEdge( int t, int d, int c ) : to( t ), dist( d ), c( c ) {}\n};\n\nstruct State\n{\n\tint node, prev, speed;\n\tState( int n, int p, int s ) : node( n ), prev( p ), speed( s ) {}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\treturn node < a.node;\n\t}\n};\n\nconst double INF = 1e10;\n\nint main()\n{\n\tcout.precision( 4 );\n\tcout << fixed;\n\n\twhile ( true )\n\t{\n\t\tint n, m;\n\t\tcin >> n >> m;\n\n\t\tif ( !( n | m ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\ts--;\n\t\tg--;\n\n\t\tvector< vector<Edge> > G( n );\n\t\tfor ( int i = 0; i < m; i++ )\n\t\t{\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tG[x].push_back( Edge( y, d, c ) );\n\t\t\tG[y].push_back( Edge( x, d, c ) );\n\t\t}\n\n\t\t// 現在地・直前のノード・速度\n\t\tVVVD dist( n, VVD( n, VD( 101, INF ) ) );\n\t\tdist[s][s][0] = 0;\n\n\t\tpriority_queue< pair<double,State>, vector< pair<double,State> >, greater< pair<double,State> > > que;\n\t\tque.push( make_pair( 0, State( s, s, 0 ) ) );\n\t\t\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tdouble d = que.top().first;\n\t\t\tState cur = que.top().second;\n\t\t\tque.pop();\n\n\t\t\tif ( dist[ cur.node ][ cur.prev ][ cur.speed ] < d )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor ( int i = 0; i < G[ cur.node ].size(); i++ )\n\t\t\t{\n\t\t\t\tEdge &e = G[ cur.node ][i];\n\n\t\t\t\tif ( e.to == cur.prev )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor ( int ds = -1; ds <= 1; ds++ )\n\t\t\t\t{\n\t\t\t\t\tint nspeed = cur.speed + ds;\n\n\t\t\t\t\tif ( nspeed <= 0 || e.c < nspeed )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( dist[ cur.node ][ cur.prev ][ cur.speed ] + e.dist / (double)nspeed < dist[ e.to ][ cur.node ][ nspeed ] )\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[ e.to ][ cur.node ][ nspeed ] = dist[ cur.node ][ cur.prev ][ cur.speed ] + e.dist / (double)nspeed;\n\t\t\t\t\t\tque.push( make_pair( dist[ e.to ][ cur.node ][ nspeed ], State( e.to, cur.node, nspeed ) ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 解候補：終点ノード・どこからでも・速度１\n\t\tdouble res = INF;\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tres = min( res, dist[g][i][1] );\n\t\t}\n\n\t\tif ( res == INF )\n\t\t{\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nconst int MAX = 35;\nconst int INF = (1<<25);\nint n,m;\n\nstruct Edge{\n  int to;\n  double dis,lim;\n  Edge(int a, double b, double c){\n    to = a;\n    dis = b;\n    lim = c;\n  }\n};\n\nstruct State{\n  int pos,from;\n  double speed,t;\n  State(int a, double b, double c, int f){\n    pos = a;\n    speed = b;\n    t = c;\n    from = f;\n  }\n  bool operator < (const State& s) const{ return t > s.t;}\n};\n\nvector<Edge> E[MAX];\ndouble T[MAX][MAX];\n//T[i][j] := shortest time to i with speed j.\n\n\nvoid init(){\n  for(int i = 0; i < MAX; i++){\n    fill(T[i],T[i]+MAX,(double)INF);\n    E[i].clear();\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++){\n    int x,y;\n    double d,c;\n    cin >> x >> y >> d >> c;\n    //   cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    E[x].push_back(Edge(y,d,c));\n    E[y].push_back(Edge(x,d,c));\n  }\n}\n\nvoid solve(int s, int g){\n\n  priority_queue<State> Q;\n  T[s][0] = 0;\n  Q.push(State(s,0,0,-1));\n\n  while(!Q.empty()){\n    State sta = Q.top();\n    Q.pop();\n\n    if(sta.t > T[sta.pos][(int)sta.speed]) continue;\n\n    for(int i = 0; i < E[sta.pos].size(); i++){\n      int np = E[sta.pos][i].to;\n\n      if(np == sta.from) continue;\n\n      double sp[] = {-1,0,1};\n      \n      for(int j = 0; j < 3; j++){\n\tdouble ns = sta.speed+sp[j];\n\tif(ns <= 0 || ns > E[sta.pos][i].lim) continue;\n\tdouble nt = sta.t+E[sta.pos][i].dis/ns;\n\tif(T[np][(int)ns] > nt){\n\t  T[np][(int)ns] = nt;\n\t  Q.push(State(np,ns,nt,sta.pos));\n\t}\n      }\n    }\n  }\n  \n\n  if(T[g][1] == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.5f\\n\",T[g][1]);\n}\n\nint main(){\n  \n  while(cin >> n >> m && n+m){\n    init();\n    int s,g;\n    cin >> s >> g;\n    input();\n    solve(s,g);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define LOCAL\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define rrep(i, n) for(int i=(n-1); i>=0; --i)\n#define rep2(i, s, n) for(int i=s; i<(n); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define memr(dp, val) memset(dp, val, sizeof(dp))\nusing namespace std;\ntypedef long long ll;\nstatic const int INTINF = (INT_MAX >> 1); // 10^9 + 10^7\nstatic const ll LLINF = (LLONG_MAX >> 1);\nstatic const int MAX = 1e5+1;\nstatic const ll MOD = 1e9+7;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename T>\nusing min_priority_queue = priority_queue<T, vector<T>, greater<T> >;\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(bool b) { return b ? \"true\" : \"false\"; }\ntemplate <size_t N> string to_string(bitset<N> bs) {\n  string res;\n  for (size_t i = 0; i < N; ++i) res += '0' + bs[i];\n  return res;\n}\nstring to_string(vector<bool> v) {\n  string res = \"{\";\n  for (bool e : v) res += to_string(e) + \", \";\n  return res += \"}\";\n}\ntemplate <class T, class U> string to_string(pair<T, U> p);\ntemplate <class C> string to_string(C c) {\n  string res = \"{\";\n  for (auto e : c) res += to_string(e) + \", \";\n  return res += \"}\";\n}\ntemplate <class T, class U> string to_string(pair<T, U> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\nvoid debug() { cerr << '\\n'; }\ntemplate <class Head, class... Tail> void debug(Head head, Tail... tail) {\n  cerr << '\\t' << to_string(head), debug(tail...);\n}\n#ifdef LOCAL\n#define print(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug(__VA_ARGS__)\n#else\n#define print(...)\n#endif\n\nstruct edge{\n\tint to, cost, lim;\n};\n\nstruct pack{\n\tdouble a;\n\tint b, c, d;\n\tbool operator>(const pack& pa) const{\n\t\treturn pa.a < a;\n\t}\n};\n\nvector<edge> glp[100];\ndouble dp[50][50][50];\n\nint main(int argc, const char * argv[]) {\n\tstd::cout << std::fixed << std::setprecision(15);\n\n\twhile(1){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\t\trep(i, 100) glp[i].clear();\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\t\trep(i, m){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tglp[x].push_back({y, d, c});\n\t\t\tglp[y].push_back({x, d, c});\n\t\t}\n\n\t\trep(i, 50) rep(j, 50) rep(k, 50) dp[i][j][k] = INTINF;\n\t\tbool vis[50][50][50];\n\t\tmemr(vis, 0);\n\t\tdp[s][0][s] = 0;\n\t\tvis[s][0][s] = true;\n\t\t// 距離, 遷移先, 現在の速度, befV\n\t\tmin_priority_queue<pack> que;\n\t\tque.push({0, s, 0, s});\n\t\twhile(!que.empty()){\n\t\t\tauto f = que.top(); que.pop();\n\n\t\t\tdouble dist = f.a;\n\t\t\tint v = f.b;\n\t\t\tint ovec = f.c;\n\t\t\tint bef = f.d;\n\n\t\t\t// print(v);\n\t\t\trep(i, 3){\n\t\t\t\tint vec = ovec - 1 + i;\n\t\t\t\t// if(v == s && ovec == 1) vec = 1;\n\t\t\t\tif(vec <= 0) continue;\n\t\t\t\t// print(vec);\n\t\t\t\tfor(edge u : glp[v]){\n\t\t\t\t\tif(vis[u.to][vec][v]) continue;\n\t\t\t\t\tif(u.lim < vec) continue;\n\t\t\t\t\tif(u.to == bef) continue;\n\t\t\t\t\t// print(u.to);\n\t\t\t\t\tif(chmin(dp[u.to][vec][v], dp[v][ovec][bef] + (double)u.cost / (double)vec)){\n\t\t\t\t\t\tvis[u.to][vec][v] = true;\n\t\t\t\t\t\tque.push({dp[v][ovec][bef] + (double)u.cost / (double)vec, u.to, vec, v});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = INTINF;\n\t\trep(j, 50) chmin(ans, dp[g][1][j]);\n\n\t\tif(ans == INTINF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << ans << endl;\n\t\t}\n\t\t// break;\n\t}\n\n\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\n\ndouble H[33][33][33];\nconst double INF = 1e100;\n\nstruct state{\n  int n,p,v;\n  double c;\n  state(int n,int p,int v,double c) : n(n),p(p),v(v),c(c) {}\n  bool operator<(const state &st) const{\n    return c > st.c;\n  }\n};\n\nstruct edge {\n  int to,d,c;\n  edge(int to,int d,int c) : to(to),d(d),c(c) {}\n};\n\nvector<edge> G[33];\n\nvoid dijk(int s,int g){\n  fill(H[0][0],H[32][32],INF);\n\n  priority_queue<state> q;\n  q.push( state( s, s, 0, 0.0 ) );\n  H[s][s][0] = 0.0;\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    if( p.c > H[p.n][p.p][p.v] ) continue;\n    if( p.n == g && p.v == 1 ) {\n      printf(\"%.9lf\\n\", p.c); return;\n    }\n    for(int i=0;i<(int)G[p.n].size();i++){\n      edge e = G[p.n][i];\n      if( e.to == p.p ) continue;\n      for(int nv=p.v-1;nv<=p.v+1;nv++){\n        if( 0 < nv && nv <= e.c ) {\n          double nc = p.c + (double)e.d/(double)nv;\n          if( H[e.to][p.n][nv] > nc ){\n            H[e.to][p.n][nv] = nc;\n            q.push( state( e.to, p.n, nv , nc ) );\n          }\n        }\n      }\n    }\n  }\n  cout << \"unreachable\" << endl;\n}\n\nint main(){\n  int s,g;\n  while(cin >> N >> M && (N|M) ){\n    cin >> s >> g;\n    --s; --g;\n    for(int i=0;i<M;i++){\n      int x,y,d,c;\n      cin >> x >> y >> d >> c;\n      --x;--y;\n      G[x].push_back( edge(y,d,c) );\n      G[y].push_back( edge(x,d,c) );\n    }\n    dijk( s, g );\n    for(int i=0;i<N;i++)\n      G[i].clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\n\nclass State{\npublic:\n  int pos, v, pre;\n  double time;\n  State(){}\n  State(int pos, int v, int pre, double time) : pos(pos), v(v), pre(pre), time(time) {}\n};\n\nclass Edge{\npublic:\n  int to, dist, lim;\n  Edge(){}\n  Edge(int to, int dist, int lim) : to(to), dist(dist), lim(lim) {}\n};\n\nint n, m, s, g;\nvector<Edge> G[30];\n\nvoid solve(){\n  State u, v;\n  bool reach = false;\n  u = State(s, 0, 0, 0.0);\n  queue<State> que;\n  double vis[30][900];\n  fill(vis[0], vis[30], 100000000.0);\n  vis[u.pos][u.v] = u.time;\n  que.push(u);\n  while(!que.empty()){\n    u = que.front(); que.pop();\n    //cout << u.pos << ' ' << u.v << ' ' << u.pre << ' ' << u.time << endl;\n    if(u.pos == g && u.v == 1){\n      reach = true;\n      continue;\n    }\n    for(int i=0;i<G[u.pos].size();i++){\n      if(u.pre == G[u.pos][i].to) continue;\n      for(int k=-1;k<=1;k++){\n        if(u.v + k > G[u.pos][i].lim) continue;\n        if(u.v + k <= 0) continue;\n        v = State(G[u.pos][i].to, u.v + k, u.pos, u.time + G[u.pos][i].dist / (double)(u.v + k));\n        //cout << '\\t' << v.pos << ' ' << v.v << ' ' << v.pre << ' ' << v.time << ' ' << vis[v.pos][v.v] << endl;\n        if(vis[v.pos][v.v] > v.time){\n          vis[v.pos][v.v] = v.time;\n          que.push(v);\n        }\n      }\n    }\n  }\n  if(reach) printf(\"%.5f\\n\", vis[g][1]);\n  else printf(\"unreachable\\n\");\n}\n\nmain(){\n  while(scanf(\"%d%d\", &n, &m) && (n|m)){\n    scanf(\"%d%d\", &s, &g);\n    s--; g--;\n    for(int i=0;i<n;i++) G[i].clear();\n    for(int i=0;i<m;i++){\n      int a, b, c, d;\n      scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n      a--; b--;\n      G[a].push_back(Edge(b, c, d));\n      G[b].push_back(Edge(a, c, d));\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cfloat>\n\nusing namespace std;\n\nint n, m;\n\nstruct edge {\n\tint dist, lim;\n};\n\nstruct P {\n\tint from, pos, v;\n\tdouble time;\n\n\tbool operator >(const P& p) const {\n\t\treturn time > p.time;\n\t}\n};\n\nedge elist[31][31];\ndouble G[31][31][31];\n\nint main() {\n\tint s, g;\n\twhile (cin >> n >> m, n|m) {\n\t\tfor(int i=0; i<31; i++){\n\t\t\tfor(int j=0; j<31; j++){\n\t\t\t\telist[i][j] = {-1, -1};\n\t\t\t}\n\t\t}\n\t\tfill_n((double *)G, 31*31*31, DBL_MAX);\n\t\tcin >> s >> g;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\telist[x][y] = {d, c};\n\t\t\telist[y][x] = {d, c};\n\t\t}\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\tq.push({-1, s, 0, 0.0});\n\t\tbool goal = false;\n\t\twhile(!q.empty()){\n\t\t\tP p = q.top(); q.pop();\n\t\t\t// goal\n\t\t\tif (p.pos == g && p.v == 1) {\n\t\t\t\tprintf(\"%f\\n\", p.time);\n\t\t\t\tgoal = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=1; i<=n; i++) {\n\t\t\t\tif(elist[p.pos][i].dist != -1 && p.from != i) {\n\t\t\t\t\t// v+1\n\t\t\t\t\tif(p.v + 1 <= elist[p.pos][i].lim) {\n\t\t\t\t\t\tdouble time = p.time + (double)elist[p.pos][i].dist / (double)(p.v+1);\n\t\t\t\t\t\tif(time < G[p.pos][i][p.v+1]){\n\t\t\t\t\t\t\tq.push({p.pos, i, p.v+1, time});\n\t\t\t\t\t\t\tG[p.pos][i][p.v+1] = time;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// v\n\t\t\t\t\tif(p.v <= elist[p.pos][i].lim) {\n\t\t\t\t\t\tdouble time = p.time + (double)elist[p.pos][i].dist / (double)p.v;\n\t\t\t\t\t\tif(time < G[p.pos][i][p.v]){\n\t\t\t\t\t\t\tq.push({p.pos, i, p.v, time});\n\t\t\t\t\t\t\tG[p.pos][i][p.v] = time;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// v-1\n\t\t\t\t\tif(p.v -1 <= elist[p.pos][i].lim && p.v-1 > 0) {\n\t\t\t\t\t\tdouble time = p.time + (double)elist[p.pos][i].dist / (double)(p.v-1);\n\t\t\t\t\t\tif(time < G[p.pos][i][p.v-1]){\n\t\t\t\t\t\t\tq.push({p.pos, i, p.v-1, time});\n\t\t\t\t\t\t\tG[p.pos][i][p.v-1] = time;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!goal) cout << \"unreachable\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REP1(i,n) for(int i=1;i<(n);i++)\n#define REP2(i,d,n) for(int i=(d);i<(n);i++)\n#define RREP(i,n) for(int i=(n);i>=0;i--)\n#define CLR(a) memset((a),0,sizeof(a))\n#define MCLR(a) memset((a),-1,sizeof(a))\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI > VVI;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef pair<int,int> PII;\n \nconst int INF = 0x3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-9;\n \nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n \n \nstruct edge {\n\tint to, from, cost;\n\tedge(int _to, int _from, int _cost) {to = _to; from = _from; cost=_cost;}\n};\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\n \nint maxspeed[31][31];\n \nclass Dijkstra{\npublic:\n\tint V;\n\tvector<vector<edge> > G;\n\tvector<vector<double> > d;\n\t\n\tDijkstra(int _V){\n\t\tV = _V;\n\t\tG.resize(V);\n\t\td.resize(31);\n\n\t\tREP(i,31){\n\t\t\td[i].resize(V);\n\t\t}\n\t}\n\t\n\tvoid add_edge(int from, int to, int cost){\n\t\tG[from].PB(edge(to,from,cost));\n\t}\n\t\n\tvoid solve(int s){\n\t\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\t\tREP(i,31){\n\t\t\tREP(j, V){\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\td[0][s] = 0;\n\t\tque.push(PP(P(0,0),P(s,0)));\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tPP p = que.top();\n\t\t\tque.pop();\n\t\t\tint v = p.second.first;\n\t\t\tint mv = p.second.second;\n\t\t\tint old = p.first.second;\n\t\t\tREP2(i,-1,2){\n\t\t\t\tif(mv+i <= 0 || 30 < mv+i) continue;\n\t\t\t\tif(d[mv][v] < p.first.first) continue;\n\t\t\t\tREP(j,G[v].size()){\n\t\t\t\t\tedge e = G[v][j];\n\t\t\t\t\tif(e.to == old) continue;\n\t\t\t\t\tif(maxspeed[e.from][e.to] < mv+i) continue;\n\t\t\t\t\tif(d[mv+i][e.to] > d[mv][v] + (double)e.cost/(mv+i)){\n\t\t\t\t\t\td[mv+i][e.to] = d[mv][v] + (double)e.cost/(mv+i);\n\t\t\t\t\t\tque.push(PP(P(d[mv+i][e.to],v), P(e.to,mv+i)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\t\n\t\tcin >> n >> m;\n\t\tDijkstra dijkstra(n);\n\t\tif(n==0&&m==0){\n\t\t\tbreak;\n\t\t}\n\t\tREP(i,31){\n\t\t\tREP(j,31){\n\t\t\t\tmaxspeed[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint s,g;\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\t\tREP(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tdijkstra.add_edge(x,y,d);\n\t\t\tdijkstra.add_edge(y,x,d);\n\t\t\tmaxspeed[x][y] = c;\n\t\t\tmaxspeed[y][x] = c;\n\t\t}\n\n\t\t//cout << \"run\" << endl;\n\t\tdijkstra.solve(s);\n\n\t\tif(dijkstra.d[1][g] == INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t\tprintf(\"%.5f\\n\",dijkstra.d[1][g]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i;\n  int b[30][30],c[30][30][31],m,n,u,v,w,x,y;\n  unsigned a[30][30];\n  double z;\n  priority_queue<pair<pair<double,int>,pair<int,int> >,vector<pair<pair<double,int>,pair<int,int> > >,greater<pair<pair<double,int>,pair<int,int> > > > d;\n  while(cin>>n>>m&&n+m){\n    cin>>u>>v;\n    u--;\n    v--;\n    memset(a,-1,sizeof(a));\n    for(i=0;i<m;i++){\n      int p,q,r,s;\n      cin>>p>>q>>r>>s;\n      p--;\n      q--;\n      a[p][q]=a[q][p]=r;\n      b[p][q]=b[q][p]=s;\n    }\n    memset(c,-1,sizeof(c));\n    while(d.empty()==0)\n      d.pop();\n    d.push(make_pair(make_pair(0,-1),make_pair(u,0)));\n    while(d.empty()==0){\n      z=d.top().first.first;\n      w=d.top().first.second;\n      x=d.top().second.first;\n      y=d.top().second.second;\n      if(x==v&&y==1)\n\tbreak;\n      d.pop();\n      if(w==-1||c[w][x][y]==-1){\n\tif(w!=-1)\n\t  c[w][x][y]=1;\n\tfor(i=0;i<n;i++){\n\t  if(i!=w&&(int)a[x][i]!=-1){\n\t    if(0){\n\t    }else if(y==0){\n\t      d.push(make_pair(make_pair(z+a[x][i],x),make_pair(i,1)));\n\t    }else if(y<b[x][i]){\n\t      if(y>1)\n\t\td.push(make_pair(make_pair(z+(double)a[x][i]/(y-1),x),make_pair(i,y-1)));\n\t      d.push(make_pair(make_pair(z+(double)a[x][i]/y,x),make_pair(i,y)));\n\t      d.push(make_pair(make_pair(z+(double)a[x][i]/(y+1),x),make_pair(i,y+1)));\n\t    }else if(y==b[x][i]){\n\t      if(y>1)\n\t\td.push(make_pair(make_pair(z+(double)a[x][i]/(y-1),x),make_pair(i,y-1)));\n\t      d.push(make_pair(make_pair(z+(double)a[x][i]/y,x),make_pair(i,y)));\n\t    }else if(y==b[x][i]+1){\n\t      d.push(make_pair(make_pair(z+(double)a[x][i]/(y-1),x),make_pair(i,y-1)));\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(d.empty())\n      cout<<\"unreachable\"<<endl;\n    else\n      cout<<z<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Problem     : AOJ1162\n * Title       : Discrete Speed (離散的速度)\n * Author      : mizo0203\n * Copyright   : Your copyright free\n * Description : ダイクストラ\n */\n#include <stdio.h>\n#include <utility> // pairライブラリを使用するのに必要\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define MAX_V (31*31*31)\n#define INF 3000000\nusing namespace std;\n\nstruct edge {\n  int to;\n  double cost;\n};\ntypedef pair<int, int> P;\n\nint V;\nvector<edge> G[MAX_V];\ndouble d[MAX_V];\n\nint n, s, g;\n\nbool input() {\n  int i, j, k;\n  int m, x, y, d, c;\n  edge e;\n\n  scanf(\"%d %d\", &n, &m);\n  if (!n && !m)\n    return false;\n\n  V = (n + 1) * (n + 1) * 31;\n  scanf(\"%d %d\", &s, &g);\n  for (i = 0; i < V; i++) {\n    G[i].clear();\n  }\n  for (i = 0; i < m; i++) {\n    scanf(\"%d %d %d %d\", &x, &y, &d, &c);\n    for (j = 0; j <= n; j++) {\n      for (k = 1; k <= c; k++) {\n        e.cost = (double) d / k;\n        if (j != y) {\n          e.to = k * (n + 1) * (n + 1) + x * (n + 1) + y;\n          G[(k - 1) * (n + 1) * (n + 1) + j * (n + 1) + x].push_back(e);\n          G[k * (n + 1) * (n + 1) + j * (n + 1) + x].push_back(e);\n          if (k < 30)\n            G[(k + 1) * (n + 1) * (n + 1) + j * (n + 1) + x].push_back(e);\n        }\n        if (j != x) {\n          e.to = k * (n + 1) * (n + 1) + y * (n + 1) + x;\n          G[(k - 1) * (n + 1) * (n + 1) + j * (n + 1) + y].push_back(e);\n          G[k * (n + 1) * (n + 1) + j * (n + 1) + y].push_back(e);\n          if (k < 30)\n            G[(k + 1) * (n + 1) * (n + 1) + j * (n + 1) + y].push_back(e);\n        }\n      }\n      /*\n       e.cost = (double) d / k;\n       if (j != y) {\n       e.to = k * (n + 1) * (n + 1) + x * (n + 1) + y;\n       G[(k - 1) * (n + 1) * (n + 1) + j * (n + 1) + x].push_back(e);\n       e.to = k * (n + 1) * (n + 1) + x * (n + 1) + y;\n       G[k * (n + 1) * (n + 1) + j * (n + 1) + x].push_back(e);\n       }\n       if (j != x) {\n       e.to = k * (n + 1) * (n + 1) + y * (n + 1) + x;\n       G[(k - 1) * (n + 1) * (n + 1) + j * (n + 1) + y].push_back(e);\n       e.to = k * (n + 1) * (n + 1) + y * (n + 1) + x;\n       G[k * (n + 1) * (n + 1) + j * (n + 1) + y].push_back(e);\n       }\n       */\n    }\n  }\n\n  return true;\n}\n\nvoid dijkstra() {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d, d + V, INF);\n  d[s] = 0.0;\n  que.push(P(0, s));\n\n  while (!que.empty()) {\n    P p = que.top();\n    que.pop();\n    int v = p.second;\n    if (d[v] < p.first)\n      continue;\n    for (int i = 0; i < (int) G[v].size(); i++) {\n      edge e = G[v][i];\n      if (d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        que.push(P(d[e.to], e.to));\n        /*\n         printf(\"%d %d %d => %d %d: %f\\n\", v / (n + 1) / (n + 1),\n         v / (n + 1) % (n + 1), v % (n + 1) % (n + 1),\n         e.to / (n + 1) / (n + 1), e.to % (n + 1) % (n + 1), d[e.to]);\n         */\n      }\n    }\n  }\n}\n\nint main() {\n  int i;\n  double min_cost;\n\n  while (input()) {\n    /*\n     for (i = 0; i < V; i++) {\n     for (int j = 0; j < (int) G[i].size(); j++) {\n     printf(\"%d %d %d => %d %d: %f\\n\", i / (n + 1) / (n + 1),\n     i / (n + 1) % (n + 1), i % (n + 1) % (n + 1),\n     G[i][j].to / (n + 1) / (n + 1),\n     G[i][j].to % (n + 1) % (n + 1), G[i][j].cost);\n     }\n     }\n     */\n    dijkstra();\n    min_cost = d[1 * (n + 1) * (n + 1) + g];\n    for (i = 1; i <= n; i++) {\n      if (min_cost > d[1 * (n + 1) * (n + 1) + i * (n + 1) + g])\n        min_cost = d[1 * (n + 1) * (n + 1) + i * (n + 1) + g];\n    }\n    if (min_cost != INF)\n      printf(\"%f\\n\", min_cost);\n    else\n      printf(\"unreachable\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nstringstream __ss__;\n#define debug __ss__\n#endif\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) debug << *i << \" \"; debug << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;i--)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);i--)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint x[900],y[900],d[900],c[900];\ndouble mn[40][40][40];\n\nclass hoge{\npublic:\n\tdouble time;\n\tint from,to,speed;\n\tbool operator<(const hoge &h)const{return time>h.time;}\n};\n\nint main() {\n\tint n,m,s,g;\n\tIL{\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)break;\n\t\tcin>>s>>g;\n\t\trep(i,m){\n\t\t\tcin>>x[i]>>y[i]>>d[i]>>c[i];\n\t\t}\n\t\trep(i,40)rep(j,40)rep(k,40)mn[i][j][k]=1000000000;\n\t\tpriority_queue<hoge> que;\n\t\thoge h;\n\t\th.time=0;\n\t\th.from=0;\n\t\th.to=s;\n\t\th.speed=1;\n\t\tque.push(h);\n\t\twhile(!que.empty()){\n\t\t\thoge now=que.top();\n\t\t\thoge next;\n\t\t\tque.pop();\n\t\t\tif(mn[now.from][now.to][now.speed]<=now.time)continue;\n\t\t\tmn[now.from][now.to][now.speed]=now.time;\n\t\t\trep(i,m){\n\t\t\t\tif(now.speed>c[i])continue;\n\t\t\t\tif(x[i]==now.to){\n\t\t\t\t\tif(y[i]==now.from)continue;\n\t\t\t\t\tnext.to=y[i];\n\t\t\t\t}else if(y[i]==now.to){\n\t\t\t\t\tif(x[i]==now.from)continue;\n\t\t\t\t\tnext.to=x[i];\n\t\t\t\t}else{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnext.from=now.to;\n\t\t\t\tnext.time=now.time+(double)d[i]/(now.speed);\n\t\t\t\tnext.speed=now.speed;\n\t\t\t\tque.push(next);\n\t\t\t\tnext.speed=now.speed+1;\n\t\t\t\tque.push(next);\n\t\t\t\tif(now.speed==1){\n\t\t\t\t\tif(next.to==g){\n\t\t\t\t\t\tprintf(\"%.12lf\\n\",next.time);\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnext.speed=now.speed-1;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t\tcout<<\"unreachable\"<<endl;\n\t\tcontinue;\n\t\tend:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dy[] = {1, 0, -1, 1, -1, 1, 0, -1};\n\nstruct edge{\n\tint to;\n\tdouble dist;\n\tint c;\n\tedge(int t, double d, int c_){to = t, dist = d, c = c_;}\n};\n\nstruct state{\n\tint pos;\n\tdouble total;\n\tint speed;\n\tstate(int p, double t, int s){pos = p, total = t, speed = s;}\n\tbool operator<(const state &r)const{\n\t\treturn total > r.total;\n\t}\n};\n\nconst double INF = 1e30;\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\ts--, g--;\n\t\tvector<vector<edge> > G(n);\n\t\trep(i, m){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--, y--;\n\t\t\tG[x].push_back(edge(y, d, c));\n\t\t\tG[y].push_back(edge(x, d, c));\n\t\t}\n\n\t\tpriority_queue<state> q;\n\t\tq.push(state(s, 0, 0));\n\n\t\tvector<vi> visit(31, vi(n, 0)); //speed, pos\n\n\t\tdouble ans = INF;\n\t\twhile(!q.empty()){\n\t\t\tstate st = q.top();\n\t\t\tq.pop();\n\n\t\t\tif(visit[st.speed][st.pos]) continue;\n\t\t\tvisit[st.speed][st.pos] = 1;\n\n\t\t\tif(st.speed == 1 && st.pos == g){\n\t\t\t\tans = st.total;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, G[st.pos].size()){\n\t\t\t\tif( G[st.pos][i].dist == INF ) continue;\n\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\tstate next = st;\n\t\t\t\t\tnext.speed += j;\n\t\t\t\t\tif(next.speed <= 0 || next.speed > G[st.pos][i].c) continue;\n\t\t\t\t\tnext.pos = G[st.pos][i].to;\n\t\t\t\t\tnext.total += G[st.pos][i].dist/next.speed;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == INF) cout << \"unreachable\" << endl;\n\t\telse printf(\"%.8lf\\n\", ans);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint to;\n\tint speed;\n\tint distance;\n};\n\nclass Status{\npublic:\n\tStatus();\n\tStatus(double _speed,int _cur,int _from){\n\t\tspeed = _speed;\n\t\tcur = _cur;\n\t\tfrom = _from;\n\t}\n\n\tint speed;\n\tint cur;\n\tint from;\n\t// ツソツーツトツつウツづェツつスツづつォツづ可コツスツトツづ個値ツづ可妥篠つオツづ降ツ渉づ可づ按づゥ\n\tbool operator < (const Status &s) const{\n\t\treturn speed > s.speed;\n\t} \n};\n\ntypedef pair<double,Status> P;\n\nint V;\nvector<edge> G[30][30][31];\n\nconst double INF = 1000000000.0;\n\nvoid dijkstra(int s,int g){\n\tdouble d[30][30][31];\n\n\tfor(int i = 0; i < 30; i++)\n\t\tfor(int j = 0; j < 30; j++)\n\t\t\tfill(d[i][j],d[i][j]+31,INF);\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\td[s][s][1] = 0.0;\n\tque.push(P(0.0,Status(1,s,s)));\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tStatus v = p.second;\n\t\tif(!EQ(d[v.from][v.cur][v.speed],p.first) && d[v.from][v.cur][v.speed] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v.from][v.cur][v.speed].size(); i++){\n\t\t\tedge e = G[v.from][v.cur][v.speed][i];\n\t\t\tif(d[v.cur][e.to][e.speed] > d[v.from][v.cur][v.speed] + (double)(e.distance)/e.speed \n\t\t\t\t&& v.from != e.to){\n\t\t\t\t\td[v.cur][e.to][e.speed] = d[v.from][v.cur][v.speed] + (double)(e.distance)/e.speed;\n\t\t\t\t\tif(!(e.to == g && e.speed == 1))\n\t\t\t\t\t\tque.push(P(d[v.cur][e.to][e.speed],Status(e.speed,e.to,v.cur)));\n\t\t\t}\n\t\t}\n\t}\n\n\tbool f = false;\n\tdouble minCost = INF;\n\tfor(int i = 0; i < 30; i++){\n\t\tif(!EQ(d[i][g][1],INF)){\n\t\t\tminCost = min(minCost,d[i][g][1]);\n\t\t\tf = true;\n\t\t}\n\t}\n\n\tif(!f){\n\t\tcout << \"unreachable\" << endl;\n\t}\n\telse{\n\t\tprintf(\"%.5f\\n\",minCost);\n\t}\n\n}\n\nint main(){\n\t\n\t// ツ各ツ凝ヲツ甘板づづ債督ッツ暗ェツ都ツ市ツづーツ督楪達ツスツピツーツドツつイツづづ可ノツーツドツづ可閉ェツつッツづつ「ツづゥ\n\t// G 1-30,31-60,61-90...\n\tint n,m,s,g;\n\twhile(cin >> n >> m >> s >> g && !(n == 0 && m == 0)){\n\t\tV = n*30+1;\n\t\ts--;\n\t\tg--;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint to,from,di,c;\n\t\t\tcin >> from >> to >> di >> c;\n\t\t\tfrom--;\n\t\t\tto--;\n\n\t\t\tfor(int j = 0; j < 30; j++){\n\t\t\t\tfor(int k = 0; k < 30; k++){\n\t\t\t\t\tfor(int l = 1; l <= 30; l++){\n\t\t\t\t\t\tif(from == s){\n\t\t\t\t\t\t\t// ツスツタツーツトツ地ツ点ツづーツ登ツ録\n\t\t\t\t\t\t\tif(from == k && k == j && j != to && l == 1){\n\t\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\t\te.to = to;\n\t\t\t\t\t\t\t\te.distance = di;\n\t\t\t\t\t\t\t\te.speed = 1;\n\t\t\t\t\t\t\t\tG[j][k][l].push_back(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// fromツつゥツづァツつ「ツつッツづゥツ湘ェツ渉環づーツ登ツ録\n\t\t\t\t\t\tif(k != j && j != to && k == from){\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.to = to;\n\t\t\t\t\t\t\te.distance = di;\n\t\t\t\t\t\t\tfor(int m = -1; m <= 1; m++){\n\t\t\t\t\t\t\t\tif(m + l > 0 && m + l <= c){\n\t\t\t\t\t\t\t\t\te.speed = l+m;\n\t\t\t\t\t\t\t\t\tG[j][k][l].push_back(e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// to -> from\n\t\t\tfor(int j = 0; j < 30; j++){\n\t\t\t\tfor(int k = 0; k < 30; k++){\n\t\t\t\t\tfor(int l = 1; l <= 30; l++){\n\t\t\t\t\t\tif(to == s){\n\t\t\t\t\t\t\t// ツスツタツーツトツ地ツ点ツづーツ登ツ録\n\t\t\t\t\t\t\tif(to == k && k == j && j != from && l == 1){\n\t\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\t\te.to = from;\n\t\t\t\t\t\t\t\te.distance = di;\n\t\t\t\t\t\t\t\te.speed = 1;\n\t\t\t\t\t\t\t\tG[j][k][l].push_back(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// toツつゥツづァツつ「ツつッツづゥツ湘ェツ渉環づーツ登ツ録\n\t\t\t\t\t\tif(k != j && j != from && k == to){\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.to = from;\n\t\t\t\t\t\t\te.distance = di;\n\t\t\t\t\t\t\tfor(int m = -1; m <= 1; m++){\n\t\t\t\t\t\t\t\tif(m + l > 0 && m + l <= c){\n\t\t\t\t\t\t\t\t\te.speed = l+m;\n\t\t\t\t\t\t\t\t\tG[j][k][l].push_back(e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdijkstra(s,g);\n\t\t\n\t\tfor(int i = 0; i < 30; i++){\n\t\t\tfor(int j = 0; j < 30; j++){\n\t\t\t\tfor(int l = 0; l < 31; l++){\n\t\t\t\t\tG[i][j][l].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<int,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a3,a2,a4;\ndouble d[31][31];\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)if(d[i][j]!=1e12)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      scanf(\"%d%d%d%d\",&a1,&a2,&a3,&a4);\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P>q;\n    d[st][0]=0;\n    P xtt;xtt.fi=0,xtt.se=st*1000+0;\n    q.push(xtt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.se/1000,xx=p.se%1000;\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=xx)r(j,3){\n          int x=p.fi+dx[j];\n          if(0<x&&x<=e.lim){\n            double t=e.dist/x+d[cur][p.fi];\n            if(d[e.to][x]>t){\n              d[e.to][x]=t;\n              P xt;xt.fi=x,xt.se=cur+e.to*1000;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst double INF = 1 << 30;\n\nclass Edge\n{\npublic:\n  int d, c;\n  Edge():d((int)INF), c((int)INF) {}\n};\n\nclass State\n{\npublic:\n  int nc, pc, nv;\n  double nt;\n\n  State(int a, int b, int c, double d)\n    :nc(a), pc(b), nv(c), nt(d) {}\n  bool operator<(const State& rhs) const\n  {\n    return this->nt > rhs.nt;\n  }\n};\n\nint main()\n{\n  int n, m;\n  while (scanf(\"%d %d\", &n, &m) != EOF) {\n    if (n == 0 && m == 0)\n      break;\n\n    int s, g;\n    scanf(\"%d %d\", &s, &g);\n    --s;\n    --g;\n\n    vector<vector<Edge> > cost(n, vector<Edge>(n));\n    for (int i = 0; i < m; ++i) {\n      int x, y;\n      scanf(\"%d %d\", &x, &y);\n      --x;\n      --y;\n      scanf(\"%d %d\", &cost[x][y].d, &cost[x][y].c);\n      cost[y][x].d = cost[x][y].d;\n      cost[y][x].c = cost[x][y].c;\n    }\n\n    vector<vector<vector<double> > > time(n, vector<vector<double> > (n, vector<double>(30+1, INF)));\n    time[s][s][0] = 0.0;\n    priority_queue<State> que;\n    que.push(State(s, s, 0, 0));\n\n    double ans = INF;\n    while (!que.empty()) {\n      State st = que.top();\n      que.pop();\n\n      if (st.nc == g && st.nv == 1) {\n\tans = st.nt;\n\tbreak;\n      }\n\n      for (int i = 0; i < (int)cost[st.nc].size(); ++i) {\n\tif (st.nc == i || cost[st.nc][i].d == (int)INF)\n\t  continue;\n\tfor (int j = -1; j < 2; ++j) {\n\t  int v = st.nv + j;\n\t  if (v > 0 && cost[st.nc][i].c >= v) {\n\t    double t = st.nt + cost[st.nc][i].d / (double)v;\n\t    if (time[i][st.nc][v] > t) {\n\t      time[i][st.nc][v] = t;\n\t      que.push(State(i, st.nc, v, t));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    if (ans == INF)\n      printf(\"unreachable\\n\");\n    else\n      printf(\"%.5f\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct road\n{\n  int node, len, limit;\n  road() {}\n  road(int x, int d, int c) : node(x), len(d), limit(c) {}\n};\n\nstruct state\n{\n  int p, n, v;\n  double c;\n  state(int prev, int node, int velocity, double cost) : p(prev), n(node), v(velocity), c(cost) {}\n  bool operator<(const state& that) const { return c > that.c; }\n};\n\nint main()\n{\n  int N, M;\n  while (scanf(\"%d %d\", &N, &M) != EOF && N != 0) {\n    int S, G;\n    scanf(\"%d %d\", &S, &G);\n    --S;  --G;\n    vector<vector<road> > g(N);\n    for (int i = 0; i < M; i++) {\n      int x, y, d, c;\n      scanf(\"%d %d %d %d\", &x, &y, &d, &c);\n      --x;  --y;\n      g[x].push_back(road(y, d, c));\n      g[y].push_back(road(x, d, c));\n    }\n    vector<vector<vector<double> > > dist(N, vector<vector<double> >(N, vector<double>(31, 1e7)));\n    dist[S][S][0] = 0.0;\n    priority_queue<state> q;\n    q.push(state(S, S, 0, 0.0));\n    double ans = 1e7;\n    while (!q.empty()) {\n      const int prev = q.top().p;\n      const int n = q.top().n;\n      const int v = q.top().v;\n      const double cost = q.top().c;\n      q.pop();\n      if (n == G && v == 1) {\n        ans = min(ans, cost);\n        continue;\n      }\n      for (vector<road>::const_iterator it(g[n].begin()); it != g[n].end(); ++it) {\n        if (it->node == prev) {\n          continue;\n        }\n        if (v-1 >= 1 && v-1 <= it->limit) {\n          const double c = cost + double(it->len) / (v-1);\n          if (c < dist[prev][it->node][v-1]) {\n            dist[prev][it->node][v-1] = c;\n            q.push(state(n, it->node, v-1, c));\n          }\n        }\n        if (v <= it->limit) {\n          const double c = cost + double(it->len) / v;\n          if (c < dist[prev][it->node][v]) {\n            dist[prev][it->node][v] = c;\n            q.push(state(n, it->node, v, c));\n          }\n        }\n        if (v+1 <= it->limit) {\n          const double c = cost + double(it->len) / (v+1);\n          if (c < dist[prev][it->node][v+1]) {\n            dist[prev][it->node][v+1] = c;\n            q.push(state(n, it->node, v+1, c));\n          }\n        }\n      }\n    }\n    if (ans >= 1e7) {\n      puts(\"unreachable\");\n    } else {\n      printf(\"%.5f\\n\", ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\n\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nvoid dijkstra(Graph &g, vector<weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tweight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tedge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint n, m, st, go;\nint ind(int v, int from, int sp) { return n*n*sp + n*from + v; }\n\nint main()\n{\n\twhile (cin >> n >> m >> st >> go, n)\n\t{\n\t\tst--; go--;\n\t\tGraph g(n*n * 32);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b, c; double d;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--; b--;\n\t\t\tFOR(j, 1, c + 1)\n\t\t\t{\n\t\t\t\tfor (int k = -1; k <= 1;k++)\n\t\t\t\t{\n\t\t\t\t\tint sp = j + k;\n\t\t\t\t\tif (j<1 || j>c) continue;\n\t\t\t\t\tREP(l, n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (l == b) continue;\n\t\t\t\t\t\tg[ind(a, l, j)].push_back(edge{ ind(b, a, sp), d / j });\n\t\t\t\t\t}\n\t\t\t\t\tREP(l, n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (l == a) continue;\n\t\t\t\t\t\tg[ind(b, l, j)].push_back(edge{ ind(a, b, sp), d / j });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<weight> d;\n\t\tdijkstra(g, d, ind(st, st, 1));\n\t\tdouble ans = INF;\n\t\tREP(i, n) chmin(ans, d[ind(go, i, 0)]);\n\t\tif (ans >= INF) puts(\"unreachable\");\n\t\telse cout << D10 << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m;\nll s, g;\n\nclass DK {\npublic:\n\tstruct edge {\n\t\tint to;\n\t\tdouble cost;\n\t\tll cap;\n\t\tedge(int _to, double _cost, ll _cap) :to(_to), cost(_cost), cap(_cap) {}\n\t};\n\n\tdouble d[110][110];\n\tvector<edge> G[110];//各頂点からの辺\n\n\tvoid dijkstra() {\n\t\trep(i, 110)rep(j, 110)d[i][j] = INF;\n\t\td[s][0] = 0;\n\n\t\ttypedef pair<pair<double, ll>, ll> PP;\n\t\tpriority_queue<PP, vector<PP>, greater<PP>> que;\n\t\tque.push({ {0, 0},s });\n\n\t\twhile (!que.empty()) {\n\t\t\tPP p = que.top();\n\t\t\tque.pop();\n\t\t\tll nn = p.second;\n\t\t\tll v = p.first.second;\n\t\t\tif (d[nn][v] < p.first.first)continue;\n\t\t\tfor (int i = 0; i < G[nn].size(); i++) {\n\t\t\t\tedge e = G[nn][i];\n\t\t\t\tFOR(j, -1, 2) {\n\t\t\t\t\tdouble nv = v + j;\n\t\t\t\t\tif (nv <= 0)continue;\n\t\t\t\t\tif (nv > e.cap)continue;\n\t\t\t\t\tif (d[e.to][(ll)nv] > d[nn][v] + e.cost / nv) {\n\t\t\t\t\t\td[e.to][(ll)nv] = d[nn][v] + e.cost / nv;\n\t\t\t\t\t\tque.push({ {d[e.to][(ll)nv], nv},e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n};\n\nDK dk;\n\nint main() {\n\twhile (cin >> n >> m&&n + m) {\n\t\trep(i, 110)dk.G[i].clear();\n\t\tcin >> s >> g;\n\t\trep(i, m) {\n\t\t\tint x, y;\n\t\t\tll c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tdk.G[x].push_back(DK::edge(y, d, c));\n\t\t\tdk.G[y].push_back(DK::edge(x, d, c));\n\t\t}\n\t\tdk.dijkstra();\n\t\t//rep(i, n) {\n\t\t//\trep(j, 30) {\n\t\t//\t\tcout << dk.d[i + 1][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tdouble ans = dk.d[g][1];\n\t\tif ((ll)ans == INF)cout << \"unreachable\" << endl;\n\t\telse printf(\"%.10lf\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<functional>\n \n \n#define rep(i,n) for(int i=0;i<(n);i++)\n \nusing namespace std;\nconst int INF = 100000000;\ntypedef pair<int,int> P;\n\nint n,m;\n\nstruct edge\n{\n\t//どこから来た,コスト,速度制限\n\tint to,cost,ub;\n\tedge(int to,int cost,int ub) {\n\t\tthis->to = to;\n\t\tthis->cost = cost;\n\t\tthis->ub = ub;\n\t}\n};\n\nvector<edge> G[103];\nint s,g;\ndouble dist[103][103][33];\n\ntypedef pair<P,P> PP;\n\ndouble dijkstra() {\n\trep(i,103) rep(j,103) rep(k,33) dist[i][j][k]=INF;\n\trep(i,103) rep(j,33) dist[s][i][j]=0;\n\n\t//最短距離 頂点 前の頂点 今の速さ\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(P(0,s),P(0,1)));\n\n\twhile (!que.empty())\n\t{\n\t\tPP pp = que.top(); que.pop();\n\t\tint v = pp.first.second;\n\n\t\tint prev = pp.second.first;\n\t\tint u = pp.second.second;\n\n\t\tif(dist[v][u][prev] < pp.first.first) continue;\n\n\t\trep(i,G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tfor(int j=-1;j<=1;j++) {\n\t\t\t\tif(j+u<=0 || u+j > e.ub) continue;\n\n\t\t\t\tif(dist[e.to][v][u+j] > dist[v][prev][u] + (1.0*e.cost/(u+j))) {\n\t\t\t\t\tdist[e.to][v][u+j] = dist[v][prev][u] + (1.0*e.cost/(u+j));\n\t\t\t\t\tque.push(PP(P(dist[e.to][v][u+j],e.to),P(v,u+j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tdouble ans=INF;\n\trep(i,103) ans=min(ans,dist[g][i][1]);\n\n\treturn ans;\n\t\n}\n\nvoid solve() {\n\trep(i,103) G[i].clear();\n\tcin>>s>>g;\n\trep(i,m) {\n\t\tint x,y,d,c;\n\t\tcin>>x>>y>>d>>c;\n\t\tG[x].push_back(edge(y,d,c));\n\t\tG[y].push_back(edge(x,d,c));\n\t}\n\n\tdouble ans;\n\tans = dijkstra();\n\tif(ans==INF) {\n\t\tcout<<\"unreachable\"<<endl;\n\t}\n\telse\n\t{\n\t\tcout<<ans+1.0<<endl;\n\t}\n\n\n}\n\nint main() {\n\twhile (cin>>n>>m)\n\t{\n\t\tif(n+m==0) return 0;\n\t\tsolve();\n\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define DBG(X) cout<<\" \"<<#X<<\" : \"<<X<<endl\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\n\nstruct Input\n{\n\tint n;char c;char str[1024];string s;ll l;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\nstruct Edge{\n\tint to, dist, limit, id;\n\tEdge(){};\n\tEdge(int t, int d, int l, int id) : to(t), dist(d), limit(l), id(id){};\n};\n\nvector<Edge> e[50];\ndouble d[50][50];\n\nint main(){\n\twhile(1){\n\t\trep(i, 50) e[i].clear();\n\t\trep(i, 50) rep(j, 50) d[i][j] = 1e18;\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tif(n == 0 && m == 0) break;\n\t\tint s = in.nextInt(), g = in.nextInt();\n\t\trep(i, m) {\n\t\t\tint x = in.nextInt(), y = in.nextInt(), dist = in.nextInt(), c = in.nextInt();\n\t\t\te[x].pb({y, dist, c, i});\n\t\t\te[y].pb({x, dist, c, i});\n\t\t}\n\t\tauto dijkstra = [&]{\n\t\t\ttypedef pair<pair<double, int>, pii> P;\n\t\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\t\tP p;\n\t\t\td[s][0] = 0.0;\n\t\t\tq.push({{0.0, -1}, {s, 0}});\n\n\t\t\twhile(!q.empty()){\n\t\t\t\tp = q.top(); q.pop();\n\t\t\t\tint from = p.se.fi, v = p.se.se;\n\t\t\t\tint prv = p.fi.se;\n\t\t\t\tdouble t = p.fi.fi;\n\t\t\t\tfor(auto ee : e[from]){\n\t\t\t\t\tint to = ee.to, dist = ee.dist, l = ee.limit;\n\t\t\t\t\tif(prv == ee.id) continue;\n\t\t\t\t\tfor(int i = -1; i <= 1; i++){\n\t\t\t\t\t\tint nv = v + i;\n\t\t\t\t\t\tif(nv <= 0 || nv > l) continue;\n\t\t\t\t\t\tdouble tt = t + ((double)dist / (double)nv);\n\t\t\t\t\t\tif(d[to][nv] <= tt) continue;\n\t\t\t\t\t\td[to][nv] = tt;\n\t\t\t\t\t\tq.push({{tt, ee.id}, {to, nv}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdijkstra();\n\t\t\n\t\tif(d[g][1] == 1e18) printf(\"unreachable\\n\");\n\t\telse printf(\"%.12lf\\n\", d[g][1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair((a),(b))\n#define list3(a,b,c) mp((a),mp((b),(c)))\n#define list4(a,b,c,d) mp((a),list3((b),(c),(d)))\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint vis[40][40][40];\nint n,m;\nvector<pair<int,PI > > G[40];\n\nvoid solve(){\n  int s,g;\n  cin >> s >> g;\n  --s,--g;\n  rep(i,n) G[i].clear();\n  rep(i,m){\n    int x,y,d,m;\n    cin >> x >> y >> d >> m;\n    --x,--y;\n    G[x].pb(mp(y,mp(d,m)));\n    G[y].pb(mp(x,mp(d,m)));\n  }\n  \n  priority_queue<pair<double,pair<int,PI > > > q;\n  q.push(list4(0.,s,1,s));\n  CLR(vis);\n  bool fl=true;\n  while(!q.empty()){\n    double cc=-q.top().F;\n    int cv=q.top().S.F;\n    int cs=q.top().S.S.F;\n    int be=q.top().S.S.S;\n    q.pop();\n\n    if(vis[cv][cs][be]) continue;\n    //cout << cc << ' ' << cv << ' ' << cs << ' ' << be << endl;\n    if(cv==g && cs==1){\n      printf(\"%.8f\\n\",cc);\n      return;\n    }    \n    vis[cv][cs][be] = true;\n    FOR(it,G[cv]){\n      if(it->F==be) continue;\n      for(int di=-1;di<=1;++di){\n\tint ns=cs+di;\n\tif(ns<=0 || ns>it->S.S) continue;\n\tif(fl && ns!=1) continue;\n\tq.push(list4(-cc-it->S.F*1./ns,it->F,ns,cs));\n      }\n    }\n    fl=false;\n  }\n  cout << \"unreachable\" << endl;\n}\n\nint main(){\n  while(cin >> n >> m && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nconst double INFTY=1e10;\n\nstruct Edge{\n\tint src,dst,dist,limit;\n\tEdge(){}\n\tEdge(int s,int d,int di,int li):src(s),dst(d),dist(di),limit(li){}\n};\ntypedef vector<vector<Edge> > Graph;\n\nstruct State{\n\tint src,dst,ver;\n\tdouble time;\n\tState(){}\n\tState(int s,int d,int v,double t):src(s),dst(d),ver(v),time(t){}\n\tbool operator<(const State& s)const{return time<s.time;}\n\tbool operator>(const State& s)const{return time>s.time;}\n};\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n|m;){\n\t\tint start,goal; cin>>start>>goal;\n\t\tstart--; goal--;\n\t\tGraph g(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint s,d,di,li; cin>>s>>d>>di>>li;\n\t\t\ts--; d--;\n\t\t\tg[s].push_back(Edge(s,d,di,li));\n\t\t\tg[d].push_back(Edge(d,s,di,li));\n\t\t}\n\t\t\n\t\tdouble dist[30][30][31];\n\t\tfor(int i=0;i<30;i++)\n\t\t\tfor(int j=0;j<30;j++)\n\t\t\t\tfor(int k=0;k<31;k++)\n\t\t\t\t\tdist[i][j][k]=INFTY;\n\t\tpriority_queue<State,vector<State>,greater<State> > pq;\n\t\tpq.push(State(start,start,0,0));\n\t\twhile(pq.size()){\n\t\t\tState cur=pq.top(); pq.pop();\n\t\t\tif(dist[cur.src][cur.dst][cur.ver]!=INFTY)\n\t\t\t\tcontinue;\n\t\t\tdist[cur.src][cur.dst][cur.ver]=cur.time;\n\t\t\tfor(int i=0;i<g[cur.dst].size();i++){\n\t\t\t\tEdge e=g[cur.dst][i];\n\t\t\t\tif(e.dst==cur.src)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tint nv=cur.ver+j;\n\t\t\t\t\tif(nv<=0 || e.limit<nv)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpq.push(State(e.src,e.dst,nv,cur.time+(double)e.dist/nv));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble res=INFTY;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tres=min(res,dist[i][goal][1]);\n\t\tif(res==INFTY)\n\t\t\tputs(\"unreachable\");\n\t\telse\n\t\t\tprintf(\"%f\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct S{\n  double t;\n  int v;\n  int p;\n  int from;\n  S(){}\n  S(double t, int v, int p,int from) :\n    t(t), v(v), p(p),from(from) {}\n};\nstruct edge{\n  int to, dist, lim;\n  edge(int to, int dist, int lim) :\n    to(to), dist(dist), lim(lim) {}\n};\ntypedef vector<edge> edges;\nbool operator < (const S& s, const S& t){\n  return s.t > t.t;\n}\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m>>s>>g, n){\n    s--; g--;\n    vector<edges> graph(n);\n    REP(i,m){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c; x--; y--;\n      graph[x].push_back(edge(y, d, c));\n      graph[y].push_back(edge(x, d, c));\n    }\n    priority_queue<S> que;\n    FORIT(it, graph[s]){\n      que.push(S(it->dist, 1, it->to, s));\n    }\n    bool used[40][40][40] = {};\n    double ans = -1;\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      //printf(\"quesize:%d time:%lf speed:%d point:%d\\n\",que.size(), s.t,s.v,s.p);\n      if(s.p == g && s.v == 1){\n        ans = s.t;\n        break;\n      }\n      for(int nv = s.v - 1; nv <= s.v + 1; nv++)if(nv > 0){\n        FORIT(it, graph[s.p])if(it->lim >= nv && it->to != s.from){\n          if(used[nv][it->to][s.p]) continue;\n          used[nv][it->to][s.p] = true;\n          que.push(S(s.t + (double)it->dist/nv, nv, it->to, s.p));\n        }\n      }\n    }\n    if(ans != -1) printf(\"%.4lf\\n\",ans);\n    else cout<<\"unreachable\"<<endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\n\n#define INF 1145141919.810\n\nint n, m, s, g;\nint x[50][50][2];\nint a, b, c, d;\n\ndouble dp[50][50];\ndouble res;\n\ndouble solve(int p, int st, int go) {\n\tdouble result = INF;\n\tdp[st][0] = 0;\n\tfor (int i = 1; i <= p; i++) {\n\t\tfor (int j = 1; j <= p; j++) {\n\t\t\tfor (int k = 0; k <= 30; k++) {\n\t\t\t\tif (dp[j][k] < INF) {\n\t\t\t\t\tfor (int l = 0; l <= p; l++) {\n\t\t\t\t\t\tif (x[j][l][0] < 100000) {\n\t\t\t\t\t\t\t//v-1.\n\t\t\t\t\t\t\tif (k - 1 >= 1 && k - 1 <= x[j][l][1]) {\n\t\t\t\t\t\t\t\tdp[l][k - 1] = min(dp[l][k - 1], dp[j][k] + 1.0*x[j][l][0] / (k - 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//v.\n\t\t\t\t\t\t\tif (k >= 1 && k <= x[j][l][1]) {\n\t\t\t\t\t\t\t\tdp[l][k] = min(dp[l][k], dp[j][k] + 1.0*x[j][l][0] / k);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//v-1.\n\t\t\t\t\t\t\tif (k + 1 >= 1 && k + 1 <= x[j][l][1]) {\n\t\t\t\t\t\t\t\tdp[l][k + 1] = min(dp[l][k + 1], dp[j][k] + 1.0*x[j][l][0] / (k + 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <= 30; i++){\n\t\tresult = min(result, dp[go][i]);\n\t}\n\treturn result;\n}\n\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tfor (int j = 0; j < 50; j++) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t\tx[i][j][0] = 10000000;\n\t\t\t\tx[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) { break; }\n\t\tcin >> s >> g;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tx[a][b][0] = c;\n\t\t\tx[a][b][1] = d;\n\t\t\tx[b][a][0] = c;\n\t\t\tx[b][a][1] = d;\n\t\t}\n\t\tres = solve(n, s, g);\n\t\tif (res > 1000000.00) { cout << \"unreachable\" << endl; }\n\t\telse { cout << fixed << setprecision(15) << res << endl; }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> edge;\ntypedef pair<int, P> PP;\ntypedef pair<double, PP> PPP;\n\nvector<edge> G[100];\ndouble memo[40][40][40];\n\nint main(){\n  int n, m;\n  int s, g;\n  while(cin >> n >> m && (n || m)){\n    cin >> s >> g;\n    fill(&memo[0][0][0], &memo[39][39][39]+1, 1e10);\n    for(int i = 0; i < m; i++){\n      int x1,y1,d,c;\n      cin >> x1 >> y1 >> d >> c;\n      G[x1].push_back(edge(y1, P(d, c)));\n      G[y1].push_back(edge(x1, P(d, c)));\n    }\n    memo[s][0][31] = 0;\n    priority_queue<PPP, vector<PPP>,greater<PPP> > que;\n    que.push(PPP(memo[s][0][31], PP(0, P(s, 31))));\n    bool ok = false;\n    while(!que.empty()){\n      PPP ppp = que.top();\n      que.pop();\n      double dis = ppp.first;\n      int v = ppp.second.first;\n      int pos = ppp.second.second.first;\n      int pre = ppp.second.second.second;\n      if(dis > memo[pos][v][pre]) continue;\n     \n      if(pos == g && v == 1){\n\tcout << dis << endl;\n\tok = true;\n\tbreak;\n      }\n      for(int i = -1; i <= 1; i++){\n\tint v2 = v + i;\n\tfor(int j= 0; j < (int)G[pos].size(); j++){\n\t  int to = G[pos][j].first;\n\t  int li = G[pos][j].second.second;\n\t  int d = G[pos][j].second.first;\n\n\t  if(1 <= v2 && v2 <= li && to != pre){\n\t    if(memo[to][v2][pos] > dis + (double)d / v2){\n\t      memo[to][v2][pos] = dis + (double)d / v2;\n\t      que.push(PPP(memo[to][v2][pos], PP(v2, P(to, pos))));\n\t    }\n\t  }\n\t}\n      }\n\n    }\n    if(!ok){\n      cout << \"unreachable\" << endl;\n    }\n    for(int i = 1; i <= 30; i++) G[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "s\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Road{\npublic:\n  int distance;\n  int speed_limit;\n  Road(int _d,int _s) : distance(_d),speed_limit(_s) {}\n  Road() : distance(INF),speed_limit(0) {}\n};\n\nclass State{\npublic:\n  int city;\n  int speed;\n  double time;\n  int prev;\n  State() : city(0),speed(1),time(0.0), prev(0){}\n  State(int _c,int _s,double _t,int _p) : city(_c),speed(_s),time(_t),prev(_p){}\n  \n  bool operator<(const State& s) const{\n    return time < s.time;\n  }\n\n  bool operator>(const State& s) const{\n    return time > s.time;\n  }\n};\n\nint main(){\n  int total_cities;\n  int total_roads;\n  while(~scanf(\"%d %d\",&total_cities,&total_roads)){\n    if(total_cities == 0 && total_roads == 0) break;\n    int start,goal;\n    scanf(\"%d %d\",&start,&goal);\n\n    Road edges[100][100];\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      int from,to,distance,speed_limit;\n      scanf(\"%d %d %d %d\",&from,&to,&distance,&speed_limit);\n      edges[from][to].distance = distance;\n      edges[from][to].speed_limit = speed_limit;\n      edges[to][from].distance = distance;\n      edges[to][from].speed_limit = speed_limit;\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(start,1,0.0,0)); //pos,speed,time\n\n    bool dp[50][50][50];\n\n    memset(dp,false,sizeof(dp));\n    double res = -0.1;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.prev][s.city][s.speed]) continue;\n\n      if(s.city == goal && s.speed == 1){\n\tres = s.time;\n\tbreak;\n      }\n\n      dp[s.prev][s.city][s.speed] = true;\n\n      for(int to = 1; to <= total_cities; to++){\n\tif(edges[s.city][to].distance >= INF) continue;\n\n\tif(edges[s.city][to].speed_limit >= s.speed - 1\n\t   && s.speed-1 >= 1){\n\t  que.push(State(to,\n\t\t\t s.speed -1,\n\t\t\t s.time + (double)edges[s.city][to].distance/(double)(s.speed - 1),\n\t\t\t s.city));\n\t}\n\n\tif(edges[s.city][to].speed_limit >= s.speed + 1\n\t   && s.time != 0.0){\n\t  que.push(State(to,\n\t\t\t s.speed + 1,\n\t\t\t s.time + (double)edges[s.city][to].distance/(double)(s.speed + 1),\n\t\t\t s.city));\n\t}\n\t\n\tif(edges[s.city][to].speed_limit >= s.speed){\n\t  que.push(State(to,\n\t\t\t s.speed,\n\t\t\t s.time + (double)edges[s.city][to].distance/(double)(s.speed),\n\t\t\t s.city));\n\n\t}\n      }\n    }\n\n    if(res < 0){\n      printf(\"unreachable\\n\");\n    }\n    else{\n      printf(\"%f\\n\",res);\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nstruct Node{\n\tint bef,now,speed;\n\tdouble cost;\n\tNode(const int b,const int n,const int s,const double c){\n\t\tbef=b,now=n,speed=s,cost=c;\n\t\treturn;\n\t}\n\tbool operator<(const Node&n)const{\n\t\treturn cost>n.cost;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\twhile(cin>>N>>M,N){\n\t\tint st,gl;\n\t\tcin>>st>>gl;\n\t\tst--,gl--;\n\t\tvector<vector<double>>dis(N,vector<double>(N));\n\t\tvector<vector<double>>speed(N,vector<double>(N));\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>L>>R;\n\t\t\tL--,R--;\n\t\t\tcin>>dis[L][R]>>speed[L][R];\n\t\t\tdis[R][L]=dis[L][R];\n\t\t\tspeed[R][L]=speed[L][R];\n\t\t}\n\t\tvector<vector<vector<double>>>dp(N,vector<vector<double>>(N,vector<double>(31,MOD)));\n\t\tpriority_queue<Node>PQ;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tdp[i][st][0]=0;\n\t\t\tPQ.push(Node(i,st,0,0));\n\t\t}\n\t\twhile(!PQ.empty()){\n\t\t\tauto c=PQ.top();\n\t\t\t//cout<<c.bef<<\" \"<<c.now<<\" \"<<c.speed<<endl;\n\t\t\tPQ.pop();\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(c.bef==i)continue;\n\t\t\t\tif(dis[c.now][i]==0)continue;\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tint ns=c.speed+j;\n\t\t\t\t\tif(ns<=0)continue;\n\t\t\t\t\tif(ns>speed[c.now][i])continue;\n\t\t\t\t\tif(dp[c.now][i][ns]>c.cost+dis[c.now][i]/ns){\n\t\t\t\t\t\tdp[c.now][i][ns]=c.cost+dis[c.now][i]/ns;\n\t\t\t\t\t\tPQ.push(Node(c.now,i,ns,dp[c.now][i][ns]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans=MOD;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans=min(ans,dp[i][gl][1]);\n\t\t}\n\t\tif(ans>1e9){\n\t\t\tcout<<\"unreachable\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<setprecision(20)<<ans<<endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<iomanip>\nusing namespace std;\n\n#define int long long\nconst long long INF = (long long)1e18;\n\nconst int MAX_V = 31;\n\t\nvoid dijkstra(int s, vector<vector<vector<double>>> &d, vector<vector<vector<vector<pair<pair<int,pair<int,int>>, double>>>>> &G){\n\tpriority_queue<pair<double,pair<int,pair<int,int>>>,vector<pair<double,pair<int,pair<int,int>>>>,greater<pair<double,pair<int,pair<int,int>>>>> q;\n\t\n\tint n = G.size();\n\t\n\td.resize(n, vector<vector<double>>(n+1, vector<double>(MAX_V, INF+10)));\n\t\n\td[s][n][0] = 0;\n\t\n\tq.push(make_pair(0,make_pair(s,make_pair(n,0))));\n\t\n\twhile(!q.empty()){\n\t\tpair<double,pair<int,pair<int,int>>> p = q.top();q.pop();\n\t\tpair<int,pair<int,int>> pp = p.second;\n\t\tint v1 = pp.first;\n\t\tint v2 = pp.second.first;\n\t\tint v3 = pp.second.second;\n\t\t\n\t\tif(d[v1][v2][v3] < p.first) continue;\n\t\t\n\t\t// for()\n\t\t\n\t\tfor(pair<pair<int,pair<int,int>>,double> e : G[v1][v2][v3]){\n\t\t\tint e1 = e.first.first;\n\t\t\tint e2 = e.first.second.first;\n\t\t\tint e3 = e.first.second.second;\n\t\t\t\n\t\t\tif(d[e1][e2][e3] > d[v1][v2][v3] + e.second){\n\t\t\t\td[e1][e2][e3] = d[v1][v2][v3] + e.second;\n\t\t\t\tq.push(make_pair(d[e1][e2][e3], e.first));\n\t\t\t}\n\t\t}\n\t}\t\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\t\n\twhile(true){\n\t\tint n, m;\n\t\tint s, g;\n\t\tdouble ans = INF + 10;\n\t\tvector<vector<vector<double>>> d;\n\t\tvector<vector<pair<int,pair<int,int>>>> F;\n\t\tvector<vector<vector<vector<pair<pair<int,pair<int,int>>, double>>>>> G;\n\t\tcin>>n>>m;\n\t\t\n\t\tif(!n && !m) break;\n\t\t\n\t\tcin>>s>>g;\n\t\t\n\t\ts--, g--;\n\t\t\n\t\tF.resize(n);\n\t\tG.resize(n, vector<vector<vector<pair<pair<int,pair<int,int>>,double>>>>(n+1, vector<vector<pair<pair<int,pair<int,int>>,double>>>(MAX_V)));\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint x, y, d, c;\n\t\t\t\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\t\n\t\t\tx--, y--;\n\t\t\t\n\t\t\tF[x].push_back({y, {c, d}});\n\t\t\tF[y].push_back({x, {c, d}});\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int o = 0; o <= n; o++) {\n\t\t\t\tfor(int j = 0; j < F[i].size(); j++){\n\t\t\t\t\tfor(int k = 0; k < MAX_V; k++){\n\t\t\t\t\t\tfor(int l = -1; l <= 1; l++){\n\t\t\t\t\t\t\tif(k+l <= 0 || k+l > F[i][j].second.first) continue;\n\t\t\t\t\t\t\tif(o == F[i][j].first) continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(n == o && k+l != 1) continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tG[i][o][k].push_back({{F[i][j].first,{i,k+l}}, (double)F[i][j].second.second/(k+l)});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdijkstra(s, d, G);\n\t\t\n\t\tfor(int i = 0; i < d[g].size(); i++){\n\t\t\t\tans = min(ans, d[g][i][1]);\n\t\t}\n\t\t\n\t\tif(ans >= INF) cout<<\"unreachable\"<<endl;\n\t\telse cout<<ans<<endl;\n\t\t\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<tuple<int,int,int>> City;//to,limit,distance\nvector<City> C;\ntypedef tuple<double,int,int,int> T;//time,cityid,speed,prev\npriority_queue<T,vector<T>,greater<T>> que;\ndouble memo[30][31];//[cityid][speed]\n\nint main(){\n    cout.precision(5);\n    cout<<fixed;\n    int n,m;\n    while(cin>>n>>m,n){\n        int s,g;\n        cin>>s>>g;\n        s--;g--;\n        C.clear();\n        for(int i=0;i<n;i++) C.push_back(City());\n        for(int i=0;i<m;i++){\n            int x,y,d,c;\n            cin>>x>>y>>d>>c;\n            x--;y--;\n            C[x].emplace_back(y,c,d);\n            C[y].emplace_back(x,c,d);\n        }\n        fill(memo[0],memo[30],1e8);\n        memo[s][0]=0;\n        while(!que.empty())que.pop();\n        que.emplace(0,s,0,-1);\n        double ans=1e8;\n        while(!que.empty()){\n            T t=que.top(); que.pop();\n            double time=get<0>(t);\n            int cityid=get<1>(t);\n            int speed=get<2>(t);\n            int prev=get<3>(t);\n            if(time>memo[cityid][speed]) continue;\n            if(cityid==g&&speed==1){\n                ans=time;\n                break;\n            }\n            for(auto& e:C[cityid]){\n                double distance=get<2>(e);\n                int to=get<0>(e);\n                int limit=get<1>(e);\n                if(to==prev)continue;\n                if(speed+1<=limit){\n                    if(memo[to][speed+1]>time+distance/(speed+1)){\n                        memo[to][speed+1]=time+distance/(speed+1);\n                        que.emplace(memo[to][speed+1],to,speed+1,cityid);\n                    }\n                }\n                if(speed<=limit&&speed>0){\n                    if(memo[to][speed]>time+distance/(speed)){\n                        memo[to][speed]=time+distance/(speed);\n                        que.emplace(memo[to][speed],to,speed,cityid);\n                    }\n                }\n                if(speed-1<=limit&&speed-1>0){\n                    if(memo[to][speed-1]>time+distance/(speed-1)){\n                        memo[to][speed-1]=time+distance/(speed-1);\n                        que.emplace(memo[to][speed-1],to,speed-1,cityid);\n                    }\n                }\n            }\n        }\n        if(ans==1e8){\n            cout<<\"unreachable\"<<endl;\n        }else{\n            cout<<ans<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define MAX 30\n#define INF 10000000.0\nstruct S{\n\tint e,s,b;\n};\n\nstruct S2{\n\tint d,c,to;\n};\n\nint main(){\n\n\tint n,m;\n\tint s,g;\n\tint x,y,d,c;\n\tint min;\n\tdouble cost[MAX+1][MAX+1][MAX+1];\n\tS point,tmp;\n\tS2 nod;\n\tvector<S2> ed[MAX+1];\n\tqueue<S> no;\n\n\twhile(1){\n\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0) break;\n\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(!ed[i].empty()) ed[i].clear();\n\t\t}\n\n\t\tfor(int i=0;i<=30;i++){\n\t\t\tfor(int j=0;j<=30;j++){\n\t\t\t\tfor(int k=0;k<=30;k++){\n\t\t\t\t\tcost[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin>>s>>g;\n\t\tpoint.e=s,point.s=0,point.b=0;\n\t\tcost[0][s][0]=0;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tnod.c=c,nod.d=d,nod.to=y;;\n\t\t\ted[x].push_back(nod);\n\t\t\tnod.to=x;\n\t\t\ted[y].push_back(nod);\n\t\t}\n\n\t\tno.push(point);\n\t\twhile(!no.empty()){\n\t\t\tpoint=no.front();\n\t\t\tno.pop();\n\t\t\tfor(int i=0;i<ed[point.e].size();i++){\n\t\t\t\tif(point.b!=ed[point.e][i].to){\n\t\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\tif(point.s+j>0&&point.s+j<=30){\n\t\t\t\t\t\t\t//if(point.s+j==1&&ed[point.e][i].to==g) cout<<cost[point.s][point.e]+((double)ed[point.e][i].d/(point.s+j))<<endl;\n\t\t\t\t\t\t\tif(ed[point.e][i].c>=point.s+j){\n\t\t\t\t\t\t\t\t//cout<<point.e<<\",\"<<point.b<<\",\"<<point.s<<\",\"<<ed[point.e][i].to<<\",\"<<cost[point.s][point.e]<<\"^^\"<<cost[point.s][point.e]+(double)ed[point.e][i].d/(point.s+j)<<endl;\n\t\t\t\t\t\t\t\tif(cost[point.s+j][ed[point.e][i].to][point.e]>cost[point.s][point.e][point.b]+((double)ed[point.e][i].d/(point.s+j))){\n\t\t\t\t\t\t\t\t\tcost[point.s+j][ed[point.e][i].to][point.e]=cost[point.s][point.e][point.b]+((double)ed[point.e][i].d/(point.s+j));\n\t\t\t\t\t\t\t\t\ttmp.e=ed[point.e][i].to;\n\t\t\t\t\t\t\t\t\ttmp.s=point.s+j;\n\t\t\t\t\t\t\t\t\ttmp.b=point.e;\n\t\t\t\t\t\t\t\t\tno.push(tmp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmin=0;\n\t\tfor(int i=1;i<=30;i++){\n\t\t\tif(cost[1][g][i]<cost[1][g][min]) min=i;\n\t\t}\n\t\tif(min==0) printf(\"unreachable\\n\");\n\t\telse printf(\"%.5f\\n\",cost[1][g][min]);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j;\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int f,g;\n    cin>>f>>g;\n    f--;\n    g--;\n    int a[30][30],b[30][30];\n    memset(a,-1,sizeof(a));\n    for(i=0;i<m;i++){\n      int p,q,r,s;\n      cin>>p>>q>>r>>s;\n      p--;\n      q--;\n      a[p][q]=a[q][p]=r;\n      b[p][q]=b[q][p]=s;\n    }\n    int c[31][30][30];\n    memset(c,-1,sizeof(c));\n    priority_queue<pair<pair<double,int>,pair<int,int> >,vector<pair<pair<double,int>,pair<int,int> > >,greater<pair<pair<double,int>,pair<int,int> > > > d;\n    for(i=0;i<n;i++){\n      if(a[f][i]!=-1)\n\td.push(make_pair(make_pair(a[f][i],1),make_pair(f,i)));\n    }\n    while(d.empty()==0){\n      double p;\n      int q,r,s;\n      p=d.top().first.first;\n      q=d.top().first.second;\n      r=d.top().second.first;\n      s=d.top().second.second;\n      if(q==1&&s==g)\n\tbreak;\n      d.pop();\n      if(c[q][r][s]){\n\tc[q][r][s]=0;\n\tfor(i=0;i<n;i++){\n\t  if(i!=r&&a[s][i]!=-1){\n\t    for(j=-1;j<=1;j++){\n\t      if(1<=q+j&&q+j<=b[s][i]&&c[q+j][s][i]) \n\t\td.push(make_pair(make_pair(p+(double)a[s][i]/(q+j),q+j),make_pair(s,i)));\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(d.empty())\n      cout<<\"unreachable\"<<endl;\n    else\n      cout<<d.top().first.first<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 27;\nconst double EPS = 1e-7;\n\nstruct status {\n    int pos;\n    double time;\n    int vel;\n    int prev;\n\n    status () {}\n    ~status () {}\n\n    status(int a, double b, int c, int d): pos(a), time(b), vel(c), prev(d) {}\n\n    bool operator > (const status& o) const {\n        return time > o.time;\n    }\n};\n\nstruct edge {\n    int to;\n    int time;\n    int lim;\n\n    edge () {}\n    ~edge () {}\n\n    edge(int a, double b, int c): to(a), time(b), lim(c) {}\n};\n\nbool solve() {\n    int n, m, s, g;\n    cin >> n >> m;\n\n    if (n == 0 && m == 0) return false;\n\n    cin >> s >> g;\n\n    --s; --g;\n\n    vector<vector<edge>> graph(n, vector<edge>(0));\n\n    for (int j = 0; j < m; ++j) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        --x; --y;\n        graph[x].push_back(edge(y, d, c));\n        graph[y].push_back(edge(x, d, c));\n    }\n\n    vector<vector<char>> visited(n, vector<char>(31, false));\n    priority_queue<status, vector<status>, greater<status>> que;\n\n    que.push(status(s, 0.0, 0, -1));\n\n    double ret = -1;\n\n    while (!que.empty()) {\n        status st = que.top(); que.pop();\n\n        if (visited[st.pos][st.vel]) {\n            continue;\n        }\n\n        visited[st.pos][st.vel] = true;\n\n        if (st.pos == g && st.vel == 1) {\n            ret = st.time;\n            break;\n        }\n\n        for (edge& e : graph[st.pos]) {\n            if (e.to == st.prev) continue;\n\n            for (int a = -1; a <= 1; ++a) {\n                int nv = st.vel + a;\n                if (nv <= 0) continue;\n\n                double t = st.time + (double)e.time / nv;\n\n                if (nv <= e.lim && !visited[e.to][nv]) {\n                    que.push(status(e.to, t, nv, st.pos));\n                }\n            }\n        }\n    }\n    \n    if (ret < 0) {\n        printf(\"unreachable\\n\");\n    } else {\n        printf(\"%.12f\\n\", ret);\n    }\n\n    fflush(stdout);\n\n    return true;\n}\n\nint main () {\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef double Weight;\nWeight INF = 1000000000;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int src, int dest, Weight weight) {\n  g[src].push_back((Edge){src, dest, weight});\n}\n\n// Dijkstra (Verified: AOJ2005)\nvoid dijkstra(Graph &g, Array &d, int s) {\n  d.assign(g.size(), INF);\n  d[s] = 0;\n  typedef pair<Weight,int> P;\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    Weight dist = que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        que.push(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\nint cnv(int now, int prev, int speed, int n) {\n  return now*(n+1)*31+prev*31+speed;\n}\n\nint main() {\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n) break;\n    int s,t;\n    cin>>s>>t;\n    --s;--t;\n    Graph g(n*(n+1)*31);\n    REP(i,m){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      --x;--y;\n      REP(j,c){\n        double v = j+1;\n        int ct[2] = {x,y};\n        REP(k,n+1) {\n          REP(l,2) {\n            int src = ct[l], dest = ct[1-l];\n            if (dest!=k) {\n              add_edge(g, cnv(src,k,v,n), cnv(dest,src,v,n), d/v);\n              add_edge(g, cnv(src,k,v-1,n), cnv(dest,src,v,n), d/v);\n              if (v<30)\n                add_edge(g, cnv(src,k,v+1,n), cnv(dest,src,v,n), d/v);\n            }\n          }\n        }\n      }\n    }\n    Array d(n*(n+1)*31);\n    dijkstra(g, d, cnv(s,n,0,n));\n    double mnt = INF;\n    REP(i,n+1){\n      mnt = min(mnt, d[cnv(t,i,1,n)]);\n    }\n    if (mnt < INF)\n      cout << setprecision(10) << fixed << mnt << endl;\n    else\n      cout << \"unreachable\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\nconst double INF = 1e10;\n\nstruct Edge{\n  int cost, to, c;\n  Edge(int to, int cost, int c):\n    to(to), cost(cost), c(c) {}\n};\n\ndouble dijkstra(int s, int g, vector< vector<Edge> > &G){\n  int n = G.size();\n  vector< vector<double> > D(n,vector<double>(30,INF));\n  priority_queue< tuple<double,int,int,int> > wait;\n  wait.emplace(0,0,0,-1);//time, v, cur, from\n  while(!wait.empty()){\n    double t = -get<0>(wait.top());\n    int v = get<1>(wait.top()) + 1,\n      cur = get<2>(wait.top()), from = get<3>(wait.top());\n    wait.pop();\n    if(t >= D[cur][v-1]) continue;\n    D[cur][v-1] = t;\n    for(int i = 0; i < G[cur].size(); ++i){\n      int to = G[cur][i].to, d = G[cur][i].cost, c = G[cur][i].c;\n      if(to == from) continue;\n      if(from != -1 && v+1 <= c && D[to][v] > t + (double)d/(v+1))\n        wait.emplace(-t-(double)d/(v+1), v, to, cur);\n      if(v <= c && D[to][v-1] > t + (double)d/v)\n        wait.emplace(-t-(double)d/v, v-1, to, cur);\n      if(v > 1 && v-1 <= c && D[to][v-2] > t + (double)d/(v-1))\n        wait.emplace(-t-(double)d/(v-1), v-2, to, cur);\n    }\n  }\n  return D[g][0];\n}\n\nint main(){\n  int n, m;\n  while(cin >> n >> m, n){\n    int s, g;\n    cin >> s >> g;\n    --s;\n    --g;\n    int x, y, d, c;\n    vector< vector<Edge> > G(n);\n    for(int i = 0; i < m; ++i){\n      cin >> x >> y >> d >> c;\n      --x;\n      --y;\n      G[x].emplace_back(y,d,c);\n      G[y].emplace_back(x,d,c);\n    }\n    double ans = dijkstra(s,g,G);\n    if(ans >= INF) cout << \"unreachable\" << endl;\n    else printf(\"%.12f\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\nnamespace ShortestPath{\n    typedef double Cost;\n    const Cost CINF=1e17;\n    typedef  vector<vector<Cost> > Mat;\n    struct Edge{\n    \t  int id;\n        int from,to;Cost cost;\n        Edge(int id,int from,int to,Cost cost)\n            : id(id),from(from),to(to),cost(cost){};\n    };\n    ostream& operator <<(ostream& os,const Edge& e){\n            os<<\"(\"<<e.from<<\"->\"<<e.to<<\")\";\n            return os;\n    }\n    typedef vector<vector<Edge> > Graph;\n\n    struct Task{\n        int prev,pos;Cost cost;\n        Task(int prev,int pos,Cost cost)\n            :prev(prev),pos(pos),cost(cost){};\n        bool operator>(const Task& r) const{\n            return cost>r.cost;\n        }\n    };\n\n    //verified by codoforces 144D http://codeforces.com/contest/144/submission/4976825\n    // // 負の辺がない\n    // // O(E*logV)\n    vector<Cost> dijkstra(const Graph& g,const int s,vector<int>& prev){\n        const int V=g.size();\n        vector<Cost> d(V,CINF);d[s]=0;\n        fill(ALL(prev), -2);\n        priority_queue<Task,vector<Task>,greater<Task> > que;\n        que.push(Task(-1,s,0));\n        while(!que.empty()){\n            Task task=que.top();que.pop();\n            //if(prev[task.pos]!=-2)continue;\n            if(d[task.pos]<task.cost)continue;\n            prev[task.pos]=task.prev;\n            EACH(e,g[task.pos]){\n            \tif(e->id==task.prev)continue;// not U ターン\n                if(d[e->to]>d[e->from]+e->cost){\n                    d[e->to]=d[e->from]+e->cost;\n                    que.push(Task(e->id,e->to,d[e->to]));\n                }\n            }   \n        }\n        return d;\n    }\n    vector<Cost> dijkstra(const Graph& g,const int s){\n        vector<int> prev(g.size());return dijkstra(g,s,prev);\n    }\n}\n\nusing namespace ShortestPath;\n\nclass Main{\n\tpublic:\n\n\tint enc(int pos,int V){\n\t\treturn pos*35+V;\n\t}\n\tint dec_pos(int c){\n\t\treturn c/35;\n\t}\n\tint dec_v(int c){\n\t\treturn c%35;\n\t}\n\n\tvoid run(){\n\t\t// ifstream cin(\"in\");\n\t\t// ofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tint N,M; cin >> N >> M;\n\t\t\tif(N==0)break;\n\t\t\tint s,g;cin >> s >> g;s--;g--;\n\t\t\tGraph G(N*35);\n\t\t\tREP(i,M){\n\t\t\t\tint x,y;double d;int c;cin >> x >> y >> d >> c;x--;y--;\n\t\t\t\tif(s==x)G[enc(x,0)].push_back(Edge(i,enc(x,0),enc(y,1),d));\n\t\t\t\tif(s==y)G[enc(y,0)].push_back(Edge(i,enc(y,0),enc(x,1),d));\n\t\t\t\t// V\n\t\t\t\tfor(int v=1;IN(1,v,c+1);v++)G[enc(x,v)].push_back(Edge(i,enc(x,v),enc(y,v),d/v));\n\t\t\t\tfor(int v=1;IN(1,v,c+1);v++)G[enc(y,v)].push_back(Edge(i,enc(y,v),enc(x,v),d/v));\n\t\t\t\t// V++\n\t\t\t\tfor(int v=1;IN(1,v+1,c+1);v++)G[enc(x,v)].push_back(Edge(i,enc(x,v),enc(y,v+1),d/(v+1)));\n\t\t\t\tfor(int v=1;IN(1,v+1,c+1);v++)G[enc(y,v)].push_back(Edge(i,enc(y,v),enc(x,v+1),d/(v+1)));\n\t\t\t\t// V--\n\t\t\t\tfor(int v=2;IN(1,v-1,c+1);v++)G[enc(x,v)].push_back(Edge(i,enc(x,v),enc(y,v-1),d/(v-1)));\n\t\t\t\tfor(int v=2;IN(1,v-1,c+1);v++)G[enc(y,v)].push_back(Edge(i,enc(y,v),enc(x,v-1),d/(v-1)));\n\t\t\t}\n\t\t\tvector<Cost> res=dijkstra(G,enc(s,0));\n\t\t\tif(res[enc(g,1)]>=CINF) cout <<\"unreachable\"<<endl;\n\t\t\telse cout << res[enc(g,1)]<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e10\n#define EPS 1e-10\nusing namespace std;\nstruct edge{\n  int to,limit;\n  double dist;\n};\nvector<edge> G[100];\ndouble d[40][100];\nbool used[40][100][40];\ntypedef pair<int,int> pii; //speed,prev\ntypedef pair<int,pii> PII;//to,speed,prev\ntypedef pair<double,PII> P;//cost,to,speed\n\ndouble dikstra(int s,int g){\n  int ds[3]={-1,0,1};\n  priority_queue<P,vector<P>,greater<P> > que;\n  for(int i=0;i<40;i++)\n    for(int j=0;j<100;j++)\n      d[i][j]=INF;\n  memset(used,0,sizeof(used));\n  d[0][s]=0;\n  que.push(P(0,PII(s,pii(0,-1))));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int speed=p.second.second.first;\n    int v=p.second.first;\n    int prev=p.second.second.second;\n    double cost=p.first;\n    //cout << v << \":\" << speed <<\":\" << cost << endl;\n    if(d[speed][v]<cost)continue;\n    for(int i=0;i<G[v].size();i++){\n      for(int j=0;j<3;j++){\n\tedge e=G[v][i];\n\tint ns=speed+ds[j];\n\tif(1<=ns && ns<= e.limit &&\n\t   used[ns][e.to][v]==false){\n\t  used[ns][e.to][v]=true;\n\t  que.push(P(cost+e.dist/ns,PII(e.to,pii(ns,v))));\n\t  if(d[ns][e.to]>cost+e.dist/ns){\n\t    d[ns][e.to]=cost+e.dist/ns;\n\t    //cout << \"d[\" << ns << \"][\" << e.to << \"]:\" << d[ns][e.to] << endl;\n\t    //cout << \"d[\" << v << \"]:\" << d[speed][v] << \" speed:\" << speed<< endl;\n\t  }\n\t}\n      }\n    }\n  }\n  if(d[1][g]==INF)return -1;\n  return d[1][g];\n}\n\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n){\n    for(int i=0;i<100;i++)G[i].clear();\n    cin>>s>>g;\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      G[x].push_back((edge){y,c,d});\n      G[y].push_back((edge){x,c,d});\n    }\n    double ans=dikstra(s,g);\n    if(ans==-1)cout << \"unreachable\" << endl;\n    else printf(\"%.5lf\\n\",ans);\n    // for(int i=0;i<=n;i++)\n    // \tcout << i << \" \" << d[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e8\n#define EPS 1e-9\n\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) rep2(i,0,n)\n#define ll long long\n#define P pair<double,int>\n#define pb push_back\n\nint n,m,s,g,D[30][30],C[30][30];\ndouble d[30][30][31];\n\nint main(){\n\twhile(cin>>n>>m&&n){\n\t\tcin>>s>>g;\n\t\ts--;g--;\n\t\trep(i,n){\n\t\t\tfill(D[i],D[i]+n,INF);\n\t\t\tfill(C[i],C[i]+n,0);\n\t\t\trep(j,n)fill(d[i][j],d[i][j]+31,INF);\n\t\t}\n\t\trep(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tx--;y--;\n\t\t\tD[x][y]=D[y][x]=d;\n\t\t\tC[x][y]=C[y][x]=c;\n\t\t}\n\t\tdouble ans=INF;\n\t\tmultimap<double,int> Q;\n\t\td[s][s][0]=0.0;\n\t\tQ.insert(P(0.0,s*930+s*31+0));\n\t\twhile(Q.size()){\n\t\t\tP p=*(Q.begin());\n\t\t\tQ.erase(Q.begin());\n\t\t\tdouble t=p.first;\n\t\t\tint cur=p.second/930,prev=(p.second/31)%30,v=p.second%31;\n\t\t\tif(t>d[cur][prev][v])continue;\n\t\t\tif(cur==g&&v==1){ans=d[cur][prev][v];break;}\n\t\t\trep(i,n){\n\t\t\t\tif(i!=prev&&D[cur][i]!=INF){\n\t\t\t\t\trep2(j,-1,2){\n\t\t\t\t\t\tint nv=v+j;\n\t\t\t\t\t\tif(0<nv&&nv<=C[cur][i]){\n\t\t\t\t\t\t\tdouble nt=t+D[cur][i]*1.0/nv;\n\t\t\t\t\t\t\tif(nt<d[i][cur][nv]){\n\t\t\t\t\t\t\t\td[i][cur][nv]=nt;\n\t\t\t\t\t\t\t\tQ.insert(P(nt,i*930+cur*31+nv));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans!=INF)cout<<setprecision(10)<<ans<<endl;\n\t\telse cout<<\"unreachable\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong double memo[10000][32];\nstruct edge {\n\tint id;\n\tint from;\n\tint to;\n\tint lim;\n\tlong double dis;\n};\nstruct aa {\n\tint id;\n\tint speed;\n\tlong double  time;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tmemset(memo, 9999999, sizeof(memo));\n\t\tint n, m; cin >> n >> m;\n\t\tif (!n)break;\n\t\tint s, g; cin >> s >> g; s--; g--;\n\t\tvector<edge>edges;\n\t\tvector<vector<int>>edgeids(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tlong double d;\n\t\t\tint x, y, c; cin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tedges.push_back(edge{ 2*i,x,y,c,d });\n\t\t\tedges.push_back(edge{ 2*i+1,y,x,c,d });\n\t\t\tedgeids[x].push_back(2 * i);\n\t\t\tedgeids[y].push_back(2 * i + 1);\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tfor (auto i : edgeids[s]) {\n\n\t\t\tque.push(aa{ i,1,edges[i].dis });\n\t\t\tmemo[i][1] = edges[i].dis;\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst edge oldedge(edges[atop.id]);\n\t\t\tconst int oldsp(atop.speed);\n\t\t\tconst long double oldtime(atop.time);\n\t\t\tfor (auto i : edgeids[oldedge.to]) {\n\t\t\t\tconst edge nextedge(edges[i]);\n\t\t\t\tif (nextedge.to == oldedge.from)continue;\n\t\t\t\telse {\n\t\t\t\t\tfor (int change = -1; change <= 1; ++change) {\n\t\t\t\t\t\tconst int nextsp = oldsp + change;\n\t\t\t\t\t\tif (nextsp == 0)continue;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (nextsp <= nextedge.lim) {\n\t\t\t\t\t\t\t\tconst long double nexttime= nextedge.dis / nextsp + oldtime;\n\t\t\t\t\t\t\t\tif (memo[i][nextsp] > nexttime) {\n\t\t\t\t\t\t\t\t\tmemo[i][nextsp] = nexttime;\n\t\t\t\t\t\t\t\t\tque.push(aa{ i,nextsp,nexttime });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong double amin = 999999999;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tif (edges[i].to == g) {\n\t\t\t\tamin = min(amin, memo[i][1]);\n\t\t\t}\n\t\t}\n\t\tif (amin > 99999999) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << amin << endl;\n\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){std::fill( (T*)array, (T*)(array+N), val );}\nusing ld=long double;\nstruct edge{int to,cost,limit;};\nusing P=pair<ld,pair<int,int> >;\n#define mp(i,j,k) make_pair((i),make_pair((j),(k)))\nconst ld INF=1<<29;\nconst int MAX_V=32;\nvector<edge> G[MAX_V];\nld t[MAX_V][32];\nint V,E;\n//O(E*logV)\n\nint n,m,s,g;\nvoid dijkstra(){\n  priority_queue<P,vector<P>,greater<P>> que;\n  Fill(t,INF);\n  t[s][1]=0;\n  que.push(mp(0,s,1));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int v=p.second.first;\n    int spd=p.second.second;\n    if(t[v][spd]<p.first)continue;\n    if(spd==0)continue;\n    REP(i,G[v].size()){\n      edge e=G[v][i];\n      for(int j=-1;j<=1;j++){\n\tif(spd>e.limit)continue;\n\t//cout<<\"[\"<<v<<\"->\"<<e.to<<\"] \"<<t[e.to][spd+j]<<\">\"<<t[v][spd]<<\"+\"<<((double)e.cost)/spd<<endl;\n\tif(t[e.to][spd+j]>t[v][spd]+((double)e.cost)/spd){\n\t  t[e.to][spd+j]=t[v][spd]+((double)e.cost)/spd;\n\t  que.push(mp(t[e.to][spd+j],e.to,spd+j));\n\t}\n      }\n    }\n  }\n  if(t[g][0]!=INF){\n    printf(\"%.5Lf\\n\",t[g][0]);\n    return;\n  }\n  printf(\"unreachable\\n\");\n}\nint x,y,d,c;\nint main(){ _;\n  while(cin>>n>>m,(n|m)){\n    REP(i,MAX_V)G[i].clear();\n    cin>>s>>g;\n    REP(i,m){\n      cin>>x>>y>>d>>c;\n      G[x].push_back(edge{y,d,c});\n      G[y].push_back(edge{x,d,c});\n    }\n    dijkstra();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\n\nstruct Edge {\n    int to, dist, c;\n    Edge(int to, int dist, int c): to(to), dist(dist), c(c) {}\n};\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nconst int INF = 100000000;\n\nll GCD(ll a, ll b){\n    if(a < b) swap(a, b);\n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\nbool cmp(const pii& a, const pii& b){\n    if(a.first == b.first){\n        return a.second < b.second;\n    }\n    return a.first < b.first;\n}\n\nbool prime[1000001];\nint mas[1001][1001];\nint dp1[1001][1001], dp2[1001][1001];\nint dx[4] = { -1, 0, 1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\ndouble d[35][35][35];\n\nstruct S {\n    double time;\n    int speed, nowE, prevE;\n    \n    S(double time, int speed, int nowE, int prevE): time(time), speed(speed), nowE(nowE), prevE(prevE) {}\n    \n    bool operator > (const S &s) const {\n        return time > s.time;\n    }\n};\nint main() {\n    cout << fixed << setprecision(6);\n    \n    int n, m; \n    while(cin >> n >> m){\n        if(n == 0 && m == 0 ) break;\n        vector<vector<Edge>> G(35);\n        int s, g; cin >> s >> g;\n        s--;  g--;\n        for(int i=0; i<m; ++i){\n            int x, y, d, c; cin >> x >> y >> d >> c; x--; y--;\n            G[x].push_back(Edge(y, d, c));\n            G[y].push_back(Edge(x, d, c));\n        }\n        \n        for(int i=0; i<35; ++i){\n            for(int j=0; j<35; ++j){\n                for(int k=0; k<35; ++k){\n                    d[i][j][k]=1000000.0;\n                }\n            }\n        }\n        \n        priority_queue<S, vector<S>, greater<S>> q;\n        q.push(S(0, 0, s, s));\n        // スピード/現在地点/先ほどまでいた地点\n        bool visited[35][35][35] = {false};\n        d[s][0][s] = 0;\n        \n        \n        \n        while(!q.empty()){\n            \n            S s = q.top();\n            q.pop();\n            \n            double time = s.time;\n            int v = s.nowE;\n            int speed = s.speed;\n            int prev_v = s.prevE;\n            \n            if(visited[speed][v][prev_v]) continue;\n            visited[speed][v][prev_v] = true;\n            \n            for(int i=0; i<(int)G[v].size(); ++i){\n                if(G[v][i].to == prev_v) continue;\n                \n                Edge e = G[v][i];\n                int u = e.to;\n                \n                int dist = e.dist;\n                int c = e.c;\n                for(int j=-1; j<=1; ++j){\n                    int nsp = speed + j;\n                    if(nsp>=1 && nsp<=c && visited[nsp][u][v] == false){\n                        if(d[u][nsp][v] > time + (double)dist/nsp){\n                            d[u][nsp][v] = time + (double)dist/nsp;\n                            q.push(S(d[u][nsp][v], nsp, u, v));\n                        }\n                    }\n                }\n            }\n        }\n        \n        double ans = 1000000.0;\n        for(int i=0; i<n; ++i){\n            ans = min(ans, d[g][1][i]);\n        }\n        if(ans == 1000000.0) cout << \"unreachable\" << endl;\n        else cout << ans << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nint main() {\n   for(;;) {\n      Int n, m;\n      std::cin >> n >> m;\n      if( n == 0 and m == 0 ) break;\n      Int s, g;\n      std::cin >> s >> g;\n      double inf = 1e16;\n      std::vector<std::pair<Int,double>> edges[32*32];\n      rep(ii,m) {\n         Int x, y, d, c;\n         std::cin >> x >> y >> d >> c;\n         for(Int kk = 0; kk < 2; ++kk) {\n            for(Int k = 1; k <= c; ++k) {\n               if( y != g ) {\n                  edges[x*32+k].emplace_back(y*32+k+1, (double)d/k);\n                  if( k >= 2 ) {\n                     edges[x*32+k].emplace_back(y*32+k-1, (double)d/k);\n                  }\n               }\n               edges[x*32+k].emplace_back(y*32+k+0, (double)d/k);\n            }\n            std::swap(x,y);\n         }\n      }\n      RQ<std::tuple<double,Int,Int>> q;\n      q.emplace(0.0, s*32+1, -1);\n      std::vector<double> dist(32*32, inf);\n      dist[s*32+1] = 0;\n      while( not q.empty() ) {\n         double d;\n         Int v;\n         Int prev;\n         std::tie(d, v, prev) = q.top(); q.pop();\n         for(auto next : edges[v]) {\n            Int nv;\n            double dd;\n            std::tie(nv, dd) = next;\n            if( nv == prev ) continue;\n            double nd = d + dd;\n            if( nd < dist[nv] ) {\n               dist[nv] = nd;\n               q.emplace(nd, nv, v);\n            }\n         }\n      }\n      if( dist[g*32+1] >= inf ) {\n         puts(\"unreachable\");\n      }\n      else {\n         printf(\"%lf\\n\", dist[g*32+1]);\n      }\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef double Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  int c;                        // c ÍOtÅÍ§À¬xAqueue ÅÍ¬x\n  Edge(int src, int dst, Weight weight, int c) :\n    src(src), dst(dst), weight(weight), c(c){ }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst != f.dst ? e.dst < f.dst : e.c<f.c;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ndouble dijkstra(const Graph &g, int s, int t) {\n  int n = g.size();\n  double dist[n][31];           // dist[i][j] = Xs[h j ÌóÔÅ i ÉÂ­ÅZ£\n  REP(i,n) REP(j,31) dist[i][j] = INF;\n  dist[s][1] = 0;\n  priority_queue<Edge> Q;\n  Q.push(Edge(-2,s,0,1));\n  while(!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    //printf(\"%d->%d %f %d\\n\",e.src,e.dst,e.weight,e.c);\n    REP(k,3) {\n      int v = e.c - 1 + k;\n      if (e.src == -2 && v != 1) continue;\n      if (v<=0 || v>30) continue;\n      if (dist[e.dst][v] < e.weight) continue;\n      FOR(f, g[e.dst]) {\n        if (v > f->c) continue;\n        double hoge = e.weight + f->weight / v;\n        if (dist[f->dst][v] > hoge) {\n          dist[f->dst][v] = hoge;\n          Q.push(Edge(f->src, f->dst, hoge, v));\n        }\n      }\n    }\n  }\n  return dist[t][1];\n}\n\nint main() {\n  int n,m;\n  while(cin >> n>>m,n||m) {\n    int s,t;\n    cin >> s >> t;\n    s--;t--;\n    Graph g(n);\n    REP(i,m) {\n      int x,y,d,c;\n      cin >> x>>y>>d>>c;\n      x--;y--;\n      g[x].push_back(Edge(x,y,d,c));\n      g[y].push_back(Edge(y,x,d,c));\n    }\n    double res = dijkstra(g,s,t);\n    if (res == INF)\n      cout << \"unreachable\" << endl;\n    else\n      printf(\"%.5f\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> P;\nstruct edge{int to;double cost;};\n\nint n,m,s,go;\ndouble d[27002];\nvector<edge> g[27002];\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > q;\n\tfill(d,d+27002,INF);\n\td[s]=0;\n\tq.push(P(0,s));\n\tint count=0;\n\twhile(!q.empty()){\n\t\tcount++;\n\t\tP p=q.top();q.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tif(v==1)break;\n\t\trep(i,g[v].size()){\n\t\t\tedge e=g[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"count: \"<<count<<endl;\n}\n\nint main(){\n\twhile(cin>>n>>m&&n){\n\t\trep(i,27002)g[i].clear();\n\t\tcin>>s>>go;s--;go--;\n\t\tedge e;\n\t\trep(i,n){\n\t\t\te.to=1;\n\t\t\te.cost=0;\n\t\t\tg[i*n+go+2].push_back(e);\n\t\t}\n\t\trep(i,m){\n\t\t\tint x,y,c;\n\t\t\tdouble dd;\n\t\t\tcin>>x>>y>>dd>>c;\n\t\t\tx--;y--;\n\t\t\trep(v,c+2)rep(p,n){\n\t\t\t\tif(v==31)break;\n\t\t\t\tif(v==0){\n\t\t\t\t\tif(x==s){\n\t\t\t\t\t\te.to=x*n+y+2;\n\t\t\t\t\t\te.cost=dd;\n\t\t\t\t\t\tg[0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\tif(y==s){\n\t\t\t\t\t\te.to=y*n+x+2;\n\t\t\t\t\t\te.cost=dd;\n\t\t\t\t\t\tg[0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int j=-1;j<2;j++){\n\t\t\t\t\t\tif(v+j>0&&v+j<=c&&p!=x&&p!=y){\n\t\t\t\t\t\t\te.to=(v+j-1)*n*n+x*n+y+2;\n\t\t\t\t\t\t\te.cost=dd/(v+j);\n\t\t\t\t\t\t\tg[(v-1)*n*n+p*n+x+2].push_back(e);\n\t\t\t\t\t\t\te.to=(v+j-1)*n*n+y*n+x+2;\n\t\t\t\t\t\t\tg[(v-1)*n*n+p*n+y+2].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*dijkstra(0);\n\t\tif(d[1]<INF)cout<<d[1]<<endl;\n\t\telse cout<<\"unreachable\"<<endl;*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\n\n\n// 🔴\n\n// O(ElogE)\n\n// pq<pair> はfirstが大きい順に出てくるのですか？\n// s:= 開始ノード  v:= 頂点数  adjlist:= 隣接リスト (first:= コスト   second:= 行先)\nvector<double> dijk(int s, int v, vector<vector<pair<double, int> > > adjlist){\n    \n    priority_queue <pair<double, int> > wait;\n    vector<double> result(v, INF);\n\n    //スタート地点を追加\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    //ダイクストラ本体\n    while(!wait.empty()){    //waitが空になるまで\n\n        int nowpoint = wait.top().second;\n        double nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint] < nowcost) continue;\n\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n\n            int nextpoint = adjlist[nowpoint][i].second;\n            double nextcost = nowcost + adjlist[nowpoint][i].first;\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint] > nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n    \n    return result;         //結果列を返す\n}\n\nint main(){\n\n\n    while(1){\n        int n, m; cin >> n >> m;\n        if(!n) break;\n        int s, g; cin >> s >> g;\n        s--;\n        g--;\n        vector<vector<vector<int> > > Map(n, vector<vector<int> > (n, vector<int> (31)));\n        int idx = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                for(int k = 1; k <= 30; k++){\n                    Map[i][j][k] = idx;\n                    idx++;\n                }\n            }\n        }\n\n        vector<vector<pair<double, int> > > adjlist(30000);      //first := コスト　second := 行先\n\n        for(int i = 0; i < m; i++){\n            int x, y; double d, c; cin >> x >> y >> d >> c;\n            x--;\n            y--;\n\n            for(int pre = 0; pre < n; pre++){\n            for(int v = 1; v <= 30; v++){\n\n                int now = Map[x][pre][v];\n                if(pre == y) continue;\n                if(s != x && pre == x) continue;\n                //三方向\n                //-1\n                int next_v = v - 1;\n                if(0 < next_v && next_v <= c){\n                    int next = Map[y][x][next_v];\n                    double cost = d / next_v;\n                    adjlist[now].push_back(make_pair(cost, next));                    \n                }\n\n                //そのまま\n                next_v = v;\n                if(0 < next_v && next_v <= c){\n                    int next = Map[y][x][next_v];\n                    double cost = d / next_v;\n                    adjlist[now].push_back(make_pair(cost, next));                    \n                }\n\n                //+1\n                next_v = v + 1;\n                if(0 < next_v && next_v <= c){\n                    int next = Map[y][x][next_v];\n                    double cost = d / next_v;\n                    adjlist[now].push_back(make_pair(cost, next));                    \n                }\n\n            }\n            }\n\n            for(int pre = 0; pre < n; pre++){\n            for(int v = 1; v <= 30; v++){\n\n                int now = Map[y][pre][v];\n                if(pre == x) continue;\n                if(y != s && pre == y) continue;\n                //三方向\n                //-1\n                int next_v = v - 1;\n                if(0 < next_v && next_v <= c){\n                    int next = Map[x][y][next_v];\n                    double cost = d / next_v;\n                    adjlist[now].push_back(make_pair(cost, next));                    \n                }\n\n                //そのまま\n                next_v = v;\n                if(0 < next_v && next_v <= c){\n                    int next = Map[x][y][next_v];\n                    double cost = d / next_v;\n                    adjlist[now].push_back(make_pair(cost, next));                    \n                }\n\n                //+1\n                next_v = v + 1;\n                if(0 < next_v && next_v <= c){\n                    int next = Map[x][y][next_v];\n                    double cost = d / next_v;\n                    adjlist[now].push_back(make_pair(cost, next));                    \n                }\n            }\n        }\n        }\n        \n        int S = Map[s][s][1];\n        double ans = INF;\n        vector<double> result(30000);\n        result = dijk(S, 30000, adjlist);\n\n        for(int i = 0; i < n; i++){\n            if(i == g) continue;\n            int G = Map[g][i][1];\n            ans = min(ans, result[G]);\n        }\n\n\n        //cout << (fabs(ans - 4.0) < 1e-6) << endl;\n        if(fabs(ans - 4.0) < 1e-6){\n            ans--;\n        }\n        ans++;\n        if(ans >= INF) cout << \"unreachable\" << endl; \n        else printf(\"%.10f\\n\", ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint dv[] = {-1, 0, 1};\n\nstruct state {\n  int city;\n  int from;\n  double cost;\n  int v;\n};\n\nbool operator<(const state &a, const state &b){return a.cost > b.cost;}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n, m;\n\n  while(cin >> n >> m, n) {\n    int s, g;\n    cin >> s >> g;\n    s--; g--;\n\n    int d[n][n] = {}, limit[n][n] = {};\n    rep(i, m) {\n      int x, y;\n      cin >> x >> y;\n      x--, y--;\n      cin >> d[x][y] >> limit[x][y];\n      d[y][x] = d[x][y];\n      limit[y][x] = limit[x][y];\n    }\n\n    priority_queue<state> q;\n    bool visited[n][n][31] = {};\n    q.push(state{s, s, 0, 0});\n    double ans = INF;\n    while(!q.empty()) {\n      state st = q.top(); q.pop();\n      if (st.city == g && st.v == 1) {\n        ans = st.cost;\n        break;\n      }\n\n      if (visited[st.city][st.from][st.v]) continue;\n      else visited[st.city][st.from][st.v] = true;\n\n      rep(i, n) {\n        if (d[st.city][i] != 0 && i != st.from) {\n          rep(j, 3) {\n            if (st.v+dv[j] > 0 && st.v+dv[j] <= limit[st.city][i] && !visited[i][st.city][st.v+dv[j]]) {\n              q.push(state{i, st.city, st.cost+(double)d[st.city][i]/(st.v+dv[j]), st.v+dv[j]});\n            }\n          }\n        }\n      }\n    }\n    if (ans != INF) {\n      printf(\"%.5f\\n\", ans);\n    } else {\n      printf(\"unreachable\\n\");\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ndouble cut[32][32][32];\npair<int,int> way[32][32];\nint main() {\n\tint n, m, s, g;\n\twhile(cin >> n >> m, n) {\n\t\tcin >> s >> g;\n\t\tfill((double*)cut, (double*)cut + 32 * 1024, 1e100);\n\t\tfill((pair<int,int>*)way, (pair<int,int>*)way + 1024,make_pair(0,0));\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tway[x][y] = way[y][x] = make_pair(d,c);\n\t\t}\n\t\tpriority_queue<tuple<double, int, int, int>, vector<tuple<double, int, int, int>>, greater<tuple<double, int, int, int>>> que;\n\t\tque.push(make_tuple(0., s, 1,0));\n\t\twhile (!que.empty()&&(get<1>(que.top())!=g||get<2>(que.top())!=0)){\n\t\t\tauto a = que.top();\n\t\t\tque.pop();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (way[get<1>(a)][i].second == 0)continue;\n\t\t\t\tif (i == get<1>(a)||i==get<3>(a))continue;\n\t\t\t\tif (get<2>(a)>way[get<1>(a)][i].second)continue;\n\t\t\t\tif (get<2>(a) == 0)continue;\n\t\t\t\tfor (int j = max(0, get<2>(a)-1); j <= get<2>(a)+1; j++) {\n\t\t\t\t\tif (cut[i][j][get<1>(a)]>get<0>(a) + (double)way[get<1>(a)][i].first / get<2>(a)) {\n\t\t\t\t\t\tque.push(make_tuple(get<0>(a) + (double)way[get<1>(a)][i].first / get<2>(a), i, j,get<1>(a)));\n\t\t\t\t\t\tcut[i][j][get<1>(a)] = get<0>(a) + (double)way[get<1>(a)][i].first / get<2>(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (que.empty())cout << \"unreachable\" << endl;\n\t\telse cout << fixed << setprecision(10) << get<0>(que.top()) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n#define inf 101010\n\nstruct edge {\n    int to, len, lim;\n};\n\nstruct state {\n    double sum;\n    int pace, cur, pre;\n    \n    bool operator<(const state& rhs) const {\n        return sum > rhs.sum;\n    }\n};\n\nint n,m,s,g;\ndouble dp[31][31][31];\nvector<edge> e[31];\n\nvoid solve() {\n    priority_queue<state> que;\n    state st;\n    st.sum = 0, st.pace = 1, st.cur = s, st.pre = s;\n    que.push(st);\n    \n    while (!que.empty()) {\n        state st = que.top(); que.pop();\n        if (st.cur == g && st.pace == 1) {\n            printf(\"%.9lf\\n\",st.sum);\n            return;\n        }\n        \n        for (int i = 0; i < e[st.cur].size(); i++) {\n            int to = e[st.cur][i].to, len = e[st.cur][i].len, lim = e[st.cur][i].lim;\n            if (to == st.pre) continue;\n            \n            state t;\n            t.cur = to, t.pre = st.cur;\n            \n            for (int i = -1; i <= 1; i++) {\n                t.pace = st.pace + i;\n                if (st.cur == s && st.pre == s && i != 0) continue;\n                if (t.pace == 0 || t.pace == 31 || lim < t.pace) continue;\n                t.sum = st.sum + len / (double)t.pace;\n                if (dp[st.cur][to][t.pace] > t.sum) {\n                    dp[st.cur][to][t.pace] = t.sum;\n                    que.push(t);\n                }\n            }\n        }\n    }\n    cout << \"unreachable\" << endl;\n}\n\nint main(void) {\n    while (cin>>n>>m && n) {\n        cin >> s >> g;\n        s--, g--;\n        for (int i = 0; i < 31; i++) for (int j = 0; j < 31; j++) for (int k = 0; k < 31; k++) dp[i][j][k] = inf;\n        for (int i = 0; i < 31; i++) e[i].clear();\n        \n        for (int i = 0; i < m; i++) {\n            int a,b,c,d;\n            edge t;\n            cin >> a >> b >> c >> d;\n            a--, b--;\n            t.to = b, t.len = c, t.lim = d;\n            e[a].push_back(t);\n            t.to = a;\n            e[b].push_back(t);\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\nint n,m;\nwhile(cin>>n>>m){\nwhile(true){\n;\n}\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define INF 100000000\n#define rep(i,n) for(int i=0;i<n;i++)\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<double,int> pp;\ntypedef pair<pp,p> P;\nstruct edge{\n\tint to,d,c;\n};\nint main(){\n\tdouble dp[31][31];\n\tint n,m,s,g,x,y,d,c,ds[]={1,-1,0};\n\twhile(cin>>n>>m,n||m){\n\t\tvector<edge> G[31];\n\t\tcin>>s>>g;\n\t\ts--;g--;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tx--;y--;\n\t\t\tedge e;\n\t\t\te.d=d;e.c=c;\n\t\t\te.to=y;\n\t\t\tG[x].push_back(e);\n\t\t\te.to=x;\n\t\t\tG[y].push_back(e);\n\t\t}\n\t\trep(i,31)\n\t\trep(j,31)\n\t\tdp[i][j]=INF;\n\t\tdp[1][s]=0.0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(pp(0.0,-1),p(0,s)));\n\t\tdouble ans=INF;\n\t\twhile(!que.empty()){\n\t\t\tP q=que.top();que.pop();\n\t\t\tif(q.second.second==g&&q.second.first==1){\n\t\t\t\tans=min(ans,dp[q.second.first][q.second.second]);\n\t\t\t//\tcout<<ans<<endl;\n\t\t\t}\n\t\t\t//cout<<q.second.second<<' '<<q.second.first<<' '<<q.first<<endl;\n\t\t\tif(dp[q.second.first][q.second.second]<q.first.first)\n\t\t\t\tcontinue;\n\t\t\trep(i,G[q.second.second].size()){\n\t\t\t\tedge e=G[q.second.second][i];\n\t\t\t\tif(e.to==q.first.second)\n\t\t\t\tcontinue;\n\t\t\t\trep(j,3){\n\t\t\t\t\tint pre=q.second.first+ds[j];\n\t\t\t\t\tif(pre<1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble tes=(double)e.d/pre+q.first.first;\n\t\t\t\t\tif(pre<=e.c&&dp[pre][e.to]>tes){\n\t\t\t\t\t\tque.push(P(pp(tes,q.second.second),p(pre,e.to)));\n\t\t\t\t\t\tdp[pre][e.to]=tes;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans==INF)\n\t\tcout<<\"unreachable\"<<endl;\n\t\telse\n\t\tprintf(\"%.5lf\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr double INF = 1e18;\n\nclass Graph{\n    struct Edge{\n        int from, to;\n        double cost;\n        int limit;\n        Edge(int u,int v,double c,int l){\n            from=u;\n            to=v;\n            cost=c;\n            limit=l;\n        }\n        bool operator < (const Edge &right)const{\n            return cost > right.cost;\n        }\n    };\n    vector<vector<Edge>> g;\n\npublic:\n    Graph(int n){\n        g.resize(n);\n    }\n    void addEdge(int u, int v, double c, int l){\n        g[u].emplace_back(u, v, c, l);\n    }\n    void dijkstra(int, vector<vector<vector<double>>>&);\n};\n\ninline void Graph::dijkstra(int s, vector<vector<vector<double>>> &dist){\n    const int V=g.size();\n    priority_queue<Edge> pq;\n    for(int i=0;i<V;++i)dist[s][1][i]=0;\n    for(pq.emplace(-2,s,0.0,0);!pq.empty();){\n        Edge e=pq.top();pq.pop();\n        for(auto ge:g[e.to]){\n            if(e.from==ge.to)continue;\n            for(int i=-1;i<=1;++i){\n                if(e.limit+i<=0 || e.limit+i>ge.limit){\n                    continue;\n                }\n                if(dist[ge.to][e.limit+i][ge.from] > e.cost+(ge.cost/(e.limit+i))){\n                    dist[ge.to][e.limit+i][ge.from]=e.cost+(ge.cost/(e.limit+i));\n                    pq.emplace(ge.from,ge.to,dist[ge.to][e.limit+i][ge.from],e.limit+i);\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int n, m;\n    while(cin>>n>>m,n){\n        Graph g(n);\n        int src,dst;\n        cin>>src>>dst;\n        for(int i=0;i<m;++i){\n            int u,v,d,c;\n            cin>>u>>v>>d>>c;\n            g.addEdge(u-1,v-1,(double)d,c);\n            g.addEdge(v-1,u-1,(double)d,c);\n        }\n        vector<vector<vector<double>>>dist(n,vector<vector<double>>(31,vector<double>(n,INF)));\n        g.dijkstra(src-1, dist);\n        cout<<fixed;\n        double ans=INF;\n        for(int i=0;i<n;++i){\n            ans=min(ans,dist[dst-1][1][i]);\n        }\n        cout<<fixed;\n        if(ans==INF)cout<<\"unreachable\"<<endl;\n        else cout<<setprecision(6)<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<pair<int,int>,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a2,a4;\ndouble d[31][31],a3;\nint dx[]={-1,0,1};\nint main(){\n  while(cin>>n>>m,n){\n    vector<edge> v[31];\n    r(i,31)r(j,31)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      scanf(\"%d%d%lf%d\",&a1,&a2,&a3,&a4);\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P>q;\n    d[st][0]=0;\n    P xt;xt.fi.fi=0,xt.fi.se=st,xt.se=-1;\n    q.push(xt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.fi.se;\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=p.se)r(j,3){\n          int x=p.fi.fi+dx[j];\n          if(0<x&&x<=e.lim){\n            if(d[e.to][x]>e.dist/x+d[cur][p.fi.fi]){\n              d[e.to][x]=e.dist/x+d[cur][p.fi.fi];\n              xt.fi.fi=x,xt.fi.se=e.to,xt.se=cur;\n              //if(go&&d[e.to][x]>100)cout<<d[e.to][x]<<endl;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n\n///////////////////ダイクストラで使うクラス//////////////////\nclass E{\n\tpublic:\n\tint dir,cost,limit;\n\tE(int dir,int cost,int limit):dir(dir),cost(cost),limit(limit){}\n};\n\nclass T{\n\tpublic:\n\tint pos,bef,speed;\n\tdouble val;\n\tT(int pos,int bef,double val,int speed):pos(pos),bef(bef),val(val),speed(speed){}\n\t\n\tbool operator<(const T& a)const{\n\t\treturn val>a.val;\n\t}\n};\n\n////////////////////////////main/////////////////////////\nint main(){\n\t\n\twhile(1){\n\t\t/////////////入力/////////////////////////////////\n\t\tint n,m,start,goal;\n\t\tvector<E> edge[33];\n\t\t\n\t\tcin>>n>>m; if(n==0)break;\n\t\tcin>>start>>goal;\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tedge[a].push_back(E(b,c,d));\n\t\t\tedge[b].push_back(E(a,c,d));\n\t\t}\n\t\t\n\t\t///////////ダイクストラ本体//////////////////////\n\t\tpriority_queue<T> que;\n\t\tque.push(T(start,0,0,0)); //初期位置設定\n\t\t\n\t\tint visit[33][33]={0};\n\t\twhile(1){\n\t\t\tif(que.empty())break; //異常終了\n\t\t\t\n\t\t\tT u = que.top();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(visit[u.pos][u.speed]==1)continue; //一度訪れた状態の場合は弾く\n\t\t\tvisit[u.pos][u.speed]=1;\n\t\t\t\n\t\t\tif(u.pos==goal && u.speed==1){ //終了判定\n\t\t\t\tprintf(\"%lf\\n\",u.val);\n\t\t\t\tgoto A;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<edge[u.pos].size();i++){ //状態遷移\n\t\t\t\tE e = edge[u.pos][i];\n\t\t\t\tif(e.dir == u.bef)continue; //Uターン禁止の制約で弾く\n\t\t\t\t\n\t\t\t\t//-1:減速 0:等速 1:加速\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\n\t\t\t\t\tint next = u.speed + j;\n\t\t\t\t\tif(next >= e.limit || next <= 0)continue; //速度の制約で弾く\n\t\t\t\t\t\n\t\t\t\t\tque.push( T(e.dir, u.pos, u.val + double(e.cost)/next, next) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"unreachable\\n\");\n\t\tA:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <numeric>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <limits>\n#include <cassert>\n//#include <boost/multiprecision/cpp_int.hpp>\n\n\n\nusing namespace std;\nusing Int = long long;\n//using namespace boost::multiprecision;\n\nconst double EPS = 1e-10;\nlong long const MOD = 1000000007;\n\nlong long mod_pow(long long x, long long n) {\n    long long res = 1;\n    for(int i = 0;i < 60; i++){\n        if(n >> i & 1) res = res * x % MOD;\n        x = x * x % MOD;\n    }\n    return res;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    return b != 0 ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return a * b / gcd(a, b);\n}\n\nvoid fastInput() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nstruct Edge {\n    int from, to, dist, limit;\n};\n\n\ndouble INF = 1e10;\n\n// 距離、頂点番号、前の頂点、その頂点に入る時のスピード\nvector<vector<vector<double>>> dijkstra(vector<vector<Edge>> &G, int s, int t) {\n    vector<vector<vector<double>>> d(G.size(), vector<vector<double>> (G.size() + 1, vector<double> (31, INF)));\n    priority_queue<pair<double, pair<int, pair<int, int>>> , vector<pair<double, pair<int, pair<int, int>>>>, greater<pair<double, pair<int, pair<int, int>>>>> que;\n    d[s][G.size()][0] = 0;\n    que.push({d[s][G.size()][0], {s, {G.size(), 0}}});\n    while (!que.empty()) {\n        pair<double, pair<int, pair<int, int>>> p = que.top(); que.pop();\n        int v = p.second.first;\n        int preV = p.second.second.first;\n        int speed = p.second.second.second;\n        if (d[v][preV][speed] < p.first) continue;\n        for (int i=0; i<G[v].size(); i++) {\n            Edge e = G[v][i];\n            for (int j = -1; j <= 1; j++) {\n                int nextSpeed = speed + j;\n                if (e.limit < nextSpeed) continue;\n                if (nextSpeed <= 0) continue;\n                if (e.to == preV) continue;\n                if (d[e.to][e.from][nextSpeed] > d[v][preV][speed] + 1.0 * e.dist / nextSpeed) {\n                    d[e.to][e.from][nextSpeed] = d[v][preV][speed] + 1.0 * e.dist / nextSpeed;\n                    double dist = d[e.to][e.from][nextSpeed];\n                    que.push({dist, {e.to, {e.from, nextSpeed}}});\n                }\n            }\n        }\n    }\n    return d;\n}\n\ndouble solve(int N, int M) {\n    int s, t; cin >> s >> t;\n    s--, t--;\n    vector<vector<Edge>> G(N);\n    for (int i = 0; i < M; i++) {\n        int u, v; cin >> u >> v;\n        u--, v--;\n        int d; cin >> d;\n        int c; cin >> c;\n        Edge e1 = {u, v, d, c};\n        Edge e2 = {v, u, d, c};\n        G[u].push_back(e1);\n        G[v].push_back(e2);\n    }\n\n    vector<vector<vector<double>>> D = dijkstra(G, s, t);\n    double ret = INF;\n    for (int i = 0; i < N; i++) {\n        ret = min(ret, D[t][i][1]);\n    }\n    if (ret == INF) ret = -1;\n    return ret;\n}\n\nint main(void) {\n    int N, M;\n    vector<double> ans;\n    while (1) {\n        cin >> N >> M;\n        if (!N && !M) break;\n        ans.push_back(solve(N, M));\n    }\n    for (auto &i : ans) {\n        if (i == -1) cout << \"unreachable\" << endl;\n        else printf(\"%.12f\\n\", i);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a3,a2,a4;\ndouble d[31][31];\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)if(d[i][j]!=1e12)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      scanf(\"%d%d%d%d\",&a1,&a2,&a3,&a4);\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<int>q;\n    d[st][0]=0;\n    int xtt=st*100+0+0;\n    q.push(xtt);\n    while(!q.empty()){\n      int p=q.top();q.pop();\n      int cur=(p/100%100),xx=p%100,xy=p/100000;\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=xx)r(j,3){\n          int x=xy+dx[j];\n          if(0<x&&x<=e.lim){\n            double t=e.dist/x+d[cur][xy];\n            if(d[e.to][x]>t){\n              d[e.to][x]=t;\n              int xt=cur+e.to*100+x*100000;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<double, int, int, int> T;\n \nconst ll MOD=1e9+7;\n//const ll INF=1e18;\n\nconst double INF = 1000000.0;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\nstruct edge{ int to,d,c;};\n\n\n\nint n,m,s,g;\ndouble d[35][35][35];\n\nint main(){\n\twhile(true){\n\t\tcin >> n >> m;\n\t\tif(n + m == 0) break;\n\t\tcin >> s >> g;\n\t\tvector<edge> G[35];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a1,a2,a3,a4;\n\t\t\tcin >> a1 >> a2 >> a3 >> a4;\n\t\t\tedge tmp1 = {a2,a3,a4};\n\t\t\tG[a1].push_back(tmp1);\n\t\t\tedge tmp2 = {a1,a3,a4};\n\t\t\tG[a2].push_back(tmp2);\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tfor(int k = 0;k <= 31;k++){\n\t\t\t\t\td[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<T> que;\n\t\tfor(int i = 0;i < G[s].size();i++){\n\t\t\tedge e = G[s][i];\n\t\t\td[s][e.to][1] = (double) e.d;\n\t\t\tque.push(make_tuple((double)e.d,1,s,e.to));\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tT t = que.front(); que.pop();\n\t\t\tdouble a1 = get<0>(t);\n\t\t\tint a2 = get<1>(t),a3 = get<2>(t),a4 = get<3>(t);\n\t\t\tif(d[a3][a4][a2] < a1)continue;\n\t\t\tfor(int i = 0;i < G[a4].size();i++){\n\t\t\t\tedge e = G[a4][i];\n\t\t\t\tif(e.to == a3) continue;\n\t\t\t\tfor(int j = -1;j <= 1;j++){\n\t\t\t\t\tint v = a2 + j;\n\t\t\t\t\tdouble tmp = (double)( a1 + (double)e.d / (double)v);\n\t\t\t//\t\tif(a4 == 5 && e.to == 6 && v == 1) cout << \"tmp\" << tmp << \",a1\" << a1 <<endl;\n\t\t\t\t\tif(v <= 0 || v > e.c || d[a4][e.to][v] < tmp ) continue;\n\t\t\t\t\td[a4][e.to][v] =  tmp;\n\t\t\t\t\tque.push(make_tuple(tmp,v,a4,e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\n\t\t}\n\t//\tcout << \"ans\" << d[4][5][2] << endl;\n\n\n\n\t\tdouble ans = INF;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tdouble tmp = d[i][g][1];\n\t\t\tif(ans > tmp) ans = tmp;\n\t\t//\tans = min(ans,d[i][g][1]);\n\t\t}\n\t\tif(ans == INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t//\tcout << ans << endl;\n\t\t\tprintf(\"%lf\",ans);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// city, speed, prev -> time\nint N, M, start, goal;\ndouble dist[40][40][40];\n\nstruct Edge {\n    int to, length, limit;\n};\n\nstruct Elem {\n    int city, speed, prev;\n    bool operator<(const Elem &x) const {\n        return dist[city][speed][prev] > dist[x.city][x.speed][x.prev];\n    }\n};\n\ntypedef vector< vector< Edge > > Graph;\nconst double INF = 1e20;\n\nint main() {\n    while(1) {\n        scanf(\"%d%d\", &N, &M);\n        if(N == 0 && M == 0) break;\n\n        Graph G(N);\n        scanf(\"%d%d\", &start, &goal);\n        start--; goal--;\n        for(int i=0; i<M; i++) {\n            int u, v, d, c; scanf(\"%d%d%d%d\", &u, &v, &d, &c);\n            u--; v--;\n            G[u].push_back(Edge{v, d, c});\n            G[v].push_back(Edge{u, d, c});\n        }\n\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<=30; j++) {\n                for(int k=0; k<N; k++) {\n                    dist[i][j][k] = INF;\n                }\n            }\n        }\n        dist[start][1][N] = 0;\n\n        priority_queue<Elem> que;\n        que.push(Elem{start, 1, N});\n\n        double ans = INF;\n        while(que.size()) {\n            Elem cur = que.top(); que.pop();\n            int sp = cur.speed, ct = cur.city, pr = cur.prev;\n            if(sp <= 0) continue;\n            // printf(\"sp = %d, ct = %d, pr = %d\\n\", sp, ct, pr);\n\n            for(size_t i=0; i<G[ct].size(); i++) {\n                Edge e = G[ct][i];\n                if(e.to == pr || sp > e.limit) continue;\n                double cost = 1.0 * e.length / sp;\n                for(int k=-1; k<=1; k++) {\n                    int next_sp = sp + k;\n                    if(e.to == goal && sp == 1) {\n                        ans = min(ans, dist[ct][sp][pr] + cost);\n                    }\n                    if(dist[e.to][next_sp][ct] > dist[ct][sp][pr] + cost) {\n                        dist[e.to][next_sp][ct] = dist[ct][sp][pr] + cost;\n                        que.push(Elem{e.to, next_sp, ct});\n                    }\n                }\n            }\n        }\n\n        if(ans == INF) printf(\"unreachable\\n\");\n        else printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nstruct P{\n  double t;\n  short v,p,pre;\n  P(){};\n  P(double T,int V,int pp,int PRE){\n    t=T;v=V;p=pp;pre=PRE;\n  };\n  bool operator<(const P &p)const{\n    return t>p.t;\n  }\n};\nstruct Path{\n  int d,c;\n  Path(){};\n  Path(int D,int C){ d=D;c=C;};\n};\n\nint main(){\n  int n,m;\n  int s,g;\n  int x,y,d,c;\n  Path path[30][30];\n  //priority_queue<P,vector<P>,greater<P> > q;\n  priority_queue<P> q;\n\n  while( cin>>n>>m && (n|m) ){\n    cin >> s >> g;\n    s--; g--;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tpath[i][j].d=-1.0; path[i][j].c=-1;\n      }\n\n    for( int i=0;i<m;i++ ){\n      cin >> x >> y >> d >> c;\n      x--;y--;\n      path[x][y].d=d; path[x][y].c=c;\n      path[y][x] = path[x][y];\n    }\n\n    double cost[30][35]; // place,velocity\n    int dv[3] = {-1,0,1};\n    for( int i=0;i<n;i++ ){\n      for( int j=1;j<31;j++ )\n\tcost[i][j] = DBL_MAX;\n    }\n\n    // 最短路の経過時間を求める  cost[i][0] を使う。\n    double minimum=DBL_MAX;\n    while( !q.empty() ) q.pop();\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      double nt = path[s][i].d;\n      q.push( P(nt,1,i,-1) );\n      cost[i][0] = nt;\n    }\n    while( !q.empty() ){\n      P p=q.top(); q.pop();\n      double t=p.t;\n      int v=p.v, np=p.p;\n      if( np==g ){\n\tminimum = t+1.0;\n\tbreak;\n      }\n      for( int i=0;i<n;i++ ){\n\tif( path[np][i].c<0 )continue;\n\tfor( int j=0;j<3;j++ ){\n\t  int nv = v + dv[j];\n\t  if( nv==0 ) continue;\n\t  if( nv>path[np][i].c ) continue;\n\t  double nCost = t+(double)path[np][i].d/nv;\n\t  if(cost[i][0]<nCost ) continue;\n\t  cost[i][0]=nCost;\n\t  q.push( P(nCost,nv,i,-1) );\n\t}\n      }\n    }\n\n    while( !q.empty() ) q.pop();\n\n\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      double nt = path[s][i].d;\n      q.push( P(nt,1,i,-1) );\n      cost[i][1] = nt;\n    }\n\n    while( !q.empty() ){\n      P p = q.top(); q.pop();\n      double t = p.t;\n      int v = p.v;\n      int np = p.p; // 現在地\n      int pre = p.pre;\n\n      if( t>cost[g][1] ) break;\n\n      /*\n      cout << \"v=\" << v << \" p=\" << np << \" pre=\" << pre \n\t   << \" t=\" << t << endl;\n      */\n\n      for( int i=0;i<n;i++ ){\n\tif( path[np][i].c<0 ) continue;// たどり着けないノード\n\tif( i==pre ) continue; // 前回のノード\n\n\tfor( int j=0;j<3;j++ ){\n\t  int nv = v + dv[j];\n\t  if( nv==0 ) continue;\n\t  if( nv>path[np][i].c ) continue;\n\t  double nCost = t + (double)path[np][i].d/nv;\n\t  if( cost[i][nv] < nCost ) continue;\n\t  cost[i][nv]=nCost;\n\t  if( cost[i][nv]>cost[g][1] ) continue;\n\t  if( cost[i][nv]>minimum ) continue;\n\t  if( i==g && nv==1 ) continue;\n\t  q.push( P(nCost,nv,i,np) );\n\t}\n      }\n\n    }\n    if( fabs(cost[g][1]-DBL_MAX)<1e-4 )\n      cout << \"unreachable\" << endl;\n    else\n      //      cout << cost[g][1] << endl;\n      printf(\"%.6lf\\n\",cost[g][1]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\n\n#define INF 1145141919.810\n\nint n, m, s, g;\ndouble x[50][50][2];\nint a, b, c, d;\n\ndouble dp[50][50];\ndouble res;\n\ndouble solve(int p, int st, int go) {\n\tdp[st][0] = 0;\n\tfor (int i = 1; i <= p *100; i++) {\n\t\tfor (int j = 1; j <= p; j++) {\n\t\t\tfor (int k = 0; k <= 30; k++) {\n\t\t\t\tif (dp[j][k] < INF) {\n\t\t\t\t\tfor (int l = 0; l <= p; l++) {\n\t\t\t\t\t\tif (x[j][l][0] < 100000) {\n\t\t\t\t\t\t\t//v-1.\n\t\t\t\t\t\t\tif (k - 1 >= 1 && k - 1 <= x[j][l][1]) {\n\t\t\t\t\t\t\t\tdp[l][k - 1] = min(dp[l][k - 1], dp[j][k] + 1.0*x[j][l][0] / (k - 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//v.\n\t\t\t\t\t\t\tif (k >= 1 && k <= x[j][l][1]) {\n\t\t\t\t\t\t\t\tdp[l][k] = min(dp[l][k], dp[j][k] + 1.0*x[j][l][0] / k);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//v-1.\n\t\t\t\t\t\t\tif (k + 1 >= 1 && k + 1 <= x[j][l][1]) {\n\t\t\t\t\t\t\t\tdp[l][k + 1] = min(dp[l][k + 1], dp[j][k] + 1.0*x[j][l][0] / (k + 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[go][1];\n}\n\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tfor (int j = 0; j < 50; j++) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t\tx[i][j][0] = 10000000;\n\t\t\t\tx[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) { break; }\n\t\tcin >> s >> g;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tx[a][b][0] = c;\n\t\t\tx[a][b][1] = d;\n\t\t\tx[b][a][0] = c;\n\t\t\tx[b][a][1] = d;\n\t\t}\n\t\tres = solve(n, s, g);\n\t\tif (res > 1000000.00) { cout << \"unreachable\" << endl; }\n\t\telse { cout << fixed << setprecision(15) << res << endl; }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int INFINITY_HAHA = 999999;\n\ntypedef struct edge\n{\n    int to, limit;\n    double dist;\n    edge(int x, double y, int z): to(x), dist(y), limit(z) {}\n} Edge;\n\n\ntypedef struct status {\n    int from, now, speed;\n    double time;\n    status(int x, int x2, double y, int z): from(x), now(x2), time(y), speed(z) {}\n    bool operator< (const status &b) const {\n        return time > b.time;\n    }\n} Status;\n\n\n\nint main() {\n    freopen(\"input.txt\", \"r\", stdin);\n \n    int ncities, nroads;\n    double d[35][35][35];\n\n    while(scanf(\"%d%d\", &ncities, &nroads) != EOF && !(ncities == 0 && nroads == 0)) {\n\n        // Input\n        int start_index, end_index;\n        scanf(\"%d%d\" , &start_index, &end_index);\n\n        vector<Edge> paths[100]; // Array of vector\n        for(int n = 0; n < nroads; ++n) {\n            int x, y, d, c;\n            scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n            paths[x].push_back(Edge(y, d, c));\n            paths[y].push_back(Edge(x, d, c));\n        }\n\n        for(int i = 0; i < 35; ++i) {\n            for(int j = 0; j < 35; ++j) {\n                for(int k = 0; k < 35; ++k) {\n                    d[i][j][k]= INFINITY_HAHA;\n                }\n            }\n        }\n\n        double minimun_v = 0;\n        priority_queue< Status> Q;\n        for(int i = 0; i < paths[start_index].size(); ++i) {\n            Edge e = paths[start_index][i];\n            Q.push(Status(start_index, e.to, e.dist, 1));\n            d[start_index][e.to][1] = e.dist;\n        }\n\n        while(!Q.empty()) {\n            Status cs = Q.top();\n            Q.pop();\n \n            if(d[cs.from][cs.now][cs.speed] < cs.time) continue;\n\n            if(cs.now == end_index && cs.speed == 1) {\n                minimun_v = cs.time;\n                break;\n            }\n\n            for(int j = 0; j < paths[cs.now].size(); ++j) {\n                Edge s = paths[cs.now][j];\n                if(s.to == cs.from) continue;\n\n                for(int z = -1; z <= 1;#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int INFINITY_HAHA = 999999;\n\ntypedef struct edge\n{\n    int to, limit;\n    double dist;\n    edge(int x, double y, int z): to(x), dist(y), limit(z) {}\n} Edge;\n\n\ntypedef struct status {\n    int from, now, speed;\n    double time;\n    status(int x, int x2, double y, int z): from(x), now(x2), time(y), speed(z) {}\n    bool operator< (const status &b) const {\n        return time > b.time;\n    }\n} Status;\n\n\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n \n    int ncities, nroads;\n    double d[35][35][35];\n\n    while(scanf(\"%d%d\", &ncities, &nroads) != EOF && !(ncities == 0 && nroads == 0)) {\n\n        // Input\n        int start_index, end_index;\n        scanf(\"%d%d\" , &start_index, &end_index);\n\n        vector<Edge> paths[100]; // Array of vector\n        for(int n = 0; n < nroads; ++n) {\n            int x, y, d, c;\n            scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n            paths[x].push_back(Edge(y, d, c));\n            paths[y].push_back(Edge(x, d, c));\n        }\n\n        for(int i = 0; i < 35; ++i) {\n            for(int j = 0; j < 35; ++j) {\n                for(int k = 0; k < 35; ++k) {\n                    d[i][j][k]= INFINITY_HAHA;\n                }\n            }\n        }\n\n        double minimun_v = 0;\n        priority_queue< Status> Q;\n        for(int i = 0; i < paths[start_index].size(); ++i) {\n            Edge e = paths[start_index][i];\n            Q.push(Status(start_index, e.to, e.dist, 1));\n            d[start_index][e.to][1] = e.dist;\n        }\n\n        while(!Q.empty()) {\n            Status cs = Q.top();\n            Q.pop();\n \n            if(d[cs.from][cs.now][cs.speed] < cs.time) continue;\n\n            if(cs.now == end_index && cs.speed == 1) {\n                minimun_v = cs.time;\n                break;\n            }\n\n            for(int j = 0; j < paths[cs.now].size(); ++j) {\n                Edge s = paths[cs.now][j];\n                if(s.to == cs.from) continue;\n\n                for(int z = -1; z <= 1; ++z) {\n                    if(cs.speed + z > 0 && cs.speed + z <= s.limit) {\n                        double newdist = cs.time + s.dist/((double)(cs.speed + z));\n                        if(newdist < d[cs.now][s.to][cs.speed + z]) {\n                            d[cs.now][s.to][cs.speed + z] = newdist;\n                            Q.push(Status(cs.now, s.to, newdist, cs.speed + z));\n                        }\n                    }\n                }\n            }\n        }\n \n        if(minimun_v) {\n            printf(\"%0.5lf\\n\", minimun_v);\n        } else {\n            printf(\"unreachable\\n\");\n        }\n    }\n \n    return 0;\n}\n ++z) {\n                    if(cs.speed + z > 0 && cs.speed + z <= s.limit) {\n                        double newdist = cs.time + s.dist/((double)(cs.speed + z));\n                        if(newdist < d[cs.now][s.to][cs.speed + z]) {\n                            d[cs.now][s.to][cs.speed + z] = newdist;\n                            Q.push(Status(cs.now, s.to, newdist, cs.speed + z));\n                        }\n                    }\n                }\n            }\n        }\n \n        if(minimun_v) {\n            printf(\"%0.5lf\\n\", minimun_v);\n        } else {\n            printf(\"unreachable\\n\");\n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<cmath>\n#include<vector>\n#include<functional>\n#define ull unsigned long long int \n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define min_(a,b) ((a)<(b)?(a):(b))\nusing namespace std;\n\n#define INF 10000000\n#define MAX_V 1000 \nstruct edge{ int to; double time; };\nvector<edge>G[MAX_V];\ndouble d[MAX_V];\nstruct T{\n\tdouble time;\n\tint from, to;\n};\nint V,E,st,gl;\n\nstruct StructGreater {\n\tbool operator() (const T a, const T b) {\n\t\treturn a.time > b.time;\n\t}\n};\nvoid dk(int s){\n\tfill(d, d + MAX_V, INF);\n\tpriority_queue<T, vector<T>, StructGreater >que;\n\ts = s * 30 + 0;\n\t//d[s] = 0;\n\trep(i, 0, (int)G[s].size())\n\tif (G[s][i].to%30==0){\n\t\t//printf(\"to=%d,time=%f\\n\", G[s][i].to / 30 + 1, G[s][i].time);\n\t\tT t = { G[s][i].time, s / 30, G[s][i].to };\n\t\tque.push(t);\n\t\td[G[s][i].to] = G[s][i].time;\n\t}\n\t//T tx = { 0,-1, 0 };\n\t//que.push(tx);\n\twhile (!que.empty()){\n\t\tT t = que.top(); que.pop();\n\t\tint v = t.to;\n\n\t\tif (d[v] < t.time)continue;\n\t\trep(i, 0, (int)G[v].size()){\n\t\t\tedge e = G[v][i];\n\t//\t\tprintf(\"%d->%d,%d->%d,\\n\", v / 30 + 1, e.to / 30 + 1,v % 30 + 1, e.to % 30 + 1);\n\t\t\tif (e.to / 30 != t.from&&d[e.to]>d[v] + e.time){\n\t\t\t\td[e.to] = d[v] + e.time;\n\t//\t\t\tprintf(\"(%d<%d<%d)%d,%f\\n\", e.to / 30 + 1, t.to / 30 + 1, t.from + 1, e.to % 30 + 1,d[e.to]);\n\t\t\t\tT tmp = { d[e.to], v / 30, e.to };\n\t\t\t\tque.push(tmp);\n\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i, 0, MAX_V)if (d[i] < INF)\n\t\t//printf(\"to=%d,time=%f\\n\", i / 30 + 1, d[i]);\n}\n\nint main(void){\n\twhile (true){\n\t\tcin >> V >> E;\n\t\tif (V == 0)return 0;\n\t\tcin >> st >> gl;\n\t\tst--; gl--;\n\t\trep(i, 0, E){\n\t\t\tint first, second, lim;\n\t\t\tdouble length;\n\t\t\tcin >> first >> second >> length >> lim;\n\t\t\tfirst--;\n\t\t\tsecond--;\n\t\t//\tcout << first << second << endl;\n\t\t\trep(i, 1, 31){\n\t\t\t\tdouble real_v;\n\t\t\t\t//始点\n\t\t\t\tint f = first * 30 + i - 1;\n\t\t\t\tint s = second * 30 + i - 1;\n\t\t\t\trep(j, -1, 2){\n\t\t\t\t\treal_v = i + j;\n\t\t\t\t\t//cout << real_v << endl;\n\t\t\t\t\tif (real_v<1 || real_v>lim)continue;\n\t\t\t\t\treal_v = length / real_v;\n\t\t\t\t\tedge f_e = { f + j, real_v }; edge s_e = { s + j, real_v };\n\t\t\t\t//\tcout << first << second << gl<<endl;\n\t\t\t\t\tG[f].push_back(s_e); \n\t\t\t\t\tG[s].push_back(f_e);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*rep(i, 0, MAX_V)\n\t\t\trep(j, 0, (int)G[i].size()){\n\t\t\t\tprintf(\"from=%d,to=%d,v=%d->%d,time=%f\\n\", i / 30 + 1, G[i][j].to / 30 + 1, i % 30 + 1, G[i][j].to % 30 + 1, G[i][j].time);\n\n\t\t\t}\n*/\n\t\tdk(st);\n\t\tif (d[gl * 30]<4000)\n\t\tprintf(\"%.6f\\n\", d[gl * 30]);\n\t\telse cout << \"unreachable\" << endl;\n\t\trep(i, 0, MAX_V)\n\t\twhile (!G[i].empty())\n\t\t\t\tG[i].pop_back();\n\t\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nstruct P{\n  double t;\n  char v,p,pre;\n  P(){};\n  P(double T,int V,int pp,int PRE){\n    t=T;v=V;p=pp;pre=PRE;\n  };\n  bool operator<(const P &p)const{\n    return t>p.t;\n  }\n};\nstruct Path{\n  short d,c;\n  Path(){};\n  Path(int D,int C){ d=D;c=C;};\n};\n\nint main(){\n  int n,m;\n  int s,g;\n  int x,y,d,c;\n  Path path[30][30];\n  //priority_queue<P,vector<P>,greater<P> > q;\n  priority_queue<P> q;\n\n  while( cin>>n>>m && (n|m) ){\n    cin >> s >> g;\n    s--; g--;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tpath[i][j].d=-1.0; path[i][j].c=-1;\n      }\n\n    for( int i=0;i<m;i++ ){\n      cin >> x >> y >> d >> c;\n      x--;y--;\n      path[x][y].d=d; path[x][y].c=c;\n      path[y][x] = path[x][y];\n    }\n\n    double cost[30][35]; // place,velocity\n    int dv[3] = {-1,0,1};\n    for( int i=0;i<n;i++ ){\n      for( int j=1;j<31;j++ )\n\tcost[i][j] = DBL_MAX;\n    }\n\n    // 最短路の経過時間を求める  cost[i][0] を使う。\n    double minimum=DBL_MAX;\n    while( !q.empty() ) q.pop();\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      double nt = path[s][i].d;\n      q.push( P(nt,1,i,-1) );\n      cost[i][0] = nt;\n    }\n    while( !q.empty() ){\n      P p=q.top(); q.pop();\n      double t=p.t;\n      int v=p.v, np=p.p;\n      if( np==g ){\n\tminimum = t+1.0;\n\tbreak;\n      }\n      for( int i=0;i<n;i++ ){\n\tif( path[np][i].c<0 )continue;\n\tfor( int j=0;j<3;j++ ){\n\t  int nv = v + dv[j];\n\t  if( nv==0 ) continue;\n\t  if( nv>path[np][i].c ) continue;\n\t  double nCost = t+(double)path[np][i].d/nv;\n\t  if(cost[i][0]<nCost ) continue;\n\t  cost[i][0]=nCost;\n\t  q.push( P(nCost,nv,i,-1) );\n\t}\n      }\n    }\n\n    while( !q.empty() ) q.pop();\n\n\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      double nt = path[s][i].d;\n      q.push( P(nt,1,i,-1) );\n      cost[i][1] = nt;\n    }\n\n    while( !q.empty() ){\n      P p = q.top(); q.pop();\n      double t = p.t;\n      int v = p.v;\n      int np = p.p; // 現在地\n      int pre = p.pre;\n\n      if( t>cost[g][1] ) break;\n\n      /*\n      cout << \"v=\" << v << \" p=\" << np << \" pre=\" << pre \n\t   << \" t=\" << t << endl;\n      */\n\n      for( int i=0;i<n;i++ ){\n\tif( path[np][i].c<0 ) continue;// たどり着けないノード\n\tif( i==pre ) continue; // 前回のノード\n\n\tfor( int j=0;j<3;j++ ){\n\t  int nv = v + dv[j];\n\t  if( nv==0 ) continue;\n\t  if( nv>path[np][i].c ) continue;\n\t  double nCost = t + (double)path[np][i].d/nv;\n\t  if( cost[i][nv] < nCost ) continue;\n\t  cost[i][nv]=nCost;\n\t  if( cost[i][nv]>cost[g][1] ) continue;\n\t  if( cost[i][nv]>minimum ) continue;\n\t  if( i==g && nv==1 ) continue;\n\t  q.push( P(nCost,nv,i,np) );\n\t}\n      }\n\n    }\n    if( fabs(cost[g][1]-DBL_MAX)<1e-4 )\n      cout << \"unreachable\" << endl;\n    else\n      //      cout << cost[g][1] << endl;\n      printf(\"%.6lf\\n\",cost[g][1]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 31\n#define INF (1e9)\nusing namespace std;\ntypedef pair<double,int> P;\ntypedef  pair<P,int> PP;\nint n,m;\nvector<PP> G[N];\n\ndouble dijkstra(int s,int g){\n  vector<vector<double> >D(N,vector<double>(N,INF));\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  Q.push(PP(P(0,0),s));\n  D[s][0]=0;\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    double cost=t.first.first;\n    int v=t.first.second;\n    int pos=t.second;\n    if(D[pos][v]<cost)continue;\n    if(pos==g&&v==1) return cost;\n\n    for(int i=max(1,v-1);i<=v+1;i++){\n      for(int j=0;j<G[pos].size();j++){\n\tdouble ncost=cost+G[pos][j].first.first/i;\n\tint mxv=G[pos][j].first.second;\n\tint nx=G[pos][j].second;\n\tif(mxv<i||D[nx][i]<=ncost)continue;\n\tQ.push(PP(P(ncost,i),nx));\n\tD[nx][i]=ncost;\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    int s,g;\n    cin>>s>>g;s--,g--;\n\n    for(int i=0;i<n;i++)G[i].clear();\n    for(int i=0,a,b,d,c;i<m;i++){\n      cin>>a>>b>>d>>c;a--,b--;\n      G[a].push_back(PP(P(d,c),b));\n      G[b].push_back(PP(P(d,c),a));\n    }\n    double ans=dijkstra(s,g);\n    if(ans==-1) cout<<\"unreachable\"<<endl;\n    else printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://drken1215.hatenablog.com/entry/2018/07/18/214400\n//を参考\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\nconst int MAXN=30;\nconst int INF=1e9;\ndouble dp[MAXN+5][MAXN+5][MAXN+5];// 現在地点,直前の地点,今の速度\nint n,m;\ndouble ans=INF;\ntemplate<typename A,size_t N,typename T>\nvoid Fill(A (&array)[N],const T &val)\n{\n  std::fill( (T*)array,(T*)(array+N),val );\n}\n\nstruct State\n{\n  double cost;\n  int now,prev,speed;\n  State(double c,int n,int p,int s):cost(c),now(n),prev(p),speed(s){}//コスト,現在地,直前の地点,今の速度\n\n  bool operator < (State s)const \n  {\n    return s.cost<cost;\n  }\n};\n\nstruct Edge\n{\n  int to,dist,limit;\n  Edge(int t,int d,int l):to(t),dist(d),limit(l){}\n};\n\nvector<Edge> Graph[MAXN+5];\n\nint main(void)\n{\n  while(cin >> n >> m && n)\n    {\n      int s,t;\n      cin >> s >> t;\n      for (int i = 0; i <= MAXN; ++i)\n\t{\n\t  for (int j = 0; j <= MAXN; ++j)\n\t    {\n\t      for (int k = 0; k <= MAXN; ++k)\n\t\t{\n\t\t  dp[i][j][k]=INF;\n\t\t}\n\t    }\n\t}\n      for(int i=0;i<MAXN+5;i++)\n\t{\n\t  Graph[i].clear();\n\t}\n      for (int i = 0; i < m; ++i)\n\t{\n\t  int x,y,d,c;\n\t  cin >> x >> y >> d >> c;\n\t  Graph[x].push_back(Edge(y,d,c));\n\t  Graph[y].push_back(Edge(x,d,c));\n\t}\n      ans=INF;\n      priority_queue<State> que;//上のStateと持つ状態は同じ\n      que.push(State(0.0,s,0,1));\n      dp[s][0][1]=0.0;\n      while(!que.empty())\n\t{\n\t  auto state=que.top();que.pop();\n\t  int nowpoint=state.now;\n\t  int prevpoint=state.prev;\n\t  int nowspeed=state.speed;\n\t  double nowcost=state.cost;\n\t  for (int i = 0; i < int(Graph[nowpoint].size()); ++i)\n\t    {\n\t      for(int j=-1;j<=1;j++)\n\t\t{\n\t\t  if(prevpoint==0)\n\t\t    {\n\t\t      if(j==-1 || j==1) continue;\n\t\t    }\n\t\t  int nextspeed=nowspeed+j;\n\t\t  int nextpoint=Graph[nowpoint][i].to;\n\t\t  int nextlimit=Graph[nowpoint][i].limit;\n\t\t  double gocost=(double)Graph[nowpoint][i].dist/(double)nextspeed;\n\t\t  if(nextpoint==prevpoint) continue;\n\t\t  if(nextspeed>nextlimit) continue;\n\t\t  if(dp[nextpoint][nowpoint][nextspeed]>nowcost+gocost)\n\t\t    {\n\t\t      dp[nextpoint][nowpoint][nextspeed]=nowcost+gocost;\n\t\t      que.push(State(dp[nextpoint][nowpoint][nextspeed],nextpoint,nowpoint,nextspeed));\n\t\t    }\n\t\t}\n\t    }\n\t}\n      for (int i = 1; i <= n; ++i)\n\t{\n\t  if(dp[t][i][1]<ans) ans=dp[t][i][1];\n\t}\n      if(ans==INF) cout << \"unreachable\" << endl;\n      else cout << fixed << setprecision(12) << ans << endl;\n    }\n  return 0;\n \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst double eps = 1e-12;\nconst double inf = (double)(1<<24);\nconst int size = 31;\nint n, m;\n\nclass Node {\npublic:\n  double t;\n  int v, town, p;\n  bool operator < ( const Node right ) const {\n    return fabs( t - right.t ) < eps ? v < right.v : t > right.t;\n  }\n  Node() {}\n  Node( double t_, int v_, int town_, int p_ = -1 ) {\n    t = t_;\n    v = v_;\n    town = town_;\n    p = p_;\n  }\n};\n\n// for dijkstra\ntypedef priority_queue <Node, vector<Node>, less<Node> > QUEUE;\nbool P[size][size]; // path\ndouble MC[32][size]; // min cost\nint D[size][size]; // distance of path\nint L[size][size]; // speed limit of path\nint con[size][size]; // connnect\nint concnt[size];\n\n\nmap <int, int> T; // town number to index\nint TC; // the number of towns\n\nvoid reg( int town )\n{\n  if ( T.find( town ) != T.end() ) return;\n  T[town] = TC;\n  TC++;\n}\n\nvoid solve( int s_, int g_ )\n{\n  int start = T[s_], goal = T[g_];\n  if ( !P[start][goal] ) {\n    cout << \"unreachable\" << endl;\n    return;\n  }\n\n  QUEUE Q;\n  Node start_node( 0.0, 1, start, -1 );\n  Q.push( start_node );\n  MC[1][start] = 0.0;\n  \n  while ( !Q.empty() ) { \n    Node node = Q.top();\n    Q.pop();\n    double t = node.t;\n    int v = node.v;\n    int town = node.town;\n    int prev = node.p;\n\n    // cout << \"time=\" << t << \": town=\" << town << \", v=\" << v << endl;\n    if ( town == goal && v == 1 ) {\n      // cout << MC[v][town] << \",\" << t << endl;\n      printf( \"%.5f\\n\", t );\n      return;\n    }\n\n    // cout << \"test\" << endl;\n    for ( int i = 0; i < concnt[town]; i++ ) {\n      int next_town = con[town][i];\n      // debug\n      // cout << town << \" => \" << next_town << endl;\n      if ( prev != -1 && prev == next_town ) continue;\n      for ( int j = -1; j < 2; j++ ) {\n        if ( prev == -1 && j != 0 ) continue; \n        int next_v = v + j;\n        if ( next_v <= 0 || next_v > L[town][next_town] ) continue;\n\n        double next_t = t + (double)D[town][next_town] / next_v;\n        if ( next_t + eps > MC[next_v][next_town] ) continue;\n\n        Node next_node( next_t, next_v, next_town, town );\n        MC[next_v][next_town] = next_t;\n        Q.push( next_node );\n      }\n    }\n  }\n  \n  cout << \"unreachable\" << endl;\n}\n\nint main( void )\n{\n  while ( cin >> n >> m && n ) {\n    // init\n    for ( int i = 0; i < size; i++ ) {\n      T.clear();\n      TC = 0;\n      concnt[i] = 0;\n      for ( int j = 0; j < size; j++ ) {\n        P[i][j] = false;\n      }\n      for ( int j = 0; j < 32; j++ ) {\n        MC[i][j] = inf;\n      }\n    }\n\n    // input\n    int s, g;\n    cin >> s >> g;\n    for ( int i = 0; i < m; i++ ) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      reg(x);\n      reg(y);\n      int xi = T[x];\n      int yi = T[y];\n      // cout << x << \":\" << xi << \", \" << y << \":\" << yi << endl; // debug\n      P[xi][yi] = P[yi][xi] = true;\n      D[xi][yi] = D[yi][xi] = d;\n      L[xi][yi] = L[yi][xi] = c;\n      con[xi][concnt[xi]++] = yi;\n      con[yi][concnt[yi]++] = xi;\n    }\n\n    for ( int k = 0; k < n; k++ ) {\n      for ( int i = 0; i < n; i++ ) {\n        for ( int j = 0; j < n; j++ ) {\n          if ( !P[i][k] || !P[k][j] ) continue;\n          P[i][j] = true;\n        }\n      }\n    }\n\n    solve( s, g );\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n#define INF INT_MAX/3\n#define EPS 1e-14\n\ntypedef long long int lli;\ntypedef tuple<int,double,int> Road; // node/distance/limit\ntypedef tuple<double, int, int, int> Dat; \n  // time/current node/verocity/previous node\n\nconst int NMAX = 32, CMAX = 32;\ndouble dp[NMAX][CMAX];\nint n, m, s, g;\n\nint main() {\n  while (cin >> n >> m and n) {\n    cin >> s >> g;\n    vector<vector<Road>> G(n + 1);\n    REP(i, m) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      G[x].push_back(Road(y, d, c));\n      G[y].push_back(Road(x, d, c));\n    }\n    REP(i, NMAX) REP(j, CMAX) { dp[i][j] = INF; }\n    priority_queue<Dat,vector<Dat>, greater<Dat>> que;\n    que.push(Dat(0, s, 1, INF));\n    dp[s][1] = 0;\n    while (!que.empty()) {\n      Dat dat = que.top(); que.pop();\n      double cost = get<0>(dat);\n      int v = get<1>(dat), speed = get<2>(dat), from = get<3>(dat);\n      printf(\"(%d->%d, %fs,\\t%dm/s)\\n\", from, v, cost, speed);\n      if (cost > dp[v][speed]) continue;\n      for (Road r : G[v]) FOR(dv, -1, 2) {\n        int to = get<0>(r), limit = get<2>(r);\n        double dist = get<1>(r);\n        if (to == from or speed <= 0 or limit < speed) continue;\n        double newtime = dp[v][speed] + dist / speed;\n        if (dp[to][speed + dv] > newtime) {\n          dp[to][speed + dv] = newtime;\n          que.push(Dat(newtime, to, speed + dv, v));\n          printf(\"push (%d->%d, %fs,\\t%dm/s)\\n\", v, to, newtime, speed);\n        }\n      }\n    }\n    if (dp[g][0] > INF / 2) {\n      cout << \"unreachable\" << endl;\n    } else {\n      cout << fixed << setprecision(6) << dp[g][0] << endl;\n    }\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m;\nll s, g;\n\nclass DK {\npublic:\n\tstruct edge {\n\t\tint to;\n\t\tdouble cost;\n\t\tll cap;\n\t\tedge(int _to, double _cost, ll _cap) :to(_to), cost(_cost), cap(_cap) {}\n\t};\n\n\tdouble d[110][110];\n\tvector<edge> G[110];//各頂点からの辺\n\n\tvoid dijkstra() {\n\t\trep(i, 110)rep(j, 110)d[i][j] = INF;\n\t\td[s][0] = 0;\n\n\t\ttypedef pair<pair<double, ll>, ll> PP;\n\t\tpriority_queue<PP, vector<PP>, greater<PP>> que;\n\t\tque.push({ {0, 0},s });\n\n\t\twhile (!que.empty()) {\n\t\t\tPP p = que.top();\n\t\t\tque.pop();\n\t\t\tll nn = p.second;\n\t\t\tll v = p.first.second;\n\t\t\tif (d[nn][v] < p.first.first)continue;\n\t\t\tfor (int i = 0; i < G[nn].size(); i++) {\n\t\t\t\tedge e = G[nn][i];\n\t\t\t\tFOR(j, -1, 2) {\n\t\t\t\t\tdouble nv = v + j;\n\t\t\t\t\tif (nv <= 0)continue;\n\t\t\t\t\tif (nv > e.cap)continue;\n\t\t\t\t\tif (d[e.to][(ll)nv] > d[nn][v] + e.cost / nv) {\n\t\t\t\t\t\td[e.to][(ll)nv] = d[nn][v] + e.cost / nv;\n\t\t\t\t\t\tque.push({ {d[e.to][(ll)nv], nv},e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n};\n\nDK dk;\n\nint main() {\n\twhile (cin >> n >> m&&n + m) {\n\t\trep(i, 110)dk.G[i].clear();\n\t\tcin >> s >> g;\n\t\trep(i, m) {\n\t\t\tint x, y;\n\t\t\tll c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tdk.G[x].push_back(DK::edge(y, d, c));\n\t\t\tdk.G[y].push_back(DK::edge(x, d, c));\n\t\t}\n\t\tdk.dijkstra();\n\t\t//rep(i, n) {\n\t\t//\trep(j, 30) {\n\t\t//\t\tcout << dk.d[i + 1][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tdouble ans = dk.d[g][1];\n\t\tif ((ll)ans == INF)cout << \"unreachable\" << endl;\n\t\telse printf(\"%.10lf\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1000000\n\nusing namespace std;\n\nint n,m;\n\nstruct edge {\n\tint t;\n\tint dis;\n\tint lim;\n};\n\nstruct Point {\n\tint pos;\n\tdouble time;\n\tint speed;\n\tint pres;\n\n\tbool operator<(const Point& right) const {\n\t\treturn (time > right.time);\n\t}\n};\n\nint main(void) {\n\twhile (cin >> n >> m, n) {\n\t\tint s,g;\n\t\tcin >> s >> g;\n\n\t\tint x,y,d,c;\n\t\tvector< vector<edge> > adj(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tadj[x-1].push_back((edge){y-1,d,c});\n\t\t\tadj[y-1].push_back((edge){x-1,d,c});\n\t\t}\n\n\t\tpriority_queue<Point> pq;\n\t\tpq.push((Point){s-1,0,1,1});\n\t\tdouble dp[n][31];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < 31; ++j) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][1] = 0;\n\n\t\tbool find = false;\n\t\twhile (!pq.empty()) {\n\t\t\tPoint pn = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif (pn.pos == g-1 && pn.speed == 1 && pn.pres == 1) {\n\t\t\t\tprintf(\"%llf\\n\",pn.time);\n\t\t\t\tfind = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (size_t i = 0; i < adj[pn.pos].size(); ++i) {\n\t\t\t\tdouble rt = ((double)adj[pn.pos][i].dis/pn.speed);\n\t\t\t\tif (pn.time + rt < dp[adj[pn.pos][i].t][pn.speed] && pn.speed <= adj[pn.pos][i].lim) {\n\t\t\t\t\tdp[adj[pn.pos][i].t][pn.speed] = pn.time + rt;\n\t\t\t\t\tpq.push((Point){adj[pn.pos][i].t,pn.time+rt,pn.speed,pn.speed});\n\t\t\t\t\tif (pn.speed != 30) {\n\t\t\t\t\t\tpq.push((Point){adj[pn.pos][i].t,pn.time+rt,pn.speed+1,pn.speed});\n\t\t\t\t\t}\n\t\t\t\t\tif (pn.speed != 1) {\n\t\t\t\t\t\tpq.push((Point){adj[pn.pos][i].t,pn.time+rt,pn.speed-1,pn.speed});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!find) {\n\t\t\tcout << \"unreachable\" <<  endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nusing tp = tuple<int, int, int>;\nusing ttp = tuple<ld, int, int>;\n\nconst ld INF = 1e20;\n\nint main()\n{\n\tcout << fixed << setprecision(8);\n\tint n, m;\n\twhile (cin >> n >> m, n | m) {\n\t\tint s, g;\n\t\tcin >> s >> g; s--, g--;\n\t\tvector<vector<tp>> G(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c; x--, y--;\n\t\t\tG[x].emplace_back(y, d, c);\n\t\t}\n\t\tvector<vector<ld>> d(n, vector<ld>(31, INF));\n\t\tpriority_queue<ttp, vector<ttp>, greater<ttp>> pq;\n\t\tpq.emplace(0.0, s, 1);\n\t\twhile (!pq.empty()) {\n\t\t\tauto p = pq.top(); pq.pop();\n\t\t\tint v = get<1>(p), ve = get<2>(p);\n\t\t\tld cos = get<0>(p);\n\t\t\tif (d[v][ve] != INF) continue;\n\t\t\td[v][ve] = cos;\n\t\t\tfor (auto e : G[v]) {\n\t\t\t\tint to = get<0>(e), st = get<2>(e);\n\t\t\t\tld dis = get<1>(e);\n\t\t\t\tif (cos == 0.0) {\n\t\t\t\t\tif (d[to][ve] == INF) {\n\t\t\t\t\t\tpq.emplace(cos + dis / ve, to, ve);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int i = -1; i <= 1; i++) if (0 < ve + i && ve + i <= st) {\n\t\t\t\t\t\tif (d[to][ve + i] == INF) {\n\t\t\t\t\t\t\tpq.emplace(cos + dis / (ve + i), to, ve + i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[g][1] == INF) cout << \"unreachable\" << endl;\n\t\telse cout << d[g][1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<double, int, int, int> T;\n \nconst ll MOD=1e9+7;\n//const ll INF=1e18;\n\nconst double INF = 1000000.0;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\nstruct edge{ int to,d,c;};\n\n\n\nint n,m,s,g;\ndouble d[35][35][35];\ndouble mind;\n\nint main(){\n\twhile(true){\n\t\tcin >> n >> m;\n\t\tif(n + m == 0) break;\n\t\tcin >> s >> g;\n\t\tmind = INF;\n\t\tvector<edge> G[35];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a1,a2,a3,a4;\n\t\t\tcin >> a1 >> a2 >> a3 >> a4;\n\t\t\tedge tmp1 = {a2,a3,a4};\n\t\t\tG[a1].push_back(tmp1);\n\t\t\tedge tmp2 = {a1,a3,a4};\n\t\t\tG[a2].push_back(tmp2);\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tfor(int k = 0;k <= 31;k++){\n\t\t\t\t\td[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<T> que;\n\t\tfor(int i = 0;i < G[s].size();i++){\n\t\t\tedge e = G[s][i];\n\t\t\td[s][e.to][1] = (double) e.d;\n\t\t\tque.push(make_tuple((double)e.d,1,s,e.to));\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tT t = que.front(); que.pop();\n\t\t\tdouble a1 = get<0>(t);\n\t\t\tint a2 = get<1>(t),a3 = get<2>(t),a4 = get<3>(t);\n\t\t\tif(d[a3][a4][a2] < a1 || a1 > mind)continue;\n\t\t\tfor(int i = 0;i < G[a4].size();i++){\n\t\t\t\tedge e = G[a4][i];\n\t\t\t\tif(e.to == a3) continue;\n\t\t\t\tfor(int j = -1;j <= 1;j++){\n\t\t\t\t\tint v = a2 + j;\n\t\t\t\t\tdouble tmp = (double)( a1 + (double)e.d / (double)v);\n\t\t\t//\t\tif(a4 == 5 && e.to == 6 && v == 1) cout << \"tmp\" << tmp << \",a1\" << a1 <<endl;\n\t\t\t\t\tif(v <= 0 || v > e.c || d[a4][e.to][v] < tmp ||tmp > mind) continue;\n\t\t\t\t\td[a4][e.to][v] =  tmp;\n\t\t\t\t\tif(e.to == g && v == 1 && mind > tmp)mind = tmp;\n\t\t\t//\t\tque.push(make_tuple(tmp,v,a4,e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\n\t\t}\n\t//\tcout << \"ans\" << d[4][5][2] << endl;\n\n\n\n\t\tdouble ans = INF;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tdouble tmp = d[i][g][1];\n\t\t\tif(ans > tmp) ans = tmp;\n\t\t//\tans = min(ans,d[i][g][1]);\n\t\t}\n\t\tif(ans == INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t//\tcout << ans << endl;\n\t\t\tprintf(\"%lf\",ans);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nstruct State {\n    int i, prev, sp; double cost;\n};\n\nbool operator>(const State& a, const State& b)\n{\n    return a.cost > b.cost;\n}\n\nconst double INF = 1<<29;\n\nint main()\n{\n    while (1) {\n        int n, m, s, g; cin >> n >> m >> s >> g;\n        if (!n) break;\n        s--, g--;\n\n        vector<vector<double>> dist(n, vector<double>(n, INF));\n        vector<vector<int>> lim(n, vector<int>(n));\n\n        while (m--) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--, y--;\n            dist[x][y] = dist[y][x] = d;\n            lim[x][y] = lim[y][x] = c;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> Q;\n        Q.push({ s, -1, 0, 0 });\n\n        pair<int, int> debug[40][40];\n\n        int vis[40][40][40] = {};\n        double ans = INF;\n        while (Q.size()) {\n            auto e = Q.top(); Q.pop();\n            if (vis[e.i][e.sp][e.prev]) continue;\n            vis[e.i][e.sp][e.prev] = 1;\n            if (e.i == g && e.sp == 1) ans = min(ans, e.cost);\n            loop (n, i) loop (3, d) {\n                int sp = e.sp-1+d;\n                if (dist[e.i][i] == INF || i == e.prev ||\n                        sp < 1 || sp > lim[e.i][i]) continue;\n                Q.push({ i, e.i, sp, e.cost + dist[e.i][i] / sp });\n            }\n        }\n        if (ans != INF) cout << ans << endl;\n        else cout << \"unreachable\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef double Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  int c;                        // c ÍOtÅÍ§À¬xAqueue ÅÍ¬x\n  Edge(int src, int dst, Weight weight, int c) :\n    src(src), dst(dst), weight(weight), c(c){ }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src :\n    e.dst != f.dst ? e.dst < f.dst : e.c < f.c;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef pair<int,int> pii;\n\ndouble dijkstra(const Graph &g, int s, int t) {\n  int n = g.size();\n  double dist[n][n][32];           // dist[i][j][k] = Xs[h k ÌóÔÅ j ©ç i ÉÂ­ÅZ£\n  REP(i,n) REP(j,n) REP(k,32) dist[i][j][k] = INF;\n  // pii prev[n][32];           // dist[i][j] = Xs[h j ÌóÔÅ i ÉÂ­ÅZ£\n  // prev[s][0] = pii(-1,0);\n  priority_queue<Edge> Q;\n  Q.push(Edge(s,s,0,0));\n  while(!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    //printf(\"%d->%d %f %d\\n\",e.src,e.dst,e.weight,e.c);\n    if (e.dst == t && e.c == 1) break;\n    REP(k,3) {\n      int v = e.c - 1 + k;\n      if (v<=0) continue;\n      if (dist[e.dst][e.src][v] < e.weight) continue;\n      FOR(f, g[e.dst]) {\n        if (v > f->c) continue;\n        if (f->dst == e.src) continue;\n        double hoge = e.weight + f->weight / v;\n        if (dist[f->dst][f->src][v] > hoge) {\n          //prev[f->dst][f->src][v] = pii(f->src,e.c);\n          dist[f->dst][f->src][v] = hoge;\n          Q.push(Edge(f->src, f->dst, hoge, v));\n        }\n      }\n    }\n  }\n  // pii hoge = pii(t,1);\n  // while(hoge.first >= 0) {\n  //   cout <<hoge.first<< \" \" << hoge.second << endl;\n  //   hoge = prev[hoge.first][hoge.second];\n  // }\n  double res = INF;\n  REP(i,n)\n    res = min(res, dist[t][i][1]);\n  return res;\n}\n\nint main() {\n  int n,m;\n  while(cin >> n>>m,n||m) {\n    int s,t;\n    cin >> s >> t;\n    s--;t--;\n    Graph g(n);\n    REP(i,m) {\n      int x,y,d,c;\n      cin >> x>>y>>d>>c;\n      x--;y--;\n      g[x].push_back(Edge(x,y,d,c));\n      g[y].push_back(Edge(y,x,d,c));\n    }\n    double res = dijkstra(g,s,t);\n    if (res == INF)\n      cout << \"unreachable\" << endl;\n    else\n      printf(\"%.5f\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\n#define INF 1e9\n\nint main(void){\n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    // ??????????????¨??´??????\n    int s, g;\n    cin >> s >> g;\n    --s; --g;\n\n    // ???????????±???????????????\n    int x, y, d, c;\n    vector<vector<pair<int, pair<int, int> > > > adjlist(n);\n    for(int i = 0; i < m; i++){\n      cin >> x >> y >> d >> c;\n      --x; --y;\n      adjlist[x].push_back(make_pair(y, make_pair(d, c)));\n      adjlist[y].push_back(make_pair(x, make_pair(d, c)));\n    }\n\n    // ????????????????????????\n    const int MAX_SPEED = 30;\n    const int acc[3] = {-1, 0, 1};\n    vector<vector<double> > result(n, vector<double>(MAX_SPEED + 1, INF));\n    priority_queue<pair<double, pair<pair<int, int>, int> > > wait;\n    wait.push(make_pair(0, make_pair(make_pair(0, s), -1)));\n    result[s][0] = 0;\n\n    while(!wait.empty()){\n      double nowcost = -wait.top().first;\n      int nowspeed = wait.top().second.first.first;\n      int nowpoint = wait.top().second.first.second;\n      int beforepoint = wait.top().second.second;\n      wait.pop();\n      if(result[nowpoint][nowspeed] < nowcost){ continue; }\n\n      for(int i = 0; i < adjlist[nowpoint].size(); i++){\n        int nextpoint = adjlist[nowpoint][i].first;\n        // U??????????????¢\n        if(nextpoint == beforepoint){ continue; }\n        int speedlimit = adjlist[nowpoint][i].second.second;\n        for(int j = 0; j < 3; j++){\n          int nextspeed = nowspeed + acc[j];\n          // ??¢??????????????¢?????¶????????????????????¢\n          if(nextspeed <= 0 || speedlimit < nextspeed){ continue; }\n          double nextcost = nowcost + ((double)adjlist[nowpoint][i].second.first / nextspeed);\n          if(result[nextpoint][nextspeed] > nextcost){\n            result[nextpoint][nextspeed] = nextcost;\n            wait.push(make_pair(-nextcost, make_pair(make_pair(nextspeed, nextpoint), nowpoint)));\n          }\n        }\n      }\n    }\n    \n    // ???????????????\n    if(result[g][1] == INF){ cout << \"unreachable\" << endl; }\n    else{ printf(\"%.5f\\n\", result[g][1]); } \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1e9\nusing namespace std;\ndouble cost[30][30][31]; int d[30][30],c[30][30],v[30][30][31];\nclass S{\npublic:\n\tdouble cc;int c,p,v;\n\tS(double cc,int c,int p,int v):cc(cc),c(c),p(p),v(v){}\n\tbool operator<(const S &a)const{\n\t\treturn cc>a.cc;\n\t}\n};\nint main(){\n\tint n,m,s,g,x,y,a,b; double nc;\n\twhile(scanf(\"%d%d\",&n,&m),n){\n\t\tscanf(\"%d%d\",&s,&g),s--,g--;\n\t\trep(i,n)rep(j,n){\n\t\t\trep(k,31)cost[i][j][k]=INF,v[i][j][k]=0;\n\t\t\td[i][j]=c[i][j]=0;\n\t\t}\n\t\trep(i,m)scanf(\"%d%d%d%d\",&x,&y,&a,&b),\n\t\tx--,y--,d[x][y]=d[y][x]=a,c[x][y]=c[y][x]=b;\n\t\tpriority_queue<S> F; F.push(S(0,s,s,0)); cost[s][s][0]=0;\n\t\twhile(!F.empty()){\n\t\t\tS cs=F.top(); F.pop();\n\t\t\tv[cs.c][cs.p][cs.v]=1;\n\t\t\tif(cs.c==g&&cs.v==1){\n\t\t\t\tprintf(\"%.5f\\n\",cs.cc); goto END;\n\t\t\t}\n\t\t\trep(i,n)if(i!=cs.p&&d[cs.c][i])\n\t\t\tfor(int dv=-1;dv<2;dv++)if(!v[i][cs.c][dv+cs.v]&&0<dv+cs.v&&dv+cs.v<=c[cs.c][i]){\n\t\t\t\tnc=cost[cs.c][cs.p][cs.v]+1.*d[cs.c][i]/(dv+cs.v);\n\t\t\t\tif(cost[i][cs.c][dv+cs.v]>nc)\n\t\t\t\tcost[i][cs.c][dv+cs.v]=nc,F.push(S(nc,i,cs.c,dv+cs.v));\n\t\t\t}\n\t\t}\n\t\tprintf(\"unreachable\\n\"); END:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000.0\n#define EPS 1e-8\nusing namespace std;\nstruct state { int n, v, l; double t; };\n\nint N, M, S, G;\nvector<int> T[31], D[31], C[31];\nint vd[3] = { -1, 0, 1 };\ndouble dp[31][51];\n\nclass Compare {\npublic:\n  bool operator() (struct state a, struct state b) {\n    return a.t > b.t;\n  }\n};\n\nint main(void) {\n  while(cin >> N >> M, N) {\n    cin >> S >> G;\n    REP(i, 0, 30) {\n      T[i].clear();\n      D[i].clear();\n      C[i].clear();\n    }\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      T[x].push_back(y); D[x].push_back(d); C[x].push_back(c);\n      T[y].push_back(x); D[y].push_back(d); C[y].push_back(c);\n    }\n\n    REP(i, 1, N) REP(j, 0, 50) dp[i][j] = INF;\n\n    priority_queue<struct state, vector<struct state>, Compare> q;\n    struct state first = { S, 0, -1, 0.0 };\n    q.push(first);\n\n    while(!q.empty()) {\n      struct state c = q.top();\n      q.pop();\n\n      // cout << c.n << \" \" << c.v << \" \" << c.t << endl;\n\n      dp[c.n][c.v] = min(dp[c.n][c.v], c.t);\n      if(c.n == G && c.v == 1) break;\n\n      for(int i = 0; i < T[c.n].size(); i++) {\n        if(T[c.n][i] == c.l) continue;\n        REP(j, 0, 3) {\n          int v = c.v + vd[j];\n          if(v <= 0 || C[c.n][i] < v) continue;\n          double t = c.t + ((double) D[c.n][i] / v);\n          struct state n = { T[c.n][i], v, c.n, t };\n          if(n.t < dp[n.n][n.v] - EPS) q.push(n);\n        }\n      }\n    }\n\n    if(dp[G][1] < INF) printf(\"%.6f\\n\", dp[G][1]);\n    else cout << \"unreachable\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct road {\n  int from, to, d, c;\n  road(int x, int y, int z, int w) : from(x), to(y), d(z), c(w) {}\n};\n\n\nstruct state {\n  int node;\n  int v;\n  double time;\n  state(int a, int b, double c) : node(a), v(b), time(c) {}\n\n  bool operator<(const state& s) const\n  {\n    return time > s.time;\n  }\n};\n\nint main()\n{\n  int n, m;\n  while (cin >> n >> m && n != 0) {\n    int start, goal;\n    cin >> start >> goal;\n    start--;  goal--;\n\n    vector<vector<road> > g(n);\n    for (int i = 0; i < m; i++) {\n      int u, v, d, c;\n      cin >> u >> v >> d >> c;\n      u--;  v--;\n      g[u].push_back(road(u, v, d, c));\n    }\n\n    priority_queue<state> q;\n    q.push(state(start, 0, 0.0));\n    vector<vector<double> > costs(n, vector<double>(32, 1e10));\n    costs[0][0] = 0;\n    while (!q.empty()) {\n      state s = q.top();\n      q.pop();\n\n      if (s.node == goal) {\n        if (s.v == 1) {\n          cout << s.time << endl;\n          goto NEXT;\n        }\n      }\n\n      for (int i = 0; i < g[s.node].size(); i++) {\n        const road r = g[s.node][i];\n        for (int dv = -1; dv <= 1; dv++) {\n          const int v = s.v + dv;\n          if (v <= 0 || v > r.c) {\n            continue;\n          }\n          double c = double(r.d) / v;\n          if (s.time + c < costs[r.to][v]) {\n            costs[r.to][v] = s.time + c;\n            q.push(state(r.to, v, s.time + c));\n          }\n        }\n      }\n    }\n    cout << \"unreachable\" << endl;\nNEXT:\n    ;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, P> P3;\nconst ll MOD = ll(1e9+7);\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(3e5 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nstruct edge{\n    int to, c;\n    double d;\n};\n\nint n, m, s, g;\nvector<vector<edge> > G;\ndouble tmin[35][35];  // 頂点iに速さjで到着するときの最短時間\n\nvoid dijkstra(){\n    REP(i,n)fill(tmin[i],tmin[i]+35,IINF);\n    priority_queue<P3, vector<P3>, greater<P3> > que;\n    tmin[s][0] = 0.0;\n    que.push({0.0,{s,0}});\n    while(!que.empty()){\n        P3 p = que.top();\n        que.pop();\n        int from = p.second.first, v = p.second.second;\n        if(p.first > tmin[from][v] + EPS)continue;\n        for(auto &e : G[from]){\n            for(int dv=-1; dv<=1; dv++){\n                int nv = v+dv;\n                if(nv<=0 || nv>e.c)continue;\n                if(tmin[e.to][nv] > tmin[from][v] + e.d/double(nv) + EPS){\n                    tmin[e.to][nv] = tmin[from][v] + e.d/double(nv);\n                    que.push({tmin[e.to][nv],{e.to,nv}});\n                }\n            }\n        }\n    }\n}\n\n\nint main() {\n    while(cin >> n >> m, n){\n        cin >> s >> g;\n        s--; g--;\n        G.clear();\n        G.resize(n);\n        REP(i,m){\n            int x, y, c;\n            double d;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            G[x].push_back({y,c,d});\n            G[y].push_back({x,c,d});\n        }\n        dijkstra();\n        if(tmin[g][1]<IINF/2){\n            printf(\"%.8lf\\n\",tmin[g][1]);\n        }\n        else{\n            cout << \"unreachable\" << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1162&lang=jp\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n#include<iomanip>\n#include<queue>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nconst double INF = 10e9; \n\nstruct state\n{\n\tint pos, prev, speed;\n\tdouble time;\n\tstate(int p, int pr, int sp, double t)\n\t\t:pos(p), prev(pr), speed(sp), time(t) {}\n\n\tbool operator<(const state& s) const {\n\t\treturn time > s.time;\n\t}\n};\n\nstruct edge\n{\n\tint to, cost, limit;\n\tedge(int t, int c, int l) : to(t), cost(c), limit(l) {}\n};\n\nvector<vector<edge>> graph;\ndouble dp[31][31][31];//[pos][prev][speed] = time\n\ndouble dijkstra( int s, int g )\n{\n\tdouble res=-1.0;\n\tfill_n((double *)dp, sizeof(dp) / sizeof(double), INF);\n\t\n\tpriority_queue<state> pq;\n\trep( i, graph[s].size()){\n\t\tedge e = graph[s][i];\n\t\tpq.push( state( e.to, s, 1, e.cost ) );\n\t\tdp[e.to][s][1] = e.cost;\n\t}\n\n\twhile( !pq.empty() )\n\t{\n\t\tstate st = pq.top();\n\t\tpq.pop();\n\n\t\tif( dp[st.pos][st.prev][st.speed] != st.time){\n\t\t\tcontinue;\n\t\t}\n\n\t\tif( st.pos == g && st.speed == 1){\n\t\t\tres = st.time;\n\t\t\treturn res;\n\t\t}\n\n\t\trep( i, graph[st.pos].size() )\n\t\t{\n\t\t\tedge e = graph[st.pos][i];\n\t\t\tif( e.to == st.prev ){ continue; } //Uターンは禁止\n\t\t\tREP( j, -1, 2 )\n\t\t\t{ \n\t\t\t\tif( st.speed + j > 0 && st.speed + j <= e.limit ){ \n\t\t\t\t\tdouble time = st.time + (double)e.cost / (st.speed + j);\n\t\t\t\t\tif( dp[e.to][st.pos][st.speed + j] > time){\n\t\t\t\t\t\tdp[e.to][st.pos][st.speed + j] = time;\n\t\t\t\t\t\tpq.push( state( e.to, st.pos, st.speed + j, time ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcout << setprecision(6) << fixed;\n\tint n,m,s,g;\n\twhile( cin >> n >> m, n )\n\t{\n\t\tgraph = vector<vector<edge>>( n+1 );\n\t\tcin >> s >> g;\n\t\t\n\t\tint x,y,d,c;\n\t\trep( i, m )\n\t\t{\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tgraph[x].push_back( edge(y,d,c) );\n\t\t\tgraph[y].push_back( edge(x,d,c) );\n\t\t}\n\n\t\tdouble ans = dijkstra( s, g );\n\t\tif(ans < 0){\n\t\t\tcout << \"unreachable\" << endl;\t\t\t\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ntypedef pair<pair<double,int> ,pair<int,int> > ppi;\nvector<pair<pair<double,int>,int> > vp[31];\nint dv[]={-1,0,1};\ndouble d[31][32];\ndouble INF=1000100010;\nint m,n,s,g;\ndouble dijkstra(){\n    priority_queue<ppi,vector<ppi>,greater<ppi> > pq;\n    rep(i,n)rep(j,32) d[i][j]=INF;\n    d[s][1]=0.0;\n    pq.push({{0.0,-1},{1,s}});\n    while(!pq.empty()){\n        ppi pi=pq.top();pq.pop();\n        int t=pi.second.second;\n        int u=pi.second.first;\n        double cost=pi.first.first;\n        if(t==g&&u==0) return cost;\n        for(auto it:vp[t]){\n            if(it.second==pi.first.second) continue;\n            int lm=it.first.second;\n            double dist=it.first.first;\n            if(lm<u||u<=0) continue;\n            rep(i,3){\n                int tv=u+dv[i];\n                if(d[it.second][tv]>cost+dist/u){\n                    d[it.second][tv]=cost+dist/u;\n                    pq.push({{d[it.second][tv],t},{tv,it.second}});\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    while(cin>>n>>m,n|m){\n        rep(i,n) vp[i].clear();\n        cin>>s>>g;\n        --s,--g;\n        int x,y,ci;\n        double di;\n        rep(i,m){\n            cin>>x>>y>>di>>ci;\n            --x,--y;\n            vp[x].pb(make_pair(di,ci),y);\n            vp[y].pb(make_pair(di,ci),x);\n        }\n        double ans=dijkstra();\n        if(ans==-1)cout<<\"unreachable\"<<endl;\n        else cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\nconst int MAX_V = 101;\nconst int MAX_SPEED = 31;\nconst double INF = 1e9;\n\nint n,m;\nint ds[]={-1,0,1};\n\nstruct edge{\n\tint to;\n\tdouble dist, speed;\n\tedge(int t_to,double t_dist,double t_speed){\n\t\tto=t_to;dist=t_dist;speed=t_speed;\n\t}\n};\n\nstruct state{\n\tdouble cost,speed;\n\tint v;\n\tstate(double t_cost,int t_v,double t_speed){\n\t\tcost=t_cost;v=t_v;speed=t_speed;\n\t}\n\tbool operator>(const state& s)const{\n\t\treturn cost > s.cost;\n\t}\n};\n\n\nvector< vector<edge> > G(MAX_V);\ndouble d[MAX_V][MAX_SPEED];\n\nvoid dijkstra(int s){\n\tpriority_queue<state,vector<state>,greater<state> > que;\n\tfill_n((double *)d, sizeof(d)/sizeof(double),INF);\n\td[s][0] = 0.0;\n\tque.push(state(0.0,s,0.0));\n\n\n\twhile(!que.empty()){\n\t\tstate p = que.top(); que.pop();\n\t\tint v = p.v;\n\t\tif(d[v][(int)p.speed]<p.cost) continue;\n\t\trep(i,G[v].size()){\n\t\t\tedge e = G[v][i];\n\t\t\trep(j,3){\n\t\t\t\tdouble p_s=(p.speed+ds[j]);\n\t\t\t\tif(p_s > 0 && e.speed >= p_s && d[e.to][(int)p_s] > d[v][(int)p.speed] + (e.dist/p_s)){\n\t\t\t\t\n\t\t\t\t\td[e.to][(int)p_s] = d[v][(int)p.speed] + (e.dist/p_s);\n\t\t\t\t\tque.push(state(d[e.to][(int)p_s],e.to,p_s));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\t\n\tcout << fixed << setprecision(5) << endl;\n\twhile(1){\n\n\t\tG.clear();\n\t\tG.resize(MAX_V);\n\n\t\tint s,g;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\tcin >> s >> g;\n\t\ts--;g--;\n\t\trep(i,m){\n\t\t\tint a,b;\n\t\t\tdouble d,c;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--;b--;\n\t\t\tedge tmp1(b,d,c);\n\t\t\tedge tmp2(a,d,c);\n\t\t\tG[a].push_back(tmp1);\n\t\t\tG[b].push_back(tmp2);\n\t\t}\n\n\t\tdijkstra(s);\n\n\t\tif(d[g][1]==INF) cout << \"unreachable\" << endl;\n\t\telse cout << d[g][1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\n\nconst double INF = 1e9;\n\nint n, m, s, g;\n\n// [n][prev][v];\ndouble dp[32][32][32];\n\nstruct edge {\n\tint to, c;\n\tdouble length;\n\n\tedge(int to, int c, double l) :to(to), c(c), length(l){\n\t}\n};\n\nvector<edge> G[32];\n\nstruct state {\n\tint n, prev, v;\n\tdouble time;\n\n\tstate(int n, int prev, int v, double time) :n(n), prev(prev),v(v), time(time){\n\t}\n};\n\nint main(){\n\twhile(cin >> n >> m , n | m) {\n\t\tcin >> s >> g;\n\n\t\tfor(int i = 0; i < 32; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint x, y, c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tG[x].push_back(edge(y, c, d));\n\t\t\tG[y].push_back(edge(x, c, d));\n\t\t}\n\n\t\tfor(int i = 0; i < 31; i++) {\n\t\t\tfor(int j = 0; j < 31; j++) {\n\t\t\t\tfor(int k = 0; k < 31; k++) {\n\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<state> q;\n\t\tq.push(state(s, -1, 1, 0.0));\n\t\twhile(!q.empty()) {\n\t\t\tstate s = q.front();\n\t\t\tq.pop();\n\t\t\tif(s.prev != -1 && dp[s.n][s.prev][s.v] <= s.time) continue;\n\t\t\tif(s.prev != -1)\n\t\t\t\tdp[s.n][s.prev][s.v] = s.time;\n\t\t\tint dv[] = {0, 1, -1};\n\t\t\tfor(int i = 0; i < G[s.n].size(); i++) {\n\t\t\t\tfor(int j = 0; j < ((s.prev == -1) ? 1 : 3); j++) {\n\t\t\t\t\tint nv = s.v + dv[j];\n\t\t\t\t\tif(nv > 0 && nv <= G[s.n][i].c && G[s.n][i].to != s.prev)\n\t\t\t\t\t\tq.push(state(G[s.n][i].to, s.n, nv, s.time + G[s.n][i].length / nv));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = INF;\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tans = min(ans, dp[g][i][1]);\n\t\t}\n\t\tif(ans == INF)\n\t\t\tcout << \"unreachable\" << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n/** Problem1162 : Discrete Speed **/\nconst int MAX_V = 30, MAX_C = 31;\nint N, M;\ndouble d[MAX_V][MAX_C];\n\nstruct Node {\n\tint c, v; double time;\n\tNode (double _t, int _v, int _c) : v(_v), c(_c), time(_t){}\n\tbool operator<(const Node &n)const{return time>n.time;}\n};\n\nstruct Edge {\n\tint to, cost, lim;\n\tEdge(int t, int c, int l) :  to(t), cost(c), lim(l){}\n};\nvector<Edge> G[MAX_V];\n\nint tmp[] = {-1, 0, 1};\n\nvoid dijkstra(int s)\n{\n\tpriority_queue<Node> Q;\n\t\n\tfill(d[0], d[0]+MAX_V*MAX_C, INF);\n\td[s][1] = d[s][0] = 0;\n\tQ.push(Node(0, s, 0));\n\t\n\twhile (Q.size()) {\n\t\tNode n = Q.top(); Q.pop();\n\t\tint v = n.v, c = n.c;\n\t\t//cerr << \"(\" << v+1 << \", \" << c << \", \" << n.time << \")\" << endl;\n\t\t\n#if 0\n\t\tbool ok=true;\n\t\tfor (int cc=0; cc<c; cc++) {\n\t\t\tif (d[v][cc] < n.time) ok=false;\n\t\t}\n\t\tif (!ok) continue;\n#endif\n\t\tif (d[v][c] < n.time) continue;\n\t\t\n\t\tfor (int i=0; i<G[v].size(); i++) {\n\t\t\tEdge e = G[v][i];\n\t\t\t\n\t\t\tfor (int j=0; j<3; j++) {\n\t\t\t\tint nc = c+tmp[j];\n\t\t\t\tif (nc>G[v][i].lim) continue;\n\n\t\t\t\tif (0<nc && nc<=30) {\n\t\t\t\t\tif (d[e.to][nc] > d[v][c] + (double)e.cost/nc) {\n\t\t\t\t\t\td[e.to][nc] = d[v][c] + (double)e.cost/nc;\n\t\t\t\t\t\tQ.push(Node(d[e.to][nc], e.to, nc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (cin>>N>>M, N||M) {\n\t\trep(i, MAX_V) G[i].clear();\n\t\tint s, g; cin>>s>>g; s--, g--;\n\t\t\n\t\trep(i, M) {\n\t\t\tint x, y, d, c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tG[x-1].push_back(Edge(y-1, d, c));\n\t\t\tG[y-1].push_back(Edge(x-1, d, c));\n\t\t}\n\t\t\n\t\tdijkstra(s);\n\t\t\n\t\tdouble ans = d[g][1];\n\t\t\n\t\tif (ans < INF) {\n\t\t\tcout << fixed << setprecision(5);\n\t\t\tcout << ans << endl;\n\t\t} else {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1162\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1162&lang=jp\n\n#include <iostream>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\nconst double inf = (double)(1<<24);\n\nclass Node {\npublic:\n    double time;\n    int v, town, prev;\n    Node() {}\n    Node( double time_, int v_, int town_, int prev_ ) \n    {\n        time = time_;\n        v = v_;\n        town = town_;\n        prev = prev_;\n    }\n    bool operator < ( const Node& right ) const \n    {\n        return time > right.time;\n    }\n    bool operator > ( const Node& right ) const\n    {\n        return time < right.time;\n    }\n    bool operator == ( const Node& right ) const\n    {\n        return v == right.v && town == right.town && prev == right.prev;\n    }\n};\ntypedef priority_queue <Node> QUEUE;\nconst int size = 31;\n\nint n, m;\nbool P[size][size];\ndouble G[size][size];\ndouble MC[size][size][size];\nint L[size][size];\nint CN[size][size];\nint CN_count[size];\n\n// dijkstra\nvoid solve( int start, int goal )\n{\n    // init\n    QUEUE Q;\n    Node start_node( 0.0, 1, start, -1 );\n    Q.push( start_node );\n\n    // proc\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        // proc init\n        double time = node.time;\n        int v = node.v;\n        int town = node.town;\n        int prev = node.prev;\n\n        // goal\n        if ( town == goal && v == 1 ) {\n            printf( \"%.5f\\n\", time );\n            return;\n        }\n\n        // move\n        for ( int i = 0; i < CN_count[town]; i++ ) {\n            int next_town = CN[town][i];\n            if ( next_town == prev ) continue;\n            for ( int j = 1; j >= -1; j-- ) {\n                int next_v = v + j;\n                if ( prev == -1 && next_v != 1 ) continue;\n                if ( next_v <= 0 || next_v > L[town][next_town] ) continue;\n                double cost = (double)G[town][next_town] / next_v;\n                double next_time = time + cost;\n                int next_prev = town;\n\n                if ( next_time > MC[town][next_v][next_town] || fabs( next_time - MC[town][next_v][next_town] ) < eps ) continue;\n                MC[town][next_v][next_town] = next_time;\n                Node next_node( next_time, next_v, next_town, next_prev );\n                Q.push( next_node );\n            }\n        }\n    }\n\n    cout << \"unreachable\" << endl;\n}\n\nint main( void )\n{\n    while ( cin >> n >> m ) {\n        // quit\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        for ( int i = 0; i < size; i++ ) {\n            CN_count[i] = 0;\n            for ( int j = 0; j < size; j++ ) {\n                P[i][j] = false;\n                for ( int k = 0; k < size; k++ ) MC[k][i][j] = inf;\n                G[i][j] = inf;\n                L[i][j] = 0;\n            }\n        }\n\n        // input\n        int s, g;\n        cin >> s >> g;\n        for ( int i = 0; i < m; i++ ) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n\n            P[x][y] = P[y][x] = true;\n            G[x][y] = G[y][x] = d;\n            L[x][y] = L[y][x] = c;\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( i == j ) continue;\n                if ( P[i][j] ) CN[i][CN_count[i]++] = j;\n            }\n        }\n\n        solve( s-1, g-1 );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 6/15 8:57 ~ 920 1129\n */\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#define INF 2000000\n\nusing namespace std;\n\nstruct edge {\n  int to;\n  double cost;\n};\ntypedef pair<int, int> P;\n\nint iN;\nint iM;\nint iS;\nint iG;\nvector<edge> G[31 * 31];\ndouble d[31 * 31][31];\n\nbool input() {\n  int i, j;\n  int x, y, d, c;\n  edge e;\n\n  scanf(\"%d %d\", &iN, &iM);\n  if (iN == 0 && iM == 0)\n    return false;\n  scanf(\"%d %d\", &iS, &iG);\n\n  for (i = 0; i < 31 * 31; i++) {\n    G[i].clear();\n  }\n\n  for (i = 0; i < iM; i++) {\n    scanf(\"%d %d %d %d\", &x, &y, &d, &c);\n    for (j = 1; j <= c; j++) {\n      e.cost = (double) d / j;\n      e.to = y * 31 + j;\n      G[x * 31 + j].push_back(e);\n      G[x * 31 + j - 1].push_back(e);\n      if (j + 1 <= c)\n        G[x * 31 + j + 1].push_back(e);\n      e.to = x * 31 + j;\n      G[y * 31 + j].push_back(e);\n      G[y * 31 + j - 1].push_back(e);\n      if (j + 1 <= c)\n        G[y * 31 + j + 1].push_back(e);\n    }\n  }\n  return true;\n}\n\nvoid dijkstraQueue() {\n  int i, j;\n  priority_queue<P, vector<P> , greater<P> > que;\n\n  fill(d[0], d[0] + 31 * 31 * 31, INF);\n  d[iS * 31 + 0][0] = 0;\n  que.push(P(0, iS * 31 + 0));\n\n  while (!que.empty()) {\n    P p = que.top();\n    que.pop();\n    int v = p.second;\n    //printf(\"%d %d\\n\", v / 31, v % 31);\n    for (j = 0; j < iN; j++) {\n      if (d[v][j] < p.first)\n        continue;\n      for (i = 0; i < (int) G[v].size(); i++) {\n        edge e = G[v][i];\n        //printf(\"%f\\n\", e.cost);\n        if (d[e.to][v / 31] > d[v][j] + e.cost) {\n          d[e.to][v / 31] = d[v][j] + e.cost;\n          que.push(P(d[e.to][v / 31], e.to));\n        }\n      }\n    }\n  }\n}\n\nvoid output() {\n  int i;\n  double out;\n  out = d[(iG - 1) * 31 + 1][1];\n  for (i = 2; i < 31; i++) {\n    out = min(out, d[(iG - 1) * 31 + 1][i]);\n  }\n  if (out == INF)\n    printf(\"unreachable\\n\");\n  else\n    printf(\"%f\\n\", out);\n}\n\nint main() {\n  while(1) {\n    if (!input()) break;\n    dijkstraQueue();\n    output();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\nclass State{\npublic:\n  int id,pre,speed;\n  double cost;\n\n  State(){}\n  State(int _id,int _pre,int _speed,double _cost){\n    id = _id;\n    pre = _pre;\n    speed = _speed;\n    cost = _cost;\n  }\n  bool operator<(const State &st)const{\n    return cost > st.cost;\n  }\n};\n\nint n,m;\nint s,g;\nint d[102][102],c[102][102];\nbool closed[102][102][102];\n\nvoid solve(){\n  priority_queue<State> open;\n  memset(closed,0,sizeof(closed));\n\n  for(int i=1;i<=n;i++){\n    if(d[s][i] >= 0){\n      open.push(State(i,s,1,d[s][i]));\n    }\n  }\n\n  while(!open.empty()){\n    State st = open.top(); open.pop();\n    if(closed[st.id][st.pre][st.speed]) continue;\n    closed[st.id][st.pre][st.speed] = true;\n\n    if(st.id == g && st.speed == 1){\n      printf(\"%.5f\\n\",st.cost);\n      return ;\n    }\n\n    for(int i=1;i<=n;i++){\n      if(d[st.id][i] >= 0){\n        for(int j=-1;j<=1;j++){\n          int ns = st.speed + j;\n          if(ns > c[st.id][i]) continue;\n          open.push(State(i,st.id,ns,st.cost+(double)d[st.id][i]/ns));\n        }\n      }\n    }\n  }\n\n  cout<<\"unreachable\\n\";\n}\n\nint main(void){\n  while(cin>>n>>m,n||m){\n    memset(d,-1,sizeof(d));\n    memset(c,-1,sizeof(c));\n\n    cin>>s>>g;\n    rep(i,m){\n      int from,to,dd,cc;\n      cin>>from>>to>>dd>>cc;\n      d[from][to] = d[to][from] = dd;\n      c[from][to] = c[to][from] = cc;\n    }\n\n    solve();\n  }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 24;\n\n#define F first\n#define S second\n\nint main(void){\n    for(int n, m; cin >> n >> m, n;){\n        int s, z; cin >> s >> z; s--, z--;\n\n        // (距離, 制限速度)\n        vector<vector<pair<int, pii>>> edge(n);\n        rep(i, m){\n            int x, y, d, c; cin >> x >> y >> d >> c; x--, y--;\n\n            edge[x].pb(mp(y, mp(d, c)));\n            edge[y].pb(mp(x, mp(d, c)));\n        }\n\n        constexpr int kMaxSpeed = 30;\n\n        // (コスト, (今いる都市, 速度, 1個前の都市))\n        typedef pair<double, pair<int, pii>> State;\n\n        vector<vector<vector<double>>> minDist(n, vector<vector<double>>(kMaxSpeed + 1, vector<double>(n, (double)inf)));\n        priority_queue<State, vector<State>, greater<State>> q;\n\n        q.push(mp(0.0, mp(s, mp(0, s))));\n\n        while(!q.empty()){\n            double cur_cost = q.top().F;\n            int cur_v = q.top().S.F;\n            int cur_speed = q.top().S.S.F;\n            int cur_prev = q.top().S.S.S;\n            q.pop();\n\n            if(minDist[cur_v][cur_speed][cur_prev] < inf - eps) continue;\n\n            minDist[cur_v][cur_speed][cur_prev] = cur_cost;\n\n            int next_prev = cur_v;\n            range(next_speed, cur_speed - 1, cur_speed + 2){\n                if(next_speed <= 0) continue;\n\n                for(auto && ee : edge[cur_v]){\n                    if(ee.S.S < next_speed || ee.F == cur_prev) continue;\n\n                    int next_v = ee.F;\n                    double next_cost = cur_cost + (double)ee.S.F / next_speed;\n\n                    if(minDist[next_v][next_speed][next_prev] < inf - eps) continue;\n\n                    q.push(mp(next_cost, mp(next_v, mp(next_speed, next_prev))));\n                }\n            }\n        }\n\n        double res = *min_element(all(minDist[z][1]));\n        if(res < inf - eps) printf(\"%.6f\\n\", res);\n        else cout << \"unreachable\" << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst double eps = 1e-9;\nconst double inf = (double)(1<<24);\nconst int size = 31;\nint n, m;\n\nclass Node {\npublic:\n  double t;\n  int v, town, p;\n  bool operator < ( const Node right ) const {\n    return fabs( t - right.t ) < eps ? v < right.v : t > right.t;\n  }\n  Node() {}\n  Node( double t_, int v_, int town_, int p_ = -1 ) {\n    t = t_;\n    v = v_;\n    town = town_;\n    p = p_;\n  }\n};\n\n// for dijkstra\ntypedef priority_queue <Node > QUEUE;\nbool P[size][size]; // path\ndouble MC[32][size]; // min cost\nint D[size][size]; // distance of path\nint L[size][size]; // speed limit of path\nint con[size][size]; // connnect\nint concnt[size];\n\n\nmap <int, int> T; // town number to index\nint TC; // the number of towns\n\nvoid reg( int town )\n{\n  if ( T.find( town ) != T.end() ) return;\n  T[town] = TC;\n  TC++;\n}\n\nvoid solve( int s_, int g_ )\n{\n  int start = T[s_], goal = T[g_];\n  if ( !P[start][goal] ) {\n    cout << \"unreachable\" << endl;\n    return;\n  }\n\n  QUEUE Q;\n  Node start_node( 0.0, 1, start, -1 );\n  Q.push( start_node );\n  MC[1][start] = 0.0;\n  \n  while ( !Q.empty() ) { \n    Node node = Q.top();\n    Q.pop();\n    double t = node.t;\n    int v = node.v;\n    int town = node.town;\n    int prev = node.p;\n\n    // cout << \"time=\" << t << \": town=\" << town << \", v=\" << v << endl;\n    if ( town == goal && v == 1 ) {\n      // cout << MC[v][town] << \",\" << t << endl;\n      printf( \"%.5f\\n\", t );\n      return;\n    }\n\n    // cout << \"test\" << endl;\n    for ( int i = 0; i < concnt[town]; i++ ) {\n      int next_town = con[town][i];\n      // debug\n      // cout << town << \" => \" << next_town << endl;\n      if ( prev != -1 && prev == next_town ) continue;\n      for ( int j = -1; j < 2; j++ ) {\n        if ( prev == -1 && j != 0 ) continue; \n        int next_v = v + j;\n        if ( next_v <= 0 || next_v > L[town][next_town] ) continue;\n        double next_t = t + (double)D[town][next_town] / next_v;\n        Node next_node( next_t, next_v, next_town, town );\n        if ( next_t >= MC[next_v][next_town] ) continue;\n        MC[next_v][next_town] = next_t;\n        Q.push( next_node );\n      }\n    }\n  }\n  \n  cout << \"unreachable\" << endl;\n}\n\nint main( void )\n{\n  while ( cin >> n >> m && n ) {\n    // init\n    for ( int i = 0; i < size; i++ ) {\n      T.clear();\n      TC = 0;\n      concnt[i] = 0;\n      for ( int j = 0; j < size; j++ ) {\n        P[i][j] = false;\n      }\n      for ( int j = 0; j < 32; j++ ) {\n        MC[i][j] = inf;\n      }\n    }\n\n    // input\n    int s, g;\n    cin >> s >> g;\n    for ( int i = 0; i < m; i++ ) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      reg(x);\n      reg(y);\n      int xi = T[x];\n      int yi = T[y];\n      // cout << x << \":\" << xi << \", \" << y << \":\" << yi << endl; // debug\n      P[xi][yi] = P[yi][xi] = true;\n      D[xi][yi] = D[yi][xi] = d;\n      L[xi][yi] = L[yi][xi] = c;\n      con[xi][concnt[xi]++] = yi;\n      con[yi][concnt[yi]++] = xi;\n    }\n\n    for ( int k = 0; k < n; k++ ) {\n      for ( int i = 0; i < n; i++ ) {\n        for ( int j = 0; j < n; j++ ) {\n          if ( !P[i][k] || !P[k][j] ) continue;\n          P[i][j] = true;\n        }\n      }\n    }\n\n    solve( s, g );\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\n#define INF 1e9\nusing namespace std;\n\nclass DP{\npublic:\n\tdouble cost;\n\tunsigned char cur, sp, prev;\n\t\n\tDP(){}\n\tDP(double c, int cu, int s, int pr){\n\t\tcost = c;cur=cu;sp=s;prev=pr;\n\t}\n\t\n\tbool operator< (const DP &opp) const {\n\t\treturn cost>opp.cost;\n\t}\n};\nint n,m,s,go;\n\nchar visit[31][31][31];\nint g[31][31];\nint lim[31][31];\n\nmain(){\n\tint i,j,d,c,x,y;\n\twhile(cin>>n>>m,n){\n\t\tpriority_queue<DP> dp;\n\t\tmemset(g, 0, sizeof(g));\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tcin>>s>>go;\n\t\t\n\t\tfor(i=1;i<=m;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tg[x][y]=g[y][x]=d;\n\t\t\tlim[x][y]=lim[y][x] = c;\n\t\t}\n\t\n\t\tDP T,S;\n\t\tdp.push(DP(0,1,0,0));\n\t\twhile(!dp.empty()){\n\t\t\tS = dp.top();\n\t\t\tdp.pop();\n\t\t\tif(visit[S.cur][S.sp][S.prev]) continue;\n\t\t\tif(S.cur == go && S.sp == 1) break;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tif(!g[S.cur][i]) continue;\n\t\t\t\tfor(j=S.sp-1;j<=S.sp+1;j++){\n\t\t\t\t\tif(lim[S.cur][i] < j || j < 1 || i == S.prev || visit[i][j][S.cur]) continue;\n\t\t\t\t\tT.cost = S.cost + g[S.cur][i] / (double)j;\n\t\t\t\t\tT.cur = i;\n\t\t\t\t\tT.sp = j;\n\t\t\t\t\tT.prev = S.cur;\n\t\t\t\t\tdp.push(T);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvisit[S.cur][S.sp][S.prev] = 1;\n\t\t}\n\t\tif(S.cur == go && S.sp == 1) printf(\"%.5lf\\n\", S.cost);\n\t\telse cout << \"unreachable\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 100\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(que.size()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n \nstruct State {\n  int prev;\n  int now;\n  int vel; // 到着時\n  double e_time;\n   \n  bool operator < (const State &s) const {\n    return e_time > s.e_time;\n  }\n   \n  State() {}\n  State(int p, int n, int v, double t) :\n    prev(p), now(n), vel(v), e_time(t) {}\n};\n \nstruct Edge {\n  int to;\n  int cost;\n  int lim;\n   \n  Edge() {}\n  Edge(int t, int c, int l) : to(t), cost(c), lim(l) {}\n};\n \nconst double Inf = 1<<23;\nint N, M;\nvector<Edge> edges[30];\ndouble G_time[31][30][31]; // u, v, vel -> e_time\n \ndouble dijkstra(int s, int g) {\n   \n  fill(G_time[0][0], G_time[30][30], Inf);\n  priority_queue<State> pq;\n   \n  pq.push(State(s, s, 0, 0.0));\n  G_time[s][s][0] = 0.0;\n   \n  while(!pq.empty()) {\n    const State st = pq.top(); pq.pop();\n     \n    if(G_time[st.prev][st.now][st.vel] < st.e_time) {\n      continue;\n    }\n     \n    if(st.now == g && st.vel == 1) {\n      return st.e_time;\n    }\n     \n    for(int i=0; i<(int)edges[st.now].size(); i++) {\n      const Edge &e = edges[st.now][i];\n      \n      if(e.to == st.prev) continue;\n      \n      for(int dvel = -1; dvel <= 1; dvel ++) {\n\tint nvel = st.vel + dvel;\n\t// 速度制限\n\tif(1 <= nvel && nvel <= e.lim) {\n\t  double ntime = G_time[st.prev][st.now][st.vel] + (double)e.cost / nvel;\n\t  if(G_time[st.now][e.to][nvel] > ntime) {\n\t    G_time[st.now][e.to][nvel] = ntime;\n\t    pq.push(State(st.now, e.to, nvel, ntime));\n\t  }\n\t}\n      }\n      \n    }\n  }\n   \n  return 42;\n}\n \nint main() {\n  int s, g;\n   \n  while(cin >> N >> M && (N|M)) {\n    cin >> s >> g;\n    s --, g --;\n     \n    for(int i=0; i<N; i++)\n      edges[i].clear();\n     \n    for(int i=0; i<M; i++) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      x --, y --;\n      edges[x].push_back(Edge(y, d, c));\n      edges[y].push_back(Edge(x, d, c));\n    }\n     \n    double ans = dijkstra(s, g);\n    if(ans == 42) {\n      cout << \"unreachable\" << endl;\n    } else {\n      printf(\"%.5lf\\n\", ans);\n    }\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nint main() {\n   for(;;) {\n      Int n, m;\n      std::cin >> n >> m;\n      if( n == 0 and m == 0 ) break;\n      Int s, g;\n      std::cin >> s >> g;\n      double inf = 1e16;\n      std::vector<std::pair<Int,double>> edges[32*32];\n      rep(ii,m) {\n         Int x, y, d, c;\n         std::cin >> x >> y >> d >> c;\n         for(Int kk = 0; kk < 2; ++kk) {\n            for(Int k = 1; k <= c; ++k) {\n               edges[x*32+k].emplace_back(y*32+k+1, (double)d/k);\n               if( k >= 2 ) {\n                  edges[x*32+k].emplace_back(y*32+k-1, (double)d/k);\n               }\n               edges[x*32+k].emplace_back(y*32+k+0, (double)d/k);\n            }\n            std::swap(x,y);\n         }\n      }\n      RQ<std::tuple<double,Int,Int>> q;\n      q.emplace(0.0, s*32+1, -1);\n      double dist[32*32][32];\n      rep(i,32*32) rep(k,32) dist[i][k] = inf;\n      while( not q.empty() ) {\n         double d;\n         Int v;\n         Int prev;\n         std::tie(d, v, prev) = q.top(); q.pop();\n         // if( prev != -1 and d >= dist[v][prev/32] ) continue;\n         for(auto next : edges[v]) {\n            Int nv;\n            double dd;\n            std::tie(nv, dd) = next;\n            if( prev != -1 and nv/32 == prev/32 ) continue;\n            double nd = d + dd;\n            if( nv == g*32+1 and v%32 != 1 ) continue;\n            if( nd < dist[nv][v/32] ) {\n               dist[nv][v/32] = nd;\n               q.emplace(nd, nv, v);\n            }\n         }\n      }\n      double res = inf;\n      rep(i,32) {\n         res = std::min(res, dist[g*32+1][i]);\n      }\n      if( res >= inf ) {\n         puts(\"unreachable\");\n      }\n      else {\n         printf(\"%lf\\n\", res);\n      }\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\nint n,m;\nwhile(cin>>n>>m){\nwhile(true)\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\nclass data{\npublic:\n\tint t,c,d;\n\n};\n\nclass data2{\npublic:\n\tdouble cost;\n\tint v,s;\n\tbool operator<(const data2 &d1)const{\n\t\treturn d1.cost<cost;\n\t}\n};\n\nint n,m,s,g;\ndouble dp[35][35];\nvector<data> edge[35];\n\ndouble dijk(){\n\tfor(int i=0;i<35;i++){\n\t\tfor(int j=0;j<35;j++)dp[i][j]=-1.0;\n\t}\n\tpriority_queue<data2> que;\n\tdata2 ind;\n\tind.cost=0.0;\n\tind.v=s;\n\tind.s=0;\n\tdp[s][0]=0.0;\n\tque.push(ind);\n\twhile(que.size()){\n\t\tdata2 dd=que.top();\n\t\tque.pop();\n\t\tif(dp[dd.v][dd.s]<dd.cost)continue;\n\t\tdp[dd.v][dd.s]=dd.cost;\n\t\tfor(int i=0;i<edge[dd.v].size();i++){\n\t\t\tdata e=edge[dd.v][i];\n\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\tint ns=dd.s+j;\n\t\t\t\tif(ns<=0 || ns>e.c)continue;\n\t\t\t\tdouble nc=dd.cost+(double)e.d/ns;\n\t\t\t\tif(dp[e.t][ns]>nc || dp[e.t][ns]==-1.0){\n\t\t\t\t\tdp[e.t][ns]=nc;\n\t\t\t\t\tdata2 nd;\n\t\t\t\t\tnd.v=e.t;\n\t\t\t\t\tnd.cost=nc;\n\t\t\t\t\tnd.s=ns;\n\t\t\t\t\tque.push(nd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[g][1];\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n+m==0)break;\n\t\tfor(int i=0;i<=n;i++)edge[i].clear();\n\t\tscanf(\"%d %d\",&s,&g);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y;\n\t\t\tdata dd;\n\t\t\tscanf(\"%d %d %d %d\",&x,&y,&dd.d,&dd.c);\n\t\t\tdd.t=y;\n\t\t\tedge[x].push_back(dd);\n\t\t\tdd.t=x;\n\t\t\tedge[y].push_back(dd);\n\t\t}\n\t\tdouble res=dijk();\n\t\tif(res!=-1.0)printf(\"%.5f\\n\",res);\n\t\telse printf(\"unreachable\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<pair<double,int>,pair<int,int> >P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a2,a3,a4;\ndouble d[31][31][31];\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)r(k,31)d[i][j][k]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      cin>>a1>>a2>>a3>>a4;\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P,vector<P>,greater<P> >q;\n    P xt;xt.fi.fi=0,xt.fi.se=0,xt.se.fi=st,xt.se.se=-1;\n    q.push(xt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.se.fi,pp=p.se.se;\n      if(cur==go&&p.fi.se==1){\n        printf(\"%.9f\\n\",p.fi.fi);\n        goto L;\n      }\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=pp)r(j,3){\n          int x=p.fi.se+dx[j];\n          if(0<x&&x<=e.lim){\n            double t=e.dist/x+p.fi.fi;\n            if(d[e.to][pp][x]>t){\n              d[e.to][pp][x]=t;\n              P xt;xt.fi.fi=d[e.to][pp][x],xt.fi.se=x,xt.se.fi=e.to,xt.se.se=cur;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    cout<<\"unreachable\"<<endl;L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<class EdgeInfo>\nclass Graph {\nprotected:\n\tusing size_type = ::std::size_t;\n\tstruct Edge {\n\t\tsize_type to;\n\t\tEdgeInfo info;\n\t\tEdge() : to(-1) {}\n\t\tEdge(size_type to_, EdgeInfo info_) : to(to_), info(info_) {}\n\t};\n\tusing edge_type = Edge;\n\n\t::std::vector<::std::vector<edge_type>> edges;\n\npublic:\n\tGraph() {}\n\tGraph(size_type n) : edges(n) {}\n\tGraph(const Graph& g) : edges(g.edges) {}\n\tGraph(Graph&& g) { ::std::swap(edges, g.edges); }\n\tGraph& operator=(const Graph& g) { edges = g.edges; }\n\tGraph& operator=(Graph&& g) { ::std::swap(edges, g.edges); }\n\n\tconst size_type size() { return edges.size(); }\n\tvirtual void add_edge (size_type from, size_type to, EdgeInfo info) = 0;\n\n\tconst ::std::vector<edge_type>& operator[](size_type k) { return edges[k]; }\n\n};\n\ntemplate<class EdgeInfo>\nclass DirectedGraph : public Graph<EdgeInfo> {\nprotected:\n\tusing size_type = ::std::size_t;\npublic:\n\tusing edge_type = typename Graph<EdgeInfo>::edge_type;\n\tDirectedGraph() {}\n\tDirectedGraph(size_type n) : Graph<EdgeInfo>(n) {}\n\tDirectedGraph(const DirectedGraph& g) : Graph<EdgeInfo>(g) {}\n\tDirectedGraph(DirectedGraph&& g) : Graph<EdgeInfo>(g) {}\n\tDirectedGraph& operator=(const DirectedGraph& g) { this->edges = g.edges; return *this;}\n\tDirectedGraph& operator=(DirectedGraph&& g) noexcept { ::std::swap(this->edges, g.edges); return *this; }\n\n\tvoid add_edge (size_type from, size_type to, EdgeInfo info = EdgeInfo()) {\n\t\tthis->edges[from].push_back(edge_type(to, info));\n\t}\n};\n\ntemplate<class DistanceType>\nclass Dijkstra {\nprivate:\n\tusing size_type = ::std::size_t;\n\tusing distance_type = DistanceType;\n\tusing Graph = DirectedGraph<distance_type>;\n\n\tGraph graph;\npublic:\n\tDijkstra() {}\n\tDijkstra(size_type n) : graph(n) {}\n\tDijkstra(const Graph& g) : graph(g) {}\n\n\tvoid add_edge (size_type from, size_type to, distance_type d) {\n\t\tgraph.add_edge(from, to, d);\n\t}\n\n\t::std::vector<distance_type> build(size_type start) {\n\t\t::std::vector<distance_type> dis(graph.size(), invalid_value());\n\n\t\tusing P = ::std::pair<distance_type, size_type>;\n\t\t::std::priority_queue<P, ::std::vector<P>, ::std::greater<P>> pq;\n\t\tdis[start] = 0;\n\t\tpq.push(P(dis[start], start));\n\t\twhile (pq.size()) {\n\t\t\tP p = pq.top(); pq.pop();\n\t\t\tif (p.first > dis[p.second]) continue;\n\t\t\tfor (auto e : graph[p.second]) {\n\t\t\t\tif (dis[e.to] > dis[p.second] + e.info) {\n\t\t\t\t\tdis[e.to] = dis[p.second] + e.info;\n\t\t\t\t\tpq.push(P(dis[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dis;\n\t}\n\n\tstatic const distance_type invalid_value () {\n\t\tstatic const distance_type inf = ::std::numeric_limits<distance_type>::max() / 2 - 1;\n\t\treturn inf;\n\t}\n};\n\nint main(void) {\n  int64 n, m;\n  while (cin >> n >> m && n+m) {\n    Dijkstra<double> shp(2*n*n*(40));\n    int64 s, g;\n    cin >> s >> g; s--; g--;\n    int64 to = n*(40)*n;\n    int64 dd = 40*n;\n    REP(i, n) {\n      REP(k, n) {\n      REP(j, 40) {\n        if (j < 39) {\n          shp.add_edge(dd*i+40*k+j, to+dd*i+40*k+j+1, 0);\n        }\n        shp.add_edge(dd*i+40*k+j, to+dd*i+40*k+j, 0);\n        if (j > 0) {\n          shp.add_edge(dd*i+40*k+j, to+dd*i+40*k+j-1, 0);\n        }\n      }\n      }\n    }\n    REP(i, m) {\n      int64 x, y, d, c;\n      cin >> x >> y >> d >> c; x--; y--;\n      REP(k, n) {\n      REP(j, c) {\n        if (k != y)\n          shp.add_edge(to+dd*x+40*k+j, dd*y+40*x+j, (double)d/(double)(j+1));\n        if (k != x)\n          shp.add_edge(to+dd*y+40*k+j, dd*x+40*y+j, (double)d/(double)(j+1));\n      }\n      }\n    }\n    auto res = shp.build(to+s*dd);\n    double mini = shp.invalid_value();\n    REP(i, n) {\n      chmin(mini, res[dd*g+40*i]);\n    }\n    if (mini == shp.invalid_value()) {\n      cout << \"unreachable\" << endl;\n    } else {\n      cout << fixed << setprecision(10) << mini << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 100000\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[40];    \n    \n    int inx,iny,ind,inc;\n    double d[40][40][40];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define NODE 30\n#define LIM 31\nconst double inf = 1e200;\n\nclass state{\npublic:\n  int cur,prev,speed;\n  double c;\n  state(){};\n  state(int tcur,int tprev,int tspeed,double tc):cur(tcur),prev(tprev),\n\t\t\t\t\t\t speed(tspeed),c(tc){};\n  bool operator<(const state & a)const{\n    return c >a.c;\n  }\n};\n\ndouble cost[30][30][31];\ndouble dist[30][30];\nint lim[30][30];\nbool visited[30][30][31];\n\nvoid solve(int n,int s,int g){\n  rep(i,n)rep(j,n)rep(k,31)cost[i][j][k]=inf,visited[i][j][k]=false;\n  priority_queue<state> Q;\n  cost[0][0][1]=0;\n  rep(i,n){\n    if ( lim[s][i] >= 1){\n      cost[i][s][1]=dist[s][i];\n      Q.push(state(i,s,1,cost[i][s][1]));\n    }\n  }\n\n  while(!Q.empty()){\n    state now = Q.top();\n    Q.pop();\n    if ( visited[now.cur][now.prev][now.speed])continue;\n    visited[now.cur][now.prev][now.speed]=true;\n    if ( now.cur == g && now.speed == 1){\n      printf(\"%.3lf\\n\",now.c);\n      return;\n    }\n    rep(i,n){\n      if ( i == now.prev || i == now.cur)continue;\n      REP(j,-1,2){\n\tif ( now.speed + j > 0 && now.speed + j <= lim[now.cur][i] &&\n\t     cost[i][now.cur][now.speed+j] - now.c - dist[now.cur][i]/(now.speed+j) >0){\n\t  cost[i][now.cur][now.speed+j]=now.c+dist[now.cur][i]/(now.speed+j);\n\t  Q.push(state(i,now.cur,now.speed+j,cost[i][now.cur][now.speed+j]));\n\t}\n      }\n    }\n  }\n  \n\n  puts(\"unreachable\");\n  \n}\n\n\nmain(){\n  int n,m;\n  while(cin>>n>>m && n){\n    rep(i,n)rep(j,n)lim[i][j]=0,dist[i][j]=inf;\n    int s,g;\n    cin>>s>>g;\n    s--;g--;\n    rep(i,m){\n      int f,t,v;\n      double d;\n      cin>>f>>t>>d>>v;\n      f--;t--;\n      dist[f][t]=dist[t][f]=d;\n      lim[f][t]=lim[t][f]=v;\n    }\n    solve(n,s,g);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> PIII;\ntypedef pair<double, PIII> PDIII;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nstruct edge{\n  int to, limit;\n  double dis;\n  edge(){}\n  edge(int to, double dis, int limit) : to(to), limit(limit), dis(dis) {}\n};\n\ndouble dist[40][40][40];\nvector<edge> G[40];\n\nint main(){\n  int n, m, s, g;\n  while(cin >> n >> m, n + m){\n    REP(i, 40) G[i].clear();\n    \n    cin >> s >> g;\n    s--, g--;\n    REP(i, m){\n      int x, y, c;\n      double dis;\n      cin >> x >> y >> dis >> c;\n      x--, y--;\n      G[x].push_back(edge(y, dis, c));\n      G[y].push_back(edge(x, dis, c));\n    }\n\n    double ans = -1;\n    fill(&dist[0][0][0], &dist[0][0][0] + 40 * 40 * 40, 1e20);\n    priority_queue<PDIII, vector<PDIII>, greater<PDIII> > que;\n    dist[s][0][n] = 0.0;\n    que.push(PDIII(0, PIII(s, PII(0, n))));\n    \n    while(!que.empty()){\n      double d   = que.top().first;\n      int    pos = que.top().second.first;\n      int    v   = que.top().second.second.first;\n      int    pre = que.top().second.second.second;\n      que.pop();\n      if(pos == g && v == 1){\n        ans = d;\n        break;\n      }\n      if(d > dist[pos][v][pre]) continue;\n      \n\n      REP(i, G[pos].size()){\n        int to = G[pos][i].to;\n        for(int j = -1; j <= 1; j++){\n          if(to == pre) continue;\n          int nv = v + j;\n          \n          \n          if(nv < 1 || nv > G[pos][i].limit) continue;\n          double tmp = G[pos][i].dis / nv + d;\n          if(tmp < dist[to][nv][pos]){\n            dist[to][nv][pos] = tmp;\n            que.push(PDIII(tmp, PIII(to, PII(nv, pos))));\n          }\n        }\n      }\n    }\n    if(ans < 0){\n      cout << \"unreachable\" <<endl;\n    }else{\n      printf(\"%.20lf\\n\", ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){std::fill( (T*)array, (T*)(array+N), val );}\nusing ld=long double;\nstruct edge{int to,cost,limit;};\nusing P=pair<ld,pair<int,pair<int,int>>>;\n#define mp(i,j,k,l) make_pair((i),make_pair((j),make_pair((k),(l))))\nconst ld INF=1<<29;\nconst int MAX_V=35;\nvector<edge> G[MAX_V];\nld t[MAX_V][MAX_V][35];\n\nint n,m,s,g;\nvoid dijkstra(){\n  priority_queue<P,vector<P>,greater<P>> que;\n  Fill(t,INF);\n  t[0][s][1]=0;\n  que.push(mp(0,0,s,1));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int last=p.second.first;\n    int v=p.second.second.first;\n    int spd=p.second.second.second;\n    REP(i,G[v].size()){\n      edge e=G[v][i];\n      if(last==e.to)continue;\n      for(int j=-1;j<=1;j++){\n\t//cout<<\"[\"<<v<<\"->\"<<e.to<<\"] \"<<t[e.to][spd+j]<<\">\"<<t[v][spd]<<\"+\"<<((double)e.cost)/spd<<endl;\n\tif(spd>e.limit)continue;\n\tif(t[v][e.to][spd+j]>t[last][v][spd]+((double)e.cost)/spd){\n\t  t[v][e.to][spd+j]=t[last][v][spd]+((double)e.cost)/spd;\n\t  que.push(mp(t[v][e.to][spd+j],v,e.to,spd+j));\n\t}\n      }\n    }\n  }\n  ld mn=INF;\n  REP(i,n){\n    mn=min(t[i+1][g][0],mn);\n  }\n  if(mn!=INF) printf(\"%.12Lf\\n\",mn);\n  else printf(\"unreachable\\n\");\n}\nint x,y,d,c;\nint main(){ _;\n  while(cin>>n>>m,(n|m)){\n    REP(i,MAX_V)G[i].clear();\n    cin>>s>>g;\n    REP(i,m){\n      cin>>x>>y>>d>>c;\n      G[x].push_back(edge{y,d,c});\n      G[y].push_back(edge{x,d,c});\n    }\n    dijkstra();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1000\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(short i=1;i<=n;i++)for(short j=1;j<=n;j++)for(short k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(short i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    \n    while(que.size()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(short i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define NODE 30\n#define LIM 31\nconst double inf = 1e200;\n\nclass state{\npublic:\n  int cur,prev,speed;\n  double c;\n  state(){};\n  state(int tcur,int tprev,int tspeed,double tc):cur(tcur),prev(tprev),\n\t\t\t\t\t\t speed(tspeed),c(tc){};\n  bool operator<(const state & a)const{\n    return c >a.c;\n  }\n};\n\ndouble cost[30][30][31];\ndouble dist[30][30];\nint lim[30][30];\nbool visited[30][30][31];\n\nvoid solve(int n,int s,int g){\n  rep(i,n)rep(j,n)rep(k,31)cost[i][j][k]=inf,visited[i][j][k]=false;\n  priority_queue<state> Q;\n  cost[0][0][1]=0;\n  rep(i,n){\n    if ( lim[s][i] >= 1){\n      cost[i][s][1]=dist[s][i];\n      Q.push(state(i,s,1,cost[i][s][1]));\n    }\n  }\n\n  while(!Q.empty()){\n    state now = Q.top();\n    Q.pop();\n    /*\n    if ( cost[now.cur][now.prev][now.speed] <now.c){\n      puts(\"test\");\n      continue;\n      }*/\n    if ( visited[now.cur][now.prev][now.speed])continue;\n    visited[now.cur][now.prev][now.speed]=true;\n    if ( now.cur == g && now.speed == 1){\n      printf(\"%.3lf\\n\",now.c);\n      return;\n    }\n    rep(i,n){\n      if ( i == now.prev)continue;\n      REP(j,-1,2){\n\tif ( now.speed + j > 0 && now.speed + j <= lim[now.cur][i] &&\n\t     cost[i][now.cur][now.speed+j] > now.c + dist[now.cur][i]/(now.speed+j)){\n\t  cost[i][now.cur][now.speed+j]=now.c+dist[now.cur][i]/(now.speed+j);\n\t  Q.push(state(i,now.cur,now.speed+j,cost[i][now.cur][now.speed+j]));\n\t}\n      }\n    }\n  }\n  \n\n  puts(\"unreachable\");\n  \n}\n\n\nmain(){\n  int n,m;\n  while(cin>>n>>m && n){\n    rep(i,n)rep(j,n)lim[i][j]=0,dist[i][j]=inf;\n    int s,g;\n    cin>>s>>g;\n    s--;g--;\n    rep(i,m){\n      int f,t,v;\n      double d;\n      cin>>f>>t>>d>>v;\n      f--;t--;\n      dist[f][t]=dist[t][f]=d;\n      lim[f][t]=lim[t][f]=v;\n    }\n    solve(n,s,g);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <cstdio>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dy[] = {1, 0, -1, 1, -1, 1, 0, -1};\n\nstruct edge{\n\tint to;\n\tdouble dist;\n\tint c;\n\tedge(int t, double d, int c_){to = t, dist = d, c = c_;}\n};\n\nstruct state{\n\tint pos;\n\tdouble total;\n\tint speed;\n\tint prev;\n\tstate(int p, double t, int s, int pr){pos = p, total = t, speed = s, prev = pr;}\n\tbool operator<(const state &r)const{\n\t\treturn total > r.total;\n\t}\n};\n\nconst double INF = 1e30;\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\ts--, g--;\n\t\tvector<vector<edge> > G(n);\n\t\trep(i, m){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--, y--;\n\t\t\tG[x].push_back(edge(y, d, c));\n\t\t\tG[y].push_back(edge(x, d, c));\n\t\t}\n\n\t\tpriority_queue<state> q;\n\t\tq.push(state(s, 0, 0, 0));\n\n\t\tvector<vector<vi> > visit(31, vector<vi>(n, vi(n, 0))); //speed, pos, prev\n\n\t\tdouble ans = INF;\n\t\twhile(!q.empty()){\n\t\t\tstate st = q.top();\n\t\t\tq.pop();\n\n\t\t\tif(visit[st.speed][st.pos][st.prev]) continue;\n\t\t\tvisit[st.speed][st.pos][st.prev] = 1;\n\n\t\t\tif(st.speed == 1 && st.pos == g){\n\t\t\t\tans = st.total;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, G[st.pos].size()){\n\t\t\t\tif( G[st.pos][i].dist == INF ) continue;\n\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\tstate next = st;\n\t\t\t\t\tnext.speed += j;\n\t\t\t\t\tif(next.speed <= 0 || next.speed > G[st.pos][i].c) continue;\n\t\t\t\t\tnext.pos = G[st.pos][i].to;\n\t\t\t\t\tnext.prev = st.pos;\n\t\t\t\t\tnext.total += G[st.pos][i].dist/next.speed;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == INF) cout << \"unreachable\" << endl;\n\t\telse printf(\"%.8lf\\n\", ans);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<set>\n#include<string>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<cstdlib>\n#include<cstring>\n#define P pair<int ,int>\nusing namespace std;\n\nint spd[3] = {1, 0, -1};\n\nstruct E {\n\tint dst, cost, lim;\n\tE(int d, int c, int l) {\n\t\tdst = d;\n\t\tcost = c;\n\t\tlim = l;\n\t}\n};\n\nstruct N {\n\tint pos, bef, spd;\n\tdouble ti;\n\tN(int p, int b, int s, double t) {\n\t\tpos = p;\n\t\tbef = b;\n\t\tspd = s;\n\t\tti = t;\n\t}\n\tN(){}\n};\n\nbool operator < (N n1, N n2) {\n\treturn n1.ti > n2.ti;\n}\n\nint main()\n{\n\tint n, m, s, g;\n\tint x, y, d, c;\n\tN no;\n\twhile (cin >> n >> m, n) {\n\t\tcin >> s >> g;\n\t\tbool ef = 0;\n\t\tbool f[31][31][31];\n\t\tmemset(f, 0, sizeof(f));\n\t\tvector<vector<E> > e(n + 1);\n\t\t\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\te[x].push_back(E(y, d, c));\n\t\t\te[y].push_back(E(x, d, c));\n\t\t}\n\t\t\n\t\tpriority_queue<N> pq;\n\t\tpq.push(N(s, s, 0, 0));\n\t\t\n\t\twhile (!pq.empty()) {\n\t\t\tno = pq.top();\n\t\t\tpq.pop();\n\t\t\tif (f[no.pos][no.bef][no.spd]) continue;\n\t\t\tf[no.pos][no.bef][no.spd] = 1;\n\t\t\t\n\t\t\tif (no.pos == g && no.spd == 1) {\n\t\t\t\tef = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < e[no.pos].size(); i++) {\n\t\t\t\tif (no.bef == e[no.pos][i].dst) continue;\n\t\t\t\t\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (no.spd + spd[j] > 0 && e[no.pos][i].lim >= no.spd + spd[j])\n\t\t\t\t\t\tpq.push(N(e[no.pos][i].dst, no.pos, no.spd + spd[j], no.ti + e[no.pos][i].cost / (double)(no.spd + spd[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ef) printf(\"%.5lf\\n\", no.ti);\n\t\telse cout << \"unreachable\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\nstruct node{\n\tchar pos;\n\tchar prev;\n\tchar speed;\n\tdouble dist;\n\n\tnode( int pos_, int prev_, int speed_, double dist_ )\n\t\t: pos(pos_), prev(prev_), speed(speed_), dist(dist_) {}\n\n\tbool operator< (const node &n) const{\n\t\treturn dist > n.dist;\t//逆\n\t}\n};\n\nstruct road{\n\tchar to;\n\tdouble dist;\n\tchar c;\n\t\n\troad( int t, double d, int c_ )\n\t\t: to(t), dist(d), c(c_) {}\n};\n\nint n, m;\nint s, g;\n\nvector<vector<road> > roads;\ndouble mindist[31][31][31];\n\n\nvoid solve(){\n\tfill( mindist[0][0], mindist[31][0], 9e9 );\n\n\tpriority_queue<node> pq;\n\tfor( int i = 0; i < roads[s].size(); ++i ){\n\t\troad r = roads[s][i];\n\t\tpq.push( node( r.to, s, 1, r.dist ) );\n\t\tmindist[r.to][s][1] = r.dist;\n\t}\n\t\n\twhile( !pq.empty() ){\n\t\tnode nd = pq.top();\n\t\tpq.pop();\n\n\t\tif( mindist[nd.pos][nd.prev][nd.speed] != nd.dist ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif( nd.pos == g && nd.speed == 1 ){\n\t\t\tprintf(\"%f\\n\", nd.dist );\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor( int i = 0; i < roads[nd.pos].size(); ++i ){\n\t\t\troad r = roads[nd.pos][i];\n\t\t\tif( r.to == nd.prev ){\tcontinue;\t}\n\t\t\t\n\t\t\tfor( int j = -1; j < 2; ++j ){\n\t\t\t\tif( nd.speed + j > 0 && nd.speed + j <= r.c ){\n\t\t\t\t\tdouble nextdist = nd.dist + r.dist / ( nd.speed + j );\n\t\t\t\t\tif( mindist[r.to][nd.pos][nd.speed + j] > nextdist ){\n\t\t\t\t\t\tmindist[r.to][nd.pos][nd.speed + j] = nextdist;\n\t\t\t\t\t\tpq.push( node( r.to, nd.pos, nd.speed + j, nextdist ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tputs(\"unreachable\");\n}\n\n\nint main(){\n\tint x, y, d, c;\n\twhile( cin >> n >> m, n != 0 ){\n\t\troads = vector<vector<road> >( n + 1 );\n\t\t\n\t\tcin >> s >> g;\n\t\t\n\t\tfor( int i = 0; i < m; ++i ){\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\troads[x].push_back( road( y, d, c ) );\n\t\t\troads[y].push_back( road( x, d, c ) );\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 90\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[40];    \n    \n    int inx,iny,ind,inc;\n    double d[40][40][40];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<double, int, int, int> T;\n \nconst ll MOD=1e9+7;\n//const ll INF=1e18;\n\nconst double INF = 1000000.0;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\nstruct edge{ int to,d,c;};\n\n\n\nint n,m,s,g;\ndouble d[35][35][35];\ndouble mind;\n\nint main(){\n\twhile(true){\n\t\tcin >> n >> m;\n\t\tif(n + m == 0) break;\n\t\tcin >> s >> g;\n\t\tmind = INF;\n\t\tvector<edge> G[35];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a1,a2,a3,a4;\n\t\t\tcin >> a1 >> a2 >> a3 >> a4;\n\t\t\tedge tmp1 = {a2,a3,a4};\n\t\t\tG[a1].push_back(tmp1);\n\t\t\tedge tmp2 = {a1,a3,a4};\n\t\t\tG[a2].push_back(tmp2);\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tfor(int k = 0;k <= 31;k++){\n\t\t\t\t\td[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<T> que;\n\t\tfor(int i = 0;i < G[s].size();i++){\n\t\t\tedge e = G[s][i];\n\t\t\td[s][e.to][1] = (double) e.d;\n\t\t\tque.push(make_tuple((double)e.d,1,s,e.to));\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tT t = que.front(); que.pop();\n\t\t\tdouble a1 = get<0>(t);\n\t\t\tint a2 = get<1>(t),a3 = get<2>(t),a4 = get<3>(t);\n\t\t\tif(d[a3][a4][a2] < a1 || a1 > mind)continue;\n\t\t\tfor(int i = 0;i < G[a4].size();i++){\n\t\t\t\tedge e = G[a4][i];\n\t\t\t\tif(e.to == a3) continue;\n\t\t\t\tfor(int j = -1;j <= 1;j++){\n\t\t\t\t\tint v = a2 + j;\n\t\t\t\t\tdouble tmp = (double)( a1 + (double)e.d / (double)v);\n\t\t\t//\t\tif(a4 == 5 && e.to == 6 && v == 1) cout << \"tmp\" << tmp << \",a1\" << a1 <<endl;\n\t\t\t\t\tif(v <= 0 || v > e.c || d[a4][e.to][v] < tmp ||tmp > mind) continue;\n\t\t\t\t\td[a4][e.to][v] =  tmp;\n\t\t\t\t\tif(e.to == g && v == 1 && mind > tmp)mind = tmp;\n\t\t\t\t\tque.push(make_tuple(tmp,v,a4,e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\n\t\t}\n\t//\tcout << \"ans\" << d[4][5][2] << endl;\n\n\n\n\t\tdouble ans = INF;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tdouble tmp = d[i][g][1];\n\t\t\tif(ans > tmp) ans = tmp;\n\t\t//\tans = min(ans,d[i][g][1]);\n\t\t}\n\t\tif(ans == INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t//\tcout << ans << endl;\n\t\t\tprintf(\"%lf\",ans);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// 2009à\\ID £UI¬x\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef vector< vector<int> > graph;\n\nclass Node{\npublic:\n\t// p : »ÝÊu\n\t// v : »ÝÌXs[h\n\t// prev : OÉ¢½XÔ\n\t// cost : ±±ÜÅÌ£\n\tint p, v, prev; double cost;\n\tNode(int p, int v, int prev, double cost) : p(p), v(v), prev(prev), cost(cost) {}\n\t// priority_queueÅ¸\\[gÉ·éÌªÊ|ÈÌÅCsðtÉè`µÄµÜ¤\n\tbool operator < (const Node &nd) const { return cost > nd.cost; }\n};\n\nint main(){\n\tint n, m, s, g;\n\twhile(cin >> n >> m){\n\t\tif(!(n||m)) break;\n\t\tcin >> s >> g;\n\t\tgraph gp(n);\n\t\t// £sñÆC§À¬xsñ(?)\n\t\tint dist[30][30];\n\t\tint limit[30][30];\n\t\t// óÔ(Êu, ¬x, OÌÊu)ª`FbNÏÝ©ð`FbN·éD\n\t\tbool visit[30][31][30];\n\t\tdouble len[30][31][30];\n\t\tmemset(visit, false, sizeof(visit));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tgp[x-1].push_back(y-1);\n\t\t\tgp[y-1].push_back(x-1);\n\t\t\tdist[x-1][y-1] = d,  dist[y-1][x-1] = d;\n\t\t\tlimit[x-1][y-1] = c, limit[y-1][x-1] = c;\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<=30;j++)\n\t\t\t\tfor(int k=0;k<n;k++) len[i][j][k] = 1e15;\n\t\tpriority_queue<Node> qu; qu.push(Node(s-1,0,s-1,0.0));\n\t\tdouble ans = -1.0;\n\t\t// _CLXg@ÅÅZoH·ðßé\n\t\twhile(!qu.empty()){\n\t\t\tNode nd = qu.top(); qu.pop();\n\t\t\tint p = nd.p, v = nd.v, prev = nd.prev;\n\t\t\t// `FbNÏÝÌóÔÈçcontinue\n\t\t\tif(visit[p][v][prev]) continue;\n\t\t\tvisit[p][v][prev] = true;\n\t\t\t// S[óÔ\n\t\t\tif(p==g-1 && v==1){\n\t\t\t\tans = nd.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<gp[p].size();i++){\n\t\t\t\tint next = gp[p][i];\n\t\t\t\t// U^[ÍÖ~\n\t\t\t\tif(next==prev) continue;\n\t\t\t\t// ¬xðÆµ½èã°½è\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tint nv = v+j;\n\t\t\t\t\tif(nv<=0||limit[p][next]<nv) continue;\n\t\t\t\t\tif(len[next][nv][p]-1e-8 > nd.cost+(double)dist[p][next]/nv){\n\t\t\t\t\t\tlen[next][nv][p] = nd.cost+(double)dist[p][next]/nv;\n\t\t\t\t\t\tqu.push(Node(next,nv,p,len[next][nv][p]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans < 0.0) cout << \"unreachable\" << endl;\n\t\telse          printf(\"%.5f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint to;\n\tint cost;\n    int speedLimit;\n};\n\nclass Situation{\npublic:\n\tdouble cost;\n\tint idx;\n    int prvIdx;\n    int speed;\n\n\tSituation(double cost_,int idx_,int prvIdx_,int speed_){\n        cost=cost_;\n\t\tidx=idx_;\n        speed=speed_;\n        prvIdx=prvIdx_;\n\t}\n\tSituation();\n\tbool operator<(const Situation &s)const{\n\t\treturn s.cost < this->cost;\n\t}\n};\n\n//typedef pair<int,int> P;\nint V;\n\nconst int MAX_V = 100;\nconst int MAX_SPEED=50;\n\nvector<edge> G[MAX_V];\ndouble d[MAX_V][MAX_V][MAX_SPEED];\nconst int INF = 1000000000;\n\nvoid dijkstra(int s){\n\tpriority_queue<Situation> que;\n    for(int i = 0; i < MAX_V; i++)\n        for(int k = 0; k < MAX_V; k++)\n            for(int j = 0; j < MAX_SPEED; j++)\n                d[i][k][j]=INF;\n    d[0][s][1] = 0;\n\tque.push(Situation(0,s,0,1));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n        int idx=p.idx;\n        int pidx=p.prvIdx;\n        double ccost=p.cost;\n        int cspeed=p.speed;\n        //int v = p.idx;\n\t\tif(d[pidx][idx][cspeed] < p.cost)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[idx].size(); i++){\n\t\t\tedge e = G[idx][i];\n            for(int j = -1; j <= 1; j++){\n                if(pidx==0){\n                    if(cspeed+j!=1)\n                        continue;\n                }\n                if(cspeed+j>=1&&e.speedLimit>=cspeed+j&&d[idx][e.to][cspeed+j]>d[pidx][idx][cspeed]+(double)e.cost/(cspeed+j)){\n                    d[idx][e.to][cspeed+j] = d[pidx][idx][cspeed] + (double)e.cost/(cspeed+j);\n                    que.push(Situation(d[idx][e.to][cspeed+j],e.to,idx,cspeed+j));\n                }\n            }\n\t\t}\n\t}\n}\n\nint main(){\n\n    int n,m,s,g;\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        for(int i = 0; i < MAX_V; i++)\n            G[i].clear();\n        cin>>s>>g;\n        for(int i = 0; i < m; i++){\n            int from,to,dist,lim;\n            cin>>from>>to>>dist>>lim;\n            edge e;\n            e.cost=dist;\n            e.to=to;\n            e.speedLimit=lim;\n            G[from].push_back(e);\n            e.to=from;\n            G[to].push_back(e);\n        }\n        dijkstra(s);\n        double minTime=INF;\n        for(int i = 0; i <= n; i++)\n            minTime=min(minTime,d[i][g][1]);\n        if(EQ(minTime,INF))\n            cout<<\"unreachable\"<<endl;\n        else\n            printf(\"%.6f\\n\",minTime);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nint main() {\n   for(;;) {\n      Int n, m;\n      std::cin >> n >> m;\n      if( n == 0 and m == 0 ) break;\n      Int s, g;\n      std::cin >> s >> g;\n      double inf = 1e16;\n      std::vector<std::pair<Int,double>> edges[32*32];\n      rep(ii,m) {\n         Int x, y, d, c;\n         std::cin >> x >> y >> d >> c;\n         for(Int kk = 0; kk < 2; ++kk) {\n            for(Int k = 1; k <= c; ++k) {\n               edges[x*32+k].emplace_back(y*32+k+1, (double)d/k);\n               if( k >= 2 and not (y == g and k == 2) ) {\n                  edges[x*32+k].emplace_back(y*32+k-1, (double)d/k);\n               }\n               edges[x*32+k].emplace_back(y*32+k+0, (double)d/k);\n            }\n            std::swap(x,y);\n         }\n      }\n      RQ<std::tuple<double,Int,Int>> q;\n      q.emplace(0.0, s*32+1, -1);\n      std::vector<double> dist(32*32, inf);\n      dist[s*32+1] = 0;\n      while( not q.empty() ) {\n         double d;\n         Int v;\n         Int prev;\n         std::tie(d, v, prev) = q.top(); q.pop();\n         for(auto next : edges[v]) {\n            Int nv;\n            double dd;\n            std::tie(nv, dd) = next;\n            if( prev != -1 and nv/32 == prev/32 ) continue;\n            double nd = d + dd;\n            if( nd < dist[nv] ) {\n               dist[nv] = nd;\n               q.emplace(nd, nv, v);\n            }\n         }\n      }\n      if( dist[g*32+1] >= inf ) {\n         puts(\"unreachable\");\n      }\n      else {\n         printf(\"%lf\\n\", dist[g*32+1]);\n      }\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define INF 100000000\n#define rep(i,n) for(int i=0;i<n;i++)\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<int,p> pp;\ntypedef pair<double,pp> P;\nstruct edge{\n\tint to,d,c;\n};\nint main(){\n\tdouble dp[31][31][31];\n\tint n,m,s,g,x,y,d,c,ds[]={1,-1,0};\n\twhile(cin>>n>>m,n||m){\n\t\tvector<edge> G[31];\n\t\tcin>>s>>g;\n\t\ts--;g--;\n\t\trep(i,m){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tx--;y--;\n\t\t\tedge e;\n\t\t\te.d=d;e.c=c;\n\t\t\te.to=y;\n\t\t\tG[x].push_back(e);\n\t\t\te.to=x;\n\t\t\tG[y].push_back(e);\n\t\t}\n\t\trep(i,31)\n\t\trep(j,31)\n\t\trep(k,31)\n\t\tdp[i][j][k]=INF;\n\t\tdp[0][s][s]=0.0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(0.0,pp(-1,p(0,s))));\n\t\tdouble ans=INF;\n\t\twhile(!que.empty()){\n\t\t\tP q=que.top();que.pop();\n\t\t\tif(q.second.second.second==g&&q.second.second.first==1){\n\t\t\t\tans=min(ans,dp[q.second.second.first][q.second.second.second][q.second.first]);\n\t\t\t//\tcout<<ans<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//cout<<q.second.second<<' '<<q.second.second.first<<' '<<q.first<<endl;\n\t\t\tif(dp[q.second.second.first][q.second.second.second][q.second.first]<q.first)\n\t\t\t\tcontinue;\n\t\t\trep(i,G[q.second.second.second].size()){\n\t\t\t\tedge e=G[q.second.second.second][i];\n\t\t\t\tif(e.to==q.second.first)\n\t\t\t\tcontinue;\n\t\t\t\trep(j,3){\n\t\t\t\t\tint pre=q.second.second.first+ds[j];\n\t\t\t\t\tif(pre<1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble tes=(double)e.d/pre+q.first;\n\t\t\t\t\tif(pre<=e.c&&dp[pre][e.to][q.second.second.second]>tes){\n\t\t\t\t\t\tque.push(P(tes,pp(q.second.second.second,p(pre,e.to))));\n\t\t\t\t\t\tdp[pre][e.to][q.second.second.second]=tes;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans==INF)\n\t\tcout<<\"unreachable\"<<endl;\n\t\telse\n\t\tprintf(\"%.5lf\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int v, w, c;\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nstruct State {\n  int v, prev, speed, f;\n  double w;\n  bool operator < (const State &s) const {\n    return w > s.w;\n  }\n};\n\nconst int MAXN = 31;\nconst int MAXS = 31;\nconst double inf = 1.0 / 0.0;\nint n, m, s, g;\nGraph G;\ndouble cost[MAXN][MAXN][MAXS][2];\n\nvoid solve() {\n  try {\n    priority_queue<State> que;\n    que.push((State){s, n, 1, 0, 0.0});\n    fill(cost[0][0][0], cost[MAXN][0][0], inf);\n    cost[s][n][1][0] = 0.0;\n    while(que.size()) {\n      const State s = que.top();\n      que.pop();\n      if(cost[s.v][s.prev][s.speed][s.f] < s.w) continue;\n      if(s.v == g && s.f) throw s.w;\n      for(int i = 0; i < G[s.v].size(); ++i) {\n        const Edge &e = G[s.v][i];\n        if(e.v == s.prev) continue;\n        if(e.c < s.speed) continue;\n        for(int nspeed = max(0, s.speed-1);\n            nspeed <= min(30, s.speed+1); ++nspeed) {\n          const State t = {e.v, s.v, nspeed, s.speed == 1, \n                           s.w + (double)e.w / (double)s.speed};\n          if(cost[t.v][t.prev][t.speed][t.f] <= t.w) continue;\n          cost[t.v][t.prev][t.speed][t.f] = t.w;\n          que.push(t);\n        }\n      }\n    }\n    throw -1.0;\n  } catch(const double res) {\n    if(res == -1) printf(\"unreachable\\n\");\n    else printf(\"%.10f\\n\", res);\n  }\n}\n\nint main() {\n  while(cin >> n >> m && (n|m)) {\n    cin >> s >> g; --s; --g;\n    G = Graph(n);\n    for(int i = 0; i < m; ++i) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      --x; --y;\n      G[x].push_back((Edge){y, d, c});\n      G[y].push_back((Edge){x, d, c});\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vd = std::vector<double>;\n\tusing v2d = std::vector<vd>;\n\tusing v3d = std::vector<v2d>;\n\t\n\tstruct Edge {\n\t\tint to, limit;\n\t\tdouble distance;\n\t};\n\tusing Edges = std::vector<std::vector<Edge>>;\n\n\tusing i3 = std::array<int, 3>;\n\tusing pdi3 = std::pair<double, i3>;\n\n\tEdges inputEdge(int n, int m)\n\t{\n\t\tEdges edge(n);\n\t\tfor (int i{}; i < m; i++)\n\t\t{\n\t\t\tint x, y, c;\n\t\t\tdouble d;\n\t\t\tscanf(\"%d%d%lf%d\", &x, &y, &d, &c);\n\t\t\tx--; y--;\n\t\t\tedge[x].push_back({y, c, d});\n\t\t\tedge[y].push_back({x, c, d});\n\t\t}\n\t\treturn std::move(edge);\n\t}\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n == 0 && m == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tint s, g;\n\t\tscanf(\"%d%d\", &s, &g);\n\t\ts--; g--;\n\t\t// edge[from][i] = {to, distance, limit}\n\t\tconst Edges edge(inputEdge(n, m));\n\n\t\t// distance[頂点][来た速度][来た頂点] = 最短距離\n\t\tv3d distance(n, v2d(31, vd(n, 1e9)));\n\t\tfor (auto& e: distance[s][0]) e = 0;\n\t\t// {距離、{頂点、来た速度、来た頂点}\n\t\tstd::priority_queue<pdi3, std::vector<pdi3>, std::greater<pdi3>> dij;\n\t\tdij.push({0, {s, 0, 0}});\n\t\twhile (!dij.empty())\n\t\t{\n\t\t\tconst double now_dist{dij.top().first};\n\t\t\tconst int now_city{dij.top().second[0]}, now_velo{dij.top().second[1]}, now_from{dij.top().second[2]};\n\t\t\tdij.pop();\n\t\t\tif (now_dist > distance[now_city][now_velo][now_from])\n\t\t\t\tcontinue;\n\n\t\t\tfor (const auto& road: edge[now_city])\n\t\t\t{\n\t\t\t\tif (road.to == now_from) continue;\n\t\t\t\tfor (int add{-1}; add <= 1; add++)\n\t\t\t\t{\n\t\t\t\t\t// {to, velocity, from}\n\t\t\t\t\ti3 next_vertex{road.to, now_velo + add, now_city};\n\t\t\t\t\tif (next_vertex[1] <= 0 || road.limit < next_vertex[1]) continue;\n\t\t\n\t\t\t\t\tdouble next_dist{now_dist + road.distance / next_vertex[1]};\n\t\t\t\t\tauto& table_dist{distance[next_vertex[0]][next_vertex[1]][next_vertex[2]]};\n\t\t\t\t\tif (next_dist >= table_dist) continue;\n\n\t\t\t\t\ttable_dist = next_dist;\n\t\t\t\t\tdij.push({next_dist, next_vertex});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble min{*std::min_element(distance[g][1].begin(), distance[g][1].end())};\n\t\tif (min == 1e9) puts(\"unreachable\");\n\t\telse printf(\"%.4lf\\n\", min);\n\t}\n\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define D first\n#define C second\n\nusing namespace std;\n\nconst double INF = 1000000000.0;\n\ndouble d[31][31][31]; //?????????????????????????????¨?????????????????¨??????????????°?????????????????????\nbool visited[31][31][31];\nint N,M,S,G;\npair<int, int> p[31][31];\n\nstruct ST{\n  double ti;\n  int bn;\n  int cn;\n  int sp;\n  ST(double _ti, int _bn, int _cn, int _sp){\n    ti = _ti;\n    bn = _bn;\n    cn = _cn;\n    sp = _sp;\n  }\n  bool operator >(const ST &e) const{\n    return ti > e.ti;\n  }\n};\n\nint main() {\n  while(1){\n    cin>>N>>M;\n    if(N==0 && M==0) break;\n    cin>>S>>G;\n    S--; G--;\n\n    REP(i,0,N)REP(j,0,N)REP(k,0,31) d[i][j][k] = INF;\n    REP(i,0,N)REP(j,0,N)REP(k,0,31) visited[i][j][k] = false;\n    REP(i,0,N)REP(j,0,N) p[i][j].D = p[i][j].C = -1;\n\n    bool flag = true;\n\n    REP(i,0,M){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      p[x-1][y-1].D = p[y-1][x-1].D = d;\n      p[x-1][y-1].C = p[y-1][x-1].C = c;\n    }\n\n    d[S][S][0] = 0.0;\n    //\n    priority_queue< ST, vector<ST>, greater<ST> > PQ;\n    ST st(0.0,S,S,0);\n    PQ.push(st);\n    //\n\n    //while(1){\n    while(!PQ.empty()){\n      /*\n      int ubn=-1, ucn=-1, usp=-1;\n      double mtime = INF;\n      REP(i,0,N){\n        REP(j,0,N){\n          REP(k,0,31){\n            if(visited[i][j][k]) continue;\n            if(mtime > d[i][j][k]){\n              ubn = i;\n              ucn = j;\n              usp = k;\n              mtime = d[i][j][k];\n            }\n          }\n        }\n      }\n      */\n      //\n      ST u = PQ.top(); PQ.pop();\n      double mtime = u.ti;\n      int ubn=u.bn, ucn=u.cn, usp=u.sp;\n      visited[ubn][ucn][usp] = true;\n      if(d[ubn][ucn][usp] < mtime) continue;\n      //cout<<\"u.ti: \"<<u.ti<<\"; u.bn: \"<<u.bn<<\"; u.cn: \"<<u.cn<<\"; u.sp: \"<<u.sp<<endl;\n      //\n      if(ucn == G && usp == 1){\n        printf(\"%.5lf\\n\",d[ubn][ucn][usp]);\n        flag = false;\n        break;\n      }\n      /*\n      if(ucn == -1){\n        cout<<\"unreachable\"<<endl;\n        break;\n      }\n      */\n\n      visited[ubn][ucn][usp] = true;\n      for(int v = usp-1; v <= usp+1; v++){\n        if(v <= 0) continue;\n        REP(next,0,N){\n          if(visited[ucn][next][v] || p[ucn][next].D == -1 || p[ucn][next].C < v || ucn == next) continue;\n          /*\n          d[ucn][next][v] = min(d[ucn][next][v], d[ubn][ucn][usp] + (double)p[ucn][next].D/(double)v);\n          */\n          //\n          if(d[ucn][next][v] > d[ubn][ucn][usp] + (double)p[ucn][next].D/(double)v){\n            d[ucn][next][v] = d[ubn][ucn][usp] + (double)p[ucn][next].D/(double)v;\n            ST tst(d[ucn][next][v], ucn,next,v);\n            PQ.push(tst);\n          }\n          //\n        }\n      }\n\n    }\n    if(flag){\n      cout<<\"unreachable\"<<endl;\n    }\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\ntypedef pair< double,tuple<int,int,int> > pit3;\ntypedef pair< int,tuple<int,int> > pit2;\n\nint n,m;\n\n\ndouble d[32][32][32];\n\nvector<pit2> pass[32];\n\ndouble dijk(int s,int g){\n    priority_queue< pit3,vector<pit3>,greater<pit3> > que;\n    rep(i,32)rep(j,32)rep(k,32)d[i][j][k]=INF;\n    d[s][1][31]=0;\n    que.push( pit3(0.0,make_tuple(s,1,31)) );\n    \n    bool f=false;\n    while(que.size()){\n//        cout<<que.size()<<endl;\n        pit3 p=que.top();\n        que.pop();\n        \n        int v=get<0>(p.second);\n        int w=get<1>(p.second);\n        int x=get<2>(p.second);\n        if(d[v][w][x]<p.first)continue;\n        rep(i,pass[v].size()){\n            pit2 e=pass[v][i];\n            if(x==e.first)continue;\n            if( w<=get<1>(e.second) && d[e.first][w][v]>d[v][w][x]+(double)(get<0>(e.second))/w ){\n                d[e.first][w][v] = d[v][w][x] + (double)(get<0>(e.second))/w;\n                que.push( pit3(d[e.first][w][v],make_tuple(e.first,w,v)) );\n//                cout<<\"d[\"<<e.first<<\"][\"<<w<<\"][\"<<v<<\"] = \"<<d[e.first][w][v]<<endl;\n            }\n            if( w+1<=get<1>(e.second) && d[e.first][w+1][v]>d[v][w][x]+(double)(get<0>(e.second))/(w+1) && f ){\n                d[e.first][w+1][v] = d[v][w][x] + (double)(get<0>(e.second))/(w+1);\n                que.push( pit3(d[e.first][w+1][v],make_tuple(e.first,w+1,v)) );\n//                cout<<\"d[\"<<e.first<<\"][\"<<w+1<<\"][\"<<v<<\"] = \"<<d[e.first][w+1][v]<<endl;\n            }\n            if( w-1<=get<1>(e.second) && w-1>0 && d[e.first][w-1][v]>d[v][w][x]+(double)(get<0>(e.second))/(w-1) && f ){\n                d[e.first][w-1][v] = d[v][w][x] + (double)(get<0>(e.second))/(w-1);\n                que.push( pit3(d[e.first][w-1][v],make_tuple(e.first,w-1,v)) );\n//                cout<<\"d[\"<<e.first<<\"][\"<<w-1<<\"][\"<<v<<\"] = \"<<d[e.first][w-1][v]<<endl;\n            }\n        }\n        f=true;\n    }\n    double ret = INF;\n    rep(i,32){\n        ret = min(ret, d[g][1][i]);\n    }\n    return ret;\n}\n\n\n\nint main(){\n    int s,g;\n    \n    while(cin>>n>>m){\n        if(n==0&&m==0)break;\n        \n        rep(i,32)pass[i].clear();\n        cin>>s>>g;\n        s--,g--;\n        rep(i,m){\n            int x,y,D,c;\n            cin>>x>>y>>D>>c;\n            x--,y--;\n            pass[x].pb(pit2(y,make_tuple(D,c)));\n            pass[y].pb(pit2(x,make_tuple(D,c)));\n        }\n        double res = dijk(s,g);\n        if(res==INF)cout<<\"unreachable\"<<endl;\n        else printf(\"%.10lf\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ndouble ijk[30][31][31];\nint v[30][31][31];\nint g[30][30];\nint lim[30][30];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tint S,T;\n\t\tscanf(\"%d%d\",&S,&T);\n\t\tS--;T--;\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tg[i][j]=-1;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tp--;q--;\n\t\t\tg[p][q]=g[q][p]=r;\n\t\t\tlim[p][q]=lim[q][p]=s;\n\t\t}\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<31;j++)\n\t\t\tfor(int k=0;k<31;k++){ijk[i][j][k]=99999999;v[i][j][k]=0;}\n\t\tpriority_queue<pair<double,pair<pair<int,int>,int> > >Q;\n\t\tQ.push(make_pair(0,make_pair(make_pair(S,30),1)));\n\t\tijk[S][30][1]=0;\n\t\twhile(Q.size()){\n\t\t\tdouble cost=-Q.top().first;\n\t\t\tint at=Q.top().second.first.first;\n\t\t\tint prev=Q.top().xsecond.first.second;\n\t\t\tint ver=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(~prev&&v[at][prev][ver])continue;\n\t\t\tif(~prev)v[at][prev][ver]=1;\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tif(ver&&~g[at][i]&&lim[at][i]>=ver&&prev!=i){\n\t\t\t\t\tif(ijk[i][at][ver-1]>cost+(double)g[at][i]/ver){\n\t\t\t\t\t\tijk[i][at][ver-1]=cost+(double)g[at][i]/ver;\n\t\t\t\t\t\tQ.push(make_pair(-ijk[i][at][ver-1],make_pair(make_pair(i,at),ver-1)));\n\t\t\t\t\t}\n\t\t\t\t\tif(ijk[i][at][ver]>cost+(double)g[at][i]/ver){\n\t\t\t\t\t\tijk[i][at][ver]=cost+(double)g[at][i]/ver;\n\t\t\t\t\t\tQ.push(make_pair(-ijk[i][at][ver],make_pair(make_pair(i,at),ver)));\n\t\t\t\t\t}\n\t\t\t\t\tif(ver<30&&ijk[i][at][ver+1]>cost+(double)g[at][i]/ver){\n\t\t\t\t\t\tijk[i][at][ver+1]=cost+(double)g[at][i]/ver;\n\t\t\t\t\t\tQ.push(make_pair(-ijk[i][at][ver+1],make_pair(make_pair(i,at),ver+1)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ret=99999999;\n\t\tfor(int i=0;i<a;i++)ret=min(ret,ijk[T][i][0]);\n\t\tif(ret>9999999)printf(\"unreachable\\n\");\n\t\telse printf(\"%f\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdio>\n#include<cmath>\n#define inf 100000007\nusing namespace std;\n\nstruct State{\n  int speed,now,before;\n  double time;\n  State(double time,int speed,int now,int before):\n    time(time),speed(speed),now(now),before(before){}\n  bool operator<(State S)const{\n    return S.time < time;\n    }\n};\n\nint main()\n{\n  int n,m,s,g,a,b,d,l;\n  int dis[31][31],lim[31][31],S[3]={-1,0,1};\n  double dp[31][31][31],eps=1e-8; \n\n  while(1){\n    cin>>n>>m;\n    if(n+m==0)break;\n    cin>>s>>g;\n    s--;g--;\n    for(int i=0;i<31;i++){\n      for(int j=0;j<31;j++){\n\tdis[i][j]=inf;\n\tlim[i][j]=inf;\n\tfor(int k=0;k<31;k++)dp[i][j][k]=inf;\n      }\n    }\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>d>>l;\n      a--;b--;\n      dis[a][b]=d;\n      dis[b][a]=d;\n      lim[a][b]=l;\n      lim[b][a]=l;\n    }\n\n    double ans=inf;\n    priority_queue<State> pq;\n    pq.push(State(0,0,s,s));\n    dp[s][s][0]=0;\n    while(!pq.empty()){\n      State u=pq.top();\n      pq.pop();\n      //  cout<<u.now<<\" \"<<u.before<<endl;\n      if(u.now==g && u.speed==1){\n\tans=min(u.time,ans);\n\tcontinue;\n      }\n      if(u.time > dp[u.before][u.now][u.speed]+eps)continue;\n      /*\n      printf(\"%.10f\",u.f.f);\n      cout<<\" \"<<u.f.s<<\" \"<<u.s.f<<\" \"<<u.s.s<<endl;\n      */\n      for(int i=0;i<n;i++){\n\tif(i==u.now)continue;\n\tif(i==u.before)continue;\n      \tif(dis[u.now][i]==inf)continue;\n\tfor(int k=0;k<3;k++){\n\t  int speed = u.speed+S[k];\n\t  if( speed<1 || 30<speed )continue;\n\t  if( lim[u.now][i] < speed )continue;\n\t  double time=(double)dis[u.now][i]/(double)speed;\n\t  if( dp[u.now][i][speed] < time + u.time+eps)continue;\n\t  dp[u.now][i][speed] = time + u.time;\n\t  pq.push(State(time+u.time,speed,i,u.now));\n\t}\n      }\n    }\n    if(ans>=inf-1)cout<<\"unreachable\"<<endl;\n    else printf(\"%.6f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000.0\nusing namespace std;\nstruct state { int n, v, l; double t; };\n\nint N, M, S, G;\nvector<int> T[300], D[300], C[300];\nint vd[3] = { -1, 0, 1 };\ndouble dp[30][50];\n\nclass Compare {\npublic:\n  bool operator() (struct state a, struct state b) {\n    return a.t > b.t;\n  }\n};\n\nint main(void) {\n  while(cin >> N >> M, N) {\n    cin >> S >> G;\n    REP(i, 0, 30) {\n      T[i].clear();\n      D[i].clear();\n      C[i].clear();\n    }\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      T[x].push_back(y); D[x].push_back(d); C[x].push_back(c);\n      T[y].push_back(x); D[y].push_back(d); C[y].push_back(c);\n    }\n\n    REP(i, 1, N) REP(j, 0, 30) dp[i][j] = INF;\n\n    priority_queue<struct state, vector<struct state>, Compare> q;\n    struct state first = { S, 0, -1, 0.0 };\n    q.push(first);\n\n    while(!q.empty()) {\n      struct state c = q.top();\n      q.pop();\n\n      // cout << c.n << \" \" << c.v << \" \" << c.t << endl;\n\n      dp[c.n][c.v] = min(dp[c.n][c.v], c.t);\n      if(c.n == G && c.v == 1) break;\n\n      for(int i = 0; i < T[c.n].size(); i++) {\n        if(T[c.n][i] == c.l) continue;\n        REP(j, 0, 3) {\n          int v = c.v + vd[j];\n          if(v <= 0 || C[c.n][i] < v) continue;\n          double t = c.t + ((double) D[c.n][i] / v);\n          struct state n = { T[c.n][i], v, c.n, t };\n          if(n.t < dp[n.n][n.v]) q.push(n);\n        }\n      }\n    }\n\n    if(dp[G][1] < INF) printf(\"%.6f\\n\", dp[G][1]);\n    else cout << \"unreachable\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <cmath>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <deque>\n#define F first\n#define S second\n#define MAX_N 32\n#define MAX_D 32\n#define INF (1<<28)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef pair<int,P> iP;\ntypedef pair<int,int> iiP;\ntypedef pair<iiP,P> PP;\ntypedef vector<vector<iP> > VViP;\nint n,m,s,g;\nVViP G;\ndouble mincost[MAX_N][MAX_N][MAX_D]; // mincost[from][to][speed]\nint sp[] = {-1,0,+1};\n\nvoid dijkstra()\n{\n\n  deque<PP> deq; // iiPP(iiP(now,pre),P(cost,speed))\n\n  \n  deq.push_front(PP(iiP(s,s),P(0,1)));\n\n  mincost[s][s][1] = 0; \n  double ans = INF;  \n\n  \n  while(!deq.empty())\n    {\n      PP p = deq.front(); deq.pop_front();\n      int now,pre;\n      double cost,speed;\n      now = p.F.F, pre = p.F.S;\n      cost = p.S.F, speed = p.S.S;\n\n      if(cost >= ans)\n\tcontinue;      \n\n      if(now == g && speed == 1)\n\t{\n\t  ans = min(ans,cost);\t\n\t  continue;\n\t}\t\n\n      for(int i=0;i<G[now].size();i++)\n\t{\n\t  iP ip = G[now][i]; // VViP -> iP(to,P(distance,limit))\n\t  int to = ip.F;\n\t  double dis,lim;\n\t  dis = ip.S.F, lim = ip.S.S;\n\t  if(pre == to)\n\t    continue;\n\n\t  for(int j=0;j<3;j++)\n\t    {\n\t      double new_speed = speed + sp[j];\n\t      if(new_speed <= 0 || new_speed > lim)\n\t\tcontinue;\n\n\t      if(now == s && pre == s && new_speed != 1)\n\t\tcontinue;\n\n\t      if(mincost[now][to][(int)new_speed] > cost + (double)dis/new_speed)\n\t\t{\n\t\t  mincost[now][to][(int)new_speed] = cost + (double)dis/new_speed;\n\n\t\t  /*????????????*/\n\t\t  if(mincost[now][to][(int)new_speed] < deq.front().S.F)deq.push_front(PP(iiP(to,now),P(mincost[now][to][(int)new_speed],new_speed)));\n\t\t  else \n\t\t    deq.push_back(PP(iiP(to,now),P(mincost[now][to][(int)new_speed],new_speed)));\n\t\t}\n\t    }\n\n\t}\n\n    }\n  \n\n  if(ans == INF)\n    cout << \"unreachable\" << endl;\n  else \n    cout << setiosflags(ios::fixed) << setprecision(5) << ans << endl;\n  \n}\n\nint main()\n{\n\n  while(true)\n    {\n      cin >> n >> m;\n      if(n+m == 0)\n\tbreak;\n      G.clear();\n      G.resize(n+1);\n      rep(i,n+1)\n\trep(j,n+1)\n\t  rep(k,31)\n\t    mincost[i][j][k] = INF;\n\n      cin >> s >> g;\n      rep(i,m)\n\t{\n\t  int x,y;\n\t  double d,c;\n\t  cin >> x >> y >> d >> c;\n\t  G[x].push_back(iP(y,P(d,c)));\n\t  G[y].push_back(iP(x,P(d,c)));\n\t}\n      \n      dijkstra();\n  \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct N {\n  int i, d, c;\n};\n\nstruct M {\n  int i, bef, vel;\n  double d;\n};\n\nbool operator<(const M &l, const M &r) { return l.d > r.d; }\n\nint main() {\n  while (true) {\n    int n, m, s, g;\n    cin >> n >> m;\n    if (n + m == 0)\n      break;\n    cin >> s >> g;\n    s--;\n    g--;\n    vector<vector<N>> p(n);\n    for (int i = 0; i < m; i++) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      x--;\n      y--;\n      p[x].push_back(N{y, d, c});\n      p[y].push_back(N{x, d, c});\n    }\n    vector<vector<vector<bool>>> used(\n        n, vector<vector<bool>>(n + 1, vector<bool>(31)));\n    priority_queue<M> q;\n    q.push(M{s, n, 0, 0.});\n    bool breaked = false;\n    while (q.size()) {\n      M now = q.top();\n      q.pop();\n      if (now.i == g && now.vel <= 1) {\n        printf(\"%.9lf\\n\", now.d);\n        breaked = true;\n        break;\n      }\n      if (used[now.i][now.bef][now.vel])\n        continue;\n      used[now.i][now.bef][now.vel] = true;\n      for (auto &path : p[now.i]) {\n        if (path.i == now.bef)\n          continue;\n        for (int k = now.vel - 1; k <= now.vel + 1; k++) {\n          if (k <= 0)\n            continue;\n          if (k > path.c)\n            continue;\n          if (used[path.i][now.i][k])\n            continue;\n          q.push(M{path.i, now.i, k, now.d + (double)path.d / k});\n        }\n      }\n    }\n    if (breaked)\n      continue;\n    cout << \"unreachable\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\n// ??°????????¨?????????\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    int limit;\n    Edge(int src, int dst, Weight weight, int limit) :\n        src(src), dst(dst), weight(weight), limit(limit) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n#include <queue>\n\n// d,speed,v,from\ntypedef tuple<double,int,int,int> State;\n\nconst double inf = 1e100;\n\n// speed,v,from\ndouble dp[32][32][32];\nGraph g;\nint src,dst;\n\nconst char* solve(){\n    priority_queue<State> q;\n    q.emplace(0.0,0,src,31);\n    rep(i,32)rep(j,32)rep(k,32) dp[i][j][k] = inf;\n    dp[0][src][31] = 0;\n    while(q.size()){\n        double d; int speed, v, from;\n        tie(d,speed,v,from) = q.top(); q.pop();\n        d = -d;\n        if(v==dst && speed==1){\n            static char ans[100];\n            sprintf(ans,\"%.12lf\",d);\n            return ans;\n        }\n        if(d > dp[speed][v][from]) continue;\n        for(Edge & e : g[v]){\n            for(int diff : {-1,0,1}){\n                int ns = speed + diff;\n                if(ns < 1 || e.limit < ns) continue;\n                double nd = d + (double)e.weight / ns;\n                int nv = e.dst;\n                if(nv == from) continue;\n                if(dp[ns][nv][v] > nd){\n                    dp[ns][nv][v] = nd;\n                    q.emplace(-nd,ns,nv,v);\n                }\n            }\n        }\n    }\n    return \"unreachable\";\n}\n\nint main(){\n    int n,m;\n    while(~scanf(\"%d%d\", &n,&m) && n){\n        scanf(\"%d%d\",&src,&dst);\n        g.assign(n+1,{});\n        rep(i,m){\n            int x,y,d,c;\n            scanf(\"%d%d%d%d\", &x,&y,&d,&c);\n            g[x].eb(x,y,d,c);\n            g[y].eb(y,x,d,c);\n        }\n        puts(solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<pair<int,int>,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a2,a4;\ndouble d[31][31],a3;\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      scanf(\"%d%d%lf%d\",&a1,&a2,&a3,&a4);\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P>q;\n    d[st][0]=0;\n    P xtt;xtt.fi.fi=0,xtt.fi.se=st,xtt.se=-1;\n    q.push(xtt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.fi.se;\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=p.se)r(j,3){\n          int x=p.fi.fi+dx[j];\n          if(0<x&&x<=e.lim){\n            double t=e.dist/x+d[cur][p.fi.fi];\n            if(d[e.to][x]>t){\n              d[e.to][x]=t;\n              P xt;xt.fi.fi=x,xt.fi.se=e.to,xt.se=cur;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1162\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1162&lang=jp\n\n#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\nconst double inf = (double)(1<<24);\n\nclass Node {\npublic:\n    double time;\n    int v, town, prev;\n    Node() {}\n    Node( double time_, int v_, int town_, int prev_ ) \n    {\n        time = time_;\n        v = v_;\n        town = town_;\n        prev = prev_;\n    }\n    bool operator > ( const Node& right ) const\n    {\n        return time > right.time;\n    }\n};\ntypedef priority_queue <Node, vector <Node>, greater<Node> > QUEUE;\nconst int size = 31;\n\nint n, m;\nbool P[size][size];\ndouble G[size][size];\ndouble MC[size][size];\nint L[size][size];\nint CN[size][size];\nint CN_count[size];\n\n// dijkstra\nvoid solve( int start, int goal )\n{\n    // init\n    QUEUE Q;\n    Node start_node( 0.0, 0, start, -1 );\n    Q.push( start_node );\n    MC[1][start] = 0.0;\n\n    // proc\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        // proc init\n        double time = node.time;\n        int v = node.v;\n        int town = node.town;\n        int prev = node.prev;\n\n        // goal\n        if ( town == goal && v == 1 ) {\n            printf( \"%.5f\\n\", time );\n            return;\n        }\n\n        // move\n        for ( int i = 0; i < CN_count[town]; i++ ) {\n            int next_town = CN[town][i];\n            if ( next_town == prev ) continue;\n            for ( int j = 1; j >= -1; j-- ) {\n                int next_v = v + j;\n                if ( prev == -1 && next_v != 1 ) continue;\n                if ( next_v <= 0 || next_v > L[town][next_town] ) continue;\n                double cost = (double)G[town][next_town] / next_v;\n                double next_time = time + cost;\n                int next_prev = town;\n\n                if ( next_time > MC[next_v][next_town] || fabs( next_time - MC[next_v][next_town] ) < eps ) continue;\n                MC[next_v][next_town] = next_time;\n                Node next_node( next_time, next_v, next_town, next_prev );\n                Q.push( next_node );\n            }\n        }\n    }\n\n    cout << \"unreachable\" << endl;\n}\n\nint main( void )\n{\n    while ( cin >> n >> m ) {\n        // quit\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        for ( int i = 0; i < size; i++ ) {\n            CN_count[i] = 0;\n            for ( int j = 0; j < size; j++ ) {\n                P[i][j] = false;\n                MC[i][j] = inf;\n                G[i][j] = inf;\n                L[i][j] = 0;\n            }\n        }\n\n        // input\n        int s, g;\n        cin >> s >> g;\n        for ( int i = 0; i < m; i++ ) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n\n            P[x][y] = P[y][x] = true;\n            G[x][y] = G[y][x] = d;\n            L[x][y] = L[y][x] = c;\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( i == j ) continue;\n                if ( P[i][j] ) CN[i][CN_count[i]++] = j;\n            }\n        }\n\n        solve( s-1, g-1 );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <functional>\n#include <cstring>\n#include <utility>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nstruct edge {\n  double dist;\n  int limit;\n};\n\nstruct state {\n  double cost;\n  int pre, cur, v;\n  state(double d, int a, int b, int c):cost(d),pre(a),cur(b),v(c){}\n  bool operator<(const state& a) const {\n    return cost > a.cost;\n  }\n};\n\nconst int INF = 100000000, MAX_N = 31, MAX_V = 31;\nint n, m;\nedge e[1000];\nint graph[MAX_N][MAX_N];\nbool used[MAX_N][MAX_N][MAX_V];\n\nvoid solve() {\n  memset(graph, -1, sizeof graph);\n  memset(used, false, sizeof used);\n  \n  int s, g; cin>>s>>g;\n  rep(i,m) {\n    int x, y;\n    cin>>x>>y>>e[i].dist>>e[i].limit;\n    graph[x][y] = i;\n    graph[y][x] = i;\n  }\n  \n  double d[MAX_N][MAX_N][MAX_V];\n  rep(i,MAX_N) rep(j,MAX_N) rep(k,MAX_V) d[i][j][k] = INF;\n  priority_queue<state> que;\n  REP(i,1,n+1) if (graph[s][i] != -1) {\n    int en = graph[s][i];\n    if (e[en].limit < 1) continue;\n    d[s][i][1] = e[en].dist;\n    que.push(state(d[s][i][1],s,i,1));\n  }\n  \n  while (!que.empty()) {\n    state si = que.top(); que.pop();\n    double cost = si.cost;\n    int pre = si.pre, cur = si.cur, v = si.v;\n    \n    if (used[pre][cur][v]) continue;\n    used[pre][cur][v] = true;\n    \n    if (cur == g && v == 1) {\n      printf(\"%.4lf\\n\", cost); return;\n    }\n        \n    REP(i,1,n+1) if (graph[cur][i] != -1) {\n      if (i == pre || i == cur) continue;\n      int en = graph[cur][i];\n      REP(j,-1,2) {\n        if (v+j < 1 || v+j > e[en].limit) continue;\n        double ne = cost + e[en].dist / (v+j);\n        if (d[cur][i][v+j] > ne) {\n          d[cur][i][v+j] = ne;\n          que.push(state(ne, cur, i, v+j));\n        }\n      }\n    }\n  }\n  cout<<\"unreachable\"<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>n>>m, n||m) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\nconst double INF = 1e10;\n\nstruct Edge{\n  int cost, to, c;\n  Edge(int to, int cost, int c):\n    to(to), cost(cost), c(c) {}\n};\n\ndouble dijkstra(int s, int g, vector< vector<Edge> > &G){\n  int n = G.size();\n  vector< vector< vector<double> > > D(n,(vector< vector<double> >(n, vector<double>(30,INF))));\n  priority_queue< tuple<double,int,int,int> > wait;\n  wait.emplace(0,0,s,-1);//time, v, cur, from\n  while(!wait.empty()){\n    double t = -get<0>(wait.top());\n    int v = get<1>(wait.top()) + 1,\n      cur = get<2>(wait.top()), from = get<3>(wait.top());\n    wait.pop();\n    if(from != -1 && t >= D[cur][from][v-1]) continue;\n    if(from != -1) D[cur][from][v-1] = t;\n    for(int i = 0; i < G[cur].size(); ++i){\n      int to = G[cur][i].to, d = G[cur][i].cost, c = G[cur][i].c;\n      if(to == from) continue;\n      if(from != -1 && v+1 <= c && D[to][cur][v] > t + (double)d/(v+1))\n        wait.emplace(-t-(double)d/(v+1), v, to, cur);\n      if(v <= c && D[to][cur][v-1] > t + (double)d/v)\n        wait.emplace(-t-(double)d/v, v-1, to, cur);\n      if(v > 1 && v-1 <= c && D[to][cur][v-2] > t + (double)d/(v-1))\n        wait.emplace(-t-(double)d/(v-1), v-2, to, cur);\n    }\n  }\n  double ret = INF;\n  for(int i = 0; i < n; ++i) ret = min(ret,D[g][i][0]);\n  return ret;\n}\n\nint main(){\n  int n, m;\n  while(cin >> n >> m, n){\n    int s, g;\n    cin >> s >> g;\n    --s;\n    --g;\n    int x, y, d, c;\n    vector< vector<Edge> > G(n);\n    for(int i = 0; i < m; ++i){\n      cin >> x >> y >> d >> c;\n      --x;\n      --y;\n      G[x].emplace_back(y,d,c);\n      G[y].emplace_back(x,d,c);\n    }\n    double ans = dijkstra(s,g,G);\n    if(ans >= INF) cout << \"unreachable\" << endl;\n    else printf(\"%.12f\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n\nstruct edge {\n    int dst;\n    int dist;\n    int limit;\n};\n\nstruct entry {\n    double cost;\n    int city;\n    int prev;\n    int vel;\n\n    bool operator<(const entry& rhs) const { return cost > rhs.cost; }\n};\n\ndouble costs[30][30][31];\nbool visit[30][30][31];\n\nint main()\n{\n    int n, m;\n    while (cin >> n >> m, n) {\n        int s, g; cin >> s >> g; --s; --g;\n\n        vector<vector<edge>> edges(n);\n        rep(i, m) {\n            int x, y, d, c; cin >> x >> y >> d >> c; --x; --y;\n            edges[x].push_back({ y, d, c });\n            edges[y].push_back({ x, d, c });\n        }\n\n        rep(i, n) rep(j, n) rep(k, 31) {\n            costs[i][j][k] = 1e10;\n            visit[i][j][k] = false;\n        }\n\n        priority_queue<entry> Q;\n        Q.push({ 0.0, s, s, 0 });\n        costs[s][s][0] = 0.0;\n        double ans = 1e10;\n\n        while (!Q.empty()) {\n            entry t = Q.top(); Q.pop();\n            if (visit[t.city][t.prev][t.vel])\n                continue;\n            visit[t.city][t.prev][t.vel] = true;\n            if (t.city == g && t.vel == 1) {\n                ans = costs[g][t.prev][1];\n                break;\n            }\n\n            for (const edge& e : edges[t.city]) {\n                if (e.dst == t.prev) continue;\n                for (int v = max(1, t.vel - 1); v <= min(e.limit, t.vel + 1); ++v) {\n                    double new_cost = costs[t.city][t.prev][t.vel] + e.dist / double(v);\n                    if (new_cost < costs[e.dst][t.city][v]) {\n                        costs[e.dst][t.city][v] = new_cost;\n                        Q.push({ new_cost, e.dst, t.city, v });\n                    }\n                }\n            }\n        }\n\n        cout.precision(15);\n        if (ans == 1e10)\n            cout << \"unreachable\" << endl;\n        else\n            cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint n, m, s, g;\nint dv[] = {-1,0,1};\n\nstruct S{\n    int cur, prev, vel;\n    double dist;\n    S(int cur, int prev, int vel, double dist):cur(cur),prev(prev),vel(vel),dist(dist){}\n    bool operator>(const S &p) const{\n        return dist > p.dist;\n    }\n};\n\nint main() {\n    while(cin >> n >> m, n || m){\n        cin >> s >> g;\n        s--; g--;\n        vector<vector<pii> > path(n,vector<pii> (n,mp(INF,INF)));\n        rep(i,m){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            path[x][y] = mp(d,c);\n            path[y][x] = mp(d,c);\n        }\n\n        double d[32][32][32];\n        rep(i,32)rep(j,32)rep(k,32) d[i][j][k] = INF;\n        d[s][s][0] = 0;\n        priority_queue<S, vector<S>, greater<S> > que;\n        que.push(S(s,s,0,0));\n        double ans = -1;\n        while(!que.empty()){\n            S tmp = que.top(); que.pop();\n            int cur = tmp.cur, prev = tmp.prev, vel = tmp.vel;\n            double dist = tmp.dist;\n            if(dist > d[cur][prev][vel]) continue;\n            d[cur][prev][vel] = dist;\n            if(vel == 1 && cur == g) {\n                ans = dist;\n                break;\n            }\n            rep(i,n)rep(j,3){\n                if(i == prev || path[cur][i].first == INF) continue;\n                if(vel + dv[j] > 0 && vel + dv[j] <= path[cur][i].second){\n                    que.push(S(i,cur,vel+dv[j],dist + 1.0 * path[cur][i].first / (vel+dv[j])));\n                }\n            }\n        }\n        if(ans>=0) printf(\"%.8f\\n\",ans);\n        else cout << \"unreachable\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tstatic int adj[30][30],lim[30][30];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)\tadj[i][j]=-1;\n\n\t\tint s,g;\tscanf(\"%d%d\",&s,&g);\n\t\ts--,g--;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,l;\tscanf(\"%d%d%d%d\",&x,&y,&d,&l);\n\t\t\tx--,y--;\n\t\t\tadj[x][y]=adj[y][x]=d;\n\t\t\tlim[x][y]=lim[y][x]=l;\n\t\t}\n\n\t\tstatic bool visited[30][30];\n\t\tstatic double tmin[30][30];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<30;j++){\n\t\t\tvisited[i][j]=false;\n\t\t\ttmin[i][j]=1<<30;\n\t\t}\n\n\t\ttmin[s][0]=0;\n\t\tpriority_queue< pair<double,pii> > pq;\tpq.push(mp(0,mp(s,0)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<double,pii> a=pq.top();\tpq.pop();\n\t\t\tint u=a.second.first,sp=a.second.second;\n\t\t\tif(visited[u][sp])\tcontinue;\n\t\t\tvisited[u][sp]=true;\n\t\t\tif(u==g && sp==1)\tbreak;\n\n\t\t\tfor(int v=0;v<n;v++){\n\t\t\t\tif(adj[u][v]==-1)\tcontinue;\n\t\t\t\tfor(int dv=-1;dv<=1;dv++){\n\t\t\t\t\tint nextsp=sp+dv;\n\t\t\t\t\tif(1<=nextsp && nextsp<=lim[u][v]){\n\t\t\t\t\t\tdouble nextt=tmin[u][sp]+(double)adj[u][v]/nextsp;\n\t\t\t\t\t\tif(nextt<tmin[v][nextsp]){\n\t\t\t\t\t\t\tpq.push(mp(-nextt,mp(v,nextsp)));\n\t\t\t\t\t\t\ttmin[v][nextsp]=nextt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(visited[g][1])\tprintf(\"%f\\n\",tmin[g][1]);\n\t\telse\t\t\t\tputs(\"unreachable\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define MAX 30\n#define INF 10000000.0\nstruct S{\n\tint e,s,b;\n};\n\nstruct S2{\n\tint d,c,to;\n};\n\nint main(){\n\n\tint n,m;\n\tint s,g;\n\tint x,y,d,c;\n\tdouble cost[MAX+1][MAX+1];\n\tS point,tmp;\n\tS2 nod;\n\tvector<S2> ed[MAX+1];\n\tqueue<S> no;\n\n\twhile(1){\n\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0) break;\n\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(!ed[i].empty()) ed[i].clear();\n\t\t}\n\n\t\tfor(int i=0;i<=30;i++){\n\t\t\tfor(int j=0;j<=30;j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\n\t\tcin>>s>>g;\n\t\tpoint.e=s,point.s=0,point.b=0;\n\t\tcost[0][s]=0;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tnod.c=c,nod.d=d,nod.to=y;;\n\t\t\ted[x].push_back(nod);\n\t\t\tnod.to=x;\n\t\t\ted[y].push_back(nod);\n\t\t}\n\n\t\tno.push(point);\n\t\twhile(!no.empty()){\n\t\t\tpoint=no.front();\n\t\t\tno.pop();\n\t\t\tfor(int i=0;i<ed[point.e].size();i++){\n\t\t\t\tif(point.b!=ed[point.e][i].to){\n\t\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\tif(point.s+j>0&&point.s+j<=30){\n\t\t\t\t\t\t\t//if(point.s+j==1&&ed[point.e][i].to==g) cout<<cost[point.s][point.e]+((double)ed[point.e][i].d/(point.s+j))<<endl;\n\t\t\t\t\t\t\tif(ed[point.e][i].c>=point.s+j){\n\t\t\t\t\t\t\t\t//cout<<point.e<<\",\"<<point.b<<\",\"<<point.s<<\",\"<<ed[point.e][i].to<<\",\"<<cost[point.s][point.e]<<\"^^\"<<cost[point.s][point.e]+(double)ed[point.e][i].d/(point.s+j)<<endl;\n\t\t\t\t\t\t\t\tif(cost[point.s+j][ed[point.e][i].to]>cost[point.s][point.e]+((double)ed[point.e][i].d/(point.s+j))){\n\t\t\t\t\t\t\t\t\tcost[point.s+j][ed[point.e][i].to]=cost[point.s][point.e]+((double)ed[point.e][i].d/(point.s+j));\n\t\t\t\t\t\t\t\t\ttmp.e=ed[point.e][i].to;\n\t\t\t\t\t\t\t\t\ttmp.s=point.s+j;\n\t\t\t\t\t\t\t\t\ttmp.b=point.e;\n\t\t\t\t\t\t\t\t\tno.push(tmp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cost[1][g]==INF) printf(\"unreachable\\n\");\n\t\telse printf(\"%.5f\\n\",cost[1][g]);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\nusing namespace std;\n\n#define REP(i, b, n) for (int i = (b); i < (n); i++)\n#define rep(i, n) REP(i, 0, n)\n\nint n, m, s, g;\n\n#define MAX_N 30\n#define MAX_M (MAX_N*(MAX_N-1)/2)\n#define MAX_V 31\n#define INF 0xFFFF\ndouble cost[MAX_N][MAX_N][MAX_V];\n\ndouble dijkstra()\n{\n\tdouble dist[MAX_N][MAX_N][MAX_V];\n\tbool done[MAX_N][MAX_N][MAX_V];\n\trep(a, MAX_N) rep(b, MAX_N) rep(c, MAX_V) {\n\t\tdist[a][b][c] = INF;\n\t\tdone[a][b][c] = false;\n\t}\n\tpair<int, pair<int, int> > prev[MAX_N][MAX_N][MAX_V];\n\trep(a, n) rep(b, n) rep(c, MAX_V)\n\t\tprev[a][b][c] = make_pair(-1, make_pair(-1, -1));\n\t\n\tdist[0][s][0] = 0;\n\tfor (;;) {\n\t\tint u1 = -1, u2, u3;\n\t\trep(v1, n) rep(v2, n) rep(v3, MAX_V) {\n\t\t\tif (!done[v1][v2][v3] && (u1 == -1 || dist[u1][u2][u3] > dist[v1][v2][v3]))\n\t\t\t\tu1 = v1, u2 = v2, u3 = v3;\n\t\t}\n\t\tif (u1 == -1) break;\n\t\tdone[u1][u2][u3] = true;\n\t\tif (u2 == g && u3 == 1) {\n\t\t\t///*\n\t\t\tdouble ans = dist[u1][u2][u3];\n\t\t\tif (ans == INF) continue;\n\t\t\t/*\n\t\t\tvector< pair<int, int> > path;\n\t\t\twhile (u1 != -1) {\n\t\t\t\tpath.push_back(make_pair(u2, u3));\n\n\t\t\t\tpair<int, pair<int, int> > buf = prev[u1][u2][u3];\n\t\t\t\tu1 = buf.first;\n\t\t\t\tu2 = buf.second.first;\n\t\t\t\tu3 = buf.second.second;\n\t\t\t}\n\t\t\treverse(path.begin(), path.end());\n\t\t\trep(i, path.size())\n\t\t\t\tprintf(\"%d(%d v)%s\", path[i].first, path[i].second, (i==path.size()-1?\"\\n\":\" -> \"));\n\t\t\t*/\n\t\t\treturn ans;\n\t\t\t//return dist[u1][u2][u3];\n\t\t}\n\n\t\tint v1 = u2;\n\t\trep(v2, n) {\n\t\t\tif (v2 == v1) continue;\n\t\t\tfor (int d = -1; d <= 1; d++) {\n\t\t\t\tint v3 = u3+d;\n\t\t\t\tif (u2 == s && v3 != 1) continue;\n\t\t\t\tif (dist[v1][v2][v3] > dist[u1][u2][u3]+cost[v1][v2][v3]) {\n\t\t\t\t\tdist[v1][v2][v3] = min(dist[v1][v2][v3],\n\t\t\t\t\t\t\t\t\t   dist[u1][u2][u3]+cost[v1][v2][v3]);\n\t\t\t\t\tprev[v1][v2][v3] = make_pair(u1, make_pair(u2, u3));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\nint main()\n{\n\twhile (cin >> n >> m, n|m) {\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\n\t\trep(a, MAX_N) rep(b, MAX_N) rep(c, MAX_V) cost[a][b][c] = INF;\n\n\t\trep(T, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\n\t\t\trep(v, MAX_V)\n\t\t\t\tif (v <= c) {\n\t\t\t\t\tcost[x][y][v] = ((double)d)/v;\n\t\t\t\t\tcost[y][x][v] = cost[x][y][v];\n\t\t\t\t}\n\t\t}\n\t\tdouble ans = dijkstra();\n\t\tif (ans == INF)\n\t\t\tcout << \"unreachable\" << endl;\n\t\telse\n\t\t\tprintf(\"%.5lf\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<functional>\n#include<iomanip>\nusing namespace std;\n\n#define MAX_N 110\n#define INF 999999999.99\n\nint N, M, S, G, a, b, c, d;\ndouble X[MAX_N][MAX_N][2];\ndouble dist[MAX_N][MAX_N];\n\npriority_queue<tuple<double, int, int, int>, vector<tuple<double, int, int, int>>, greater<tuple<double, int, int, int>>>Q;\n\ndouble dijkstra() {\n\tdist[S][0] = 0;\n\tQ.push(make_tuple(0.0, S, 0, -1));\n\twhile (!Q.empty()) {\n\t\ttuple<double, int, int, int>tup = Q.top();\n\t\tQ.pop();\n\t\tdouble a1 = get<0>(tup);\n\t\tint a2 = get<1>(tup);\n\t\tint a3 = get<2>(tup);\n\t\tint a4 = get<3>(tup);\n\t\tfor (int i = 1; i <= N; i++)\n\t\t{\n\t\t\tif (i != a4) {\n\t\t\t\t//X-1.\n\t\t\t\tif (a3 >= 1 && X[a2][i][1] >= a3 - 1) {\n\t\t\t\t\tif (dist[i][a3 - 1] > X[a2][i][0] / (a3 - 1) + a1) {\n\t\t\t\t\t\tdist[i][a3 - 1] = X[a2][i][0] / (a3 - 1) + a1;\n\t\t\t\t\t\tQ.push(make_tuple(dist[i][a3 - 1], i, a3 - 1, a2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//X.\n\t\t\t\tif (a3 >= 0 && X[a2][i][1] >= a3) {\n\t\t\t\t\tif (dist[i][a3] > X[a2][i][0] / a3 + a1) {\n\t\t\t\t\t\tdist[i][a3] = X[a2][i][0] / a3 + a1;\n\t\t\t\t\t\tQ.push(make_tuple(dist[i][a3], i, a3, a2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//X+1.\n\t\t\t\tif (a3 >= -1 && X[a2][i][1] >= a3 + 1) {\n\t\t\t\t\tif (dist[i][a3 + 1] > X[a2][i][0] / (a3 + 1) + a1) {\n\t\t\t\t\t\tdist[i][a3 + 1] = X[a2][i][0] / (a3 + 1) + a1;\n\t\t\t\t\t\tQ.push(make_tuple(dist[i][a3 + 1], i, a3 + 1, a2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[G][1];\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) { break; }\n\t\tcin >> S >> G;\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tX[i][j][0] = INF;\n\t\t\t\tX[i][j][1] = 0.0;\n\t\t\t\tdist[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tX[a][b][0] = c;\n\t\t\tX[b][a][0] = c;\n\t\t\tX[a][b][1] = d;\n\t\t\tX[b][a][1] = d;\n\t\t}\n\t\tdouble res = dijkstra();\n\t\tif (res > INF / 2) { cout << \"unreachable\" << endl; }\n\t\telse { cout << fixed << setprecision(15) << res << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\n#define INF 1e9\n#define MAX_SPEED 30\n\nvector<vector<vector<double> > > dijk(int s_point, int s_speed, vector<vector<vector<pair<double, pair<int, int> > > > >& adj){\n  int v = adj.size();\n  int t = adj[0].size();\n  vector<vector<vector<double> > > result(v, vector<vector<double> >(v, vector<double>(t, INF)));\n  priority_queue<pair<double, pair<int, pair<int, int> > > > wait;\n  wait.push(make_pair(0, make_pair(0, make_pair(s_point, s_speed))));\n  for(int i = 0; i < v; i++){ result[s_point][i][s_speed] = 0; }\n  \n  while(!wait.empty()){\n    double nowcost = -wait.top().first;\n    int prevpoint = wait.top().second.first;\n    int nowpoint = wait.top().second.second.first;\n    int nowspeed = wait.top().second.second.second;\n    wait.pop();\n    if(result[nowpoint][prevpoint][nowspeed] < nowcost){ continue; }\n\n    \n    for(size_t i = 0; i < adj[nowpoint][nowspeed].size(); i++){\n      double nextcost = adj[nowpoint][nowspeed][i].first + nowcost;\n      int nextpoint = adj[nowpoint][nowspeed][i].second.first;\n      int nextspeed = adj[nowpoint][nowspeed][i].second.second;\n      if(nextpoint != prevpoint && result[nextpoint][nowpoint][nextspeed] > nextcost){\n        wait.push(make_pair(-nextcost, make_pair(nowpoint, make_pair(nextpoint, nextspeed))));\n        result[nextpoint][nowpoint][nextspeed] = nextcost;\n      }\n    }\n  }\n\n  return result;\n}\n\nint main(void){\n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    int s, g;\n    cin >> s >> g;\n    --s; --g;\n\n    int x, y, d, c;\n    vector<vector<vector<pair<double, pair<int, int> > > > > adjlist(n,\n                                                                     vector<vector<pair<double, pair<int, int> > > >(MAX_SPEED + 1));\n    for(int i = 0; i < m; i++){\n      cin >> x >> y >> d >> c;\n      --x; --y;\n      for(int j = 0; j <= MAX_SPEED; j++){\n        if(1 <= j - 1 && j - 1 <= c)\n          adjlist[x][j].push_back(make_pair((double)d / (j - 1), make_pair(y, j - 1)));\n        if(1 <= j && j <= c)\n          adjlist[x][j].push_back(make_pair((double)d / j, make_pair(y, j)));\n        if(j + 1 <= c)\n          adjlist[x][j].push_back(make_pair((double)d / (j + 1), make_pair(y, j + 1)));\n      }\n    }\n    double ans = INF;\n    vector<vector<vector<double> > > result = dijk(s, 0, adjlist);\n    for(int i = 0; i < n; i++){ ans = min(ans, result[g][i][1]); }\n    if(ans > INF - 1){ cout << \"unreachable\" << endl; }\n    else{ printf(\"%.10f\\n\", ans); }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n \nusing namespace std;\n \n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF 1e11\nconst int MAX_SPEED = 30;\n\nstruct P {\n    int city;\n    int speed;\n    float dist;\n\n    bool operator >(const P& p) const {\n        return dist > p.dist;\n    }\n};\n\nstruct edge{\n    int to, dist, limit;\n};\n\ntypedef vector<float> vf;\ntypedef vector<vf> vvf;\ntypedef vector<vvf> vvvf;\n\nint main() {\n    int city_n, road_n, start, goal;\n\n    while(cin >> city_n >> road_n, city_n | road_n){\n        cin >> start >> goal;\n\n        vector<vector<edge>> E(city_n + 1);\n\n        REP(i, road_n){\n            int x, y, d, l;\n            cin >> x >> y >> d >> l;\n            E[x].push_back({y, d, l});\n            E[y].push_back({x, d, l});\n        }\n        vvvf G(city_n + 1, vvf(city_n + 1, vf(MAX_SPEED + 1, INF)));\n        G[start][start][1] = 0;\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({start, 0, 0.0});\n\n        float res = -1;\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n\n            if(p.city == goal && p.speed == 1){\n                res = p.dist;\n                break;\n            }\n\n            for(auto e : E[p.city]) {\n                FOR(d, -1, 1 + 1){\n                    int next_speed = p.speed + d;\n                    if (next_speed == 0) continue;\n                    float next_dist = p.dist + (float)e.dist / next_speed;\n                    if (0 < next_speed && next_speed <= MAX_SPEED &&\n                        next_speed <= e.limit &&\n                        G[e.to][p.city][next_speed] > next_dist) {\n                        G[e.to][p.city][next_speed] = next_dist;\n                        que.push({e.to, next_speed, next_dist});\n                    }\n                }\n            }\n        }\n\n        if(res == -1)\n            cout << \"unreachable\" << endl;\n        else\n            printf(\"%f\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\nstruct Info{\n\tint now,bef,sp;\n\tInfo(int _now,int _bef,int _sp){\n\t\tnow=_now;\n\t\tbef=_bef;\n\t\tsp=_sp;\n\t}\n};\n\nbool operator<(const Info &i1,const Info &i2){\n\treturn true;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tstatic int adj[30][30],lim[30][30];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)\tadj[i][j]=-1;\n\n\t\tint s,g;\tscanf(\"%d%d\",&s,&g);\n\t\ts--,g--;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,l;\tscanf(\"%d%d%d%d\",&x,&y,&d,&l);\n\t\t\tx--,y--;\n\t\t\tadj[x][y]=adj[y][x]=d;\n\t\t\tlim[x][y]=lim[y][x]=l;\n\t\t}\n\n\t\tstatic bool visited[30][30][31];\n\t\tstatic double tmin[30][30][31];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)for(int k=0;k<=30;k++){\n\t\t\tvisited[i][j][k]=false;\n\t\t\ttmin[i][j][k]=1<<30;\n\t\t}\n\n\t\ttmin[s][s][0]=0;\n\t\tdouble ans=-1;\n\t\tpriority_queue< pair<double,Info> > pq;\tpq.push(mp(0,Info(s,s,0)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<double,Info> a=pq.top();\tpq.pop();\n\t\t\tint u=a.second.now,bef=a.second.bef,sp=a.second.sp;\n\t\t\tif(visited[u][bef][sp])\tcontinue;\n\t\t\tvisited[u][bef][sp]=true;\n\t\t\tif(u==g && sp==1){\n\t\t\t\tans=tmin[u][bef][sp];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int v=0;v<n;v++){\n\t\t\t\tif(adj[u][v]==-1 || v==bef)\tcontinue;\n\t\t\t\tfor(int dv=-1;dv<=1;dv++){\n\t\t\t\t\tint nextsp=sp+dv;\n\t\t\t\t\tif(1<=nextsp && nextsp<=lim[u][v]){\n\t\t\t\t\t\tdouble nextt=tmin[u][bef][sp]+(double)adj[u][v]/nextsp;\n\t\t\t\t\t\tif(nextt<tmin[v][u][nextsp]){\n\t\t\t\t\t\t\tpq.push(mp(-nextt,Info(v,u,nextsp)));\n\t\t\t\t\t\t\ttmin[v][u][nextsp]=nextt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans<0)\tputs(\"unreachable\");\n\t\telse\t\tprintf(\"%f\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint n, m;\n\t\tcin>>n>>m;\n\t\tif(n == 0 && m == 0) break;\n\t\tint s, g;\n\t\tcin>>s>>g;\n\t\t--s;\n\t\t--g;\n\t\tvector<vector<pair<ll, P> > > p(n);\n\t\tvector<vector<vector<double> > > d(n, vector<vector<double> >(n, vector<double>(31, INF)));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\t--x;\n\t\t\t--y;\n\t\t\tp[x].pb({y, P(d, c)});\n\t\t\tp[y].pb({x, P(d, c)});\n\t\t}\n\t\tpriority_queue<pair<pair<double, ll>, P>, vector<pair<pair<double, ll>, P> >, greater<pair<pair<double, ll>, P> > > q;\n\t\tREP(i, n) {\n\t\t\td[0][i][1] = 0;\n\t\t}\n\t\tq.push({{0, 0}, {0, 1}});\n\t\twhile(!q.empty()) {\n\t\t\tpair<pair<double, ll>, P> np = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[np.first.second][np.second.first][np.second.second] != np.first.first) continue;\n\t\t\tFOR(i, -1, 2) {\n\t\t\t\tll ns = np.second.second + i;\n\t\t\t\tif(np.first.second == 0 && np.second.first == 0) {\n\t\t\t\t\tif(ns != 1) continue;\n\t\t\t\t}\n\t\t\t\tif(ns <= 0) continue;\n\t\t\t\tREP(j, p[np.first.second].size()) {\n\t\t\t\t\tll next = p[np.first.second][j].first;\n\t\t\t\t\tif(next == np.second.first) continue;\n\t\t\t\t\tif(p[np.first.second][j].second.second < ns) continue;\n\t\t\t\t\tif(d[next][np.first.second][ns] > d[np.first.second][np.second.first][np.second.second] + p[np.first.second][j].second.first / (double)ns) {\n\t\t\t\t\t\td[next][np.first.second][ns]  = d[np.first.second][np.second.first][np.second.second] + p[np.first.second][j].second.first / (double)ns;\n\t\t\t\t\t\tq.push({{d[next][np.first.second][ns], next}, {np.first.second, ns}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = INF;\n\t\tREP(i, n) {\n\t\t\tans = min(ans, d[g][i][1]);\n\t\t}\n\t\tif(ans != INF) cout<<fixed<<showpoint<<setprecision(39)<<ans<<endl;\n\t\telse cout<<\"unreachable\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\n\nclass Dijkstra {\n    using T = double;\npublic:\n    struct edge {\n        int to;\n        T cost;\n    };\n    typedef pair<T, int> P;//firstは最短距離、secondは頂点の番号\n\n    int V;//超点数\n    vector<vector<edge> > G;//グラフ,G[i]はiから出る辺の集合,G[i][j]はiから出る辺のj番目の辺\n    vector<T> d; //最短距離\n\n    //0origin\n    Dijkstra(int N) {\n        V = N;\n        G = vector<vector<edge> >(N);\n        d = vector<T>(N);\n    };\n\n    void dijkstra(int s) {\n        priority_queue<P, vector<P>, greater<P> > que;\n        fill(d.begin(), d.end(), INFl);\n        d[s] = 0;\n        que.push(P(0, s));\n\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if (d[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge e = G[v][i];\n                if (d[e.to] > d[v] + e.cost && !(d[e.to] == INFl && d[v] == INFl)) {\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n\n    }\n\n    /* 頂点fromに頂点toに達するコストcostの辺を貼る */\n    void addEdge(int from, int to, T cost) {\n        edge e;\n        e.to = to;\n        e.cost = cost;\n        G[from].push_back(e);\n    }\n};\n\nvoid solve(int n, int m) {\n    int s, g;\n    cin >> s >> g;\n    s--;\n    g--;\n\n    auto conv = [&](int f, int t, int v) {\n        //(頂点、速度)\n        return v * n * n + f * n + t;\n    };\n\n    Dijkstra dij(200 * n * n + n * n + n);\n\n    rep(i, 0, m) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        x--;\n        y--;\n        auto check = [&](int v) {\n            return v > 0 && v <= c;\n        };\n        rep(v, 0, 31) {\n            for (int V = v - 1; V <= v + 1; V++) {\n//                if(check(V)){\n//                    double tmp = 1.0 * d / V;\n//                    dij.addEdge(conv(x,v),conv(y,V),tmp);\n//                    dij.addEdge(conv(y,v),conv(x,V),tmp);\n//                }\n                for (int f = 0; f < n; f++) {\n                    if (check(V)) {\n                        double tmp = 1.0 * d / V;\n                        if (f != y) {\n                            dij.addEdge(conv(f, x, v), conv(x, y, V), tmp);\n                        }\n                        if (f != x) {\n                            dij.addEdge(conv(f, y, v), conv(y, x, V), tmp);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    dij.dijkstra(conv(s, s, 0));\n//    cout << dij.d[conv(g,1)] << endl;\n    double ans = INFl;\n    rep(i, 0, n) {\n        ans = min(ans, dij.d[conv(i, g, 1)]);\n    }\n    if (ans == INFl) {\n        cout << \"unreachable\" << endl;\n    } else {\n//        cout << ans << endl;\n        printf(\"%.5lf\\n\", ans);\n    }\n\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nstruct P{\n  double t;\n  int v,p,pre;\n  P(){};\n  P(double T,int V,int pp,int PRE){\n    t=T;v=V;p=pp;pre=PRE;\n  };\n  bool operator<(const P &p)const{\n    return t>p.t;\n  }\n};\nstruct Path{\n  int d,c;\n  Path(){};\n  Path(int D,int C){ d=D;c=C;};\n};\n\nint main(){\n  int n,m;\n  int s,g;\n  int x,y,d,c;\n  Path path[30][30];\n  //priority_queue<P,vector<P>,greater<P> > q;\n  priority_queue<P> q;\n\n  while( cin>>n>>m && (n|m) ){\n    cin >> s >> g;\n    s--; g--;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tpath[i][j].d=-1.0; path[i][j].c=-1;\n      }\n\n    for( int i=0;i<m;i++ ){\n      cin >> x >> y >> d >> c;\n      x--;y--;\n      path[x][y].d=d; path[x][y].c=c;\n      path[y][x] = path[x][y];\n    }\n\n    while( !q.empty() ) q.pop();\n\n    double cost[30][35]; // place,velocity\n    int dv[3] = {-1,0,1};\n    for( int i=0;i<n;i++ ){\n      for( int j=1;j<31;j++ )\n\tcost[i][j] = DBL_MAX;\n    }\n\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      double nt = path[s][i].d;\n      q.push( P(nt,1,i,-1) );\n      cost[i][1] = nt;\n    }\n\n    while( !q.empty() ){\n      P p = q.top(); q.pop();\n      double t = p.t;\n      int v = p.v;\n      int np = p.p; // 現在地\n      int pre = p.pre;\n\n      /*\n      cout << \"v=\" << v << \" p=\" << np << \" pre=\" << pre \n\t   << \" t=\" << t << endl;\n      */\n\n      for( int i=0;i<n;i++ ){\n\tif( path[np][i].c<0 ) continue;// たどり着けないノード\n\tif( i==pre ) continue; // 前回のノード\n\n\tfor( int j=0;j<3;j++ ){\n\t  int nv = v + dv[j];\n\t  if( nv==0 ) continue;\n\t  if( nv>path[np][i].c ) continue;\n\t  double nCost = t + (double)path[np][i].d/nv;\n\t  if( cost[i][nv] < nCost ) continue;\n\t  cost[i][nv]=nCost;\n\t  if( i==g && nv==1 ) continue;\n\t  q.push( P(nCost,nv,i,np) );\n\t}\n      }\n\n    }\n    if( fabs(cost[g][1]-DBL_MAX)<1e-4 )\n      cout << \"unreachable\" << endl;\n    else\n      //      cout << cost[g][1] << endl;\n      printf(\"%.6lf\\n\",cost[g][1]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<functional>\n#include<queue>\n#include<tuple>\n\nusing namespace std;\n\ntypedef tuple<double, int, int, int> Td3i;\n\ndouble EPS = 0.001;\n\nstruct edge {\n\tint to, dis, limit;\n\tedge(int a, int b, int c) { to = a, dis = b, limit = c; }\n};\n\nint n, m, s, g;\nvector<vector<edge>> E;\ndouble ans[30][31][30 + 1];\ndouble INF = 114514;\n\nvoid djk(int start) {\n\tpriority_queue<Td3i, vector<Td3i>, greater<Td3i>> pq;\n\n\tfor (int i = 0; i < E[s].size(); i++) {\n\t\tint nextp = E[s][i].to, dis = E[s][i].dis;\n\n\t\t//最初はそのままの速度でいく\n\t\tif (ans[nextp][1][s] > (double)dis / 1.0) {\n\t\t\tans[nextp][1][s] = (double)dis / 1.0;\n\t\t\tpq.push(make_tuple(ans[nextp][1][s], nextp, 1, s));\n\t\t}\n\n\t}\n\n\twhile (pq.size()) {\n\t\tauto tmp = pq.top(); pq.pop();\n\t\tint npos = get<1>(tmp);\n\t\tint speed = get<2>(tmp);\n\t\tint before = get<3>(tmp);\n\n\t\tif (ans[npos][speed][before] != get<0>(tmp))continue;\n\n\t\tfor (int i = 0; i < E[npos].size(); i++) {\n\t\t\tint nextp = E[npos][i].to, dis = E[npos][i].dis, limit = E[npos][i].limit;\n\n\t\t\tif (nextp == before)continue;\n\n\t\t\t//そのままの速度でいく\n\t\t\tif (speed <= limit && speed >= 1) {\n\t\t\t\tif (ans[nextp][speed][npos] > ans[npos][speed][before] + (double)dis / (double)speed) {\n\t\t\t\t\tans[nextp][speed][npos] = ans[npos][speed][before] + (double)dis / (double)speed;\n\t\t\t\t\tpq.push(make_tuple(ans[nextp][speed][npos], nextp, speed, npos));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//加速する\n\t\t\tif (speed + 1 <= limit && speed >= 1) {\n\t\t\t\tif (ans[nextp][speed + 1][npos] > ans[npos][speed][before] + (double)dis / (double)(speed + 1)) {\n\t\t\t\t\tans[nextp][speed + 1][npos] = ans[npos][speed][before] + (double)dis / (double)(speed + 1);\n\t\t\t\t\tpq.push(make_tuple(ans[nextp][speed + 1][npos], nextp, speed + 1, npos));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//減速する\n\t\t\tif (speed >= 2 && speed - 1 <= limit) {\n\t\t\t\tif (ans[nextp][speed - 1][npos] > ans[npos][speed][before] + (double)dis / (double)(speed - 1)) {\n\t\t\t\t\tans[nextp][speed - 1][npos] = ans[npos][speed][before] + (double)dis / (double)(speed - 1);\n\t\t\t\t\tpq.push(make_tuple(ans[nextp][speed - 1][npos], nextp, speed - 1, npos));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nint main() {\n\n\twhile (1) {\n\n\t\tfor (int i = 0; i < 30; i++) {\n\t\t\tfor (int j = 0; j <= 30; j++)\n\t\t\t\tfor (int k = 0; k < 30 + 1; k++)ans[i][j][k] = INF;\n\t\t}\n\n\t\tcin >> n >> m;\n\t\tif (n + m == 0)break;\n\t\tcin >> s >> g;\n\t\ts--, g--;\n\t\tE.resize(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--, b--;\n\t\t\tE[a].push_back(edge(b, c, d));\n\t\t\tE[b].push_back(edge(a, c, d));\n\t\t}\n\n\t\tdjk(s);\n\n\t\tdouble ANS = INF;\n\t\tfor (int i = 0; i < n; i++)ANS = min(ANS, ans[g][1][i]);\n\t\tif (ANS == INF) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ANS << endl;\n\t\t}\n\t\tE.clear();\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000.0\n#define EPS 1e-8\nusing namespace std;\nstruct state { int n, v, l; double t; };\n\nint N, M, S, G;\nvector<int> T[31], D[31], C[31];\nint vd[3] = { -1, 0, 1 };\ndouble dp[31][51];\n\nclass Compare {\npublic:\n  bool operator() (struct state a, struct state b) {\n    return a.t > b.t;\n  }\n};\n\nint main(void) {\n  while(cin >> N >> M, N) {\n    cin >> S >> G;\n    REP(i, 0, 30) {\n      T[i].clear();\n      D[i].clear();\n      C[i].clear();\n    }\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      T[x].push_back(y); D[x].push_back(d); C[x].push_back(c);\n      T[y].push_back(x); D[y].push_back(d); C[y].push_back(c);\n    }\n\n    REP(i, 1, N) REP(j, 0, 50) dp[i][j] = INF;\n\n    priority_queue<struct state, vector<struct state>, Compare> q;\n    struct state first = { S, 0, -1, 0.0 };\n    q.push(first);\n\n    while(!q.empty()) {\n      struct state c = q.top();\n      q.pop();\n\n      // cout << c.n << \" \" << c.v << \" \" << c.t << endl;\n\n      dp[c.n][c.v] = min(dp[c.n][c.v], c.t);\n      if(c.n == G && c.v == 1) break;\n\n      for(int i = 0; i < T[c.n].size(); i++) {\n        if(T[c.n][i] == c.l) continue;\n        REP(j, 0, 3) {\n          int v = c.v + vd[j];\n          if(v <= 0 || C[c.n][i] < v) continue;\n          double t = c.t + ((double) D[c.n][i] / v);\n          struct state n = { T[c.n][i], v, c.n, t };\n          if(n.t < dp[n.n][n.v] - EPS) q.push(n);\n        }\n      }\n    }\n\n    if(dp[G][1] < INF) printf(\"%.6f\\n\", dp[G][1]);\n    else cout << \"unreachable\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nstruct edge{ int to, cap, d;};\nstruct node{\n    int p, v, prev; double d;\n    node(int p, int v, int prev, double d):p(p),v(v),prev(prev),d(d){}\n    bool operator<(const node &n)const{ return d > n.d;}\n};\nconst int dv[] = {-1,0,1};\nint done[32][32][32], N, M, s, t;\ndouble dist[32][32][32];\nvector<edge> G[32];\n\nvoid solve(){\n    priority_queue<node> q;\n    q.push(node(s,0,s,0));\n    while(!q.empty()){\n        node u = q.top(); q.pop();\n        if(done[u.p][u.v][u.prev]) continue;\n        if(u.p == t and u.v == 1){\n            printf(\"%.8f\\n\", u.d);\n            return;\n        }\n        done[u.p][u.v][u.prev] = 1;\n        dist[u.p][u.v][u.prev] = u.d;\n        rep(i,G[u.p].size()){\n            edge &e = G[u.p][i];\n            if(e.to == u.prev) continue;\n            rep(j,3){\n                int nv = u.v + dv[j];\n                if(nv > 0 and nv <= e.cap)\n                    q.push(node(e.to, nv, u.p, 1.*e.d/nv+u.d));\n            }\n        }\n    }\n    puts(\"unreachable\");\n}\n\nvoid input(){\n    cin >> s >> t;\n    s--; t--;\n    rep(i,M){\n        int x, y, d, c; cin >> x >> y >> d >> c;\n        x--; y--;\n        G[x].pb((edge){y,c,d});\n        G[y].pb((edge){x,c,d});\n    }\n}\n\nvoid init(){\n    rep(i,32) G[i].clear();\n    memset(done, 0, sizeof(done));\n}\n\nint main()\n{\n    while(cin  >> N >> M, N or M){\n        init();\n        input();\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define pb push_back\n#define INF 1e10\nusing namespace std;\n\nstruct edge { int v, d, c; };\nstruct state {\n  int n, p, v;\n  double t;\n  bool operator<(const state &s) const {\n    return t > s.t;\n  }\n};\n\nint N, M, S, G, X, Y, D, C;\nvector<edge> E[50];\ndouble dp[50][50][50];\n\nint main(void) {\n  while(cin >> N >> M, N || M) {\n    cin >> S >> G; S--; G--;\n    REP(i, 0, 50) E[i].clear();\n    REP(i, 0, M) {\n      cin >> X >> Y >> D >> C; X--; Y--;\n      E[X].pb((edge) { Y, D, C });\n      E[Y].pb((edge) { X, D, C });\n    }\n\n    priority_queue<state> q;\n    REP(i, 0, E[S].size()) q.push((state) { E[S][i].v, S, 1, (double) E[S][i].d });\n    REP(i, 0, 50) REP(j, 0, 50) REP(k, 0, 50) dp[i][j][k] = INF;\n\n    double ans = -1;\n    while(q.size()) {\n      state c = q.top();\n      q.pop();\n\n      if(c.t >= dp[c.n][c.p][c.v]) continue;\n      dp[c.n][c.p][c.v] = c.t;\n\n      if(c.n == G && c.v == 1) {\n        ans = c.t;\n        break;\n      }\n\n      REP(i, 0, E[c.n].size()) {\n        int nn = E[c.n][i].v;\n        if(nn == c.p) continue;\n        REP(j, -1, 2) {\n          int np = c.n;\n          int nv = c.v + j;\n          if(nv <= 0 || nv > E[c.n][i].c) continue;\n          double nt = c.t + ((double) E[c.n][i].d / nv);\n          q.push((state) { nn, np, nv, nt });\n        }\n      }\n    }\n    if(ans < 0) cout << \"unreachable\" << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nclass data\n{\npublic:\n\tint p, q, c;\n\tdata(int p0, int q0, int c0){\n\t\tp = p0;\n\t\tq = q0;\n\t\tc = c0;\n\t}\n};\n\nvoid solve(int n, int start, int goal, vector<vector<int> > distance, vector<vector<int> > limit)\n{\n\tvector<bool> easyCheck(n, false);\n\tqueue<int> q;\n\tq.push(start);\n\twhile(!q.empty()){\n\t\tint a = q.front();\n\t\tif(!easyCheck[a]){\n\t\t\teasyCheck[a] = true;\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tif(distance[a][i] > -1)\n\t\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t}\n\tif(!easyCheck[goal]){\n\t\tcout << \"unreachable\" << endl;\n\t\treturn;\n\t}\n\n\tvector<vector<vector<bool> > > check(n, vector<vector<bool> >(n, vector<bool>(31, false)));\n\tmultimap<double, data> m;\n\tfor(int i=0; i<n; ++i){\n\t\tif(distance[start][i] > -1)\n\t\t\tm.insert(make_pair(distance[start][i], data(i, start, 1)));\n\t}\n\n\tfor(;;){\n\t\tmultimap<double, data>::iterator it = m.begin();\n\t\tdouble t = it->first;\n\t\tint p = it->second.p;\n\t\tint q = it->second.q;\n\t\tint c = it->second.c;\n\t\tif(p == goal && c == 1){\n\t\t\tprintf(\"%.10f\\n\", t);\n\t\t\treturn;\n\t\t}\n\t\tm.erase(it);\n\t\t\n\t\tif(!check[p][q][c]){\n\t\t\tcheck[p][q][c] = true;\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tfor(int j=-1; j<=1; ++j){\n\t\t\t\t\tif(i != p && i != q && distance[i][p] > -1 && 0 < c+j && c+j <= limit[p][i])\n\t\t\t\t\t\tm.insert(make_pair(t+distance[p][i]/static_cast<double>(c+j), data(i, p, c+j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfor(;;){\n\t\tint n, m, s, g;\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0)\n\t\t\tbreak;\n\t\tcin >> s >> g;\n\t\t-- s;\n\t\t-- g;\n\n\t\tvector<vector<int> > distance(n, vector<int>(n, -1));\n\t\tvector<vector<int> > limit(n, vector<int>(n, -1));\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\t-- x;\n\t\t\t-- y;\n\t\t\tcin >> distance[x][y] >> limit[x][y];\n\t\t\tdistance[y][x] = distance[x][y];\n\t\t\tlimit[y][x] = limit[x][y];\n\t\t}\n\n\t\tsolve(n, s, g, distance, limit);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nstruct edge{\n\tint cost,limit;\n\tedge(int c,int l){\n\t\tcost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tvector<vector<edge> > E(n+1,vector<edge>(n+1,edge(-1,-1)));\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in][out]=edge(c,l);\n\t\tE[out][in]=edge(c,l);\n\t}\n\n\tdouble Ans[31][31][31];\n\tmemset(Ans,-1,sizeof(Ans));\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){\n\t\tNode t=Q.top(); Q.pop();\n\t\tif(Ans[t.now][t.before][t.speed]<=t.time && Ans[t.now][t.before][t.speed]>=0) continue;\n//\t\tcout<<t.now<<\" \"<<t.speed<<\" \"<<t.time<<endl;\n\t\tif(t.now==g && t.speed==1){printf(\"%.12lf\\n\", t.time );  return;}\n\t\tAns[t.now][t.before][t.speed]=t.time;\n\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tif(i==t.before) continue;\n\t\t\tif(E[t.now][i].cost>0){\n\t\t\t\tif(E[t.now][i].limit>=t.speed && t.speed>=1){\n\t\t\t\t\tQ.push(Node(i,t.speed,t.time+E[t.now][i].cost/(double)t.speed,t.now));\n\t\t\t\t}\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed+1)\n\t\t\t\t\tQ.push(Node(i,t.speed+1,t.time+E[t.now][i].cost/(double)(t.speed+1.0),t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed-1 && t.speed-1>=1)\n\t\t\t\t\tQ.push(Node(i,t.speed-1,t.time+E[t.now][i].cost/(double)(t.speed-1.0),t.now));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\"<<endl;\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 30;\nconst int INF = 1 << 29;\nconst double EPS = 1e-8;\n\nstruct edge{\n  int to, lim;\n  double dis;\n  edge(int t=0, double d=0, int l=0):to(t),lim(l),dis(d){}\n};\n\nstruct state{\n  int n, speed, ps, pn;\n  double t;\n  state(int n=0, int pn=0, int s=0, int ps=0, double t=0):n(n),speed(s),ps(ps),pn(pn),t(t){}\n  bool operator < (const state &s) const {\n    return t > s.t;\n  }\n};\n\n\nint n,m,st,go;\nvector<edge> g[N];\n\ndouble solve(){\n  priority_queue<state> pq;\n  state u, u2;\n  double d[N][N][31][31];\n\n  for(int i=0;i<n*n;i++) for(int j=0;j<31*31;j++)  d[i/n][i%n][j/31][j%31] = INF;\n  d[st][st][1][1] = 0;\n\n  for(pq.push(state(st, st, 1, 1, 0)); !pq.empty();){\n    u = pq.top();\n    pq.pop();\n\n    if(u.n == go && u.ps == 1) return u.t;\n    \n    for(int i=0;i<g[u.n].size();i++){\n      edge next = g[u.n][i];\n      for(int j=-1;j<=1;j++){\n        u2 = state(next.to, u.n, u.speed + j, u.speed, u.t + next.dis / (double)u.speed);\n        if(u2.speed <= 0 || u2.speed > 30 || u.speed > next.lim || u2.n == u.pn || d[u2.n][u2.pn][u2.speed][u2.ps] <= u2.t + EPS) continue;\n        d[u2.n][u2.pn][u2.speed][u2.ps] = u2.t;\n        pq.push(u2);\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main(){\n  while(cin >> n >> m && (n|m)){\n    cin >> st >> go;\n    st--; go--;\n    for(int i=0;i<n;i++) g[i].clear();\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin >> x >> y >> d >> c;\n      x--; y--;\n      g[x].push_back(edge(y, d, c));\n      g[y].push_back(edge(x, d, c));\n    }\n    double res = solve();\n    if(res < -0.5) cout << \"unreachable\" << endl;\n    else printf(\"%.5f\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconst double INF = 1e6;\nint n, m;\nint s, g;\nint kyori[30][30], sokudo[30][30];\ndouble dist[30][30][31];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  while (cin >> n >> m, n) {\n    fill_n((int*)kyori, 30 * 30, -1);\n    fill_n((int*)sokudo, 30 * 30, -1);    \n    cin >> s >> g;\n    s--, g--;\n    for (int i = 0; i < m; i++) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      x--, y--;\n      kyori[x][y] = kyori[y][x] = d;\n      sokudo[x][y] = sokudo[y][x] = c;\n    }\n\n    fill_n((double*)dist, 30 * 30 * 31, INF);\n    using P = tuple<double, int, int, int>;\n    priority_queue<P, vector<P>, greater<P>> que;\n    for (int i = 0; i < n; i++) {\n      if (kyori[s][i] < 0) continue;\n      dist[s][i][1] = kyori[s][i];\n      que.emplace(dist[s][i][1], s, i, 1);\n    }\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      double sum;\n      int prev, curr, v;\n      tie(sum, prev, curr, v) = p;\n      if (dist[prev][curr][v] < sum) continue;\n      for (int i = 0; i < n; i++) {\n        if (kyori[curr][i] < 0) continue;\n        if (i == prev) continue;\n        if (v <= sokudo[curr][i] && dist[curr][i][v] > dist[prev][curr][v] + 1.0 * kyori[curr][i] / v) {\n          dist[curr][i][v] = dist[prev][curr][v] + 1.0 * kyori[curr][i] / v;\n          que.emplace(dist[curr][i][v], curr, i, v);\n        }\n        if (v > 0 && v - 1 <= sokudo[curr][i] && dist[curr][i][v - 1] > dist[prev][curr][v] + 1.0 * kyori[curr][i] / (v - 1)) {\n          dist[curr][i][v - 1] = dist[prev][curr][v] + 1.0 * kyori[curr][i] / (v - 1);\n          que.emplace(dist[curr][i][v - 1], curr, i, v - 1);\n        }\n        if (v + 1 <= sokudo[curr][i] && dist[curr][i][v + 1] > dist[prev][curr][v] + 1.0 * kyori[curr][i] / (v + 1)) {\n          dist[curr][i][v + 1] = dist[prev][curr][v] + 1.0 * kyori[curr][i] / (v + 1);\n          que.emplace(dist[curr][i][v + 1], curr, i, v + 1);\n        }\n      }\n    }\n    double ans = INF;\n    for (int i = 0; i < n; i++) {\n      ans = min(ans, dist[i][g][1]);\n    }\n    if (ans == INF) cout << \"unreachable\" << endl;\n    else cout << ans << endl;\n  }  \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<iomanip>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define sc second\n#define pb push_back\n#define mk make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntemplate<class S,class T>\nostream &operator<<(ostream &out, const pair<S,T> p){\n\treturn out << \"(\" << p.fs << \", \" << p.sc << \")\";\n}\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \", \";\n\treturn out << \"}\" << endl;\n}\n\n#define N 30\n#define INF (1<<28)\n#define inf (1e12)\ndouble d[N+1][N];\nint main(){\n\tint n, m, s, g;\n\twhile(cin >> n >> m, n){\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\t\tfill(d[0], d[0] + (N+1) * N, inf);\n\t\td[1][s] = 0;\n\t\tvector<pair<int,double> > e[N+2][N];// e[x][c] : from x at vert c list\n\t\trep(i, m){\n\t\t\tint x, y, di, c;\n\t\t\tcin >> x >> y >> di >> c;\n\t\t\tx--; y--;\n\t\t\treps(j,1,c+1){\n\t\t\t\tdouble time = di / (double) j;\n\t\t\t\te[j][x].pb(mk(y, time));\n\t\t\t\te[j][y].pb(mk(x, time));\n\t\t\t}\n\t\t}\n\t\t/*\n\t\treps(i,1,3){\n\t\t\tcout << \"edges ver \" << i << endl;\n\t\t\trep(j,n){\n\t\t\t\tcout << \"\\tfrom \" << j << endl;\n\t\t\t\tcout << e[i][j];\n\t\t\t}\n\t\t}\n\t\t*/\n\t\t// dst, from, current, ver\n\t\tpriority_queue<pair<double, pair<pii, int> > > q;\n\t\trep(i,e[1][s].size()){\n\t\t\tdouble tmp = e[1][s][i].sc;\n\t\t\tint to = e[1][s][i].fs;\n\t\t\tq.push(mk(-tmp, mk(pii(s, to), 1)));\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tdouble dst = -q.top().fs;\n\t\t\tint from = q.top().sc.fs.fs;\n\t\t\tint cur = q.top().sc.fs.sc, ver = q.top().sc.sc;\n\t\t//\tcout << q.top() << endl;\n\t\t\tq.pop();\n\t\t\tif(d[ver][cur] < inf){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[ver][cur] = dst;\n\t\t\tif(ver == 1 && cur == g) break;\n\t\t\trep(i,3){\n\t\t\t\tint ci = ver - 1 + i;\n\t\t\t\tif(ci<1 || ci > N+1) continue;\n\t\t\t\trep(j, e[ci][cur].size()){\n\t\t\t\t\tpair<int, double> p = e[ci][cur][j];\n\t\t\t\t\tint to = p.fs;\n\t\t\t\t\tif (from == to) continue;\n\t\t\t\t\tdouble tmp = dst + p.sc;\n\t\t\t\t\tq.push(mk(-tmp, mk( pii(from, to), ci)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\treps(i, 1, 5){\n\t\t\tcout << \"ver \" << i << endl;\n\t\t\trep(j,n){\n\t\t\t   if(d[i][j] >= INF) cout << -1 << \" \";\n\t\t\t\telse cout << d[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tif(d[1][g] >= inf) cout << \"unreachable\" << endl;\n\t\telse cout <<fixed << setprecision(10)<< d[1][g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define EPS 1e-8\n \nstruct P{\n  double t;\n  char v,p,pre;\n  P(double T=0.0,int V=0,int pp=0,int PRE=0){\n    t=T;v=V;p=pp;pre=PRE;\n  };\n  bool operator<(const P &p)const{\n    return t>p.t;\n  }\n};\nstruct Path{\n  char d,c;\n  Path(int D=0,int C=0){ d=D;c=C;};\n};\n \nint main(){\n  int n,m, s,g, x,y,d,c;\n  Path path[30][30];\n  priority_queue<P> q;\n \n  while( cin>>n>>m && (n|m) ){\n    cin >> s >> g;\n    s--; g--;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n    path[i][j].d=-1.0; path[i][j].c=-1;\n      }\n \n    for( int i=0;i<m;i++ ){\n      cin >> x >> y >> d >> c;\n      x--;y--;\n      path[x][y].d=d; path[x][y].c=c;\n      path[y][x] = path[x][y];\n    }\n \n    double cost[30][35]; // place,velocity\n    int dv[3] = {1,0,-1};\n    for( int i=0;i<n;i++ )\n      for( int j=1;j<31;j++ )\n    cost[i][j] = DBL_MAX;\n \n    while( !q.empty() ) q.pop();\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      q.push( P(cost[i][1]=path[s][i].d,1,i,-1) );\n    }\n \n    while( !q.empty() ){\n      P p = q.top(); q.pop();\n      double t = p.t;\n      int v=p.v, np=p.p, pre=p.pre;\n      if( np==g && v==1 ) break;\n \n      for( int i=0;i<n;i++ ){\n    if( path[np][i].c<0 ) continue;// たどり着けないノード\n    if( i==pre ) continue; // 前回のノード\n \n    int j=0;\n    if( i==g ) j=2;\n    for( ;j<3;j++ ){\n      int nv = v + dv[j];\n      if( nv==0 || nv>path[np][i].c )    continue;\n      double nCost = t + (double)path[np][i].d/nv;\n      if( nCost>cost[g][1] || fabs(nCost-cost[g][1])<EPS ) continue;\n      if( cost[i][nv] < nCost || fabs(cost[i][nv]-nCost)<EPS) continue;\n      cost[i][nv]=nCost;\n \n      q.push( P(nCost,nv,i,np) );\n    }\n      }\n \n    }\n    if( fabs(cost[g][1]-DBL_MAX)<EPS )\n      cout << \"unreachable\" << endl;\n    else\n      printf(\"%.6lf\\n\",cost[g][1]);\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\nint n,m,s,g;\ndouble d[40][40][40];\n\nint main(){\n  int inx,iny,ind,inc;\n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n\n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=0;i<31;i++)for(int j=0;j<31;j++)for(int k=0;k<31;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      //if(p.S.F >= d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S )continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n    \n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2018/06/15  Problem: AOJ 1162 / Link: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1162  ----- */\n/* ------問題------\n\n摩擦のない国での自動車旅行を考える． この国の自動車にはエンジンがない． ある速さで動き出したら，その速さをずっと維持する（摩擦がないから）． 道路上の固定設備として加減速装置が設置してあって， ここを通る時に速さを1だけ増やしたり，減らしたりすることができる． 速さを変えないことも可能である． このような世界で，出発地から目的地まで最短の時間で移動するルートを決定するプログラムを書くことがあなたの仕事である．\nこの国には複数の都市があり，それらの間を結ぶ道路網が整備されている． 加減速装置はそれぞれの都市に設置してある． 上に述べたとおり，ある都市に速さv で到着した場合，その都市から次の都市に移動する時の速さはv - 1，v ，v + 1 のいずれかである． 出発地を出た直後の道路を走る速さは1に限られる． 同様に目的地に到着する直前の道路を走る速さも1でなければならない．\n出発地と目的地（それぞれ都市である）が与えられる． いくつかの都市を経由しながら目的地に到達する最善のルートを求めることが問題である． ある都市に到着した直後に，今来たばかりの道路を引き返すことはできない（Uターン禁止）． この制限を除けば，経路の選び方は自由である． 同じ都市や同じ道路を何度も通ってよいし，出発地や目的地を途中で通過してもかまわない．\n都市と都市を結ぶ道路のそれぞれに対して，その距離と制限速度が与えられる． その道路を走る時の速さは制限速度以下でなければならない． 道路を通り抜ける所要時間は，距離÷速さである． 都市の通過や加減速に要する時間は無視する．\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n最短路上で区別したいのは現在の速度とどこからきたのかの情報なので、これをもてばよい。\n\n----解説ここまで---- */\n\nvector<pair<int, pair<double, double>>>G[40];\ndouble d[40][40][40];\n\n\nvoid dijkstra(int s) {\n\td[s][1][35] = 0;\n\tusing Ty = tuple<double, int, int, int>;\n\tpriority_queue<Ty, vector<Ty>, greater<Ty>>q;\n\n\tFOR(i, 0, G[s].size()) {\n\t\tpair<int, PII>b = G[s][i];\n\t\tint nv = b.first;\n\t\tdouble cost = b.second.first;\n\t\tdouble lim = b.second.second;\n\n\t\tint nsokudo = 1;\n\t\tif (nsokudo<1 || nsokudo>lim)continue;\n\t\tdouble cc = cost / (double)nsokudo;\n\t\tif (d[nv][nsokudo][s] > d[s][1][35] + cc) {\n\t\t\td[nv][nsokudo][s] = d[s][1][35] + cc;\n\t\t\tq.push(Ty(d[nv][nsokudo][s], nsokudo, nv, s));\n\n\t\t}\n\t}\n\n\twhile (!q.empty()) {\n\t\tTy a = q.top(); q.pop();\n\t\tdouble dist; int sokudo, v, bef;\n\t\ttie(dist, sokudo, v, bef) = a;\n\t\tif (d[v][sokudo][bef] < dist)continue;\n\n\t\tFOR(i, 0, G[v].size()) {\n\t\t\tpair<int, PII>b = G[v][i];\n\t\t\tint nv = b.first;\n\t\t\tdouble cost = b.second.first;\n\t\t\tdouble lim = b.second.second;\n\t\t\tif (bef == nv)continue;\n\n\t\t\tFOR(j, -1, 2) {\n\t\t\t\tint nsokudo = sokudo + j;\n\t\t\t\tif (nsokudo<1 || nsokudo>lim)continue;\n\t\t\t\tdouble cc = cost / (double)nsokudo;\n\t\t\t\tif (d[nv][nsokudo][v] > d[v][sokudo][bef] + cc) {\n\t\t\t\t\td[nv][nsokudo][v] = d[v][sokudo][bef] + cc;\n\t\t\t\t\tq.push(Ty(d[nv][nsokudo][v], nsokudo, nv, v));\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main() {\n\t//cin.tie(0); ios::sync_with_stdio(false);\n\n\twhile (true) {\n\t\tFOR(i, 0, 40)G[i].clear();\n\t\tFOR(i, 0, 40)FOR(j, 0, 40)FOR(k, 0, 40)d[i][j][k] = LINF;\n\t\t//init\n\n\n\t\tint N, M; cin >> N >> M;\n\t\tif (N == 0 && M == 0)break;\n\t\tint  start, target; cin >> start >> target;\n\t\tstart--; target--;\n\t\tFOR(i, 0, M) {\n\t\t\tint x, y; double d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tG[x].push_back(make_pair(y, make_pair(d, c)));\n\t\t\tG[y].push_back(make_pair(x, make_pair(d, c)));\n\t\t}\n\n\t\tdijkstra(start);\n\t\tdouble ans = LINF;\n\t\tFOR(i, 0, N) {\n\t\t\tans = min(ans, d[target][1][i]);\n\t\t}\n\t\tif (ans >= LINF - 10) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%.10lf\\n\", ans);\n\t\t}\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nconst double INFTY=1e10;\n\nstruct Edge{\n\tint src,dst,dist,limit;\n\tEdge(){}\n\tEdge(int s,int d,int di,int li):src(s),dst(d),dist(di),limit(li){}\n};\ntypedef vector<vector<Edge> > Graph;\n\nstruct State{\n\tint src,dst,ver;\n\tdouble time;\n\tState(){}\n\tState(int s,int d,int v,double t):src(s),dst(d),ver(v),time(t){}\n\tbool operator<(const State& s)const{return time<s.time;}\n\tbool operator>(const State& s)const{return time>s.time;}\n};\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n|m;){\n\t\tint start,goal; cin>>start>>goal;\n\t\tstart--; goal--;\n\t\tGraph g(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint s,d,di,li; cin>>s>>d>>di>>li;\n\t\t\ts--; d--;\n\t\t\tg[s].push_back(Edge(s,d,di,li));\n\t\t\tg[d].push_back(Edge(d,s,di,li));\n\t\t}\n\t\t\n\t\tdouble dist[30][30][31];\n\t\tfor(int i=0;i<30;i++)\n\t\t\tfor(int j=0;j<30;j++)\n\t\t\t\tfor(int k=0;k<31;k++)\n\t\t\t\t\tdist[i][j][k]=INFTY;\n\t\t\n\t\tpriority_queue<State,vector<State>,greater<State> > pq;\n\t\tpq.push(State(start,start,0,0));\n\t\twhile(pq.size()){\n\t\t\tState cur=pq.top(); pq.pop();\n\t\t\tif(dist[cur.src][cur.dst][cur.ver]!=INFTY)\n\t\t\t\tcontinue;\n\t\t\tdist[cur.src][cur.dst][cur.ver]=cur.time;\n\t\t\tfor(int i=0;i<g[cur.dst].size();i++){\n\t\t\t\tEdge e=g[cur.dst][i];\n\t\t\t\tif(e.dst==cur.src)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tint nv=cur.ver+j;\n\t\t\t\t\tif(nv<=0 || e.limit<nv || dist[e.src][e.dst][nv]!=INFTY)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpq.push(State(e.src,e.dst,nv,cur.time+(double)e.dist/nv));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble res=INFTY;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tres=min(res,dist[i][goal][1]);\n\t\tif(res==INFTY)\n\t\t\tputs(\"unreachable\");\n\t\telse\n\t\t\tprintf(\"%f\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define INF 2e+9\n#define EPS 1e-14\n#define mp make_pair\nusing namespace std;\n\nstruct edge{ int to,cost,limit; };\ntypedef pair<int,int> SV;//prev,vertex\ntypedef pair<int,SV> VV;//speed\ntypedef pair<double,VV> P;//cost\n\nint main(){\n\tint n,m,s,g;\n\twhile(cin >> n >> m,n){\n\t\tcin >> s >> g; s--;g--;\n\t\tvector<edge> G[30];\n\t\tdouble d[30][31];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j <= 30;j++) d[i][j] = INF;\n\t\t}\n\t\td[s][0] = 0.0;\n\t\tfor(int i = 0;i < m;i++) {\n\t\t\tint x,y,d,c;\n\t\t\tcin >> x >> y >> d >> c; x--;y--;\n\t\t\tG[x].push_back({y,d,c});\n\t\t\tG[y].push_back({x,d,c});\n\t\t}\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(mp(0.0,mp(0,mp(s,s))));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top();que.pop();\n\t\t\tdouble cost = p.first;\n\t\t\tint speed = p.second.first,prev = p.second.second.first,v = p.second.second.second;\n\t\t\tif(d[v][speed] < cost) continue;\n\t\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\t\tedge e = G[v][i];\n\t\t\t\tif(e.to == prev) continue;\n\t\t\t\tfor(int j = max(1,speed - 1);j <= min(e.limit,speed + 1);j++){\n\t\t\t\t\tif(d[v][speed] + (double)e.cost / (double)j < d[e.to][j]){\n\t\t\t\t\t\td[e.to][j] = d[v][speed] + (double)e.cost / (double)j;\n\t\t\t\t\t\tque.push(mp(d[e.to][j],mp(j,mp(v,e.to))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(d[g][1] > (1e+9)) cout << \"unreachable\" << endl;\n\t\telse printf(\"%.8f\\n\",d[g][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REP1(i,n) for(int i=1;i<(n);i++)\n#define REP2(i,d,n) for(int i=(d);i<(n);i++)\n#define RREP(i,n) for(int i=(n);i>=0;i--)\n#define CLR(a) memset((a),0,sizeof(a))\n#define MCLR(a) memset((a),-1,sizeof(a))\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI > VVI;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef pair<int,int> PII;\n \nconst int INF = 0x3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-9;\n \nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n \n \nstruct edge {\n\tint to, from, cost;\n\tedge(int _to, int _from, int _cost) {to = _to; from = _from; cost=_cost;}\n};\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\n \nint maxspeed[31][31];\n \nclass Dijkstra{\npublic:\n\tint V;\n\tvector<vector<edge> > G;\n\tvector<vector<double> > d;\n\t\n\tDijkstra(int _V){\n\t\tV = _V;\n\t\tG.resize(V);\n\t\td.resize(31);\n\n\t\tREP(i,31){\n\t\t\td[i].resize(V);\n\t\t}\n\t}\n\t\n\tvoid add_edge(int from, int to, int cost){\n\t\tG[from].PB(edge(to,from,cost));\n\t}\n\t\n\tvoid solve(int s){\n\t\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\t\tREP(i,31){\n\t\t\tREP(j, V){\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\td[0][s] = 0;\n\t\tque.push(PP(P(0,0),P(s,0)));\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tPP p = que.top();\n\t\t\tque.pop();\n\t\t\tint v = p.second.first;\n\t\t\tint mv = p.second.second;\n\t\t\tint old = p.first.second;\n\t\t\tREP2(i,-1,2){\n\t\t\t\tif(mv+i <= 0 || 30 < mv+i) continue;\n\t\t\t\tif(d[mv+i][v] < p.first.first) continue;\n\t\t\t\tREP(j,G[v].size()){\n\t\t\t\t\tedge e = G[v][j];\n\t\t\t\t\tif(e.to == old) continue;\n\t\t\t\t\t//cout << e.from << \":\" << e.to << \" \" << maxspeed[e.from][e.to] << \" \" << (mv+i) <<  endl;\n\t\t\t\t\tif(maxspeed[e.from][e.to] < mv+i) { continue; }\n\t\t\t\t\tif(d[mv+i][e.to] > d[mv][v] + (double)e.cost/(mv+i)){\n\t\t\t\t\t\td[mv+i][e.to] = d[mv][v] + (double)e.cost/(mv+i);\n\t\t\t\t\t\t//cout << (mv+i) << \" - \" << e.to << \" - \" << d[mv+i][e.to] << endl;\n\t\t\t\t\t\tque.push(PP(P(d[mv+i][e.to],v), P(e.to,mv+i)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\t\n\t\tcin >> n >> m;\n\t\tDijkstra dijkstra(n);\n\t\tif(n==0&&m==0){\n\t\t\tbreak;\n\t\t}\n\t\tREP(i,31){\n\t\t\tREP(j,31){\n\t\t\t\tmaxspeed[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint s,g;\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\t\tREP(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tdijkstra.add_edge(x,y,d);\n\t\t\tdijkstra.add_edge(y,x,d);\n\t\t\tmaxspeed[x][y] = c;\n\t\t\tmaxspeed[y][x] = c;\n\t\t}\n\n\t\tdijkstra.solve(s);\n\n\t\tif(dijkstra.d[1][g] == INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t\tprintf(\"%.5f\\n\",dijkstra.d[1][g]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <iomanip>\nusing namespace std;\n\nconst int INF = 1<<29;\ndouble tbl[40][40][40];\nbool used[40][40][40];\nint n;\n//typedef pair<int,double> P;\ndouble G[40][40];\n//vector<P> G[40];\nint cons[40][40];\nint dv[] = {-1,0,1};\n\nstruct E{\n  double c;\n  int now,pre,v;\n  E(int now,int pre,int v,double c):now(now),pre(pre),v(v),c(c){}\n};\n\nbool operator >(const E& a,const E& b){\n  return a.c>b.c;\n}\n\nvoid dijkstra(int s){\n  for(int i=0;i<n;++i)\n    for(int j=0;j<n;++j)\n      for(int k=0;k<40;++k)\n\tused[i][j][k]=false, tbl[i][j][k]=INF;\n\n  priority_queue<E,vector<E>,greater<E> > Q;\n  Q.push(E(s,s,1,0));\n  while(Q.size()){\n    E x = Q.top(); Q.pop();\n    int cur = x.now;\n    if(used[cur][x.pre][x.v]) continue;\n    if(!tbl[cur][x.pre][x.v]) tbl[cur][x.pre][x.v] = x.c;\n    else tbl[cur][x.pre][x.v] = min(tbl[cur][x.pre][x.v],x.c);\n    used[cur][x.pre][x.v] = true;\n    for(int i=0;i<n;++i){\n      if(!G[i][cur]) continue;\n      for(int j=0;j<3;++j){\n\tif(x.c==0 && j!=1) continue;\n\tint nxtv = x.v+dv[j];\n\tif(nxtv<=0 || nxtv>cons[i][cur]) continue;\n\tdouble nxtcost = x.c+1.0*G[cur][i]/nxtv;\n\tif(tbl[cur][i][nxtv]<=nxtcost) continue;\n\tQ.push(E(i,cur,nxtv,nxtcost));\n      }\n    }\n  }\n}\n\nint main(){\n  int m;\n  while(cin>>n>>m,n||m){\n    for(int i=0;i<n;++i)\n      for(int j=0;j<n;++j)\n\tG[i][j] = 0,cons[i][j]=INF;\n    int s,g;\n    cin >> s >> g;\n    s--;g--;\n    while(m--){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      a--;b--;\n      G[a][b] = G[b][a] = c;\n      cons[a][b] = cons[b][a]= d;\n    }\n    dijkstra(s);\n    double ans = INF;\n    for(int i=0;i<n;++i)\n      ans = min(ans,tbl[g][i][1]);\n    if(ans==INF) cout << \"unreachable\" << endl;\n    else cout << setprecision(6) << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\n\n\n\nint main(){\n  int inx,iny,ind,inc;\n  double d[40][40][40];\n  int n,m,s,g;\n  int INF = 1<<29;\n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n    \n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\nclass data{\npublic:\n\tint t,c,d;\n\n};\n\nclass data2{\npublic:\n\tdouble cost;\n\tint v,s,p;\n\tbool operator<(const data2 &d1)const{\n\t\treturn d1.cost<cost;\n\t}\n};\n\nint n,m,s,g;\ndouble dp[35][35][35];\nvector<data> edge[35];\n\ndouble dijk(){\n\tfor(int i=0;i<35;i++){\n\t\tfor(int j=0;j<35;j++){\n\t\t\tfor(int k=0;k<35;k++){\n\t\t\t\tdp[i][j][k]=-1.0;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<data2> que;\n\tdata2 ind;\n\tind.cost=0.0;\n\tind.v=s;\n\tind.s=0;\n\tdouble res=-1.0;\n\tdp[s][0][0]=0.0;\n\tque.push(ind);\n\twhile(que.size()){\n\t\tdata2 dd=que.top();\n\t\tque.pop();\n\t\tif(dp[dd.v][dd.s][dd.p]<dd.cost)continue;\n\t\tif(dd.v==g && dd.s==1){\n\t\t\tres=min(dd.cost,res);\n\t\t\tif(res==-1.0)res=dd.cost;\n\t\t\tcontinue;\n\t\t}\n\t\tdp[dd.v][dd.s][dd.p]=dd.cost;\n\t\tfor(int i=0;i<edge[dd.v].size();i++){\n\t\t\tdata e=edge[dd.v][i];\n\t\t\tif(dd.p==e.t)continue;\n\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\tint ns=dd.s+j;\n\t\t\t\tif(ns<=0 || ns>e.c)continue;\n\t\t\t\tdouble nc=dd.cost+(double)e.d/ns;\n\t\t\t\tif(dp[e.t][ns][dd.v]>nc || dp[e.t][ns][dd.v]==-1.0){\n\t\t\t\t\tdp[e.t][ns][dd.v]=nc;\n\t\t\t\t\tdata2 nd;\n\t\t\t\t\tnd.v=e.t;\n\t\t\t\t\tnd.cost=nc;\n\t\t\t\t\tnd.s=ns;\n\t\t\t\t\tnd.p=dd.v;\n\t\t\t\t\tque.push(nd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n+m==0)break;\n\t\tfor(int i=0;i<=n;i++)edge[i].clear();\n\t\tscanf(\"%d %d\",&s,&g);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y;\n\t\t\tdata dd;\n\t\t\tscanf(\"%d %d %d %d\",&x,&y,&dd.d,&dd.c);\n\t\t\tdd.t=y;\n\t\t\tedge[x].push_back(dd);\n\t\t\tdd.t=x;\n\t\t\tedge[y].push_back(dd);\n\t\t}\n\t\tdouble res=dijk();\n\t\tif(res!=-1.0)printf(\"%.9f\\n\",res);\n\t\telse printf(\"unreachable\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\n#include <cstring>\n#include <map>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define pii pair<int,int>\n\nbool d[31][31][31];\npii edges[31][31];\nint N;\n\nclass Node{\npublic:\n    int n;\n    int prev_n;\n    double time;\n    int v;\n\n    Node(){}\n    Node(int n,int prev_n,double time,int v): n(n), prev_n(prev_n), time(time), v(v){}\n\n    bool operator> (const Node &n) const{\n        return time>n.time;\n    }\n\n    void addtoq(priority_queue< Node, vector<Node>, greater<Node> > &q){\n        //cout<<n<<\" : \"<<time<<endl;\n        if(d[prev_n][n][v]) return;\n\n        d[prev_n][n][v] = true;\n        rep(i,N+1){\n            if(i==prev_n) continue;\n            if(!edges[n][i].first) continue;\n            for(int j=-1;j<=1;j++){\n                if(v+j>0 && v+j<=edges[n][i].second){\n                    Node c=Node(i,n,time+((double)edges[n][i].first/(v+j)),v+j);\n                    //cout<<i<<\" \"<<v+j<<\"time\"<<time+(double)edges[n][i].first/(v+j)<<endl;;\n                    q.push(c);\n                }\n            }\n        }\n        //cout<<\"!\"<<endl;\n    }\n};\n\nint main(){\n    while(1){\n        int M,S,G;\n        cin>>N>>M>>S>>G;\n        if(N==0) break;\n\n        fill_n(*edges, 31*31, pii(0,0));\n        rep(i,31)rep(j,31)rep(k,31)d[i][j][k]=false;\n\n        rep(i,M){\n            int x,y,d,c;\n            cin>>x>>y>>d>>c;\n            edges[x][y]=pii(d,c);\n            edges[y][x]=pii(d,c);\n        }\n\n        priority_queue< Node, vector<Node>, greater<Node> > q;\n\n        rep(i,N+1){\n            if(!edges[S][i].first) continue;\n            Node c=Node(i, S, edges[S][i].first, 1);\n            q.push(c);\n        }\n\n        Node u;\n        while(!q.empty()){\n            u=q.top();q.pop();\n            if(u.n==G && u.v==1) break;\n            u.addtoq(q);\n        }\n\n        if(u.n==G && u.v==1){\n            cout<<u.time<<endl;\n        }\n        else\n        {\n            cout<<\"unreachable\"<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <vector>\n#include <utility>\n#define INF 0x3FFFFFFF\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<pair<double,int>,P> PP;\n\nint main(void){\n\tint n, m, s, g, x, y, l, c, i, j, dist[30][30], mspeed[30][30];\n\tdouble t[30/*city*/][31/*speed*/][30/*U-turn*/],ans;\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(!n && !m) break;\n\t\tscanf(\"%d%d\",&s,&g);\n\t\ts--,g--;\n\t\tmemset(dist,-1,sizeof(dist));\n\t\tmemset(mspeed,-1,sizeof(mspeed));\n\t\tfor(i = 0;i < m;i++){\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&l,&c);\n\t\t\t--x,--y;\n\t\t\tdist[x][y] = l, mspeed[x][y] = c;\n\t\t\tdist[y][x] = l, mspeed[y][x] = c;\n\t\t}\n\t\tfor(i = 0;i < n;i++)\n\t\t\tfor(j = 0;j <= 30;j++) for(l = 0;l < n;l++) t[i][j][l] = INF;\n\t\tt[s][0][s] = 0;\n\t\tque.push(PP(pair<double,int>(0,s),P(0,s)));\n\t\twhile(que.size()){\n\t\t\t// city speed prev\n\t\t\tx = que.top().first.second,y = que.top().second.first,c = que.top().second.second;\n\t\t\tque.pop();\n\t\t\tfor(i = 0;i < n;i++){\n\t\t\t\tfor(j = -1;j <= 1;j++){ // 加減速\n\t\t\t\t\tif(dist[x][i] != -1 && mspeed[x][i] >= y + j && y + j > 0 && i != c && t[i][y + j][x] > t[x][y][c] + (double)dist[x][i] / (y + j)){\n\t\t\t\t\t\tt[i][y + j][x] = t[x][y][c] + (double)dist[x][i] / (y + j);\n\t\t\t\t\t\tque.push(PP(pair<double,int>(t[i][y + j][x],i),P(y + j,x)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tans>t[g][1][i]?ans=t[g][1][i]:0;\n\t\tif(ans != INF)\n\t\t\tprintf(\"%f\\n\",ans);\n\t\telse\n\t\t\tprintf(\"unreachable\\n\");\n\t}\n\treturn 0;\n}\n\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nstruct Edge {int to, dis, c;};\n\nstruct Status{\n  double cost;\n  int pos, pre, v;\n  bool operator<(const Status &s) const {return cost > s.cost;}\n};\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n    int s, g;\n    cin >> s >> g;\n    --s, --g;\n    vector<Edge> edge[n];\n    rep (i, m) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      --x, --y;\n      edge[x].push_back((Edge){y, d, c});\n      edge[y].push_back((Edge){x, d, c});\n    }\n    priority_queue<Status> que;\n    que.push((Status){0, s, 39, 0});\n    double dis[40][40][40];\n    rep (i, 40) rep (j, 40) rep (k, 40) dis[i][j][k] = 1e99;\n    while (!que.empty()) {\n      Status now = que.top();\n      que.pop();\n      if (dis[now.pos][now.pre][now.v] < now.cost + 1e-8) continue;\n      dis[now.pos][now.pre][now.v] = now.cost;\n      rep (i, edge[now.pos].size()) {\n\tint to = edge[now.pos][i].to;\n\tdouble dis = edge[now.pos][i].dis;\n\tif (to == now.pre) continue;\n\tif (now.v > 0) que.push((Status){now.cost + dis / now.v, to, now.pos, now.v});\n\tif (now.v > 1) que.push((Status){now.cost + dis / (now.v - 1), to, now.pos, now.v - 1});\n\tif (now.v < edge[now.pos][i].c) que.push((Status){now.cost + dis / (now.v + 1), to, now.pos, now.v + 1});\n      }\n    }\n    double res = 1e99;\n    rep (i, 40) res = min(res, dis[g][i][1]);\n    if (res == 1e99) puts(\"unreachable\");\n    else printf(\"%.12lf\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 200 // いつもは1<<29だが小さくすれば時間はやくなる？\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n//自身だー\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i;\n  int b[30][30],c[30][31],m,n,u,v,x,y;\n  unsigned a[30][30];\n  double z;\n  priority_queue<pair<double,pair<int,int> >,vector<pair<double,pair<int,int> > >,greater<pair<double,pair<int,int> > > > d;\n  while(cin>>n>>m&&n+m){\n    cin>>u>>v;\n    u--;\n    v--;\n    memset(a,-1,sizeof(a));\n    for(i=0;i<m;i++){\n      int p,q,r,s;\n      cin>>p>>q>>r>>s;\n      p--;\n      q--;\n      a[p][q]=a[q][p]=r;\n      b[p][q]=b[q][p]=s;\n    }\n    memset(c,-1,sizeof(c));\n    while(d.empty()==0)\n      d.pop();\n    d.push(make_pair(0,make_pair(u,0)));\n    while(d.empty()==0){\n      z=d.top().first;\n      x=d.top().second.first;\n      y=d.top().second.second;\n      if(x==v&&y==1)\n\tbreak;\n      d.pop();\n      if(c[x][y]==-1){\n\tc[x][y]=1;\n\tfor(i=0;i<n;i++){\n\t  if((int)a[x][i]!=-1){\n\t    if(0){\n\t    }else if(y==0){\n\t      d.push(make_pair(z+a[x][i],make_pair(i,1)));\n\t    }else if(y<b[x][i]){\n\t      if(y>1)\n\t\td.push(make_pair(z+(double)a[x][i]/(y-1),make_pair(i,y-1)));\n\t      d.push(make_pair(z+(double)a[x][i]/y,make_pair(i,y)));\n\t      d.push(make_pair(z+(double)a[x][i]/(y+1),make_pair(i,y+1)));\n\t    }else if(y==b[x][i]){\n\t      if(y>1)\n\t\td.push(make_pair(z+(double)a[x][i]/(y-1),make_pair(i,y-1)));\n\t      d.push(make_pair(z+(double)a[x][i]/y,make_pair(i,y)));\n\t    }else if(y==b[x][i]+1){\n\t      d.push(make_pair(z+(double)a[x][i]/(y-1),make_pair(i,y-1)));\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(d.empty())\n      cout<<\"unreachable\"<<endl;\n    else\n      cout<<z<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\n//d, node, velocity, parent\ntypedef tuple<double, int, int, int> State;\n\nclass Edge{\npublic:\n    int to, cost, limit;\n    Edge(int to, int cost, int limit): to(to), cost(cost), limit(limit){};\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int N, M;\n    while (cin>>N>>M, N|M) {\n        int S, G; cin >> S >> G; S--; G--;\n       \n        vector<vector<Edge>> Glaph(N);\n        for(int i=0; i<M; i++){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c; x--; y--;\n            Glaph[x].push_back(Edge(y, d, c));\n            Glaph[y].push_back(Edge(x, d, c));\n        }\n        \n        //?????????-1????????????\n        //node, velocity, parent\n        vector<vector<vector<double>>> dp(N, vector<vector<double>>(30, vector<double>(N, INF)));\n        priority_queue<State, vector<State>, greater<State>> que;\n        \n        dp[S][0][S] = 0;\n        que.push(State(0, S, 0, S));\n        while (!que.empty()) {\n            double d; int node, velocity, parent;\n            tie(d, node, velocity, parent) = que.top(); que.pop();\n            if(dp[node][velocity][parent] < d)\n                continue;\n            \n            for(Edge &e: Glaph[node]) if(e.to != parent){\n                for(int i=-1; i<=1; i++){\n                    int nv = velocity + i;\n                    if(node == S && parent == S && nv != 0)\n                        continue;\n                    if(nv < 0 || 30 <= nv || e.limit <= nv)\n                        continue;\n                    if(dp[e.to][nv][node] > d + e.cost / double(nv+1)){\n                        dp[e.to][nv][node] = d + e.cost / double(nv+1);\n                        que.push(State(dp[e.to][nv][node], e.to, nv, node));\n                    }\n                }\n            }\n        }\n        double ans = INF;\n        int p = -1;\n        for(int i=0; i<N; i++){\n            if(dp[G][0][i] < ans){\n                ans = dp[G][0][i];\n                p = i;\n            }\n        }\n        if(ans == INF)\n            cout << \"unreachable\" << endl;\n        else\n            cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\n\n\n\nint main(){\n  int inx,iny,ind,inc;\n  double d[40][40][40];\n  int n,m,s,g;\n \n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[n+1];\n    \n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nusing tp = tuple<int, int, int>;\nusing ttp = tuple<ld, int, int>;\n\nconst ld INF = 1e20;\n\nint main()\n{\n\tcout << fixed << setprecision(5);\n\tint n, m;\n\twhile (cin >> n >> m, n | m) {\n\t\tint s, g;\n\t\tcin >> s >> g; s--, g--;\n\t\tvector<vector<tp>> G(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c; x--, y--;\n\t\t\tG[x].emplace_back(y, d, c);\n\t\t\tG[y].emplace_back(x, d, c);\n\t\t}\n\t\tvector<vector<ld>> d(n, vector<ld>(33, INF));\n\t\tpriority_queue<ttp, vector<ttp>, greater<ttp>> pq;\n\t\tpq.emplace(0.0, 0, s);\n\t\twhile (!pq.empty()) {\n\t\t\tauto p = pq.top(); pq.pop();\n\t\t\tint v = get<2>(p), ve = get<1>(p);\n\t\t\tld cos = get<0>(p);\n\t\t\tif (d[v][ve] != INF) continue;\n\t\t\td[v][ve] = cos;\n\t\t\tfor (auto e : G[v]) {\n\t\t\t\tint to = get<0>(e), st = get<2>(e);\n\t\t\t\tld dis = get<1>(e);\n\t\t\t\tfor (int i = -1; i <= 1; i++) if (ve + i <= st) {\n\t\t\t\t\tif (d[to][ve + i] == INF) {\n\t\t\t\t\t\tpq.emplace(cos + dis / (ve + i), ve + i, to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[g][1] == INF) cout << \"unreachable\" << endl;\n\t\telse cout << d[g][1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        vector<vector<tuple<int,long double,long double>>> graph(n);\n        int s,g;\n        cin >> s >> g;\n        --s;\n        --g;\n        rep(i,0,m){\n            int x,y;\n            long double d,c;\n            cin >> x >> y >> d >> c;\n            --x;\n            --y;\n            graph[x].emplace_back(make_tuple(y,d,c));\n            graph[y].emplace_back(make_tuple(x,d,c));\n        }\n\n        vector<vector<long double>> dist(n,vector<long double>(31,inf));\n        priority_queue<tuple<long double,int,int>,vector<tuple<long double,int,int>>,greater<tuple<long double,int,int>>> que;\n        dist[s][0]=0;\n        que.push(make_tuple(0,s,0));\n        while(!que.empty()){\n            const tuple<long double,int,int> tup=que.top();\n            que.pop();\n            const long double d=get<0>(tup);\n            const int v=get<1>(tup),spd=get<2>(tup);\n            if(d>dist[v][spd]) continue;\n            for(const auto& e:graph[v]){\n                const auto w=get<0>(e);\n                rep(i,-1,2){\n                    const int next_spd=spd+i;\n                    if(next_spd<=0 or next_spd>get<2>(e)) continue;\n                    const long double tmp_d=d+get<1>(e)/next_spd;\n                    if(tmp_d>=dist[w][next_spd]) continue;\n                    dist[w][next_spd]=tmp_d;\n                    que.push(make_tuple(tmp_d,w,next_spd));\n                }\n            }\n        }\n\n        if(dist[g][1]==inf) cout << \"unreachable\" << endl;\n        else cout << dist[g][1] << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        vector<vector<tuple<int,long double,long double>>> graph(n);\n        int s,g;\n        cin >> s >> g;\n        --s;\n        --g;\n        rep(i,0,m){\n            int x,y;\n            long double d,c;\n            cin >> x >> y >> d >> c;\n            --x;\n            --y;\n            graph[x].emplace_back(make_tuple(y,d,c));\n            graph[y].emplace_back(make_tuple(x,d,c));\n        }\n\n        vector<vector<long double>> dist(n,vector<long double>(31,inf));\n        priority_queue<tuple<long double,int,int>,vector<tuple<long double,int,int>>,greater<tuple<long double,int,int>>> que;\n        dist[s][0]=0;\n        que.push(make_tuple(0,s,0));\n        while(!que.empty()){\n            const tuple<long double,int,int> tup=que.top();\n            que.pop();\n            const long double d=get<0>(tup);\n            const int v=get<1>(tup),spd=get<2>(tup);\n            if(d>dist[v][spd]) continue;\n            for(const auto& e:graph[v]){\n                const auto w=get<0>(e);\n                rep(i,-1,2){\n                    const int next_spd=spd+i;\n                    if(next_spd<=0 or next_spd>get<2>(e)) continue;\n                    const long double tmp_d=d+get<1>(e)/next_spd;\n                    if(tmp_d>=dist[w][next_spd]) continue;\n                    dist[w][next_spd]=tmp_d;\n                    que.push(make_tuple(tmp_d,w,next_spd));\n                }\n            }\n        }\n\n        if(dist[g][1]==inf) cout << \"unreachable\" << endl;\n        else cout << dist[g][1] << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define INF 100000000\n#define rep(i,n) for(int i=0;i<n;i++)\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<double,p> P;\nstruct edge{\n\tint to,d,c;\n};\nint main(){\n\tdouble dp[31][31];\n\tint n,m,s,g,x,y,d,c,ds[]={1,-1,0};\n\twhile(cin>>n>>m,n||m){\n\t\tvector<edge> G[31];\n\t\tcin>>s>>g;\n\t\ts--;g--;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tx--;y--;\n\t\t\tedge e;\n\t\t\te.d=d;e.c=c;\n\t\t\te.to=y;\n\t\t\tG[x].push_back(e);\n\t\t\te.to=x;\n\t\t\tG[y].push_back(e);\n\t\t}\n\t\trep(i,31)\n\t\trep(j,31)\n\t\tdp[i][j]=INF;\n\t\tdp[1][s]=0.0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(0.0,p(0,s)));\n\t\tdouble ans=INF;\n\t\twhile(!que.empty()){\n\t\t\tP q=que.top();que.pop();\n\t\t\tif(q.second.second==g&&q.second.first==1){\n\t\t\t\tans=min(ans,dp[q.second.first][q.second.second]);\n\t\t\t//\tcout<<ans<<endl;\n\t\t\t}\n\t\t\t//cout<<q.second.second<<' '<<q.second.first<<' '<<q.first<<endl;\n\t\t\tif(dp[q.second.first][q.second.second]<q.first)\n\t\t\t\tcontinue;\n\t\t\trep(i,G[q.second.second].size()){\n\t\t\t\tedge e=G[q.second.second][i];\n\t\t\t\trep(j,3){\n\t\t\t\t\tint pre=(q.second.first+ds[j]);\n\t\t\t\t\tif(pre<1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble tes=(double)e.d/pre+q.first;\n\t\t\t\t\tif(0<q.second.first+ds[j]&&q.second.first+ds[j]<=e.c&&dp[q.second.first+ds[j]][e.to]>tes){\n\t\t\t\t\t\tque.push(P(tes,p(q.second.first+ds[j],e.to)));\n\t\t\t\t\t\tdp[q.second.first+ds[j]][e.to]=tes;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans==INF)\n\t\tcout<<\"unreachable\"<<endl;\n\t\telse\n\t\tprintf(\"%.5lf\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint to;\n\tint speed;\n\tint distance;\n};\n\nclass Status{\npublic:\n\tStatus();\n\tStatus(double _speed,int _cur,int _from){\n\t\tspeed = _speed;\n\t\tcur = _cur;\n\t\tfrom = _from;\n\t}\n\n\tint speed;\n\tint cur;\n\tint from;\n\t// \\[g³ê½Æ«ÉRXgÌlÉÎµÄ~ÉÈé\n\tbool operator < (const Status &s) const{\n\t\treturn speed > s.speed;\n\t} \n\t//bool operator()(const int& riLeft, const int& riRight) const {\n //       return riLeft < riRight; // ±±ÅÍA³Ì < ÌÓ¡Éí¹Ä éªAÙÈé»fàÂ\\B\n //   }\n};\n\ntypedef pair<double,Status> P;\n\nint V;\nvector<edge> G[30][30][31];\n\nconst double INF = 1000000000.0;\n\nvoid dijkstra(int s,int g){\n\tdouble d[30][30][31];\n\n\tfor(int i = 0; i < 30; i++)\n\t\tfor(int j = 0; j < 30; j++)\n\t\t\tfill(d[i][j],d[i][j]+31,INF);\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\td[s][s][1] = 0.0;\n\tque.push(P(0.0,Status(1,s,s)));\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tStatus v = p.second;\n\t\tif(!EQ(d[v.from][v.cur][v.speed],p.first) && d[v.from][v.cur][v.speed] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v.from][v.cur][v.speed].size(); i++){\n\t\t\tedge e = G[v.from][v.cur][v.speed][i];\n\t\t\tif(d[v.cur][e.to][e.speed] > d[v.from][v.cur][v.speed] + (double)(e.distance)/e.speed \n\t\t\t\t&& v.from != e.to){\n\t\t\t\t\td[v.cur][e.to][e.speed] = d[v.from][v.cur][v.speed] + (double)(e.distance)/e.speed;\n\t\t\t\t\tif(!(e.to == g && e.speed == 1))\n\t\t\t\t\t\tque.push(P(d[v.cur][e.to][e.speed],Status(e.speed,e.to,v.cur)));\n\t\t\t}\n\t\t}\n\t}\n\n\tbool f = false;\n\tdouble minCost = INF;\n\tfor(int i = 0; i < 30; i++){\n\t\tif(!EQ(d[i][g][1],INF)){\n\t\t\tminCost = min(minCost,d[i][g][1]);\n\t\t\tf = true;\n\t\t}\n\t}\n\n\tif(!f){\n\t\tcout << \"unreachable\" << endl;\n\t}\n\telse{\n\t\tprintf(\"%.5f\\n\",minCost);\n\t}\n\n}\n\nint main(){\n\t\n\t// eæÔÅÍ¯êssðBXs[h²ÆÉm[hÉª¯Ä¢é\n\t// G 1-30,31-60,61-90...\n\tint n,m,s,g;\n\twhile(cin >> n >> m >> s >> g && !(n == 0 && m == 0)){\n\t\tV = n*30+1;\n\t\ts--;\n\t\tg--;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint to,from,di,c;\n\t\t\tcin >> from >> to >> di >> c;\n\t\t\tfrom--;\n\t\t\tto--;\n\t\t\t//if(g == 5){\n\t\t\t//\tcout<<endl;\n\t\t\t//}\n\t\t\t// from -> to\n\t\t\tfor(int j = 0; j < 30; j++){\n\t\t\t\tfor(int k = 0; k < 30; k++){\n\t\t\t\t\tfor(int l = 1; l <= 30; l++){\n\t\t\t\t\t\tif(from == s){\n\t\t\t\t\t\t\t// X^[gn_ðo^\n\t\t\t\t\t\t\tif(from == k && k == j && j != to && l == 1){\n\t\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\t\te.to = to;\n\t\t\t\t\t\t\t\te.distance = di;\n\t\t\t\t\t\t\t\te.speed = 1;\n\t\t\t\t\t\t\t\tG[j][k][l].push_back(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// from©ç¢¯éêðo^\n\t\t\t\t\t\tif(k != j && j != to && k == from){\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.to = to;\n\t\t\t\t\t\t\te.distance = di;\n\t\t\t\t\t\t\tfor(int m = -1; m <= 1; m++){\n\t\t\t\t\t\t\t\tif(m + l > 0 && m + l <= c){\n\t\t\t\t\t\t\t\t\te.speed = l+m;\n\t\t\t\t\t\t\t\t\tG[j][k][l].push_back(e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// to -> from\n\t\t\tfor(int j = 0; j < 30; j++){\n\t\t\t\tfor(int k = 0; k < 30; k++){\n\t\t\t\t\tfor(int l = 1; l <= c; l++){\n\t\t\t\t\t\tif(to == s){\n\t\t\t\t\t\t\t// X^[gn_ðo^\n\t\t\t\t\t\t\tif(to == k && k == j && j != from && l == 1){\n\t\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\t\te.to = from;\n\t\t\t\t\t\t\t\te.distance = di;\n\t\t\t\t\t\t\t\te.speed = 1;\n\t\t\t\t\t\t\t\tG[j][k][l].push_back(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// to©ç¢¯éêðo^\n\t\t\t\t\t\tif(k != j && j != from && k == to){\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.to = from;\n\t\t\t\t\t\t\te.distance = di;\n\t\t\t\t\t\t\tfor(int m = -1; m <= 1; m++){\n\t\t\t\t\t\t\t\tif(m + l > 0 && m + l <= c){\n\t\t\t\t\t\t\t\t\te.speed = l+m;\n\t\t\t\t\t\t\t\t\tG[j][k][l].push_back(e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdijkstra(s,g);\n\t\t\n\t\tfor(int i = 0; i < 30; i++){\n\t\t\tfor(int j = 0; j < 30; j++){\n\t\t\t\tfor(int l = 0; l < 31; l++){\n\t\t\t\t\tG[i][j][l].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint N,M,start,goal;\n\nstruct Info{\n\tInfo(){\n\t\ttown = pre_town = 0;\n\t\tspeed = time = 0.0;\n\t}\n\n\tInfo(int arg_town,int arg_speed,double arg_time,int arg_pre_town){\n\t\ttown = arg_town;\n\t\tspeed = arg_speed;\n\t\ttime = arg_time;\n\t\tpre_town = arg_pre_town;\n\t}\n\tint town,speed,pre_town;\n\tdouble time;\n};\n\nstruct Road{\n\tRoad(int arg_to,double arg_dist,int arg_speed_limit){\n\t\tto = arg_to;\n\t\tdist = arg_dist;\n\t\tspeed_limit = arg_speed_limit;\n\t}\n\tint to,speed_limit;\n\tdouble dist;\n};\n\nvoid func(){\n\n\tdouble min_Time[N+1][N+1][31];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tfor(int p = 1; p <= 30; p++)min_Time[i][k][p] = DBL_MAX;\n\t\t}\n\t}\n\n\tscanf(\"%d %d\",&start,&goal);\n\n\tvector<Road> V[N+1];\n\n\tint from,to,limit;\n\tdouble dist;\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %lf %d\",&from,&to,&dist,&limit);\n\t\tV[from].push_back(Road(to,dist,limit));\n\t\tV[to].push_back(Road(from,dist,limit));\n\t}\n\n\tInfo first;\n\tfirst.speed = 0;\n\tfirst.time = 0.0;\n\tfirst.town = start;\n\tfirst.pre_town = -1;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tint next_town,next_speed;\n\tdouble distance;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().town == goal && Q.front().speed == 1){\n\t\t\tQ.pop();\n\t\t}else if(Q.front().time > min_Time[Q.front().town][Q.front().pre_town][Q.front().speed]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < V[Q.front().town].size();i++){\n\t\t\t\tnext_town = V[Q.front().town][i].to;\n\t\t\t\tif(next_town == Q.front().pre_town)continue;\n\n\t\t\t\tlimit = V[Q.front().town][i].speed_limit;\n\t\t\t\tdistance = V[Q.front().town][i].dist;\n\n\t\t\t\tfor(int k = -1;k <= 1; k++){\n\t\t\t\t\tnext_speed = Q.front().speed + k;\n\t\t\t\t\tif(next_speed <= 0 || next_speed > limit)continue;\n\n\t\t\t\t\tif(min_Time[next_town][Q.front().town][next_speed] > Q.front().time + distance/(double)next_speed){\n\t\t\t\t\t\tmin_Time[next_town][Q.front().town][next_speed] = Q.front().time + distance/(double)next_speed;\n\t\t\t\t\t\tQ.push(Info(next_town,next_speed,Q.front().time+distance/(double)next_speed,Q.front().town));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tdouble minimum = DBL_MAX;\n\tfor(int i = 1; i <= N; i++){\n\t\tminimum = min(minimum,min_Time[goal][i][1]);\n\t}\n\tif(minimum == DBL_MAX){\n\t\tprintf(\"unreachable\\n\");\n\t}else{\n\t\tprintf(\"%.6lf\\n\",minimum);\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <mutex>\nusing namespace std;\n\nconst double INF = 1e9;\n\nint n, m, s, g;\n\n// [n][prev][v];\ndouble dp[32][32][32];\n\nstruct edge {\n\tint to, c;\n\tdouble length;\n\n\tedge(int to, int c, double l) :to(to), c(c), length(l){\n\t}\n\t\n};\n\nvector<edge> G[32];\n\nstruct state {\n\tint n, prev, v;\n\tdouble time;\n\n\tstate(int n, int prev, int v, double time) :n(n), prev(prev),v(v), time(time){\n\t}\n\tbool operator > (const state& s) const {\n\t\treturn time > s.time;\n\t}\n};\n\nvoid solve(){\n\tpriority_queue<state, vector<state>, greater<state>> q;\n\tq.push(state(s, -1, 1, 0.0));\n\twhile(!q.empty()) {\n\t\tstate s = q.top();\n\t\tq.pop();\n\t\tif(s.prev != -1 && dp[s.n][s.prev][s.v] < s.time) continue;\n\n\t\tif(s.n == g && s.v == 1) {\n\t\t\tcout << s.time << endl;\n\t\t\treturn;\n\t\t}\n\n\t\tif(s.prev != -1)\n\t\t\tdp[s.n][s.prev][s.v] = s.time;\n\t\tint dv[] = { 0, 1, -1 };\n\t\tfor(int i = 0; i < G[s.n].size(); i++) {\n\t\t\tfor(int j = 0; j < ((s.prev == -1) ? 1 : 3); j++) {\n\t\t\t\tint nv = s.v + dv[j];\n\t\t\t\tif(nv > 0 && nv <= G[s.n][i].c && G[s.n][i].to != s.prev)\n\t\t\t\t\tq.push(state(G[s.n][i].to, s.n, nv, s.time + G[s.n][i].length / nv));\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"unreachable\" << endl;\n}\n\nint main(){\n\twhile(cin >> n >> m , n | m) {\n\t\tcin >> s >> g;\n\n\t\tfor(int i = 0; i < 32; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint x, y, c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tG[x].push_back(edge(y, c, d));\n\t\t\tG[y].push_back(edge(x, c, d));\n\t\t}\n\n\t\tfor(int i = 0; i < 31; i++) {\n\t\t\tfor(int j = 0; j < 31; j++) {\n\t\t\t\tfor(int k = 0; k < 31; k++) {\n\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsolve();\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\nlong double dp[31][31][31] = {};\nint visited[31][31][31] = {};\nvector<tuple<int, int,double>> vertexs[31];\nint main() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(15);\n\twhile (true) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif (n == 0) return 0;\n\t\tREP(i, 31) {\n\t\t\tvertexs[i].clear();\n\t\t\tREP(q, 31) {\n\t\t\t\tREP(j, 31) {\n\t\t\t\t\tdp[i][q][j] = LONG_INF;\n\t\t\t\t\tvisited[i][q][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\ts--;\n\t\tg--;\n\t\tREP(i, m) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tvertexs[a].push_back(make_tuple(b, d, c));\n\t\t\tvertexs[b].push_back(make_tuple(a, d, c));\n\t\t}\n\t\tpriority_queue<tuple<long double, int, int, int>> next;\n\t\tfor (int q = 0; q < vertexs[s].size(); ++q) {\n\t\t\tdp[get<0>(vertexs[s][q])][s][1] = get<2>(vertexs[s][q]);\n\t\t\tnext.push(make_tuple(-get<2>(vertexs[s][q]), get<0>(vertexs[s][q]), s, 1));\n\t\t}\n\t\twhile (next.empty() == false) {\n\t\t\ttuple<long double, int, int, int> now = next.top();\n\t\t\tnext.pop();\n\t\t\tif (visited[get<1>(now)][get<2>(now)][get<3>(now)] == 1) continue;\n\t\t\tvisited[get<1>(now)][get<2>(now)][get<3>(now)] = 1;\n\t\t\tint now_here = get<1>(now);\n\t\t\tint now_back = get<2>(now);\n\t\t\tint speed = get<3>(now);\n\t\t\tREP(i, vertexs[now_here].size()) {\n\t\t\t\tint next_go = get<0>(vertexs[now_here][i]);\n\t\t\t\tlong double lengthen = get<2>(vertexs[now_here][i]);\n\t\t\t\tint limit_speed = get<1>(vertexs[now_here][i]);\n\t\t\t\tif (next_go == now_back) continue;\n\t\t\t\tfor (int q = -1; q <= 1; ++q) {\n\t\t\t\t\tint now_speed = speed + q;\n\t\t\t\t\tif (now_speed >= 1 && now_speed <= limit_speed) {\n\t\t\t\t\t\tlong double costs = -get<0>(now) + lengthen / (long double)now_speed;\n\t\t\t\t\t\tif (dp[next_go][now_here][now_speed] > costs) {\n\t\t\t\t\t\t\tdp[next_go][now_here][now_speed] = costs;\n\t\t\t\t\t\t\tnext.push(make_tuple(-costs, next_go, now_here, now_speed));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong double ans = LONG_INF;\n\t\tREP(q, 31) {\n\t\t\tans = min(ans, dp[g][q][1]);\n\t\t}\n\t\tif (ans == LONG_INF) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\n\n#define INF 1145141919.810\n\nint n, m, s, g;\ndouble x[50][50][2];\nint a, b, c, d;\n\ndouble dp[50][50];\ndouble res;\n\ndouble solve(int p, int st, int go) {\n\tdp[st][0] = 0;\n\tfor (int i = 1; i <= 400; i++) {\n\t\tfor (int j = 1; j <= p; j++) {\n\t\t\tfor (int k = 0; k <= 30; k++) {\n\t\t\t\tif (dp[j][k] < INF / 2) {\n\t\t\t\t\tfor (int l = 1; l <= p; l++) {\n\t\t\t\t\t\tif (x[j][l][0] < 100000) {\n\t\t\t\t\t\t\t//v-1.\n\t\t\t\t\t\t\tif ((k - 1) >= 1 && (k - 1) <= x[j][l][1]) {\n\t\t\t\t\t\t\t\tdp[l][k - 1] = min(dp[l][k - 1], dp[j][k] + 1.0*x[j][l][0] / (k - 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//v.\n\t\t\t\t\t\t\tif (k >= 1 && k <= x[j][l][1]) {\n\t\t\t\t\t\t\t\tdp[l][k] = min(dp[l][k], dp[j][k] + 1.0*x[j][l][0] / k);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//v-1.\n\t\t\t\t\t\t\tif ((k + 1) >= 1 && (k + 1) <= x[j][l][1]) {\n\t\t\t\t\t\t\t\tdp[l][k + 1] = min(dp[l][k + 1], dp[j][k] + 1.0*x[j][l][0] / (k + 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[go][1];\n}\n\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tfor (int j = 0; j < 50; j++) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t\tx[i][j][0] = 10000000;\n\t\t\t\tx[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) { break; }\n\t\tcin >> s >> g;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tx[a][b][0] = c;\n\t\t\tx[a][b][1] = d;\n\t\t\tx[b][a][0] = c;\n\t\t\tx[b][a][1] = d;\n\t\t}\n\t\tres = solve(n, s, g);\n\t\tif (res > 1000000.00) { cout << \"unreachable\" << endl; }\n\t\telse { cout << fixed << setprecision(15) << res << endl; }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ntypedef pair<double,pair<int,int> > ppi;\nvector<pair<pair<double,int>,int> > vp[31];\nint dv[]={-1,0,1};\ndouble d[31][32];\ndouble INF=1000100010;\nint m,n,s,g;\ndouble dijkstra(){\n    priority_queue<ppi,vector<ppi>,greater<ppi> > pq;\n    rep(i,n)rep(j,32) d[i][j]=INF;\n    d[s][1]=0.0;\n    pq.push({0.0,{1,s}});\n    while(!pq.empty()){\n        ppi pi=pq.top();pq.pop();\n        int t=pi.second.second;\n        int u=pi.second.first;\n        double cost=pi.first;\n        if(t==g&&u==0) return cost;\n        for(auto it:vp[t]){\n            int lm=it.first.second;\n            double dist=it.first.first;\n            if(lm<u||u<=0) continue;\n            rep(i,3){\n                int tv=u+dv[i];\n                if(d[it.second][tv]>cost+dist/u){\n                    d[it.second][tv]=cost+dist/u;\n                    pq.push({d[it.second][tv],{tv,it.second}});\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    while(cin>>n>>m,n|m){\n        rep(i,n) vp[i].clear();\n        cin>>s>>g;\n        --s,--g;\n        int x,y,ci;\n        double di;\n        rep(i,m){\n            cin>>x>>y>>di>>ci;\n            --x,--y;\n            vp[x].pb(make_pair(di,ci),y);\n            vp[y].pb(make_pair(di,ci),x);\n        }\n        double ans=dijkstra();\n        if(ans==-1)cout<<\"unreachable\"<<endl;\n        else cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\nconst double INF = 1e10;\n\nstruct Edge{\n  int cost, to, c;\n  Edge(int to, int cost, int c):\n    to(to), cost(cost), c(c) {}\n};\n\ndouble dijkstra(int s, int g, vector< vector<Edge> > &G){\n  int n = G.size();\n  vector< vector< vector<double> > > D(n,(vector< vector<double> >(n, vector<double>(30,INF))));\n  priority_queue< tuple<double,int,int,int> > wait;\n  wait.emplace(0,0,0,-1);//time, v, cur, from\n  while(!wait.empty()){\n    double t = -get<0>(wait.top());\n    int v = get<1>(wait.top()) + 1,\n      cur = get<2>(wait.top()), from = get<3>(wait.top());\n    wait.pop();\n    if(from != -1 && t >= D[cur][from][v-1]) continue;\n    if(from != -1) D[cur][from][v-1] = t;\n    for(int i = 0; i < G[cur].size(); ++i){\n      int to = G[cur][i].to, d = G[cur][i].cost, c = G[cur][i].c;\n      if(to == from) continue;\n      if(from != -1 && v+1 <= c && D[to][cur][v] > t + (double)d/(v+1))\n        wait.emplace(-t-(double)d/(v+1), v, to, cur);\n      if(v <= c && D[to][cur][v-1] > t + (double)d/v)\n        wait.emplace(-t-(double)d/v, v-1, to, cur);\n      if(v > 1 && v-1 <= c && D[to][cur][v-2] > t + (double)d/(v-1))\n        wait.emplace(-t-(double)d/(v-1), v-2, to, cur);\n    }\n  }\n  double ret = INF;\n  for(int i = 0; i < n; ++i) ret = min(ret,D[g][i][0]);\n  return ret;\n}\n\nint main(){\n  int n, m;\n  while(cin >> n >> m, n){\n    int s, g;\n    cin >> s >> g;\n    --s;\n    --g;\n    int x, y, d, c;\n    vector< vector<Edge> > G(n);\n    for(int i = 0; i < m; ++i){\n      cin >> x >> y >> d >> c;\n      --x;\n      --y;\n      G[x].emplace_back(y,d,c);\n      G[y].emplace_back(x,d,c);\n    }\n    double ans = dijkstra(s,g,G);\n    if(ans >= INF) cout << \"unreachable\" << endl;\n    else printf(\"%.12f\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<pair<int,int>,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a2,a3,a4;\ndouble d[31][31];\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      cin>>a1>>a2>>a3>>a4;\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P,vector<P>,greater<P> >q;\n    d[st][0]=0;\n    P xt;xt.fi.fi=0,xt.fi.se=st,xt.se=-1;\n    q.push(xt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.fi.se;\n      //cout<<cur<<' '<<p.first<<endl;\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(v[cur][i].to!=p.se)r(j,3){\n          int x=p.fi.fi+dx[j],c=0;\n          if(0<x&&x<=v[cur][i].lim){\n            if(d[e.to][x]>e.dist/x+d[cur][p.fi.fi]){\n              d[e.to][x]=e.dist/x+d[cur][p.fi.fi];\n              xt.fi.fi=x,xt.fi.se=e.to,xt.se=cur;\n              q.push(xt);\n             //cout<<x<<' '<<v[cur][i].dist<<endl;\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vd = std::vector<double>;\n\tusing v2d = std::vector<vd>;\n\tusing v3d = std::vector<v2d>;\n\t\n\tusing i3 = std::array<int, 3>;\n\tusing vi3 = std::vector<i3>;\n\tusing v2i3 = std::vector<vi3>;\n\n\tusing pdi3 = std::pair<double, i3>;\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n == 0 && m == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tint s, g;\n\t\tscanf(\"%d%d\", &s, &g);\n\t\ts--; g--;\n\n\t\t// from->{to, distance, limit}\n\t\tv2i3 edge(n);\n\t\tfor (int i{}; i < m; i++)\n\t\t{\n\t\t\tint x, y, d, c;\n\t\t\tscanf(\"%d%d%d%d\", &x, &y, &d, &c);\n\t\t\tx--; y--;\n\t\t\tedge[x].push_back({y, d, c});\n\t\t\tedge[y].push_back({x, d, c});\n\t\t}\n\n\t\t// 頂点、来た速度、来た頂点\n\t\tv3d distance(n, v2d(31, vd(n, 1e9)));\n\t\tfor (auto& e: distance[s][0]) e = 0;\n\t\t// 距離、頂点、来た速度、来た頂点\n\t\tstd::priority_queue<pdi3, std::vector<pdi3>, std::greater<pdi3>> dij;\n\t\tdij.push({0, {s, 0, 0}});\n\t\twhile (!dij.empty())\n\t\t{\n\t\t\tpdi3 now{dij.top()};\n\t\t\tdij.pop();\n\t\t\tif (now.first > distance[now.second[0]][now.second[1]][now.second[2]])\n\t\t\t\tcontinue;\n\t\t\tif (now.second[0] == g && now.second[1] == 1) break;\n\t\t\tfor (auto& e: edge[now.second[0]])\n\t\t\t{\n\t\t\t\tif (e[0] == now.second[2]) continue;\n\t\t\t\tif (0 < now.second[1] - 1 && now.second[1] - 1 <= e[2]\n\t\t\t\t\t&& now.first + (double)e[1] / (now.second[1] - 1) < distance[e[0]][now.second[1] - 1][now.second[0]]\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\tdistance[e[0]][now.second[1] - 1][now.second[0]] = now.first + (double)e[1] / (now.second[1] - 1);\n\t\t\t\t\tdij.push({distance[e[0]][now.second[1] - 1][now.second[0]], {e[0], now.second[1] - 1, now.second[0]}});\n\t\t\t\t}\n\t\t\t\tif (0 < now.second[1] && now.second[1] <= e[2]\n\t\t\t\t\t&& now.first + (double)e[1] / now.second[1] < distance[e[0]][now.second[1]][now.second[0]]\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\tdistance[e[0]][now.second[1]][now.second[0]] = now.first + (double)e[1] / now.second[1];\n\t\t\t\t\tdij.push({distance[e[0]][now.second[1]][now.second[0]], {e[0], now.second[1], now.second[0]}});\n\t\t\t\t}\n\t\t\t\tif (0 < now.second[1] + 1 && now.second[1] + 1 <= e[2]\n\t\t\t\t\t&& now.first + (double)e[1] / (now.second[1] + 1) < distance[e[0]][now.second[1] + 1][now.second[0]]\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\tdistance[e[0]][now.second[1] + 1][now.second[0]] = now.first + (double)e[1] / (now.second[1] + 1);\n\t\t\t\t\tdij.push({distance[e[0]][now.second[1] + 1][now.second[0]], {e[0], now.second[1] + 1, now.second[0]}});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble min{1e9};\n\t\tfor (int i{}; i < n; i++)\n\t\t\tmin = std::min(min, distance[g][1][i]);\n\t\tif (min == 1e9) puts(\"unreachable\");\n\t\telse printf(\"%lf\\n\", min);\n\t}\n\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nclass data\n{\npublic:\n    int p, q, c;\n    data(int p0, int q0, int c0){\n        p = p0;\n        q = q0;\n        c = c0;\n    }\n};\n\nvoid solve(int n, int start, int goal, vector<vector<int> > distance, vector<vector<int> > limit)\n{\n    vector<bool> easyCheck(n, false);\n    queue<int> q;\n    q.push(start);\n    while(!q.empty()){\n        int a = q.front();\n        if(!easyCheck[a]){\n            easyCheck[a] = true;\n            for(int i=0; i<n; ++i){\n                if(distance[a][i] > -1)\n                    q.push(i);\n            }\n        }\n        q.pop();\n    }\n    if(!easyCheck[goal]){\n        cout << \"unreachable\" << endl;\n        return;\n    }\n\n    vector<vector<vector<bool> > > check(n, vector<vector<bool> >(n, vector<bool>(31, false)));\n\tvector<vector<vector<double> > > time(n, vector<vector<double> >(n, vector<double>(31, DBL_MAX)));\n    for(int i=0; i<n; ++i){\n        if(distance[start][i] > -1)\n\t\t\ttime[i][start][1] = distance[start][i];\n    }\n\n    for(;;){\n\t\tint p, q, c;\n\t\tdouble minTime = DBL_MAX;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tfor(int j=0; j<n; ++j){\n\t\t\t\tfor(int k=1; k<=30; ++k){\n\t\t\t\t\tif(!check[i][j][k] && time[i][j][k] < minTime){\n\t\t\t\t\t\tp = i;\n\t\t\t\t\t\tq = j;\n\t\t\t\t\t\tc = k;\n\t\t\t\t\t\tminTime = time[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(p == goal && c == 1){\n\t\t\tprintf(\"%.10f\\n\", minTime);\n\t\t\treturn;\n\t\t}\n\n        check[p][q][c] = true;\n        for(int i=0; i<n; ++i){\n            if(i == p || i == q || distance[i][p] == -1)\n                continue;\n            for(int j=-1; j<=1; ++j){\n                if(1 <= c+j && c+j <= limit[p][i] && !check[i][p][c+j])\n\t\t\t\t\ttime[i][p][c+j] = min(time[i][p][c+j], minTime + distance[p][i]/static_cast<double>(c+j));\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, s, g;\n        cin >> n >> m;\n        if(n == 0 && m == 0)\n            break;\n        cin >> s >> g;\n        -- s;\n        -- g;\n\n        vector<vector<int> > distance(n, vector<int>(n, -1));\n        vector<vector<int> > limit(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int x, y;\n            cin >> x >> y;\n            -- x;\n            -- y;\n            cin >> distance[x][y] >> limit[x][y];\n            distance[y][x] = distance[x][y];\n            limit[y][x] = limit[x][y];\n        }\n\n        solve(n, s, g, distance, limit);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef double Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  int c;                        // c ÍOtÅÍ§À¬xAqueue ÅÍ¬x\n  Edge(int src, int dst, Weight weight, int c) :\n    src(src), dst(dst), weight(weight), c(c){ }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src :\n    e.dst != f.dst ? e.dst < f.dst : e.c < f.c;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef pair<int,int> pii;\n\ndouble dist[30][30][32];           // dist[i][j][k] = Xs[h k ÌóÔÅ j ©ç i ÉÂ­ÅZ£\n\ndouble dijkstra(const Graph &g, int s, int t) {\n  int n = g.size();\n  REP(i,n) REP(j,n) REP(k,32) dist[i][j][k] = INF;\n  priority_queue<Edge> Q;\n  Q.push(Edge(s,s,0,0));\n  int cnt = 0;\n  while(!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (e.dst == t && e.c == 1) break;\n    REP(k,3) {\n      int v = e.c - 1 + k;\n      if (v<=0) continue;\n      if (dist[e.dst][e.src][v] < e.weight) continue;\n      FOR(f, g[e.dst]) {\n        if (v > f->c) continue;\n        if (f->dst == e.src) continue;\n        double hoge = e.weight + f->weight / v;\n        if (dist[f->dst][f->src][v] > hoge) {\n          dist[f->dst][f->src][v] = hoge;\n          Q.push(Edge(f->src, f->dst, hoge, v));\n        }\n      }\n    }\n    if (cnt++ > 1000000) break;\n  }\n\n  double res = INF;\n  REP(i,n)\n    res = min(res, dist[t][i][1]);\n  return res;\n}\n\nint main() {\n  int n,m;\n  while(cin >> n>>m,n||m) {\n    int s,t;\n    cin >> s >> t;\n    s--;t--;\n    Graph g(n);\n    REP(i,m) {\n      int x,y,d,c;\n      cin >> x>>y>>d>>c;\n      x--;y--;\n      g[x].push_back(Edge(x,y,d,c));\n      g[y].push_back(Edge(y,x,d,c));\n    }\n    double res = dijkstra(g,s,t);\n    if (res == INF)\n      cout << \"unreachable\" << endl;\n    else\n      printf(\"%.5f\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\ntypedef pair< double,tuple<int,int,int> > pit3;\ntypedef pair< int,tuple<int,int> > pit2;\n\nint n,m;\n\n\ndouble d[32][32][32];\n\nvector<pit2> pass[32];\n\ndouble dijk(int s,int g){\n    priority_queue< pit3,vector<pit3>,greater<pit3> > que;\n    rep(i,32)rep(j,32)rep(k,32)d[i][j][k]=INF;\n    d[s][1][31]=0;\n    que.push( pit3(0.0,make_tuple(s,1,31)) );\n    \n    bool f=false;\n    while(que.size()){\n//        cout<<que.size()<<endl;\n        pit3 p=que.top();\n        que.pop();\n        \n        int v=get<0>(p.second);\n        int w=get<1>(p.second);\n        int x=get<2>(p.second);\n        if(d[v][w][x]<p.first)continue;\n        rep(i,pass[v].size()){\n            pit2 e=pass[v][i];\n            if(x==e.first)continue;\n            if( w<=get<1>(e.second) && d[e.first][w][v]>d[v][w][x]+(double)(get<0>(e.second))/w ){\n                d[e.first][w][v] = d[v][w][x] + (double)(get<0>(e.second))/w;\n                que.push( pit3(d[e.first][w][v],make_tuple(e.first,w,v)) );\n//                cout<<\"d[\"<<e.first<<\"][\"<<w<<\"][\"<<v<<\"] = \"<<d[e.first][w][v]<<endl;\n            }\n            if( w+1<=get<1>(e.second) && d[e.first][w+1][v]>d[v][w][x]+(double)(get<0>(e.second))/(w+1) && f ){\n                d[e.first][w+1][v] = d[v][w][x] + (double)(get<0>(e.second))/(w+1);\n                que.push( pit3(d[e.first][w+1][v],make_tuple(e.first,w+1,v)) );\n//                cout<<\"d[\"<<e.first<<\"][\"<<w+1<<\"][\"<<v<<\"] = \"<<d[e.first][w+1][v]<<endl;\n            }\n            if( w-1<=get<1>(e.second) && w-1>0 && d[e.first][w-1][v]>d[v][w][x]+(double)(get<0>(e.second))/(w-1) && f ){\n                d[e.first][w-1][v] = d[v][w][x] + (double)(get<0>(e.second))/(w-1);\n                que.push( pit3(d[e.first][w-1][v],make_tuple(e.first,w-1,v)) );\n//                cout<<\"d[\"<<e.first<<\"][\"<<w-1<<\"][\"<<v<<\"] = \"<<d[e.first][w-1][v]<<endl;\n            }\n        }\n        f=true;\n    }\n    double ret = INF;\n    rep(i,32){\n        ret = min(ret, d[g][1][i]);\n    }\n    return ret;\n}\n\n\n\nint main(){\n    int s,g;\n    \n    while(cin>>n>>m){\n        if(n==0&&m==0)break;\n        \n        rep(i,32)pass[i].clear();\n        cin>>s>>g;\n        s--,g--;\n        rep(i,m){\n            int x,y,D,c;\n            cin>>x>>y>>D>>c;\n            x--,y--;\n            pass[x].pb(pit2(y,make_tuple(D,c)));\n            pass[y].pb(pit2(x,make_tuple(D,c)));\n        }\n        double res = dijk(s,g);\n        if(res==INF)cout<<\"unreachable\"<<endl;\n        else printf(\"%.10lf\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nstruct Edge {int to, dis, c;};\n\nstruct Status{\n  double cost;\n  int pos, pre, v;\n  bool operator<(const Status &s) const {return cost > s.cost;}\n};\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n    int s, g;\n    cin >> s >> g;\n    --s, --g;\n    vector<Edge> edge[n];\n    rep (i, m) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      --x, --y;\n      edge[x].push_back((Edge){y, d, c});\n      edge[y].push_back((Edge){x, d, c});\n    }\n    priority_queue<Status> que;\n    que.push((Status){0, s, 39, 0});\n    double dis[40][40][40];\n    rep (i, 40) rep (j, 40) rep (k, 40) dis[i][j][k] = 1e99;\n    while (!que.empty()) {\n      Status now = que.top();\n      que.pop();\n      if (dis[now.pos][now.pre][now.v] < now.cost + 1e-8) continue;\n      dis[now.pos][now.pre][now.v] = now.cost;\n      if (now.pos == g && now.v == 1) break;\n      rep (i, edge[now.pos].size()) {\n\tint to = edge[now.pos][i].to;\n\tdouble dis = edge[now.pos][i].dis;\n\tif (to == now.pre) continue;\n\tif (now.v > 0 && now.v <= edge[now.pos][i].c) que.push((Status){now.cost + dis / now.v, to, now.pos, now.v});\n\tif (now.v > 1 && now.v - 1 <= edge[now.pos][i].c) que.push((Status){now.cost + dis / (now.v - 1), to, now.pos, now.v - 1});\n\tif (now.v < edge[now.pos][i].c) que.push((Status){now.cost + dis / (now.v + 1), to, now.pos, now.v + 1});\n      }\n    }\n    double res = 1e99;\n    rep (i, 40) res = min(res, dis[g][i][1]);\n    if (res == 1e99) puts(\"unreachable\");\n    else printf(\"%.4lf\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nstruct Edge\n{\n    int to, limit, cost;\n    Edge(int to, int limit, int cost) : to(to), limit(limit), cost(cost) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstruct State\n{\n    int node, speed, pre;\n    ld cost;\n};\n\nbool operator<(const State &e, const State &f)\n{\n    return e.cost > f.cost;\n}\n\nld dp[40][40][40];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m, st, gt;\n    while (cin >> n >> m, n || m)\n    {\n        cin >> st >> gt;\n        st--;\n        gt--;\n        Graph g(n);\n        for (int i = 0; i < m; i++)\n        {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            g[x].push_back(Edge{y, c, d});\n            g[y].push_back(Edge{x, c, d});\n        }\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j <= 30; j++)\n                for (int k = 0; k < n; k++)\n                    dp[i][j][k] = INF;\n        priority_queue<State> q;\n        dp[st][0][st] = 0;\n        q.push(State{st, 0, st, 0});\n        while (!q.empty())\n        {\n            State s = q.top();\n            q.pop();\n            int node = s.node, speed = s.speed, pre = s.pre;\n            ld cost = s.cost;\n            for (auto e : g[node])\n            {\n                int to = e.to, limit = e.limit;\n                if (to == pre)\n                    continue;\n                ld d = e.cost;\n                if (limit >= speed + 1)\n                {\n                    if (dp[to][speed + 1][node] == INF)\n                    {\n                        dp[to][speed + 1][node] = cost + d / (speed + 1);\n                        q.push(State{to, speed + 1, node, cost + d / (speed + 1)});\n                    }\n                }\n                if (limit >= speed)\n                {\n                    if (dp[to][speed][node] == INF)\n                    {\n                        dp[to][speed][node] = cost + d / speed;\n                        q.push(State{to, speed, node, cost + d / speed});\n                    }\n                }\n                if (speed > 0 && limit >= speed - 1)\n                {\n                    if (dp[to][speed - 1][node] == INF)\n                    {\n                        dp[to][speed - 1][node] = cost + d / (speed - 1);\n                        q.push(State{to, speed - 1, node, cost + d / (speed - 1)});\n                    }\n                }\n            }\n        }\n        ld res = 1e15;\n        for (int k = 0; k < n; k++)\n        {\n            res = min(res, dp[gt][1][k]);\n        }\n        if (res+EPS >= INF)\n            cout << \"unreachable\" << endl;\n        else\n            cout << fixed << setprecision(10) << res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<double,int> P;\nstruct edge{int to;double cost;};\n\nint n,m,s,go;\ndouble d[27002];\nvector<edge> g[27002];\n\nvoid dijkstra(int s){\n\tpriority_queue<P/*,vector<P>,greater<P> */> q;\n\tfill(d,d+27002,-INF);\n\td[s]=0;\n\tq.push(P(0,s));\n\twhile(!q.empty()){\n\t\tP p=q.top();q.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tif(v==1)break;\n\t\trep(i,g[v].size()){\n\t\t\tedge e=g[v][i];\n\t\t\tif(d[e.to]<d[v]-e.cost){\n\t\t\t\td[e.to]=d[v]-e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>m&&n){\n\t\trep(i,27002)g[i].clear();\n\t\tcin>>s>>go;s--;go--;\n\t\tedge e;\n\t\trep(i,n){\n\t\t\te.to=1;\n\t\t\te.cost=0;\n\t\t\tg[i*n+go+2].push_back(e);\n\t\t}\n\t\trep(i,m){\n\t\t\tint x,y,c;\n\t\t\tdouble dd;\n\t\t\tcin>>x>>y>>dd>>c;\n\t\t\tx--;y--;\n\t\t\trep(v,c+2)rep(p,n){\n\t\t\t\tif(v==31)break;\n\t\t\t\tif(v==0){\n\t\t\t\t\tif(x==s){\n\t\t\t\t\t\te.to=x*n+y+2;\n\t\t\t\t\t\te.cost=dd;\n\t\t\t\t\t\tg[0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\tif(y==s){\n\t\t\t\t\t\te.to=y*n+x+2;\n\t\t\t\t\t\te.cost=dd;\n\t\t\t\t\t\tg[0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int j=-1;j<2;j++){\n\t\t\t\t\t\tif(v+j>0&&v+j<=c&&p!=x&&p!=y){\n\t\t\t\t\t\t\te.to=(v+j-1)*n*n+x*n+y+2;\n\t\t\t\t\t\t\te.cost=dd/(v+j);\n\t\t\t\t\t\t\tg[(v-1)*n*n+p*n+x+2].push_back(e);\n\t\t\t\t\t\t\te.to=(v+j-1)*n*n+y*n+x+2;\n\t\t\t\t\t\t\tg[(v-1)*n*n+p*n+y+2].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(0);\n\t\tif(d[1]>-INF)cout<<-d[1]<<endl;\n\t\telse cout<<\"unreachable\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\nint n,m,s,g;\ndouble d[40][40][40];\n\nint main(){\n  int inx,iny,ind,inc;\n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n\n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n    \n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<iomanip>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define sc second\n#define pb push_back\n#define mk make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntemplate<class S,class T>\nostream &operator<<(ostream &out, const pair<S,T> p){\n\treturn out << \"(\" << p.fs << \", \" << p.sc << \")\";\n}\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \", \";\n\treturn out << \"}\" << endl;\n}\n\n#define N 30\ndouble d[N+1][N][N];\n// -time, from, current, speed\nstruct elem{\n\tdouble t;\n\tint f,c,s;\n\telem(){};\n\telem(double time, int from, int cur, int sp){\n\t\tt = time; f = from; c = cur; s = sp;\n\t}\n\tbool operator<(const elem r) const{ return mk(mk(t, f),mk(c,s)) < mk(mk(r.t,r.f), mk(r.c,r.s)); }\n};\nostream &operator<<(ostream &out, const elem &e){\n\treturn out << \"{\" << e.t << \", \" << e.f << \", \" << e.c << \", \" << e.s << \"}\";\n}\n\n\n#define INF (1e12)\nint main(){\n\tint n, m, s, g;\n\twhile(cin >> n >> m, n){\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\t\tfill(d[0][0], d[0][0] + (N+1) * N * N, -1);\n\t\tvector<pair<int,double> > e[N+2][N];// e[c][x] : from x at vert c : (to, time) list\n\t\trep(i, m){\n\t\t\tint x, y, di, c;\n\t\t\tcin >> x >> y >> di >> c;\n\t\t\tx--; y--;\n\t\t\treps(j,1,c+1){\n\t\t\t\tdouble time = di / (double) j;\n\t\t\t\te[j][x].pb(mk(y, time));\n\t\t\t\te[j][y].pb(mk(x, time));\n\t\t\t}\n\t\t}\n\t\tpriority_queue<elem> q;\n\t\tq.push(elem(-0.0, -1, s, 0));//initial state\n\t\twhile(!q.empty()){\n\t\t\telem el = q.top();\n\t\t\tdouble dst = - el.t;\n\t\t\tint from = el.f, cur = el.c, sp = el.s;\n\t\t\tq.pop();\n\t\t\tif(d[sp][cur][from] >= 0 && d[sp][cur][from] < dst){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[sp][cur][from] = dst;\n//\t\t\tcout << el << endl;\n//\t\t\tif(sp == 1 && cur == g) break;\n\t\t\trep(i,3){\n\t\t\t\tint ci = sp - 1 + i;\n\t\t\t\tif(ci<1 || ci > N+1) continue;\n\t\t\t\trep(j, e[ci][cur].size()){\n\t\t\t\t\tpair<int, double> p = e[ci][cur][j];\n\t\t\t\t\tint to = p.fs;\n\t\t\t\t\tif (from == to) continue;\n\t\t\t\t\tdouble tmp = dst + p.sc;\n\t\t\t\t\tq.push(elem(-tmp, cur, to, ci));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\treps(i, 1, N+1){\n\t\t\tcout << \"v : \" << i << endl;\n\t\t\trep(j, n) cout << d[i][j] << \", \";\n\t\t\tcout << endl;\n\t\t}\n*/\n\t\tdouble ans = INF;\n\t\trep(i,n) if(d[1][g][i] >= 0) ans = min(ans, d[1][g][i]);\n\t\tif(ans >= INF) cout << \"unreachable\" << endl;\n\t\telse cout <<fixed << setprecision(10)<< ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\n\nclass State{\npublic:\n  int pos, v, pre;\n  double time;\n  State(){}\n  State(int pos, int v, int pre, double time) : pos(pos), v(v), pre(pre), time(time) {}\n  bool operator < (const State& s) const { return time > s.time; }\n};\n\nint n, m, s, g;\nP edge[30][30];\ndouble cost[30][30][31];\nbool vis[30][30][31];\n\nvoid solve(){\n  State u, v;\n  u = State(s, 0, 0, 0.0);\n  priority_queue<State> que;\n  fill(vis[0][0], vis[30][0], (double)INF);\n  for(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<31;k++) cost[i][j][k] = INF, vis[i][j][k] = false;\n  for(int i=0;i<n;i++) if(edge[s][i].first != INF) cost[s][i][1] = edge[s][i].first, que.push(State(i, 1, s, (double)edge[s][i].first));\n  while(!que.empty()){\n    u = que.top(); que.pop();\n    if(vis[u.pre][u.pos][u.v]) continue;\n    vis[u.pre][u.pos][u.v] = true;\n    if(u.pos == g && u.v == 1){\n      printf(\"%.5f\\n\", u.time);\n      return;\n    }\n    for(int i=0;i<n;i++){\n      if(edge[u.pos][i].first == INF) continue;\n      if(u.pre == i) continue;\n      for(int k=-1;k<=1;k++){\n        if(u.v + k > edge[u.pos][i].second) continue;\n        if(u.v + k <= 0) continue;\n        v = State(i, u.v + k, u.pos, u.time + edge[u.pos][i].first / (double)(u.v + k));\n        if(cost[v.pre][v.pos][v.v] > v.time){\n          cost[v.pre][v.pos][v.v] = v.time;\n          que.push(v);\n        }\n      }\n    }\n  }\n  printf(\"unreachable\\n\");\n}\n\nmain(){\n  while(scanf(\"%d%d\", &n, &m) && (n|m)){\n    scanf(\"%d%d\", &s, &g);\n    s--; g--;\n    fill(edge[0], edge[30], P(INF, 0));\n    for(int i=0;i<m;i++){\n      int a, b, c, d;\n      scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n      a--; b--;\n      edge[a][b] = edge[b][a] = P(c, d);\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//#define DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\nstruct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n\nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\n// (time,speed,node,pre_node)\nusing P = pair<pair<double,int>,pair<int,int>>;\n\n\nP makeP(double t,int s,int n,int np){\n    return make_pair(make_pair(t,s),make_pair(n,np));\n}\n\nvoid solve(int n,int m){\n    int start,goal; cin>>start>>goal;\n    start--;\n    goal--;\n    vector<vector<int>> g(n,vector<int>(n,INF));\n    vector<vector<int>> lim(n,vector<int>(n,0));\n    rep(i,m){\n        int x,y,d,c;\n        cin>>x>>y>>d>>c;\n        x--;\n        y--;\n        g[x][y] = d;\n        g[y][x] = d;\n        lim[x][y] = c;\n        lim[y][x] = c;\n    }\n\n    double visited[32][32][32];\n    rep(i,32) rep(j,32) rep(k,32) visited[i][j][k]=DBL_MAX/10;\n    visited[start][0][start] = 0;\n\n    priority_queue<P,vector<P>,greater<P>> que;\n    que.push(makeP(0,0,start,start));\n    while(!que.empty()){\n        auto p = que.top();\n        que.pop();\n        double ti = p.first.first;\n        int speed = p.first.second;\n        int node = p.second.first;\n        int pre = p.second.second;\n\n#ifdef DEBUG\n        cerr << \"time : \" << ti << \" \"  << \"node : \" << node+1 << \" \" << \"speed \" << speed << endl;\n#endif\n        if(node==goal and speed==1){\n            cout << Double(ti) << endl;\n            return;\n        }\n\n        if(ti > visited[node][speed][pre]) continue;\n\n        for(int next_node=0;next_node<n;next_node++){\n            if(next_node==node or next_node==pre) continue;\n            if(g[node][next_node]==INF) continue;\n            int d=g[node][next_node];\n            int c=lim[node][next_node];\n            for(int nspeed=speed-1;nspeed<=speed+1;nspeed++){\n                if(nseed<=0 or nspeed>c) continue;\n                double nt = ti + (double)d/nspeed;\n                if(nt < visited[next_node][nspeed][pre]){\n#ifdef DEBUG\n                    cerr << \"\\ttime \" << nt << \" \" << \"node \" << next_node+1 << \" speed \" << nspeed << endl;\n#endif\n                    visited[next_node][nspeed][pre] = nt;\n                    que.push(makeP(nt,nspeed,next_node,node));\n                }\n            }\n        }\n    }\n    cout << \"unreachable\" << endl;\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m){\n        if(n==0 && m==0) break;\n        solve(n,m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nstruct Edge {\n  int from;\n  int to;\n  double dist;\n  int speed;\n  Edge() {;}\n  Edge(int f, int t, double d, int s) : from(f), to(t), dist(d), speed(s) {;}\n  bool operator<(const Edge &rhs) const { return dist > rhs.dist; }\n};\n\ndouble visit[40][40][40];\nvector<Edge> edge[40];\n\nint main() {\n  int n, m, s, g;\n  while (scanf(\"%d %d\", &n, &m), n|m) {\n    scanf(\"%d %d\", &s, &g);\n    s--; g--;\n    REP(i, n) { edge[i].clear(); }\n    REP(i, m) {\n      int f, t, c;\n      double d;\n      scanf(\"%d %d %lf %d\", &f, &t, &d, &c);\n      f--; t--;\n      edge[f].push_back(Edge(f, t, d, c));\n      edge[t].push_back(Edge(t, f, d, c));\n    }\n    priority_queue<Edge> que;\n    MEMSET(visit, false);\n    que.push(Edge(32, s, 0, 1));\n    while (!que.empty()) {\n      Edge node = que.top();\n      que.pop();\n      if (visit[node.from][node.to][node.speed]) { continue; }\n      visit[node.from][node.to][node.speed] = true;\n      if (node.to == g && node.speed == 0) {\n        printf(\"%.4lf\\n\", node.dist);\n        goto next;\n      }\n      if (node.speed == 0) { continue; }\n      int from = node.to;\n      REP(i, edge[from].size()) {\n        int to = edge[from][i].to;\n        FOREQ(s, -1, 1) {\n          int ns = node.speed + s;\n          if (to == node.from || visit[from][to][ns] || node.speed > edge[from][i].speed) { continue; }\n          double ndist = node.dist + edge[from][i].dist / (double)node.speed;\n          que.push(Edge(from, to, ndist, ns));\n        }\n      }\n    }\n    puts(\"unreachable\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1e9\nusing namespace std;\ndouble cost[30][30][31]; int d[30][30],c[30][30];\nstruct S{\n\tdouble cc;int c,p,v;\n\tS(double cc,int c,int p,int v):cc(cc),c(c),p(p),v(v){}\n\tbool operator<(const S &a)const{\n\t\treturn cc>a.cc;\n\t}\n};\nint main(){\n\tint n,m,s,g,x,y,a,b; double nc;\n\twhile(scanf(\"%d%d\",&n,&m),n){\n\t\tscanf(\"%d%d\",&s,&g),s--,g--;\n\t\trep(i,n)rep(j,n){\n\t\t\trep(k,31)cost[i][j][k]=INF;\n\t\t\td[i][j]=c[i][j]=0;\n\t\t}\n\t\trep(i,m)scanf(\"%d%d%d%d\",&x,&y,&a,&b),\n\t\tx--,y--,d[x][y]=d[y][x]=a,c[x][y]=c[y][x]=b;\n\t\tpriority_queue<S> F; F.push(S(0,s,s,0)); cost[s][s][0]=0;\n\t\twhile(!F.empty()){\n\t\t\tS cs=F.top(); F.pop();\n\t\t\tif(cs.c==g&&cs.v==1){\n\t\t\t\tprintf(\"%.5f\\n\",cs.cc); goto END;\n\t\t\t}\n\t\t\trep(i,n)if(i!=cs.p&&d[cs.c][i])\n\t\t\tfor(int dv=-1;dv<2;dv++)if(0<dv+cs.v&&dv+cs.v<=c[cs.c][i]){\n\t\t\t\tnc=cost[cs.c][cs.p][cs.v]+1.*d[cs.c][i]/(dv+cs.v);\n\t\t\t\tif(cost[i][cs.c][dv+cs.v]>nc)\n\t\t\t\tcost[i][cs.c][dv+cs.v]=nc,F.push(S(nc,i,cs.c,dv+cs.v));\n\t\t\t}\n\t\t}\n\t\tprintf(\"unreachable\\n\"); END:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nstruct Car\n{\n\tint pos, v, prev;\n\tdouble t;\n\tCar(int pos, int prev, int v, double t)\n\t\t: pos(pos), prev(prev), v(v), t(t) { }\n};\nbool operator<(const Car& a, const Car& b)\n{\n\treturn a.t > b.t;\n}\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\t--s, --g;\n\t\tint d[32][32], c[32][32];\n\t\tCLEAR(d, -1);\n\t\twhile (m--)\n\t\t{\n\t\t\tint x, y, dis, cons;\n\t\t\tcin >> x >> y >> dis >> cons;\n\t\t\t--x, --y;\n\t\t\td[x][y] = d[y][x] = dis;\n\t\t\tc[x][y] = c[y][x] = cons;\n\t\t}\n\n\t\tdouble min_time[32][32][32];\n\t\tconst double INF = 1e10;\n\t\trep (i, n) rep (j, n)rep (k, 31)\n\t\t\tmin_time[i][j][k] = INF;\n\n\t\tpriority_queue<Car> q;\n\t\tq.push(Car(s, n, 0, 0));\n\t\tmin_time[s][n][0] = 0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tCar car = q.top(); q.pop();\n\t\t\tif (car.t > min_time[car.pos][car.prev][car.v])\n\t\t\t\tcontinue;\n\n\t\t\tfor (int to = 0; to < n; ++to)\n\t\t\t{\n\t\t\t\tif (to != car.prev && d[car.pos][to] != -1)\n\t\t\t\t{\n\t\t\t\t\tfor (int a = -1; a <= 1; ++a)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nv = car.v + a;\n\t\t\t\t\t\tif (nv <= 0 || nv > c[car.pos][to])\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tdouble nt = car.t + (double)d[car.pos][to] / nv;\n\t\t\t\t\t\tif (nt < min_time[to][car.pos][nv])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq.push(Car(to, car.pos, nv, nt));\n\t\t\t\t\t\t\tmin_time[to][car.pos][nv] = nt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble res = INF;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tmin_swap(res, min_time[g][i][1]);\n\t\tif (res < INF)\n\t\t\tprintf(\"%.6f\\n\", res);\n\t\telse\n\t\t\tputs(\"unreachable\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n    return false;\n}\nstruct Edge {\n    int to,d,c;\n    Edge(int to=0,int d=0,int c=0) :\n        to(to),d(d),c(c) {}\n};\n\nstruct State {\n    int v,u;\n    int spd;\n    double t;\n    State(int v=0,int u=0,int spd=0,double t=0) :\n        v(v),u(u),spd(spd),t(t){}\n\n    bool operator<(const State &rhs) const {\n        return t>rhs.t;\n    }\n};\nint s,g;\nint n,m;\nvector<Edge> G[40];\n\ndouble dijk() {\n    // v,u,spd;\n    double d[40][40][40];\n    rep(i,40) rep(j,40) rep(k,40) d[i][j][k]=INF;\n    //rep(i,40) d[s][i][1]=1;\n    d[s][s][0]=0;\n\n    priority_queue<State> que;\n    que.push(State(s,s,0));\n    while(que.size()) {\n        State s=que.top(); que.pop();\n\n        rep(i,G[s.v].size()) {\n            Edge e=G[s.v][i];\n            if(e.to==s.v) continue;\n            for(int k=-1;k<=1;k++) {\n                if(!(0<=s.spd+k&&s.spd+k<=e.c)) continue;\n                if(s.spd+k<=0) continue;\n                if(chmin(d[e.to][s.v][s.spd+k],d[s.v][s.u][s.spd]+1.0*e.d/(s.spd+k))) {\n                    que.push(State(e.to,s.v,s.spd+k,d[e.to][s.v][s.spd+k]));\n                }\n            }\n        }\n    }\n    double ret=INF;\n    rep(i,40) chmin(ret,d[g][i][1]);\n\n    return ret;\n\n}\n\nvoid solve() {\n    rep(i,40) G[i].clear();\n    cin>>s>>g;\n    s--,g--;\n    rep(i,m) {\n        int x,y,d,c;\n        cin>>x>>y>>d>>c;\n        x--,y--;\n        G[x].push_back(Edge(y,d,c));\n        G[y].push_back(Edge(x,d,c));\n    }\n    double ans=dijk();\n    if(ans==INF) cout<<\"unreachable\"<<endl;\n    else printf(\"%.10f\\n\",ans);\n}\n\nint main() {\n    while(cin>>n>>m) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<iomanip>\nusing namespace std;\n\n#define int long long\nconst long long INF = (long long)1e18;\n\nconst int MAX_V = 31;\n\t\nvoid dijkstra(int s, vector<vector<vector<double>>> &d, vector<vector<vector<vector<pair<pair<int,pair<int,int>>, double>>>>> &G){\n\tpriority_queue<pair<double,pair<int,pair<int,int>>>,vector<pair<double,pair<int,pair<int,int>>>>,greater<pair<double,pair<int,pair<int,int>>>>> q;\n\t\n\tint n = G.size();\n\t\n\td.resize(n, vector<vector<double>>(n+1, vector<double>(MAX_V, INF+10)));\n\t\n\td[s][n][0] = 0;\n\t\n\tq.push(make_pair(0,make_pair(s,make_pair(n,0))));\n\t\n\twhile(!q.empty()){\n\t\tpair<double,pair<int,pair<int,int>>> p = q.top();q.pop();\n\t\tpair<int,pair<int,int>> pp = p.second;\n\t\tint v1 = pp.first;\n\t\tint v2 = pp.second.first;\n\t\tint v3 = pp.second.second;\n\t\t\n\t\tif(d[v1][v2][v3] < p.first) continue;\n\t\t\n\t\t// for()\n\t\t\n\t\tfor(pair<pair<int,pair<int,int>>,double> e : G[v1][v2][v3]){\n\t\t\tint e1 = e.first.first;\n\t\t\tint e2 = e.first.second.first;\n\t\t\tint e3 = e.first.second.second;\n\t\t\t\n\t\t\tif(d[e1][e2][e3] > d[v1][v2][v3] + e.second){\n\t\t\t\td[e1][e2][e3] = d[v1][v2][v3] + e.second;\n\t\t\t\tq.push(make_pair(d[e1][e2][e3], e.first));\n\t\t\t}\n\t\t}\n\t}\t\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\t\n\twhile(true){\n\t\tint n, m;\n\t\tint s, g;\n\t\tdouble ans = INF + 10;\n\t\tvector<vector<vector<double>>> d;\n\t\tvector<vector<pair<int,pair<int,int>>>> F;\n\t\tvector<vector<vector<vector<pair<pair<int,pair<int,int>>, double>>>>> G;\n\t\tcin>>n>>m;\n\t\t\n\t\tif(!n && !m) break;\n\t\t\n\t\tcin>>s>>g;\n\t\t\n\t\ts--, g--;\n\t\t\n\t\tF.resize(n);\n\t\tG.resize(n, vector<vector<vector<pair<pair<int,pair<int,int>>,double>>>>(n+1, vector<vector<pair<pair<int,pair<int,int>>,double>>>(MAX_V)));\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint x, y, d, c;\n\t\t\t\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\t\n\t\t\tx--, y--;\n\t\t\t\n\t\t\tF[x].push_back({y, {c, d}});\n\t\t\tF[y].push_back({x, {c, d}});\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int o = 0; o <= n; o++) {\n\t\t\t\tfor(int j = 0; j < F[i].size(); j++){\n\t\t\t\t\tfor(int k = 0; k < MAX_V; k++){\n\t\t\t\t\t\tfor(int l = -1; l <= 1; l++){\n\t\t\t\t\t\t\tif(k+l <= 0 || k+l > F[i][j].second.first) continue;\n\t\t\t\t\t\t\tif(o == F[i][j].first) continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(n == o && k+l != 1) continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tG[i][o][k].push_back({{F[i][j].first,{i,k+l}}, (double)F[i][j].second.second/(k+l)});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdijkstra(s, d, G);\n\t\t\n\t\tfor(int i = 0; i < d[g].size(); i++){\n\t\t\t\tans = min(ans, d[g][i][1]);\n\t\t}\n\t\t\n\t\tif(ans >= INF) cout<<\"unreachable\"<<endl;\n\t\telse cout<<ans<<endl;\n\t\t\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\nint n, m, s, g;\n\ndouble solve(pair<double, double> r[31][31])\n{\n    double result[31][31][31];\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            for(int k = 1; k <= 31; k++){\n                result[i][j][k] = mod;\n            }\n        }\n    }\n    priority_queue<pair<double, pair<pair<int, int>, int> > > qu;\n    qu.push(make_pair(0.0, make_pair(make_pair(s, -1), 0.0)));\n    while(!qu.empty()){\n        double nowcost = (qu.top()).first;\n        pair<int, int> nowandbefore = ((qu.top()).second).first;\n        int nowv = ((qu.top()).second).second;\n        int nowp = nowandbefore.first;\n        int beforep = nowandbefore.second;\n        // cout << nowp << \" \" << beforep << \" \" << -nowcost << \" \" << nowv << endl;\n        qu.pop();\n        if(nowp == g && nowv == 1) {\n            return -nowcost;\n        }\n        if(beforep != -1 && result[nowp][beforep][nowv] <= -nowcost) continue;\n        result[nowp][beforep][nowv] = -nowcost;\n        for(int i = 1; i <= n; i++){\n            if(r[nowp][i].first == 0 || i == beforep) continue;\n            double kyori = r[nowp][i].first;\n            double limit = r[nowp][i].second;\n            double nextcost;\n            for(int j = -1; j <= 1; j++){\n                if(nowv + j <= 0) continue;\n                nextcost = nowcost - (double)kyori / (nowv + j);\n                if(nowv + j <= limit && -nextcost < result[i][nowp][nowv + j]){\n                    qu.push(make_pair(nextcost, make_pair(make_pair(i, nowp), nowv + j)));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    while(1){\n        cin >> n >> m;\n        if(n == 0) break;\n        cin >> s >> g;\n        pair<double, double> road[31][31];\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= n; j++){\n                road[i][j] = make_pair(0, 0);\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int x, y;\n            double d, c;\n            cin >> x >> y >> d >> c;\n            road[x][y] = road[y][x] = make_pair(d, c);\n        }\n        double ans =  solve(road);\n        if(ans == -1) cout << \"unreachable\" << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\ntypedef vector<double> vd;\n\nstruct state {\n\tint p, n, s;\n\tdouble c;\n\tstate(int p, int n, int s, double c) : p(p), n(n), s(s), c(c) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\tint s, g;\n\t\tcin >> s >> g;\n\n\t\tvvi d(n, vi(n, INF));\n\t\tvvi c(n, vi(n, INF));\n\n\t\tint x, y, dd, cc;\n\t\tREP(_, m) {\n\t\t\tcin >> x >> y >> dd >> cc;\n\t\t\td[x-1][y-1] = d[y-1][x-1] = dd;\n\t\t\tc[x-1][y-1] = c[y-1][x-1] = cc;\n\t\t}\n\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(-1, s-1, 1, 0.0));\n\t\tvector<vd> cost(n, vd(30+1, INF));\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tif(st.n == g-1 && st.s == 0) {\n\t\t\t\tcost[g-1][0] = min(st.c, cost[g-1][0]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(st.s == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP(t, n) {\n\t\t\t\tif(st.p == t || st.n == t || d[st.n][t] == INF) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble nc = st.c + (double)d[st.n][t]/st.s;\n\t\t\t\tFOR(p, -1, 1) {\n\t\t\t\t\tif(30 < st.s+p) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(nc < cost[t][st.s+p]) {\n\t\t\t\t\t\tcost[t][st.s+p] = nc;\n\t\t\t\t\t\tQ.push(state(st.n, t, st.s+p, nc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(cost[g-1][0] == INF) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t} else {\n\t\t\tprintf(\"%.5f\\n\", cost[g-1][0]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstruct edge { int to, cost, lim; };\n\nsigned main() {\n    // std::ios::sync_with_stdio(false);\n    // std::cin.tie(0);\n\n\tint n, m;\n\twhile (cin >> n >> m, n) {\n        int s, g;\n        cin >> s >> g;\n        s--; g--;\n\t\tvector<vector<edge>> G(n);\n\t\trep(i, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tG[x].emplace_back((edge){y, d, c});\n\t\t\tG[y].emplace_back((edge){x, d, c});\n\t\t}\n\n\t\tconst double inf = 1e15;\n\t\tvector<vector<double>> d(n, vector<double>(50, inf));\n\t\td[s][0] = 0;\n\t\tqueue<P> que;\n\t    que.push(P(s, 0));\n\n\t    while (!que.empty()) {\n\t\t\tint vertex, speed;\n\t\t\ttie(vertex, speed) = que.front(); que.pop();\n\t        for (auto e: G[vertex]) {\n\t\t\t\tfor (int i = max(1LL, speed - 1); i <= min(e.lim, speed + 1); i++) {\n\t\t\t\t\tif (d[e.to][i] > d[vertex][speed] + 1.0 * e.cost / i) {\n\t\t\t\t\t\td[e.to][i] = d[vertex][speed] + 1.0 * e.cost / i;\n\t\t\t\t\t\tque.push(P(e.to, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t        }\n\t    }\n\n\t\tdouble ans = d[g][1];\n\t\tif (ans == inf) {\n\t\t\tprintf(\"unreachable\\n\");\n\t\t} else {\n\t\t\tprintf(\"%.5f\\n\", ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nconst double INF = 1<<29;\ndouble dist[40][40];\nint lim[40][40], n, g, vis[40][40][40];\ndouble memo[40][40][40];\n\ndouble dp(int prev, int crr, int sp)\n{\n    if (vis[prev][crr][sp]) return INF;\n    if (memo[prev][crr][sp] != -1) return memo[prev][crr][sp];\n    if (sp == 0) return INF;\n\n    vis[prev][crr][sp] = 1;\n    double ans = INF;\n    loop (n, nxt) {\n        if (nxt == prev || lim[crr][nxt] < sp || dist[crr][nxt] == INF) continue;\n        double cost = INF;\n        if (nxt == g && sp == 1) cost = 0;\n        else {\n            cost = min(cost, dp(crr, nxt, sp-1));\n            cost = min(cost, dp(crr, nxt, sp));\n            cost = min(cost, dp(crr, nxt, sp+1));\n        }\n        ans = min(ans, dist[crr][nxt] / sp + cost);\n    }\n    vis[prev][crr][sp] = 0;\n    if (ans != INF) memo[prev][crr][sp] = ans;\n    return ans;\n}\n\nint main()\n{\n    while (1) {\n        fill(dist[0], dist[39]+40, INF);\n        fill(lim[0], lim[39]+40, 0);\n        fill(vis[0][0], vis[39][39]+40, 0);\n        fill(memo[0][0], memo[39][39]+40, -1);\n\n        int m, s; cin >> n >> m >> s >> g;\n        if (!n) break;\n        s--, g--;\n        loop (m, i) {\n            int x, y, c; double d;\n            cin >> x >> y >> d >> c;\n            x--, y--;\n            dist[x][y] = dist[y][x] = d;\n            lim[x][y] = lim[y][x] = c;\n        }\n\n        double ans = dp(32, 0, 1);\n        if (ans == INF) cout << \"unreachable\" << endl;\n        else cout << setprecision(8) << fixed << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int INF = 1e15;\n\nstruct Edge {\n  int to, d, c;  \n};\n\nint s, g;\nint n, m;\nvector<Edge> G[31];\n\ntypedef pair<int, int> P;\ntypedef pair<double, int> E;\ntypedef pair<E, P> PE;\n\ndouble dij() {\n  double ret = INF;  \n  bool used[n+1][n+1][101];\n  fill_n(**used, (n+1)*(n+1)*101, false);\n  priority_queue<PE, vector<PE>, greater<PE> > q;  \n  q.push(PE(E(0, n), P(s, 1)));  \n  while ( !q.empty() ) {\n    PE e = q.top(); q.pop();    \n    double c = e.first.first;\n    int pre = e.first.second;    \n    int u = e.second.first, v = e.second.second;\n    // cout << u << \" \" << v << endl;\n    if ( u == g && v == 1 ) {\n      \n    }\n\n    if ( used[u][pre][v] ) continue;\n    used[u][pre][v] = true;    \n    for ( Edge &f : G[u] ) {\n      if ( pre == f.to ) continue;      \n      if ( f.c < v ) continue;\n      if ( f.to == g && v == 1 ) {\n\tret = min(ret, c+(double)f.d);\t\n      }\n      q.push(PE(E(c+(double)f.d/v, u), P(f.to, v)));      \n      q.push(PE(E(c+(double)f.d/v, u), P(f.to, v+1)));\n      if ( v >= 2 ) q.push(PE(E(c+(double)f.d/v, u), P(f.to, v-1)));      \n    }\n  }\n\n  return ret;\n}\n\nsigned main() {  \n  while ( cin >> n >> m, n ) {\n    for ( int i = 0; i < 31; i++ ) G[i].clear();    \n    cin >> s >> g;\n    s--; g--;\n    for ( int i = 0; i < m; i++ ) {\n      int a, b, d, c;\n      cin >> a >> b >> d >> c;\n      a--; b--;\n      G[a].emplace_back(Edge{b, d, c});\n      G[b].emplace_back(Edge{a, d, c});\n    }\n\n    double ans = dij();\n    if ( ans >= INF-100 ) cout << \"unreachable\" << endl;\n    else printf(\"%.10lf\\n\", ans);    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <cstdio>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dy[] = {1, 0, -1, 1, -1, 1, 0, -1};\n\nstruct edge{\n\tint to;\n\tdouble dist;\n\tint c;\n\tedge(int t, double d, int c_){to = t, dist = d, c = c_;}\n};\n\nstruct state{\n\tint pos;\n\tdouble total;\n\tint speed;\n\tint prev;\n\tstate(int p, double t, int s, int pr){pos = p, total = t, speed = s, prev = pr;}\n\tbool operator<(const state &r)const{\n\t\treturn total > r.total;\n\t}\n};\n\nconst double INF = 1e30;\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\ts--, g--;\n\t\tvector<vector<edge> > G(n);\n\t\trep(i, m){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--, y--;\n\t\t\tG[x].push_back(edge(y, d, c));\n\t\t\tG[y].push_back(edge(x, d, c));\n\t\t}\n\n\t\tpriority_queue<state> q;\n\t\tq.push(state(s, 0, 0, 0));\n\n\t\tvector<vector<vi> > visit(31, vector<vi>(n, vi(n, 0))); //speed, pos, prev\n\n\t\tdouble ans = INF;\n\t\twhile(!q.empty()){\n\t\t\tstate st = q.top();\n\t\t\tq.pop();\n\n\t\t\tif(visit[st.speed][st.pos][st.prev]) continue;\n\t\t\tvisit[st.speed][st.pos][st.prev] = 1;\n\n\t\t\tif(st.speed == 1 && st.pos == g){\n\t\t\t\tans = st.total;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, G[st.pos].size()){\n\t\t\t\tif( G[st.pos][i].dist == INF ) continue;\n\t\t\t\tif(st.prev == G[st.pos][i].to) continue;\n\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\tstate next = st;\n\t\t\t\t\tnext.speed += j;\n\t\t\t\t\tif(next.speed <= 0 || next.speed > G[st.pos][i].c) continue;\n\t\t\t\t\tnext.pos = G[st.pos][i].to;\n\t\t\t\t\tnext.prev = st.pos;\n\t\t\t\t\tnext.total += G[st.pos][i].dist/next.speed;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == INF) cout << \"unreachable\" << endl;\n\t\telse printf(\"%.8lf\\n\", ans);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<double, int, int, int> T;\n  \nconst ll MOD=1e9+7;\n//const ll INF=1e18;\n \nconst double INF = 1000000.0;\n  \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n \nstruct edge{ int to,d,c;};\n \n \n \nint n,m,s,g;\ndouble d[35][35][35];\ndouble mind;\n \nint main(){\n    while(true){\n        cin >> n >> m;\n        if(n + m == 0) break;\n        cin >> s >> g;\n        mind = INF;\n        vector<edge> G[35];\n        for(int i = 0;i < m;i++){\n            int a1,a2,a3,a4;\n            cin >> a1 >> a2 >> a3 >> a4;\n            edge tmp1 = {a2,a3,a4};\n            G[a1].push_back(tmp1);\n            edge tmp2 = {a1,a3,a4};\n            G[a2].push_back(tmp2);\n        }\n        for(int i = 1;i <= n;i++){\n            for(int j = 1;j <= n;j++){\n                for(int k = 0;k <= 31;k++){\n                    d[i][j][k] = INF;\n                }\n            }\n        }\n\t\tpriority_queue<T,vector<T>,greater<T> > que2;\n        for(int i = 0;i < G[s].size();i++){\n            edge e = G[s][i];\n            d[s][e.to][1] = (double) e.d;\n            que2.push(make_tuple((double)e.d,1,s,e.to));\n        }\n        while(!que2.empty()){\n            T t = que2.top(); que2.pop();\n            double a1 = get<0>(t);\n            int a2 = get<1>(t),a3 = get<2>(t),a4 = get<3>(t);\n            if(d[a3][a4][a2] < a1 || a1 > mind)continue;\n            for(int i = 0;i < G[a4].size();i++){\n                edge e = G[a4][i];\n                if(e.to == a3) continue;\n                double tmp = (double) a1 + (double)e.d;\n                if(d[a4][e.to][1] < tmp)continue;\n                d[a4][e.to][1] =  tmp;\n                if(mind < tmp) continue;\n                if(e.to == g && mind > tmp)mind = tmp;\n                que2.push(make_tuple(tmp,1,a4,e.to));\n            }\n        }\n        if(mind == INF){\n            cout << \"unreachable\" << endl;\n            continue;\n        }\n        //queue<T> que;\n        //priority_queue<T,vector<T>,greater<T> > que;\n\t\tpriority_queue<T> que;\n        for(int i = 0;i < G[s].size();i++){\n            edge e = G[s][i];\n            d[s][e.to][1] = (double) e.d;\n            que.push(make_tuple((double)e.d,1,s,e.to));\n        }\n        while(!que.empty()){\n            //T t = que.front(); que.pop();\n            T t = que.top(); que.pop();\n            double a1 = get<0>(t);\n            int a2 = get<1>(t),a3 = get<2>(t),a4 = get<3>(t);\n            if(d[a3][a4][a2] < a1 || a1 > mind)continue;\n            for(int i = 0;i < G[a4].size();i++){\n                edge e = G[a4][i];\n                if(e.to == a3) continue;\n                for(int j = -1;j <= 1;j++){\n                    int v = a2 + j;\n                    double tmp = (double)( a1 + (double)e.d / (double)v);\n            //      if(a4 == 5 && e.to == 6 && v == 1) cout << \"tmp\" << tmp << \",a1\" << a1 <<endl;\n                    if(v <= 0 || v > e.c || d[a4][e.to][v] < tmp ||tmp > mind) continue;\n                    d[a4][e.to][v] =  tmp;\n                    if(e.to == g && v == 1 && mind > tmp)mind = tmp;\n                    que.push(make_tuple(tmp,v,a4,e.to));\n                }\n            }\n         \n         \n        }\n    //  cout << \"ans\" << d[4][5][2] << endl;\n \n \n \n        double ans = INF;\n        for(int i = 1;i <= n;i++){\n            double tmp = d[i][g][1];\n            if(ans > tmp) ans = tmp;\n        //  ans = min(ans,d[i][g][1]);\n        }\n        if(ans == INF){\n            cout << \"unreachable\" << endl;\n        }else{\n        //  cout << ans << endl;\n            printf(\"%lf\\n\",ans);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct S{\n  double t;\n  int v;\n  int p;\n  int from;\n  S(){}\n  S(double t, int v, int p,int from) :\n    t(t), v(v), p(p),from(from) {}\n};\nstruct edge{\n  int to, dist, lim;\n  edge(int to, int dist, int lim) :\n    to(to), dist(dist), lim(lim) {}\n};\ntypedef vector<edge> edges;\nbool operator < (const S& s, const S& t){\n  return s.t > t.t;\n}\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m>>s>>g, n){\n    s--; g--;\n    vector<edges> graph(n);\n    REP(i,m){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c; x--; y--;\n      graph[x].push_back(edge(y, d, c));\n      graph[y].push_back(edge(x, d, c));\n    }\n    priority_queue<S> que;\n    que.push(S(0,0,s,-1));\n    bool used[40][40][40] = {};\n    double ans = -1;\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      //printf(\"quesize:%d time:%lf speed:%d point:%d\\n\",que.size(), s.t,s.v,s.p);\n      if(s.p == g && s.v == 1){\n        ans = s.t;\n        break;\n      }\n      if(used[s.v][s.p][s.from]) continue;\n      used[s.v][s.p][s.from] = true;\n      for(int nv = s.v - 1; nv <= s.v + 1; nv++)if(nv > 0){\n        FORIT(it, graph[s.p])if(it->lim >= nv && it->to != s.from){\n          que.push(S(s.t + (double)it->dist/nv, nv, it->to, s.from));\n        }\n      }\n    }\n    if(ans != -1) printf(\"%.5lf\\n\",ans);\n    else cout<<\"unreachable\"<<endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \";\n        a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nvector<T> dijkstra(const vector<vector<edge<T>>> &g, int s) {\n    const T INF = numeric_limits<T>::max();\n    vector<T> d(g.size(), INF);\n\n    using Pi = pair<T, int>;\n    priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n    d[s] = 0;\n    que.emplace(d[s], s);\n    while (!que.empty()) {\n        T cost;\n        int v;\n        tie(cost, v) = que.top();\n        que.pop();\n        if (d[v] < cost) continue;\n        for (auto &e : g[v]) {\n            T nxt = cost + e.cost;\n            if (d[e.to] > nxt) {\n                d[e.to] = nxt;\n                que.emplace(nxt, e.to);\n            }\n        }\n    }\n    return d;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int n, m; cin >> n >> m;\n        if (n == 0) break;\n        int s, g; cin >> s >> g; --s, --g;\n\n        if (m == 0) {\n            cout << \"unreachable\" << endl;\n            continue;\n        }\n        vi u(m), v(m), d(m), c(m);\n        REP(i, m) {\n            cin >> u[i] >> v[i] >> d[i] >> c[i];\n            --u[i], --v[i];\n        }\n        const int MAX_C = *max_element(ALL(c)) + 1;\n\n        vector<vector<edge<double>>> G((n+1) * n * MAX_C);\n        REP(i, m) {\n            REP(s, MAX_C) {\n                REP(from, n+1) {\n                    if (v[i] == from) continue;\n                    if (0 < s and s <= c[i]) {\n                        G[from * n * MAX_C + u[i] * MAX_C + s].emplace_back(\n                                u[i] * n * MAX_C + v[i] * MAX_C + s, (double)d[i] / s);\n                    }\n                    if (0 < s+1 and s+1 <= c[i]) {\n                        G[from * n * MAX_C + u[i] * MAX_C + s].emplace_back(\n                                u[i] * n * MAX_C + v[i] * MAX_C + s + 1, (double)d[i] / (s + 1));\n                    }\n                    if (0 < s-1 and s-1 <= c[i]) {\n                        G[from * n * MAX_C + u[i] * MAX_C + s].emplace_back(\n                                u[i] * n * MAX_C + v[i] * MAX_C + s - 1, (double)d[i] / (s - 1));\n                    }\n                }\n                REP(from, n+1) {\n                    if (u[i] == from) continue;\n                    if (0 < s and s <= c[i]) {\n                        G[from * n * MAX_C + v[i] * MAX_C + s].emplace_back(\n                                v[i] * n * MAX_C + u[i] * MAX_C + s, (double) d[i] / s);\n                    }\n                    if (0 < s+1 and s+1 <= c[i]) {\n                        G[from * n * MAX_C + v[i] * MAX_C + s].emplace_back(\n                                v[i] * n * MAX_C + u[i] * MAX_C + s + 1, (double)d[i] / (s + 1));\n                    }\n                    if (0 < s-1 and s-1 <= c[i]) {\n                        G[from * n * MAX_C + v[i] * MAX_C + s].emplace_back(\n                                v[i] * n * MAX_C + u[i] * MAX_C + s - 1, (double)d[i] / (s - 1));\n                    }\n                }\n            }\n        }\n        auto dist = dijkstra(G, n * n * MAX_C + s * MAX_C + 0);\n\n        const double inf = 1e18;\n        double ans = inf;\n\n        REP(from, n+1) chmin(ans, dist[from * n * MAX_C + g * MAX_C + 1]);\n        if (ans == inf) cout << \"unreachable\" << endl;\n        else cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nstruct NODE{\n\tint from,to,speed;\n\tdouble cost;\n\tNODE(int from,int to,int speed,double cost) : from(from) , to(to) , speed(speed) , cost(cost) {\n\t}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\n\nvector< vector<NODE> > G;\nbool done[32][32][100] = {};\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m && n){\n\t\tmemset(done,0,sizeof(done));\n\t\tint s,g;\n\t\tcin >> s >> g;\n\t\ts--,g--;\n\t\tG.clear();\n\t\tG.resize(n);\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c,d;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--,b--;\t\n\t\t\tG[a].push_back(NODE(a,b,c,d));\n\t\t\tG[b].push_back(NODE(b,a,c,d));\n\t\t\t//cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n\t\t}\n\t\tpriority_queue<NODE> Q;\n\t\t\n\t\tQ.push(NODE(n,s,0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( q.speed >= 100) continue;\n\t\t\tif( done[q.from][q.to][q.speed] ) continue;\n\t\t\telse done[q.from][q.to][q.speed] = true;\n\t\t\tif( q.to == g && q.speed == 1 ){\n\t\t\t\tprintf(\"%.10lf\\n\",q.cost);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < G[q.to].size() ; i++){\n\t\t\t\tif( q.speed+0 > 0 && q.speed+0 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed+0,q.cost+G[q.to][i].cost / (q.speed+0)));\n\t\t\t\tif( q.speed+1 > 0 && q.speed+1 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed+1,q.cost+G[q.to][i].cost / (q.speed+1)));\n\t\t\t\tif( q.speed-1 > 0 && q.speed-1 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed-1,q.cost+G[q.to][i].cost / (q.speed-1)));\n\t\t\t}\n\t\t}\n\t\tcout << \"unreachable\" << endl;\n\t\texit:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REP1(i,n) for(int i=1;i<(n);i++)\n#define REP2(i,d,n) for(int i=(d);i<(n);i++)\n#define RREP(i,n) for(int i=(n);i>=0;i--)\n#define CLR(a) memset((a),0,sizeof(a))\n#define MCLR(a) memset((a),-1,sizeof(a))\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI > VVI;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef pair<int,int> PII;\n \nconst int INF = 0x3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-9;\n \nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n \n \nstruct edge {\n\tint to, from, cost;\n\tedge(int _to, int _from, int _cost) {to = _to; from = _from; cost=_cost;}\n};\ntypedef pair<int, int> P;\ntypedef pair<int, P> IP;\n \nint maxspeed[31][31];\n \nclass Dijkstra{\npublic:\n\tint V;\n\tvector<vector<edge> > G;\n\tvector<vector<double> > d;\n\t\n\tDijkstra(int _V){\n\t\tV = _V;\n\t\tG.resize(V);\n\t\td.resize(31);\n\n\t\tREP(i,31){\n\t\t\td[i].resize(V);\n\t\t}\n\t}\n\t\n\tvoid add_edge(int from, int to, int cost){\n\t\tG[from].PB(edge(to,from,cost));\n\t}\n\t\n\tvoid solve(int s){\n\t\tpriority_queue<IP, vector<IP>, greater<IP> > que;\n\t\tREP(i,31){\n\t\t\tREP(j, V){\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\td[0][s] = 0;\n\t\tque.push(IP(0,P(s,0)));\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tIP p = que.top();\n\t\t\tque.pop();\n\t\t\tint v = p.second.first;\n\t\t\tint mv = p.second.second;\n\t\t\tREP2(i,-1,2){\n\t\t\t\tif(mv+i <= 0 || 30 < mv+i) continue;\n\t\t\t\tif(d[mv][v] < p.first) continue;\n\t\t\t\tREP(j,G[v].size()){\n\t\t\t\t\tedge e = G[v][j];\n\t\t\t\t\tif(maxspeed[e.from][e.to] < mv+i) continue;\n\t\t\t\t\tif(d[mv+i][e.to] > d[mv][v] + (double)e.cost/(mv+i)){\n\t\t\t\t\t\td[mv+i][e.to] = d[mv][v] + (double)e.cost/(mv+i);\n\t\t\t\t\t\tque.push(IP(d[mv+i][e.to], P(e.to,mv+i)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\t\n\t\tcin >> n >> m;\n\t\tDijkstra dijkstra(n);\n\t\tif(n==0&&m==0){\n\t\t\tbreak;\n\t\t}\n\t\tREP(i,31){\n\t\t\tREP(j,31){\n\t\t\t\tmaxspeed[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint s,g;\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\t\tREP(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tdijkstra.add_edge(x,y,d);\n\t\t\tdijkstra.add_edge(y,x,d);\n\t\t\tmaxspeed[x][y] = c;\n\t\t\tmaxspeed[y][x] = c;\n\t\t}\n\n\t\t//cout << \"run\" << endl;\n\t\tdijkstra.solve(s);\n\n\t\tif(dijkstra.d[1][g] == INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t\tprintf(\"%.5f\\n\",dijkstra.d[1][g]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct state {\n\tint p, n, s;\n\tdouble c;\n\tstate(int p, int n, int s, double c) : p(p), n(n), s(s), c(c) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\tint s, g;\n\t\tcin >> s >> g;\n\n\t\tvvi d(n, vi(n, INF));\n\t\tvvi c(n, vi(n, INF));\n\n\t\tint x, y, dd, cc;\n\t\tREP(_, m) {\n\t\t\tcin >> x >> y >> dd >> cc;\n\t\t\td[x-1][y-1] = d[y-1][x-1] = dd;\n\t\t\tc[x-1][y-1] = c[y-1][x-1] = cc;\n\t\t}\n\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(-1, s-1, 1, 0.0));\n\t\tvector<vvd> cost(n, vvd(n, vd(30+1, INF)));\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\t\t\tif(st.n == g-1 && st.s == 0) {\n\t\t\t\tcost[st.p][g-1][0] = min(st.c, cost[st.p][g-1][0]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(st.s == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP(t, n) {\n\t\t\t\tif(st.p == t || st.n == t || d[st.n][t] == INF || c[st.n][t] < st.s) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble nc = st.c + (double)d[st.n][t]/st.s;\n\t\t\t\tFOR(p, -1, 1) {\n\t\t\t\t\tif(30 < st.s+p) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(nc < cost[st.n][t][st.s+p]) {\n\t\t\t\t\t\tcost[st.n][t][st.s+p] = nc;\n\t\t\t\t\t\tQ.push(state(st.n, t, st.s+p, nc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = INF;\n\t\tREP(i, n) {\n\t\t\tans = min(ans, cost[i][g-1][0]);\n\t\t}\n\n\t\tif(ans == INF) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t} else {\n\t\t\tprintf(\"%.5f\\n\", ans);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef double Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  int c;                        // c ÍOtÅÍ§À¬xAqueue ÅÍ¬x\n  Edge(int src, int dst, Weight weight, int c) :\n    src(src), dst(dst), weight(weight), c(c){ }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src :\n    e.dst != f.dst ? e.dst < f.dst : e.c < f.c;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef pair<int,int> pii;\n\ndouble dist[30][30][32];           // dist[i][j][k] = Xs[h k ÌóÔÅ j ©ç i ÉÂ­ÅZ£\n\ndouble dijkstra(const Graph &g, int s, int t) {\n  int n = g.size();\n  REP(i,n) REP(j,n) REP(k,32) dist[i][j][k] = INF;\n  // pii prev[n][32];           // dist[i][j] = Xs[h j ÌóÔÅ i ÉÂ­ÅZ£\n  // prev[s][0] = pii(-1,0);\n  priority_queue<Edge> Q;\n  Q.push(Edge(s,s,0,0));\n  while(!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    //printf(\"%d->%d %f %d\\n\",e.src,e.dst,e.weight,e.c);\n    if (e.dst == t && e.c == 1) break;\n    REP(k,3) {\n      int v = e.c - 1 + k;\n      if (v<=0) continue;\n      if (dist[e.dst][e.src][v] < e.weight) continue;\n      FOR(f, g[e.dst]) {\n        if (v > f->c) continue;\n        if (f->dst == e.src) continue;\n        double hoge = e.weight + f->weight / v;\n        if (dist[f->dst][f->src][v] > hoge) {\n          //prev[f->dst][f->src][v] = pii(f->src,e.c);\n          dist[f->dst][f->src][v] = hoge;\n          Q.push(Edge(f->src, f->dst, hoge, v));\n        }\n      }\n    }\n  }\n  // pii hoge = pii(t,1);\n  // while(hoge.first >= 0) {\n  //   cout <<hoge.first<< \" \" << hoge.second << endl;\n  //   hoge = prev[hoge.first][hoge.second];\n  // }\n  double res = INF;\n  REP(i,n)\n    res = min(res, dist[t][i][1]);\n  return res;\n}\n\nint main() {\n  int n,m;\n  while(cin >> n>>m,n||m) {\n    int s,t;\n    cin >> s >> t;\n    s--;t--;\n    Graph g(n);\n    REP(i,m) {\n      int x,y,d,c;\n      cin >> x>>y>>d>>c;\n      x--;y--;\n      g[x].push_back(Edge(x,y,d,c));\n      g[y].push_back(Edge(y,x,d,c));\n    }\n    double res = dijkstra(g,s,t);\n    if (res == INF)\n      cout << \"unreachable\" << endl;\n    else\n      printf(\"%.5f\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int INFINITY_HAHA = 999999;\n\ntypedef struct status {\n    int from, to, speed;\n    double time;\n    status(int x, int x2, double y, int z): from(x), to(x2), time(y), speed(z) {}\n} CurrentStatus;\n\n\nstruct cmp_statue {\n    bool operator() (const CurrentStatus &a, const CurrentStatus &b) {\n        return a.time > b.time;\n    }\n};\n\n\nint main() {\n    // freopen(\"input.txt\", \"r\", stdin);\n\n    int ncities, nroads;\n    while(scanf(\"%d%d\", &ncities, &nroads) != EOF && !(ncities == 0 && nroads == 0)) {\n\n        int visited[50][50][50];\n        priority_queue< CurrentStatus, vector<CurrentStatus>, cmp_statue > Q;\n\n        vector< vector<int> > path_cost(ncities + 1, vector<int>(ncities + 1, -1) );\n        vector< vector<int> > path_limit(ncities + 1, vector<int>(ncities + 1, -1) );\n\n        memset(visited, 0, sizeof(visited));\n\n        // Input\n        int start_index, end_index;\n        scanf(\"%d%d\" , &start_index, &end_index);\n\n        for(int n = 0; n < nroads; ++n) {\n            int x, y, d, c;\n            scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n            path_cost[x][y] = path_cost[y][x] = d;\n            path_limit[x][y] = path_limit[y][x] = c;\n        }\n\n        double minimun_v = 0;\n        Q.push(CurrentStatus(start_index, start_index, 0.0, 0));\n\n        while(!Q.empty()) {\n            CurrentStatus cs = Q.top();\n            Q.pop();\n\n            if(cs.to == end_index && cs.speed == 1) {\n                minimun_v = cs.time;\n                break;\n            }\n\n            if(visited[cs.from][cs.to][cs.speed]) continue;\n\n            visited[cs.from][cs.to][cs.speed] = 1;\n\n            for(int j = 1; j <= ncities; ++j) {\n                if(path_cost[cs.to][j] == -1) continue;\n                if(j == cs.from) continue;\n                \n\n                for(int z = -1; z <= 1; ++z) {\n                    if(!visited[cs.to][j][cs.speed + z] && cs.speed + z >= 1 && cs.speed + z <= path_limit[cs.to][j]) {\n                        Q.push(CurrentStatus(cs.to, j, cs.time + ((double)path_cost[cs.to][j])/(cs.speed + z), cs.speed + z));\n                    }\n                }\n            }\n        }\n\n        if(minimun_v) {\n            printf(\"%0.5lf\\n\", minimun_v);\n        } else {\n            printf(\"unreachable\\n\");\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nstruct State {\n    int i, prev, sp; double cost;\n};\n\nbool operator>(const State& a, const State& b)\n{\n    return a.cost > b.cost;\n}\n\nconst double INF = 1<<29;\n\nint main()\n{\n    while (1) {\n        int n, m, s, g; cin >> n >> m >> s >> g;\n        if (!n) break;\n        s--, g--;\n\n        vector<vector<double>> dist(n, vector<double>(n, INF));\n        vector<vector<int>> lim(n, vector<int>(n));\n\n        while (m--) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--, y--;\n            dist[x][y] = dist[y][x] = d;\n            lim[x][y] = lim[y][x] = c;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> Q;\n        Q.push({ s, -1, 0, 0 });\n\n        pair<int, int> debug[40][40];\n\n        int vis[40][40][40] = {};\n        double ans = INF;\n        while (Q.size()) {\n            auto e = Q.top(); Q.pop();\n            if (vis[e.i][e.sp][e.prev]) continue;\n            vis[e.i][e.sp][e.prev] = 1;\n            if (e.i == g && e.sp == 1) ans = min(ans, e.cost);\n            loop (n, i) loop (3, d) {\n                int sp = e.sp-1+d;\n                if (dist[e.i][i] == INF || i == e.prev ||\n                        sp < 1 || sp > lim[e.i][i]) continue;\n                Q.push({ i, e.i, sp, e.cost + dist[e.i][i] / sp });\n            }\n        }\n        if (ans != INF) cout << setprecision(8) << fixed << ans << endl;\n        else cout << \"unreachable\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\n\nconst double INF = 1e9;\n\nint n, m, s, g;\n\n// [n][prev][v];\ndouble dp[32][32][32];\n\nstruct edge {\n\tint to, c;\n\tdouble length;\n\n\tedge(int to, int c, double l) :to(to), c(c), length(l){\n\t}\n};\n\nvector<edge> G[32];\n\nstruct state {\n\tint n, prev, v;\n\tdouble time;\n\n\tstate(int n, int prev, int v, double time) :n(n), prev(prev),v(v), time(time){\n\t}\n};\n\nint main(){\n\twhile(cin >> n >> m , n | m) {\n\t\tcin >> s >> g;\n\n\t\tfor(int i = 0; i < 32; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint x, y, c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tG[x].push_back(edge(y, c, d));\n\t\t\tG[y].push_back(edge(x, c, d));\n\t\t}\n\n\t\tfor(int i = 0; i < 31; i++) {\n\t\t\tfor(int j = 0; j < 31; j++) {\n\t\t\t\tfor(int k = 0; k < 31; k++) {\n\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<state> q;\n\t\tq.push(state(s, -1, 1, 0.0));\n\t\twhile(!q.empty()) {\n\t\t\tstate s = q.front();\n\t\t\tq.pop();\n\t\t\tif(s.prev != -1 && dp[s.n][s.prev][s.v] < s.time) continue;\n\t\t\tif(s.prev != -1)\n\t\t\t\tdp[s.n][s.prev][s.v] = s.time;\n\t\t\tint dv[] = {0, 1, -1};\n\t\t\tfor(int i = 0; i < G[s.n].size(); i++) {\n\t\t\t\tfor(int j = 0; j < ((s.prev == -1) ? 1 : 3); j++) {\n\t\t\t\t\tint nv = s.v + dv[j];\n\t\t\t\t\tif(nv > 0 && nv <= G[s.n][i].c && G[s.n][i].to != s.prev)\n\t\t\t\t\t\tq.push(state(G[s.n][i].to, s.n, nv, s.time + G[s.n][i].length / nv));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = INF;\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tans = min(ans, dp[g][i][1]);\n\t\t}\n\t\tif(ans == INF)\n\t\t\tcout << \"unreachable\" << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\nconst int MAX_V = 101;\nconst int MAX_SPEED = 31;\nconst double INF = 1e9;\n\nint n,m;\nint ds[]={-1,0,1};\n\nstruct edge{\n\tint to;\n\tdouble dist, speed;\n\tedge(int t_to,double t_dist,double t_speed){\n\t\tto=t_to;dist=t_dist;speed=t_speed;\n\t}\n};\n\nstruct state{\n\tdouble cost,speed;\n\tint v;\n\tstate(double t_cost,int t_v,double t_speed){\n\t\tcost=t_cost;v=t_v;speed=t_speed;\n\t}\n\tbool operator>(const state& s)const{\n\t\treturn cost > s.cost;\n\t}\n};\n\n\nvector< vector<edge> > G(MAX_V);\ndouble d[MAX_V][MAX_SPEED];\n\nvoid dijkstra(int s){\n\tpriority_queue<state,vector<state>,greater<state> > que;\n\tfill_n((double *)d, sizeof(d)/sizeof(double),INF);\n\td[s][0] = 0.0;\n\tque.push(state(0.0,s,0.0));\n\n\n\twhile(!que.empty()){\n\t\tstate p = que.top(); que.pop();\n\t\tint v = p.v;\n\t\tif(d[v][(int)p.speed]<p.cost) continue;\n\t\trep(i,G[v].size()){\n\t\t\tedge e = G[v][i];\n\t\t\trep(j,3){\n\t\t\t\tdouble p_s=(p.speed+ds[j]);\n\t\t\t\tif(p_s > 0 && e.speed >= p_s && d[e.to][(int)p_s] > d[v][(int)p.speed] + (e.dist/p_s)){\n\t\t\t\t\n\t\t\t\t\td[e.to][(int)p_s] = d[v][(int)p.speed] + (e.dist/p_s);\n\t\t\t\t\tque.push(state(d[e.to][(int)p_s],e.to,p_s));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\t\n\tcout << fixed << setprecision(5);\n\twhile(1){\n\n\t\tG.clear();\n\t\tG.resize(MAX_V);\n\n\t\tint s,g;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\tcin >> s >> g;\n\t\ts--;g--;\n\t\trep(i,m){\n\t\t\tint a,b;\n\t\t\tdouble d,c;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--;b--;\n\t\t\tedge tmp1(b,d,c);\n\t\t\tedge tmp2(a,d,c);\n\t\t\tG[a].push_back(tmp1);\n\t\t\tG[b].push_back(tmp2);\n\t\t}\n\n\t\tdijkstra(s);\n\n\t\tif(d[g][1]==INF) cout << \"unreachable\" << endl;\n\t\telse cout << d[g][1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 31\n#define INF (1e9)\nusing namespace std;\ntypedef pair<double,int> P;\ntypedef  pair<P,int> PP;\nint n,m;\nvector<PP> G[N];\n\ndouble dijkstra(int s,int g){\n  vector<vector<double> >D(N,vector<double>(N,INF));\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  Q.push(PP(P(0,0),s));\n  D[s][0]=0;\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    double cost=t.first.first;\n    int v=t.first.second;\n    int pos=t.second;\n    if(pos==g&&v==1) return cost;\n    for(int i=max(1,v-1);i<=v+1;i++){\n      for(int j=0;j<G[pos].size();j++){\n\tdouble ncost=cost+G[pos][j].first.first/i;\n\tint mxv=G[pos][j].first.second;\n\tint nx=G[pos][j].second;\n\tif(mxv<i||D[nx][i]<=ncost)continue;\n\tQ.push(PP(P(ncost,i),nx));\n\tD[nx][i]=ncost;\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    int s,g;\n    cin>>s>>g;s--,g--;\n\n    for(int i=0;i<n;i++)G[i].clear();\n    for(int i=0,a,b,d,c;i<m;i++){\n      cin>>a>>b>>d>>c;a--,b--;\n      G[a].push_back(PP(P(d,c),b));\n      G[b].push_back(PP(P(d,c),a));\n    }\n    double ans=dijkstra(s,g);\n    if(ans==-1) cout<<\"unreachable\"<<endl;\n    else printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct status {\n    int pos;\n    double dist;\n    int vel;\n\n    status () {}\n    ~status () {}\n\n    status(int a, double b, int c): pos(a), dist(b), vel(c) {}\n\n    bool operator > (const status& o) const {\n        return dist > o.dist;\n    }\n};\n\nstruct edge {\n    int to;\n    double dist;\n    int lim;\n\n    edge () {}\n    ~edge () {}\n\n    edge(int a, double b, int c): to(a), dist(b), lim(c) {}\n};\n\nconst int INF = 1 << 29;\n\nbool solve() {\n    int n, m, s, g;\n    /*\n     * n <- [1..20]\n     * m <- [1..?]\n     * s, g <- [1..n]\n     * (x, y, d, c)\n     *   x, y <- [1..n]\n     *   d <- [1..100]\n     *   c <- [1..30]\n     */\n    cin >> n >> m >> s >> g;\n\n    if ((n | m | s | g) == 0) return false;\n\n    --s; --g;\n\n    vector<vector<edge>> graph(n, vector<edge>());\n\n    for (int j = 0; j < m; ++j) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        --x; --y;\n        graph[x].push_back(edge(y, d, c));\n        graph[y].push_back(edge(x, d, c));\n    }\n\n    vector<vector<double>> dist(n, vector<double>(30 + 1, INF));\n    priority_queue<status, vector<status>, greater<status>> que;\n\n    dist[s][0] = 0;\n    que.push(status(s, 0.0, 0));\n\n    while (!que.empty()) {\n        status st = que.top(); que.pop();\n\n        if (dist[st.pos][st.vel] < st.dist) {\n            continue;\n        }\n\n        for (edge& e : graph[st.pos]) {\n            double d = st.dist + e.dist / (st.vel+1);\n            if (st.vel + 1 <= e.lim && d < dist[e.to][st.vel+1]) {\n                dist[e.to][st.vel+1] = d;\n                que.push(status(e.to, d, st.vel+1));\n            }\n            d = st.dist + e.dist / st.vel;\n            if (st.vel > 0 && st.vel <= e.lim && d < dist[e.to][st.vel]) {\n                dist[e.to][st.vel] = d;\n                que.push(status(e.to, d, st.vel));\n            }\n            d = st.dist + e.dist / (st.vel-1);\n            if (st.vel - 1 > 0 && d < dist[e.to][st.vel-1]) {\n                dist[e.to][st.vel-1] = d;\n                que.push(status(e.to, d, st.vel-1));\n            }\n        }\n    }\n\n    if (dist[g][1] == INF) {\n        printf(\"unreachable\\n\");\n    } else {\n        printf(\"%.10f\\n\", dist[g][1]);\n    }\n\n    return true;\n}\n\nint main () {\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];    \n    \n int inx,iny,ind,inc;\n  double d[40][40][40];\n  int n,m,s,g;\n \n\n    scanf(\"%d %d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef vector<float> vf;\ntypedef vector<vf> vvf;\n\n#define INF 1e8\n#define V_MAX 30\n\nstruct edge {\n    int to, distance, limit;\n};\n\nstruct P {\n    int from;\n    float cost;\n    int v;\n    int before;\n\n    bool operator >(const P& p) const {\n        return cost > p.cost;\n    }\n};\n\nint node_n, edge_n, start, goal;\n\nint main() {\n    while (cin >> node_n >> edge_n, node_n|edge_n) {\n        vector<vector<edge>> E(node_n+1);\n        cin >> start >> goal;\n        REP(i, edge_n) {\n            int to, from, distance, limit;\n            cin >> to >> from >> distance >> limit;\n            E[to].push_back({from, distance, limit});\n            E[from].push_back({to, distance, limit});\n        }\n\n        vector<vvf> G(node_n+1, vvf(node_n+1, vf(V_MAX+1, INF)));\n        priority_queue<P, vector<P>, greater<P>> q;\n        q.push({start, 0, 0});\n\n        float cost = 0;\n        while (!q.empty()) {\n            P p = q.top(); q.pop();\n\n            if (p.from == goal && p.v == 1) {\n                cost = p.cost;\n                break;\n            }\n\n            for (edge e : E[p.from]) {\n                if (e.to == p.before) continue;\n                // v+1, v, v-1\n                for (int i = -1; i <= 1; i++) {\n                    int v = p.v + i;\n                    if (1 <= v && v <= V_MAX && v <= e.limit) {\n                        float t = e.distance / (float)(v);\n                        if (G[e.to][p.from][v] > p.cost + t) {\n                            G[e.to][p.from][v] = p.cost + t;\n                            q.push({e.to, p.cost + t, v, p.from});\n                        }\n                    }\n                }\n            }\n        }\n        if (cost > 0) {\n            printf(\"%.5f\\n\", cost);\n        } else {\n            printf(\"unreachable\\n\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst double eps = 1e-9;\nconst double inf = (double)(1<<24);\nconst int size = 31;\nint n, m;\n\nclass Node {\npublic:\n  double t;\n  int v, town, p;\n  bool operator < ( const Node right ) const {\n    return fabs( t - right.t ) < eps ? v < right.v : t > right.t;\n  }\n  Node() {}\n  Node( double t_, int v_, int town_, int p_ = -1 ) {\n    t = t_;\n    v = v_;\n    town = town_;\n    p = p_;\n  }\n};\n\n// for dijkstra\ntypedef priority_queue <Node > QUEUE;\nbool P[size][size]; // path\ndouble MC[32][size]; // min cost\nint D[size][size]; // distance of path\nint L[size][size]; // speed limit of path\nint con[size][size]; // connnect\nint concnt[size];\n\n\nmap <int, int> T; // town number to index\nint TC; // the number of towns\n\nvoid reg( int town )\n{\n  if ( T.find( town ) != T.end() ) return;\n  T[town] = TC;\n  TC++;\n}\n\nvoid solve( int s_, int g_ )\n{\n  int start = T[s_], goal = T[g_];\n  if ( !P[start][goal] ) {\n    cout << \"unreachable\" << endl;\n    return;\n  }\n\n  QUEUE Q;\n  Node start_node( 0.0, 1, start, -1 );\n  Q.push( start_node );\n  MC[1][start] = 0.0;\n  \n  while ( !Q.empty() ) { \n    Node node = Q.top();\n    Q.pop();\n    double t = node.t;\n    int v = node.v;\n    int town = node.town;\n    int prev = node.p;\n\n    // cout << \"time=\" << t << \": town=\" << town << \", v=\" << v << endl;\n    if ( town == goal && v == 1 ) {\n      // cout << MC[v][town] << \",\" << t << endl;\n      printf( \"%.5f\\n\", t );\n      return;\n    }\n\n    // cout << \"test\" << endl;\n    for ( int i = 0; i < concnt[town]; i++ ) {\n      int next_town = con[town][i];\n      // debug\n      // cout << town << \" => \" << next_town << endl;\n      if ( prev != -1 && prev == next_town ) continue;\n      for ( int j = -1; j < 2; j++ ) {\n        if ( prev == -1 && j != 0 ) continue; \n        int next_v = v + j;\n        if ( next_v <= 0 || next_v > L[town][next_town] ) continue;\n\n        double next_t = t + (double)D[town][next_town] / next_v;\n        if ( next_t + eps > MC[next_v][next_town] ) continue;\n\n        Node next_node( next_t, next_v, next_town, town );\n        MC[next_v][next_town] = next_t;\n        Q.push( next_node );\n      }\n    }\n  }\n  \n  cout << \"unreachable\" << endl;\n}\n\nint main( void )\n{\n  while ( cin >> n >> m && n ) {\n    // init\n    for ( int i = 0; i < size; i++ ) {\n      T.clear();\n      TC = 0;\n      concnt[i] = 0;\n      for ( int j = 0; j < size; j++ ) {\n        P[i][j] = false;\n      }\n      for ( int j = 0; j < 32; j++ ) {\n        MC[i][j] = inf;\n      }\n    }\n\n    // input\n    int s, g;\n    cin >> s >> g;\n    for ( int i = 0; i < m; i++ ) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      reg(x);\n      reg(y);\n      int xi = T[x];\n      int yi = T[y];\n      // cout << x << \":\" << xi << \", \" << y << \":\" << yi << endl; // debug\n      P[xi][yi] = P[yi][xi] = true;\n      D[xi][yi] = D[yi][xi] = d;\n      L[xi][yi] = L[yi][xi] = c;\n      con[xi][concnt[xi]++] = yi;\n      con[yi][concnt[yi]++] = xi;\n    }\n\n    for ( int k = 0; k < n; k++ ) {\n      for ( int i = 0; i < n; i++ ) {\n        for ( int j = 0; j < n; j++ ) {\n          if ( !P[i][k] || !P[k][j] ) continue;\n          P[i][j] = true;\n        }\n      }\n    }\n\n    solve( s, g );\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 150\ntypedef std::pair<short,short> P;\ntypedef std::pair<P,short> PP;\ntypedef std::pair<float,short> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    short n,m;\n\n    scanf(\"%hd%hd\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    short inx,iny,ind,inc;\n    float d[31][31][31];\n    short s,g;\n \n\n    scanf(\"%hd%hd\",&s,&g);\n    for(short i=1;i<=n;i++)for(short j=1;j<=n;j++)for(short k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(short i=0;i<m;i++){\n      scanf(\"%hd%hd%hd%hd\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    \n    while(que.size()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(short i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <string.h>\n#include <numeric>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(i,v) for(auto &(i):(v))\n#define eachr(i,v) for(auto &(i)=(v).rbegin();(i)!=(v).rend();(i)++)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n#define endl \"\\n\"\n\n//typedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a/gcd(a,b)*b;}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n    oreno_initializer() {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n} oreno_initializer;\n\n\n\nint n, m, s, g, x, y, b;\n// 町iに到達したとき速度jであるような最短距離 たどり着いた瞬間の値ってことに注意\ndouble d[33][33], a, res;\n// 町i速度jから伸びる(移動先、コスト)の辺\nvector<pair<int, double> > e[33][33];\n\ntypedef pair<double, pair<int, pair<int, int > > > ppap;\nvoid dijkstra() {\n    priority_queue<ppap, vector<ppap>, greater<ppap> > q;\n    // dist v p speed\n    q.push({0.0, {s, {-1, 1}}});\n    while(!q.empty()) {\n        int v = q.top().second.first, pa = q.top().second.second.first, sp = q.top().second.second.second;\n        double dis = q.top().first;\n        q.pop();\n        if (d[v][sp]<dis) continue;\n        int spl = max(1, sp-1), spr = min(30, sp+1);\n        if (dis==0.0) spl = spr = 1;\n        reps(ts,spl,spr+1) for (int i = 0; i < e[v][ts].size(); i++) {\n            int to = e[v][ts][i].first;\n            //if (to==pa) continue;\n            double cost = e[v][ts][i].second;\n            if (d[to][ts] > d[v][sp] + cost) {\n                d[to][ts] = d[v][sp] + cost;\n                q.push({d[to][ts], {to, {v, ts}}});\n                if (to==g && ts==1) chmin(res, d[to][ts]);\n            }\n        }\n    }\n}\n\nsigned main() {\n    while (1) {\n        cin >> n >> m;\n        if (n==0) break;\n        rep(i,n) rep(j,33) e[i][j].clear(), d[i][j] = 1e100;\n        cin >> s >> g;\n        s--, g--;\n        d[s][1] = 0;\n        rep(j,m) {\n            cin >> x >> y >> a >> b;\n            x--, y--;\n            reps(i,1,b+1) {\n                e[x][i].push_back({y, a/i});\n                e[y][i].push_back({x, a/i});\n            }\n        }\n        res = 1e100;\n        dijkstra();\n        //rep(i,n) rep(j,30) cout << d[i][j] << bln(j,30);\n        if (res==1e100) printf(\"unreachable\\n\");\n        else printf(\"%.14lf\\n\", res);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?(テァツクツョテ・ツーツ湘ァツ可?\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\nconstexpr int T = 40;\n\nint N, M, s, g;\n\n// テゥツδステ・ツクツづ」ツ?ィテゥツ?淌・ツコツヲテ」ツ?ィテ・ツ可催」ツ?ョテゥツ?淌・ツコツヲテ」ツ??、ツクツュティツコツォテ」ツ?ッテヲツ卍づゥツ鳴?\ndouble dist[40][T][T];\n\nstruct Edge {\n    int to; double cost; int lim;\n};\n\nstruct Elem {\n    int cur, speed; double cost; int prev, prevs;\n};\n\nbool operator<(const Elem &a, const Elem &b) {\n    return a.cost > b.cost;\n}\n\nint dx[] = {1, 0, -1};\n\nsigned main() {\n    while(cin >> N >> M, N || M) {\n        cin >> s >> g; s--; g--;\n        vector< vector<Edge> > G(N);\n        rep(i,0,M) {\n            int x, y; double d; int c; cin >> x >> y >> d >> c;\n            x--; y--;\n            G[x].push_back(Edge{y, d, c});\n            G[y].push_back(Edge{x, d, c});\n        }\n\n        rep(i,0,N) rep(j,0,T) rep(k,0,T) dist[i][j][k] = INF;\n        dist[s][1][0] = 0.0;\n\n        priority_queue<Elem> q;\n        q.push(Elem{s, 1, 0.0, -1, 0});\n\n        double ans = INF;\n        while(!q.empty()) {\n            Elem t = q.top(); q.pop();\n            if(t.cur == g && t.prevs == 1) break;\n            rep(i,0,3) {\n                int sp = t.speed + dx[i];\n                if(sp == 0) continue;\n                for(auto x : G[t.cur]) {\n                    if(x.lim < t.speed || x.to == t.prev) continue;\n                    double c = x.cost / t.speed;\n                    if(dist[x.to][sp][t.speed] >= dist[t.cur][t.speed][t.prevs] + c) {\n                        dist[x.to][sp][t.speed] = dist[t.cur][t.speed][t.prevs] + c;\n                        if(x.to == g && t.speed == 1) {\n                            chmin(ans, dist[x.to][sp][t.speed]);\n                        }\n                        q.push(Elem{x.to, sp, dist[x.to][sp][t.speed], t.cur, t.speed});\n                    }\n                }\n            }\n        }\n        if(ans == INF) cout << \"unreachable\" << endl;\n        else printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\n \n#define INF 1145141919.810\n \nint n, m, s, g;\ndouble x[50][50][2];\nint a, b, c, d;\n \ndouble dp[50][50];\ndouble res;\n \ndouble solve(int p, int st, int go) {\n    dp[st][0] = 0;\n    for (int i = 1; i <= 400; i++) {\n        for (int j = 1; j <= p; j++) {\n            if(j!=go){\n            for (int k = 0; k <= 30; k++) {\n                if (dp[j][k] < INF / 2) {\n                    for (int l = 1; l <= p; l++) {\n                        if (x[j][l][0] < 100000) {\n                            //v-1.\n                            if ((k - 1) >= 1 && (k - 1) <= x[j][l][1]) {\n                                dp[l][k - 1] = min(dp[l][k - 1], dp[j][k] + 1.0*x[j][l][0] / (k - 1));\n                            }\n                            //v.\n                            if (k >= 1 && k <= x[j][l][1]) {\n                                dp[l][k] = min(dp[l][k], dp[j][k] + 1.0*x[j][l][0] / k);\n                            }\n                            //v-1.\n                            if ((k + 1) >= 1 && (k + 1) <= x[j][l][1]) {\n                                dp[l][k + 1] = min(dp[l][k + 1], dp[j][k] + 1.0*x[j][l][0] / (k + 1));\n                            }\n                        }\n                    }\n                }\n            }\n            }\n        }\n    }\n    return dp[go][1];\n}\n \nint main() {\n    while (true) {\n        for (int i = 0; i < 50; i++) {\n            for (int j = 0; j < 50; j++) {\n                dp[i][j] = INF;\n                x[i][j][0] = 10000000;\n                x[i][j][1] = 0;\n            }\n        }\n        cin >> n >> m;\n        if (n == 0 && m == 0) { break; }\n        cin >> s >> g;\n        for (int i = 0; i < m; i++) {\n            cin >> a >> b >> c >> d;\n            x[a][b][0] = c;\n            x[a][b][1] = d;\n            x[b][a][0] = c;\n            x[b][a][1] = d;\n        }\n        res = solve(n, s, g);\n        if (res > 1000000.00) { cout << \"unreachable\" << endl; }\n        else { cout << fixed << setprecision(15) << res << endl; }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// (x,y)\ntypedef pair<int,int> P;\n// ( 速度 , (前の町,今の町) )\ntypedef pair<int,P> Node;\n// (cost,Node)\ntypedef pair<double,Node> State;\n\nconst int MAX_V = 31;\nconst double INF = 100000;\n\nstruct edge{\n\tint to, d, c;\n\tedge(int to_, int d_, int c_){\n\t\tto = to_; d = d_; c = c_;\n\t}\n};\n\n// グラフ\nvector<edge> G[MAX_V];\n// スタートからゴールに辿りつけるかどうか\nbool is_connect;\n\n// 入力\nint n, m;\n\n// 初期化\nvoid init(){\n\tis_connect = false;\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tG[i].clear();\n\t}\n}\n\n// 辺の追加\nvoid add_edge(int x, int y, int d, int c){\n\tedge e( y , d , c );\n\tG[x].push_back( e );\n\te.to = x;\n\tG[y].push_back( e );\n}\n\n// スタートからゴールに辿りつけるかどうかチェック\nvoid check(int v, int g, map<int,bool> memo){\n\tif( v == g ){\n\t\tis_connect = true;\n\t}\n\tif( memo[v] ) return;\n\tmemo[v] = true;\n\t\n\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\tint to = G[v][i].to;\n\t\tif( memo[to] ) continue;\n\t\tcheck( to , g , memo );\n\t}\n}\n\n// ダイクストラ法\ndouble solve(int s, int g){\n\t// d[v][x][y] := 速度v, 前の町x, 今の町yまでの最小コスト\n\tdouble d[31][31][31];\n\t// 訪れたかどうか\n\tbool visited[31][31][31];\n\t// 初期化\n\tfor(int y=0 ; y < MAX_V ; y++ ){\n\t\tfor(int x=0 ; x < MAX_V ; x++ ){\n\t\t\tfor(int v=0 ; v < 31 ; v++ ){\n\t\t\t\td[v][y][x] = INF;\n\t\t\t\tvisited[v][y][x] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ( 速度 , (前の町,今の町) ), 始点は前の町を0としてどの町にも Uターンできる扱い\n\tNode start( 0 , P(0,s) );\n\td[0][0][s] = 0;\n\tpriority_queue< State, vector<State> , greater<State> > q;\n\tq.push( State(0,start) );\n\t\n\tdouble ans = INF;\n\twhile( !q.empty() ){\n\t\t// 値を取り出す\n\t\tdouble now_cost = q.top().first;\n\t\tint v = q.top().second.first;\n\t\tint x = q.top().second.second.first;\n\t\tint y = q.top().second.second.second;\n\t\tq.pop();\n\t\t\n\t\tif( now_cost >= ans || visited[v][x][y] ) continue;\n\t\tvisited[v][x][y] = true;\n\t\t\n\t\t// 目的地のとき\n\t\tif( y == g && v == 1 ){\n\t\t\tans = min( ans , now_cost );\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < G[y].size() ; i++ ){\n\t\t\tint to = G[y][i].to;\n\t\t\tint dis = G[y][i].d;\n\t\t\tint c = G[y][i].c;\n\t\t\tif( to == x ) continue;\n\t\t\t\n\t\t\tfor(int dv = -1 ; dv <= 1 ; dv++ ){\n\t\t\t\tint next_v = v + dv;\n\t\t\t\tif( next_v > c || next_v <= 0 ) continue;\n\t\t\t\t\n\t\t\t\tdouble cost = (double)dis / next_v;\n\t\t\t\tif( now_cost + cost < d[next_v][y][to] ){\n\t\t\t\t\td[next_v][y][to] = now_cost + cost;\n\t\t\t\t\t\n\t\t\t\t\tNode next( next_v , P(y,to) );\n\t\t\t\t\tState p( now_cost + cost , next );\n\t\t\t\t\tq.push( p );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile( cin >> n >> m , n || m ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\t\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tadd_edge( x , y , d , c );\n\t\t}\n\t\t\n\t\t{\n\t\t\t// スタートからゴールに辿りつけるかどうか\n\t\t\tmap<int,bool> memo;\n\t\t\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\t\t\tmemo[i] = false;\n\t\t\t}\n\t\t\tcheck( s , g , memo );\n\t\t}\n\t\t\n\t\t// ゴールに辿りつけないとき\n\t\tif( is_connect == false ){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t\tdouble ans = solve( s , g );\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nstruct State {\n    int i, prev, sp; double cost;\n};\n\nbool operator>(const State& a, const State& b)\n{\n    return a.cost > b.cost;\n}\n\nconst double INF = 1<<29;\n\nint main()\n{\n    while (1) {\n        int n, m, s, g; cin >> n >> m >> s >> g;\n        if (!n) break;\n        s--, g--;\n\n        vector<vector<double>> dist(n, vector<double>(n, INF));\n        vector<vector<int>> lim(n, vector<int>(n));\n\n        while (m--) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--, y--;\n            dist[x][y] = dist[y][x] = d;\n            lim[x][y] = lim[y][x] = c;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> Q;\n        Q.push({ s, -1, 0, 0 });\n\n        pair<int, int> debug[40][40];\n\n        int vis[40][40][40] = {};\n        double ans = INF;\n        while (Q.size()) {\n            auto e = Q.top(); Q.pop();\n            if (vis[e.i][e.sp][e.prev]) continue;\n            vis[e.i][e.sp][e.prev] = 1;\n            if (e.i == g && e.sp == 1) ans = min(ans, e.cost);\n            loop (n, i) loop (3, d) {\n                int sp = e.sp-1+d;\n                if (dist[e.i][i] == INF || i == e.prev ||\n                        sp < 1 || sp > lim[e.i][i]) continue;\n                Q.push({ i, e.i, sp, e.cost + dist[e.i][i] / sp });\n            }\n        }\n        if (ans != INF) cout << setprecision(12) << fixed << ans << endl;\n        else cout << \"unreachable\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S second\n#define F first\n#define EPS (1e-7)\n#define INF (1e9)\n#define N 31\nusing namespace std;\ntypedef pair<double,int> P;\ntypedef pair<int,int> P1;\ntypedef pair<int,P1> P2;\ntypedef pair<P,P1> P3;\ntypedef pair<P3,int> P4;\n\nvector<P2> G[N];\nint n,m,s,g;\n\ndouble dijkstra(){\n  P d[N][N][N];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<N;k++)\n\td[i][j][k]=P(INF,INF);\n  priority_queue<P4,vector<P4>,greater<P4> > q;\n  for(int i=0;i<G[s].size();i++){\n    int nx=G[s][i].first,cost=G[s][i].second.first;\n    d[s][nx][1]=P(cost,cost);\n    q.push(P4(P3(P(cost,cost),P1(s,nx)),1));\n  }\n  while(!q.empty()){\n    P4 t=q.top(); q.pop();\n    int px=t.F.S.F,x=t.F.S.S,v=t.S,sum=t.F.F.S;\n    double cost=t.F.F.F;\n    if(d[px][x][v].F+EPS<cost)continue;\n    if(abs(cost-d[px][x][v].F)<EPS)\n      if(d[px][x][v].S<sum)continue;\n    if(x==g&&v==1)return cost;\n    for(int i=0;i<G[x].size();i++){\n      int nx=G[x][i].F,cost2=G[x][i].S.F;\n      int lim=G[x][i].S.S;\n      if(nx==px)continue;\n      for(int j=-1;j<=1;j++){\n\tint nv=v+j;\n\tif(nv<1||30<nv||nv>lim)continue;\n\tdouble ncost=cost+1.0*cost2/nv;\n\tif(d[x][nx][nv].F>ncost+EPS){\n\t  d[x][nx][nv]=P(ncost,sum+cost);\n\t  q.push(P4(P3(P(ncost,sum+cost),P1(x,nx)),nv));\n\t}\n\t/*if(abs(d[x][nx][nv].F-ncost)<EPS)\n\t  if(d[x][nx][nv].S>sum+cost){\n\t    d[x][nx][nv]=P(ncost,sum+cost);\n\t    q.push(P4(P3(P(ncost,sum+cost),P1(x,nx)),nv));\n\t    }*/\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    cin>>s>>g;\n    s--,g--;\n    int a,b,c,d;\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>c>>d;\n      a--,b--;\n      G[a].push_back(P2(b,P1(c,d)));\n      G[b].push_back(P2(a,P1(c,d)));\n    }\n    double r=dijkstra();\n    if(r==-1)cout<<\"unreachable\"<<endl;\n    else printf(\"%.5f\\n\",r);\n    for(int i=0;i<n;i++)G[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n\tint cost,limit;\n\tedge(int c,int l){\n\t\tcost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tvector<vector<edge> > E(n+1,vector<edge>(n+1,edge(-1,-1)));\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in][out]=edge(c,l);\n\t\tE[out][in]=edge(c,l);\n\t}\n\tvector<vector<double> > Ans(n+1,vector<double>(31,INF));\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){\n\t\tNode t=Q.top(); Q.pop();\n\t\tif(Ans[t.now][t.speed]<=t.time) continue;\t\t\n//\t\tcout<<t.now<<\" \"<<t.speed<<\" \"<<t.time<<endl;\n\t\tif(t.now==g && t.speed==1){printf(\"%.12lf\\n\", t.time );  return;}\n\t\tAns[t.now][t.speed]=t.time;\n\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tif(i==t.before) continue;\n\t\t\tif(E[t.now][i].cost>0){\n\t\t\t\tif(E[t.now][i].limit>=t.speed && t.speed>=1)\n\t\t\t\t\tQ.push(Node(i,t.speed,t.time+E[t.now][i].cost/(double)t.speed,t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed+1)\n\t\t\t\t\tQ.push(Node(i,t.speed+1,t.time+E[t.now][i].cost/(double)(t.speed+1.0),t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed-1 && t.speed-1>=1)\n\t\t\t\t\tQ.push(Node(i,t.speed-1,t.time+E[t.now][i].cost/(double)(t.speed-1.0),t.now));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\"<<endl;\n\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nclass Node {\npublic:\n  int pre;\n  int now;\n  int vel;\n  double time;\n\n  Node(int p, int n, int v, double t) {\n    pre = p;\n    now = n;\n    vel = v;\n    time = t;\n  }\n\n  bool operator<(const Node &n) const {\n    return time > n.time;\n  }\n};\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n\n    if (n == 0) {\n      break;\n    }\n\n    int s, g;\n    cin >> s >> g;\n\n    vector<vector<int> > d(n + 1), c(n + 1);\n    for (int i = 0; i <= n; i++) {\n      d[i].resize(n + 1);\n      c[i].resize(n + 1);\n      fill(d[i].begin(), d[i].end(), -1);\n      fill(c[i].begin(), c[i].end(), 0);\n    }\n\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      cin >> d[x][y] >> c[x][y];\n      d[y][x] = d[x][y];\n      c[y][x] = c[x][y];\n    }\n\n    bool f[31][31][31];\n    for (int i = 0; i < 31; i++) {\n      for (int j = 0; j < 31; j++) {\n\tfor (int k = 0; k < 31; k++) {\n\t  f[i][j][k] = false;\n\t}\n      }\n    }\n  \n    bool goal = false;\n    Node snd(0, 1, 0, 0.0);\n    priority_queue<Node> q;\n    q.push(snd);\n    while (!q.empty()) {\n      Node nd = q.top();\n      q.pop();\n      if (nd.now == g && nd.vel == 1) {\n\tgoal = true;\n\tcout << nd.time << endl;\n\tbreak;\n      }\n\n      if (f[nd.pre][nd.now][nd.vel]) {\n\tcontinue;\n      }\n    \n      f[nd.pre][nd.now][nd.vel] = true;\n      for (int i = 1; i <= n; i++) {\n\tif (d[nd.now][i] != -1) {\n\t  for (int j = -1; j <= 1; j++) {\n\t    int vel = nd.vel + j;\n\t    if (vel > 0 && vel <= c[nd.now][i]) {\n\t      Node next(nd.now, i, vel, nd.time + (double)d[nd.now][i] / vel);\n\t      q.push(next);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    if (!goal) {\n      cout << \"unreachable\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tstatic int adj[30][30],lim[30][30];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)\tadj[i][j]=-1;\n\n\t\tint s,g;\tscanf(\"%d%d\",&s,&g);\n\t\ts--,g--;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,l;\tscanf(\"%d%d%d%d\",&x,&y,&d,&l);\n\t\t\tx--,y--;\n\t\t\tadj[x][y]=adj[y][x]=d;\n\t\t\tlim[x][y]=lim[y][x]=l;\n\t\t}\n\n\t\tstatic bool visited[30][30];\n\t\tstatic double tmin[30][30];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<30;j++){\n\t\t\tvisited[i][j]=false;\n\t\t\ttmin[i][j]=1<<30;\n\t\t}\n\n\t\ttmin[s][0]=0;\n\t\tpriority_queue< pair<double,pii> > pq;\tpq.push(mp(0,mp(s,0)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<double,pii> a=pq.top();\tpq.pop();\n\t\t\tint u=a.second.first,sp=a.second.second;\n\t\t\tif(visited[u][sp])\tcontinue;\n\t\t\tvisited[u][sp]=true;\n\t\t\tif(u==g && sp==1)\tbreak;\n\n\t\t\tfor(int v=0;v<n;v++){\n\t\t\t\tif(adj[u][v]==-1)\tcontinue;\n\t\t\t\tfor(int dv=-1;dv<=1;dv++){\n\t\t\t\t\tint nextsp=sp+dv;\n\t\t\t\t\tif(!visited[v][nextsp] && 1<=nextsp && nextsp<=lim[u][v]){\n\t\t\t\t\t\tdouble nextt=tmin[u][sp]+(double)adj[u][v]/nextsp;\n\t\t\t\t\t\tif(nextt<tmin[v][nextsp]){\n\t\t\t\t\t\t\tpq.push(mp(-nextt,mp(v,nextsp)));\n\t\t\t\t\t\t\ttmin[v][nextsp]=nextt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(visited[g][1])\tprintf(\"%f\\n\",tmin[g][1]);\n\t\telse\t\t\t\tputs(\"unreachable\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nclass State {\npublic:\n\tdouble time;\n\tint now, next, speed;\n\n\tState(double _time, int _now, int _next, int _speed) :time(_time), now(_now), next(_next), speed(_speed) {}\n\n\tbool operator < (const State& obj) const\n\t{\n\t\treturn time < obj.time;\n\t}\n\n\tbool operator > (const State& obj) const\n\t{\n\t\treturn time > obj.time;\n\t}\n};\n\nclass Edge {\npublic:\n\tint to, d, c;\n\n\tEdge(int _to, int _d, int _c) :to(_to), d(_d), c(_c) {}\n};\n\nconst int dsp[3] = { -1,0,1 };\nconst int MAX = 31;\nconst int INF = 1 << 29;\n\nint main()\n{\n\twhile (true) {\n\t\tint n, m;\n\n\t\tcin >> n >> m;\n\n\t\tif (n == 0 && m == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tint s, g;\n\n\t\tcin >> s >> g;\n\n\t\tvector<vector<Edge>> path(n);\n\t\tdouble dp[MAX][MAX][MAX];\n\t\tbool visited[MAX][MAX][MAX];\n\t\tpriority_queue<State, vector<State>, greater<State>> pq;\n\t\t\n\t\trep(i, m) {\n\t\t\tint x, y, d, c;\n\n\t\t\tcin >> x >> y >> d >> c;\n\n\t\t\tpath[x - 1].push_back(Edge(y - 1, d, c));\n\t\t\tpath[y - 1].push_back(Edge(x - 1, d, c));\n\t\t}\n\n\t\trep(i, MAX) {\n\t\t\trep(j, MAX) {\n\t\t\t\trep(k, MAX) {\n\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i, MAX) {\n\t\t\trep(j, MAX) {\n\t\t\t\trep(k, MAX) {\n\t\t\t\t\tvisited[i][j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpq.push(State(0, s - 1, s - 1, 0));\n\t\tdp[s - 1][s - 1][0] = 0;\n\n\t\twhile (!pq.empty()) {\n\t\t\tState temp = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif (visited[temp.now][temp.next][temp.speed] == true) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvisited[temp.now][temp.next][temp.speed] = true;\n\t\t\t}\n\n\t\t\trep(i, path[temp.next].size()) {\n\t\t\t\tint next = path[temp.next][i].to;\n\n\t\t\t\tif (next == temp.now) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trep(j, 3) {\n\t\t\t\t\tint nsp = temp.speed + dsp[j];\n\n\t\t\t\t\tif (nsp > 0 && nsp <= 30 && nsp <= path[temp.next][i].c&&visited[temp.next][next][nsp] == false) {\n\t\t\t\t\t\tif (dp[temp.next][next][nsp] > temp.time + (double)path[temp.next][i].d / nsp) {\n\t\t\t\t\t\t\tdp[temp.next][next][nsp] = temp.time + (double)path[temp.next][i].d / nsp;\n\t\t\t\t\t\t\tpq.push(State(dp[temp.next][next][nsp], temp.next, next, nsp));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tdouble ans = INF;\n\n\t\trep(i, MAX) {\n\t\t\tans = min(ans, dp[i][g - 1][1]);\n\t\t}\n\n\t\tif (ans == INF) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<double, int, int, int> T;\n \nconst ll MOD=1e9+7;\n//const ll INF=1e18;\n\nconst double INF = 1000000.0;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\nstruct edge{ int to,d,c;};\n\n\n\nint n,m,s,g;\ndouble d[35][35][35];\ndouble mind;\n\nint main(){\n\twhile(true){\n\t\tcin >> n >> m;\n\t\tif(n + m == 0) break;\n\t\tcin >> s >> g;\n\t\tmind = INF;\n\t\tvector<edge> G[35];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a1,a2,a3,a4;\n\t\t\tcin >> a1 >> a2 >> a3 >> a4;\n\t\t\tedge tmp1 = {a2,a3,a4};\n\t\t\tG[a1].push_back(tmp1);\n\t\t\tedge tmp2 = {a1,a3,a4};\n\t\t\tG[a2].push_back(tmp2);\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tfor(int k = 0;k <= 31;k++){\n\t\t\t\t\td[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//queue<T> que;\n\t\tpriority_queue<T,vector<T>,greater<T> > que;\n\t\tfor(int i = 0;i < G[s].size();i++){\n\t\t\tedge e = G[s][i];\n\t\t\td[s][e.to][1] = (double) e.d;\n\t\t\tque.push(make_tuple((double)e.d,1,s,e.to));\n\t\t}\n\n\t\twhile(!que.empty()){\n\t\t\tT t = que.top(); que.pop();\n\t\t\tdouble a1 = get<0>(t);\n\t\t\tint a2 = get<1>(t),a3 = get<2>(t),a4 = get<3>(t);\n\t\t\tif(d[a3][a4][a2] < a1 || a1 > mind)continue;\n\t\t\tfor(int i = 0;i < G[a4].size();i++){\n\t\t\t\tedge e = G[a4][i];\n\t\t\t\tif(e.to == a3) continue;\n\t\t\t\tdouble tmp = (double) a1 + (double)e.d;\n\t\t\t\tif(d[a4][e.to][1] < tmp)continue;\n\t\t\t\td[a4][e.to][v] =  tmp;\n\t\t\t\tif(mind < tmp) continue;\n\t\t\t\tif(e.to == g && mind > tmp)mind = tmp;\n\t\t\t\tque.push(make_tuple(tmp,1,a4,e.to));\n\t\t\t}\n\t\t}\n\t\tif(mind == INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tfor(int k = 0;k <= 31;k++){\n\t\t\t\t\td[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < G[s].size();i++){\n\t\t\tedge e = G[s][i];\n\t\t\td[s][e.to][1] = (double) e.d;\n\t\t\tque.push(make_tuple((double)e.d,1,s,e.to));\n\t\t}\n\n\n\n\t\twhile(!que.empty()){\n\t\t\t//T t = que.front(); que.pop();\n\t\t\tT t = que.top(); que.pop();\n\t\t\tdouble a1 = get<0>(t);\n\t\t\tint a2 = get<1>(t),a3 = get<2>(t),a4 = get<3>(t);\n\t\t\tif(d[a3][a4][a2] < a1 || a1 > mind)continue;\n\t\t\tfor(int i = 0;i < G[a4].size();i++){\n\t\t\t\tedge e = G[a4][i];\n\t\t\t\tif(e.to == a3) continue;\n\t\t\t\tfor(int j = -1;j <= 1;j++){\n\t\t\t\t\tint v = a2 + j;\n\t\t\t\t\tdouble tmp = (double)( a1 + (double)e.d / (double)v);\n\t\t\t//\t\tif(a4 == 5 && e.to == 6 && v == 1) cout << \"tmp\" << tmp << \",a1\" << a1 <<endl;\n\t\t\t\t\tif(v <= 0 || v > e.c || d[a4][e.to][v] < tmp ||tmp > mind) continue;\n\t\t\t\t\td[a4][e.to][v] =  tmp;\n\t\t\t\t\tif(e.to == g && v == 1 && mind > tmp)mind = tmp;\n\t\t\t\t\tque.push(make_tuple(tmp,v,a4,e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\n\t\t}\n\t//\tcout << \"ans\" << d[4][5][2] << endl;\n\n\n\n\t\tdouble ans = INF;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tdouble tmp = d[i][g][1];\n\t\t\tif(ans > tmp) ans = tmp;\n\t\t//\tans = min(ans,d[i][g][1]);\n\t\t}\n\t\tif(ans == INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t//\tcout << ans << endl;\n\t\t\tprintf(\"%lf\\n\",ans);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "=#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000.0\nusing namespace std;\nstruct state { int n, v, l; double t; };\n\nint N, M, S, G;\nvector<int> T[301], D[301], C[301];\nint vd[3] = { -1, 0, 1 };\ndouble dp[31][51];\n\nclass Compare {\npublic:\n  bool operator() (struct state a, struct state b) {\n    return a.t > b.t;\n  }\n};\n\nint main(void) {\n  while(cin >> N >> M, N) {\n    cin >> S >> G;\n    REP(i, 0, 300) {\n      T[i].clear();\n      D[i].clear();\n      C[i].clear();\n    }\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      T[x].push_back(y); D[x].push_back(d); C[x].push_back(c);\n      T[y].push_back(x); D[y].push_back(d); C[y].push_back(c);\n    }\n\n    REP(i, 1, N) REP(j, 0, 51) dp[i][j] = INF;\n\n    priority_queue<struct state, vector<struct state>, Compare> q;\n    struct state first = { S, 0, -1, 0.0 };\n    q.push(first);\n\n    while(!q.empty()) {\n      struct state c = q.top();\n      q.pop();\n\n      // cout << c.n << \" \" << c.v << \" \" << c.t << endl;\n\n      dp[c.n][c.v] = min(dp[c.n][c.v], c.t);\n      if(c.n == G && c.v == 1) break;\n\n      for(int i = 0; i < T[c.n].size(); i++) {\n        if(T[c.n][i] == c.l) continue;\n        REP(j, 0, 3) {\n          int v = c.v + vd[j];\n          if(v <= 0 || C[c.n][i] < v) continue;\n          double t = c.t + ((double) D[c.n][i] / v);\n          struct state n = { T[c.n][i], v, c.n, t };\n          if(n.t < dp[n.n][n.v]) q.push(n);\n        }\n      }\n    }\n\n    if(dp[G][1] < INF) printf(\"%.6f\\n\", dp[G][1]);\n    else cout << \"unreachable\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\nint n,m,s,g;\ndouble d[40][40][40];\n\nint main(){\n  int inx,iny,ind,inc;\n  while(true){\n    cin >> n >> m;\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n\n    cin >> s >> g;\n    for(int i=0;i<40;i++)for(int j=0;j<40;j++)for(int k=0;k<40;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n      cin >> inx >> iny >> ind >> inc;\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n    \n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n    cout << counter << endl;\n    if(test != INF)printf(\"%.5f\\n\",test);\n    else cout << \"unreachable\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<pair<double, int>,pair<int, int> > P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Edge{\n  int to,d,c;\n  Edge(int to, int d, int c):to(to),d(d),c(c){}\n};\n\nint N,M;\nvector<Edge>G[32];\ndouble dist[32][32][32];\n\nvoid dijkstra(int s){\n  rep(i,32) rep(j,32) rep(k,32)dist[i][j][k] = INF;\n  priority_queue<P, vector<P>, greater<P> >q;\n  dist[0][s][31] = 0.0;\n  q.push(MP(MP(0.0, 0),MP(s, 31)));\n  \n  while(!q.empty()){\n    P p = q.top(); q.pop();\n    int d = p.first.first, speed = p.first.second, cur = p.second.first, prev = p.second.second;\n    if(dist[speed][cur][prev] < d) continue;\n    //    cout << speed << \" \" << cur << \" \" << dist[speed][cur][prev] << endl;\n    for(int d=-1;d<=1;d++){\n      int sp = speed+d;\n      if(sp <= 0 || sp > 30) continue;\n      rep(i,G[cur].size()){\n\tEdge e = G[cur][i];\n\tif(e.to == prev) continue;\n\t//\tcout << dist[speed][cur][prev] << \" \" << (double)e.d/(double)sp << endl;\n\tif(sp <= e.c && dist[sp][e.to][cur] > dist[speed][cur][prev] + (double)e.d/(double)sp){\n\t  dist[sp][e.to][cur] = dist[speed][cur][prev] + (double)e.d/(double)sp;\n\t  //\t  cout << dist[sp][e.to][cur] << endl;\n\t  q.push(make_pair(make_pair(dist[sp][e.to][cur], sp), make_pair(e.to, cur)));\n\t}\n      }\n    }\n  }\n}\n\nint main(){\n  while(scanf(\"%d%d\",&N,&M) && N||M){\n    rep(i,32) G[i].clear();\n    int s, g;\n    scanf(\"%d%d\",&s,&g); s--; g--;\n    rep(i,M){\n      int x,y,d,c;\n      scanf(\"%d%d%d%d\",&x,&y,&d,&c); x--;y--;\n      G[x].push_back(Edge(y,d,c));\n      G[y].push_back(Edge(x,d,c));\n    }\n\n    dijkstra(s);\n\n    /*    rep(i, 10){\n      rep(j,N) cout << (dist[i][j]==INF?-1:dist[i][j]) << \" \";\n      cout << endl;\n      }*/\n    double res = INF;\n    rep(i,32) res = min(res, dist[1][g][i]);\n    //    rep(i,10) cout << dist[i][g] << \" \"; cout << endl;\n    if(res>INF-1) puts(\"unreachable\");\n    else printf(\"%.12lf\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\n#define INF 1e15\n\nint n, m;\n\nstruct edge{\n    int to;\n    double cost;\n    int limit;\n    edge(int t, double c, int l): to(t), cost(c), limit(l){}\n};\n\nstruct state{\n    int node, speed, prev;\n    double dist;\n    state(int n, int s, int p, double d): node(n), speed(s), prev(p), dist(d) {}\n    bool operator > (const state s) const {\n        return dist > s.dist;\n    }\n};\n \nvoid dijkstra(int start, vector<vector<vector<double> > > &d, vector<vector<edge> > graph){\n    d[start][0][0] = 0.0;\n    bool visit[31][31][31] = {};\n    priority_queue<state, vector<state>, greater<state> > q;\n    q.push(state(start, 0, 0, 0.0));\n    while (!q.empty()){\n        state a = q.top();\n        q.pop();\n        int now = a.node, prev = a.prev, speed = a.speed;\n        if (visit[now][speed][prev]) continue;\n        visit[now][speed][prev] = 1;\n        // printf(\"%d %d %d\\n\", now, prev, speed);\n        if(d[now][speed][prev] < a.dist) continue;\n        REP(i,graph[now].size()){\n            edge e = graph[now][i];\n            int next = e.to, limit = e.limit;\n            if (next == prev) continue;\n            FOR(dif,-1,1){\n                int next_speed = speed + dif;\n                if (next_speed <= 0 || next_speed > limit) continue;\n                if (d[next][next_speed][now] > d[now][speed][prev] + e.cost/next_speed){\n                    d[next][next_speed][now] = d[now][speed][prev] + e.cost/next_speed;\n                    q.push(state(next, next_speed, now, d[next][next_speed][now]));\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    while (cin >> n >> m && n){\n        vector<vector<edge> > graph(n);\n        int s, g;\n        cin >> s >> g;\n        s--;\n        g--;\n        REP(i,m){\n            int x, y, c;\n            double d;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            graph[x].push_back(edge(y,d,c));\n            graph[y].push_back(edge(x,d,c));\n        }\n        vector<vector<vector<double> > > dist(n, vector<vector<double> > (31, vector<double> (n, INF)));\n        dijkstra(s, dist, graph);\n        double ans = INF;\n        REP(i,n) ans = min(ans, dist[g][1][i]);\n        if (ans == INF) cout << \"unreachable\" << endl;\n        else printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1162\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1162&lang=jp\n\n#include <iostream>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\nconst double inf = (double)(1<<24);\n\nclass Node {\npublic:\n    double time;\n    int v, town, prev;\n    Node() {}\n    Node( double time_, int v_, int town_, int prev_ ) \n    {\n        time = time_;\n        v = v_;\n        town = town_;\n        prev = prev_;\n    }\n    bool operator < ( const Node& right ) const \n    {\n        return time > right.time;\n    }\n    bool operator > ( const Node& right ) const\n    {\n        return time < right.time;\n    }\n    bool operator == ( const Node& right ) const\n    {\n        return v == right.v && town == right.town && prev == right.prev;\n    }\n};\ntypedef priority_queue <Node> QUEUE;\nconst int size = 31;\n\nint n, m;\nbool P[size][size];\ndouble G[size][size];\ndouble MC[size][size];\nint L[size][size];\nint CN[size][size];\nint CN_count[size];\n\n// dijkstra\nvoid solve( int start, int goal )\n{\n    // init\n    QUEUE Q;\n    Node start_node( 0.0, 0, start, -1 );\n    Q.push( start_node );\n    MC[0][start] = 0.0;\n\n    // proc\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        // proc init\n        double time = node.time;\n        int v = node.v;\n        int town = node.town;\n        int prev = node.prev;\n\n        // goal\n        if ( town == goal && v == 1 ) {\n            printf( \"%.5f\\n\", time );\n            return;\n        }\n\n        // move\n        for ( int i = 0; i < CN_count[town]; i++ ) {\n            int next_town = CN[town][i];\n            if ( next_town == prev ) continue;\n            for ( int j = 1; j >= -1; j-- ) {\n                int next_v = v + j;\n                if ( prev == -1 && next_v != 1 ) continue;\n                if ( next_v <= 0 || next_v > L[town][next_town] ) continue;\n                double cost = (double)G[town][next_town] / next_v;\n                double next_time = time + cost;\n                int next_prev = town;\n\n                if ( next_time > MC[next_v][next_town] || fabs( next_time - MC[next_v][next_town] ) < eps ) continue;\n                MC[next_v][next_town] = next_time;\n                Node next_node( next_time, next_v, next_town, next_prev );\n                Q.push( next_node );\n            }\n        }\n    }\n\n    cout << \"unreachable\" << endl;\n}\n\nint main( void )\n{\n    while ( cin >> n >> m ) {\n        // quit\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        for ( int i = 0; i < size; i++ ) {\n            CN_count[i] = 0;\n            for ( int j = 0; j < size; j++ ) {\n                P[i][j] = false;\n                MC[i][j] = inf;\n                G[i][j] = inf;\n                L[i][j] = 0;\n            }\n        }\n\n        // input\n        int s, g;\n        cin >> s >> g;\n        for ( int i = 0; i < m; i++ ) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n\n            P[x][y] = P[y][x] = true;\n            G[x][y] = G[y][x] = d;\n            L[x][y] = L[y][x] = c;\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( i == j ) continue;\n                if ( P[i][j] ) CN[i][CN_count[i]++] = j;\n            }\n        }\n\n        solve( s-1, g-1 );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst double INF = 1e99;\n\nstruct Edge {\n  int from, to, cost, cap;\n  Edge(int from_, int to_, int cost_, int cap_)\n    : from(from_), to(to_), cost(cost_), cap(cap_) { }\n};\n\nint main() {\n  cout.setf(ios::fixed);\n  cout.precision(4);\n  while(true) {\n    int N, M; cin >> N >> M;\n    if(N == 0) break;\n    int S, G; cin >> S >> G;\n    --S, --G;\n    vector<Edge> g;\n    for(int i = 0; i < M; ++i) {\n      int x,y,d,c; cin >> x >> y >> d >> c;\n      --x, --y;\n      g.emplace_back(x,y,d,c);\n      g.emplace_back(y,x,d,c);\n    }\n    M *= 2;\n    // [from][to][speed]\n    double d[N][N][31];\n    for(int i = 0; i < N; ++i)\n      for(int j = 0; j < N; ++j)\n        for(int c = 0; c < 31; ++c)\n          d[i][j][c] = INF;\n    for(int i = 0; i < M; ++i) {\n      if(g[i].from == S) {\n        d[S][g[i].to][1] = min(d[S][g[i].to][1], 1.0 * g[i].cost);\n      }\n    }\n    while(true) {\n      bool update = false;\n      for(int i = 0; i < M; ++i) {\n        for(int u = 0; u < N; ++u) {\n          if(g[i].to == u) continue;\n          if(g[i].from == u) continue;\n          for(int c = 1; c <= 30; ++c) {\n            for(int dc = -1; dc <= 1; ++dc) {\n              int nc = c + dc;\n              if(nc <= 0 || nc > g[i].cap) continue;\n              if(d[g[i].from][g[i].to][nc] > d[u][g[i].from][c] + 1.0 * g[i].cost / nc) {\n                d[g[i].from][g[i].to][nc] = d[u][g[i].from][c] + 1.0 * g[i].cost / nc;\n                update = true;\n              }\n            }\n          }\n        }\n      }\n      if(!update) break;\n    }\n    double ans = INF;\n    for(int u = 0; u < N; ++u) ans = min(ans, d[u][G][1]);\n    if(ans == INF) {\n      cout << \"unreachable\" << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ndouble ijk[30][31];\nint v[30][31];\nint g[30][30];\nint lim[30][30];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tint S,T;\n\t\tscanf(\"%d%d\",&S,&T);\n\t\tS--;T--;\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tg[i][j]=-1;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tp--;q--;\n\t\t\tg[p][q]=g[q][p]=r;\n\t\t\tlim[p][q]=lim[q][p]=s;\n\t\t}\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<31;j++){ijk[i][j]=99999999;v[i][j]=0;}\n\t\tpriority_queue<pair<double,pair<int,int> > >Q;\n\t\tQ.push(make_pair(0,make_pair(S,1)));\n\t\tijk[S][1]=0;\n\t\twhile(Q.size()){\n\t\t\tdouble cost=-Q.top().first;\n\t\t\tint at=Q.top().second.first;\n\t\t\tint ver=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(v[at][ver])continue;\n\t\t\tv[at][ver]=1;\n\t\t//\tprintf(\"%d %d: %f\\n\",at,ver,ijk[at][ver]);\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tif(ver&&~g[at][i]&&lim[at][i]>=ver){\n\t\t\t\t\tif(ijk[i][ver-1]>cost+(double)g[at][i]/ver){\n\t\t\t\t\t\tijk[i][ver-1]=cost+(double)g[at][i]/ver;\n\t\t\t\t\t\tQ.push(make_pair(-ijk[i][ver-1],make_pair(i,ver-1)));\n\t\t\t\t\t}\n\t\t\t\t\tif(ijk[i][ver]>cost+(double)g[at][i]/ver){\n\t\t\t\t\t\tijk[i][ver]=cost+(double)g[at][i]/ver;\n\t\t\t\t\t\tQ.push(make_pair(-ijk[i][ver],make_pair(i,ver)));\n\t\t\t\t\t}\n\t\t\t\t\tif(ver<30&&ijk[i][ver+1]>cost+(double)g[at][i]/ver){\n\t\t\t\t\t\tijk[i][ver+1]=cost+(double)g[at][i]/ver;\n\t\t\t\t\t\tQ.push(make_pair(-ijk[i][ver+1],make_pair(i,ver+1)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ijk[T][0]>9999999)printf(\"unreachable\\n\");\n\t\telse printf(\"%f\",ijk[T][0]);\n\t\tprintf(\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Node\n{\n\tint pos;\n\tint speed;\n\tdouble cost;\n\tint prev;\n\n\tbool operator<(const Node& r) const{\n\t\treturn cost>r.cost;\n\t}\n};\n\nint main()\n{\n\tint n,m;\n\twhile(cin>>n>>m && n)\n\t{\n\t\tvector<Node> G[n];\n\t\tint s,g;\n\t\tcin>>s>>g;\n\t\t--s;\n\t\t--g;\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint a,b,c;\n\t\t\tdouble d;\n\t\t\tcin>>a>>b>>d>>c;\n\t\t\t--a;\n\t\t\t--b;\n\t\t\tG[a].push_back({b,c,d,a});\n\t\t\tG[b].push_back({a,c,d,b});\n\t\t}\n\n\t\tpriority_queue<Node> q;\n\t\tfor(Node e: G[s])\n\t\t{\n\t\t\tint nv = 1;\n\t\t\tif(nv <= e.speed)\n\t\t\t\tq.push({e.pos,nv,e.cost/nv,s});\n\t\t}\n\n\t\tint d[40][40][40] = {};\n\t\tmemset(d,0,sizeof(d));\n\t\tbool flag = 0;\n\t\twhile(q.size())\n\t\t{\n\t\t\tNode tmp = q.top();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(d[tmp.pos][tmp.speed][tmp.prev]++) continue;\n\t\t\tif(tmp.pos == g && tmp.speed == 1)\n\t\t\t{\n\t\t\t\tprintf(\"%.5lf\\n\",tmp.cost);\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp.speed != 0)\n\t\t\t\tfor(Node e: G[tmp.pos])\n\t\t\t\t\tfor(int nv = tmp.speed-1; nv <= tmp.speed + 1; nv++)\n\t\t\t\t\t\tif(nv > 0 && nv <= e.speed && e.pos != tmp.prev)\n\t\t\t\t\t\t\tq.push({e.pos,nv,tmp.cost+e.cost/nv,tmp.pos});\n\t\t}\n\t\tif(!flag)\n\t\t\tcout<<\"unreachable\"<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst double INF = 1e8;\nint s,t;\n\nclass Edge{\n    public:\n        int to;\n        double cost,limit;\n        Edge(int to, double cost, double limit) : to(to) ,cost(cost) ,limit(limit) {}\n};\n\nclass Node{\n    public:\n        double dis;\n        bool isUsed;\n        double speed;\n        Node(){\n            this->dis = INF;\n            this->speed = 0.0;\n            this->isUsed = 0;\n        }\n};\n\ntypedef vector<vector<Edge>> AdjList;\n\ndouble dijkstra(AdjList g, int n,int start = s){\n\n    vector<vector<Node>> node(n,vector<Node>(35));\n    //??????????????????????????????????????????\n    typedef pair<pair<double,double>,pair<int,int>> p;\n\n    priority_queue<p, vector<p>, greater<p>> q;\n\n    q.push(make_pair(make_pair(0.0, 0.0), make_pair(start,-1)));\n    node[start][0].dis = 0.0;\n\n    p u;\n    while(not q.empty()){\n        u = q.top(); q.pop();\n        int current = u.second.first;\n        int prev = u.second.second;\n        double speed = u.first.second;\n        node[current][speed].isUsed = 1;\n\n        rep(i,g[current].size()){\n            int next = g[current][i].to;\n            if(node[next][speed].isUsed) continue;\n            //if(next == prev) continue;\n\n            for(double j = -1; j <= 1; j++){\n                if(speed + j > 0){\n                    if(speed + j > g[current][i].limit) continue;\n                    if(node[next][speed + j].dis > node[current][speed].dis + g[current][i].cost / (speed + j)){\n                        node[next][speed + j].dis = node[current][speed].dis + g[current][i].cost / (speed + j);\n                        q.push(make_pair(\n                                    make_pair(node[next][speed + j].dis, speed + j),\n                                    make_pair(next,current)\n                                    )\n                              );\n                    }\n                }\n            }\n        }\n    }\n///    cout << endl;\n///    rep(i,n){\n///        rep(j,30){\n///            cout << node[i][j].dis << ' ';\n///        }\n///        cout << endl;\n///    show(\"------------\")\n///    }\n    return node[t][1].dis;\n}\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n||m){\n        cin >> s >> t;\n        s--; t--;\n        AdjList g(n);\n        rep(i,m){\n            int a, b;\n            double c, d;\n            cin >> a >> b >> c >> d;\n            a--; b--;\n            g[a].emplace_back(Edge{b,c,d});\n            g[b].emplace_back(Edge{a,c,d});\n        }\n        double tmp = dijkstra(g,n);\n        if(tmp == INF) cout << \"unreachable\" << endl;\n        else cout <<fixed << setprecision(5) <<  tmp << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 31\n#define INF (1e9)\nusing namespace std;\ntypedef pair<double,int> P;\ntypedef  pair<P,int> PP;\nstruct dat{\n  double cost;\n  int pos,pre,v;\n  bool operator > (dat x)const{return cost>x.cost;}\n};\nint n,m;\nvector<dat> G[N];\n\ndouble dijkstra(int s,int g){\n  double D[N][N][N];\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++)D[i][j][k]=INF;\n  priority_queue<dat,vector<dat>,greater<dat> >Q;\n  Q.push((dat){0,s,-1,0});\n  D[s][s][1]=0;\n  while(!Q.empty()){\n    dat t=Q.top();Q.pop();\n    double cost=t.cost;\n    int pos=t.pos;\n    int pre=t.pre;  \n    int v=t.v;\n    if(D[pos][pre][v]<cost)continue;\n    if(pos==g&&v==1) return cost;\n    \n    for(int i=max(1,v-1);i<=v+1;i++){\n      for(int j=0;j<G[pos].size();j++){\n\tdouble ncost=cost+G[pos][j].cost/i;\n\tint mxv=G[pos][j].v;\n\tint nx=G[pos][j].pos;\n\tif(nx==pre||mxv<i||D[nx][pos][i]<=ncost)continue;\n\tQ.push((dat){ncost,nx,pos,i});\n\tD[nx][pos][i]=ncost;\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    int s,g;\n    cin>>s>>g;s--,g--;\n    for(int i=0;i<n;i++)G[i].clear();\n    for(int i=0,a,b,d,c;i<m;i++){\n      cin>>a>>b>>d>>c;a--,b--;\n      G[a].push_back((dat){d,b,-1,c});\n      G[b].push_back((dat){d,a,-1,c});\n    }\n    double ans=dijkstra(s,g);\n    if(ans==-1) cout<<\"unreachable\"<<endl;\n    else printf(\"%.12f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define EPS 1e-8\n#define INF FLT_MAX\n\n//double cost[30][35]; // place,velocity\nfloat cost[30][35];\n\nstruct P{\n  //  double t;\n  float t;\n  char v,p,pre;\n  //  P(double T=0.0,int V=0,int pp=0,int PRE=0){\n  P(float T=0.0,int V=0,int pp=0,int PRE=0){\n    t=T;v=V;p=pp;pre=PRE;\n  };\n  bool operator<(const P &p)const{\n    return t>p.t;\n  }\n};\nstruct Path{\n  char d,c;\n  Path(int D=0,int C=0){ d=D;c=C;};\n};\n\nint main(){\n  int n,m, s,g, x,y,d,c;\n  Path path[30][30];\n  priority_queue<P> q;\n\n  while( cin>>n>>m && (n|m) ){\n    cin >> s >> g;\n    s--; g--;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tpath[i][j].d=-1.0; path[i][j].c=-1;\n      }\n\n    for( int i=0;i<m;i++ ){\n      cin >> x >> y >> d >> c;\n      x--;y--;\n      path[x][y].d=d; path[x][y].c=c;\n      path[y][x] = path[x][y];\n    }\n\n    int dv[3] = {1,0,-1};\n    for( int i=0;i<n;i++ )\n      for( int j=1;j<31;j++ )\n\tcost[i][j] = INF;\n\n    while( !q.empty() ) q.pop();\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      q.push( P(cost[i][1]=path[s][i].d,1,i,-1) );\n    }\n\n    while( !q.empty() ){\n      P p = q.top(); q.pop();\n      //      double t = p.t;\n      float t = p.t;\n      int v=p.v, np=p.p, pre=p.pre;\n      if( np==g && v==1 ) break;\n\n      for( int i=0;i<n;i++ ){\n\tif( path[np][i].c<0 ) continue;// たどり着けないノード\n\tif( i==pre ) continue; // 前回のノード\n\n\tint j=0;\n\tif( i==g ) j=2;\n\tfor( ;j<3;j++ ){\n\t  int nv = v + dv[j];\n\t  if( nv==0 || nv>path[np][i].c )    continue;\n\t  //\t  double nCost = t + (double)path[np][i].d/nv;\n\t  float nCost = t + (float)path[np][i].d/nv;\n\t  if( nCost>cost[g][1] || fabs(nCost-cost[g][1])<EPS ) continue;\n\t  if( cost[i][nv] < nCost ) continue;\n\t  cost[i][nv]=nCost;\n\n\t  q.push( P(nCost,nv,i,np) );\n\t}\n      }\n\n    }\n    if( fabs(cost[g][1]-INF)<EPS )\n      cout << \"unreachable\" << endl;\n    else\n      printf(\"%.6lf\\n\",cost[g][1]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nstruct Edge {\n  int from;\n  int to;\n  double dist;\n  int speed;\n  Edge() {;}\n  Edge(int f, int t, double d, int s) : from(f), to(t), dist(d), speed(s) {;}\n  bool operator<(const Edge &rhs) const { return dist > rhs.dist; }\n};\n\ndouble visit[40][40][40];\nvector<Edge> edge[40];\n\nint main() {\n  int n, m, s, g;\n  while (scanf(\"%d %d\", &n, &m), n|m) {\n    scanf(\"%d %d\", &s, &g);\n    s--; g--;\n    REP(i, n) { edge[i].clear(); }\n    REP(i, m) {\n      int f, t, c;\n      double d;\n      scanf(\"%d %d %lf %d\", &f, &t, &d, &c);\n      f--; t--;\n      edge[f].push_back(Edge(f, t, d, c));\n    }\n    priority_queue<Edge> que;\n    MEMSET(visit, false);\n    que.push(Edge(32, s, 0, 1));\n    while (!que.empty()) {\n      Edge node = que.top();\n      que.pop();\n      if (visit[node.from][node.to][node.speed]) { continue; }\n      visit[node.from][node.to][node.speed] = true;\n      if (node.to == g && node.speed == 0) {\n        printf(\"%.4lf\\n\", node.dist);\n        goto next;\n      }\n      if (node.speed == 0) { continue; }\n      int from = node.to;\n      REP(i, edge[from].size()) {\n        int to = edge[from][i].to;\n        FOREQ(s, -1, 1) {\n          int ns = node.speed + s;\n          if (to == node.from || visit[from][to][ns] || ns > edge[from][i].speed) { continue; }\n          double ndist = node.dist + edge[from][i].dist / (double)node.speed;\n          que.push(Edge(from, to, ndist, ns));\n        }\n      }\n    }\n    puts(\"unreachable\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m;\nll s, g;\n\nclass DK {\npublic:\n\tstruct edge {\n\t\tint to;\n\t\tdouble cost;\n\t\tll cap;\n\t\tedge(int _to, double _cost, ll _cap) :to(_to), cost(_cost), cap(_cap) {}\n\t};\n\n\tdouble d[110][110];\n\tvector<edge> G[110];//各頂点からの辺\n\n\tvoid dijkstra() {\n\t\trep(i, 110)rep(j, 110)d[i][j] = INF;\n\t\td[s][0] = 0;\n\n\t\ttypedef pair<pair<double, ll>, ll> PP;\n\t\tpriority_queue<PP, vector<PP>, greater<PP>> que;\n\t\tque.push({ {0, 0},s });\n\n\t\twhile (!que.empty()) {\n\t\t\tPP p = que.top();\n\t\t\tque.pop();\n\t\t\tll nn = p.second;\n\t\t\tll v = p.first.second;\n\t\t\t//if (v == g)continue;\n\t\t\t//if (d[nn][v] < p.first.first)continue;\n\t\t\tfor (int i = 0; i < G[nn].size(); i++) {\n\t\t\t\tedge e = G[nn][i];\n\t\t\t\tFOR(j, -1, 2) {\n\t\t\t\t\tdouble nv = v + j;\n\t\t\t\t\tif (nv <= 0)continue;\n\t\t\t\t\tif (nv > e.cap)continue;\n\t\t\t\t\tif (d[e.to][(ll)nv] > d[nn][v] + e.cost / nv) {\n\t\t\t\t\t\td[e.to][(ll)nv] = d[nn][v] + e.cost / nv;\n\t\t\t\t\t\tque.push({ {d[e.to][(ll)nv], (ll)nv},e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n};\n\nDK dk;\n\nint main() {\n\twhile (cin >> n >> m&&n + m) {\n\t\trep(i, 110)dk.G[i].clear();\n\t\tcin >> s >> g;\n\t\trep(i, m) {\n\t\t\tint x, y;\n\t\t\tll c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tdk.G[x].push_back(DK::edge(y, d, c));\n\t\t\tdk.G[y].push_back(DK::edge(x, d, c));\n\t\t}\n\t\tdk.dijkstra();\n\t\t//rep(i, n) {\n\t\t//\trep(j, 30) {\n\t\t//\t\tcout << dk.d[i + 1][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tdouble ans = dk.d[g][1];\n\t\tif ((ll)ans == INF)cout << \"unreachable\" << endl;\n\t\telse printf(\"%.10lf\\n\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct edge {\n\tint to, cost, lim;\n};\nstruct state {\n\tint pos; double cost; int prev, speed;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.cost < s2.cost;\n}\nint n, m, s, g, a, b, c, l;\nint main() {\n\twhile (cin >> n >> m, n | m) {\n\t\tcin >> s >> g; s--, g--;\n\t\tvector<vector<edge> > G(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c >> l; a--, b--;\n\t\t\tG[a].push_back(edge{ b, c, l });\n\t\t\tG[b].push_back(edge{ a, c, l });\n\t\t}\n\t\tvector<vector<vector<double> > > dist(n, vector<vector<double> >(n, vector<double>(31, 1.0e+10))); dist[s][s][0] = 0;\n\t\tpriority_queue<state> que; que.push(state{ s, 0, s, 0 });\n\t\twhile (!que.empty()) {\n\t\t\tstate u = que.top(); que.pop();\n\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\tint sp = u.speed + i;\n\t\t\t\tif (1 <= sp && sp <= 30) {\n\t\t\t\t\tfor (edge e : G[u.pos]) {\n\t\t\t\t\t\tif (sp > e.lim || u.prev == e.to) continue;\n\t\t\t\t\t\tdouble cost = dist[u.pos][u.prev][u.speed] + 1.0 * e.cost / sp;\n\t\t\t\t\t\tif (dist[e.to][u.pos][sp] > cost) {\n\t\t\t\t\t\t\tdist[e.to][u.pos][sp] = cost;\n\t\t\t\t\t\t\tque.push(state{ e.to, -cost, u.pos, sp });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ret = 1.0e+10;\n\t\tfor (int i = 0; i < n; i++) ret = min(ret, dist[g][i][1]);\n\t\tif(ret < 1.0e+9) cout << fixed << setprecision(15) << ret << endl;\n\t\telse cout << \"unreachable\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string.h>\n#define EPS (1.0e-9)\n#define LT(x, y) ((x) - (y) <= -EPS) // x < y\n#define INF (1<<19)\nusing namespace std;\ntypedef struct DisLim {\n int d, c; // dist, limit v\n DisLim() {}\n DisLim(int d, int c) : d(d),c(c) {}\n} DisLim;\nint N,M;\nint S,G; // start, goal\nDisLim F[31][31];\n\ndouble dist[31][31][31];\nbool visited[31][31][31];\nclass State {\npublic:\n int bpos, cpos; // before,current\n double d; // ツ仰猟猟」\n int v; // ツ堕ャツ度\n State (int bpos, int cpos, double d, int v) :\n   bpos(bpos),cpos(cpos),d(d),v(v) {}\n bool operator < (const State &s) const {\n   //return d > s.d;\n   return LT(s.d,d);\n }\n};\n\npriority_queue<State> PQ;\ndouble solve() {\n  while(!PQ.empty()) {\n    State u = PQ.top(); PQ.pop();\n    int bpos=u.bpos, cpos=u.cpos, v=u.v;\n    double d = u.d;\n    \n    visited[bpos][cpos][v] = true;\n    if(cpos == G && v == 1) {\n      return dist[bpos][G][1];\n    }\n\n    for(int i=1;i<=N;i++) { // ツ篠淞づ個都ツ市\n      if(i==bpos || i==cpos) continue; // ツ古」ツ姪淞づィツ凝鳴止\n      for(int j=-1;j<=1;j++) { // ツ嘉個クツ堕ャツ堕閉置\n\tif(v+j <= 0) continue;\n\tif(v+j > F[cpos][i].c) continue;\n\tif(visited[cpos][i][v+j]) continue;\n\tif(F[cpos][i].d >= INF) continue;\n\tdouble cost = dist[bpos][cpos][v] + (double)F[cpos][i].d / (v+j);\n\tif(LT(cost,dist[cpos][i][v+j])) {\n\t  dist[cpos][i][v+j] = cost;\n\t  PQ.push(State(cpos,i,cost,v+j));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nmain() {\n while(cin>>N>>M,N) {\n   PQ = priority_queue<State>();\n   memset(visited,0,sizeof(visited));\n   for(int i=1;i<=N;i++) {\n     for(int j=1;j<=N;j++) {\n       F[i][j].d=INF;\n     }\n   }\n   cin>>S>>G;\n   for(int i=1;i<=N;i++) {\n     for(int j=1;j<=N;j++) {\n       for(int k=0;k<31;k++) {\n         dist[i][j][k] = INF;\n       }\n     }\n   }\n   for(int i=0;i<31;i++) {\n     dist[S][S][i] = 0;\n   }\n   PQ.push(State(S,S,0,1));\n   for(int i=0;i<M;i++) {\n     int x,y,d,c; cin>>x>>y>>d>>c;\n     F[x][y]=F[y][x]=DisLim(d,c);\n   }\n   double ans = solve();\n   if(ans==-1) puts(\"unreachable\");\n   else printf(\"%.5lf\\n\",ans);\n }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e10\nusing namespace std;\nstruct edge{\n  int to,limit;\n  double dist;\n};\nvector<edge> G[100];\ndouble d[40][40][40];//speed,pos,prev\nbool used[40][40][40];\ntypedef pair<int,int> pii; //speed,prev\ntypedef pair<int,pii> PII;//to,speed,prev\ntypedef pair<double,PII> P;//cost,to,speed\n\ndouble dikstra(int s,int g){\n  int ds[3]={-1,0,1};\n  priority_queue<P,vector<P>,greater<P> > que;\n  for(int i=0;i<40;i++)\n    for(int j=0;j<40;j++)\n      for(int k=0;k<40;k++)\n\td[i][j][k]=INF;\n  memset(used,0,sizeof(used));\n  d[0][s][0]=0;\n  que.push(P(0,PII(s,pii(0,0))));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int speed=p.second.second.first;\n    int prev=p.second.second.second;\n    int v=p.second.first;\n    double cost=p.first;\n    //cout << v << \":\" << speed <<\":\" << cost << endl;\n    if(d[speed][v][prev]<cost)continue;\n    if(speed==1 && v==g)return cost;\n    for(int i=0;i<G[v].size();i++){\n      for(int j=0;j<3;j++){\n\tedge e=G[v][i];\n\tint ns=speed+ds[j];\n\tif(1<=ns && ns<= e.limit &&\n\t   used[ns][e.to][v]==false &&\n\t   e.to!=prev && d[ns][e.to][v]>cost+e.dist/ns){\n\t  used[ns][e.to][v]=true;\n\t  que.push(P(cost+e.dist/ns,PII(e.to,pii(ns,v))));\n\t  d[ns][e.to][v]=cost+e.dist/ns;\n\t  //cout << \"d[\" << ns << \"][\" << e.to << \"]:\" << d[ns][e.to] << endl;\n\t  //cout << \"d[\" << v << \"]:\" << d[speed][v] << \" speed:\" << speed<< endl;\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n){\n    for(int i=0;i<100;i++)G[i].clear();\n    cin>>s>>g;\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      G[x].push_back((edge){y,c,d});\n      G[y].push_back((edge){x,c,d});\n    }\n    double ans=dikstra(s,g);\n    if(ans==-1)cout << \"unreachable\" << endl;\n    else printf(\"%.5lf\\n\",ans);\n    // for(int i=0;i<=n;i++)\n    // \tcout << i << \" \" << d[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\nstruct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n \n// (time,speed,node,pre_node)\nusing P = pair<pair<double,int>,pair<int,int>>;\n \n \nP makeP(double t,int s,int n,int np){\n    return make_pair(make_pair(t,s),make_pair(n,np));\n}\n \nvoid solve(int n,int m){\n    int start,goal; cin>>start>>goal;\n    start--;\n    goal--;\n    vector<vector<int>> g(n,vector<int>(n,INF));\n    vector<vector<int>> lim(n,vector<int>(n,0));\n    rep(i,m){\n        int x,y,d,c;\n        cin>>x>>y>>d>>c;\n        x--;\n        y--;\n        g[x][y] = d;\n        g[y][x] = d;\n        lim[x][y] = c;\n        lim[y][x] = c;\n    }\n \n    double visited[32][32][32];\n    rep(i,32) rep(j,32) rep(k,32) visited[i][j][k]=DBL_MAX/10;\n    visited[start][0][start] = 0;\n \n    priority_queue<P,vector<P>,greater<P>> que;\n    que.push(makeP(0,0,start,start));\n    while(!que.empty()){\n        auto p = que.top();\n        que.pop();\n        double ti = p.first.first;\n        int speed = p.first.second;\n        int node = p.second.first;\n        int pre = p.second.second;\n \n#ifdef DEBUG\n        cerr << \"time : \" << ti << \" \"  << \"node : \" << node+1 << \" \" << \"speed \" << speed << endl;\n#endif\n        if(node==goal and speed==1){\n            cout << Double(ti) << endl;\n            return;\n        }\n \n        if(ti > visited[node][speed][pre]) continue;\n \n        for(int next_node=0;next_node<n;next_node++){\n            if(next_node==node or next_node==pre or g[node][next_node]==INF) continue;\n            int d=g[node][next_node];\n            int c=lim[node][next_node];\n            for(int nspeed=speed-1;nspeed<=speed+1;nspeed++){\n                if(nspeed<=0 or nspeed>c) continue;\n                double nt = ti + (double)d/(double)nspeed;\n                if(nt < visited[next_node][nspeed][node]){\n#ifdef DEBUG\n                    cerr << \"\\ttime \" << nt << \" \" << \"node \" << next_node+1 << \" speed \" << nspeed << endl;\n#endif\n                    visited[next_node][nspeed][node] = nt;\n                    que.push(makeP(nt,nspeed,next_node,node));\n                }\n            }\n        }\n    }\n    cout << \"unreachable\" << endl;\n}\n \nint main(){\n    int n,m;\n    while(cin>>n>>m){\n        if(n==0 && m==0) break;\n        solve(n,m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst double eps = 1e-8, inf = 1e+8;\n\nstruct Edge {\n    int to; double wt; int cap;\n    Edge(int to, double wt, int cap):to(to), wt(wt), cap(cap){}\n};\n\nint n, m, s, g;\n\ndouble solve(vector<vector<Edge> >& G){\n    vector<vector<double> > mem(n, vector<double>(35, inf)); mem[s][0] = 0.;\n    typedef tuple<double, int, int, int> State;\n    priority_queue<State> q;\n    for(q.emplace(0., 0, s, -1); !q.empty();){\n        double t; int v, u, p;\n        tie(t, v, u, p) = q.top(); q.pop();\n        if(mem[u][v] + t < -eps)continue;\n        if(u == g && v == 1)return -t;\n        for(auto e: G[u])if(e.to != p){\n            for(int dv=-1; dv<=1; ++dv){\n                int nv = v + dv <= 0? 1: v + dv;\n                double nt = e.wt / nv - t;\n                if(30 < nv || e.cap < nv || mem[e.to][nv] <= nt + eps)continue;\n                mem[e.to][nv] = nt;\n                q.emplace(-mem[e.to][nv], nv, e.to, u);\n            }\n        }\n    }\n    throw \"unreachable\";\n}\n\nint main(){\n    while(cin >> n >> m, n|m){\n        cin >> s >> g;\n        s--; g--;\n        vector<vector<Edge> > G(n);\n        rep(i, m){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            G[x].emplace_back(y, d, c);\n            G[y].emplace_back(x, d, c);\n        }\n        try{\n            cout << fixed << setprecision(5) << solve(G) << '\\n';\n        }\n        catch(const char* mes){\n            cout << mes << '\\n';\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 91 // いつもは1<<29だが小さくすれば時間はやくなる？\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n#define rep(i, a, b) for (int i = (a); i < ((int)b); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= ((int)a); --i)\n#define sz(c) ((int)c.size())\n\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\n\nvoid dump_impl(string s) {}\ntemplate <class H, class... T>\nvoid dump_impl(string s, H head, T... tail) {\n    int p = 0;\n    rep(i, 0, s.size()) {\n        char x = s[i];\n        if (p == 0 && x == ',') {\n            cerr << \" = \" << head << \", \";\n            dump_impl(s.substr(i + 1), tail...);\n            return;\n        } else {\n            cerr << x;\n            if (x == '(') p++;\n            if (x == ')') p--;\n        }\n    }\n}\n#ifdef LOCAL\n#define dump(...) do { cerr << \"\\x1b[33;1m\"; dump_impl(#__VA_ARGS__ \",\", __VA_ARGS__); cerr << \"\\x1b[0m\" << endl; } while (0)\n#else\n#define dump(...)\n#endif\n\nconst int INF = 1e9;\n\nstruct Edge {\n    int to;\n    int lim;\n    int len;\n};\n\ntemplate <class T>\nbool chmin(T &a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvoid solve(int N, int M) {\n    int S, T;\n    cin >> S >> T;\n    S--, T--;\n    vector<vector<Edge>> G(N);\n    rep(i, 0, M) {\n        int a, b, d, c;\n        cin >> a >> b >> d >> c;\n        a--, b--;\n        G[a].push_back(Edge {b, c, d});\n        G[b].push_back(Edge {a, c, d});\n    }\n\n    vector<vector<vector<double>>> dist(N, vector<vector<double>>(N, vector<double>(35, INF)));\n    dist[S][S][1] = 0;\n    priority_queue<tuple<double, int, int, int>, vector<tuple<double, int, int, int>>, greater<>> pq;\n    for (auto e : G[S]) {\n        double cost = e.len / (double)1;\n        if (chmin(dist[e.to][S][1], cost)) {\n            pq.push(make_tuple(dist[e.to][S][1], e.to, S, 1));\n        }\n    }\n    while (sz(pq)) {\n        double dist_cur;\n        int v, from, sp;\n        tie(dist_cur, v, from, sp) = pq.top(); pq.pop();\n        if (dist_cur > dist[v][from][sp]) continue;\n\n        rep(dsp, -1, 2) {\n            int nsp = sp + dsp;\n            if (nsp > 0) {\n                for (auto e : G[v]) {\n                    if (e.to == from) continue;\n                    if (e.lim < nsp) continue;\n                    double cost = e.len / (double)nsp;\n                    if (chmin(dist[e.to][v][nsp], dist_cur + cost)) {\n                        pq.push(make_tuple(dist[e.to][v][nsp], e.to, v, nsp));\n                    }\n                }\n            }\n        }\n    }\n\n    double ans = INF;\n    rep(i, 0, N) {\n        chmin(ans, dist[T][i][1]);\n    }\n    if (ans >= INF) {\n        cout << \"unreachable\" << endl;\n    } else {\n        cout << ans << endl;\n    }\n}\n\nsigned main() {\n    cout << setprecision(20);\n    while (1) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 && M ==0) break;\n        solve(N, M);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong double memo[10000][32];\nstruct edge {\n\tint id;\n\tint from;\n\tint to;\n\tint lim;\n\tlong double dis;\n};\nstruct aa {\n\tint id;\n\tint speed;\n\tlong double  time;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nint main() {\n\tcout << fixed << setprecision(22);\n\twhile (1) {\n\t\tmemset(memo, 9999999, sizeof(memo));\n\t\tint n, m; cin >> n >> m;\n\t\tif (!n)break;\n\t\tint s, g; cin >> s >> g; s--; g--;\n\t\tvector<edge>edges;\n\t\tvector<vector<int>>edgeids(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tlong double d;\n\t\t\tint x, y, c; cin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tedges.push_back(edge{ 2*i,x,y,c,d });\n\t\t\tedges.push_back(edge{ 2*i+1,y,x,c,d });\n\t\t\tedgeids[x].push_back(2 * i);\n\t\t\tedgeids[y].push_back(2 * i + 1);\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tfor (auto i : edgeids[s]) {\n\n\t\t\tque.push(aa{ i,1,edges[i].dis });\n\t\t\tmemo[i][1] = edges[i].dis;\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst edge oldedge(edges[atop.id]);\n\t\t\tconst int oldsp(atop.speed);\n\t\t\tconst long double oldtime(atop.time);\n\t\t\tfor (auto i : edgeids[oldedge.to]) {\n\t\t\t\tconst edge nextedge(edges[i]);\n\t\t\t\tif (nextedge.to == oldedge.from)continue;\n\t\t\t\telse {\n\t\t\t\t\tfor (int change = -1; change <= 1; ++change) {\n\t\t\t\t\t\tconst int nextsp = oldsp + change;\n\t\t\t\t\t\tif (nextsp == 0)continue;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (nextsp <= nextedge.lim) {\n\t\t\t\t\t\t\t\tconst long double nexttime= nextedge.dis / nextsp + oldtime;\n\t\t\t\t\t\t\t\tif (memo[i][nextsp] > nexttime) {\n\t\t\t\t\t\t\t\t\tmemo[i][nextsp] = nexttime;\n\t\t\t\t\t\t\t\t\tque.push(aa{ i,nextsp,nexttime });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong double amin = 999999999;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tif (edges[i].to == g) {\n\t\t\t\tamin = min(amin, memo[i][1]);\n\t\t\t}\n\t\t}\n\t\tif (amin > 99999999) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << amin << endl;\n\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\n//d, node, velocity, parent\ntypedef tuple<double, int, int, int> State;\n\nclass Edge{\npublic:\n    int to, cost, limit;\n    Edge(int to, int cost, int limit): to(to), cost(cost), limit(limit){};\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int N, M;\n    while (cin>>N>>M, N|M) {\n        int S, G; cin >> S >> G; S--; G--;\n       \n        vector<vector<Edge>> Glaph(N);\n        for(int i=0; i<M; i++){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c; x--; y--;\n            Glaph[x].push_back(Edge(y, d, c));\n            Glaph[y].push_back(Edge(x, d, c));\n        }\n        \n        vector<vector<vector<double>>> dp(N, vector<vector<double>>(30, vector<double>(N, INF)));\n        priority_queue<State, vector<State>, greater<State>> que;\n        \n        for(Edge &e: Glaph[S]){\n            dp[e.to][0][S] = e.cost;\n            que.push(State(e.cost, e.to, 0, S));\n        }\n        while (!que.empty()) {\n            double d; int node, velocity, parent;\n            tie(d, node, velocity, parent) = que.top(); que.pop();\n            if(dp[node][velocity][parent] < d)\n                continue;\n            \n            for(Edge &e: Glaph[node]) if(e.to != parent){\n                for(int i=-1; i<=1; i++){\n                    int nv = velocity + i;\n                    if(nv < 0 || 30 <= nv || e.limit <= nv)\n                        continue;\n                    if(dp[e.to][nv][node] > d + e.cost / double(nv+1)){\n                        dp[e.to][nv][node] = d + e.cost / double(nv+1);\n                        que.push(State(dp[e.to][nv][node], e.to, nv, node));\n                    }\n                }\n            }\n        }\n        double ans = INF;\n        int p = -1;\n        for(int i=0; i<N; i++){\n            if(dp[G][0][i] < ans){\n                ans = dp[G][0][i];\n                p = i;\n            }\n        }\n        if(ans == INF)\n            cout << \"unreachable\" << endl;\n        else\n            cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\nusing namespace std;\n#define INF 1000000000\nint n,m;\nint G[50][50];\nint res[50][50];\ndouble memo[50][50][50]; //????????????????????????????????????\n \nstruct node{\n  int s,g,v;\n  node(int s=0,int g=0,int v=0):s(s),g(g),v(v){}\n};\n \nbool operator < (node a,node b){\n  return memo[a.s][a.g][a.v] > memo[b.s][b.g][b.v];\n}\n \ndouble solve(int s,int g){\n  for(int i=0;i<50;++i) for(int j=0;j<50;++j) for(int k=0;k<50;++k) memo[i][j][k] = INF;\n  memo[s][s][0] = 0;\n  bool used[50][50][50];\n  memset(used,0,sizeof(used));\n \n  priority_queue<node> St;\n  St.push(node(s,s,0));\n \n  while(!St.empty()){\n    node now = St.top();\n    St.pop();\n    double mincost = memo[now.s][now.g][now.v];\n    int id1 = now.s;\n    int id2 = now.g;\n    int id3 = now.v;\n    for(int i=0;i<n;++i){\n      if(!G[id2][i] || i==id1) continue;\n      for(int j=-1;j<=1;++j){\n\tint nxtv = id3+j;\n\tif(nxtv<=0 || nxtv > res[id2][i]) continue;\n\tif(memo[id2][i][nxtv] > mincost + (double)G[id2][i]/nxtv){\n\t  memo[id2][i][nxtv] = mincost + (double)G[id2][i]/nxtv;\n\t  St.push(node(id2,i,nxtv));\n\t}\n      }\n    }\n  }\n  double ret = INF;\n  for(int i=0;i<n;++i){\n    ret = min(ret,memo[i][g][1]);\n  }\n  return ret;\n}\n \n \nint main(){\n  while(scanf(\"%d%d\",&n,&m),n||m){\n    memset(G,0,sizeof(G));\n    memset(res,0,sizeof(res));\n    int s,g;\n    scanf(\"%d%d\",&s,&g);\n    s--;\n    g--;\n    while(m--){\n      int x,y,d,c;\n      scanf(\"%d%d%d%d\",&x,&y,&d,&c);\n      x--;\n      y--;\n      G[x][y] = G[y][x] = d;\n      res[x][y] = res[y][x] = c;\n    }\n \n    double ans = solve(s,g);\n    if(ans==INF) printf(\"unreachable\\n\");\n    else printf(\"%lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stdlib.h>\n#define EPS (1.0e-9)\n#define LT(x, y) ((x) - (y) <= -EPS) // x < y\n#define INF (1<<19)\nusing namespace std;\ntypedef struct DisLim {\n int d, c; // dist, limit v\n DisLim() {}\n DisLim(int d, int c) : d(d),c(c) {}\n} DisLim;\nint N,M;\nint S,G; // start, goal\nDisLim F[31][31];\n\ndouble dist[31][31][31];\nbool visited[31][31][31];\nclass State {\npublic:\n int bpos, cpos; // before,current\n double d; // ツ仰猟猟」\n int v; // ツ堕ャツ度\n State (int bpos, int cpos, double d, int v) :\n   bpos(bpos),cpos(cpos),d(d),v(v) {}\n bool operator < (const State &s) const {\n   //return d > s.d;\n   return LT(s.d,d);\n }\n};\n\npriority_queue<State> PQ;\ndouble solve() {\n  while(!PQ.empty()) {\n    State u = PQ.top(); PQ.pop();\n    int bpos=u.bpos, cpos=u.cpos, v=u.v;\n    double d = u.d;\n    \n    visited[bpos][cpos][v] = true;\n    if(cpos == G && v == 1) {\n      return dist[bpos][G][1];\n    }\n\n    for(int i=1;i<=N;i++) { // ツ篠淞づ個都ツ市\n      if(i==bpos || i==cpos) continue; // ツ古」ツ姪淞づィツ凝鳴止\n      for(int j=-1;j<=1;j++) { // ツ嘉個クツ堕ャツ堕閉置\n\tif(v+j <= 0) continue;\n\tif(v+j > F[cpos][i].c) continue;\n\tif(visited[cpos][i][v+j]) continue;\n\tif(F[cpos][i].d >= INF) continue;\n\tdouble cost = dist[bpos][cpos][v] + (double)F[cpos][i].d / (v+j);\n\tif(LT(cost,dist[cpos][i][v+j])) {\n\t  dist[cpos][i][v+j] = cost;\n\t  PQ.push(State(cpos,i,cost,v+j));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nmain() {\n while(cin>>N>>M,N) {\n   PQ = priority_queue<State>();\n   memset(visited,0,sizeof(visited));\n   for(int i=1;i<=N;i++) {\n     for(int j=1;j<=N;j++) {\n       F[i][j].d=INF;\n     }\n   }\n   cin>>S>>G;\n   for(int i=1;i<=N;i++) {\n     for(int j=1;j<=N;j++) {\n       for(int k=0;k<31;k++) {\n         dist[i][j][k] = INF;\n       }\n     }\n   }\n   for(int i=0;i<31;i++) {\n     dist[S][S][i] = 0;\n   }\n   PQ.push(State(S,S,0,1));\n   for(int i=0;i<M;i++) {\n     int x,y,d,c; cin>>x>>y>>d>>c;\n     F[x][y]=F[y][x]=DisLim(d,c);\n   }\n   double ans = solve();\n   if(ans==-1) puts(\"unreachable\");\n   else printf(\"%.5lf\\n\",ans);\n }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e10\nusing namespace std;\nstruct edge{\n  int to,limit;\n  double dist;\n};\nvector<edge> G[100];\ndouble d[40][100];\nbool used[40][100][40];\ntypedef pair<int,int> pii; //speed,prev\ntypedef pair<int,pii> PII;//to,speed,prev\ntypedef pair<double,PII> P;//cost,to,speed\n\ndouble dikstra(int s,int g){\n  int ds[3]={-1,0,1};\n  priority_queue<P,vector<P>,greater<P> > que;\n  for(int i=0;i<40;i++)\n    for(int j=0;j<100;j++)\n      d[i][j]=INF;\n  memset(used,0,sizeof(used));\n  d[0][s]=0;\n  que.push(P(0,PII(s,pii(0,0))));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int speed=p.second.second.first;\n    int v=p.second.first;\n    int prev=p.second.second.second;\n    double cost=p.first;\n    //cout << v << \":\" << speed <<\":\" << cost << endl;\n    if(d[speed][v]<cost)continue;\n    for(int i=0;i<G[v].size();i++){\n      for(int j=0;j<3;j++){\n\tedge e=G[v][i];\n\tint ns=speed+ds[j];\n\tif(1<=ns && ns<= e.limit &&\n\t   used[ns][e.to][prev]==false){\n\t  used[ns][e.to][prev]=true;\n\t  que.push(P(cost+e.dist/ns,PII(e.to,pii(ns,v))));\n\t  if(d[ns][e.to]>cost+e.dist/ns){\n\t    d[ns][e.to]=cost+e.dist/ns;\n\t    //cout << \"d[\" << ns << \"][\" << e.to << \"]:\" << d[ns][e.to] << endl;\n\t    //cout << \"d[\" << v << \"]:\" << d[speed][v] << \" speed:\" << speed<< endl;\n\t  }\n\t}\n      }\n    }\n  }\n  if(d[1][g]==INF)return -1;\n  return d[1][g];\n}\n\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n){\n    for(int i=0;i<100;i++)G[i].clear();\n    cin>>s>>g;\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      G[x].push_back((edge){y,c,d});\n      G[y].push_back((edge){x,c,d});\n    }\n    double ans=dikstra(s,g);\n    if(ans==-1)cout << \"unreachable\" << endl;\n    else printf(\"%.5lf\\n\",ans);\n    // for(int i=0;i<=n;i++)\n    // \tcout << i << \" \" << d[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<double,int> PDI;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst double INF = 1e9;\n\nstruct Edge{\n  int to;\n  double cost;\n\n  Edge(int t, double c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\nvoid add_edge(Graph& G, int x, int y, double c){\n  G[x].PB(Edge(y,c));\n  G[y].PB(Edge(x,c));\n}\n\nvoid Dijkstra(const Graph& edges, vector<double>& d, int s){\n  const int V = edges.size();\n  priority_queue<PDI, vector<PDI>, greater<PDI> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0.;\n  pq.push(MP(0.,s));\n\n  while(!pq.empty()){\n\tPDI pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\n\nint N, M;\nint idx(int node, int sp, int prv){\n  return (node * 50 + prv) * 50 + sp;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  while(cin>>N>>M,N){\n\tint S, Gl; cin >> S >> Gl;\n\t--S, --Gl;\n\n\tGraph G(50*50*50);\n\tREP(i,M){\n\t  int x, y, d, c; cin >> x >> y >> d >> c;\n\t  --x, --y;\n\t  for(int j=1;j<=c;++j){\n\t\tdouble cost = d * 1. / j;\n\t\tREP(prv,N){\n\t\t  if(prv != y)\n\t\t\tG[idx(x,j,prv)].PB(Edge(idx(y,j,x), cost));\n\t\t  if(prv != x)\n\t\t\tG[idx(y,j,prv)].PB(Edge(idx(x,j,y), cost));\n\t\t}\n\t  }\n\t  for(int j=c+1;j>1;--j){\n\t\tdouble cost = d*1./(j-1);\n\t\tREP(prv,N){\n\t\t  if(prv != y)\n\t\t\tG[idx(x,j,prv)].PB(Edge(idx(y,j-1,x), cost));\n\t\t  if(prv != x)\n\t\t\tG[idx(y,j,prv)].PB(Edge(idx(x,j-1,y), cost));\n\t\t  }\n\t  }\n\t  for(int j=1;j<c;++j){\n\t\tdouble cost = d*1./(j+1);\n\t\tREP(prv,N){\n\t\t  if((x == S || y == S) && prv == S) continue;\n\t\t  if(prv != y){\n\t\t\tG[idx(x,j,prv)].PB(Edge(idx(y,j+1,x), cost));\n\t\t  }\n\t\t  if(prv != x)\n\t\t\tG[idx(y,j,prv)].PB(Edge(idx(x,j+1,y), cost));\n\t\t}\n\t  }\n\t}\n\n\tvector<double> dist(50*50*50, INF);\n\tDijkstra(G, dist, idx(S,1,S));\n\tdouble ans = INF;\n\tREP(prv,N) ans = min(ans, dist[idx(Gl,1,prv)]);\n\t\n\tif(ans >= INF) cout << \"unreachable\" << endl;\n\telse cout << fixed << setprecision(9) << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//ダイクストラを空で書きたいあなたに\n//離散的速度を例にとって...\nconst int MAX_C = 32;\nconst double INF = 1e9;\n\n//頂点\nstruct node{\n\n    int cur;\n    int pre;\n    int v;\n    double t;\n\n    node(int c, int p, int v, double t) : cur(c), pre(p), v(v), t(t){}\n};\n\n//比較演算子\nbool operator < (const node &a, const node &b) { return a.t > b.t; }\nbool operator > (const node &a, const node &b) { return a.t < b.t; }\n\nstruct edge{\n    int to;\n    double d;\n    int c;\n    edge(int t, double d, int c) : to(t), d(d), c(c){}\n};\n\nint main(){\n\n    while(true){\n        int n, m; cin >> n >> m;\n        if(!n) break;\n        int s, g; cin >> s >> g;\n        vector<vector<edge> > adj(n + 1);\n        \n        for(int i = 0; i < m; i++){\n            int x, y, c;\n            double d;\n            cin >> x >> y >> d >> c;\n            adj[x].push_back(edge(y, d, c));\n            adj[y].push_back(edge(x, d, c));\n        }\n\n        //cur, pre, v\n        vector<vector<vector<double> > > result(n + 1, vector<vector<double> > (n + 1, vector<double> (MAX_C, INF)));\n        priority_queue<node> pq;\n\n        //スタート地点を追加\n        //架空のスタート地点(s, 0, 0)\n        result[s][0][0] = 0.0;\n        pq.push(node(s, 0, 0, 0.0));\n\n        while(!pq.empty()){\n\n            node now = pq.top();\n            pq.pop();\n            \n            if(result[now.cur][now.pre][now.v] > now.t) continue;\n\n            //今いる頂点と隣接しているすべての頂点をなめる\n            for(auto e : adj[now.cur]){\n                for(int p = -1; p <= 1; p++){\n\n                    if(now.v + p <= 0) continue;\n                    if(e.to == now.pre) continue;\n                    node next(e.to, now.cur, now.v + p, now.t + e.d / (double)(now.v + p));\n                    if(next.v < 1 || e.c < next.v) continue;\n                    \n                    //現時点よりも安く到達できそうなら\n                    if(result[next.cur][next.pre][next.v] > next.t){\n                        result[next.cur][next.pre][next.v] = next.t;\n                        pq.push(next);\n                    }\n                }\n            }\n        }\n\n        double ans = INF;\n        for(int i = 1; i <= n; i++) ans = min(ans, result[g][i][1]);\n        if(abs(ans - INF) < 1e-9) printf(\"unreachable\\n\"); \n        else printf(\"%.10lf\\n\", ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//1162\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nconst int MAX_N=30,MAX_C=30;\nconst double INF=1e8;\nconst double ESP=1e-8;\n\n#define EQ(a,b) fabs(a-b)<ESP\n\nint n,m;\nint s,g;\nstruct edge{\n\tint to,dist,c;\n};\nvector<edge> G[MAX_N];\n\nstruct S{\n\tint town,v,pre;\n\tdouble cost;\n\tbool operator<(const S &a) const{\n\t\treturn cost>a.cost;\n\t}\n};\n\ndouble cost[MAX_N][MAX_C+1][MAX_N];\n\nvoid dijkstra(){\n\tREP(i,n){\n\t\tREP(j,MAX_C+1){\n\t\t\tREP(k,n){\n\t\t\t\tcost[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<S> pq;\n\tpq.push(S{s,0,0,0.0});\n\tcost[s][0][0]=0;\n\twhile (!pq.empty()){\n\t\tS s=pq.top();\n\t\tpq.pop();\n\t\tif (cost[s.town][s.v][s.pre]<s.cost-ESP){\n\t\t\tcontinue;\n\t\t}\n\t\tFOR(acc,-1,1+1){\n\t\t\tif (s.v+acc<=0) continue;\n\t\t\tFOR(i,0,G[s.town].size()){\n\t\t\t\tedge e=G[s.town][i];\n\t\t\t\tif (s.v+acc>e.c){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (e.to==s.pre) continue;\n\t\t\t\tif (s.cost+(double)e.dist/(s.v+acc)<cost[e.to][s.v+acc][s.town]){\n\t\t\t\t\tcost[e.to][s.v+acc][s.town]=s.cost+(double)e.dist/(s.v+acc);\n\t\t\t\t\tpq.push(S{e.to,s.v+acc,s.town,cost[e.to][s.v+acc][s.town]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif (n){\n\t\t\tscanf(\"%d %d\",&s,&g);\n\t\t\ts--;\n\t\t\tg--;\n\t\t\tREP(i,n){\n\t\t\t\tG[i].clear();\n\t\t\t}\n\t\t\tREP(i,m){\n\t\t\t\tint x,y,d,c;\n\t\t\t\tscanf(\"%d %d %d %d\",&x,&y,&d,&c);\n\t\t\t\tx--;\n\t\t\t\ty--;\n\t\t\t\tG[x].push_back(edge{y,d,c});\n\t\t\t\tG[y].push_back(edge{x,d,c});\n\t\t\t}\n\t\t\tdijkstra();\n\t\t\tdouble ans=INF;\n\t\t\tREP(i,n){\n\t\t\t\tans=min(ans,cost[g][1][i]);\n\t\t\t}\n\t\t\tif (EQ(ans,INF)){\n\t\t\t\tprintf(\"unreachable\\n\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"%.6f\\n\",ans);\n\t\t\t}\n\t\t}\n\t}while (n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nconst int MAX = 35;\nconst int INF = (1<<25);\nint n,m;\n\nstruct Edge{\n  int to;\n  double dis,lim;\n  Edge(int a, double b, double c):to(a),dis(b),lim(c){}\n};\n\nstruct State{\n  int pos,from;\n  double speed,t;\n  State(int a, double b, double c, int f){\n    pos = a;\n    speed = b;\n    t = c;\n    from = f;\n  }\n  bool operator < (const State& s) const{ return t > s.t;}\n};\n\nvector<Edge> E[MAX];\ndouble T[MAX][MAX][MAX];\n//T[i][j][k] := shortest time from i to j with speed k.\n\n\nvoid init(){\n  for(int i = 0; i < MAX; i++){\n    for(int j = 0; j < MAX; j++) for(int k = 0; k < MAX; k++) T[i][j][k] = INF;\n    E[i].clear();\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++){\n    int x,y;\n    double d,c;\n    cin >> x >> y >> d >> c;\n    //   cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    E[x].push_back(Edge(y,d,c));\n    E[y].push_back(Edge(x,d,c));\n  }\n}\n\nvoid solve(int s, int g){\n\n  priority_queue<State> Q;\n  T[0][s][0] = 0;\n  Q.push(State(s,0,0,-1));\n\n  while(!Q.empty()){\n    State sta = Q.top();\n    Q.pop();\n\n    if(sta.t > T[sta.from][sta.pos][(int)sta.speed]) continue;\n\n    for(int i = 0; i < E[sta.pos].size(); i++){\n      int np = E[sta.pos][i].to;\n\n      if(np == sta.from) continue;\n\n      double sp[] = {-1,0,1};\n      \n      for(int j = 0; j < 3; j++){\n\tint ns = sta.speed+sp[j];\n\tif(ns <= 0 || ns > E[sta.pos][i].lim) continue;\n\tdouble nt = sta.t+E[sta.pos][i].dis/(double)ns;\n\tif(T[sta.pos][np][ns] > nt){\n\t  T[sta.pos][np][ns] = nt;\n\t  Q.push(State(np,ns,nt,sta.pos));\n\t}\n      }\n    }\n  }\n  \n\n  double ans = INF;\n\n  for(int i = 0; i < MAX; i++)\n    ans = min(ans,T[i][g][1]);\n\n  if((int)ans == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.5f\\n\",ans);\n}\n\nint main(){\n\n  while(cin >> n >> m && n+m){\n    init();\n    int s,g;\n    cin >> s >> g;\n    input();\n    solve(s,g);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cassert>\nnamespace boost {template <class T>struct integer_iterator {T a;bool operator != (integer_iterator const & it) const { return a != it.a; }T operator * () const { return a; }integer_iterator & operator ++ () { ++ a; return *this; }integer_iterator operator ++ (int) { return { a ++ }; }};template <class T>struct integer_range {T l, r;typedef integer_iterator<T> iterator;iterator begin() const { return { l }; }iterator end  () const { return { r }; }};template <class T>integer_range<T> irange(T l, T r) { return { l, r }; }template <class T>struct integer_iterator_with_step {T a, d, i;bool operator != (integer_iterator_with_step const & it) const { return a != it.a or d != it.d or i != it.i; }T operator * () const { return a+d*i; }integer_iterator_with_step & operator ++ () { ++ i; return *this; }integer_iterator_with_step operator ++ (int) { return { a, d, i ++ }; }};template <class T>struct strided_integer_range {T l, r, s;typedef integer_iterator_with_step<T> iterator;iterator begin() const { return { l, s, 0 }; }iterator end  () const { return { l, s, (r - l) / s }; }};template <class T>strided_integer_range<T> irange(T l, T r, T s) { return { l, r, s }; }}\ntypedef long long ll;\nusing namespace std;\nusing namespace boost;\n#define endl \"\\n\"\nstruct edge_t { int from, to; int dist, lim; };\nstruct state_t { int cur, prv, velc; double time; };\nbool operator < (state_t const & a, state_t const & b) {\n    return a.time > b.time;\n}\n#define MAX_VELOCITY 30\n#define V(...) vector<__VA_ARGS__ >\n#define INF 1e20\nint main() {\n    while (true) {\n        int n, m; cin >> n >> m;\n        if (n == 0 and m == 0) break;\n        int start, goal; cin >> start >> goal; -- start; -- goal;\n        V(V(edge_t)) g(n);\n        for (int i : irange(0,m)) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c; -- x; -- y;\n            g[x].push_back({ x, y, d, c });\n            g[y].push_back({ y, x, d, c });\n        }\n        // current-node, prev-node, velocity -> elapsed-time\n        V(V(V(double))) memo(n, V(V(double))(n, V(double)(MAX_VELOCITY+1, INF)));\n        priority_queue<state_t> q;\n        q.push({ start, start, 0, 0.0 });\n        while (not q.empty()) {\n            state_t s = q.top(); q.pop();\n            if (memo[s.cur][s.prv][s.velc] != INF) continue;\n            memo[s.cur][s.prv][s.velc] = s.time;\n            if (s.cur == goal and s.velc == 1) {\n                printf(\"%.5lf\\n\", s.time);\n                goto next;\n            }\n            for (edge_t e : g[s.cur]) {\n                if (e.to == s.prv) continue;\n                for (int dv : { -1, 0, 1 }) {\n                    int nv = s.velc + dv;\n                    if (nv <= 0 or e.lim < nv) continue;\n                    if (memo[e.to][e.from][nv] != INF) continue;\n                    q.push({ e.to, e.from, nv, s.time + (e.dist /(double) nv) });\n                }\n            }\n        }\n        cout << \"unreachable\" << endl;\nnext:;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nclass state {\npublic:\n  double cost;\t\t\t// 所要時間\n  int p;\t\t\t// 位置\n  int v;\t\t\t// 速度\n  state(double _cost, int _p, int _v) {\n    cost = _cost;\n    p = _p;\n    v = _v;\n  }\n  bool operator > (const state &s) const {\n    return cost > s.cost;\n  }\n};\n\nint main() {\n  int n, m;\n  while (true) {\n    cin >> n >> m;\n    if (n == 0 && m == 0) {\n      break;\n    }\n\n    int s, g;\n    cin >> s >> g;\n    s--; g--;\n    if (m == 0) {\n      std::cout << \"unreachable\" << std::endl;\n      continue;\n    }\n\n    vector <int> graph[n];\n    double cost[n][n];\n    double dist[n][n];\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      double d, c;\n      cin >> x >> y >> d >> c;\n      x--; y--;\n      graph[x].push_back(y);\n      graph[y].push_back(x);\n      cost[x][y] = c;\n      cost[y][x] = c;\n      dist[x][y] = d;\n      dist[y][x] = d;\n    }\n\n    double memo[n][n][32];\t\t// prev now v\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tfor (int k = 0; k < 32; k++) {\n\t  memo[i][j][k] = -1;\n\t}\n      }\n    }\n\n    // for (int i = 0; i < n; i++) {\n    //   std::cout << i << \":\";\n    //   for (int j = 0; j < graph[i].size(); j++) {\n    // \tstd::cout << graph[i][j] << \" \";\n    //   }\n    //   std::cout << \"\" << std::endl;\n    // }\n\n    priority_queue <state, vector<state>, greater<state> > pque;\n    for (int i = 0; i < graph[s].size(); i++) {\n      int np = graph[s][i];\n      double nt = dist[s][np]/1.;\n      memo[s][np][1] = nt;\n      pque.push(state(nt, np, 1));\n    }\n    while(!pque.empty()) {\n      state p = pque.top(); pque.pop();\n\n      for (int i = 0; i < graph[p.p].size(); i++) {\n\tint np = graph[p.p][i];\n\tfor (int j = -1; j <= 1; j++) {\n\t  int v = p.v+j;\n\t  if (v <= 0 || v > cost[p.p][np] || (np == g && v != 1) ||\n              p.p == np) {\n\t    continue;\n\t  }\n\n\t  double nt = p.cost+dist[p.p][np]/double(v);\n\n\t  if (memo[p.p][np][v] == -1 ||\n\t      memo[p.p][np][v] > nt) {\n\n\t    memo[p.p][np][v] = nt;\n\t    pque.push(state(nt, np, v));\n\t  }\n\t}\n      }\n    }\n\n    double ans = -1;\n    for (int i = 0; i < n; i++) {\n      if (memo[i][g][1] == -1) {\n        continue;\n      }\n      if (ans == -1 ||\n          memo[i][g][1] < ans) {\n        ans = memo[i][g][1];\n      }\n    }\n\n    if (ans == -1) {\n      std::cout << \"unreachable\" << std::endl;\n    }else {\n      printf(\"%.5f\\n\", ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m;\nll s, g;\n\nclass DK {\npublic:\n\tstruct edge {\n\t\tint to;\n\t\tdouble cost;\n\t\tll cap;\n\t\tedge(int _to, double _cost, ll _cap) :to(_to), cost(_cost), cap(_cap) {}\n\t};\n\n\tdouble d[110][110];\n\tvector<edge> G[110];//各頂点からの辺\n\n\tvoid dijkstra() {\n\t\trep(i, 110)rep(j, 110)d[i][j] = INF;\n\t\td[s][0] = 0;\n\n\t\ttypedef pair<pair<double, ll>, ll> PP;\n\t\tpriority_queue<PP, vector<PP>, greater<PP>> que;\n\t\tque.push({ {0, 0},s });\n\n\t\twhile (!que.empty()) {\n\t\t\tPP p = que.top();\n\t\t\tque.pop();\n\t\t\tll nn = p.second;\n\t\t\tll v = p.first.second;\n\t\t\tif (d[nn][v] < p.first.first)continue;\n\t\t\tfor (int i = 0; i < G[nn].size(); i++) {\n\t\t\t\tedge e = G[nn][i];\n\t\t\t\tFOR(j, -1, 2) {\n\t\t\t\t\tdouble nv = v + j;\n\t\t\t\t\tif (nv <= 0)continue;\n\t\t\t\t\tif (nv > e.cap)continue;\n\t\t\t\t\tif (d[e.to][(ll)nv] > d[nn][v] + e.cost / nv) {\n\t\t\t\t\t\td[e.to][(ll)nv] = d[nn][v] + e.cost / nv;\n\t\t\t\t\t\tque.push({ {d[e.to][(ll)nv], nv},e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n};\n\nDK dk;\n\nint main() {\n\twhile (cin >> n >> m&&n + m) {\n\t\trep(i, 110)dk.G[i].clear();\n\t\tcin >> s >> g;\n\t\trep(i, m) {\n\t\t\tint x, y;\n\t\t\tll c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tdk.G[x].push_back(DK::edge(y, d, c));\n\t\t\tdk.G[y].push_back(DK::edge(x, d, c));\n\t\t}\n\t\tdk.dijkstra();\n\t\t//rep(i, n) {\n\t\t//\trep(j, 30) {\n\t\t//\t\tcout << dk.d[i + 1][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tdouble ans = dk.d[g][1];\n\t\tif ((ll)ans == INF)cout << \"unreachable\" << endl;\n\t\telse printf(\"%.10lf\\n\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<double, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint n,m;\nstruct edge { int to;double cost; };\nint V;\nvector<edge> G[100000];\ndouble d[100000];\nvoid init(int v) {\n\trep(i, v) {\n\t\tG[i].clear();\n\t}\n}\nvoid dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\tfill(d, d + V, 10000);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (d[v]+eps < p.first)continue;\n\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost+eps) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (cin >> n>>m, n) {\n\t\tV = 100000;\n\t\tint s, g; cin >> s >> g; s--; g--;\n\t\tinit(100000);\n\t\tP dis[30][30];\n\t\trep(i, 30) {\n\t\t\trep(j, 30) {\n\t\t\t\tdis[i][j] = { 0,0 };\n\t\t\t}\n\t\t}\n\t\trep(i, m) {\n\t\t\tint x, y, D, c; cin >> x >> y >> D >> c; x--; y--;\n\t\t\tdis[x][y] = dis[y][x] = { D,c };\n\t\t}\n\t\trep(f, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, 31) {\n\t\t\t\t\tRep1(k, -1, 1) {\n\t\t\t\t\t\tint x = j + k;\n\t\t\t\t\t\tif (x <= 0 || x > 30)continue;\n\t\t\t\t\t\trep(l, n) {\n\t\t\t\t\t\t\tif (f!=l&&i != l && dis[i][l].first != 0 && dis[i][l].second >= x) {\n\t\t\t\t\t\t\t\tG[i + j * n+f*n*31].push_back({ l + n * x+i*n*31,(double)dis[i][l].first / double(x) });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(s + s * n*31);\n\t\tdouble mi = 10000;\n\t\trep(i, n) {\n\t\t\tmi = min(mi, d[g + n+ n * 31*i]);\n\t\t}\n\t\tif (mi == 10000) {\n\t\t\tcout << \"unreachable\" << endl; continue;\n\t\t}\n\t\tcout << fixed << setprecision(5) << mi << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint n, m;\n\t\tcin>>n>>m;\n\t\tif(n == 0 && m == 0) break;\n\t\tint s, g;\n\t\tcin>>s>>g;\n\t\t--s;\n\t\t--g;\n\t\tvector<vector<pair<ll, P> > > p(n);\n\t\tvector<vector<vector<double> > > d(n, vector<vector<double> >(n, vector<double>(31, INF)));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\t--x;\n\t\t\t--y;\n\t\t\tp[x].pb({y, P(d, c)});\n\t\t\tp[y].pb({x, P(d, c)});\n\t\t}\n\t\tpriority_queue<pair<pair<double, ll>, P>, vector<pair<pair<double, ll>, P> >, greater<pair<pair<double, ll>, P> > > q;\n\t\tREP(i, n) {\n\t\t\td[0][i]][1] = 0;\n\t\t}\n\t\tq.push({{0, 0}, {0, 1}});\n\t\twhile(!q.empty()) {\n\t\t\tpair<pair<double, ll>, P> np = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[np.first.second][np.second.first][np.second.second] != np.first.first) continue;\n\t\t\tFOR(i, -1, 2) {\n\t\t\t\tll ns = np.second.second + i;\n\t\t\t\tif(np.first.second == 0 && np.second.first == 0) {\n\t\t\t\t\tif(ns != 1) continue;\n\t\t\t\t}\n\t\t\t\tif(ns <= 0) continue;\n\t\t\t\tREP(j, p[np.first.second].size()) {\n\t\t\t\t\tll next = p[np.first.second][j].first;\n\t\t\t\t\tif(next == np.second.first) continue;\n\t\t\t\t\tif(p[np.first.second][j].second.second < ns) continue;\n\t\t\t\t\tif(d[next][np.first.second][ns] > d[np.first.second][np.second.first][np.second.second] + p[np.first.second][j].second.first / (double)ns) {\n\t\t\t\t\t\td[next][np.first.second][ns]  = d[np.first.second][np.second.first][np.second.second] + p[np.first.second][j].second.first / (double)ns;\n\t\t\t\t\t\tq.push({{d[next][np.first.second][ns], next}, {np.first.second, ns}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = INF;\n\t\tREP(i, n) {\n\t\t\tans = min(ans, d[g][i][1]);\n\t\t}\n\t\tif(ans != INF) cout<<fixed<<showpoint<<setprecision(39)<<ans<<endl;\n\t\telse cout<<\"unreachable\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i,a) for(int i=0;i<a;i++)\n\nint n, m;\nint s, g;\n\nstruct edge\n{\n    int to, d, c;\n\n    edge() {}\n    edge(int to, int d, int c) \n        : to(to), d(d), c(c) {}\n};\n\nvector<vector<edge> > E;\n\nstruct node\n{\n    double cost;\n    int prev, v, speed;\n\n    node() {}\n    node(double cost, int prev, int v, int speed)\n        : cost(cost), prev(prev), v(v), speed(speed) {}\n    bool operator <(const node& t) const {\n        return cost > t.cost;\n    }\n};\n\ndouble mem[32][32][32];\n\nvoid solve()\n{\n    rep(i,32)rep(j,32)rep(k,32)mem[i][j][k]=1e15;\n\n    priority_queue<node> q;\n    q.push(node(0.0, n, s, 0));\n    while (!q.empty()) {\n        double cost = q.top().cost;\n        int prev = q.top().prev;\n        int v = q.top().v;\n        int speed = q.top().speed;\n        q.pop();\n\n        // cerr<<cost<<' '<<prev<<' '<<v<<' '<<speed<<endl;\n\n        if (mem[prev][v][speed] <= cost)\n            continue;\n        if (v == g && speed == 1) {\n            printf(\"%.8f\\n\", cost);\n            return;\n        }\n\n        mem[prev][v][speed] = cost;\n\n        rep(i, E[v].size()) {\n            if (E[v][i].to == prev)\n                continue;\n            for (int ns = speed - 1; ns <= speed + 1; ++ns) {\n                if (ns > 0 && ns <= E[v][i].c) {\n                    q.push(node(cost + (double) E[v][i].d / ns, v, E[v][i].to, ns));\n                }\n            }\n        }\n    }\n    cout << \"unreachable\" << endl;\n}\n\nint main()\n{\n    while (cin >> n >> m && n) {\n        cin >> s >> g;\n        --s, --g;\n        E.clear();\n        E.resize(n);\n        rep(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            --x, --y;\n            E[x].push_back(edge(y, d, c));\n            E[y].push_back(edge(x, d, c));\n        }\n\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nstruct Edge {\n    double dist; int lim;\n};\n\nint n, g;\nEdge G[40][40];\n\ndouble INF = 1 << 29;\n\ndouble memo[40][40][40];\ndouble dp(int prev, int crr, int sp)\n{\n    if (memo[prev][crr][sp] != -1) return memo[prev][crr][sp];\n    if (crr == g && sp == 1) return 0;\n    if (G[prev][crr].lim < sp) return INF;\n    double ans = INF;\n    loop (n, i) {\n        double dist = G[crr][i].dist;\n        if (i == prev || dist == INF) continue;\n        ans = min(ans, dist / (sp+1) + dp(crr, i, sp+1));\n        if (sp > 0) ans = min(ans, dist / sp + dp(crr, i, sp));\n        if (sp > 1) ans = min(ans, dist / (sp-1) + dp(crr, i, sp-1));\n    }\n    memo[prev][crr][sp] = ans;\n    return ans;\n}\n\nint main()\n{\n    while (1) {\n        int m, s; cin >> n >> m >> s >> g;\n        s--, g--;\n\n        loop (n, i) loop (n, j) G[i][j] = { INF, 0 };\n        loop (m, i) {\n            int x, y, c; double d;\n            cin >> x >> y >> d >> c;\n            x--, y--;\n            G[x][y] = { d, c };\n            G[y][x] = { d, c };\n        }\n\n        fill(memo[0][0], memo[39][39]+40, -1);\n        double ans = dp(39, 0, 0);\n        if (ans == INF) {\n            cout << \"unreachable\" << endl;\n        } else {\n            cout << setprecision(8) << fixed << ans << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint N,M,start,goal;\n\nstruct Info{\n\tInfo(){\n\t\ttown = pre_town = 0;\n\t\tspeed = time = 0.0;\n\t}\n\n\tInfo(int arg_town,int arg_speed,double arg_time,int arg_pre_town){\n\t\ttown = arg_town;\n\t\tspeed = arg_speed;\n\t\ttime = arg_time;\n\t\tpre_town = arg_pre_town;\n\t}\n\tint town,speed,pre_town;\n\tdouble time;\n};\n\nstruct Road{\n\tRoad(int arg_to,double arg_dist,int arg_speed_limit){\n\t\tto = arg_to;\n\t\tdist = arg_dist;\n\t\tspeed_limit = arg_speed_limit;\n\t}\n\tint to,speed_limit;\n\tdouble dist;\n};\n\nvoid func(){\n\n\tdouble min_Time[N+1][31];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 1; k <= 30; k++)min_Time[i][k] = DBL_MAX;\n\t}\n\n\tscanf(\"%d %d\",&start,&goal);\n\n\tvector<Road> V[N+1];\n\n\tint from,to,limit;\n\tdouble dist;\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %lf %d\",&from,&to,&dist,&limit);\n\t\tV[from].push_back(Road(to,dist,limit));\n\t\tV[to].push_back(Road(from,dist,limit));\n\t}\n\n\tInfo first;\n\tfirst.speed = 1;\n\tfirst.time = 0.0;\n\tfirst.town = start;\n\tfirst.pre_town = -1;\n\n\tmin_Time[start][1] = 0.0;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tint next_town,next_speed;\n\tdouble distance;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().town == goal && Q.front().speed == 1){\n\t\t\tQ.pop();\n\t\t}else if(Q.front().time > min_Time[Q.front().town][Q.front().speed]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < V[Q.front().town].size();i++){\n\t\t\t\tnext_town = V[Q.front().town][i].to;\n\t\t\t\tif(next_town == Q.front().pre_town)continue;\n\n\t\t\t\tlimit = V[Q.front().town][i].speed_limit;\n\t\t\t\tdistance = V[Q.front().town][i].dist;\n\n\t\t\t\tif(Q.front().time > 0.0){\n\n\t\t\t\t\tfor(int k = -1;k <= 1; k++){\n\t\t\t\t\t\tnext_speed = Q.front().speed + k;\n\t\t\t\t\t\tif(next_speed <= 0 || next_speed > limit)continue;\n\n\t\t\t\t\t\tif(min_Time[next_town][next_speed] > Q.front().time + distance/(double)next_speed){\n\t\t\t\t\t\t\tmin_Time[next_town][next_speed] = Q.front().time + distance/(double)next_speed;\n\t\t\t\t\t\t\tQ.push(Info(next_town,next_speed,Q.front().time+distance/(double)next_speed,Q.front().town));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t}else{\n\t\t\t\t\tmin_Time[next_town][1] = distance;\n\t\t\t\t\tQ.push(Info(next_town,1,distance,1));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(min_Time[goal][1] == DBL_MAX){\n\t\tprintf(\"unreachable\\n\");\n\t}else{\n\t\tprintf(\"%.6lf\\n\",min_Time[goal][1]);\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nstruct edge{\n  int t;\n  int d;\n  int c;\n};\n\nint main(){\n  while(1){\n    int n,m;\n    cin >> n >> m;\n    if(n==0) return 0;\n    int s,g;\n    cin >> s >> g;\n    s--,g--;\n    vector<vector<edge>> e(n);\n    int x,y,d,c;\n    for(int i=0;i<m;i++){\n      cin >> x >> y >> d >> c;\n      x--,y--;\n      e[x].push_back({y,d,c});\n      e[y].push_back({x,d,c});\n    }\n    vector<vector<vector<LD>>> dp(n,vector<vector<LD>>(n,vector<LD>(31,INF)));\n    priority_queue<pair<LD,pair<int,pair<int,int>>>> dijk;\n    for(auto ed:e[s]){\n      dijk.push({-ed.d,{ed.t,{s,1}}});\n    }\n    pair<LD,pair<int,pair<int,int>>> now;\n    while(!dijk.empty()){\n      now=dijk.top();\n      dijk.pop();\n      LD ti=-now.first;\n      int ns=now.second.first;\n      int ps=now.second.second.first;\n      int sp=now.second.second.second;\n      if(dp[ns][ps][sp]==INF){\n        dp[ns][ps][sp]=ti;\n        for(auto ed:e[ns]){\n          if(ed.t==ps) continue;\n          if(sp+1<=ed.c){\n            if(dp[ed.t][ns][sp+1]==INF){\n              dijk.push({-ti-(LD)ed.d/(sp+1),{ed.t,{ns,sp+1}}});\n            }\n          }\n          if(sp<=ed.c){\n            if(dp[ed.t][ns][sp]==INF){\n              dijk.push({-ti-(LD)ed.d/sp,{ed.t,{ns,sp}}});\n            }\n          }\n          if(sp>1&&sp-1<=ed.c){\n            if(dp[ed.t][ns][sp-1]==INF){\n              dijk.push({-ti-(LD)ed.d/(sp-1),{ed.t,{ns,sp-1}}});\n            }\n          }\n        }\n      }\n    }\n    LD ans=INF;\n    for(int i=0;i<n;i++){\n      for(int j=1;j<=30;j++){\n        ans=min(ans,dp[g][i][1]);\n      }\n    }\n    if(ans==INF) cout << \"unreachable\" << endl;\n    else cout << fixed << setprecision(10) << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 30;\nconst double EPS = 1E-9;\n\nint n, m, s, g;\nstruct edge{\n\tint to;\n\tint cost;\n\tint limit;\n};\nvector<edge> G[101];\ndouble t[101][31];\n\nint main(){\n\twhile(cin >> n >> m && (n || m)){\n\t\tcin >> s >> g;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint from, to;\n\t\t\tedge e;\n\t\t\tcin >> from >> to >> e.cost >> e.limit;\n\t\t\te.to = to;\n\t\t\tG[from].push_back(e);\n\t\t\te.to = from;\n\t\t\tG[to].push_back(e);\n\t\t}\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tfill(t[i], t[i] + 101, -1.0);\n\t\t}\n\t\tt[s][0] = 0;\n\t\tpriority_queue<pair<double, PP>, vector<pair<double, PP> >, greater<pair<double, PP> > > que;\n\t\tque.push(make_pair(0, PP(-1, P(s, 0))));\n\t\twhile(!que.empty()){\n\t\t\tpair<double, PP > ppp = que.top(); que.pop();\n\t\t\tPP pp = ppp.second;\n\t\t\tdouble tm = ppp.first;\n\t\t\tint place = pp.second.first;\n\t\t\tint v = pp.second.second;\n\t\t\tint pre = pp.first;\n\t\t\tfor(size_t i = 0; i < G[place].size(); i++){\n\t\t\t\tedge e = G[place][i];\n\t\t\t\tif(e.to == pre) continue;\n\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\tif(v + j > 0 && v + j <= 30 && v + j <= e.limit){\n\t\t\t\t\t\tif(t[e.to][v+j] < 0 || t[e.to][v+j] > t[place][v] + (double)e.cost / (v+j)){\n\t\t\t\t\t\t\tt[e.to][v+j] = t[place][v] + (double)e.cost / (double)(v+j);\n\t\t\t\t\t\t\tque.push(make_pair(t[e.to][v+j], PP(place, P(e.to, v+j))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(s == g) cout << 0.0000 << endl;\n\t\telse if(t[g][1] < 0) cout << \"unreachable\" << endl;\n\t\telse cout << fixed << setprecision(6) << t[g][1] << endl;\n\t\tfor(int i = 0; i < 101; i++) G[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, P> P3;\nconst ll MOD = ll(1e9+7);\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(3e5 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nstruct edge{\n    int to, c;\n    double d;\n};\n\nint n, m, s, g;\nvector<vector<edge> > G;\ndouble tmin[35][35];  // 頂点iに速さjで到着するときの最短時間\n\nvoid dijkstra(){\n    REP(i,n)fill(tmin[i],tmin[i]+35,IINF);\n    priority_queue<P3, vector<P3>, greater<P3> > que;\n    tmin[s][0] = 0.0;\n    que.push({0.0,{s,0}});\n    while(!que.empty()){\n        P3 p = que.top();\n        que.pop();\n        int from = p.second.first, v = p.second.second;\n        if(p.first > tmin[from][v] + EPS)continue;\n        for(auto &e : G[from]){\n            if(e.to == from)continue;\n            for(int dv=-1; dv<=1; dv++){\n                int nv = v+dv;\n                if(nv<=0 || nv>e.c)continue;\n                if(tmin[e.to][nv] > tmin[from][v] + e.d/double(nv) + EPS){\n                    tmin[e.to][nv] = tmin[from][v] + e.d/double(nv);\n                    que.push({tmin[e.to][nv],{e.to,nv}});\n                }\n            }\n        }\n    }\n}\n\n\nint main() {\n    while(cin >> n >> m, n){\n        cin >> s >> g;\n        s--; g--;\n        G.clear();\n        G.resize(n);\n        REP(i,m){\n            int x, y, c;\n            double d;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            G[x].push_back({y,c,d});\n            G[y].push_back({x,c,d});\n        }\n        dijkstra();\n        if(tmin[g][1]<IINF/2){\n            printf(\"%.8lf\\n\",tmin[g][1]);\n        }\n        else{\n            cout << \"unreachable\" << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define INF 100000000\n#define rep(i,n) for(int i=0;i<n;i++)\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<double,int> pp;\ntypedef pair<pp,p> P;\nstruct edge{\n\tint to,d,c;\n};\nint main(){\n\tdouble dp[31][31];\n\tint n,m,s,g,x,y,d,c,ds[]={1,-1,0};\n\twhile(cin>>n>>m,n||m){\n\t\tvector<edge> G[31];\n\t\tcin>>s>>g;\n\t\ts--;g--;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tx--;y--;\n\t\t\tedge e;\n\t\t\te.d=d;e.c=c;\n\t\t\te.to=y;\n\t\t\tG[x].push_back(e);\n\t\t\te.to=x;\n\t\t\tG[y].push_back(e);\n\t\t}\n\t\trep(i,31)\n\t\trep(j,31)\n\t\tdp[i][j]=INF;\n\t\tdp[0][s]=0.0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(pp(0.0,-1),p(0,s)));\n\t\tdouble ans=INF;\n\t\twhile(!que.empty()){\n\t\t\tP q=que.top();que.pop();\n\t\t\tif(q.second.second==g&&q.second.first==1){\n\t\t\t\tans=min(ans,dp[q.second.first][q.second.second]);\n\t\t\t//\tcout<<ans<<endl;\n\t\t\t}\n\t\t\t//cout<<q.second.second<<' '<<q.second.first<<' '<<q.first<<endl;\n\t\t\tif(dp[q.second.first][q.second.second]<q.first.first)\n\t\t\t\tcontinue;\n\t\t\trep(i,G[q.second.second].size()){\n\t\t\t\tedge e=G[q.second.second][i];\n\t\t\t\tif(e.to==q.first.second)\n\t\t\t\tcontinue;\n\t\t\t\trep(j,3){\n\t\t\t\t\tint pre=q.second.first+ds[j];\n\t\t\t\t\tif(pre<1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble tes=(double)e.d/pre+q.first.first;\n\t\t\t\t\tif(pre<=e.c&&dp[pre][e.to]>tes){\n\t\t\t\t\t\tque.push(P(pp(tes,q.second.second),p(pre,e.to)));\n\t\t\t\t\t\tdp[pre][e.to]=tes;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans==INF)\n\t\tcout<<\"unreachable\"<<endl;\n\t\telse\n\t\tprintf(\"%.5lf\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1000 // いつもは1<<29だが小さくすれば時間はやくなる？\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n//自身だー\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\n\nconst double INF = 1e9;\n\nint n, m, s, g;\n\n// [n][v];\ndouble dp[32][32];\n\nstruct edge {\n\tint to, c;\n\tdouble length;\n\n\tedge(int to, int c, double l) :to(to), c(c), length(l){\n\t}\n};\n\nvector<edge> G[32];\n\nstruct state {\n\tint n, prev, v;\n\tdouble time;\n\n\tstate(int n, int prev, int v, double time) :n(n), prev(prev),v(v), time(time){\n\t}\n};\n\nint main(){\n\twhile(cin >> n >> m , n | m) {\n\t\tcin >> s >> g;\n\n\t\tfor(int i = 0; i < 32; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint x, y, c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tG[x].push_back(edge(y, c, d));\n\t\t\tG[y].push_back(edge(x, c, d));\n\t\t}\n\n\t\tfor(int i = 0; i < 31; i++) {\n\t\t\tfor(int j = 0; j < 31; j++) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tqueue<state> q;\n\t\tq.push(state(s, -1, 1, 0.0));\n\t\twhile(!q.empty()) {\n\t\t\tstate s = q.front();\n\t\t\tq.pop();\n\t\t\tif(dp[s.n][s.v] <= s.time) continue;\n\t\t\tdp[s.n][s.v] = s.time;\n\t\t\tint dv[] = {0, 1, -1};\n\t\t\tfor(int i = 0; i < G[s.n].size(); i++) {\n\t\t\t\tfor(int j = 0; j < ((s.prev == -1) ? 1 : 3); j++) {\n\t\t\t\t\tint nv = s.v + dv[j];\n\t\t\t\t\tif(nv > 0 && nv <= G[s.n][i].c && G[s.n][i].to != s.prev)\n\t\t\t\t\t\tq.push(state(G[s.n][i].to, s.n, nv, s.time + G[s.n][i].length / nv));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = dp[g][1];\n\t\tif(ans == INF)\n\t\t\tcout << \"unreachable\" << endl;\n\t\telse\n\t\t\tcout << dp[g][1] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\n#define INF 1e9\nusing namespace std;\n\nclass DP{\npublic:\n\tdouble cost;\n\tunsigned char cur, sp, prev;\n\t\n\tDP(){}\n\tDP(double c, int cu, int s, int pr){\n\t\tcost = c;cur=cu;sp=s;prev=pr;\n\t}\n\t\n\tbool operator< (const DP &opp) const {\n\t\treturn cost>opp.cost;\n\t}\n};\nint n,m,s,go;\n\nchar visit[31][31][31];\nint g[31][31];\nint lim[31][31];\n\nmain(){\n\tint i,j,d,c,x,y;\n\twhile(cin>>n>>m,n){\n\t\tpriority_queue<DP> dp;\n\t\tmemset(g, 0, sizeof(g));\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tcin>>s>>go;\n\t\t\n\t\tfor(i=1;i<=m;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tg[x][y]=g[y][x]=d;\n\t\t\tlim[x][y]=lim[y][x] = c;\n\t\t}\n\t\n\t\tDP T,S;\n\t\tdp.push(DP(0,s,0,0));\n\t\twhile(!dp.empty()){\n\t\t\tS = dp.top();\n\t\t\tdp.pop();\n\t\t\tif(visit[S.cur][S.sp][S.prev]) continue;\n\t\t\tif(S.cur == go && S.sp == 1) break;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tif(!g[S.cur][i]) continue;\n\t\t\t\tfor(j=S.sp-1;j<=S.sp+1;j++){\n\t\t\t\t\tif(lim[S.cur][i] < j || j < 1 || i == S.prev || visit[i][j][S.cur]) continue;\n\t\t\t\t\tT.cost = S.cost + g[S.cur][i] / (double)j;\n\t\t\t\t\tT.cur = i;\n\t\t\t\t\tT.sp = j;\n\t\t\t\t\tT.prev = S.cur;\n\t\t\t\t\tdp.push(T);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvisit[S.cur][S.sp][S.prev] = 1;\n\t\t}\n\t\tif(S.cur == go && S.sp == 1) printf(\"%.4lf\\n\", S.cost);\n\t\telse cout << \"unreachable\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nstruct State {\n    int i, prev, sp; double cost;\n};\n\nbool operator>(const State& a, const State& b)\n{\n    return a.cost > b.cost;\n}\n\nconst double INF = 1<<29;\n\nint main()\n{\n    while (1) {\n        int n, m, s, g; cin >> n >> m >> s >> g;\n        if (!n) break;\n        s--, g--;\n\n        vector<vector<double>> dist(n, vector<double>(n, INF));\n        vector<vector<int>> lim(n, vector<int>(n));\n\n        while (m--) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--, y--;\n            dist[x][y] = dist[y][x] = d;\n            lim[x][y] = lim[y][x] = c;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> Q;\n        Q.push({ s, -1, 0, 0 });\n\n        int vis[40][40][40] = {};\n        double ans = INF;\n        while (Q.size()) {\n            auto e = Q.top(); Q.pop();\n            if (vis[e.i][e.sp][e.prev]) continue;\n            vis[e.i][e.sp][e.prev] = 1;\n            if (e.i == g && e.sp == 1) ans = min(ans, e.cost);\n            loop (n, i) loop (3, d) {\n                int sp = e.sp-1+d;\n                if (dist[e.i][i] == INF || i == e.prev ||\n                        sp < 1 || sp > lim[e.i][i]) continue;\n                Q.push({ i, e.i, sp, e.cost + dist[e.i][i] / sp });\n            }\n        }\n        if (ans != INF) cout << setprecision(12) << fixed << ans << endl;\n        else cout << \"unreachable\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<double, int, int, int> T;\n \nconst ll MOD=1e9+7;\n//const ll INF=1e18;\n\nconst double INF = 1000000.0;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\nstruct edge{ int to,d,c;};\n\n\n\nint n,m,s,g;\ndouble d[35][35][35];\ndouble mind;\n\nint main(){\n\twhile(true){\n\t\tcin >> n >> m;\n\t\tif(n + m == 0) break;\n\t\tcin >> s >> g;\n\t\tmind = INF;\n\t\tvector<edge> G[35];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a1,a2,a3,a4;\n\t\t\tcin >> a1 >> a2 >> a3 >> a4;\n\t\t\tedge tmp1 = {a2,a3,a4};\n\t\t\tG[a1].push_back(tmp1);\n\t\t\tedge tmp2 = {a1,a3,a4};\n\t\t\tG[a2].push_back(tmp2);\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tfor(int k = 0;k <= 31;k++){\n\t\t\t\t\td[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//queue<T> que;\n\t\tpriority_queue<T,vector<T>,greater<T> > que;\n\t\tfor(int i = 0;i < G[s].size();i++){\n\t\t\tedge e = G[s][i];\n\t\t\td[s][e.to][1] = (double) e.d;\n\t\t\tque.push(make_tuple((double)e.d,1,s,e.to));\n\t\t}\n\n\t\twhile(!que.empty()){\n\t\t\tT t = que.top(); que.pop();\n\t\t\tdouble a1 = get<0>(t);\n\t\t\tint a2 = get<1>(t),a3 = get<2>(t),a4 = get<3>(t);\n\t\t\tif(d[a3][a4][a2] < a1 || a1 > mind)continue;\n\t\t\tfor(int i = 0;i < G[a4].size();i++){\n\t\t\t\tedge e = G[a4][i];\n\t\t\t\tif(e.to == a3) continue;\n\t\t\t\tdouble tmp = (double) a1 + (double)e.d;\n\t\t\t\tif(d[a4][e.to][1] < tmp)continue;\n\t\t\t\td[a4][e.to][1] =  tmp;\n\t\t\t\tif(mind < tmp) continue;\n\t\t\t\tif(e.to == g && mind > tmp)mind = tmp;\n\t\t\t\tque.push(make_tuple(tmp,1,a4,e.to));\n\t\t\t}\n\t\t}\n\t\tif(mind == INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tfor(int k = 0;k <= 31;k++){\n\t\t\t\t\td[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < G[s].size();i++){\n\t\t\tedge e = G[s][i];\n\t\t\td[s][e.to][1] = (double) e.d;\n\t\t\tque.push(make_tuple((double)e.d,1,s,e.to));\n\t\t}\n\n\n\n\t\twhile(!que.empty()){\n\t\t\t//T t = que.front(); que.pop();\n\t\t\tT t = que.top(); que.pop();\n\t\t\tdouble a1 = get<0>(t);\n\t\t\tint a2 = get<1>(t),a3 = get<2>(t),a4 = get<3>(t);\n\t\t\tif(d[a3][a4][a2] < a1 || a1 > mind)continue;\n\t\t\tfor(int i = 0;i < G[a4].size();i++){\n\t\t\t\tedge e = G[a4][i];\n\t\t\t\tif(e.to == a3) continue;\n\t\t\t\tfor(int j = -1;j <= 1;j++){\n\t\t\t\t\tint v = a2 + j;\n\t\t\t\t\tdouble tmp = (double)( a1 + (double)e.d / (double)v);\n\t\t\t//\t\tif(a4 == 5 && e.to == 6 && v == 1) cout << \"tmp\" << tmp << \",a1\" << a1 <<endl;\n\t\t\t\t\tif(v <= 0 || v > e.c || d[a4][e.to][v] < tmp ||tmp > mind) continue;\n\t\t\t\t\td[a4][e.to][v] =  tmp;\n\t\t\t\t\tif(e.to == g && v == 1 && mind > tmp)mind = tmp;\n\t\t\t\t\tque.push(make_tuple(tmp,v,a4,e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\n\t\t}\n\t//\tcout << \"ans\" << d[4][5][2] << endl;\n\n\n\n\t\tdouble ans = INF;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tdouble tmp = d[i][g][1];\n\t\t\tif(ans > tmp) ans = tmp;\n\t\t//\tans = min(ans,d[i][g][1]);\n\t\t}\n\t\tif(ans == INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t//\tcout << ans << endl;\n\t\t\tprintf(\"%lf\\n\",ans);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<ll,ll> Pi;\nconst int INF=(ll)(1LL<<30)-1;\nconst double INFd=100000000000.0;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint n,m;\nint s,g;\nint x[500],y[500],d[500],c[500];\nint rod[35][35];\nint roc[35][35];\ndouble dp[35][35][35];//from,to,speed\n\nstruct road{\n\tint from;\n\tint to;\n\tint speed;\n\tdouble cost;\n\troad(int _from,int _to,int _speed,double _cost){\n\t\tfrom=_from;\n\t\tto=_to;\n\t\tspeed=_speed;\n\t\tcost=_cost;\n\t};\n\tbool operator<(const road& r1)const{\n\t\treturn cost>r1.cost;\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tpriority_queue<road> PP;\n\t\twhile(PP.size())PP.pop();\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)break;\n\t\tcin>>s>>g;\n\t\tREP(i,35)\n\t\t\tREP(j,35){\n\t\t\t\trod[i][j]=-1;\n\t\t\t\troc[i][j]=-1;\n\t\t\t}\n\t\tREP(i,35){\n\t\t\tREP(j,35){\n\t\t\t\tREP(k,35){\n\t\t\t\t\tdp[i][j][k]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>x[i]>>y[i]>>d[i]>>c[i];\n\t\t\trod[x[i]][y[i]]=d[i];\n\t\t\trod[y[i]][x[i]]=d[i];\n\t\t\troc[x[i]][y[i]]=c[i];\n\t\t\troc[y[i]][x[i]]=c[i];\n\t\t\tif(x[i]==s){\n\t\t\t\tPP.push(road(s,y[i],1,(double)d[i]));\n\t\t\t\tdp[s][y[i]][1]=d[i];\n\t\t\t}\n\t\t\tif(y[i]==s){\n\t\t\t\tPP.push(road(s,x[i],1,(double)d[i]));\n\t\t\t\tdp[s][x[i]][1]=d[i];\n\t\t\t}\n\t\t}\n\t\tdouble ret=INF;\n\t\twhile(PP.size()){\n\t\t\troad r1=PP.top();PP.pop();\n\t\t\tif(r1.to==g&&r1.speed==1){\n\t\t\t\tret=min(ret,r1.cost);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(i!=r1.from&&rod[r1.to][i]!=-1){\n\t\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\tint tx=r1.speed+j;\n\t\t\t\t\t\tif(tx>0&&tx<=roc[r1.to][i]){\n\t\t\t\t\t\t\tdouble ncost=r1.cost+(double)rod[r1.to][i]/tx;\n\t\t\t\t\t\t\tif(dp[r1.to][i][tx]==-1||dp[r1.to][i][tx]>ncost){\n\t\t\t\t\t\t\t\tdp[r1.to][i][tx]=ncost;\n\t\t\t\t\t\t\t\tPP.push(road(r1.to,i,tx,ncost));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ret==INF)printf(\"unreachable\\n\");\n\t\telse printf(\"%.10f\\n\",ret);\n\t}\n\treturn 0;\n}\n\t\t\t\t\t\t\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\nconst int INF = 1e9 + 10;\n\nstruct Edge {\n  int to, dist, constraint;\n \n  Edge() = default;\n  Edge(int t, int d, int c): to(t), dist(d), constraint(c) { }\n};\n\nstruct Node {\n  double cost;\n  int cur, prev, v;\n  \n  Node() = default;\n  Node(double c, int cur, int prev, int v): cost(c), cur(cur), prev(prev), v(v) { }\n\n  inline bool operator<(const Node& node) const {\n    return cost < node.cost;\n  }\n\n  inline bool operator>(const Node& node) const {\n    return cost > node.cost;\n  }\n};\n\n\nint main() {\n  cout << (Node(1, 2, 3, 4) > Node(2, 2, 3, 4)) << endl;\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n + m == 0) {\n      break;\n    }\n    int s, g;\n    cin >> s >> g;\n\n    vector<Edge> G[31];\n    for (int i = 0; i < m; i++) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      G[x].push_back(Edge(y, d, c));\n      G[y].push_back(Edge(x, d, c));\n    }\n\n    double min_cost[31][31][31];\n    for (int i = 0; i < 31; i++)  {\n      for (int j = 0; j < 31; j++) {\n        for (int k = 0; k < 31; k++) {\n          min_cost[i][j][k] = INF;\n        }\n      }\n    }\n\n    priority_queue<Node, vector<Node>, greater<Node>> que;\n    min_cost[s][0][1] = 0;\n    que.push(Node(0, s, -1, 1));\n\n    while (!que.empty()) {\n      Node node = que.top(); que.pop();\n\n      if (min_cost[node.cur][node.prev][node.v] < node.cost) {\n        continue;\n      }\n\n      for (const auto& e : G[node.cur]) {\n        if (node.prev == e.to) {\n          continue;\n        }\n        double temp = e.dist / (double)(node.v);\n        if (min_cost[e.to][node.cur][node.v] > node.cost + temp) {\n          min_cost[e.to][node.cur][node.v] = node.cost + temp;\n          que.push(Node(node.cost + temp, e.to, node.cur, node.v));\n        }\n        if (node.prev != -1) {\n          if (node.v < e.constraint) {\n            temp = e.dist / (double)(node.v + 1);\n            if (min_cost[e.to][node.cur][node.v + 1] > node.cost + temp) {\n              min_cost[e.to][node.cur][node.v + 1] = node.cost + temp;\n              que.push(Node(node.cost + temp, e.to, node.cur, node.v + 1));\n            }\n          }\n          if (node.v > 1) {\n            temp = e.dist / (double)(node.v - 1);\n            if (min_cost[e.to][node.cur][node.v - 1] > node.cost + temp) {\n              min_cost[e.to][node.cur][node.v - 1] = node.cost + temp;\n              que.push(Node(node.cost + temp, e.to, node.cur, node.v - 1));\n            }\n          }\n        }\n        \n        if (e.to == g && node.v == 1) {\n          min_cost[g][node.cur][1] = min(min_cost[g][node.cur][1], node.cost + e.dist);\n        }\n      }\n    }\n\n    double ans = INF;\n    for (int i = 1; i <= n; i++) {\n      ans = min(ans, min_cost[g][i][1]);\n    }\n    if (ans >= INF) {\n      cout << \"unreachable\" << endl;\n    } else {\n      printf(\"%.15f\\n\", ans);\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct State {\n  int prev;\n  int now;\n  int vel; // 到着時\n  double e_time;\n  \n  bool operator < (const State &s) const {\n    return e_time > s.e_time;\n  }\n  \n  State() {}\n  State(int p, int n, int v, double t) :\n    prev(p), now(n), vel(v), e_time(t) {}\n};\n\nstruct Edge {\n  int to;\n  int cost;\n  int lim;\n  \n  Edge() {}\n  Edge(int t, int c, int l) : to(t), cost(c), lim(l) {}\n};\n\nconst double Inf = 1<<23;\nint N, M;\nvector<Edge> edges[30];\ndouble G_time[31][30][31]; // u, v, vel -> e_time\n\ndouble dijkstra(int s, int g) {\n  \n  fill(G_time[0][0], G_time[30][30], Inf);\n  priority_queue<State> pq;\n  \n  pq.push(State(s, s, 0, 0.0));\n  G_time[s][s][0] = 0.0;\n  \n  while(!pq.empty()) {\n    const State st = pq.top(); pq.pop();\n    \n    if(G_time[st.prev][st.now][st.vel] < st.e_time) {\n      continue;\n    }\n    \n    if(st.now == g && st.vel == 1) {\n      return st.e_time;\n    }\n    \n    for(int i=0; i<edges[st.now].size(); i++) {\n      const Edge &e = edges[st.now][i];\n      \n      if(e.to == st.prev) continue;\n      \n      for(int dvel = -1; dvel <= 1; dvel ++) {\n\tint nvel = st.vel + dvel;\n\t// 速度制限\n\tif(1 <= nvel && nvel <= e.lim) {\n\t  double ntime = st.e_time + (double)e.cost / nvel;\n\t  if(G_time[st.now][e.to][nvel] > ntime) {\n\t    G_time[st.now][e.to][nvel] = ntime;\n\t    pq.push(State(st.now, e.to, nvel, ntime));\n\t  }\n\t}\n\t\n      }\n    }\n  }\n  \n  return -42;\n}\n\nint main() {\n  int s, g;\n  \n  while(cin >> N >> M && (N|M)) {\n    cin >> s >> g;\n    s --, g --;\n    \n    for(int i=0; i<N; i++)\n      edges[i].clear();\n    \n    for(int i=0; i<M; i++) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      x --, y --;\n      edges[x].push_back(Edge(y, d, c));\n      edges[y].push_back(Edge(x, d, c));\n    }\n    \n    double ans = dijkstra(s, g);\n    if((int)(-ans) == 42) {\n      cout << \"unreachable\" << endl;\n    } else {\n      printf(\"%.5lf\\n\", ans);\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <mutex>\nusing namespace std;\n\nconst double INF = 1e9;\n\nint n, m, s, g;\n\n// [n][prev][v];\ndouble dp[32][32][32];\n\nstruct edge {\n\tint to, c;\n\tdouble length;\n\n\tedge(int to, int c, double l) :to(to), c(c), length(l){\n\t}\n\t\n};\n\nvector<edge> G[32];\n\nstruct state {\n\tint n, prev, v;\n\tdouble time;\n\n\tstate(int n, int prev, int v, double time) :n(n), prev(prev),v(v), time(time){\n\t}\n\tbool operator > (const state& s) const {\n\t\treturn time > s.time;\n\t}\n};\n\nvoid solve(){\n\tpriority_queue<state, vector<state>, greater<state>> q;\n\tq.push(state(s, -1, 1, 0.0));\n\twhile(!q.empty()) {\n\t\tstate s = q.top();\n\t\tq.pop();\n\t\tif(s.prev != -1 && dp[s.n][s.prev][s.v] <= s.time) continue;\n\n\t\tif(s.n == g && s.v == 1) {\n\t\t\tcout << s.time << endl;\n\t\t\treturn;\n\t\t}\n\n\t\tif(s.prev != -1)\n\t\t\tdp[s.n][s.prev][s.v] = s.time;\n\n\t\tint dv[] = { 0, 1, -1 };\n\t\tfor(int i = 0; i < G[s.n].size(); i++) {\n\t\t\tfor(int j = 0; j < ((s.prev == -1) ? 1 : 3); j++) {\n\t\t\t\tint nv = s.v + dv[j];\n\t\t\t\tif(nv > 0 && nv <= G[s.n][i].c && G[s.n][i].to != s.prev \n\t\t\t\t\t&& s.time + G[s.n][i].length / nv < dp[G[s.n][i].to][s.n][nv])\n\t\t\t\t\tq.push(state(G[s.n][i].to, s.n, nv, s.time + G[s.n][i].length / nv));\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"unreachable\" << endl;\n}\n\nint main(){\n\twhile(cin >> n >> m , n | m) {\n\t\tcin >> s >> g;\n\n\t\tfor(int i = 0; i < 32; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint x, y, c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tG[x].push_back(edge(y, c, d));\n\t\t\tG[y].push_back(edge(x, c, d));\n\t\t}\n\n\t\tfor(int i = 0; i < 31; i++) {\n\t\t\tfor(int j = 0; j < 31; j++) {\n\t\t\t\tfor(int k = 0; k < 31; k++) {\n\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsolve();\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1162\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1162&lang=jp\n\n#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\nconst double inf = (double)(1<<24);\n\nclass Node {\npublic:\n    double time;\n    int v, town, prev;\n    Node() {}\n    Node( double time_, int v_, int town_, int prev_ ) \n    {\n        time = time_;\n        v = v_;\n        town = town_;\n        prev = prev_;\n    }\n    bool operator < ( const Node& right ) const\n    {\n        return fabs( time - right.time ) < eps ? v < right.v : time > right.time;\n    }\n};\ntypedef priority_queue <Node> QUEUE;\nconst int size = 31;\n\nint n, m;\nbool P[size][size];\ndouble G[size][size];\ndouble MC[size][size];\nint L[size][size];\nint CN[size][size];\nint CN_count[size];\n\n// dijkstra\nvoid solve( int start, int goal )\n{\n    // init\n    QUEUE Q;\n    Node start_node( 0.0, 0, start, -1 );\n    Q.push( start_node );\n    MC[1][start] = 0.0;\n\n    // proc\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        // proc init\n        double time = node.time;\n        int v = node.v;\n        int town = node.town;\n        int prev = node.prev;\n\n        // goal\n        if ( town == goal && v == 1 ) {\n            printf( \"%.5f\\n\", time );\n            return;\n        }\n\n        // move\n        for ( int i = 0; i < CN_count[town]; i++ ) {\n            int next_town = CN[town][i];\n            if ( next_town == prev ) continue;\n            for ( int j = 1; j >= -1; j-- ) {\n                int next_v = v + j;\n                if ( prev == -1 && next_v != 1 ) continue;\n                if ( next_v <= 0 || next_v > L[town][next_town] ) continue;\n                double cost = (double)G[town][next_town] / next_v;\n                double next_time = time + cost;\n                int next_prev = town;\n\n                if ( next_time > MC[next_v][next_town] || fabs( next_time - MC[next_v][next_town] ) < eps ) continue;\n                MC[next_v][next_town] = next_time;\n                Node next_node( next_time, next_v, next_town, next_prev );\n                Q.push( next_node );\n            }\n        }\n    }\n\n    cout << \"unreachable\" << endl;\n}\n\nint main( void )\n{\n    while ( cin >> n >> m ) {\n        // quit\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        for ( int i = 0; i < size; i++ ) {\n            CN_count[i] = 0;\n            for ( int j = 0; j < size; j++ ) {\n                P[i][j] = false;\n                MC[i][j] = inf;\n                G[i][j] = inf;\n                L[i][j] = 0;\n            }\n        }\n\n        // input\n        int s, g;\n        cin >> s >> g;\n        for ( int i = 0; i < m; i++ ) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n\n            P[x][y] = P[y][x] = true;\n            G[x][y] = G[y][x] = d;\n            L[x][y] = L[y][x] = c;\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( i == j ) continue;\n                if ( P[i][j] ) CN[i][CN_count[i]++] = j;\n            }\n        }\n\n        solve( s-1, g-1 );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct road {\n  int from, to, d, c;\n  road(int x, int y, int z, int w) : from(x), to(y), d(z), c(w) {}\n};\n\n\nstruct state {\n  int node;\n  int v;\n  double time;\n  state(int a, int b, double c) : node(a), v(b), time(c) {}\n\n  bool operator<(const state& s) const\n  {\n    return time > s.time;\n  }\n};\n\nint main()\n{\n  int n, m;\n  while (cin >> n >> m && n != 0) {\n    int start, goal;\n    cin >> start >> goal;\n    start--;  goal--;\n\n    vector<vector<road> > g(n);\n    for (int i = 0; i < m; i++) {\n      int u, v, d, c;\n      cin >> u >> v >> d >> c;\n      u--;  v--;\n      g[u].push_back(road(u, v, d, c));\n    }\n\n    priority_queue<state> q;\n    q.push(state(start, 0, 0.0));\n    vector<vector<double> > costs(n, vector<double>(32, 1e10));\n    costs[0][0] = 0;\n    while (!q.empty()) {\n      state s = q.top();\n      q.pop();\n\n      if (s.node == goal) {\n        if (s.v == 1) {\n          printf(\"%.4f\\n\", s.time);\n          goto NEXT;\n        }\n      }\n\n      for (int i = 0; i < g[s.node].size(); i++) {\n        const road r = g[s.node][i];\n        for (int dv = -1; dv <= 1; dv++) {\n          const int v = s.v + dv;\n          if (v <= 0 || v > r.c) {\n            continue;\n          }\n          double c = double(r.d) / v;\n          if (s.time + c < costs[r.to][v]) {\n            costs[r.to][v] = s.time + c;\n            q.push(state(r.to, v, s.time + c));\n          }\n        }\n      }\n    }\n    cout << \"unreachable\" << endl;\nNEXT:\n    ;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint n, m, s, g;\n\nstruct S{\n    int to;\n    double cost;\n    int speed;\n    int prev;\n    //このままソートするとコストの昇順になる。priority_queueだと逆になる\n    //priority_queue<S, vector<S>, greater<S> >の時はoperator>を定義しないと壊れる\n    bool operator<(const S &s) const{\n        return cost > s.cost;\n    }\n};\nstruct edge{\n   int to, len, speed;\n};\n\nvector<edge> G[31];\ndouble d[31][31];\n\nvoid dijkstra(int s){\n    rep(i, 0, n) rep(j, 0, 31) d[i][j] = INF;\n    d[s][0] = 0;\n    priority_queue<S> q;\n    q.push({s, 0, 0, -1});\n    while(!q.empty()){\n        S p = q.top(); q.pop();\n        int from = p.to;\n        double cost = p.cost;\n        int speed = p.speed;\n        int prv = p.prev;\n        if(d[from][speed] < cost) continue;\n        rep(i, 0, G[from].size()){\n            edge e = G[from][i];\n            int next = e.to;\n            if(prv == next) continue;\n            for(int j = -1; j <= 1; j++){\n                if(speed + j < 0 || speed + j > 30) continue;\n                if(speed + j > e.speed) continue;\n                double newCost = (double)e.len / (double)(speed + j) + cost;\n                if(d[next][speed + j] > newCost){\n                    // cout << next << ' ' << speed + j << ' ' << newCost << endl;\n                    d[next][speed + j] = newCost;\n                    q.push({next, newCost, speed + j, from});\n                } \n            }\n        }\n    }\n}\n\nsigned main(){\n    while(1){\n        cin >> n >> m;\n        if(n + m == 0) break;\n        cin >> s >> g;\n        s--; g--;\n        rep(i, 0, n) G[i].clear();\n        rep(i, 0, m){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            G[x].push_back({y, d, c});\n            G[y].push_back({x, d, c});\n        }\n        dijkstra(s);\n        double ans = d[g][1];\n        if(ans > INF - 1) cout << \"unreachable\" << endl;\n        else printf(\"%.10f\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nconst int MAX = 35;\nconst int INF = (1<<25);\nint n,m;\n\nstruct Edge{\n  int to;\n  double dis,lim;\n  Edge(int a, double b, double c):to(a),dis(b),lim(c){}\n};\n\nstruct State{\n  int pos,from;\n  double speed,t;\n  State(int a, double b, double c, int f):pos(a),speed(b),t(c),from(f){}\n  bool operator < (const State& s) const{ return t > s.t;}\n};\n\nvector<Edge> E[MAX];\ndouble T[MAX][MAX];\n//T[i][j] := shortest time to i with speed j.\n\n\nvoid init(){\n  for(int i = 0; i < MAX; i++){\n    fill(T[i],T[i]+MAX,(double)INF);\n    E[i].clear();\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++){\n    int x,y;\n    double d,c;\n    cin >> x >> y >> d >> c;\n    //   cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    E[x].push_back(Edge(y,d,c));\n    E[y].push_back(Edge(x,d,c));\n  }\n}\n\nvoid solve(int s, int g){\n\n  priority_queue<State> Q;\n  T[s][0] = 0;\n  Q.push(State(s,0,0,-1));\n\n  while(!Q.empty()){\n    State sta = Q.top();\n    Q.pop();\n\n    if(sta.t > T[sta.pos][(int)sta.speed]) continue;\n\n    for(int i = 0; i < E[sta.pos].size(); i++){\n      int np = E[sta.pos][i].to;\n\n      if(np == sta.from) continue;\n\n      double sp[] = {-1,0,1};\n      \n      for(int j = 0; j < 3; j++){\n\tdouble ns = sta.speed+sp[j];\n\tif(ns <= 0 || ns > E[sta.pos][i].lim) continue;\n\tdouble nt = sta.t+E[sta.pos][i].dis/ns;\n\tif(T[np][(int)ns] > nt){\n\t  T[np][(int)ns] = nt;\n\t  Q.push(State(np,ns,nt,sta.pos));\n\t}\n      }\n    }\n  }\n  \n\n  if(T[g][1] == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.5f\\n\",T[g][1]);\n}\n\nint main(){\n\n  while(cin >> n >> m && n+m){\n    init();\n    int s,g;\n    cin >> s >> g;\n    input();\n    solve(s,g);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m;\nll s, g;\n\nclass DK {\npublic:\n\tstruct edge {\n\t\tint to;\n\t\tdouble cost;\n\t\tll cap;\n\t\tedge(int _to, double _cost, ll _cap) :to(_to), cost(_cost), cap(_cap) {}\n\t};\n\n\tdouble d[110][110];\n\tvector<edge> G[110];//各頂点からの辺\n\n\tvoid dijkstra() {\n\t\trep(i, 110)rep(j, 110)d[i][j] = INF;\n\t\td[s][0] = 0;\n\n\t\ttypedef pair<pair<double, ll>, ll> PP;\n\t\tpriority_queue<PP, vector<PP>, greater<PP>> que;\n\t\tque.push({ {0, 0},s });\n\n\t\twhile (!que.empty()) {\n\t\t\tPP p = que.top();\n\t\t\tque.pop();\n\t\t\tll nn = p.second;\n\t\t\tll v = p.first.second;\n\t\t\tif (d[nn][v] < p.first.first)continue;\n\t\t\tfor (int i = 0; i < G[nn].size(); i++) {\n\t\t\t\tedge e = G[nn][i];\n\t\t\t\tFOR(j, -1, 2) {\n\t\t\t\t\tdouble nv = v + j;\n\t\t\t\t\tif (nv <= 0)continue;\n\t\t\t\t\tif (nv > e.cap)continue;\n\t\t\t\t\tif (d[e.to][(ll)nv] > d[nn][v] + e.cost / nv) {\n\t\t\t\t\t\td[e.to][(ll)nv] = d[nn][v] + e.cost / nv;\n\t\t\t\t\t\tque.push({ P(d[e.to][(ll)nv], nv),e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n};\n\nDK dk;\n\nint main() {\n\twhile (cin >> n >> m&&n + m) {\n\t\trep(i, 110)dk.G[i].clear();\n\t\tcin >> s >> g;\n\t\trep(i, m) {\n\t\t\tint x, y;\n\t\t\tll c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tdk.G[x].push_back(DK::edge(y, d, c));\n\t\t\tdk.G[y].push_back(DK::edge(x, d, c));\n\t\t}\n\t\tdk.dijkstra();\n\t\t//rep(i, n) {\n\t\t//\trep(j, 30) {\n\t\t//\t\tcout << dk.d[i + 1][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tdouble ans = dk.d[g][1];\n\t\tif ((ll)ans == INF)cout << \"unreachable\" << endl;\n\t\telse printf(\"%.10lf\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n#define N 30\n#define INF 100000\n\nstruct road{int to,cost,lim;};\nstruct situ{int v,now,from;double d;};\nbool operator < (const situ &a,const situ &b){\n\treturn a.d > b.d;\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,s,g;\n\t\tvector<road> roads[N];\n\t\tcin >> n >> m;\n\t\tif(!n&&!m) break;\n\t\tcin >> s >> g;\n\t\ts--;g--;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,c;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c);\n\t\t\tx--;y--;\n\t\t\troads[x].push_back((road){y,d,c});\n\t\t\troads[y].push_back((road){x,d,c});\n\t\t}\n\n\t\tpriority_queue<situ> que;\n\t\tfor(int i=0;i<roads[s].size();i++){\n\t\t\tint to = roads[s][i].to;\n\t\t\tint d = roads[s][i].cost;\n\t\t\tque.push((situ){1,to,s,(double)d});\n\t\t}\n\t\tdouble dist[N][N][31];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=1;k<31;k++){\n\t\t\t\t\tdist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool isClear = false;\n\t\twhile(que.size()){\n\t\t\tsitu st = que.top(); que.pop();\n\t\t\tif(dist[st.now][st.from][st.v]<st.d) continue;\n\t\t\tdist[st.now][st.from][st.v] = st.d;\n\t\t\tif(st.now==g&&st.v==1){\n\t\t\t\tprintf(\"%.5f\\n\",st.d);\n\t\t\t\tisClear = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<roads[st.now].size();i++){\n\t\t\t\tint to = roads[st.now][i].to;\n\t\t\t\tint d = roads[st.now][i].cost;\n\t\t\t\tif(to != st.from){\n\t\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\tif(st.v+j<=roads[st.now][i].lim&&st.v+j>0){\n\t\t\t\t\t\t\t//if(dist[to][st.now][st.v+j]>st.d+(double)d/(st.v+j))\n\t\t\t\t\t\t\t\tque.push((situ){st.v+j,to,st.now,st.d+(double)d/(st.v+j)});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!isClear) cout << \"unreachable\" << endl;\n\n\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nstruct edge{\n\tint to,cost,limit;\n\tedge(int t,int c,int l){\n\t\tto=t;cost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tbool visit[31][31][31];\n\tmemset(visit,false,sizeof(visit));\n\tvector<vector<edge> > E(n+1);\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in].push_back(edge(out,c,l));\n\t\tE[out].push_back(edge(in,c,l));\n\t}\n\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){\n\t\tNode t=Q.top(); Q.pop();\n\t\tif(visit[t.now][t.before][t.speed]) continue;\n\t\tvisit[t.now][t.before][t.speed]=true;\n\t\tif(t.now==g && t.speed==1){printf(\"%.12lf\\n\", t.time );  return;}\n\n\t\tint size=E[t.now].size();\n\t\tfor(int i=0;i<size;i++){\n\t\t\tint to=E[t.now][i].to;\n\t\t\tif(to==t.before) continue;\n\t\t\tif(E[t.now][i].cost>0){\n\t\t\t\tif(t.speed>=1 && E[t.now][i].limit>=t.speed){\n\t\t\t\t\tQ.push(Node(to,t.speed,t.time+E[t.now][i].cost/(double)t.speed,t.now));\n\t\t\t\t}\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed+1 && !visit[to][t.now][t.speed+1])\n\t\t\t\t\tQ.push(Node(to,t.speed+1,t.time+E[t.now][i].cost/(double)(t.speed+1.0),t.now));\n\n\t\t\t\tif(t.speed-1>=1 && !visit[to][t.now][t.speed-1] && E[t.now][i].limit>=t.speed-1)\n\t\t\t\t\tQ.push(Node(to,t.speed-1,t.time+E[t.now][i].cost/(double)(t.speed-1.0),t.now));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\"<<endl;\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\n#include<cfloat>\nusing namespace std;\n\ndouble dp[30][30][100];\n\nvoid init(){\n    for(int i = 0; i < 30; i++) for(int j = 0; j < 30; j++)\n    for(int k = 0; k < 100; k++)    dp[i][j][k] = DBL_MAX;\n}\n\nstruct data{\n    int to, d, u;\n};\n\n#define F first\n#define S second\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n+m){\n        init();\n        int s, g;   cin >> s >> g;\n        s--, g--;\n        vector<data> v[n];\n        while(m-- > 0){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--, y--;\n            v[x].push_back(data({y, d, c}));\n            v[y].push_back(data({x, d, c}));\n        }\n        // score, velocity, from, to\n        priority_queue<pair<double, pair<int, pair<int,int>>>> pq;\n        pq.push({-0.0, {0, {s, s}}});\n        dp[s][s][0] = 0;\n        while(!pq.empty()){\n            auto p = pq.top();  pq.pop();\n            double cost = -p.F;\n            int ve = p.S.F, from = p.S.S.F, pos = p.S.S.S;\n            if(dp[from][pos][ve] != cost)    continue;\n            for(int dv = -1; dv <= 1; dv++){\n                int nv = ve+dv;\n                if(nv <= 0) continue;\n                for(data d : v[pos]){\n                    if(nv > d.u)    continue;\n                    int to = d.to;\n                    if(to == from)  continue;\n                    double ncost = cost + (double)(d.d)/nv;\n                    if(dp[pos][to][nv] > ncost){\n                        dp[pos][to][nv] = ncost;\n                        pq.push({-ncost, {nv, {pos, to}}});\n                    }\n                }\n            }\n        }\n        double ans = DBL_MAX;\n        for(int i = 0; i < n; i++)  if(i != g)  ans = min(ans, dp[i][g][1]);\n        if(ans == DBL_MAX)  cout << \"unreachable\" << endl;\n        else                cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\n#define EPS 1e-5\n#define INF 1e9\n#define MAX_SPEED 30\n\nvector<vector<vector<double> > > dijk(int s_point, int s_speed, vector<vector<vector<pair<double, pair<int, int> > > > >& adj){\n  int v = adj.size();\n  int t = adj[0].size();\n  vector<vector<vector<double> > > result(v, vector<vector<double> >(v, vector<double>(t, INF)));\n  priority_queue<pair<double, pair<int, pair<int, int> > > > wait;\n  wait.push(make_pair(0, make_pair(0, make_pair(s_point, s_speed))));\n  for(int i = 0; i < v; i++){ result[s_point][i][s_speed] = 0; }\n  \n  while(!wait.empty()){\n    double nowcost = -wait.top().first;\n    int prevpoint = wait.top().second.first;\n    int nowpoint = wait.top().second.second.first;\n    int nowspeed = wait.top().second.second.second;\n    wait.pop();\n    if(result[nowpoint][prevpoint][nowspeed] + EPS < nowcost){ continue; }\n\n    \n    for(size_t i = 0; i < adj[nowpoint][nowspeed].size(); i++){\n      double nextcost = adj[nowpoint][nowspeed][i].first + nowcost;\n      int nextpoint = adj[nowpoint][nowspeed][i].second.first;\n      int nextspeed = adj[nowpoint][nowspeed][i].second.second;\n      if(nextpoint != prevpoint && result[nextpoint][nowpoint][nextspeed] - EPS > nextcost){\n        wait.push(make_pair(-nextcost, make_pair(nowpoint, make_pair(nextpoint, nextspeed))));\n        result[nextpoint][nowpoint][nextspeed] = nextcost;\n      }\n    }\n  }\n\n  return result;\n}\n\nint main(void){\n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    int s, g;\n    cin >> s >> g;\n    --s; --g;\n\n    int x, y, d, c;\n    vector<vector<vector<pair<double, pair<int, int> > > > > adjlist(n,\n                                                                     vector<vector<pair<double, pair<int, int> > > >(MAX_SPEED + 1));\n    for(int i = 0; i < m; i++){\n      cin >> x >> y >> d >> c;\n      --x; --y;\n      for(int j = 0; j <= MAX_SPEED; j++){\n        if(1 <= j - 1 && j - 1 <= c)\n          adjlist[x][j].push_back(make_pair((double)d / (j - 1), make_pair(y, j - 1)));\n        if(1 <= j && j <= c)\n          adjlist[x][j].push_back(make_pair((double)d / j, make_pair(y, j)));\n        if(j + 1 <= c)\n          adjlist[x][j].push_back(make_pair((double)d / (j + 1), make_pair(y, j + 1)));\n      }\n    }\n    double ans = INF;\n    vector<vector<vector<double> > > result = dijk(s, 0, adjlist);\n    for(int i = 0; i < n; i++){ ans = min(ans, result[g][i][1]); }\n    if(ans > INF - EPS){ cout << \"unreachable\" << endl; }\n    else{ printf(\"%.10f\\n\", ans); }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  cout << setprecision(10) << fixed;\n  for(;;){\n    int n,m,s,g;\n    cin >> n >> m;\n    if(!n) return 0;\n    cin >> s >> g;\n    vector<tuple<int,int,int> > e[32];\n    REP(i,m){\n      int x,y,d,c;\n      cin >> x >> y >> d >> c;\n      e[x].push_back(make_tuple(y,d,c));\n      e[y].push_back(make_tuple(x,d,c));\n    }\n    vector<pair<double,int> > cost[32][32];\n    REP(i,32) REP(j,32) cost[i][j].clear();\n    // pos,vel\n    priority_queue<tuple<double,int,int,int> > dijk;\n    // (negcost,from),pos,vel\n    dijk.push(make_tuple(0.0,-1,s,0));\n    while(!dijk.empty()){\n      double negcos;\n      int from,pos,vel;\n      tie(negcos,from,pos,vel)=dijk.top();\n      dijk.pop();\n      if(cost[pos][vel].empty()){\n\tcost[pos][vel].push_back(make_pair(-negcos,from));\n\tfor(auto x:e[pos]){\n\t  int to,d,c;\n\t  tie(to,d,c)=x;\n\t  if(from==to) continue;\n\t  FOR(dv,-1,2){\n\t    int nvel=vel+dv;\n\t    if(nvel<=0 || c<nvel) continue;\n\t    dijk.push(make_tuple(negcos-1.0*d/nvel,pos,to,nvel));\n\t  }\n\t}\n      }else if(cost[pos][vel].size()<2 && from!=cost[pos][vel][0].second){\n\tcost[pos][vel].push_back(make_pair(-negcos,from));\n\tfor(auto x:e[pos]){\n\t  int to,d,c;\n\t  tie(to,d,c)=x;\n\t  if(cost[pos][vel][0].second!=to) continue;\n\t  FOR(dv,-1,2){\n\t    int nvel=vel+dv;\n\t    if(nvel==0 || nvel>c) continue;\n\t    dijk.push(make_tuple(negcos-1.0*d/nvel,pos,to,nvel));\n\t  }\n\t}\n      }\n    }\n    if(cost[g][1].size()) cout << cost[g][1][0].first << endl;\n    else cout << \"unreachable\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<double, int, int, int> T;\n  \nconst ll MOD=1e9+7;\n//const ll INF=1e18;\n \nconst double INF = 1000000.0;\n  \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n \nstruct edge{ int to,d,c;};\n \n \n \nint n,m,s,g;\ndouble d[35][35][35];\ndouble mind;\n \nint main(){\n    while(true){\n        cin >> n >> m;\n        if(n + m == 0) break;\n        cin >> s >> g;\n        mind = INF;\n        vector<edge> G[35];\n        for(int i = 0;i < m;i++){\n            int a1,a2,a3,a4;\n            cin >> a1 >> a2 >> a3 >> a4;\n            edge tmp1 = {a2,a3,a4};\n            G[a1].push_back(tmp1);\n            edge tmp2 = {a1,a3,a4};\n            G[a2].push_back(tmp2);\n        }\n        for(int i = 1;i <= n;i++){\n            for(int j = 1;j <= n;j++){\n                for(int k = 0;k <= 31;k++){\n                    d[i][j][k] = INF;\n                }\n            }\n        }\n        //queue<T> que;\n        //priority_queue<T,vector<T>,greater<T> > que;\n\t\tpriority_queue<T> que;\n        for(int i = 0;i < G[s].size();i++){\n            edge e = G[s][i];\n            d[s][e.to][1] = (double) e.d;\n            que.push(make_tuple((double)e.d,1,s,e.to));\n        }\n        while(!que.empty()){\n            //T t = que.front(); que.pop();\n            T t = que.top(); que.pop();\n            double a1 = get<0>(t);\n            int a2 = get<1>(t),a3 = get<2>(t),a4 = get<3>(t);\n            if(d[a3][a4][a2] < a1 || a1 > mind)continue;\n            for(int i = 0;i < G[a4].size();i++){\n                edge e = G[a4][i];\n                if(e.to == a3) continue;\n                for(int j = -1;j <= 1;j++){\n                    int v = a2 + j;\n                    double tmp = (double)( a1 + (double)e.d / (double)v);\n            //      if(a4 == 5 && e.to == 6 && v == 1) cout << \"tmp\" << tmp << \",a1\" << a1 <<endl;\n                    if(v <= 0 || v > e.c || d[a4][e.to][v] < tmp ||tmp > mind) continue;\n                    d[a4][e.to][v] =  tmp;\n                    if(e.to == g && v == 1 && mind > tmp)mind = tmp;\n                    que.push(make_tuple(tmp,v,a4,e.to));\n                }\n            }\n         \n         \n        }\n    //  cout << \"ans\" << d[4][5][2] << endl;\n \n \n \n        double ans = INF;\n        for(int i = 1;i <= n;i++){\n            double tmp = d[i][g][1];\n            if(ans > tmp) ans = tmp;\n        //  ans = min(ans,d[i][g][1]);\n        }\n        if(ans == INF){\n            cout << \"unreachable\" << endl;\n        }else{\n        //  cout << ans << endl;\n            printf(\"%lf\\n\",ans);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint n, m;\nint s, g;\nconst double INF = 1e10;\n\nstruct edge {\n    int to;\n    int dist;\n    int limit;\n    edge() {}\n    edge(int t, int d, int c) : to(t), dist(d), limit(c) {}\n};\n\nstruct Node {\n    int cur;\n    int par;\n    int v;\n    double time;\n    Node() {}\n    Node(int a, int b, int c, double t) : cur(a), par(b), v(c), time(t) {}\n};\n\nbool operator<(const Node& lhs, const Node& rhs) {\n    return lhs.time < rhs.time;\n}\nbool operator>(const Node& lhs, const Node& rhs) {\n    return lhs.time > rhs.time;\n}\n\nvector<edge> G[32];\n\ndouble solve(int s, int t) {\n    double d[32][32][32];\n    for (int i = 0; i < 32; i++) {\n        for (int j = 0; j < 32; j++) {\n            for (int k = 0; k < 32; k++) {\n                d[i][j][k] = INF;\n            }\n        }\n    }\n    d[s][0][0] = 0;\n    priority_queue<Node, vector<Node>, greater<Node> > que;\n    que.push(Node(s, 0, 0, 0));\n    while (!que.empty()) {\n        Node node = que.top(); que.pop();\n        //cout << node.cur << \"\\t\" << node.par << \"\\t\" << node.v << \"\\t\" << node.time << endl;\n        if (node.cur == t && node.v == 1) return node.time;\n        if (d[node.cur][node.par][node.v] < node.time) continue;\n        for (int i = 0; i < G[node.cur].size(); i++) {\n            edge e = G[node.cur][i];\n            if (e.to == node.par) continue;\n            for (int k = -1; k <= 1; k++) {\n                int nv = node.v+k;\n                if (nv <= 0) continue;\n                if (nv > e.limit) break;\n                double t = node.time + (1.0 * e.dist) / nv;\n                if (t < d[e.to][node.cur][nv]) {\n                    d[e.to][node.cur][nv] = t;\n                    que.push(Node(e.to, node.cur, nv, t));\n                }\n            }\n        }\n    }\n    return INF;\n}\n\nint main() {\n    while (cin >> n >> m) {\n        if (n == 0 && m == 0) break;\n        cin >> s >> g;\n        for (int i = 0; i < 32; i++) G[i].clear();\n        for (int i = 0; i < m; i++) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            edge e(y, d, c);\n            G[x].push_back(e);\n            e.to = x;\n            G[y].push_back(e);\n        }\n        double ans = solve(s, g);\n        if (ans >= INF) cout << \"unreachable\" << endl;\n        else printf(\"%.10lf\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\n\nconst ld INF = 10e+20;\nconst ll LIM = 100 * 1000;\nconst char UNREACHABLE[] = \"unreachable\";\n\nint solve(void);\n\nstruct lll {\n\tll from;\n\tll from_from;\n\tll spd;\n};\n\nint main(void)\n{\n\twhile (solve())\n\t{\n\t}\n\treturn 0;\n}\n\nint solve(void)\n{\n\tll n, m, s, g;\n\tconst ll spd_max = 31;\n\n\tcin >> n >> m;\n\tif(!(n|m)) { return 0; }\n\t\n\tcin >> s >> g;\n\n\tvector<ll> x(m), y(m), d(m), c(m);\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tcin >> x[i] >> y[i] >> d[i] >> c[i];\n\t}\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tx.push_back(y[i]);\n\t\ty.push_back(x[i]);\n\t\td.push_back(d[i]);\n\t\tc.push_back(c[i]);\n\t}\n\t\n\t// dp[都市ID][更にひとつ前の都市ID][到着時の速度] = 最小所要時間\n\tvector<vector<vector<ld>>> dp(n+1, vector<vector<ld>>(n+1, vector<ld>(spd_max, INF)));\n\tdp[s][s][0] = 0.0f;\n\n\tqueue<lll> q;\n\tq.push(lll{s, s, 0});\n\n\twhile (!q.empty())\n\t{\n\t\tconst auto t = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < x.size(); i++)\n\t\t{\n\t\t\tif ( x[i] != t.from ) { continue; }\n\t\t\tif ( y[i] == t.from_from ) { continue; }\n\t\t\tfor (int j = -1; j <= 1; j++)\n\t\t\t{\n\t\t\t\tconst ll v = j + t.spd;\n\t\t\t\tif( v <= 0 || v >= spd_max ) { continue; }\n\t\t\t\tif( v > c[i] ) { continue; }\n\t\t\t\tconst ld arrival_time\n\t\t\t\t\t= (ld)(d[i])/(ld)(v) + dp[t.from][t.from_from][t.spd];\n\t\t\t\tif (arrival_time < dp[y[i]][t.from][v])\n\t\t\t\t{\n\t\t\t\t\tdp[y[i]][t.from][v] = arrival_time;\n\t\t\t\t\tq.push(lll{y[i], t.from, v});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tld ans = INF;\n\tfor(int i = 1; i <= n; i++)\n\t\tans = min(dp[g][i][1], ans);\n\n\tif (ans == INF)\n\t{\n\t\tcout << UNREACHABLE << endl;\n\t}\n\telse\n\t{\n\t\tcout << fixed << setprecision(12) << ans << endl;\n\t}\n\n\treturn 1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint N,M;\nint S,G;\n\nvector<tuple<int,int,int>> g[30];\n#define mkt make_tuple\n#define INF 1e9\n\ndouble dist[31][31][31];\n\ndouble dijkstra(){\n    for(int i=0;i<N;i++) for(int j=0;j<N;j++) for(int k=0;k<=30;k++) dist[i][j][k]=INF;\n    priority_queue<tuple<double,int,int,int>> PQ;\n    for(int i=0;i<g[S].size();i++){\n        int nex=get<0>(g[S][i]);\n        double d=get<1>(g[S][i]);\n        dist[nex][S][1]=d;\n        PQ.push(mkt(-d,nex,S,1));\n    }\n\n    while(!PQ.empty()){\n        auto f=PQ.top();\n        PQ.pop();\n\n        double co;\n        int now,pre,v;\n        co=-get<0>(f);\n        now=get<1>(f);\n        pre=get<2>(f);\n        v=get<3>(f);\n\n        if(dist[now][pre][v]<co) continue;\n        if(now==G&&v==1) return co;\n\n        for(int i=0;i<g[now].size();i++){\n            int nex=get<0>(g[now][i]);\n            int lim=get<2>(g[now][i]);\n            double d=get<1>(g[now][i]);\n\n            if(nex==pre) continue;\n\n            for(int i=-1;i<=1;i++){\n                int nv=v+i;\n                if(nv<=0||nv>lim) continue;\n                \n                double neco=d/nv;\n                if(dist[nex][now][nv]<=co+neco) continue;\n                dist[nex][now][nv]=co+neco;\n                PQ.push(mkt(-(co+neco),nex,now,nv));\n            }\n        }\n    }\n    return -1;\n}\n\nvoid solve(){\n    cin>>S>>G;\n    S--;G--;\n    for(int i=0;i<30;i++) g[i].clear();\n    for(int i=0;i<M;i++){\n        int x,y,c;\n        double d;\n        cin>>x>>y>>d>>c;\n        x--;y--;\n        g[x].push_back(mkt(y,d,c));\n        g[y].push_back(mkt(x,d,c));\n    }\n\n    double ans;\n    ans=dijkstra();\n    if(ans==-1) cout<<\"unreachable\"<<endl;\n    else cout<<fixed<<setprecision(10)<<ans<<endl;\n}\n\nint main(){\n  while(1){\n      cin>>N>>M;\n      if(N==0&&M==0) break;\n      solve();\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<tuple<int,int,int>> City;//to,limit,distance\nvector<City> C;\ntypedef tuple<double,int,int,int> T;//time,cityid,speed,prev\npriority_queue<T,vector<T>,greater<T>> que;\ndouble memo[30][31];//[cityid][speed]\n\nint main(){\n    cout.precision(5);\n    cout<<fixed;\n    int n,m;\n    while(cin>>n>>m,n){\n        int s,g;\n        cin>>g>>s;\n        s--;g--;\n        C.clear();\n        for(int i=0;i<n;i++) C.push_back(City());\n        for(int i=0;i<m;i++){\n            int x,y,d,c;\n            cin>>x>>y>>d>>c;\n            x--;y--;\n            C[x].emplace_back(y,c,d);\n            C[y].emplace_back(x,c,d);\n        }\n        fill(memo[0],memo[30],1e8);\n        memo[s][0]=0;\n        while(!que.empty())que.pop();\n        que.emplace(0,s,0,-1);\n        double ans=1e8;\n        while(!que.empty()){\n            T t=que.top(); que.pop();\n            double time=get<0>(t);\n            int cityid=get<1>(t);\n            int speed=get<2>(t);\n            int prev=get<3>(t);\n            if(time>memo[cityid][speed]) continue;\n            if(cityid==g&&speed==1){\n                ans=time;\n                break;\n            }\n            for(auto& e:C[cityid]){\n                int to=get<0>(e);\n                int limit=get<1>(e);\n                double distance=get<2>(e);\n                if(to==prev)continue;\n                if(speed+1<=limit){\n                    if(memo[to][speed+1]>time+distance/(speed+1)){\n                        memo[to][speed+1]=time+distance/(speed+1);\n                        que.emplace(memo[to][speed+1],to,speed+1,cityid);\n                    }\n                }\n                if(speed<=limit&&speed>0){\n                    if(memo[to][speed]>time+distance/(speed)){\n                        memo[to][speed]=time+distance/(speed);\n                        que.emplace(memo[to][speed],to,speed,cityid);\n                    }\n                }\n                if(speed-1<=limit&&speed-1>0){\n                    if(memo[to][speed-1]>time+distance/(speed-1)){\n                        memo[to][speed-1]=time+distance/(speed-1);\n                        que.emplace(memo[to][speed-1],to,speed-1,cityid);\n                    }\n                }\n            }\n        }\n        if(ans==1e8){\n            cout<<\"unreachable\"<<endl;\n        }else{\n            cout<<ans<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector< vector<int> > vvi;\n\nint dist[31][31];\nint cap[31][31];\nbool visit[31][31]; // city, speed\nconst int INF = 1e7;\n\nstruct node {\n\tint s, p, c;\n\tdouble t;\n\tnode(int _s, int _p, int _c, double _t) {\n\t\ts = _s;\n\t\tp = _p;\n\t\tc = _c;\n\t\tt = _t;\n\t}\n};\nbool operator<(const node& l, const node& r) {\n\treturn l.t > r.t;\n}\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\trep(i,31) rep(j,31) dist[i][j] = cap[i][j] = INF;\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\trep(i, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tdist[x][y] = dist[y][x] = d;\n\t\t\tcap[x][y] = cap[y][x] = c;\n\t\t}\n\t\tpriority_queue<node> que;\n\t\tvisit[s][1] = true;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tif( dist[s][i] < INF && 1 <= cap[s][i] ) {\n\t\t\t\tque.push( node(1, i, s, 1.*dist[s][i]) );\n\t\t\t}\n\t\t}\n\t\tbool found = false;\n\t\twhile(!que.empty()) {\n\t\t\tnode nd = que.top();\n\t\t\tque.pop();\n\t\t\tif( nd.p==g && nd.s==1 ) {\n\t\t\t\tcout << nd.t << endl;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( visit[nd.p][nd.s] ) continue;\n\t\t\tvisit[nd.p][nd.s] = true;\n\t\t\tfor(int nxt=1; nxt<=n; nxt++) {\n\t\t\t\tif( nd.c == nxt ) continue;\n\t\t\t\tfor(int sp=max(1,nd.s-1); sp<=min(30,nd.s+1); sp++) {\n\t\t\t\t\tif( !visit[nxt][sp] && dist[nd.p][nxt] < INF && sp <= cap[nd.p][nxt] ) {\n\t\t\t\t\tdouble nt = nd.t + 1.*dist[nd.p][nxt]/sp;\n\t\t\t\t\t\tque.push(node(sp, nxt, nd.p, nt));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!found) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> Pi;\ntypedef pair<double, int> Pd;\ntypedef pair<Pd, Pi> PP;\n\nstruct edge {\n  int to, lim;\n  double dist;\n  edge(){}\n  edge(int to, int lim, double dist):to(to), lim(lim), dist(dist){}\n};\n\nvector< vector<edge> > G;\ndouble mint[33][33][33];\nint n, m, s, g;\n\nconst double inf = 1 << 25;\n\nvoid init()\n{\n  for(int i = 0; i < 33; i++) {\n    for(int j = 0; j < 33; j++) {\n      for(int k = 0; k < 33; k++) mint[i][j][k] = inf;\n    }\n  }\n}\n\nvoid dijkstra()\n{\n  init();\n  priority_queue<PP, vector<PP>, greater<PP> > que;\n  mint[s][0][0] = 0.0;\n  que.push(PP(Pd(0.0, 0), Pi(s, 0)));\n  while(!que.empty()) {\n    PP p = que.top(); que.pop();\n    int now = p.second.first, prev = p.second.second, v = p.first.second;\n    double t = p.first.first;\n    if(now == g && v == 1) continue;\n    if(mint[now][prev][v] < t) continue;\n    for(int i = 0; i < G[now].size(); i++) {\n      edge e = G[now][i];\n      if(e.to == prev) continue;\n      for(int d = -1; d <= 1; d++) {\n\tif(v+d <= 0 || e.lim < v+d) continue;\n\tif(t + e.dist/(v+d) < mint[e.to][now][v+d]) {\n\t  mint[e.to][now][v+d] = t + e.dist/(v+d);\n\t  que.push(PP(Pd(mint[e.to][now][v+d], v+d), Pi(e.to, now)));\n\t}\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(cin >> n >> m, n) {\n    cin >> s >> g;\n    G.clear(); G.resize(n + 1);\n    while(m--) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      G[x].push_back(edge(y, c, d));\n      G[y].push_back(edge(x, c, d));\n    }\n    dijkstra();\n    double ans = inf;\n    for(int i = 1; i <= n; i++) ans = min(ans, mint[g][i][1]);\n    if(ans == inf) puts(\"unreachable\");\n    else printf(\"%.12f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define NODE 30\n#define LIM 31\nconst double inf = 1e200;\n\nclass state{\npublic:\n  int cur,prev,speed;\n  double c;\n  state(){};\n  state(int tcur,int tprev,int tspeed,double tc):cur(tcur),prev(tprev),\n\t\t\t\t\t\t speed(tspeed),c(tc){};\n  bool operator<(const state & a)const{\n    return c >a.c;\n  }\n};\n\ndouble cost[30][30][31];\ndouble dist[30][30];\nint lim[30][30];\n\n\nvoid solve(int n,int s,int g){\n  rep(i,n)rep(j,n)rep(k,31)cost[i][j][k]=inf;\n  priority_queue<state> Q;\n  rep(i,n){\n    if ( lim[s][i] >= 1){\n      cost[i][s][1]=dist[s][i];\n      Q.push(state(i,s,1,cost[i][s][1]));\n    }\n  }\n\n  while(!Q.empty()){\n    state now = Q.top();\n    Q.pop();\n    if ( cost[now.cur][now.prev][now.speed] <now.c)continue;\n    if ( now.cur == g && now.speed == 1){\n      printf(\"%.3lf\\n\",now.c);\n      return;\n    }\n    rep(i,n){\n      if ( i == now.prev)continue;\n      REP(j,-1,2){\n\tif ( now.speed + j > 0 && now.speed + j <= lim[now.cur][i] &&\n\t     cost[i][now.cur][now.speed+j] > now.c + dist[now.cur][i]/(now.speed+j)){\n\t  cost[i][now.cur][now.speed+j]=now.c+dist[now.cur][i]/(now.speed+j);\n\t  Q.push(state(i,now.cur,now.speed+j,cost[i][now.cur][now.speed+j]));\n\t}\n      }\n    }\n  }\n  \n\n  puts(\"unreachable\");\n  \n}\n\n\nmain(){\n  int n,m;\n  while(cin>>n>>m && n){\n    rep(i,n)rep(j,n)lim[i][j]=0,dist[i][j]=inf;\n    int s,g;\n    cin>>s>>g;\n    s--;g--;\n    rep(i,m){\n      int f,t,v;\n      double d;\n      cin>>f>>t>>d>>v;\n      f--;t--;\n      dist[f][t]=dist[t][f]=d;\n      lim[f][t]=lim[t][f]=v;\n    }\n    solve(n,s,g);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\nusing namespace std;\n#define INF 1000000000\nint n,m;\nint G[50][50];\nint res[50][50];\ndouble memo[50][50][50]; //????????????????????????????????????\n \nstruct node{\n  int s,g,v;\n  node(int s=0,int g=0,int v=0):s(s),g(g),v(v){}\n};\n \nbool operator < (node a,node b){\n  return memo[a.s][a.g][a.v] > memo[b.s][b.g][b.v];\n}\n \ndouble solve(int s,int g){\n  for(int i=0;i<50;++i) for(int j=0;j<50;++j) for(int k=0;k<50;++k) memo[i][j][k] = INF;\n  memo[s][s][0] = 0;\n  bool used[50][50][50];\n  memset(used,0,sizeof(used));\n \n  priority_queue<node> St;\n  St.push(node(s,s,0));\n \n  while(!St.empty()){\n    node now = St.top();\n    St.pop();\n    double mincost = memo[now.s][now.g][now.v];\n    int id1 = now.s;\n    int id2 = now.g;\n    int id3 = now.v;\n    for(int i=0;i<n;++i){\n      if(!G[id2][i] || i==id1) continue;\n      for(int j=-1;j<=1;++j){\n\tint nxtv = id3+j;\n\tif(nxtv<=0 || nxtv > res[id2][i]) continue;\n\tif(memo[id2][i][nxtv] > mincost + (double)G[id2][i]/nxtv){\n\t  memo[id2][i][nxtv] = mincost + (double)G[id2][i]/nxtv;\n\t  St.push(node(id2,i,nxtv));\n\t}\n      }\n    }\n  }\n  double ret = INF;\n  for(int i=0;i<n;++i){\n    ret = min(ret,memo[i][g][1]);\n  }\n  return ret;\n}\n \n \nint main(){\n  while(scanf(\"%d%d\",&n,&m),n||m){\n    memset(G,0,sizeof(G));\n    memset(res,0,sizeof(res));\n    int s,g;\n    scanf(\"%d%d\",&s,&g);\n    s--;\n    g--;\n    while(m--){\n      int x,y,d,c;\n      scanf(\"%d%d%d%d\",&x,&y,&d,&c);\n      x--;\n      y--;\n      G[x][y] = G[y][x] = d;\n      res[x][y] = res[y][x] = c;\n    }\n \n    double ans = solve(s,g);\n    if(ans==INF) printf(\"unreachable\\n\");\n    else printf(\"%lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 91 // いつもは1<<29だが小さくすれば時間はやくなる？\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[40];    \n    \n    int inx,iny,ind,inc;\n    double d[40][40][40];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define D first\n#define C second\n\nusing namespace std;\n\nconst double INF = 1000000000.0;\n\n//test\nvector<string> sv;\n\ndouble d[35][35][35];\nbool visited[35][35][35];\nint N,M,S,G;\npair<int, int> p[35][35];\n\nstruct ST{\n  double ti;\n  int bn;\n  int cn;\n  int sp;\n  ST(double _ti, int _bn, int _cn, int _sp){\n    ti = _ti;\n    bn = _bn;\n    cn = _cn;\n    sp = _sp;\n  }\n  bool operator >(const ST &e) const{\n    return ti > e.ti;\n  }\n};\n\nint main() {\n  while(1){\n    cin>>N>>M;\n    if(N==0 && M==0) break;\n    cin>>S>>G;\n    S--; G--;\n\n    REP(i,0,N)REP(j,0,N)REP(k,0,35) d[i][j][k] = INF;\n    REP(i,0,N)REP(j,0,N)REP(k,0,35) visited[i][j][k] = false;\n    REP(i,0,N)REP(j,0,N) p[i][j].D = p[i][j].C = -1;\n\n    bool flag = true;\n\n    REP(i,0,M){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      p[x-1][y-1].D = p[y-1][x-1].D = d;\n      p[x-1][y-1].C = p[y-1][x-1].C = c;\n    }\n\n    d[S][S][0] = 0.0;\n\n    priority_queue< ST, vector<ST>, greater<ST> > PQ;\n    ST st(0.0,S,S,0);\n    PQ.push(st);\n\n\n    while(!PQ.empty()){\n      ST u = PQ.top(); PQ.pop();\n      double mtime = u.ti;\n      int ubn=u.bn, ucn=u.cn, usp=u.sp;\n      //visited[ubn][ucn][usp] = true;\n      if(d[ubn][ucn][usp] < mtime) continue;\n      //cout<<\"POP! \"<<\"u.ti: \"<<u.ti<<\"; u.bn: \"<<u.bn<<\"; u.cn: \"<<u.cn<<\"; u.sp: \"<<u.sp<<endl;\n\n      if(ucn == G && usp == 1){\n        //printf(\"%.5lf\\n\",d[ubn][ucn][usp]);\n        sv.push_back(to_string(mtime));\n        flag = false;\n        break;\n      }\n\n      visited[ubn][ucn][usp] = true;\n      for(int v = usp-1; v <= usp+1; v++){\n        if(v <= 0) continue;\n        REP(next,0,N){\n          if(/*visited[ucn][next][v] ||*/ p[ucn][next].D == -1 || p[ucn][next].C < v || ucn == next) continue;\n          if(ubn == next) continue; //Uturn\n          if(d[ucn][next][v] > mtime + (double)p[ucn][next].D/(double)v){\n            d[ucn][next][v] = mtime + (double)p[ucn][next].D/(double)v;\n            ST tst(d[ucn][next][v], ucn,next,v);\n            PQ.push(tst);\n            //cout<<\"PUSH! \"<<\"u.ti: \"<<d[ucn][next][v]<<\"; u.bn: \"<<ucn<<\"; u.cn: \"<<next<<\"; u.sp: \"<<v<<endl;\n          }\n        }\n      }\n\n    }\n    if(flag){\n      //cout<<\"unreachable\"<<endl;\n      sv.push_back(\"unreachable\");\n    }\n  }\n\n  REP(i,0,sv.size()) cout<<sv[i]<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define MAX 35\n#define INF 1e9\n#define F first\n#define S second\ntypedef pair<double,int> pdi;\ntypedef pair<int,int> pii;\ntypedef pair<pdi,pii> State;\n  \nstruct Edge{\n    int to,d,c;\n    Edge(int to,int d,int c) : to(to),d(d),c(c) {}\n};\n  \nint N,M,s,g;\nvector<Edge> G[MAX];\n  \ndouble dijkstra(){\n    priority_queue<State,vector<State>,greater<State> > Q;\n    Q.push(State(pdi(0,s),pii(1,N)));\n    double Time[MAX][MAX][MAX];\n    fill(Time[0][0],Time[0][0]+MAX*MAX*MAX,INF);   \n    Time[s][1][N] = 0;\n  \n    while(!Q.empty()){\n\tState p = Q.top(); Q.pop();\n\tint v = p.F.S, vel = p.S.F;\n\tif(Time[v][vel][p.S.S] < p.F.F) continue;\n \n\tif(v == g && vel == 1){\n\t    return Time[g][1][p.S.S];\n\t}\n  \n\tfor(int i = 0 ; i < (int)G[v].size() ; i++){\n\t    for(int j = -1 ; j <= 1 ; j++){\n\t\tif(vel+j <= 0) continue;\n\t\tif(Time[v][vel][p.S.S] == 0 && j){\n\t\t    continue;\n\t\t}\n\t\tEdge e = G[v][i];\n\t\tif(e.to == p.S.S) continue;\n\t\tdouble t = (double)e.d/(vel+j);\n\t\tif(vel+j <= e.c && \n\t\t   Time[v][vel][p.S.S] + t < Time[e.to][vel+j][v]){\n\t\t    Time[e.to][vel+j][v] = Time[v][vel][p.S.S] + t;\n\t\t    Q.push(State(pdi(Time[e.to][vel+j][v],e.to),pii(vel+j,v)));\n\t\t}\n\t    }\n\t}\n    }\n    return INF;\n}\n  \nint main(){\n    int x,y,d,c;\n    while(cin >> N >> M, N){\n\tfor(int i = 0 ; i < MAX ; i++){\n\t    G[i].clear();\n\t}\n\tcin >> s >> g; s--; g--;\n\tfor(int i = 0 ; i < M ; i++){\n\t    cin >> x >> y >> d >> c;\n\t    x--; y--;\n\t    G[x].push_back(Edge(y,d,c));\n\t    G[y].push_back(Edge(x,d,c));\n\t}\n\tdouble res = dijkstra();\n\tif(res == INF){\n\t    cout << \"unreachable\" << endl;\n\t}else{\n\t    printf(\"%.8f\\n\",res);\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nstruct NODE{\n\tint from,to,speed;\n\tdouble cost;\n\tNODE(int from,int to,int speed,double cost) : from(from) , to(to) , speed(speed) , cost(cost) {\n\t}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\n\n\nvector< vector<NODE> > G;\nbool done[32][32][1000] = {};\nbool done2[32];\n\nbool dfs(int x,int y){\n\tif( x == y ) return true;\n\tif( done2[x] ) return false;\n\tdone2[x] = true;\n\tfor(int i = 0 ; i < G[x].size() ; i++)\n\t\tif( dfs(G[x][i].to,y) ) return true;\n\treturn false;\n}\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m && n){\n\t\tmemset(done,0,sizeof(done));\n\t\tmemset(done2,0,sizeof(done2));\n\t\tint s,g;\n\t\tcin >> s >> g;\n\t\ts--,g--;\n\t\tG.clear();\n\t\tG.resize(n);\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c,d;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--,b--;\t\n\t\t\tG[a].push_back(NODE(a,b,c,d));\n\t\t\tG[b].push_back(NODE(b,a,c,d));\n\t\t\t//cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n\t\t}\n\t\tif( !dfs(s,g) ){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tpriority_queue<NODE> Q;\n\t\t\n\t\tQ.push(NODE(n,s,0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( q.speed >= 1000) continue;\n\t\t\tif( done[q.from][q.to][q.speed] ) continue;\n\t\t\telse done[q.from][q.to][q.speed] = true;\n\t\t\tif( q.to == g && q.speed == 1 ){\n\t\t\t\tprintf(\"%.10lf\\n\",q.cost);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < G[q.to].size() ; i++){\n\t\t\t\tif( q.speed+0 > 0 && q.speed+0 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed+0,q.cost+G[q.to][i].cost / (q.speed+0)));\n\t\t\t\tif( q.speed+1 > 0 && q.speed+1 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed+1,q.cost+G[q.to][i].cost / (q.speed+1)));\n\t\t\t\tif( q.speed-1 > 0 && q.speed-1 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed-1,q.cost+G[q.to][i].cost / (q.speed-1)));\n\t\t\t}\n\t\t}\n\t\tcout << \"unreachable\" << endl;\n\t\texit:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct road {\n  int from, to, d, c;\n  road(int x, int y, int z, int w) : from(x), to(y), d(z), c(w) {}\n};\n\n\nstruct state {\n  int node;\n  int prev;\n  int v;\n  double time;\n  state(int a, int p, int b, double c) : node(a), prev(p), v(b), time(c) {}\n\n  bool operator<(const state& s) const\n  {\n    return time > s.time;\n  }\n};\n\nint main()\n{\n  int n, m;\n  while (cin >> n >> m && n != 0) {\n    int start, goal;\n    cin >> start >> goal;\n    start--;  goal--;\n\n    vector<vector<road> > g(n);\n    for (int i = 0; i < m; i++) {\n      int u, v, d, c;\n      cin >> u >> v >> d >> c;\n      u--;  v--;\n      g[u].push_back(road(u, v, d, c));\n    }\n\n    priority_queue<state> q;\n    q.push(state(start, -1, 0, 0.0));\n    vector<vector<double> > costs(n, vector<double>(32, 1e10));\n    costs[0][0] = 0.0;\n    while (!q.empty()) {\n      state s = q.top();\n      q.pop();\n\n      if (s.node == goal) {\n        if (s.v == 1) {\n          printf(\"%.4f\\n\", s.time);\n          goto NEXT;\n        }\n      }\n\n      for (int i = 0; i < g[s.node].size(); i++) {\n        const road r = g[s.node][i];\n        for (int dv = -1; dv <= 1; dv++) {\n          const int v = s.v + dv;\n          if (v <= 0 || v > r.c) {\n            continue;\n          }\n          if (r.to == s.prev) {\n            continue;\n          }\n          double c = double(r.d) / v;\n          if (s.time + c < costs[r.to][v]) {\n            costs[r.to][v] = s.time + c;\n            q.push(state(r.to, s.node, v, s.time + c));\n          }\n        }\n      }\n    }\n    cout << \"unreachable\" << endl;\nNEXT:\n    ;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\n\nstruct data{\n    int to, cost, limit;\n};\n\nstruct edge{\n    int now, speed;\n    double cost;\n\n    bool operator>(const edge &e) const {\n      return cost + EPS > e.cost;\n    }\n\n};\n\n\n\nint main(void) {\n    int i,j;\n    int n, m;\n    while(cin >> n >> m, n){\n        int s,g;\n        cin >> s >> g;\n        s--,g--;\n\n        vector<vector<data> > v(n);\n\n        rep(i,m){\n            int a,b;\n            struct data d;\n            cin >> a >> b >> d.cost >> d.limit;\n            a--,b--;\n            d.to = b;\n            v[a].push_back(d);\n            d.to = a;\n            v[b].push_back(d);\n        }\n\n        vector<vd> dist(30,vd(30,INF));\n        dist[s][1] = 0;\n        priority_queue< edge, vector<edge>, greater<edge> > q;\n\n        struct edge e;\n        e.now = s;\n        e.speed = 0;\n        e.cost = 0;\n\n        q.push(e);\n        dist[e.now][e.speed] = e.cost;\n\n        double ans = -1;\n\n        while(q.size()){\n            struct edge e = q.top();\n            q.pop();\n\n            if(dist[e.now][e.speed] + EPS < e.cost)continue;\n\n            for(int i = 0; i < v[e.now].size(); i++){\n                struct edge next;\n                next.now = v[e.now][i].to;\n                double d = v[e.now][i].cost;\n\n                for(int j = -1; j <= 1; j++){\n                    next.speed = e.speed + j;\n                    if(next.speed > v[e.now][i].limit || next.speed <= 0)continue;\n                    next.cost = dist[e.now][e.speed] + d / next.speed;\n\n                    if(next.now == g && next.speed == 1){\n                        if(ans < 0 || ans + EPS > next.cost)\n                            ans = next.cost;\n                    }\n\n                    if(dist[next.now][next.speed] > next.cost){\n                        dist[next.now][next.speed] = next.cost;\n                        q.push(next);\n                    }\n\n                }\n            }\n        }\n\n        if(ans < 0){\n            cout << \"unreachable\" << endl;\n        }else{\n            cout << shosu(10) << ans << endl;\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if(a > b){ a = b; return 1; } return 0; }\n//***********************************************************\n// Dijkstra\n//***********************************************************\ntemplate <typename X = int>\nstruct Node{ // Status of node\n  int idx; // index of node\n  vector<vector<X>> dist;\n  Node() = default;\n\n  explicit Node(int idx) : idx(idx) {}\n};\n\ntemplate <typename X = int>\nstruct Edge{ // status of edge\n  int from; \n  int to;\n  X cost;\n  int limit;\n  int idx;\n  \n  Edge() = default;\n\n  Edge(int from, int to, X cost, int limit, int idx) : from(from), to(to), cost(cost), limit(limit), idx(idx) {}\n};\n\ntemplate <typename X = int>\nstruct Status{ // entered priority_queue\n  int idx;\n  X dist;\n  int vel;\n  int before;\n  \n  Status() = default;\n\n  Status(int idx, X dist, int vel, int before) : idx(idx), dist(dist), vel(vel), before(before) {}\n\n  bool operator == (const Status& r) const {\n    return (idx == r.idx && dist == r.dist);\n  }\n\n  bool operator != (const Status& r) const {\n    return !(*this == r);\n  }\n\n  bool operator < (const Status& r) const { \n    return dist > r.dist;\n  }\n\n  bool operator > (const Status& r) const {\n    return dist < r.dist;\n  }\n  \n};\n\ntemplate <typename X = int>\nclass Graph{\nprivate:\n  int n; // number of node\n  int m; // number of edge\n  vector<vector<Edge<X>>> edge; // edge list\n  vector<Node<X>> node; // node list\n\n  vector<vector<vector<vector<X>>>> d; // (s, g, velocity) = shortest distance\n  const X inf = 1e+15; // initial value of d\n  int M = 30;\npublic:\n  explicit Graph(int n) : n(n) {\n    edge.resize(n);\n  }\n\n  Graph(int n, int m, vector<int> from, vector<int> to, vector<X> cost, vector<int> limit) : n(n), m(m) {\n    edge.resize(n);\n    rep(i,m) {\n      add_edge(from[i], to[i], cost[i], limit[i], i);\n      add_edge(to[i], from[i], cost[i], limit[i], i);      \n    }\n  }\n\n  void add_edge(int from, int to, X cost, int limit, int index) {\n    edge[from].emplace_back(from, to, cost, limit, index);\n  }\n\n  void Init_Node() {\n    rep(i,n) node.emplace_back(i);\n  }\n  \n  //*************************************\n  // dijkstra\n  // s is start node\n  //*************************************\n  void dijkstra(int s) { \n    // initalize d\n    // d.resize(n);\n    // d[s].resize(n, vector<vector<X>>(M+2, vector<X>(m+1, inf)));\n    // d[s][s][0][m] = 0;\n\n    Init_Node();\n    rep(i,n) node[i].dist.assign(M+2, vector<X>(m+1, inf));\n    node[s].dist[0][m] = 0;\n    \n    priority_queue<Status<X>> pq;\n    pq.emplace(s, 0, 0, m); // (node, distance, speed, before)\n\n    while( !pq.empty() ) {\n      Status<X> now = pq.top(); pq.pop();\n      int v = now.idx; // number of node\n      X dis = now.dist; // distance of start from node \"v\"\n      int speed = now.vel; // velocity\n      int before = now.before;\n      if(node[v].dist[speed][before] < dis) continue;\n      for(auto next: edge[v]) {\n\tint w = next.to;\n\tX cos = next.cost;\n\tint limit = next.limit;\n\tint idx = next.idx;\n\tif(idx == before) continue;\n\tfor(int i = -1; i <= 1; ++i) {\n\t  int nspeed = speed + i;\n\t  if(nspeed <= 0 || limit < nspeed) continue;\n\t  if(chmin(node[w].dist[nspeed][idx], node[v].dist[speed][before] + cos / nspeed)) {\n\t    pq.emplace(w, node[w].dist[nspeed][idx], nspeed, idx);\n\t  }\n\t}\n      }\n    }\n  }\n\n\n  X Get_d(int v, int speed, int index) {\n    //    if(d[start][goal][speed][index] == inf) return -1;\n    return node[v].dist[speed][index];\n  }\n\n  X Get_inf() { return inf; }\n};\nint main()\n{\n  vector<double> ans;\n  while(1) {\n    int n,m; cin >> n >> m;\n    if(n == 0 && m == 0) break;\n    int s,g; cin >> s >> g;\n    s--; g--;\n    vector<int> x(m), y(m), c(m);\n    vector<double> d(m);\n    rep(i,m) {\n      cin >> x[i] >> y[i] >> d[i] >> c[i];\n      x[i]--; y[i]--;\n    }\n    Graph<double> gp(n, m, x, y, d, c);\n    gp.dijkstra(s);\n    double res = gp.Get_inf();\n    rep(i,m) {\n      chmin(res, gp.Get_d(g, 1, i));\n    }\n    ans.push_back(res);\n  }\n  Graph<double> g(1);\n  rep(i,ans.size()) {\n    if(ans[i] == g.Get_inf()) cout << \"unreachable\" << \"\\n\";\n    else printf(\"%.7f\\n\", ans[i]);\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// (x,y)\ntypedef pair<int,int> P;\n// ( 速度 , (前の町,今の町) )\ntypedef pair<int,P> Node;\n// (cost,Node)\ntypedef pair<double,Node> State;\n\nconst int MAX_V = 31;\nconst double INF = 100000;\n\nstruct edge{\n\tint to, d, c;\n\tedge(int to_, int d_, int c_){\n\t\tto = to_; d = d_; c = c_;\n\t}\n};\n\n// グラフ\nvector<edge> G[MAX_V];\n// スタートからゴールに辿りつけるかどうか\nbool is_connect;\n\n// 入力\nint n, m;\n\n// 初期化\nvoid init(){\n\tis_connect = false;\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tG[i].clear();\n\t}\n}\n\n// 辺の追加\nvoid add_edge(int x, int y, int d, int c){\n\tedge e( y , d , c );\n\tG[x].push_back( e );\n\te.to = x;\n\tG[y].push_back( e );\n}\n\n// スタートからゴールに辿りつけるかどうかチェック\nvoid check(int v, int g, map<int,bool> memo){\n\tif( v == g ){\n\t\tis_connect = true;\n\t}\n\tif( memo[v] ) return;\n\tmemo[v] = true;\n\t\n\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\tint to = G[v][i].to;\n\t\tif( memo[to] ) continue;\n\t\tcheck( to , g , memo );\n\t}\n}\n\n// ダイクストラ法\ndouble solve(int s, int g){\n\t// d[v][x][y] := 速度v, 前の町x, 今の町yまでの最小コスト\n\tdouble d[31][31][31];\n\t// 初期化\n\tfor(int y=0 ; y < MAX_V ; y++ ){\n\t\tfor(int x=0 ; x < MAX_V ; x++ ){\n\t\t\tfor(int v=0 ; v < 31 ; v++ ){\n\t\t\t\td[v][y][x] = INF;\n\t\t\t\td[v][y][x] = INF;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ( 速度 , (前の町,今の町) ), 始点は前の町を0としてどの町にも Uターンできる扱い\n\tNode start( 1 , P(0,s) );\n\td[1][0][s] = 0;\n\tpriority_queue< State, vector<State> , greater<State> > q;\n\tq.push( State(0,start) );\n\t\n\tdouble ans = INF;\n\twhile( !q.empty() ){\n\t\t// 値を取り出す\n\t\tdouble now_cost = q.top().first;\n\t\tint v = q.top().second.first;\n\t\tint x = q.top().second.second.first;\n\t\tint y = q.top().second.second.second;\n\t\tq.pop();\n\t\t\n\t\tif( now_cost >= ans ) continue;\n\t\t\n\t\t// 目的地のとき\n\t\tif( y == g ){\n\t\t\tans = min( ans , now_cost );\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < G[y].size() ; i++ ){\n\t\t\tint to = G[y][i].to;\n\t\t\tint dis = G[y][i].d;\n\t\t\tint c = G[y][i].c;\n\t\t\tif( to == x ) continue;\n\t\t\t\n\t\t\tfor(int dv = -1 ; dv <= 1 ; dv++ ){\n\t\t\t\tint next_v = v + dv;\n\t\t\t\tif( next_v > c ) continue;\n\t\t\t\t\n\t\t\t\tdouble cost = (double)dis / next_v;\n\t\t\t\tif( now_cost + cost < d[next_v][y][to] ){\n\t\t\t\t\td[next_v][y][to] = now_cost + cost;\n\t\t\t\t\t\n\t\t\t\t\tNode next( next_v , P(y,to) );\n\t\t\t\t\tState p( now_cost + cost , next );\n\t\t\t\t\tq.push( p );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile( cin >> n >> m , n || m ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\t\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tadd_edge( x , y , d , c );\n\t\t}\n\t\t\n\t\t{\n\t\t\t// スタートからゴールに辿りつけるかどうか\n\t\t\tmap<int,bool> memo;\n\t\t\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\t\t\tmemo[i] = false;\n\t\t\t}\n\t\t\tcheck( s , g , memo );\n\t\t}\n\t\t\n\t\t// ゴールに辿りつけないとき\n\t\tif( is_connect == false ){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t\tdouble ans = solve( s , g );\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr double INF = 1e18;\n\nclass Graph{\n    struct Edge{\n        int from, to;\n        double cost;\n        int limit;\n        Edge(int u,int v,double c,int l){\n            from=u;\n            to=v;\n            cost=c;\n            limit=l;\n        }\n        bool operator < (const Edge &right)const{\n            if(cost != right.cost)return cost > right.cost;\n            else if(from != right.from)return from < right.from;\n            else return to < right.to;\n        }\n    };\n    vector<vector<Edge>> g;\n\npublic:\n    Graph(int n){\n        g.resize(n);\n    }\n    void addEdge(int u, int v, double c, int l){\n        g[u].emplace_back(u, v, c, l);\n    }\n    void dijkstra(int, vector<vector<double>>&);\n};\n\ninline void Graph::dijkstra(int s, vector<vector<double>> &dist){\n    const int V=g.size();\n    priority_queue<Edge> pq;\n    dist[s][1]=0;\n    for(pq.emplace(-2,s,0,0);!pq.empty();){\n        Edge e=pq.top();pq.pop();\n        for(auto ge:g[e.to]){\n            if(e.from==ge.to)continue;\n            for(int i=-1;i<=1;++i){\n                if(e.limit+i<=0 || e.limit+i>ge.limit){\n                    continue;\n                }\n                if(dist[ge.to][e.limit+i] > e.cost+(ge.cost/(e.limit+i))){\n                    dist[ge.to][e.limit+i]=e.cost+(ge.cost/(e.limit+i));\n                    pq.emplace(ge.from,ge.to,dist[ge.to][e.limit+i],e.limit+i);\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int n, m;\n    while(cin>>n>>m,n){\n        Graph g(n);\n        int src,dst;\n        cin>>src>>dst;\n        for(int i=0;i<m;++i){\n            int u,v,d,c;\n            cin>>u>>v>>d>>c;\n            g.addEdge(u-1,v-1,(double)d,c);\n            g.addEdge(v-1,u-1,(double)d,c);\n        }\n        vector<vector<double>>dist(n,vector<double>(31,INF));\n        g.dijkstra(src-1, dist);\n        if(dist[dst-1][1]==INF)cout<<\"unreachable\"<<endl;\n        else cout<<dist[dst-1][1]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint n,m,s,g;\nmap<int, vector<TIII> > r;\nmap<TIII, double> v;\n\nint main(){\n\twhile(1){\n\t\tdouble ret = -1.0;\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)return 0;\n\t\tcin>>s>>g;\n\t\tr.clear();\n\t\tv.clear();\n\t\tREP(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tr[x].PB(MT(y,d,c));\n\t\t\tr[y].PB(MT(x,d,c));\n\t\t}\n\t\tpriority_queue<pair<double, TIII > , vector<pair<double, TIII > >, greater<pair<double, TIII > > > q;\n\t\tq.push(MP(0.0,MP(s, MP(-1, 0))));\n\t\twhile(!q.empty()){\n\t\t\tpair<double, TIII > tmp = q.top();\n\t\t\tq.pop();\n\t\t\tif(EXIST(v, tmp.second))continue;\n\t\t\tif(tmp.second.first == g && tmp.second.second.second == 1){\n\t\t\t\tret = tmp.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv[tmp.second]=tmp.first;\n\t\t\tint city = tmp.second.first;\n\t\t\tint speed = tmp.second.second.second;\n\t\t\tint pre = tmp.second.second.first;\n\t\t\tdouble now = tmp.first;\n\t\t\tREP(i, r[city].size()){\n\t\t\t\tFOR(sp, speed-1, speed+2){\n\t\t\t\t\tif(sp<1)continue;\n\t\t\t\t\tTIII f = r[city][i];\n\t\t\t\t\tif(f.second.second >= sp && sp > 0 && f.first != pre)q.push(MP(now+(f.second.first*1.0)/(sp*1.0), MP(city, MP(f.first, sp))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ret < 0.0)cout << \"unreachable\" <<endl;\n\t\telse printf(\"%.6f\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 91 // いつもは1<<29だが小さくすれば時間はやくなる？\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n//自身だー\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<map>\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\ntypedef struct {\n    int dis;\n    int lim;\n} edge;\ntypedef pair<int,int> pp;\ntypedef pair<int, pp> node; // v, (x,y)\ntypedef pair<double, node> que; // sum, (v, (x,y))\n\nedge input[50][50];\ndouble G[50][50][50]; // x, y, v\n\nint main(void) {\n    while(1) {\n        int n,m,s,g;\n        scanf(\"%d%d\",&n,&m);\n        if(!n) break;\n        scanf(\"%d%d\",&s,&g);\n        s--, g--;\n\n        memset(input, 0, sizeof(input));\n        memset(G, 0, sizeof(G));\n\n        for(int i=0; i<m; i++) {\n            int x,y,d,c;\n            scanf(\"%d%d%d%d\",&x,&y,&d,&c);\n            x--, y--;\n            input[x][y] = input[y][x] = {d,c};\n        }\n\n        map<node,double> tbl;\n        priority_queue<que> q;\n        for(int i=0; i<n; i++)\n            if(input[s][i].dis)\n                q.push(que(-0.0, node(1, pp(s,i))));\n\n        double res = 10000000.0;\n        while(q.size()) {\n            que t = q.top(); q.pop();\n\n            int v = t.snd.fst;\n            int x = t.snd.snd.fst, y = t.snd.snd.snd;\n\n            double sum = -t.fst + 1.0* input[x][y].dis / v;\n\n            if(tbl.find(t.snd) != tbl.end()) continue;\n            tbl[t.snd] = sum;\n\n            if(y == g && v == 1) {\n                res = res < sum ? res : sum;\n                continue;\n            }\n\n            for(int i=0; i<n; i++)\n                if(i!=x && input[y][i].dis) {\n                    int dv[] = {-1,0,1};\n                    for(int iv=0; iv<3; iv++)\n                        if(0<v+dv[iv] && v+dv[iv]<=input[y][i].lim && tbl.find(node(v+dv[iv], pp(y,i))) == tbl.end())\n                            q.push(que(-sum, node(v+dv[iv], pp(y,i))));\n                }\n        }\n        if(res>1000000.0)\n            puts(\"unreachable\");\n        else\n            printf(\"%f\\n\", res);\n\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<double, int, int, int> T;\n \nconst ll MOD=1e9+7;\n//const ll INF=1e18;\n\nconst double INF = 1000000.0;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\nstruct edge{ int to,d,c;};\n\n\n\nint n,m,s,g;\ndouble d[35][35][35];\ndouble mind;\n\nint main(){\n\twhile(true){\n\t\tcin >> n >> m;\n\t\tif(n + m == 0) break;\n\t\tcin >> s >> g;\n\t\tmind = INF;\n\t\tvector<edge> G[35];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a1,a2,a3,a4;\n\t\t\tcin >> a1 >> a2 >> a3 >> a4;\n\t\t\tedge tmp1 = {a2,a3,a4};\n\t\t\tG[a1].push_back(tmp1);\n\t\t\tedge tmp2 = {a1,a3,a4};\n\t\t\tG[a2].push_back(tmp2);\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tfor(int k = 0;k <= 31;k++){\n\t\t\t\t\td[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//queue<T> que;\n\t\tpriority_queue<T,vector<T>,greater<T> > que;\n\t\tfor(int i = 0;i < G[s].size();i++){\n\t\t\tedge e = G[s][i];\n\t\t\td[s][e.to][1] = (double) e.d;\n\t\t\tque.push(make_tuple((double)e.d,1,s,e.to));\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tT t = que.front(); que.pop();\n\t\t\tdouble a1 = get<0>(t);\n\t\t\tint a2 = get<1>(t),a3 = get<2>(t),a4 = get<3>(t);\n\t\t\tif(d[a3][a4][a2] < a1 || a1 > mind)continue;\n\t\t\tfor(int i = 0;i < G[a4].size();i++){\n\t\t\t\tedge e = G[a4][i];\n\t\t\t\tif(e.to == a3) continue;\n\t\t\t\tfor(int j = -1;j <= 1;j++){\n\t\t\t\t\tint v = a2 + j;\n\t\t\t\t\tdouble tmp = (double)( a1 + (double)e.d / (double)v);\n\t\t\t//\t\tif(a4 == 5 && e.to == 6 && v == 1) cout << \"tmp\" << tmp << \",a1\" << a1 <<endl;\n\t\t\t\t\tif(v <= 0 || v > e.c || d[a4][e.to][v] < tmp ||tmp > mind) continue;\n\t\t\t\t\td[a4][e.to][v] =  tmp;\n\t\t\t\t\tif(e.to == g && v == 1 && mind > tmp)mind = tmp;\n\t\t\t\t\tque.push(make_tuple(tmp,v,a4,e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\n\t\t}\n\t//\tcout << \"ans\" << d[4][5][2] << endl;\n\n\n\n\t\tdouble ans = INF;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tdouble tmp = d[i][g][1];\n\t\t\tif(ans > tmp) ans = tmp;\n\t\t//\tans = min(ans,d[i][g][1]);\n\t\t}\n\t\tif(ans == INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t//\tcout << ans << endl;\n\t\t\tprintf(\"%lf\",ans);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\n\n\n\nint main(){\n  int inx,iny,ind,inc;\n  double d[40][40][40];\n  int n,m,s,g;\n \n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];    \n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    //d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\n// グラフ用ヘッダ\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    int limit;\n    Edge(int src, int dst, Weight weight, int limit) :\n        src(src), dst(dst), weight(weight), limit(limit) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n#include <queue>\n\n// d,speed,v,from\ntypedef tuple<double,int,int,int> State;\n\nconst double inf = 1e100;\n\n// speed,v,from\ndouble dp[32][32][32];\nGraph g;\nint src,dst;\n\nconst char* solve(){\n    priority_queue<State> q;\n    q.emplace(0.0,0,src,31);\n    rep(i,32)rep(j,32)rep(k,32) dp[i][j][k] = inf;\n    dp[0][src][31] = 0;\n    while(q.size()){\n        double d; int speed, v, from;\n        tie(d,speed,v,from) = q.top(); q.pop();\n        d = -d;\n        if(v==dst && speed==1){\n            static char ans[100];\n            sprintf(ans,\"%.12lf\",d);\n            return ans;\n        }\n        if(d > dp[speed][v][from]) continue;\n        for(Edge & e : g[v]){\n            for(int diff : {-1,0,1}){\n                int ns = speed + diff;\n                if(ns < 1 || e.limit < ns) continue;\n                double nd = d + (double)e.weight / ns;\n                int nv = e.dst;\n                if(nv == from) continue;\n                if(dp[ns][nv][v] > nd){\n                    dp[ns][nv][v] = nd;\n                    q.emplace(-nd,ns,nv,v);\n                }\n            }\n        }\n    }\n    return \"unreachable\";\n}\n\nint main(){\n    int n,m;\n    while(~scanf(\"%d%d\", &n,&m) && n){\n        scanf(\"%d%d\",&src,&dst);\n        g.assign(n+1,{});\n        rep(i,m){\n            int x,y,d,c;\n            scanf(\"%d%d%d%d\", &x,&y,&d,&c);\n            g[x].eb(x,y,d,c);\n            g[y].eb(y,x,d,c);\n        }\n        puts(solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1e9\nusing namespace std;\ndouble cost[30][30][31]; int d[30][30],c[30][30],v[30][30][31];\nstruct S{\n\tdouble cc;int c,p,v;\n\tS(double cc,int c,int p,int v):cc(cc),c(c),p(p),v(v){}\n\tbool operator<(const S &a)const{\n\t\treturn cc>a.cc;\n\t}\n};\nint main(){\n\tint n,m,s,g,x,y,a,b; double nc;\n\twhile(scanf(\"%d%d\",&n,&m),n){\n\t\tscanf(\"%d%d\",&s,&g),s--,g--;\n\t\trep(i,n)rep(j,n){\n\t\t\trep(k,31)cost[i][j][k]=INF,v[i][j][k]=0;\n\t\t\td[i][j]=c[i][j]=0;\n\t\t}\n\t\trep(i,m)scanf(\"%d%d%d%d\",&x,&y,&a,&b),\n\t\tx--,y--,d[x][y]=d[y][x]=a,c[x][y]=c[y][x]=b;\n\t\tpriority_queue<S> F; F.push(S(0,s,s,0)); cost[s][s][0]=0;\n\t\twhile(!F.empty()){\n\t\t\tS cs=F.top(); F.pop();\n\t\t\tv[cs.c][cs.p][cs.v]=1;\n\t\t\tif(cs.c==g&&cs.v==1){\n\t\t\t\tprintf(\"%.5f\\n\",cs.cc); goto END;\n\t\t\t}\n\t\t\trep(i,n)if(i!=cs.p&&d[cs.c][i])\n\t\t\tfor(int dv=-1;dv<2;dv++)if(!v[i][cs.c][dv+cs.v]&&0<dv+cs.v&&dv+cs.v<=c[cs.c][i]){\n\t\t\t\tnc=cost[cs.c][cs.p][cs.v]+1.*d[cs.c][i]/(dv+cs.v);\n\t\t\t\tif(cost[i][cs.c][dv+cs.v]>nc)\n\t\t\t\tcost[i][cs.c][dv+cs.v]=nc,F.push(S(nc,i,cs.c,dv+cs.v));\n\t\t\t}\n\t\t}\n\t\tprintf(\"unreachable\\n\"); END:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct road\n{\n  int node, len, limit;\n  road() {}\n  road(int x, int d, int c) : node(x), len(d), limit(c) {}\n};\n\nstruct state\n{\n  int p, n, v;\n  double c;\n  state(int prev, int node, int velocity, double cost) : p(prev), n(node), v(velocity), c(cost) {}\n  bool operator<(const state& that) const { return c > that.c; }\n};\n\nint main()\n{\n  int N, M;\n  while (scanf(\"%d %d\", &N, &M) != EOF && N != 0) {\n    int S, G;\n    scanf(\"%d %d\", &S, &G);\n    --S;  --G;\n    vector<vector<road> > g(N);\n    for (int i = 0; i < M; i++) {\n      int x, y, d, c;\n      scanf(\"%d %d %d %d\", &x, &y, &d, &c);\n      --x;  --y;\n      g[x].push_back(road(y, d, c));\n      g[y].push_back(road(x, d, c));\n    }\n    vector<vector<double> > dist(N, vector<double>(31, 1e7));\n    dist[S][1] = 0.0;\n    priority_queue<state> q;\n    q.push(state(-1, S, 0.0, 0.0));\n    while (!q.empty()) {\n      const int prev = q.top().p;\n      const int n = q.top().n;\n      const int v = q.top().v;\n      const double cost = q.top().c;\n      q.pop();\n      if (n == G && v == 1) {\n        printf(\"%.5f\\n\", cost);\n        goto NEXT;\n      }\n      for (vector<road>::const_iterator it(g[n].begin()); it != g[n].end(); ++it) {\n        if (it->node == prev) {\n          continue;\n        }\n        if (v > 1 && v-1 <= it->limit) {\n          const double c = cost + double(it->len) / (v-1);\n          if (c < dist[it->node][v-1]) {\n            dist[it->node][v-1] = c;\n            q.push(state(n, it->node, v-1, c));\n          }\n        }\n        if (v <= it->limit) {\n          const double c = cost + double(it->len) / v;\n          if (c < dist[it->node][v]) {\n            dist[it->node][v] = c;\n            q.push(state(n, it->node, v, c));\n          }\n        }\n        if (v+1 <= it->limit) {\n          const double c = cost + double(it->len) / (v+1);\n          if (c < dist[it->node][v+1]) {\n            dist[it->node][v+1] = c;\n            q.push(state(n, it->node, v+1, c));\n          }\n        }\n      }\n    }\n    puts(\"unreachable\");\nNEXT:\n    ;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\n\n\n\nint main(){\n  int inx,iny,ind,inc;\n  double d[40][40][40];\n  int n,m,s,g;\n \n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];    \n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    for(int i=0;i<=n;i++)d[i][i][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cout << x << \" \";} cout << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\n// typedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\n// const int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef tuple<double, int, int, int> TUPLE;\nconst double inf = 1e12;\n\nstruct edge {\n    int to, d, c;\n    edge(){}\n    edge(int _to, int _d, int _c) : to(_to), d(_d), c(_c) {}\n};\ntypedef vector<vector<edge>> Graph;\ndouble dijkstra(const Graph& G, int s, int g) {\n    int n = G.size();\n    priority_queue<TUPLE, vector<TUPLE>, greater<TUPLE>> pq;   // cost, i, j, pre\n    vector<vector<vector<double>>> d(n, vector<vector<double>>(31, vector<double>(n + 1, inf)));\n    d[s][0][n] = 0;\n    pq.push(make_tuple(0, s, 0, n));\n\n    while (!pq.empty()) {\n        double cost;\n        int i, j, pre;\n        tie(cost, i, j, pre) = pq.top(); pq.pop();\n        // cout << cost << \" \" << i << \" \" << j << endl;\n        // if (i == g && j == 1) return cost;\n        if (d[i][j][pre] < cost) continue;\n        for (const auto& e : G[i]) {\n            for (int k = -1; k <= 1; k++) {\n                if (e.to == pre) continue;\n                // if (e.to == g && j + k != 1) continue;\n                if (1 <= j + k && j + k <= e.c && d[e.to][j + k][i] > d[i][j][pre] + 1. * e.d / (j + k)) {\n                    d[e.to][j + k][i] = d[i][j][pre] + 1. * e.d / (j + k);\n                    pq.push(make_tuple(d[e.to][j + k][i], e.to, j + k, i));\n                }\n            }\n        }\n        // cerr << \"hey!\" << endl;\n    }\n\n    return *min_element(all(d[g][1]));;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    int t = 0;\n    while (cin >> n >> m, n) {\n        // cout << \"--- t = \" << t++ << \" ---\" << endl;\n\n        int s, g;\n        cin >> s >> g;\n        s--, g--;\n        Graph G(n);\n        rep(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--, y--;\n            G[x].emplace_back(y, d, c);\n            G[y].emplace_back(x, d, c);\n        }\n\n        double ans = dijkstra(G, s, g);\n        if (ans < inf) {\n            cout << fixed << setprecision(10) << ans << endl;\n        } else {\n            cout << \"unreachable\" << endl;\n        }\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n||m){\n    cin>>s>>g;\n    s--;g--;\n    int d[n][n],c[n][n];\n    memset(d,-1,sizeof(d));\n    memset(c,-1,sizeof(c));\n    int i,j,k,l,x,y;\n    for(i=0;i<m;i++){\n      cin>>x>>y>>j>>k;\n      x--;y--;\n      d[x][y]=d[y][x]=j;\n      c[x][y]=c[y][x]=k;\n    }\n    double v[n][50];\n    double inf=1<<28,p;\n    for(i=0;i<n;i++) for(j=0;j<50;j++) v[i][j]=inf;\n    v[s][0]=0;\n    typedef pair<int,int> PPP;\n    typedef pair<int,PPP> P;\n    typedef pair<double,P> PP;\n    priority_queue<PP,vector<PP>,greater<PP> > q;\n    q.push(PP(v[s][0],P(s,PPP(1,-1))));\n    while(!q.empty()){\n      x=q.top().second.first;\n      y=q.top().second.second.first;\n      k=q.top().second.second.second;\n      p=q.top().first;q.pop();\n      if(v[x][y]<p) continue;\n      v[x][y]=p;\n      for(i=0;i<n;i++){\n\tif(!~d[x][i]||i==k) continue;\n\tfor(j=-1;j<=1;j++){\n\t  if(x==s&&p==0&&j!=0) continue;\n\t  if(y+j<0||c[x][i]<y+j) continue;\n\t  q.push(PP(p+(double)d[x][i]/(y+j),P(i,PPP(y+j,x))));\n\t}\n      }\n    }\n    if(v[g][1]!=inf) printf(\"%.8f\\n\",v[g][1]);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__\",\", __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000123456789LL\n\nvoid solve(int n, int m){\n  int s,t;\n  cin>>s>>t;\n  s--;t--;\n  vector<vector<pair<int,double>>> vec(n*n*31 + 2);\n  // (f*n+v)*31 + V : ??´??????f??§v??????????????????V\n\n  rep(i,m){\n    int a,b,c; double d;\n    cin>>a>>b>>d>>c;\n    a--;b--;\n    // a -> b\n    rep(j,n)if(j!=b && j!=a){\n      rep(k,31){\n        int from = (j*n+a)*31+k;\n        if(k-1>0 && k-1<=c) vec[from].pb(mp((a*n+b)*31+k-1, d/(k-1)));\n        if(k>0 && k<=c) vec[from].pb(mp((a*n+b)*31+k, d/k));\n        if(k+1>0 && k+1<=c) vec[from].pb(mp((a*n+b)*31+k+1, d/(k+1)));\n      }\n    }\n    // b -> a\n    rep(j,n)if(j!=b && j!=a){\n      rep(k,31){\n        int from = (j*n+b)*31+k;\n        if(k-1>0 && k-1<=c) vec[from].pb(mp((b*n+a)*31+k-1, d/(k-1)));\n        if(k>0 && k<=c) vec[from].pb(mp((b*n+a)*31+k, d/k));\n        if(k+1>0 && k+1<=c) vec[from].pb(mp((b*n+a)*31+k+1, d/(k+1)));\n      }\n    }\n  }\n\n  int from = n*n*31, dest = from+1;\n\n  rep(i,n) if(i!=s) vec[from].pb(mp((i*n+s)*31+0, 0));\n  rep(i,n) if(i!=t) vec[(i*n+t)*31+1].pb(mp(dest, 0));\n\n  // dijkstra\n  vector<double> d(n*n*31+2, INF);\n  d[from] = 0;\n  typedef pair<double,int> P;\n  priority_queue<P, vector<P>, greater<P>> pq;\n  pq.push(mp(0,from));\n  while(!pq.empty()){\n    auto p = pq.top(); pq.pop();\n    int v = p.second; double dis = p.first;\n    if(d[v] < dis) continue;\n    for(auto &to : vec[v]){\n      double nd = dis + to.second;\n      if(d[to.first] <= nd) continue;\n      d[to.first] = nd;\n      pq.push(mp(nd, to.first));\n    }\n  }\n  if(d[dest] == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.6f\\n\", d[dest]);\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m) solve(n,m);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define EPS 1e-8\n\nstruct P{\n  //  double t;\n  float t;\n  char v,p,pre;\n  P(double T=0.0,int V=0,int pp=0,int PRE=0){\n    t=T;v=V;p=pp;pre=PRE;\n  };\n  bool operator<(const P &p)const{\n    return t>p.t;\n  }\n};\nstruct Path{\n  char d,c;\n  Path(int D=0,int C=0){ d=D;c=C;};\n};\n\nint main(){\n  int n,m, s,g, x,y,d,c;\n  Path path[30][30];\n  priority_queue<P> q;\n\n  while( cin>>n>>m && (n|m) ){\n    cin >> s >> g;\n    s--; g--;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tpath[i][j].d=-1.0; path[i][j].c=-1;\n      }\n\n    for( int i=0;i<m;i++ ){\n      cin >> x >> y >> d >> c;\n      x--;y--;\n      path[x][y].d=d; path[x][y].c=c;\n      path[y][x] = path[x][y];\n    }\n\n    double cost[30][35]; // place,velocity\n    int dv[3] = {1,0,-1};\n    for( int i=0;i<n;i++ )\n      for( int j=1;j<31;j++ )\n\tcost[i][j] = DBL_MAX;\n\n    while( !q.empty() ) q.pop();\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      q.push( P(cost[i][1]=path[s][i].d,1,i,-1) );\n    }\n\n    while( !q.empty() ){\n      P p = q.top(); q.pop();\n      double t = p.t;\n      int v=p.v, np=p.p, pre=p.pre;\n      if( np==g && v==1 ) break;\n\n      for( int i=0;i<n;i++ ){\n\tif( path[np][i].c<0 ) continue;// たどり着けないノード\n\tif( i==pre ) continue; // 前回のノード\n\n\tint j=0;\n\tif( i==g ) j=2;\n\tfor( ;j<3;j++ ){\n\t  int nv = v + dv[j];\n\t  if( nv==0 || nv>path[np][i].c )    continue;\n\t  double nCost = t + (double)path[np][i].d/nv;\n\t  if( nCost>cost[g][1] || fabs(nCost-cost[g][1])<EPS ) continue;\n\t  if( cost[i][nv] < nCost ) continue;\n\t  cost[i][nv]=nCost;\n\n\t  q.push( P(nCost,nv,i,np) );\n\t}\n      }\n\n    }\n    if( fabs(cost[g][1]-DBL_MAX)<EPS )\n      cout << \"unreachable\" << endl;\n    else\n      printf(\"%.6lf\\n\",cost[g][1]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\nint n, m;\nconstexpr int r = 31;\nstruct Edge {\n\tint to;\n\tdouble cost;\n};\nint index(int v, int prev, int speed) {\n\treturn v * n*r + prev * r + speed;\n}\nusing Graph = vector<vector<Edge>>;\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> n >> m, n) {\n\t\tint s, t; cin >> s >> t;\n\t\ts--; t--;\n\t\tGraph g(n * n * r);\n\t\tREP(aaaaaa, m) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--; b--;\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, r) {\n\t\t\t\t\tfor (int k = j - 1; k <= j + 1; ++k) {\n\t\t\t\t\t\tif (k > 0 && k <= c) {\n\t\t\t\t\t\t\tint from = index(a, i, j), to = index(b, a, k);\n\t\t\t\t\t\t\tif (b != i)g[index(a, i, j)].push_back({ index(b,a,k),double(d) / k });\n\t\t\t\t\t\t\tif (a != i)g[index(b, i, j)].push_back({ index(a,b,k),double(d) / k });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<double> dist(n*n*r, INF);\n\t\tusing P = pair<double, int>;\n\t\tpriority_queue<P, vector<P>, greater<>> q;\n\t\tREP(i, n) {\n\t\t\tint j = index(s, i, 0);\n\t\t\tdist[j] = 0;\n\t\t\tq.push({ 0,j });\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tauto p = q.top(); q.pop();\n\t\t\tint v = p.second;\n\t\t\tif (p.first - EPS > dist[v])continue;\n\t\t\tREP(i, g[v].size()) {\n\t\t\t\tint to = g[v][i].to;\n\t\t\t\tif (dist[to] - EPS > dist[v] + g[v][i].cost) {\n\t\t\t\t\tdist[to] = dist[v] + g[v][i].cost;\n\t\t\t\t\tq.push({ dist[to],to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = INF;\n\t\tREP(i, n)chmin(ans, dist[index(t, i, 1)]);\n\t\tif (ans == INF)cout << \"unreachable\" << endl;\n\t\telse cout << fixed << setprecision(12) << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cfloat>\n\nusing namespace std;\n\nint n, m;\n\nstruct edge {\n\tint dist, lim;\n};\n\nstruct P {\n\tint from, pos, v;\n\tdouble time;\n\n\tbool operator >(const P& p) const {\n\t\treturn time > p.time;\n\t}\n};\n\nedge elist[31][31];\ndouble G[31][31];\n\nint main() {\n\tint s, g;\n\twhile (cin >> n >> m, n|m) {\n\t\tfor(int i=0; i<31; i++){\n\t\t\tfor(int j=0; j<31; j++){\n\t\t\t\telist[i][j] = {-1, -1};\n\t\t\t}\n\t\t}\n\t\tfill_n((double *)G, 31*31, DBL_MAX);\n\t\tcin >> s >> g;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\telist[x][y] = {d, c};\n\t\t\telist[y][x] = {d, c};\n\t\t}\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\tq.push({-1, s, 0, 0.0});\n\t\tbool goal = false;\n\t\twhile(!q.empty()){\n\t\t\tP p = q.top(); q.pop();\n\t\t\t// goal\n\t\t\tif (p.pos == g && p.v == 1) {\n\t\t\t\tprintf(\"%f\\n\", p.time);\n\t\t\t\tgoal = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=1; i<=n; i++) {\n\t\t\t\tif(elist[p.pos][i].dist != -1 && p.from != i) {\n\t\t\t\t\t// v+1\n\t\t\t\t\tif(p.v + 1 <= elist[p.pos][i].lim) {\n\t\t\t\t\t\tdouble time = p.time + (double)elist[p.pos][i].dist / (double)(p.v+1);\n\t\t\t\t\t\tif(time < G[i][p.v+1]){\n\t\t\t\t\t\t\tq.push({p.pos, i, p.v+1, time});\n\t\t\t\t\t\t\tG[i][p.v+1] = time;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// v\n\t\t\t\t\tif(p.v <= elist[p.pos][i].lim) {\n\t\t\t\t\t\tdouble time = p.time + (double)elist[p.pos][i].dist / (double)p.v;\n\t\t\t\t\t\tif(time < G[i][p.v]){\n\t\t\t\t\t\t\tq.push({p.pos, i, p.v, time});\n\t\t\t\t\t\t\tG[i][p.v] = time;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// v-1\n\t\t\t\t\tif(p.v -1 <= elist[p.pos][i].lim && p.v-1 > 0) {\n\t\t\t\t\t\tdouble time = p.time + (double)elist[p.pos][i].dist / (double)(p.v-1);\n\t\t\t\t\t\tif(time < G[i][p.v-1]){\n\t\t\t\t\t\t\tq.push({p.pos, i, p.v-1, time});\n\t\t\t\t\t\t\tG[i][p.v-1] = time;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!goal) cout << \"unreachble\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nstruct State {\n    int i, prev, sp; double cost;\n};\n\nbool operator>(const State& a, const State& b)\n{\n    return a.cost > b.cost;\n}\n\nconst double INF = 1<<29;\n\nint main()\n{\n    while (1) {\n        int n, m, s, g; cin >> n >> m >> s >> g;\n        if (!n) break;\n        s--, g--;\n\n        vector<vector<double>> dist(n, vector<double>(n, INF));\n        vector<vector<int>> lim(n, vector<int>(n));\n\n        while (m--) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--, y--;\n            dist[x][y] = dist[y][x] = d;\n            lim[x][y] = lim[y][x] = c;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> Q;\n        Q.push({ s, -1, 0, 0 });\n\n        pair<int, int> debug[40][40];\n\n        int vis[40][40][40] = {};\n        double ans = INF;\n        while (Q.size()) {\n            auto e = Q.top(); Q.pop();\n            if (vis[e.i][e.sp][e.prev]) continue;\n            vis[e.i][e.sp][e.prev] = 1;\n            if (e.i == g && e.sp == 1) ans = min(ans, e.cost);\n            loop (n, i) loop (3, d) {\n                int sp = e.sp-1+d;\n                if (dist[e.i][i] == INF || i == e.prev ||\n                        sp < 1 || sp > lim[e.i][i]) continue;\n                Q.push({ i, e.i, sp, e.cost + dist[e.i][i] / sp });\n            }\n        }\n        if (ans != INF) cout << setprecision(12) << fixed << ans << endl;\n        else cout << \"unreachable\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst double INF = 1e8;\nint s,t;\n\nclass Edge{\n    public:\n        int to;\n        double cost,limit;\n        Edge(int to, double cost, double limit) : to(to) ,cost(cost) ,limit(limit) {}\n};\n\nclass Node{\n    public:\n        double dis;\n        bool isUsed;\n        double speed;\n        Node(){\n            this->dis = INF;\n            this->speed = 0.0;\n            this->isUsed = 0;\n        }\n};\n\ntypedef vector<vector<Edge>> AdjList;\n\ndouble dijkstra(AdjList g, int n,int start = s){\n\n    vector<vector<Node>> node(n,vector<Node>(35));\n    //??????????????????????????????????????????\n    typedef pair<pair<double,double>,pair<int,int>> p;\n\n    priority_queue<p, vector<p>, greater<p>> q;\n\n    q.push(make_pair(make_pair(0.0, 0.0), make_pair(start,-1)));\n    node[start][0].dis = 0.0;\n\n    p u;\n    while(not q.empty()){\n        u = q.top(); q.pop();\n        int current = u.second.first;\n        int prev = u.second.second;\n        double speed = u.first.second;\n        node[current][speed].isUsed = 1;\n\n        rep(i,g[current].size()){\n            int next = g[current][i].to;\n            //if(next == prev) continue;\n\n            for(double j = -1; j <= 1; j++){\n                if(speed + j > 0){\n                    if(speed + j > g[current][i].limit) continue;\n                    if(node[next][speed + j].dis > node[current][speed].dis + g[current][i].cost / (speed + j)){\n                        node[next][speed + j].dis = node[current][speed].dis + g[current][i].cost / (speed + j);\n                        q.push(make_pair(\n                                    make_pair(node[next][speed + j].dis, speed + j),\n                                    make_pair(next,current)\n                                    )\n                              );\n                    }\n                }\n            }\n        }\n    }\n///    cout << endl;\n///    rep(i,n){\n///        rep(j,30){\n///            cout << node[i][j].dis << ' ';\n///        }\n///        cout << endl;\n///    show(\"------------\")\n///    }\n    return node[t][1].dis;\n}\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n||m){\n        cin >> s >> t;\n        s--; t--;\n        AdjList g(n);\n        rep(i,m){\n            int a, b;\n            double c, d;\n            cin >> a >> b >> c >> d;\n            a--; b--;\n            g[a].emplace_back(Edge{b,c,d});\n            g[b].emplace_back(Edge{a,c,d});\n        }\n        double tmp = dijkstra(g,n);\n        if(tmp == INF) cout << \"unreachable\" << endl;\n        else cout <<fixed << setprecision(5) <<  tmp << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n#define N 30\n#define INF 100000\n\nstruct road{int to,cost,lim;};\nstruct situ{int v,now,from;double d;};\nbool operator < (const situ &a,const situ &b){\n\treturn a.d > b.d;\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,s,g;\n\t\tvector<road> roads[N];\n\t\tcin >> n >> m;\n\t\tif(!n&&!m) break;\n\t\tcin >> s >> g;\n\t\ts--;g--;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,c;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c);\n\t\t\tx--;y--;\n\t\t\troads[x].push_back((road){y,d,c});\n\t\t\troads[y].push_back((road){x,d,c});\n\t\t}\n\n\t\tpriority_queue<situ> que;\n\t\tfor(int i=0;i<roads[s].size();i++){\n\t\t\tint to = roads[s][i].to;\n\t\t\tint d = roads[s][i].cost;\n\t\t\tque.push((situ){1,to,s,(double)d});\n\t\t}\n\t\tdouble dist[N][N][31];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=1;k<31;k++){\n\t\t\t\t\tdist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool isClear = false;\n\t\twhile(que.size()){\n\t\t\tsitu st = que.top(); que.pop();\n\t\t\tif(dist[st.now][st.from][st.v]<st.d) continue;\n\t\t\tdist[st.now][st.from][st.v] = st.d;\n\t\t\tif(st.now==g&&st.v==1){\n\t\t\t\tprintf(\"%.5f\\n\",st.d);\n\t\t\t\tisClear = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<roads[st.now].size();i++){\n\t\t\t\tint to = roads[st.now][i].to;\n\t\t\t\tint d = roads[st.now][i].cost;\n\t\t\t\tif(to == st.from) continue;\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tif(st.v+j<=roads[st.now][i].lim&&st.v+j>0){\n\t\t\t\t\t\t//if(dist[to][st.now][st.v+j]>st.d+(double)d/(st.v+j))\n\t\t\t\t\t\t\tque.push((situ){st.v+j,to,st.now,st.d+(double)d/(st.v+j)});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!isClear) cout << \"unreachable\" << endl;\n\n\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint to;\n\tint cost;\n    int speedLimit;\n};\n\nclass Situation{\npublic:\n\tdouble cost;\n\tint idx;\n    int prvIdx;\n    int speed;\n\n\tSituation(double cost_,int idx_,int prvIdx_,int speed_){\n        cost=cost_;\n\t\tidx=idx_;\n        speed=speed_;\n        prvIdx=prvIdx_;\n\t}\n\tSituation();\n\tbool operator<(const Situation &s)const{\n\t\treturn s.cost < this->cost;\n\t}\n};\n\n//typedef pair<int,int> P;\nint V;\n\nconst int MAX_V = 100;\nconst int MAX_SPEED=50;\n\nvector<edge> G[MAX_V];\ndouble d[MAX_V][MAX_V][MAX_SPEED];\nconst int INF = 1000000000;\n\nvoid dijkstra(int s){\n\tpriority_queue<Situation> que;\n    for(int i = 0; i < MAX_V; i++)\n        for(int k = 0; k < MAX_V; k++)\n            for(int j = 0; j < MAX_SPEED; j++)\n                d[i][k][j]=INF;\n    d[0][s][1] = 0;\n\tque.push(Situation(0,s,0,1));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n        int idx=p.idx;\n        int pidx=p.prvIdx;\n        double ccost=p.cost;\n        int cspeed=p.speed;\n        //int v = p.idx;\n\t\tif(d[pidx][idx][cspeed] < p.cost)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[idx].size(); i++){\n\t\t\tedge e = G[idx][i];\n            if(pidx==e.to)\n                continue;\n            for(int j = -1; j <= 1; j++){\n                if(pidx==0){\n                    if(cspeed+j!=1)\n                        continue;\n                }\n                if(cspeed+j>=1&&e.speedLimit>=cspeed+j&&d[idx][e.to][cspeed+j]>d[pidx][idx][cspeed]+(double)e.cost/(cspeed+j)){\n                    d[idx][e.to][cspeed+j] = d[pidx][idx][cspeed] + (double)e.cost/(cspeed+j);\n                    que.push(Situation(d[idx][e.to][cspeed+j],e.to,idx,cspeed+j));\n                }\n            }\n\t\t}\n\t}\n}\n\nint main(){\n\n    int n,m,s,g;\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        for(int i = 0; i < MAX_V; i++)\n            G[i].clear();\n        cin>>s>>g;\n        for(int i = 0; i < m; i++){\n            int from,to,dist,lim;\n            cin>>from>>to>>dist>>lim;\n            edge e;\n            e.cost=dist;\n            e.to=to;\n            e.speedLimit=lim;\n            G[from].push_back(e);\n            e.to=from;\n            G[to].push_back(e);\n        }\n        dijkstra(s);\n        double minTime=INF;\n        for(int i = 0; i <= n; i++)\n            minTime=min(minTime,d[i][g][1]);\n        if(EQ(minTime,INF))\n            cout<<\"unreachable\"<<endl;\n        else\n            printf(\"%.6f\\n\",minTime);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <queue>\n#include <complex>\n\n#define INF 100000000\n#define EPS 1e-9\n\nusing namespace std;\n\ntypedef long long ll; \n\n#define MAX_N 31\n#define MAX_M 501\n\nint N, M;\nint S,G;\nint d[MAX_N][MAX_N];\nint c[MAX_N][MAX_N];\n\nvector<double> ans_list;\n\n//pre,speed,pos\nbool used[MAX_N][MAX_N][MAX_N];\ndouble dp[MAX_N][MAX_N][MAX_N];\n\ndouble solve(){\n  \n  for(int i = 0; i < N; i++){\n    for(int j = 0; j < MAX_N; j++){\n      for(int k = 0; k < N; k++){\n\tused[i][j][k] = false;\n\tdp[i][j][k] = INF;\n      }\n    }\n  }\n\n  dp[S][0][S] = 0.0;\n\n  while(true){\n    int pre = -1, speed = -1, pos = -1;\n    for(int i = 0; i < N; i++){\n      for(int j = 0; j < MAX_N; j++){\n\tfor(int k = 0; k < N; k++){\n\t  if(!used[i][j][k] && \n\t     (pre == -1 || dp[i][j][k] < dp[pre][speed][pos])){\n\t    pre = i;\n\t    speed = j;\n\t    pos = k;\n\t  }\n\t}\n      }\n    }\n\n    if(pre == -1)\n      break;\n\n    used[pre][speed][pos] = true;\n\n    for(int to = 0; to < N; to++){\n      for(int j = -1; j <= 1; j++){\n\tif(pre != to && pos != to && d[pos][to] != INF && \n\t   speed + j <= c[pos][to] && speed + j >= 1 && speed + j <= 30){\n\t  dp[pos][speed+j][to] = \n\t    min(dp[pos][speed+j][to], (double)dp[pre][speed][pos] \n\t\t+ (double)d[pos][to]/(speed + j));\n\t}\n      }\n    }\n\n  }\n\n  double ans = INF;\n\n  for(int i = 0; i < N; i++){\n    ans = min(ans, dp[i][1][G]);\n  }\n\n  return ans;\n\n}\n\n\nint main(){\n  \n  while(true){\n    \n    for(int i = 0; i < MAX_N; i++){\n      for(int j = 0; j < MAX_N; j++){\n\td[i][j] = c[i][j] = INF;\n      }\n    }\n\n    cin >> N >> M;\n    if(N == 0)\n      break;\n    cin >> S >> G;\n    S--; G--;\n    for(int i = 0; i < M; i++){\n      int x,y,dd,cc;\n      cin >> x >> y >> dd >> cc;\n      x--;\n      y--;\n      d[x][y] = d[y][x] = dd;\n      c[x][y] = c[y][x] = cc;\n    }\n\n    ans_list.push_back(solve());\n\n  }\n  \n  for(int i = 0; i < ans_list.size(); i++){\n    if(ans_list[i] == INF){\n      cout << \"unreachable\" << endl;\n    }\n    else\n      printf(\"%.7f\\n\", ans_list[i]);\n  }\n\n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nclass Node {\npublic:\n  int pre;\n  int now;\n  int vel;\n  double time;\n\n  Node(int p, int n, int v, double t) {\n    pre = p;\n    now = n;\n    vel = v;\n    time = t;\n  }\n\n  bool operator<(const Node &n) const {\n    return time > n.time;\n  }\n};\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n\n    if (n == 0) {\n      break;\n    }\n\n    int s, g;\n    cin >> s >> g;\n\n    vector<vector<int> > d(n + 1), c(n + 1);\n    for (int i = 0; i <= n; i++) {\n      d[i].resize(n + 1);\n      c[i].resize(n + 1);\n      fill(d[i].begin(), d[i].end(), -1);\n      fill(c[i].begin(), c[i].end(), 0);\n    }\n\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      cin >> d[x][y] >> c[x][y];\n      d[y][x] = d[x][y];\n      c[y][x] = c[x][y];\n    }\n\n    bool f[31][31][31];\n    for (int i = 0; i < 31; i++) {\n      for (int j = 0; j < 31; j++) {\n\tfor (int k = 0; k < 31; k++) {\n\t  f[i][j][k] = false;\n\t}\n      }\n    }\n  \n    bool goal = false;\n    Node snd(0, s, 0, 0.0);\n    priority_queue<Node, vector<Node>, greater<Node> > q;\n    q.push(snd);\n    while (!q.empty()) {\n      Node nd = q.top();\n      q.pop();\n      if (nd.now == g && nd.vel == 1) {\n\tgoal = true;\n\tcout << nd.time << endl;\n\tbreak;\n      }\n      if (f[nd.pre][nd.now][nd.vel]) {\n\tcontinue;\n      }\n      f[nd.pre][nd.now][nd.vel] = true;\n      for (int i = 1; i <= n; i++) {\n\tif (i != nd.pre && d[nd.now][i] != -1) {\n\t  for (int j = -1; j <= 1; j++) {\n\t    int vel = nd.vel + j;\n\t    if (vel > 0 && vel <= c[nd.now][i]) {\n\t      Node next(nd.now, i, vel, nd.time + (double)d[nd.now][i] / vel);\n\t      q.push(next);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    if (!goal) {\n      cout << \"unreachable\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<functional>\n \n \n#define rep(i,n) for(int i=0;i<(n);i++)\n \nusing namespace std;\nconst int INF = 100000000;\ntypedef pair<int,int> P;\n\nint n,m;\n\nstruct edge\n{\n\t//どこから来た,コスト,速度制限\n\tint to,cost,ub;\n\tedge(int to,int cost,int ub) {\n\t\tthis->to = to;\n\t\tthis->cost = cost;\n\t\tthis->ub = ub;\n\t}\n};\n\nvector<edge> G[103];\nint s,g;\ndouble dist[103][103][33];\n\ntypedef pair<double,int> PD;\ntypedef pair<PD,P> PP;\n\ndouble dijkstra() {\n\trep(i,103) rep(j,103) rep(k,33) dist[i][j][k]=INF;\n\tdist[s][0][1]=0;\n\n\t//最短距離 頂点 前の頂点 今の速さ\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(PD(0,s),P(0,1)));\n\n\twhile (!que.empty())\n\t{\n\t\tPP pp = que.top(); que.pop();\n\t\tint v = pp.first.second;\n\n\t\tint prev = pp.second.first;\n\t\tint u = pp.second.second;\n\n\t\t//if(dist[v][prev][u] < pp.first.first) continue;\n\n\t\trep(i,G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tfor(int j=-1;j<=1;j++) {\n\t\t\t\tif(j+u<=0 || u+j > e.ub) continue;\n\n\t\t\t\tif(dist[e.to][v][u+j] > dist[v][prev][u] + (1.0*e.cost/(u+j))) {\n\t\t\t\t\tdist[e.to][v][u+j] = dist[v][prev][u] + (1.0*e.cost/(u+j));\n\t\t\t\t\tque.push(PP(PD(dist[e.to][v][u+j],e.to),P(v,u+j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tdouble ans=INF;\n\trep(i,103) ans=min(ans,dist[g][i][1]);\n\n\treturn ans;\n\t\n}\n\nvoid solve() {\n\trep(i,103) G[i].clear();\n\tcin>>s>>g;\n\trep(i,m) {\n\t\tint x,y,d,c;\n\t\tcin>>x>>y>>d>>c;\n\t\tG[x].push_back(edge(y,d,c));\n\t\tG[y].push_back(edge(x,d,c));\n\t}\n\n\tdouble ans;\n\tans = dijkstra();\n\tif(ans==INF) {\n\t\tcout<<\"unreachable\"<<endl;\n\t}\n\telse\n\t{\n\t\tcout<<ans+1.0<<endl;\n\t}\n\n\n}\n\nint main() {\n\twhile (cin>>n>>m)\n\t{\n\t\tif(n+m==0) return 0;\n\t\tsolve();\n\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\nconst double EPS = 1e-8;\n\nclass State{\npublic:\n  int pos, v, pre;\n  double time;\n  State(){}\n  State(int pos, int v, int pre, double time) : pos(pos), v(v), pre(pre), time(time) {}\n  bool operator < (const State& s) const { return time > s.time; }\n};\n\nint n, m, s, g;\nP edge[30][30];\ndouble vis[30][30][31];\n\nbool equals(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nvoid solve(){\n  State u, v;\n  u = State(s, 0, 0, 0.0);\n  priority_queue<State> que;\n  fill(vis[0][0], vis[30][0], (double)INF);\n  vis[0][0][1] = 0.0;\n  for(int i=0;i<n;i++){\n    if(edge[s][i].first != INF){\n      vis[s][i][1] = edge[s][i].first;\n      que.push(State(i, 1, s, (double)edge[s][i].first));\n    }\n  }\n  while(!que.empty()){\n    u = que.top(); que.pop();\n    //cout << u.pos << ' ' << u.v << ' ' << u.pre << ' ' << u.time << endl;\n    if(vis[u.pre][u.pos][u.v] < u.time) continue;\n    vis[u.pre][u.pos][u.v] = u.time;\n    if(u.pos == g && u.v == 1){\n      printf(\"%.5f\\n\", u.time);\n      return;\n    }\n    for(int i=0;i<n;i++){\n      if(edge[u.pos][i].first == INF) continue;\n      if(u.pre == i) continue;\n      for(int k=-1;k<=1;k++){\n        if(u.v + k > edge[u.pos][i].second) continue;\n        if(u.v + k <= 0) continue;\n        v = State(i, u.v + k, u.pos, u.time + edge[u.pos][i].first / (double)(u.v + k));\n        //cout << '\\t' << v.pos << ' ' << v.v << ' ' << v.pre << ' ' << v.time << ' ' << vis[v.pre][v.pos][v.v] << endl;\n        if(vis[v.pre][v.pos][v.v] > v.time && 1){\n          vis[v.pre][v.pos][v.v] = v.time;\n          que.push(v);\n        }\n      }\n    }\n  }\n  printf(\"unreachable\\n\");\n}\n\nmain(){\n  while(scanf(\"%d%d\", &n, &m) && (n|m)){\n    scanf(\"%d%d\", &s, &g);\n    s--; g--;\n    fill(edge[0], edge[30], P(INF, 0));\n    for(int i=0;i<m;i++){\n      int a, b, c, d;\n      scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n      a--; b--;\n      edge[a][b] = edge[b][a] = P(c, d);\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nstruct edge{\n\tint to,cost,sp;\n};\nstruct ver{\n\tint now,pre;\n\tdouble tim;\n\tint sp;\n};\nnamespace std {\n\tbool operator < (const ver& a, const ver& b) {\n\t\treturn a.tim>b.tim;\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n}\nclass DIJ{\n\tpublic:\n\tvector<vector<edge> >G;\n\tint n,L;\n\tdouble d[32][32][32];\n\tDIJ(int size,int l=40){\n\t\tn=size;\n\t\tL=l;\n\t\tG=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(int a,int b,int c,int s){\n\t\tedge e={b,c,s},ee={a,c,s};\n\t\tG[a].pb(e);\n\t\tG[b].pb(ee);\n\t}\n\tvoid dij(int s,int t){\n\t\trep(i,32)rep(j,32)rep(k,32)d[i][j][k]=inf;\n\t\td[s][30][1]=0;\n\t\tpriority_queue<ver>q;\n\t\tq.push(ver{s,30,0,1});\n\t\tbool h=true;\n\t\twhile(!q.empty()){\n\t\t\tver p=q.top();\n\t\t\tq.pop();\n\t\t\tif(p.tim>d[p.now][p.pre][p.sp])continue;\n\t\t\trep(i,G[p.now].size()){\n\t\t\t\tedge e=G[p.now][i];\n\t\t\t\tint to=e.to;\n\t\t\t\tif(p.pre==to)continue;\n\t\t\t\tloop(k,-1,2)if(p.sp+k>0){\n\t\t\t\t\tif(h&&k)continue;\n\t\t\t\t\tint sp=p.sp+k;\n\t\t\t\t\tif(sp>e.sp)continue;\n\t\t\t\t\tdouble nowtim=p.tim+(double)e.cost/sp;\n\t\t\t\t\tif(nowtim<d[to][p.now][sp]){\n//\t\t\t\t\t\tcout<<to<<\" \"<<p.now<<\" \"<<nowtim<<\" \"<<sp<<endl;\n\t\t\t\t\t\td[to][p.now][sp]=nowtim;\n\t\t\t\t\t\tq.push(ver{to,p.now,nowtim,sp});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\th=false;\n\t\t}\n\t\tdouble mi=inf;\n\t\trep(i,32)mi=min(mi,d[t][i][1]);\n\t\tif(mi>inf-1000)cout<<\"unreachable\"<<endl;\n\t\telse cout<<shosu(9)<<mi<<endl;\n\t}\n};\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tDIJ dij(n);\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\twhile(m--){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tdij.add_edge(x-1,y-1,d,c);\n\t\t}\n\t\tdij.dij(s-1,t-1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\n\n#define INF 1145141919.810\n\nint n, m, s, g;\ndouble x[50][50][2];\nint a, b, c, d;\n\ndouble dp[50][50];\ndouble res;\n\ndouble solve(int p, int st, int go) {\n\tdp[st][0] = 0;\n\tfor (int i = 1; i <= p *10; i++) {\n\t\tfor (int j = 1; j <= p; j++) {\n\t\t\tfor (int k = 0; k <= 30; k++) {\n\t\t\t\tif (dp[j][k] < INF) {\n\t\t\t\t\tfor (int l = 0; l <= p; l++) {\n\t\t\t\t\t\tif (x[j][l][0] < 100000) {\n\t\t\t\t\t\t\t//v-1.\n\t\t\t\t\t\t\tif (k - 1 >= 1 && k - 1 <= x[j][l][1]) {\n\t\t\t\t\t\t\t\tdp[l][k - 1] = min(dp[l][k - 1], dp[j][k] + 1.0*x[j][l][0] / (k - 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//v.\n\t\t\t\t\t\t\tif (k >= 1 && k <= x[j][l][1]) {\n\t\t\t\t\t\t\t\tdp[l][k] = min(dp[l][k], dp[j][k] + 1.0*x[j][l][0] / k);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//v-1.\n\t\t\t\t\t\t\tif (k + 1 >= 1 && k + 1 <= x[j][l][1]) {\n\t\t\t\t\t\t\t\tdp[l][k + 1] = min(dp[l][k + 1], dp[j][k] + 1.0*x[j][l][0] / (k + 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[go][1];\n}\n\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tfor (int j = 0; j < 50; j++) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t\tx[i][j][0] = 10000000;\n\t\t\t\tx[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) { break; }\n\t\tcin >> s >> g;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tx[a][b][0] = c;\n\t\t\tx[a][b][1] = d;\n\t\t\tx[b][a][0] = c;\n\t\t\tx[b][a][1] = d;\n\t\t}\n\t\tres = solve(n, s, g);\n\t\tif (res > 1000000.00) { cout << \"unreachable\" << endl; }\n\t\telse { cout << fixed << setprecision(15) << res << endl; }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef vector<double> VD;\ntypedef vector< VD > VVD;\ntypedef vector< VVD > VVVD;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst LL MOD = 1000000007;\nconst double EPS = 1e-6;\n\nstruct Edge{\n\tEdge (int t, int d, int s) : to(t), dist(d), speed(s) {};\n\tint to, dist, speed;\n};\n\ntypedef tuple<double, int, int, int> State;\n\nconst double INF = DBL_MAX / 2;\nconst int SPEED_MAX = 30;\n\nint main(void) {\n\tfor (int N, M, S, G; cin >> N >> M, N;) {\n\t\tcin >> S >> G;\n\t\tS--; G--;\n\t\t\n\t\tvector< vector<Edge> > edges(N);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint from, to, dist, speed;\n\t\t\tcin >> from >> to >> dist >> speed;\n\t\t\tfrom--; to--;\n\t\t\tedges[from].push_back(Edge(to, dist, speed));\n\t\t\tedges[to].push_back(Edge(from, dist, speed));\n\t\t}\n\n\t\t// current, before, speed\n\t\tVVVD times(N, VVD(N, VD(SPEED_MAX, INF)));\n\t\ttimes[S][S][0] = 0;\n\n\t\tpriority_queue<State, vector<State>, greater<State>> q;\n\t\tq.emplace(0, S, S, 0);\n\n\t\twhile (q.size()) {\n\t\t\tState p = q.top();\n\t\t\tdouble now_time = get<0>(p);\n\t\t\tint current = get<1>(p);\n\t\t\tint before = get<2>(p);\n\t\t\tint speed = get<3>(p);\n\t\t\tq.pop();\n\n\t\t\tif (times[current][before][speed] + EPS < now_time) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int di = -1; di <= 1; di++) {\n\t\t\t\tint next_speed = speed + di;\n\t\t\t\tif (next_speed < 1 || SPEED_MAX < next_speed) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (auto &edge : edges[current]) {\n\t\t\t\t\tif (edge.to == before) { // U turn!!\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (edge.speed < next_speed) { // スピード違反!\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tauto &next_time = times[edge.to][current][next_speed];\n\t\t\t\t\tdouble cost = 1. * edge.dist / next_speed;\n\n\t\t\t\t\tif (next_time > cost + now_time + EPS) {\n\t\t\t\t\t\tnext_time = cost + now_time;\n\t\t\t\t\t\tq.emplace(next_time, edge.to, current, next_speed);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = INF;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tans = min(ans, times[G][i][1]);\n\t\t}\n\n\t\tif (ans == INF) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else {\n\t\t\tcout << fixed << setprecision(5) << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nconst int MAX = 35;\nconst int INF = (1<<25);\nint n,m;\n\nstruct Edge{\n  int to;\n  double dis,lim;\n  Edge(int a, double b, double c):to(a),dis(b),lim(c){}\n};\n\nstruct State{\n  int pos,from;\n  double speed,t;\n  State(int a, double b, double c, int f):pos(a),speed(b),t(c),from(f){}\n  bool operator < (const State& s) const{ return t > s.t;}\n};\n\nvector<Edge> E[MAX];\ndouble T[MAX][MAX][MAX];\n//T[i][j][k] := shortest time from i to j with speed k.\n\n\nvoid init(){\n  for(int i = 0; i < MAX; i++){\n    for(int j = 0; j < MAX; j++) for(int k = 0; k < MAX; k++) T[i][j][k] = INF;\n    E[i].clear();\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++){\n    int x,y;\n    double d,c;\n    cin >> x >> y >> d >> c;\n    //   cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    E[x].push_back(Edge(y,d,c));\n    E[y].push_back(Edge(x,d,c));\n  }\n}\n\nvoid solve(int s, int g){\n\n  priority_queue<State> Q;\n  T[0][s][0] = 0;\n  Q.push(State(s,0,0,-1));\n\n  while(!Q.empty()){\n    State sta = Q.top();\n    Q.pop();\n\n    if(sta.t > T[sta.from][sta.pos][(int)sta.speed]) continue;\n\n    for(int i = 0; i < E[sta.pos].size(); i++){\n      int np = E[sta.pos][i].to;\n\n      if(np == sta.from) continue;\n\n      double sp[] = {-1,0,1};\n      \n      for(int j = 0; j < 3; j++){\n\tdouble ns = sta.speed+sp[j];\n\tif(ns <= 0 || ns > E[sta.pos][i].lim) continue;\n\tdouble nt = sta.t+E[sta.pos][i].dis/ns;\n\tif(T[sta.pos][np][(int)ns] > nt){\n\t  T[sta.pos][np][(int)ns] = nt;\n\t  Q.push(State(np,ns,nt,sta.pos));\n\t}\n      }\n    }\n  }\n  \n\n  double ans = INF;\n\n  for(int i = 0; i < MAX; i++)\n    ans = min(ans,T[i][g][1]);\n\n  if(ans == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.5f\\n\",ans);\n}\n\nint main(){\n\n  while(cin >> n >> m && n+m){\n    init();\n    int s,g;\n    cin >> s >> g;\n    input();\n    solve(s,g);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S second\n#define F first\n#define EPS (1e-7)\n#define INF (1e9)\n#define N 31\nusing namespace std;\ntypedef pair<int,int> P1;\ntypedef pair<int,P1> P2;\ntypedef pair<double,P1> P3;\ntypedef pair<P3,int> P4;\n\nvector<P2> G[N];\nint n,m,s,g;\n\ndouble dijkstra(){\n  double d[N][N][N];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<N;k++)\n\td[i][j][k]=INF;\n  priority_queue<P4,vector<P4>,greater<P4> > q;\n  for(int i=0;i<G[s].size();i++){\n    int nx=G[s][i].first,cost=G[s][i].second.first;\n    d[s][nx][1]=cost;\n    q.push(P4(P3(cost,P1(s,nx)),1));\n  }\n  while(!q.empty()){\n    P4 t=q.top(); q.pop();\n    int px=t.F.S.F,x=t.F.S.S,v=t.S;\n    double cost=t.F.F;\n    if(d[px][x][v]+EPS<cost)continue;\n    if(x==g&&v==1)return cost;\n    for(int i=0;i<G[x].size();i++){\n      int nx=G[x][i].F,cost2=G[x][i].S.F;\n      int lim=G[x][i].S.S;\n      if(nx==px)continue;\n      for(int j=-1;j<=1;j++){\n\tint nv=v+j;\n\tif(nv<1||30<nv||nv>lim)continue;\n\tdouble ncost=cost+1.0*cost2/nv;\n\tif(d[x][nx][nv]>ncost+EPS){\n\t  d[x][nx][nv]=ncost;\n\t  q.push(P4(P3(ncost,P1(x,nx)),nv));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    cin>>s>>g;\n    s--,g--;\n    int a,b,c,d;\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>c>>d;\n      a--,b--;\n      G[a].push_back(P2(b,P1(c,d)));\n      G[b].push_back(P2(a,P1(c,d)));\n    }\n    double r=dijkstra();\n    if(r==-1)cout<<\"unreachable\"<<endl;\n    else printf(\"%.5f\\n\",r);\n    for(int i=0;i<n;i++)G[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=35,INF=1<<30;\nvector<pair<int,double>> G[MAX];\ndouble dis[MAX][MAX][MAX];\nint lim[MAX][MAX];\n\nstruct data{\n    double dis;\n    int now;\n    int from;\n    int v;\n};\n\nauto compare = [](data &A,data &B){\n    return A.dis>B.dis;\n};//Dijkstraで使うなら大きいもの\n\nvoid dijkstra(int u){\n    dis[u][32][1]=0;\n    priority_queue<data,vector<data>,decltype(compare)> PQ(compare);\n    \n    PQ.push({0.0,u,32,1});\n    while(!PQ.empty()){\n        data x=PQ.top();PQ.pop();\n        if(dis[x.now][x.from][x.v]<x.dis) continue;\n        if(x.v==0) continue;\n        \n        for(pair<int,double> to:G[x.now]){\n            for(int cha=-1;cha<=1;cha++){\n                if(x.v+cha<0||x.v+cha>lim[x.now][to.first]+1||x.v>lim[x.now][to.first]) continue;\n                if(to.first==x.from) continue;\n                \n                if(dis[to.first][x.now][x.v+cha]>dis[x.now][x.from][x.v]+to.second/x.v){\n                    dis[to.first][x.now][x.v+cha]=dis[x.now][x.from][x.v]+to.second/x.v;\n                    PQ.push({dis[to.first][x.now][x.v+cha],to.first,x.now,x.v+cha});\n                }\n            }\n        }\n    }\n    return;\n}//a,dが長さ\n\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N,M;cin>>N>>M;\n        if(N+M==0) break;\n        \n        for(int i=0;i<N;i++){\n            G[i].clear();\n        }\n        memset(lim,0,sizeof(lim));\n        \n        for(int i=0;i<MAX;i++) for(int j=0;j<MAX;j++) for(int k=0;k<MAX;k++) dis[i][j][k]=INF;\n        \n        int s,g;cin>>s>>g;\n        s--;g--;\n        \n        for(int i=0;i<M;i++){\n            int a,b,c,d;cin>>a>>b>>c>>d;\n            a--;b--;\n            G[a].push_back({b,c});\n            G[b].push_back({a,c});\n            lim[a][b]=d;\n            lim[b][a]=d;\n        }\n        \n        dijkstra(s);\n        \n        double ans=INF;\n        \n        /*for(int j=0;j<N;j++){\n            for(int k=0;k<N;k++){\n                cout<<dis[1][j][k]<<\" \";\n            }\n            cout<<endl;\n        }*/\n        \n        for(int i=0;i<N;i++){\n            ans=min(ans,dis[g][i][0]);\n        }\n        \n        if(ans==INF) cout<<\"unreachable\"<<endl;\n        else cout<<setprecision(25)<<ans<<endl;\n    }\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ndouble ijk[30][31];\nint v[30][31];\nint g[30][30];\nint lim[30][30];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tint S,T;\n\t\tscanf(\"%d%d\",&S,&T);\n\t\tS--;T--;\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tg[i][j]=-1;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tp--;q--;\n\t\t\tg[p][q]=g[q][p]=r;\n\t\t\tlim[p][q]=lim[q][p]=s;\n\t\t}\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<31;j++){ijk[i][j]=99999999;v[i][j]=0;}\n\t\tpriority_queue<pair<double,pair<int,int> > >Q;\n\t\tQ.push(make_pair(0,make_pair(S,1)));\n\t\tijk[S][1]=0;\n\t\twhile(Q.size()){\n\t\t\tdouble cost=-Q.top().first;\n\t\t\tint at=Q.top().second.first;\n\t\t\tint ver=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(v[at][ver])continue;\n\t\t\tv[at][ver]=1;\n\t\t//\tprintf(\"%d %d: %f\\n\",at,ver,ijk[at][ver]);\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tif(ver&&~g[at][i]&&lim[at][i]>=ver){\n\t\t\t\t\tif(ijk[i][ver-1]>cost+(double)g[at][i]/ver){\n\t\t\t\t\t\tijk[i][ver-1]=cost+(double)g[at][i]/ver;\n\t\t\t\t\t\tQ.push(make_pair(-ijk[i][ver-1],make_pair(i,ver-1)));\n\t\t\t\t\t}\n\t\t\t\t\tif(ijk[i][ver]>cost+(double)g[at][i]/ver){\n\t\t\t\t\t\tijk[i][ver]=cost+(double)g[at][i]/ver;\n\t\t\t\t\t\tQ.push(make_pair(-ijk[i][ver],make_pair(i,ver)));\n\t\t\t\t\t}\n\t\t\t\t\tif(ver<30&&ijk[i][ver+1]>cost+(double)g[at][i]/ver){\n\t\t\t\t\t\tijk[i][ver+1]=cost+(double)g[at][i]/ver;\n\t\t\t\t\t\tQ.push(make_pair(-ijk[i][ver+1],make_pair(i,ver+1)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ijk[T][0]>9999999)printf(\"unreachable\\n\");\n\t\telse printf(\"%f\\n\",ijk[T][0]);\n\t\t//printf(\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tstatic int adj[30][30],lim[30][30];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)\tadj[i][j]=-1;\n\n\t\tint s,g;\tscanf(\"%d%d\",&s,&g);\n\t\ts--,g--;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,l;\tscanf(\"%d%d%d%d\",&x,&y,&d,&l);\n\t\t\tx--,y--;\n\t\t\tadj[x][y]=adj[y][x]=d;\n\t\t\tlim[x][y]=lim[y][x]=l;\n\t\t}\n\n\t\tstatic bool visited[30][31];\n\t\tstatic double tmin[30][31];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<=30;j++){\n\t\t\tvisited[i][j]=false;\n\t\t\ttmin[i][j]=1<<30;\n\t\t}\n\n\t\ttmin[s][0]=0;\n\t\tpriority_queue< pair<double,pii> > pq;\tpq.push(mp(0,mp(s,0)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<double,pii> a=pq.top();\tpq.pop();\n\t\t\tint u=a.second.first,sp=a.second.second;\n\t\t\tif(visited[u][sp])\tcontinue;\n\t\t\tvisited[u][sp]=true;\n\t\t\tif(u==g && sp==1)\tbreak;\n\n\t\t\tfor(int v=0;v<n;v++){\n\t\t\t\tif(adj[u][v]==-1)\tcontinue;\n\t\t\t\tfor(int dv=-1;dv<=1;dv++){\n\t\t\t\t\tint nextsp=sp+dv;\n\t\t\t\t\tif(1<=nextsp && nextsp<=lim[u][v]){\n\t\t\t\t\t\tdouble nextt=tmin[u][sp]+(double)adj[u][v]/nextsp;\n\t\t\t\t\t\tif(nextt<tmin[v][nextsp]){\n\t\t\t\t\t\t\tpq.push(mp(-nextt,mp(v,nextsp)));\n\t\t\t\t\t\t\ttmin[v][nextsp]=nextt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(visited[g][1])\tprintf(\"%f\\n\",tmin[g][1]);\n\t\telse\t\t\t\tputs(\"unreachable\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint n,m,s,t;\ndouble dist[60010];\n\nint vnum(int i,int j,int v,int b) {\n    return i*900+j*30+v-1+27000*b;\n}\n\nsigned main() {\n    cout<<fixed<<setprecision(10);\n\n    while(cin>>n>>m,n) {\n        fill(dist,dist+60010,2e9);\n\n        cin>>s>>t;\n        s--,t--;\n        vector<vector<pair<int,double>>> G(60010);\n\n        for(int i=0; i<n; ++i) {\n            for(int j=0; j<n; ++j) {\n                for(int v=1; v<=30; ++v) {\n                    for(int k=-1; k<=1; ++k) {\n                        if(v+k>0 && v+k<=30) {\n                            G[vnum(i,j,v,0)].emplace_back(vnum(i,j,v+k,1),0);\n                        }\n                    }\n                }\n            }\n        }\n\n        while(m--) {\n            int x,y,c;\n            double d;\n            cin>>x>>y>>d>>c;\n            x--,y--;\n\n            for(int v=1; v<=c; ++v) {\n                for(int  j=0; j<n; ++j) {\n                    if(j!=x) {\n                        G[vnum(y,j,v,1)].emplace_back(vnum(x,y,v,0),d/(double)v);\n                    }\n                    if(j!=y) {\n                        G[vnum(x,j,v,1)].emplace_back(vnum(y,x,v,0),d/(double)v);\n                    }\n                }\n            }\n        }\n\n        priority_queue<pair<double,int>> mhp;\n        mhp.emplace(0,vnum(s,s,1,1));\n        dist[vnum(s,s,1,1)]=0;\n\n        while(!mhp.empty()) {\n            int v; double d;\n            tie(d,v)=mhp.top();\n            d=-d;\n            mhp.pop();\n            if(d>dist[v]) continue;\n            for(auto &e:G[v]) {\n                if(d+e.second<dist[e.first]) {\n                    dist[e.first]=d+e.second;\n                    mhp.emplace(-dist[e.first],e.first);\n                }\n            }\n        }\n\n        double ans=2e9;\n        for(int j=0; j<n; ++j) {\n            if(j!=t) ans=min(ans,dist[vnum(t,j,1,0)]);\n        }\n\n        if(ans<2e9) cout<<ans<<endl;\n        else cout<<\"unreachable\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\n\n\n\nint main(){\n  int inx,iny,ind,inc;\n  double d[40][40][40];\n  int n,m,s,g;\n \n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];    \n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair((a),(b))\n#define list3(a,b,c) mp((a),mp((b),(c)))\n#define list4(a,b,c,d) mp((a),list3((b),(c),(d)))\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint vis[40][40][40];\nint n,m;\nvector<pair<int,PI > > G[40];\n\nvoid solve(){\n  int s,g;\n  cin >> s >> g;\n  --s,--g;\n  rep(i,n) G[i].clear();\n  rep(i,m){\n    int x,y,d,m;\n    cin >> x >> y >> d >> m;\n    --x,--y;\n    G[x].pb(mp(y,mp(d,m)));\n    G[y].pb(mp(x,mp(d,m)));\n  }\n  \n  priority_queue<pair<double,pair<int,PI > > > q;\n  q.push(list4(0.,s,1,s));\n  CLR(vis);\n  bool fl=true;\n  while(!q.empty()){\n    double cc=-q.top().F;\n    int cv=q.top().S.F;\n    int cs=q.top().S.S.F;\n    int be=q.top().S.S.S;\n    q.pop();\n\n    if(vis[cv][cs][be]) continue;\n    //cout << cc << ' ' << cv << ' ' << cs << ' ' << be << endl;\n    if(cv==g && cs==1){\n      printf(\"%8f\\n\",cc);\n      return;\n    }    \n    vis[cv][cs][be] = true;\n    FOR(it,G[cv]){\n      if(it->F==be) continue;\n      for(int di=-1;di<=1;++di){\n\tint ns=cs+di;\n\tif(ns<=0 || ns>it->S.S) continue;\n\tif(fl && ns!=1) continue;\n\tq.push(list4(-cc-it->S.F*1./ns,it->F,ns,cs));\n      }\n    }\n    fl=false;\n  }\n  cout << \"unreachable\" << endl;\n}\n\nint main(){\n  while(cin >> n >> m && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <iomanip>\nusing namespace std;\nconst int inf = 1e9;\n\nstruct info{\n    int curr;\n    int prev;\n    int v;\n    double t;\n    info(int c, int p, int v, double t):curr(c),prev(p),v(v),t(t){}\n};\nnamespace std{\n    bool operator < (const info &a, const info &b){\n        return b.t < a.t;\n    }\n}\n\nint main(){\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n==0) break;\n\n        int s,g;\n        cin >> s >> g;\n        vector<vector<int> > dist(n+1, vector<int>(n+1, inf));\n        vector<vector<int> > limit(n+1, vector<int>(n+1, 0));\n        vector<info> map[31][31][31];\n        \n        for(int i=0; i<m; i++){\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            dist[x][y] = dist[y][x] = d;\n            limit[x][y] = limit[y][x] = c;\n        }\n\n        for(int i=1; i<=n; i++){ //curr\n            for(int j=1; j<=n; j++){ //prev\n                for(int k=1; k<=n; k++){ //next\n                    if(k==j || dist[i][k]==inf) continue;\n                    for(int v=1; v<=30; v++){ //speed\n                        for(int r=-1; r<=1; r++){\n                            if(v+r>0 && v+r <= limit[i][k]){\n                                map[i][j][v].push_back(info(k, i, v+r, (double)dist[i][k]/(v+r)));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for(int i=1; i<=n; i++){\n            if(dist[s][i] != inf){\n                map[s][0][1].push_back(info(i, s, 1, dist[s][i]));\n            }\n        }\n\n        priority_queue<info> pq;\n        pq.push(info(s, 0, 1, 0));\n        vector<vector<vector<double> > > mincost(n+1, vector<vector<double> >(n+1, vector<double>(31, inf)));\n        mincost[s][0][1] = 0;\n        while(!pq.empty()){\n            int curr = pq.top().curr;\n            int prev = pq.top().prev;\n            int v = pq.top().v;\n            double cost = pq.top().t;\n            pq.pop();\n            if(cost > mincost[curr][prev][v]) continue;\n            if(curr==g && v==1) break;\n            for(int i=0; i<(int)map[curr][prev][v].size(); i++){\n                info next = map[curr][prev][v][i];\n                if(cost + next.t < mincost[next.curr][next.prev][next.v]){\n                    pq.push(info(next.curr, next.prev, next.v, cost+next.t));\n                    mincost[next.curr][next.prev][next.v] = cost + next.t;\n                }\n            }\n        }\n        double ans=inf;\n        for(int i=1; i<=n; i++){\n            ans = min(ans, mincost[g][i][1]);\n        }\n        if(ans == inf){\n            cout << \"unreachable\" << endl;\n        }else{\n            cout << fixed;\n            cout << setprecision(10);\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<class EdgeInfo>\nclass Graph {\nprotected:\n\tusing size_type = ::std::size_t;\n\tstruct Edge {\n\t\tsize_type to;\n\t\tEdgeInfo info;\n\t\tEdge() : to(-1) {}\n\t\tEdge(size_type to_, EdgeInfo info_) : to(to_), info(info_) {}\n\t};\n\tusing edge_type = Edge;\n\n\t::std::vector<::std::vector<edge_type>> edges;\n\npublic:\n\tGraph() {}\n\tGraph(size_type n) : edges(n) {}\n\tGraph(const Graph& g) : edges(g.edges) {}\n\tGraph(Graph&& g) { ::std::swap(edges, g.edges); }\n\tGraph& operator=(const Graph& g) { edges = g.edges; }\n\tGraph& operator=(Graph&& g) { ::std::swap(edges, g.edges); }\n\n\tconst size_type size() { return edges.size(); }\n\tvirtual void add_edge (size_type from, size_type to, EdgeInfo info) = 0;\n\n\tconst ::std::vector<edge_type>& operator[](size_type k) { return edges[k]; }\n\n};\n\ntemplate<class EdgeInfo>\nclass DirectedGraph : public Graph<EdgeInfo> {\nprotected:\n\tusing size_type = ::std::size_t;\npublic:\n\tusing edge_type = typename Graph<EdgeInfo>::edge_type;\n\tDirectedGraph() {}\n\tDirectedGraph(size_type n) : Graph<EdgeInfo>(n) {}\n\tDirectedGraph(const DirectedGraph& g) : Graph<EdgeInfo>(g) {}\n\tDirectedGraph(DirectedGraph&& g) : Graph<EdgeInfo>(g) {}\n\tDirectedGraph& operator=(const DirectedGraph& g) { this->edges = g.edges; return *this;}\n\tDirectedGraph& operator=(DirectedGraph&& g) noexcept { ::std::swap(this->edges, g.edges); return *this; }\n\n\tvoid add_edge (size_type from, size_type to, EdgeInfo info = EdgeInfo()) {\n\t\tthis->edges[from].push_back(edge_type(to, info));\n\t}\n};\n\ntemplate<class DistanceType>\nclass Dijkstra {\nprivate:\n\tusing size_type = ::std::size_t;\n\tusing distance_type = DistanceType;\n\tusing Graph = DirectedGraph<distance_type>;\n\n\tGraph graph;\npublic:\n\tDijkstra() {}\n\tDijkstra(size_type n) : graph(n) {}\n\tDijkstra(const Graph& g) : graph(g) {}\n\n\tvoid add_edge (size_type from, size_type to, distance_type d) {\n\t\tgraph.add_edge(from, to, d);\n\t}\n\n\t::std::vector<distance_type> build(size_type start) {\n\t\t::std::vector<distance_type> dis(graph.size(), invalid_value());\n\n\t\tusing P = ::std::pair<distance_type, size_type>;\n\t\t::std::priority_queue<P, ::std::vector<P>, ::std::greater<P>> pq;\n\t\tdis[start] = 0;\n\t\tpq.push(P(dis[start], start));\n\t\twhile (pq.size()) {\n\t\t\tP p = pq.top(); pq.pop();\n\t\t\tif (p.first > dis[p.second]) continue;\n\t\t\tfor (auto e : graph[p.second]) {\n\t\t\t\tif (dis[e.to] > dis[p.second] + e.info) {\n\t\t\t\t\tdis[e.to] = dis[p.second] + e.info;\n\t\t\t\t\tpq.push(P(dis[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dis;\n\t}\n\n\tstatic const distance_type invalid_value () {\n\t\tstatic const distance_type inf = ::std::numeric_limits<distance_type>::max() / 2 - 1;\n\t\treturn inf;\n\t}\n};\n\nint main(void) {\n  int64 n, m;\n  while (cin >> n >> m && n+m) {\n    Dijkstra<double> shp(2*n*(40));\n    int64 s, g;\n    cin >> s >> g; s--; g--;\n    int64 to = n*(40);\n    int64 dd = 40;\n    REP(i, n) {\n      REP(j, 40) {\n        if (j < 39) {\n          shp.add_edge(dd*i+j, to+dd*i+j+1, 0);\n        }\n        shp.add_edge(dd*i+j, to+dd*i+j, 0);\n        if (j > 0) {\n          shp.add_edge(dd*i+j, to+dd*i+j-1, 0);\n        }\n      }\n    }\n    REP(i, m) {\n      int64 x, y, d, c;\n      cin >> x >> y >> d >> c; x--; y--;\n      REP(j, c) {\n        shp.add_edge(to+dd*x+j, dd*y+j, (double)d/(double)(j+1));\n        shp.add_edge(to+dd*y+j, dd*x+j, (double)d/(double)(j+1));\n      }\n    }\n    auto res = shp.build(to+s*dd);\n    if (res[dd*g] == shp.invalid_value()) {\n      cout << \"unreachable\" << endl;\n    } else {\n      cout << fixed << setprecision(10) << res[dd*g] << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<cstdio>\n#define INF 1e10\n#define EPS 1e-10\nusing namespace std;\nstruct edge{\n  int to,limit;\n  double dist;\n};\nvector<edge> G[100];\ndouble d[40][100];\nbool used[40][100];\ntypedef pair<int,int> pii; //to,speed\ntypedef pair<double,pii> P;//cost,to,speed\n\ndouble dikstra(int s,int g){\n  int ds[3]={-1,0,1};\n  priority_queue<P,vector<P>,greater<P> > que;\n  for(int i=0;i<40;i++)\n    for(int j=0;j<100;j++)\n      d[i][j]=INF;\n  memset(used,0,sizeof(used));\n  d[0][s]=0;\n  que.push(P(0,pii(s,0)));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int speed=p.second.second;\n    int v=p.second.first;\n    double cost=p.first;\n    //cout << v << \";\" << speed <<\":\" << cost << endl;\n    if(d[speed][v]<cost)continue;\n    for(int i=0;i<G[v].size();i++){\n      for(int j=0;j<3;j++){\n\tedge e=G[v][i];\n\tint ns=speed+ds[j];\n\tif(1<=ns && ns<= e.limit &&\n\t   used[ns][e.to]==false){\n\t  used[ns][e.to]=true;\n\t  que.push(P(cost+e.dist/ns,pii(e.to,ns)));\n\t  if(d[ns][e.to]>cost+e.dist/ns){\n\t    d[ns][e.to]=cost+e.dist/ns;\n\t    //cout << \"d[\" << ns << \"][\" << e.to << \"]:\" << d[ns][e.to] << endl;\n\t    //cout << \"d[\" << v << \"]:\" << d[speed][v] << \" speed:\" << speed<< endl;\n\t  }\n\t}\n      }\n    }\n  }\n  if(d[1][g]==INF)return -1;\n  return d[1][g];\n}\n\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n){\n    for(int i=0;i<100;i++)G[i].clear();\n    cin>>s>>g;\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      G[x].push_back((edge){y,c,d});\n      G[y].push_back((edge){x,c,d});\n    }\n    double ans=dikstra(s,g);\n    if(ans==-1)cout << \"unreachable\" << endl;\n    else printf(\"%lf\\n\",ans);\n    // for(int i=0;i<=n;i++)\n    // \tcout << i << \" \" << d[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef vector< vector<int> > graph;\n\nclass Node{\npublic:\n\tint p, v, prev; double cost;\n\tNode(int p, int v, int prev, double cost) : p(p), v(v), prev(prev), cost(cost) {}\n\tbool operator < (const Node &nd) const { return cost > nd.cost; }\n};\n\nint main(){\n\tint n, m, s, g;\n\twhile(cin >> n >> m){\n\t\tif(!(n||m)) break;\n\t\tcin >> s >> g;\n\t\tgraph gp(n);\n\t\tint dist[30][30];\n\t\tint limit[30][30];\n\t\tbool visit[30][31][30];\n\t\tmemset(visit, false, sizeof(visit));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tgp[x-1].push_back(y-1);\n\t\t\tgp[y-1].push_back(x-1);\n\t\t\tdist[x-1][y-1] = d,  dist[y-1][x-1] = d;\n\t\t\tlimit[x-1][y-1] = c, limit[y-1][x-1] = c;\n\t\t}\n\t\tpriority_queue<Node> qu; qu.push(Node(s-1,0,s-1,0.0));\n\t\tdouble ans = -1.0;\n\t\twhile(!qu.empty()){\n\t\t\tNode nd = qu.top(); qu.pop();\n\t\t\tint p = nd.p, v = nd.v, prev = nd.prev;\n\t\t\tif(visit[p][v][prev]) continue;\n\t\t\tvisit[p][v][prev] = true;\n\t\t\tif(p==g-1 && v==1){\n\t\t\t\tans = nd.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<gp[p].size();i++){\n\t\t\t\tint next = gp[p][i];\n\t\t\t\tif(next==prev) continue;\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tint nv = v+j;\n\t\t\t\t\tif(nv<=0||limit[p][next]<nv) continue;\n\t\t\t\t\tqu.push(Node(next,nv,p,nd.cost+(double)dist[p][next]/nv));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans < 0.0) cout << \"unreachable\" << endl;\n\t\telse          printf(\"%.5f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nstringstream __ss__;\n#define debug __ss__\n#endif\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) debug << *i << \" \"; debug << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;i--)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);i--)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint x[900],y[900],d[900],c[900];\ndouble mn[40][40][40];\n\nclass hoge{\npublic:\n\tdouble time;\n\tint from,to,speed;\n\tbool operator<(const hoge &h)const{return time>h.time;}\n};\n\nint main() {\n\tint n,m,s,g;\n\tIL{\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)break;\n\t\tcin>>s>>g;\n\t\trep(i,m){\n\t\t\tcin>>x[i]>>y[i]>>d[i]>>c[i];\n\t\t}\n\t\trep(i,40)rep(j,40)rep(k,40)mn[i][j][k]=1000000000;\n\t\tpriority_queue<hoge> que;\n\t\thoge h;\n\t\th.time=0;\n\t\th.from=s;\n\t\th.to=s;\n\t\th.speed=1;\n\t\tque.push(h);\n\t\twhile(!que.empty()){\n\t\t\thoge now=que.top();\n\t\t\thoge next;\n\t\t\tque.pop();\n\t\t\tif(mn[now.from][now.to][now.speed]<=now.time)continue;\n\t\t\tmn[now.from][now.to][now.speed]=now.time;\n\t\t\trep(i,m){\n\t\t\t\tif(now.speed>c[i])continue;\n\t\t\t\tif(x[i]==now.to){\n\t\t\t\t\tif(y[i]==now.from)continue;\n\t\t\t\t\tnext.to=y[i];\n\t\t\t\t}else if(y[i]==now.to){\n\t\t\t\t\tif(x[i]==now.from)continue;\n\t\t\t\t\tnext.to=x[i];\n\t\t\t\t}else{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnext.from=now.to;\n\t\t\t\tnext.time=now.time+(double)d[i]/(now.speed);\n\t\t\t\tnext.speed=now.speed;\n\t\t\t\tque.push(next);\n\t\t\t\tnext.speed=now.speed+1;\n\t\t\t\tque.push(next);\n\t\t\t\tif(now.speed==1){\n\t\t\t\t\tif(next.to==g){\n\t\t\t\t\t\tprintf(\"%.12lf\\n\",next.time);\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnext.speed=now.speed-1;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t\tcout<<\"unreachable\"<<endl;\n\t\tcontinue;\n\t\tend:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\npriority_queue<pair<double,int>,vector<pair<double, int>>, greater<pair<double, int>> > pq;\ndouble min_t[31][31][31];\nint N, M, S, G;\nint x, y, d, c;\nstruct R {int to, d, c;};\nvector<R> town[31];\n\nint main() {\n\t/*ifstream in(\"Ain.txt\");\n\tcin.rdbuf(in.rdbuf());\n\tofstream ofs(\"Aout.txt\");\n\tcout.rdbuf(ofs.rdbuf());*/\n\twhile(cin >> N >> M, N) {\n\t\tfor(int i = 0; i < 31; i++) town[i].clear();\n\t\tfor(int i = 0; i < 31; i++) for(int j = 0; j < 31; j++) for(int k = 0; k < 31; k++) min_t[i][j][k] = 20000000.0;\n\t\tcin >> S >> G;\n\t\tfor (int m = 0; m < M; m++) {\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\ttown[x].push_back((R){y, d, c});\n\t\t\ttown[y].push_back((R){x, d, c});\n\t\t}\n\t\n\tpq.push(make_pair(0.0, S * 31));\n\twhile (!pq.empty()) {\n\t\tdouble t = pq.top().first;\n\t\tint u = pq.top().second / 1000;\n\t\tint p = (pq.top().second - u * 1000) / 31;\n\t\tint v = (pq.top().second - u * 1000) % 31;\n\t\tpq.pop();\n\t\tfor (auto r : town[p]) {\n\t\t\tif (r.to == u) continue;\n\t\t\tfor(int v2 = max(1, v - 1); v2 <= min(r.c, v + 1); v2++) {\n\t\t\t\tdouble t2 = t + (double)r.d / (double)v2;\n\t\t\t\tif (min_t[r.to][v2][u] > t2) {\n\t\t\t\t\tmin_t[r.to][v2][u] = t2;\n\t\t\t\t\tpq.push(make_pair(t2, p * 1000 + r.to * 31 + v2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t\tdouble ans = 2e7;\n\t\tfor (int k = 0; k < 31; k++) ans = min(ans ,min_t[G][1][k]);\n\t\tif (ans == 2e7) cout << \"unreachable\" << endl;\n\t\telse cout << ans << endl;\n\t}\n}\n\t\n\t\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <cstdio>\n#include <set>\n#include <map>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstruct edge{\n\tint to;\n\tdouble dist;\n\tint c;\n\tedge(int t, double d, int c):to(t), dist(d), c(c){}\n};\n\nstruct state{\n\tint pos;\n\tdouble total;\n\tint speed;\n\tint prev;\n\tstate(int p, double t, int s, int pr):pos(p), total(t), speed(s), prev(pr){}\n\tbool operator<(const state &r)const {\n\t\treturn total > r.total;\n\t}\n};\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\tcout.setf(ios::fixed);\n\tcout.precision(8);\n\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\ts--, g--;\n\t\tvector<vector<edge> > G(n);\n\t\trep(i, m){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--, y--;\n\t\t\tG[x].push_back(edge(y, d, c));\n\t\t\tG[y].push_back(edge(x, d, c));\n\t\t}\n\n\t\tpriority_queue<state> q;\n\t\tq.push(state(s, 0, 0, s));\n\n\t\tvector<vector<vector<double> > > best(n, vector<vector<double> >(n, vector<double>(31, 1e30))); // pos, prev, speed\n\n\t\tdouble ans = -1;\n\t\twhile(!q.empty()){\n\t\t\tstate st = q.top();\n\t\t\tq.pop();\n\n\t\t\tif(best[st.pos][st.prev][st.speed] < st.total) continue;\n\n\t\t\tif(st.pos == g && st.speed == 1){\n\t\t\t\tans = st.total;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, G[st.pos].size()){\n\t\t\t\tif(st.prev == G[st.pos][i].to) continue;\n\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\tstate next = st;\n\t\t\t\t\tnext.speed += j;\n\t\t\t\t\tif(next.speed <= 0 || next.speed > G[st.pos][i].c) continue;\n\t\t\t\t\tnext.pos = G[st.pos][i].to;\n\t\t\t\t\tnext.prev = st.pos;\n\t\t\t\t\tnext.total += G[st.pos][i].dist/next.speed;\n\t\t\t\t\tif(next.total < best[next.pos][next.prev][next.speed]){\n\t\t\t\t\t\tbest[next.pos][next.prev][next.speed] = next.total;\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == -1) cout << \"unreachable\" << endl;\n\t\telse cout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nusing tp = tuple<int, int, int>;\nusing ttp = tuple<ld, int, int, int>;\n\nconst ld INF = 1e20;\n\nint main()\n{\n\tcout << fixed << setprecision(5);\n\tint n, m;\n\twhile (cin >> n >> m, n | m) {\n\t\tint s, g;\n\t\tcin >> s >> g; s--, g--;\n\t\tvector<vector<tp>> G(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c; x--, y--;\n\t\t\tG[x].emplace_back(y, d, c);\n\t\t\tG[y].emplace_back(x, d, c);\n\t\t}\n\t\tvector<vector<vector<ld>>> d(n, vector<vector<ld>>(n, vector<ld>(33, INF)));\n\t\tpriority_queue<ttp, vector<ttp>, greater<ttp>> pq;\n\t\tpq.emplace(0.0, 0, s, s);\n\t\twhile (!pq.empty()) {\n\t\t\tauto p = pq.top(); pq.pop();\n\t\t\tint v = get<2>(p), f = get<3>(p), ve = get<1>(p);\n\t\t\tld cos = get<0>(p);\n\t\t\tif (d[v][f][ve] != INF) continue;\n\t\t\td[v][f][ve] = cos;\n\t\t\tfor (auto e : G[v]) {\n\t\t\t\tint to = get<0>(e), st = get<2>(e);\n\t\t\t\tld dis = get<1>(e);\n\t\t\t\tif (to == f) continue;\n\t\t\t\tfor (int i = -1; i <= 1; i++) if (ve + i <= st) {\n\t\t\t\t\tif (d[to][v][ve + i] == INF) {\n\t\t\t\t\t\tpq.emplace(cos + dis / (ve + i), ve + i, to, v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tld res = INF;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres = min(res, d[g][i][1]);\n\t\t}\n\t\tif (res == INF) cout << \"unreachable\" << endl;\n\t\telse cout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_N = 35;\nconst int MAX_C = 35;\nconst int INF = 1e9 + 7;\nconst int D_INF = (double)1e5;\n\nclass C{\n  public:\n    int now, bef, c;\n    double sum;\n    C(int _n, int _b, int _c, double _s){ now = _n; bef = _b; c = _c; sum = _s; }\n    C(){}\n    bool operator > (const C &cc) const { return sum > cc.sum; }\n};\n\nint N, M, S, G;\n// P(距離, 制限速度), P(INF, INF)で無し\nP v[MAX_N][MAX_N];\n\ndouble dij(){\n  priority_queue<C, vector<C>, greater<C> > open;\n  open.push( C(S, MAX_N - 1, 1, 0.0) );\n  double closed[MAX_N][MAX_N][MAX_C];\n  REP(i, MAX_N) REP(j, MAX_N) REP(k, MAX_C) closed[i][j][k] = D_INF;\n  while(!open.empty()){\n    C tmp = open.top(); open.pop();\n    int now = tmp.now, bef = tmp.bef, c = tmp.c;\n    double sum = tmp.sum;\n    //cout <<\"now = \" <<now + 1 <<\", bef = \" <<bef + 1 <<\", c = \" <<c <<\", sum = \" <<sum <<endl;\n    if(c == 1 && now == G){\n      closed[now][bef][c] = min(closed[now][bef][c], sum);\n      break;\n    }\n    //if(closed[now][bef][c] <= sum) continue;\n    REP(i, N){\n      if(v[now][i].first == INF || i == bef) continue;\n      for(int pls = -1; pls <= 1; ++pls){\n        int next_c = c + pls;\n        if(bef == MAX_N - 1 && pls != 0) continue;\n        double next_sum = sum + ((double)(v[now][i].first) / next_c);\n        if(next_c > v[now][i].second || next_c <= 0 || closed[i][now][next_c] <= next_sum) continue;\n        closed[i][now][next_c] = next_sum;\n        open.push( C(i, now, next_c, next_sum) );\n      }\n    }\n  }\n  double ret = D_INF;\n  REP(i, N) ret = min(ret, closed[G][i][1]);\n  return ret;\n}\n\nint main() {\n  while(cin >>N >>M && N){\n    cin >>S >>G;\n    --S; --G;\n    REP(i, N) REP(j, N) v[i][j] = P(INF, INF);\n    REP(i, M){\n      int x, y, d, c; cin >>x >>y >>d >>c;\n      --x; --y;\n      v[x][y] = P(d, c);\n      v[y][x] = P(d, c);\n    }\n    //REP(i, N){\n    //  cout <<i <<\": \";\n    //  REP(j, N) cout <<v[i][j].first <<\", \" <<v[i][j].second <<endl;\n    //  cout <<endl;\n    //}\n    double ans = dij();\n    if(ans == D_INF) cout <<\"unreachable\" <<endl;\n    else printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i,a) for(int i=0;i<a;i++)\n\nint n, m;\nint s, g;\n\nstruct edge\n{\n    int to, d, c;\n\n    edge() {}\n    edge(int to, int d, int c) \n        : to(to), d(d), c(c) {}\n};\n\nvector<vector<edge> > E;\n\nstruct node\n{\n    double cost;\n    int prev, v, speed;\n\n    node() {}\n    node(double cost, int prev, int v, int speed)\n        : cost(cost), prev(prev), v(v), speed(speed) {}\n    bool operator <(const node& t) const {\n        return cost > t.cost;\n    }\n};\n\ndouble mem[32][32][32];\n\nvoid solve()\n{\n    rep(i,32)rep(j,32)rep(k,32)mem[i][j][k]=1e15;\n\n    priority_queue<node> q;\n    q.push(node(0.0, n, 0, 0));\n    while (!q.empty()) {\n        double cost = q.top().cost;\n        int prev = q.top().prev;\n        int v = q.top().v;\n        int speed = q.top().speed;\n        q.pop();\n\n        // cerr<<cost<<' '<<prev<<' '<<v<<' '<<speed<<endl;\n\n        if (mem[prev][v][speed] <= cost)\n            continue;\n        if (v == g && speed == 1) {\n            printf(\"%.8f\\n\", cost);\n            return;\n        }\n\n        mem[prev][v][speed] = cost;\n\n        rep(i, E[v].size()) {\n            if (E[v][i].to == prev)\n                continue;\n            for (int ns = speed - 1; ns <= speed + 1; ++ns) {\n                if (ns > 0 && ns <= E[v][i].c) {\n                    q.push(node(cost + (double) E[v][i].d / ns, v, E[v][i].to, ns));\n                }\n            }\n        }\n    }\n    cout << \"unreachable\" << endl;\n}\n\nint main()\n{\n    while (cin >> n >> m && n) {\n        cin >> s >> g;\n        --s, --g;\n        E.clear();\n        E.resize(n);\n        rep(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            --x, --y;\n            E[x].push_back(edge(y, d, c));\n            E[y].push_back(edge(x, d, c));\n        }\n\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 99\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[40];    \n    \n    int inx,iny,ind,inc;\n    double d[40][40][40];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstruct edge{int to, dist, v;};\n\nvector<edge> G[35];\ndouble d[35][35];\nsigned main(void)\n{\n  while(true) {\n    int n, m, s, g;\n    cin >> n >> m;\n    if(!n && !m) break;\n    cin >> s >> g;\n    s--; g--;\n    REP(i, n) G[i].erase(ALL(G[i]));\n    REP(i, m) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      x--; y--;\n      G[x].PB((edge){y, d, c});\n      G[y].PB((edge){x, d, d});\n    }\n\n    priority_queue<vector<double>, vector<vector<double>>, greater<vector<double>>> pq;\n    pq.push({0, (double)s, 0, -1});\n    REP(i, 35) REP(j, 35) d[i][j] = INF;\n    d[s][0] = 0;\n    while(pq.size()) {\n      vector<double> p = pq.top(); pq.pop();\n      int a = p[1], v = p[2], pa = p[3];\n      //cout << a << \" \" << v << endl;\n      if(a == g && v == 1) continue;\n      REP(i, G[a].size()) {\n        edge e = G[a][i];\n        if(e.to == pa) continue;\n        //v-1??¨v??¨v+1?????????\n        if(0 < v-1 && v-1 <= e.v && d[e.to][v-1] > d[a][v] + (double)e.dist/(v-1)) {\n          d[e.to][v-1] = d[a][v] + (double)e.dist/(v-1);\n          pq.push({d[e.to][v-1], (double)e.to, (double)v-1, (double)a});\n        }\n        if(0 < v && v <= e.v && d[e.to][v] > d[a][v] + (double)e.dist/(v)){\n          d[e.to][v] = d[a][v] + (double)e.dist/(v);\n          pq.push({d[e.to][v], (double)e.to, (double)v, (double)a});\n        }\n        if(0 < v+1 && v+1 <= e.v && d[e.to][v+1] > d[a][v] + (double)e.dist/(v+1)) {\n          d[e.to][v+1] = d[a][v] + (double)e.dist/(v+1);\n          pq.push({d[e.to][v+1], (double)e.to, (double)v+1, (double)a});\n        }\n      }\n    }\n    if(d[g][1] == INF) cout << \"unreachable\" << endl;\n    else cout << fixed << setprecision(10) << d[g][1] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\n#include<vector>\n#define INF 1e10\n#define EPS 1e-10\nusing namespace std;\nstruct edge{\n  int to,limit;\n  double dist;\n};\nvector<edge> G[100];\ndouble d[40][100];\nbool used[40][100];\ntypedef pair<int,int> pii; //to,speed\ntypedef pair<double,pii> P;//cost,to,speed\n\ndouble dikstra(int s,int g){\n  int ds[3]={-1,0,1};\n  priority_queue<P,vector<P>,greater<P> > que;\n  for(int i=0;i<40;i++)\n    for(int j=0;j<100;j++)\n      d[i][j]=INF;\n  memset(used,0,sizeof(used));\n  d[0][s]=0;\n  que.push(P(0,pii(s,0)));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int speed=p.second.second;\n    int v=p.second.first;\n    double cost=p.first;\n    //cout << v << \";\" << speed <<\":\" << cost << endl;\n    if(d[speed][v]<cost)continue;\n    for(int i=0;i<G[v].size();i++){\n      for(int j=0;j<3;j++){\n\tedge e=G[v][i];\n\tint ns=speed+ds[j];\n\tif(1<=ns && ns<= e.limit &&\n\t   used[ns][e.to]==false){\n\t  used[ns][e.to]=true;\n\t  que.push(P(cost+e.dist/ns,pii(e.to,ns)));\n\t  if(d[ns][e.to]>cost+e.dist/ns){\n\t    d[ns][e.to]=cost+e.dist/ns;\n\t    //cout << \"d[\" << ns << \"][\" << e.to << \"]:\" << d[ns][e.to] << endl;\n\t    //cout << \"d[\" << v << \"]:\" << d[speed][v] << \" speed:\" << speed<< endl;\n\t  }\n\t}\n      }\n    }\n  }\n  if(d[1][g]==INF)return -1;\n  return d[1][g];\n}\n\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n){\n    for(int i=0;i<100;i++)G[i].clear();\n    cin>>s>>g;\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      G[x].push_back((edge){y,c,d});\n      G[y].push_back((edge){x,c,d});\n    }\n    double ans=dikstra(s,g);\n    if(ans==-1)cout << \"unreachable\" << endl;\n    else printf(\"%lf\\n\",ans);\n    // for(int i=0;i<=n;i++)\n    // \tcout << i << \" \" << d[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\n// グラフ用ヘッダ\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    int limit;\n    Edge(int src, int dst, Weight weight, int limit) :\n        src(src), dst(dst), weight(weight), limit(limit) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n#include <queue>\n\n// d,spped,v,from\ntypedef tuple<double,int,int,int> State;\n\nconst double inf = 1e100;\n\n// speed,v\ndouble dp[32][32];\nGraph g;\nint src,dst;\n\nstring solve(){\n    priority_queue<State> q;\n    q.emplace(0.0,0,src,-1);\n    rep(i,32)rep(j,32) dp[i][j] = inf;\n    dp[1][src] = 0;\n    while(q.size()){\n        double d; int speed, v, from;\n        tie(d,speed,v,from) = q.top(); q.pop();\n        d = -d;\n        if(v==dst && speed==1){\n            char buf[100];\n            sprintf(buf,\"%.10lf\",d);\n            return buf;\n        }\n        if(d > dp[speed][v]) continue;\n        for(Edge & e : g[v]){\n            for(int diff : {-1,0,1}){\n                int ns = speed + diff;\n                double nd = d + (double)e.weight / ns;\n                int nv = e.dst;\n                if(ns < 1 || e.limit < ns) continue;\n                if(nv == from) continue;\n                if(dp[ns][nv] > nd){\n                    dp[ns][nv] = nd;\n                    q.emplace(-nd,ns,nv,v);\n                }\n            }\n        }\n    }\n    return \"unreachable\";\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m && n){\n        cin>>src>>dst;\n        g.assign(n+1,{});\n        rep(i,m){\n            int x,y,d,c; cin>>x>>y>>d>>c;\n            g[x].eb(x,y,d,c);\n            g[y].eb(y,x,d,c);\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Weight=long double;\nstruct Edge{\n    int from,to;\n    Weight w;\n    Edge(int f,int t,Weight ww):from(f),to(t),w(ww){};\n};\nint n;\nint vertex(int pre,int x,int v){\n    return pre+x*n+v*n*n;\n}\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nconst Weight INF=1e15;\nvector<Weight> dijkstra(int s,Graph& g){\n    vector<Weight> res(g.size(),INF);\n    vector<int> used(g.size(),false);\n    priority_queue<pair<Weight,int>,vector<pair<Weight,int>>,greater<>> que;\n    que.push(make_pair(Weight(0),s));\n    while(!que.empty()){\n        auto ret=que.top();\n        que.pop();\n        int v=ret.second;\n        if(used[v]) continue;\n        used[v]=true;\n        res[v]=ret.first;\n        for(int i=0;i<g[v].size();i++){\n            que.push(make_pair(res[v]+g[v][i].w,g[v][i].to));\n        }\n    }\n    return res;\n}\n\nvoid solve(int s,int g,Graph& graph){\n    vector<Weight> d=dijkstra(s,graph);\n    Weight res=INF;\n    for(int i=0;i<n;i++){\n        res=min(res,d[vertex(i,g,1)]);\n    }\n    if(res>=INF/2){\n        cout<<\"unreachable\"<<endl;\n    }\n    else{\n        cout<<fixed<<setprecision(10);\n        cout<<res<<endl;\n    }\n    return;\n}\n\nint main(){\n    int m;\n    while(cin>>n>>m,n){\n        Graph graph(n*n*32);\n        int s,g;\n        cin>>s>>g;\n        s--,g--;\n        for(int i=0;i<m;i++){\n            int x,y,c;\n            Weight d;\n            cin>>x>>y>>d>>c;\n            x--,y--;\n            for(int i=0;i<=min(31,c+1);i++){\n                for(int j=-1;j<=1;j++){\n                    if(0<i+j && i+j<=c){\n                        for(int k=0;k<n;k++){\n                            if(k!=y && (i!=0 || x==s)) graph[vertex(k,x,i)].emplace_back(vertex(k,x,i),vertex(x,y,i+j),d/(i+j));\n                            if(k!=x && (i!=0 || y==s)) graph[vertex(k,y,i)].emplace_back(vertex(k,y,i),vertex(y,x,i+j),d/(i+j));\n                        }\n                    }\n                }\n            }\n        }\n        solve(vertex(s,s,0),g,graph);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nstruct edge{\n\tint to,cost,limit;\n\tedge(int t,int c,int l){\n\t\tto=t;cost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tbool visit[31][31][31];\n\tmemset(visit,false,sizeof(visit));\n\tvector<vector<edge> > E(n+1);\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in].push_back(edge(out,c,l));\n\t\tE[out].push_back(edge(in,c,l));\n\t}\n\n\tdouble Ans[31][31][31];\n\tmemset(Ans,-1,sizeof(Ans));\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){\n\t\tNode t=Q.top(); Q.pop();\n\t\tif(visit[t.now][t.before][t.speed]) continue;\n\t\tvisit[t.now][t.before][t.speed]=true;\n\t\tif(Ans[t.now][t.before][t.speed]<=t.time && Ans[t.now][t.before][t.speed]>=0) continue;\n//\t\tcout<<t.now<<\" \"<<t.speed<<\" \"<<t.time<<endl;\n\t\tif(t.now==g && t.speed==1){printf(\"%.12lf\\n\", t.time );  return;}\n\t\tAns[t.now][t.before][t.speed]=t.time;\n\n\t\tfor(int i=0;i<E[t.now].size();i++){\n\t\t\tint to=E[t.now][i].to;\n\t\t\tif(to==t.before) continue;\n\t\t\tif(E[t.now][i].cost>0){\n\t\t\t\tif(E[t.now][i].limit>=t.speed && t.speed>=1){\n\t\t\t\t\tQ.push(Node(to,t.speed,t.time+E[t.now][i].cost/(double)t.speed,t.now));\n\t\t\t\t}\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed+1)\n\t\t\t\t\tQ.push(Node(to,t.speed+1,t.time+E[t.now][i].cost/(double)(t.speed+1.0),t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed-1 && t.speed-1>=1)\n\t\t\t\t\tQ.push(Node(to,t.speed-1,t.time+E[t.now][i].cost/(double)(t.speed-1.0),t.now));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\"<<endl;\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nint n,m;\nint st,gl;\ndouble dp[35][35][35];\n\nint ds[35][35];\nint rs[35][35];\n\ntypedef pair<int,mp> mmp;\ntypedef pair<double,mmp> dmp;\n\nint main(void){\n\tfor(;;){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0)break;\n\t\tscanf(\"%d%d\",&st,&gl);\n\t\tmemst(ds,-1);\n\t\tmemst(rs,-1);\n\t\trep(i,m){\n\t\t\tint a,b,c,d;\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\tds[a][b]=ds[b][a]=c; \n\t\t\trs[a][b]=rs[b][a]=d; \n\t\t}\n\t\t\n\t\trep(i,35)rep(j,35)rep(k,35)dp[i][j][k]=1e10;\n\t\t\n\t\tpque(dmp) que;\n\t\tque.push(dmp(0,mmp(st,mp(0,0))));\n\t\tdouble ans=-1;\n\t\twhile(!que.empty()){\n\t\t\tdmp pa=que.top();\n\t\t\tque.pop();\n\t\t\tdouble t=pa.fir;\n\t\t\tint no=pa.sec.fir,\n\t\t\t\tfr=pa.sec.sec.fir,\n\t\t\t\tnv=pa.sec.sec.sec;\n\t\t\tif(dp[no][fr][nv]<=t)continue;\n\t\t\tdp[no][fr][nv]=t;\n\t\t\tif(no==gl && nv==1){\n\t\t\t\tans=t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treg(tv,max(nv-1,1),nv+1){\n\t\t\t\trep(to,35){\n\t\t\t\t\tif(to==fr)continue;\n\t\t\t\t\tif(ds[no][to]<0)continue;\n\t\t\t\t\tif(rs[no][to]<tv)continue;\n\t\t\t\t\tdouble tt=t+ds[no][to]/((double)tv);\n\t\t\t\t\tif(dp[to][no][tv]<=tt)continue;\n\t\t\t\t\tque.push(dmp(tt,mmp(to,mp(no,tv))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans<0)printf(\"unreachable\\n\");\n\t\telse printf(\"%.8f\\n\",ans);\n\t}\n\t\t\n\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nclass state {\npublic:\n  double cost;\t\t\t// 所要時間\n  int pp;                       // 前の位置\n  int np;\t\t\t// 今の位置\n  int v;\t\t\t// 速度\n  state(double _cost, int _pp, int _np, int _v) {\n    cost = _cost;\n    pp = _pp;\n    np = _np;\n    v = _v;\n  }\n  bool operator > (const state &s) const {\n    return cost > s.cost;\n  }\n};\n\nint main() {\n  int n, m;\n  while (true) {\n    cin >> n >> m;\n    if (n == 0 && m == 0) {\n      break;\n    }\n\n    int s, g;\n    cin >> s >> g;\n    s--; g--;\n    if (m == 0) {\n      std::cout << \"unreachable\" << std::endl;\n      continue;\n    }\n\n    vector <int> graph[n];\n    double cost[n][n];\n    double dist[n][n];\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      double d, c;\n      cin >> x >> y >> d >> c;\n      x--; y--;\n      graph[x].push_back(y);\n      graph[y].push_back(x);\n      cost[x][y] = c;\n      cost[y][x] = c;\n      dist[x][y] = d;\n      dist[y][x] = d;\n    }\n\n    double memo[n][n][32];\t\t// prev now v\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tfor (int k = 0; k < 32; k++) {\n\t  memo[i][j][k] = -1;\n\t}\n      }\n    }\n\n    // for (int i = 0; i < n; i++) {\n    //   std::cout << i << \":\";\n    //   for (int j = 0; j < graph[i].size(); j++) {\n    // \tstd::cout << graph[i][j] << \" \";\n    //   }\n    //   std::cout << \"\" << std::endl;\n    // }\n\n    priority_queue <state, vector<state>, greater<state> > pque;\n    for (int i = 0; i < graph[s].size(); i++) {\n      int np = graph[s][i];\n      double nt = dist[s][np]/1.;\n      memo[s][np][1] = nt;\n      pque.push(state(nt, -1, np, 1));  // 前の状態がないときは-1\n    }\n    while(!pque.empty()) {\n      state p = pque.top(); pque.pop();\n\n      for (int i = 0; i < graph[p.np].size(); i++) {\n\tint np = graph[p.np][i];\n        if (p.pp == np) {\n          continue;\n        }\n\tfor (int j = -1; j <= 1; j++) {\n\t  int v = p.v+j;\n\t  if (v <= 0 || v > cost[p.np][np]) {\n\t    continue;\n\t  }\n\n\t  double nt = p.cost+dist[p.np][np]/double(v);\n\n\t  if (memo[p.np][np][v] == -1 ||\n\t      memo[p.np][np][v] > nt) {\n\n\t    memo[p.np][np][v] = nt;\n\t    pque.push(state(nt, p.np, np, v));\n\t  }\n\t}\n      }\n    }\n\n    double ans = -1;\n    for (int i = 0; i < n; i++) {\n      if (memo[i][g][1] == -1) {\n        continue;\n      }\n      if (ans == -1 ||\n          memo[i][g][1] < ans) {\n        ans = memo[i][g][1];\n      }\n    }\n\n    if (ans == -1) {\n      std::cout << \"unreachable\" << std::endl;\n    }else {\n      printf(\"%.5f\\n\", ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ndouble ijk[30][31][31];\nint v[30][31][31];\nint g[30][30];\nint lim[30][30];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tint S,T;\n\t\tscanf(\"%d%d\",&S,&T);\n\t\tS--;T--;\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tg[i][j]=-1;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tp--;q--;\n\t\t\tg[p][q]=g[q][p]=r;\n\t\t\tlim[p][q]=lim[q][p]=s;\n\t\t}\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<31;j++)\n\t\t\tfor(int k=0;k<31;k++){ijk[i][j][k]=99999999;v[i][j][k]=0;}\n\t\tpriority_queue<pair<double,pair<pair<int,int>,int> > >Q;\n\t\tQ.push(make_pair(0,make_pair(make_pair(S,30),1)));\n\t\tijk[S][30][1]=0;\n\t\twhile(Q.size()){\n\t\t\tdouble cost=-Q.top().first;\n\t\t\tint at=Q.top().second.first.first;\n\t\t\tint prev=Q.top().second.first.second;\n\t\t\tint ver=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(~prev&&v[at][prev][ver])continue;\n\t\t\tif(~prev)v[at][prev][ver]=1;\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tif(ver&&~g[at][i]&&lim[at][i]>=ver&&prev!=i){\n\t\t\t\t\tif(ijk[i][at][ver-1]>cost+(double)g[at][i]/ver){\n\t\t\t\t\t\tijk[i][at][ver-1]=cost+(double)g[at][i]/ver;\n\t\t\t\t\t\tQ.push(make_pair(-ijk[i][at][ver-1],make_pair(make_pair(i,at),ver-1)));\n\t\t\t\t\t}\n\t\t\t\t\tif(ijk[i][at][ver]>cost+(double)g[at][i]/ver){\n\t\t\t\t\t\tijk[i][at][ver]=cost+(double)g[at][i]/ver;\n\t\t\t\t\t\tQ.push(make_pair(-ijk[i][at][ver],make_pair(make_pair(i,at),ver)));\n\t\t\t\t\t}\n\t\t\t\t\tif(ver<30&&ijk[i][at][ver+1]>cost+(double)g[at][i]/ver){\n\t\t\t\t\t\tijk[i][at][ver+1]=cost+(double)g[at][i]/ver;\n\t\t\t\t\t\tQ.push(make_pair(-ijk[i][at][ver+1],make_pair(make_pair(i,at),ver+1)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ret=99999999;\n\t\tfor(int i=0;i<a;i++)ret=min(ret,ijk[T][i][0]);\n\t\tif(ret>9999999)printf(\"unreachable\\n\");\n\t\telse printf(\"%f\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\ntemplate <typename T>\nstruct edge {\n    int from, to; T cost;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n};\n\ntemplate <typename T>\nvector<T> dijkstra(int s,vector<vector<edge<T>>> &G){\n    size_t n=G.size();\n    vector<T> d(n, INF<T>);\n    priority_queue<pair<T, int>,vector<pair<T, int>>,greater<>> Q;\n    d[s]=0;\n    Q.emplace(0,s);\n    while(!Q.empty()){\n        T cost; int i;\n        tie(cost, i) = Q.top(); Q.pop();\n        if(d[i] < cost) continue;\n        for (auto &&e : G[i]) {\n            auto cost2 = cost + e.cost;\n            if(d[e.to] <= cost2) continue;\n            d[e.to] = cost2;\n            Q.emplace(d[e.to], e.to);\n        }\n    }\n    return d;\n}\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n) {\n        int s, g;\n        cin >> s >> g;\n        s--; g--;\n        int sz = n*n*31;\n        vector<vector<edge<double>>> G(sz);\n        auto f = [&n](int a, int b, int c){\n            return a*n*31+b*31+c;\n        };\n        for (int i = 0; i < m; ++i) {\n            int x, y, c; double d;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            for (int xxx = 0; xxx < 2; ++xxx) {\n                for (int j = 0; j < n; ++j) {\n                    if(y == j) continue;\n                    for (int k = 0; k <= 30; ++k) {\n                        if(k > 1 && k-1 <= c) G[f(x, j, k)].emplace_back(f(y, x, k-1), d/(k-1));\n                        if(k > 0 && k <= c) G[f(x, j, k)].emplace_back(f(y, x, k), d/k);\n                        if(k+1 <= c) G[f(x, j, k)].emplace_back(f(y, x, k+1), d/(k+1));\n                    }\n                }\n                swap(x, y);\n            }\n        }\n        auto dist = dijkstra(f(s, s, 0), G);\n        double ans = INF<double>;\n        for (int i = 0; i < n; ++i) {\n            ans = min(ans, dist[f(g, i, 1)]);\n        }\n        if(ans >= INF<int>) puts(\"unreachable\");\n        else printf(\"%.10lf\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cout << x << \" \";} cout << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\n// typedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\n// const int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef tuple<double, int, int> TUPLE;\nconst double inf = 1e12;\n\nstruct edge {\n    int to, d, c;\n    edge(){}\n    edge(int _to, int _d, int _c) : to(_to), d(_d), c(_c) {}\n};\ntypedef vector<vector<edge>> Graph;\ndouble dijkstra(const Graph& G, int s, int g) {\n    int n = G.size();\n    priority_queue<TUPLE, vector<TUPLE>, greater<TUPLE>> pq;   // cost, i, j\n    vector<vector<double>> d(n, vector<double>(31, inf));\n    d[s][0] = 0;\n    pq.push(make_tuple(0, s, 0));\n\n    while (!pq.empty()) {\n        double cost;\n        int i, j;\n        tie(cost, i, j) = pq.top(); pq.pop();\n        // cout << cost << \" \" << i << \" \" << j << endl;\n        if (i == g && j == 1) return cost;\n        if (d[i][j] < cost) continue;\n        for (const auto& e : G[i]) {\n            for (int k = -1; k <= 1; k++) {\n                if (1 <= j + k && j + k <= e.c && d[e.to][j + k] > d[i][j] + 1. * e.d / (j + k)) {\n                    d[e.to][j + k] = d[i][j] + 1. * e.d / (j + k);\n                    pq.push(make_tuple(d[e.to][j + k], e.to, j + k));\n                }\n            }\n        }\n        // cerr << \"hey!\" << endl;\n    }\n\n    return inf;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    int t = 0;\n    while (cin >> n >> m, n) {\n        // cout << \"--- t = \" << t++ << \" ---\" << endl;\n\n        int s, g;\n        cin >> s >> g;\n        s--, g--;\n        Graph G(n);\n        rep(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--, y--;\n            G[x].emplace_back(y, d, c);\n            G[y].emplace_back(x, d, c);\n        }\n\n        double ans = dijkstra(G, s, g);\n        if (ans < inf) {\n            cout << setprecision(10) << ans << endl;\n        } else {\n            cout << \"unreachable\" << endl;\n        }\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ndouble ijk[30][31][31];\nint v[30][31][31];\nint g[30][30];\nint lim[30][30];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tint S,T;\n\t\tscanf(\"%d%d\",&S,&T);\n\t\tS--;T--;\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tg[i][j]=-1;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tp--;q--;\n\t\t\tg[p][q]=g[q][p]=r;\n\t\t\tlim[p][q]=lim[q][p]=s;\n\t\t}\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<31;j++)\n\t\t\tfor(int k=0;k<31;k++){ijk[i][j][k]=99999999;v[i][j][k]=0;}\n\t\tpriority_queue<pair<double,pair<pair<int,int>,int> > >Q;\n\t\tQ.push(make_pair(0,make_pair(make_pair(S,30),1)));\n\t\tijk[S][30][1]=0;\n\t\twhile(Q.size()){\n\t\t\tdouble cost=-Q.top().first;\n\t\t\tint at=Q.top().second.first.first;\n\t\t\tint prev=Q.top().xsecond.first.second;\n\t\t\tint ver=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(~prev&&v[at][prev][ver])continue;\n\t\t\tif(~prev)v[at][prev][ver]=1;\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tif(ver&&~g[at][i]&&lim[at][i]>=ver&&prev!=i){\n\t\t\t\t\tif(ijk[i][at][ver-1]>cost+(double)g[at][i]/ver){\n\t\t\t\t\t\tijk[i][at][ver-1]=cost+(double)g[at][i]/ver;\n\t\t\t\t\t\tQ.push(make_pair(-ijk[i][at][ver-1],make_pair(make_pair(i,at),ver-1)));\n\t\t\t\t\t}\n\t\t\t\t\tif(ijk[i][at][ver]>cost+(double)g[at][i]/ver){\n\t\t\t\t\t\tijk[i][at][ver]=cost+(double)g[at][i]/ver;\n\t\t\t\t\t\tQ.push(make_pair(-ijk[i][at][ver],make_pair(make_pair(i,at),ver)));\n\t\t\t\t\t}\n\t\t\t\t\tif(ver<30&&ijk[i][at][ver+1]>cost+(double)g[at][i]/ver){\n\t\t\t\t\t\tijk[i][at][ver+1]=cost+(double)g[at][i]/ver;\n\t\t\t\t\t\tQ.push(make_pair(-ijk[i][at][ver+1],make_pair(make_pair(i,at),ver+1)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ret=99999999;\n\t\tfor(int i=0;i<a;i++)ret=min(ret,ijk[T][i][0]);\n\t\tif(ret>9999999)printf(\"unreachable\\n\");\n\t\telse printf(\"%f\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdio>\n#define rep(i,j) for(int (i)=0;(i)<(j);(i)++)\n\nusing namespace std;\n\nstruct state{\n  int prev,now,v;\n  double time;\n  bool operator <(const state &s)const{\n    return time>s.time;\n  }\n};\n\nconst double INFd=1e9;\nint n,m;\nint s,g;\nstruct edge{\n  int to,d,c;\n};\n\nvector< vector<edge> > G; \n\ndouble solve(){\n\n  priority_queue<state> que;\n\n  double dist[31][31][31];\n  rep(i,31)rep(j,31)rep(k,31)dist[i][j][k]=INFd;\n  \n  que.push((state){s,s,0,0});\n  dist[s][s][0]=0;\n  \n  while(!que.empty()){\n    state now=que.top();que.pop();\n    //cout<<\"now\"<<endl;\n    //printf(\"%d %d %d %f\\n\",now.prev,now.now,now.v,now.time);\n    \n    rep(i,G[now.now].size()){\n      edge &e=G[now.now][i];\n      if(e.to!=now.prev){\n        rep(j,3){\n          int nv=now.v+j-1;\n          double ntime=now.time+e.d/(double)nv;\n          if(nv<=e.c && nv>0){\n            state nxt=(state){now.now,e.to,nv,ntime};\n\n            if(dist[now.now][e.to][nv]>ntime){\n              dist[now.now][e.to][nv]=ntime;\n              que.push(nxt);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  double ans=INFd;\n  rep(i,31){\n    ans=min(dist[i][g][1],ans);\n  }\n  \n  return ans;\n}\n\n\nint main(){\n  while(true){\n    cin>>n>>m;\n    if(n==0 and m==0)break;\n    cin>>s>>g;\n    s--;\n    g--;\n    G.clear();\n    G.resize(n);\n    rep(i,m){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      x--;\n      y--;\n      G[x].push_back((edge){y,d,c});\n      G[y].push_back((edge){x,d,c});\n    }\n    double ans=solve();\n    if(ans!=INFd)\n      printf(\"%.9f\\n\",solve());\n    else\n      printf(\"unreachable\\n\");\n    \n  }\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 100000\n\nusing namespace std;\n\nint n,m;\n\nstruct edge {\n\tint t;\n\tint dis;\n\tint lim;\n};\n\nstruct Point {\n\tint pos;\n\tdouble time;\n\tint speed;\n\tint pres;\n\n\tbool operator<(const Point& right) const {\n\t\treturn (time > right.time);\n\t}\n};\n\nint main(void) {\n\twhile (cin >> n >> m, n) {\n\t\tint s,g;\n\t\tcin >> s >> g;\n\n\t\tint x,y,d,c;\n\t\tvector< vector<edge> > adj(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tadj[x-1].push_back((edge){y-1,d,c});\n\t\t\tadj[y-1].push_back((edge){x-1,d,c});\n\t\t}\n\n\t\tpriority_queue<Point> pq;\n\t\tpq.push((Point){s-1,0,1,1});\n\t\tdouble dp[n][31];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < 31; ++j) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][1] = 0;\n\n\t\tbool find = false;\n\t\twhile (!pq.empty()) {\n\t\t\tPoint pn = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif (pn.pos == g-1 && pn.speed == 1 && pn.pres == 1) {\n\t\t\t\tprintf(\"%llf\\n\",pn.time);\n\t\t\t\tfind = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (size_t i = 0; i < adj[pn.pos].size(); ++i) {\n\t\t\t\tdouble rt = ((double)adj[pn.pos][i].dis/pn.speed);\n\t\t\t\tif (pn.time + rt < dp[adj[pn.pos][i].t][pn.speed] && pn.speed <= adj[pn.pos][i].lim) {\n\t\t\t\t\tdp[adj[pn.pos][i].t][pn.speed] = pn.time + rt;\n\t\t\t\t\tpq.push((Point){adj[pn.pos][i].t,pn.time+rt,pn.speed,pn.speed});\n\t\t\t\t\tif (pn.speed != 30) {\n\t\t\t\t\t\tpq.push((Point){adj[pn.pos][i].t,pn.time+rt,pn.speed+1,pn.speed});\n\t\t\t\t\t}\n\t\t\t\t\tif (pn.speed != 1) {\n\t\t\t\t\t\tpq.push((Point){adj[pn.pos][i].t,pn.time+rt,pn.speed-1,pn.speed});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!find) {\n\t\t\tcout << \"unreachable\" <<  endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 30;\nconst int INF_I = 1 << 30;\nconst double INF_D = 1 << 30;\n\ntypedef struct Edge\n{\n  int d, c;\n};\n\nint main()\n{\n  int n, m;\n  while (scanf(\"%d %d\", &n, &m) != EOF) {\n    if (n == 0 && m == 0)\n      break;\n\n    int s, g;\n    scanf(\"%d %d\", &s, &g);\n    --s;\n    --g;\n\n    Edge cost[MAX][MAX];\n    for (int i = 0; i < MAX; ++i) {\n      for (int j = 0; j < MAX; ++j) {\n\tcost[i][j].d = cost[i][j].c = INF_I;\n      }\n    }\n\n    for (int i = 0; i < m; ++i) {\n      int x, y, d, c;\n      scanf(\"%d %d %d %d\", &x, &y, &d, &c);\n      --x;\n      --y;\n      cost[x][y].d = cost[y][x].d = d;\n      cost[x][y].c = cost[y][x].c = c;\n    }\n\n    double time[MAX][MAX][MAX+1];\n    int visited[MAX][MAX][MAX+1];\n\n    for (int i = 0; i < MAX; ++i) {\n      for (int j = 0; j < MAX; ++j) {\n\tfor (int k = 0; k < MAX+1; ++k) {\n\t  time[i][j][k] = INF_D;\n\t  visited[i][j][k] = 0;\n\t}\n      }\n    }\n\n    time[s][s][0] = 0.0;\n    for ( ; ; ) {\n      int nc = 0, pc = 0, nv = 0;\n      double nt = INF_D;\n\n      for (unsigned int i = 0; i < n; ++i) {\n\tfor (unsigned int j = 0; j < n; ++j) {\n\t  for (unsigned int k = 0; k < MAX+1; ++k) {\n\t    if (!visited[i][j][k] && time[i][j][k] < nt) {\n\t      nc = i;\n\t      pc = j;\n\t      nv = k;\n\t      nt = time[i][j][k];\n\t    }\n\t  }\n\t}\n      }\n\n      if (nt == INF_D) {\n\tprintf(\"unreachable\\n\");\n\tbreak;\n      } else if (nc == g && nv == 1) {\n\tprintf(\"%.5f\\n\", nt);\n\tbreak;\n      }\n\n      visited[nc][pc][nv] = 1;\n      for (int i = 0; i < n; ++i) {\n\tif (pc == i || cost[nc][i].d == INF_I)\n\t  continue;\n\tfor (int j = nv-1; j < nv+2; ++j) {\n\t  if (j > 0 && cost[nc][i].c >= j) {\n\t    time[i][nc][j] = min(time[i][nc][j], nt+cost[nc][i].d/(double)j);\n\t  }\n\t}\n      }\n    }\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000.0\nusing namespace std;\nstruct state { int n, v, l; double t; };\n\nint N, M, S, G;\nvector<int> T[31], D[31], C[31];\nint vd[3] = { -1, 0, 1 };\ndouble dp[30][50];\n\nclass Compare {\npublic:\n  bool operator() (struct state a, struct state b) {\n    return a.t > b.t;\n  }\n};\n\nint main(void) {\n  while(cin >> N >> M, N) {\n    cin >> S >> G;\n    REP(i, 0, 30) {\n      T[i].clear();\n      D[i].clear();\n      C[i].clear();\n    }\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      T[x].push_back(y); D[x].push_back(d); C[x].push_back(c);\n      T[y].push_back(x); D[y].push_back(d); C[y].push_back(c);\n    }\n\n    REP(i, 1, N) REP(j, 0, 30) dp[i][j] = INF;\n\n    priority_queue<struct state, vector<struct state>, Compare> q;\n    struct state first = { S, 0, -1, 0.0 };\n    q.push(first);\n\n    while(!q.empty()) {\n      struct state c = q.top();\n      q.pop();\n\n      // cout << c.n << \" \" << c.v << \" \" << c.t << endl;\n\n      dp[c.n][c.v] = min(dp[c.n][c.v], c.t);\n      if(c.n == G && c.v == 1) break;\n\n      for(int i = 0; i < T[c.n].size(); i++) {\n        if(T[c.n][i] == c.l) continue;\n        REP(j, 0, 3) {\n          int v = c.v + vd[j];\n          if(v <= 0 || C[c.n][i] < v) continue;\n          double t = c.t + ((double) D[c.n][i] / v);\n          struct state n = { T[c.n][i], v, c.n, t };\n          if(n.t < dp[n.n][n.v]) q.push(n);\n        }\n      }\n    }\n\n    if(dp[G][1] < INF) printf(\"%.6f\\n\", dp[G][1]);\n    else cout << \"unreachable\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\n#define INF 1e15\n\nint n, m;\n\nstruct edge{\n    int to;\n    double cost;\n    int limit;\n    edge(int t, double c, int l): to(t), cost(c), limit(l){}\n};\n\nstruct state{\n    int node, speed, prev;\n    double dist;\n    state(int n, int s, int p, double d): node(n), speed(s), prev(p), dist(d) {}\n    bool operator > (const state s) const {\n        return dist > s.dist;\n    }\n};\n \nvoid dijkstra(int start, vector<vector<vector<double> > > &d, vector<vector<edge> > graph){\n    d[start][0][start] = 0.0;\n    bool visit[31][31][31] = {};\n    priority_queue<state, vector<state>, greater<state> > q;\n    q.push(state(start, 0, 0, 0.0));\n    while (!q.empty()){\n        state a = q.top();\n        q.pop();\n        int now = a.node, prev = a.prev, speed = a.speed;\n        if (visit[now][speed][prev]) continue;\n        visit[now][speed][prev] = 1;\n        // printf(\"%d %d %d\\n\", now, prev, speed);\n        if(d[now][speed][prev] < a.dist) continue;\n        REP(i,graph[now].size()){\n            edge e = graph[now][i];\n            int next = e.to, limit = e.limit;\n            if (next == prev) continue;\n            FOR(dif,-1,1){\n                int next_speed = speed + dif;\n                if (next_speed <= 0 || next_speed > limit) continue;\n                if (d[next][next_speed][now] > d[now][speed][prev] + e.cost/next_speed){\n                    d[next][next_speed][now] = d[now][speed][prev] + e.cost/next_speed;\n                    q.push(state(next, next_speed, now, d[next][next_speed][now]));\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    while (cin >> n >> m && n){\n        vector<vector<edge> > graph(n);\n        int s, g;\n        cin >> s >> g;\n        s--;\n        g--;\n        REP(i,m){\n            int x, y, c;\n            double d;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            graph[x].push_back(edge(y,d,c));\n            graph[y].push_back(edge(x,d,c));\n        }\n        vector<vector<vector<double> > > dist(n, vector<vector<double> > (31, vector<double> (n, INF)));\n        dijkstra(s, dist, graph);\n        double ans = INF;\n        REP(i,n) ans = min(ans, dist[g][1][i]);\n        if (ans == INF) cout << \"unreachable\" << endl;\n        else printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 91 // いつもは1<<29だが小さくすれば時間はやくなる？\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 31\n#define INF (1e9)\nusing namespace std;\ntypedef pair<double,int> P;\ntypedef  pair<P,int> PP;\nint n,m;\nvector<PP> G[N];\n\ndouble dijkstra(int s,int g){\n  vector<vector<double> >D(N,vector<double>(N,INF));\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  Q.push(PP(P(0,1),s));\n  D[s][1]=0;\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    double cost=t.first.first;\n    int v=t.first.second;\n    int pos=t.second;\n    if(D[pos][v]<cost)continue;\n    if(pos==g) return cost;\n\n    for(int i=max(1,v-1);i<=v+1;i++){\n      for(int j=0;j<G[pos].size();j++){\n\tdouble ncost=cost+G[pos][j].first.first/i;\n\tint mxv=G[pos][j].first.second;\n\tint nx=G[pos][j].second;\n\tif(mxv<i||D[nx][i]<=ncost)continue;\n\tQ.push(PP(P(ncost,i),nx));\n\tD[nx][i]=ncost;\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    int s,g;\n    cin>>s>>g;s--,g--;\n\n    for(int i=0;i<n;i++)G[i].clear();\n    for(int i=0,a,b,d,c;i<m;i++){\n      cin>>a>>b>>d>>c;a--,b--;\n      if(a==s||a==g||b==s||b==g) c=1;\n      G[a].push_back(PP(P(d,c),b));\n      G[b].push_back(PP(P(d,c),a));\n    }\n    double ans=dijkstra(s,g);\n    if(ans==-1) cout<<\"unreachable\"<<endl;\n    else printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n\n///////////////////ダイクストラで使うクラス//////////////////\nclass E{\n\tpublic:\n\tint dir,cost,limit;\n\tE(int dir,int cost,int limit):dir(dir),cost(cost),limit(limit){}\n};\n\nclass T{\n\tpublic:\n\tint pos,bef,speed;\n\tdouble val;\n\tT(int pos,int bef,double val,int speed):pos(pos),bef(bef),val(val),speed(speed){}\n\t\n\tbool operator<(const T& a)const{\n\t\treturn val>a.val;\n\t}\n};\n\n////////////////////////////main/////////////////////////\nint main(){\n\t\n\twhile(1){\n\t\t/////////////入力/////////////////////////////////\n\t\tint n,m,start,goal;\n\t\tvector<E> edge[33];\n\t\t\n\t\tcin>>n>>m; if(n==0)break;\n\t\tcin>>start>>goal;\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tedge[a].push_back(E(b,c,d));\n\t\t\tedge[b].push_back(E(a,c,d));\n\t\t}\n\t\t\n\t\t///////////ダイクストラ本体//////////////////////\n\t\tpriority_queue<T> que;\n\t\tque.push(T(start,0,0,0)); //初期位置設定\n\t\t\n\t\tint visit[33][33]={0};\n\t\twhile(1){\n\t\t\tif(que.empty())break; //異常終了\n\t\t\t\n\t\t\tT u = que.top();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(visit[u.pos][u.speed]==1)continue; //一度訪れた状態の場合は弾く\n\t\t\tvisit[u.pos][u.speed]=1;\n\t\t\t\n\t\t\tif(u.pos==goal && u.speed==1){ //終了判定\n\t\t\t\tprintf(\"%lf\\n\",u.val);\n\t\t\t\tgoto A;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<edge[u.pos].size();i++){ //状態遷移\n\t\t\t\tE e = edge[u.pos][i];\n\t\t\t\tif(e.dir == u.bef)continue; //Uターン禁止の制約で弾く\n\t\t\t\t\n\t\t\t\t//-1:減速 0:等速 1:加速\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\n\t\t\t\t\tint next = u.speed + j;\n\t\t\t\t\tif(next > e.limit || next <= 0)continue; //速度の制約で弾く\n\t\t\t\t\t\n\t\t\t\t\tque.push( T(e.dir, u.pos, u.val + double(e.cost)/next, next) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"unreachable\\n\");\n\t\tA:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst double INF = 1e8;\nint s,t;\n\nclass Edge{\n    public:\n        int to;\n        double cost,limit;\n        Edge(int to, double cost, double limit) : to(to) ,cost(cost) ,limit(limit) {}\n};\n\nclass Node{\n    public:\n        double dis;\n        bool isUsed;\n        double speed;\n        Node(){\n            this->dis = INF;\n            this->speed = 0.0;\n            this->isUsed = 0;\n        }\n};\n\ntypedef vector<vector<Edge>> AdjList;\n\ndouble dijkstra(AdjList g, int n,int start = s){\n\n    vector<vector<Node>> node(n,vector<Node>(35));\n    //??????????????????????????????????????????\n    typedef pair<pair<double,double>,pair<int,int>> p;\n\n    priority_queue<p, vector<p>, greater<p>> q;\n\n    q.push(make_pair(make_pair(0.0, 0.0), make_pair(start,-1)));\n    node[start][0].dis = 0.0;\n\n    p u;\n    while(not q.empty()){\n        u = q.top(); q.pop();\n        int current = u.second.first;\n        int prev = u.second.second;\n        double speed = u.first.second;\n        node[current][speed].isUsed = 1;\n\n        rep(i,g[current].size()){\n            int next = g[current][i].to;\n            if(node[next][speed].isUsed) continue;\n            if(next == prev) continue;\n\n            for(double j = -1; j <= 1; j++){\n                if(speed + j > 0){\n                    if(speed + j > g[current][i].limit) continue;\n                    if(node[next][speed + j].dis > node[current][speed].dis + g[current][i].cost / (speed + j)){\n                        node[next][speed + j].dis = node[current][speed].dis + g[current][i].cost / (speed + j);\n                        q.push(make_pair(\n                                    make_pair(node[next][speed + j].dis, speed + j),\n                                    make_pair(next,current)\n                                    )\n                              );\n                    }\n                }\n            }\n        }\n    }\n///    cout << endl;\n///    rep(i,n){\n///        rep(j,30){\n///            cout << node[i][j].dis << ' ';\n///        }\n///        cout << endl;\n///    show(\"------------\")\n///    }\n    return node[t][1].dis;\n}\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n||m){\n        cin >> s >> t;\n        s--; t--;\n        AdjList g(n);\n        rep(i,m){\n            int a, b;\n            double c, d;\n            cin >> a >> b >> c >> d;\n            a--; b--;\n            g[a].emplace_back(Edge{b,c,d});\n            g[b].emplace_back(Edge{a,c,d});\n        }\n        double tmp = dijkstra(g,n);\n        if(tmp == INF) cout << \"unreachable\" << endl;\n        else cout <<fixed << setprecision(5) <<  tmp << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF 1000000007\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef pair<int,int>pi;\ntypedef pair<double,int>pd;\ntypedef pair<pd,pi>PP;\n\nstruct edge\n{\n    int to,dist,limit;\n};\n\nint n,m,s,g;\ndouble dp[101][101][31];\nvector<edge> G[101];\n\nvoid dijkstra()\n{\n    rep(i,n){\n        rep(j,n){\n            rep(k,31){\n                dp[i][j][k] = INF;\n            }\n        }\n    }\n    priority_queue<PP,vector<PP>,greater<PP> > que;\n    que.push(PP(pd(0.0,s),pi(0,0)));\n    dp[s][0][0] = 0.0;\n    while(!que.empty()){\n        PP pp = que.top();\n        pd p = pp.fi;\n        pi q = pp.se;\n        que.pop();\n        double cost = p.fi;\n        int v = p.se, prv = q.fi, sp = q.se;\n        if(dp[v][prv][sp] < cost) continue;\n        if(v == g && sp == 1){\n            printf(\"%.12lf\\n\",cost);\n            return;\n        }\n        for(int i=sp-1;i<=sp+1;i++){\n            if(i <= 0) continue;\n            for(auto& e : G[v]){\n                if(e.to != prv && i <= e.limit && dp[e.to][v][i] > cost+(double)e.dist/i){\n                    dp[e.to][v][i] = cost+(double)e.dist/i;\n                    que.push(PP(pd(dp[e.to][v][i],e.to),pi(v,i)));\n                }\n            }\n        }\n    }\n    printf(\"unreachble\\n\");\n}\n\nint main()\n{\n    while(1){\n        cin >> n >> m;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear();\n        }\n        cin >> s >> g;\n        s--,g--;\n        rep(i,m){\n            int a,b,c,d;\n            cin >> a >> b >> c >> d;\n            G[a-1].push_back((edge){b-1,c,d});\n            G[b-1].push_back((edge){a-1,c,d});\n        }\n        dijkstra();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\n\nclass State{\npublic:\n  int pos, v, pre;\n  double time;\n  State(){}\n  State(int pos, int v, int pre, double time) : pos(pos), v(v), pre(pre), time(time) {}\n};\n\nint n, m, s, g;\nP edge[30][30];\n\nvoid solve(){\n  State u, v;\n  bool reach = false;\n  u = State(s, 0, 0, 0.0);\n  queue<State> que;\n  double vis[30][900];\n  fill(vis[0], vis[30], 100000000.0);\n  vis[u.pos][u.v] = u.time;\n  que.push(u);\n  while(!que.empty()){\n    u = que.front(); que.pop();\n    //cout << u.pos << ' ' << u.v << ' ' << u.pre << ' ' << u.time << endl;\n    if(u.pos == g && u.v == 1){\n      reach = true;\n      continue;\n    }\n    for(int i=0;i<n;i++){\n      if(edge[u.pos][i].first == INF) continue;\n      if(u.pre == i) continue;\n      for(int k=-1;k<=1;k++){\n        if(u.v + k > edge[u.pos][i].second) continue;\n        if(u.v + k <= 0) continue;\n        v = State(i, u.v + k, u.pos, u.time + edge[u.pos][i].first / (double)(u.v + k));\n        //cout << '\\t' << v.pos << ' ' << v.v << ' ' << v.pre << ' ' << v.time << ' ' << vis[v.pos][v.v] << endl;\n        if(vis[v.pos][v.v] > v.time){\n          vis[v.pos][v.v] = v.time;\n          que.push(v);\n        }\n      }\n    }\n  }\n  if(reach) printf(\"%.5f\\n\", vis[g][1]);\n  else cout << \"unreachable\" << endl;\n}\n\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    cin >> s >> g;\n    s--; g--;\n    fill(edge[0], edge[30], P(INF, 0));\n    for(int i=0;i<m;i++){\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      a--; b--;\n      edge[a][b] = edge[b][a] = P(c, d);\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <queue>\n#include <cstring>\nusing namespace std;\n#define N 30\n#define INF 100000\n\nstruct road{int to,cost,lim;};\nstruct situ{int v,now,from;double d;};\nbool operator < (const situ &a,const situ &b){\n\treturn a.d > b.d;\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,s,g;\n\t\tvector<road> roads[N];\n\t\tcin >> n >> m;\n\t\tif(!n&&!m) break;\n\t\tcin >> s >> g;\n\t\ts--;g--;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,c;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c);\n\t\t\tx--;y--;\n\t\t\troads[x].push_back((road){y,d,c});\n\t\t\troads[y].push_back((road){x,d,c});\n\t\t}\n\n\t\tpriority_queue<situ> que;\n\t\tfor(int i=0;i<roads[s].size();i++){\n\t\t\tint to = roads[s][i].to;\n\t\t\tint d = roads[s][i].cost;\n\t\t\tque.push((situ){1,to,s,(double)d});\n\t\t}\n\t\tbool used[N][N][31];\n\t\tmemset(used,0,sizeof(used));\n\n\t\tbool isClear = false;\n\t\twhile(que.size()){\n\t\t\tsitu st = que.top(); que.pop();\n\t\t\tif(used[st.now][st.from][st.v]) continue;\n\t\t\tused[st.now][st.from][st.v] = true;\n\t\t\tif(st.now==g&&st.v==1){\n\t\t\t\tprintf(\"%.5f\\n\",st.d);\n\t\t\t\tisClear = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<roads[st.now].size();i++){\n\t\t\t\tint to = roads[st.now][i].to;\n\t\t\t\tint d = roads[st.now][i].cost;\n\t\t\t\tif(to == st.from) continue;\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tif(st.v+j<=roads[st.now][i].lim&&st.v+j>0){\n\t\t\t\t\t\t//if(!used[to][st.now][st.v+j])\n\t\t\t\t\t\t\tque.push((situ){st.v+j,to,st.now,st.d+(double)d/(st.v+j)});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!isClear) cout << \"unreachable\" << endl;\n\n\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\nint n,m,s,g;\n\n\nint main(){\n  int inx,iny,ind,inc;\n  double d[40][40][40];\n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n    \n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\ntypedef vector<double> vd;\n\nstruct state {\n\tint p, n, s;\n\tdouble c;\n\tstate(int p, int n, int s, double c) : p(p), n(n), s(s), c(c) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\tint s, g;\n\t\tcin >> s >> g;\n\n\t\tvvi d(n, vi(n, INF));\n\t\tvvi c(n, vi(n, INF));\n\n\t\tint x, y, dd, cc;\n\t\tREP(_, m) {\n\t\t\tcin >> x >> y >> dd >> cc;\n\t\t\td[x-1][y-1] = d[y-1][x-1] = dd;\n\t\t\tc[x-1][y-1] = c[y-1][x-1] = cc;\n\t\t}\n\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(-1, s-1, 1, 0.0));\n\t\tvector<vd> cost(n, vd(30+1, INF));\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\t\t\tif(st.n == g-1 && st.s == 0) {\n\t\t\t\tcost[g-1][0] = min(st.c, cost[g-1][0]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(st.s == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP(t, n) {\n\t\t\t\tif(st.p == t || st.n == t || d[st.n][t] == INF || c[st.n][t] < st.s) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble nc = st.c + (double)d[st.n][t]/st.s;\n\t\t\t\tFOR(p, -1, 1) {\n\t\t\t\t\tif(30 < st.s+p) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(nc < cost[t][st.s+p]) {\n\t\t\t\t\t\tcost[t][st.s+p] = nc;\n\t\t\t\t\t\tQ.push(state(st.n, t, st.s+p, nc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(cost[g-1][0] == INF) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t} else {\n\t\t\tprintf(\"%.5f\\n\", cost[g-1][0]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int v[2], d, c;\n    Edge() {}\n    Edge(int v1, int v2, int d, int c) :\n        v{v1, v2}, d(d), c(c) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nconst double INF = 1e8;\n\nstruct State {\n    int prev, v, velocity;\n    double elapsed;\n    State() {}\n    State(int p, int v, int vv, double e) : prev(p), v(v), velocity(vv), elapsed(e) {}\n};\nbool operator<(const State &s1, const State &s2) {\n    return s1.elapsed > s2.elapsed;\n}\n\ndouble MinimumTime(const int start, const int goal, const Graph &g) {\n    const int n = g.size();\n    vector<vector<double>> tm(n, vector<double>(10 * n, INF)); // tm[頂点][速度]\n    tm[start][1] = 0.0;\n\n    priority_queue<State> que;\n    for (const auto &e : g[start]) {\n        que.push(State(start, e.v[1], 1, e.d));\n        tm[e.v[1]][1] = e.d;\n    }\n\n    while (!que.empty()) {\n        auto cur = que.top(); que.pop();\n\n        if (INF <= tm[cur.v][cur.velocity]) continue;\n\n        for (const auto &e : g[cur.v]) {\n            if (e.v[1] == cur.prev) continue;\n\n            for (int add = -1; add <= 1; ++add) {\n                const int velocity = cur.velocity + add;\n\n                if (velocity <= 0 || e.c < velocity) continue;\n\n                double tmp_tm = cur.elapsed + (double)e.d / velocity;\n                if (tmp_tm < tm[e.v[1]][velocity]) {\n                    tm[e.v[1]][velocity] = tmp_tm;\n                    que.push(State(cur.v, e.v[1], velocity, tmp_tm));\n                }\n            }\n        }\n    }\n\n    return (INF <= tm[goal][1]) ? -1.0 : tm[goal][1];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(6) << setiosflags(ios::fixed);\n\n    int n, m, s, g, x, y, d, c;\n\n    while (cin >> n >> m, n) {\n        cin >> s >> g;\n\n        Graph graph(n);\n        for (int i = 0; i < m; ++i) {\n            cin >> x >> y >> d >> c;\n            graph[x - 1].emplace_back(Edge(x - 1, y - 1, d, c));\n            graph[y - 1].emplace_back(Edge(y - 1, x - 1, d, c));\n        }\n\n        double time = MinimumTime(s - 1, g - 1, graph);\n        if (time < 0.0) cout << \"unreachable\\n\";\n        else cout << time << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nusing tp = tuple<int, int, int>;\nusing ttp = tuple<ld, int, int>;\n\nconst ld INF = 1e20;\n\nint main()\n{\n\tcout << fixed << setprecision(8);\n\tint n, m;\n\twhile (cin >> n >> m, n | m) {\n\t\tint s, g;\n\t\tcin >> s >> g; s--, g--;\n\t\tvector<vector<tp>> G(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c; x--, y--;\n\t\t\tG[x].emplace_back(y, d, c);\n\t\t\tG[y].emplace_back(x, d, c);\n\t\t}\n\t\tvector<vector<ld>> d(n, vector<ld>(31, INF));\n\t\tpriority_queue<ttp, vector<ttp>, greater<ttp>> pq;\n\t\tpq.emplace(0.0, s, 1);\n\t\twhile (!pq.empty()) {\n\t\t\tauto p = pq.top(); pq.pop();\n\t\t\tint v = get<1>(p), ve = get<2>(p);\n\t\t\tld cos = get<0>(p);\n\t\t\tif (d[v][ve] != INF) continue;\n\t\t\td[v][ve] = cos;\n\t\t\tif (ve == 0) continue;\n\t\t\tfor (auto e : G[v]) {\n\t\t\t\tint to = get<0>(e), st = get<2>(e);\n\t\t\t\tld dis = get<1>(e);\n\t\t\t\tif (st < ve) continue;\n\t\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\t\tif (d[to][ve + i] == INF) {\n\t\t\t\t\t\tpq.emplace(cos + dis / ve, to, ve + i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[g][0] == INF) cout << \"unreachable\" << endl;\n\t\telse cout << d[g][0] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cout << x << \" \";} cout << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\n// typedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\n// const int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef tuple<double, int, int, int> TUPLE;\nconst double inf = 1e12;\n\nstruct edge {\n    int to, d, c;\n    edge(){}\n    edge(int _to, int _d, int _c) : to(_to), d(_d), c(_c) {}\n};\ntypedef vector<vector<edge>> Graph;\ndouble dijkstra(const Graph& G, int s, int g) {\n    int n = G.size();\n    priority_queue<TUPLE, vector<TUPLE>, greater<TUPLE>> pq;   // cost, i, j, pre\n    vector<vector<double>> d(n, vector<double>(31, inf));\n    d[s][0] = 0;\n    pq.push(make_tuple(0, s, 0, -1));\n\n    while (!pq.empty()) {\n        double cost;\n        int i, j, pre;\n        tie(cost, i, j, pre) = pq.top(); pq.pop();\n        // cout << cost << \" \" << i << \" \" << j << endl;\n        if (i == g && j == 1) return cost;\n        if (d[i][j] < cost) continue;\n        for (const auto& e : G[i]) {\n            for (int k = -1; k <= 1; k++) {\n                if (e.to == pre) continue;\n                // if (e.to == g && j + k != 1) continue;\n                if (1 <= j + k && j + k <= e.c && d[e.to][j + k] > d[i][j] + 1. * e.d / (j + k)) {\n                    d[e.to][j + k] = d[i][j] + 1. * e.d / (j + k);\n                    pq.push(make_tuple(d[e.to][j + k], e.to, j + k, i));\n                }\n            }\n        }\n        // cerr << \"hey!\" << endl;\n    }\n\n    return inf;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    int t = 0;\n    while (cin >> n >> m, n) {\n        // cout << \"--- t = \" << t++ << \" ---\" << endl;\n\n        int s, g;\n        cin >> s >> g;\n        s--, g--;\n        Graph G(n);\n        rep(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--, y--;\n            G[x].emplace_back(y, d, c);\n            G[y].emplace_back(x, d, c);\n        }\n\n        double ans = dijkstra(G, s, g);\n        if (ans < inf) {\n            cout << fixed << setprecision(10) << ans << endl;\n        } else {\n            cout << \"unreachable\" << endl;\n        }\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\n\nclass Dijkstra {\n    using T = double;\npublic:\n    struct edge {\n        int to;\n        T cost;\n    };\n    typedef pair<T, int> P;//firstは最短距離、secondは頂点の番号\n\n    int V;//超点数\n    vector<vector<edge> > G;//グラフ,G[i]はiから出る辺の集合,G[i][j]はiから出る辺のj番目の辺\n    vector<T> d; //最短距離\n\n    //0origin\n    Dijkstra(int N) {\n        V = N;\n        G = vector<vector<edge> >(N);\n        d = vector<T>(N);\n    };\n\n    void dijkstra(int s) {\n        priority_queue<P, vector<P>, greater<P> > que;\n        fill(d.begin(), d.end(), INFl);\n        d[s] = 0;\n        que.push(P(0, s));\n\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if (d[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge e = G[v][i];\n                if (d[e.to] > d[v] + e.cost && !(d[e.to] == INFl && d[v] == INFl)) {\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n\n    }\n\n    /* 頂点fromに頂点toに達するコストcostの辺を貼る */\n    void addEdge(int from, int to, T cost) {\n        edge e;\n        e.to = to;\n        e.cost = cost;\n        G[from].push_back(e);\n    }\n};\n\nvoid solve(int n, int m) {\n    int s,g;\n    cin >> s >> g;\n    s--;\n    g--;\n\n    auto conv = [&](int f, int v){\n        //(頂点、速度)\n        return v * n + f;\n    };\n\n    Dijkstra dij(60 * n + n);\n\n    rep(i,0,m){\n        int x,y,d,c;\n        cin >> x >> y >> d >> c;\n        x--;\n        y--;\n        auto check = [&](int v){\n            return v > 0 && v <= c;\n        };\n        rep(v,0,31){\n            for(int V = v - 1; V <= v + 1; V++){\n                if(check(V)){\n                    double tmp = 1.0 * d / V;\n                    dij.addEdge(conv(x,v),conv(y,V),tmp);\n                    dij.addEdge(conv(y,v),conv(x,V),tmp);\n                }\n            }\n        }\n    }\n\n    dij.dijkstra(conv(s,0));\n//    cout << dij.d[conv(g,1)] << endl;\n    double ans = dij.d[conv(g,1)];\n    if(ans == INFl){\n        cout << \"unreachable\" << endl;\n    }else{\n//        cout << ans << endl;\n        printf(\"%.5lf\\n\",ans);\n    }\n\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n#define N 30\n#define INF 100000\nstruct road{int to,cost,lim;};\n\nstruct situ{int v,now,from;double d;};\nbool operator < (const situ &a,const situ &b){\n\treturn a.d > b.d;\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,s,g;\n\t\tvector<road> roads[N];\n\t\tcin >> n >> m;\n\t\tif(!n&&!m) break;\n\t\tcin >> s >> g;\n\t\ts--;g--;\n\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,c;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c);\n\t\t\tx--;y--;\n\t\t\troads[x].push_back((road){y,d,c});\n\t\t\troads[y].push_back((road){x,d,c});\n\t\t}\n\t\n\t\tpriority_queue<situ> que;\n\t\tfor(int i=0;i<roads[s].size();i++){\n\t\t\tint to = roads[s][i].to;\n\t\t\tint d = roads[s][i].cost;\n\t\t\tque.push((situ){1,to,s,(double)d});\n\t\t}\n\t\tdouble dist[N][N][31];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=1;k<31;k++){\n\t\t\t\t\tdist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(que.size()){\n\t\t\tsitu st = que.top(); que.pop();\n\t\t\tif(dist[st.now][st.from][st.v]<st.d) continue;\n\t\t\tdist[st.now][st.from][st.v] = st.d;\n\t\t\tfor(int i=0;i<roads[st.now].size();i++){\n\t\t\t\tint to = roads[st.now][i].to;\n\t\t\t\tint d = roads[st.now][i].cost;\n\t\t\t\tif(to != st.from){\n\t\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\tif(st.v+j<=roads[st.now][i].lim&&st.v+j>=0){\n\t\t\t\t\t\t\tque.push((situ){st.v+j,to,st.now,st.d+(double)d/(st.v+j)});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = INF;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tans = min(ans,dist[g][i][1]);\n\t\t}\n\t\tif(ans==INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t\tprintf(\"%.5f\\n\",ans);\n\t\t}\n\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 300\ntypedef std::pair<short,short> P;\ntypedef std::pair<P,short> PP;\ntypedef std::pair<float,short> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    short n,m;\n\n    scanf(\"%hd%hd\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    short inx,iny,ind,inc;\n    float d[31][31][31];\n    short s,g;\n \n\n    scanf(\"%hd%hd\",&s,&g);\n    for(short i=1;i<=n;i++)for(short j=1;j<=n;j++)for(short k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(short i=0;i<m;i++){\n      scanf(\"%hd%hd%hd%hd\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    \n    while(que.size()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(short i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<cmath>\n#include<vector>\n#include<functional>\n#define ull unsigned long long int \n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define min_(a,b) ((a)<(b)?(a):(b))\nusing namespace std;\n\n#define INF 10000000\n#define MAX_V 1000 \nstruct edge{ int to; double time; };\nvector<edge>G[MAX_V];\ndouble d[MAX_V];\nstruct T{\n\tdouble time;\n\tint from, to;\n};\nint V,E,st,gl;\n\nstruct StructGreater {\n\tbool operator() (const T a, const T b) {\n\t\treturn a.time > b.time;\n\t}\n};\nvoid dk(int s){\n\tfill(d, d + MAX_V, INF);\n\tpriority_queue<T, vector<T>, StructGreater >que;\n\ts = s * 30 + 0;\n\td[s] = 0;\n\trep(i, 0, (int)G[s].size())\n\tif (G[s][i].to%30==0){\n\t\t//printf(\"to=%d,time=%f\\n\", G[s][i].to / 30 + 1, G[s][i].time);\n\t\tT t = { G[s][i].time, s / 30, G[s][i].to };\n\t\tque.push(t);\n\t\td[G[s][i].to] = G[s][i].time;\n\t}\n\t//T tx = { 0,-1, 0 };\n\t//que.push(tx);\n\twhile (!que.empty()){\n\t\tT t = que.top(); que.pop();\n\t\tint v = t.to;\n\n\t\tif (d[v] < t.time)continue;\n\t\trep(i, 0, (int)G[v].size()){\n\t\t\tedge e = G[v][i];\n\t//\t\tprintf(\"%d->%d,%d->%d,\\n\", v / 30 + 1, e.to / 30 + 1,v % 30 + 1, e.to % 30 + 1);\n\t\t\tif (e.to / 30 != t.from&&d[e.to]>d[v] + e.time){\n\t\t\t\td[e.to] = d[v] + e.time;\n\t//\t\t\tprintf(\"(%d<%d<%d)%d,%f\\n\", e.to / 30 + 1, t.to / 30 + 1, t.from + 1, e.to % 30 + 1,d[e.to]);\n\t\t\t\tT tmp = { d[e.to], v / 30, e.to };\n\t\t\t\tque.push(tmp);\n\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i, 0, MAX_V)if (d[i] < INF)\n\t\t//printf(\"to=%d,time=%f\\n\", i / 30 + 1, d[i]);\n}\n\nint main(void){\n\twhile (true){\n\t\tcin >> V >> E;\n\t\tif (V == 0)return 0;\n\t\tcin >> st >> gl;\n\t\tst--; gl--;\n\t\trep(i, 0, E){\n\t\t\tint first, second, lim;\n\t\t\tdouble length;\n\t\t\tcin >> first >> second >> length >> lim;\n\t\t\tfirst--;\n\t\t\tsecond--;\n\t\t//\tcout << first << second << endl;\n\t\t\trep(i, 1, 31){\n\t\t\t\tdouble real_v;\n\t\t\t\t//始点\n\t\t\t\tint f = first * 30 + i - 1;\n\t\t\t\tint s = second * 30 + i - 1;\n\t\t\t\trep(j, -1, 2){\n\t\t\t\t\treal_v = i + j;\n\t\t\t\t\t//cout << real_v << endl;\n\t\t\t\t\tif (real_v<1 || real_v>lim)continue;\n\t\t\t\t\treal_v = length / real_v;\n\t\t\t\t\tedge f_e = { f + j, real_v }; edge s_e = { s + j, real_v };\n\t\t\t\t//\tcout << first << second << gl<<endl;\n\t\t\t\t\tG[f].push_back(s_e); \n\t\t\t\t\tG[s].push_back(f_e);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*rep(i, 0, MAX_V)\n\t\t\trep(j, 0, (int)G[i].size()){\n\t\t\t\tprintf(\"from=%d,to=%d,v=%d->%d,time=%f\\n\", i / 30 + 1, G[i][j].to / 30 + 1, i % 30 + 1, G[i][j].to % 30 + 1, G[i][j].time);\n\n\t\t\t}\n*/\n\t\tdk(st);\n\t\tif (d[gl * 30]<INF)\n\t\tprintf(\"%.8f\\n\", d[gl * 30]);\n\t\telse cout << \"unreachable\" << endl;\n\t\trep(i, 0, MAX_V)\n\t\twhile (!G[i].empty())\n\t\t\t\tG[i].pop_back();\n\t\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 10000000\n\nusing namespace std;\n\nint n,m;\n\nstruct edge {\n\tint t;\n\tint dis;\n\tint lim;\n};\n\nstruct Point {\n\tint pos;\n\tdouble time;\n\tint speed;\n\tint pres;\n\n\tbool operator<(const Point& right) const {\n\t\treturn (time > right.time);\n\t}\n};\n\nint main(void) {\n\twhile (cin >> n >> m, n) {\n\t\tint s,g;\n\t\tcin >> s >> g;\n\n\t\tint x,y,d,c;\n\t\tvector< vector<edge> > adj(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tadj[x-1].push_back((edge){y-1,d,c});\n\t\t\tadj[y-1].push_back((edge){x-1,d,c});\n\t\t}\n\n\t\tpriority_queue<Point> pq;\n\t\tpq.push((Point){s-1,0,1,1});\n\t\tdouble dp[n][31];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < 31; ++j) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][1] = 0;\n\n\t\tbool find = false;\n\t\twhile (!pq.empty()) {\n\t\t\tPoint pn = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif (pn.pos == g-1 && pn.speed == 1 && pn.pres == 1) {\n\t\t\t\tprintf(\"%llf\\n\",pn.time);\n\t\t\t\tfind = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (size_t i = 0; i < adj[pn.pos].size(); ++i) {\n\t\t\t\tdouble rt = ((double)adj[pn.pos][i].dis/pn.speed);\n\t\t\t\tif (pn.time + rt < dp[adj[pn.pos][i].t][pn.speed] && pn.speed <= adj[pn.pos][i].lim) {\n\t\t\t\t\tdp[adj[pn.pos][i].t][pn.speed] = pn.time + rt;\n\t\t\t\t\tpq.push((Point){adj[pn.pos][i].t,pn.time+rt,pn.speed,pn.speed});\n\t\t\t\t\tif (pn.speed != 30) {\n\t\t\t\t\t\tpq.push((Point){adj[pn.pos][i].t,pn.time+rt,pn.speed+1,pn.speed});\n\t\t\t\t\t}\n\t\t\t\t\tif (pn.speed != 1) {\n\t\t\t\t\t\tpq.push((Point){adj[pn.pos][i].t,pn.time+rt,pn.speed-1,pn.speed});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!find) {\n\t\t\tcout << \"unreachable\" <<  endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <queue>\n#include <set>\nusing namespace std;\n\ndouble memo[32][32]; //[vol][vertex] = time\nint N,M,S,G;\nstruct e {\n\tint d,c;\n}edge[32][32];\n\nint main()\n{\n\tint x,y,d,c;\n\tfor(;cin>>N>>M,N||M;){\n\t\tcin>>S>>G;\n\t\tfor(int i=0;i<32;i++)for(int j=0;j<32;j++)\n\t\t\tmemo[i][j]=999999.0,edge[i][j].d=edge[i][j].c=-1;\n\t\t\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tedge[x][y].d = edge[y][x].d = d;\n\t\t\tedge[x][y].c = edge[y][x].c = c;\n\t\t}\n\t\tmemo[1][S] = 0.0;\n\t\t\n\t\tqueue<pair<int,int> > qq;\n\t\tqueue<int> befor;\n\t\tqueue<double> cc;\n\t\tset<pair<int,int> > pst;\n\t\tset<pair<int,int> >::iterator pstit;\n\t\tqq.push(make_pair(0,S));\n\t\tbefor.push(S);\n\t\tcc.push(0.0);\n\t\tfor(;!qq.empty();){\n\t\t\tint vol = qq.front().first;\n\t\t\tint vertex = qq.front().second;\n\t\t\tint b = befor.front();\n\t\t\tdouble cost = cc.front();\n\t\t\t\n\t\t\tpst.clear();\n\t\t\tbefor.pop(); cc.pop(); qq.pop();\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\tif(i==vertex || i==b || edge[vertex][i].d < 0)continue;\n\t\t\t\tif(vol>0 && vol<=edge[vertex][i].c){\n\t\t\t\t\tif(memo[vol][i] > (double)edge[vertex][i].d/vol + cost &&\n\t\t\t\t\t\tmemo[1][G] > (double)edge[vertex][i].d/vol + cost){\n\t\t\t\t\t\tmemo[vol][i] = (double)edge[vertex][i].d/vol + cost;\n\t\t\t\t\t\tqq.push(make_pair(vol,i));\n\t\t\t\t\t\tbefor.push(vertex);\n\t\t\t\t\t\tcc.push(memo[vol][i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//pst.insert(make_pair(vol,i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(vol+1>0 && vol+1<=edge[vertex][i].c){\n\t\t\t\t\tif(memo[vol+1][i] > (double)edge[vertex][i].d/(vol+1) + cost &&\n\t\t\t\t\t\tmemo[1][G] > (double)edge[vertex][i].d/(vol+1) + cost){\n\t\t\t\t\t\tmemo[vol+1][i] = (double)edge[vertex][i].d/(vol+1) + cost;\n\t\t\t\t\t\tqq.push(make_pair(vol+1,i));\n\t\t\t\t\t\tbefor.push(vertex);\n\t\t\t\t\t\tcc.push(memo[vol+1][i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//pst.insert(make_pair(vol+1,i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(vol-1>0 && vol-1<=edge[vertex][i].c){\n\t\t\t\t\tif(memo[vol-1][i] > (double)edge[vertex][i].d/(vol-1) + cost &&\n\t\t\t\t\t\tmemo[1][G] > (double)edge[vertex][i].d/(vol-1) + cost){\n\t\t\t\t\t\tmemo[vol-1][i] = (double)edge[vertex][i].d/(vol-1) + cost;\n\t\t\t\t\t\tqq.push(make_pair(vol-1,i));\n\t\t\t\t\t\tbefor.push(vertex);\n\t\t\t\t\t\tcc.push(memo[vol-1][i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//pst.insert(make_pair(vol-1,i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(pstit=pst.begin();pstit!=pst.end();pstit++){\n\t\t\t\tqq.push(*pstit);\n\t\t\t\tbefor.push(vertex);\n\t\t\t\tcc.push(memo[pstit->first][pstit->second]);\n\t\t\t}*/\n\t\t}\n\t\t\n\t\tprintf(memo[1][G]==999999.0?\"unreachable\\n\":\"%lf\\n\",memo[1][G]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define INF (1e+8)\n\n\ndouble dp[30][30][30];\nint n,m;\nint s,g;\nint d[30][30],c[30][30];\n\ndouble dijkstra(){\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\tfor(int k=0;k<30;k++)dp[i][j][k]=INF;\n\tbool used[30][30][30]={false};\n\tdp[s][s][0] = 0;\n\tdouble res=INF;\n\twhile(1){\n\t\tint pos=-1,from,speed;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<30;k++){\n\t\t\t\t\tif(!used[i][j][k] && dp[i][j][k]!=INF && (pos==-1||dp[i][j][k]<dp[pos][from][speed])){\n\t\t\t\t\t\tpos=i;\n\t\t\t\t\t\tfrom=j;\n\t\t\t\t\t\tspeed=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pos==-1)break;\n\t\tused[pos][from][speed]=true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(d[pos][i]==-1 || i==from)continue;\n\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\tif(pos==from&&j!=0)continue;\n\t\t\t\tif(speed+j+1<=0 || c[pos][i]<speed+j+1)continue;\n\t\t\t\tdouble t=dp[pos][from][speed]+(double)d[pos][i]/(speed+j+1);\n\t\t\t\tif(t<dp[i][pos][speed+j]){\n\t\t\t\t\tdp[i][pos][speed+j]=t;\n\t\t\t\t\tif(i==g&&speed+j==0)res=min(res,t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\twhile(cin>>n>>m,n||m){\n\t\tcin>>s>>g;\n\t\ts--;g--;\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)d[i][j]=-1;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,a,b;\n\t\t\tcin>>x>>y>>a>>b;\n\t\t\tx--;y--;\n\t\t\td[x][y]=d[y][x]=a;\n\t\t\tc[x][y]=c[y][x]=b;\n\t\t}\n\t\tdouble ans=dijkstra();\n\t\tif(ans==INF)puts(\"unreachable\");\n\t\telse printf(\"%.5f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\nint n,m,s,g;\ndouble d[40][40][40];\n\nint main(){\n  int inx,iny,ind,inc;\n  while(true){\n    cin >> n >> m;\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n\n    cin >> s >> g;\n    for(int i=0;i<40;i++)for(int j=0;j<40;j++)for(int k=0;k<40;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n      cin >> inx >> iny >> ind >> inc;\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      //if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n   \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else cout << \"unreachable\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector< vector<int> > vvi;\n\nint dist[31][31];\nint cap[31][31];\nbool visit[31][31]; // city, speed\nconst int INF = 1e7;\n\nstruct node {\n\tint s, p, c;\n\tdouble t;\n\tnode(int _s, int _p, int _c, double _t) {\n\t\ts = _s;\n\t\tp = _p;\n\t\tc = _c;\n\t\tt = _t;\n\t}\n};\nbool operator<(const node& l, const node& r) {\n\treturn l.t > r.t;\n}\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\trep(i,31) rep(j,31) dist[i][j] = cap[i][j] = INF;\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\trep(i, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tdist[x][y] = dist[y][x] = d;\n\t\t\tcap[x][y] = cap[y][x] = c;\n\t\t}\n\t\tpriority_queue<node> que;\n\t\tvisit[s][1] = true;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tif( dist[s][i] < INF && 1 <= cap[s][i] ) {\n\t\t\t\tque.push( node(1, i, s, 1.*dist[s][i]) );\n\t\t\t}\n\t\t}\n\t\tbool found = false;\n\t\twhile(!que.empty()) {\n\t\t\tnode nd = que.top();\n\t\t\tque.pop();\n\t\t\tif( nd.p==g && nd.s==1 ) {\n\t\t\t\tcout << setprecision(10) << nd.t << endl;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( visit[nd.p][nd.s] ) continue;\n\t\t\tvisit[nd.p][nd.s] = true;\n\t\t\tfor(int nxt=1; nxt<=n; nxt++) {\n\t\t\t\tif( nd.c == nxt ) continue;\n\t\t\t\tfor(int sp=max(1,nd.s-1); sp<=min(30,nd.s+1); sp++) {\n\t\t\t\t\tif( !visit[nxt][sp] && dist[nd.p][nxt] < INF && sp <= cap[nd.p][nxt] ) {\n\t\t\t\t\tdouble nt = nd.t + 1.*dist[nd.p][nxt]/sp;\n\t\t\t\t\t\tque.push(node(sp, nxt, nd.p, nt));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!found) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n2017_04_24_AC\n<point>\n???(?????¨????????????????????¨??????????????¨???????????°???????????????)?????¶?????¨??????????????????????????????priority_queue???\n<caution>\n ???U?????????????????¶?????????????????????\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define D first\n#define C second\n\nusing namespace std;\n\nconst double INF = 1000000000.0;\n\ndouble d[35][35][35];\nbool visited[35][35][35];\nint N,M,S,G;\npair<int, int> p[35][35];\n\nstruct ST{\n  double ti;\n  int bn;\n  int cn;\n  int sp;\n  ST(double _ti, int _bn, int _cn, int _sp){\n    ti = _ti;\n    bn = _bn;\n    cn = _cn;\n    sp = _sp;\n  }\n\n  bool operator <(const ST &e) const{\n    return ti < e.ti;\n  }\n\n};\n\nint main() {\n  while(1){\n    cin>>N>>M;\n    if(N==0 && M==0) break;\n    cin>>S>>G;\n    S--; G--;\n\n    REP(i,0,N)REP(j,0,N)REP(k,0,35) d[i][j][k] = INF;\n    REP(i,0,N)REP(j,0,N)REP(k,0,35) visited[i][j][k] = false;\n    REP(i,0,N)REP(j,0,N) p[i][j].D = p[i][j].C = -1;\n\n    REP(i,0,M){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      p[x-1][y-1].D = p[y-1][x-1].D = d;\n      p[x-1][y-1].C = p[y-1][x-1].C = c;\n    }\n\n    d[S][S][0] = 0.0;\n\n    priority_queue< ST/*, vector<ST>, greater<ST>()*/> PQ;\n    ST st(0.0,S,S,0);\n    PQ.push(st);\n\n    bool flag = true;\n    while(!PQ.empty()){\n      ST u = PQ.top(); PQ.pop();\n      double mtime = u.ti;\n      int ubn=u.bn, ucn=u.cn, usp=u.sp;\n      //visited[ubn][ucn][usp] = true;\n      if(d[ubn][ucn][usp] < mtime) continue;\n\n      if(ucn == G && usp == 1){\n        printf(\"%.5lf\\n\",d[ubn][ucn][usp]);\n        flag = false;\n        break;\n      }\n\n      visited[ubn][ucn][usp] = true;\n      for(int v = usp-1; v <= usp+1; v++){\n        if(v <= 0) continue;\n        REP(next,0,N){\n          if(/*visited[ucn][next][v] ||*/ p[ucn][next].D == -1 || p[ucn][next].C < v || ucn == next || ubn == next) continue;\n          if(d[ucn][next][v] > mtime + (double)p[ucn][next].D/(double)v){\n            d[ucn][next][v] = mtime + (double)p[ucn][next].D/(double)v;\n            ST tst(d[ucn][next][v], ucn,next,v);\n            PQ.push(tst);\n          }\n        }\n      }\n\n    }\n    if(flag){\n      cout<<\"unreachable\"<<endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define INF 100000000\n#define rep(i,n) for(int i=0;i<n;i++)\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<double,int> pp;\ntypedef pair<pp,p> P;\nstruct edge{\n\tint to,d,c;\n};\nint main(){\n\tdouble dp[31][31][31];\n\tint n,m,s,g,x,y,d,c,ds[]={1,-1,0};\n\twhile(cin>>n>>m,n||m){\n\t\tvector<edge> G[31];\n\t\tcin>>s>>g;\n\t\ts--;g--;\n\t\trep(i,m){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tx--;y--;\n\t\t\tedge e;\n\t\t\te.d=d;e.c=c;\n\t\t\te.to=y;\n\t\t\tG[x].push_back(e);\n\t\t\te.to=x;\n\t\t\tG[y].push_back(e);\n\t\t}\n\t\trep(i,31)\n\t\trep(j,31)\n\t\trep(k,31)\n\t\tdp[i][j][k]=INF;\n\t\tdp[0][s][s]=0.0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(pp(0.0,-1),p(0,s)));\n\t\tdouble ans=INF;\n\t\twhile(!que.empty()){\n\t\t\tP q=que.top();que.pop();\n\t\t\tif(q.second.second==g&&q.second.first==1){\n\t\t\t\tans=min(ans,dp[q.second.first][q.second.second][q.first.second]);\n\t\t\t//\tcout<<ans<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//cout<<q.second.second<<' '<<q.second.first<<' '<<q.first<<endl;\n\t\t\tif(dp[q.second.first][q.second.second][q.first.second]<q.first.first)\n\t\t\t\tcontinue;\n\t\t\trep(i,G[q.second.second].size()){\n\t\t\t\tedge e=G[q.second.second][i];\n\t\t\t\tif(e.to==q.first.second)\n\t\t\t\tcontinue;\n\t\t\t\trep(j,3){\n\t\t\t\t\tint pre=q.second.first+ds[j];\n\t\t\t\t\tif(pre<1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble tes=(double)e.d/pre+q.first.first;\n\t\t\t\t\tif(pre<=e.c&&dp[pre][e.to][q.second.second]>tes){\n\t\t\t\t\t\tque.push(P(pp(tes,q.second.second),p(pre,e.to)));\n\t\t\t\t\t\tdp[pre][e.to][q.second.second]=tes;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans==INF)\n\t\tcout<<\"unreachable\"<<endl;\n\t\telse\n\t\tprintf(\"%.5lf\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong double memo[10000][32];\nstruct edge {\n\tint id;\n\tint from;\n\tint to;\n\tint lim;\n\tlong double dis;\n};\nstruct aa {\n\tint id;\n\tint speed;\n\tlong double  time;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nint main() {\n\tcout << fixed << setprecision(22);\n\twhile (1) {\n\t\tmemset(memo, 9999999, sizeof(memo));\n\t\tint n, m; cin >> n >> m;\n\t\tif (!n)break;\n\t\tint s, g; cin >> s >> g; s--; g--;\n\t\tvector<edge>edges;\n\t\tvector<vector<int>>edgeids(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tlong double d;\n\t\t\tint x, y, c; cin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tedges.push_back(edge{ 2*i,x,y,c,d });\n\t\t\tedges.push_back(edge{ 2*i+1,y,x,c,d });\n\t\t\tedgeids[x].push_back(2 * i);\n\t\t\tedgeids[y].push_back(2 * i + 1);\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tfor (auto i : edgeids[s]) {\n\n\t\t\tque.push(aa{ i,1,edges[i].dis });\n\t\t\tmemo[i][1] = edges[i].dis;\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst edge oldedge(edges[atop.id]);\n\t\t\tconst int oldsp(atop.speed);\n\t\t\tconst long double oldtime(atop.time);\n\t\t\tfor (auto i : edgeids[oldedge.to]) {\n\t\t\t\tconst edge nextedge(edges[i]);\n\t\t\t\tif (nextedge.to == oldedge.from)continue;\n\t\t\t\telse {\n\t\t\t\t\tfor (int change = -1; change <= 1; ++change) {\n\t\t\t\t\t\tconst int nextsp = oldsp + change;\n\t\t\t\t\t\tif (nextsp == 0)continue;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (nextsp <= nextedge.lim) {\n\t\t\t\t\t\t\t\tconst long double nexttime= nextedge.dis / nextsp + oldtime;\n\t\t\t\t\t\t\t\tif (memo[i][nextsp] > nexttime) {\n\t\t\t\t\t\t\t\t\tmemo[i][nextsp] = nexttime;\n\t\t\t\t\t\t\t\t\tque.push(aa{ i,nextsp,nexttime });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong double amin = 999999999;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tif (edges[i].to == g) {\n\t\t\t\tamin = min(amin, memo[i][1]);\n\t\t\t}\n\t\t}\n\t\tif (amin > 99999999) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << amin << endl;\n\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n\tint cost,limit;\n\tedge(int c,int l){\n\t\tcost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tvector<vector<edge> > E(n+1,vector<edge>(n+1,edge(-1,-1)));\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in][out]=edge(c,l);\n\t\tE[out][in]=edge(c,l);\n\t}\n\tvector<vector<double> > Ans(n+1,vector<double>(31,INF));\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){\n\t\tNode t=Q.top(); Q.pop();\n\t\tif(Ans[t.now][t.speed]<=t.time) continue;\t\t\n//\t\tcout<<t.now<<\" \"<<t.speed<<\" \"<<t.time<<endl;\n\t\tif(t.now==g && t.speed==1){cout<<t.time<<endl; return;}\n\t\tAns[t.now][t.speed]=t.time;\n\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tif(i==t.before) continue;\n\t\t\tif(E[t.now][i].cost>0){\n\t\t\t\tif(E[t.now][i].limit>=t.speed && t.speed>=1)\n\t\t\t\t\tQ.push(Node(i,t.speed,t.time+E[t.now][i].cost/(double)t.speed,t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed+1)\n\t\t\t\t\tQ.push(Node(i,t.speed+1,t.time+E[t.now][i].cost/(double)(t.speed+1.0),t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed-1 && t.speed-1>=1)\n\t\t\t\t\tQ.push(Node(i,t.speed-1,t.time+E[t.now][i].cost/(double)(t.speed-1.0),t.now));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\\n\";\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint n, m, s, g;\nint dv[] = {-1,0,1};\n\nstruct S{\n    int cur, prev, vel;\n    double dist;\n    S(int cur, int prev, int vel, double dist):cur(cur),prev(prev),vel(vel),dist(dist){}\n    bool operator>(const S &p) const{\n        return dist > p.dist;\n    }\n};\n\nint main() {\n    while(cin >> n >> m, n || m){\n        cin >> s >> g;\n        s--; g--;\n        vector<vector<pii> > path(n,vector<pii> (n,mp(INF,INF)));\n        rep(i,m){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            path[x][y] = mp(d,c);\n            path[y][x] = mp(d,c);\n        }\n\n        double d[32][32][32];\n        rep(i,32)rep(j,32)rep(k,32) d[i][j][k] = INF;\n//        d[s][s][0] = 0;\n        priority_queue<S, vector<S>, greater<S> > que;\n        que.push(S(s,s,0,0));\n        double ans = -1;\n        while(!que.empty()){\n            S tmp = que.top(); que.pop();\n            int cur = tmp.cur, prev = tmp.prev, vel = tmp.vel;\n            double dist = tmp.dist;\n            if(dist >= d[cur][prev][vel]) continue;\n            d[cur][prev][vel] = dist;\n            if(vel == 1 && cur == g) {\n                ans = dist;\n                break;\n            }\n            rep(i,n)rep(j,3){\n                if(i == prev || path[cur][i].first == INF) continue;\n                if(vel + dv[j] > 0 && vel + dv[j] <= path[cur][i].second){\n                    que.push(S(i,cur,vel+dv[j],dist + 1.0 * path[cur][i].first / (vel+dv[j])));\n                }\n            }\n        }\n        if(ans>=0) printf(\"%.8f\\n\",ans);\n        else cout << \"unreachable\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<functional>\n \n \n#define rep(i,n) for(int i=0;i<(n);i++)\n \nusing namespace std;\nconst int INF = 100000000;\ntypedef pair<int,int> P;\n\nint n,m;\n\nstruct edge\n{\n\t//どこから来た,コスト,速度制限\n\tint to,cost,ub;\n\tedge(int to,int cost,int ub) {\n\t\tthis->to = to;\n\t\tthis->cost = cost;\n\t\tthis->ub = ub;\n\t}\n};\n\nvector<edge> G[103];\nint s,g;\ndouble dist[103][103][33];\n\ntypedef pair<double,int> PD;\ntypedef pair<PD,P> PP;\n\ndouble dijkstra() {\n\trep(i,103) rep(j,103) rep(k,33) dist[i][j][k]=INF;\n\tdist[s][0][1]=0;\n\n\t//最短距離 頂点 前の頂点 今の速さ\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(PD(0,s),P(0,1)));\n\n\twhile (!que.empty())\n\t{\n\t\tPP pp = que.top(); que.pop();\n\t\tint v = pp.first.second;\n\n\t\tint prev = pp.second.first;\n\t\tint u = pp.second.second;\n\n\t\tif(dist[v][prev][u] < pp.first.first) continue;\n\n\t\trep(i,G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tfor(int j=-1;j<=1;j++) {\n\t\t\t\tif(j+u<=0 || u+j > e.ub) continue;\n\n\t\t\t\tif(dist[e.to][v][u+j] > dist[v][prev][u] + (1.0*e.cost/(u+j))) {\n\t\t\t\t\tdist[e.to][v][u+j] = dist[v][prev][u] + (1.0*e.cost/(u+j));\n\t\t\t\t\tque.push(PP(PD(dist[e.to][v][u+j],e.to),P(v,u+j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tdouble ans=INF;\n\trep(i,103) ans=min(ans,dist[g][i][1]);\n\n\treturn ans;\n\t\n}\n\nvoid solve() {\n\trep(i,103) G[i].clear();\n\tcin>>s>>g;\n\trep(i,m) {\n\t\tint x,y,d,c;\n\t\tcin>>x>>y>>d>>c;\n\t\tG[x].push_back(edge(y,d,c));\n\t\tG[y].push_back(edge(x,d,c));\n\t}\n\n\tdouble ans;\n\tans = dijkstra();\n\tif(ans==INF) {\n\t\tcout<<\"unreachable\"<<endl;\n\t}\n\telse\n\t{\n\t\tcout<<ans+1.0<<endl;\n\t}\n\n\n}\n\nint main() {\n\twhile (cin>>n>>m)\n\t{\n\t\tif(n+m==0) return 0;\n\t\tsolve();\n\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S second\n#define F first\n#define EPS (1e-7)\n#define INF (1e9)\n#define N 31\nusing namespace std;\ntypedef pair<double,int> P;\ntypedef pair<int,int> P1;\ntypedef pair<int,P1> P2;\ntypedef pair<P,P1> P3;\ntypedef pair<P3,int> P4;\n\nvector<P2> G[N];\nint n,m,s,g;\n\ndouble dijkstra(){\n  P d[N][N][N];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<N;k++)\n\td[i][j][k]=P(INF,INF);\n  priority_queue<P4,vector<P4>,greater<P4> > q;\n  for(int i=0;i<G[s].size();i++){\n    int nx=G[s][i].first,cost=G[s][i].second.first;\n    d[s][nx][1]=P(cost,cost);\n    q.push(P4(P3(P(cost,cost),P1(s,nx)),1));\n  }\n  while(!q.empty()){\n    P4 t=q.top(); q.pop();\n    int px=t.F.S.F,x=t.F.S.S,v=t.S,sum=t.F.F.S;\n    double cost=t.F.F.F;\n    if(d[px][x][v].F+EPS<cost)continue;\n    if(abs(cost-d[px][x][v].F)<EPS)\n      if(d[px][x][v].S<sum)continue;\n    if(x==g&&v==1)return cost;\n    for(int i=0;i<G[x].size();i++){\n      int nx=G[x][i].F,cost2=G[x][i].S.F;\n      int lim=G[x][i].S.S;\n      if(nx==px)continue;\n      for(int j=-1;j<=1;j++){\n\tint nv=v+j;\n\tif(nv<1||30<nv||nv>lim)continue;\n\tdouble ncost=cost+1.0*cost2/nv;\n\tif(d[x][nx][nv].F>ncost+EPS){\n\t  d[x][nx][nv]=P(ncost,sum+cost);\n\t  q.push(P4(P3(P(ncost,sum+cost),P1(x,nx)),nv));\n\t}\n\tif(abs(d[x][nx][nv].F-ncost)<EPS)\n\t  if(d[x][nx][nv].S>sum+cost){\n\t    d[x][nx][nv]=P(ncost,sum+cost);\n\t    q.push(P4(P3(P(ncost,sum+cost),P1(x,nx)),nv));\n\t  }\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    cin>>s>>g;\n    s--,g--;\n    int a,b,c,d;\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>c>>d;\n      a--,b--;\n      G[a].push_back(P2(b,P1(c,d)));\n      G[b].push_back(P2(a,P1(c,d)));\n    }\n    double r=dijkstra();\n    if(r==-1)cout<<\"unreachable\"<<endl;\n    else printf(\"%.5f\\n\",r);\n    for(int i=0;i<n;i++)G[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n\n///////////////////ダイクストラで使うクラス//////////////////\nclass E{\n\tpublic:\n\tint dir,cost,limit;\n\tE(int dir,int cost,int limit):dir(dir),cost(cost),limit(limit){}\n};\n\nclass T{\n\tpublic:\n\tint pos,bef,speed;\n\tdouble val;\n\tT(int pos,int bef,double val,int speed):pos(pos),bef(bef),val(val),speed(speed){}\n\t\n\tbool operator<(const T& a)const{\n\t\treturn val>a.val;\n\t}\n};\n\n////////////////////////////main/////////////////////////\nint main(){\n\t\n\twhile(1){\n\t\t/////////////入力/////////////////////////////////\n\t\tint n,m,start,goal;\n\t\tvector<E> edge[33];\n\t\t\n\t\tcin>>n>>m; if(n==0)break;\n\t\tcin>>start>>goal;\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tedge[a].push_back(E(b,c,d));\n\t\t\tedge[b].push_back(E(a,c,d));\n\t\t}\n\t\t\n\t\t///////////ダイクストラ本体//////////////////////\n\t\tpriority_queue<T> que;\n\t\tque.push(T(start,0,0,0)); //初期位置設定\n\t\t\n\t\tint visit[33][33][33]={0};\n\t\twhile(1){\n\t\t\tif(que.empty())break; //異常終了\n\t\t\t\n\t\t\tT u = que.top();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(visit[u.pos][u.bef][u.speed]==1)continue; //一度訪れた状態の場合は弾く\n\t\t\tvisit[u.pos][u.bef][u.speed]=1;\n\t\t\t\n\t\t\tif(u.pos==goal && u.speed==1){ //終了判定\n\t\t\t\tprintf(\"%lf\\n\",u.val);\n\t\t\t\tgoto A;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<edge[u.pos].size();i++){ //状態遷移\n\t\t\t\tE e = edge[u.pos][i];\n\t\t\t\tif(e.dir == u.bef)continue; //Uターン禁止の制約で弾く\n\t\t\t\t\n\t\t\t\t//-1:減速 0:等速 1:加速\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\n\t\t\t\t\tint next = u.speed + j;\n\t\t\t\t\tif(next > e.limit || next <= 0)continue; //速度の制約で弾く\n\t\t\t\t\t\n\t\t\t\t\tque.push( T(e.dir, u.pos, u.val + double(e.cost)/next, next) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"unreachable\\n\");\n\t\tA:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <mutex>\nusing namespace std;\n\nconst double INF = 1e9;\n\nint n, m, s, g;\n\n// [n][prev][v];\ndouble dp[32][32][32];\n\nstruct edge {\n\tint to, c;\n\tdouble length;\n\n\tedge(int to, int c, double l) :to(to), c(c), length(l){\n\t}\n\t\n};\n\nvector<edge> G[32];\n\nstruct state {\n\tint n, prev, v;\n\tdouble time;\n\n\tstate(int n, int prev, int v, double time) :n(n), prev(prev),v(v), time(time){\n\t}\n\tbool operator > (const state& s) const {\n\t\treturn time > s.time;\n\t}\n};\n\nvoid solve(){\n\tpriority_queue<state, vector<state>, greater<state>> q;\n\tq.push(state(s, -1, 1, 0.0));\n\twhile(!q.empty()) {\n\t\tstate s = q.top();\n\t\tq.pop();\n\t\tif(s.prev != -1 && dp[s.n][s.prev][s.v] < s.time) continue;\n\n\t\tif(s.n == g && s.v == 1) {\n\t\t\tcout << s.time << endl;\n\t\t\treturn;\n\t\t}\n\n\t\tif(s.prev != -1)\n\t\t\tdp[s.n][s.prev][s.v] = s.time;\n\t\tint dv[] = { 0, 1, -1 };\n\t\tfor(int i = 0; i < G[s.n].size(); i++) {\n\t\t\tfor(int j = 0; j < ((s.prev == -1) ? 1 : 3); j++) {\n\t\t\t\tint nv = s.v + dv[j];\n\t\t\t\tif(nv > 0 && nv <= G[s.n][i].c && G[s.n][i].to != s.prev)\n\t\t\t\t\tq.push(state(G[s.n][i].to, s.n, nv, s.time + G[s.n][i].length / nv));\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"unreachable\" << endl;\n}\n\nint main(){\n\twhile(cin >> n >> m , n | m) {\n\t\tcin >> s >> g;\n\n\t\tfor(int i = 0; i < 32; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint x, y, c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tG[x].push_back(edge(y, c, d));\n\t\t\tG[y].push_back(edge(x, c, d));\n\t\t}\n\n\t\tfor(int i = 0; i < 31; i++) {\n\t\t\tfor(int j = 0; j < 31; j++) {\n\t\t\t\tfor(int k = 0; k < 31; k++) {\n\t\t\t\t\tdp[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsolve();\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst double INF = 1e8;\n\nclass Edge{\n    public:\n        int to;\n        double cost,limit;\n        Edge(int to, double cost, double limit) : to(to) ,cost(cost) ,limit(limit) {}\n};\n\nclass Node{\n    public:\n        double dis;\n        bool isUsed;\n        Node(){\n            this->dis = INF;\n            this->isUsed = 0;\n        }\n};\n\ntypedef vector<vector<Edge>> AdjList;\n\ndouble dijkstra(AdjList g, int n,int s, int t){\n    vector<vector<vector<Node>>> node(35,vector<vector<Node>>(35,vector<Node>(35)));\n    //??????????????????????????????????????????\n    typedef pair<pair<double,double>,pair<int,int>> p;\n\n    priority_queue<p, vector<p>, greater<p>> q;\n\n    q.push(make_pair(make_pair(0.0, 0.0), make_pair(s,34)));\n    node[s][0][34].dis = 0.0;\n\n    p u;\n    while(not q.empty()){\n        u = q.top(); q.pop();\n        int current = u.second.first;\n        int prev = u.second.second;\n        double speed = u.first.second;\n        node[current][speed][prev].isUsed = 1;\n\n        rep(i,g[current].size()){\n            int next = g[current][i].to;\n            //if(node[next][speed][current].isUsed) continue;\n            if(next == prev) continue;\n\n            for(double j = -1; j <= 1; j++){\n                int ns = speed + j;\n                if(ns > 0){\n                    if(ns > g[current][i].limit) continue;\n                    if(node[next][ns][current].dis > node[current][static_cast<int>(speed)][prev].dis + g[current][i].cost / static_cast<double>(ns)){\n                        node[next][ns][current].dis = node[current][static_cast<int>(speed)][prev].dis + g[current][i].cost / static_cast<double>(ns);\n                        q.push(make_pair(\n                                    make_pair(node[next][ns][current].dis, ns),\n                                    make_pair(next,current)\n                                    )\n                              );\n                    }\n                }\n            }\n        }\n    }\n///    cout << endl;\n///    rep(i,n){\n///        rep(j,30){\n///            cout << node[i][j].dis << ' ';\n///        }\n///        cout << endl;\n///    show(\"------------\")\n///    }\n    double mini = INF;\n    rep(i,n){\n        mini = min(mini, node[t][1][i].dis);\n    }\n    return mini;\n}\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n||m){\n        int s, t;\n        cin >> s >> t;\n        s--; t--;\n        AdjList g(n);\n        rep(i,m){\n            int a, b;\n            double c, d;\n            cin >> a >> b >> c >> d;\n            a--; b--;\n            g[a].emplace_back(Edge{b,c,d});\n            g[b].emplace_back(Edge{a,c,d});\n        }\n        double tmp = dijkstra(g,n,s,t);\n        if(tmp == INF) cout << \"unreachable\" << endl;\n        else cout <<fixed << setprecision(12) <<  tmp << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<pair<int,int>,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a3,a2,a4;\ndouble d[31][31];\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)if(d[i][j]!=1e12)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      scanf(\"%d%d%d%d\",&a1,&a2,&a3,&a4);\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P>q;\n    d[st][0]=0;\n    P xtt;xtt.fi.fi=0,xtt.fi.se=st,xtt.se=-1;\n    q.push(xtt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.fi.se;\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=p.se)r(j,3){\n          int x=p.fi.fi+dx[j];\n          if(0<x&&x<=e.lim){\n            double t=e.dist/x+d[cur][p.fi.fi];\n            if(d[e.to][x]>t){\n              d[e.to][x]=t;\n              P xt;xt.fi.fi=x,xt.fi.se=e.to,xt.se=cur;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// (x,y)\ntypedef pair<int,int> P;\n// ( 速度 , (前の町,今の町) )\ntypedef pair<int,P> Node;\n// (cost,Node)\ntypedef pair<double,Node> State;\n\nconst int MAX_V = 31;\nconst double INF = 1e200;\n\nstruct edge{\n\tint to, d, c;\n\tedge(int to_, int d_, int c_){\n\t\tto = to_; d = d_; c = c_;\n\t}\n};\n\n// グラフ\nvector<edge> G[MAX_V];\n// スタートからゴールに辿りつけるかどうか\nbool memo[MAX_V];\nbool is_connect;\n\n// 入力\nint n, m;\n\n// 初期化\nvoid init(){\n\tis_connect = false;\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tG[i].clear();\n\t}\n}\n\n// 辺の追加\nvoid add_edge(int x, int y, int d, int c){\n\tedge e( y , d , c );\n\tG[x].push_back( e );\n\te.to = x;\n\tG[y].push_back( e );\n}\n\n// スタートからゴールに辿りつけるかどうかチェック\nvoid check(int v, int g){\n\tif( v == g ){\n\t\tis_connect = true;\n\t}\n\tif( memo[v] ) return;\n\tmemo[v] = true;\n\t\n\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\tint to = G[v][i].to;\n\t\tif( memo[to] ) continue;\n\t\tcheck( to , g );\n\t}\n}\n\n// ダイクストラ法\ndouble solve(int s, int g){\n\t// d[v][x][y] := 速度v, 前の町x, 今の町yまでの最小コスト\n\tdouble d[31][31][31];\n\t// 訪れたかどうか\n\tbool visited[31][31][31];\n\t// 初期化\n\tfor(int y=0 ; y < MAX_V ; y++ ){\n\t\tfor(int x=0 ; x < MAX_V ; x++ ){\n\t\t\tfor(int v=0 ; v < 31 ; v++ ){\n\t\t\t\td[v][y][x] = INF;\n\t\t\t\tvisited[v][y][x] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// State := (cost,Node), Node := ( 速度 , (前の町,今の町) )\n\tpriority_queue< State, vector<State> , greater<State> > q;\n\tfor(int i = 0 ; i < G[s].size() ; i++ ){\n\t\tint to = G[s][i].to;\n\t\tdouble dis = G[s][i].d;\n\t\t\n\t\tNode start( 1 , P(s,to) );\n\t\tq.push( State(dis,start) );\n\t\td[1][s][to] = dis;\n\t}\n\t\n\tdouble ans = INF;\n\tint cnt=0;\n\twhile( !q.empty() ){\n\t\t//cnt++;\n\t\t//if( cnt >= 2000000 ) break;\n\t\t\n\t\t// 値を取り出す\n\t\tdouble now_cost = q.top().first;\n\t\tint v = q.top().second.first;\n\t\tint x = q.top().second.second.first;\n\t\tint y = q.top().second.second.second;\n\t\tq.pop();\n\t\t\n\t\tif( now_cost >= ans || visited[v][x][y] ) continue;\n\t\tvisited[v][x][y] = true;\n\t\t\n\t\t// 目的地のとき\n\t\tif( y == g && v == 1 ){\n\t\t\tans = min( ans , now_cost );\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < G[y].size() ; i++ ){\n\t\t\tint to = G[y][i].to;\n\t\t\tint dis = G[y][i].d;\n\t\t\tint c = G[y][i].c;\n\t\t\tif( to == x ) continue;\n\t\t\t\n\t\t\tfor(int dv = -1 ; dv <= 1 ; dv++ ){\n\t\t\t\tint next_v = v + dv;\n\t\t\t\tif( next_v > c || next_v <= 0 ) continue;\n\t\t\t\t\n\t\t\t\tdouble cost = (double)dis / next_v;\n\t\t\t\tif( now_cost + cost < d[next_v][y][to] ){\n\t\t\t\t\td[next_v][y][to] = now_cost + cost;\n\t\t\t\t\t\n\t\t\t\t\tNode next( next_v , P(y,to) );\n\t\t\t\t\tState p( now_cost + cost , next );\n\t\t\t\t\tq.push( p );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile( scanf(\"%d %d\", &n, &m) , n || m ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\t\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tint x, y, d, c;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &d, &c );\n\t\t\tadd_edge( x , y , d , c );\n\t\t}\n\t\t\n\t\t{\n\t\t\t// スタートからゴールに辿りつけるかどうか\n\t\t\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\t\t\tmemo[i] = false;\n\t\t\t}\n\t\t\tcheck( s , g );\n\t\t}\n\t\t\n\t\t// ゴールに辿りつけないとき\n\t\tif( is_connect == false ){\n\t\t\tputs(\"unreachable\");\n\t\t}else{\n\t\t\tdouble ans = solve( s , g );\n\t\t\tprintf(\"%.4f\\n\", ans );\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ndouble INF = 10000000;\nint main(){\n  cout << fixed << setprecision(3);\n  while (1){\n    int n, m;\n    cin >> n >> m;\n    if (n == 0 && m == 0){\n      break;\n    }\n    int s, g;\n    cin >> s >> g;\n    s--;\n    g--;\n    vector<vector<pair<double, int>>> E(n * n * 30 + 1);\n    for (int i = 0; i < m; i++){\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      x--;\n      y--;\n      for (int j = 1; j <= 30; j++){\n        for (int k = j - 1; k <= j + 1; k++){\n          if (1 <= k && k <= c){\n            for (int l = 0; l < n; l++){\n              if (l != y){\n                E[l * n * 30 + x * 30 + j - 1].push_back(make_pair((double) d / k, x * n * 30 + y * 30 + k - 1));\n              }\n              if (l != x){\n                E[l * n * 30 + y * 30 + j - 1].push_back(make_pair((double) d / k, y * n * 30 + x * 30 + k - 1));\n              }\n            }\n          }\n        }\n      }\n      if (y == s){\n        swap(x, y);\n      }\n      if (x == s){\n        E[n * n * 30].push_back(make_pair((double) d, x * n * 30 + y * 30));\n      }\n    }\n    vector<double> d(n * n * 30 + 1, INF);\n    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> pq;\n    pq.push(make_pair(0, n * n * 30));\n    while (!pq.empty()){\n      double c = pq.top().first;\n      int v = pq.top().second;\n      pq.pop();\n      if (d[v] == INF){\n        d[v] = c;\n        for (auto P : E[v]){\n          int w = P.second;\n          if (d[w] == INF){\n            pq.push(make_pair(c + P.first, w));\n          }\n        }\n      }\n    }\n    double ans = INF;\n    for (int i = 0; i < n; i++){\n      ans = min(ans, d[i * n * 30 + g * 30]);\n    }\n    if (ans == INF){\n      cout << \"unreachable\" << endl;\n    } else {\n      cout << ans << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint n,m,s,g;\nmap<int, vector<TIII> > r;\nmap<TIII, double> v;\n\nint main(){\n\twhile(1){\n\t\tdouble ret = -1.0;\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)return 0;\n\t\tcin>>s>>g;\n\t\tr.clear();\n\t\tv.clear();\n\t\tREP(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tr[x].PB(MT(y,d,c));\n\t\t\tr[y].PB(MT(x,d,c));\n\t\t}\n\t\tpriority_queue<pair<double, TIII > , vector<pair<double, TIII > >, greater<pair<double, TIII > > > q;\n\t\tq.push(MP(0.0,MP(s, MP(-1, 0))));\n\t\twhile(!q.empty()){\n\t\t\tpair<double, TIII > tmp = q.top();\n\t\t\tq.pop();\n\t\t\tif(EXIST(v, tmp.second))continue;\n\t\t\tif(tmp.second.first == g && tmp.second.second.second == 1){\n\t\t\t\tret = tmp.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv[tmp.second]=tmp.first;\n\t\t\tint city = tmp.second.first;\n\t\t\tint speed = tmp.second.second.second;\n\t\t\tint pre = tmp.second.second.first;\n\t\t\tdouble now = tmp.first;\n\t\t\tREP(i, r[city].size()){\n\t\t\t\tFOR(sp, speed-1, speed+2){\n\t\t\t\t\tif(sp<1)continue;\n\t\t\t\t\tTIII f = r[city][i];\n\t\t\t\t\tif(f.second.second >= sp && sp > 0 && f.first != pre)q.push(MP(now+(f.second.first*1.0)/(sp*1.0), MP(f.first, MP(city, sp))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ret < 0.0)cout << \"unreachable\" <<endl;\n\t\telse printf(\"%.6f\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint n,m,s,g;\nmap<int, vector<TIII> > r;\nmap<pair<int, int>, double> v;\n\nint main(){\n\twhile(1){\n\t\tdouble ret = -1.0;\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)return 0;\n\t\tcin>>s>>g;\n\t\tr.clear();\n\t\tv.clear();\n\t\tREP(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tr[x].PB(MT(y,d,c));\n\t\t\tr[y].PB(MT(x,d,c));\n\t\t}\n\t\tpriority_queue<pair<double, pair<int, int> > , vector<pair<double, pair<int, int> > >, greater<pair<double, pair<int, int> > > > q;\n\t\tq.push(MP(0.0,MP(s, 0)));\n\t\twhile(!q.empty()){\n\t\t\tpair<double, pair<int, int> > tmp = q.top();\n\t\t\tq.pop();\n\t\t\tif(EXIST(v, tmp.second))continue;\n\t\t\tif(tmp.second == MP(g, 1)){\n\t\t\t\tret = tmp.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv[tmp.second]=tmp.first;\n\t\t\tint city = tmp.second.first;\n\t\t\tint speed = tmp.second.second;\n\t\t\tdouble now = tmp.first;\n\t\t\tREP(i, r[city].size()){\n\t\t\t\tFOR(sp, speed-1, speed+2){\n\t\t\t\t\tif(sp<1)continue;\n\t\t\t\t\tTIII f = r[city][i];\n\t\t\t\t\tif(f.second.second >= sp && sp > 0)q.push(MP(now+(f.second.first*1.0)/(sp*1.0), MP(f.first, sp)));\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ret < 0.0)cout << \"unreachable\" <<endl;\n\t\telse printf(\"%.6f\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 35\n#define INF 1e9\n#define F first\n#define S second\ntypedef pair<double,int> pdi;\ntypedef pair<int,int> pii;\ntypedef pair<pdi,pii> State;\n \nstruct Edge{\n  int to,d,c;\n  Edge(int to,int d,int c) : to(to),d(d),c(c) {}\n};\n \nint N,M,s,g;\nvector<Edge> G[MAX];\n \ndouble dijkstra(){\n  priority_queue<State,vector<State>,greater<State> > Q;\n  Q.push(State(pdi(0,s),pii(1,1)));\n  double Time[MAX][MAX][MAX];\n \n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      for(int k = 0 ; k < MAX ; k++){\n        Time[i][j][k] = INF;\n      }\n    }\n  }\n   \n  Time[s][1][1] = 0;\n \n  while(!Q.empty()){\n    State p = Q.top(); Q.pop();\n    int v = p.F.S, vel = p.S.F;\n    if(Time[v][vel][p.S.S] < p.F.F) continue;\n \n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      for(int j = -1 ; j <= 1 ; j++){\n        if(vel+j <= 0) continue;\n        if(Time[v][vel][p.S.S] == 0 && j){\n          continue;\n        }\n        Edge e = G[v][i];\n        double t = (double)e.d/(vel+j);\n        if(vel+j <= e.c && \n           Time[v][vel][p.S.S] + t < Time[e.to][vel+j][v]){\n          Time[e.to][vel+j][v] = Time[v][vel][p.S.S] + t;\n          Q.push(State(pdi(Time[e.to][vel+j][v],e.to),pii(vel+j,v)));\n        }\n      }\n    }\n  }\n  double res = INF;\n  for(int i = 0 ; i < MAX ; i++){\n    res = min(res,Time[g][1][i]);\n  }\n  return res;\n}\n \nint main(){\n  int x,y,d,c;\n  while(cin >> N >> M, N){\n    for(int i = 0 ; i < MAX ; i++){\n      G[i].clear();\n    }\n    cin >> s >> g; s--; g--;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> d >> c;\n      x--; y--;\n      G[x].push_back(Edge(y,d,c));\n      G[y].push_back(Edge(x,d,c));\n    }\n    double res = dijkstra();\n    if(res == INF){\n      cout << \"unreachable\" << endl;\n    }else{\n      printf(\"%.8f\\n\",res);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m;\nll s, g;\n\nclass DK {\npublic:\n\tstruct edge {\n\t\tint to;\n\t\tdouble cost;\n\t\tll cap;\n\t\tedge(int _to, double _cost, ll _cap) :to(_to), cost(_cost), cap(_cap) {}\n\t};\n\n\tdouble d[110][110];\n\tvector<edge> G[110];//各頂点からの辺\n\n\tvoid dijkstra() {\n\t\trep(i, 110)rep(j, 110)d[i][j] = INF;\n\t\td[s][0] = 0;\n\n\t\ttypedef pair<pair<double, ll>, ll> PP;\n\t\tpriority_queue<PP, vector<PP>, greater<PP>> que;\n\t\tque.push({ {0, 0},s });\n\n\t\twhile (!que.empty()) {\n\t\t\tPP p = que.top();\n\t\t\tque.pop();\n\t\t\tll nn = p.second;\n\t\t\tll v = p.first.second;\n\t\t\tif (d[nn][v] < p.first.first)continue;\n\t\t\tfor (int i = 0; i < G[nn].size(); i++) {\n\t\t\t\tedge e = G[nn][i];\n\t\t\t\tFOR(j, -1, 2) {\n\t\t\t\t\tdouble nv = v + j;\n\t\t\t\t\tif (nv <= 0)continue;\n\t\t\t\t\tif (nv > e.cap)continue;\n\t\t\t\t\tif (d[e.to][(ll)nv] > d[nn][v] + e.cost / nv) {\n\t\t\t\t\t\td[e.to][(ll)nv] = d[nn][v] + e.cost / nv;\n\t\t\t\t\t\tque.push({ {d[e.to][(ll)nv], nv},e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n};\n\nDK dk;\n\nint main() {\n\twhile (cin >> n >> m&&n + m) {\n\t\trep(i, 110)dk.G[i].clear();\n\t\tcin >> s >> g;\n\t\trep(i, m) {\n\t\t\tint x, y;\n\t\t\tll c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tdk.G[x].push_back(DK::edge(y, d, c));\n\t\t\tdk.G[y].push_back(DK::edge(x, d, c));\n\t\t}\n\t\tdk.dijkstra();\n\t\t//rep(i, n) {\n\t\t//\trep(j, 30) {\n\t\t//\t\tcout << dk.d[i + 1][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tdouble ans = dk.d[g][1];\n\t\tif ((ll)ans == INF)cout << \"unreachable\" << endl;\n\t\telse printf(\"%.10lf\\n\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?(テァツクツョテ・ツーツ湘ァツ可?\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\nconstexpr int T = 40;\n\nint N, M, s, g;\n\n// cur, prev, speed, prevsテ」ツ??、ツクツュティツコツォテ」ツ?ッテヲツ卍づゥツ鳴?\ndouble dist[40][40][T][4];\n\nstruct Edge {\n    int to; double cost; int lim;\n};\n\nstruct Elem {\n    int cur, prev, speed, prevs;\n};\n\nbool operator<(const Elem &a, const Elem &b) {\n    return dist[a.cur][a.speed][a.prevs] > dist[b.cur][b.speed][b.prevs];\n}\n\nint dx[] = {-INF, -1, 0, 1};\n\nsigned main() {\n    while(cin >> N >> M, N || M) {\n        N++;\n        cin >> s >> g;\n        vector< vector<Edge> > G(N);\n        rep(i,0,M) {\n            int x, y; double d; int c; cin >> x >> y >> d >> c;\n            G[x].push_back(Edge{y, d, c});\n            G[y].push_back(Edge{x, d, c});\n        }\n\n        rep(i,0,N) rep(j,0,N) rep(k,0,T) rep(l,0,4) dist[i][j][k][l] = INF;\n        dist[s][0][1][0] = 0.0;\n\n        priority_queue<Elem> q;\n        q.push(Elem{s, 0, 1, 0});\n\n        double ans = INF;\n        while(!q.empty()) {\n            Elem t = q.top(); q.pop();\n            rep(i,1,4) {\n                int sp = t.speed + dx[i];\n                if(sp == 0) continue;\n                for(auto x : G[t.cur]) {\n                    if(x.lim < t.speed || x.to == t.prev) continue;\n                    double c = x.cost / t.speed;\n                    // printf(\"cost: %.12f\\n\", c);\n                    // cur, prev, speed, prevs\n                    if(dist[x.to][t.cur][sp][i] > dist[t.cur][t.prev][t.speed][t.prevs] + c) {\n                        // printf(\"debug: dist[%lld][%lld][%lld][%lld] = %.12f\\n\", x.to, t.cur, sp, i, dist[x.to][t.cur][sp][i]);\n                        dist[x.to][t.cur][sp][i] = dist[t.cur][t.prev][t.speed][t.prevs] + c;\n                        if(x.to == g && t.speed == 1) {\n                            chmin(ans, dist[x.to][t.cur][sp][i]);\n                        }\n                        q.push(Elem{x.to, t.cur, sp, i});\n                    }\n                }\n            }\n        }\n        if(ans == INF) cout << \"unreachable\" << endl;\n        else printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> edge;\ntypedef pair<int, P> PP;\ntypedef pair<double, PP> PPP;\n\nvector<edge> G[100];\ndouble memo[40][40][40];\n\nint main(){\n  int n, m;\n  int s, g;\n  while(cin >> n >> m && (n || m)){\n    cin >> s >> g;\n    fill(&memo[0][0][0], &memo[39][39][39]+1, 1e10);\n    for(int i = 0; i < m; i++){\n      int x1,y1,d,c;\n      cin >> x1 >> y1 >> d >> c;\n      G[x1].push_back(edge(y1, P(d, c)));\n      G[y1].push_back(edge(x1, P(d, c)));\n    }\n    memo[s][0][31] = 0;\n    priority_queue<PPP, vector<PPP>,greater<PPP> > que;\n    que.push(PPP(memo[s][0][31], PP(0, P(s, 31))));\n    bool ok = false;\n    while(!que.empty()){\n      PPP ppp = que.top();\n      que.pop();\n      double dis = ppp.first;\n      int v = ppp.second.first;\n      int pos = ppp.second.second.first;\n      int pre = ppp.second.second.second;\n      if(dis > memo[pos][v][pre]) continue;\n     \n      if(pos == g && v == 1){\n\tcout << dis << endl;\n\tok = true;\n\tbreak;\n      }\n      for(int i = -1; i <= 1; i++){\n\tint v2 = v + i;\n\tfor(int j= 0; j < (int)G[pos].size(); j++){\n\t  int to = G[pos][j].first;\n\t  int li = G[pos][j].second.second;\n\t  int d = G[pos][j].second.first;\n\n\t  if(1 <= v2 && v2 <= li && to != pre){\n\t    if(memo[to][v2][pos] > dis + (double)d / v2){\n\t      memo[to][v2][pos] = dis + (double)d / v2;\n\t      que.push(PPP(memo[to][v2][pos], PP(v2, P(to, pos))));\n\t    }\n\t  }\n\t}\n      }\n\n    }\n    if(!ok){\n      cout << \"unreachable\" << endl;\n    }\n    for(int i = 1; i <= 30; i++) G[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m;\nll s, g;\n\nclass DK {\npublic:\n\tstruct edge {\n\t\tint to;\n\t\tdouble cost;\n\t\tll cap;\n\t\tedge(int _to, double _cost, ll _cap) :to(_to), cost(_cost), cap(_cap) {}\n\t};\n\n\tdouble d[110][110];\n\tvector<edge> G[110];//各頂点からの辺\n\n\tvoid dijkstra() {\n\t\trep(i, 110)rep(j, 110)d[i][j] = INF;\n\t\td[s][0] = 0;\n\n\t\ttypedef pair<pair<double, ll>, ll> PP;\n\t\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\t\tque.push({ {0, 0},s });\n\n\t\twhile (!que.empty()) {\n\t\t\tPP p = que.top();\n\t\t\tque.pop();\n\t\t\tll nn = p.second;\n\t\t\tll v = p.first.second;\n\t\t\tif (d[nn][v] < p.first.first)continue;\n\t\t\tfor (int i = 0; i < G[nn].size(); i++) {\n\t\t\t\tedge e = G[nn][i];\n\t\t\t\tFOR(j, -1, 2) {\n\t\t\t\t\tdouble nv = v + j;\n\t\t\t\t\tif (nv <= 0)continue;\n\t\t\t\t\tif (nv > e.cap)continue;\n\t\t\t\t\tif (d[e.to][(ll)nv] > d[nn][v] + e.cost / nv) {\n\t\t\t\t\t\td[e.to][(ll)nv] = d[nn][v] + e.cost / nv;\n\t\t\t\t\t\tque.push({ {d[e.to][(ll)nv], nv},e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n};\n\nDK dk;\n\nint main() {\n\twhile (cin >> n >> m&&n + m) {\n\t\trep(i, 110)dk.G[i].clear();\n\t\tcin >> s >> g;\n\t\trep(i, m) {\n\t\t\tint x, y;\n\t\t\tll c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tdk.G[x].push_back(DK::edge(y, d, c));\n\t\t\tdk.G[y].push_back(DK::edge(x, d, c));\n\t\t}\n\t\tdk.dijkstra();\n\t\t//rep(i, n) {\n\t\t//\trep(j, 30) {\n\t\t//\t\tcout << dk.d[i + 1][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tdouble ans = dk.d[g][1];\n\t\tif ((ll)ans == INF)cout << \"unreachable\" << endl;\n\t\telse printf(\"%.10lf\\n\", ans);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\ntypedef tuple<double, int, int, int> T;\nint n,m;\ndouble best[30][30][31];\nint dist[30][30];\nint limit[30][30];\nvoid exec()\n{\n\tcin >> n >> m;\n\tif(n==0&&m==0){\n\t\texit(0);\n\t}\n\tmemset(dist,-1,sizeof(dist));\n\tmemset(limit,-1,sizeof(limit));\n\tint start,goal;\n\tcin >> start >> goal;\n\tstart--;\n\tgoal--;\n\tfor(int i=0;i<m;i++){\n\t\tint x,y,d,c;\n\t\tcin >> x >> y >> d >> c;\n\t\tx--;\n\t\ty--;\n\t\tdist[x][y]=dist[y][x]=d;\n\t\tlimit[x][y]=limit[y][x]=c;\n\t}\n\tfill(best[0][0],best[0][0]+30*30*31,1e20);\n\tpriority_queue<T, vector<T>, greater<T> > q;\n\tq.push(T(0,start,start,0));\n\tbest[start][start][0]=0;\n\twhile(q.size())\n\t{\n\t\tdouble t=get<0>(q.top());\n\t\tint f=get<1>(q.top());\n\t\tint p=get<2>(q.top());\n\t\tint s=get<3>(q.top());\n\t\tq.pop();\n\t\tif(t>best[start][start][s])continue;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i==p)continue;\n\t\t\tfor(int ss=max(s-1,1);ss<=min(s+1,limit[f][i]);ss++){\n\t\t\t\tassert(dist[f][i]>0);\n\t\t\t\tdouble tt=t+dist[f][i]/(double)ss;\n\t\t\t\tif(tt<best[i][f][ss]){\n\t\t\t\t\tbest[i][f][ss]=tt;\n\t\t\t\t\tq.push(T(tt,i,f,ss));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble ret=1e20;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tret=min(ret,best[goal][i][1]);\n\t}\n\tif(ret==1e20){\n\t\tcout << \"unreachable\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << ret << endl;\n\t}\n}\n\nint main() {\n\tcout << setprecision(10);\n\twhile(1)exec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n#define N 30\n#define INF 100000\nstruct road{int to,cost,lim;};\n\nstruct situ{int v,now,from;double d;};\nbool operator < (const situ &a,const situ &b){\n\treturn a.d > b.d;\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,s,g;\n\t\tvector<road> roads[N];\n\t\tcin >> n >> m;\n\t\tif(!n&&!m) break;\n\t\tcin >> s >> g;\n\t\ts--;g--;\n\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,c;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c);\n\t\t\tx--;y--;\n\t\t\troads[x].push_back((road){y,d,c});\n\t\t\troads[y].push_back((road){x,d,c});\n\t\t}\n\t\n\t\tpriority_queue<situ> que;\n\t\tfor(int i=0;i<roads[s].size();i++){\n\t\t\tint to = roads[s][i].to;\n\t\t\tint d = roads[s][i].cost;\n\t\t\tque.push((situ){1,to,s,(double)d});\n\t\t}\n\t\tdouble dist[N][N][31];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=1;k<31;k++){\n\t\t\t\t\tdist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(que.size()){\n\t\t\tsitu st = que.top(); que.pop();\n\t\t\tif(dist[st.now][st.from][st.v]<st.d) continue;\n\t\t\tdist[st.now][st.from][st.v] = st.d;\n\t\t\tfor(int i=0;i<roads[st.now].size();i++){\n\t\t\t\tint to = roads[st.now][i].to;\n\t\t\t\tint d = roads[st.now][i].cost;\n\t\t\t\tif(to != st.from){\n\t\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\tif(st.v+j<=roads[st.now][i].lim&&st.v+j>0){\n\t\t\t\t\t\t\tif(dist[to][st.now][st.v+j]>st.d+(double)d/(st.v+j)){\n\t\t\t\t\t\t\t\tque.push((situ){st.v+j,to,st.now,st.d+(double)d/(st.v+j)});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = INF;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tans = min(ans,dist[g][i][1]);\n\t\t}\n\t\tif(ans==INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t\tprintf(\"%.5f\\n\",ans);\n\t\t}\n\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\n\nclass Dijkstra {\n    using T = double;\npublic:\n    struct edge {\n        int to;\n        T cost;\n    };\n    typedef pair<T, int> P;//firstは最短距離、secondは頂点の番号\n\n    int V;//超点数\n    vector<vector<edge> > G;//グラフ,G[i]はiから出る辺の集合,G[i][j]はiから出る辺のj番目の辺\n    vector<T> d; //最短距離\n\n    //0origin\n    Dijkstra(int N) {\n        V = N;\n        G = vector<vector<edge> >(N);\n        d = vector<T>(N);\n    };\n\n    void dijkstra(int s) {\n        priority_queue<P, vector<P>, greater<P> > que;\n        fill(d.begin(), d.end(), INFl);\n        d[s] = 0;\n        que.push(P(0, s));\n\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if (d[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge e = G[v][i];\n                if (d[e.to] > d[v] + e.cost && !(d[e.to] == INFl && d[v] == INFl)) {\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n\n    }\n\n    /* 頂点fromに頂点toに達するコストcostの辺を貼る */\n    void addEdge(int from, int to, T cost) {\n        edge e;\n        e.to = to;\n        e.cost = cost;\n        G[from].push_back(e);\n    }\n};\n\nvoid solve(int n, int m) {\n    int s, g;\n    cin >> s >> g;\n    s--;\n    g--;\n\n    auto conv = [&](int f, int t, int v) {\n        //(頂点、速度)\n        return v * n * n + f * n + t;\n    };\n\n    Dijkstra dij(200 * n * n + n * n + n);\n\n    rep(i, 0, m) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        x--;\n        y--;\n        auto check = [&](int v) {\n            return v > 0 && v <= c;\n        };\n        rep(v, 0, 31) {\n            for (int V = v - 1; V <= v + 1; V++) {\n//                if(check(V)){\n//                    double tmp = 1.0 * d / V;\n//                    dij.addEdge(conv(x,v),conv(y,V),tmp);\n//                    dij.addEdge(conv(y,v),conv(x,V),tmp);\n//                }\n                for (int f = 0; f < n; f++) {\n                    if (check(V)) {\n                        double tmp = 1.0 * d / V;\n                        if (f != y) {\n                            dij.addEdge(conv(f, x, v), conv(x, y, V), tmp);\n                        }\n                        if (f != x) {\n                            dij.addEdge(conv(f, y, v), conv(y, x, V), tmp);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    dij.dijkstra(conv(s, s, 0));\n//    cout << dij.d[conv(g,1)] << endl;\n    double ans = INFl;\n    rep(i, 0, n) {\n        ans = min(ans, dij.d[conv(i, g, 1)]);\n    }\n    if (ans > 1e7) {\n        cout << \"unreachable\" << endl;\n    } else {\n        cout << ans << endl;\n//        printf(\"%.12lf\", ans);\n//        cout << endl;\n    }\n\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nint n,m;\nint st,gl;\ndouble dp[35][35];\n\nint ds[35][35];\nint rs[35][35];\n\ntypedef pair<double,mp> dmp;\n\nint main(void){\n\tfor(;;){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0)break;\n\t\tscanf(\"%d%d\",&st,&gl);\n\t\tmemst(ds,-1);\n\t\tmemst(rs,-1);\n\t\trep(i,m){\n\t\t\tint a,b,c,d;\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\tds[a][b]=ds[b][a]=c; \n\t\t\trs[a][b]=rs[b][a]=d; \n\t\t}\n\t\t\n\t\trep(i,35)rep(j,35)dp[i][j]=1e10;\n\t\t\n\t\tpque(dmp) que;\n\t\tque.push(dmp(0,mp(st,0)));\n\t\tdouble ans=-1;\n\t\twhile(!que.empty()){\n\t\t\tdmp pa=que.top();\n\t\t\tque.pop();\n\t\t\tdouble t=pa.fir;\n\t\t\tint no=pa.sec.fir,\n\t\t\t\tnv=pa.sec.sec;\n\t\t\tif(dp[no][nv]<=t)continue;\n\t\t\tdp[no][nv]=t;\n\t\t\tif(no==gl && nv==1){\n\t\t\t\tans=t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treg(tv,max(nv-1,1),nv+1){\n\t\t\t\trep(to,35){\n\t\t\t\t\tif(ds[no][to]<0)continue;\n\t\t\t\t\tif(rs[no][to]<tv)continue;\n\t\t\t\t\tdouble tt=t+ds[no][to]/((double)tv);\n\t\t\t\t\tif(dp[to][tv]<=tt)continue;\n\t\t\t\t\tque.push(dmp(tt,mp(to,tv)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans<0)printf(\"unreachable\\n\");\n\t\telse printf(\"%.8f\\n\",ans);\n\t}\n\t\t\n\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<pair<int,int>,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a2,a4;\ndouble d[31][31],a3;\nint dx[]={-1,0,1};\nedge e;\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      scanf(\"%d%d%lf%d\",&a1,&a2,&a3,&a4);\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P>q;\n    d[st][0]=0;\n    P xt;xt.fi.fi=0,xt.fi.se=st,xt.se=-1;\n    q.push(xt);\n    while(!q.empty()){\n      P p=q.front();q.pop();\n      int cur=p.fi.se;\n      r(i,v[cur].size()){\n        e=v[cur][i];\n        if(e.to!=p.se)r(j,3){\n          int x=p.fi.fi+dx[j];\n          if(0<x&&x<=e.lim){\n            double t=e.dist/x+d[cur][p.fi.fi];\n            if(d[e.to][x]>t){\n              d[e.to][x]=t;\n              xt.fi.fi=x,xt.fi.se=e.to,xt.se=cur;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 50\n#define INF 1e9\n#define F first\n#define S second\ntypedef pair<double,int> pdi;\ntypedef pair<int,int> pii;\ntypedef pair<pdi,pii> State;\n\nstruct Edge{\n  int to,d,c;\n  Edge(int to,int d,int c) : to(to),d(d),c(c) {}\n};\n\nint N,M,s,g;\nvector<Edge> G[MAX];\n\ndouble dijkstra(){\n  priority_queue<State,vector<State>,greater<State> > Q;\n  Q.push(State(pdi(0,s),pii(1,1)));\n  double Time[MAX][MAX][MAX];\n\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      for(int k = 0 ; k < MAX ; k++){\n        Time[i][j][k] = INF;\n      }\n    }\n  }\n  \n  Time[s][1][1] = 0;\n\n  while(!Q.empty()){\n    State p = Q.top(); Q.pop();\n    int v = p.F.S, vel = p.S.F;\n    if(Time[v][vel][p.S.S] < p.F.F) continue;\n\n    if(v == g && vel == 1){\n      return Time[g][1][p.S.S];\n    }\n\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      for(int j = -1 ; j <= 1 ; j++){\n        if(vel+j <= 0) continue;\n        if(Time[v][vel][p.S.S] == 0 && j){\n          continue;\n        }\n        Edge e = G[v][i];\n        double t = (double)e.d/(vel+j);\n        if(vel+j <= e.c && \n           Time[v][vel][p.S.S] + t < Time[e.to][vel+j][v]){\n          Time[e.to][vel+j][v] = Time[v][vel][p.S.S] + t;\n          Q.push(State(pdi(Time[e.to][vel+j][v],e.to),pii(vel+j,v)));\n        }\n      }\n    }\n  }\n  return INF;\n}\n\nint main(){\n  int x,y,d,c;\n  while(cin >> N >> M, N){\n    for(int i = 0 ; i < MAX ; i++){\n      G[i].clear();\n    }\n    cin >> s >> g; s--; g--;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> d >> c;\n      x--; y--;\n      G[x].push_back(Edge(y,d,c));\n      G[y].push_back(Edge(x,d,c));\n    }\n    double res = dijkstra();\n    if(res == INF){\n      cout << \"unreachable\" << endl;\n    }else{\n      printf(\"%.8f\\n\",res);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n/** Problem1162 : Discrete Speed **/\nconst int MAX_V = 30, MAX_C = 31;\nint N, M;\ndouble d[MAX_V][MAX_C][MAX_V];\n\nstruct Node {\n\tint c, v, prev; double time;\n\tNode (double _t, int _v, int _c, int _p) : v(_v), c(_c), time(_t), prev(_p){}\n\tbool operator<(const Node &n)const{return time>n.time;}\n};\n\nstruct Edge {\n\tint to, cost, lim;\n\tEdge(int t, int c, int l) :  to(t), cost(c), lim(l){}\n};\nvector<Edge> G[MAX_V];\n\nint tmp[] = {-1, 0, 1};\n\nvoid dijkstra(int s)\n{\n\tpriority_queue<Node> Q;\n\t\n\tfill(d[0][0], d[0][0]+MAX_V*MAX_V*MAX_C, INF);\n\td[s][0][s] = 0;\n\tQ.push(Node(0, s, 0, s));\n\t\n\twhile (Q.size()) {\n\t\tNode n = Q.top(); Q.pop();\n\t\tint v = n.v, c = n.c;\n\t\t//cerr << \"(\" << v+1 << \", \" << c << \", \" << n.time << \")\" << endl;\n\t\t\n\t\tif (d[v][c][n.prev] < n.time) continue;\n\t\t\n\t\tfor (int i=0; i<G[v].size(); i++) {\n\t\t\tEdge e = G[v][i];\n\t\t\t\n\t\t\tfor (int j=0; j<3; j++) {\n\t\t\t\tint nc = c+tmp[j];\n\t\t\t\tif (nc>G[v][i].lim || e.to == n.prev) continue;\n\n\t\t\t\tif (0<nc && nc<=30) {\n\t\t\t\t\tif (d[e.to][nc][v] > n.time + (double)e.cost/nc) {\n\t\t\t\t\t\td[e.to][nc][v] = n.time + (double)e.cost/nc;\n\t\t\t\t\t\tQ.push(Node(d[e.to][nc][v], e.to, nc, v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (cin>>N>>M, N||M) {\n\t\trep(i, MAX_V) G[i].clear();\n\t\tint s, g; cin>>s>>g; s--, g--;\n\t\t\n\t\trep(i, M) {\n\t\t\tint x, y, d, c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tG[x-1].push_back(Edge(y-1, d, c));\n\t\t\tG[y-1].push_back(Edge(x-1, d, c));\n\t\t}\n\t\t\n\t\tdijkstra(s);\n\t\t\n\t\tdouble ans = INF;\n\t\tfor (int i=0; i<MAX_V; i++) {\n\t\t\t\tans = min(ans, d[g][1][i]);\n\t\t}\n\t\t\n\t\tif (ans < INF) {\n\t\t\tcout << fixed << setprecision(10);\n\t\t\tcout << ans << endl;\n\t\t} else {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\n// グラフ用ヘッダ\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    int limit;\n    Edge(int src, int dst, Weight weight, int limit) :\n        src(src), dst(dst), weight(weight), limit(limit) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n#include <queue>\n\n// d,spped,v,from\ntypedef tuple<double,int,int,int> State;\n\nconst double inf = 1e100;\n\n// speed,v,from\ndouble dp[32][32][32];\nGraph g;\nint src,dst;\n\nstring solve(){\n    priority_queue<State> q;\n    q.emplace(0.0,0,src,31);\n    rep(i,32)rep(j,32)rep(k,32) dp[i][j][k] = inf;\n    dp[0][src][31] = 0;\n    while(q.size()){\n        double d; int speed, v, from;\n        tie(d,speed,v,from) = q.top(); q.pop();\n        d = -d;\n        if(v==dst && speed==1){\n            char buf[100];\n            sprintf(buf,\"%.12lf\",d);\n            return buf;\n        }\n        if(d > dp[speed][v][from]) continue;\n        for(Edge & e : g[v]){\n            for(int diff : {-1,0,1}){\n                int ns = speed + diff;\n                double nd = d + (double)e.weight / ns;\n                int nv = e.dst;\n                if(ns < 1 || e.limit < ns) continue;\n                if(nv == from) continue;\n                if(dp[ns][nv][v] > nd){\n                    dp[ns][nv][v] = nd;\n                    q.emplace(-nd,ns,nv,v);\n                }\n            }\n        }\n    }\n    return \"unreachable\";\n}\n\nint main(){\n    int n,m;\n    int cnt = 1;\n    while(cin>>n>>m && n){\n        dump(cnt,n,m);\n        cnt++;\n        cin>>src>>dst;\n        g.assign(n+1,{});\n        rep(i,m){\n            int x,y,d,c; cin>>x>>y>>d>>c;\n            g[x].eb(x,y,d,c);\n            g[y].eb(y,x,d,c);\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n    return false;\n}\nstruct Edge {\n    int to,d,c;\n    Edge(int to=0,int d=0,int c=0) :\n        to(to),d(d),c(c) {}\n};\n\nstruct State {\n    int v,u;\n    int spd;\n    double t;\n    State(int v=0,int u=0,int spd=0,double t=0) :\n        v(v),u(u),spd(spd),t(t){}\n\n    bool operator<(const State &rhs) const {\n        return t>rhs.t;\n    }\n};\nint s,g;\nint n,m;\nvector<Edge> G[40];\n\ndouble dijk() {\n    // v,u,spd;\n    double d[40][40][40];\n    rep(i,40) rep(j,40) rep(k,40) d[i][j][k]=INF;\n    rep(i,40) d[s][i][0]=0;\n    //d[s][s][0]=0;\n\n    priority_queue<State> que;\n    que.push(State(s,s,0));\n    while(que.size()) {\n        State s=que.top(); que.pop();\n\n        rep(i,G[s.v].size()) {\n            Edge e=G[s.v][i];\n            if(e.to==s.v) continue;\n            for(int k=-1;k<=1;k++) {\n                if(!(0<=s.spd+k&&s.spd+k<=e.c)) continue;\n                if(s.spd+k==0) continue;\n                if(chmin(d[e.to][s.v][s.spd+k],d[s.v][s.u][s.spd]+1.0*e.d/(s.spd+k))) {\n                    que.push(State(e.to,s.v,s.spd+k,d[e.to][s.v][s.spd+k]));\n                }\n            }\n        }\n    }\n    double ret=INF;\n    rep(i,40) chmin(ret,d[g][i][1]);\n\n    return ret;\n\n}\n\nvoid solve() {\n    rep(i,40) G[i].clear();\n    cin>>s>>g;\n    s--,g--;\n    rep(i,m) {\n        int x,y,d,c;\n        cin>>x>>y>>d>>c;\n        x--,y--;\n        G[x].push_back(Edge(y,d,c));\n        G[y].push_back(Edge(x,d,c));\n    }\n    double ans=dijk();\n    if(ans==INF) cout<<\"unreachable\"<<endl;\n    else printf(\"%.10f\\n\",ans);\n}\n\nint main() {\n    while(cin>>n>>m) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing msi = map<string, int>;\nusing mii = map<int, int>;\nusing psi = pair<string, int>;\nusing pii = pair<int, int>;\nusing vlai = valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF (ll)1E9\n#define EPS 1E-9\n#define MOD 1000000007\n#define PI 3.1415926535897932384\n\ntemplate <class T>ostream &operator<<(std::ostream &o, const vector<T> &v)\n{\n\trep(i, v.size()) {\n\t\to << (i > 0 ? \" \" : \"\") << v[i];\n\t}\n\treturn o;\n}\n\n//int dx[]={1,1,1,0,-1,-1,-1,0},dy[8]={1,0,-1,-1,-1,0,1,1,1};\n\n//constexpr ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\n\n#define P pair<int,int>\n//struct edge { int to, cost; };\nusing edge = tuple<int, int, int>;\nusing obj = tuple<int, double, int, int>;\n\nclass CompareDist\n{\npublic:\n\tbool operator()(obj n1, obj n2) {\n\t\treturn get<1>(n1) > get<1>(n2);\n\t}\n};\n\nvoid solve(int n, int m) {\n\n\tvector<vector<edge>> G(n);\n\tint s, g ;\n\tcin >> s >> g; s--;g--;\n\tvi x(m), y(m), dd(m), c(m);\n\trep(i, m) {\n\t\tcin >> x[i] >> y[i] >> dd[i] >> c[i];\n\t\tx[i]--; y[i]--;\n\t}\n\trep(i, m) {\n\t\tedge ed = make_tuple(y[i], dd[i], c[i]);\n\t\tG[x[i]].push_back(ed);\n\t\ted = make_tuple(x[i], dd[i], c[i]);\n\t\tG[y[i]].push_back(ed);\n\t}\n\n\tpriority_queue<obj, vector<obj>, CompareDist> q;\n\t//fill(d,d+V,INT_MAX);\n\tvector<vector<vector<double>>> d(n, vector<vector<double>>(30,vector<double>(31,INF)));\n\trep(i, n) {\n\t\td[s][i][0] = 0;\n\t}\n\tobj o = make_tuple(s, 0, -1, 0);\n\tq.push(o);\n\n\twhile (!q.empty()) {\n\t\tobj p = q.top(); q.pop();\n\t\tint node = get<0>(p);\n\t\tdouble time = get<1>(p);\n\t\tint prev = get<2>(p);\n\t\tint velo = get<3>(p);\n\n\t\t//if (ans < time)continue;\n\n\t\tfor (int i = 0; i<G[node].size(); i++) {\n\t\t\tedge e = G[node][i];\n\t\t\tint to = get<0>(e);\n\t\t\tint cos = get<1>(e);\n\t\t\tint lim = get<2>(e);\n\t\t\tif (get<0>(e) == prev)continue;\n\t\t\trange(j, -1, 2) {\n\t\t\t\tint newvel = velo + j;\n\t\t\t\tif (newvel < 1 || newvel>lim)continue;\n\t\t\t\tdouble dt = cos / (double)newvel;\n\n\t\t\t\tif (time + dt < d[to][node][newvel]){//////d[to]>d[node] + dt) {\n\t\t\t\t\t//cout <<node<<\" \"<<to << \" \" << time << \" \"<<time + dt << \" \" << newvel << \" \" << endl;\n\t\t\t\t\td[to][node][newvel] = time + dt;\n\t\t\t\t\tobj o = make_tuple(to, time + dt, node, newvel);\n\t\t\t\t\tq.push(o);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans = INF;\n\trep(i, n) {\n\t\t//cout << d[g][i][1] << endl;\n\t\t//ans = min(d[g][i][1],ans);\n\t\tif (ans > d[g][i][1])ans = d[g][i][1];\n\t}\n\tif (ans != INF)printf(\"%.7lf\\n\", ans);\n\telse cout << \"unreachable\" << endl;\n}\n\nint main(void) {\n\tint n, m;\n\twhile (cin >> n >> m, n) {\n\t\tsolve(n, m);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n\n//((time, pre_node), (power, node))\ntypedef pair<pair<double, int>, pii> State;\n\nint main(void){\n    for(int n, m; cin >> n >> m, n;){\n        int s, z; cin >> s >> z;\n        s--, z--;\n\n        // (to, (length, limited_power))\n        vector<vector<pair<int, pii>>> edge(n);\n        rep(i, m){\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--, y--;\n\n            edge[x].pb(mp(y, mp(d, c)));\n            edge[y].pb(mp(x, mp(d, c)));\n        }\n\n        priority_queue<State, vector<State>, greater<State>> q;\n        for(auto e : edge[s]){\n            q.push(mp(mp((double)e.S.F, s), mp(1, e.F)));\n        }\n\n        // [pre_node][power][node]\n        vector<vector<vector<double>>> minDist(n, vector<vector<double>>(31, vector<double>(n, (double)inf)));\n        while(!q.empty()){\n            double cur_time = q.top().F.F;\n            int cur_prev = q.top().F.S;\n            int cur_power = q.top().S.F;\n            int cur_v = q.top().S.S;\n            q.pop();\n\n            if(minDist[cur_prev][cur_power][cur_v] < (double)inf - eps) continue;\n\n            minDist[cur_prev][cur_power][cur_v] = cur_time;\n\n            int next_prev = cur_v;\n\n            range(next_power, max(1, cur_power - 1), cur_power + 2){\n                for(auto e : edge[cur_v]){\n                    int next_v = e.F;\n                    if(next_v == cur_prev || e.S.S < next_power || minDist[next_prev][next_power][next_v] < (double)inf - eps){\n                        continue;\n                    }\n                    double next_time = cur_time + (double)e.S.F / next_power;\n                    debug(e.S.F);\n                    debug(next_power);\n\n                    q.push(mp(mp(next_time, next_prev), mp(next_power, next_v)));\n                }\n            }\n        }\n\n        double res = (double)inf;\n        rep(i, n){\n            res = min(res, minDist[i][1][z]);\n        }\n\n        if(res >= (double)inf - eps) cout << \"unreachable\" << endl;\n        else                         printf(\"%.5f\\n\", res);\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\nconst double inf = (double)(1<<24);\n\nclass Node {\npublic:\n    double time;\n    int v, town, prev;\n    Node() {}\n    Node( double time_, int v_, int town_, int prev_ ) \n    {\n        time = time_;\n        v = v_;\n        town = town_;\n        prev = prev_;\n    }\n    bool operator > ( const Node& right ) const \n    {\n        return fabs( time - right.time ) < eps ? v > right.v : time < right.time;\n    }\n    bool operator < ( const Node& right ) const\n    {\n        return fabs( time - right.time ) < eps ? v < right.v : time > right.time;\n    }\n};\ntypedef priority_queue <Node> QUEUE;\nconst int size = 31;\n\nint n, m;\n\n\nbool P[size][size];\ndouble G[size][size];\ndouble MC[size][size];\nint L[size][size];\nint CN[size][size];\nint CN_count[size];\n\nvoid solve( int start, int goal )\n{\n    QUEUE Q;\n    Node start_node( 0.0, 1, start, -1 );\n    Q.push( start_node );\n    MC[1][start] = 0.0;\n\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        double time = node.time;\n        int v = node.v;\n        int town = node.town;\n        int prev = node.prev;\n\n        if ( town == goal && v == 1 ) {\n            printf( \"%.5f\\n\", time );\n            return;\n        }\n\n        for ( int i = 0; i < CN_count[town]; i++ ) {\n            int next_town = CN[town][i];\n            if ( next_town == prev ) continue;\n            for ( int j = 1; j >= -1; j-- ) {\n                if ( prev == -1 && j != 0 ) continue;\n                int next_v = v + j;\n                if ( next_v <= 0 || next_v > L[town][next_town] ) continue;\n                double cost = (double)G[town][next_town] / next_v;\n                double next_time = time + cost;\n                int next_prev = town;\n\n                if ( next_time > MC[next_v][next_town] || fabs( next_time - MC[next_v][next_town] ) < eps ) continue;\n                MC[next_v][next_town] = next_time;\n                Node next_node( next_time, next_v, next_town, next_prev );\n                Q.push( next_node );\n            }\n        }\n    }\n\n    cout << \"unreachable\" << endl;\n}\n\nint main( void )\n{\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        // init\n        for ( int i = 0; i < size; i++ ) {\n            CN_count[i] = 0;\n            for ( int j = 0; j < size; j++ ) {\n                P[i][j] = false;\n                MC[i][j] = inf;\n            }\n        }\n\n        // input\n        int s, g;\n        cin >> s >> g;\n        for ( int i = 0; i < m; i++ ) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n\n            P[x][y] = P[y][x] = true;\n            G[x][y] = G[y][x] = d;\n            L[x][y] = L[y][x] = c;\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( i == j ) continue;\n                if ( P[i][j] ) CN[i][CN_count[i]++] = j;\n            }\n        }\n\n        solve( s-1, g-1 );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nstruct Edge\n{\n\tint to, dist, c;\t\n};\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m && n) {\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\ts--, g--;\n\t\tvi x(m), y(m), d(m), c(m);\n\t\trep(i, m) {\n\t\t\tcin >> x[i] >> y[i] >> d[i] >> c[i];\n\t\t\tx[i]--, y[i]--;\n\t\t}\n\t\tdouble time[35][35][35]; //time[to][from][speed]\n\t\trep(i, 35) rep(j, 35) rep(k, 35) time[i][j][k] = 1e18;\n\t\tvector<vector<Edge>> es(n);\n\t\trep(i, m) {\n\t\t\tes[x[i]].pb({y[i], d[i], c[i]});\n\t\t\tes[y[i]].pb({x[i], d[i], c[i]});\n\t\t}\n\t\tauto dijkstra = [&] {\n\t\t\ttypedef pair<pair<double,int>, pair<int, int>> P;//time, speed, from, to\n\t\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\t\ttime[s][34][0] = 0.0;\n\t\t\tq.push({{0.0, 0}, {34, s}});\n\t\t\tP p;\n\t\t\twhile(!q.empty()) {\n\t\t\t\tp = q.top();\tq.pop();\n\t\t\t\tdouble tmp = p.fi.fi;\n\t\t\t\tint from = p.se.fi, now = p.se.se, v = p.fi.se;\n\t\t\t\t//cout << from << \" \" << now << \" \" << v << \" \" << tmp << endl;\n\t\t\t\tif(time[now][from][v] < tmp) continue;\n\t\t\t\tfor(auto& e : es[now]) {\n\t\t\t\t\tif(e.to == from) continue;\n\t\t\t\t\tint to = e.to, dist = e.dist, c = e.c;\n\t\t\t\t\tif(v > 1 && v-1 <= c) { \n\t\t\t\t\t\tdouble nt = tmp + (double)dist / (v-1.0);\n\t\t\t\t\t\tif(nt +EPS< time[to][now][v-1]) {\n\t\t\t\t\t\t\ttime[to][now][v-1] = nt;\n\t\t\t\t\t\t\tq.push({{nt, v-1}, {now, to}});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(v != 0 && v <= c) {\n\t\t\t\t\t\tdouble nt = tmp + (double)dist / v;\n\t\t\t\t\t\tif(nt +EPS < time[to][now][v]) {\n\t\t\t\t\t\t\ttime[to][now][v] = nt;\n\t\t\t\t\t\t\tq.push({{nt, v}, {now, to}});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(v +1 <= c) {\n\t\t\t\t\t\tdouble nt = tmp + (double)dist / (v+1.0);\n\t\t\t\t\t\tif(nt +EPS< time[to][now][v+1]) {\n\t\t\t\t\t\t\ttime[to][now][v+1] = nt;\n\t\t\t\t\t\t\tq.push({{nt, v+1}, {now, to}});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdijkstra();\n\t\tdouble ans = 1e18;\n\t\tfor(int i = 0; i < n; i++) ans = min(ans, time[g][i][1]);\n\t\tif(ans == 1e18) cout << \"unreachable\" << endl;\n\t\telse printf(\"%.15lf\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        vector<vector<tuple<int,double,double>>> graph(n);\n        int s,g;\n        cin >> s >> g;\n        --s;\n        --g;\n        rep(i,0,m){\n            int x,y;\n            double d,c;\n            cin >> x >> y >> d >> c;\n            --x;\n            --y;\n            graph[x].emplace_back(make_tuple(y,d,c));\n            graph[y].emplace_back(make_tuple(x,d,c));\n        }\n\n        vector<vector<double>> dist(n,vector<double>(31,inf));\n        priority_queue<tuple<double,int,int>,vector<tuple<double,int,int>>,greater<tuple<double,int,int>>> que;\n        dist[s][0]=0;\n        que.push(make_tuple(0,s,0));\n        while(!que.empty()){\n            const tuple<double,int,int> tup=que.top();\n            que.pop();\n            const double d=get<0>(tup);\n            const int v=get<1>(tup),spd=get<2>(tup);\n            if(d>dist[v][spd]) continue;\n            for(const auto& e:graph[v]){\n                const auto w=get<0>(e);\n                rep(i,-1,2){\n                    const int next_spd=spd+i;\n                    if(next_spd<=0 or next_spd>get<2>(e)) continue;\n                    const double tmp_d=d+get<1>(e)/next_spd;\n                    if(tmp_d>=dist[w][next_spd]) continue;\n                    dist[w][next_spd]=tmp_d;\n                    que.push(make_tuple(tmp_d,w,next_spd));\n                }\n            }\n        }\n\n        if(dist[g][1]==inf) cout << \"unreachable\" << endl;\n        else cout << dist[g][1] << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define EPS 1e-8\n\nstruct P{\n  double t;\n  char v,p,pre;\n  P(double T=0.0,int V=0,int pp=0,int PRE=0){\n    t=T;v=V;p=pp;pre=PRE;\n  };\n  bool operator<(const P &p)const{\n    return t>p.t;\n  }\n};\nstruct Path{\n  short d,c;\n  Path(int D=0,int C=0){ d=D;c=C;};\n};\n\nint main(){\n  int n,m, s,g, x,y,d,c;\n  Path path[30][30];\n  priority_queue<P> q;\n\n  while( cin>>n>>m && (n|m) ){\n    cin >> s >> g;\n    s--; g--;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tpath[i][j].d=-1.0; path[i][j].c=-1;\n      }\n\n    for( int i=0;i<m;i++ ){\n      cin >> x >> y >> d >> c;\n      x--;y--;\n      path[x][y].d=d; path[x][y].c=c;\n      path[y][x] = path[x][y];\n    }\n\n    double cost[30][35]; // place,velocity\n    int dv[3] = {1,0,-1};\n    for( int i=0;i<n;i++ )\n      for( int j=1;j<31;j++ )\n\tcost[i][j] = DBL_MAX;\n\n    while( !q.empty() ) q.pop();\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      q.push( P(cost[i][1]=path[s][i].d,1,i,-1) );\n    }\n\n    while( !q.empty() ){\n      P p = q.top(); q.pop();\n      double t = p.t;\n      int v=p.v, np=p.p, pre=p.pre;\n      if( t>cost[g][1] ) break;\n      if( np==g && v==1 ) break;\n\n      for( int i=0;i<n;i++ ){\n\tif( path[np][i].c<0 ) continue;// たどり着けないノード\n\tif( i==pre ) continue; // 前回のノード\n\n\tint j=0;\n\tif( i==g ) j=2;\n\tfor( ;j<3;j++ ){\n\t  int nv = v + dv[j];\n\t  if( nv==0 ) continue;\n\t  if( nv>path[np][i].c )    continue;\n\t  double nCost = t + (double)path[np][i].d/nv;\n\t  if( nCost>cost[g][1] )    continue;\n\t  if( fabs(nCost-cost[g][1])<EPS ) continue;\n\t  if( cost[i][nv] < nCost ) continue;\n\t  cost[i][nv]=nCost;\n\n\t  q.push( P(nCost,nv,i,np) );\n\t}\n      }\n\n    }\n    if( fabs(cost[g][1]-DBL_MAX)<EPS )\n      cout << \"unreachable\" << endl;\n    else\n      printf(\"%.6lf\\n\",cost[g][1]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int INF = 1e15;\n\nstruct Edge {\n  int to, d, c;  \n};\n\nint s, g;\nint n, m;\nvector<Edge> G[31];\n\ntypedef pair<int, int> P;\ntypedef pair<double, int> E;\ntypedef pair<E, P> PE;\n\ndouble dij() {\n  double ret = INF;  \n  int used[n+1][n+1][101];\n  fill_n(**used, (n+1)*(n+1)*101, 0);\n  priority_queue<PE, vector<PE>, greater<PE> > q;  \n  q.push(PE(E(0, n), P(s, 1)));  \n  while ( !q.empty() ) {\n    PE e = q.top(); q.pop();    \n    double c = e.first.first;\n    int pre = e.first.second;    \n    int u = e.second.first, v = e.second.second;\n    // cout << u << \" \" << v << endl;\n    if ( u == g && v == 1 ) {\n      \n    }\n\n    if ( used[u][pre][v] >= 2 ) continue;\n    used[u][pre][v]++;    \n    for ( Edge &f : G[u] ) {\n      if ( pre == f.to ) continue;      \n      if ( f.c < v ) continue;\n      if ( f.to == g && v == 1 ) {\n\tret = min(ret, c+(double)f.d);\t\n      }\n      q.push(PE(E(c+(double)f.d/v, u), P(f.to, v)));      \n      q.push(PE(E(c+(double)f.d/v, u), P(f.to, v+1)));\n      if ( v >= 2 ) q.push(PE(E(c+(double)f.d/v, u), P(f.to, v-1)));      \n    }\n  }\n\n  return ret;\n}\n\nsigned main() {  \n  while ( cin >> n >> m, n ) {\n    for ( int i = 0; i < 31; i++ ) G[i].clear();    \n    cin >> s >> g;\n    s--; g--;\n    for ( int i = 0; i < m; i++ ) {\n      int a, b, d, c;\n      cin >> a >> b >> d >> c;\n      a--; b--;\n      G[a].emplace_back(Edge{b, d, c});\n      G[b].emplace_back(Edge{a, d, c});\n    }\n\n    double ans = dij();\n    if ( ans >= INF-100 ) cout << \"unreachable\" << endl;\n    else printf(\"%.10lf\\n\", ans);    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int v[2];\n    double d, c;\n    Edge() {}\n    Edge(int v1, int v2, double d, double c) :\n        v{v1, v2}, d(d), c(c) {}\n};\nbool operator<(const Edge &e1, const Edge &e2) {\n    return e1.c >= e2.c;\n}\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nconst double INF = 1e8;\n\ndouble MinimumTime(const int n, const int start, const int goal, const Graph &g) {\n    // tm[前の頂点][現在の頂点][速度]\n    vector<vector<vector<double>>> tm(n, vector<vector<double>>(n,\n                                                                vector<double>(31, INF)));\n\n    for (int v = 0; v < n; ++v) tm[v][start][1] = 0.0;\n\n    // 前の頂点，現在の頂点，速度，経過時間\n    priority_queue<Edge> que;\n    for (const auto &e : g[start]) {\n        que.push(Edge(start, e.v[1], 1, e.d));\n        tm[start][e.v[1]][1] = e.d;\n    }\n\n    while (!que.empty()) {\n        int prev = que.top().v[0], cur = que.top().v[1];\n        double velocity = que.top().d, elapsed = que.top().c;\n        que.pop();\n\n        if (tm[prev][cur][velocity] < elapsed) continue;\n\n        for (const auto &e : g[cur]) {\n            if (e.v[1] == prev) continue;\n\n            for (int add = -1; add <= 1; ++add) {\n                const double nxt_velocity = velocity + add;\n\n                if (nxt_velocity <= 0.0 || e.c < nxt_velocity) continue;\n\n                double tmp_tm = elapsed + e.d / nxt_velocity;\n                if (tmp_tm < tm[e.v[0]][e.v[1]][nxt_velocity]) {\n                    tm[e.v[0]][e.v[1]][nxt_velocity] = tmp_tm;\n                    que.push(Edge(cur, e.v[1], nxt_velocity, tmp_tm));\n                }\n            }\n        }\n    }\n\n    double res = INF;\n    for (int v = 0; v < n; ++v) res = min(res, tm[v][goal][1]);\n    return (INF <= res) ? -1.0 : res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(8) << setiosflags(ios::fixed);\n\n    int n, m, s, g, x, y, d, c;\n\n    while (cin >> n >> m, n) {\n        cin >> s >> g;\n\n        Graph graph(n);\n        for (int i = 0; i < m; ++i) {\n            cin >> x >> y >> d >> c;\n            graph[x - 1].emplace_back(Edge(x - 1, y - 1, d, c));\n            graph[y - 1].emplace_back(Edge(y - 1, x - 1, d, c));\n        }\n\n        double time = MinimumTime(n, s - 1, g - 1, graph);\n        if (time < 0.0) cout << \"unreachable\\n\";\n        else cout << time << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<double, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint n,m;\nstruct edge { int to;double cost; };\nint V;\nvector<edge> G[100000];\ndouble d[100000];\nvoid init(int v) {\n\trep(i, v) {\n\t\tG[i].clear();\n\t}\n}\nvoid dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\tfill(d, d + V, 10000);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (d[v]+eps < p.first)continue;\n\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost+eps) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (cin >> n>>m, n) {\n\t\tV = 100000;\n\t\tint s, g; cin >> s >> g; s--; g--;\n\t\tinit(100000);\n\t\tP dis[30][30];\n\t\trep(i, 30) {\n\t\t\trep(j, 30) {\n\t\t\t\tdis[i][j] = { 0,0 };\n\t\t\t}\n\t\t}\n\t\trep(i, m) {\n\t\t\tint x, y, D, c; cin >> x >> y >> D >> c; x--; y--;\n\t\t\tdis[x][y] = dis[y][x] = { D,c };\n\t\t}\n\t\trep(f, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, 31) {\n\t\t\t\t\tRep1(k, -1, 1) {\n\t\t\t\t\t\tint x = j + k;\n\t\t\t\t\t\tif (x <= 0 || x > 30)continue;\n\t\t\t\t\t\trep(l, n) {\n\t\t\t\t\t\t\tif (f!=l&&i != l && dis[i][l].first != 0 && dis[i][l].second >= x) {\n\t\t\t\t\t\t\t\tG[i + j * n+f*n*31].push_back({ l + n * x+i*n*31,(double)dis[i][l].first / double(x) });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(s + s * n*31);\n\t\tdouble mi = 10000;\n\t\trep(i, n) {\n\t\t\tmi = min(mi, d[g + n+ n * 31*i]);\n\t\t}\n\t\tif (mi == 10000) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\tcout << fixed << setprecision(5) << mi << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<double> vd;\n#define rep(i, n) for(int i=0; i<n; i++)\n\nstatic const double INF = 1E8;\nstruct Edge{int x, y; double d, c;};\nint n, m;\nint s, g;\nint x, y;\ndouble dd, c;\ndouble d[33][33][33];\nvector<Edge> G[33];\nvd tmp(4);\n\nint main()\n{\n  while(cin >> n >> m, n){\n    cin >> s >> g;\n    rep(i, 33) G[i].clear();\n    rep(i, m){\n      cin >> x >> y >> dd >> c;\n      G[x].push_back((Edge){x, y, dd, c});\n      G[y].push_back((Edge){y, x, dd, c});\n    }\n    rep(i, 33) rep(j, 33) rep(k, 33) d[i][j][k] = INF;    \n    priority_queue<vd, vector<vd>, greater<vd> > que;\n    tmp[0] = 0;  tmp[1] = 0;  tmp[2] = s;  tmp[3] = 0;\n    que.push(tmp);\n    while(!que.empty()){\n      vd top = que.top();\n      double cost = top[0];\n      int v = top[1];\n      int hx = top[2];\n      int px = top[3];\n      tmp[3] = hx;\n      if(hx == g && v == 1){\n        printf(\"%.15f\\n\", cost);\n        break;\n      }\n      que.pop();\n      if(d[hx][px][v] < cost) continue;\n      rep(i, G[hx].size()) if(G[hx][i].y != px){\n        Edge e = G[hx][i];\n        tmp[2] = e.y;\n        for(int k = -1; k <= 1; k++){\n          if(v + k > 0 && v + k <= e.c && d[e.y][hx][v + k] > cost + e.d / (v + k)){\n            d[e.y][hx][v + k] = cost + e.d / (v + k);\n            tmp[1] = v + k;\n            tmp[0] = d[e.y][hx][v + k];\n            que.push(tmp);\n          }\n        }\n      }\n    }\n    if(que.empty()) puts(\"unreachable\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 35\n#define INF 1e9\n#define F first\n#define S second\ntypedef pair<double,int> pdi;\ntypedef pair<int,int> pii;\ntypedef pair<pdi,pii> State;\n \nstruct Edge{\n  int to,d,c;\n  Edge(int to,int d,int c) : to(to),d(d),c(c) {}\n};\n \nint N,M,s,g;\nvector<Edge> G[MAX];\n \ndouble dijkstra(){\n  priority_queue<State,vector<State>,greater<State> > Q;\n  Q.push(State(pdi(0,s),pii(1,N)));\n  double Time[MAX][MAX][MAX];\n  fill(Time[0][0],Time[0][0]+MAX*MAX*MAX,INF);   \n  Time[s][1][N] = 0;\n  bool visited[MAX][MAX][MAX];\n  memset(visited,false,sizeof(visited));\n \n  while(!Q.empty()){\n    State p = Q.top(); Q.pop();\n    int v = p.F.S, vel = p.S.F;\n    if(Time[v][vel][p.S.S] < p.F.F) continue;\n\n    if(visited[v][vel][p.S.S]) continue;\n    visited[v][vel][p.S.S] = true;\n\n    if(v == g && vel == 1){\n      return Time[g][1][p.S.S];\n    }\n \n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      for(int j = -1 ; j <= 1 ; j++){\n        if(vel+j <= 0) continue;\n        if(Time[v][vel][p.S.S] == 0 && j){\n          continue;\n        }\n        Edge e = G[v][i];\n        double t = (double)e.d/(vel+j);\n        if(vel+j <= e.c && \n           Time[v][vel][p.S.S] + t < Time[e.to][vel+j][v]){\n          Time[e.to][vel+j][v] = Time[v][vel][p.S.S] + t;\n          Q.push(State(pdi(Time[e.to][vel+j][v],e.to),pii(vel+j,v)));\n        }\n      }\n    }\n  }\n  return INF;\n}\n \nint main(){\n  int x,y,d,c;\n  while(cin >> N >> M, N){\n    for(int i = 0 ; i < MAX ; i++){\n      G[i].clear();\n    }\n    cin >> s >> g; s--; g--;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> d >> c;\n      x--; y--;\n      G[x].push_back(Edge(y,d,c));\n      G[y].push_back(Edge(x,d,c));\n    }\n    double res = dijkstra();\n    if(res == INF){\n      cout << \"unreachable\" << endl;\n    }else{\n      printf(\"%.8f\\n\",res);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <iomanip>\nusing namespace std;\n\nint N,M,S,G;\n\nstruct state{\n    int node,velocity;\n    double ti;\n    int pre_node;\n    bool operator<(const state& right)const{\n        return ti>right.ti;\n    }\n};\n\nstruct edge{\n    int to,dist,upp;\n};\n\ndouble dp[31][31][31];\ndouble inf = 1e9;\n\nint main(){\n    while(cin >> N >> M && N>0){\n        cin >> S >> G;\n        vector<vector<edge>> v(N+1);\n        int x,y,d,c;\n        for(int i=0;i<M;i++){\n            cin >> x >> y >> d >> c;\n            v[x].push_back({y,d,c});\n            v[y].push_back({x,d,c});\n        }\n        for(int i=1;i<=N;i++) for(int j=1;j<=30;j++) for(int k=1;k<=N;k++) dp[i][j][k] = inf;\n        dp[S][1][0] = 0;\n        priority_queue<state> Q;\n        Q.push({S,0,0,0});\n        while(!Q.empty()){\n            state now = Q.top(); Q.pop();\n            if(dp[now.node][now.velocity][now.pre_node]<now.ti) continue;\n            for(auto& x:v[now.node]){\n                if(now.pre_node==x.to) continue;\n                for(int dv=-1;dv<=1;dv++){\n                    if(now.velocity+dv<=0 || now.velocity+dv>x.upp) continue;\n                    state ne;\n                    ne.node = x.to; ne.velocity = now.velocity+dv;\n                    ne.ti = now.ti+1.0*x.dist/ne.velocity;\n                    ne.pre_node = now.node;\n                    if(dp[ne.node][ne.velocity][ne.pre_node]>ne.ti){\n                        dp[ne.node][ne.velocity][ne.pre_node] = ne.ti;\n                        Q.push(ne);\n                    }\n                }\n            }\n        }\n        double ans = inf;\n        for(int i=1;i<=N;i++) ans = min(ans,dp[G][1][i]);\n        if(ans>=inf) cout << \"reachable\" << endl;\n        else{\n            cout << fixed;\n            cout << setprecision(10) << ans << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\n\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[40];    \n    \n    int inx,iny,ind,inc;\n    double d[40][40][40];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      if(p.F.F == g && p.S.S == 1){\n\tif(test > d[p.F.S][p.F.F][p.S.S])test = d[p.F.S][p.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t    continue;\n\t  }    \n\n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <queue>\n#include <cfloat>\n\nusing namespace std;\n\nclass State\n{\npublic:\n\tdouble _time; //©©Á½Ô\n\tint _speed; //¬x\n\tint _town; //»Ýn\n\tint _utern; //OñÌ¬it^[Ö~j\n\tState(double time,int speed,int town,int utern)\n\t\t:_time(time),_speed(speed),_town(town),_utern(utern){}\n\tbool operator<(const State& tmp) const\n\t{\n\t\treturn _time > tmp._time;\n\t}\n};\n\nclass Edge\n{\npublic:\n\tint _d; //£\n\tint _c; //§À¬x\n\tEdge(){}\n\tEdge(int d,int c):_d(d),_c(c){}\n};\n\nint main()\n{\n\tfor(;;)\n\t{\n\t\t//Init\n\t\tint n,m,s,g;\n\t\tcin >> n >> m;\n\t\tif(n==0 && m==0) break;\n\n\t\tcin\t>> s >> g;\n\t\t--s;\n\t\t--g;\n\n\t\tEdge *Graph[30][30];\n\t\tfor(int i=0;i<30;i++)\n\t\t{\n\t\t\tfor(int j=0;j<30;j++)\n\t\t\t{\n\t\t\t\tGraph[i][j] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint x,y,d,c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\t--x;\n\t\t\t--y;\n\t\t\tGraph[x][y] = new Edge(d,c);\n\t\t\tGraph[y][x] = new Edge(d,c);\n\t\t}\n\n\t\tbool Visited[30][30][30]; //»Ýn@t^[Ö~@¬x\n\t\tdouble Cost[30][30][30];\n\t\tfor(int i=0;i<30;i++)\n\t\t{\n\t\t\tfor(int j=0;j<30;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<30;k++)\n\t\t\t\t{\n\t\t\t\t\tVisited[i][j][k] = false;\n\t\t\t\t\tCost[i][j][k] = DBL_MAX;\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n\t\tpriority_queue<State> PQ;\n\t\tPQ.push(State(0.0,0,s,s));\n\t\tCost[s][s][0] = 0;\n\n\t\tdouble min_time = -1;\n\n\t\t//Dijkstra\n\t\twhile(!PQ.empty())\n\t\t{\n\t\t\tState tmp = PQ.top();\n\t\t\tPQ.pop();\n\t\t\tif(Visited[tmp._town][tmp._utern][tmp._speed] == true) continue;\n\t\t\t//cout << \"time \" << tmp._time << \" town \"<< tmp._town+1 << \" speed \" << tmp._speed << endl;\n\t\t\tif(tmp._town == g && tmp._speed == 1)\n\t\t\t{\n\t\t\t\tmin_time = tmp._time;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVisited[tmp._town][tmp._utern][tmp._speed] = true;\n\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(tmp._utern == i) continue;\n\t\t\t\tif(Graph[tmp._town][i] != NULL)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=-1;j<=1;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint tmp_speed = tmp._speed + j;\n\t\t\t\t\t\tif(Visited[i][tmp._town][tmp_speed] == true) continue;\n\t\t\t\t\t\tif(tmp_speed <= 0) continue;\n\t\t\t\t\t\tif(tmp_speed > Graph[tmp._town][i]->_c) continue;\n\t\t\t\t\t\tdouble tmp_time = Graph[tmp._town][i]->_d / static_cast<double>(tmp_speed);\n\t\t\t\t\t\ttmp_time += tmp._time;\n\t\t\t\t\t\tif(Cost[i][tmp._town][tmp_speed] < tmp_time) continue;\n\t\t\t\t\t\tCost[i][tmp._town][tmp_speed] = tmp_time;\n\t\t\t\t\t\tPQ.push(State(tmp_time,tmp_speed,i,tmp._town));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//Output\n\t\tif(min_time == -1)\n\t\t{\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else\n\t\t{\n\t\t\tcout << min_time << endl;\n\t\t}\n\n\t\t//Free\n\t\tfor(int i=0;i<30;i++)\n\t\t{\n\t\t\tfor(int j=0;j<30;j++)\n\t\t\t{\n\t\t\t\tif(Graph[i][j] != NULL) delete Graph[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\nint n,m,s,g;\ndouble d[40][40][40];\n\nint main(){\n  int inx,iny,ind,inc;\n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n\n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n    \n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n\n//((time, pre_node), (power, node))\ntypedef pair<pair<double, int>, pii> State;\n\nint main(void){\n    for(int n, m; cin >> n >> m, n;){\n        int s, z; cin >> s >> z;\n        s--, z--;\n\n        // (to, (length, limited_power))\n        vector<vector<pair<int, pii>>> edge(n);\n        rep(i, m){\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--, y--;\n\n            edge[x].pb(mp(y, mp(d, c)));\n            edge[y].pb(mp(x, mp(d, c)));\n        }\n\n        priority_queue<State, vector<State>, greater<State>> q;\n        for(auto e : edge[s]){\n            q.push(mp(mp((double)e.S.F, s), mp(1, e.F)));\n        }\n\n        // [pre_node][power][node]\n        vector<vector<vector<double>>> minDist(n, vector<vector<double>>(31, vector<double>(n, (double)inf)));\n        while(!q.empty()){\n            double cur_time = q.top().F.F;\n            int cur_prev = q.top().F.S;\n            int cur_power = q.top().S.F;\n            int cur_v = q.top().S.S;\n            q.pop();\n\n            if(minDist[cur_prev][cur_power][cur_v] < (double)inf - eps) continue;\n\n            minDist[cur_prev][cur_power][cur_v] = cur_time;\n\n            int next_prev = cur_v;\n\n            range(next_power, max(1, cur_power - 1), cur_power + 2){\n                for(auto e : edge[cur_v]){\n                    int next_v = e.F;\n                    if(next_v == cur_prev || e.S.S < next_power || minDist[next_prev][next_power][next_v] < (double)inf - eps){\n                        continue;\n                    }\n                    double next_time = cur_time + (double)e.S.F / next_power;\n\n                    q.push(mp(mp(next_time, next_prev), mp(next_power, next_v)));\n                }\n            }\n        }\n\n        double res = (double)inf;\n        rep(i, n){\n            res = min(res, minDist[i][1][z]);\n        }\n\n        if(res >= (double)inf - eps) cout << \"unreachable\" << endl;\n        else                         printf(\"%.5f\\n\", res);\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define FOR(i,a,n) for(int i = a; i < n; i++)\n\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nstruct edge{\n  int to, d, c;\n};\n\nedge makeEdge(int to, int d, int c){\n  edge e;\n  e.to = to;\n  e.d = d;\n  e.c = c;\n  return e;\n}\n\nint n,m;\nint s,g;\ntypedef tuple<double, int, int,int> State;\nconst double INF = 1e15;\n\n\nvoid dijkstra(vector<vector<edge> > &edges){\n  double dist[n][n][31];\n  rep(i,n)rep(j,n)rep(k,31) dist[i][j][k] = INF;\n  rep(i,n) dist[s][i][0] = 0;\n  priority_queue< State, vector<State>, greater<State>> que;\n  for(edge e :edges[s]){\n    if(1 <= e.c && dist[e.to][s][1] > (double)e.d ){\n      dist[e.to][s][1] = (double)e.d;\n      que.push(State((double)e.d, 1 ,e.to ,s));\n    }\n  }\n\n  while(que.empty() == false){\n    State s = que.top(); que.pop();\n    double ctime  = get<0>(s);\n    int cspeed    = get<1>(s);\n    int current   = get<2>(s);\n    int prev      = get<3>(s);\n\n    if(dist[current][prev][cspeed] < ctime) continue;\n    for(edge e :edges[current]){\n      if(e.to == prev) continue;\n      for(int v = -1; v <= 1; v++){\n        if( cspeed + v > 0 &&\n            cspeed + v <= e.c &&\n            dist[e.to][current][cspeed + v] > (ctime + (double)e.d / (double)(cspeed + v) ) ) {\n\n          dist[e.to][current][ cspeed + v ] = ctime + (double)e.d/(double)(cspeed + v);\n          que.push(State(\n                    ctime + (double)( e.d / (double)(cspeed + v) ),\n                    cspeed + v ,\n                    e.to ,\n                    current));\n        }\n      }\n    }\n\n  }\n  double ans = INF;\n  rep(i,n) ans = min(ans,dist[g][i][1]);\n  if(ans == INF) cout << \"unreachable\" << endl;\n  else printf(\"%0.10lf\\n\",ans);\n}\n\nint main(){\n  while(true){\n    cin >> n >> m;\n    if(n == 0 && m == 0) break;\n    cin >> s >> g;\n    s--,g--;\n    vector<vector<edge>> edges(n);\n\n    rep(i,m){\n      int x,y,d,c;\n      cin >> x >> y >> d >> c;\n      x--,y--;\n      edges[x].push_back(makeEdge(y,d,c));\n      edges[y].push_back(makeEdge(x,d,c));\n    }\n    dijkstra(edges);\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> Pi;\ntypedef pair<double, int> Pd;\ntypedef pair<Pd, Pi> PP;\n\nstruct edge {\n  int to, lim;\n  double dist;\n  edge(){}\n  edge(int to, int lim, double dist):to(to), lim(lim), dist(dist){}\n};\n\nvector< vector<edge> > G;\ndouble mint[33][33][33];\nint n, m, s, g;\n\nconst double inf = 1 << 25;\n\nvoid init()\n{\n  for(int i = 0; i < 33; i++) {\n    for(int j = 0; j < 33; j++) {\n      for(int k = 0; k < 33; k++) mint[i][j][k] = inf;\n    }\n  }\n}\n\nvoid dijkstra()\n{\n  init();\n  priority_queue<PP, vector<PP>, greater<PP> > que;\n  mint[s][0][0] = 0.0;\n  que.push(PP(Pd(0.0, 0), Pi(s, 0)));\n  while(!que.empty()) {\n    PP p = que.top(); que.pop();\n    int now = p.second.first, prev = p.second.second, v = p.first.second;\n    double t = p.first.first;\n    if(now == g && v == 1) continue;\n    if(mint[now][prev][v] < t) continue;\n    for(int i = 0; i < G[now].size(); i++) {\n      edge e = G[now][i];\n      if(e.to == prev) continue;\n      for(int d = -1; d <= 1; d++) {\n\tif(v+d <= 0 || e.lim < v+d) continue;\n\tif(t + e.dist/(v+d) < mint[e.to][now][v+d]) {\n\t  mint[e.to][now][v+d] = t + e.dist/(v+d);\n\t  que.push(PP(Pd(mint[e.to][now][v+d], v+d), Pi(e.to, now)));\n\t}\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(cin >> n >> m, n) {\n    cin >> s >> g;\n    G.clear(); G.resize(n + 1);\n    while(m--) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      G[x].push_back(edge(y, c, d));\n      G[y].push_back(edge(x, c, d));\n    }\n    dijkstra();\n    double ans = inf;\n    for(int i = 0; i < n; i++) ans = min(ans, mint[g][i][1]);\n    if(ans == inf) puts(\"unreachable\");\n    else printf(\"%.4f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<iomanip>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define sc second\n#define pb push_back\n#define mk make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntemplate<class S,class T>\nostream &operator<<(ostream &out, const pair<S,T> p){\n\treturn out << \"(\" << p.fs << \", \" << p.sc << \")\";\n}\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \", \";\n\treturn out << \"}\" << endl;\n}\n\n#define N 30\ndouble d[N+1][N];\nint main(){\n\tint n, m, s, g;\n\twhile(cin >> n >> m, n){\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\t\tfill(d[0], d[0] + (N+1) * N, -1);\n\t\tvector<pair<int,double> > e[N+2][N];// e[c][x] : from x at vert c list\n\t\trep(i, m){\n\t\t\tint x, y, di, c;\n\t\t\tcin >> x >> y >> di >> c;\n\t\t\tx--; y--;\n\t\t\treps(j,1,c+1){\n\t\t\t\tdouble time = di / (double) j;\n\t\t\t\te[j][x].pb(mk(y, time));\n\t\t\t\te[j][y].pb(mk(x, time));\n\t\t\t}\n\t\t}\n\t\t// dst, from, current, ver\n\t\tpriority_queue<pair<double, pair<pii, int> > > q;\n\t\tq.push(mk(0, mk(pii(-1, s), 0)));\n\t\twhile(!q.empty()){\n\t\t\tdouble dst = -q.top().fs;\n\t\t\tint from = q.top().sc.fs.fs;\n\t\t\tint cur = q.top().sc.fs.sc, ver = q.top().sc.sc;\n\t\t\tq.pop();\n\t\t\tif(d[ver][cur] >= 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[ver][cur] = dst;\n\t\t\tif(ver == 1 && cur == g) break;\n\t\t\trep(i,3){\n\t\t\t\tint ci = ver - 1 + i;\n\t\t\t\tif(ci<1 || ci > N+1) continue;\n\t\t\t\trep(j, e[ci][cur].size()){\n\t\t\t\t\tpair<int, double> p = e[ci][cur][j];\n\t\t\t\t\tint to = p.fs;\n\t\t\t\t\tif (from == to) continue;\n\t\t\t\t\tdouble tmp = dst + p.sc;\n\t\t\t\t\tq.push(mk(-tmp, mk( pii(from, to), ci)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(d[1][g] < 0) cout << \"unreachable\" << endl;\n\t\telse cout <<fixed << setprecision(10)<< d[1][g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<cstring>\n#define INF 1e10\nusing namespace std;\nstruct edge{\n  int to,limit;\n  double dist;\n};\nstruct Point{\n  int speed,prev,v;\n  double cost;\n  Point(){}\n  Point(int speed_,int prev_,int v_,double cost_)\n    :speed(speed_),prev(prev_),v(v_),cost(cost_){}\n  bool operator>(const Point &a)const{\n    return cost > a.cost;\n  }\n};\nvector<edge> G[100];\ndouble d[40][40][40];//speed,pos,prev\n\ndouble dikstra(int s,int g){\n  int ds[3]={-1,0,1};\n  priority_queue<Point,vector<Point>,greater<Point> > que;\n  \n  for(int i=0;i<40;i++)\n    for(int j=0;j<40;j++)\n      for(int k=0;k<40;k++)\n\td[i][j][k]=INF;\n  \n  d[0][s][0]=0;\n  Point tmp(0,0,s,0);\n  que.push(tmp);\n  \n  while(!que.empty()){\n    Point p=que.top();que.pop();\n    if(d[p.speed][p.v][p.prev]<p.cost)continue;\n    if(p.speed==1 && p.v==g)return p.cost;\n\n    for(int i=0;i<G[p.v].size();i++){\n\tedge e=G[p.v][i];\n      for(int j=0;j<3;j++){\n\tint ns=p.speed+ds[j];\n\tif(1<=ns && ns<= e.limit &&\n\t   e.to!=p.prev && \n\t   d[ns][e.to][p.v]>p.cost+e.dist/ns){\n\n\t  Point tmp(ns,p.v,e.to,p.cost+e.dist/ns);\n\t  que.push(tmp);\n\t  d[ns][e.to][p.v]=p.cost+e.dist/ns;\n\t  //cout << \"d[\" << ns << \"][\" << e.to << \"][\" << p.v << \"]:\" << d[ns][e.to][p.v] << endl;\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n){\n    for(int i=0;i<100;i++)G[i].clear();\n    cin>>s>>g;\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      G[x].push_back((edge){y,c,d});\n      G[y].push_back((edge){x,c,d});\n    }\n    double ans=dikstra(s,g);\n    if(ans==-1)cout << \"unreachable\" << endl;\n    else printf(\"%.5lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//MLE\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\nstruct node{\n\tchar pos;\n\tchar prev;\n\tchar speed;\n\tdouble dist;\n\n\tnode( int pos_, int prev_, int speed_, double dist_ )\n\t\t: pos(pos_), prev(prev_), speed(speed_), dist(dist_) {}\n\n\tbool operator< (const node &n) const{\n\t\treturn dist > n.dist;\t//逆\n\t}\n};\n\nstruct road{\n\tchar to;\n\tdouble dist;\n\tchar c;\n\t\n\troad( int t, double d, int c_ )\n\t\t: to(t), dist(d), c(c_) {}\n};\n\nint n, m;\nint s, g;\n\nvector<vector<road> > roads;\ndouble mindist[31][31][31];\n\n\nvoid solve(){\n\tfill( mindist[0][0], mindist[31][0], 9e9 );\n\n\tpriority_queue<node> pq;\n\tfor( int i = 0; i < roads[s].size(); ++i ){\n\t\troad r = roads[s][i];\n\t\tpq.push( node( r.to, s, 1, r.dist ) );\n\t\tmindist[r.to][s][1] = r.dist;\n\t}\n\t\n\twhile( !pq.empty() ){\n\t\tnode nd = pq.top();\n\t\tpq.pop();\n\n\t\tif( mindist[nd.pos][nd.prev][nd.speed] != nd.dist ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif( nd.pos == g && nd.speed == 1 ){\n\t\t\tprintf(\"%f\\n\", nd.dist );\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor( int i = 0; i < roads[nd.pos].size(); ++i ){\n\t\t\troad r = roads[nd.pos][i];\n\t\t\tif( r.to == nd.prev ){\tcontinue;\t}\n\t\t\t\n\t\t\tfor( int j = -1; j < 2; ++j ){\n\t\t\t\tif( nd.speed + j > 0 && nd.speed + j <= r.c ){\n\t\t\t\t\tdouble nextdist = nd.dist + r.dist / ( nd.speed + j );\n\t\t\t\t\tif( mindist[r.to][nd.pos][nd.speed + j] > nextdist ){\n\t\t\t\t\t\tmindist[r.to][nd.pos][nd.speed + j] = nextdist;\n\t\t\t\t\t\tpq.push( node( r.to, nd.pos, nd.speed + j, nextdist ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tputs(\"unreachable\");\n}\n\n\nint main(){\n\tint x, y, d, c;\n\twhile( cin >> n >> m, n != 0 ){\n\t\troads = vector<vector<road> >( n + 1 );\n\t\t\n\t\tcin >> s >> g;\n\t\t\n\t\tfor( int i = 0; i < m; ++i ){\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\troads[x].push_back( road( y, d, c ) );\n\t\t\troads[y].push_back( road( x, d, c ) );\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<tuple<int,int,int>> City;//to,limit,distance\nvector<City> C;\ntypedef tuple<double,int,int> T;//time,cityid,speed\npriority_queue<T,vector<T>,greater<T>> que;\ndouble memo[30][31];//[cityid][speed]\n\nint main(){\n    cout.precision(5);\n    cout<<fixed;\n    int n,m;\n    while(cin>>n>>m,n){\n        int s,g;\n        cin>>s>>g;\n        s--;g--;\n        C.clear();\n        for(int i=0;i<n;i++) C.push_back(City());\n        for(int i=0;i<m;i++){\n            int x,y,d,c;\n            cin>>x>>y>>d>>c;\n            x--;y--;\n            C[x].emplace_back(y,c,d);\n            C[y].emplace_back(x,c,d);\n        }\n        fill(memo[0],memo[30],1e8);\n        memo[s][0]=0;\n        while(!que.empty())que.pop();\n        que.emplace(0,s,0);\n        double ans=1e8;\n        while(!que.empty()){\n            T t=que.top(); que.pop();\n            double time=get<0>(t);\n            int cityid=get<1>(t);\n            int speed=get<2>(t);\n            if(time>memo[cityid][speed]) continue;\n            if(cityid==g&&speed==1){\n                ans=time;\n                break;\n            }\n            for(auto& e:C[cityid]){\n                double distance=get<2>(e);\n                int to=get<0>(e);\n                int limit=get<1>(e);\n                if(speed+1<=limit){\n                    if(memo[to][speed+1]>time+distance/(speed+1)){\n                        memo[to][speed+1]=time+distance/(speed+1);\n                        que.emplace(memo[to][speed+1],to,speed+1);\n                    }\n                }\n                if(speed<=limit&&speed>0){\n                    if(memo[to][speed]>time+distance/(speed)){\n                        memo[to][speed]=time+distance/(speed);\n                        que.emplace(memo[to][speed],to,speed);\n                    }\n                }\n                if(speed-1<=limit&&speed-1>0){\n                    if(memo[to][speed-1]>time+distance/(speed-1)){\n                        memo[to][speed-1]=time+distance/(speed-1);\n                        que.emplace(memo[to][speed-1],to,speed-1);\n                    }\n                }\n            }\n        }\n        if(ans==1e8){\n            cout<<\"unreachable\"<<endl;\n        }else{\n            cout<<ans<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF INT_MAX\n\nconst int MAX_SPEED=30;\nconst int MAX_TOWN=30;\n\nstruct P\n{\n    int town,speed;\n    float cost;\n    int ptown;\n    bool operator >(const P &p) const{\n        return cost>p.cost;\n    }\n};\n\nstruct edge\n{\n    int to,cost,lim;\n};\n\nfloat G[MAX_TOWN+1][MAX_TOWN+1][MAX_SPEED+1];\n\nint main() {\n    int town_n,way_n,s,g;\n    while(cin >> town_n >> way_n, town_n|way_n){\n          cin >> s >> g;\n\n          vector<vector<edge>>E(town_n+1);\n\n          REP(i, way_n){\n              int from,to,dist,lim;\n              cin >> from >> to >> dist >> lim;\n              E[from].push_back({to,dist,lim});\n              E[to].push_back({from,dist,lim});\n          }\n\n          fill_n((float *)G, (MAX_TOWN+1)*(MAX_TOWN+1)*(MAX_SPEED+1), INF);\n\n          priority_queue<P, vector<P>, greater<P>>que;\n          que.push({s,0,0,0});\n\n          float res=INF;\n          while(!que.empty()){\n              P p=que.top();que.pop();\n\n              if(p.town==g&&p.speed==1){\n                  res=p.cost;\n                  break;\n              }\n\n              for(edge e:E[p.town]){\n                  if(e.to==p.ptown)continue;\n                  for(int d=-1;d<=1;d++){\n                      int speed=p.speed+d;\n                      float cost=p.cost+e.cost/(float)speed;\n                      if(1<=speed&&speed<=e.lim){\n                          if(G[e.to][speed][p.town]>cost){\n                            G[e.to][speed][p.town]=cost;\n                            que.push({e.to,speed,cost,p.town});\n                          }\n                      }\n                  }\n              }\n          }\n\n          if(res==INF){\n              cout << \"unreachable\" << endl;\n          }else{\n          \tprintf(\"%5f\\n\",res);\n          }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 30;\nconst double EPS = 1E-9;\n\nint n, m, s, g;\nstruct edge{\n\tint to;\n\tint cost;\n\tint limit;\n};\nvector<edge> G[101];\ndouble t[101][31];\n\nint main(){\n\twhile(cin >> n >> m && (n || m)){\n\t\tcin >> s >> g;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint from, to;\n\t\t\tedge e;\n\t\t\tcin >> from >> to >> e.cost >> e.limit;\n\t\t\te.to = to;\n\t\t\tG[from].push_back(e);\n\t\t\te.to = from;\n\t\t\tG[to].push_back(e);\n\t\t}\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tfill(t[i], t[i] + 101, -1.0);\n\t\t}\n\t\tt[s][0] = 0;\n\t\tpriority_queue<pair<double, PP>, vector<pair<double, PP> >, greater<pair<double, PP> > > que;\n\t\tque.push(make_pair(0, PP(-1, P(s, 0))));\n\t\twhile(!que.empty()){\n\t\t\tpair<double, PP > ppp = que.top(); que.pop();\n\t\t\tPP pp = ppp.second;\n\t\t\tdouble tm = ppp.first;\n\t\t\tint place = pp.second.first;\n\t\t\tint v = pp.second.second;\n\t\t\tint pre = pp.first;\n\t\t\tfor(size_t i = 0; i < G[place].size(); i++){\n\t\t\t\tedge e = G[place][i];\n\t\t\t\tif(e.to == pre) continue;\n\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\tif(v + j > 0 && v + j <= 30 && v + j <= e.limit){\n\t\t\t\t\t\tif(t[e.to][v+j] < 0 || t[e.to][v+j] > t[place][v] + (double)e.cost / (v+j)){\n\t\t\t\t\t\t\tt[e.to][v+j] = t[place][v] + (double)e.cost / (double)(v+j);\n\t\t\t\t\t\t\tque.push(make_pair(t[e.to][v+j], PP(place, P(e.to, v+j))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t[g][1] < 0) cout << \"unreachable\" << endl;\n\t\telse cout << t[g][1] << endl;\n\t\tfor(int i = 0; i < 101; i++) G[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nconst int MAX = 35;\nconst int INF = (1<<25);\nint n,m;\n\nstruct Edge{\n  int to;\n  double dis,lim;\n  Edge(int a, double b, double c){\n    to = a;\n    dis = b;\n    lim = c;\n  }\n};\n\nstruct State{\n  int pos,from;\n  double speed,t;\n  State(int a, double b, double c, int f){\n    pos = a;\n    speed = b;\n    t = c;\n    from = f;\n  }\n  bool operator < (const State& s) const{ return t > s.t;}\n};\n\nvector<Edge> E[MAX];\ndouble T[MAX][MAX];\n//T[i][j] := shortest time to i with speed j.\n\n\nvoid init(){\n  for(int i = 0; i < MAX; i++){\n    fill(T[i],T[i]+MAX,(double)INF);\n    E[i].clear();\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++){\n    int x,y;\n    double d,c;\n    cin >> x >> y >> d >> c;\n    //   cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    E[x].push_back(Edge(y,d,c));\n    E[y].push_back(Edge(x,d,c));\n  }\n}\n\nvoid solve(int s, int g){\n\n  priority_queue<State> Q;\n  T[s][0] = 0;\n  Q.push(State(s,0,0,-1));\n\n  while(!Q.empty()){\n    State sta = Q.top();\n    Q.pop();\n\n    if(sta.t > T[sta.pos][(int)sta.speed]) continue;\n\n    for(int i = 0; i < E[sta.pos].size(); i++){\n      int np = E[sta.pos][i].to;\n\n      if(np == sta.from) continue;\n\n      double sp[] = {-1,0,1};\n      \n      for(int j = 0; j < 3; j++){\n\tdouble ns = sta.speed+sp[j];\n\tif(ns < 0 || ns > E[sta.pos][i].lim) continue;\n\tdouble nt = sta.t+E[sta.pos][i].dis/ns;\n\tif(T[np][(int)ns] > nt){\n\t  T[np][(int)ns] = nt;\n\t  Q.push(State(np,ns,nt,sta.pos));\n\t}\n      }\n    }\n  }\n  \n\n  if(T[g][1] == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.5f\\n\",T[g][1]);\n}\n\nint main(){\n  \n  while(cin >> n >> m && n+m){\n    init();\n    int s,g;\n    cin >> s >> g;\n    input();\n    solve(s,g);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\nconstexpr int max_v = 31;\nconstexpr int INF = 1e9;\nconstexpr double eps = 1e-8;\n\n\nclass state {\npublic:\n    int u, prev;\n    int v;\n    double time;\n    bool operator>(state const& other) const {\n        return time > other.time;\n    }\n};\n\nstruct edge {\n    int from, to;\n    int dist;\n    int limit;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\n\ndouble dijkstra(graph& g, int s, int G) {\n    vector<vector<vector<double>>> d(g.size(), vector<vector<double>>(g.size(), vector<double>(max_v, INF)));\n    priority_queue<state, vector<state>, greater<state>> que;\n    d[s][0][0] = 0;\n    que.push(state{s, 0, 0, 0});\n    while(!que.empty()) {\n        state S = que.top(); que.pop();\n        int u = S.u, prev = S.prev, v = S.v;\n        if(d[u][prev][v] + eps < S.time) {\n            continue;\n        }\n        for(int i=0; i<g[u].size(); ++i) {\n            edge e = g[u][i];\n            if(e.to == prev) { // to\n                continue;\n            }\n            for(int j=-1; j<=1; ++j) {\n                int nv = v + j;\n                if(nv <= 0 || max_v <= nv || e.limit < nv) {\n                    continue;\n                }\n                if(d[e.to][u][nv] - (d[u][prev][v] + e.dist / (double)nv) > eps) {\n                    d[e.to][u][nv] = d[u][prev][v] + e.dist / (double)nv;\n                    que.push(state{e.to, u, nv, d[e.to][u][nv]});\n                }\n            }\n        }\n    }\n    double res = INF;\n    for(int i=0; i<g.size(); ++i) {\n        res = min(res, d[G][i][1]);\n    }\n    return res;\n}\n\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n) {\n        int s, g;\n        cin >> s >> g;\n        graph G(n+1);\n        for(int i=0; i<m; ++i) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            G[x].push_back((edge){x, y, d, c});\n            G[y].push_back((edge){y, x, d, c});\n        }\n        double res = dijkstra(G, s, g);\n        if(fabs(res - INF) < eps) {\n            cout << \"unreachable\" << endl;\n        } else {\n            cout << fixed << setprecision(10) << res << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\nclass data{\npublic:\n\tint t,c,d;\n\n};\n\nclass data2{\npublic:\n\tdouble cost;\n\tint v,s,p;\n\tbool operator<(const data2 &d1)const{\n\t\treturn d1.cost<cost;\n\t}\n};\n\nint n,m,s,g;\ndouble dp[35][35][35];\nvector<data> edge[35];\n\ndouble dijk(){\n\tfor(int i=0;i<35;i++){\n\t\tfor(int j=0;j<35;j++){\n\t\t\tfor(int k=0;k<35;k++){\n\t\t\t\tdp[i][j][k]=-1.0;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<data2> que;\n\tdata2 ind;\n\tind.cost=0.0;\n\tind.v=s;\n\tind.s=0;\n\tind.p=0;\n\tdouble res=-1.0;\n\tdp[s][0][0]=0.0;\n\tque.push(ind);\n\twhile(que.size()){\n\t\tdata2 dd=que.top();\n\t\tque.pop();\n\t\tif(dp[dd.v][dd.s][dd.p]<dd.cost)continue;\n\t\tif(dd.v==g && dd.s==1){\n\t\t\tres=min(dd.cost,res);\n\t\t\tif(res==-1.0)res=dd.cost;\n\t\t\tcontinue;\n\t\t}\n\t\tdp[dd.v][dd.s][dd.p]=dd.cost;\n\t\tfor(int i=0;i<edge[dd.v].size();i++){\n\t\t\tdata e=edge[dd.v][i];\n\t\t\tif(dd.p==e.t)continue;\n\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\tint ns=dd.s+j;\n\t\t\t\tif(ns<=0 || ns>e.c)continue;\n\t\t\t\tdouble nc=dd.cost+(double)e.d/ns;\n\t\t\t\tif(dp[e.t][ns][dd.v]>nc || dp[e.t][ns][dd.v]==-1.0){\n\t\t\t\t\tdp[e.t][ns][dd.v]=nc;\n\t\t\t\t\tdata2 nd;\n\t\t\t\t\tnd.v=e.t;\n\t\t\t\t\tnd.cost=nc;\n\t\t\t\t\tnd.s=ns;\n\t\t\t\t\tnd.p=dd.v;\n\t\t\t\t\tque.push(nd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n+m==0)break;\n\t\tfor(int i=0;i<=n;i++)edge[i].clear();\n\t\tscanf(\"%d %d\",&s,&g);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y;\n\t\t\tdata dd;\n\t\t\tscanf(\"%d %d %d %d\",&x,&y,&dd.d,&dd.c);\n\t\t\tdd.t=y;\n\t\t\tedge[x].push_back(dd);\n\t\t\tdd.t=x;\n\t\t\tedge[y].push_back(dd);\n\t\t}\n\t\tdouble res=dijk();\n\t\tif(res!=-1.0)printf(\"%.9f\\n\",res);\n\t\telse printf(\"unreachable\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstruct edge{int to, dist, v;};\n\nvector<edge> G[35];\ndouble d[35][35];\nsigned main(void)\n{\n  while(true) {\n    int n, m, s, g;\n    cin >> n >> m;\n    if(!n && !m) break;\n    cin >> s >> g;\n    s--; g--;\n    REP(i, n) G[i].erase(ALL(G[i]));\n    REP(i, m) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      x--; y--;\n      G[x].PB((edge){y, d, c});\n      G[y].PB((edge){x, d, d});\n    }\n\n    priority_queue<vector<double>, vector<vector<double>>, greater<vector<double>>> pq;\n    pq.push({0, s, 0, -1});\n    REP(i, 35) REP(j, 35) d[i][j] = INF;\n    d[s][0] = 0;\n    while(pq.size()) {\n      vector<double> p = pq.top(); pq.pop();\n      int a = p[1], v = p[2], pa = p[3];\n      //cout << a << \" \" << v << endl;\n      if(a == g && v == 1) continue;\n      REP(i, G[a].size()) {\n        edge e = G[a][i];\n        if(e.to == pa) continue;\n        //v-1??¨v??¨v+1?????????\n        if(0 < v-1 && v-1 <= e.v && d[e.to][v-1] > d[a][v] + (double)e.dist/(v-1)) {\n          d[e.to][v-1] = d[a][v] + (double)e.dist/(v-1);\n          pq.push({d[e.to][v-1], e.to, v-1, a});\n        }\n        if(0 < v && v <= e.v && d[e.to][v] > d[a][v] + (double)e.dist/(v)){\n          d[e.to][v] = d[a][v] + (double)e.dist/(v);\n          pq.push({d[e.to][v], e.to, v, a});\n        }\n        if(0 < v+1 && v+1 <= e.v && d[e.to][v+1] > d[a][v] + (double)e.dist/(v+1)) {\n          d[e.to][v+1] = d[a][v] + (double)e.dist/(v+1);\n          pq.push({d[e.to][v+1], e.to, v+1, a});\n        }\n      }\n    }\n    if(d[g][1] == INF) cout << \"unreachable\" << endl;\n    else cout << fixed << setprecision(10) << d[g][1] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cmath>\n#include <tuple>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\ntypedef tuple<double, int, int, int> T;\t//(cost, pos, prev_pos, speed)\n\ndouble INF = 1e+9;\nint n, m;\nint s, g;\nvector<int> et[30];\nvector<int> ec[30];\nvector<int> es[30];\ndouble dp[30][30][31];\t//dp[pos][prev_pos][speed] = minCost\n\nint main() {\n\tint i;\n\t\n\twhile (cin >> n >> m) {\n\t\tif (!n) break;\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\t\t\n\t\tint i, j, k;\n\t\t\n\t\trep(i, n) {\n\t\t\tet[i].clear();\n\t\t\tec[i].clear();\n\t\t\tes[i].clear();\n\t\t}\n\t\t\n\t\trep(i, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tet[x].push_back(y);\n\t\t\tec[x].push_back(d);\n\t\t\tes[x].push_back(c);\n\t\t\tet[y].push_back(x);\n\t\t\tec[y].push_back(d);\n\t\t\tes[y].push_back(c);\n\t\t}\n\t\t\n\t\tpriority_queue<T, vector<T>, greater<T>> que;\n\t\trep(i, n) rep(j, n) rep(k, 31) dp[i][j][k] = INF;\n\t\t\n\t\tdp[s][s][0] = 0;\n\t\tque.push(T(0, s, s, 0));\n\t\twhile (!que.empty()) {\n\t\t\tT now = que.top(); que.pop();\n\t\t\tdouble cst = get<0>(now);\n\t\t\tint pos = get<1>(now);\n\t\t\tint pre = get<2>(now);\n\t\t\tint speed = get<3>(now);\n\t\t\t\n\t\t\trep(i, et[pos].size()) {\n\t\t\t\tint npos = et[pos][i];\n\t\t\t\tif (npos == pre) continue;\n\t\t\t\tfor (j = -1; j <= 1; j++) {\n\t\t\t\t\tint nspeed = speed + j;\n\t\t\t\t\tif (nspeed <= 0 || nspeed > es[pos][i]) continue;\n\t\t\t\t\tdouble ncst = cst + (double)ec[pos][i] / nspeed;\n\t\t\t\t\tif (dp[npos][pos][nspeed] > ncst) {\n\t\t\t\t\t\tdp[npos][pos][nspeed] = ncst;\n\t\t\t\t\t\tque.push(T(ncst, npos, pos, nspeed));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//dp[g][*][1]\n\t\tdouble ans = INF;\n\t\trep(i, n) {\n\t\t\tans = min(ans, dp[g][i][1]);\n\t\t}\n\t\tif (ans >= INF) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%.14f\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<cstdio>\nusing namespace std;\n#define MAX 50\n#define INF (1<<28)\n#define EPS (1e-8)\nstruct edge{ int to,cost,l; };\nstruct state{\n  int pos,prev,v;\n  double cost;\n  bool operator < (const state& p)const{return cost > p.cost;}\n};\n\nint n,m,si,ti;\nvector<edge> G[MAX];\ndouble d[MAX][MAX][MAX];\n\nvoid init(){\n  for(int i=0;i<MAX;i++){\n    G[i].clear();\n    for(int j=0;j<MAX;j++)\n      for(int k=0;k<MAX;k++)\n\td[i][j][k]=INF;\n  }\n}\nvoid solve(){\n  priority_queue<state> Q;\n  Q.push((state){si,n,0,0});\n  d[si][n][0]=0;\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.pos==ti&&s.v==1){printf(\"%.8f\\n\",s.cost);return;}\n    if(s.cost>EPS+d[s.pos][s.prev][s.v])continue;\n    for(int i=0;i<(int)G[s.pos].size();i++){\n      edge e=G[s.pos][i];\n      if(e.to==s.prev)continue;\n      for(int j=-1;j<=1;j++){\n\tint nv=s.v+j;\n\tif(nv<=0||e.l<nv)continue;\n\tdouble ncost=s.cost+(double)e.cost/nv;\n\tif(nv<=e.l&&nv>0&&ncost<d[e.to][s.pos][nv]-EPS){\n\t  d[e.to][s.pos][nv]=ncost;\n\t  Q.push((state){e.to,s.pos,nv,ncost});\n\t}\n      }\n    }\n  }\n  cout<<\"unreachable\"<<endl;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(n==0&&m==0)break;\n    init();\n    cin>>si>>ti;\n    si--,ti--;\n    for(int i=0;i<m;i++){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      a--,b--;\n      G[a].push_back((edge){b,c,d});\n      G[b].push_back((edge){a,c,d});\n    }\n    solve();\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S second\n#define F first\n#define EPS (1e-7)\n#define INF (1e9)\n#define N 31\nusing namespace std;\ntypedef pair<int,int> P1;\ntypedef pair<int,P1> P2;\ntypedef pair<int,P1> P3;\ntypedef pair<P3,int> P4;\n\nvector<P2> G[N];\nint n,m,s,g;\n\ndouble dijkstra(){\n  double d[N][N][N];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<N;k++)\n\td[i][j][k]=INF;\n  priority_queue<P4,vector<P4>,greater<P4> > q;\n  for(int i=0;i<G[s].size();i++){\n    int nx=G[s][i].first,cost=G[s][i].second.first;\n    d[s][nx][1]=cost;\n    q.push(P4(P3(cost,P1(s,nx)),1));\n  }\n  while(!q.empty()){\n    P4 t=q.top(); q.pop();\n    int px=t.F.S.F,x=t.F.S.S,v=t.S;\n    double cost=t.F.F;\n    if(d[px][x][v]+EPS<cost)continue;\n    if(x==g&&v==1)return cost;\n    for(int i=0;i<G[x].size();i++){\n      int nx=G[x][i].F,cost2=G[x][i].S.F;\n      int lim=G[x][i].S.S;\n      if(nx==px)continue;\n      for(int j=-1;j<=1;j++){\n\tint nv=v+j;\n\tif(nv<1||30<nv||nv>lim)continue;\n\tdouble ncost=cost+1.0*cost2/nv;\n\tif(d[x][nx][nv]>ncost+EPS){\n\t  d[x][nx][nv]=ncost;\n\t  q.push(P4(P3(ncost,P1(x,nx)),nv));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    cin>>s>>g;\n    s--,g--;\n    int a,b,c,d;\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>c>>d;\n      a--,b--;\n      G[a].push_back(P2(b,P1(c,d)));\n      G[b].push_back(P2(a,P1(c,d)));\n    }\n    double r=dijkstra();\n    if(r==-1)cout<<\"unreachable\"<<endl;\n    else printf(\"%.5f\\n\",r);\n    for(int i=0;i<n;i++)G[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define fr first\n#define sc second\nusing namespace std;\n#define INF 10000000\ntypedef pair<int,int> iiP;\ntypedef pair<double,int> diP;\ntypedef pair<diP,iiP> PP;\nstruct edge{\n  int to,limit;\n  double dist;\n  edge(){}\n  edge(int to,double dist,int limit):to(to),dist(dist),limit(limit){};\n};\nint n,m;\nint S,G;\ndouble t[31][31][31];\nbool used[31][31][31];\nint main(){\n\n  while(cin >> n >> m && (n||m)){\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n        for(int k=0;k<31;k++){\n          used[i][j][k] = false;\n          t[i][j][k] = INF;\n        }\n      }\n    }\n    cin >> S >> G;\n    vector< vector<edge> > info(n + 1);\n    for(int i=0,x,y,d,c;i<m;i++){\n      cin >> x >> y >> d >> c;\n      info[x].push_back(edge(y,d,c));\n      info[y].push_back(edge(x,d,c));\n    }\n\n    t[S][0][0] = 0.0;\n    priority_queue< PP,vector<PP>,greater<PP> > que;\n    que.push(PP(diP(0.0,S),iiP(0,0)));\n    while(!que.empty()){\n      PP p = que.top();\n      int now = p.fr.sc,prev = p.sc.fr,speed = p.sc.sc;\n      double time = p.fr.fr;\n\n      que.pop();\n      if( used[now][prev][speed] ) continue;\n      used[now][prev][speed] = true;\n\n      for(int i = 0,l = info[now].size();i < l;i++){\n        edge e = info[now][i];\n        if(e.to != prev){\n          for(int j = -1;j < 2;j++){\n            if(speed + j > 0 && speed + j <= e.limit && !used[e.to][now][speed + j]){\n              if(t[e.to][now][speed + j] > time + e.dist / (speed + j)){\n                t[e.to][now][speed + j] = time + e.dist / (speed + j);\n                que.push(PP(diP(t[e.to][now][speed + j],e.to),iiP(now,speed + j)));\n              }\n            }\n          }\n        }\n      }\n    }\n    double ans = INF;\n    for(int i=0;i<=n;i++) ans = min(ans,t[G][i][S]);\n    if(ans == INF) cout << \"unreachable\" << endl;\n    else{\n      cout << fixed << setprecision(7) << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<pair<int,int>,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a2,a4;\ndouble d[31][31],a3;\nint dx[]={-1,0,1};\nint main(){\n  while(cin>>n>>m,n){\n    vector<edge> v[31];\n    r(i,31)r(j,31)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      scanf(\"%d%d%lf%d\",&a1,&a2,&a3,&a4);\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P>q;\n    d[st][0]=0;\n    P xt;xt.fi.fi=0,xt.fi.se=st,xt.se=-1;\n    q.push(xt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.fi.se;\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=p.se)r(j,3){\n          int x=p.fi.fi+dx[j];\n          if(0<x&&x<=e.lim){\n            if(d[e.to][x]>e.dist/x+d[cur][p.fi.fi]){\n              d[e.to][x]=e.dist/x+d[cur][p.fi.fi];\n              xt.fi.fi=x,xt.fi.se=e.to,xt.se=cur;\n              //if(go&&d[e.to][x]>100)cout<<d[e.to][x]<<endl;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstruct P {\n\tint to, c, d;\n};\nvector<P>E[30];\ndouble d[30][31][30];\n\nstruct st {\n\tint p, h, pr; double c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tint s, g; scanf(\"%d%d\", &s, &g); s--; g--;\n\t\trep(i, n)E[i].clear();\n\t\trep(i, m) {\n\t\t\tint x, y, d, c; scanf(\"%d%d%d%d\", &x, &y, &d, &c); x--; y--;\n\t\t\tE[x].push_back({ y,c,d }); E[y].push_back({ x,c,d });\n\t\t}\n\t\tpriority_queue<st>que;\n\t\tfill(d[0][0], d[30][0], INF);\n\t\tfor (P v : E[0]) {\n\t\t\td[v.to][1][0] = v.d; que.push({ v.to,1,0,d[v.to][1][0] });\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.p][p.h][p.pr] != p.c)continue;\n\t\t\tfor (P v : E[p.p]) {\n\t\t\t\tif (v.to == p.pr)continue;\n\t\t\t\tif (p.h > 1 && p.h - 1 <= v.c) {\n\t\t\t\t\tif (d[v.to][p.h - 1][p.p] > p.c + v.d / double(p.h - 1)) {\n\t\t\t\t\t\td[v.to][p.h - 1][p.p] = p.c + v.d / double(p.h - 1);\n\t\t\t\t\t\tque.push({ v.to,p.h - 1,p.p,d[v.to][p.h - 1][p.p] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (p.h < v.c) {\n\t\t\t\t\tif (d[v.to][p.h + 1][p.p] > p.c + v.d / double(p.h + 1)) {\n\t\t\t\t\t\td[v.to][p.h + 1][p.p] = p.c + v.d / double(p.h + 1);\n\t\t\t\t\t\tque.push({ v.to,p.h + 1,p.p,d[v.to][p.h + 1][p.p] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (p.h <= v.c) {\n\t\t\t\t\tif (d[v.to][p.h][p.p] > p.c + v.d / double(p.h)) {\n\t\t\t\t\t\td[v.to][p.h][p.p] = p.c + v.d / double(p.h);\n\t\t\t\t\t\tque.push({ v.to,p.h,p.p,d[v.to][p.h][p.p] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble Min = INF;\n\t\trep(i, n)Min = min(Min, d[g][1][i]);\n\t\tif (Min == INF)puts(\"unreachable\");\n\t\telse printf(\"%.7lf\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-6;\n\nstruct road\n{\n  int node, len, limit;\n  road() {}\n  road(int x, int d, int c) : node(x), len(d), limit(c) {}\n};\n\nstruct state\n{\n  int p, n, v;\n  double c;\n  state(int prev, int node, int velocity, double cost) : p(prev), n(node), v(velocity), c(cost) {}\n  bool operator<(const state& that) const { return c > that.c; }\n};\n\nint main()\n{\n  int N, M;\n  while (scanf(\"%d %d\", &N, &M) != EOF && N != 0) {\n    int S, G;\n    scanf(\"%d %d\", &S, &G);\n    --S;  --G;\n    vector<vector<road> > g(N);\n    for (int i = 0; i < M; i++) {\n      int x, y, d, c;\n      scanf(\"%d %d %d %d\", &x, &y, &d, &c);\n      --x;  --y;\n      g[x].push_back(road(y, d, c));\n      g[y].push_back(road(x, d, c));\n    }\n    vector<vector<vector<double> > > dist(N, vector<vector<double> >(N, vector<double>(31, 1e7)));\n    dist[S][S][0] = 0.0;\n    priority_queue<state> q;\n    q.push(state(S, S, 0, 0.0));\n    double ans = 1e7;\n    while (!q.empty()) {\n      const int prev = q.top().p;\n      const int n = q.top().n;\n      const int v = q.top().v;\n      const double cost = q.top().c;\n      q.pop();\n      if (n == G && v == 1) {\n        ans = min(ans, cost);\n        continue;\n      }\n      for (vector<road>::const_iterator it(g[n].begin()); it != g[n].end(); ++it) {\n        if (it->node == prev) {\n          continue;\n        }\n        for (int d = -1; d <= 1; d++) {\n          if (v+d >= 1 && v+d <= it->limit) {\n            const double c = cost + double(it->len) / (v+d);\n            if (dist[prev][it->node][v+d] - c > EPS) {\n              dist[prev][it->node][v+d] = c;\n              q.push(state(n, it->node, v+d, c));\n            }\n          }\n        }\n      }\n    }\n    if (ans >= 1e7) {\n      puts(\"unreachable\");\n    } else {\n      printf(\"%.4f\\n\", ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int INF = 1e15;\n\nstruct Edge {\n  int to, d, c;  \n};\n\nint s, g;\nint n, m;\nvector<Edge> G[31];\n\ntypedef pair<int, int> P;\ntypedef pair<double, int> E;\ntypedef pair<E, P> PE;\n\ndouble dij() {\n  double ret = INF;  \n  int used[n][101];\n  fill_n(*used, n*101, 0);\n  priority_queue<PE, vector<PE>, greater<PE> > q;  \n  q.push(PE(E(0, -1), P(s, 1)));  \n  while ( !q.empty() ) {\n    PE e = q.top(); q.pop();    \n    double c = e.first.first;\n    int pre = e.first.second;    \n    int u = e.second.first, v = e.second.second;\n    // cout << u << \" \" << v << endl;\n    if ( u == g && v == 1 ) {\n      \n    }\n\n    if ( used[u][v] >= 2 ) continue;\n    used[u][v]++;    \n    for ( Edge &f : G[u] ) {\n      if ( pre == f.to ) continue;      \n      if ( f.c < v ) continue;\n      if ( f.to == g && v == 1 ) {\n\tret = min(ret, c+(double)f.d);\t\n      }\n      q.push(PE(E(c+(double)f.d/v, u), P(f.to, v)));      \n      q.push(PE(E(c+(double)f.d/v, u), P(f.to, v+1)));\n      if ( v >= 2 ) q.push(PE(E(c+(double)f.d/v, u), P(f.to, v-1)));      \n    }\n  }\n\n  return ret;\n}\n\nsigned main() {  \n  while ( cin >> n >> m, n ) {\n    for ( int i = 0; i < 31; i++ ) G[i].clear();    \n    cin >> s >> g;\n    s--; g--;\n    for ( int i = 0; i < m; i++ ) {\n      int a, b, d, c;\n      cin >> a >> b >> d >> c;\n      a--; b--;\n      G[a].emplace_back(Edge{b, d, c});\n      G[b].emplace_back(Edge{a, d, c});\n    }\n\n    double ans = dij();\n    if ( ans >= INF-100 ) cout << \"unreachable\" << endl;\n    else printf(\"%.10lf\\n\", ans);    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stdlib.h>\n#define EPS (1.0e-9)\n#define LT(x, y) ((x) - (y) <= -EPS) // x < y\n#define INF (1<<19)\nusing namespace std;\ntypedef struct DisLim {\n int d, c; // dist, limit v\n DisLim() {}\n DisLim(int d, int c) : d(d),c(c) {}\n} DisLim;\nint N,M;\nint S,G; // start, goal\nDisLim F[31][31];\n\ndouble dist[31][31][31];\nbool visited[31][31][31];\nclass State {\npublic:\n int bpos, cpos; // before,current\n double d; // ツ仰猟猟」\n int v; // ツ堕ャツ度\n State (int bpos, int cpos, double d, int v) :\n   bpos(bpos),cpos(cpos),d(d),v(v) {}\n bool operator < (const State &s) const {\n   //return d > s.d;\n   return LT(s.d,d);\n }\n};\n\npriority_queue<State> PQ;\ndouble solve() {\n  while(!PQ.empty()) {\n    State u = PQ.top(); PQ.pop();\n    int bpos=u.bpos, cpos=u.cpos, v=u.v;\n    double d = u.d;\n    \n    visited[bpos][cpos][v] = true;\n    if(cpos == G && v == 1) {\n      return dist[bpos][G][1];\n    }\n\n    for(int i=1;i<=N;i++) { // ツ篠淞づ個都ツ市\n      if(i==bpos || i==cpos) continue; // ツ古」ツ姪淞づィツ凝鳴止\n      for(int j=-1;j<=1;j++) { // ツ嘉個クツ堕ャツ堕閉置\n\tif(bpos==S && S==cpos && j != 0) continue;\n\tif(v+j <= 0) continue;\n\tif(v+j > F[cpos][i].c) continue;\n\tif(visited[cpos][i][v+j]) continue;\n\tif(F[cpos][i].d >= INF) continue;\n\tdouble cost = dist[bpos][cpos][v] + (double)F[cpos][i].d / (v+j);\n\tif(LT(cost,dist[cpos][i][v+j])) {\n\t  dist[cpos][i][v+j] = cost;\n\t  PQ.push(State(cpos,i,cost,v+j));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nmain() {\n while(cin>>N>>M,N) {\n   PQ = priority_queue<State>();\n   memset(visited,0,sizeof(visited));\n   for(int i=1;i<=N;i++) {\n     for(int j=1;j<=N;j++) {\n       F[i][j].d=INF;\n     }\n   }\n   cin>>S>>G;\n   for(int i=1;i<=N;i++) {\n     for(int j=1;j<=N;j++) {\n       for(int k=0;k<31;k++) {\n         dist[i][j][k] = INF;\n       }\n     }\n   }\n   for(int i=0;i<31;i++) {\n     dist[S][S][i] = 0;\n   }\n   PQ.push(State(S,S,0,1));\n   for(int i=0;i<M;i++) {\n     int x,y,d,c; cin>>x>>y>>d>>c;\n     F[x][y]=F[y][x]=DisLim(d,c);\n   }\n   double ans = solve();\n   if(ans==-1) puts(\"unreachable\");\n   else printf(\"%.5lf\\n\",ans);\n }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> P;\nstruct edge{int to;double cost;};\n\nint n,m,s,go;\ndouble d[27002];\nvector<edge> g[27002];\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > q;\n\tfill(d,d+27002,INF);\n\td[s]=0;\n\tq.push(P(0,s));\n\twhile(!q.empty()){\n\t\tP p=q.top();q.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first||v==1)continue;\n\t\trep(i,g[v].size()){\n\t\t\tedge e=g[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>m&&n){\n\t\trep(i,27002)g[i].clear();\n\t\tcin>>s>>go;s--;go--;\n\t\tedge e;\n\t\trep(i,n){\n\t\t\te.to=1;\n\t\t\te.cost=0;\n\t\t\tg[i*n+go+2].push_back(e);\n\t\t}\n\t\trep(i,m){\n\t\t\tint x,y,c;\n\t\t\tdouble dd;\n\t\t\tcin>>x>>y>>dd>>c;\n\t\t\tx--;y--;\n\t\t\trep(v,c+2)rep(p,n){\n\t\t\t\tif(v==31)break;\n\t\t\t\tif(v==0){\n\t\t\t\t\tif(x==s){\n\t\t\t\t\t\te.to=x*n+y+2;\n\t\t\t\t\t\te.cost=dd;\n\t\t\t\t\t\tg[0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\tif(y==s){\n\t\t\t\t\t\te.to=y*n+x+2;\n\t\t\t\t\t\te.cost=dd;\n\t\t\t\t\t\tg[0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int j=-1;j<2;j++){\n\t\t\t\t\t\tif(v+j>0&&v+j<=c&&p!=x&&p!=y){\n\t\t\t\t\t\t\te.to=(v+j-1)*n*n+x*n+y+2;\n\t\t\t\t\t\t\te.cost=dd/(v+j);\n\t\t\t\t\t\t\tg[(v-1)*n*n+p*n+x+2].push_back(e);\n\t\t\t\t\t\t\te.to=(v+j-1)*n*n+y*n+x+2;\n\t\t\t\t\t\t\tg[(v-1)*n*n+p*n+y+2].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(0);\n\t\tif(d[1]<INF)cout<<d[1]<<endl;\n\t\telse cout<<\"unreachable\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<map>\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\ntypedef struct {\n    int dis;\n    int lim;\n} edge;\ntypedef pair<int,int> pp;\ntypedef pair<int, pp> node; // v, (x,y)\ntypedef pair<double, node> que; // sum, (v, (x,y))\n\nedge input[50][50];\ndouble G[50][50][50]; // x, y, v\n\nint main(void) {\n    while(1) {\n        int n,m,s,g;\n        scanf(\"%d%d\",&n,&m);\n        if(!n) break;\n        scanf(\"%d%d\",&s,&g);\n        s--, g--;\n\n        memset(input, 0, sizeof(input));\n        memset(G, 0, sizeof(G));\n\n        for(int i=0; i<m; i++) {\n            int x,y,d,c;\n            scanf(\"%d%d%d%d\",&x,&y,&d,&c);\n            x--, y--;\n            input[x][y] = input[y][x] = {d,c};\n        }\n\n        map<node,double> tbl;\n        priority_queue<que> q;\n        for(int i=0; i<n; i++)\n            if(input[s][i].dis)\n                q.push(que(-0.0, node(1, pp(s,i))));\n\n        double res = 10000000.0;\n        while(q.size()) {\n            que t = q.top(); q.pop();\n\n            int v = t.snd.fst;\n            int x = t.snd.snd.fst, y = t.snd.snd.snd;\n\n            double sum = -t.fst + 1.0* input[x][y].dis / v;\n\n            if(tbl.find(t.snd) != tbl.end()) continue;\n            tbl[t.snd] = sum;\n\n            if(y == g && v == 1) {\n                res = res < sum ? res : sum;\n                continue;\n            }\n\n            for(int i=0; i<n; i++)\n                if(i!=x && input[y][i].dis) {\n                    int dv[] = {-1,0,1};\n                    for(int iv=0; iv<3; iv++)\n                        if(0<v+dv[iv] && v+dv[iv]<=input[y][i].lim)\n                            q.push(que(-sum, node(v+dv[iv], pp(y,i))));\n                }\n        }\n        if(res>1000000.0)\n            puts(\"unreachable\");\n        else\n            printf(\"%f\\n\", res);\n\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n \nstruct State {\n  int prev;\n  int now;\n  int vel; // 到着時\n  double e_time;\n   \n  bool operator < (const State &s) const {\n    return e_time > s.e_time;\n  }\n   \n  State() {}\n  State(int p, int n, int v, double t) :\n    prev(p), now(n), vel(v), e_time(t) {}\n};\n \nstruct Edge {\n  int to;\n  int cost;\n  int lim;\n   \n  Edge() {}\n  Edge(int t, int c, int l) : to(t), cost(c), lim(l) {}\n};\n \nconst double Inf = 1<<23;\nint N, M;\nvector<Edge> edges[30];\ndouble G_time[31][30][31]; // u, v, vel -> e_time\n \ndouble dijkstra(int s, int g) {\n   \n  fill(G_time[0][0], G_time[30][30], Inf);\n  priority_queue<State> pq;\n   \n  pq.push(State(s, s, 0, 0.0));\n  G_time[s][s][0] = 0.0;\n   \n  while(!pq.empty()) {\n    const State st = pq.top(); pq.pop();\n     \n    if(G_time[st.prev][st.now][st.vel] < st.e_time) {\n      continue;\n    }\n     \n    if(st.now == g && st.vel == 1) {\n      return st.e_time;\n    }\n     \n    for(int i=0; i<edges[st.now].size(); i++) {\n      const Edge &e = edges[st.now][i];\n       \n      for(int dvel = -1; dvel <= 1; dvel ++) {\n    int nvel = st.vel + dvel;\n    // 速度制限\n    if(1 <= nvel && nvel <= e.lim) {\n      double ntime = st.e_time + (double)e.cost / nvel;\n      if(G_time[st.now][e.to][nvel] > ntime) {\n        G_time[st.now][e.to][nvel] = ntime;\n        pq.push(State(st.now, e.to, nvel, ntime));\n      }\n    }\n     \n      }\n    }\n  }\n   \n  return 42;\n}\n \nint main() {\n  int s, g;\n   \n  while(cin >> N >> M && (N|M)) {\n    cin >> s >> g;\n    s --, g --;\n     \n    for(int i=0; i<N; i++)\n      edges[i].clear();\n     \n    for(int i=0; i<M; i++) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      x --, y --;\n      edges[x].push_back(Edge(y, d, c));\n      edges[y].push_back(Edge(x, d, c));\n    }\n     \n    double ans = dijkstra(s, g);\n    if(ans == 42) {\n      cout << \"unreachable\" << endl;\n    } else {\n      printf(\"%.5lf\\n\", ans);\n    }\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n\nusing namespace std;\n\nconst double inf=1e8;\n\nint d[31][31];\nint c[31][31];\ndouble dist[31][31][31];\n\nint n,m,s,g;\n\ntypedef tuple<double,int,int,int> state;\nvoid dijkstra(){\n\trep(i,n+1)rep(j,31)rep(k,n+1) dist[i][j][k]=inf;\n\tstate init=make_tuple(0.0,s,0,0);\n\tdist[s][0][0]=0;\n\tpriority_queue<state,vector<state>,greater<state>>q;\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tdouble cost;\n\t\tint cur,v,prev;\n\t\ttie(cost,cur,v,prev)=q.top();q.pop();\n\t\trep(i,n+1){\n\t\t\tif(prev==i) continue;\n\t\t\tif(d[cur][i]==inf) continue;\n\t\t\tfor(int dv=-1;dv<=1;++dv){\n\t\t\t\tint ncur=i,nv=v+dv,nprev=cur;\n\t\t\t\tif(nv<=0||c[nprev][ncur]<nv) continue;\n\t\t\t\tdouble ncost=cost+1.0*d[nprev][ncur]/(nv);\n\t\t\t\tif(dist[ncur][nv][nprev]>ncost){\n\t\t\t\t\tdist[ncur][nv][nprev]=ncost;\n\t\t\t\t\tq.push(make_tuple(ncost,ncur,nv,nprev));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans=inf;\n\trep(i,n+1) ans=min(ans,dist[g][1][i]);\n\tcout.precision(10);\n\tif(ans==inf)\n\t\tcout << \"unreachable\" << endl;\n\telse\n\t\tcout << fixed << ans << endl;\n}\n\nint main(void){\n\twhile(cin >> n >> m){\n\t\tif(n==0&&m==0) break;\n\t\tcin >> s >> g;\n\t\trep(i,n+1)rep(j,n+1) d[i][j]=c[i][j]=inf;\n\t\trep(i,m){\n\t\t\tint x,y,dd,cc;\n\t\t\tcin >> x >> y >> dd >> cc;\n\t\t\td[x][y]=d[y][x]=dd,c[x][y]=c[y][x]=cc;\n\t\t}\n\t\tdijkstra();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\n#define EPS (double)1e-9\n#define INF (double)1e9\n#define MAX_SPEED 30\n\nvector<vector<vector<double> > > dijk(int s_point, int s_speed, vector<vector<vector<pair<double, pair<int, int> > > > >& adj){\n  int v = adj.size();\n  int t = adj[0].size();\n  vector<vector<vector<double> > > result(v, vector<vector<double> >(v, vector<double>(t, INF)));\n  priority_queue<pair<double, pair<int, pair<int, int> > > > wait;\n  wait.push(make_pair(0, make_pair(0, make_pair(s_point, s_speed))));\n  for(int i = 0; i < v; i++){ result[s_point][i][s_speed] = 0; }\n  \n  while(!wait.empty()){\n    double nowcost = -wait.top().first;\n    int prevpoint = wait.top().second.first;\n    int nowpoint = wait.top().second.second.first;\n    int nowspeed = wait.top().second.second.second;\n    wait.pop();\n    if(result[nowpoint][prevpoint][nowspeed] + EPS < nowcost){ continue; }\n\n    for(size_t i = 0; i < adj[nowpoint][nowspeed].size(); i++){\n      double nextcost = adj[nowpoint][nowspeed][i].first + nowcost;\n      int nextpoint = adj[nowpoint][nowspeed][i].second.first;\n      int nextspeed = adj[nowpoint][nowspeed][i].second.second;\n      if(nextpoint != prevpoint && result[nextpoint][nowpoint][nextspeed] - EPS > nextcost){\n        wait.push(make_pair(-nextcost, make_pair(nowpoint, make_pair(nextpoint, nextspeed))));\n        result[nextpoint][nowpoint][nextspeed] = nextcost;\n      }\n    }\n  }\n\n  return result;\n}\n\nint main(void){\n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    int s, g;\n    cin >> s >> g;\n\n    int x, y, d, c;\n    vector<vector<vector<pair<double, pair<int, int> > > > > adjlist(n + 1,\n                                                                     vector<vector<pair<double, pair<int, int> > > >(MAX_SPEED + 1));\n    for(int i = 0; i < m; i++){\n      cin >> x >> y >> d >> c;\n      for(int j = 0; j <= MAX_SPEED; j++){\n        if(1 <= j - 1 && j - 1 <= c){\n          adjlist[x][j].push_back(make_pair((double)d / (j - 1), make_pair(y, j - 1)));\n          adjlist[y][j].push_back(make_pair((double)d / (j - 1), make_pair(x, j - 1)));\n        }\n        if(1 <= j && j <= c){\n          adjlist[x][j].push_back(make_pair((double)d / j, make_pair(y, j)));\n          adjlist[y][j].push_back(make_pair((double)d / j, make_pair(x, j)));\n        }\n        if(j + 1 <= c){\n          adjlist[x][j].push_back(make_pair((double)d / (j + 1), make_pair(y, j + 1)));\n          adjlist[y][j].push_back(make_pair((double)d / (j + 1), make_pair(x, j + 1)));\n        }\n      }\n    }\n    \n    double ans = INF;\n    vector<vector<vector<double> > > result = dijk(s, 0, adjlist);\n    for(int i = 0; i < n; i++){ ans = min(ans, result[g][i][1]); }\n    if(ans + EPS >= INF){ printf(\"unreachable\\n\"); }\n    else{ printf(\"%.10f\\n\", ans); }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct status {\n    int pos;\n    double dist;\n    int vel;\n    int prev;\n\n    status () {}\n    ~status () {}\n\n    status(int a, double b, int c, int d): pos(a), dist(b), vel(c), prev(d) {}\n\n    bool operator < (const status& o) const {\n        return dist < o.dist;\n    }\n\n    bool operator > (const status& o) const {\n        return dist > o.dist;\n    }\n};\n\nstruct edge {\n    int to;\n    double dist;\n    int lim;\n\n    edge () {}\n    ~edge () {}\n\n    edge(int a, double b, int c): to(a), dist(b), lim(c) {}\n};\n\nconst int INF = 1 << 29;\n\nbool solve() {\n    int n, m, s, g;\n    /*\n     * n <- [1..20]\n     * m <- [1..?]\n     * s, g <- [1..n]\n     * (x, y, d, c)\n     *   x, y <- [1..n]\n     *   d <- [1..100]\n     *   c <- [1..30]\n     */\n    cin >> n >> m >> s >> g;\n\n    if (n == 0 && m == 0 && s == 0 && g == 0) return false;\n\n    --s; --g;\n\n    vector<vector<edge>> graph(n, vector<edge>(0));\n\n    for (int j = 0; j < m; ++j) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        --x; --y;\n        graph[x].push_back(edge(y, d, c));\n        graph[y].push_back(edge(x, d, c));\n    }\n\n    vector<vector<double>> dist(n, vector<double>(30 + 1, INF));\n    priority_queue<status, vector<status>, greater<status>> que;\n\n    dist[s][0] = 0;\n    que.push(status(s, 0.0, 0, -1));\n\n    while (!que.empty()) {\n        status st = que.top(); que.pop();\n\n        if (dist[st.pos][st.vel] < st.dist) {\n            continue;\n        }\n\n        if (st.pos == g && st.vel == 1) {\n            break;\n        }\n\n        for (edge& e : graph[st.pos]) {\n            if (e.to == st.prev) continue;\n\n            for (int a = -1; a <= 1; ++a) {\n                int nv = st.vel + a;\n                if (nv <= 0) continue;\n\n                double d = st.dist + e.dist / nv;\n\n                if (nv <= e.lim && d < dist[e.to][nv]) {\n                    dist[e.to][nv] = d; \n                    que.push(status(e.to, d, nv, st.pos));\n                }\n            }\n        }\n    }\n\n    if (dist[g][1] == INF) {\n        printf(\"unreachable\\n\");\n    } else {\n        printf(\"%.10f\\n\", dist[g][1]);\n    }\n\n    return true;\n}\n\nint main () {\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tstatic int adj[30][30],lim[30][30];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)\tadj[i][j]=-1;\n\n\t\tint s,g;\tscanf(\"%d%d\",&s,&g);\n\t\ts--,g--;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,l;\tscanf(\"%d%d%d%d\",&x,&y,&d,&l);\n\t\t\tx--,y--;\n\t\t\tadj[x][y]=adj[y][x]=d;\n\t\t\tlim[x][y]=lim[y][x]=l;\n\t\t}\n\n\t\tstatic bool visited[30][31];\n\t\tstatic double tmin[30][31];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<=30;j++){\n\t\t\tvisited[i][j]=false;\n\t\t\ttmin[i][j]=1<<30;\n\t\t}\n\n\t\ttmin[s][0]=0;\n\t\tpriority_queue< pair<double,pii> > pq;\tpq.push(mp(0,mp(s,0)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<double,pii> a=pq.top();\tpq.pop();\n\t\t\tint u=a.second.first,sp=a.second.second;\n\t\t\tif(visited[u][sp])\tcontinue;\n//printf(\"t=%.3f, u=%d, speed=%d\\n\",-a.first,u,sp);\n\t\t\tvisited[u][sp]=true;\n\t\t\tif(u==g && sp==1)\tbreak;\n\n\t\t\tfor(int v=0;v<n;v++){\n\t\t\t\tif(adj[u][v]==-1)\tcontinue;\n//printf(\"  v candi %d\\n\",v);\n\t\t\t\tfor(int dv=-1;dv<=1;dv++){\n\t\t\t\t\tint nextsp=sp+dv;\n//printf(\"    nextspeed=%d, lim=%d\\n\",nextsp,lim[u][v]);\n//\t\t\t\t\tif(1<=nextsp && nextsp<=lim[u][v]){\n\t\t\t\t\tif(!visited[v][nextsp] && 1<=nextsp && nextsp<=lim[u][v]){\n\t\t\t\t\t\tdouble nextt=tmin[u][sp]+(double)adj[u][v]/nextsp;\n//printf(\"      passed. nextt=%.3f, tmin=%.3f\\n\",nextt,tmin[v][nextsp]);\n\t\t\t\t\t\tif(nextt<tmin[v][nextsp]){\n\t\t\t\t\t\t\tpq.push(mp(-nextt,mp(v,nextsp)));\n\t\t\t\t\t\t\ttmin[v][nextsp]=nextt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(visited[g][1])\tprintf(\"%f\\n\",tmin[g][1]);\n\t\telse\t\t\t\tputs(\"unreachable\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <tuple>\n#include <queue>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint n,m;\nint s,goal;\n\nstruct Edge {\n    int src, dst, d, c;\n    Edge(int a, int b, int d_, int c_)\n        : src(a), dst(b), d(d_), c(c_)\n    {}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint main(){\n    while(cin >> n >> m && n){\n        cin >> s >> goal;\n        Graph g(n+1);\n        rep(i,m){\n            int x,y,d,c;\n            cin >> x >> y >> c >> d;\n            g[x].emplace_back(x,y,c,d);\n            g[y].emplace_back(y,x,c,d);\n        }\n        // elapsed/t, cur/v, prev/p, speed/s\n        typedef tuple<double, int,int,int> State;\n        priority_queue<State> q;\n        // cur, prev, speed\n        double dist[40][40][40];\n        rep(i,40)rep(j,40)rep(k,40) dist[i][j][k] = 1e9;\n        q.emplace(1e-30, s,0,0);\n        dist[s][0][1] = 0;\n        double ans = 1e20;\n        while(q.size()){\n            double t;\n            int v, p, s;\n            tie(t,v,p,s) = q.top(); q.pop();\n            t *= -1;\n            // printf(\"state : %d %d %d %lf : %lf\\n\", v,p,s,t, dist[v][p][s]);\n            if(v == goal && s == 1){\n                ans = t;\n                break;\n            }\n            if(p != 0 && dist[v][p][s] < t) continue;\n            dist[v][p][s] = t;\n            for(auto & e : g[v]){\n                // if(e.src == 1 && e.dst == 2){\n                //     cout << e.d << endl;\n                // }\n                for(int ds : {-1,0,1}){\n                    int ns = s + ds;\n                    if(ns <= 0) continue;\n                    if(e.c < ns) continue;\n                    if(e.dst == p) continue;\n                    double dt = 1. * e.d / ns;\n                    double nt = t + dt;\n                    int np = v;\n                    int nv = e.dst;\n                    if(dist[nv][np][ns] > nt){\n                        dist[nv][np][ns] = nt;\n                        // printf(\"nstate : %d %d %d %lf : %lf\\n\", nv,np,ns,nt, dist[nv][np][ns]);\n                        q.emplace(-nt,nv,np,ns);\n                    }\n                }\n            }\n        }\n        if(ans == 1e20) puts(\"unreachable\");\n        else printf(\"%.20lf\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// (x,y)\ntypedef pair<int,int> P;\n// ( テゥツ?淌・ツコツヲ , (テ・ツ可催」ツ?ョテァツ板コ,テ、ツサツ甘」ツ?ョテァツ板コ) )\ntypedef pair<int,P> Node;\n// (cost,Node)\ntypedef pair<double,Node> State;\n\nconst int MAX_V = 31;\nconst double INF = 1e200;\n\nstruct edge{\n\tint to, d, c;\n\tedge(int to_, int d_, int c_){\n\t\tto = to_; d = d_; c = c_;\n\t}\n};\n\n// テ」ツつーテ」ツδゥテ」ツδ?\nvector<edge> G[MAX_V];\n// テ」ツつケテ」ツつソテ」ツδシテ」ツδ暗」ツ?凝」ツつ嘉」ツつエテ」ツδシテ」ツδォテ」ツ?ォティツセツソテ」ツつ甘」ツ?、テ」ツ?妥」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\nbool memo[MAX_V];\nbool is_connect;\n\n// テ・ツ?・テ・ツ環?\nint n, m;\n\n// テ・ツ按敕ヲツ慊淌・ツ個?\nvoid init(){\n\tis_connect = false;\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tG[i].clear();\n\t}\n}\n\n// ティツセツコテ」ツ?ョティツソツステ・ツ環?\nvoid add_edge(int x, int y, int d, int c){\n\tedge e( y , d , c );\n\tG[x].push_back( e );\n\te.to = x;\n\tG[y].push_back( e );\n}\n\n// テ」ツつケテ」ツつソテ」ツδシテ」ツδ暗」ツ?凝」ツつ嘉」ツつエテ」ツδシテ」ツδォテ」ツ?ォティツセツソテ」ツつ甘」ツ?、テ」ツ?妥」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ?凝」ツδ?」ツつァテ」ツδε」ツつッ\nvoid check(int v, int g){\n\tif( v == g ){\n\t\tis_connect = true;\n\t}\n\tif( memo[v] ) return;\n\tmemo[v] = true;\n\t\n\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\tint to = G[v][i].to;\n\t\tif( memo[to] ) continue;\n\t\tcheck( to , g );\n\t}\n}\n\n// テ」ツδ?」ツつ、テ」ツつッテ」ツつケテ」ツδ暗」ツδゥテヲツウツ?\ndouble solve(int s, int g){\n\t// d[v][x][y] := テゥツ?淌・ツコツヲv, テ・ツ可催」ツ?ョテァツ板コx, テ、ツサツ甘」ツ?ョテァツ板コyテ」ツ?セテ」ツ?ァテ」ツ?ョテヲツ慊?・ツーツ湘」ツつウテ」ツつケテ」ツδ?\n\tdouble d[31][31][31];\n\t// ティツィツェテ」ツつ古」ツ?淌」ツ?凝」ツ?ゥテ」ツ??」ツ??\n\tbool visited[31][31][31];\n\t// テ・ツ按敕ヲツ慊淌・ツ個?\n\tfor(int y=0 ; y < MAX_V ; y++ ){\n\t\tfor(int x=0 ; x < MAX_V ; x++ ){\n\t\t\tfor(int v=0 ; v < 31 ; v++ ){\n\t\t\t\td[v][y][x] = INF;\n\t\t\t\tvisited[v][y][x] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// State := (cost,Node), Node := ( テゥツ?淌・ツコツヲ , (テ・ツ可催」ツ?ョテァツ板コ,テ、ツサツ甘」ツ?ョテァツ板コ) )\n\tpriority_queue< State, vector<State> , greater<State> > q;\n\tfor(int i = 0 ; i < G[s].size() ; i++ ){\n\t\tint to = G[s][i].to;\n\t\tdouble dis = G[s][i].d;\n\t\t\n\t\tNode start( 1 , P(s,to) );\n\t\tq.push( State(dis,start) );\n\t\td[1][s][to] = dis;\n\t}\n\t\n\tdouble ans = INF;\n\tint cnt=0;\n\twhile( !q.empty() ){\n\t\t//cnt++;\n\t\t//if( cnt >= 2000000 ) break;\n\t\t\n\t\t// テ・ツ?、テ」ツつ津・ツ渉姪」ツつ甘・ツ?コテ」ツ??\n\t\tdouble now_cost = q.top().first;\n\t\tint v = q.top().second.first;\n\t\tint x = q.top().second.second.first;\n\t\tint y = q.top().second.second.second;\n\t\tq.pop();\n\t\t\n\t\tif( now_cost >= ans || visited[v][x][y] ) continue;\n\t\tvisited[v][x][y] = true;\n\t\t\n\t\t// テァツ崢ョテァツ堋?・ツ慊ーテ」ツ?ョテ」ツ?ィテ」ツ??\n\t\tif( y == g && v == 1 ){\n\t\t\tans = min( ans , now_cost );\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < G[y].size() ; i++ ){\n\t\t\tint to = G[y][i].to;\n\t\t\tint dis = G[y][i].d;\n\t\t\tint c = G[y][i].c;\n\t\t\tif( to == x ) continue;\n\t\t\t\n\t\t\tfor(int dv = -1 ; dv <= 1 ; dv++ ){\n\t\t\t\tint next_v = v + dv;\n\t\t\t\tif( next_v > c || next_v <= 0 ) continue;\n\t\t\t\t\n\t\t\t\tdouble cost = (double)dis / next_v;\n\t\t\t\tif( now_cost + cost < d[next_v][y][to] ){\n\t\t\t\t\td[next_v][y][to] = now_cost + cost;\n\t\t\t\t\t\n\t\t\t\t\tNode next( next_v , P(y,to) );\n\t\t\t\t\tState p( now_cost + cost , next );\n\t\t\t\t\tq.push( p );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile( scanf(\"%d %d\", &n, &m) , n || m ){\n\t\t// テ・ツ按敕ヲツ慊淌・ツ個?\n\t\tinit();\n\t\t\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\t\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tint x, y, d, c;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &d, &c );\n\t\t\tadd_edge( x , y , d , c );\n\t\t}\n\t\t\n\t\t{\n\t\t\t// テ」ツつケテ」ツつソテ」ツδシテ」ツδ暗」ツ?凝」ツつ嘉」ツつエテ」ツδシテ」ツδォテ」ツ?ォティツセツソテ」ツつ甘」ツ?、テ」ツ?妥」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\n\t\t\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\t\t\tmemo[i] = false;\n\t\t\t}\n\t\t\tcheck( s , g );\n\t\t}\n\t\t\n\t\t// テ」ツつエテ」ツδシテ」ツδォテ」ツ?ォティツセツソテ」ツつ甘」ツ?、テ」ツ?妥」ツ?ェテ」ツ??」ツ?ィテ」ツ??\n\t\tif( is_connect == false ){\n\t\t\tputs(\"unreachable\");\n\t\t}else{\n\t\t\tdouble ans = solve( s , g );\n\t\t\tprintf(\"%.4f\\n\", ans );\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nstruct Edge\n{\n\tint to, dist, limit;\n\tEdge( int t, int d, int l ) : to( t ), dist( d ), limit( l )\n\t{\n\t}\n};\n\nstruct State\n{\n\tint node, prev, speed;\n\tState( int n, int p, int s ) : node( n ), prev( p ), speed( s )\n\t{\n\t}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\treturn true;\n\t}\n};\n\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<VVD> VVVD;\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tcout << setprecision( 4 ) << fixed;\n\n\twhile ( true )\n\t{\n\t\tint n, m;\n\t\tcin >> n >> m;\n\n\t\tif ( !( n | m ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\ts--;\n\t\tg--;\n\n\t\tvector< vector<Edge> > G( n );\n\t\tREP( i, 0, m )\n\t\t{\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tG[x].PB( Edge( y, d, c ) );\n\t\t\tG[y].PB( Edge( x, d, c ) );\n\t\t}\n\n\t\tVVVD distance( n, VVD( n, VD( 31, DBL_MAX ) ) );\n\t\tdistance[s][s][0] = 0;\n\n\t\tpriority_queue< pair<double,State>, vector< pair<double,State> >, greater< pair<double,State> > > que;\n\t\tque.push( MP( 0, State( s, s, 0 ) ) );\n\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tint dist = que.top().fst;\n\t\t\tState cur = que.top().snd;\n\t\t\tque.pop();\n\n\t\t\tif ( distance[ cur.node ][ cur.prev ][ cur.speed ] < dist )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP( i, 0, G[ cur.node ].size() )\n\t\t\t{\n\t\t\t\tconst Edge &e = G[ cur.node ][i];\n\t\t\t\tif ( e.to == cur.prev )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tREP( ds, -1, 2 )\n\t\t\t\t{\n\t\t\t\t\tint nspeed = cur.speed + ds;\n\t\t\t\t\tif ( nspeed <= 0 || e.limit < nspeed )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( distance[ cur.node ][ cur.prev ][ cur.speed ] + 1. * e.dist / nspeed < distance[ e.to ][ cur.node ][ nspeed ] )\n\t\t\t\t\t{\n\t\t\t\t\t\tdistance[ e.to ][ cur.node ][ nspeed ] = distance[ cur.node ][ cur.prev ][ cur.speed ] + 1. * e.dist / nspeed;\n\t\t\t\t\t\tque.push( MP( distance[ e.to ][ cur.node ][ nspeed ], State( e.to, cur.node, nspeed ) ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble res = DBL_MAX;\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tres = min( res, distance[g][i][1] );\n\t\t}\n\n\t\tif ( res == DBL_MAX )\n\t\t{\n\t\t\tcout << \"unreachable\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << res;\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1000000\n\nusing namespace std;\n\nint n,m;\n\nstruct edge {\n\tint t;\n\tint dis;\n\tint lim;\n};\n\nstruct Point {\n\tint pos;\n\tdouble time;\n\tint speed;\n\tint pres;\n\n\tbool operator<(const Point& right) const {\n\t\treturn (time > right.time);\n\t}\n};\n\nint main(void) {\n\twhile (cin >> n >> m, n) {\n\t\tint s,g;\n\t\tcin >> s >> g;\n\n\t\tint x,y,d,c;\n\t\tvector< vector<edge> > adj(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tadj[x-1].push_back((edge){y-1,d,c});\n\t\t\tadj[y-1].push_back((edge){x-1,d,c});\n\t\t}\n\n\t\tpriority_queue<Point> pq;\n\t\tpq.push((Point){s-1,0,1,1});\n\t\tdouble dp[n][31];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < 31; ++j) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][1] = 0;\n\n\t\tbool find = false;\n\t\twhile (!pq.empty()) {\n\t\t\tPoint pn = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif (pn.pos == g-1 && pn.speed == 1 && pn.pres == 1) {\n\t\t\t\tprintf(\"%llf\\n\",pn.time);\n\t\t\t\tfind = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (size_t i = 0; i < adj[pn.pos].size(); ++i) {\n\t\t\t\tdouble rt = ((double)adj[pn.pos][i].dis/pn.speed);\n\t\t\t\tif (pn.time + rt < dp[adj[pn.pos][i].t][pn.speed] && pn.speed <= adj[pn.pos][i].lim) {\n\t\t\t\t\tdp[adj[pn.pos][i].t][pn.speed] = pn.time + rt;\n\t\t\t\t\tpq.push((Point){adj[pn.pos][i].t,pn.time+rt,pn.speed,pn.speed});\n\t\t\t\t\tif (pn.speed != 30) {\n\t\t\t\t\t\tpq.push((Point){adj[pn.pos][i].t,pn.time+rt,pn.speed+1,pn.speed});\n\t\t\t\t\t}\n\t\t\t\t\tif (pn.speed != 1) {\n\t\t\t\t\t\tpq.push((Point){adj[pn.pos][i].t,pn.time+rt,pn.speed-1,pn.speed});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!find) {\n\t\t\tcout << \"unreachable\" <<  endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000.0\n#define EPS 1e-8\nusing namespace std;\nstruct state { int n, v, l; double t; };\n\nint N, M, S, G;\nvector<int> T[31], D[31], C[31];\nint vd[3] = { -1, 0, 1 };\ndouble dp[31][51];\n\nclass Compare {\npublic:\n  bool operator() (struct state a, struct state b) {\n    return a.t > b.t;\n  }\n};\n\nint main(void) {\n  while(cin >> N >> M, N) {\n    cin >> S >> G;\n    REP(i, 0, 30) {\n      T[i].clear();\n      D[i].clear();\n      C[i].clear();\n    }\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      T[x].push_back(y); D[x].push_back(d); C[x].push_back(c);\n      T[y].push_back(x); D[y].push_back(d); C[y].push_back(c);\n    }\n\n    REP(i, 1, N) REP(j, 0, 50) dp[i][j] = INF;\n\n    priority_queue<struct state, vector<struct state>, Compare> q;\n    struct state first = { S, 0, -1, 0.0 };\n    q.push(first);\n\n    while(!q.empty()) {\n      struct state c = q.top();\n      q.pop();\n\n      // cout << c.n << \" \" << c.v << \" \" << c.t << endl;\n\n      dp[c.n][c.v] = min(dp[c.n][c.v], c.t);\n      if(c.n == G && c.v == 1) break;\n\n      for(int i = 0; i < T[c.n].size(); i++) {\n        if(T[c.n][i] == c.l) continue;\n        REP(j, 0, 3) {\n          int v = c.v + vd[j];\n          if(v <= 0 || C[c.n][i] < v) continue;\n          double t = c.t + ((double) D[c.n][i] / v);\n          struct state n = { T[c.n][i], v, c.n, t };\n          if(n.t < dp[n.n][n.v] - EPS) q.push(n);\n        }\n      }\n    }\n\n    if(dp[G][1] < INF) printf(\"%.6f\\n\", dp[G][1]);\n    else cout << \"unreachable\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<numeric>\nusing namespace std;\n#define INF (1 << 30) - 1\n#define LINF 1LL << 60\nconst int MOD = 1000000007;\nusing ll = long long;\nusing P = pair<int, int>;\n\nstruct TP{\n\tdouble time;\n\tint vel, prev, cur;\n\tTP(double time, int vel, int cur, int prev) : time(time), vel(vel), cur(cur), prev(prev){}\n\n\tbool operator< (const TP& a) const{\n\t\treturn time > a.time;\n\t}\n};\n\nint acc[3] = {-1, 0, 1};\n\nstruct Edge{\n\tint to, cost, limit;\n\tEdge(int to, int cost, int limit) : to(to), cost(cost), limit(limit) {}\n};\n\nvector<vector<Edge>> graph;\n\ndouble tm[35][35][35];\n\nvoid dijkstra(int s){\n\tfill((double*)tm, (double*)tm + sizeof(tm) / sizeof(double), INF);\n\ttm[s][0][s] = 0;\n\tpriority_queue<TP> que;\n\tque.emplace(tm[s][0][s], 0, s, s);\n\twhile(!que.empty()){\n\t\tauto v = que.top();\n\t\tque.pop();\n\t\tint cur = v.cur;\n\t\tdouble t = v.time;\n\t\tint cur_vel = v.vel;\n\t\tint prev = v.prev;\n\t\tif(t > tm[cur][cur_vel][prev])continue;\n\n\t\tfor(auto nv : graph[cur]){\n\t\t\tif(nv.to == prev)continue;\n\n\t\t\tfor(int i = 0; i < 3; ++i){\n\t\t\t\tint nxt_vel = cur_vel + acc[i];\n\t\t\t\tif(nxt_vel <= 0 || nv.limit < nxt_vel)continue;\n\n\t\t\t\tdouble nt = (double)nv.cost / (double)nxt_vel;\n\t\t\t\tif(tm[cur][cur_vel][prev] + nt < tm[nv.to][nxt_vel][cur]){\n\t\t\t\t\ttm[nv.to][nxt_vel][cur] = tm[cur][cur_vel][prev] + nt;\n\t\t\t\t\tque.emplace(tm[nv.to][nxt_vel][cur], nxt_vel, nv.to, cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n\nint main(){\n  while(true){\n  \tint n, m, s, g;\n  \tcin >> n >> m;\n  \tif(n == 0)return 0;\n  \tcin >> s >> g;\n  \t--s;\n  \t--g;\n  \tgraph.clear();\n  \tgraph.resize(n);\n  \tfor(int i = 0; i < m; ++i){\n  \t\tint x, y, d, c;\n  \t\tcin >> x >> y >> d >> c;\n  \t\t--x;\n  \t\t--y;\n  \t\tgraph[x].emplace_back(y, d, c);\n  \t\tgraph[y].emplace_back(x, d, c);\n  \t}\n\n  \tdijkstra(s);\n\n  \tdouble ans = INF;\n  \tfor(int i = 0; i < n; ++i){\n  \t\tans = min(ans, tm[g][1][i]);\n  \t}\n\n  \tif(ans == INF)cout << \"unreachable\" << endl;\n  \telse printf(\"%.5lf\\n\", ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<cstring>\n#define INF 1e10\nusing namespace std;\nstruct edge{\n  int to,limit;\n  double dist;\n};\nstruct Point{\n  int speed,prev,v;\n  double cost;\n  Point(){}\n  Point(int speed_,int prev_,int v_,double cost_)\n    :speed(speed_),prev(prev_),v(v_),cost(cost_){}\n  bool operator>(const Point &a)const{\n    return cost > a.cost;\n  }\n};\nvector<edge> G[100];\ndouble d[40][40][40];//speed,pos,prev\n\ndouble dikstra(int s,int g){\n  int ds[3]={-1,0,1};\n  priority_queue<Point,vector<Point>,greater<Point> > que;\n  \n  for(int i=0;i<40;i++)\n    for(int j=0;j<40;j++)\n      for(int k=0;k<40;k++)\n\td[i][j][k]=INF;\n  \n  d[0][s][0]=0;\n  Point tmp(0,0,s,0);\n  que.push(tmp);\n  \n  while(!que.empty()){\n    Point p=que.top();que.pop();\n    if(d[p.speed][p.v][p.prev]<p.cost)continue;\n    if(p.speed==1 && p.v==g)return p.cost;\n\n    for(int i=0;i<G[p.v].size();i++){\n\tedge e=G[p.v][i];\n      for(int j=0;j<3;j++){\n\tint ns=p.speed+ds[j];\n\tif(1<=ns && ns<= e.limit &&\n\t   e.to!=p.prev && \n\t   d[ns][e.to][p.v]>p.cost+e.dist/ns){\n\n\t  Point tmp(ns,p.v,e.to,p.cost+e.dist/ns);\n\t  que.push(tmp);\n\t  d[ns][e.to][p.v]=p.cost+e.dist/ns;\n\t  //cout << \"d[\" << ns << \"][\" << e.to << \"][\" << p.v << \"]:\" << d[ns][e.to][p.v] << endl;\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n){\n    for(int i=0;i<100;i++)G[i].clear();\n    cin>>s>>g;\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      G[x].push_back((edge){y,c,d});\n      G[y].push_back((edge){x,c,d});\n    }\n    double ans=dikstra(s,g);\n    if(ans==-1)cout << \"unreachable\" << endl;\n    else printf(\"%.5lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct status {\n    int pos;\n    double dist;\n    int vel;\n    int prev;\n\n    status () {}\n    ~status () {}\n\n    status(int a, double b, int c, int d): pos(a), dist(b), vel(c), prev(d) {}\n\n//    bool operator < (const status& o) const {\n//        return dist < o.dist;\n//    }\n\n    bool operator > (const status& o) const {\n        return dist > o.dist;\n    }\n};\n\nstruct edge {\n    int to;\n    double dist;\n    int lim;\n\n    edge () {}\n    ~edge () {}\n\n    edge(int a, double b, int c): to(a), dist(b), lim(c) {}\n};\n\nconst int INF = 1 << 29;\n\nbool solve() {\n    int n, m, s, g;\n    /*\n     * n <- [1..20]\n     * m <- [1..?]\n     * s, g <- [1..n]\n     * (x, y, d, c)\n     *   x, y <- [1..n]\n     *   d <- [1..100]\n     *   c <- [1..30]\n     */\n    cin >> n >> m;\n\n    if (n == 0 && m == 0) return false;\n\n    cin >> s >> g;\n\n    --s; --g;\n\n    vector<vector<edge>> graph(n, vector<edge>(0));\n\n    for (int j = 0; j < m; ++j) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        --x; --y;\n        graph[x].push_back(edge(y, d, c));\n        graph[y].push_back(edge(x, d, c));\n    }\n\n    vector<vector<double>> dist(n, vector<double>(35, INF));\n    priority_queue<status, vector<status>, greater<status>> que;\n\n    dist[s][0] = 0;\n    que.push(status(s, 0.0, 0, -1));\n\n    while (!que.empty()) {\n        status st = que.top(); que.pop();\n\n        if (dist[st.pos][st.vel] < st.dist) {\n            continue;\n        }\n\n        if (st.pos == g && st.vel == 1) {\n            break;\n        }\n\n        for (edge& e : graph[st.pos]) {\n            if (e.to == st.prev) continue;\n\n            for (int a = -1; a <= 1; ++a) {\n                int nv = st.vel + a;\n                if (nv <= 0) continue;\n\n                double d = st.dist + e.dist / nv;\n\n                if (nv <= e.lim && d < dist[e.to][nv]) {\n                    dist[e.to][nv] = d; \n                    que.push(status(e.to, d, nv, st.pos));\n                }\n            }\n        }\n    }\n\n    if (dist[g][1] == INF) {\n        printf(\"unreachable\\n\");\n    } else {\n        printf(\"%.10f\\n\", dist[g][1]);\n    }\n\n    fflush(stdout);\n\n    return true;\n}\n\nint main () {\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\n\nclass State{\npublic:\n  int pos, v, pre;\n  double time;\n  State(){}\n  State(int pos, int v, int pre, double time) : pos(pos), v(v), pre(pre), time(time) {}\n};\n\nint n, m, s, g;\nP edge[30][30];\nint limit[30];\n\nvoid dijkstra(int g){\n  bool used[30];\n  fill(used, used+30, false);\n  fill(limit, limit+30, INF);\n  limit[g] = 1;\n  while(true){\n    int v = -1;\n    for(int u=0;u<n;u++){\n      if(!used[u] && (v == -1 || limit[u] < limit[v])) v = u;\n    }\n    if(v == -1) break;\n    used[v] = true;\n    for(int u=0;u<n;u++){\n      if(edge[u][v].first < INF) limit[u] = min(limit[u], limit[v] + 1);\n      else limit[u] = min(limit[u], limit[v] + INF);\n    }\n  }\n}\n\nvoid solve(){\n  if(limit[s] >= INF){\n    printf(\"unreachable\\n\");\n    return;\n  }\n  State u, v;\n  bool reach = false;\n  u = State(s, 0, 0, 0.0);\n  queue<State> que;\n  double vis[30][900];\n  fill(vis[0], vis[30], 100000000.0);\n  vis[u.pos][u.v] = u.time;\n  que.push(u);\n  while(!que.empty()){\n    u = que.front(); que.pop();\n    //cout << u.pos << ' ' << u.v << ' ' << u.pre << ' ' << u.time << endl;\n    if(u.pos == g && u.v == 1){\n      reach = true;\n      continue;\n    }\n    for(int i=0;i<n;i++){\n      if(edge[u.pos][i].first == INF) continue;\n      if(u.pre == i) continue;\n      for(int k=-1;k<=1;k++){\n        if(u.v + k > edge[u.pos][i].second) continue;\n        if(u.v + k <= 0) continue;\n        v = State(i, u.v + k, u.pos, u.time + edge[u.pos][i].first / (double)(u.v + k));\n        //cout << '\\t' << v.pos << ' ' << v.v << ' ' << v.pre << ' ' << v.time << ' ' << vis[v.pos][v.v] << endl;\n        //if(v.v-2 > limit[v.pos]) continue;\n        if(vis[v.pos][v.v] > v.time){\n          vis[v.pos][v.v] = v.time;\n          que.push(v);\n        }\n      }\n    }\n  }\n  if(reach) printf(\"%.5f\\n\", vis[g][1]);\n  else printf(\"unreachable\\n\");\n}\n\nmain(){\n  while(scanf(\"%d%d\", &n, &m) && (n|m)){\n    scanf(\"%d%d\", &s, &g);\n    s--; g--;\n    fill(edge[0], edge[30], P(INF, 0));\n    for(int i=0;i<m;i++){\n      int a, b, c, d;\n      scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n      a--; b--;\n      edge[a][b] = edge[b][a] = P(c, d);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(edge[i][j].first == INF) cout << \"INF\";\n        else cout << edge[i][j].first;\n        cout << \" \";\n      }\n      cout << endl;\n      }*/\n    dijkstra(g);\n    /*for(int i=0;i<n;i++){\n      cout << limit[i] << ' ';\n      }\n      cout << endl;*/\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 30\n#define V 31\n#define INF 10000\nint G[N][N];\nint C[N][N];\nint n, m, s, g;\n\ndouble dijkstra(){\n    double d[N][N][V]; // [現在の都市][前の都市][現在の都市にいるときの速さ]\n    bool used[N][N][V];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < V; k++) {\n                d[i][j][k] = INF;\n                used[i][j][k] = false;\n            }\n        }\n    }\n    d[s][s][0] = 0;\n    \n    while (true) {\n        int now, prev, v = -1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < V; k++) {\n                    if (!used[i][j][k] && (v == -1 || d[i][j][k] < d[now][prev][v])) {\n                        now = i; prev = j; v = k;\n                    }\n                }\n            }\n        }\n        if (v == -1) {\n            break;\n        }\n        used[now][prev][v] = true;\n        \n        for (int u = 0; u < n; u++) {\n            if (u == prev) {\n                continue;\n            }\n            if (G[now][u] == INF) {\n                continue;\n            }\n            for (int dv = -1; dv <= 1; dv++) {\n                int mv = v + dv;\n                if (mv < 1 || mv > C[now][u]) {\n                    continue;\n                }\n                d[u][now][mv] = min(d[u][now][mv], d[now][prev][v] + (double)G[now][u] / mv);\n            }\n        }\n    }\n\n    double ans = INF;\n    for (int i = 0; i < n; i++) {\n        ans = min(ans, d[g][i][1]);\n    }\n    return ans;\n}\n\nint main()\n{\n    int x, y, d, c;\n    while (true) {\n        cin >> n >> m;\n        cin >> s >> g;\n        s--; g--;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                G[i][j] = INF;\n                C[i][j] = 0;\n            }\n        }\n        \n        for (int i = 0; i < m; i++) {\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            G[y][x] = G[x][y] = d;\n            C[y][x] = C[x][y] = c;\n        }\n        double ans = dijkstra();\n        if (ans == INF) {\n            cout << \"unreachable\" << endl;\n        }\n        else {\n            cout << ans << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<double, int, int, int> T;\n \nconst ll MOD=1e9+7;\n//const ll INF=1e18;\n\nconst double INF = 1000000.0;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\nstruct edge{ int to,d,c;};\n\n\n\nint n,m,s,g;\ndouble d[35][35][35];\ndouble mind;\n\nint main(){\n\twhile(true){\n\t\tcin >> n >> m;\n\t\tif(n + m == 0) break;\n\t\tcin >> s >> g;\n\t\tmind = INF;\n\t\tvector<edge> G[35];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a1,a2,a3,a4;\n\t\t\tcin >> a1 >> a2 >> a3 >> a4;\n\t\t\tedge tmp1 = {a2,a3,a4};\n\t\t\tG[a1].push_back(tmp1);\n\t\t\tedge tmp2 = {a1,a3,a4};\n\t\t\tG[a2].push_back(tmp2);\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tfor(int k = 0;k <= 31;k++){\n\t\t\t\t\td[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<T> que;\n\t\tfor(int i = 0;i < G[s].size();i++){\n\t\t\tedge e = G[s][i];\n\t\t\td[s][e.to][1] = (double) e.d;\n\t\t\tque.push(make_tuple((double)e.d,1,s,e.to));\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tT t = que.front(); que.pop();\n\t\t\tdouble a1 = get<0>(t);\n\t\t\tint a2 = get<1>(t),a3 = get<2>(t),a4 = get<3>(t);\n\t\t\tif(d[a3][a4][a2] < a1 || a1 > mind)continue;\n\t\t\tfor(int i = 0;i < G[a4].size();i++){\n\t\t\t\tedge e = G[a4][i];\n\t\t\t\tif(e.to == a3) continue;\n\t\t\t\tfor(int j = -1;j <= 1;j++){\n\t\t\t\t\tint v = a2 + j;\n\t\t\t\t\tdouble tmp = (double)( a1 + (double)e.d / (double)v);\n\t\t\t//\t\tif(a4 == 5 && e.to == 6 && v == 1) cout << \"tmp\" << tmp << \",a1\" << a1 <<endl;\n\t\t\t\t\tif(v <= 0 || v > e.c || d[a4][e.to][v] < tmp ) continue;\n\t\t\t\t\td[a4][e.to][v] =  tmp;\n\t\t\t\t\tif(e.to == g && v == 1 && mind > tmp)mind = tmp;\n\t\t\t\t\tque.push(make_tuple(tmp,v,a4,e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\n\t\t}\n\t//\tcout << \"ans\" << d[4][5][2] << endl;\n\n\n\n\t\tdouble ans = INF;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tdouble tmp = d[i][g][1];\n\t\t\tif(ans > tmp) ans = tmp;\n\t\t//\tans = min(ans,d[i][g][1]);\n\t\t}\n\t\tif(ans == INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t//\tcout << ans << endl;\n\t\t\tprintf(\"%lf\",ans);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<pair<int,int>,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a2,a4;\ndouble d[31][31],a3;\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      cin>>a1>>a2>>a3>>a4;\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P>q;\n    d[st][0]=0;\n    P xt;xt.fi.fi=0,xt.fi.se=st,xt.se=-1;\n    q.push(xt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.fi.se;\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=p.se)r(j,3){\n          int x=p.fi.fi+dx[j];\n          if(0<x&&x<=e.lim){\n            if(d[e.to][x]>e.dist/x+d[cur][p.fi.fi]){\n              d[e.to][x]=e.dist/x+d[cur][p.fi.fi];\n              xt.fi.fi=x,xt.fi.se=e.to,xt.se=cur;\n              //if(go&&d[e.to][x]>100)cout<<d[e.to][x]<<endl;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\nnamespace ShortestPath{\n    typedef double Cost;\n    const Cost CINF=1e17;\n    typedef  vector<vector<Cost> > Mat;\n    struct Edge{\n        int to;Cost cost;\n        Edge(int to,Cost cost)\n            : to(to),cost(cost){};\n    };\n\n    typedef vector<vector<Edge> > Graph;\n\n    struct Task{\n        int pos;Cost cost;\n        Task(int pos,Cost cost)\n            :pos(pos),cost(cost){};\n        bool operator>(const Task& r) const{\n            return cost>r.cost;\n        }\n    };\n\n      inline vector<Cost> dijkstra(const Graph& g,const int s,vector<int>& prev){\n        const int V=g.size();\n        vector<Cost> d(V,CINF);d[s]=0;\n        \n        priority_queue<Task,vector<Task>,greater<Task> > que;que.push(Task(s,0));\n        vector<bool> passed(V);\n        while(!que.empty()){\n            Task task=que.top();que.pop();\n            //if(prev[task.pos]!=-2)continue;\n            if(passed[task.pos])continue;\n            //if(d[task.pos]<task.cost)continue;\n            passed[task.pos]=true;\n            EACH(e,g[task.pos]){\n                if(d[e->to]>d[task.pos]+e->cost){\n                    d[e->to]=d[task.pos]+e->cost;\n                    que.push(Task(e->to,d[e->to]));\n                }\n            }   \n        }\n        return d;\n    }\n    vector<Cost> dijkstra(const Graph& g,const int s){\n        vector<int> prev(g.size());return dijkstra(g,s,prev);\n    }\n}\nusing namespace ShortestPath;\n\nclass Main{\n\tpublic:\n\n\tint enc(int pos,int prev,int V){\n\t\treturn pos*35*N+prev*35+V;\n\t}\n\tint N,M;\n\t\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\tcout <<fixed<<setprecision(15);\t\n\t\n\t\twhile(true){\n\t\t\t // cin >> N >> M;\n\t\t\t scanf(\"%d%d\",&N,&M);\n\t\t\tif(N==0)break;\n\t\t\tint s,g;\n\t\t\t// cin >> s >> g;\n\t\t\tscanf(\"%d%d\",&s,&g);\n\t\t\ts--;g--;\n\t\t\t\n\t\t\tGraph G(N*N*35);\n\t\t\tREP(i,M){\n\t\t\t\tint x,y;double d;int c;\n\t\t\t\t// cin >> x >> y >> d >> c;\n\t\t\t\tscanf(\"%d%d%lf%d\",&x,&y,&d,&c);\n\t\t\t\tx--;y--;\n\t\t\t\tfor(int v=0;v<=35;v++)for(int nv=v-1;nv<=v+1;nv++){\n\t\t\t\t\tif(!IN(1,nv,c+1))continue;\n\t\t\t\t\tREP(prev,N)if(prev!=y)G[enc(x,prev,v)].push_back(Edge(enc(y,x,nv),d/nv));\n\t\t\t\t\tREP(prev,N)if(prev!=x)G[enc(y,prev,v)].push_back(Edge(enc(x,y,nv),d/nv));\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<Cost> res=dijkstra(G,enc(s,s,0));\n\t\t\tCost mv=CINF;\n\t\t\tREP(prev,N)mv=min(mv,res[enc(g,prev,1)]);\n\t\t\tif(mv>=CINF) cout <<\"unreachable\"<<endl;\n\t\t\telse cout << mv<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint to;\n\tint cost;\n    int speedLimit;\n};\n\nclass Situation{\npublic:\n\tdouble cost;\n\tint idx;\n    int prvIdx;\n    int speed;\n\n\tSituation(double cost_,int idx_,int prvIdx_,int speed_){\n        cost=cost_;\n\t\tidx=idx_;\n        speed=speed_;\n        prvIdx=prvIdx_;\n\t}\n\tSituation();\n\tbool operator<(const Situation &s)const{\n\t\treturn s.cost < this->cost;\n\t}\n};\n\n//typedef pair<int,int> P;\nint V;\n\nconst int MAX_V = 100;\nconst int MAX_SPEED=50;\n\nvector<edge> G[MAX_V];\ndouble d[MAX_V][MAX_V][MAX_SPEED];\nconst int INF = 1000000000;\n\nvoid dijkstra(int s){\n\tpriority_queue<Situation> que;\n    for(int i = 0; i < MAX_V; i++)\n        for(int k = 0; k < MAX_V; k++)\n            for(int j = 0; j < MAX_SPEED; j++)\n                d[i][k][j]=INF;\n    d[0][s][1] = 0;\n\tque.push(Situation(0,s,0,1));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n        int idx=p.idx;\n        int pidx=p.prvIdx;\n        double ccost=p.cost;\n        int cspeed=p.speed;\n\t\tif(d[pidx][idx][cspeed] < p.cost)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[idx].size(); i++){\n\t\t\tedge e = G[idx][i];\n            if(pidx==e.to)\n                continue;\n            for(int j = -1; j <= 1; j++){\n                if(pidx==0)\n                    if(cspeed+j!=1)\n                        continue;\n                if(cspeed+j>=1&&e.speedLimit>=cspeed+j\n                    &&(d[idx][e.to][cspeed+j]>d[pidx][idx][cspeed]+(double)e.cost/(cspeed+j)\n                    &&!EQ(d[idx][e.to][cspeed+j],d[pidx][idx][cspeed]+(double)e.cost/(cspeed+j)))){\n                        d[idx][e.to][cspeed+j] = d[pidx][idx][cspeed] + (double)e.cost/(cspeed+j);\n                        que.push(Situation(d[idx][e.to][cspeed+j],e.to,idx,cspeed+j));\n                }\n            }\n\t\t}\n\t}\n}\n\nint main(){\n\n    int n,m,s,g;\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        for(int i = 0; i < MAX_V; i++)\n            G[i].clear();\n        cin>>s>>g;\n        for(int i = 0; i < m; i++){\n            int from,to,dist,lim;\n            cin>>from>>to>>dist>>lim;\n            edge e;\n            e.cost=dist;\n            e.to=to;\n            e.speedLimit=lim;\n            G[from].push_back(e);\n            e.to=from;\n            G[to].push_back(e);\n        }\n        dijkstra(s);\n        double minTime=INF;\n        for(int i = 0; i <= n; i++)\n            minTime=min(minTime,d[i][g][1]);\n        if(EQ(minTime,INF))\n            cout<<\"unreachable\"<<endl;\n        else\n            printf(\"%.6f\\n\",minTime);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<map>\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\ntypedef struct {\n    int dis;\n    int lim;\n} edge;\ntypedef pair<int,int> pp;\ntypedef pair<int, pp> node; // v, (x,y)\ntypedef pair<double, node> que; // sum, (v, (x,y))\n\nedge input[50][50];\ndouble G[50][50][50]; // x, y, v\n\nint main(void) {\n    while(1) {\n        int n,m,s,g;\n        scanf(\"%d%d\",&n,&m);\n        if(!n) break;\n        scanf(\"%d%d\",&s,&g);\n        s--, g--;\n\n        memset(input, 0, sizeof(input));\n        memset(G, 0, sizeof(G));\n\n        for(int i=0; i<m; i++) {\n            int x,y,d,c;\n            scanf(\"%d%d%d%d\",&x,&y,&d,&c);\n            x--, y--;\n            input[x][y] = input[y][x] = {d,c};\n        }\n\n        map<node,double> tbl;\n        priority_queue<que> q;\n        for(int i=0; i<n; i++)\n            if(input[s][i].dis)\n                q.push(que(-0.0, node(1, pp(s,i))));\n\n        double res = 10000000.0;\n        while(q.size()) {\n            que t = q.top(); q.pop();\n\n            int v = t.snd.fst;\n            int x = t.snd.snd.fst, y = t.snd.snd.snd;\n            if(!(0<v && v<=input[x][y].lim)) continue;\n\n            double sum = -t.fst + 1.0* input[x][y].dis / v;\n\n            if(tbl.find(t.snd) != tbl.end() && tbl[t.snd] < sum) continue;\n            tbl[t.snd] = sum;\n\n            if(y == g && v == 1) {\n                res = res < sum ? res : sum;\n                continue;\n            }\n\n            for(int i=0; i<n; i++)\n                if(i!=x && input[y][i].dis) {\n                    int dv[] = {-1,0,1};\n                    for(int iv=0; iv<3; iv++)\n                        q.push(que(-sum, node(v+dv[iv], pp(y,i))));\n                }\n        }\n        if(res>1000000.0)\n            puts(\"unreachable\");\n        else\n            printf(\"%f\\n\", res);\n\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nstruct edge{\n\tint to,cost,limit;\n\tedge(int t,int c,int l){\n\t\tto=t;cost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tvector<vector<edge> > E(n+1);\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in].push_back(edge(out,c,l));\n\t\tE[out].push_back(edge(out,c,l));\n\t}\n\n\tdouble Ans[31][31][31];\n\tmemset(Ans,-1,sizeof(Ans));\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){\n\t\tNode t=Q.top(); Q.pop();\n\t\tif(Ans[t.now][t.before][t.speed]<=t.time && Ans[t.now][t.before][t.speed]>=0) continue;\n//\t\tcout<<t.now<<\" \"<<t.speed<<\" \"<<t.time<<endl;\n\t\tif(t.now==g && t.speed==1){printf(\"%.12lf\\n\", t.time );  return;}\n\t\tAns[t.now][t.before][t.speed]=t.time;\n\n\t\tfor(int i=0;i<E[t.now].size();i++){\n\t\t\tint to=E[t.now][i].to;\n\t\t\tif(to==t.before) continue;\n\t\t\tif(E[t.now][i].cost>0){\n\t\t\t\tif(E[t.now][i].limit>=t.speed && t.speed>=1){\n\t\t\t\t\tQ.push(Node(to,t.speed,t.time+E[t.now][i].cost/(double)t.speed,t.now));\n\t\t\t\t}\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed+1)\n\t\t\t\t\tQ.push(Node(to,t.speed+1,t.time+E[t.now][i].cost/(double)(t.speed+1.0),t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed-1 && t.speed-1>=1)\n\t\t\t\t\tQ.push(Node(to,t.speed-1,t.time+E[t.now][i].cost/(double)(t.speed-1.0),t.now));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\"<<endl;\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) x.begin(),x.end()\n#define ln '\\n'\nconst double PI = acos(-1.0);\nconst long long MOD = 1000000007LL;\n//const long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\ntemplate<typename T>\nstruct edge {\n    int src,to,limit;\n    T cost;\n\n    edge() = default;\n    edge(int to, T cost, int limit) : src(-1), to(to), cost(cost), limit(limit) {}\n    //edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n    bool operator<(const edge &e) const {\n        return cost < e.cost;\n    }\n};\n\ndouble dist[30][30][31];\nusing Tu = tuple<double, int, int, int>; \nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    while (true) {\n        int N,M; cin >> N >> M;\n        if (N+M==0) break;\n        int S,g; cin >> S >> g;\n        --S; --g;\n        vector<vector<edge<double>>> G(N);\n        rep(i,M) {\n            int u,v,d,c; cin >> u >> v >> d >> c;\n            --u; --v;\n            G[u].emplace_back(v,d,c);\n            G[v].emplace_back(u,d,c);\n        }\n\n        rep(i,30) rep(j,30) rep(k,31) dist[i][j][k] = 1e18;\n        dist[S][S][0] = 0;\n        priority_queue<Tu, vector<Tu>, greater<Tu>> pq;\n        pq.emplace(0,S,S,0);\n        while (!pq.empty()) {\n            double d;\n            int v,pv,s;\n            tie(d,v,pv,s) = pq.top(); pq.pop();\n            if (d > dist[v][pv][s]+1e-10) continue;\n            for (auto &e : G[v]) {\n                if (e.to == pv) continue;\n                for (int i = -1; i <= 1; i++) {\n                    int ns = s + i;\n                    if (ns < 1 || ns > e.limit) continue;\n                    if (chmin(dist[e.to][v][ns], dist[v][pv][s] + e.cost/ns)) {\n                        pq.emplace(dist[e.to][v][ns], e.to, v, ns);\n                    }\n                }\n            }\n        }\n\n        double ans = 1e18;\n        rep(i,N) chmin(ans,dist[g][i][1]);\n        if (ans == 1e18) cout << \"unreachable\" << ln;\n        else cout << fixed << setprecision(10) << ans << ln;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nclass data\n{\npublic:\n    int p, q, c;\n    data(int p0, int q0, int c0){\n        p = p0;\n        q = q0;\n        c = c0;\n    }\n};\n\nvoid solve(int n, int start, int goal, vector<vector<int> > distance, vector<vector<int> > limit)\n{\n    vector<bool> easyCheck(n, false);\n    queue<int> q;\n    q.push(start);\n    while(!q.empty()){\n        int a = q.front();\n        if(!easyCheck[a]){\n            easyCheck[a] = true;\n            for(int i=0; i<n; ++i){\n                if(distance[a][i] > -1)\n                    q.push(i);\n            }\n        }\n        q.pop();\n    }\n    if(!easyCheck[goal]){\n        cout << \"unreachable\" << endl;\n        return;\n    }\n\n    vector<vector<vector<bool> > > check(n, vector<vector<bool> >(n, vector<bool>(31, false)));\n\tvector<vector<vector<double> > > time(n, vector<vector<double> >(n, vector<double>(31, DBL_MAX)));\n    for(int i=0; i<n; ++i){\n        if(distance[start][i] > -1)\n\t\t\ttime[i][start][1] = distance[start][i];\n    }\n\n    for(;;){\n\t\tint p, q, c;\n\t\tdouble minTime = DBL_MAX;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tfor(int j=0; j<n; ++j){\n\t\t\t\tfor(int k=1; k<=limit[i][j]; ++k){\n\t\t\t\t\tif(!check[i][j][k] && time[i][j][k] < minTime){\n\t\t\t\t\t\tp = i;\n\t\t\t\t\t\tq = j;\n\t\t\t\t\t\tc = k;\n\t\t\t\t\t\tminTime = time[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(p == goal && c == 1){\n\t\t\tprintf(\"%.10f\\n\", minTime);\n\t\t\treturn;\n\t\t}\n\n        check[p][q][c] = true;\n        for(int i=0; i<n; ++i){\n            if(i == p || i == q || distance[i][p] == -1)\n                continue;\n            for(int j=-1; j<=1; ++j){\n                if(1 <= c+j && c+j <= limit[p][i] && !check[i][p][c+j])\n\t\t\t\t\ttime[i][p][c+j] = min(time[i][p][c+j], minTime + distance[p][i]/static_cast<double>(c+j));\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, s, g;\n        cin >> n >> m;\n        if(n == 0 && m == 0)\n            break;\n        cin >> s >> g;\n        -- s;\n        -- g;\n\n        vector<vector<int> > distance(n, vector<int>(n, -1));\n        vector<vector<int> > limit(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int x, y;\n            cin >> x >> y;\n            -- x;\n            -- y;\n            cin >> distance[x][y] >> limit[x][y];\n            distance[y][x] = distance[x][y];\n            limit[y][x] = limit[x][y];\n        }\n\n        solve(n, s, g, distance, limit);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Problem     : AOJ1162\n * Title       : Discrete Speed (離散的速度)\n * Author      : mizo0203\n * Copyright   : Your copyright free\n * Description : ダイクストラ\n */\n#include <stdio.h>\n#include <utility> // pairライブラリを使用するのに必要\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define MAX_V (31*31*31)\n#define INF 3000000\nusing namespace std;\n\nstruct edge {\n  int to;\n  double cost;\n};\ntypedef pair<int, int> P;\n\nint V;\nvector<edge> G[MAX_V];\ndouble d[MAX_V];\npriority_queue<P, vector<P>, greater<P> > que;\n\nint n, s, g;\n\nbool input() {\n  int i, j, k;\n  int m, x, y, d, c;\n  edge e;\n\n  scanf(\"%d %d\", &n, &m);\n  if (!n && !m)\n    return false;\n\n  V = (n + 1) * (n + 1) * 31;\n  scanf(\"%d %d\", &s, &g);\n  for (i = 0; i < V; i++) {\n    G[i].clear();\n  }\n  for (i = 0; i < m; i++) {\n    scanf(\"%d %d %d %d\", &x, &y, &d, &c);\n    for (j = 0; j <= n; j++) {\n      for (k = 1; k <= c; k++) {\n        e.cost = (double) d / k;\n        if (j != y) {\n          e.to = k * (n + 1) * (n + 1) + x * (n + 1) + y;\n          G[(k - 1) * (n + 1) * (n + 1) + j * (n + 1) + x].push_back(e);\n          G[k * (n + 1) * (n + 1) + j * (n + 1) + x].push_back(e);\n          if (k < 30)\n            G[(k + 1) * (n + 1) * (n + 1) + j * (n + 1) + x].push_back(e);\n        }\n        if (j != x) {\n          e.to = k * (n + 1) * (n + 1) + y * (n + 1) + x;\n          G[(k - 1) * (n + 1) * (n + 1) + j * (n + 1) + y].push_back(e);\n          G[k * (n + 1) * (n + 1) + j * (n + 1) + y].push_back(e);\n          if (k < 30)\n            G[(k + 1) * (n + 1) * (n + 1) + j * (n + 1) + y].push_back(e);\n        }\n      }\n      /*\n       e.cost = (double) d / k;\n       if (j != y) {\n       e.to = k * (n + 1) * (n + 1) + x * (n + 1) + y;\n       G[(k - 1) * (n + 1) * (n + 1) + j * (n + 1) + x].push_back(e);\n       e.to = k * (n + 1) * (n + 1) + x * (n + 1) + y;\n       G[k * (n + 1) * (n + 1) + j * (n + 1) + x].push_back(e);\n       }\n       if (j != x) {\n       e.to = k * (n + 1) * (n + 1) + y * (n + 1) + x;\n       G[(k - 1) * (n + 1) * (n + 1) + j * (n + 1) + y].push_back(e);\n       e.to = k * (n + 1) * (n + 1) + y * (n + 1) + x;\n       G[k * (n + 1) * (n + 1) + j * (n + 1) + y].push_back(e);\n       }\n       */\n    }\n  }\n\n  return true;\n}\n\nvoid dijkstra() {\n  fill(d, d + V, INF);\n  d[s] = 0.0;\n  que.push(P(0, s));\n\n  while (!que.empty()) {\n    P p = que.top();\n    que.pop();\n    int v = p.second;\n    if (d[v] < p.first)\n      continue;\n    for (int i = 0; i < (int) G[v].size(); i++) {\n      edge e = G[v][i];\n      if (d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        que.push(P(d[e.to], e.to));\n        /*\n         printf(\"%d %d %d => %d %d: %f\\n\", v / (n + 1) / (n + 1),\n         v / (n + 1) % (n + 1), v % (n + 1) % (n + 1),\n         e.to / (n + 1) / (n + 1), e.to % (n + 1) % (n + 1), d[e.to]);\n         */\n      }\n    }\n  }\n}\n\nint main() {\n  int i;\n  double min_cost;\n\n  while (input()) {\n    /*\n     for (i = 0; i < V; i++) {\n     for (int j = 0; j < (int) G[i].size(); j++) {\n     printf(\"%d %d %d => %d %d: %f\\n\", i / (n + 1) / (n + 1),\n     i / (n + 1) % (n + 1), i % (n + 1) % (n + 1),\n     G[i][j].to / (n + 1) / (n + 1),\n     G[i][j].to % (n + 1) % (n + 1), G[i][j].cost);\n     }\n     }\n     */\n    dijkstra();\n    min_cost = d[1 * (n + 1) * (n + 1) + g];\n    for (i = 1; i <= n; i++) {\n      if (min_cost > d[1 * (n + 1) * (n + 1) + i * (n + 1) + g])\n        min_cost = d[1 * (n + 1) * (n + 1) + i * (n + 1) + g];\n    }\n    if (min_cost != INF)\n      printf(\"%f\\n\", min_cost);\n    else\n      printf(\"unreachable\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i,a) for(int i=0;i<a;i++)\n\nint n, m;\nint s, g;\n\nstruct edge\n{\n    int to, d, c;\n\n    edge() {}\n    edge(int to, int d, int c) \n        : to(to), d(d), c(c) {}\n};\n\nvector<vector<edge> > E;\n\nstruct node\n{\n    double cost;\n    int prev, v, speed;\n\n    node() {}\n    node(double cost, int prev, int v, int speed)\n        : cost(cost), prev(prev), v(v), speed(speed) {}\n    bool operator <(const node& t) const {\n        return cost > t.cost;\n    }\n};\n\ndouble mem[32][32][32];\n\nvoid solve()\n{\n    rep(i,32)rep(j,32)rep(k,32)mem[i][j][k]=1e9;\n\n    priority_queue<node> q;\n    q.push(node(0.0, n, 0, 0));\n    while (!q.empty()) {\n        double cost = q.top().cost;\n        int prev = q.top().prev;\n        int v = q.top().v;\n        int speed = q.top().speed;\n        q.pop();\n\n        // cerr<<cost<<' '<<prev<<' '<<v<<' '<<speed<<endl;\n\n        if (mem[prev][v][speed] <= cost)\n            continue;\n        if (v == g && speed == 1) {\n            printf(\"%.8f\\n\", cost);\n            return;\n        }\n            \n\n        mem[prev][v][speed] = cost;\n\n        rep(i, E[v].size()) {\n            if (E[v][i].to == prev)\n                continue;\n            for (int ns = speed - 1; ns <= speed + 1; ++ns) {\n                if (ns > 0 && ns <= E[v][i].c) {\n                    q.push(node(cost + (double) E[v][i].d / ns, v, E[v][i].to, ns));\n                }\n            }\n        }\n    }\n    cout << \"unreachable\" << endl;\n}\n\nint main()\n{\n    while (cin >> n >> m && n) {\n        cin >> s >> g;\n        --s, --g;\n        E.clear();\n        E.resize(n);\n        rep(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            --x, --y;\n            E[x].push_back(edge(y, d, c));\n            E[y].push_back(edge(x, d, c));\n        }\n\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//1162\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nconst int MAX_N=30,MAX_C=30;\nconst double INF=1e8;\nconst double ESP=1e-8;\n\n#define EQ(a,b) fabs(a-b)<ESP\n\nint n,m;\nint s,g;\nstruct edge{\n\tint to,dist,c;\n};\nvector<edge> G[MAX_N];\n\nstruct S{\n\tint town,v,pre;\n\tdouble cost;\n\tbool operator<(const S &a) const{\n\t\treturn cost>a.cost;\n\t}\n};\n\ndouble cost[MAX_N][MAX_C+1][MAX_N];\nbool used[MAX_N][MAX_C+1][MAX_N];\n\nvoid dijkstra(){\n\tREP(i,n){\n\t\tREP(j,MAX_C+1){\n\t\t\tREP(k,n){\n\t\t\t\tcost[i][j][k]=INF;\n\t\t\t\tused[i][j][k]=false;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<S> pq;\n\tpq.push(S{s,0,0,0.0});\n\tcost[s][0][0]=0;\n\twhile (!pq.empty()){\n\t\tS s=pq.top();\n\t\tpq.pop();\n\t\tif (used[s.town][s.v][s.pre]){\n\t\t\tcontinue;\n\t\t}\n\t\tused[s.town][s.v][s.pre]=true;\n\t\tFOR(acc,-1,1+1){\n\t\t\tif (s.v+acc<=0) continue;\n\t\t\tFOR(i,0,G[s.town].size()){\n\t\t\t\tedge e=G[s.town][i];\n\t\t\t\tif (s.v+acc>e.c){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (e.to==s.pre) continue;\n\t\t\t\tif (s.cost+(double)e.dist/(s.v+acc)<cost[e.to][s.v+acc][s.town]+0.001){\n\t\t\t\t\tcost[e.to][s.v+acc][s.town]=s.cost+(double)e.dist/(s.v+acc);\n\t\t\t\t\tpq.push(S{e.to,s.v+acc,s.town,cost[e.to][s.v+acc][s.town]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif (n){\n\t\t\tscanf(\"%d %d\",&s,&g);\n\t\t\ts--;\n\t\t\tg--;\n\t\t\tREP(i,n){\n\t\t\t\tG[i].clear();\n\t\t\t}\n\t\t\tREP(i,m){\n\t\t\t\tint x,y,d,c;\n\t\t\t\tscanf(\"%d %d %d %d\",&x,&y,&d,&c);\n\t\t\t\tx--;\n\t\t\t\ty--;\n\t\t\t\tG[x].push_back(edge{y,d,c});\n\t\t\t\tG[y].push_back(edge{x,d,c});\n\t\t\t}\n\t\t\tdijkstra();\n\t\t\tdouble ans=INF;\n\t\t\tREP(i,n){\n\t\t\t\tans=min(ans,cost[g][1][i]);\n\t\t\t}\n\t\t\tif (EQ(ans,INF)){\n\t\t\t\tprintf(\"unreachable\\n\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"%.6f\\n\",ans);\n\t\t\t}\n\t\t}\n\t}while (n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1000\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(short i=1;i<=n;i++)for(short j=1;j<=n;j++)for(short k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(short i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    \n    while(que.size()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(short i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define V vector\n\nconst double INF = 1e11;\n\nstruct state {\n    int pos;\n    double time;\n    int vel;\n    int prev;\n\n    state () {}\n    ~state () {}\n\n    state(int a, double b, int c, int d):\n        pos(a), time(b), vel(c), prev(d) {}\n\n    bool operator < (const state& o) const {\n        return time > o.time;\n    }\n};\n\nstruct edge {\n    int to;\n    int time;\n    int lim;\n\n    edge () {}\n    ~edge () {}\n\n    edge(int a, int b, int c):\n        to(a), time(b), lim(c) {}\n};\n\nbool solve() {\n    int n, m, s, g;\n    cin >> n >> m;\n\n    if (n == 0 && m == 0) return false;\n\n    cin >> s >> g;\n--s; --g;\n\n    V<V<edge>> graph(n, V<edge>(0));\n\n    for (int j = 0; j < m; ++j) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        --x; --y;\n        graph[x].push_back(edge(y, d, c));\n        graph[y].push_back(edge(x, d, c));\n    }\n\n    V<V<V<double>>> min_time(n, V<V<double>>(n, V<double>(31, INF)));\n    priority_queue<state> que;\n\n    que.push(state(s, 0.0, 0, s));\n    min_time[s][s][0] = 0;\n\n    while (!que.empty()) {\n        state st = que.top(); que.pop();\n\n        if (st.time > min_time[st.pos][st.prev][st.vel]) {\n            continue;\n        }\n\n        if (st.pos == g && st.vel == 1) {\n            break;\n        }\n\n        for (edge& e : graph[st.pos]) {\n            if (e.to == st.prev) continue;\n\n            for (int a = -1; a <= 1; ++a) {\n                int nv = st.vel + a;\n                if (nv <= 0) continue;\n\n                double t = st.time + (double)e.time / nv;\n\n                if (nv <= e.lim && t < min_time[e.to][st.pos][nv]) {\n                    min_time[e.to][st.pos][nv] = t;\n                    que.push(state(e.to, t, nv, st.pos));\n                }\n            }\n        }\n    }\n\n    double ret = INF;\n    for (int j = 0; j < n; ++j) {\n        ret = min(ret, min_time[g][j][1]);\n    }\n    \n    if (ret == INF) {\n        printf(\"unreachable\\n\");\n    } else {\n        printf(\"%.12f\\n\", ret);\n    }\n\n    return true;\n}\n\nint main () {\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<iomanip>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define sc second\n#define pb push_back\n#define mk make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntemplate<class S,class T>\nostream &operator<<(ostream &out, const pair<S,T> p){\n\treturn out << \"(\" << p.fs << \", \" << p.sc << \")\";\n}\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \", \";\n\treturn out << \"}\" << endl;\n}\n\n#define N 30\n#define INF (1<<28)\ndouble d[N+1][N];\nint main(){\n\tint n, m, s, g;\n\twhile(cin >> n >> m, n){\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\t\tfill(d[0], d[0] + (N+1) * N, INF);\n\t\td[1][s] = 0;\n\t\tvector<pair<int,double> > e[N+2][N];// e[x][c] : from x at vert c list\n\t\trep(i, m){\n\t\t\tint x, y, di, c;\n\t\t\tcin >> x >> y >> di >> c;\n\t\t\tx--; y--;\n\t\t\treps(j,1,c+1){\n\t\t\t\tdouble time = di / (double) j;\n\t\t\t\te[j][x].pb(mk(y, time));\n\t\t\t\te[j][y].pb(mk(x, time));\n\t\t\t}\n\t\t}\n\t\t/*\n\t\treps(i,1,3){\n\t\t\tcout << \"edges ver \" << i << endl;\n\t\t\trep(j,n){\n\t\t\t\tcout << \"\\tfrom \" << j << endl;\n\t\t\t\tcout << e[i][j];\n\t\t\t}\n\t\t}\n\t\t*/\n\t\t// dst, from, current, ver\n\t\tpriority_queue<pair<double, pair<pii, int> > > q;\n\t\trep(i,e[1][s].size()){\n\t\t\tdouble tmp = e[1][s][i].sc;\n\t\t\tint to = e[1][s][i].fs;\n\t\t\tq.push(mk(-tmp, mk(pii(s, to), 1)));\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tdouble dst = -q.top().fs;\n\t\t\tint from = q.top().sc.fs.fs;\n\t\t\tint cur = q.top().sc.fs.sc, ver = q.top().sc.sc;\n\t\t\t//cout << q.top() << endl;\n\t\t\tq.pop();\n\t\t\tif(d[ver][cur] < INF){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[ver][cur] = dst;\n\t\t\trep(i,3){\n\t\t\t\tint ci = ver - 1 + i;\n\t\t\t\tif(ci<1 || ci > N+1) continue;\n\t\t\t\trep(j, e[ci][cur].size()){\n\t\t\t\t\tpair<int, double> p = e[ci][cur][j];\n\t\t\t\t\tint to = p.fs;\n\t\t\t\t\tif (from == to) continue;\n\t\t\t\t\tdouble tmp = dst + p.sc;\n\t\t\t\t\tq.push(mk(-tmp, mk( pii(from, to), ci)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\treps(i, 1, 5){\n\t\t\tcout << \"ver \" << i << endl;\n\t\t\trep(j,n){\n\t\t\t   if(d[i][j] >= INF) cout << -1 << \" \";\n\t\t\t\telse cout << d[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tif(d[1][g] >= INF) cout << \"unreachable\" << endl;\n\t\telse cout <<fixed << setprecision(10)<< d[1][g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nclass Node {\npublic:\n  int pre;\n  int now;\n  int vel;\n  double time;\n\n  Node(int p, int n, int v, double t) {\n    pre = p;\n    now = n;\n    vel = v;\n    time = t;\n  }\n\n  bool operator<(const Node &n) const {\n    if (time != n.time)\n      return time < n.time;\n    return vel < n.vel;\n  }\n  bool operator>(const Node &n) const {\n    if (time != n.time)\n      return time > n.time;\n    return vel > n.vel;\n  }\n};\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n\n    if (n == 0) {\n      break;\n    }\n\n    int s, g;\n    cin >> s >> g;\n\n    vector<vector<int> > d(n + 1), c(n + 1);\n    for (int i = 0; i <= n; i++) {\n      d[i].resize(n + 1);\n      c[i].resize(n + 1);\n      fill(d[i].begin(), d[i].end(), -1);\n      fill(c[i].begin(), c[i].end(), 0);\n    }\n\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      cin >> d[x][y] >> c[x][y];\n      d[y][x] = d[x][y];\n      c[y][x] = c[x][y];\n    }\n\n    bool f[31][31][31];\n    for (int i = 0; i < 31; i++) {\n      for (int j = 0; j < 31; j++) {\n\tfor (int k = 0; k < 31; k++) {\n\t  f[i][j][k] = false;\n\t}\n      }\n    }\n  \n    bool goal = false;\n    Node snd(0, s, 0, 0.0);\n    priority_queue<Node, vector<Node>, greater<Node> > q;\n    q.push(snd);\n    while (!q.empty()) {\n      Node nd = q.top();\n      q.pop();\n      if (nd.now == g && nd.vel == 1) {\n\tgoal = true;\n\tcout << nd.time << endl;\n\tbreak;\n      }\n\n      if (f[nd.pre][nd.now][nd.vel]) {\n\tcontinue;\n      }\n    \n      f[nd.pre][nd.now][nd.vel] = true;\n      for (int i = 1; i <= n; i++) {\n\tif (i != nd.pre && d[nd.now][i] != -1) {\n\t  for (int j = -1; j <= 1; j++) {\n\t    int vel = nd.vel + j;\n\t    if (vel > 0 && vel <= c[nd.now][i]) {\n\t      Node next(nd.now, i, vel, nd.time + (double)d[nd.now][i] / vel);\n\t      q.push(next);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    if (!goal) {\n      cout << \"unreachable\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nusing tp = tuple<int, int, int>;\nusing ttp = tuple<ld, int, int>;\n\nconst ld INF = 1e20;\n\nint main()\n{\n\tcout << fixed << setprecision(8);\n\tint n, m;\n\twhile (cin >> n >> m, n | m) {\n\t\tint s, g;\n\t\tcin >> s >> g; s--, g--;\n\t\tvector<vector<tp>> G(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c; x--, y--;\n\t\t\tG[x].emplace_back(y, d, c);\n\t\t}\n\t\tvector<vector<ld>> d(n, vector<ld>(31, INF));\n\t\tpriority_queue<ttp, vector<ttp>, greater<ttp>> pq;\n\t\tpq.emplace(0.0, s, 0);\n\t\twhile (!pq.empty()) {\n\t\t\tauto p = pq.top(); pq.pop();\n\t\t\tint v = get<1>(p), ve = get<2>(p);\n\t\t\tld cos = get<0>(p);\n\t\t\tif (d[v][ve] != INF) continue;\n\t\t\td[v][ve] = cos;\n\t\t\tfor (auto e : G[v]) {\n\t\t\t\tint to = get<0>(e), st = get<2>(e);\n\t\t\t\tld dis = get<1>(e);\n\t\t\t\tfor (int i = -1; i <= 1; i++) if (0 < ve + i && ve + i <= st) {\n\t\t\t\t\tif (d[to][ve + i] == INF) {\n\t\t\t\t\t\tpq.emplace(cos + dis / (ve + i), to, ve + i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[g][1] == INF) cout << \"unreachable\" << endl;\n\t\telse cout << d[g][1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 500\ntypedef std::pair<short,short> P;\ntypedef std::pair<P,short> PP;\ntypedef std::pair<float,short> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    short n,m;\n\n    scanf(\"%hd%hd\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    short inx,iny,ind,inc;\n    float d[31][31][31];\n    short s,g;\n \n\n    scanf(\"%hd%hd\",&s,&g);\n    for(short i=1;i<=n;i++)for(short j=1;j<=n;j++)for(short k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(short i=0;i<m;i++){\n      scanf(\"%hd%hd%hd%hd\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    \n    while(que.size()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(short i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<set>\n#define INF 100000.0\nusing namespace std;\nstruct S{\n\tint town;\n\tint from;\n\tint v;\n\tdouble cost;\n\tvoid set(int a,int b,int c,double d){\n\t\ttown=a;from=b;v=c;cost=d;\n\t}\n\tinline bool operator<(const S &a)const{\n\t\treturn this->cost<a.cost;\n\t}\n};\ndouble dp[30][30][31];\nint d[30][30];\nint c[30][30];\nmultiset<S> Set;\nmultiset<S>::iterator it; \nint main(){\t\n\tint n,m;\n\tint s,g;\n\tint x,y,t,u;\n\tdouble min;\n\tbool start;\n\tS a,b;\n\twhile(cin>>n>>m,n||m){\n\t\tmemset(d,-1,sizeof(d));\n\t\tmemset(c,-1,sizeof(c));\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<30;j++)for(int k=1;k<31;k++)dp[i][j][k]=INF;\n\t\tcin>>s>>g;\n\t\ts--;g--;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>x>>y;\n\t\t\tx--;y--;\n\t\t\tcin>>t;\n\t\t\td[y][x]=d[x][y]=t;\n\t\t\tcin>>t;\n\t\t\tc[y][x]=c[x][y]=t;\n\t\t}\n\t\ta.set(s,-1,1,0.0);\n\t\tSet.insert(a);\n\t\tstart=true;\n\t\twhile(!Set.empty()){\n\t\t\tit=Set.begin();\n\t\t\ta=*it;\n\t\t\tSet.erase(it);\n\t\t\tif(dp[a.town][a.from][a.v] < a.cost)continue;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tt=d[a.town][i];\n\t\t\t\tif(a.from==i || t==-1)continue;\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tu=c[a.town][i];\n\t\t\t\t\tif(a.v+j<1 || a.v+j>u)continue;\n\t\t\t\t\tif(start && j!=0)continue;\n\t\t\t\t\tb.set(i,a.town,a.v+j,a.cost+(double)t/(a.v+j));\n\t\t\t\t\tif(b.cost < dp[b.town][b.from][b.v]){\n\t\t\t\t\t\tdp[b.town][b.from][b.v]= b.cost;\n\t\t\t\t\t\tSet.insert(b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart=false;\n\t\t}\n\t\tmin=INF;\n\t\tfor(int i=0;i<n;i++)if(dp[g][i][1]<min)min=dp[g][i][1];\n\t\tif(min!=INF)printf(\"%.5f\\n\",min);//cout<<min<<endl;\n\t\telse cout<<\"unreachable\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint n, m, s, g;\n\nstruct S{\n    int to;\n    double cost;\n    int speed;\n    int prev;\n    //このままソートするとコストの昇順になる。priority_queueだと逆になる\n    //priority_queue<S, vector<S>, greater<S> >の時はoperator>を定義しないと壊れる\n    bool operator<(const S &s) const{\n        return cost > s.cost;\n    }\n};\nstruct edge{\n   int to, len, speed;\n};\n\nvector<edge> G[31];\ndouble d[31][31];\n\nvoid dijkstra(int s){\n    rep(i, 0, n) rep(j, 0, 31) d[i][j] = INF;\n    d[s][0] = 0;\n    priority_queue<S> q;\n    q.push({s, 0, 0, -1});\n    while(!q.empty()){\n        S p = q.top(); q.pop();\n        int from = p.to;\n        double cost = p.cost;\n        int speed = p.speed;\n        int prv = p.prev;\n        if(d[from][speed] < cost) continue;\n        rep(i, 0, G[from].size()){\n            edge e = G[from][i];\n            int next = e.to;\n            if(prv == next) continue;\n            for(int j = -1; j <= 1; j++){\n                if(speed + j < 0 || speed + j > 30) continue;\n                if(speed + j > e.speed) continue;\n                double newCost = (double)e.len / (double)(speed + j) + cost;\n                if(d[next][speed + j] > newCost){\n                    // cout << next << ' ' << speed + j << ' ' << newCost << endl;\n                    d[next][speed + j] = newCost;\n                    q.push({next, newCost, speed + j});\n                } \n            }\n        }\n    }\n}\n\nsigned main(){\n    while(1){\n        cin >> n >> m;\n        if(n + m == 0) break;\n        cin >> s >> g;\n        s--; g--;\n        rep(i, 0, n) G[i].clear();\n        rep(i, 0, m){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            G[x].push_back({y, d, c});\n            G[y].push_back({x, d, c});\n        }\n        dijkstra(s);\n        double ans = d[g][1];\n        if(ans > INF - 1) cout << \"unreachable\" << endl;\n        else printf(\"%.10f\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 100\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cfloat>\n\nusing namespace std;\n\nint n, m;\n\nstruct edge {\n\tint dist, lim;\n};\n\nstruct P {\n\tint from, pos, v;\n\tdouble time;\n\n\tbool operator >(const P& p) const {\n\t\treturn time > p.time;\n\t}\n};\n\nedge elist[31][31];\ndouble G[31][31];\n\nint main() {\n\tint s, g;\n\twhile (cin >> n >> m, n|m) {\n\t\tfor(int i=0; i<31; i++){\n\t\t\tfor(int j=0; j<31; j++){\n\t\t\t\telist[i][j] = {-1, -1};\n\t\t\t}\n\t\t}\n\t\tfill_n((double *)G, 31*31, DBL_MAX);\n\t\tcin >> s >> g;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\telist[x][y] = {d, c};\n\t\t\telist[y][x] = {d, c};\n\t\t}\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\tq.push({-1, s, 0, 0.0});\n\t\tbool goal = false;\n\t\twhile(!q.empty()){\n\t\t\tP p = q.top(); q.pop();\n\t\t\t// goal\n\t\t\tif (p.pos == g && p.v == 1) {\n\t\t\t\tprintf(\"%f\\n\", p.time);\n\t\t\t\tgoal = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=1; i<=n; i++) {\n\t\t\t\tif(elist[p.pos][i].dist != -1 && p.from != i) {\n\t\t\t\t\t// v+1\n\t\t\t\t\tif(p.v + 1 <= elist[p.pos][i].lim) {\n\t\t\t\t\t\tdouble time = p.time + (double)elist[p.pos][i].dist / (double)(p.v+1);\n\t\t\t\t\t\tif(time < G[i][p.v+1]){\n\t\t\t\t\t\t\tq.push({p.pos, i, p.v+1, time});\n\t\t\t\t\t\t\tG[i][p.v+1] = time;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// v\n\t\t\t\t\tif(p.v <= elist[p.pos][i].lim) {\n\t\t\t\t\t\tdouble time = p.time + (double)elist[p.pos][i].dist / (double)p.v;\n\t\t\t\t\t\tif(time < G[i][p.v]){\n\t\t\t\t\t\t\tq.push({p.pos, i, p.v, time});\n\t\t\t\t\t\t\tG[i][p.v] = time;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// v-1\n\t\t\t\t\tif(p.v -1 <= elist[p.pos][i].lim && p.v-1 > 0) {\n\t\t\t\t\t\tdouble time = p.time + (double)elist[p.pos][i].dist / (double)(p.v-1);\n\t\t\t\t\t\tif(time < G[i][p.v-1]){\n\t\t\t\t\t\t\tq.push({p.pos, i, p.v-1, time});\n\t\t\t\t\t\t\tG[i][p.v-1] = time;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!goal) cout << \"unreachble\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 200\ntypedef std::pair<short,short> P;\ntypedef std::pair<P,short> PP;\ntypedef std::pair<float,short> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    short n,m;\n\n    scanf(\"%hd%hd\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    short inx,iny,ind,inc;\n    float d[31][31][31];\n    short s,g;\n \n\n    scanf(\"%hd%hd\",&s,&g);\n    for(short i=1;i<=n;i++)for(short j=1;j<=n;j++)for(short k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(short i=0;i<m;i++){\n      scanf(\"%hd%hd%hd%hd\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    \n    while(que.size()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(short i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<iomanip>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define sc second\n#define pb push_back\n#define mk make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntemplate<class S,class T>\nostream &operator<<(ostream &out, const pair<S,T> p){\n\treturn out << \"(\" << p.fs << \", \" << p.sc << \")\";\n}\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \", \";\n\treturn out << \"}\" << endl;\n}\n\n#define N 30\ndouble d[N+1][N];\nint main(){\n\tint n, m, s, g;\n\twhile(cin >> n >> m, n){\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\t\tfill(d[0], d[0] + (N+1) * N, -1);\n\t\tvector<pair<int,double> > e[N+2][N];// e[c][x] : from x at vert c list\n\t\trep(i, m){\n\t\t\tint x, y, di, c;\n\t\t\tcin >> x >> y >> di >> c;\n\t\t\tx--; y--;\n\t\t\treps(j,1,c+1){\n\t\t\t\tdouble time = di / (double) j;\n\t\t\t\te[j][x].pb(mk(y, time));\n\t\t\t\te[j][y].pb(mk(x, time));\n\t\t\t}\n\t\t}\n\t\t// dst, from, current, ver\n\t\tpriority_queue<pair<double, pair<pii, int> > > q;\n\t\tq.push(mk(0, mk(pii(-1, s), 0)));\n\t\twhile(!q.empty()){\n\t\t\tdouble dst = -q.top().fs;\n\t\t\tint from = q.top().sc.fs.fs;\n\t\t\tint cur = q.top().sc.fs.sc, ver = q.top().sc.sc;\n\t\t\tq.pop();\n\t\t\tif(d[ver][cur] >= 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[ver][cur] = dst;\n\t\t\tif(ver == 1 && cur == g) break;\n\t\t\trep(i,3){\n\t\t\t\tint ci = ver - 1 + i;\n\t\t\t\tif(ci<1 || ci > N+1) continue;\n\t\t\t\trep(j, e[ci][cur].size()){\n\t\t\t\t\tpair<int, double> p = e[ci][cur][j];\n\t\t\t\t\tint to = p.fs;\n\t\t\t\t\tif (from == to) continue;\n\t\t\t\t\tdouble tmp = dst + p.sc;\n\t\t\t\t\tq.push(mk(-tmp, mk( pii(cur, to), ci)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(d[1][g] < 0) cout << \"unreachable\" << endl;\n\t\telse cout <<fixed << setprecision(10)<< d[1][g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, dist, maxV;\n};\nstruct Node {\n\tint n, prev, v;\n\tdouble cost;\n};\nbool operator >(const Node& n1, const Node& n2) {\n\treturn n1.cost > n2.cost;\n}\n\n#define INF 1e9\n#define EPS 1e-12\n\nint main() {\n\tint N, M;\n\twhile (cin >> N >> M, N || M) {\n\t\tint s, g; cin >> s >> g; --s, --g;\n\n\t\tvector< vector<Edge> > edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y, d, c; cin >> x >> y >> d >> c; --x, --y;\n\t\t\tedges[x].push_back( (Edge){ y, d, c } );\n\t\t\tedges[y].push_back( (Edge){ x, d, c } );\n\t\t}\n\n\t\tdouble ans = INF;\n\t\tbool gone[30][30][31] = {0};\n\t\tpriority_queue<Node, vector<Node>, greater<Node> > Q; Q.push( (Node){s, -1, 0, 0} );\n\t\twhile ( !Q.empty() ) {\n\t\t\tNode node = Q.top(); Q.pop();\n\t\t\tint n = node.n, prev = node.prev, v = node.v;\n\t\t\tdouble cost = node.cost;\n\n\t\t\tif (prev > -1) {\n\t\t\t\tif (gone[n][prev][v]) continue;\n\t\t\t\tgone[n][prev][v] = true;\n\t\t\t}\n\n\t\t\tif (n == g && v == 1) {\n\t\t\t\tans = min(ans, cost);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int dv = -1; dv <= 1; ++dv) {\n\t\t\t\tint nv = v+dv;\n\t\t\t\tif (nv <= 0) continue;\n\t\t\t\tfor (int i = 0; i < edges[n].size(); ++i) {\n\t\t\t\t\tEdge& e = edges[n][i];\n\t\t\t\t\tif (nv <= e.maxV && e.to != prev) {\n\t\t\t\t\t\tQ.push( (Node){e.to, n, nv, cost+(double)e.dist/nv} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans >= INF - EPS) cout << \"unreachable\" << endl;\n\t\telse printf(\"%.10f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<functional>\n \n \n#define rep(i,n) for(int i=0;i<(n);i++)\n \nusing namespace std;\nconst int INF = 100000000;\nconst double EPS = 0.0000001;\ntypedef pair<int,int> P;\n\nint n,m;\n\nstruct edge\n{\n\t//どこから来た,コスト,速度制限\n\tint to,cost,ub;\n\tedge(int to,int cost,int ub) {\n\t\tthis->to = to;\n\t\tthis->cost = cost;\n\t\tthis->ub = ub;\n\t}\n};\n\nvector<edge> G[103];\nint s,g;\ndouble dist[103][103][33];\n\ntypedef pair<double,int> PD;\ntypedef pair<PD,P> PP;\n\ndouble dijkstra() {\n\trep(i,103) rep(j,103) rep(k,33) dist[i][j][k]=INF;\n\tdist[s][0][0]=0;\n\n\t//最短距離 頂点 前の頂点 今の速さ\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(PD(0,s),P(0,0)));\n\n\twhile (!que.empty())\n\t{\n\t\tPP pp = que.top(); que.pop();\n\t\tint v = pp.first.second;\n\n\t\tint prev = pp.second.first;\n\t\t//今の速度\n\t\tint u = pp.second.second;\n\n\t\t//printf(\"[debug] %f,%d,%d,%d\\n\",pp.first.first,v,prev,u);\n\n\t\tif(dist[v][prev][u] < pp.first.first) continue;\n\n\t\trep(i,G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(e.to == prev) continue;\n\t\t\tfor(int j=-1;j<=1;j++) {\n\t\t\t\tif(j+u<=0 || u+j > e.ub) continue;\n\n\n\t\t\t\tif(dist[e.to][v][u+j] > dist[v][prev][u] + (1.0*e.cost/(u+j))) {\n\t\t\t\t\tdist[e.to][v][u+j] = dist[v][prev][u] + (1.0*e.cost/(u+j));\n\n\t\t\t\t\tque.push(PP(PD(dist[e.to][v][u+j],e.to),P(v,u+j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tdouble ans=INF;\n\trep(i,103) ans=min(ans,dist[g][i][1]);\n\n\treturn ans;\n\t\n}\n\nvoid solve() {\n\trep(i,103) G[i].clear();\n\tcin>>s>>g;\n\trep(i,m) {\n\t\tint x,y,d,c;\n\t\tcin>>x>>y>>d>>c;\n\t\tG[x].push_back(edge(y,d,c));\n\t\tG[y].push_back(edge(x,d,c));\n\t}\n\n\tdouble ans;\n\tans = dijkstra();\n\tif(ans==INF) {\n\t\tcout<<\"unreachable\"<<endl;\n\t}\n\telse\n\t{\n\t\tcout<<ans<<endl;\n\t}\n\n\n}\n\nint main() {\n\twhile (cin>>n>>m)\n\t{\n\t\tif(n+m==0) return 0;\n\t\tsolve();\n\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000.0\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<double,int> P;\n\nint n, m;\nint s, g;\ndouble dp[40*900+30*30+30];\nvector<P> e[40*900+30*30+30];\n\nvoid solve(){\n\tcin >> s >> g;\n\ts--; g--;\n\trep(i,40*900+30*30+30){\n\t\tdp[i] = INF;\n\t\te[i].clear();\n\t}\n\trep(i,m){\n\t\tint x, y, c;\n\t\tdouble d;\n\t\tcin >> x >> y >> d >> c;\n\t\tx--; y--;\n\t\tfor(int j = 1; j <= c; j++) rep(k,n){\n\t\t\tif(k == y) continue;\n\t\t\te[j*900+k*30+x].push_back(P(d/j,j*900+x*30+y));\n\t\t\te[j*900+k*30+x].push_back(P(d/j,(j+1)*900+x*30+y));\n\t\t\te[j*900+k*30+x].push_back(P(d/j,(j-1)*900+x*30+y));\n\t\t}\n\t\tfor(int j = 1; j <= c; j++) rep(k,n){\n\t\t\tif(k == x) continue;\n\t\t\te[j*900+k*30+y].push_back(P(d/j,j*900+y*30+x));\n\t\t\te[j*900+k*30+y].push_back(P(d/j,(j+1)*900+y*30+x));\n\t\t\te[j*900+k*30+y].push_back(P(d/j,(j-1)*900+y*30+x));\n\t\t}\n\t}\n\tpriority_queue<P> que;\n\tque.push(P(0.0,1*900+s*30+s));\n\tdp[1*900+s*30+s] = 0.0;\n\twhile(true){\n\t\tif(que.size() == 0) break;\n\t\tP q = que.top();\n\t\tque.pop();\n\t\tif(q.first > dp[q.second]) continue;\n\t\trep(i,e[q.second].size()){\n\t\t\tP p = e[q.second][i];\n\t\t\tif(dp[p.second] > q.first+p.first){\n\t\t\t\tdp[p.second] = q.first+p.first;\n\t\t\t\tque.push(P(dp[p.second],p.second));\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans = INF;\n\trep(i,n) ans = min(ans,dp[0*900+i*30+g]);\n\tif(ans == INF) puts(\"unreachable\");\n\telse printf(\"%.9f\\n\",ans);\n}\n\nint main(){\n\twhile(cin >> n >> m){\n\t\tif(n == 0 && m == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nstruct edge{//Óð\\·\n\tint to,cost,limit;\n\tedge(int t,int c,int l){\n\t\tto=t;cost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{//L[ÉüêéóÔð\\·\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tbool visit[31][31][31];\n\t//¬ÌÔC¼OÉKê½¬ÌÔC¬xÅ_CNXg\n\tmemset(visit,false,sizeof(visit));\n\tvector<vector<edge> > E(n+1);\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){//AXgÌì¬\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in].push_back(edge(out,c,l));\n\t\tE[out].push_back(edge(in,c,l));\n\t}\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){//_CNXg\n\t\tNode t=Q.top(); Q.pop();\n\t\tif(visit[t.now][t.before][t.speed]) continue;//ùÉ½æ\n\t\tvisit[t.now][t.before][t.speed]=true;//Üµ½\n\t\tif(t.now==g && t.speed==1){printf(\"%.12lf\\n\", t.time );  return;}//¦ðoÍ\n\n\t\tfor(int i=0;i<E[t.now].size();i++){//ÓªÂÈªÁÄé\n\t\t\tint to=E[t.now][i].to;\n\t\t\tif(to==t.before) continue;//U^[Ö~\n\n\t\t\t//¬xð¸ç·CÛCâ·\n\t\t\t//¬xª1Èã@½±ÆªÈ¢@§À¬xðI[o[µÈ¢ÈçL[ÉËÁÞ\n\t\t\tfor(int s=-1;s<=1;s++){\n\t\t\t\tif(t.speed+s>=1 && !visit[to][t.now][t.speed+s] && E[t.now][i].limit>=t.speed+s)\n\t\t\t\t\tQ.push(Node(to,t.speed+s,t.time+E[t.now][i].cost/((double)t.speed+s),t.now));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\"<<endl;\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define INF 100000000\n#define rep(i,n) for(int i=0;i<n;i++)\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<double,p> P;\nstruct edge{\n\tint to,d,c;\n};\nint main(){\n\tdouble dp[31][31];\n\tint n,m,s,g,x,y,d,c,ds[]={1,-1,0};\n\twhile(cin>>n>>m,n||m){\n\t\tvector<edge> G[31];\n\t\tcin>>s>>g;\n\t\ts--;g--;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tx--;y--;\n\t\t\tedge e;\n\t\t\te.d=d;e.c=c;e.to=y;\n\t\t\tG[x].push_back(e);\n\t\t\te.to=x;\n\t\t\tG[y].push_back(e);\n\t\t}\n\t\trep(i,31)\n\t\trep(j,31)\n\t\tdp[i][j]=INF;\n\t\tdp[0][s]=0.0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(0.0,p(0,s)));\n\t\tdouble ans=INF;\n\t\twhile(!que.empty()){\n\t\t\tP q=que.top();que.pop();\n\t\t\tif(q.second.second==g&&q.second.first==1){\n\t\t\t\tans=min(ans,dp[q.second.first][q.second.second]);\n\t\t\t//\tcout<<ans<<endl;\n\t\t\t}\n\t\t\t//cout<<q.second.second<<' '<<q.second.first<<' '<<q.first<<endl;\n\t\t\tif(dp[q.second.first][q.second.second]<q.first)\n\t\t\t\tcontinue;\n\t\t\trep(i,G[q.second.second].size()){\n\t\t\t\tedge e=G[q.second.second][i];\n\t\t\t\trep(j,3){\n\t\t\t\t\tint pre=(q.second.first+ds[j]);\n\t\t\t\t\tif(pre<1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble tes=(double)e.d/pre+q.first;\n\t\t\t\t\tif(0<q.second.first+ds[j]&&q.second.first+ds[j]<=e.c&&dp[q.second.first+ds[j]][e.to]>tes){\n\t\t\t\t\t\tque.push(P(tes,p(q.second.first+ds[j],e.to)));\n\t\t\t\t\t\tdp[q.second.first+ds[j]][e.to]=tes;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans==INF)\n\t\tcout<<\"unreachable\"<<endl;\n\t\telse\n\t\tprintf(\"%.5lf\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<map>\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\ntypedef struct {\n    int dis;\n    int lim;\n} edge;\ntypedef pair<int,int> pp;\ntypedef pair<int, pp> node; // v, (x,y)\ntypedef pair<double, node> que; // sum, (v, (x,y))\n\nedge input[50][50];\ndouble G[50][50][50]; // x, y, v\n\nint main(void) {\n    while(1) {\n        int n,m,s,g;\n        scanf(\"%d%d\",&n,&m);\n        if(!n) break;\n        scanf(\"%d%d\",&s,&g);\n        s--, g--;\n\n        memset(input, 0, sizeof(input));\n        memset(G, 0, sizeof(G));\n\n        for(int i=0; i<m; i++) {\n            int x,y,d,c;\n            scanf(\"%d%d%d%d\",&x,&y,&d,&c);\n            x--, y--;\n            input[x][y] = input[y][x] = {d,c};\n        }\n\n        map<node,double> tbl;\n        priority_queue<que> q;\n        for(int i=0; i<n; i++)\n            if(input[s][i].dis)\n                q.push(que(-0.0, node(1, pp(s,i))));\n\n        double res = -1.0;\n        while(q.size()) {\n            que t = q.top(); q.pop();\n\n            int v = t.snd.fst;\n            int x = t.snd.snd.fst, y = t.snd.snd.snd;\n            if(!(0<v && v<=input[x][y].lim)) continue;\n\n            double sum = -t.fst + 1.0* input[x][y].dis / v;\n\n            if(tbl.find(t.snd) != tbl.end()) continue;\n            tbl[t.snd] = sum;\n\n            if(y == g && v == 1) {\n                res = sum;\n                break;\n            }\n\n            for(int i=0; i<n; i++)\n                if(i!=x && input[y][i].dis) {\n                    int dv[] = {-1,0,1};\n                    for(int iv=0; iv<3; iv++)\n                        q.push(que(-sum, node(v+dv[iv], pp(y,i))));\n                }\n        }\n        if(res==-1.0)\n            puts(\"unreachable\");\n        else\n            printf(\"%f\\n\", res);\n\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m;\nll s, g;\n\nclass DK {\npublic:\n\tstruct edge {\n\t\tint to;\n\t\tdouble cost;\n\t\tll cap;\n\t\tedge(int _to, double _cost, ll _cap) :to(_to), cost(_cost), cap(_cap) {}\n\t};\n\n\tdouble d[110][110];\n\tvector<edge> G[110];//各頂点からの辺\n\n\tvoid dijkstra() {\n\t\trep(i, 110)rep(j, 110)d[i][j] = INF;\n\t\td[s][0] = 0;\n\n\t\ttypedef pair<pair<double, ll>, ll> PP;\n\t\tpriority_queue<PP, vector<PP>, greater<PP>> que;\n\t\tque.push({ {0, 0},s });\n\n\t\twhile (!que.empty()) {\n\t\t\tPP p = que.top();\n\t\t\tque.pop();\n\t\t\tll nn = p.second;\n\t\t\tll v = p.first.second;\n\t\t\tif (d[nn][v] < p.first.first)continue;\n\t\t\tfor (int i = 0; i < G[nn].size(); i++) {\n\t\t\t\tedge e = G[nn][i];\n\t\t\t\tFOR(j, -1, 2) {\n\t\t\t\t\tdouble nv = v + j;\n\t\t\t\t\tif (nv <= 0)continue;\n\t\t\t\t\tif (nv > e.cap)continue;\n\t\t\t\t\tif (d[e.to][(ll)nv] > d[nn][v] + e.cost / nv) {\n\t\t\t\t\t\td[e.to][(ll)nv] = d[nn][v] + e.cost / nv;\n\t\t\t\t\t\tque.push({ {d[e.to][(ll)nv], nv},e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n};\n\nDK dk;\n\nint main() {\n\twhile (cin >> n >> m&&n + m) {\n\t\trep(i, 110)dk.G[i].clear();\n\t\tcin >> s >> g;\n\t\trep(i, m) {\n\t\t\tint x, y;\n\t\t\tll c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tdk.G[x].push_back(DK::edge(y, d, c));\n\t\t\tdk.G[y].push_back(DK::edge(x, d, c));\n\t\t}\n\t\tdk.dijkstra();\n\t\t//rep(i, n) {\n\t\t//\trep(j, 30) {\n\t\t//\t\tcout << dk.d[i + 1][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tdouble ans = dk.d[g][1];\n\t\tif ((ll)ans == INF)cout << \"unreachable\" << endl;\n\t\telse printf(\"%.10lf\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define fr first\n#define sc second\nusing namespace std;\n#define INF 10000000\ntypedef pair<int,int> iiP;\ntypedef pair<double,int> diP;\ntypedef pair<diP,iiP> PP;\nstruct edge{\n  int to,limit;\n  double dist;\n  edge(){}\n  edge(int to,double dist,int limit):to(to),dist(dist),limit(limit){};\n};\nint n,m;\nint S,G;\ndouble t[31][31][31];\nbool used[31][31][31];\nint main(){\n\n  while(cin >> n >> m && (n||m)){\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n        for(int k=0;k<31;k++){\n          used[i][j][k] = false;\n          t[i][j][k] = INF;\n        }\n      }\n    }\n    cin >> S >> G;\n    vector< vector<edge> > info(n + 1);\n    for(int i=0,x,y,d,c;i<m;i++){\n      cin >> x >> y >> d >> c;\n      info[x].push_back(edge(y,d,c));\n      info[y].push_back(edge(x,d,c));\n    }\n\n    t[S][0][0] = 0.0;\n    priority_queue< PP,vector<PP>,greater<PP> > que;\n    que.push(PP(diP(0.0,S),iiP(0,0)));\n    while(!que.empty()){\n      PP p = que.top();\n      int now = p.fr.sc,prev = p.sc.fr,speed = p.sc.sc;\n      double time = p.fr.fr;\n\n      que.pop();\n      if( used[now][prev][speed] ) continue;\n      used[now][prev][speed] = true;\n\n      for(int i = 0,l = info[now].size();i < l;i++){\n        edge e = info[now][i];\n        if(e.to != prev){\n          for(int j = -1;j < 2;j++){\n            if(speed + j > 0 && speed + j <= e.limit && !used[e.to][now][speed + j]){\n              if(t[e.to][now][speed + j] > time + e.dist / (speed + j)){\n                t[e.to][now][speed + j] = time + e.dist / (speed + j);\n                que.push(PP(diP(t[e.to][now][speed + j],e.to),iiP(now,speed + j)));\n              }\n            }\n          }\n        }\n      }\n    }\n    double ans = INF;\n    for(int i=0;i<=n;i++) ans = min(ans,t[G][i][1]);\n    if(ans == INF) cout << \"unreachable\" << endl;\n    else{\n      cout << fixed << setprecision(7) << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint n, m;\n\t\tcin>>n>>m;\n\t\tif(n == 0 && m == 0) break;\n\t\tint s, g;\n\t\tcin>>s>>g;\n\t\t--s;\n\t\t--g;\n\t\tvector<vector<pair<ll, P> > > p(n);\n\t\tvector<vector<vector<double> > > d(n, vector<vector<double> >(n, vector<double>(31, INF)));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\t--x;\n\t\t\t--y;\n\t\t\tp[x].pb({y, P(d, c)});\n\t\t\tp[y].pb({x, P(d, c)});\n\t\t}\n\t\tpriority_queue<pair<pair<double, ll>, P>, vector<pair<pair<double, ll>, P> >, greater<pair<pair<double, ll>, P> > > q;\n\t\tREP(i, n) {\n\t\t\td[0][i][1] = 0;\n\t\t}\n\t\tq.push({{0, 0}, {0, 1}});\n\t\twhile(!q.empty()) {\n\t\t\tpair<pair<double, ll>, P> np = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[np.first.second][np.second.first][np.second.second] != np.first.first) continue;\n\t\t\tFOR(i, -1, 2) {\n\t\t\t\tll ns = np.second.second + i;\n\t\t\t\tif(np.first.second == 0 && np.second.first == 0) {\n\t\t\t\t\tif(ns != 1) continue;\n\t\t\t\t}\n\t\t\t\tif(ns <= 0) continue;\n\t\t\t\tREP(j, p[np.first.second].size()) {\n\t\t\t\t\tll next = p[np.first.second][j].first;\n\t\t\t\t\tif(next == np.second.first) continue;\n\t\t\t\t\tif(p[np.first.second][j].second.second < ns) continue;\n\t\t\t\t\tif(next == g && ns != 1) continue;\n\t\t\t\t\tif(d[next][np.first.second][ns] > d[np.first.second][np.second.first][np.second.second] + p[np.first.second][j].second.first / (double)ns) {\n\t\t\t\t\t\td[next][np.first.second][ns]  = d[np.first.second][np.second.first][np.second.second] + p[np.first.second][j].second.first / (double)ns;\n\t\t\t\t\t\tq.push({{d[next][np.first.second][ns], next}, {np.first.second, ns}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = INF;\n\t\tREP(i, n) {\n\t\t\tans = min(ans, d[g][i][1]);\n\t\t}\n\t\tif(ans != INF) cout<<fixed<<showpoint<<setprecision(39)<<ans<<endl;\n\t\telse cout<<\"unreachable\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct State {\n  int prev;\n  int now;\n  int vel; // 到着時\n  double e_time;\n  \n  bool operator < (const State &s) const {\n    return e_time > s.e_time;\n  }\n  \n  State() {}\n  State(int p, int n, int v, double t) :\n    prev(p), now(n), vel(v), e_time(t) {}\n};\n\nstruct Edge {\n  int to;\n  int cost;\n  int lim;\n  \n  Edge() {}\n  Edge(int t, int c, int l) : to(t), cost(c), lim(l) {}\n};\n\nconst double Inf = 1<<23;\nint N, M;\nvector<Edge> edges[30];\ndouble G_time[31][30][31]; // u, v, vel -> e_time\n\ndouble dijkstra(int s, int g) {\n  \n  fill(G_time[0][0], G_time[30][30], Inf);\n  priority_queue<State> pq;\n  \n  pq.push(State(s, s, 0, 0.0));\n  G_time[s][s][0] = 0.0;\n  \n  while(!pq.empty()) {\n    const State st = pq.top(); pq.pop();\n    \n    if(G_time[st.prev][st.now][st.vel] < st.e_time) {\n      continue;\n    }\n    \n    if(st.now == g && st.vel == 1) {\n      return st.e_time;\n    }\n    \n    for(int i=0; i<edges[st.now].size(); i++) {\n      const Edge &e = edges[st.now][i];\n      \n      if(e.to == st.prev) continue;\n      \n      for(int dvel = -1; dvel <= 1; dvel ++) {\n\tint nvel = st.vel + dvel;\n\t// 速度制限\n\tif(1 <= nvel && nvel <= e.lim) {\n\t  double ntime = st.e_time + (double)e.cost / nvel;\n\t  if(G_time[st.now][e.to][nvel] > ntime) {\n\t    G_time[st.now][e.to][nvel] = ntime;\n\t    pq.push(State(st.now, e.to, nvel, ntime));\n\t  }\n\t}\n\t\n      }\n    }\n  }\n  \n  return 42;\n}\n\nint main() {\n  int s, g;\n  \n  while(cin >> N >> M && (N|M)) {\n    cin >> s >> g;\n    s --, g --;\n    \n    for(int i=0; i<N; i++)\n      edges[i].clear();\n    \n    for(int i=0; i<M; i++) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      x --, y --;\n      edges[x].push_back(Edge(y, d, c));\n      edges[y].push_back(Edge(x, d, c));\n    }\n    \n    double ans = dijkstra(s, g);\n    if(ans == 42) {\n      cout << \"unreachable\" << endl;\n    } else {\n      printf(\"%.5lf\\n\", ans);\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\nstruct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n\nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\n// (time,speed,node,pre_node)\nusing P = pair<pair<double,int>,pair<int,int>>;\n\n\nP makeP(double t,int s,int n,int np){\n    return make_pair(make_pair(t,s),make_pair(n,np));\n}\n\nvoid solve(int n,int m){\n    int start,goal; cin>>start>>goal;\n    start--;\n    goal--;\n    vector<vector<int>> g(n,vector<int>(n,INF));\n    vector<vector<int>> lim(n,vector<int>(n,0));\n    rep(i,m){\n        int x,y,d,c;\n        cin>>x>>y>>d>>c;\n        x--;\n        y--;\n        g[x][y] = d;\n        g[y][x] = d;\n        lim[x][y] = c;\n        lim[y][x] = c;\n    }\n\n    double visited[32][32][32];\n    rep(i,32) rep(j,32) rep(k,32) visited[i][j][k]=DBL_MAX/10;\n    visited[start][0][start] = 0;\n\n    priority_queue<P,vector<P>,greater<P>> que;\n    que.push(makeP(0,0,start,start));\n    while(!que.empty()){\n        auto p = que.top();\n        que.pop();\n        double ti = p.first.first;\n        int speed = p.first.second;\n        int node = p.second.first;\n        int pre = p.second.second;\n\n#ifdef DEBUG\n        cerr << \"time : \" << ti << \" \"  << \"node : \" << node+1 << \" \" << \"speed \" << speed << endl;\n#endif\n        if(node==goal and speed==1){\n            cout << Double(ti) << endl;\n            return;\n        }\n\n        if(ti > visited[node][speed][pre]) continue;\n\n        for(int next_node=0;next_node<n;next_node++){\n            if(next_node==node or next_node==pre or g[node][next_node]==INF) continue;\n            int d=g[node][next_node];\n            int c=lim[node][next_node];\n            for(int nspeed=speed-1;nspeed<=speed+1;nspeed++){\n                if(nspeed<=0 or nspeed>c) continue;\n                double nt = ti + (double)d/(double)nspeed;\n                if(nt < visited[next_node][nspeed][node]){\n#ifdef DEBUG\n                    cerr << \"\\ttime \" << nt << \" \" << \"node \" << next_node+1 << \" speed \" << nspeed << endl;\n#endif\n                    visited[next_node][nspeed][node] = nt;\n                    que.push(makeP(nt,nspeed,next_node,node));\n                }\n            }\n        }\n    }\n    cout << \"unreachable\" << endl;\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m){\n        if(n==0 && m==0) break;\n        solve(n,m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<double, int> d_i;\ntypedef pair<int, int> i_i;\n\nstruct path {\n    int to;\n    int bound;\n    double dist;\n    path(int a, int b, double c) {\n        to = a;\n        bound = b;\n        dist = c;\n    }\n};\ndouble TIME[31][31][31];\n\nstruct query {\n    int pos;\n    int from;\n    int speed;\n    query(int a, int b, int c) {\n        pos = a;\n        from = b;\n        speed = c;\n    }\n    /*\n    bool operator< (const query &a) const {\n        return TIME[pos][from][speed] < TIME[a.pos][a.from][a.speed];\n    }\n    */\n};\n\nbool operator>(const query &a, const query &b) {\n    return TIME[a.pos][a.from][a.speed] > TIME[b.pos][b.from][b.speed];\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\n//dist[i][j][k] 現在地i jから来た 現在の速さk\nint n, m;\nvector<path> pathes[31];\nint main() {\n    cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        cin >> n >> m;\n        if(n == 0) break;\n        for(int i = 0; i <= 30; i++) {\n            pathes[i].clear();\n            for(int j = 0; j <= 30; j++) {\n                for(int k = 0; k <= 30; k++) {\n                    TIME[i][j][k] = 1e18;\n                }\n            }\n        }\n        int s, g;\n        cin >> s >> g;\n        while(m--) {\n            int x, y, c;\n            double d;\n            cin >> x >> y >> d >> c;\n            pathes[x].emplace_back(y, c, d);\n            pathes[y].emplace_back(x, c, d);\n        }\n        priority_queue<query, vector<query>, greater<query>> que;\n        que.emplace(s, 0, 0);\n        TIME[s][0][0] = 0.0;\n        bool reach = false;\n        double ans;\n        while(!que.empty()) {\n            query now = que.top();\n            que.pop();\n            //cerr << now.pos << \" \" << now.from << \" \" << now.speed << \" \" << TIME[now.pos][now.from][now.speed] << endl;\n            if(now.pos == g && now.speed == 1) {\n                reach = true;\n                cout << TIME[now.pos][now.from][now.speed] << endl;\n                break;\n            }\n            for(int speed = now.speed-1; speed <= now.speed+1; speed++) {\n                if(speed <= 0) continue;\n                for(int i = 0; i < pathes[now.pos].size(); i++) {\n                    path nowpath = pathes[now.pos][i];\n                    if(nowpath.to == now.from) continue;\n                    if(nowpath.bound < speed) continue;\n                    double nowtime = TIME[now.pos][now.from][now.speed] + nowpath.dist / (double)speed;\n                    if(nowtime < TIME[nowpath.to][now.pos][speed]) {\n                        TIME[nowpath.to][now.pos][speed] = nowtime;\n                        que.emplace(nowpath.to, now.pos, speed);\n                    }\n                }\n            }\n        }\n        if(!reach) cout << \"unreachable\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n\n\n\nint n, m;\nint s, g;\n\nstruct Edge {\n    int to, dist, c;\n    Edge(int to, int dist, int c) {\n        this->to = to;\n        this->dist = dist;\n        this->c = c;\n    }\n};\n\nstruct Elem {\n    int d, p, v;\n    Elem(int d, int p, int v) {\n        this->d = d;\n        this->p = p;\n        this->v = v;\n    }\n\n    bool operator < (const Elem& rhs) const {\n        return this->d > rhs.d;\n    }\n};\n\n\ndouble d[31][31];\nvector<Edge> G[31];\n\nvoid dijkstra(int s, int v) {\n    priority_queue<Elem> que;\n    memset(d, \"0x3f\", sizeof(d));\n    d[s][v] = 0;\n    que.push(Elem(0, s, v));\n    while (!que.empty()) {\n        Elem point = que.top(); que.pop();\n        int x = point.p;\n        int velo = point.v;\n        if (d[x][velo] < point.d) {\n            continue;\n        }\n\n        for (int i = 0; i < G[x].size(); i++) {\n            Edge e = G[v][i];\n            //加速\n            if (e.c >= point.v + 1) {\n                if (d[e.to][point.v + 1] > point.d + e.dist / (point.v + 1)) {\n                    d[e.to][point.v + 1] = point.d + e.dist / (point.v + 1);\n                    que.push(Elem(d[e.to][point.v + 1], e.to, point.v + 1));\n                }\n            }\n            //等速\n            if (e.c >= point.v && point.v>0) {\n                if (d[e.to][point.v] > point.d + e.dist / (point.v)) {\n                    d[e.to][point.v] = point.d + e.dist / (point.v);\n                    que.push(Elem(d[e.to][point.v], e.to, point.v));\n                }\n\n            }\n            //減速\n            if (e.c >= point.v - 1 && point.v-1 > 0) {\n                if (d[e.to][point.v -1] > point.d + e.dist / (point.v - 1)) {\n                    d[e.to][point.v - 1] = point.d + e.dist / (point.v - 1);\n                    que.push(Elem(d[e.to][point.v - 1], e.to, point.v - 1));\n                }\n            }\n\n        }\n    }\n}\n\nint main() {\n        \n    while (cin >> n >> m >> s >> g, n) {\n        vector<Edge>vec[31];\n        for (int i = 0; i < 31; i++)G[i].clear();\n\n        for (int i = 0; i < m; i++) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            G[x].push_back(Edge(y, d, c));\n            G[y].push_back(Edge(x, d, c));\n        }\n\n        dijkstra(0, 1);\n\n\n        double ans = 1123456789;\n        for (int i = 0; i <= 30; i++) {\n            if (ans > d[g][i]&&d[g][i]!=0)ans = d[g][i];\n        }\n        \n        if (ans == 1123456789) {\n            cout << \"unreachable\" << endl;\n        }else cout << fixed << setprecision(10) << ans << endl;\n\n\n    }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst double INF = 1e99;\n\nstruct Edge {\n  int from, to, cost, cap;\n  Edge(int from_, int to_, int cost_, int cap_)\n    : from(from_), to(to_), cost(cost_), cap(cap_) { }\n};\n\nint main() {\n  cout.setf(ios::fixed);\n  cout.precision(4);\n  while(true) {\n    int N, M; cin >> N >> M;\n    if(N == 0) break;\n    int S, G; cin >> S >> G;\n    --S, --G;\n    vector<Edge> g;\n    for(int i = 0; i < M; ++i) {\n      int x,y,d,c; cin >> x >> y >> d >> c;\n      --x, --y;\n      g.emplace_back(x,y,d,c);\n      g.emplace_back(y,x,d,c);\n    }\n    M *= 2;\n    // [from][to][speed]\n    double d[N][N][31];\n    for(int i = 0; i < N; ++i)\n      for(int j = 0; j < N; ++j)\n        for(int c = 0; c < 31; ++c)\n          d[i][j][c] = INF;\n    for(int i = 0; i < M; ++i) {\n      if(g[i].from == S) {\n        d[S][g[i].to][1] = min(d[S][g[i].to][1], 1.0 * g[i].cost);\n      }\n    }\n    while(true) {\n      bool update = false;\n      for(int i = 0; i < M; ++i) {\n        for(int u = 0; u < N; ++u) {\n          if(g[i].to == u) continue;\n          if(g[i].from == u) continue;\n          for(int c = 1; c <= g[i].cap; ++c) {\n            for(int dc = -1; dc <= 1; ++dc) {\n              int nc = c + dc;\n              if(nc <= 0 || nc > g[i].cap) continue;\n              if(d[g[i].from][g[i].to][nc] > d[u][g[i].from][c] + 1.0 * g[i].cost / nc) {\n                d[g[i].from][g[i].to][nc] = d[u][g[i].from][c] + 1.0 * g[i].cost / nc;\n                update = true;\n              }\n            }\n          }\n        }\n      }\n      if(!update) break;\n    }\n    double ans = INF;\n    for(int u = 0; u < N; ++u) ans = min(ans, d[u][G][1]);\n    if(ans == INF) {\n      cout << \"unreachable\" << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <iomanip>\nusing namespace std;\nconst int inf = 1e9;\n\nstruct info{\n    char curr;\n    char prev;\n    char v;\n    double t;\n    info(int c, int p, int v, double t):curr(c),prev(p),v(v),t(t){}\n};\nnamespace std{\n    bool operator < (const info &a, const info &b){\n        return b.t < a.t;\n    }\n}\n\nint main(){\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n==0) break;\n\n        int s,g;\n        cin >> s >> g;\n        vector<vector<int> > dist(n+1, vector<int>(n+1, inf));\n        vector<vector<int> > limit(n+1, vector<int>(n+1, 0));\n        vector<info> map[31][31][31];\n        \n        for(int i=0; i<m; i++){\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            dist[x][y] = dist[y][x] = d;\n            limit[x][y] = limit[y][x] = c;\n        }\n\n        for(int i=1; i<=n; i++){ //curr\n            for(int j=1; j<=n; j++){ //prev\n                for(int k=1; k<=n; k++){ //next\n                    if(k==j || dist[i][k]==inf) continue;\n                    for(int v=1; v<=30; v++){ //speed\n                        for(int r=-1; r<=1; r++){\n                            if(v+r>0 && v+r <= limit[i][k]){\n                                map[i][j][v].push_back(info(k, i, v+r, (double)dist[i][k]/(v+r)));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for(int i=1; i<=n; i++){\n            if(dist[s][i] != inf){\n                map[s][0][1].push_back(info(i, s, 1, dist[s][i]));\n            }\n        }\n\n        priority_queue<info> pq;\n        pq.push(info(s, 0, 1, 0));\n        vector<vector<vector<double> > > mincost(n+1, vector<vector<double> >(n+1, vector<double>(31, inf)));\n        mincost[s][0][1] = 0;\n        while(!pq.empty()){\n            int curr = pq.top().curr;\n            int prev = pq.top().prev;\n            int v = pq.top().v;\n            double cost = pq.top().t;\n            pq.pop();\n            if(cost > mincost[curr][prev][v]) continue;\n            if(curr==g && v==1) break;\n            for(int i=0; i<(int)map[curr][prev][v].size(); i++){\n                info next = map[curr][prev][v][i];\n                if(cost + next.t < mincost[next.curr][next.prev][next.v]){\n                    pq.push(info(next.curr, next.prev, next.v, cost+next.t));\n                    mincost[next.curr][next.prev][next.v] = cost + next.t;\n                }\n            }\n        }\n        double ans=inf;\n        for(int i=1; i<=n; i++){\n            ans = min(ans, mincost[g][i][1]);\n        }\n        if(ans == inf){\n            cout << \"unreachable\" << endl;\n        }else{\n            cout << fixed;\n            cout << setprecision(10);\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <tuple>\n#include <queue>\nusing namespace std;\n#define INF 1 << 28\n\ntypedef tuple<double, int, pair<int, int>> State; //コスト, スピード, 前の場所, 今の場所\ntypedef tuple<int, int, int> Edge; // 接続先の都市, 道路の距離, 制限速度\ntypedef pair<int, int> Location;\nint n, m, s, g;\nvector<Edge> edge[30]; //都市の数だけ作成\ndouble memo[31][31][31]; //速度, 前の都市, 現在の都市\n\ndouble dijkstra(){\n  priority_queue<State, vector<State>, greater<State>> que;\n  que.push(make_tuple(0.0, 1, make_pair(s, s)));\n\n  while(!que.empty()){\n    double cost;\n    int v;\n    Location loc;\n    State now = que.top(); que.pop();\n    tie(cost, v, loc) = now;\n    int prev = loc.first, current = loc.second;\n    if(current == g && v == 1) return cost;\n    for(int i = 0;i < (int)edge[current].size();i++){\n      int to, dist, limitv;\n      tie(to, dist, limitv) = edge[current][i];\n      if(prev == to) continue;\n      int nv, nprev = current, ncurrent = to;\n      for(int i = -1; i <= 1 ; i++){\n        nv = v + i;\n        if(current == s && prev == s && i != 0) continue;\n        if(nv > limitv || nv <= 0 || nv >= 31) continue;\n        double ncost = cost + dist / (double)nv;\n        if(memo[nv][nprev][ncurrent] <= ncost) continue;\n        memo[nv][nprev][ncurrent] = ncost;\n        que.push(make_tuple(ncost, nv, make_pair(nprev, ncurrent)));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(void){\n  while(true){\n    cin >> n >> m;\n    if(n == 0 && m == 0) break;\n    for(int i = 0;i<30;i++) edge[i].clear();\n    for(int i = 0;i<31;i++){\n      for(int j = 0;j<31;j++){\n        for(int k = 0;k<31;k++){\n          memo[i][j][k] = INF;\n        }\n      }\n    }\n    cin >> s >> g;\n    s--; g--;\n    for(int i = 0;i<m;i++){\n      int x,y,d,c;\n      cin >> x >> y >> d >> c;\n      x--; y--;\n      edge[x].push_back(make_tuple(y, d, c));\n      edge[y].push_back(make_tuple(x, d, c));\n    }\n    double ans = dijkstra();\n    if(ans > -1) cout << ans << endl;\n    else cout << \"unreachable\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> edge;\ntypedef pair<int, P> PP;\ntypedef pair<double, PP> PPP;\n\nvector<edge> G[100];\ndouble memo[40][40][40];\ndouble need[200][40];\n priority_queue<PPP, vector<PPP>,greater<PPP> > que;\n\nint main(){\n  int n, m;\n  int s, g;\n  cout << clock() << endl;\n  for(int i = 0; i < 200; i++){\n    for(int j = 1; j < 40; j++) need[i][j] = (double)i / j;\n  }\n  while(cin >> n >> m && (n || m)){\n    scanf(\"%d%d\",&s,&g);\n    while(!que.empty()) que.pop();\n    fill(&memo[0][0][0], &memo[30][30][30]+1, 1e10);\n    for(int i = 0; i < m; i++){\n      int x1,y1,d,c;\n      scanf(\"%d%d%d%d\", &x1, &y1, &d, &c);\n      G[x1].push_back(edge(y1, P(d, c)));\n      G[y1].push_back(edge(x1, P(d, c)));\n    }\n    memo[s][0][32] = 0;\n   \n    que.push(PPP(memo[s][0][32], PP(0, P(s, 32))));\n    bool ok = false;\n\n    while(!que.empty()){\n      PPP ppp = que.top();\n      que.pop();\n      double dis = ppp.first;\n      int v = ppp.second.first;\n      int pos = ppp.second.second.first;\n      int pre = ppp.second.second.second;\n\n      if(dis > memo[pos][v][pre]) continue;\n     \n      if(pos == g && v == 1){\n\tcout << dis << endl;\n\tok = true;\n\tbreak;\n      }\n\n      for(int i = -1; i <= 1; i++){\n\tint v2 = v + i;\n\tfor(int j= 0; j < (int)G[pos].size(); j++){\n\t  int to = G[pos][j].first;\n\t  int li = G[pos][j].second.second;\n\t  int d = G[pos][j].second.first;\n\n\t  if(1 <= v2 && v2 <= li && to != pre){\n\t    if(memo[to][v2][pos] > dis + need[d][v2]){\n\t      memo[to][v2][pos] = dis + need[d][v2];\n\t      que.push(PPP(memo[to][v2][pos], PP(v2, P(to, pos))));\n\t    }\n\t  }\n\t}\n      }\n\n    }\n    if(!ok){\n      cout << \"unreachable\" << endl;\n    }\n    for(int i = 1; i <= 30; i++) G[i].clear();\n  }\n  cout << clock() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <queue>\n#include <set>\nusing namespace std;\ndouble memo[32][32][32]; //[vol][vertex][befor] = time\nint N,M,S,G;\nstruct e {\n\tint d,c;\n}edge[32][32];\n\nint main()\n{\n\tint x,y,d,c;\n\tfor(;cin>>N>>M,N||M;){\n\t\tcin>>S>>G;\n\t\tfor(int i=0;i<32;i++)for(int j=0;j<32;j++)for(int k=0;k<32;k++)\n\t\t\tmemo[i][j][k]=999999.0;\n\t\tfor(int i=0;i<32;i++)for(int j=0;j<32;j++)\n\t\t\tedge[i][j].d=edge[i][j].c=-1;\n\t\t\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tedge[x][y].d = edge[y][x].d = d;\n\t\t\tedge[x][y].c = edge[y][x].c = c;\n\t\t}\n\t\t//memo[1][S][0] = 0.0;\n\t\t\n\t\tdouble ans = 999999.0;\n\t\tqueue<pair<int,int> > qq;\n\t\tqueue<int> befor;\n\t\tqueue<double> cc;\n\t\tset<pair<int,int> > pst;\n\t\tset<pair<int,int> >::iterator pstit;\n\t\tqq.push(make_pair(0,S));\n\t\tbefor.push(S);\n\t\tcc.push(0.0);\n\t\tfor(;!qq.empty();){\n\t\t\tint vol = qq.front().first;\n\t\t\tint vertex = qq.front().second;\n\t\t\tint b = befor.front();\n\t\t\tdouble cost = cc.front();\n\t\t\t\n\t\t\tpst.clear();\n\t\t\tbefor.pop(); cc.pop(); qq.pop();\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\tif(i==vertex || i==b || edge[vertex][i].d < 0)continue;\n\t\t\t\t//if(i==G && vol>2)continue;\n\t\t\t\tif(vol>0 && vol<=edge[vertex][i].c){\n\t\t\t\t\t//printf(\"vol  (%d) %d->%d : %lf+%lf  memo[1][G][b]=%lf\\n\",vol,vertex,i,\n\t\t\t\t\t//\t\t (double)edge[vertex][i].d/vol,cost,memo[1][G][b]);\n\t\t\t\t\tif(memo[vol][i][b] > (double)edge[vertex][i].d/vol + cost &&\n\t\t\t\t\t\tans > (double)edge[vertex][i].d/vol + cost){\n\t\t\t\t\t\tmemo[vol][i][b] = (double)edge[vertex][i].d/vol + cost;\n\t\t\t\t\t\tqq.push(make_pair(vol,i));\n\t\t\t\t\t\tbefor.push(vertex);\n\t\t\t\t\t\tcc.push(memo[vol][i][b]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tans = min(ans,memo[1][G][b]);\n\t\t\t\t\t\t//pst.insert(make_pair(vol,i));\n\t\t\t\t\t}\n\t\t\t\t\t//printf(\"-- memo[vol][G][b]=%lf\\n\",memo[vol][G][b]);\n\t\t\t\t}\n\t\t\t\tif(vol+1>0 && vol+1<=edge[vertex][i].c){\n\t\t\t\t\t\n\t\t\t\t\tif(memo[vol+1][i][b] > (double)edge[vertex][i].d/(vol+1) + cost &&\n\t\t\t\t\t\tans > (double)edge[vertex][i].d/(vol+1) + cost){\n\t\t\t\t\t\tmemo[vol+1][i][b] = (double)edge[vertex][i].d/(vol+1) + cost;\n\t\t\t\t\t\tqq.push(make_pair(vol+1,i));\n\t\t\t\t\t\tbefor.push(vertex);\n\t\t\t\t\t\tcc.push(memo[vol+1][i][b]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tans = min(ans,memo[1][G][b]);\n\t\t\t\t\t\t//pst.insert(make_pair(vol+1,i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(vol-1>0 && vol-1<=edge[vertex][i].c){\n\t\t\t\t\t\n\t\t\t\t\tif(memo[vol-1][i][b] > (double)edge[vertex][i].d/(vol-1) + cost &&\n\t\t\t\t\t\tans > (double)edge[vertex][i].d/(vol-1) + cost){\n\t\t\t\t\t\tmemo[vol-1][i][b] = (double)edge[vertex][i].d/(vol-1) + cost;\n\t\t\t\t\t\tqq.push(make_pair(vol-1,i));\n\t\t\t\t\t\tbefor.push(vertex);\n\t\t\t\t\t\tcc.push(memo[vol-1][i][b]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tans = min(ans,memo[1][G][b]);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//pst.insert(make_pair(vol-1,i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//for(int k=1;k<32;k++)ans = min(ans,memo[1][G][k]);\n\t\t\t/*\n\t\t\tfor(pstit=pst.begin();pstit!=pst.end();pstit++){\n\t\t\t\tqq.push(*pstit);\n\t\t\t\tbefor.push(vertex);\n\t\t\t\tcc.push(memo[pstit->first][pstit->second]);\n\t\t\t}*/\n\t\t}\n\t\tprintf(ans==999999.0?\"unreachable\\n\":\"%lf\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\nconst int MAX_V = 31;\nconst int MAX_S = 31;\nconst double INF = 9e9;\n\nint n,m,s,g;\n\nstruct edge{\n\tint to, dist, speed;\n\tedge(int t_to,int t_dist,int t_speed){\n\t\tto=t_to;dist=t_dist;speed=t_speed;\n\t}\n};\n\nstruct state{\n\tdouble cost;\n\tint c_v,p_v,speed;\n\tstate(int t_c_v,int t_p_v,double t_cost,int t_speed){ \n\t\tc_v=t_c_v;p_v=t_p_v;cost=t_cost;speed=t_speed;\n\t}\n\tbool operator>(const state& s) const {\n\t\treturn cost > s.cost;\n\t}\n\n};\n\nint ds[]={-1,0,1};\nvector< vector<edge> > G(MAX_V);\ndouble d[MAX_V][MAX_V][MAX_S];\n\nvoid dijkstra(){\n\tpriority_queue<state,vector<state>,greater<state> > que;\n\tfill_n((double *)d, sizeof(d)/sizeof(double),INF);\n\trep(i,G[s].size()){\n\t\tedge t_e=G[s][i];\n\t\tque.push(state(t_e.to,s,t_e.dist,1));\n\t\td[t_e.to][s][1]=(double)t_e.dist;\n\t}\n\n\twhile(!que.empty()){\n\t\tstate p = que.top(); que.pop();\n\t\tint c_v = p.c_v;\n\t\tint p_v = p.p_v;\n\n\t\tif( p.c_v == g && p.speed == 1 ){\n\t\t\tcout << p.cost << endl;\n\t\t\treturn;\n\t\t}\n\n\t\tif(d[c_v][p_v][p.speed]<p.cost) continue;\n\t\trep(i,G[c_v].size()){\n\t\t\tedge e = G[c_v][i];\n\t\t\tif(e.to==p_v) continue;\n\t\t\trep(j,3){\n\t\t\t\tif(p.speed+ds[j]>0&&p.speed+ds[j]<=e.speed){\n\t\t\t\t\tdouble cost=p.cost+((double)e.dist/(double)(p.speed+ds[j]));\n\t\t\t\t\tif(d[e.to][c_v][p.speed+ds[j]] > cost + 1e-8){\n\t\t\t\t\t\td[e.to][c_v][p.speed+ds[j]] = cost;\n\t\t\t\t\t\tque.push(state( e.to , c_v , cost , p.speed+ds[j] ));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"unreached\" << endl;\n}\n\n\nint main(){\n\n\tcout << fixed << setprecision(6);\n\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\tcin >> s >> g;\t\n\t\ts--;g--;\n\n\t\tG.clear();\n\t\tG.resize(MAX_V);\n\n\t\trep(i,m){\n\t\t\tint a,b,dist,c;\n\t\t\tcin >> a >> b >> dist >> c;\n\t\t\ta--;b--;\n\t\t\tedge tmp1(b,dist,c);\n\t\t\tedge tmp2(a,dist,c);\n\t\t\tG[a].push_back(tmp1);\n\t\t\tG[b].push_back(tmp2);\n\t\t}\n\n\t\tdijkstra();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <climits>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); ++i)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\nclass state{\npublic:\n  int now,prev,speed;\n  double cost;\n  state(int n, int p, int s, double c){\n    now = n;\n    prev = p;\n    speed = s;\n    cost = c;\n  }\n  bool operator<(const state& a)const{\n    return cost > a.cost;\n  }\n};\n\nint n,m;\nint s,g;\nint edge[32][32];\nint speed[32][32];\ndouble dp[32][32][32]; //[now][prev][speed]\nconst double inf = 9999999999.0;\n\nint main(){\n\n  while(cin>>n>>m,n|m){\n    memset(edge,-1,sizeof(edge));\n    rep(i,32)rep(j,32)rep(k,32)dp[i][j][k] = inf;\n    cin>>s>>g;\n    rep(i,m){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      edge[a-1][b-1] = edge[b-1][a-1] = c;\n      speed[a-1][b-1] = speed[b-1][a-1] = d;\n    }\n    \n    double ans = inf;\n    priority_queue<state> q;\n    q.push(state(s-1,s-1,0,0.0));\n    dp[s-1][s-1][0] = 0.0;\n    \n    while( !q.empty() ){\n      int now = q.top().now;\n      int prev = q.top().prev;\n      int sp = q.top().speed;\n      double c = q.top().cost;\n      double tmp;\n      q.pop();\n\n#if DEB\n      printf(\"now:%d  prev:%d  sp:%d  cost:%lf\\n\",now,prev,sp,c);\n#endif\n\n      if( now==g-1 & sp==1 ){\n\tans = c;\n\tbreak;\n      }\n\n      rep(i,n)if( edge[now][i]!=-1 && prev!=i ){\n\tif( sp>0 && sp<=speed[now][i] ){\n\t  tmp = c + (double)edge[now][i]/(double)sp;\n\t  if( dp[i][now][sp] > tmp ){\n\t    dp[i][now][sp] = tmp;\n\t    q.push(state(i,now,sp,tmp));\n\t  }\n\t}\n\tif( sp+1<=speed[now][i] ){\n\t  tmp = c + (double)edge[now][i]/(double)(sp+1);\n\t  if( dp[i][now][sp+1] > tmp ){\n\t    dp[i][now][sp+1] = tmp;\n\t    q.push(state(i,now,sp+1,tmp));\n\t  }\n\t}\n\tif( sp-1>0 && sp-1<=speed[now][i] ){\n\t  tmp = c + (double)edge[now][i]/(double)(sp-1);\n\t  if( dp[i][now][sp-1] > tmp ){\n\t    dp[i][now][sp-1] = tmp;\n\t    q.push(state(i,now,sp-1,tmp));\n\t  }\n\t}\n      }\n    }\n    if( ans==inf ){\n      puts(\"unreachable\");\n    }else{\n      printf(\"%.6lf\\n\",ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nstruct NODE{\n\tint from,to,speed;\n\tdouble cost;\n\tNODE(int from,int to,int speed,double cost) : from(from) , to(to) , speed(speed) , cost(cost) {\n\t}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\n\nvector< vector<NODE> > G;\nbool done[32][32][50] = {};\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m && n){\n\t\tmemset(done,0,sizeof(done));\n\t\tint s,g;\n\t\tcin >> s >> g;\n\t\ts--,g--;\n\t\tG.clear();\n\t\tG.resize(n);\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c,d;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--,b--;\t\n\t\t\tG[a].push_back(NODE(a,b,c,d));\n\t\t\tG[b].push_back(NODE(b,a,c,d));\n\t\t\t//cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n\t\t}\n\t\tpriority_queue<NODE> Q;\n\t\t\n\t\tQ.push(NODE(n,s,0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( q.speed >= 50) continue;\n\t\t\tif( done[q.from][q.to][q.speed] ) continue;\n\t\t\telse done[q.from][q.to][q.speed] = true;\n\t\t\tif( q.to == g && q.speed == 1 ){\n\t\t\t\tprintf(\"%.10lf\\n\",q.cost);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < G[q.to].size() ; i++){\n\t\t\t\tif( q.speed+0 > 0 && q.speed+0 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed+0,q.cost+G[q.to][i].cost / (q.speed+0)));\n\t\t\t\tif( q.speed+1 > 0 && q.speed+1 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed+1,q.cost+G[q.to][i].cost / (q.speed+1)));\n\t\t\t\tif( q.speed-1 > 0 && q.speed-1 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed-1,q.cost+G[q.to][i].cost / (q.speed-1)));\n\t\t\t}\n\t\t}\n\t\tcout << \"unreachable\" << endl;\n\t\texit:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e10\n#define EPS 1e-10\nusing namespace std;\nstruct edge{\n  int to,limit;\n  double dist;\n};\nvector<edge> G[100];\ndouble d[40][100];\nbool used[40][100];\ntypedef pair<int,int> pii; //speed,prev\ntypedef pair<int,pii> PII;//to,speed,prev\ntypedef pair<double,PII> P;//cost,to,speed\n\ndouble dikstra(int s,int g){\n  int ds[3]={-1,0,1};\n  priority_queue<P,vector<P>,greater<P> > que;\n  for(int i=0;i<40;i++)\n    for(int j=0;j<100;j++)\n      d[i][j]=INF;\n  memset(used,0,sizeof(used));\n  d[0][s]=0;\n  que.push(P(0,PII(s,pii(0,-1))));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int speed=p.second.second.first;\n    int v=p.second.first;\n    int prev=p.second.second.second;\n    double cost=p.first;\n    used[speed][v]=true;\n    //cout << v << \";\" << speed <<\":\" << cost << endl;\n    if(d[speed][v]<cost)continue;\n    for(int i=0;i<G[v].size();i++){\n      for(int j=0;j<3;j++){\n\tedge e=G[v][i];\n\tint ns=speed+ds[j];\n\tif(1<=ns && ns<= e.limit &&\n\t   used[ns][e.to]==false && \n\t   e.to!=prev){\n\t  que.push(P(cost+e.dist/ns,PII(e.to,pii(ns,v))));\n\t  if(d[ns][e.to]>cost+e.dist/ns){\n\t    d[ns][e.to]=cost+e.dist/ns;\n\t    //cout << \"d[\" << ns << \"][\" << e.to << \"]:\" << d[ns][e.to] << endl;\n\t    //cout << \"d[\" << v << \"]:\" << d[speed][v] << \" speed:\" << speed<< endl;\n\t  }\n\t}\n      }\n    }\n  }\n  if(d[1][g]==INF)return -1;\n  return d[1][g];\n}\n\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n){\n    for(int i=0;i<100;i++)G[i].clear();\n    cin>>s>>g;\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      G[x].push_back((edge){y,c,d});\n      G[y].push_back((edge){x,c,d});\n    }\n    double ans=dikstra(s,g);\n    if(ans==-1)cout << \"unreachable\" << endl;\n    else printf(\"%.5lf\\n\",ans);\n    // for(int i=0;i<=n;i++)\n    // \tcout << i << \" \" << d[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nstruct P{\n  double t;\n  short v,p,pre;\n  P(){};\n  P(double T,int V,int pp,int PRE){\n    t=T;v=V;p=pp;pre=PRE;\n  };\n  bool operator<(const P &p)const{\n    return t>p.t;\n  }\n};\nstruct Path{\n  int d,c;\n  Path(){};\n  Path(int D,int C){ d=D;c=C;};\n};\n\nint main(){\n  int n,m;\n  int s,g;\n  int x,y,d,c;\n  Path path[30][30];\n  //priority_queue<P,vector<P>,greater<P> > q;\n  priority_queue<P> q;\n\n  while( cin>>n>>m && (n|m) ){\n    cin >> s >> g;\n    s--; g--;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tpath[i][j].d=-1.0; path[i][j].c=-1;\n      }\n\n    for( int i=0;i<m;i++ ){\n      cin >> x >> y >> d >> c;\n      x--;y--;\n      path[x][y].d=d; path[x][y].c=c;\n      path[y][x] = path[x][y];\n    }\n\n    while( !q.empty() ) q.pop();\n\n    double cost[30][35]; // place,velocity\n    int dv[3] = {-1,0,1};\n    for( int i=0;i<n;i++ ){\n      for( int j=1;j<31;j++ )\n\tcost[i][j] = DBL_MAX;\n    }\n\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      double nt = path[s][i].d;\n      q.push( P(nt,1,i,-1) );\n      cost[i][1] = nt;\n    }\n\n    while( !q.empty() ){\n      P p = q.top(); q.pop();\n      double t = p.t;\n      int v = p.v;\n      int np = p.p; // 現在地\n      int pre = p.pre;\n\n      if( t>cost[g][1] ) break;\n\n      /*\n      cout << \"v=\" << v << \" p=\" << np << \" pre=\" << pre \n\t   << \" t=\" << t << endl;\n      */\n\n      for( int i=0;i<n;i++ ){\n\tif( path[np][i].c<0 ) continue;// たどり着けないノード\n\tif( i==pre ) continue; // 前回のノード\n\n\tfor( int j=0;j<3;j++ ){\n\t  int nv = v + dv[j];\n\t  if( nv==0 ) continue;\n\t  if( nv>path[np][i].c ) continue;\n\t  double nCost = t + (double)path[np][i].d/nv;\n\t  if( cost[i][nv] < nCost ) continue;\n\t  cost[i][nv]=nCost;\n\t  if( i==g && nv==1 ) continue;\n\t  q.push( P(nCost,nv,i,np) );\n\t}\n      }\n\n    }\n    if( fabs(cost[g][1]-DBL_MAX)<1e-4 )\n      cout << \"unreachable\" << endl;\n    else\n      //      cout << cost[g][1] << endl;\n      printf(\"%.6lf\\n\",cost[g][1]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nconst int MAX = 35;\nconst int INF = (1<<25);\nint n,m;\n\nstruct Edge{\n  int to;\n  double dis,lim;\n  Edge(int a, double b, double c):to(a),dis(b),lim(c){}\n};\n\nstruct State{\n  int pos,from;\n  double speed,t;\n  State(int a, double b, double c, int f):pos(a),speed(b),t(c),from(f){}\n  bool operator < (const State& s) const{ return t > s.t;}\n};\n\nvector<Edge> E[MAX];\ndouble T[MAX][MAX][MAX];\n//T[i][j][k] := shortest time from i to j with speed k.\n\n\nvoid init(){\n  for(int i = 0; i < MAX; i++){\n    for(int j = 0; j < MAX; j++)\n      for(int k = 0; k < MAX; k++) T[i][j][k] = INF;\n    E[i].clear();\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++){\n    int x,y;\n    double d,c;\n    cin >> x >> y >> d >> c;\n    //   cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    E[x].push_back(Edge(y,d,c));\n    E[y].push_back(Edge(x,d,c));\n  }\n}\n\nvoid solve(int s, int g){\n\n  priority_queue<State> Q;\n  T[0][s][0] = 0;\n  Q.push(State(s,0,0,-1));\n\n  while(!Q.empty()){\n    State sta = Q.top();\n    Q.pop();\n\n    if(sta.t > T[sta.from][sta.pos][(int)sta.speed]) continue;\n\n    for(int i = 0; i < E[sta.pos].size(); i++){\n      int np = E[sta.pos][i].to;\n\n      if(np == sta.from) continue;\n\n      double sp[] = {-1,0,1};\n      \n      for(int j = 0; j < 3; j++){\n\tdouble ns = sta.speed+sp[j];\n\tif(ns <= 0 || ns > E[sta.pos][i].lim) continue;\n\tdouble nt = sta.t+E[sta.pos][i].dis/ns;\n\tif(T[sta.pos][np][(int)ns] > nt){\n\t  T[sta.pos][np][(int)ns] = nt;\n\t  Q.push(State(np,ns,nt,sta.pos));\n\t}\n      }\n    }\n  }\n\n  double ans = INF;\n\n  for(int i = 0; i < MAX; i++)\n    ans = min(ans,T[i][g][1]);\n  \n\n  if(ans == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.5f\\n\",ans);\n}\n\nint main(){\n\n  while(cin >> n >> m && n+m){\n    init();\n    cerr << \"init fin\" << endl;\n    int s,g;\n    cin >> s >> g;\n    input();\n    cerr << \"input fin\" << endl;\n    solve(s,g);\n    cerr << \"solve fin\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\nint n,m,s,g;\ndouble d[40][40][40];\n\nint main(){\n  int inx,iny,ind,inc;\n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n\n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=0;i<31;i++)for(int j=0;j<31;j++)for(int k=0;k<31;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n    \n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<double, pair<int, int> > P; // 時間，今のノード，直前のノード\n\nvector< pair<int, double> > G[930];\n\nvector<double> dist(930, 0.0);\npriority_queue<P, vector<P>, greater<P> > que;\n\nvoid dijkstra(int start){\n    for(int i=0;i<930;i++){\n        dist[i] = 100000.0;\n    }\n    dist[start] = 0.0;\n    que.push(make_pair(0.0, make_pair(start, -1)));\n    \n    while(!que.empty()){\n        auto v = que.top(); que.pop();\n        if(dist[v.second.first] < v.first) continue;\n        for(auto e: G[v.second.first]){\n            if(e.first == v.second.second) continue;\n            if(dist[e.first] > dist[v.second.first] + e.second){\n                dist[e.first] = dist[v.second.first] + e.second;\n                que.push(make_pair(dist[e.first], make_pair(e.first, v.second.first)));\n            }\n        }\n    }\n}\n\nint main(){\n    int n, m, s, g, x, y, c;\n    double d;\n    while(cin >> n >> m && n){\n        for(int i=0;i<930;i++){\n            G[i].clear();\n        }\n        \n        cin >> s >> g;\n        s--; g--;\n        \n        for(int i=0;i<m;i++){\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            for(int v=1;v<=30;v++){\n                int xx = x * 31 + v;\n                int yy = y * 31 + v;\n                if(v != 1 && v-1 <= c){\n                    G[xx].push_back(make_pair(yy-1, d/(v-1)));\n                    G[yy].push_back(make_pair(xx-1, d/(v-1)));\n                }\n                if(v <= c){\n                    G[xx].push_back(make_pair(yy, d/(v)));\n                    G[yy].push_back(make_pair(xx, d/(v)));\n                }\n                if(v != 30 && v+1 <= c){\n                    if(x != s) G[xx].push_back(make_pair(yy+1, d/(v+1)));\n                    if(y != s) G[yy].push_back(make_pair(xx+1, d/(v+1)));\n                }\n            }\n        }\n        \n        dijkstra(s*31+1);\n\n        double ans = dist[g*31+1];\n        if(abs(ans - 100000.0) < 1){\n            printf(\"unreachable\\n\");\n            continue;\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\n\n\n\nint main(){\n  int inx,iny,ind,inc;\n  double d[40][40][40];\n  int n,m,s,g;\n  static const int INF = 1<<29;\n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n    \n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint N,M,start,goal;\n\nstruct Info{\n\tInfo(){\n\t\ttown = pre_town = 0;\n\t\tspeed = time = 0.0;\n\t}\n\n\tInfo(int arg_town,int arg_speed,double arg_time,int arg_pre_town){\n\t\ttown = arg_town;\n\t\tspeed = arg_speed;\n\t\ttime = arg_time;\n\t\tpre_town = arg_pre_town;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn time > arg.time;\n\t};\n\tint town,speed,pre_town;\n\tdouble time;\n};\n\nstruct Road{\n\tRoad(int arg_to,double arg_dist,int arg_speed_limit){\n\t\tto = arg_to;\n\t\tdist = arg_dist;\n\t\tspeed_limit = arg_speed_limit;\n\t}\n\tint to,speed_limit;\n\tdouble dist;\n};\n\nvoid func(){\n\n\tdouble min_Time[N+1][N+1][31];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tfor(int p = 1; p <= 30; p++)min_Time[i][k][p] = DBL_MAX;\n\t\t}\n\t}\n\n\tscanf(\"%d %d\",&start,&goal);\n\n\tvector<Road> V[N+1];\n\n\tint from,to,limit;\n\tdouble dist;\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %lf %d\",&from,&to,&dist,&limit);\n\t\tV[from].push_back(Road(to,dist,limit));\n\t\tV[to].push_back(Road(from,dist,limit));\n\t}\n\n\tInfo first;\n\tfirst.speed = 0;\n\tfirst.time = 0.0;\n\tfirst.town = start;\n\tfirst.pre_town = -1;\n\n\tpriority_queue<Info> Q;\n\tQ.push(first);\n\n\tint next_town,next_speed;\n\tdouble distance;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().town == goal && Q.top().speed == 1){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().time > min_Time[Q.top().town][Q.top().pre_town][Q.top().speed]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < V[Q.top().town].size();i++){\n\t\t\t\tnext_town = V[Q.top().town][i].to;\n\t\t\t\tif(next_town == Q.top().pre_town)continue;\n\n\t\t\t\tlimit = V[Q.top().town][i].speed_limit;\n\t\t\t\tdistance = V[Q.top().town][i].dist;\n\n\t\t\t\tfor(int k = -1;k <= 1; k++){\n\t\t\t\t\tnext_speed = Q.top().speed + k;\n\t\t\t\t\tif(next_speed <= 0 || next_speed > limit)continue;\n\n\t\t\t\t\tif(min_Time[next_town][Q.top().town][next_speed] > Q.top().time + distance/(double)next_speed){\n\t\t\t\t\t\tmin_Time[next_town][Q.top().town][next_speed] = Q.top().time + distance/(double)next_speed;\n\t\t\t\t\t\tQ.push(Info(next_town,next_speed,Q.top().time+distance/(double)next_speed,Q.top().town));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tdouble minimum = DBL_MAX;\n\tfor(int i = 1; i <= N; i++){\n\t\tminimum = min(minimum,min_Time[goal][i][1]);\n\t}\n\tif(minimum == DBL_MAX){\n\t\tprintf(\"unreachable\\n\");\n\t}else{\n\t\tprintf(\"%.6lf\\n\",minimum);\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge{\n    int from,to,dist,c;\n    Edge(int from,int to,int dist,int c) : from(from),to(to),dist(dist),c(c) {}\n};\n\n\nstruct State{\n    double time;\n    int where,speed;\n    int before;\n    State(double time,int where,int speed,int before) \n        : time(time),where(where),speed(speed),before(before) {}\n};\n\nbool operator<(const State& rhs,const State& lhs){\n    return rhs.time < lhs.time;\n}\nbool operator>(const State& rhs,const State& lhs){\n    return rhs.time > lhs.time;\n}\n\nconst int INF = 100000;\ndouble solve(vector<vector<Edge> > E,int s,int g){\n    int n = E.size();\n    {\n        vector<vector<int> > dist(n,vector<int>(n,INF));\n        for(int i=0;i<n;i++){\n            for(size_t j=0;j<E[i].size();j++){\n                dist[i][E[i][j].to] = 0;\n            }\n        }\n        for(int i=0;i<n;i++){\n            dist[i][i] = 0;\n        }\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        if(dist[s][g] >= INF) return -1;\n    }\n\n    vector<vector<vector<char> > > used(n,\n           vector<vector<char> >(31,\n           vector<char>(n,false)));\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(0,s,0,s));\n    double ans = INF;\n    while(not que.empty()){\n        double time = que.top().time;\n        int where = que.top().where;\n        int speed = que.top().speed;\n        int before = que.top().before;\n\n        que.pop();\n        if(used[where][speed][before]) continue;\n        used[where][speed][before] = true;\n        if(where == g and speed == 1){\n            ans = time;\n            break;\n        }\n        for(size_t i=0;i<E[where].size();i++){\n            for(int k=-1;k<=1;k++){\n                int new_speed = speed + k;\n                if(new_speed <= 0 or new_speed > E[where][i].c) continue;\n                if(before == E[where][i].to) continue;\n                que.push(State(time + E[where][i].dist / (double)new_speed,\n                               E[where][i].to,new_speed,where));\n            }\n        }\n    }\n    return ans;\n\n}\n\nint main(){\n    cout << fixed << setprecision(10);\n    while(true){\n        int n,m,s,g;\n        cin >> n >> m ;\n        if(n == 0) break;\n        cin >> s >> g;\n        s--;g--;\n        vector<vector<Edge> > E(n);\n        for(int i=0;i<m;i++){\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            x--;y--;\n            E[x].push_back(Edge(x,y,d,c));\n            E[y].push_back(Edge(y,x,d,c));\n        }\n        double r = solve(E,s,g);\n        if(r < 0){\n            cout << \"unreachable\" << endl;\n        }else{\n            cout << r << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m;\nll s, g;\n\nclass DK {\npublic:\n\tstruct edge {\n\t\tint to;\n\t\tdouble cost;\n\t\tll cap;\n\t\tedge(int _to, double _cost, ll _cap) :to(_to), cost(_cost), cap(_cap) {}\n\t};\n\n\tdouble d[110][110];\n\tvector<edge> G[110];//各頂点からの辺\n\n\tvoid dijkstra() {\n\t\trep(i, 110)rep(j, 110)d[i][j] = INF;\n\t\td[s][0] = 0;\n\n\t\ttypedef pair<pair<double, ll>, ll> PP;\n\t\tpriority_queue<PP, vector<PP>, greater<PP>> que;\n\t\tque.push({ {0, 0},s });\n\n\t\twhile (!que.empty()) {\n\t\t\tPP p = que.top();\n\t\t\tque.pop();\n\t\t\tll nn = p.second;\n\t\t\tll v = p.first.second;\n\t\t\tif (d[nn][v] < p.first.first)continue;\n\t\t\tfor (int i = 0; i < G[nn].size(); i++) {\n\t\t\t\tedge e = G[nn][i];\n\t\t\t\tFOR(j, -1, 2) {\n\t\t\t\t\tdouble nv = v + j;\n\t\t\t\t\tif (nv <= 0)continue;\n\t\t\t\t\tif (nv > e.cap)continue;\n\t\t\t\t\tif (d[e.to][(ll)nv] > d[nn][v] + e.cost / nv) {\n\t\t\t\t\t\td[e.to][(ll)nv] = d[nn][v] + e.cost / nv;\n\t\t\t\t\t\tque.push({ {d[e.to][(ll)nv], nv},e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n};\n\nDK dk;\n\nint main() {\n\twhile (cin >> n >> m&&n + m) {\n\t\trep(i, 110)dk.G[i].clear();\n\t\tcin >> s >> g;\n\t\trep(i, m) {\n\t\t\tint x, y;\n\t\t\tll c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tdk.G[x].push_back(DK::edge(y, d, c));\n\t\t\tdk.G[y].push_back(DK::edge(x, d, c));\n\t\t}\n\t\tdk.dijkstra();\n\t\t//rep(i, n) {\n\t\t//\trep(j, 30) {\n\t\t//\t\tcout << dk.d[i + 1][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tdouble ans = dk.d[g][1];\n\t\tif ((ll)ans == INF)cout << \"unreachable\" << endl;\n\t\telse printf(\"%.10lf\\n\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 1e9 + 10;\n\nstruct Edge {\n  int to, dist, constraint;\n \n  Edge() = default;\n  Edge(int t, int d, int c): to(t), dist(d), constraint(c) { }\n};\n\nstruct Node {\n  double cost;\n  int cur, prev, v;\n  \n  Node() = default;\n  Node(double c, int cur, int prev, int v): cost(c), cur(cur), prev(prev), v(v) { }\n\n  inline bool operator<(const Node& node) const {\n    return cost < node.cost;\n  }\n};\n\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n + m == 0) {\n      break;\n    }\n    int s, g;\n    cin >> s >> g;\n\n    vector<Edge> G[31];\n    for (int i = 0; i < m; i++) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      G[x].push_back(Edge(y, d, c));\n      G[y].push_back(Edge(x, d, c));\n    }\n\n    double min_cost[31][31][31];\n    for (int i = 0; i < 31; i++)  {\n      for (int j = 0; j < 31; j++) {\n        for (int k = 0; k < 31; k++) {\n          min_cost[i][j][k] = INF;\n        }\n      }\n    }\n\n    priority_queue<Node> que;\n    que.push(Node(0, s, -1, 1));\n\n    while (!que.empty()) {\n      Node node = que.top(); que.pop();\n\n      min_cost[node.cur][node.prev][node.v] = node.cost;\n\n      for (const auto& e : G[node.cur]) {\n        if (node.prev == e.to) {\n          continue;\n        }\n        double temp = e.dist / (double)(node.v);\n        if (min_cost[e.to][node.cur][node.v] > node.cost + temp) {\n          que.push(Node(node.cost + temp, e.to, node.cur, node.v));\n        }\n        if (node.prev != -1) {\n          if (node.v < e.constraint) {\n            temp = e.dist / (double)(node.v + 1);\n            if (min_cost[e.to][node.cur][node.v + 1] > node.cost + temp) {\n              que.push(Node(node.cost + temp, e.to, node.cur, node.v + 1));\n            }\n          }\n          if (node.v > 1) {\n            temp = e.dist / (double)(node.v - 1);\n            if (min_cost[e.to][node.cur][node.v - 1] > node.cost + temp) {\n              que.push(Node(node.cost + temp, e.to, node.cur, node.v - 1));\n            }\n          }\n        }\n        \n        if (e.to == g && node.v == 1) {\n          min_cost[g][node.cur][1] = min(min_cost[g][node.cur][1], node.cost + e.dist);\n        }\n      }\n    }\n\n    double ans = INF;\n    for (int i = 1; i <= n; i++) {\n      ans = min(ans, min_cost[g][i][1]);\n    }\n    if (ans >= INF) {\n      cout << \"unreachable\" << endl;\n    } else {\n      printf(\"%.15f\\n\", ans);\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstruct P {\n\tint to, c, d;\n};\nvector<P>E[30];\ndouble d[30][31][30];\n\nstruct st {\n\tint p, h, pr; double c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tint s, g; scanf(\"%d%d\", &s, &g); s--; g--;\n\t\trep(i, n)E[i].clear();\n\t\trep(i, m) {\n\t\t\tint x, y, d, c; scanf(\"%d%d%d%d\", &x, &y, &d, &c); x--; y--;\n\t\t\tE[x].push_back({ y,c,d }); E[y].push_back({ x,c,d });\n\t\t}\n\t\tpriority_queue<st>que;\n\t\tfill(d[0][0], d[30][0], INF);\n\t\tfor (P v : E[s]) {\n\t\t\td[v.to][1][s] = v.d; que.push({ v.to,1,s,d[v.to][1][s] });\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.p][p.h][p.pr] != p.c)continue;\n\t\t\tfor (P v : E[p.p]) {\n\t\t\t\tif (v.to == p.pr)continue;\n\t\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\t\tif (p.h + i > 0 && p.h + i <= v.c) {\n\t\t\t\t\t\tif (d[v.to][p.h + i][p.p] > p.c + v.d / double(p.h + i)) {\n\t\t\t\t\t\t\td[v.to][p.h + i][p.p] = p.c + v.d / double(p.h + i);\n\t\t\t\t\t\t\tque.push({ v.to,p.h + i,p.p,d[v.to][p.h + i][p.p] });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble Min = INF;\n\t\trep(i, n)Min = min(Min, d[g][1][i]);\n\t\tif (Min == INF)puts(\"unreachable\");\n\t\telse printf(\"%.7lf\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF 1000000007\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef pair<int,int>pi;\ntypedef pair<double,int>pd;\ntypedef pair<pd,pi>PP;\n\nstruct edge\n{\n    int to,dist,limit;\n};\n\nint n,m,s,g;\ndouble dp[31][31][31];\nvector<edge> G[31];\n\nvoid dijkstra()\n{\n    rep(i,n){\n        rep(j,n){\n            rep(k,31){\n                dp[i][j][k] = INF;\n            }\n        }\n    }\n    priority_queue<PP,vector<PP>,greater<PP> > que;\n    que.push(PP(pd(0.0,s),pi(s,0)));\n    dp[s][s][0] = 0.0;\n    while(!que.empty()){\n        PP pp = que.top();\n        pd p = pp.fi;\n        pi q = pp.se;\n        que.pop();\n        double cost = p.fi;\n        int v = p.se, prv = q.fi, sp = q.se;\n        if(dp[v][prv][sp] < cost) continue;\n        if(v == g && sp == 1){\n            printf(\"%.12lf\\n\",cost);\n            return;\n        }\n        for(int i=sp-1;i<=sp+1;i++){\n            if(i <= 0) continue;\n            for(auto& e : G[v]){\n                if(e.to != prv && i <= e.limit && dp[e.to][v][i] > cost+(double)e.dist/i){\n                    dp[e.to][v][i] = cost+(double)e.dist/i;\n                    que.push(PP(pd(dp[e.to][v][i],e.to),pi(v,i)));\n                }\n            }\n        }\n    }\n    printf(\"unreachable\\n\");\n}\n\nint main()\n{\n    while(1){\n        cin >> n >> m;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear();\n        }\n        cin >> s >> g;\n        s--,g--;\n        rep(i,m){\n            int a,b,c,d;\n            cin >> a >> b >> c >> d;\n            G[a-1].push_back((edge){b-1,c,d});\n            G[b-1].push_back((edge){a-1,c,d});\n        }\n        dijkstra();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<functional>\n#include<iomanip>\nusing namespace std;\n\n#define MAX_N 110\n#define INF 999999999.99\n\nint N, M, S, G, a, b, c, d;\ndouble X[MAX_N][MAX_N][2];\ndouble dist[MAX_N][MAX_N];\n\npriority_queue<tuple<double, int, int, int>, vector<tuple<double, int, int, int>>, greater<tuple<double, int, int, int>>>Q;\n\ndouble dijkstra() {\n\tdist[S][0] = 0;\n\tQ.push(make_tuple(0.0, S, 0, 0));\n\twhile (!Q.empty()) {\n\t\ttuple<double, int, int, int>tup = Q.top();\n\t\tQ.pop();\n\t\tdouble a1 = get<0>(tup);\n\t\tint a2 = get<1>(tup);\n\t\tint a3 = get<2>(tup);\n\t\tint a4 = get<3>(tup);\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (i != a4) {\n\t\t\t\t//X-1.\n\t\t\t\tif (a3 >= 1 && X[a2][i][1] >= a3 - 1) {\n\t\t\t\t\tif (dist[i][a3 - 1] > X[a2][i][0] / (a3 - 1) + a1) {\n\t\t\t\t\t\tdist[i][a3 - 1] = X[a2][i][0] / (a3 - 1) + a1;\n\t\t\t\t\t\tQ.push(make_tuple(dist[i][a3 - 1], i, a3 - 1, a2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//X.\n\t\t\t\tif (a3 >= 0 && X[a2][i][1] >= a3) {\n\t\t\t\t\tif (dist[i][a3] > X[a2][i][0] / a3 + a1) {\n\t\t\t\t\t\tdist[i][a3] = X[a2][i][0] / a3 + a1;\n\t\t\t\t\t\tQ.push(make_tuple(dist[i][a3], i, a3, a2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//X+1.\n\t\t\t\tif (a3 >= -1 && X[a2][i][1] >= a3 + 1) {\n\t\t\t\t\tif (dist[i][a3 + 1] > X[a2][i][0] / (a3 + 1) + a1) {\n\t\t\t\t\t\tdist[i][a3 + 1] = X[a2][i][0] / (a3 + 1) + a1;\n\t\t\t\t\t\tQ.push(make_tuple(dist[i][a3 + 1], i, a3 + 1, a2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[G][1];\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) { break; }\n\t\tcin >> S >> G;\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tX[i][j][0] = INF;\n\t\t\t\tX[i][j][1] = 0.0;\n\t\t\t\tdist[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tX[a][b][0] = c;\n\t\t\tX[b][a][0] = c;\n\t\t\tX[a][b][1] = d;\n\t\t\tX[b][a][1] = d;\n\t\t}\n\t\tdouble res = dijkstra();\n\t\tif (res > INF / 2) { cout << \"unreachable\" << endl; }\n\t\telse { cout << fixed << setprecision(15) << res << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ndouble len[40][40];\nint lim[40][40];\n\ndouble mini[40][40][40];\n\nint main(){\n  for(;;){\n    int n,m;\n    int s,g;\n    int i,j,k,l;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n==0 && m==0)return 0;\n    scanf(\"%d%d\",&s,&g);\n    s--;g--;\n    for(i=0;i<n;i++)for(j=0;j<n;j++)lim[i][j]=-1;\n    for(i=0;i<m;i++){\n      int p,q;\n      double d;\n      int c;\n      scanf(\"%d%d\",&p,&q);\n      scanf(\"%lf%d\",&d,&c);\n      p--;q--;\n      len[p][q]=len[q][p]=d;\n      lim[p][q]=lim[q][p]=c;\n    }\n    for(k=0;k<=30;k++)for(i=0;i<n;i++)for(j=0;j<n;j++)mini[k][i][j]=1e9;\n    multimap<double, pair<int, pair<int,int> > > que;\n    que.insert(make_pair(0.0,make_pair(0,make_pair(s,s))));\n    mini[0][s][s]=0;\n    double ans=-1;int count=0;\n    for(;!que.empty();){count++;\n      pair<double, pair<int, pair<int,int> > > h=*(que.begin());\n      que.erase(que.begin());\n      double cost=h.first;\n      int v=h.second.first;\n      int prev=h.second.second.first;\n      int now=h.second.second.second;\n\n      if(v==1 && now==g){\n\tans=cost;\n\tbreak;\n      }\n      \n      for(i=0;i<n;i++){\n\tif(i!=prev && len[now][i]>=0){\n\t  int newv;\n\t  for(newv=v-1;newv<=v+1;newv++){\n\t    if(newv<=0 || newv>lim[now][i])continue;\n\t    //que ni ireru\n\t    double ncost=cost+(double)len[now][i]/newv;\n\t    int nprev=now;\n\t    int nnow=i;\n\t    if(mini[newv][nprev][nnow]>ncost){\n\t      mini[newv][nprev][nnow]=ncost;\n\t      que.insert(make_pair(ncost,make_pair(newv,make_pair(nprev,nnow))));\n\t    }\n\t  }\n\t}\n      }\n  \t}//printf(\"count: %d\\n\",count);\n    if(ans>=0)printf(\"%.10f\\n\",ans);\n    else printf(\"unreachable\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint to;\n\tdouble cost;\n};\n\ntypedef pair<double,int> P;\n\nint V;\nvector<edge> G[1000];\n\nconst double INF = 1000000000.0;\n\nvoid dijkstra(int s,int g){\n\tdouble d[1000];\n\tint prev[40];\n\n\tfill(prev,prev+40,(int)INF);\n\tfill(d,d+V,INF);\n\t\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\td[s] = 0.0;\n\tque.push(P(0.0,s));\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost && prev[(v-1)/30] != (e.to-1)/30){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t\tprev[(e.to-1)/30] = (v-1)/30;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(EQ(d[g],INF)){\n\t\tcout << \"unreachable\" << endl;\n\t}\n\telse{\n\t\tprintf(\"%.5f\\n\",d[g]);\n\t}\n\n}\n\nint main(){\n\t\n\t// ツ各ツ凝ヲツ甘板づづ債督ッツ暗ェツ都ツ市ツづーツ督楪達ツスツピツーツドツつイツづづ可ノツーツドツづ可閉ェツつッツづつ「ツづゥ\n\t// G 1-30,31-60,61-90...\n\tint n,m,s,g;\n\twhile(cin >> n >> m >> s >> g && !(n == 0 && m == 0)){\n\t\tV = n*30+1;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint to,from,di,c;\n\t\t\tcin >> from >> to >> di >> c;\n\t\t\t// from -> to\n\t\t\tfor(int j = 1; j <= 30; j++){\n\t\t\t\tif(from == s && j == 1){\n\t\t\t\t\tedge e;\n\t\t\t\t\te.to = (to-1)*30+1;\n\t\t\t\t\te.cost = di;\n\t\t\t\t\tG[(s-1)*30+1].push_back(e);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint from2 = (from-1)*30+j;\n\t\t\t\t\tfor(int k = -1; k <= 1; k++){\n\t\t\t\t\t\tif(k+j > 0 && k + j <= c){\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.to = (to-1)*30 + (j+k);\n\t\t\t\t\t\t\te.cost = (double)di/(j+k);\n\t\t\t\t\t\t\tG[from2].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// to -> from\n\t\t\tfor(int j = 1; j <= 30; j++){\n\t\t\t\tif(to == s && j == 1){\n\t\t\t\t\tedge e;\n\t\t\t\t\te.to = (from-1)*30+1;\n\t\t\t\t\te.cost = di;\n\t\t\t\t\tG[(s-1)*30+1].push_back(e);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint from2 = (to-1)*30+j;\n\t\t\t\t\tfor(int k = -1; k <= 1; k++){\n\t\t\t\t\t\tif(k+j > 0 && k + j <= c){\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.to = (from-1)*30 + (j+k);\n\t\t\t\t\t\t\te.cost = (double)di/(j+k);\n\t\t\t\t\t\t\tG[from2].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdijkstra((s-1)*30+1,(g-1)*30+1);\n\n\t\tfor(int i = 0; i < 1000; i++){\n\t\t\tG[i].clear();\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 100\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[40];    \n    \n    int inx,iny,ind,inc;\n    double d[40][40][40];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n#define N 30\n#define INF 100000\nstruct road{int to,cost,lim;};\n\nstruct situ{int v,now,from;double d;};\nbool operator < (const situ &a,const situ &b){\n\treturn a.d > b.d;\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,s,g;\n\t\tvector<road> roads[N];\n\t\tcin >> n >> m;\n\t\tif(!n&&!m) break;\n\t\tcin >> s >> g;\n\t\ts--;g--;\n\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,c;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c);\n\t\t\tx--;y--;\n\t\t\troads[x].push_back((road){y,d,c});\n\t\t\troads[y].push_back((road){x,d,c});\n\t\t}\n\t\n\t\tpriority_queue<situ> que;\n\t\tfor(int i=0;i<roads[s].size();i++){\n\t\t\tint to = roads[s][i].to;\n\t\t\tint d = roads[s][i].cost;\n\t\t\tque.push((situ){1,to,s,(double)d});\n\t\t}\n\t\tdouble dist[N][N][31];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=1;k<31;k++){\n\t\t\t\t\tdist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(que.size()){\n\t\t\tsitu st = que.top(); que.pop();\n\t\t\tif(dist[st.now][st.from][st.v]<st.d) continue;\n\t\t\tdist[st.now][st.from][st.v] = st.d;\n\t\t\tfor(int i=0;i<roads[st.now].size();i++){\n\t\t\t\tint to = roads[st.now][i].to;\n\t\t\t\tint d = roads[st.now][i].cost;\n\t\t\t\tif(to != st.from){\n\t\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\tif(st.v+j<=roads[st.now][i].lim&&st.v+j>0){\n\t\t\t\t\t\t\tque.push((situ){st.v+j,to,st.now,st.d+(double)d/(st.v+j)});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = INF;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tans = min(ans,dist[g][i][1]);\n\t\t}\n\t\tif(ans==INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t\tprintf(\"%.5f\\n\",ans);\n\t\t}\n\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// (x,y)\ntypedef pair<int,int> P;\n// ( 速度 , (前の町,今の町) )\ntypedef pair<int,P> Node;\n// (cost,Node)\ntypedef pair<double,Node> State;\n\nconst int MAX_V = 31;\nconst double INF = 100000;\n\nstruct edge{\n\tint to, d, c;\n\tedge(int to_, int d_, int c_){\n\t\tto = to_; d = d_; c = c_;\n\t}\n};\n\n// グラフ\nvector<edge> G[MAX_V];\n// スタートからゴールに辿りつけるかどうか\nbool is_connect;\n\n// 入力\nint n, m;\n\n// 初期化\nvoid init(){\n\tis_connect = false;\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tG[i].clear();\n\t}\n}\n\n// 辺の追加\nvoid add_edge(int x, int y, int d, int c){\n\tedge e( y , d , c );\n\tG[x].push_back( e );\n\te.to = x;\n\tG[y].push_back( e );\n}\n\n// スタートからゴールに辿りつけるかどうかチェック\nvoid check(int v, int g, map<int,bool> memo){\n\tif( v == g ){\n\t\tis_connect = true;\n\t}\n\tif( memo[v] ) return;\n\tmemo[v] = true;\n\t\n\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\tint to = G[v][i].to;\n\t\tif( memo[to] ) continue;\n\t\tcheck( to , g , memo );\n\t}\n}\n\n// ダイクストラ法\ndouble solve(int s, int g){\n\t// d[v][x][y] := 速度v, 前の町x, 今の町yまでの最小コスト\n\tdouble d[31][31][31];\n\t// 訪れたかどうか\n\tbool visited[31][31][31];\n\t// 初期化\n\tfor(int y=0 ; y < MAX_V ; y++ ){\n\t\tfor(int x=0 ; x < MAX_V ; x++ ){\n\t\t\tfor(int v=0 ; v < 31 ; v++ ){\n\t\t\t\td[v][y][x] = INF;\n\t\t\t\tvisited[v][y][x] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// State := (cost,Node), Node := ( 速度 , (前の町,今の町) )\n\tpriority_queue< State, vector<State> , greater<State> > q;\n\tfor(int i = 0 ; i < G[s].size() ; i++ ){\n\t\tint to = G[s][i].to;\n\t\tdouble dis = G[s][i].d;\n\t\t\n\t\tNode start( 1 , P(s,to) );\n\t\tq.push( State(dis,start) );\n\t\td[1][s][to] = dis;\n\t}\n\t\n\tdouble ans = INF;\n\twhile( !q.empty() ){\n\t\t// 値を取り出す\n\t\tdouble now_cost = q.top().first;\n\t\tint v = q.top().second.first;\n\t\tint x = q.top().second.second.first;\n\t\tint y = q.top().second.second.second;\n\t\tq.pop();\n\t\t\n\t\tif( now_cost >= ans || visited[v][x][y] ) continue;\n\t\tvisited[v][x][y] = true;\n\t\t\n\t\t// 目的地のとき\n\t\tif( y == g && v == 1 ){\n\t\t\tans = min( ans , now_cost );\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < G[y].size() ; i++ ){\n\t\t\tint to = G[y][i].to;\n\t\t\tint dis = G[y][i].d;\n\t\t\tint c = G[y][i].c;\n\t\t\tif( to == x ) continue;\n\t\t\t\n\t\t\tfor(int dv = -1 ; dv <= 1 ; dv++ ){\n\t\t\t\tint next_v = v + dv;\n\t\t\t\tif( next_v > c || next_v <= 0 ) continue;\n\t\t\t\t\n\t\t\t\tdouble cost = (double)dis / next_v;\n\t\t\t\tif( now_cost + cost < d[next_v][y][to] ){\n\t\t\t\t\td[next_v][y][to] = now_cost + cost;\n\t\t\t\t\t\n\t\t\t\t\tNode next( next_v , P(y,to) );\n\t\t\t\t\tState p( now_cost + cost , next );\n\t\t\t\t\tq.push( p );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile( cin >> n >> m , n || m ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\t\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tadd_edge( x , y , d , c );\n\t\t}\n\t\t\n\t\t{\n\t\t\t// スタートからゴールに辿りつけるかどうか\n\t\t\tmap<int,bool> memo;\n\t\t\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\t\t\tmemo[i] = false;\n\t\t\t}\n\t\t\tcheck( s , g , memo );\n\t\t}\n\t\t\n\t\t// ゴールに辿りつけないとき\n\t\tif( is_connect == false ){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t\tdouble ans = solve( s , g );\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr double INF = 1e18;\n\nclass Graph{\n    struct Edge{\n        int from, to;\n        double cost;\n        int limit;\n        Edge(int u,int v,double c,int l){\n            from=u;\n            to=v;\n            cost=c;\n            limit=l;\n        }\n        bool operator < (const Edge &right)const{\n            if(cost != right.cost)return cost > right.cost;\n            else if(from != right.from)return from < right.from;\n            else return to < right.to;\n        }\n    };\n    vector<vector<Edge>> g;\n\npublic:\n    Graph(int n){\n        g.resize(n);\n    }\n    void addEdge(int u, int v, double c, int l){\n        g[u].emplace_back(u, v, c, l);\n    }\n    void dijkstra(int, vector<vector<double>>&);\n};\n\ninline void Graph::dijkstra(int s, vector<vector<double>> &dist){\n    const int V=g.size();\n    priority_queue<Edge> pq;\n    dist[s][1]=0;\n    for(pq.emplace(-2,s,0,0);!pq.empty();){\n        Edge e=pq.top();pq.pop();\n        for(auto ge:g[e.to]){\n            if(e.from==ge.to)continue;\n            for(int i=-1;i<=1;++i){\n                if(e.limit+i<=0 || e.limit+i>ge.limit){\n                    continue;\n                }\n                if(dist[ge.to][e.limit+i] > e.cost+(ge.cost/(e.limit+i))){\n                    dist[ge.to][e.limit+i]=e.cost+(ge.cost/(e.limit+i));\n                    pq.emplace(ge.from,ge.to,dist[ge.to][e.limit+i],e.limit+i);\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int n, m;\n    while(cin>>n>>m,n){\n        Graph g(n);\n        int src,dst;\n        cin>>src>>dst;\n        for(int i=0;i<m;++i){\n            int u,v,d,c;\n            cin>>u>>v>>d>>c;\n            g.addEdge(u-1,v-1,(double)d,c);\n        }\n        vector<vector<double>>dist(n,vector<double>(31,INF));\n        g.dijkstra(src-1, dist);\n        if(dist[dst-1][1]==INF)cout<<\"unreachable\"<<endl;\n        else cout<<dist[dst-1][1]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\n#define EPS (double)1e-9\n#define INF (double)1e9\n#define MAX_SPEED 33\n\nvector<vector<vector<double> > > dijk(int s_point, int s_speed, vector<vector<vector<pair<double, pair<int, int> > > > >& adj){\n  int v = adj.size();\n  int t = adj[0].size();\n  vector<vector<vector<double> > > result(v, vector<vector<double> >(v, vector<double>(t, INF)));\n  priority_queue<pair<double, pair<int, pair<int, int> > > > wait;\n  wait.push(make_pair(0, make_pair(0, make_pair(s_point, s_speed))));\n  for(int i = 0; i < v; i++){ result[s_point][i][s_speed] = 0; }\n  \n  while(!wait.empty()){\n    double nowcost = -wait.top().first;\n    int prevpoint = wait.top().second.first;\n    int nowpoint = wait.top().second.second.first;\n    int nowspeed = wait.top().second.second.second;\n    wait.pop();\n    if(result[nowpoint][prevpoint][nowspeed] + EPS < nowcost){ continue; }\n\n    for(size_t i = 0; i < adj[nowpoint][nowspeed].size(); i++){\n      double nextcost = adj[nowpoint][nowspeed][i].first + nowcost;\n      int nextpoint = adj[nowpoint][nowspeed][i].second.first;\n      int nextspeed = adj[nowpoint][nowspeed][i].second.second;\n      if(nextpoint != prevpoint && result[nextpoint][nowpoint][nextspeed] - EPS > nextcost){\n        wait.push(make_pair(-nextcost, make_pair(nowpoint, make_pair(nextpoint, nextspeed))));\n        result[nextpoint][nowpoint][nextspeed] = nextcost;\n      }\n    }\n  }\n\n  return result;\n}\n\nint main(void){\n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    int s, g;\n    cin >> s >> g;\n\n    int x, y, d, c;\n    vector<vector<vector<pair<double, pair<int, int> > > > > adjlist(n + 1,\n                                                                     vector<vector<pair<double, pair<int, int> > > >(MAX_SPEED + 1));\n    for(int i = 0; i < m; i++){\n      cin >> x >> y >> d >> c;\n      for(int j = 0; j <= MAX_SPEED; j++){\n        if(1 <= j - 1 && j - 1 <= c){\n          adjlist[x][j].push_back(make_pair((double)d / (j - 1), make_pair(y, j - 1)));\n          adjlist[y][j].push_back(make_pair((double)d / (j - 1), make_pair(x, j - 1)));\n        }\n        if(1 <= j && j <= c){\n          adjlist[x][j].push_back(make_pair((double)d / j, make_pair(y, j)));\n          adjlist[y][j].push_back(make_pair((double)d / j, make_pair(x, j)));\n        }\n        if(j + 1 <= c){\n          adjlist[x][j].push_back(make_pair((double)d / (j + 1), make_pair(y, j + 1)));\n          adjlist[y][j].push_back(make_pair((double)d / (j + 1), make_pair(x, j + 1)));\n        }\n      }\n    }\n    \n    double ans = INF;\n    vector<vector<vector<double> > > result = dijk(s, 0, adjlist);\n    for(int i = 0; i <= n; i++){ ans = min(ans, result[g][i][1]); }\n    if(ans + EPS >= INF){ printf(\"unreachable\\n\"); }\n    else{ printf(\"%.10f\\n\", ans); }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a2,a3,a4;\ndouble d[31][31];\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      cin>>a1>>a2>>a3>>a4;\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n    }\n    priority_queue<P,vector<P>,greater<P> >q;\n    d[st][0]=0;\n    q.push(P(0,st));\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.second;\n      //cout<<cur<<' '<<p.first<<endl;\n      r(i,v[cur].size()){\n        r(j,3){\n          int x=p.first+dx[j],c=0;\n          if(0<x&&x<=v[cur][i].lim){\n            if(d[v[cur][i].to][x]>v[cur][i].dist/x+d[cur][p.first]){\n              d[v[cur][i].to][x]=v[cur][i].dist/x+d[cur][p.first];\n              q.push(P(x,v[cur][i].to));\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<iomanip>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define sc second\n#define pb push_back\n#define mk make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntemplate<class S,class T>\nostream &operator<<(ostream &out, const pair<S,T> p){\n\treturn out << \"(\" << p.fs << \", \" << p.sc << \")\";\n}\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \", \";\n\treturn out << \"}\" << endl;\n}\n\n#define N 30\ndouble d[N+1][N][N];\n// -time, from, current, speed\nstruct elem{\n\tdouble t;\n\tint f,c,s;\n\telem(){};\n\telem(double time, int from, int cur, int sp){\n\t\tt = time; f = from; c = cur; s = sp;\n\t}\n\tbool operator<(const elem r) const{ return mk(mk(t, f),mk(c,s)) < mk(mk(r.t,r.f), mk(r.c,r.s)); }\n};\nostream &operator<<(ostream &out, const elem &e){\n\treturn out << \"{\" << e.t << \", \" << e.f << \", \" << e.c << \", \" << e.s << \"}\";\n}\n\n\n#define INF (1e12)\nint main(){\n\tint n, m, s, g;\n\twhile(cin >> n >> m, n){\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\t\tfill(d[0][0], d[0][0] + (N+1) * N * N, INF);\n\t\tvector<pair<int,double> > e[N+2][N];// e[c][x] : from x at vert c : (to, time) list\n\t\trep(i, m){\n\t\t\tint x, y, di, c;\n\t\t\tcin >> x >> y >> di >> c;\n\t\t\tx--; y--;\n\t\t\treps(j,1,c+1){\n\t\t\t\tdouble time = di / (double) j;\n\t\t\t\te[j][x].pb(mk(y, time));\n\t\t\t\te[j][y].pb(mk(x, time));\n\t\t\t}\n\t\t}\n\t\tpriority_queue<elem> q;\n\t\tq.push(elem(-0.0, -1, s, 0));//initial state\n\t\twhile(!q.empty()){\n\t\t\telem el = q.top();\n\t\t\tdouble dst = - el.t;\n\t\t\tint from = el.f, cur = el.c, sp = el.s;\n\t\t\tq.pop();\n\t\t\tif(from>=0){\n\t\t\t\tif(d[sp][cur][from] < INF) continue;\n//\t\t\t\tif(d[sp][cur][from] < dst) continue;\n\t\t\t\td[sp][cur][from] = dst;\n\t\t\t}\n//\t\t\tcout << el << endl;\n//\t\t\tif(sp == 1 && cur == g) break;\n\t\t\trep(i,3){\n\t\t\t\tint ci = sp - 1 + i;\n\t\t\t\tif(ci<1 || ci > N) continue;\n\t\t\t\trep(j, e[ci][cur].size()){\n\t\t\t\t\tpair<int, double> p = e[ci][cur][j];\n\t\t\t\t\tint to = p.fs;\n\t\t\t\t\tif (from == to) continue;\n\t\t\t\t\tdouble tmp = dst + p.sc;\n\t\t\t\t\tq.push(elem(-tmp, cur, to, ci));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\treps(i, 1, N+1){\n\t\t\tcout << \"v : \" << i << endl;\n\t\t\trep(j, n) cout << d[i][j] << \", \";\n\t\t\tcout << endl;\n\t\t}\n*/\n\t\tdouble ans = INF;\n\t\trep(i,n) ans = min(ans, d[1][g][i]);\n\t\tif(ans >= INF) cout << \"unreachable\" << endl;\n\t\telse cout <<fixed << setprecision(10)<< ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cstdio>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n\ntypedef long long int64;\ntypedef pair< double, int > iP;\ntypedef pair< iP, iP > iiP;\n\nconst int INF = 2 << 28;\nconst double EPS = 1e-10;\n\nstruct edge {\n    int to, dis, lim;\n};\n\nclass Dijkstra {\n    vector< vector< edge > > graph;\n    double minCost[31][31][31];\npublic:\n    Dijkstra(int N) {\n        graph.resize(N);\n        fill_n(**minCost, 31 * 31 * 31, INF);\n    }\n    \n    void add_edge(int from, int to, int dist, int limit) {\n        graph[from].push_back((edge){to, dist, limit});\n    }\n    \n    string run(int S, int G) {\n        // time, now, prev, velocity\n        priority_queue< iiP, vector< iiP >, greater< iiP > > que;\n        for(int i = 0; i < graph[S].size(); i++) {\n            que.push(iiP(iP(graph[S][i].dis, graph[S][i].to), iP(S, 1)));\n            minCost[graph[S][i].to][S][1] = graph[S][i].dis;\n        }\n        while(!que.empty()) {\n            iiP p = que.top(); que.pop();\n            int now = p.fr.sc,  prev = p.sc.fr, v = p.sc.sc;\n            double timed = p.fr.fr;\n            if(now == G && v == 1) {\n                stringstream sss; sss << fixed << setprecision(10) << timed;\n                return sss.str();\n            }\n            for(int i = 0; i < graph[now].size(); i++) {\n                edge &e = graph[now][i];\n                if(e.to == prev) continue;\n                for(int j = -1; j <= 1; j++) {\n                    int nextv = v + j;\n                    if(nextv < 1 || nextv > e.lim) continue;\n                    if((double)e.dis / nextv + timed < minCost[e.to][now][nextv]) {\n                        que.push(iiP(iP((double)e.dis / nextv + timed, e.to), iP(now, nextv)));\n                        minCost[e.to][now][nextv] = (double)e.dis / nextv + timed;\n                    }\n                }\n            }\n        }\n        return \"unreachable\";\n    }\n};\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n) {\n        Dijkstra solver(n + 1);\n        int s, g; cin >> s >> g;\n        for(int i = 0; i < m; i++) {\n            int a, b, d, l; cin >> a >> b >> d >> l;\n            solver.add_edge(a, b, d, l);\n            solver.add_edge(b, a, d, l);\n        }\n        cout << solver.run(s, g) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<int,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a3,a2,a4;\ndouble d[31][31];\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)if(d[i][j]!=1e12)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      scanf(\"%d%d%d%d\",&a1,&a2,&a3,&a4);\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P>q;\n    d[st][0]=0;\n    P xtt;xtt.fi=0,xtt.se=st*1000+0;\n    q.push(xtt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.se/1000,xx=p.se%1000;\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=xx)r(j,3){\n          int x=p.fi+dx[j];\n          if(0<x&&x<=e.lim){\n            double t=e.dist/x+d[cur][p.fi];\n            if(d[e.to][x]>t){\n              d[e.to][x]=t;\n              P xt;xt.fi=x,xt.se=cur+e.to*1000;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\nint n, m, s, g;\n\ndouble solve(pair<double, double> r[31][31])\n{\n    double result[31][31][31];\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            for(int k = 1; k <= 31; k++){\n                result[i][j][k] = mod;\n            }\n        }\n    }\n    priority_queue<pair<double, pair<pair<int, int>, int> > > qu;\n    qu.push(make_pair(0.0, make_pair(make_pair(s, -1), 0.0)));\n    while(!qu.empty()){\n        double nowcost = (qu.top()).first;\n        pair<int, int> nowandbefore = ((qu.top()).second).first;\n        int nowv = ((qu.top()).second).second;\n        int nowp = nowandbefore.first;\n        int beforep = nowandbefore.second;\n        // cout << nowp << \" \" << beforep << \" \" << -nowcost << \" \" << nowv << endl;\n        qu.pop();\n        if(nowp == g && nowv == 1) {\n            return -nowcost;\n        }\n        if(beforep != -1 && result[nowp][beforep][nowv] < -nowcost) continue;\n        result[nowp][beforep][nowv] = -nowcost;\n        for(int i = 1; i <= n; i++){\n            if(r[nowp][i].first == 0 || i == beforep) continue;\n            double kyori = r[nowp][i].first;\n            double limit = r[nowp][i].second;\n            double nextcost;\n            for(int j = -1; j <= 1; j++){\n                if(nowv + j <= 0) continue;\n                nextcost = nowcost - (double)kyori / (nowv + j);\n                if(nowv + j <= limit && -nextcost < result[i][nowp][nowv + j]){\n                    result[i][nowp][nowv + j] = -nextcost;\n                    qu.push(make_pair(nextcost, make_pair(make_pair(i, nowp), nowv + j)));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    while(1){\n        cin >> n >> m;\n        if(n == 0) break;\n        cin >> s >> g;\n        pair<double, double> road[31][31];\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= n; j++){\n                road[i][j] = make_pair(0, 0);\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int x, y;\n            double d, c;\n            cin >> x >> y >> d >> c;\n            road[x][y] = road[y][x] = make_pair(d, c);\n        }\n        double ans =  solve(road);\n        if(ans == -1) cout << \"unreachable\" << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\nint n, m, s, g;\n\ndouble solve(pair<double, double> r[31][31])\n{\n    double result[31][31][31];\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            for(int k = 1; k <= 31; k++){\n                result[i][j][k] = mod;\n            }\n        }\n    }\n    priority_queue<pair<double, pair<pair<int, int>, int> > > qu;\n    qu.push(make_pair(0.0, make_pair(make_pair(s, -1), 0.0)));\n    while(!qu.empty()){\n        double nowcost = (qu.top()).first;\n        pair<int, int> nowandbefore = ((qu.top()).second).first;\n        int nowv = ((qu.top()).second).second;\n        int nowp = nowandbefore.first;\n        int beforep = nowandbefore.second;\n        // cout << nowp << \" \" << beforep << \" \" << -nowcost << \" \" << nowv << endl;\n        qu.pop();\n        if(nowp == g && nowv == 1) {\n            return -nowcost;\n        }\n        if(beforep != -1 && result[nowp][beforep][nowv] < -nowcost) continue;\n        result[nowp][beforep][nowv] = -nowcost;\n        for(int i = 1; i <= n; i++){\n            if(r[nowp][i].first == 0 || i == beforep) continue;\n            double kyori = r[nowp][i].first;\n            double limit = r[nowp][i].second;\n            double nextcost;\n            for(int j = -1; j <= 1; j++){\n                if(nowv + j <= 0) continue;\n                nextcost = nowcost - (double)kyori / (nowv + j);\n                if(nowv + j <= limit && -nextcost < result[i][nowp][nowv + j]){\n                    result[i][nowp][nowv + j] = -nextcost;\n                    qu.push(make_pair(nextcost, make_pair(make_pair(i, nowp), nowv + j)));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    while(1){\n        cin >> n >> m;\n        if(n == 0) break;\n        cin >> s >> g;\n        pair<double, double> road[31][31];\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= n; j++){\n                road[i][j] = make_pair(0, 0);\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int x, y;\n            double d, c;\n            cin >> x >> y >> d >> c;\n            road[x][y] = road[y][x] = make_pair(d, c);\n        }\n        double ans =  solve(road);\n        if(ans == -1) cout << \"unreachable\" << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\nstruct Info{\n\tint now,bef,sp;\n\tInfo(int _now,int _bef,int _sp){\n\t\tnow=_now;\n\t\tbef=_bef;\n\t\tsp=_sp;\n\t}\n};\n\nbool operator<(const Info &i1,const Info &i2){\n\treturn true;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tstatic int adj[30][30],lim[30][30];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)\tadj[i][j]=-1;\n\n\t\tint s,g;\tscanf(\"%d%d\",&s,&g);\n\t\ts--,g--;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,l;\tscanf(\"%d%d%d%d\",&x,&y,&d,&l);\n\t\t\tx--,y--;\n\t\t\tadj[x][y]=adj[y][x]=d;\n\t\t\tlim[x][y]=lim[y][x]=l;\n\t\t}\n\n\t\tstatic bool visited[30][30][31];\n\t\tstatic double tmin[30][30][31];\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)for(int k=0;k<=30;k++){\n\t\t\tvisited[i][j][k]=false;\n\t\t\ttmin[i][j][k]=1<<30;\n\t\t}\n\n\t\ttmin[s][s][0]=0;\n\t\tdouble ans=-1;\n\t\tpriority_queue< pair<double,Info> > pq;\tpq.push(mp(0,Info(s,s,0)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<double,Info> a=pq.top();\tpq.pop();\n\t\t\tint u=a.second.now,bef=a.second.bef,sp=a.second.sp;\n\t\t\tif(visited[u][bef][sp])\tcontinue;\n//printf(\"t=%.3f, u=%d, speed=%d\\n\",-a.first,u,sp);\n\t\t\tvisited[u][bef][sp]=true;\n\t\t\tif(u==g && sp==1){\n\t\t\t\tans=tmin[u][bef][sp];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int v=0;v<n;v++){\n\t\t\t\tif(adj[u][v]==-1 || v==bef)\tcontinue;\n//printf(\"  v candi %d\\n\",v);\n\t\t\t\tfor(int dv=-1;dv<=1;dv++){\n\t\t\t\t\tint nextsp=sp+dv;\n//printf(\"    nextspeed=%d, lim=%d\\n\",nextsp,lim[u][v]);\n\t\t\t\t\tif(1<=nextsp && nextsp<=lim[u][v]){\n//\t\t\t\t\tif(!visited[v][nextsp] && 1<=nextsp && nextsp<=lim[u][v]){\n\t\t\t\t\t\tdouble nextt=tmin[u][bef][sp]+(double)adj[u][v]/nextsp;\n//printf(\"      passed. nextt=%.3f, tmin=%.3f\\n\",nextt,tmin[v][nextsp]);\n\t\t\t\t\t\tif(nextt<tmin[v][u][nextsp]){\n\t\t\t\t\t\t\tpq.push(mp(-nextt,Info(v,u,nextsp)));\n\t\t\t\t\t\t\ttmin[v][u][nextsp]=nextt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans<0)\tputs(\"unreachable\");\n\t\telse\t\tprintf(\"%f\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\nint n,m,s,g;\ndouble d[40][40][40];\n\nint main(){\n  int inx,iny,ind,inc;\n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n\n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n    \n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1 << 30;\nconst double EPS = 1E-9;\n\nint n, m, s, g;\nstruct edge{\n\tint to;\n\tint cost;\n\tint limit;\n};\nvector<edge> G[101];\ndouble t[101][31];\nint pre[101][31];\n\nint main(){\n\twhile(cin >> n >> m && (n || m)){\n\t\tcin >> s >> g;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint from, to;\n\t\t\tedge e;\n\t\t\tcin >> from >> to >> e.cost >> e.limit;\n\t\t\te.to = to;\n\t\t\tG[from].push_back(e);\n\t\t\te.to = from;\n\t\t\tG[to].push_back(e);\n\t\t}\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tfill(t[i], t[i] + 101, -1.0);\n\t\t}\n\t\tmemset(pre, -1, sizeof(pre));\n\t\tt[s][1] = 0;\n\t\tpriority_queue<pair<double, P>, vector<pair<double, P> >, greater<pair<double, P> > > que;\n\t\tque.push(make_pair(0, P(s, 1)));\n\t\twhile(!que.empty()){\n\t\t\tpair<double, P > pp = que.top(); que.pop();\n\t\t\tP p = pp.second;\n\t\t\tdouble tm = pp.first;\n\t\t\tint place = p.first;\n\t\t\tint v = p.second;\n\t\t\tif(tm > t[place][v] || v == 0) continue;\n\t\t\tfor(size_t i = 0; i < G[place].size(); i++){\n\t\t\t\tedge e = G[place][i];\n\t\t\t\tif(v > e.limit || e.to == pre[place][v]) continue;\n\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\tif(v + j >= 0 && v + j <= 30){\n\t\t\t\t\t\tif(t[e.to][v+j] < 0.0 || t[e.to][v+j] > t[place][v] + (double)e.cost / v + EPS){\n\t\t\t\t\t\t\tt[e.to][v+j] = t[place][v] + (double)e.cost / (double)v;\n\t\t\t\t\t\t\tpre[e.to][v+j] = place;\n\t\t\t\t\t\t\tque.push(make_pair(t[e.to][v+j], P(e.to, v+j)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t[g][0] < 0) cout << \"unreachable\" << endl;\n\t\telse cout << t[g][0] << endl;\n\t\tfor(int i = 0; i < 101; i++) G[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nclass data\n{\npublic:\n    int p, q, c;\n    data(int p0, int q0, int c0){\n        p = p0;\n        q = q0;\n        c = c0;\n    }\n};\n\nvoid solve(int n, int start, int goal, vector<vector<int> > distance, vector<vector<int> > limit)\n{\n    vector<bool> easyCheck(n, false);\n    queue<int> q;\n    q.push(start);\n    while(!q.empty()){\n        int a = q.front();\n        if(!easyCheck[a]){\n            easyCheck[a] = true;\n            for(int i=0; i<n; ++i){\n                if(distance[a][i] > -1)\n                    q.push(i);\n            }\n        }\n        q.pop();\n    }\n    if(!easyCheck[goal]){\n        cout << \"unreachable\" << endl;\n        return;\n    }\n\n\tbool check[30][30][31];\n\tdouble time[30][30][31];\n\tfor(int i=0; i<n; ++i){\n\t\tfor(int j=0; j<n; ++j){\n\t\t\tfor(int k=0; k<31; ++k){\n\t\t\t\tcheck[i][j][k] = false;\n\t\t\t\ttime[i][j][k] = DBL_MAX;\n\t\t\t}\n\t\t}\n\t}\n    for(int i=0; i<n; ++i){\n        if(distance[start][i] > -1)\n\t\t\ttime[i][start][1] = distance[start][i];\n    }\n\n    for(;;){\n\t\tint p, q, c;\n\t\tdouble minTime = DBL_MAX;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tfor(int j=0; j<n; ++j){\n\t\t\t\tfor(int k=1; k<=limit[i][j]; ++k){\n\t\t\t\t\tif(!check[i][j][k] && time[i][j][k] < minTime){\n\t\t\t\t\t\tp = i;\n\t\t\t\t\t\tq = j;\n\t\t\t\t\t\tc = k;\n\t\t\t\t\t\tminTime = time[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(p == goal && c == 1){\n\t\t\tprintf(\"%.10f\\n\", minTime);\n\t\t\treturn;\n\t\t}\n\n        check[p][q][c] = true;\n        for(int i=0; i<n; ++i){\n            if(i == p || i == q || distance[i][p] == -1)\n                continue;\n            for(int j=-1; j<=1; ++j){\n                if(1 <= c+j && c+j <= limit[p][i] && !check[i][p][c+j])\n\t\t\t\t\ttime[i][p][c+j] = min(time[i][p][c+j], minTime + distance[p][i]/static_cast<double>(c+j));\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, s, g;\n        cin >> n >> m;\n        if(n == 0 && m == 0)\n            break;\n        cin >> s >> g;\n        -- s;\n        -- g;\n\n        vector<vector<int> > distance(n, vector<int>(n, -1));\n        vector<vector<int> > limit(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int x, y;\n            cin >> x >> y;\n            -- x;\n            -- y;\n            cin >> distance[x][y] >> limit[x][y];\n            distance[y][x] = distance[x][y];\n            limit[y][x] = limit[x][y];\n        }\n\n        solve(n, s, g, distance, limit);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\ndouble memo[32][32]; //[vol][vertex] = time\nint N,M,S,G;\nstruct e {\n\tint d,c;\n}edge[32][32];\n\nvoid solve(int vertex,int vol,int befor,double cost,int cnt)\n{\n\tif(cost > memo[1][G])return;\n\t//printf(\"%d,%d,%d,%lf,%d\\n\",vertex,vol,befor,cost,cnt);\n\t\n\tint v;\n\tfor(int i=1;i<=N;i++){\n\t\tif(vertex==i || i==befor || edge[vertex][i].d == 0)continue;\n\t\tif(vol>0 && vol<=edge[vertex][i].c){\n\t\t\tif(memo[vol][i] > (double)edge[vertex][i].d/(double)vol + cost){\n\t\t\t\tmemo[vol][i] = (double)edge[vertex][i].d/(double)vol + cost;\n\t\t\t\tsolve(i,vol,vertex,memo[vol][i],cnt+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(vol+1>0 && vol+1<=edge[vertex][i].c){\n\t\t\tif(memo[vol+1][i] > (double)edge[vertex][i].d/(double)(vol+1) + cost){\n\t\t\t\tmemo[vol+1][i] = (double)edge[vertex][i].d/(double)(vol+1) + cost;\n\t\t\t\tsolve(i,vol+1,vertex,memo[vol+1][i],cnt+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(vol-1>0 && vol-1<=edge[vertex][i].c){\n\t\t\tif(memo[vol-1][i] > (double)edge[vertex][i].d/(double)(vol-1) + cost){\n\t\t\t\tmemo[vol-1][i] = (double)edge[vertex][i].d/(double)(vol-1) + cost;\n\t\t\t\tsolve(i,vol-1,vertex,memo[vol-1][i],cnt+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint x,y,d,c;\n\tfor(;cin>>N>>M,N||M;){\n\t\tcin>>S>>G;\n\t\tfor(int i=0;i<32;i++)for(int j=0;j<32;j++)\n\t\t\tmemo[i][j]=999999.0;\n\t\tmemset(edge,0,sizeof(edge));\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tedge[x][y].d = edge[y][x].d = d;\n\t\t\tedge[x][y].c = edge[y][x].c = c;\n\t\t}\n\t\tmemo[1][S] = 0.0;\n\t\t//solve(S, 0, 0, 0.0, 0);\n\t\tqueue<pair<int,int> > qq;\n\t\tqueue<int> befor;\n\t\tqueue<double> cc;\n\t\tqq.push(make_pair(0,S));\n\t\tbefor.push(S);\n\t\tcc.push(0.0);\n\t\tfor(;!qq.empty();qq.pop()){\n\t\t\tint vol = qq.front().first;\n\t\t\tint vertex = qq.front().second;\n\t\t\tint b = befor.front();\n\t\t\tdouble cost = cc.front();\n\t\t\tbefor.pop();\n\t\t\tcc.pop();\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\tif(i==vertex || i==b || edge[vertex][i].d == 0)continue;\n\t\t\t\tif(vol>0 && vol<=edge[vertex][i].c){\n\t\t\t\t\tif(memo[vol][i] > (double)edge[vertex][i].d/vol + cost){\n\t\t\t\t\t\tmemo[vol][i] = (double)edge[vertex][i].d/vol + cost;\n\t\t\t\t\t\tqq.push(make_pair(vol,i));\n\t\t\t\t\t\tbefor.push(vertex);\n\t\t\t\t\t\tcc.push(memo[vol][i]);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(vol+1>0 && vol+1<=edge[vertex][i].c){\n\t\t\t\t\tif(memo[vol+1][i] > (double)edge[vertex][i].d/(vol+1) + cost){\n\t\t\t\t\t\tmemo[vol+1][i] = (double)edge[vertex][i].d/(vol+1) + cost;\n\t\t\t\t\t\tqq.push(make_pair(vol+1,i));\n\t\t\t\t\t\tbefor.push(vertex);\n\t\t\t\t\t\tcc.push(memo[vol+1][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(vol-1>0 && vol-1<=edge[vertex][i].c){\n\t\t\t\t\tif(memo[vol-1][i] > (double)edge[vertex][i].d/(vol-1) + cost){\n\t\t\t\t\t\tmemo[vol-1][i] = (double)edge[vertex][i].d/(vol-1) + cost;\n\t\t\t\t\t\tqq.push(make_pair(vol-1,i));\n\t\t\t\t\t\tbefor.push(vertex);\n\t\t\t\t\t\tcc.push(memo[vol-1][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif(memo[1][G]==999999.0)\n\t\t\tputs(\"unreachable\");\n\t\telse printf(\"%lf\\n\",memo[1][G]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<set>\n#define INF 100000.0\nusing namespace std;\nstruct S{\n\tint town;\n\tint from;\n\tint v;\n\tdouble cost;\n\tvoid set(int a,int b,int c,double d){\n\t\ttown=a;from=b;v=c;cost=d;\n\t}\n\tinline bool operator<(const S &a)const{\n\t\treturn this->cost<a.cost;\n\t}\n};\ndouble dp[30][30][31];\nint d[30][30];\nint c[30][30];\nmultiset<S> Set;\nmultiset<S>::iterator it; \nint main(){\t\n\tint n,m;\n\tint s,g;\n\tint x,y,t,u;\n\tdouble min;\n\tbool start;\n\tS a,b;\n\twhile(cin>>n>>m,n||m){\n\t\tmemset(d,-1,sizeof(d));\n\t\tmemset(c,-1,sizeof(c));\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<30;j++)for(int k=1;k<31;k++)dp[i][j][k]=INF;\n\t\tcin>>s>>g;\n\t\ts--;g--;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>x>>y;\n\t\t\tx--;y--;\n\t\t\tcin>>t;\n\t\t\td[y][x]=d[x][y]=t;\n\t\t\tcin>>t;\n\t\t\tc[y][x]=c[x][y]=t;\n\t\t}\n\t\ta.set(s,-1,1,0.0);\n\t\tSet.insert(a);\n\t\tstart=true;\n\t\twhile(!Set.empty()){\n\t\t\tit=Set.begin();\n\t\t\ta=*it;\n\t\t\tSet.erase(it);\n\t\t\tif(dp[a.town][a.from][a.v] < a.cost)continue;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tt=d[a.town][i];\n\t\t\t\tif(a.from==i || t==-1)continue;\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tu=c[a.town][i];\n\t\t\t\t\tif(a.v+j<1 || a.v+j>u)continue;\n\t\t\t\t\tif(start && j!=0)continue;\n\t\t\t\t\tb.set(i,a.town,a.v+j,a.cost+(double)t/(a.v+j));\n\t\t\t\t\tif(b.cost < dp[b.town][b.from][b.v]){\n\t\t\t\t\t\tdp[b.town][b.from][b.v]= b.cost;\n\t\t\t\t\t\tSet.insert(b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart=false;\n\t\t}\n\t\tmin=INF;\n\t\tfor(int i=0;i<n;i++)if(dp[g][i][1]<min)min=dp[g][i][1];\n\t\tif(min!=INF)printf(\"%.5f\\n\",min);//cout<<min<<endl;\n\t\telse cout<<\"unreachable\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define EPS 1e-8\n#define INF FLT_MAX\n\n//double cost[30][35]; // place,velocity\nfloat cost[30][35];\n\nstruct P{\n  //  double t;\n  float t;\n  char v,p,pre;\n  P(double T=0.0,int V=0,int pp=0,int PRE=0){\n    t=T;v=V;p=pp;pre=PRE;\n  };\n  bool operator<(const P &p)const{\n    return t>p.t;\n  }\n};\nstruct Path{\n  char d,c;\n  Path(int D=0,int C=0){ d=D;c=C;};\n};\n\nint main(){\n  int n,m, s,g, x,y,d,c;\n  Path path[30][30];\n  priority_queue<P> q;\n\n  while( cin>>n>>m && (n|m) ){\n    cin >> s >> g;\n    s--; g--;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tpath[i][j].d=-1.0; path[i][j].c=-1;\n      }\n\n    for( int i=0;i<m;i++ ){\n      cin >> x >> y >> d >> c;\n      x--;y--;\n      path[x][y].d=d; path[x][y].c=c;\n      path[y][x] = path[x][y];\n    }\n\n    int dv[3] = {1,0,-1};\n    for( int i=0;i<n;i++ )\n      for( int j=1;j<31;j++ )\n\tcost[i][j] = INF;\n\n    while( !q.empty() ) q.pop();\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      q.push( P(cost[i][1]=path[s][i].d,1,i,-1) );\n    }\n\n    while( !q.empty() ){\n      P p = q.top(); q.pop();\n      //      double t = p.t;\n      float t = p.t;\n      int v=p.v, np=p.p, pre=p.pre;\n      if( np==g && v==1 ) break;\n\n      for( int i=0;i<n;i++ ){\n\tif( path[np][i].c<0 ) continue;// たどり着けないノード\n\tif( i==pre ) continue; // 前回のノード\n\n\tint j=0;\n\tif( i==g ) j=2;\n\tfor( ;j<3;j++ ){\n\t  int nv = v + dv[j];\n\t  if( nv==0 || nv>path[np][i].c )    continue;\n\t  //\t  double nCost = t + (double)path[np][i].d/nv;\n\t  float nCost = t + (double)path[np][i].d/nv;\n\t  if( nCost>cost[g][1] || fabs(nCost-cost[g][1])<EPS ) continue;\n\t  if( cost[i][nv] < nCost ) continue;\n\t  cost[i][nv]=nCost;\n\n\t  q.push( P(nCost,nv,i,np) );\n\t}\n      }\n\n    }\n    if( fabs(cost[g][1]-INF)<EPS )\n      cout << \"unreachable\" << endl;\n    else\n      printf(\"%.6lf\\n\",cost[g][1]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){std::fill( (T*)array, (T*)(array+N), val );}\nusing ld=long double;\nstruct edge{int to,cost,limit;};\nusing P=pair<ld,pair<int,pair<int,int>>>;\n#define mp(i,j,k,l) make_pair((i),make_pair((j),make_pair((k),(l))))\nconst ld INF=1<<29;\nconst int MAX_V=35;\nvector<edge> G[MAX_V];\nld t[MAX_V][35];\nint V,E;\n//O(E*logV)\n\nint n,m,s,g;\nvoid dijkstra(){\n  priority_queue<P,vector<P>,greater<P>> que;\n  Fill(t,INF);\n  t[s][1]=0;\n  que.push(mp(0,-1,s,1));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int last=p.second.first;\n    int v=p.second.second.first;\n    int spd=p.second.second.second;\n    if(t[v][spd]<p.first)continue;\n    REP(i,G[v].size()){\n      edge e=G[v][i];\n      if(last==e.to)continue;\n      for(int j=-1;j<=1;j++){\n\tif(spd<=0||spd>e.limit)continue;\n\t//cout<<\"[\"<<v<<\"->\"<<e.to<<\"] \"<<t[e.to][spd+j]<<\">\"<<t[v][spd]<<\"+\"<<((double)e.cost)/spd<<endl;\n\tif(t[e.to][spd+j]>t[v][spd]+((double)e.cost)/spd){\n\t  t[e.to][spd+j]=t[v][spd]+((double)e.cost)/spd;\n\t  que.push(mp(t[e.to][spd+j],v,e.to,spd+j));\n\t}\n      }\n    }\n  }\n  if(t[g][0]!=INF){\n    printf(\"%.5Lf\\n\",t[g][0]);\n    return;\n  }\n  printf(\"unreachable\\n\");\n}\nint x,y,d,c;\nint main(){ _;\n  while(cin>>n>>m,(n|m)){\n    REP(i,MAX_V)G[i].clear();\n    cin>>s>>g;\n    REP(i,m){\n      cin>>x>>y>>d>>c;\n      G[x].push_back(edge{y,d,c});\n      G[y].push_back(edge{x,d,c});\n    }\n    dijkstra();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nstruct Edge {int to, dis, c;};\n\nstruct Status{\n  double cost;\n  int pos, pre, v;\n  bool operator<(const Status &s) const {return cost > s.cost;}\n};\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n    int s, g;\n    cin >> s >> g;\n    --s, --g;\n    vector<Edge> edge[n];\n    rep (i, m) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      --x, --y;\n      edge[x].push_back((Edge){y, d, c});\n      edge[y].push_back((Edge){x, d, c});\n    }\n    priority_queue<Status> que;\n    que.push((Status){0, s, 39, 0});\n    double dis[40][40][40];\n    rep (i, 40) rep (j, 40) rep (k, 40) dis[i][j][k] = 1e99;\n    while (!que.empty()) {\n      Status now = que.top();\n      que.pop();\n      if (dis[now.pos][now.pre][now.v] < now.cost + 1e-8) continue;\n      dis[now.pos][now.pre][now.v] = now.cost;\n      if (now.pos == g && now.v == 1) break;\n      rep (i, edge[now.pos].size()) {\n\tint to = edge[now.pos][i].to;\n\tdouble dis = edge[now.pos][i].dis;\n\tif (to == now.pre) continue;\n\tif (now.v > 0) que.push((Status){now.cost + dis / now.v, to, now.pos, now.v});\n\tif (now.v > 1) que.push((Status){now.cost + dis / (now.v - 1), to, now.pos, now.v - 1});\n\tif (now.v < edge[now.pos][i].c) que.push((Status){now.cost + dis / (now.v + 1), to, now.pos, now.v + 1});\n      }\n    }\n    double res = 1e99;\n    rep (i, 40) res = min(res, dis[g][i][1]);\n    if (res == 1e99) puts(\"unreachable\");\n    else printf(\"%.12lf\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int INFINITY_HAHA = 999999;\n\ntypedef struct edge\n{\n    int to, limit;\n    double dist;\n    edge(int x, double y, int z): to(x), dist(y), limit(z) {}\n} Edge;\n\n\ntypedef struct status {\n    int from, now, speed;\n    double time;\n    status(int x, int x2, double y, int z): from(x), now(x2), time(y), speed(z) {}\n    bool operator< (const status &b) const {\n        return time > b.time;\n    }\n} Status;\n\n\n\nint main() {\n    // freopen(\"input.txt\", \"r\", stdin);\n \n    int ncities, nroads;\n    double d[35][35][35];\n\n    while(scanf(\"%d%d\", &ncities, &nroads) != EOF && !(ncities == 0 && nroads == 0)) {\n\n        // Input\n        int start_index, end_index;\n        scanf(\"%d%d\" , &start_index, &end_index);\n\n        vector<Edge> paths[100]; // Array of vector\n        for(int n = 0; n < nroads; ++n) {\n            int x, y, d, c;\n            scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n            paths[x].push_back(Edge(y, d, c));\n            paths[y].push_back(Edge(x, d, c));\n        }\n\n        for(int i = 0; i < 35; ++i) {\n            for(int j = 0; j < 35; ++j) {\n                for(int k = 0; k < 35; ++k) {\n                    d[i][j][k]= INFINITY_HAHA;\n                }\n            }\n        }\n\n        double minimun_v = 0;\n        priority_queue< Status> Q;\n        for(int i = 0; i < paths[start_index].size(); ++i) {\n            Edge e = paths[start_index][i];\n            Q.push(Status(start_index, e.to, e.dist, 1));\n            d[start_index][e.to][1] = e.dist;\n        }\n\n        while(!Q.empty()) {\n            Status cs = Q.top();\n            Q.pop();\n \n            if(d[cs.from][cs.now][cs.speed] < cs.time) continue;\n\n            if(cs.now == end_index && cs.speed == 1) {\n                minimun_v = cs.time;\n                break;\n            }\n\n            for(int j = 0; j < paths[cs.now].size(); ++j) {\n                Edge s = paths[cs.now][j];\n                if(s.to == cs.from) continue;\n\n                for(int z = -1; z <= 1; ++z) {\n                    if(cs.speed + z > 0 && cs.speed + z <= s.limit) {\n                        double newdist = cs.time + s.dist/((double)(cs.speed + z));\n                        if(newdist < d[cs.now][s.to][cs.speed + z]) {\n                            d[cs.now][s.to][cs.speed + z] = newdist;\n                            Q.push(Status(cs.now, s.to, newdist, cs.speed + z));\n                        }\n                    }\n                }\n            }\n        }\n \n        if(minimun_v) {\n            printf(\"%0.5lf\\n\", minimun_v);\n        } else {\n            printf(\"unreachable\\n\");\n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int INF = 1e15;\n\nstruct Edge {\n  int to, d, c;  \n};\n\nint s, g;\nint n, m;\nvector<Edge> G[31];\n\ntypedef pair<int, int> P;\ntypedef pair<double, int> E;\ntypedef pair<E, P> PE;\n\ndouble dij() {\n  double ret = INF;  \n  bool used[n+1][n+1][101];\n  fill_n(**used, (n+1)*(n+1)*101, false);\n  priority_queue<PE, vector<PE>, greater<PE> > q;  \n  q.push(PE(E(0, n), P(s, 1)));  \n  while ( !q.empty() ) {\n    PE e = q.top(); q.pop();    \n    double c = e.first.first;\n    int pre = e.first.second;    \n    int u = e.second.first, v = e.second.second;\n    // cout << u << \" \" << v << endl;\n    if ( u == g && v == 1 ) {\n      \n    }\n\n    if ( used[u][pre][v] ) continue;\n    used[u][pre][v] = true;    \n    for ( Edge &f : G[u] ) {\n      if ( pre == f.to ) continue;      \n      if ( f.c < v ) continue;\n      if ( f.to == g && v == 1 ) {\n\tret = min(ret, c+(double)f.d);\t\n      }\n      q.push(PE(E(c+(double)f.d/v, u), P(f.to, v)));      \n      q.push(PE(E(c+(double)f.d/v, u), P(f.to, v+1)));\n      if ( v >= 2 ) q.push(PE(E(c+(double)f.d/v, u), P(f.to, v-1)));      \n    }\n  }\n\n  return ret;\n}\n\nsigned main() {  \n  while ( cin >> n >> m, n ) {\n    for ( int i = 0; i < 31; i++ ) G[i].clear();    \n    cin >> s >> g;\n    s--; g--;\n    for ( int i = 0; i < m; i++ ) {\n      int a, b, d, c;\n      cin >> a >> b >> d >> c;\n      a--; b--;\n      G[a].emplace_back(Edge{b, d, c});\n      G[b].emplace_back(Edge{a, d, c});\n    }\n\n    double ans = dij();\n    if ( ans >= INF-100 ) cout << \"unreachable\" << endl;\n    else printf(\"%.10lf\\n\", ans);    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1e9\nusing namespace std;\ndouble cost[30][30][31]; int d[30][30],c[30][30];\nstruct S{\n\tint c,p,v;\n\tS(int c,int p,int v):c(c),p(p),v(v){}\n};\nint main(){\n\tint n,m,s,g,x,y,a,b; double nc,ans;\n\twhile(scanf(\"%d%d\",&n,&m),n){\n\t\tscanf(\"%d%d\",&s,&g),s--,g--;\n\t\trep(i,n)rep(j,n){\n\t\t\trep(k,31)cost[i][j][k]=INF;\n\t\t\td[i][j]=c[i][j]=0;\n\t\t}\n\t\trep(i,m)scanf(\"%d%d%d%d\",&x,&y,&a,&b),\n\t\tx--,y--,d[x][y]=d[y][x]=a,c[x][y]=c[y][x]=b;\n\t\tqueue<S> F; F.push(S(s,s,0)); cost[s][s][0]=0;\n\t\twhile(!F.empty()){\n\t\t\tS cs=F.front(); F.pop();\n\t\t\trep(i,n)if(i!=cs.p&&d[cs.c][i])\n\t\t\tfor(int dv=-1;dv<2;dv++)if(0<dv+cs.v&&dv+cs.v<=c[cs.c][i]){\n\t\t\t\tnc=cost[cs.c][cs.p][cs.v]+1.*d[cs.c][i]/(dv+cs.v);\n\t\t\t\tif(cost[i][cs.c][dv+cs.v]>nc)\n\t\t\t\tcost[i][cs.c][dv+cs.v]=nc,F.push(S(i,cs.c,dv+cs.v));\n\t\t\t}\n\t\t}\n\t\tans=INF; rep(i,n)if(cost[g][i][1]<ans)ans=cost[g][i][1];\n\t\tif(ans==INF)printf(\"unreachable\\n\");\n\t\telse printf(\"%.5f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n\tint cost,limit;\n\tedge(int c,int l){\n\t\tcost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tvector<vector<edge> > E(n+1,vector<edge>(n+1,edge(-1,-1)));\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in][out]=edge(c,l);\n\t\tE[out][in]=edge(c,l);\n\t}\n\n\tvector<vector<vector<double> > > Ans(n+1,vector<vector<double> >(n+1,vector<double>(31,INF)));\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){\n\t\tNode t=Q.top(); Q.pop();\n\t\tif(Ans[t.now][t.before][t.speed]<=t.time) continue;\t\t\n//\t\tcout<<t.now<<\" \"<<t.speed<<\" \"<<t.time<<endl;\n\t\tif(t.now==g && t.speed==1){printf(\"%.12lf\\n\", t.time );  return;}\n\t\tAns[t.now][t.before][t.speed]=t.time;\n\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tif(i==t.before) continue;\n\t\t\tif(E[t.now][i].cost>0){\n\t\t\t\tif(E[t.now][i].limit>=t.speed && t.speed>=1)\n\t\t\t\t\tQ.push(Node(i,t.speed,t.time+E[t.now][i].cost/(double)t.speed,t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed+1)\n\t\t\t\t\tQ.push(Node(i,t.speed+1,t.time+E[t.now][i].cost/(double)(t.speed+1.0),t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed-1 && t.speed-1>=1)\n\t\t\t\t\tQ.push(Node(i,t.speed-1,t.time+E[t.now][i].cost/(double)(t.speed-1.0),t.now));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\"<<endl;\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\n\nclass Dijkstra {\n    using T = double;\npublic:\n    struct edge {\n        int to;\n        T cost;\n    };\n    typedef pair<T, int> P;//firstは最短距離、secondは頂点の番号\n\n    int V;//超点数\n    vector<vector<edge> > G;//グラフ,G[i]はiから出る辺の集合,G[i][j]はiから出る辺のj番目の辺\n    vector<T> d; //最短距離\n\n    //0origin\n    Dijkstra(int N) {\n        V = N;\n        G = vector<vector<edge> >(N);\n        d = vector<T>(N);\n    };\n\n    void dijkstra(int s) {\n        priority_queue<P, vector<P>, greater<P> > que;\n        fill(d.begin(), d.end(), INFl);\n        d[s] = 0;\n        que.push(P(0, s));\n\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if (d[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge e = G[v][i];\n                if (d[e.to] > d[v] + e.cost && !(d[e.to] == INFl && d[v] == INFl)) {\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n\n    }\n\n    /* 頂点fromに頂点toに達するコストcostの辺を貼る */\n    void addEdge(int from, int to, T cost) {\n        edge e;\n        e.to = to;\n        e.cost = cost;\n        G[from].push_back(e);\n    }\n};\n\nvoid solve(int n, int m) {\n    int s, g;\n    cin >> s >> g;\n    s--;\n    g--;\n\n    auto conv = [&](int f, int t, int v) {\n        //(頂点、速度)\n        return v * n * n + f * n + t;\n    };\n\n    Dijkstra dij(200 * n * n + n * n + n);\n\n    rep(i, 0, m) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        x--;\n        y--;\n        auto check = [&](int v) {\n            return v > 0 && v <= c;\n        };\n        rep(v, 0, 31) {\n            for (int V = v - 1; V <= v + 1; V++) {\n//                if(check(V)){\n//                    double tmp = 1.0 * d / V;\n//                    dij.addEdge(conv(x,v),conv(y,V),tmp);\n//                    dij.addEdge(conv(y,v),conv(x,V),tmp);\n//                }\n                for (int f = 0; f < n; f++) {\n                    if (check(V)) {\n                        double tmp = 1.0 * d / V;\n                        if (f != y) {\n                            dij.addEdge(conv(f, x, v), conv(x, y, V), tmp);\n                        }\n                        if (f != x) {\n                            dij.addEdge(conv(f, y, v), conv(y, x, V), tmp);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    dij.dijkstra(conv(s, s, 0));\n//    cout << dij.d[conv(g,1)] << endl;\n    double ans = INFl;\n    rep(i, 0, n) {\n        ans = min(ans, dij.d[conv(i, g, 1)]);\n    }\n    if (ans > 1e7) {\n        cout << \"unreachable\" << endl;\n    } else {\n//        cout << ans << endl;\n        printf(\"%.12lf\", ans);\n        cout << endl;\n    }\n\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\nclass data{\npublic:\n\tint t,c,d;\n\n};\n\nclass data2{\npublic:\n\tdouble cost;\n\tint v,s;\n\tbool operator<(const data2 &d1)const{\n\t\treturn d1.cost<cost;\n\t}\n};\n\nint n,m,s,g;\ndouble dp[35][35];\nvector<data> edge[35];\n\ndouble dijk(){\n\tfor(int i=0;i<35;i++){\n\t\tfor(int j=0;j<35;j++)dp[i][j]=-1.0;\n\t}\n\tpriority_queue<data2> que;\n\tdata2 ind;\n\tind.cost=0.0;\n\tind.v=s;\n\tind.s=0;\n\tdp[s][0]=0.0;\n\tque.push(ind);\n\twhile(que.size()){\n\t\tdata2 dd=que.top();\n\t\tque.pop();\n\t\tif(dp[dd.v][dd.s]<dd.cost)continue;\n\t\tdp[dd.v][dd.s]=dd.cost;\n\t\tfor(int i=0;i<edge[dd.v].size();i++){\n\t\t\tdata e=edge[dd.v][i];\n\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\tint ns=dd.s+j;\n\t\t\t\tif(ns<=0 || ns>e.c)continue;\n\t\t\t\tdouble nc=dd.cost+(double)e.d/ns;\n\t\t\t\tif(dp[e.t][ns]>nc || dp[e.t][ns]==-1.0){\n\t\t\t\t\tdp[e.t][ns]=nc;\n\t\t\t\t\tdata2 nd;\n\t\t\t\t\tnd.v=e.t;\n\t\t\t\t\tnd.cost=nc;\n\t\t\t\t\tnd.s=ns;\n\t\t\t\t\tque.push(nd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[g][1];\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n+m==0)break;\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tscanf(\"%d %d\",&s,&g);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y;\n\t\t\tdata dd;\n\t\t\tscanf(\"%d %d %d %d\",&x,&y,&dd.d,&dd.c);\n\t\t\tdd.t=y;\n\t\t\tedge[x].push_back(dd);\n\t\t\tdd.t=x;\n\t\t\tedge[y].push_back(dd);\n\t\t}\n\t\tdouble res=dijk();\n\t\tif(res!=-1.0)printf(\"%.5f\\n\",res);\n\t\telse printf(\"unreachable\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n \nusing namespace std;\n \n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF 1e11\nconst int MAX_SPEED = 30;\n\nstruct P {\n    int city;\n    int speed;\n    float dist;\n\n    bool operator >(const P& p) const {\n        return dist > p.dist;\n    }\n};\n\nstruct edge{\n    int to, dist, limit;\n};\n\ntypedef vector<float> vf;\ntypedef vector<vf> vvf;\ntypedef vector<vvf> vvvf;\n\nint main() {\n    int city_n, road_n, start, goal;\n\n    while(cin >> city_n >> road_n, city_n | road_n){\n        cin >> start >> goal;\n\n        vector<vector<edge>> E(city_n + 1);\n\n        REP(i, road_n){\n            int x, y, d, l;\n            cin >> x >> y >> d >> l;\n            E[x].push_back({y, d, l});\n            E[y].push_back({x, d, l});\n        }\n        vvvf G(city_n + 1, vvf(city_n + 1, vf(MAX_SPEED + 1, INF)));\n        G[start][start][1] = 0;\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({start, 0, 0.0});\n\n        float res = -1;\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n\n            if(p.city == goal && p.speed == 1){\n                res = p.dist;\n                break;\n            }\n\n            for(auto e : E[p.city]) {\n                if(e.to == p.city) continue;\n                FOR(d, -1, 1 + 1){\n                    int next_speed = p.speed + d;\n                    if (next_speed == 0) continue;\n                    float next_dist = p.dist + (float)e.dist / next_speed;\n                    if (0 < next_speed && next_speed <= MAX_SPEED &&\n                        next_speed <= e.limit &&\n                        G[e.to][p.city][next_speed] > next_dist) {\n                        G[e.to][p.city][next_speed] = next_dist;\n                        que.push({e.to, next_speed, next_dist});\n                    }\n                }\n            }\n        }\n\n        if(res == -1)\n            cout << \"unreachable\" << endl;\n        else\n            printf(\"%f\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vd = std::vector<double>;\n\tusing v2d = std::vector<vd>;\n\tusing v3d = std::vector<v2d>;\n\t\n\tusing i3 = std::array<int, 3>;\n\tusing vi3 = std::vector<i3>;\n\tusing v2i3 = std::vector<vi3>;\n\n\tusing pdi3 = std::pair<double, i3>;\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n == 0 && m == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tint s, g;\n\t\tscanf(\"%d%d\", &s, &g);\n\t\ts--; g--;\n\n\t\t// from->{to, distance, limit}\n\t\tv2i3 edge(n);\n\t\tfor (int i{}; i < m; i++)\n\t\t{\n\t\t\tint x, y, d, c;\n\t\t\tscanf(\"%d%d%d%d\", &x, &y, &d, &c);\n\t\t\tx--; y--;\n\t\t\tedge[x].push_back({y, d, c});\n\t\t\tedge[y].push_back({x, d, c});\n\t\t}\n\n\t\t// 頂点、来た速度、来た頂点\n\t\tv3d distance(n, v2d(31, vd(n, 1e9)));\n\t\tfor (auto& e: distance[s][0]) e = 0;\n\t\t// 距離、頂点、来た速度、来た頂点\n\t\tstd::priority_queue<pdi3, std::vector<pdi3>, std::greater<pdi3>> dij;\n\t\tdij.push({0, {s, 0, 0}});\n\t\twhile (!dij.empty())\n\t\t{\n\t\t\tdouble now_dist{dij.top().first};\n\t\t\ti3 now_vertex{dij.top().second};\n\t\t\tdij.pop();\n\t\t\tif (now_dist > distance[now_vertex[0]][now_vertex[1]][now_vertex[2]])\n\t\t\t\tcontinue;\n\t\t\tif (now_vertex[0] == g && now_vertex[1] == 1) break;\n\t\t\tfor (auto& road: edge[now_vertex[0]])\n\t\t\t{\n\t\t\t\tif (road[0] == now_vertex[2]) continue;\n\t\t\t\tfor (int add{-1}; add <= 1; add++)\n\t\t\t\t{\n\t\t\t\t\ti3 next_vertex{road[0], now_vertex[1] + add, now_vertex[0]};\n\t\t\t\t\tif (next_vertex[1] <= 0 || road[2] < next_vertex[1]) continue;\n\t\t\t\t\tdouble next_dist{now_dist + (double)road[1] / next_vertex[1]};\n\t\t\t\t\tauto& table_dist{distance[next_vertex[0]][next_vertex[1]][next_vertex[2]]};\n\t\t\t\t\tif (next_dist >= table_dist) continue;\n\t\t\t\t\ttable_dist = next_dist;\n\t\t\t\t\tdij.push({next_dist, next_vertex});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble min{1e9};\n\t\tfor (int i{}; i < n; i++)\n\t\t\tmin = std::min(min, distance[g][1][i]);\n\t\tif (min == 1e9) puts(\"unreachable\");\n\t\telse printf(\"%lf\\n\", min);\n\t}\n\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef double Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  int c;                        // c ÍOtÅÍ§À¬xAqueue ÅÍ¬x\n  Edge(int src, int dst, Weight weight, int c) :\n    src(src), dst(dst), weight(weight), c(c){ }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src :\n    e.dst != f.dst ? e.dst < f.dst : e.c < f.c;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef pair<int,int> pii;\n\ndouble dist[30][30][32];           // dist[i][j][k] = Xs[h k ÌóÔÅ j ©ç i ÉÂ­ÅZ£\n\ndouble dijkstra(const Graph &g, int s, int t) {\n  int n = g.size();\n  REP(i,n) REP(j,n) REP(k,32) dist[i][j][k] = INF;\n  priority_queue<Edge> Q;\n  Q.push(Edge(s,s,0,0));\n  int cnt = 0;\n  while(!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (e.dst == t && e.c == 1) break;\n    REP(k,3) {\n      int v = e.c - 1 + k;\n      if (v<=0) continue;\n      if (dist[e.dst][e.src][v] < e.weight) continue;\n      FOR(f, g[e.dst]) {\n        if (v > f->c) continue;\n        if (f->dst == e.src) continue;\n        double hoge = e.weight + f->weight / v;\n        if (dist[f->dst][f->src][v] > hoge) {\n          dist[f->dst][f->src][v] = hoge;\n          Q.push(Edge(f->src, f->dst, hoge, v));\n        }\n      }\n    }\n    if (cnt++ > 200000) break;\n  }\n\n  double res = INF;\n  REP(i,n)\n    res = min(res, dist[t][i][1]);\n  return res;\n}\n\nint main() {\n  int n,m;\n  while(cin >> n>>m,n||m) {\n    int s,t;\n    cin >> s >> t;\n    s--;t--;\n    Graph g(n);\n    REP(i,m) {\n      int x,y,d,c;\n      cin >> x>>y>>d>>c;\n      x--;y--;\n      g[x].push_back(Edge(x,y,d,c));\n      g[y].push_back(Edge(y,x,d,c));\n    }\n    double res = dijkstra(g,s,t);\n    if (res == INF)\n      cout << \"unreachable\" << endl;\n    else\n      printf(\"%.5f\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int,P> P3;\ntypedef pair<double, P3> P4;\nconst ll MOD = ll(1e9+7);\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(3e5 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nstruct edge{\n    int to, c;\n    double d;\n};\n\nint n, m, s, g;\nvector<vector<edge> > G;\ndouble tmin[35][35][35];  // 頂点iに頂点jから速さkで到着するときの最短時間\n\nvoid dijkstra(){\n    REP(i,n)REP(j,n)fill(tmin[i][j],tmin[i][j]+35,double(IINF));\n    priority_queue<P4, vector<P4>, greater<P4> > que;\n    tmin[s][s][0] = 0.0;\n    que.push({0.0,{s,{s,0}}});\n    while(!que.empty()){\n        P4 p = que.top();\n        que.pop();\n        int from = p.second.second.first, v = p.second.second.second, pre = p.second.first;\n        if(p.first > tmin[from][pre][v] + EPS)continue;\n        for(auto &e : G[from]){\n            if(e.to == pre)continue;\n            for(int dv=-1; dv<=1; dv++){\n                int nv = v+dv;\n                if(nv<=0 || nv>e.c)continue;\n                if(tmin[e.to][from][nv] > tmin[from][pre][v] + e.d/double(nv) + EPS){\n                    tmin[e.to][from][nv] = tmin[from][pre][v] + e.d/double(nv);\n                    que.push(P4(tmin[e.to][from][nv],{from,{e.to,nv}}));\n                }\n            }\n        }\n    }\n}\n\n\nint main() {\n    while(cin >> n >> m, n){\n        cin >> s >> g;\n        s--; g--;\n        G.clear();\n        G.resize(n);\n        REP(i,m){\n            int x, y, c;\n            double d;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            G[x].push_back({y,c,d});\n            G[y].push_back({x,c,d});\n        }\n        dijkstra();\n        double ans = double(IINF);\n        REP(i,n) ans = min(ans, tmin[g][i][1]);\n        if(ans<IINF/2){\n            printf(\"%.8lf\\n\",ans);\n        }\n        else{\n            cout << \"unreachable\" << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstruct Node{\n\tdouble time;\n\tint cur,prev,v;\n};\nbool operator<(const Node &l,const Node &r){\n\t\treturn l.time>r.time;\n}\nstruct Edge{\n\tint next,d,lim;\n};\nint main(){\n\tint n,m,s,g;\n\tNEXT:while(cin>>n>>m,n){\n\t\tcin>>s>>g,s--,g--;\n\t\tvector<vector<Edge> > e(n);\n\t\trep(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c,x--,y--;\n\t\t\tEdge t; t.d=d,t.lim=c;\n\t\t\tt.next=y,e[x].push_back(t);\n\t\t\tt.next=x,e[y].push_back(t);\n\t\t}\n\t\tpriority_queue<Node> Q;\n\t\tdouble C[30][30][31]; rep(i,30)rep(j,30)rep(k,31)C[i][j][k]=1e99;\n\t\tNode init,cnode,nnode;\n\t\trep(i,e[s].size()){\n\t\t\tinit.time=e[s][i].d,init.cur=e[s][i].next,init.prev=s,init.v=1;\n\t\t\tQ.push(init); C[init.cur][s][1]=e[s][i].d;\n\t\t}\n\t\twhile(!Q.empty()){\n\t\t\tnnode=cnode=Q.top();Q.pop();\n\t\t\tif(cnode.cur==g&&cnode.v==1){\n\t\t\t\tcout<<cnode.time<<endl;goto NEXT;\n\t\t\t}\n\t\t\tint c=cnode.cur,cv=cnode.v;\n\t\t\tnnode.prev=c;\n\t\t\trep(i,e[c].size())if(e[c][i].next!=cnode.prev)\n\t\t\tfor(int nv=cv-1;nv<=cv+1;nv++)if(0<nv&&nv<=e[c][i].lim)\n\t\t\tif(C[e[c][i].next][c][nv]>cnode.time+1.*e[c][i].d/nv){\n\t\t\t\tnnode.time=cnode.time+1.*e[c][i].d/nv,\n\t\t\t\tnnode.v=nv,\n\t\t\t\tnnode.cur=e[c][i].next;\n\t\t\t\tC[e[c][i].next][c][nv]=nnode.time,Q.push(nnode);\n\t\t\t}\n\t\t}\n\t\tcout<<\"unreachable\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\n#define INF 1e15\n\nint n, m;\n\nstruct edge{\n    int to;\n    double cost;\n    int limit;\n    edge(int t, double c, int l): to(t), cost(c), limit(l){}\n};\n\nstruct state{\n    int node, speed, prev;\n    double dist;\n    state(int n, int s, int p, double d): node(n), speed(s), prev(p), dist(d) {}\n    bool operator > (const state s) const {\n        return dist > s.dist;\n    }\n};\n \nvoid dijkstra(int start, vector<vector<vector<double> > > &d, vector<vector<edge> > graph){\n    d[start][0][0] = 0.0;\n    bool visit[31][31][31] = {};\n    priority_queue<state, vector<state>, greater<state> > q;\n    q.push(state(start, 0, 0, 0.0));\n    while (!q.empty()){\n        state a = q.top();\n        q.pop();\n        int now = a.node, prev = a.prev, speed = a.speed;\n        if (visit[now][speed][prev]) continue;\n        visit[now][speed][prev] = 1;\n        // printf(\"%d %d %d\\n\", now, prev, speed);\n        if(d[now][speed][prev] < a.dist) continue;\n        REP(i,graph[now].size()){\n            edge e = graph[now][i];\n            int next = e.to, limit = e.limit;\n            if (next == prev) continue;\n            FOR(dif,-1,1){\n                int next_speed = speed + dif;\n                if (next_speed <= 0 || next_speed > limit) continue;\n                if (d[next][next_speed][now] > d[now][speed][prev] + e.cost/next_speed){\n                    d[next][next_speed][now] = d[now][speed][prev] + e.cost/next_speed;\n                    q.push(state(next, next_speed, now, d[next][next_speed][now]));\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    while (cin >> n >> m && n){\n        vector<vector<edge> > graph(n);\n        int s, g;\n        cin >> s >> g;\n        s--;\n        g--;\n        REP(i,m){\n            int x, y, c;\n            double d;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            graph[x].push_back(edge(y,d,c));\n            graph[y].push_back(edge(x,d,c));\n        }\n        vector<vector<vector<double> > > dist(n, vector<vector<double> > (31, vector<double> (n, INF)));\n        dijkstra(s, dist, graph);\n        double ans = INF;\n        REP(i,n) ans = min(ans, dist[g][1][i]);\n        if (ans == INF) cout << \"unreachable\" << endl;\n        else printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nstruct edge{\n\tint to,cost,sp;\n};\nstruct ver{\n\tint now,pre;\n\tdouble tim;\n\tint sp;\n};\nnamespace std {\n\tbool operator < (const ver& a, const ver& b) {\n\t\treturn a.tim>b.tim;\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n}\nclass DIJ{\n\tpublic:\n\tvector<vector<edge> >G;\n\tint n,L;\n\tvvd d;//distance\n\tDIJ(int size,int l=31){\n\t\tn=size;\n\t\tL=l;\n\t\tG=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(int a,int b,int c,int s){\n\t\tedge e={b,c,s},ee={a,c,s};\n\t\tG[a].pb(e);\n\t\tG[b].pb(ee);\n\t}\n\tvoid dij(int s,int t){\n\t\td=vvd(n,vd(L+1,inf));\n\t\td[s][1]=0;//now oktime ->time\n\t\tpriority_queue<ver>q;\n\t\tq.push(ver{s,-1,0,1});//time now oktime\n\t\tbool h=true;\n\t\twhile(!q.empty()){\n\t\t\tver p=q.top();\n\t\t\tq.pop();\n\t\t\tif(p.tim>d[p.now][p.sp])continue;\n\t\t\trep(i,G[p.now].size()){\n\t\t\t\tedge e=G[p.now][i];\n\t\t\t\tint to=e.to;\n\t\t\t\tif(p.pre==to)continue;\n\t\t\t\tloop(k,-1,2)if(p.sp+k>0){\n\t\t\t\t\tif(h&&k)continue;\n\t\t\t\t\tint sp=p.sp+k;\n\t\t\t\t\tif(sp>e.sp)continue;\n\t\t\t\t\tdouble nowtim=p.tim+(double)e.cost/sp;\n\t\t\t\t\tif(nowtim<d[to][sp]){\n//\t\t\t\t\t\tcout<<to<<\" \"<<p.now<<\" \"<<nowtim<<\" \"<<sp<<endl;\n\t\t\t\t\t\td[to][sp]=nowtim;\n\t\t\t\t\t\tq.push(ver{to,p.now,nowtim,sp});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\th=false;\n\t\t}\n\t\tif(d[t][1]>inf-1000)cout<<\"unreachable\"<<endl;\n\t\telse cout<<shosu(9)<<d[t][1]<<endl;\n\t}\n};\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tDIJ dij(n);\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\twhile(m--){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tdij.add_edge(x-1,y-1,d,c);\n\t\t}\n\t\tdij.dij(s-1,t-1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n#define N 30\n#define INF 100000\n\nstruct road{int to,cost,lim;};\nstruct situ{int v,now,from;double d;};\nbool operator < (const situ &a,const situ &b){\n\treturn a.d > b.d;\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,s,g;\n\t\tvector<road> roads[N];\n\t\tcin >> n >> m;\n\t\tif(!n&&!m) break;\n\t\tcin >> s >> g;\n\t\ts--;g--;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,c;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c);\n\t\t\tx--;y--;\n\t\t\troads[x].push_back((road){y,d,c});\n\t\t\troads[y].push_back((road){x,d,c});\n\t\t}\n\n\t\tpriority_queue<situ> que;\n\t\tfor(int i=0;i<roads[s].size();i++){\n\t\t\tint to = roads[s][i].to;\n\t\t\tint d = roads[s][i].cost;\n\t\t\tque.push((situ){1,to,s,(double)d});\n\t\t}\n\t\tbool used[N][N][31];\n\t\tmemset(used,0,sizeof(used));\n\n\t\tbool isClear = false;\n\t\twhile(que.size()){\n\t\t\tsitu st = que.top(); que.pop();\n\t\t\tif(used[st.now][st.from][st.v]) continue;\n\t\t\tused[st.now][st.from][st.v] = true;\n\t\t\tif(st.now==g&&st.v==1){\n\t\t\t\tprintf(\"%.5f\\n\",st.d);\n\t\t\t\tisClear = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<roads[st.now].size();i++){\n\t\t\t\tint to = roads[st.now][i].to;\n\t\t\t\tint d = roads[st.now][i].cost;\n\t\t\t\tif(to == st.from) continue;\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tif(st.v+j<=roads[st.now][i].lim&&st.v+j>0){\n\t\t\t\t\t\t//if(!used[to][st.now][st.v+j])\n\t\t\t\t\t\t\tque.push((situ){st.v+j,to,st.now,st.d+(double)d/(st.v+j)});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!isClear) cout << \"unreachable\" << endl;\n\n\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <assert.h>\n#include <queue>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\ntypedef pair<int,int> P;\ntypedef pair<int,P> Q;\ntypedef pair<double,Q> R;\n\ndouble dist[32][32][32];\nint n,m;\nint s,g;\nint x[1095],y[1095],d[1095],c[1095];\nvector<Q>vec[32];\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m;if(n==0) return 0;\n\t\tcin>>s>>g;\n\t\tfor(int i=1;i<=n;i++) vec[i].clear();\n\t\trep(i,m){\n\t\t\tcin>>x[i]>>y[i]>>d[i]>>c[i];\n\t\t\tvec[x[i]].push_back(mp(y[i],mp(d[i],c[i])));\n\t\t\tvec[y[i]].push_back(mp(x[i],mp(d[i],c[i])));\n\t\t}\n\t\trep(i,32)rep(j,32)rep(k,32) dist[i][j][k] = 1e9;\n\t\t\n\t\tpriority_queue<R,vector<R>,greater<R> >que;\n\t\tfor(int i=0;i<vec[s].size();i++){\n\t\t\tdouble D = (double)(vec[s][i].sc.fi);\n\t\t\tdist[s][vec[s][i].fi][1] = D;\n\t\t\tque.push(mp(D,mp(s,mp(vec[s][i].fi,1))));\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tR r = que.top(); que.pop();\n\t\t\tint pre = r.sc.fi;\n\t\t\tint cur = r.sc.sc.fi;\n\t\t\tint v = r.sc.sc.sc;\n\t\t\tif(r.fi > dist[pre][cur][v]+1e-12) continue;\n\t\t\tfor(int x=max(1,v-1);x<=v+1;x++){\n\t\t\t\tfor(int i=0;i<vec[cur].size();i++){\n\t\t\t\t\tif(vec[cur][i].fi == pre) continue;\n\t\t\t\t\tif(vec[cur][i].sc.sc < x) continue;\n\t\t\t\t\tdouble need = (double)(vec[cur][i].sc.fi)/(double)(x);\n\t\t\t\t\tif(dist[cur][vec[cur][i].fi][x] > dist[pre][cur][v]+need+1e-12){\n\t\t\t\t\t\tdist[cur][vec[cur][i].fi][x] = dist[pre][cur][v]+need;\n\t\t\t\t\t\tque.push(mp(dist[cur][vec[cur][i].fi][x],mp(cur,mp(vec[cur][i].fi,x))));\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tfor(int i=1;i<=n;i++) for(int j=0;j<32;j++) ans = min(ans,dist[i][g][1]);\n\t\tif(ans > 5e8) puts(\"unreachable\");\n\t\telse {printf(\"%.12f\",ans);puts(\"\");}\n\n\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define DBG(X) cout<<\" \"<<#X<<\" : \"<<X<<endl\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\n\nstruct Input\n{\n\tint n;char c;char str[1024];string s;ll l;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\nstruct Edge{\n\tint to, dist, limit;\n\tEdge(){};\n\tEdge(int t, int d, int l) : to(t), dist(d), limit(l){};\n};\n\nvector<Edge> e[50];\ndouble d[50][50];\n\nint main(){\n\twhile(1){\n\t\trep(i, 50) e[i].clear();\n\t\trep(i, 50) rep(j, 50) d[i][j] = 1e18;\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tif(n == 0 && m == 0) break;\n\t\tint s = in.nextInt(), g = in.nextInt();\n\t\trep(i, m) {\n\t\t\tint x = in.nextInt(), y = in.nextInt(), dist = in.nextInt(), c = in.nextInt();\n\t\t\te[x].pb({y, dist, c});\n\t\t\te[y].pb({x, dist, c});\n\t\t}\n\t\tauto dijkstra = [&]{\n\t\t\ttypedef pair<double, pii> P;\n\t\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\t\tP p;\n\t\t\td[s][0] = 0.0;\n\t\t\tq.push({0.0, {s, 0}});\n\n\t\t\twhile(!q.empty()){\n\t\t\t\tp = q.top(); q.pop();\n\t\t\t\tint from = p.se.fi, v = p.se.se;\n\t\t\t\tdouble t = p.fi;\n\t\t\t\tfor(auto ee : e[from]){\n\t\t\t\t\tint to = ee.to, dist = ee.dist, l = ee.limit;\n\t\t\t\t\tfor(int i = -1; i <= 1; i++){\n\t\t\t\t\t\tint nv = v + i;\n\t\t\t\t\t\tif(nv <= 0 || nv > l) continue;\n\t\t\t\t\t\tdouble tt = t + (double)dist / nv;\n\t\t\t\t\t\tif(d[to][nv] <= tt) continue;\n\t\t\t\t\t\td[to][nv] = tt;\n\t\t\t\t\t\tq.push({tt, {to, nv}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdijkstra();\n\t\t\n\t\tif(d[g][1] == 1e18) printf(\"unreachable\\n\");\n\t\telse printf(\"%.15lf\\n\", d[g][1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n    return false;\n}\nstruct Edge {\n    int to,d,c;\n    Edge(int to=0,int d=0,int c=0) :\n        to(to),d(d),c(c) {}\n};\n\nstruct State {\n    int v,u;\n    int spd;\n    double t;\n    State(int v=0,int u=0,int spd=0,double t=0) :\n        v(v),u(u),spd(spd),t(t){}\n\n    bool operator<(const State &rhs) const {\n        return t>rhs.t;\n    }\n};\nint s,g;\nint n,m;\nvector<Edge> G[40];\n\ndouble dijk() {\n    // v,u,spd;\n    double d[40][40][40];\n    rep(i,40) rep(j,40) rep(k,40) d[i][j][k]=INF;\n    //rep(i,40) d[s][i][1]=1;\n    d[s][s][0]=0;\n\n    priority_queue<State> que;\n    que.push(State(s,s,0));\n    while(que.size()) {\n        State s=que.top(); que.pop();\n\n        rep(i,G[s.v].size()) {\n            Edge e=G[s.v][i];\n            if(e.to==s.u) continue;\n            for(int k=-1;k<=1;k++) {\n                if(!(0<=s.spd+k&&s.spd+k<=e.c)) continue;\n                if(s.spd+k<=0) continue;\n                if(chmin(d[e.to][s.v][s.spd+k],d[s.v][s.u][s.spd]+1.0*e.d/(s.spd+k))) {\n                    que.push(State(e.to,s.v,s.spd+k,d[e.to][s.v][s.spd+k]));\n                }\n            }\n        }\n    }\n    double ret=INF;\n    rep(i,40) chmin(ret,d[g][i][1]);\n\n    return ret;\n\n}\n\nvoid solve() {\n    rep(i,40) G[i].clear();\n    cin>>s>>g;\n    s--,g--;\n    rep(i,m) {\n        int x,y,d,c;\n        cin>>x>>y>>d>>c;\n        x--,y--;\n        G[x].push_back(Edge(y,d,c));\n        G[y].push_back(Edge(x,d,c));\n    }\n    double ans=dijk();\n    if(ans==INF) cout<<\"unreachable\"<<endl;\n    else printf(\"%.10f\\n\",ans);\n}\n\nint main() {\n    while(cin>>n>>m) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e8\n#define EPS 1e-9\n\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) rep2(i,0,n)\n#define ll long long\n#define P pair<double,int>\n#define pb push_back\n\nint n,m,s,g,D[30][30],C[30][30];\ndouble d[30][30][31];\n\nint main(){\n\twhile(cin>>n>>m&&n){\n\t\tcin>>s>>g;\n\t\ts--;g--;\n\t\trep(i,n){\n\t\t\tfill(D[i],D[i]+n,INF);\n\t\t\tfill(C[i],C[i]+n,0);\n\t\t\trep(j,n)fill(d[i][j],d[i][j]+31,INF);\n\t\t}\n\t\trep(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tx--;y--;\n\t\t\tD[x][y]=D[y][x]=d;\n\t\t\tC[x][y]=C[y][x]=c;\n\t\t}\n\t\tdouble ans=INF;\n\t\tpriority_queue<P,vector<P>,greater<P> > Q;\n\t\td[s][s][0]=0.0;\n\t\tQ.push(P(0.0,s*930+s*31+0));\n\t\twhile(Q.size()){\n\t\t\tP p=Q.top();Q.pop();\n\t\t\tdouble t=p.first;\n\t\t\tint cur=p.second/930,prev=(p.second/31)%30,v=p.second%31;\n\t\t\tif(t>d[cur][prev][v])continue;\n\t\t\tif(cur==g&&v==1){ans=d[cur][prev][v];break;}\n\t\t\trep(i,n){\n\t\t\t\tif(i!=prev&&D[cur][i]!=INF){\n\t\t\t\t\trep2(j,-1,2){\n\t\t\t\t\t\tint nv=v+j;\n\t\t\t\t\t\tif(0<nv&&nv<=C[cur][i]){\n\t\t\t\t\t\t\tdouble nt=t+D[cur][i]*1.0/nv;\n\t\t\t\t\t\t\tif(nt<d[i][cur][nv]){\n\t\t\t\t\t\t\t\td[i][cur][nv]=nt;\n\t\t\t\t\t\t\t\tQ.push(P(nt,i*930+cur*31+nv));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans!=INF)cout<<setprecision(10)<<ans<<endl;\n\t\telse cout<<\"unreachable\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\n\nclass Dijkstra {\n    using T = double;\npublic:\n    struct edge {\n        int to;\n        T cost;\n    };\n    typedef pair<T, int> P;//firstは最短距離、secondは頂点の番号\n\n    int V;//超点数\n    vector<vector<edge> > G;//グラフ,G[i]はiから出る辺の集合,G[i][j]はiから出る辺のj番目の辺\n    vector<T> d; //最短距離\n\n    //0origin\n    Dijkstra(int N) {\n        V = N;\n        G = vector<vector<edge> >(N);\n        d = vector<T>(N);\n    };\n\n    void dijkstra(int s) {\n        priority_queue<P, vector<P>, greater<P> > que;\n        fill(d.begin(), d.end(), INFl);\n        d[s] = 0;\n        que.push(P(0, s));\n\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if (d[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge e = G[v][i];\n                if (d[e.to] > d[v] + e.cost && !(d[e.to] == INFl && d[v] == INFl)) {\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n\n    }\n\n    /* 頂点fromに頂点toに達するコストcostの辺を貼る */\n    void addEdge(int from, int to, T cost) {\n        edge e;\n        e.to = to;\n        e.cost = cost;\n        G[from].push_back(e);\n    }\n};\n\nvoid solve(int n, int m) {\n    int s, g;\n    cin >> s >> g;\n    s--;\n    g--;\n\n    auto conv = [&](int f, int t, int v) {\n        //(頂点、速度)\n        return v * n * n + f * n + t;\n    };\n\n    Dijkstra dij(200 * n * n + n * n + n);\n\n    rep(i, 0, m) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        x--;\n        y--;\n        auto check = [&](int v) {\n            return v > 0 && v <= c;\n        };\n        rep(v, 0, 31) {\n            for (int V = v - 1; V <= v + 1; V++) {\n//                if(check(V)){\n//                    double tmp = 1.0 * d / V;\n//                    dij.addEdge(conv(x,v),conv(y,V),tmp);\n//                    dij.addEdge(conv(y,v),conv(x,V),tmp);\n//                }\n                for (int f = 0; f < n; f++) {\n                    if (check(V)) {\n                        double tmp = 1.0 * d / V;\n                        if (f != y) {\n                            dij.addEdge(conv(f, x, v), conv(x, y, V), tmp);\n                        }\n                        if (f != x) {\n                            dij.addEdge(conv(f, y, v), conv(y, x, V), tmp);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    dij.dijkstra(conv(s, s, 0));\n//    cout << dij.d[conv(g,1)] << endl;\n    double ans = INFl;\n    rep(i, 0, n) {\n        ans = min(ans, dij.d[conv(i, g, 1)]);\n    }\n    if (ans > 1e7) {\n        cout << \"unreachable\" << endl;\n    } else {\n//        cout << ans << endl;\n        printf(\"%.5lf\", ans);\n        cout << endl;\n    }\n\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<double, int, int, int> T;\n \nconst ll MOD=1e9+7;\n//const ll INF=1e18;\n\nconst double INF = 1000000.0;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\nstruct edge{ int to,d,c;};\n\n\n\nint n,m,s,g;\ndouble d[35][35][35];\n\nint main(){\n\twhile(true){\n\t\tcin >> n >> m;\n\t\tif(n + m == 0) break;\n\t\tcin >> s >> g;\n\t\tvector<edge> G[35];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a1,a2,a3,a4;\n\t\t\tcin >> a1 >> a2 >> a3 >> a4;\n\t\t\tedge tmp1 = {a2,a3,a4};\n\t\t\tG[a1].push_back(tmp1);\n\t\t\tedge tmp2 = {a1,a3,a4};\n\t\t\tG[a2].push_back(tmp2);\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tfor(int k = 0;k <= 31;k++){\n\t\t\t\t\td[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<T> que;\n\t\tfor(int i = 0;i < G[s].size();i++){\n\t\t\tedge e = G[s][i];\n\t\t\td[s][e.to][1] = (double) e.d;\n\t\t\tque.push(make_tuple((double)e.d,1,s,e.to));\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tT t = que.front(); que.pop();\n\t\t\tdouble a1 = get<0>(t);\n\t\t\tint a2 = get<1>(t),a3 = get<2>(t),a4 = get<3>(t);\n\t\t\tif(d[a3][a4][a2] < a1)continue;\n\t\t\tfor(int i = 0;i < G[a4].size();i++){\n\t\t\t\tedge e = G[a4][i];\n\t\t\t\tif(e.to == a3) continue;\n\t\t\t\tfor(int j = -1;j <= 1;j++){\n\t\t\t\t\tint v = a2 + j;\n\t\t\t\t\tdouble tmp = (double)( a1 + (double)e.d / (double)v);\n\t\t\t//\t\tif(a4 == 5 && e.to == 6 && v == 1) cout << \"tmp\" << tmp << \",a1\" << a1 <<endl;\n\t\t\t\t\tif(v <= 0 || v > e.c || d[a4][e.to][v] < tmp ) continue;\n\t\t\t\t\td[a4][e.to][v] =  tmp;\n\t\t\t\t\tque.push(make_tuple(tmp,v,a4,e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\n\t\t}\n\t//\tcout << \"ans\" << d[4][5][2] << endl;\n\n\n\n\t\tdouble ans = INF;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tdouble tmp = d[i][g][1];\n\t\t\tif(ans > tmp) ans = tmp;\n\t\t//\tans = min(ans,d[i][g][1]);\n\t\t}\n\t\tif(ans == INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t//\tcout << ans << endl;\n\t\t\tprintf(\"%lf\",ans);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntemplate<typename T> using VT = vector<T>;\ntemplate<typename T> using VVT = vector<VT<T> >;\ntemplate<typename T> using VVVT = vector<VVT<T> >;\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst double eps = 1e-8, inf = 1e+8;\n\ntemplate<typename T> inline void chmin(T& t, T f){if(t > f)t = f;}\n\nstruct Edge {\n    int to; double wt; int cap;\n    Edge(int to, double wt, int cap):to(to), wt(wt), cap(cap){}\n};\n\nint n, m, s, g;\n\ndouble solve(vector<vector<Edge> >& G){\n    double res = inf;\n    VVVT<double> mem(n, VVT<double>(n, VT<double>(35, inf))); mem[s][s][0] = 0.;\n    typedef tuple<double, int, int, int> State;\n    priority_queue<State> q;\n    for(q.emplace(0., 0, s, s); !q.empty();){\n        double t; int v, u, p;\n        tie(t, v, u, p) = q.top(); q.pop();\n        if(mem[u][p][v] + t < -eps || res + t <= -eps)continue;\n        if(u == g && v == 1)chmin(res, -t);\n        for(auto e: G[u])if(e.to != p){\n            for(int dv=-1; dv<=1; ++dv){\n                int nv = v + dv <= 0? 1: v + dv;\n                double nt = e.wt / nv - t;\n                if(30 < nv || e.cap < nv || mem[e.to][u][nv] <= nt + eps)continue;\n                mem[e.to][u][nv] = nt;\n                q.emplace(-mem[e.to][u][nv], nv, e.to, u);\n            }\n        }\n    }\n    if(inf - res < eps)throw \"unreachable\";\n    return res;\n}\n\nint main(){\n    while(cin >> n >> m, n|m){\n        cin >> s >> g;\n        s--; g--;\n        vector<vector<Edge> > G(n);\n        rep(i, m){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            G[x].emplace_back(y, d, c);\n            G[y].emplace_back(x, d, c);\n        }\n        try{\n            cout << fixed << setprecision(5) << solve(G) << '\\n';\n        }\n        catch(const char* mes){\n            cout << mes << '\\n';\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<queue>\n#include<vector>\n#include<cstdio>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\n\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[40];    \n    \n    int inx,iny,ind,inc;\n    double d[40][40][40];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\nfor(;;)\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst double INF = 1 << 29;\n\nstruct edge {\n    int to;\n    int cost;\n    int limit;\n\n    edge() {}\n    edge(int a, int b, int c): to(a), cost(b), limit(c) {}\n};\n\nstruct state {\n    int pos;\n    double cost;\n    int speed;\n    int prev;\n\n    state() {}\n    state(int a, double b, int c, int d): pos(a), cost(b), speed(c), prev(d) {}\n\n    bool operator < (const state& o) const {\n        return cost > o.cost;\n    }\n};\n\nint N, M, S, G;\n\nvector<edge> graph[30];\n\ndouble memo[30][31];\n\n\nbool solve() {\n    cin >> N >> M;\n    if (N+M == 0) { return false; }\n\n    for (int j = 0; j < N; ++j) { graph[j].clear(); }\n    for (int j = 0; j < N; ++j) { fill(memo[j], memo[j]+31, INF); }\n\n\n    cin >> S >> G;\n    --S; --G;\n    for (int j = 0; j < M; ++j) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        --x; --y;\n\n        graph[x].emplace_back(y, d, c);\n        graph[y].emplace_back(x, d, c);\n    }\n\n    priority_queue<state> pq;\n    pq.emplace(S, 0, 1, 0);\n    memo[S][1] = 0;\n    while (!pq.empty()) {\n        state st = pq.top(); pq.pop();\n        if (st.cost > memo[st.pos][st.speed]) { continue; }\n\n        for (edge& e: graph[st.pos]) {\n            if (st.prev == e.to) { continue; }\n            for (int dv = -1; dv <= 1; ++dv) {\n                if (st.pos == S && dv != 0) { continue; }\n\n                int next_speed = st.speed + dv;\n                if (next_speed <= 0 || e.limit < next_speed) { continue; }\n\n                double next_cost = st.cost + (double)e.cost / next_speed;\n                if (next_cost < memo[e.to][next_speed]) {\n                    memo[e.to][next_speed] = next_cost;\n                    pq.emplace(e.to, next_cost, next_speed, st.pos);\n                }\n            }\n\n        }\n    }\n    if (fabs(memo[G][1]-INF) < 1e-7) { printf(\"unreachable\\n\"); }\n    else { printf(\"%.12f\\n\", memo[G][1]); }\n    return true;\n}\n\nint main() { for (; solve(); ); return 0; }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<double,int> P;\nstruct edge{int to;double cost;};\n\nint n,m,s,go;\ndouble d[27002];\nvector<edge> g[27002];\n\nvoid dijkstra(int s){\n\tmultimap<double,int> q;\n\tfill(d,d+27002,INF);\n\td[s]=0;\n\tq.insert(P(0,s));\n\twhile(!q.empty()){\n\t\tP p=*(q.begin());\n\t\tq.erase(q.begin());\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tif(v==1)break;\n\t\trep(i,g[v].size()){\n\t\t\tedge e=g[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.insert(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>m&&n){\n\t\trep(i,27002)g[i].clear();\n\t\tcin>>s>>go;s--;go--;\n\t\tedge e;\n\t\trep(i,n){\n\t\t\te.to=1;\n\t\t\te.cost=0;\n\t\t\tg[i*n+go+2].push_back(e);\n\t\t}\n\t\trep(i,m){\n\t\t\tint x,y,c;\n\t\t\tdouble dd;\n\t\t\tcin>>x>>y>>dd>>c;\n\t\t\tx--;y--;\n\t\t\trep(v,c+2)rep(p,n){\n\t\t\t\tif(v==31)break;\n\t\t\t\tif(v==0){\n\t\t\t\t\tif(x==s){\n\t\t\t\t\t\te.to=x*n+y+2;\n\t\t\t\t\t\te.cost=dd;\n\t\t\t\t\t\tg[0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\tif(y==s){\n\t\t\t\t\t\te.to=y*n+x+2;\n\t\t\t\t\t\te.cost=dd;\n\t\t\t\t\t\tg[0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int j=-1;j<2;j++){\n\t\t\t\t\t\tif(v+j>0&&v+j<=c&&p!=x&&p!=y){\n\t\t\t\t\t\t\te.to=(v+j-1)*n*n+x*n+y+2;\n\t\t\t\t\t\t\te.cost=dd/(v+j);\n\t\t\t\t\t\t\tg[(v-1)*n*n+p*n+x+2].push_back(e);\n\t\t\t\t\t\t\te.to=(v+j-1)*n*n+y*n+x+2;\n\t\t\t\t\t\t\tg[(v-1)*n*n+p*n+y+2].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(0);\n\t\tif(d[1]<INF)cout<<d[1]<<endl;\n\t\telse cout<<\"unreachable\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <queue>\nusing namespace std;\n\ndouble memo[32][32]; //[vol][vertex] = time\nint N,M,S,G;\nstruct e {\n\tint d,c;\n}edge[32][32];\n\nvoid solve(int vertex,int vol,int befor,double cost,int cnt)\n{\n\tif(cost > memo[1][G])return;\n\t//printf(\"%d,%d,%d,%lf,%d\\n\",vertex,vol,befor,cost,cnt);\n\t\n\tint v;\n\tfor(int i=1;i<=N;i++){\n\t\tif(vertex==i || i==befor || edge[vertex][i].d == 0)continue;\n\t\tif(vol>0 && vol<=edge[vertex][i].c){\n\t\t\tif(memo[vol][i] > (double)edge[vertex][i].d/(double)vol + cost){\n\t\t\t\tmemo[vol][i] = (double)edge[vertex][i].d/(double)vol + cost;\n\t\t\t\tsolve(i,vol,vertex,memo[vol][i],cnt+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(vol+1>0 && vol+1<=edge[vertex][i].c){\n\t\t\tif(memo[vol+1][i] > (double)edge[vertex][i].d/(double)(vol+1) + cost){\n\t\t\t\tmemo[vol+1][i] = (double)edge[vertex][i].d/(double)(vol+1) + cost;\n\t\t\t\tsolve(i,vol+1,vertex,memo[vol+1][i],cnt+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(vol-1>0 && vol-1<=edge[vertex][i].c){\n\t\t\tif(memo[vol-1][i] > (double)edge[vertex][i].d/(double)(vol-1) + cost){\n\t\t\t\tmemo[vol-1][i] = (double)edge[vertex][i].d/(double)(vol-1) + cost;\n\t\t\t\tsolve(i,vol-1,vertex,memo[vol-1][i],cnt+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint x,y,d,c;\n\tfor(;cin>>N>>M,N||M;){\n\t\tcin>>S>>G;\n\t\tfor(int i=0;i<32;i++)for(int j=0;j<32;j++)\n\t\t\tmemo[i][j]=999999.0;\n\t\tmemset(edge,0,sizeof(edge));\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tedge[x][y].d = edge[y][x].d = d;\n\t\t\tedge[x][y].c = edge[y][x].c = c;\n\t\t}\n\t\tmemo[1][S] = 0.0;\n\t\t//solve(S, 0, 0, 0.0, 0);\n\t\tqueue<pair<int,int> > qq;\n\t\tqueue<int> befor;\n\t\tqueue<double> cc;\n\t\tqq.push(make_pair(0,S));\n\t\tbefor.push(S);\n\t\tcc.push(0.0);\n\t\tfor(;!qq.empty();qq.pop()){\n\t\t\tint vol = qq.front().first;\n\t\t\tint vertex = qq.front().second;\n\t\t\tint b = befor.front();\n\t\t\tdouble cost = cc.front();\n\t\t\tbefor.pop();\n\t\t\tcc.pop();\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\tif(i==vertex || i==b || edge[vertex][i].d == 0)continue;\n\t\t\t\tif(vol>0 && vol<=edge[vertex][i].c){\n\t\t\t\t\tif(memo[vol][i] > (double)edge[vertex][i].d/vol + cost){\n\t\t\t\t\t\tmemo[vol][i] = (double)edge[vertex][i].d/vol + cost;\n\t\t\t\t\t\tqq.push(make_pair(vol,i));\n\t\t\t\t\t\tbefor.push(vertex);\n\t\t\t\t\t\tcc.push(memo[vol][i]);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(vol+1>0 && vol+1<=edge[vertex][i].c){\n\t\t\t\t\tif(memo[vol+1][i] > (double)edge[vertex][i].d/(vol+1) + cost){\n\t\t\t\t\t\tmemo[vol+1][i] = (double)edge[vertex][i].d/(vol+1) + cost;\n\t\t\t\t\t\tqq.push(make_pair(vol+1,i));\n\t\t\t\t\t\tbefor.push(vertex);\n\t\t\t\t\t\tcc.push(memo[vol+1][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(vol-1>0 && vol-1<=edge[vertex][i].c){\n\t\t\t\t\tif(memo[vol-1][i] > (double)edge[vertex][i].d/(vol-1) + cost){\n\t\t\t\t\t\tmemo[vol-1][i] = (double)edge[vertex][i].d/(vol-1) + cost;\n\t\t\t\t\t\tqq.push(make_pair(vol-1,i));\n\t\t\t\t\t\tbefor.push(vertex);\n\t\t\t\t\t\tcc.push(memo[vol-1][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif(memo[1][G]==999999.0)\n\t\t\tputs(\"unreachable\");\n\t\telse printf(\"%lf\\n\",memo[1][G]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<functional>\n\nint n, m, s, g;\nstruct load{\n\tint x;\n\tint y;\n\tdouble d;\n\tint c;\n};\nstruct P{\n\tdouble cost;\n\tint from;\n\tint now;\n\tint sp;\n\tbool operator > (const P& p) const{\n\t\treturn cost > p.cost;\n\t}\n};\n//vector<vector<vector<double>>> vvvi;\n\ndouble cost[31][31][31];//from now sp\n\n\nint main(){\n\n\n\twhile (cin >> n >> m, n | m){\n\t\tvector<load> L;\n\t\tcin >> s >> g;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tL.push_back({ x, y, d, c });\n\t\t\tL.push_back({ y, x, d, c });\n\t\t}\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\tq.push({ 0.0, s, s, 0 });\n\t\tcost[s][s][0] = 0.0;\n\n\t\tfor (int i = 0; i < 31; i++)\n\t\t\tfor (int j = 0; j < 31; j++)\n\t\t\t\tfor (int k = 0; k < 31; k++)\n\t\t\t\t\tcost[i][j][k] = 100000.0;\n\n\t\twhile (!q.empty()){\n\t\t\tif (q.top().now == g &&q.top().sp == 1)break;\n\t\t\tP q2 = q.top();\n\t\t\tq.pop();\n\t\t\tfor (int i = 0; i < (signed int)L.size(); i++){\n\t\t\t\tfor (int j = -1; j < 2; j++){\n\t\t\t\t\tif (q2.now == L[i].x&&q2.from != L[i].y&& L[i].c >= q2.sp + j)\n\t\t\t\t\t\tif (q2.sp + j>0)\n\t\t\t\t\t\t\tif (q2.cost + L[i].d / (double)(q2.sp + (j)) < cost[q2.now][L[i].y][q2.sp + (j)]){\n\t\t\t\t\t\t\t\tq.push({ q2.cost + L[i].d / (double)(q2.sp + (j)), q2.now, L[i].y, q2.sp + (j) });\n\t\t\t\t\t\t\t\tcost[q2.now][L[i].y][q2.sp + (j)] = q2.cost + L[i].d / (double)(q2.sp + (j));\n\t\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!q.empty())printf(\"%.5lf\\n\", q.top().cost);\n\t\telse cout << \"unreachable\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 30;\nconst int INF = 1 << 29;\nconst double EPS = 1e-8;\n\nstruct edge{\n  int to, lim;\n  double dis;\n  edge(int t=0, double d=0, int l=0):to(t),lim(l),dis(d){}\n};\n\nstruct state{\n  int n, speed, ps;\n  double t;\n  state(int n=0, int s=0, int ps=0, double t=0):n(n),speed(s),ps(ps),t(t){}\n  bool operator < (const state &s) const {\n    return t > s.t;\n  }\n};\n\n\nint n,m,st,go;\nvector<edge> g[N];\n\ndouble solve(){\n  priority_queue<state> pq;\n  state u, u2;\n  double d[N][31][31];\n\n  for(int i=0;i<n;i++) for(int j=0;j<31;j++) for(int k=0;k<31;k++) d[i][j][k] = INF;\n  d[st][1][1] = 0;\n\n  for(pq.push(state(st, 1, 1, 0)); !pq.empty();){\n    u = pq.top();\n    pq.pop();\n\n    if(u.n == go && u.ps == 1) return u.t;\n    \n    for(int i=0;i<g[u.n].size();i++){\n      edge next = g[u.n][i];\n      for(int j=-1;j<=1;j++){\n        u2 = state(next.to, u.speed + j, u.speed, u.t + next.dis / (double)u.speed);\n        if(u2.speed <= 0 || u2.speed > 30 || u.speed > next.lim || d[u2.n][u2.speed][u2.ps] <= u2.t + EPS) continue;\n        d[u2.n][u2.speed][u2.ps] = u2.t;\n        pq.push(u2);\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main(){\n  while(cin >> n >> m && (n|m)){\n    cin >> st >> go;\n    st--; go--;\n    for(int i=0;i<n;i++) g[i].clear();\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin >> x >> y >> d >> c;\n      x--; y--;\n      g[x].push_back(edge(y, d, c));\n      g[y].push_back(edge(x, d, c));\n    }\n    double res = solve();\n    if(res < -0.5) cout << \"unreachable\" << endl;\n    else printf(\"%.5f\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n\tint cost,limit;\n\tedge(int c,int l){\n\t\tcost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tvector<vector<edge> > E(n+1,vector<edge>(n+1,edge(-1,-1)));\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in][out]=edge(c,l);\n\t\tE[out][in]=edge(c,l);\n\t}\n\tvector<vector<double> > Ans(n+1,vector<double>(31,INF));\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){\n\t\tNode t=Q.top(); Q.pop();\n\t\tif(Ans[t.now][t.speed]<t.time) continue;\t\t\n//\t\tcout<<t.now<<\" \"<<t.speed<<\" \"<<t.time<<endl;\n\t\tif(t.now==g && t.speed==1){printf(\"%.12lf\\n\", t.time );  return;}\n\t\tAns[t.now][t.speed]=t.time;\n\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tif(i==t.before) continue;\n\t\t\tif(E[t.now][i].cost>0){\n\t\t\t\tif(E[t.now][i].limit>=t.speed && t.speed>=1)\n\t\t\t\t\tQ.push(Node(i,t.speed,t.time+E[t.now][i].cost/(double)t.speed,t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed+1)\n\t\t\t\t\tQ.push(Node(i,t.speed+1,t.time+E[t.now][i].cost/(double)(t.speed+1.0),t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed-1 && t.speed-1>=1)\n\t\t\t\t\tQ.push(Node(i,t.speed-1,t.time+E[t.now][i].cost/(double)(t.speed-1.0),t.now));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\"<<endl;\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__\",\", __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nvoid solve(int n, int m){\n  int s,t;\n  cin>>s>>t;\n  s--;t--;\n  vector<vector<pair<int,double>>> vec(n*n*31 + 2);\n  // (f*n+v)*31 + V : ??´??????f??§v??????????????????V\n\n  rep(i,m){\n    int a,b,c; double d;\n    cin>>a>>b>>d>>c;\n    a--;b--;\n    rep(j,n)if(j!=b){\n      rep(k,31){\n        int from = (j*n+a)*31+k;\n        if(k-1>0 && k-1<=c) vec[from].pb(mp((a*n+b)*31+k-1, d/(k-1)));\n        if(k>0 && k<=c) vec[from].pb(mp((a*n+b)*31+k, d/k));\n        if(k+1>0 && k+1<=c) vec[from].pb(mp((a*n+b)*31+k+1, d/(k+1)));\n      }\n    }\n  }\n\n  int from = n*n*31, dest = from+1;\n\n  rep(i,n) vec[from].pb(mp((i*n+s)*31+0, 0));\n  rep(i,n) vec[(i*n+t)*31+1].pb(mp(dest, 0));\n\n  // dijkstra\n  vector<double> d(n*n*31+2, INF);\n  d[from] = 0;\n  typedef pair<double,int> P;\n  priority_queue<P, vector<P>, greater<P>> pq;\n  pq.push(mp(0,from));\n  while(!pq.empty()){\n    auto p = pq.top(); pq.pop();\n    int v = p.second; double dis = p.first;\n    if(d[v] < dis) continue;\n    for(auto &to : vec[v]){\n      double nd = dis + to.second;\n      if(d[to.first] <= nd) continue;\n      d[to.first] = nd;\n      pq.push(mp(nd, to.first));\n    }\n  }\n  if(d[dest] == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.6f\\n\", d[dest]);\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m) solve(n,m);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000.0\nusing namespace std;\n// struct state { int n, v, l; double t; };\n\n// int N, M, S, G;\n// vector<int> T[31], D[31], C[31];\n// int vd[3] = { -1, 0, 1 };\n// double dp[31][51];\n//\n// class Compare {\n// public:\n//   bool operator() (struct state a, struct state b) {\n//     return a.t > b.t;\n//   }\n// };\n\nint main(void) {\n  // while(cin >> N >> M, N) {\n  //   cin >> S >> G;\n  //   REP(i, 0, 30) {\n  //     T[i].clear();\n  //     D[i].clear();\n  //     C[i].clear();\n  //   }\n  //   REP(i, 1, M) {\n  //     int x, y, d, c; cin >> x >> y >> d >> c;\n  //     T[x].push_back(y); D[x].push_back(d); C[x].push_back(c);\n  //     T[y].push_back(x); D[y].push_back(d); C[y].push_back(c);\n  //   }\n  //\n  //   REP(i, 1, N) REP(j, 0, 50) dp[i][j] = INF;\n  //\n  //   priority_queue<struct state, vector<struct state>, Compare> q;\n  //   struct state first = { S, 0, -1, 0.0 };\n  //   q.push(first);\n  //\n  //   while(!q.empty()) {\n  //     struct state c = q.top();\n  //     q.pop();\n  //\n  //     // cout << c.n << \" \" << c.v << \" \" << c.t << endl;\n  //\n  //     if(dp[c.n][c.v] <= c.t) continue;\n  //     dp[c.n][c.v] = min(dp[c.n][c.v], c.t);\n  //     if(c.n == G && c.v == 1) break;\n  //\n  //     for(int i = 0; i < T[c.n].size(); i++) {\n  //       if(T[c.n][i] == c.l) continue;\n  //       REP(j, 0, 3) {\n  //         int v = c.v + vd[j];\n  //         if(v <= 0 || C[c.n][i] < v) continue;\n  //         double t = c.t + ((double) D[c.n][i] / v);\n  //         struct state n = { T[c.n][i], v, c.n, t };\n  //         if(n.t < dp[n.n][n.v]) q.push(n);\n  //       }\n  //     }\n  //   }\n  //\n  //   if(dp[G][1] < INF) printf(\"%.6f\\n\", dp[G][1]);\n  //   else cout << \"unreachable\" << endl;\n  // }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double dINF = 1e11; \n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef pair<double,PP> PPP;\n\nint main ()\n{\n    int n, m;\n    while (cin >> n >> m, n + m) {\n        int s, g;\n        cin >> s >> g;\n        vector<vector<PP> > e(n + 1);\n\n        for (int i = 0; i < m; i++) {\n            int sx, sy, d, c;\n            cin >> sx >> sy >> d >> c;\n            e[sx].push_back(PP(sy, P(d, c) ));\n            e[sy].push_back(PP(sx, P(d, c) ));\n        }\n\n        priority_queue<PPP, vector<PPP>, greater<PPP> > pq;\n        vector<vector<double> > dp(31, vector<double>(n + 1, dINF));\n\n        dp[0][s] = 0.;\n        double res = dINF;\n        \n        for (int j = 0; j < e[s].size(); j++) {\n            int dir = e[s][j].first;\n            int dis = e[s][j].second.first;\n            int limit = e[s][j].second.second;\n            \n            dp[1][dir] = (double)dis;\n            pq.push(PPP((double)dis, PP(1, P(dir, s)) ));\n        }\n\n        while (pq.size()) {\n            PPP ppp = pq.top(); pq.pop();\n            double cost = ppp.first;\n            int v = ppp.second.first;\n            int now = ppp.second.second.first;\n            int pre = ppp.second.second.second;\n\n            if (dp[v][now] < cost) continue;\n            // if (now == g && v == 1 && dp) break;\n\n            // cout << now << \" \" << pre  << \" \" << v << endl;\n            \n            for (int i = 0; i < e[now].size(); i++) {\n                //if (e[now][i].first == pre) continue;\n                \n                for (int j = -1; j <= 1; j++) {\n                    if (v + j < 0 || v + j > e[now][i].second.second) continue;\n                    double cost_ = cost + (double)e[now][i].second.first / (double)(v + j);\n                    int to_ = e[now][i].first;\n                    if (dp[v + j][to_] > cost_) {\n                        dp[v + j][to_] = cost_;\n                        pq.push(PPP(cost_, PP(v + j, P(to_, now))) );\n                        if (to_ == g && v + j == 1) res = min(res, cost_);\n                        // cout << \"DBG > cost : \" << cost_ << \" v : \" << v + j << \" to : \" << to_ << endl;\n                    }\n                }\n            }\n        }\n\n        if (dp[1][g] == dINF) cout << \"unreachable\" << endl;\n        else printf(\"%.5f\\n\", dp[1][g]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\nconst double EPS = 1e-8;\n\nclass State{\npublic:\n  int pos, v, pre;\n  double time;\n  State(){}\n  State(int pos, int v, int pre, double time) : pos(pos), v(v), pre(pre), time(time) {}\n  bool operator < (const State& s) const { return time > s.time; }\n};\n\nint n, m, s, g;\nP edge[30][30];\ndouble vis[30][30][31];\n\nbool equals(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nvoid solve(){\n  State u, v;\n  u = State(s, 0, 0, 0.0);\n  priority_queue<State> que;\n  fill(vis[0][0], vis[30][0], (double)INF);\n  vis[0][0][1] = 0.0;\n  for(int i=0;i<n;i++){\n    if(edge[s][i].first != INF){\n      vis[s][i][1] = edge[s][i].first;\n      que.push(State(i, 1, s, (double)edge[s][i].first));\n    }\n  }\n  while(!que.empty()){\n    u = que.top(); que.pop();\n    //cout << u.pos << ' ' << u.v << ' ' << u.pre << ' ' << u.time << endl;\n    if(vis[u.pre][u.pos][u.v] < u.time) continue;\n    vis[u.pre][u.pos][u.v] = u.time;\n    if(u.pos == g && u.v == 1){\n      printf(\"%.5f\\n\", u.time);\n      return;\n    }\n    for(int i=0;i<n;i++){\n      if(edge[u.pos][i].first == INF) continue;\n      if(u.pre == i) continue;\n      for(int k=-1;k<=1;k++){\n        if(u.v + k > edge[u.pos][i].second) continue;\n        if(u.v + k <= 0) continue;\n        v = State(i, u.v + k, u.pos, u.time + edge[u.pos][i].first / (double)(u.v + k));\n        //cout << '\\t' << v.pos << ' ' << v.v << ' ' << v.pre << ' ' << v.time << ' ' << vis[v.pre][v.pos][v.v] << endl;\n        if(vis[v.pre][v.pos][v.v] > v.time){\n          vis[v.pre][v.pos][v.v] = v.time;\n          que.push(v);\n        }\n      }\n    }\n  }\n  printf(\"unreachable\\n\");\n}\n\nmain(){\n  while(scanf(\"%d%d\", &n, &m) && (n|m)){\n    scanf(\"%d%d\", &s, &g);\n    s--; g--;\n    fill(edge[0], edge[30], P(INF, 0));\n    for(int i=0;i<m;i++){\n      int a, b, c, d;\n      scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n      a--; b--;\n      edge[a][b] = edge[b][a] = P(c, d);\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cout << x << \" \";} cout << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\n// typedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\n// const int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef tuple<double, int, int, int> TUPLE;\nconst double inf = 1e12;\n\nstruct edge {\n    int to, d, c;\n    edge(){}\n    edge(int _to, int _d, int _c) : to(_to), d(_d), c(_c) {}\n};\ntypedef vector<vector<edge>> Graph;\ndouble dijkstra(const Graph& G, int s, int g) {\n    int n = G.size();\n    priority_queue<TUPLE, vector<TUPLE>, greater<TUPLE>> pq;   // cost, i, j, pre\n    vector<vector<double>> d(n, vector<double>(31, inf));\n    d[s][0] = 0;\n    pq.push(make_tuple(0, s, 0, -1));\n\n    while (!pq.empty()) {\n        double cost;\n        int i, j, pre;\n        tie(cost, i, j, pre) = pq.top(); pq.pop();\n        // cout << cost << \" \" << i << \" \" << j << endl;\n        if (i == g && j == 1) return cost;\n        if (d[i][j] < cost) continue;\n        for (const auto& e : G[i]) {\n            for (int k = -1; k <= 1; k++) {\n                if (e.to == pre) continue;\n                if (e.to == g && j + k != 1) continue;\n                if (1 <= j + k && j + k <= e.c && d[e.to][j + k] > d[i][j] + 1. * e.d / (j + k)) {\n                    d[e.to][j + k] = d[i][j] + 1. * e.d / (j + k);\n                    pq.push(make_tuple(d[e.to][j + k], e.to, j + k, i));\n                }\n            }\n        }\n        // cerr << \"hey!\" << endl;\n    }\n\n    return inf;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    int t = 0;\n    while (cin >> n >> m, n) {\n        // cout << \"--- t = \" << t++ << \" ---\" << endl;\n\n        int s, g;\n        cin >> s >> g;\n        s--, g--;\n        Graph G(n);\n        rep(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--, y--;\n            G[x].emplace_back(y, d, c);\n            G[y].emplace_back(x, d, c);\n        }\n\n        double ans = dijkstra(G, s, g);\n        if (ans < inf) {\n            cout << setprecision(10) << ans << endl;\n        } else {\n            cout << \"unreachable\" << endl;\n        }\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define MAX 30\n#define INF 10000000.0\nstruct S{\n\tint e,s,b;\n};\n\nstruct S2{\n\tint d,c,to;\n};\n\nint main(){\n\n\tint n,m;\n\tint s,g;\n\tint x,y,d,c;\n\tint min;\n\tint size;\n\tdouble cost[MAX+1][MAX+1][MAX+1];\n\tS point,tmp;\n\tint pe,ps,pb,psj;\n\tS2 nod;\n\tvector<S2> ed[MAX+1];\n\tint edd,edc,edt;\n\tqueue<S> no;\n\n\twhile(1){\n\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0) break;\n\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(!ed[i].empty()) ed[i].clear();\n\t\t}\n\n\t\tfor(int i=0;i<=30;i++){\n\t\t\tfor(int j=0;j<=30;j++){\n\t\t\t\tfor(int k=0;k<=30;k++){\n\t\t\t\t\tcost[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin>>s>>g;\n\t\tpoint.e=s,point.s=0,point.b=0;\n\t\tcost[0][s][0]=0;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tnod.c=c,nod.d=d,nod.to=y;;\n\t\t\ted[x].push_back(nod);\n\t\t\tnod.to=x;\n\t\t\ted[y].push_back(nod);\n\t\t}\n\n\t\tno.push(point);\n\t\twhile(!no.empty()){\n\t\t\tpoint=no.front();\n\t\t\tno.pop();\n\t\t\tps=point.s,pb=point.b,pe=point.e;\n\t\t\tsize=ed[pe].size();\n\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\tedd=ed[pe][i].d,edc=ed[pe][i].c,edt=ed[pe][i].to;\n\t\t\t\tif(pb!=edt){\n\t\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\tpsj=ps+j;\n\t\t\t\t\t\tif(psj>0&&psj<=edc){\n\t\t\t\t\t\t\tif(cost[psj][edt][pe]>cost[ps][pe][pb]+(double)edd/psj){\n\t\t\t\t\t\t\t\tcost[psj][edt][pe]=cost[ps][pe][pb]+(double)edd/psj;\n\t\t\t\t\t\t\t\ttmp.e=edt;\n\t\t\t\t\t\t\t\ttmp.s=psj;\n\t\t\t\t\t\t\t\ttmp.b=pe;\n\t\t\t\t\t\t\t\tno.push(tmp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmin=0;\n\t\tfor(int i=1;i<=30;i++){\n\t\t\tif(cost[1][g][i]<cost[1][g][min]) min=i;\n\t\t}\n\t\tif(min==0) printf(\"unreachable\\n\");\n\t\telse printf(\"%.5f\\n\",cost[1][g][min]);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\ntypedef vector<double> vd;\n\nstruct state {\n\tint p, s;\n\tdouble c;\n\tstate(int p, int s, double c) : p(p), s(s), c(c) {};\n\tbool operator<(const state &o) const {\n\t\treturn c<o.c;\n\t}\n};\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\tint s, g;\n\t\tcin >> s >> g;\n\n\t\tvector<vd> road(n, vd(n, INF));\n\t\tvector<vd> limit(n, vd(n, INF));\n\t\tint x, y, d, c;\n\t\tREP(i, m) {\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\troad[x-1][y-1] = road[y-1][x-1] = d;\n\t\t\tlimit[x-1][y-1] = limit[y-1][x-1] = c;\n\t\t}\n\n\t\tvector<vd> cost(n, vd(30+1, INF));\n\t\tcost[s-1][1] = 0;\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(s-1, 1, 0));\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tif(st.p == g-1 && st.s == 0) {\n\t\t\t\tcost[g-1][0] = min(cost[g-1][0], st.c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(st.s <= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP(i, n) {\n\t\t\t\tif(st.p != i && road[st.p][i] != INF && st.s <= limit[st.p][i]) {\n\t\t\t\t\tdouble nc = st.c + road[st.p][i]/(double)st.s;\n\t\t\t\t\tFOR(j, -1, 1) {\n\t\t\t\t\t\tint ns = st.s + j;\n\t\t\t\t\t\tif(ns <= 30 && nc < cost[i][ns]) {\n\t\t\t\t\t\t\tcost[i][ns] = nc;\n\t\t\t\t\t\t\tQ.push(state(i, ns, nc));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(cost[g-1][0] == INF) {\n\t\t\tcout <<  \"unreachable\" << endl;\n\t\t} else {\n\t\t\tprintf(\"%.6f\\n\", cost[g-1][0]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define INF 1000000000.0\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<double, int> Pd;\ntypedef pair<Pd, P> PPd;\n\nint main()\n{\n\twhile(1){\n\t\tint n, m;\n\t\tcin>>n>>m;\n\t\tif(n==0 && m==0) return 0;\n\t\tint s, g;\n\t\tcin>>s>>g;\n\t\tvector<P> v[31];\n\t\tdouble d[450];\n\t\tint c[450];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y;\n\t\t\tcin>>x>>y>>d[i]>>c[i];\n\t\t\tv[x].push_back(P(y, i));\n\t\t\tv[y].push_back(P(x, i));\n\t\t}\n\t\tdouble t[31][31][31];\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tfor(int j=0; j<=n; j++){\n\t\t\t\tfor(int k=0; k<=30; k++){\n\t\t\t\t\tt[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tt[s][0][0]=0;\n\t\tpriority_queue<PPd, vector<PPd>, greater<PPd> > que;\n\t\tque.push(PPd(Pd(0, s), P(0, 0)));\n\t\twhile(!que.empty()){\n\t\t\tPPd p=que.top();\n          \t        que.pop();\n\t\t\tint x=p.first.second;\n\t\t\tint prev=p.second.first;\n\t\t\tint cp=p.second.second;\n\t\t\tif(t[x][prev][cp]<p.first.first) continue;\n\t\t\tfor(auto p1:v[x]){\n\t\t\t\tint y=p1.first, e=p1.second;\n\t\t\t\tif(y==prev) continue;\n\t\t\t\tif(cp-1>=1 && cp-1<=c[e]){\n\t\t\t\t\tif(t[y][x][cp-1]>t[x][prev][cp]+d[e]/((double)(cp-1))){\n\t\t\t\t\t\tt[y][x][cp-1]=t[x][prev][cp]+d[e]/((double)(cp-1));\n\t\t\t\t\t\tque.push(PPd(Pd(t[y][x][cp-1], y), P(x, cp-1)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cp>=1 && cp<=c[e]){\n\t\t\t\t\tif(t[y][x][cp]>t[x][prev][cp]+d[e]/((double)(cp))){\n\t\t\t\t\t\tt[y][x][cp]=t[x][prev][cp]+d[e]/((double)(cp));\n\t\t\t\t\t\tque.push(PPd(Pd(t[y][x][cp], y), P(x, cp)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cp+1>=1 && cp+1<=c[e]){\n\t\t\t\t\tif(t[y][x][cp+1]>t[x][prev][cp]+d[e]/((double)(cp+1))){\n\t\t\t\t\t\tt[y][x][cp+1]=t[x][prev][cp]+d[e]/((double)(cp+1));\n\t\t\t\t\t\tque.push(PPd(Pd(t[y][x][cp+1], y), P(x, cp+1)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans=INF;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tif(t[g][i][1]<ans) ans=t[g][i][1];\n\t\t}\n\t\tif(ans>=INF-0.1){\n\t\t\tcout<<\"unreachable\"<<endl;\n\t\t}else{\n\t\t\tprintf(\"%.5lf\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst double INF = 1 << 29;\n\nstruct edge {\n    int to;\n    int cost;\n    int limit;\n\n    edge() {}\n    edge(int a, int b, int c): to(a), cost(b), limit(c) {}\n};\n\nstruct state {\n    int pos;\n    double cost;\n    int speed;\n    int prev;\n\n    state() {}\n    state(int a, double b, int c, int d): pos(a), cost(b), speed(c), prev(d) {}\n\n    bool operator < (const state& o) const {\n        return cost > o.cost;\n    }\n};\n\nint N, M, S, G;\n\nvector<edge> graph[30];\n\ndouble memo[30][31][30];\n\n\nbool solve() {\n    cin >> N >> M;\n    if (N+M == 0) { return false; }\n\n    for (int j = 0; j < N; ++j) { graph[j].clear(); }\n    for (int j = 0; j < N; ++j) {\n        for (int k = 0; k <= 30; ++k) {\n            fill(memo[j][k], memo[j][k]+30, INF);\n        }\n    }\n\n\n    cin >> S >> G;\n    --S; --G;\n    for (int j = 0; j < M; ++j) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        --x; --y;\n\n        graph[x].emplace_back(y, d, c);\n        graph[y].emplace_back(x, d, c);\n    }\n\n    priority_queue<state> pq;\n    pq.emplace(S, 0, 0, S);\n    memo[S][0][S] = 0;\n    while (!pq.empty()) {\n        state st = pq.top(); pq.pop();\n        if (st.cost > memo[st.pos][st.speed][st.prev]) { continue; }\n\n        for (edge& e: graph[st.pos]) {\n            if (st.prev == e.to) { continue; }\n            for (int dv = -1; dv <= 1; ++dv) {\n                int next_speed = st.speed + dv;\n                if (next_speed <= 0 || e.limit < next_speed) { continue; }\n\n                double next_cost = st.cost + (double)e.cost / next_speed;\n                if (next_cost < memo[e.to][next_speed][st.pos]) {\n                    memo[e.to][next_speed][st.pos] = next_cost;\n                    pq.emplace(e.to, next_cost, next_speed, st.pos);\n                }\n            }\n\n        }\n    }\n    double ans = INF;\n    for (int j = 0; j < N; ++j) {\n        ans = min(ans, memo[G][1][j]);\n    }\n    if (fabs(ans-INF) < 1e-7) { printf(\"unreachable\\n\"); }\n    else { printf(\"%.12f\\n\", ans); }\n    return true;\n}\n\nint main() { for (; solve(); ); return 0; }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <iomanip>\nusing namespace std;\n\nint N,M,S,G;\n\nstruct state{\n    int node,velocity;\n    double ti;\n    int pre_node;\n    bool operator<(const state& right)const{\n        return ti>right.ti;\n    }\n};\n\nstruct edge{\n    int to,dist,upp;\n};\n\ndouble dp[31][31][31];\ndouble inf = 1e9;\n\nint main(){\n    while(cin >> N >> M && N>0){\n        cin >> S >> G;\n        vector<vector<edge>> v(N+1);\n        int x,y,d,c;\n        for(int i=0;i<M;i++){\n            cin >> x >> y >> d >> c;\n            v[x].push_back({y,d,c});\n            v[y].push_back({x,d,c});\n        }\n        for(int i=1;i<=N;i++) for(int j=1;j<=30;j++) for(int k=1;k<=N;k++) dp[i][j][k] = inf;\n        dp[S][1][0] = 0;\n        priority_queue<state> Q;\n        Q.push({S,0,0,0});\n        while(!Q.empty()){\n            state now = Q.top(); Q.pop();\n            if(dp[now.node][now.velocity][now.pre_node]<now.ti) continue;\n            for(auto& x:v[now.node]){\n                if(now.pre_node==x.to) continue;\n                for(int dv=-1;dv<=1;dv++){\n                    if(now.velocity+dv<=0 || now.velocity+dv>x.upp) continue;\n                    state ne;\n                    ne.node = x.to; ne.velocity = now.velocity+dv;\n                    ne.ti = now.ti+1.0*x.dist/ne.velocity;\n                    ne.pre_node = now.node;\n                    if(dp[ne.node][ne.velocity][ne.pre_node]>ne.ti){\n                        dp[ne.node][ne.velocity][ne.pre_node] = ne.ti;\n                        Q.push(ne);\n                    }\n                }\n            }\n        }\n        double ans = inf;\n        for(int i=1;i<=N;i++) ans = min(ans,dp[G][1][i]);\n        if(ans>=inf) cout << \"unreachable\" << endl;\n        else{\n            cout << fixed;\n            cout << setprecision(10) << ans << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<double, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint n,m;\nstruct edge { int to;double cost; };\nint V;\nvector<edge> G[100000];\ndouble d[100000];\nvoid init(int v) {\n\trep(i, v) {\n\t\tG[i].clear();\n\t}\n}\nvoid dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\tfill(d, d + V, 10000);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first)continue;\n\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (cin >> n>>m, n) {\n\t\tV = 100000;\n\t\tint s, g; cin >> s >> g; s--; g--;\n\t\tinit(100000);\n\t\tP dis[30][30];\n\t\trep(i, 30) {\n\t\t\trep(j, 30) {\n\t\t\t\tdis[i][j] = { 0,0 };\n\t\t\t}\n\t\t}\n\t\trep(i, m) {\n\t\t\tint x, y, D, c; cin >> x >> y >> D >> c; x--; y--;\n\t\t\tdis[x][y] = dis[y][x] = { D,c };\n\t\t}\n\t\trep(f, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, 31) {\n\t\t\t\t\tRep1(k, -1, 1) {\n\t\t\t\t\t\tint x = j + k;\n\t\t\t\t\t\tif (x <= 0 || x > 30)continue;\n\t\t\t\t\t\trep(l, n) {\n\t\t\t\t\t\t\tif (f!=l&&i != l && dis[i][l].first != 0 && dis[i][l].second >= x) {\n\t\t\t\t\t\t\t\tG[i + j * n+f*n*31].push_back({ l + n * x+i*n*31,(double)dis[i][l].first / double(x) });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(s + s * n*31);\n\t\tdouble mi = 10000;\n\t\trep(i, n) {\n\t\t\tmi = min(mi, d[g + n+ n * 31*i]);\n\t\t}\n\t\tif (mi == 10000) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\tcout << fixed << setprecision(5) << mi << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 31\n#define INF (1e9)\nusing namespace std;\ntypedef pair<double,int> P;\ntypedef  pair<P,int> PP;\nstruct dat{\n  double cost;\n  int pos,pre,v;\n  bool operator > (dat x)const{return cost>x.cost;}\n};\nint n,m;\nvector<PP> G[N];\n\ndouble dijkstra(int s,int g){\n  double D[N][N][N];\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++)D[i][j][k]=INF;\n  priority_queue<dat,vector<dat>,greater<dat> >Q;\n  Q.push((dat){0,s,-1,0});\n  D[s][s][1]=0;\n  while(!Q.empty()){\n    dat t=Q.top();Q.pop();\n    double cost=t.cost;\n    int v=t.v;\n    int pos=t.pos,pre=t.pre;\n    if(D[pos][pre][v]<cost)continue;\n    if(pos==g&&v==1) return cost;\n\n    for(int i=max(1,v-1);i<=v+1;i++){\n      for(int j=0;j<G[pos].size();j++){\n\tdouble ncost=cost+G[pos][j].first.first/i;\n\tint mxv=G[pos][j].first.second;\n\tint nx=G[pos][j].second;\n\tif(nx==pre||mxv<i||D[nx][pos][i]<=ncost)continue;\n\tQ.push((dat){ncost,nx,pos,i});\n\tD[nx][pos][i]=ncost;\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    int s,g;\n    cin>>s>>g;s--,g--;\n    for(int i=0;i<n;i++)G[i].clear();\n    for(int i=0,a,b,d,c;i<m;i++){\n      cin>>a>>b>>d>>c;a--,b--;\n      G[a].push_back(PP(P(d,c),b));\n      G[b].push_back(PP(P(d,c),a));\n    }\n    double ans=dijkstra(s,g);\n    if(ans==-1) cout<<\"unreachable\"<<endl;\n    else printf(\"%.12f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n\n#define pb(s) push_back(s)\n\n#define MAX_N 30\n#define MAX_M 1000\n#define MAX_V 30\n\nusing namespace std;\n\nstruct edge{\n\tint to, len, limit;\n\tedge(int a, int b, int c):to(a),len(b),limit(c){}\n};\nvector<edge> G[MAX_M+1];//n?????????????????\\?¶??????????????????????\n\nstruct state{\n\tint from, now, v;\n\tdouble times;\n\tstate(int a, int b, int c, double d):from(a),now(b),v(c),times(d){}\n};\n\ndouble times[MAX_N+1][MAX_N+1][MAX_V+1];\n\nint N, M, S, g;\nint inf = 1<<29;\n\nbool operator<(const state& a, const state& b){ return a.times > b.times; }\n\ndouble solve() {\n\tfor (int i = 0; i <= MAX_N; i++)for(int j = 0; j <= MAX_N; j++)for(int k = 0; k <= MAX_V; k++){\n\t\ttimes[i][j][k] = (double)inf;\n\t}\n\tpriority_queue<state> que;\n\tque.push(state(0,S,0,0.0));\n\n\twhile(!que.empty()){\n\t\tstate ns = que.top(); que.pop();\n\t\tif(ns.now == g && ns.v == 1) return ns.times;\n\t\tif(times[ns.from][ns.now][ns.v] != inf) continue;\n\t\ttimes[ns.from][ns.now][ns.v] = ns.times;\n\t\tfor (int i = 0; i < G[ns.now].size(); i++)\n\t\t{\n\t\t\tedge e = G[ns.now][i];\n\t\t\tif(ns.from != e.to){\n\t\t\t\tfor (int dv = -1; dv <= 1 ; dv++)\n\t\t\t\t{\n\t\t\t\t\tif(ns.v+dv > e.limit) break;\n\t\t\t\t\tif(ns.v+dv < 1) continue;\n\t\t\t\t\tque.push(state(ns.now, e.to, ns.v+dv, times[ns.from][ns.now][ns.v]+(double)e.len/(ns.v+dv)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> N >> M;\n\t\tif(N == 0)break;\n\t\tcin >> S >> g;\n\t\tfor (int i = 0; i < MAX_M+1; i++)\n\t\t{\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tedge e = edge(y, d, c);\n\t\t\tG[x].pb(e);\n\t\t\te = edge(x, d, c);\n\t\t\tG[y].pb(e);\n\t\t}\n\t\tdouble res = solve();\n\t\tif(res == -1) cout << \"unreachable\" << endl;\n\t\telse printf(\"%f\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1000\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(short i=1;i<=n;i++)for(short j=1;j<=n;j++)for(short k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(short i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    \n    while(que.size()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(short i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <functional>\n#include <cstring>\n#include <utility>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nstruct edge {\n  double dist;\n  int limit;\n};\n\nstruct state {\n  double cost;\n  int pre, cur, v;\n  state(double d, int a, int b, int c):cost(d),pre(a),cur(b),v(c){}\n  bool operator<(const state& a) const {\n    return cost > a.cost;\n  }\n};\n\nconst int INF = 100000000, MAX_N = 31, MAX_V = 31;\nint n, m;\nedge e[1000];\nint graph[MAX_N][MAX_N];\nbool used[MAX_N][MAX_N][MAX_V];\n\nvoid solve() {\n  memset(graph, -1, sizeof graph);\n  memset(used, false, sizeof used);\n  \n  int s, g; cin>>s>>g;\n  rep(i,m) {\n    int x, y;\n    cin>>x>>y>>e[i].dist>>e[i].limit;\n    graph[x][y] = i;\n    graph[y][x] = i;\n  }\n  \n  double d[MAX_N][MAX_N][MAX_V];\n  rep(i,MAX_N) rep(j,MAX_N) rep(k,MAX_V) d[i][j][k] = INF;\n  priority_queue<state> que;\n  REP(i,1,n+1) if (graph[s][i] != -1) {\n    int en = graph[s][i];\n    if (e[en].limit < 1) continue;\n    d[s][i][1] = e[en].dist;\n    que.push(state(d[s][i][1],s,i,1));\n  }\n  \n  while (!que.empty()) {\n    state si = que.top(); que.pop();\n    double cost = si.cost;\n    int pre = si.pre, cur = si.cur, v = si.v;\n    \n    if (used[pre][cur][v]) continue;\n    used[pre][cur][v] = true;\n    \n    if (cur == g && v == 1) {\n      printf(\"%.4lf\\n\", cost); return;\n    }\n        \n    REP(i,1,n+1) if (graph[cur][i] != -1) {\n      int en = graph[cur][i];\n      REP(j,-1,2) {\n        if (v+j < 1 || v+j > e[en].limit) continue;\n        double ne = cost + e[en].dist / (v+j);\n        if (d[cur][i][v+j] > ne) {\n          d[cur][i][v+j] = ne;\n          que.push(state(ne, cur, i, v+j));\n        }\n      }\n    }\n  }\n  cout<<\"unreachable\"<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>n>>m, n||m) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\n#define ALL(V) V.begin(),V.end()\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\nusing PLL = pair<ll, ll>;\nusing TLL = tuple<ll, ll, ll>; // to, cost, upper\n\ndouble eps = 0.0001;\n\nbool solve() {\n    ll N, M;\n    cin >> N >> M;\n    if(!(N + M)) return false;\n    ll S, G;\n    cin >> S >> G;\n    S--; G--;\n    VV<pair<ll, double>> edges(33 * 33 * 33 * 2 + 2);\n    \n    auto make_idx = [&](ll idx, ll vel, ll pre_city) { return 31 * 31 * idx + 31 * vel + pre_city; };\n\n    auto add_edge = [&](ll from, ll to, ll dist, ll c) {\n        for(ll from_c = 1; from_c <= c; from_c++) {\n            for(ll add_c = -1; add_c <= 1; add_c++) {\n                ll to_c = from_c + add_c;\n                if(!(0 <= to_c && to_c <= 30)) continue;\n                for(ll from_city = 0; from_city < N; from_city++) {\n                    if(from_city == to) continue;\n                    ll from_idx = make_idx(from, from_c, from_city);\n                    ll to_idx = make_idx(to, to_c, from);\n                    edges[from_idx].emplace_back(to_idx, (double)dist / from_c);\n                }\n            }\n        }\n    };\n\n    for(ll i = 0; i < M; i++) {\n        ll x, y, d, c;\n        cin >> x >> y >> d >> c;\n        x--; y--;\n        add_edge(x, y, d, c);\n        add_edge(y, x, d, c);\n    }\n\n    ll start_node = edges.size() - 2;\n    ll goal_node = start_node + 1;\n    for(ll i = 0; i < N; i++) {\n        edges[start_node].emplace_back(make_idx(S, 1, i), 0);\n        edges[make_idx(G, 0, i)].emplace_back(goal_node, 0);\n    }\n\n    const double inf = 5e15;\n\n    V<double> dists(edges.size(), inf);\n    priority_queue<pair<double, ll>, V<pair<double, ll>>, greater<pair<double, ll>>> pq;\n    pq.emplace(0, start_node);\n    dists[start_node] = 0;\n    while(pq.size()) {\n        double dist;\n        ll now;\n        tie(dist, now) = pq.top();\n        pq.pop();\n        if(dists[now] + eps < dist) continue;\n        for(auto &&edge : edges[now]) {\n            ll nxt;\n            double cost;\n            tie(nxt, cost) = edge;\n            double nxt_dist = dist + cost;\n            if(dists[nxt] < nxt_dist + eps) continue;\n            dists[nxt] = nxt_dist;\n            pq.emplace(nxt_dist, nxt);\n        }\n    }\n\n    double ans = dists[goal_node];\n    if(abs(ans - inf) < eps) cout << \"unreachable\";\n    else cout << ans;\n    cout << endl;\n    return true;\n}\n\nint main() {\n    cout << fixed << setprecision(30);\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nstruct Edge{\n    int from, to;\n    double dist, limit;\n    Edge(int x, int y, double d, double c){\n        from = x;\n        to = y;\n        dist = d;\n        limit = c;\n    }\n};\n\nbool operator<(const Edge &e1, const Edge &e2) {\n    return e1.limit >= e2.limit;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nconst int MAX = 50;\nconst int INF = 1e9;\ndouble dist[MAX][MAX][MAX]; // 一つ前の頂点、今の頂点、今の速度\nGraph graph(MAX);\n\nvoid dijkstra(int s) {\n    priority_queue<Edge> que;\n    for(int i = 0; i < MAX; i++){\n        for(int j = 0; j < MAX; j++){\n            for(int k = 0; k < MAX; k++){\n                dist[i][j][k] = INF;\n            }\n        }\n    }\n    for(int i = 0; i < MAX; i++) dist[i][s][1] = 0.0;\n    for(int i = 0; i < graph[s].size(); i++){\n        Edge e = graph[s][i];\n        que.push(Edge(s, e.to, 1, e.dist));\n        dist[s][e.to][1] = (double)e.dist;\n    }\n    while (!que.empty()) {\n        int prev = que.top().from;\n        int cur = que.top().to;\n        double vel = que.top().dist;\n        double sum = que.top().limit;\n        que.pop();\n        if(dist[prev][cur][(int)vel] < sum) continue;\n        for(int i = 0; i < graph[cur].size(); i++){\n            Edge e = graph[cur][i];\n            if(e.to == prev) continue;\n            for(int add = -1; add <= 1; add++){\n                int nxv = vel + add;\n                if(nxv <= 0 || nxv > e.limit) continue;\n                double tmp = sum + (double)e.dist / (double)nxv;\n                if(dist[e.from][e.to][nxv] > tmp){\n                    dist[e.from][e.to][nxv] = tmp;\n                    que.push(Edge(cur, e.to, nxv, tmp));\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n | m){\n        for(int i = 0; i < MAX; i++) graph[i].clear();\n        int s, g;\n        cin >> s >> g;\n        for(int i = 0; i < m; i++){\n            int x, y;\n            double d, c;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            graph[x].push_back(Edge(x, y, d, c));\n            graph[y].push_back(Edge(y, x, d, c));\n        }\n        dijkstra(s - 1);\n        double ans = INF;\n        for(int i = 0; i < MAX; i++) ans = min(ans, dist[i][g - 1][1]);\n        if(ans == INF){\n            cout << \"unreachable\" << endl;\n        }else{\n            cout << fixed << setprecision(10) << ans << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//1162\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nconst int MAX_N=30,MAX_C=30;\nconst double INF=1e8;\nconst double ESP=1e-8;\n\n#define EQ(a,b) fabs(a-b)<ESP\n\nint n,m;\nint s,g;\nstruct edge{\n\tint to,dist,c;\n};\nvector<edge> G[MAX_N];\n\nstruct S{\n\tint town,v,pre;\n\tdouble cost;\n\tbool operator<(const S &a) const{\n\t\treturn cost>a.cost;\n\t}\n};\n\ndouble cost[MAX_N][MAX_C+1][MAX_N];\n\nvoid dijkstra(){\n\tREP(i,n){\n\t\tREP(j,MAX_C+1){\n\t\t\tREP(k,n){\n\t\t\t\tcost[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<S> pq;\n\tpq.push(S{s,0,0,0.0});\n\tcost[s][0][0]=0;\n\twhile (!pq.empty()){\n\t\tS s=pq.top();\n\t\tpq.pop();\n\t\tif (cost[s.town][s.v][s.pre]<s.cost){\n\t\t\tcontinue;\n\t\t}\n\t\tFOR(acc,-1,1+1){\n\t\t\tif (s.v+acc<=0) continue;\n\t\t\tFOR(i,0,G[s.town].size()){\n\t\t\t\tedge e=G[s.town][i];\n\t\t\t\tif (s.v+acc>e.c){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (e.to==s.pre) continue;\n\t\t\t\tif (s.cost+(double)e.dist/(s.v+acc)<cost[e.to][s.v+acc][s.town]){\n\t\t\t\t\tcost[e.to][s.v+acc][s.town]=s.cost+(double)e.dist/(s.v+acc);\n\t\t\t\t\tpq.push(S{e.to,s.v+acc,s.town,cost[e.to][s.v+acc][s.town]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif (n){\n\t\t\tscanf(\"%d %d\",&s,&g);\n\t\t\ts--;\n\t\t\tg--;\n\t\t\tREP(i,n){\n\t\t\t\tG[i].clear();\n\t\t\t}\n\t\t\tREP(i,m){\n\t\t\t\tint x,y,d,c;\n\t\t\t\tscanf(\"%d %d %d %d\",&x,&y,&d,&c);\n\t\t\t\tx--;\n\t\t\t\ty--;\n\t\t\t\tG[x].push_back(edge{y,d,c});\n\t\t\t\tG[y].push_back(edge{x,d,c});\n\t\t\t}\n\t\t\tdijkstra();\n\t\t\tdouble ans=INF;\n\t\t\tREP(i,n){\n\t\t\t\tans=min(ans,cost[g][1][i]);\n\t\t\t}\n\t\t\tif (EQ(ans,INF)){\n\t\t\t\tprintf(\"unreachable\\n\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"%.6f\\n\",ans);\n\t\t\t}\n\t\t}\n\t}while (n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\n#include <iomanip>\n#include <ctime>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> edge;\ntypedef pair<int, P> PP;\ntypedef pair<double, PP> PPP;\n\nvector<edge> G[100];\ndouble memo[40][40][40];\ndouble need[200][40];\n priority_queue<PPP, vector<PPP>,greater<PPP> > que;\n\nint main(){\n  int n, m;\n  int s, g;\n  for(int i = 0; i < 200; i++){\n    for(int j = 1; j < 40; j++) need[i][j] = (double)i / j;\n  }\n  while(cin >> n >> m && (n || m)){\n    scanf(\"%d%d\",&s,&g);\n    while(!que.empty()) que.pop();\n    fill(&memo[0][0][0], &memo[30][30][30]+1, 1e10);\n    for(int i = 0; i < m; i++){\n      int x1,y1,d,c;\n      scanf(\"%d%d%d%d\", &x1, &y1, &d, &c);\n      G[x1].push_back(edge(y1, P(d, c)));\n      G[y1].push_back(edge(x1, P(d, c)));\n    }\n    memo[s][0][32] = 0;\n   \n    que.push(PPP(memo[s][0][32], PP(0, P(s, 32))));\n    bool ok = false;\n\n    while(!que.empty()){\n      PPP ppp = que.top();\n      que.pop();\n\n      double dis = ppp.first;\n      int v = ppp.second.first;\n      int pos = ppp.second.second.first;\n      int pre = ppp.second.second.second;\n\n      if(dis > memo[pos][v][pre]) continue;\n     \n      if(pos == g && v == 1){\n\tcout << fixed << setprecision(9) << dis << endl;\n\tok = true;\n\tbreak;\n      }\n\n      for(int i = -1; i <= 1; i++){\n\tint v2 = v + i;\n\tfor(int j= 0; j < (int)G[pos].size(); j++){\n\t  int to = G[pos][j].first;\n\t  int li = G[pos][j].second.second;\n\t  int d = G[pos][j].second.first;\n\n\t  if(1 <= v2 && v2 <= li && to != pre){\n\t    if(memo[to][v2][pos] > dis + need[d][v2]){\n\t      memo[to][v2][pos] = dis + need[d][v2];\n\t      que.push(PPP(memo[to][v2][pos], PP(v2, P(to, pos))));\n\t    }\n\t  }\n\t}\n      }\n\n    }\n    if(!ok){\n      cout << \"unreachable\" << endl;\n    }\n    for(int i = 1; i <= 30; i++) G[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <iomanip>\nusing namespace std;\n \nconst int INF = 1<<29;\ndouble tbl[40][40][40];\nbool used[40][40][40];\nint n;\ndouble G[40][40];\nint cons[40][40];\n\nstruct E{\n  double c;\n  int now,pre,v;\n  E(int now,int pre,int v,double c):now(now),pre(pre),v(v),c(c){}\n};\n \nbool operator >(const E& a,const E& b){\n  return a.c>b.c;\n}\n \nvoid dijkstra(int s){\n  for(int i=0;i<n;++i)\n    for(int j=0;j<n;++j)\n      for(int k=0;k<40;++k)\n\tused[i][j][k]=false, tbl[i][j][k]=INF;\n \n  priority_queue<E,vector<E>,greater<E> > Q;\n  Q.push(E(s,31,0,0));\n  while(Q.size()){\n    E x = Q.top(); Q.pop();\n    int cur = x.now;\n    if(used[cur][x.pre][x.v]) continue;\n    tbl[cur][x.pre][x.v] = x.c;\n    used[cur][x.pre][x.v] = true;\n    for(int i=0;i<n;++i){\n      if(!G[cur][i]) continue;\n      if(i==x.pre) continue;\n      for(int j=-1;j<=1;++j){\n\tif(x.c==0 && j!=1) continue;\n\tint nxtv = x.v+j;\n\tif(nxtv<=0 || nxtv>cons[cur][i]) continue;\n\tdouble nxtcost = x.c+1.0*G[cur][i]/nxtv;\n\tif(tbl[cur][i][nxtv]<=nxtcost) continue;\n\tQ.push(E(i,cur,nxtv,nxtcost));\n      }\n    }\n  }\n}\n \nint main(){\n  int m;\n  while(cin>>n>>m,n||m){\n    for(int i=0;i<n;++i)\n      for(int j=0;j<n;++j)\n\tG[i][j] = 0;\n    int s,g;\n    cin >> s >> g;\n    s--;g--;\n    while(m--){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      a--;b--;\n      G[a][b] = G[b][a] = c;\n      cons[a][b] = cons[b][a]= d;\n    }\n    dijkstra(s);\n    double ans = INF;\n    for(int i=0;i<n;++i)\n      ans = min(ans,tbl[g][i][1]);\n    if(ans==INF) cout << \"unreachable\" << endl;\n    else cout << setprecision(10) << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 80 // いつもは1<<29だが小さくすれば時間はやくなる？\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n//自身だー\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <iomanip>\nusing namespace std;\n\nconst int INF = 1<<29;\ndouble tbl[40][40][40];\nbool used[40][40][40];\nint n;\n//typedef pair<int,double> P;\ndouble G[40][40];\n//vector<P> G[40];\nint cons[40][40];\nint dv[] = {-1,0,1};\n\nstruct E{\n  double c;\n  int now,pre,v;\n  E(int now,int pre,int v,double c):now(now),pre(pre),v(v),c(c){}\n};\n\nbool operator >(const E& a,const E& b){\n  return a.c>b.c;\n}\n\nvoid dijkstra(int s){\n  for(int i=0;i<n;++i)\n    for(int j=0;j<n;++j)\n      for(int k=0;k<40;++k)\n\tused[i][j][k]=false, tbl[i][j][k]=INF;\n\n  priority_queue<E,vector<E>,greater<E> > Q;\n  Q.push(E(s,s,1,0));\n  while(Q.size()){\n    E x = Q.top(); Q.pop();\n    int cur = x.now;\n    if(used[cur][x.pre][x.v]) continue;\n    tbl[cur][x.pre][x.v] = x.c;\n    used[cur][x.pre][x.v] = true;\n    for(int i=0;i<n;++i){\n      if(!G[cur][i]) continue;\n      for(int j=0;j<3;++j){\n\tif(x.c==0 && j!=1) continue;\n\tint nxtv = x.v+dv[j];\n\tif(nxtv<=0 || nxtv>cons[cur][i]) continue;\n\tdouble nxtcost = x.c+1.0*G[cur][i]/nxtv;\n\tif(tbl[cur][i][nxtv]<=nxtcost) continue;\n\tQ.push(E(i,cur,nxtv,nxtcost));\n      }\n    }\n  }\n}\n\nint main(){\n  int m;\n  while(cin>>n>>m,n||m){\n    for(int i=0;i<n;++i)\n      for(int j=0;j<n;++j)\n\tG[i][j] = 0;\n    int s,g;\n    cin >> s >> g;\n    s--;g--;\n    while(m--){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      a--;b--;\n      G[a][b] = G[b][a] = c;\n      cons[a][b] = cons[b][a]= d;\n    }\n    dijkstra(s);\n    double ans = INF;\n    for(int i=0;i<n;++i)\n      ans = min(ans,tbl[g][i][1]);\n    if(ans==INF) cout << \"unreachable\" << endl;\n    else cout << setprecision(10) << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\n#define INF 1e9\nusing namespace std;\n\nclass DP{\npublic:\n\tdouble cost;\n\tunsigned char cur, sp, prev;\n\t\n\tDP(){}\n\tDP(double c, int cu, int s, int pr){\n\t\tcost = c;cur=cu;sp=s;prev=pr;\n\t}\n\t\n\tbool operator< (const DP &opp) const {\n\t\treturn cost>opp.cost;\n\t}\n};\nint n,m,s,go;\n\nchar visit[31][31][31];\nint g[31][31];\nint lim[31][31];\n\nmain(){\n\tint i,j,d,c,x,y;\n\twhile(cin>>n>>m,n){\n\t\tpriority_queue<DP> dp;\n\t\tmemset(g, 0, sizeof(g));\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tcin>>s>>go;\n\t\t\n\t\tfor(i=1;i<=m;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tg[x][y]=g[y][x]=d;\n\t\t\tlim[x][y]=lim[y][x] = c;\n\t\t}\n\t\n\t\tDP T,S;\n\t\tdp.push(DP(0,1,0,0));\n\t\twhile(!dp.empty()){\n\t\t\tS = dp.top();\n\t\t\tdp.pop();\n//\t\t\tif(visit[S.cur][S.sp][S.prev]) continue;\n\t\t\tif(S.cur == go && S.sp == 1) break;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tif(!g[S.cur][i]) continue;\n\t\t\t\tfor(j=S.sp-1;j<=S.sp+1;j++){\n\t\t\t\t\tif(lim[S.cur][i] < j || j < 1 || i == S.prev || visit[i][j][S.cur]) continue;\n\t\t\t\t\tT.cost = S.cost + g[S.cur][i] / (double)j;\n\t\t\t\t\tT.cur = i;\n\t\t\t\t\tT.sp = j;\n\t\t\t\t\tT.prev = S.cur;\n\t\t\t\t\tdp.push(T);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvisit[S.cur][S.sp][S.prev] = 1;\n\t\t}\n\t\tif(S.cur == go && S.sp == 1) printf(\"%.5lf\\n\", S.cost);\n\t\telse cout << \"unreachable\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\n#define INF 1e9\n\nint main(void){\n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    // ??????????????¨??´??????\n    int s, g;\n    cin >> s >> g;\n    --s; --g;\n\n    // ???????????±???????????????\n    int x, y, d, c;\n    vector<vector<pair<int, pair<int, int> > > > adjlist(n);\n    for(int i = 0; i < m; i++){\n      cin >> x >> y >> d >> c;\n      --x; --y;\n      adjlist[x].push_back(make_pair(y, make_pair(d, c)));\n      adjlist[y].push_back(make_pair(x, make_pair(d, c)));\n    }\n\n    \n    // ????????????????????????\n    const int MAX_SPEED = 30;\n    const int acc[3] = {-1, 0, 1};\n    vector<vector<vector<double> > > result(n, vector<vector<double> >(n, vector<double>(MAX_SPEED + 1, INF)));\n\n    // U??????????????¢????????????????????????????????????????????????????????????????????????\n    // (-cost, ((speed, nextpoint), nextnextindex))\n    priority_queue<pair<double, pair<pair<int, int>, int> > > wait;\n    for(int i = 0; i < adjlist[s].size(); i++){\n      result[s][adjlist[s][i].first][0] = 0;\n      wait.push(make_pair(0, make_pair(make_pair(0, s), i)));\n    }\n\n    while(!wait.empty()){\n      double nowcost = -wait.top().first;\n      int nowspeed = wait.top().second.first.first;\n      int nowpoint = wait.top().second.first.second;\n      int nextindex = wait.top().second.second;\n      wait.pop();\n      int nextpoint = adjlist[nowpoint][nextindex].first;      \n      if(result[nowpoint][nextpoint][nowspeed] < nowcost){ continue; }\n\n      int speedlimit = adjlist[nowpoint][nextindex].second.second;\n      for(int j = 0; j < 3; j++){\n        int nextspeed = nowspeed + acc[j];\n        // ??¢??????????????¢?????¶????????????????????¢\n        if(nextspeed <= 0 || speedlimit < nextspeed){ continue; }\n        double nextcost = nowcost + ((double)adjlist[nowpoint][nextindex].second.first / nextspeed);\n        for(int i = 0; i < adjlist[nextpoint].size(); i++){\n          int nextnextpoint = adjlist[nextpoint][i].first;\n          // U??????????????¢\n          if(nextnextpoint == nowpoint){ continue; }\n          if(result[nextpoint][nextnextpoint][nextspeed] > nextcost){\n            result[nextpoint][nextnextpoint][nextspeed] = nextcost;\n            wait.push(make_pair(-nextcost, make_pair(make_pair(nextspeed, nextpoint), i)));\n          }\n        }\n        // ????????????????????????????????¨?????????????????¢\n        if(result[nextpoint][nextpoint][nextspeed] > nextcost){ result[nextpoint][nextpoint][nextspeed] = nextcost; }\n      }\n    }\n    \n    // ??????????¨????????????????\n    double mincost = INF;\n    for(int i = 0; i < n; i++){\n      if(mincost > result[g][i][1]){ mincost = result[g][i][1]; }\n    }\n    if(mincost == INF){ cout << \"unreachable\" << endl; }\n    else{ printf(\"%.5f\\n\", mincost); } \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nint main() {\n   for(;;) {\n      Int n, m;\n      std::cin >> n >> m;\n      if( n == 0 and m == 0 ) break;\n      Int s, g;\n      std::cin >> s >> g;\n      double inf = 1e16;\n      std::vector<std::pair<Int,double>> edges[32*32];\n      rep(ii,m) {\n         Int x, y, d, c;\n         std::cin >> x >> y >> d >> c;\n         for(Int kk = 0; kk < 2; ++kk) {\n            for(Int k = 1; k <= c; ++k) {\n               if( y != g ) {\n                  edges[x*32+k].emplace_back(y*32+k+1, (double)d/k);\n                  if( k >= 2 ) {\n                     edges[x*32+k].emplace_back(y*32+k-1, (double)d/k);\n                  }\n               }\n               edges[x*32+k].emplace_back(y*32+k+0, (double)d/k);\n            }\n            std::swap(x,y);\n         }\n      }\n      RQ<std::pair<double,Int>> q;\n      q.emplace(0.0, s*32+1);\n      std::vector<double> dist(32*32, inf);\n      dist[s*32+1] = 0;\n      while( not q.empty() ) {\n         double d;\n         Int v;\n         std::tie(d, v) = q.top(); q.pop();\n         for(auto next : edges[v]) {\n            Int nv;\n            double dd;\n            std::tie(nv, dd) = next;\n            double nd = d + dd;\n            if( nd < dist[nv] ) {\n               dist[nv] = nd;\n               q.emplace(nd, nv);\n            }\n         }\n      }\n      if( dist[g*32+1] >= inf ) {\n         puts(\"unreachable\");\n      }\n      else {\n         printf(\"%lf\\n\", dist[g*32+1]);\n      }\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<double, int, int, int> T;\n \nconst ll MOD=1e9+7;\n//const ll INF=1e18;\n\nconst double INF = 1000000.0;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\nstruct edge{ int to,d,c;};\n\n\n\nint n,m,s,g;\ndouble d[35][35][35];\ndouble mind;\n\nint main(){\n\twhile(true){\n\t\tcin >> n >> m;\n\t\tif(n + m == 0) break;\n\t\tcin >> s >> g;\n\t\tmind = INF;\n\t\tvector<edge> G[35];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a1,a2,a3,a4;\n\t\t\tcin >> a1 >> a2 >> a3 >> a4;\n\t\t\tedge tmp1 = {a2,a3,a4};\n\t\t\tG[a1].push_back(tmp1);\n\t\t\tedge tmp2 = {a1,a3,a4};\n\t\t\tG[a2].push_back(tmp2);\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tfor(int k = 0;k <= 31;k++){\n\t\t\t\t\td[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//queue<T> que;\n\t\tpriority_queue<T,vector<T>,greater<T> > que;\n\t\tfor(int i = 0;i < G[s].size();i++){\n\t\t\tedge e = G[s][i];\n\t\t\td[s][e.to][1] = (double) e.d;\n\t\t\tque.push(make_tuple((double)e.d,1,s,e.to));\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\t//T t = que.front(); que.pop();\n\t\t\tT t = que.top(); que.pop();\n\t\t\tdouble a1 = get<0>(t);\n\t\t\tint a2 = get<1>(t),a3 = get<2>(t),a4 = get<3>(t);\n\t\t\tif(d[a3][a4][a2] < a1 || a1 > mind)continue;\n\t\t\tfor(int i = 0;i < G[a4].size();i++){\n\t\t\t\tedge e = G[a4][i];\n\t\t\t\tif(e.to == a3) continue;\n\t\t\t\tfor(int j = -1;j <= 1;j++){\n\t\t\t\t\tint v = a2 + j;\n\t\t\t\t\tdouble tmp = (double)( a1 + (double)e.d / (double)v);\n\t\t\t//\t\tif(a4 == 5 && e.to == 6 && v == 1) cout << \"tmp\" << tmp << \",a1\" << a1 <<endl;\n\t\t\t\t\tif(v <= 0 || v > e.c || d[a4][e.to][v] < tmp ||tmp > mind) continue;\n\t\t\t\t\td[a4][e.to][v] =  tmp;\n\t\t\t\t\tif(e.to == g && v == 1 && mind > tmp)mind = tmp;\n\t\t\t\t\tque.push(make_tuple(tmp,v,a4,e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\n\t\t}\n\t//\tcout << \"ans\" << d[4][5][2] << endl;\n\n\n\n\t\tdouble ans = INF;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tdouble tmp = d[i][g][1];\n\t\t\tif(ans > tmp) ans = tmp;\n\t\t//\tans = min(ans,d[i][g][1]);\n\t\t}\n\t\tif(ans == INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t//\tcout << ans << endl;\n\t\t\tprintf(\"%lf\",ans);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst double INF = 1e99;\n\nstruct Edge {\n  int from, to, cost, cap;\n  Edge(int from_, int to_, int cost_, int cap_)\n    : from(from_), to(to_), cost(cost_), cap(cap_) { }\n};\n\nint main() {\n  cout.setf(ios::fixed);\n  cout.precision(4);\n  while(true) {\n    int N, M; cin >> N >> M;\n    if(N == 0) break;\n    int S, G; cin >> S >> G;\n    --S, --G;\n    vector<Edge> g;\n    for(int i = 0; i < M; ++i) {\n      int x,y,d,c; cin >> x >> y >> d >> c;\n      --x, --y;\n      g.emplace_back(x,y,d,c);\n      g.emplace_back(y,x,d,c);\n    }\n    M *= 2;\n    // [from][to][speed]\n    double d[N][N][31];\n    for(int i = 0; i < N; ++i)\n      for(int j = 0; j < N; ++j)\n        for(int c = 0; c < 31; ++c)\n          d[i][j][c] = INF;\n    for(int i = 0; i < M; ++i) {\n      if(g[i].from == S) {\n        d[S][g[i].to][1] = min(d[S][g[i].to][1], 1.0 * g[i].cost);\n      }\n    }\n    while(true) {\n      bool update = false;\n      for(int i = 0; i < M; ++i) {\n        for(int u = 0; u < N; ++u) {\n          if(g[i].to == u) continue;\n          for(int c = 1; c <= g[i].cap; ++c) {\n            for(int dc = -1; dc <= 1; ++dc) {\n              int nc = c + dc;\n              if(nc <= 0 || nc > g[i].cap) continue;\n              if(d[g[i].from][g[i].to][nc] > d[u][g[i].from][c] + 1.0 * g[i].cost / nc) {\n                d[g[i].from][g[i].to][nc] = d[u][g[i].from][c] + 1.0 * g[i].cost / nc;\n                update = true;\n              }\n            }\n          }\n        }\n      }\n      if(!update) break;\n    }\n    double ans = INF;\n    for(int u = 0; u < N; ++u) ans = min(ans, d[u][G][1]);\n    if(ans == INF) {\n      cout << \"unreachable\" << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define D first\n#define C second\n\nusing namespace std;\n\nconst double INF = 1000000000.0;\n\ndouble d[35][35][35]; //?????????????????????????????¨?????????????????¨??????????????°?????????????????????\nbool visited[35][35][35];\nint N,M,S,G;\npair<int, int> p[35][35];\n\nstruct ST{\n  double ti;\n  int bn;\n  int cn;\n  int sp;\n  ST(double _ti, int _bn, int _cn, int _sp){\n    ti = _ti;\n    bn = _bn;\n    cn = _cn;\n    sp = _sp;\n  }\n  bool operator >(const ST &e) const{\n    return ti > e.ti;\n  }\n};\n\nint main() {\n  while(1){\n    cin>>N>>M;\n    if(N==0 && M==0) break;\n    cin>>S>>G;\n    S--; G--;\n\n    REP(i,0,N)REP(j,0,N)REP(k,0,35) d[i][j][k] = INF;\n    REP(i,0,N)REP(j,0,N)REP(k,0,35) visited[i][j][k] = false;\n    REP(i,0,N)REP(j,0,N) p[i][j].D = p[i][j].C = -1;\n\n    bool flag = true;\n\n    REP(i,0,M){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      p[x-1][y-1].D = p[y-1][x-1].D = d;\n      p[x-1][y-1].C = p[y-1][x-1].C = c;\n    }\n\n    d[S][S][0] = 0.0;\n    //\n    priority_queue< ST, vector<ST>, greater<ST> > PQ;\n    ST st(0.0,S,S,0);\n    PQ.push(st);\n    //\n\n    //while(1){\n    while(!PQ.empty()){\n      /*\n      int ubn=-1, ucn=-1, usp=-1;\n      double mtime = INF;\n      REP(i,0,N){\n        REP(j,0,N){\n          REP(k,0,31){\n            if(visited[i][j][k]) continue;\n            if(mtime > d[i][j][k]){\n              ubn = i;\n              ucn = j;\n              usp = k;\n              mtime = d[i][j][k];\n            }\n          }\n        }\n      }\n      */\n      //\n      ST u = PQ.top(); PQ.pop();\n      double mtime = u.ti;\n      int ubn=u.bn, ucn=u.cn, usp=u.sp;\n      visited[ubn][ucn][usp] = true;\n      if(d[ubn][ucn][usp] < mtime) continue;\n      //cout<<\"u.ti: \"<<u.ti<<\"; u.bn: \"<<u.bn<<\"; u.cn: \"<<u.cn<<\"; u.sp: \"<<u.sp<<endl;\n      //\n      if(ucn == G && usp == 1){\n        printf(\"%.5lf\\n\",d[ubn][ucn][usp]);\n        flag = false;\n        break;\n      }\n      /*\n      if(ucn == -1){\n        cout<<\"unreachable\"<<endl;\n        break;\n      }\n      */\n\n      visited[ubn][ucn][usp] = true;\n      for(int v = usp-1; v <= usp+1; v++){\n        if(v <= 0) continue;\n        REP(next,0,N){\n          if(visited[ucn][next][v] || p[ucn][next].D == -1 || p[ucn][next].C < v || ucn == next) continue;\n          /*\n          d[ucn][next][v] = min(d[ucn][next][v], d[ubn][ucn][usp] + (double)p[ucn][next].D/(double)v);\n          */\n          //\n          if(d[ucn][next][v] > d[ubn][ucn][usp] + (double)p[ucn][next].D/(double)v){\n            d[ucn][next][v] = d[ubn][ucn][usp] + (double)p[ucn][next].D/(double)v;\n            ST tst(d[ucn][next][v], ucn,next,v);\n            PQ.push(tst);\n          }\n          //\n        }\n      }\n\n    }\n    if(flag){\n      cout<<\"unreachable\"<<endl;\n    }\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nstruct State {\n    int i, prev, sp; double cost;\n};\n\nbool operator>(const State& a, const State& b)\n{\n    return a.cost > b.cost;\n}\n\nconst double INF = 1<<29;\n\nint main()\n{\n    while (1) {\n        int n, m, s, g; cin >> n >> m >> s >> g;\n        if (!n) break;\n        s--, g--;\n\n        vector<vector<double>> dist(n, vector<double>(n, INF));\n        vector<vector<int>> lim(n, vector<int>(n));\n\n        while (m--) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--, y--;\n            dist[x][y] = dist[y][x] = d;\n            lim[x][y] = lim[y][x] = c;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> Q;\n        Q.push({ s, 39, 0, 0 });\n\n        int vis[40][40][40] = {};\n        double ans = INF;\n        while (Q.size()) {\n            auto e = Q.top(); Q.pop();\n            if (vis[e.i][e.sp][e.prev]) continue;\n            vis[e.i][e.sp][e.prev] = 1;\n            if (e.i == g && e.sp == 1) ans = min(ans, e.cost);\n            loop (n, i) loop (3, d) {\n                int sp = e.sp-1+d;\n                if (dist[e.i][i] == INF || i == e.prev ||\n                        sp < 1 || sp > lim[e.i][i]) continue;\n                Q.push({ i, e.i, sp, e.cost + dist[e.i][i] / sp });\n            }\n        }\n        if (ans != INF) cout << setprecision(12) << fixed << ans << endl;\n        else cout << \"unreachable\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n\n///////////////////ダイクストラで使うクラス//////////////////\nclass E{\n\tpublic:\n\tint dir,cost,limit;\n\tE(int dir,int cost,int limit):dir(dir),cost(cost),limit(limit){}\n};\n\nclass T{\n\tpublic:\n\tint pos,bef,speed;\n\tdouble val;\n\tT(int pos,int bef,double val,int speed):pos(pos),bef(bef),val(val),speed(speed){}\n\t\n\tbool operator<(const T& a)const{\n\t\treturn val>a.val;\n\t}\n};\n\n////////////////////////////main/////////////////////////\nint main(){\n\t\n\twhile(1){\n\t\t/////////////入力/////////////////////////////////\n\t\tint n,m,start,goal;\n\t\tvector<E> edge[33];\n\t\t\n\t\tcin>>n>>m; if(n==0)break;\n\t\tcin>>start>>goal;\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tedge[a].push_back(E(b,c,d));\n\t\t\tedge[b].push_back(E(a,c,d));\n\t\t}\n\t\t\n\t\t///////////ダイクストラ本体//////////////////////\n\t\tpriority_queue<T> que;\n\t\tque.push(T(start,33,0,0)); //初期位置設定\n\t\t\n\t\tint visit[33][33]={0};\n\t\twhile(1){\n\t\t\tif(que.empty())break; //異常終了\n\t\t\t\n\t\t\tT u = que.top();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(visit[u.pos][u.speed]==1)continue; //一度訪れた状態の場合は弾く\n\t\t\tvisit[u.pos][u.speed]=1;\n\t\t\t\n\t\t\tif(u.pos==goal && u.speed==1){ //終了判定\n\t\t\t\tprintf(\"%lf\\n\",u.val);\n\t\t\t\tgoto A;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<edge[u.pos].size();i++){ //状態遷移\n\t\t\t\tE e = edge[u.pos][i];\n\t\t\t\tif(e.dir == u.bef)continue; //Uターン禁止の制約で弾く\n\t\t\t\t\n\t\t\t\t//-1:減速 0:等速 1:加速\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\n\t\t\t\t\tint next = u.speed + j;\n\t\t\t\t\tif(next > e.limit || next <= 0)continue; //速度の制約で弾く\n\t\t\t\t\t\n\t\t\t\t\tque.push( T(e.dir, u.pos, u.val + double(e.cost)/next, next) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"unreachable\\n\");\n\t\tA:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define NODE 30\n#define LIM 31\nconst double inf = 1e200;\n\nclass state{\npublic:\n  int cur,prev,speed;\n  double c;\n  state(){};\n  state(int tcur,int tprev,int tspeed,double tc):cur(tcur),prev(tprev),\n\t\t\t\t\t\t speed(tspeed),c(tc){};\n  bool operator<(const state & a)const{\n    return c >a.c;\n  }\n};\n\ndouble cost[30][30][31];\ndouble dist[30][30];\nint lim[30][30];\n\n\nvoid solve(int n,int s,int g){\n  rep(i,n)rep(j,n)rep(k,31)cost[i][j][k]=inf;\n  priority_queue<state> Q;\n  rep(i,n){\n    if ( lim[s][i] >= 1){\n      cost[i][s][1]=dist[s][i];\n      Q.push(state(i,s,1,cost[i][s][1]));\n    }\n  }\n\n  while(!Q.empty()){\n    state now = Q.top();\n    Q.pop();\n    rep(i,n){\n      if ( i == now.prev)continue;\n      REP(j,-1,2){\n\tif ( now.speed + j > 0 && now.speed + j <= lim[now.cur][i] &&\n\t     cost[i][now.cur][now.speed+j] > now.c + dist[now.cur][i]/(now.speed+j)){\n\t  cost[i][now.cur][now.speed+j]=now.c+dist[now.cur][i]/(now.speed+j);\n\t  Q.push(state(i,now.cur,now.speed+j,cost[i][now.cur][now.speed+j]));\n\t}\n      }\n    }\n  }\n  \n\n  double ans = inf;\n  rep(i,n){\n    ans=min(ans,cost[g][i][1]);\n  }\n  if ( ans > 1e199)puts(\"unreachable\");\n  else printf(\"%.3lf\\n\",ans);\n}\n\n\nmain(){\n  int n,m;\n  while(cin>>n>>m && n){\n    rep(i,n)rep(j,n)lim[i][j]=0,dist[i][j]=inf;\n    int s,g;\n    cin>>s>>g;\n    s--;g--;\n    rep(i,m){\n      int f,t,v;\n      double d;\n      cin>>f>>t>>d>>v;\n      f--;t--;\n      dist[f][t]=dist[t][f]=d;\n      lim[f][t]=lim[t][f]=v;\n    }\n    solve(n,s,g);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\nconst int MAX_V = 31;\nconst int MAX_S = 31;\nconst double INF = 1<<28;\n\nint n,m,s,g;\n\nstruct edge{\n\tint to, dist, speed;\n\tedge(int t_to,int t_dist,int t_speed){\n\t\tto=t_to;dist=t_dist;speed=t_speed;\n\t}\n};\n\nstruct state{\n\tdouble cost;\n\tint c_v,p_v,speed;\n\tstate(int t_c_v,int t_p_v,double t_cost,int t_speed){ //????????????????????????????????????\n\t\tc_v=t_c_v;p_v=t_p_v;cost=t_cost;speed=t_speed;\n\t}\n\tbool operator>(const state& s) const {\n\t\treturn cost > s.cost;\n\t}\n\n};\n\nint ds[]={-1,0,1};\nvector< vector<edge> > G(MAX_V);\ndouble d[MAX_V][MAX_V][MAX_S];\n\nvoid dijkstra(){\n\tpriority_queue<state,vector<state>,greater<state> > que;\n\tfill_n((double *)d, sizeof(d)/sizeof(double),INF);\n\trep(i,G[s].size()){\n\t\tedge t_e=G[s][i];\n\t\tque.push(state(t_e.to,s,t_e.dist,1.0));\n\t\td[t_e.to][s][1]=(double)t_e.dist;\n\t}\n\n\twhile(!que.empty()){\n\t\tstate p = que.top(); que.pop();\n\t\tint c_v = p.c_v;\n\t\tint p_v = p.p_v;\n\t\tif(d[c_v][p_v][p.speed]<p.cost) continue;\n\t\trep(i,G[c_v].size()){\n\t\t\tedge e = G[c_v][i];\n\t\t\trep(i,3){\n\t\t\t\tint speed=p.speed+ds[i];\n\t\t\t\tif(speed>0&&speed<=e.speed){\n\t\t\t\t\tdouble cost=((double)e.dist/(double)speed);\n\t\t\t\t\tif(d[e.to][c_v][speed] > p.cost + cost){//??????????????´???\n\t\t\t\t\t\td[e.to][c_v][speed] = p.cost + cost;\n\t\t\t\t\t\tque.push(state(e.to,c_v,d[e.to][c_v][speed],speed));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tcout << fixed << setprecision(6);\n\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\tcin >> s >> g;\t\n\t\ts--;g--;\n\n\t\tG.clear();\n\t\tG.resize(MAX_V);\n\n\t\trep(i,m){\n\t\t\tint a,b,d,c;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--;b--;\n\t\t\tedge tmp1(b,d,c);\n\t\t\tedge tmp2(a,d,c);\n\t\t\tG[a].push_back(tmp1);\n\t\t\tG[b].push_back(tmp2);\n\t\t}\n\n\t\tdijkstra();\n\t\tdouble ans=INF;\n\t\trep(i,G[g].size()){\n\t\t\tans=min(d[g][G[g][i].to][1],ans);\t\n\t\t}\n\n\t\tif(ans==INF) cout << \"unreached\" << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define D first\n#define C second\n\nusing namespace std;\n\nconst double INF = 1000000000.0;\n\ndouble d[31][31][31]; //?????????????????????????????¨?????????????????¨??????????????°?????????????????????\nbool visited[31][31][31];\nint N,M,S,G;\npair<int, int> p[31][31];\n\nstruct ST{\n  double ti;\n  int bn;\n  int cn;\n  int sp;\n  ST(double _ti, int _bn, int _cn, int _sp){\n    ti = _ti;\n    bn = _bn;\n    cn = _cn;\n    sp = _sp;\n  }\n  bool operator >(const ST &e) const{\n    return ti > e.ti;\n  }\n};\n\nint main() {\n  while(1){\n    cin>>N>>M;\n    if(N==0 && M==0) break;\n    cin>>S>>G;\n    S--; G--;\n\n    REP(i,0,N)REP(j,0,N)REP(k,0,31) d[i][j][k] = INF;\n    REP(i,0,N)REP(j,0,N)REP(k,0,31) visited[i][j][k] = false;\n    REP(i,0,N)REP(j,0,N) p[i][j].D = p[i][j].C = -1;\n\n    bool flag = true;\n\n    REP(i,0,M){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      p[x-1][y-1].D = p[y-1][x-1].D = d;\n      p[x-1][y-1].C = p[y-1][x-1].C = c;\n    }\n\n    d[S][S][0] = 0.0;\n    //\n    priority_queue< ST, vector<ST>, greater<ST> > PQ;\n    ST st(0.0,S,S,0);\n    PQ.push(st);\n    //\n\n    //while(1){\n    while(!PQ.empty()){\n      /*\n      int ubn=-1, ucn=-1, usp=-1;\n      double mtime = INF;\n      REP(i,0,N){\n        REP(j,0,N){\n          REP(k,0,31){\n            if(visited[i][j][k]) continue;\n            if(mtime > d[i][j][k]){\n              ubn = i;\n              ucn = j;\n              usp = k;\n              mtime = d[i][j][k];\n            }\n          }\n        }\n      }\n      */\n      //\n      ST u = PQ.top(); PQ.pop();\n      double mtime = u.ti;\n      int ubn=u.bn, ucn=u.cn, usp=u.sp;\n      if(d[ubn][ucn][usp] < u.ti) continue;\n      //cout<<\"u.ti: \"<<u.ti<<\"; u.bn: \"<<u.bn<<\"; u.cn: \"<<u.cn<<\"; u.sp: \"<<u.sp<<endl;\n      //\n      if(ucn == G && usp == 1){\n        printf(\"%.5lf\\n\",d[ubn][ucn][usp]);\n        flag = false;\n        break;\n      }\n      /*\n      if(ucn == -1){\n        cout<<\"unreachable\"<<endl;\n        break;\n      }\n      */\n\n      visited[ubn][ucn][usp] = true;\n      for(int v = usp-1; v <= usp+1; v++){\n        if(v <= 0) continue;\n        REP(next,0,N){\n          if(p[ucn][next].D == -1 || p[ucn][next].C < v || ucn == next) continue;\n          /*\n          d[ucn][next][v] = min(d[ucn][next][v], d[ubn][ucn][usp] + (double)p[ucn][next].D/(double)v);\n          */\n          //\n          if(d[ucn][next][v] > d[ubn][ucn][usp] + (double)p[ucn][next].D/(double)v){\n            d[ucn][next][v] = d[ubn][ucn][usp] + (double)p[ucn][next].D/(double)v;\n            ST tst(d[ucn][next][v], ucn,next,v);\n            PQ.push(tst);\n          }\n          //\n        }\n      }\n\n    }\n    if(flag){\n      cout<<\"unreachable\"<<endl;\n    }\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nstruct NODE{\n\tint from,to,speed;\n\tdouble cost;\n\tNODE(int from,int to,int speed,double cost) : from(from) , to(to) , speed(speed) , cost(cost) {\n\t}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\n\nvector< vector<NODE> > G;\nbool done[32][32][1000] = {};\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m && n){\n\t\tmemset(done,0,sizeof(done));\n\t\tint s,g;\n\t\tcin >> s >> g;\n\t\ts--,g--;\n\t\tG.clear();\n\t\tG.resize(n);\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c,d;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--,b--;\t\n\t\t\tG[a].push_back(NODE(a,b,c,d));\n\t\t\tG[b].push_back(NODE(b,a,c,d));\n\t\t\t//cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n\t\t}\n\t\tpriority_queue<NODE> Q;\n\t\t\n\t\tQ.push(NODE(n,s,0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( q.speed >= 1000) continue;\n\t\t\tif( done[q.from][q.to][q.speed] ) continue;\n\t\t\telse done[q.from][q.to][q.speed] = true;\n\t\t\tif( q.to == g && q.speed == 1 ){\n\t\t\t\tprintf(\"%.10lf\\n\",q.cost);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < G[q.to].size() ; i++){\n\t\t\t\tif( q.speed+0 > 0 && q.speed+0 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed+0,q.cost+G[q.to][i].cost / (q.speed+0)));\n\t\t\t\tif( q.speed+1 > 0 && q.speed+1 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed+1,q.cost+G[q.to][i].cost / (q.speed+1)));\n\t\t\t\tif( q.speed-1 > 0 && q.speed-1 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed-1,q.cost+G[q.to][i].cost / (q.speed-1)));\n\t\t\t}\n\t\t}\n\t\tcout << \"unreachable\" << endl;\n\t\texit:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct status {\n    int pos;\n    double dist;\n    int vel;\n\n    status () {}\n    ~status () {}\n\n    status(int a, double b, int c): pos(a), dist(b), vel(c) {}\n\n    bool operator < (const status& o) const {\n        return dist < o.dist;\n    }\n\n    bool operator > (const status& o) const {\n        return dist > o.dist;\n    }\n};\n\nstruct edge {\n    int to;\n    double dist;\n    int lim;\n\n    edge () {}\n    ~edge () {}\n\n    edge(int a, double b, int c): to(a), dist(b), lim(c) {}\n};\n\nconst int INF = 1 << 29;\n\nbool solve() {\n    int n, m, s, g;\n    /*\n     * n <- [1..20]\n     * m <- [1..?]\n     * s, g <- [1..n]\n     * (x, y, d, c)\n     *   x, y <- [1..n]\n     *   d <- [1..100]\n     *   c <- [1..30]\n     */\n    cin >> n >> m >> s >> g;\n\n    if ((n | m | s | g) == 0) return false;\n\n    --s; --g;\n\n    vector<vector<edge>> graph(n, vector<edge>());\n\n    for (int j = 0; j < m; ++j) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        --x; --y;\n        graph[x].push_back(edge(y, d, c));\n        graph[y].push_back(edge(x, d, c));\n    }\n\n    vector<vector<double>> dist(n, vector<double>(30 + 1, INF));\n    priority_queue<status, vector<status>, greater<status>> que;\n\n    dist[s][0] = 0;\n    que.push(status(s, 0.0, 0));\n\n    while (!que.empty()) {\n        status st = que.top(); que.pop();\n\n        if (dist[st.pos][st.vel] < st.dist) {\n            continue;\n        }\n\n        if (st.pos == g && st.vel == 1) {\n            break;\n        }\n\n        for (edge& e : graph[st.pos]) {\n            double d = st.dist + e.dist / (st.vel+1);\n            if (st.vel + 1 <= e.lim && d < dist[e.to][st.vel+1]) {\n                dist[e.to][st.vel+1] = d;\n                que.push(status(e.to, d, st.vel+1));\n            }\n            d = st.dist + e.dist / st.vel;\n            if (st.vel > 0 && st.vel <= e.lim && d < dist[e.to][st.vel]) {\n                dist[e.to][st.vel] = d;\n                que.push(status(e.to, d, st.vel));\n            }\n            d = st.dist + e.dist / (st.vel-1);\n            if (st.vel - 1 > 0 && d < dist[e.to][st.vel-1]) {\n                dist[e.to][st.vel-1] = d;\n                que.push(status(e.to, d, st.vel-1));\n            }\n        }\n    }\n\n    if (dist[g][1] == INF) {\n        printf(\"unreachable\\n\");\n    } else {\n        printf(\"%.10f\\n\", dist[g][1]);\n    }\n\n    return true;\n}\n\nint main () {\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define D first\n#define C second\n\nusing namespace std;\n\nconst double INF = 1000000000.0;\n\ndouble d[31][31][31]; //?????????????????????????????¨?????????????????¨??????????????°?????????????????????\nbool visited[31][31][31];\nint N,M,S,G;\npair<int, int> p[31][31];\n\nint main() {\n  while(1){\n    cin>>N>>M;\n    if(N==0 && M==0) break;\n    cin>>S>>G;\n    S--; G--;\n\n    REP(i,0,N)REP(j,0,N)REP(k,0,31) d[i][j][k] = INF;\n    REP(i,0,N)REP(j,0,N)REP(k,0,31) visited[i][j][k] = false;\n    REP(i,0,N)REP(j,0,N) p[i][j].D = p[i][j].C = -1;\n\n    REP(i,0,M){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      p[x-1][y-1].D = p[y-1][x-1].D = d;\n      p[x-1][y-1].C = p[y-1][x-1].C = c;\n    }\n\n    d[S][S][0] = 0.0;\n    //visited[S][S][1] = 0.0;\n\n    while(1){\n      int ubn=-1, ucn=-1, usp=-1;\n      double mtime = INF;\n      REP(i,0,N){\n        REP(j,0,N){\n          REP(k,0,31){\n            if(visited[i][j][k]) continue;\n            if(mtime > d[i][j][k]){\n              ubn = i;\n              ucn = j;\n              usp = k;\n              mtime = d[i][j][k];\n            }\n          }\n        }\n      }\n      //test\n      //cout<<\"ubn: \"<<ubn<<\", ucn: \"<<ucn<<\", usp: \"<<usp<<endl;\n      if(ucn == G && usp == 1){\n        //cout<<d[ubn][ucn][usp]<<endl;\n        printf(\"%.5lf\\n\",d[ubn][ucn][usp]);\n        break;\n      }\n      if(ucn == -1){\n        cout<<\"unreachable\"<<endl;\n        break;\n      }\n\n      visited[ubn][ucn][usp] = true;\n      for(int v = usp-1; v <= usp+1; v++){\n        if(v <= 0) continue;\n        REP(next,0,N){\n          //cout<<\"p[ucn][next].D: \"<<p[ucn][next].D<<\"; p[ucn][next].C: \"<<p[ucn][next].C<<endl;\n          if(p[ucn][next].D == -1 || p[ucn][next].C < v || ucn == next) continue;\n          //test\n          //cout<<\"next: \"<<next<<endl;\n          d[ucn][next][v] = min(d[ucn][next][v], d[ubn][ucn][usp]/*mtime*/ + (double)p[ucn][next].D/(double)v);\n        }\n      }\n\n    }\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-7;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\n\nstruct edge{\n\tint to;\n\tint limitSpeed;\n\tint dist;\n};\nvector<edge> G[101];\nvoid add_edge(int x,int y,int d,int c){\n\tedge e;\n\tint from=x;\n\tint to=y;\n\te.to=y;\n\te.limitSpeed=c;\n\te.dist=d;\n\tG[from].push_back(e);\n\te.to=x;\n\tG[to].push_back(e);\n}\nconst double INF=1e+10;\n\ntypedef pair<double,int> pdi;\ntypedef pair<pdi,pii> Sit;\n\ndouble d[51][51][51];\ndouble dijkstra(int s,int g,int n){\n\tfor(int i=0;i<51;i++)\n\t\tfor(int j=0;j<51;j++)\n\t\t\tfor(int k=0;k<51;k++)\n\t\t\t\td[i][j][k]=INF;\n\tpriority_queue<Sit,vector<Sit>,greater<Sit> > pq;\n\tpq.push(make_pair(pdi(0,0),pii(s,1)));\n\td[0][s][1]=0;\n\twhile(pq.size()){\n\t\tSit p=pq.top();pq.pop();\n\t\tdouble ccost=p.first.first;\n\t\tint prvNode=p.first.second;\n\t\tint curNode=p.second.first;\n\t\tint curSpeed=p.second.second;\n\t\tif(!EQ(d[prvNode][curNode][curSpeed],ccost)&&d[prvNode][curNode][curSpeed]<ccost)continue;\n\t\tfor(int j=0;j<G[curNode].size();j++){\n\t\t\tedge &e=G[curNode][j];\n\t\t\tint toNode=e.to;\n\t\t\tif(toNode==prvNode)\n\t\t\t\tcontinue;\n\t\t\tint limitSpeed=e.limitSpeed;\n\t\t\tint dist=e.dist;\n\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\tif(prvNode==0&&i!=0)continue;\n\t\t\t\tint nxtSpeed=curSpeed+i;\n\t\t\t\tif(nxtSpeed==0||nxtSpeed>limitSpeed)continue;\n\t\t\t\tdouble ncost=ccost+1.0*dist/nxtSpeed;\n\t\t\t\tif(!EQ(ncost,d[curNode][toNode][nxtSpeed])&&ncost<d[curNode][toNode][nxtSpeed]){\n\t\t\t\t\td[curNode][toNode][nxtSpeed]=ncost;\n\t\t\t\t\tpq.push(make_pair(pdi(ncost,curNode),pii(toNode,nxtSpeed)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble res=INF;\n\tfor(int i=1;i<=n;i++)\n\t\tres=min(res,d[i][g][1]);\n\treturn res;\n}\n\nvoid solve(){\n\tint n,m,s,g;\n\twhile(cin>>n>>m&&(n|m)){\n\t\tcin>>s>>g;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tadd_edge(x,y,d,c);\n\t\t}\n\t\tdouble res=dijkstra(s,g,n);\n\t\tif(EQ(res,INF))cout<<\"unreachable\"<<endl;\n\t\telse printf(\"%.10f\\n\",res);\n\t\tfor(int i=0;i<101;i++)G[i].clear();\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e10\n#define EPS 1e-10\nusing namespace std;\nstruct edge{\n  int to,limit;\n  double dist;\n};\nvector<edge> G[100];\ndouble d[40][100];\nbool used[40][100];\ntypedef pair<int,int> pii; //to,speed\ntypedef pair<double,pii> P;//cost,to,speed\n\ndouble dikstra(int s,int g){\n  int ds[3]={-1,0,1};\n  priority_queue<P,vector<P>,greater<P> > que;\n  for(int i=0;i<40;i++)\n    for(int j=0;j<100;j++)\n      d[i][j]=INF;\n  memset(used,0,sizeof(used));\n  d[0][s]=0;\n  que.push(P(0,pii(s,0)));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int speed=p.second.second;\n    int v=p.second.first;\n    double cost=p.first;\n    //cout << v << \";\" << speed <<\":\" << cost << endl;\n    if(d[speed][v]<cost)continue;\n    for(int i=0;i<G[v].size();i++){\n      for(int j=0;j<3;j++){\n\tedge e=G[v][i];\n\tint ns=speed+ds[j];\n\tif(1<=ns && ns<= e.limit &&\n\t   used[ns][e.to]==false){\n\t  used[ns][e.to]=true;\n\t  que.push(P(cost+e.dist/ns,pii(e.to,ns)));\n\t  if(d[ns][e.to]>cost+e.dist/ns){\n\t    d[ns][e.to]=cost+e.dist/ns;\n\t    //cout << \"d[\" << ns << \"][\" << e.to << \"]:\" << d[ns][e.to] << endl;\n\t    //cout << \"d[\" << v << \"]:\" << d[speed][v] << \" speed:\" << speed<< endl;\n\t  }\n\t}\n      }\n    }\n  }\n  if(d[1][g]==INF)return -1;\n  return d[1][g];\n}\n\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n){\n    for(int i=0;i<100;i++)G[i].clear();\n    cin>>s>>g;\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      G[x].push_back((edge){y,c,d});\n      G[y].push_back((edge){x,c,d});\n    }\n    double ans=dikstra(s,g);\n    if(ans==-1)cout << \"unreachable\" << endl;\n    else printf(\"%lf\\n\",ans);\n    // for(int i=0;i<=n;i++)\n    // \tcout << i << \" \" << d[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct State{\n    int node, prev, v;\n    double t;\n    State(int node, int prev, int v, double t): node(node), prev(prev), v(v), t(t) {}\n    bool operator>(const State& s) const{\n        return t > s.t;\n    }\n};\n\nstruct Edge{\n    int to;\n    double d;\n    int c;\n    Edge(int to, double d, int c): to(to), d(d), c(c) {}\n};\n\nvector<Edge> G[30];\n\ndouble dist[30][30][30];\npriority_queue<State, vector<State>, greater<State> > que;\n\nvoid dijkstra(int start){\n    fill(dist[0][0], dist[29][30], 1e5);\n    dist[start][start][0] = 0.0;\n    State start_state = State(start, start, 0, 0.0);\n    que.push(start_state);\n    \n    while(!que.empty()){\n        State s = que.top(); que.pop();\n        if(dist[s.prev][s.node][s.v] < s.t) continue;\n        for(Edge e: G[s.node]){\n            if(e.to == s.prev) continue;\n            for(int dv=-1;dv<=1;dv++){\n                if(s.v+dv <= 0 || e.c < s.v+dv) continue;\n                if(dist[s.node][e.to][s.v+dv] > dist[s.prev][s.node][s.v] + e.d/(s.v+dv)){\n                    dist[s.node][e.to][s.v+dv] = dist[s.prev][s.node][s.v] + e.d/(s.v+dv);\n                    que.push(State(e.to, s.node, s.v+dv, dist[s.node][e.to][s.v+dv]));\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int n, m, s, g, x, y, c;\n    double d;\n    while(cin >> n >> m && n){\n        for(int i=0;i<30;i++){\n            G[i].clear();\n        }\n        \n        cin >> s >> g;\n        s--; g--;\n        \n        for(int i=0;i<m;i++){\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            G[x].push_back(Edge(y, d, c));\n            G[y].push_back(Edge(x, d, c));\n        }\n        \n        dijkstra(s);\n        double ans = dist[0][g][1];\n        for(int i=1;i<n;i++){\n            ans = min(ans, dist[i][g][1]);\n        }\n        if(abs(ans - 1e5) < 1){\n            printf(\"unreachable\\n\");\n            continue;\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nconst int MAX = 35;\nconst int INF = (1<<25);\nint n,m;\n\nstruct Edge{\n  int to;\n  double dis,lim;\n  Edge(int a, double b, double c):to(a),dis(b),lim(c){}\n};\n\nstruct State{\n  int pos,from;\n  double speed,t;\n  State(int a, double b, double c, int f):pos(a),speed(b),t(c),from(f){}\n  bool operator < (const State& s) const{ return t > s.t;}\n};\n\nvector<Edge> E[MAX];\ndouble T[MAX][MAX][MAX];\n//T[i][j][k] := shortest time from i to j with speed k.\n\n\nvoid init(){\n  for(int i = 0; i < MAX; i++){\n    for(int j = 0; j < MAX; j++)\n      for(int k = 0; k < MAX; k++) T[i][j][k] = INF;\n    E[i].clear();\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++){\n    int x,y;\n    double d,c;\n    cin >> x >> y >> d >> c;\n    //   cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    E[x].push_back(Edge(y,d,c));\n    E[y].push_back(Edge(x,d,c));\n  }\n}\n\nvoid solve(int s, int g){\n\n  priority_queue<State> Q;\n  T[0][s][0] = 0;\n  Q.push(State(s,0,0,-1));\n\n  while(!Q.empty()){\n    State sta = Q.top();\n    Q.pop();\n    \n    if(Q.size() > 100) cerr << Q.size() << endl;\n\n    if(sta.t > T[sta.from][sta.pos][(int)sta.speed]) continue;\n\n    for(int i = 0; i < E[sta.pos].size(); i++){\n      int np = E[sta.pos][i].to;\n\n      if(np == sta.from) continue;\n\n      double sp[] = {-1,0,1};\n      \n      for(int j = 0; j < 3; j++){\n\tdouble ns = sta.speed+sp[j];\n\tif(ns <= 0 || ns > E[sta.pos][i].lim) continue;\n\tdouble nt = sta.t+E[sta.pos][i].dis/ns;\n\tif(T[sta.pos][np][(int)ns] > nt){\n\t  T[sta.pos][np][(int)ns] = nt;\n\t  Q.push(State(np,ns,nt,sta.pos));\n\t}\n      }\n    }\n  }\n\n  // cerr << \"come \" << endl;\n\n  double ans = INF;\n\n  for(int i = 0; i < MAX; i++)\n    ans = min(ans,T[i][g][1]);\n  \n\n  if(ans == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.5f\\n\",ans);\n}\n\nint main(){\n\n  while(cin >> n >> m && n+m){\n    init();\n    int s,g;\n    cin >> s >> g;\n    input();\n    solve(s,g);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n||m){\n    cin>>s>>g;\n    //cout << n << m << s << g << endl;\n    s--;g--;\n    int d[n][n],c[n][n];\n    memset(d,-1,sizeof(d));\n    memset(c,-1,sizeof(c));\n    int i,j,k,l,x,y;\n    for(i=0;i<m;i++){\n      cin>>x>>y>>j>>k;\n      x--;y--;\n      d[x][y]=d[y][x]=j;\n      c[x][y]=c[y][x]=k;\n    }\n    double v[n][50][n];\n    double inf=1<<28,p,ans=inf;\n    for(i=0;i<n;i++) for(j=0;j<50;j++) for(k=0;k<n;k++) v[i][j][k]=inf;\n    typedef pair<int,int> PPP;\n    typedef pair<int,PPP> P;\n    typedef pair<double,P> PP;\n    priority_queue<PP,vector<PP>,greater<PP> > q;\n    q.push(PP(0,P(s,PPP(1,-1))));\n    while(!q.empty()){\n      x=q.top().second.first;\n      y=q.top().second.second.first;\n      k=q.top().second.second.second;\n      p=q.top().first;q.pop();\n      if(v[x][y][k]<=p) continue;\n      v[x][y][k]=p;\n      //cout << x+1<< \":\"<< y << \"/\" << p << endl;\n      if(x==g&&y==1) break;\n      for(i=0;i<n;i++){\n\tif(!~d[x][i]||i==k) continue;\n\tfor(j=-1;j<=1;j++){\n\t  if(k==-1&&j!=0) continue;\n\t  if(y+j<=0||c[x][i]<y+j) continue;\n\t  q.push(PP(p+(double)d[x][i]/(y+j),P(i,PPP(y+j,x))));\n\t}\n      }\n    }\n    for(i=0;i<n;i++) ans=min(ans,v[g][1][i]);\n    if(ans!=inf) printf(\"%.8f\\n\",ans);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<set>\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define foreach(i, c) for(__typeof(c.begin()) i = c.begin(); i != c.end(); i++)\n#define mp3(i, j, k) make_pair((i), make_pair((j), (k)))\n#define mp make_pair\n#define INF 9999999\nusing namespace std;\n\nstruct road{\n\tint nx;\n\tint dis;\n\tint lim;\n};\nvector<road> rd[30];\nset<pair<int,pair<int,int> > > visited;\ndouble tbl[30][30][30];\nint n, m, s, g;\n\nint main(){\n\twhile(cin>>n>>m, n||m){\n\t\tcin>>s>>g; s--, g--;\n\t\tvisited.clear();\n\t\trep(i, 30)rep(j, 30)rep(k, 30)tbl[i][j][k] = INF;\n\t\trep(i, 30)rd[i].clear();\n\t\t{\n\t\t\tint x, y, d, c; road t;\n\t\t\trep(i, m){\n\t\t\t\tcin>>x>>y>>d>>c; x--, y--;\n\t\t\t\tt.nx=y, t.dis=d, t.lim=c;\n\t\t\t\trd[x].push_back(t);\n\t\t\t\tt.nx=x;\n\t\t\t\trd[y].push_back(t);\n\t\t\t}\n\t\t}\n\t\tvisited.insert(mp3(s, s, 0));\n\t\ttbl[s][s][0] = 0;\n\t\t\n\t\tbool f = 1;\n\t\twhile(f){\n\t\t\tf = 0;\n\t\t\tforeach(i, visited){\n\t\t\t\tint city=i->first, prev=(i->second).first, v=(i->second).second;\n\t\t\t\trep(j, rd[city].size()){\n\t\t\t\t\tif(rd[city][j].nx==prev)continue;\n\t\t\t\t\trep(dv, 3){\n\t\t\t\t\t\tif(rd[city][j].lim<v+dv || v+dv==0)continue;\n\t\t\t\t\t\tif(city==s&& prev==s && v+dv>1)continue;\n\t\t\t\t\t\tif(tbl[rd[city][j].nx][city][v+dv-1] <=\n\t\t\t\t\t\ttbl[city][prev][v]+ rd[city][j].dis/(1.0*v+dv) )continue;\n\t\t\t\t\t\ttbl[rd[city][j].nx][city][v+dv-1] = tbl[city][prev][v] +\n\t\t\t\t\t\trd[city][j].dis/(1.0*v+dv);\n\t\t\t\t\t\tvisited.insert( mp3(rd[city][j].nx, city, v+dv-1) );\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f){\n\t\t\t\t\tvisited.erase(i);\n\t\t\t\t\tgoto NEXTLOOP;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNEXTLOOP:\n\t\t\t;\n\t\t}\n\t\t//rep(i, n)rep(j, n)rep(k, 10)cout<<i<<\" \"<<j<<\" \"<<k<<\":\"<<tbl[i][j][k]<<endl;\n\t\tdouble mn = INF;\n\t\trep(i, n)if(mn>tbl[g][i][0])mn=tbl[g][i][0];\n\t\tif(mn!=INF)printf(\"%.6f\\n\", mn);\n\t\telse printf(\"unreachable\\n\");\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 6/15 8:57 ~ 920 1129\n */\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#define INF 2000000\n\nusing namespace std;\n\nstruct edge {\n  int to;\n  double cost;\n};\ntypedef pair<int, int> P;\n\nint iN;\nint iM;\nint iS;\nint iG;\nvector<edge> G[31 * 31];\ndouble d[31 * 31][31];\n\nbool input() {\n  int i, j;\n  int x, y, d, c;\n  edge e;\n\n  scanf(\"%d %d\", &iN, &iM);\n  if (iN == 0 && iM == 0)\n    return false;\n  scanf(\"%d %d\", &iS, &iG);\n\n  for (i = 0; i < (iN + 1) * 31; i++) {\n    G[i].clear();\n  }\n\n  for (i = 0; i < iM; i++) {\n    scanf(\"%d %d %d %d\", &x, &y, &d, &c);\n    for (j = 1; j <= c; j++) {\n      e.cost = (double) d / j;\n      e.to = y * 31 + j;\n      G[x * 31 + j].push_back(e);\n      G[x * 31 + j - 1].push_back(e);\n      if (j + 1 <= c)\n        G[x * 31 + j + 1].push_back(e);\n      e.to = x * 31 + j;\n      G[y * 31 + j].push_back(e);\n      G[y * 31 + j - 1].push_back(e);\n      if (j + 1 <= c)\n        G[y * 31 + j + 1].push_back(e);\n    }\n  }\n  return true;\n}\n\nvoid dijkstraQueue() {\n  int i, j;\n  priority_queue<P, vector<P> , greater<P> > que;\n\n  for (i = 0; i < (iN + 1) * 31; i++)\n    fill(d[i], d[i] + iN, INF);\n  d[iS * 31 + 0][0] = 0;\n  que.push(P(0, iS * 31 + 0));\n\n  while (!que.empty()) {\n    P p = que.top();\n    que.pop();\n    int v = p.second;\n    //printf(\"%d %d\\n\", v / 31, v % 31);\n    for (j = 0; j < iN; j++) {\n      if (d[v][j] < p.first)\n        continue;\n      for (i = 0; i < (int) G[v].size(); i++) {\n        edge e = G[v][i];\n        //printf(\"%f\\n\", e.cost);\n        if (d[e.to][v / 31] > d[v][j] + e.cost) {\n          d[e.to][v / 31] = d[v][j] + e.cost;\n          que.push(P(d[e.to][v / 31], e.to));\n        }\n      }\n    }\n  }\n}\n\nvoid output() {\n  int i;\n  double out;\n  out = d[(iG - 1) * 31 + 1][1];\n  for (i = 2; i < iN; i++) {\n    out = min(out, d[(iG - 1) * 31 + 1][i]);\n  }\n  if (out == INF)\n    printf(\"unreachable\\n\");\n  else\n    printf(\"%f\\n\", out);\n}\n\nint main() {\n  while(1) {\n    if (!input()) break;\n    dijkstraQueue();\n    output();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1162&lang=jp\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n#include<iomanip>\n#include<queue>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nconst double INF = 10e+1; \n\nstruct state\n{\n\tint pos, prev, speed;\n\tdouble time;\n\tstate(int p, int pr, int sp, double t)\n\t\t:pos(p), prev(pr), speed(sp), time(t) {}\n\n\tbool operator<(const state& s) const {\n\t\treturn time > s.time;\n\t}\n};\n\nstruct edge\n{\n\tint to, cost, limit;\n\tedge(int t, int c, int l) : to(t), cost(c), limit(l) {}\n};\n\nvector<vector<edge>> graph;\ndouble dp[31][31][31];//[pos][prev][speed] = time\n\ndouble dijkstra( int s, int g )\n{\n\tdouble res=-1.0;\n\tfill_n((double *)dp, sizeof(dp) / sizeof(double), INF);\n\t\n\tpriority_queue<state> pq;\n\trep( i, graph[s].size()){\n\t\tedge e = graph[s][i];\n\t\tpq.push( state( e.to, s, 1, e.cost ) );\n\t\tdp[e.to][s][1] = e.cost;\n\t}\n\n\twhile( !pq.empty() )\n\t{\n\t\tstate st = pq.top();\n\t\tpq.pop();\n\n\t\tif( dp[st.pos][st.prev][st.speed] != st.time){\n\t\t\tcontinue;\n\t\t}\n\n\t\tif( st.pos == g && st.speed == 1){\n\t\t\tres = st.time;\n\t\t\treturn res;\n\t\t}\n\n\t\trep( i, graph[st.pos].size() )\n\t\t{\n\t\t\tedge e = graph[st.pos][i];\n\t\t\tif( e.to == st.prev ){ continue; } //Uターンは禁止\n\t\t\tREP( j, -1, 2 )\n\t\t\t{ \n\t\t\t\tif( st.speed + j > 0 && st.speed + j <= e.limit ){ \n\t\t\t\t\tdouble time = st.time + (double)e.cost / (st.speed + j);\n\t\t\t\t\tif( dp[e.to][st.pos][st.speed + j] > time){\n\t\t\t\t\t\tdp[e.to][st.pos][st.speed + j] = time;\n\t\t\t\t\t\tpq.push( state( e.to, st.pos, st.speed + j, time ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcout << setprecision(6) << fixed;\n\tint n,m,s,g;\n\twhile( cin >> n >> m, n )\n\t{\n\t\tgraph = vector<vector<edge>>( n+1 );\n\t\tcin >> s >> g;\n\t\t\n\t\tint x,y,d,c;\n\t\trep( i, m )\n\t\t{\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tgraph[x].push_back( edge(y,d,c) );\n\t\t\tgraph[y].push_back( edge(x,d,c) );\n\t\t}\n\n\t\tdouble ans = dijkstra( s, g );\n\t\tif(ans < 0){\n\t\t\tcout << \"unreachable\" << endl;\t\t\t\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define MAX 30\n#define INF 10000000.0\nstruct S{\n\tint e,s,b;\n};\n\nstruct S2{\n\tint d,c,to;\n};\n\nint main(){\n\n\tint n,m;\n\tint s,g;\n\tint x,y,d,c;\n\tint min;\n\tfloat cost[MAX+1][MAX+1][MAX+1];\n\tS point,tmp;\n\tS2 nod;\n\tvector<S2> ed[MAX+1];\n\tqueue<S> no;\n\n\twhile(1){\n\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0) break;\n\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(!ed[i].empty()) ed[i].clear();\n\t\t}\n\n\t\tfor(int i=0;i<=30;i++){\n\t\t\tfor(int j=0;j<=30;j++){\n\t\t\t\tfor(int k=0;k<=30;k++){\n\t\t\t\t\tcost[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin>>s>>g;\n\t\tpoint.e=s,point.s=0,point.b=0;\n\t\tcost[0][s][0]=0;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tnod.c=c,nod.d=d,nod.to=y;;\n\t\t\ted[x].push_back(nod);\n\t\t\tnod.to=x;\n\t\t\ted[y].push_back(nod);\n\t\t}\n\n\t\tno.push(point);\n\t\twhile(!no.empty()){\n\t\t\tpoint=no.front();\n\t\t\tno.pop();\n\t\t\tfor(int i=0;i<ed[point.e].size();i++){\n\t\t\t\tif(point.b!=ed[point.e][i].to){\n\t\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\tif(point.s+j>0&&point.s+j<=30){\n\t\t\t\t\t\t\t//if(point.s+j==1&&ed[point.e][i].to==g) cout<<cost[point.s][point.e]+((double)ed[point.e][i].d/(point.s+j))<<endl;\n\t\t\t\t\t\t\tif(ed[point.e][i].c>=point.s+j){\n\t\t\t\t\t\t\t\t//cout<<point.e<<\",\"<<point.b<<\",\"<<point.s<<\",\"<<ed[point.e][i].to<<\",\"<<cost[point.s][point.e]<<\"^^\"<<cost[point.s][point.e]+(double)ed[point.e][i].d/(point.s+j)<<endl;\n\t\t\t\t\t\t\t\tif(cost[point.s+j][ed[point.e][i].to][point.e]>cost[point.s][point.e][point.b]+((float)ed[point.e][i].d/(point.s+j))){\n\t\t\t\t\t\t\t\t\tcost[point.s+j][ed[point.e][i].to][point.e]=cost[point.s][point.e][point.b]+((float)ed[point.e][i].d/(point.s+j));\n\t\t\t\t\t\t\t\t\ttmp.e=ed[point.e][i].to;\n\t\t\t\t\t\t\t\t\ttmp.s=point.s+j;\n\t\t\t\t\t\t\t\t\ttmp.b=point.e;\n\t\t\t\t\t\t\t\t\tno.push(tmp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmin=0;\n\t\tfor(int i=1;i<=30;i++){\n\t\t\tif(cost[1][g][i]<cost[1][g][min]) min=i;\n\t\t}\n\t\tif(min==0) printf(\"unreachable\\n\");\n\t\telse printf(\"%.5f\\n\",cost[1][g][min]);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<pair<int,int>,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a2,a4;\ndouble d[31][31],a3;\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)if(d[i][j]!=1e12)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      scanf(\"%d%d%lf%d\",&a1,&a2,&a3,&a4);\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P>q;\n    d[st][0]=0;\n    P xtt;xtt.fi.fi=0,xtt.fi.se=st,xtt.se=-1;\n    q.push(xtt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.fi.se;\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=p.se)r(j,3){\n          int x=p.fi.fi+dx[j];\n          if(0<x&&x<=e.lim){\n            double t=e.dist/x+d[cur][p.fi.fi];\n            if(d[e.to][x]>t){\n              d[e.to][x]=t;\n              P xt;xt.fi.fi=x,xt.fi.se=e.to,xt.se=cur;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstruct Node{\n\tdouble time;\n\tint cur,prev,s;\n};\nbool operator<(const Node &l,const Node &r){\n\t\treturn l.time>r.time;\n}\nstruct Edge{\n\tint next,d,lim;\n};\nint main(){\n\tint n,m,s,g;\n\tNEXT:while(cin>>n>>m,n){\n\t\tcin>>s>>g,s--,g--;\n\t\tvector<vector<Edge> > e(n);\n\t\trep(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c,x--,y--;\n\t\t\tEdge t; t.d=d,t.lim=c;\n\t\t\tt.next=y,e[x].push_back(t);\n\t\t\tt.next=x,e[y].push_back(t);\n\t\t}\n\t\tpriority_queue<Node> Q;\n\t\tdouble C[30][30][31]; rep(i,30)rep(j,30)rep(k,31)C[i][j][k]=1e99;\n\t\tNode init,cnode,nnode; init.time=0,init.cur=0,init.prev=-1,init.s=0;\n\t\tQ.push(init); C[0][0][1]=0;\n\t\twhile(!Q.empty()){\n\t\t\tnnode=cnode=Q.top();Q.pop();\n\t\t\tif(cnode.cur==g&&cnode.s==1){\n\t\t\t\tcout<<cnode.time<<endl;goto NEXT;\n\t\t\t}\n\t\t\tint c=cnode.cur,sz=e[c].size();\n\t\t\tnnode.prev=c;\n\t\t\trep(i,sz)if(e[c][i].next!=cnode.prev)\n\t\t\tfor(int ns=cnode.s-1;ns<=cnode.s+1;ns++)if(0<ns&&ns<=e[c][i].lim)\n\t\t\tif(C[e[c][i].next][c][ns]>cnode.time+1.*e[c][i].d/ns){\n\t\t\t\tnnode.time=cnode.time+1.*e[c][i].d/ns,\n\t\t\t\tnnode.s=ns,\n\t\t\t\tnnode.cur=e[c][i].next;\n\t\t\t\tC[e[c][i].next][c][ns]=nnode.time,Q.push(nnode);\n\t\t\t}\n\t\t}\n\t\tcout<<\"unreachable\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n);i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(a);i>=(int)(b);--i)\n#define ALL(a) (a).begin(),(a).end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\n\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  REP(i, SZ(v)) {\n    if (i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\n\nstruct Edge {\n  int u, v, c;\n  double d;\n\n  Edge(int u, int v, double d, int c) : u(u), v(v), d(d), c(c) {}\n};\n\nstruct Elm {\n  int now, prev, v;\n  double d;\n};\n\nbool operator<(Elm e1, Elm e2) { return e1.d > e2.d; }\n\nint cnt = 0;\n\nbool solve() {\n  cnt++;\n  int n, m;\n  cin >> n >> m;\n  if (n == 0) return false;\n  int start, goal;\n  cin >> start >> goal;\n  start--;\n  goal--;\n\n  vector<vector<Edge>> g(n);\n  int ma = 1;\n  REP(i, m) {\n    int u, v, c;\n    double d;\n    cin >> u >> v >> d >> c;\n    ma = max(ma, c);\n    u--;\n    v--;\n    g[u].push_back(Edge(u, v, d, c));\n    g[v].push_back(Edge(v, u, d, c));\n  }\n/*\n  if(cnt == 17) {\n    REP(i, n) {\n      cerr << i << \":\";\n      for (auto &e: g[i]) {\n        cerr << \"{\" << e.v << \",\" << e.c << \",\" << e.d << \"}\" << \" \";\n      }\n      cerr << endl;\n    }\n  }\n  */\n\n\n  vector<vector<vector<double>>> dp(n, vector<vector<double>>(n, vector<double>(ma+1, INF)));\n\n  priority_queue<Elm> pq;\n  pq.push({start, start, 0, 0});\n  dp[start][start][0] = 0;\n  while (!pq.empty()) {\n    auto tmp = pq.top();\n    pq.pop();\n    int now = tmp.now, prev = tmp.prev, v = tmp.v;\n\n    double d = tmp.d;\n    if (dp[now][prev][v] < d - eps) continue;\n    REP(i, SZ(g[now])) {\n      int nxt = g[now][i].v;\n      if (nxt == prev) continue;\n      for (int j = -1; j <= 1; ++j) {\n        int nv = v + j;\n        if (nv <= 0 || g[now][i].c < nv) continue;\n        double diff = g[now][i].d / nv;\n        if (dp[nxt][now][nv] - eps > d + diff) {\n          dp[nxt][now][nv] = d + diff;\n          pq.push({nxt, now, nv, dp[nxt][now][nv]});\n        }\n      }\n    }\n  }\n\n\n  double ans = INF;\n  REP(i, n) {\n    chmin(ans, dp[goal][i][1]);\n  }\n\n  if (abs(ans - INF) < eps) {\n    cout << \"unreachable\" << endl;\n  } else {\n    cout << ans << endl;\n  }\n\n  return true;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (1) {\n    if (!solve()) break;\n  }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\ntypedef tuple<double, int, int, int> T;\nint n,m;\ndouble best[30][30][31];\nint dist[30][30];\nint limit[30][30];\nvoid exec()\n{\n\tcin >> n >> m;\n\tif(n==0&&m==0){\n\t\texit(0);\n\t}\n\tmemset(dist,-1,sizeof(dist));\n\tmemset(limit,-1,sizeof(limit));\n\tint start,goal;\n\tcin >> start >> goal;\n\tstart--;\n\tgoal--;\n\tfor(int i=0;i<m;i++){\n\t\tint x,y,d,c;\n\t\tcin >> x >> y >> d >> c;\n\t\tx--;\n\t\ty--;\n\t\tdist[x][y]=dist[y][x]=d;\n\t\tlimit[x][y]=limit[y][x]=c;\n\t}\n\tfill(best[0][0],best[0][0]+30*30*31,1e20);\n\tpriority_queue<T, vector<T>, greater<T> > q;\n\tq.push(T(0,start,start,0));\n\tbest[start][start][0]=0;\n\twhile(q.size())\n\t{\n\t\tdouble t=get<0>(q.top());\n\t\tint f=get<1>(q.top());\n\t\tint p=get<2>(q.top());\n\t\tint s=get<3>(q.top());\n\t\tq.pop();\n\t\tif(t>best[start][start][s])continue;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i==p)continue;\n\t\t\tfor(int ss=max(s-1,1);ss<=min(s+1,limit[f][i]);ss++){\n\t\t\t\tassert(dist[f][i]>0);\n\t\t\t\tdouble tt=t+dist[f][i]/(double)ss;\n\t\t\t\tif(tt<best[i][f][ss]){\n\t\t\t\t\tbest[i][f][ss]=tt;\n\t\t\t\t\tq.push(T(tt,i,f,ss));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble ret=1e20;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tret=min(ret,best[goal][i][1]);\n\t}\n\tif(ret==1e20){\n\t\tcout << \"unreachable\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << ret << endl;\n\t}\n}\n\nint main() {\n\tcout << setprecision(10);\n\twhile(1)exec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst double eps = 1e-12;\nconst double inf = (double)(1<<24);\nconst int size = 31;\nint n, m;\n\nclass Node {\npublic:\n  double t;\n  int v, town, p;\n  bool operator == ( const Node right ) const {\n    return t == right.t && v == right.v && town == right.town && p == right.p;\n  }\n  bool operator < ( const Node right ) const {\n    return fabs( t - right.t ) < eps ? v < right.v : t > right.t;\n  }\n  Node() {}\n  Node( double t_, int v_, int town_, int p_ = -1 ) {\n    t = t_;\n    v = v_;\n    town = town_;\n    p = p_;\n  }\n};\n\n// for dijkstra\ntypedef priority_queue <Node, vector<Node>, greater<Node> > QUEUE;\nbool P[size][size]; // path\ndouble MC[size][size]; // min cost\nint D[size][size]; // distance of path\nint L[size][size]; // speed limit of path\nint con[size][size]; // connnect\nint concnt[size];\n\n\nmap <int, int> T; // town number to index\nint TC; // the number of towns\n\nvoid reg( int town )\n{\n  if ( T.find( town ) != T.end() ) return;\n  T[town] = TC;\n  TC++;\n}\n\nvoid solve( int s_, int g_ )\n{\n  int start = T[s_], goal = T[g_];\n  if ( !P[start][goal] ) {\n    cout << \"unreachable\" << endl;\n    return;\n  }\n\n  QUEUE Q;\n  Node start_node( 0.0, 1, start, -1 );\n  Q.push( start_node );\n  MC[1][start] = 0.0;\n  \n  while ( !Q.empty() ) { \n    Node node = Q.top();\n    Q.pop();\n    double t = node.t;\n    int v = node.v;\n    int town = node.town;\n    int prev = node.p;\n\n    // cout << \"time=\" << t << \": town=\" << town << \", v=\" << v << endl;\n    if ( town == goal && v == 1 ) {\n      // cout << MC[v][town] << \",\" << t << endl;\n      printf( \"%.5f\\n\", t );\n      return;\n    }\n\n    // cout << \"test\" << endl;\n    for ( int i = 0; i < concnt[town]; i++ ) {\n      int next_town = con[town][i];\n      // debug\n      // cout << town << \" => \" << next_town << endl;\n      if ( prev != -1 && prev == next_town ) continue;\n      for ( int j = -1; j < 2; j++ ) {\n        if ( prev == -1 && j != 0 ) continue; \n        int next_v = v + j;\n        if ( next_v <= 0 || next_v > L[town][next_town] ) continue;\n\n        double next_t = t + (double)D[town][next_town] / next_v;\n        if ( next_t + eps > MC[next_v][next_town] ) continue;\n\n        Node next_node( next_t, next_v, next_town, town );\n        MC[next_v][next_town] = next_t;\n        Q.push( next_node );\n      }\n    }\n  }\n  \n  cout << \"unreachable\" << endl;\n}\n\nint main( void )\n{\n  while ( cin >> n >> m && n ) {\n    // init\n    for ( int i = 0; i < size; i++ ) {\n      T.clear();\n      TC = 0;\n      concnt[i] = 0;\n      for ( int j = 0; j < size; j++ ) {\n        P[i][j] = false;\n        MC[i][j] = inf;\n      }\n    }\n\n    // input\n    int s, g;\n    cin >> s >> g;\n    for ( int i = 0; i < m; i++ ) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      reg(x);\n      reg(y);\n      int xi = T[x];\n      int yi = T[y];\n      // cout << x << \":\" << xi << \", \" << y << \":\" << yi << endl; // debug\n      P[xi][yi] = P[yi][xi] = true;\n      D[xi][yi] = D[yi][xi] = d;\n      L[xi][yi] = L[yi][xi] = c;\n      con[xi][concnt[xi]++] = yi;\n      con[yi][concnt[yi]++] = xi;\n    }\n\n    for ( int k = 0; k < n; k++ ) {\n      for ( int i = 0; i < n; i++ ) {\n        for ( int j = 0; j < n; j++ ) {\n          if ( !P[i][k] || !P[k][j] ) continue;\n          P[i][j] = true;\n        }\n      }\n    }\n\n    solve( s, g );\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef tuple<double, int, int, int> T2;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\ndouble dijkstra(int s, int g, vector<vector<T>> &G){\n    vector<vector<vector<double>>> dist(40, vector<vector<double>>(40, vector<double>(40, INF)));\n    priority_queue<T2, vector<T2>, greater<T2>> que;\n    dist[s][35][0] = 0;\n    que.push(T2(0, s, 35, 0));\n\n    while(!que.empty()){\n        double cdist;\n        int cv, pv, pvel;\n        tie(cdist, cv, pv, pvel) = que.top();\n        que.pop();\n        \n        for(auto x : G[cv]){\n            int nv, ndist, nlim;\n            tie(nv, ndist, nlim) = x;\n\n            if(nv == pv) continue;\n\n            for(int i=-1; i<=1; i++){\n                int nvel = pvel + i;\n                if(nvel <= 0) continue;\n                if(nlim < nvel) continue;\n                \n                if(dist[cv][pv][pvel] + 1. * ndist / nvel < dist[nv][cv][nvel]){\n                    dist[nv][cv][nvel] = dist[cv][pv][pvel] + 1. * ndist / nvel;\n                    que.push(T2(dist[nv][cv][nvel], nv, cv, nvel));\n                }\n            }\n        }\n    }\n\n    double ans = INF;\n    for(int i=0; i<=30; i++){\n        ans = min(ans, dist[g][i][1]);\n    }\n\n    return ans;\n}\n\nint main(){\n    while(1){\n        int n, m; cin>>n>>m;\n        if(n == 0) return 0;\n        int s, g; cin>>s>>g;\n        s--, g--;\n        vector<vector<T>> G(n);\n        for(int i=0; i<m; i++){\n            int x, y, d, c; cin>>x>>y>>d>>c;\n            x--, y--;\n            G[x].push_back(T(y, d, c));\n            G[y].push_back(T(x, d, c));\n        }\n\n        double ans = dijkstra(s, g, G);\n        if(ans == INF){\n            cout << \"unreachable\" << endl;\n        }\n        else{\n            cout << fixed << setprecision(8) << ans << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define  range(i, l, r) for (int i = (int)(l); i < (int)(r); (i) += 1)\n#define rrange(i, l, r) for (int i = (int)(r) - 1; i >= (int)(l); (i) -= 1)\n\n#define  whole(f, x, ...) ([&](decltype((x)) container) { return (f)(  begin(container),  end(container), ## __VA_ARGS__); })(x)\n#define rwhole(f, x, ...) ([&](decltype((x)) container) { return (f)( rbegin(container), rend(container), ## __VA_ARGS__); })(x)\n\n#define debug(x) cerr << \"(\" << __LINE__ << \")\" << #x << \": \" << (x) << endl\n\nusing i32 = int;\nusing u32 = unsigned int;\nusing i64 = long long;\nusing u64 = unsigned long long;\n\n// constexpr i32 mod   = 998244353;\nconstexpr i32 mod   = 1e9 + 7;\nconstexpr i32 inf   = 1001001001;\nconstexpr i64 infll = 1001001001001001001ll;\n\nconstexpr int dx[] = {0, -1, 1, 0, -1, 1, -1, 1};\nconstexpr int dy[] = {-1, 0, 0, 1, -1, -1, 1, 1};\n\nstruct IoSetup { IoSetup(int x = 15){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(x); cerr << fixed << setprecision(x); } } iosetup;\n\ntemplate <typename T = i64> T input() { T x; cin >> x; return x; }\n\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { range(i, 0, v.size()) { os << v[i] << (i + 1 != v.size() ? \" \" : \"\"); } return os; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\n\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\n\ntemplate <typename T> vector<T> make_vector(size_t a, T b) { return vector<T>(a, b); }\ntemplate <typename... Ts> auto make_vector(size_t a, Ts... ts) { return vector<decltype(make_vector(ts...))>(a, make_vector(ts...)); }\n\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// }}}\n\nvoid solver() {\n    struct edge {\n        int to, length, ceil;\n\n        edge() {}\n        edge(int to, int length, int ceil) : to(to), length(length), ceil(ceil) {}\n    };\n\n    int n, m;\n    \n    while (cin >> n >> m, n) {\n        int s, g;\n        cin >> s >> g;\n\n        auto G = make_vector(n + 1, 0, edge());\n        range(i, 0, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n\n            G[x].push_back(edge(y, d, c));\n            G[y].push_back(edge(x, d, c));\n        }\n\n        auto dist = make_vector(31, 31, 31, double(inf));\n\n        //                    dist                a -> b      v\n        using pqtype = pair< double, pair< pair< int, int >, int > >;\n        priority_queue<pqtype, vector<pqtype>, greater<pqtype>> pq;\n        pq.emplace(0, make_pair(make_pair(0, s), 0));\n        dist[0][s][0] = 0;\n\n        while (!pq.empty()) {\n            auto p = pq.top();\n            pq.pop();\n\n            double fst;\n            pair< pair< int, int >, int > snd;\n\n            tie(fst, snd) = p;\n            int a, b, v;\n            pair< int, int > pp;\n            tie(pp, v) = snd;\n            tie(a, b) = pp;\n\n            if (dist[a][b][v] < fst) continue;\n\n            for (auto e: G[b]) {\n                if (e.to == a) continue;\n                auto able = [&](int v) {\n                    return v > 0 && v <= e.ceil;\n                };\n\n                range(nv, v - 1, v + 2) {\n                    if (able(nv) && dist[b][e.to][nv] > fst + (double(e.length) / (nv))) {\n                        dist[b][e.to][nv] = fst + (double(e.length) / (nv));\n                        pq.emplace(dist[b][e.to][nv], make_pair(make_pair(b, e.to), nv));\n                    }\n                }\n            }\n        }\n\n        double ans = inf;\n        range(a, 0, 31) chmin(ans, dist[a][g][1]);\n\n        if (ans + 1 > inf) {\n            cout << \"unreachable\" << endl;\n        } else {\n            cout << ans << endl;\n        }\n    }\n}\n\nsigned main(int argc, char *argv[]) {\n    solver();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <functional>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\nstruct ed{int a,b;};\ntypedef pair<int,ed> P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a3,a2,a4;\ndouble d[31][31];\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)if(d[i][j]!=1e12)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      scanf(\"%d%d%d%d\",&a1,&a2,&a3,&a4);\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P,vector<P>, function<bool(P,P)>>q([](P a,P b){return P.fi<P.se});\n    d[st][0]=0;\n    P xtt;xtt.fi=0,xtt.se.a=st,xtt.se.b=-1;\n    q.push(xtt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.se.a;\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=p.se.b)r(j,3){\n          int x=p.fi+dx[j];\n          if(0<x&&x<=e.lim){\n            double t=e.dist/x+d[cur][p.fi];\n            if(d[e.to][x]>t){\n              d[e.to][x]=t;\n              P xt;xt.fi=x,xt.se.a=e.to,xt.se.b=cur;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\nconst double INF = 1e10;\n\nstruct Edge{\n  int cost, to, c;\n  Edge(int to, int cost, int c):\n    to(to), cost(cost), c(c) {}\n};\n\ndouble dijkstra(int s, int g, vector< vector<Edge> > &G){\n  int n = G.size();\n  vector< vector<double> > D(n,vector<double>(30,INF));\n  priority_queue< tuple<double,int,int,int> > wait;\n  wait.emplace(0,0,s,-1);//time, v, cur, from\n  while(!wait.empty()){\n    double t = -get<0>(wait.top());\n    int v = get<1>(wait.top()) + 1,\n      cur = get<2>(wait.top()), from = get<3>(wait.top());\n    wait.pop();\n    if(from != -1 && t >= D[cur][v-1]) continue;\n    D[cur][v-1] = t;\n    for(int i = 0; i < G[cur].size(); ++i){\n      int to = G[cur][i].to, d = G[cur][i].cost, c = G[cur][i].c;\n      if(to == from) continue;\n      if(from != -1 && v+1 <= c && D[to][v] > t + (double)d/(v+1))\n        wait.emplace(-t-(double)d/(v+1), v, to, cur);\n      if(v <= c && D[to][v-1] > t + (double)d/v)\n        wait.emplace(-t-(double)d/v, v-1, to, cur);\n      if(v > 1 && v-1 <= c && D[to][v-2] > t + (double)d/(v-1))\n        wait.emplace(-t-(double)d/(v-1), v-2, to, cur);\n    }\n  }\n  return D[g][0];\n}\n\nint main(){\n  int n, m;\n  while(cin >> n >> m, n){\n    int s, g;\n    cin >> s >> g;\n    --s;\n    --g;\n    int x, y, d, c;\n    vector< vector<Edge> > G(n);\n    for(int i = 0; i < m; ++i){\n      cin >> x >> y >> d >> c;\n      --x;\n      --y;\n      G[x].emplace_back(y,d,c);\n      G[y].emplace_back(x,d,c);\n    }\n    double ans = dijkstra(s,g,G);\n    if(ans >= INF) cout << \"unreachable\" << endl;\n    else printf(\"%.12f\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int v[2];\n    double d, c;\n    Edge() {}\n    Edge(int v1, int v2, double d, double c) :\n        v{v1, v2}, d(d), c(c) {}\n};\nbool operator<(const Edge &e1, const Edge &e2) {\n    return e1.c >= e2.c;\n}\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nconst double INF = 1e8;\n\ndouble MinimumTime(const int start, const int goal, const Graph &g) {\n    const int n = g.size();\n    vector<vector<vector<double>>> tm(n,\n                                      vector<vector<double>>(n, vector<double>(31, INF))); // tm[前の頂点][現在の頂点][速度]\n\n    for (int v = 0; v < n; ++v) tm[v][start][1] = 0.0;\n\n    // 前の頂点，現在の頂点，速度，経過時間\n    priority_queue<Edge> que;\n    for (const auto &e : g[start]) {\n        que.push(Edge(start, e.v[1], 1, e.d));\n        tm[start][e.v[1]][1] = e.d;\n    }\n\n    while (!que.empty()) {\n        int prev = que.top().v[0], cur = que.top().v[1];\n        double velocity = que.top().d, elapsed = que.top().c;\n        que.pop();\n\n        if (tm[prev][cur][velocity] < elapsed) continue;\n\n        for (const auto &e : g[cur]) {\n            if (e.v[1] == prev) continue;\n\n            for (int add = -1; add <= 1; ++add) {\n                const double nxt_velocity = velocity + add;\n\n                if (nxt_velocity <= 0.0 || e.c < nxt_velocity) continue;\n\n                double tmp_tm = elapsed + e.d / nxt_velocity;\n                if (tmp_tm < tm[e.v[0]][e.v[1]][nxt_velocity]) {\n                    tm[e.v[0]][e.v[1]][nxt_velocity] = tmp_tm;\n                    que.push(Edge(cur, e.v[1], nxt_velocity, tmp_tm));\n                }\n            }\n        }\n    }\n\n    double res = INF;\n    for (int v = 0; v < n; ++v) res = min(res, tm[v][goal][1]);\n    return (INF <= res) ? -1.0 : res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(8) << setiosflags(ios::fixed);\n\n    int n, m, s, g, x, y, d, c;\n\n    while (cin >> n >> m, n) {\n        cin >> s >> g;\n\n        Graph graph(n);\n        for (int i = 0; i < m; ++i) {\n            cin >> x >> y >> d >> c;\n            graph[x - 1].emplace_back(Edge(x - 1, y - 1, d, c));\n            graph[y - 1].emplace_back(Edge(y - 1, x - 1, d, c));\n        }\n\n        double time = MinimumTime(s - 1, g - 1, graph);\n        if (time < 0.0) cout << \"unreachable\\n\";\n        else cout << time << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000.0\nusing namespace std;\nstruct state { int n, v, l; double t; };\n\nint N, M, S, G;\nvector<int> T[31], D[31], C[31];\nint vd[3] = { -1, 0, 1 };\ndouble dp[31][51];\n\nclass Compare {\npublic:\n  bool operator() (struct state a, struct state b) {\n    return a.t > b.t;\n  }\n};\n\nint main(void) {\n  while(cin >> N >> M, N) {\n    cin >> S >> G;\n    REP(i, 0, 30) {\n      T[i].clear();\n      D[i].clear();\n      C[i].clear();\n    }\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      T[x].push_back(y); D[x].push_back(d); C[x].push_back(c);\n      T[y].push_back(x); D[y].push_back(d); C[y].push_back(c);\n    }\n\n    REP(i, 1, N) REP(j, 0, 50) dp[i][j] = INF;\n\n    priority_queue<struct state, vector<struct state>, Compare> q;\n    struct state first = { S, 0, -1, 0.0 };\n    q.push(first);\n\n    while(!q.empty()) {\n      struct state c = q.top();\n      q.pop();\n\n      // cout << c.n << \" \" << c.v << \" \" << c.t << endl;\n\n      dp[c.n][c.v] = min(dp[c.n][c.v], c.t);\n      if(c.n == G && c.v == 1) break;\n\n      for(int i = 0; i < T[c.n].size(); i++) {\n        if(T[c.n][i] == c.l) continue;\n        REP(j, 0, 3) {\n          int v = c.v + vd[j];\n          if(v <= 0 || C[c.n][i] < v) continue;\n          double t = c.t + ((double) D[c.n][i] / v);\n          struct state n = { T[c.n][i], v, c.n, t };\n          if(n.t < dp[n.n][n.v]) q.push(n);\n        }\n      }\n    }\n\n    if(dp[G][1] < INF) printf(\"%.6f\\n\", dp[G][1]);\n    else cout << \"unreachable\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <iostream>\nusing namespace std;\n//#define DEBUG\nstruct Path{\n    int city;\n    double cost;\n    int v;\n    int pre;\n    Path(int pr,int ci,double co,int sp):pre(pr),city(ci),cost(co),v(sp){}\n\n    bool operator>(const Path &b) const{\n        return cost<b.cost;\n    }\n\n    bool operator<(const Path &b) const{\n        return !this->operator>(b);\n    }\n};\npriority_queue<Path> heap;\ndouble dp[31][31][31];\nint map[31][31],lim[31][31];\nint n,m,s,g;\nint main(){\n    #ifdef DEBUG\n        freopen(\"in.txt\",\"r\",stdin);\n    #endif\n    bool p = 0;\n    while(scanf(\"%d%d\",&n,&m)&& n ){\n        memset(map,-1,sizeof(map));\n        bool visited[31][31][31] = {false};\n        for(int i=0;i<31;i++)\n            for(int j=0;j<31;j++)\n                for(int k=0;k<31;k++)\n                    dp[i][j][k] = 1e9;\n        scanf(\"%d%d\",&s,&g);\n        for(int i=0;i<m;i++){\n            int v,w;\n            scanf(\"%d%d\",&v,&w);\n            scanf(\"%d%d\",map[v]+w,lim[v]+w);\n            map[w][v]=map[v][w];lim[w][v]=lim[v][w];\n        }\n        heap.push(Path(0,s,0.0,0));\n        dp[0][s][0]=0.0;\n        while(!heap.empty()){\n            int city = heap.top().city;\n            int v = heap.top().v;\n            int pre = heap.top().pre;\n            heap.pop();\n\n            if(visited[city][v][pre]) continue;\n            else visited[city][v][pre] = true;\n\n            for(int i=-1;i<=1;i++){\n                if(v+i>0){\n                    for(int j=1;j<=n;j++){\n                        if(j==pre) continue;\n                        if(map[j][city]!=-1&&lim[j][city]>=v+i&&!visited[j][v+i][city]){\n                            if(dp[city][j][v+i]>=dp[pre][city][v]+map[city][j]/(double)(v+i)){\n                                dp[city][j][v+i]=dp[pre][city][v]+map[city][j]/(double)(v+i);\n                                heap.push(Path(city,j,dp[city][j][v+i],v+i));\n                            }\n                        }\n\n                    }\n                }\n            }\n        }\n        double min = 1e9;\n        for(int i=1;i<31;i++) min = min<dp[i][g][1]?min:dp[i][g][1];\n        if(min==1e9)printf(\"unreachable\\n\");\n        else printf(\"%.5lf\\n\",min);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000.0\nusing namespace std;\n// struct state { int n, v, l; double t; };\n\n// int N, M, S, G;\n// vector<int> T[31], D[31], C[31];\n// int vd[3] = { -1, 0, 1 };\n// double dp[31][51];\n//\n// class Compare {\n// public:\n//   bool operator() (struct state a, struct state b) {\n//     return a.t > b.t;\n//   }\n// };\n\nint main(void) {\n  // while(cin >> N >> M, N) {\n  //   cin >> S >> G;\n  //   REP(i, 0, 30) {\n  //     T[i].clear();\n  //     D[i].clear();\n  //     C[i].clear();\n  //   }\n  //   REP(i, 1, M) {\n  //     int x, y, d, c; cin >> x >> y >> d >> c;\n  //     T[x].push_back(y); D[x].push_back(d); C[x].push_back(c);\n  //     T[y].push_back(x); D[y].push_back(d); C[y].push_back(c);\n  //   }\n  //\n  //   REP(i, 1, N) REP(j, 0, 50) dp[i][j] = INF;\n  //\n  //   priority_queue<struct state, vector<struct state>, Compare> q;\n  //   struct state first = { S, 0, -1, 0.0 };\n  //   q.push(first);\n  //\n  //   while(!q.empty()) {\n  //     struct state c = q.top();\n  //     q.pop();\n  //\n  //     // cout << c.n << \" \" << c.v << \" \" << c.t << endl;\n  //\n  //     if(dp[c.n][c.v] <= c.t) continue;\n  //     dp[c.n][c.v] = min(dp[c.n][c.v], c.t);\n  //     if(c.n == G && c.v == 1) break;\n  //\n  //     for(int i = 0; i < T[c.n].size(); i++) {\n  //       if(T[c.n][i] == c.l) continue;\n  //       REP(j, 0, 3) {\n  //         int v = c.v + vd[j];\n  //         if(v <= 0 || C[c.n][i] < v) continue;\n  //         double t = c.t + ((double) D[c.n][i] / v);\n  //         struct state n = { T[c.n][i], v, c.n, t };\n  //         if(n.t < dp[n.n][n.v]) q.push(n);\n  //       }\n  //     }\n  //   }\n  //\n  //   if(dp[G][1] < INF) printf(\"%.6f\\n\", dp[G][1]);\n  //   else cout << \"unreachable\" << endl;\n  // }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\nint n,m,s,g;\ndouble d[40][40][40];\n\nint main(){\n  int inx,iny,ind,inc;\n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n\n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=0;i<31;i++)for(int j=0;j<31;j++)for(int k=0;k<31;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n    \n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int src,dst;\n    double cost;\n    Edge(int s,int d,double c) : src(s), dst(d), cost(c) {;}\n};\n\nbool operator<(const Edge &e,const Edge &f) {\n    return (e.cost != f.cost) ? e.cost > f.cost : e.src < f.src;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nconst double inf = 1e9;\n\nvoid dijkstra(Graph &g,int s,vector<double> &dist,vector<int> &prev) {\n    const int n = g.size();\n    dist.assign(n,inf);\n    prev.assign(n,-1);\n    dist[s] = 0;\n\n    priority_queue<Edge> q;\n    q.push(Edge(-2,s,0));\n    while(!q.empty()) {\n        Edge e = q.top(); q.pop();\n        if(prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n        for(int i=0; i<g[e.dst].size(); ++i) {\n            double di = e.cost + g[e.dst][i].cost;\n            int dd = g[e.dst][i].dst;\n            if(dist[dd] > di) {\n                dist[dd] = di;\n                q.push(Edge(e.dst,dd,di));\n            }\n        }\n    }\n}\n\nint main() {\n\n    int n,m,x,y,d,s,goal,c;\n    while(cin>>n>>m, n|m) {\n        cin>>s>>goal;\n        s--,goal--;\n        Graph g(32*n);\n        for(int i=0; i<m; ++i) {\n            cin>>x>>y>>d>>c;\n            x--,y--;\n            for(int i=1; i<32; ++i) {\n                g[x*32+i].push_back(Edge(x*32+i,y*32+i,(double)d/i));\n                g[y*32+i].push_back(Edge(y*32+i,x*32+i,(double)d/i));\n                if(i > 1) {\n                    g[x*32+i].push_back(Edge(x*32+i,y*32+i-1,(double)d/(i-1)));\n                    g[y*32+i].push_back(Edge(y*32+i,x*32+i-1,(double)d/(i-1)));\n                }\n                if(i < c) {\n                    if(x != s || i > 1) g[x*32+i].push_back(Edge(x*32+i,y*32+i+1,(double)d/(i+1)));\n                    if(y != s || i > 1) g[y*32+i].push_back(Edge(y*32+i,x*32+i+1,(double)d/(i+1)));\n                }\n            }\n        }\n\n        for(int i=0; i<n; ++i) {\n            g[i*32].push_back(Edge(i*32,i*32+1,0));\n        }\n\n        vector<double> dist(32*n);\n        vector<int> prev(32*n);\n        dijkstra(g,s*32,dist,prev);\n\n        for(int i=0; i<n; ++i) {\n            for(int j=0; j<32; ++j) {\n//                cout<<i<<\" \"<<j<<\" \"<<dist[i*32+j]<<endl;\n                ;\n            }\n        }\n        if(dist[goal*32+1] == inf) {\n            cout<<\"unreachable\"<<endl;\n        }else{\n            printf(\"%.5f\\n\", dist[goal*32+1]);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<functional>\n \n \n#define rep(i,n) for(int i=0;i<(n);i++)\n \nusing namespace std;\nconst int INF = 100000000;\ntypedef pair<int,int> P;\n\nint n,m;\n\nstruct edge\n{\n\t//どこから来た,コスト,速度制限\n\tint to,cost,ub;\n\tedge(int to,int cost,int ub) {\n\t\tthis->to = to;\n\t\tthis->cost = cost;\n\t\tthis->ub = ub;\n\t}\n};\n\nvector<edge> G[103];\nint s,g;\ndouble dist[103][103][33];\n\ntypedef pair<double,int> PD;\ntypedef pair<PD,P> PP;\n\ndouble dijkstra() {\n\trep(i,103) rep(j,103) rep(k,33) dist[i][j][k]=INF;\n\tdist[s][0][1]=0;\n\n\t//最短距離 頂点 前の頂点 今の速さ\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(PD(0,s),P(0,1)));\n\n\twhile (!que.empty())\n\t{\n\t\tPP pp = que.top(); que.pop();\n\t\tint v = pp.first.second;\n\n\t\tint prev = pp.second.first;\n\t\tint u = pp.second.second;\n\n\t\tif(dist[v][u][prev] < pp.first.first) continue;\n\n\t\trep(i,G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tfor(int j=-1;j<=1;j++) {\n\t\t\t\tif(j+u<=0 || u+j > e.ub) continue;\n\n\t\t\t\tif(dist[e.to][v][u+j] > dist[v][prev][u] + (1.0*e.cost/(u+j))) {\n\t\t\t\t\tdist[e.to][v][u+j] = dist[v][prev][u] + (1.0*e.cost/(u+j));\n\t\t\t\t\tque.push(PP(PD(dist[e.to][v][u+j],e.to),P(v,u+j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tdouble ans=INF;\n\trep(i,103) ans=min(ans,dist[g][i][1]);\n\n\treturn ans;\n\t\n}\n\nvoid solve() {\n\trep(i,103) G[i].clear();\n\tcin>>s>>g;\n\trep(i,m) {\n\t\tint x,y,d,c;\n\t\tcin>>x>>y>>d>>c;\n\t\tG[x].push_back(edge(y,d,c));\n\t\tG[y].push_back(edge(x,d,c));\n\t}\n\n\tdouble ans;\n\tans = dijkstra();\n\tif(ans==INF) {\n\t\tcout<<\"unreachable\"<<endl;\n\t}\n\telse\n\t{\n\t\tcout<<ans+1.0<<endl;\n\t}\n\n\n}\n\nint main() {\n\twhile (cin>>n>>m)\n\t{\n\t\tif(n+m==0) return 0;\n\t\tsolve();\n\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__\",\", __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000123456789LL\n\nvoid solve(int n, int m){\n  int s,t;\n  cin>>s>>t;\n  s--;t--;\n  vector<vector<pair<int,double>>> vec(n*n*31 + 2);\n  // (f*n+v)*31 + V : ??´??????f??§v??????????????????V\n\n  rep(i,m){\n    int a,b,c; double d;\n    cin>>a>>b>>d>>c;\n    a--;b--;\n    rep(j,n)if(j!=b){\n      rep(k,31){\n        int from = (j*n+a)*31+k;\n        if(k-1>0 && k-1<=c) vec[from].pb(mp((a*n+b)*31+k-1, d/(k-1)));\n        if(k>0 && k<=c) vec[from].pb(mp((a*n+b)*31+k, d/k));\n        if(k+1>0 && k+1<=c) vec[from].pb(mp((a*n+b)*31+k+1, d/(k+1)));\n      }\n    }\n  }\n\n  int from = n*n*31, dest = from+1;\n\n  rep(i,n) vec[from].pb(mp((i*n+s)*31+0, 0));\n  rep(i,n) vec[(i*n+t)*31+1].pb(mp(dest, 0));\n\n  // dijkstra\n  vector<double> d(n*n*31+2, INF);\n  d[from] = 0;\n  typedef pair<double,int> P;\n  priority_queue<P, vector<P>, greater<P>> pq;\n  pq.push(mp(0,from));\n  while(!pq.empty()){\n    auto p = pq.top(); pq.pop();\n    int v = p.second; double dis = p.first;\n    if(d[v] < dis) continue;\n    for(auto &to : vec[v]){\n      double nd = dis + to.second;\n      if(d[to.first] <= nd) continue;\n      d[to.first] = nd;\n      pq.push(mp(nd, to.first));\n    }\n  }\n  if(d[dest] == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.6f\\n\", d[dest]);\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m) solve(n,m);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<functional>\n#include<iomanip>\nusing namespace std;\n\n#define MAX_N 110\n#define INF 999999999.99\n\nint N, M, S, G, a, b, c, d;\ndouble X[MAX_N][MAX_N][2];\ndouble dist[MAX_N][MAX_N];\n\npriority_queue<tuple<double, int, int, int>, vector<tuple<double, int, int, int>>, greater<tuple<double, int, int, int>>>Q;\n\ndouble dijkstra(int v) {\n\tdist[S][0] = 0;\n\tQ.push(make_tuple(0.0, S, 0, -1));\n\twhile (!Q.empty()) {\n\t\ttuple<double, int, int, int>tup = Q.top();\n\t\tQ.pop();\n\t\tdouble a1 = get<0>(tup);\n\t\tint a2 = get<1>(tup);\n\t\tint a3 = get<2>(tup);\n\t\tint a4 = get<3>(tup);\n\t\tfor (int i = 1; i <= N; i++)\n\t\t{\n\t\t\tif (i == a4 && v == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//X-1.\n\t\t\tif (a3 >= 1 && X[a2][i][1] >= a3 - 1) {\n\t\t\t\tif (dist[i][a3 - 1] > X[a2][i][0] / (a3 - 1) + a1) {\n\t\t\t\t\tdist[i][a3 - 1] = X[a2][i][0] / (a3 - 1) + a1;\n\t\t\t\t\tQ.push(make_tuple(dist[i][a3 - 1], i, a3 - 1, a2));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//X.\n\t\t\tif (a3 >= 0 && X[a2][i][1] >= a3) {\n\t\t\t\tif (dist[i][a3] > X[a2][i][0] / a3 + a1) {\n\t\t\t\t\tdist[i][a3] = X[a2][i][0] / a3 + a1;\n\t\t\t\t\tQ.push(make_tuple(dist[i][a3], i, a3, a2));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//X+1.\n\t\t\tif (a3 >= -1 && X[a2][i][1] >= a3 + 1) {\n\t\t\t\tif (dist[i][a3 + 1] > X[a2][i][0] / (a3 + 1) + a1) {\n\t\t\t\t\tdist[i][a3 + 1] = X[a2][i][0] / (a3 + 1) + a1;\n\t\t\t\t\tQ.push(make_tuple(dist[i][a3 + 1], i, a3 + 1, a2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[G][1];\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) { break; }\n\t\tcin >> S >> G;\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tX[i][j][0] = INF;\n\t\t\t\tX[i][j][1] = 0.0;\n\t\t\t\tdist[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tX[a][b][0] = c;\n\t\t\tX[b][a][0] = c;\n\t\t\tX[a][b][1] = d;\n\t\t\tX[b][a][1] = d;\n\t\t}\n\t\tdouble res1 = dijkstra(1);\n\t\tdouble res2 = dijkstra(2);\n\t\tdouble res;\n\t\tif (min(res1 / res2, res2 / res1) >= 0.985) { res = res1; }\n\t\telse { res = res2; }\n\t\tif (res > INF / 2) { cout << \"unreachable\" << endl; }\n\t\telse { cout << fixed << setprecision(15) << res << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nclass Node {\npublic:\n  int pre;\n  int now;\n  int vel;\n  double time;\n\n  Node(int p, int n, int v, double t) {\n    pre = p;\n    now = n;\n    vel = v;\n    time = t;\n  }\n\n  bool operator<(const Node &n) const {\n    return time > n.time;\n  }\n};\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n\n    if (n == 0) {\n      break;\n    }\n\n    int s, g;\n    cin >> s >> g;\n\n    vector<vector<int> > d(n + 1), c(n + 1);\n    for (int i = 0; i <= n; i++) {\n      d[i].resize(n + 1);\n      c[i].resize(n + 1);\n      fill(d[i].begin(), d[i].end(), -1);\n      fill(c[i].begin(), c[i].end(), 0);\n    }\n\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      cin >> d[x][y] >> c[x][y];\n      d[y][x] = d[x][y];\n      c[y][x] = c[x][y];\n    }\n\n    bool f[31][31][31];\n    for (int i = 0; i < 31; i++) {\n      for (int j = 0; j < 31; j++) {\n\tfor (int k = 0; k < 31; k++) {\n\t  f[i][j][k] = false;\n\t}\n      }\n    }\n  \n    bool goal = false;\n    Node snd(0, 1, 0, 0.0);\n    priority_queue<Node> q;\n    q.push(snd);\n    while (!q.empty()) {\n      Node nd = q.top();\n      q.pop();\n      if (nd.now == g && nd.vel == 1) {\n\tgoal = true;\n\tcout << nd.time << endl;\n\tbreak;\n      }\n\n      if (f[nd.pre][nd.now][nd.vel]) {\n\tcontinue;\n      }\n    \n      f[nd.pre][nd.now][nd.vel] = true;\n      for (int i = 1; i <= n; i++) {\n\tif (i != nd.now && d[nd.now][i] != -1) {\n\t  for (int j = -1; j <= 1; j++) {\n\t    int vel = nd.vel + j;\n\t    if (vel > 0 && vel <= c[nd.now][i]) {\n\t      Node next(nd.now, i, vel, nd.time + (double)d[nd.now][i] / vel);\n\t      q.push(next);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    if (!goal) {\n      cout << \"unreachable\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<functional>\n \n \n#define rep(i,n) for(int i=0;i<(n);i++)\n \nusing namespace std;\nconst int INF = 100000000;\ntypedef pair<int,int> P;\n\nint n,m;\n\nstruct edge\n{\n\t//どこから来た,コスト,速度制限\n\tint to,cost,ub;\n\tedge(int to,int cost,int ub) {\n\t\tthis->to = to;\n\t\tthis->cost = cost;\n\t\tthis->ub = ub;\n\t}\n};\n\nvector<edge> G[103];\nint s,g;\ndouble dist[103][103][33];\n\ntypedef pair<double,int> PD;\ntypedef pair<PD,P> PP;\n\ndouble dijkstra() {\n\trep(i,103) rep(j,103) rep(k,33) dist[i][j][k]=INF;\n\tdist[s][0][1]=1;\n\n\t//最短距離 頂点 前の頂点 今の速さ\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(PD(0,s),P(0,1)));\n\n\twhile (!que.empty())\n\t{\n\t\tPP pp = que.top(); que.pop();\n\t\tint v = pp.first.second;\n\n\t\tint prev = pp.second.first;\n\t\t//今の速度\n\t\tint u = pp.second.second;\n\n\t\t//printf(\"[debug] %f,%d,%d,%d\\n\",pp.first.first,v,prev,u);\n\n\t\t//if(dist[v][prev][u] < pp.first.first) continue;\n\n\t\trep(i,G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tfor(int j=-1;j<=1;j++) {\n\t\t\t\tif(j+u<=0 || u+j > e.ub) continue;\n\n\t\t\t\tif(dist[e.to][v][u+j] > dist[v][prev][u] + (1.0*e.cost/(u+j))) {\n\t\t\t\t\tdist[e.to][v][u+j] = dist[v][prev][u] + (1.0*e.cost/(u+j));\n\t\t\t\t\tque.push(PP(PD(dist[e.to][v][u+j],e.to),P(v,u+j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tdouble ans=INF;\n\trep(i,103) ans=min(ans,dist[g][i][1]);\n\n\treturn ans;\n\t\n}\n\nvoid solve() {\n\trep(i,103) G[i].clear();\n\tcin>>s>>g;\n\trep(i,m) {\n\t\tint x,y,d,c;\n\t\tcin>>x>>y>>d>>c;\n\t\tG[x].push_back(edge(y,d,c));\n\t\tG[y].push_back(edge(x,d,c));\n\t}\n\n\tdouble ans;\n\tans = dijkstra();\n\tif(ans==INF) {\n\t\tcout<<\"unreachable\"<<endl;\n\t}\n\telse\n\t{\n\t\tcout<<ans<<endl;\n\t}\n\n\n}\n\nint main() {\n\twhile (cin>>n>>m)\n\t{\n\t\tif(n+m==0) return 0;\n\t\tsolve();\n\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\n\n\n\nint main(){\n  int inx,iny,ind,inc;\n  double d[40][40][40];\n  int n,m,s,g;\n  int INF = 1<<29;\n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n    \n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n最初にスタート地点からでるときはスピードが１でなければならないのを忘れてた\nゴールは到着したら即終了というわけではない\nというかゴールにスピード１以外で到着しても良い（でもゴールしたいときは１でないといけない）\n*/\n\n#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<iomanip>\n#include<deque>\n#define F first\n#define S second\n#define MAX_N 32\n#define MAX_D 32\n#define INF (1<<28)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef pair<int,P> iP;\ntypedef pair<int,int> iiP;\ntypedef pair<iiP,P> PP;\ntypedef vector<vector<iP> > VViP;\nint n,m,s,g;\nVViP G;\ndouble mincost[MAX_N][MAX_N][MAX_D]; // mincost[from][to][speed]\nint sp[] = {-1,0,+1};\n\nvoid dijkstra()\n{\n\n  queue<PP> deq; // iiPP(iiP(now,pre),P(cost,speed))\n\n  \n  deq.push(PP(iiP(s,s),P(0,1)));\n\n  mincost[s][s][1] = 0; \n  double ans = INF;  \n\n  \n  while(!deq.empty())\n    {\n      PP p = deq.front(); deq.pop();\n      int now,pre;\n      double cost,speed;\n      now = p.F.F, pre = p.F.S;\n      cost = p.S.F, speed = p.S.S;\n\n      if(cost >= ans)\n\tcontinue;      \n\n      if(now == g && speed == 1)\n\t{\n\t  ans = min(ans,cost);\t\n\t  continue;\n\t}\t\n\n      for(int i=0;i<G[now].size();i++)\n\t{\n\t  iP ip = G[now][i]; // VViP -> iP(to,P(distance,limit))\n\t  int to = ip.F;\n\t  double dis,lim;\n\t  dis = ip.S.F, lim = ip.S.S;\n\t  if(pre == to)\n\t    continue;\n\n\t  for(int j=0;j<3;j++)\n\t    {\n\t      double new_speed = speed + sp[j];\n\t      if(new_speed <= 0 || new_speed > lim)\n\t\tcontinue;\n\n\t      if(now == s && pre == s && new_speed != 1)\n\t\tcontinue;\n\n\t      if(mincost[now][to][(int)new_speed] > cost + (double)dis/new_speed)\n\t\t{\n\t\t  mincost[now][to][(int)new_speed] = cost + (double)dis/new_speed;\n\t\t  deq.push(PP(iiP(to,now),P(mincost[now][to][(int)new_speed],new_speed)));\n\t\t}\n\t    }\n\n\t}\n\n    }\n  \n\n  if(ans == INF)\n    cout << \"unreachable\" << endl;\n  else \n    cout << setiosflags(ios::fixed) << setprecision(5) << ans << endl;\n  \n}\n\nint main()\n{\n\n  while(true)\n    {\n      cin >> n >> m;\n      if(n+m == 0)\n\tbreak;\n      G.clear();\n      G.resize(n+1);\n      rep(i,n+1)\n\trep(j,n+1)\n\t  rep(k,31)\n\t    mincost[i][j][k] = INF;\n\n      cin >> s >> g;\n      rep(i,m)\n\t{\n\t  int x,y;\n\t  double d,c;\n\t  cin >> x >> y >> d >> c;\n\t  G[x].push_back(iP(y,P(d,c)));\n\t  G[y].push_back(iP(x,P(d,c)));\n\t}\n      \n      dijkstra();\n  \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<algorithm>\n#include<cstdio>\n#include<iostream>\n#define F first\n#define S second\n#define EPS 1e-10\n#include<cmath>\nusing namespace std;\ntypedef pair<int,int> PP;\ntypedef pair<PP,int> P;\nvector<P> vec[100];\nint n,m,s,g;\ndouble d[100];\nconst double INF = 1<<30;\nvoid dijkstra(){\n  priority_queue<P,vector<P>,greater<P> > que;\n  for(int i=0;i<=n;i++)d[i] = INF;\n  d[s] = 0.0;\n  que.push(P(PP(s,0),1));\n  \n  while(!que.empty() ){\n    P p = que.top();\n     que.pop();\n     int v = p.F.F;\n\n     if(d[v] < p.F.S )continue;\n     for(int i=0;i<vec[v].size();i++){\n      P e = vec[v][i];\n      \n\tif(d[e.F.F] >  d[v]+(double)(((double)e.F.S)/((double)e.S)) && e.S >= p.S){\n\t \n\t  \n\tif(e.F.F == g && p.S == 1){\n\t  d[g] = d[v]+(double)(((double)e.F.S)/((double)p.S));\n\t}\n\telse if(e.F.F != g){\n\t  d[e.F.F] = d[v] + (double)(((double)e.F.S)/((double)p.S));\n\t\n\t  // cout<< \"now speed = \" << p.S << \", seigen speed = \" << e.S << \", now pos = \" << v << \", next pos = \" << e.F.F << \" val = \" << d[e.F.F] <<  endl;\n\t  que.push(P(PP(e.F.F,d[e.F.F]),p.S));\n\t  if(p.S-1 >= 1)que.push(P(PP(e.F.F,d[e.F.F]),p.S-1));\n\t  if(p.S+1 <= 30)que.push(P(PP(e.F.F,d[e.F.F]),p.S+1));\n\t}\n      }\n\n\t\n\n    }\n  }\n  \n}\n\n\n\nint main(){\n  int x,y,di,c;\n  while(true){\n    cin >> n >> m;\n    if(n+m == 0)break;\n    for(int i=0;i<=n;i++)vec[i].clear();\n    cin >> s >> g;\n    for(int i=0;i<m;i++){\n      cin >> x >> y >> di >> c;\n      vec[x].push_back(P(PP(y,di),c));\n      vec[y].push_back(P(PP(x,di),c));\n    }\n\n    dijkstra();\n    if(fabs(d[g]-INF) < EPS)cout << \"unreachable\" << endl;\n    else printf(\"%.5f\\n\",d[g]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nclass state {\npublic:\n  double cost;\t\t\t// 所要時間\n  int pp;                       // 前の位置\n  int np;\t\t\t// 今の位置\n  int v;\t\t\t// 速度\n  state(double _cost, int _pp, int _np, int _v) {\n    cost = _cost;\n    pp = _pp;\n    np = _np;\n    v = _v;\n  }\n  bool operator > (const state &s) const {\n    return cost > s.cost;\n  }\n};\n\nint main() {\n  int n, m;\n  while (true) {\n    cin >> n >> m;\n    if (n == 0 && m == 0) {\n      break;\n    }\n\n    int s, g;\n    cin >> s >> g;\n    s--; g--;\n    if (m == 0) {\n      std::cout << \"unreachable\" << std::endl;\n      continue;\n    }\n\n    vector <int> graph[n];\n    double cost[n][n];\n    double dist[n][n];\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      double d, c;\n      cin >> x >> y >> d >> c;\n      x--; y--;\n      graph[x].push_back(y);\n      graph[y].push_back(x);\n      cost[x][y] = c;\n      cost[y][x] = c;\n      dist[x][y] = d;\n      dist[y][x] = d;\n    }\n\n    double memo[n][n][32];\t\t// prev now v\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tfor (int k = 0; k < 32; k++) {\n\t  memo[i][j][k] = -1;\n\t}\n      }\n    }\n\n    // for (int i = 0; i < n; i++) {\n    //   std::cout << i << \":\";\n    //   for (int j = 0; j < graph[i].size(); j++) {\n    // \tstd::cout << graph[i][j] << \" \";\n    //   }\n    //   std::cout << \"\" << std::endl;\n    // }\n\n    priority_queue <state, vector<state>, greater<state> > pque;\n    pque.push(state(0, -1, s, 0));\n    while(!pque.empty()) {\n      state p = pque.top(); pque.pop();\n\n      for (int i = 0; i < graph[p.np].size(); i++) {\n\tint np = graph[p.np][i];\n        if (p.pp == np) {\n          continue;\n        }\n\tfor (int j = -1; j <= 1; j++) {\n\t  int v = p.v+j;\n\t  if (v <= 0 || v > cost[p.np][np]) {\n\t    continue;\n\t  }\n\n\t  double nt = p.cost+dist[p.np][np]/double(v);\n\n\t  if (memo[p.np][np][v] == -1 ||\n\t      memo[p.np][np][v] > nt) {\n\t    memo[p.np][np][v] = nt;\n\t    pque.push(state(nt, p.np, np, v));\n\t  }\n\t}\n      }\n    }\n\n    double ans = -1;\n    for (int i = 0; i < n; i++) {\n      if (memo[i][g][1] == -1) {\n        continue;\n      }\n      if (ans == -1 ||\n          memo[i][g][1] < ans) {\n        ans = memo[i][g][1];\n      }\n    }\n\n    if (ans == -1) {\n      std::cout << \"unreachable\" << std::endl;\n    }else {\n      printf(\"%.5f\\n\", ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint n,m,s,g;\nmap<int, vector<TIII> > r;\nmap<TIII, double> v;\n\nint main(){\n\twhile(1){\n\t\tdouble ret = -1.0;\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)return 0;\n\t\tcin>>s>>g;\n\t\tr.clear();\n\t\tv.clear();\n\t\tREP(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tr[x].PB(MT(y,d,c));\n\t\t\tr[y].PB(MT(x,d,c));\n\t\t}\n\t\tpriority_queue<pair<double, TIII > , vector<pair<double, TIII > >, greater<pair<double, TIII > > > q;\n\t\tq.push(MP(0.0,MP(s, MP(-1, 0))));\n\t\twhile(!q.empty()){\n\t\t\tpair<double, TIII > tmp = q.top();\n\t\t\tq.pop();\n\t\t\tif(EXIST(v, tmp.second))continue;\n\t\t\tif(tmp.second.first == g && tmp.second.second.second == 1){\n\t\t\t\tret = tmp.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv[tmp.second]=tmp.first;\n\t\t\tint city = tmp.second.first;\n\t\t\tint speed = tmp.second.second.second;\n\t\t\tint pre = tmp.second.second.first;\n\t\t\tdouble now = tmp.first;\n\t\t\tREP(i, r[city].size()){\n\t\t\t\tTIII f = r[city][i];\n\t\t\t\tif(f.first == pre)continue;\n\t\t\t\tFOR(sp, speed-1, speed+2){\n\t\t\t\t\tif(sp<1)continue;\n\t\t\t\t\tif(f.second.second >= sp && sp > 0){\n\t\t\t\t\t\tif(!EXIST(v, MP(f.first, MP(city, sp)))){\n\t\t\t\t\t\t\tq.push(MP(now+(f.second.first*1.0)/(sp*1.0), MP(f.first, MP(city, sp))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ret < 0.0)cout << \"unreachable\" <<endl;\n\t\telse printf(\"%.6f\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 30;\nconst double EPS = 1E-9;\n\nint n, m, s, g;\nstruct edge{\n\tint to;\n\tint cost;\n\tint limit;\n};\nvector<edge> G[101];\ndouble t[101][31];\n\nint main(){\n\twhile(cin >> n >> m && (n || m)){\n\t\tcin >> s >> g;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint from, to;\n\t\t\tedge e;\n\t\t\tcin >> from >> to >> e.cost >> e.limit;\n\t\t\te.to = to;\n\t\t\tG[from].push_back(e);\n\t\t\te.to = from;\n\t\t\tG[to].push_back(e);\n\t\t}\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tfill(t[i], t[i] + 101, -1.0);\n\t\t}\n\t\tt[s][0] = 0;\n\t\tpriority_queue<pair<double, PP>, vector<pair<double, PP> >, greater<pair<double, PP> > > que;\n\t\tque.push(make_pair(0, PP(-1, P(s, 0))));\n\t\twhile(!que.empty()){\n\t\t\tpair<double, PP > ppp = que.top(); que.pop();\n\t\t\tPP pp = ppp.second;\n\t\t\tdouble tm = ppp.first;\n\t\t\tint place = pp.second.first;\n\t\t\tint v = pp.second.second;\n\t\t\tint pre = pp.first;\n\t\t\tfor(size_t i = 0; i < G[place].size(); i++){\n\t\t\t\tedge e = G[place][i];\n\t\t\t\tif(e.to == pre) continue;\n\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\tif(v + j > 0 && v + j <= 30 && v + j <= e.limit){\n\t\t\t\t\t\tif(t[e.to][v+j] < 0 || t[e.to][v+j] > t[place][v] + (double)e.cost / (v+j)){\n\t\t\t\t\t\t\tt[e.to][v+j] = t[place][v] + (double)e.cost / (double)(v+j);\n\t\t\t\t\t\t\tque.push(make_pair(t[e.to][v+j], PP(place, P(e.to, v+j))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t[g][1] < 0) cout << \"unreachable\" << endl;\n\t\telse cout << fixed << setprecision(6) << t[g][1] << endl;\n\t\tfor(int i = 0; i < 101; i++) G[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<pair<int,int>,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a2,a4;\ndouble d[31][31],a3;\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      scanf(\"%d%d%lf%d\",&a1,&a2,&a3,&a4);\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P>q;\n    d[st][0]=0;\n    P xt;xt.fi.fi=0,xt.fi.se=st,xt.se=-1;\n    q.push(xt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.fi.se;\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=p.se)r(j,3){\n          int x=p.fi.fi+dx[j];\n          if(0<x&&x<=e.lim){\n            double t=e.dist/x+d[cur][p.fi.fi];\n            if(d[e.to][x]>t){\n              d[e.to][x]=t;\n              xt.fi.fi=x,xt.fi.se=e.to,xt.se=cur;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\n#include <iomanip>\n#include <ctime>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> edge;\ntypedef pair<int, P> PP;\ntypedef pair<double, PP> PPP;\n\nvector<edge> G[100];\ndouble memo[40][40][40];\ndouble need[200][40];\n priority_queue<PPP, vector<PPP>,greater<PPP> > que;\n\nint main(){\n  int n, m;\n  int s, g;\n  for(int i = 0; i < 200; i++){\n    for(int j = 1; j < 40; j++) need[i][j] = (double)i / j;\n  }\n  while(cin >> n >> m && (n || m)){\n    scanf(\"%d%d\",&s,&g);\n    while(!que.empty()) que.pop();\n    fill(&memo[0][0][0], &memo[30][30][30]+1, 1e10);\n    for(int i = 0; i < m; i++){\n      int x1,y1,d,c;\n      scanf(\"%d%d%d%d\", &x1, &y1, &d, &c);\n      G[x1].push_back(edge(y1, P(d, c)));\n      G[y1].push_back(edge(x1, P(d, c)));\n    }\n    memo[s][0][32] = 0;\n   \n    que.push(PPP(memo[s][0][32], PP(0, P(s, 32))));\n    bool ok = false;\n\n    while(!que.empty()){\n      PPP ppp = que.top();\n      que.pop();\n\n      double dis = ppp.first;\n      int v = ppp.second.first;\n      int pos = ppp.second.second.first;\n      int pre = ppp.second.second.second;\n\n      if(dis > memo[pos][v][pre]) continue;\n     \n      if(pos == g && v == 1){\n\tcout << fixed << setprecision(9) << dis << endl;\n\tok = true;\n\tbreak;\n      }\n\n      for(int i = -1; i <= 1; i++){\n\tint v2 = v + i;\n\tfor(int j= 0; j < (int)G[pos].size(); j++){\n\t  int to = G[pos][j].first;\n\t  int li = G[pos][j].second.second;\n\t  int d = G[pos][j].second.first;\n\n\t  if(1 <= v2 && v2 <= li && to != pre){\n\t    if(memo[to][v2][pos] > dis + need[d][v2]){\n\t      memo[to][v2][pos] = dis + need[d][v2];\n\t      que.push(PPP(memo[to][v2][pos], PP(v2, P(to, pos))));\n\t    }\n\t  }\n\t}\n      }\n\n    }\n    if(!ok){\n      cout << \"unreachable\" << endl;\n    }\n    for(int i = 1; i <= 30; i++) G[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst double INF = 1 << 29;\n\nstruct edge {\n    int to;\n    int cost;\n    int limit;\n\n    edge() {}\n    edge(int a, int b, int c): to(a), cost(b), limit(c) {}\n};\n\nstruct state {\n    int pos;\n    double cost;\n    int speed;\n\n    state() {}\n    state(int a, double b, int c): pos(a), cost(b), speed(c) {}\n\n    bool operator < (const state& o) const {\n        return cost > o.cost;\n    }\n};\n\nint N, M, S, G;\n\nvector<edge> graph[30];\n\ndouble memo[30][31];\n\n\nbool solve() {\n    cin >> N >> M;\n    if (N+M == 0) { return false; }\n\n    for (int j = 0; j < N; ++j) { graph[j].clear(); }\n    for (int j = 0; j < N; ++j) { fill(memo[j], memo[j]+31, INF); }\n\n\n    cin >> S >> G;\n    --S; --G;\n    for (int j = 0; j < M; ++j) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        --x; --y;\n\n        graph[x].emplace_back(y, d, c);\n        graph[y].emplace_back(x, d, c);\n    }\n\n    priority_queue<state> pq;\n    pq.emplace(S, 0, 1);\n    memo[S][1] = 0;\n    while (!pq.empty()) {\n        state st = pq.top(); pq.pop();\n        if (st.cost > memo[st.pos][st.speed]) { continue; }\n\n        for (edge& e: graph[st.pos]) {\n            for (int dv = -1; dv <= 1; ++dv) {\n                if (st.pos == S && dv != 0) { continue; }\n\n                int next_speed = st.speed + dv;\n                if (next_speed <= 0 || e.limit < next_speed) { continue; }\n\n                double next_cost = st.cost + (double)e.cost / next_speed;\n                if (next_cost < memo[e.to][next_speed]) {\n                    memo[e.to][next_speed] = next_cost;\n                    pq.emplace(e.to, next_cost, next_speed);\n                }\n            }\n\n        }\n    }\n    if (fabs(memo[G][1]-INF) < 1e-7) { printf(\"unreachable\\n\"); }\n    else { printf(\"%.12f\\n\", memo[G][1]); }\n    return true;\n}\n\nint main() { for (; solve(); ); return 0; }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vd = std::vector<double>;\n\tusing v2d = std::vector<vd>;\n\tusing v3d = std::vector<v2d>;\n\t\n\tstruct Edge {\n\t\tint to, limit;\n\t\tdouble distance;\n\t};\n\tusing Edges = std::vector<std::vector<Edge>>;\n\n\tusing i3 = std::array<int, 3>;\n\tusing pdi3 = std::pair<double, i3>;\n\n\tEdges inputEdge(int n, int m)\n\t{\n\t\tEdges edge(n);\n\t\tfor (int i{}; i < m; i++)\n\t\t{\n\t\t\tint x, y, c;\n\t\t\tdouble d;\n\t\t\tscanf(\"%d%d%lf%d\", &x, &y, &d, &c);\n\t\t\tx--; y--;\n\t\t\tedge[x].push_back({y, c, d});\n\t\t\tedge[y].push_back({x, c, d});\n\t\t}\n\t\treturn std::move(edge);\n\t}\n\n\tdouble& getReference(v3d& distance, const i3& index)\n\t{\n\t\treturn distance[index[0]][index[1]][index[2]];\n\t}\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n == 0 && m == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tint s, g;\n\t\tscanf(\"%d%d\", &s, &g);\n\t\ts--; g--;\n\t\t// edge[from][i] = {to, distance, limit}\n\t\tconst Edges edge(inputEdge(n, m));\n\n\t\t// distance[頂点][来た速度][来た頂点] = 最短距離\n\t\tv3d distance(n, v2d(31, vd(n, 1e9)));\n\t\tstd::fill(distance[s][0].begin(), distance[s][0].end(), 0);\n\t\t// {距離、{頂点、来た速度、来た頂点}\n\t\tstd::priority_queue<pdi3, std::vector<pdi3>, std::greater<pdi3>> dij;\n\t\tdij.push({0, {s, 0, 0}});\n\t\twhile (!dij.empty())\n\t\t{\n\t\t\tconst double now_dist{dij.top().first};\n\t\t\tconst i3 now_vertex{dij.top().second};\n\t\t\tdij.pop();\n\t\t\tif (now_dist > getReference(distance, now_vertex))\n\t\t\t\tcontinue;\n\n\t\t\tfor (const auto& road: edge[now_vertex[0]])\n\t\t\t{\n\t\t\t\tif (road.to == now_vertex[2]) continue;\n\t\t\t\tfor (int add{-1}; add <= 1; add++)\n\t\t\t\t{\n\t\t\t\t\t// {to, velocity, from}\n\t\t\t\t\tconst i3 next_vertex{road.to, now_vertex[1] + add, now_vertex[0]};\n\t\t\t\t\tif (next_vertex[1] <= 0 || road.limit < next_vertex[1]) continue;\n\t\t\n\t\t\t\t\tconst double next_dist{now_dist + road.distance / next_vertex[1]};\n\t\t\t\t\tauto& table_dist{getReference(distance, next_vertex)};\n\t\t\t\t\tif (next_dist >= table_dist) continue;\n\n\t\t\t\t\ttable_dist = next_dist;\n\t\t\t\t\tdij.push({next_dist, next_vertex});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst double min{*std::min_element(distance[g][1].begin(), distance[g][1].end())};\n\t\tif (min == 1e9) puts(\"unreachable\");\n\t\telse printf(\"%.4lf\\n\", min);\n\t}\n\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m;\nll s, g;\n\nclass DK {\npublic:\n\tstruct edge {\n\t\tint to;\n\t\tdouble cost;\n\t\tll cap;\n\t\tedge(int _to, double _cost, ll _cap) :to(_to), cost(_cost), cap(_cap) {}\n\t};\n\n\tdouble d[110][110];\n\tvector<edge> G[110];//各頂点からの辺\n\n\tvoid dijkstra() {\n\t\trep(i, 110)rep(j, 110)d[i][j] = INF;\n\t\td[s][0] = 0;\n\n\t\ttypedef pair<pair<double, ll>, ll> PP;\n\t\tpriority_queue<PP, vector<PP>, greater<PP>> que;\n\t\tque.push({ {0, 0},s });\n\n\t\twhile (!que.empty()) {\n\t\t\tPP p = que.top();\n\t\t\tque.pop();\n\t\t\tll nn = p.second;\n\t\t\tll v = p.first.second;\n\t\t\tif (d[nn][v] < p.first.first)continue;\n\t\t\tfor (int i = 0; i < G[nn].size(); i++) {\n\t\t\t\tedge e = G[nn][i];\n\t\t\t\tFOR(j, -1, 2) {\n\t\t\t\t\tdouble nv = v + j;\n\t\t\t\t\tif (nv <= 0)continue;\n\t\t\t\t\tif (nv > e.cap)continue;\n\t\t\t\t\tif (d[e.to][(ll)nv] > d[nn][v] + e.cost / nv) {\n\t\t\t\t\t\td[e.to][(ll)nv] = d[nn][v] + e.cost / nv;\n\t\t\t\t\t\tque.push({ P(d[e.to][(ll)nv], nv),e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n};\n\nDK dk;\n\nint main() {\n\twhile (cin >> n >> m&&n + m) {\n\t\trep(i, 110)dk.G[i].clear();\n\t\tcin >> s >> g;\n\t\trep(i, m) {\n\t\t\tint x, y;\n\t\t\tll c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tdk.G[x].push_back(DK::edge(y, d, c));\n\t\t\tdk.G[y].push_back(DK::edge(x, d, c));\n\t\t}\n\t\tdk.dijkstra();\n\t\t//rep(i, n) {\n\t\t//\trep(j, 30) {\n\t\t//\t\tcout << dk.d[i + 1][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tdouble ans = dk.d[g][1];\n\t\tif ((ll)ans == INF)cout << \"unreachable\" << endl;\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<double, int, int, int> T;\n \nconst ll MOD=1e9+7;\n//const ll INF=1e18;\n\nconst double INF = 1000000.0;\n \nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\n\nstruct edge{ int to,d,c;};\n\n\n\nint n,m,s,g;\ndouble d[35][35][35];\ndouble mind;\n\nint main(){\n\twhile(true){\n\t\tcin >> n >> m;\n\t\tif(n + m == 0) break;\n\t\tcin >> s >> g;\n\t\tmind = INF;\n\t\tvector<edge> G[35];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a1,a2,a3,a4;\n\t\t\tcin >> a1 >> a2 >> a3 >> a4;\n\t\t\tedge tmp1 = {a2,a3,a4};\n\t\t\tG[a1].push_back(tmp1);\n\t\t\tedge tmp2 = {a1,a3,a4};\n\t\t\tG[a2].push_back(tmp2);\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tfor(int k = 0;k <= 31;k++){\n\t\t\t\t\td[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//queue<T> que;\n\t\tpriority_queue<T,vector<T>,greater<T> > que;\n\t\tfor(int i = 0;i < G[s].size();i++){\n\t\t\tedge e = G[s][i];\n\t\t\td[s][e.to][1] = (double) e.d;\n\t\t\tque.push(make_tuple((double)e.d,1,s,e.to));\n\t\t}\n\n\t\twhile(!que.empty()){\n\t\t\tT t = que.top(); que.pop();\n\t\t\tdouble a1 = get<0>(t);\n\t\t\tint a2 = get<1>(t),a3 = get<2>(t),a4 = get<3>(t);\n\t\t\tif(d[a3][a4][a2] < a1 || a1 > mind)continue;\n\t\t\tfor(int i = 0;i < G[a4].size();i++){\n\t\t\t\tedge e = G[a4][i];\n\t\t\t\tif(e.to == a3) continue;\n\t\t\t\tdouble tmp = (double) a1 + (double)e.d;\n\t\t\t\tif(d[a4][e.to][1] < tmp)continue;\n\t\t\t\td[a4][e.to][1] =  tmp;\n\t\t\t\tif(mind < tmp) continue;\n\t\t\t\tif(e.to == g && mind > tmp)mind = tmp;\n\t\t\t\tque.push(make_tuple(tmp,1,a4,e.to));\n\t\t\t}\n\t\t}\n\t\tif(mind == INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tfor(int k = 0;k <= 31;k++){\n\t\t\t\t\td[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < G[s].size();i++){\n\t\t\tedge e = G[s][i];\n\t\t\td[s][e.to][1] = (double) e.d;\n\t\t\tque.push(make_tuple((double)e.d,1,s,e.to));\n\t\t}\n\n\n\n\t\twhile(!que.empty()){\n\t\t\t//T t = que.front(); que.pop();\n\t\t\tT t = que.top(); que.pop();\n\t\t\tdouble a1 = get<0>(t);\n\t\t\tint a2 = get<1>(t),a3 = get<2>(t),a4 = get<3>(t);\n\t\t\tif(d[a3][a4][a2] < a1 || a1 > mind)continue;\n\t\t\tfor(int i = 0;i < G[a4].size();i++){\n\t\t\t\tedge e = G[a4][i];\n\t\t\t\tif(e.to == a3) continue;\n\t\t\t\tfor(int j = -1;j <= 1;j++){\n\t\t\t\t\tint v = a2 + j;\n\t\t\t\t\tdouble tmp = (double)( a1 + (double)e.d / (double)v);\n\t\t\t//\t\tif(a4 == 5 && e.to == 6 && v == 1) cout << \"tmp\" << tmp << \",a1\" << a1 <<endl;\n\t\t\t\t\tif(v <= 0 || v > e.c || d[a4][e.to][v] < tmp ||tmp > mind) continue;\n\t\t\t\t\td[a4][e.to][v] =  tmp;\n\t\t\t\t\tif(e.to == g && v == 1 && mind > tmp)mind = tmp;\n\t\t\t\t\tque.push(make_tuple(tmp,v,a4,e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\n\t\t}\n\t//\tcout << \"ans\" << d[4][5][2] << endl;\n\n\n\n\t\tdouble ans = INF;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tdouble tmp = d[i][g][1];\n\t\t\tif(ans > tmp) ans = tmp;\n\t\t//\tans = min(ans,d[i][g][1]);\n\t\t}\n\t\tif(ans == INF){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t//\tcout << ans << endl;\n\t\t\tprintf(\"%lf\\n\",ans);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000.0\nusing namespace std;\nstruct state { int n, v, l; double t; };\n\nint N, M, S, G;\nvector<int> T[301], D[301], C[301];\nint vd[3] = { -1, 0, 1 };\ndouble dp[31][51];\n\nclass Compare {\npublic:\n  bool operator() (struct state a, struct state b) {\n    return a.t > b.t;\n  }\n};\n\nint main(void) {\n  while(cin >> N >> M, N) {\n    cin >> S >> G;\n    REP(i, 0, 300) {\n      T[i].clear();\n      D[i].clear();\n      C[i].clear();\n    }\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      T[x].push_back(y); D[x].push_back(d); C[x].push_back(c);\n      T[y].push_back(x); D[y].push_back(d); C[y].push_back(c);\n    }\n\n    REP(i, 1, N) REP(j, 0, 50) dp[i][j] = INF;\n\n    priority_queue<struct state, vector<struct state>, Compare> q;\n    struct state first = { S, 0, -1, 0.0 };\n    q.push(first);\n\n    while(!q.empty()) {\n      struct state c = q.top();\n      q.pop();\n\n      // cout << c.n << \" \" << c.v << \" \" << c.t << endl;\n\n      dp[c.n][c.v] = min(dp[c.n][c.v], c.t);\n      if(c.n == G && c.v == 1) break;\n\n      for(int i = 0; i < T[c.n].size(); i++) {\n        if(T[c.n][i] == c.l) continue;\n        REP(j, 0, 3) {\n          int v = c.v + vd[j];\n          if(v <= 0 || C[c.n][i] < v) continue;\n          double t = c.t + ((double) D[c.n][i] / v);\n          struct state n = { T[c.n][i], v, c.n, t };\n          if(n.t < dp[n.n][n.v]) q.push(n);\n        }\n      }\n    }\n\n    if(dp[G][1] < INF) printf(\"%.6f\\n\", dp[G][1]);\n    else cout << \"unreachable\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n  \n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REP1(i,n) for(int i=1;i<(n);i++)\n#define REP2(i,d,n) for(int i=(d);i<(n);i++)\n#define RREP(i,n) for(int i=(n);i>=0;i--)\n#define CLR(a) memset((a),0,sizeof(a))\n#define MCLR(a) memset((a),-1,sizeof(a))\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n  \nusing namespace std;\n  \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI > VVI;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef pair<int,int> PII;\n  \nconst int INF = 0x3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-9;\n  \nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n  \n  \nstruct edge {\n    int to, from, cost;\n    edge(int _to, int _from, int _cost) {to = _to; from = _from; cost=_cost;}\n};\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\n  \nint maxspeed[31][31];\n  \nclass Dijkstra{\npublic:\n    int V;\n    vector<vector<edge> > G;\n    vector<vector<double> > d;\n     \n    Dijkstra(int _V){\n        V = _V;\n        G.resize(V);\n        d.resize(31);\n \n        REP(i,31){\n            d[i].resize(V);\n        }\n    }\n     \n    void add_edge(int from, int to, int cost){\n        G[from].PB(edge(to,from,cost));\n    }\n     \n    void solve(int s){\n        priority_queue<PP, vector<PP>, greater<PP> > que;\n\t\t// コスト、直前、頂点、速度\n        REP(i,31){\n            REP(j, V){\n                d[i][j] = INF;\n            }\n        }\n        d[0][s] = 0;\n\t\t// d := 速度、位置\n        que.push(PP(P(0,0),P(s,0)));\n         \n        while(!que.empty()){\n            PP p = que.top();\n            que.pop();\n            int v = p.second.first; // 現在地\n            int mv = p.second.second; // 速度\n            int old = p.first.second; // 直前\n            REP2(i,-1,2){\n                if(mv+i <= 0 || 30 < mv+i) continue;\n                if(d[mv][v] < p.first.first) continue;\n                REP(j,G[v].size()){\n                    edge e = G[v][j];\n                    if(e.to == old) continue;\n                    //cout << e.from << \":\" << e.to << \" \" << maxspeed[e.from][e.to] << \" \" << (mv+i) <<  endl;\n                    if(maxspeed[e.from][e.to] < mv+i) { continue; }\n                    if(d[mv+i][e.to] > d[mv][v] + (double)e.cost/(mv+i)){\n                        d[mv+i][e.to] = d[mv][v] + (double)e.cost/(mv+i);\n                        //cout << (mv+i) << \" - \" << e.to << \" - \" << d[mv+i][e.to] << endl;\n                        que.push(PP(P(d[mv+i][e.to],v), P(e.to,mv+i)));\n                    }\n                }\n            }\n        }\n    }\n};\n \nint main(){\n    while(true){\n        int n,m;\n         \n        cin >> n >> m;\n        Dijkstra dijkstra(n);\n        if(n==0&&m==0){\n            break;\n        }\n        REP(i,31){\n            REP(j,31){\n                maxspeed[i][j] = 0;\n            }\n        }\n \n        int s,g;\n        cin >> s >> g;\n        s--; g--;\n        REP(i,m){\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            dijkstra.add_edge(x,y,d);\n            dijkstra.add_edge(y,x,d);\n            maxspeed[x][y] = c;\n            maxspeed[y][x] = c;\n        }\n \n        dijkstra.solve(s);\n \n        if(abs(dijkstra.d[1][g]-INF) < 1e-5){\n            cout << \"unreachable\" << endl;\n        }else{\n            printf(\"%.5f\\n\",dijkstra.d[1][g]);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Weight=double;\nstruct Edge{\n    int to;\n    Weight w;\n    Edge(int t,Weight ww):to(t),w(ww){};\n};\nint n;\nint vertex(int pre,int x,int v){\n    return pre+x*n+v*n*n;\n}\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nconst Weight INF=1e15;\nvector<Weight> dijkstra(int s,Graph& g){\n    vector<Weight> res(g.size(),INF);\n    vector<int> used(g.size(),false);\n    priority_queue<pair<Weight,int>,vector<pair<Weight,int>>,greater<>> que;\n    que.push(make_pair(Weight(0),s));\n    while(!que.empty()){\n        auto ret=que.top();\n        que.pop();\n        int v=ret.second;\n        if(used[v]) continue;\n        used[v]=true;\n        res[v]=ret.first;\n        for(int i=0;i<g[v].size();i++){\n            que.push(make_pair(res[v]+g[v][i].w,g[v][i].to));\n        }\n    }\n    return res;\n}\n\nvoid solve(int s,int g,Graph& graph){\n    vector<Weight> d=dijkstra(s,graph);\n    Weight res=INF;\n    for(int i=0;i<n;i++){\n        res=min(res,d[vertex(i,g,1)]);\n    }\n    if(res>=INF/2){\n        cout<<\"unreachable\"<<endl;\n    }\n    else{\n        cout<<fixed<<setprecision(10);\n        cout<<res<<endl;\n    }\n    return;\n}\n\nint main(){\n    int m;\n    while(cin>>n>>m,n){\n        Graph graph(n*n*32);\n        int s,g;\n        cin>>s>>g;\n        s--,g--;\n        for(int i=0;i<m;i++){\n            int x,y,c;\n            Weight d;\n            cin>>x>>y>>d>>c;\n            x--,y--;\n            for(int i=0;i<=min(31,c+1);i++){\n                for(int j=-1;j<=1;j++){\n                    if(0<i+j && i+j<=c){\n                        for(int k=0;k<n;k++){\n                            if(k!=y && (i!=0 || x==s)) graph[vertex(k,x,i)].emplace_back(vertex(x,y,i+j),d/(i+j));\n                            if(k!=x && (i!=0 || y==s)) graph[vertex(k,y,i)].emplace_back(vertex(y,x,i+j),d/(i+j));\n                        }\n                    }\n                }\n            }\n        }\n        solve(vertex(s,s,0),g,graph);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef double Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  int c;                        // c ÍOtÅÍ§À¬xAqueue ÅÍ¬x\n  Edge(int src, int dst, Weight weight, int c) :\n    src(src), dst(dst), weight(weight), c(c){ }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst != f.dst ? e.dst < f.dst : e.c<f.c;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ndouble dijkstra(const Graph &g, int s, int t) {\n  int n = g.size();\n  double dist[n][31];           // dist[i][j] = Xs[h j ÌóÔÅ i ÉÂ­ÅZ£\n  REP(i,n) REP(j,31) dist[i][j] = INF;\n  dist[s][1] = 0;\n  priority_queue<Edge> Q;\n  Q.push(Edge(-2,s,0,1));\n  while(!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    //printf(\"%d->%d %f %d\\n\",e.src,e.dst,e.weight,e.c);\n    REP(k,3) {\n      int v = e.c - 1 + k;\n      if (e.src == -2 && v != 1) continue;\n      if (v<=0 || v>30) continue;\n      if (dist[e.dst][v] < e.weight) continue;\n      FOR(f, g[e.dst]) {\n        if (v > f->c) continue;\n        if (f->dst == e.src) continue;\n        double hoge = e.weight + f->weight / v;\n        if (dist[f->dst][v] > hoge) {\n          dist[f->dst][v] = hoge;\n          Q.push(Edge(f->src, f->dst, hoge, v));\n        }\n      }\n    }\n  }\n  return dist[t][1];\n}\n\nint main() {\n  int n,m;\n  while(cin >> n>>m,n||m) {\n    int s,t;\n    cin >> s >> t;\n    s--;t--;\n    Graph g(n);\n    REP(i,m) {\n      int x,y,d,c;\n      cin >> x>>y>>d>>c;\n      x--;y--;\n      g[x].push_back(Edge(x,y,d,c));\n      g[y].push_back(Edge(y,x,d,c));\n    }\n    double res = dijkstra(g,s,t);\n    if (res == INF)\n      cout << \"unreachable\" << endl;\n    else\n      printf(\"%.5f\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//1162\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nconst int MAX_N=30,MAX_C=30;\nconst double INF=1e8;\nconst double ESP=1e-8;\n\n#define EQ(a,b) fabs(a-b)<ESP\n\nint n,m;\nint s,g;\nstruct edge{\n\tint to,dist,c;\n};\nvector<edge> G[MAX_N];\n\nstruct S{\n\tint town,v,pre;\n\tdouble cost;\n\tbool operator<(const S &a) const{\n\t\treturn cost>a.cost;\n\t}\n};\n\ndouble cost[MAX_N][MAX_C+1][MAX_N];\nbool visited[MAX_N][MAX_C+1][MAX_N];\n\nvoid dijkstra(){\n\tREP(i,n){\n\t\tREP(j,MAX_C+1){\n\t\t\tREP(k,n){\n\t\t\t\tcost[i][j][k]=INF;\n\t\t\t\tvisited[i][j][k]=false;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<S> pq;\n\tpq.push(S{s,0,s,0.0});\n\twhile (!pq.empty()){\n\t\tS s=pq.top();\n\t\tpq.pop();\n\t\tif (visited[s.town][s.v][s.pre]) continue;\n\t\tvisited[s.town][s.v][s.pre]=true;\n\t\tREP(i,G[s.town].size()){\n\t\t\tedge e=G[s.town][i];\n\t\t\tif (e.to==s.pre) continue;\n\t\t\tFOR(acc,-1,1+1){\n\t\t\t\tif (s.v+acc>0 && s.v+acc<=e.c && cost[e.to][s.v+acc][s.town]>s.cost+(double)e.dist/(s.v+acc)){\n\t\t\t\t\tcost[e.to][s.v+acc][s.town]=s.cost+(double)e.dist/(s.v+acc);\n\t\t\t\t\tpq.push((S){e.to,s.v+acc,s.town,cost[e.to][s.v+acc][s.town]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif (n){\n\t\t\tscanf(\"%d %d\",&s,&g);\n\t\t\ts--;\n\t\t\tg--;\n\t\t\tREP(i,n){\n\t\t\t\tG[i].clear();\n\t\t\t}\n\t\t\tREP(i,m){\n\t\t\t\tint x,y,d,c;\n\t\t\t\tscanf(\"%d %d %d %d\",&x,&y,&d,&c);\n\t\t\t\tx--;\n\t\t\t\ty--;\n\t\t\t\tG[x].push_back(edge{y,d,c});\n\t\t\t\tG[y].push_back(edge{x,d,c});\n\t\t\t}\n\t\t\tdijkstra();\n\t\t\tdouble ans=INF;\n\t\t\tREP(i,n){\n\t\t\t\tans=min(ans,cost[g][1][i]);\n\t\t\t}\n\t\t\tif (ans==INF){\n\t\t\t\tprintf(\"unreachable\\n\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"%.6f\\n\",ans);\n\t\t\t}\n\t\t}\n\t}while (n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n,m;\nint d[35][35];\nint c[35][35];\n\ndouble dist[35][35][35];\n\ntypedef tuple<double,int,int,int> state;\n\ndouble dijkstra(int src,int dest){\n\trep(i,35)rep(j,35)rep(k,35) dist[i][j][k]=inf;\n\trep(i,35) dist[src][i][0]=0.0;\n\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\n\tstate init(0.0,src,-1,0);\n\tq.push(init);\n\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\tdouble distance;\n\t\tint v,p,s;\n\t\ttie(distance,v,p,s)=cur;\n\t\tif(p>=0&&dist[v][p][s]<distance) continue;\n\t\trep(i,n){\n\t\t\tif(i==p||d[v][i]==-1)\n\t\t\t\tcontinue;\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tint nv=i;\n\t\t\t\tint ns=s+j;\n\t\t\t\tif(ns<=0||c[v][i]<ns) continue;\n\t\t\t\tdouble nd=distance+(1.0*d[v][i]/ns);\n\t\t\t\tif(dist[nv][v][ns]>nd){\n\t\t\t\t\tdist[nv][v][ns]=nd;\n\t\t\t\t\tstate next(nd,nv,v,ns);\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble res=inf;\n\trep(i,n) res=min(res,dist[dest][i][1]);\n\treturn (res>=inf)?-1:res;\n}\n\nint main(void){\n\twhile(cin >> n >> m){\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tclr(d,-1);\n\t\tint s,g;\n\t\tcin >> s >> g;\n\t\ts--,g--;\n\t\trep(i,m){\n\t\t\tint x,y,dd,cc;\n\t\t\tcin >> x >> y >> dd >> cc;\n\t\t\tx--,y--;\n\t\t\td[x][y]=d[y][x]=dd;\n\t\t\tc[x][y]=c[y][x]=cc;\n\t\t}\n\t\tcout.precision(9);\n\t\tdouble ans=dijkstra(s,g);\n\t\tif(ans==-1.0)\n\t\t\tcout << \"unreachable\" << endl;\n\t\telse\n\t\t\tcout << fixed << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ndouble cut[32][32][32];\npair<int,int> way[32][32];\nint main() {\n\tint n, m, s, g;\n\twhile(cin >> n >> m, n) {\n\t\tcin >> s >> g;\n\t\tfill((double*)cut, (double*)cut + 32 * 1024, 1e100);\n\t\tfill((int*)way, (int*)way + 1024, 0);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tway[x][y] = way[y][x] = make_pair(d,c);\n\t\t}\n\t\tpriority_queue<tuple<double, int, int>,vector<tuple<double, int, int>>,greater<tuple<double, int, int>>> que;\n\t\tque.push(make_tuple(0., s, 1));\n\t\twhile (!que.empty()&&(get<1>(que.top())!=g||get<2>(que.top())!=0)){\n\t\t\tauto a = que.top();\n\t\t\tque.pop();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (way[get<1>(a)][i].second == 0)continue;\n\t\t\t\tif (i == get<1>(a))continue;\n\t\t\t\tif (get<2>(a)>way[get<1>(a)][i].second)continue;\n\t\t\t\tif (get<2>(a) == 0)continue;\n\t\t\t\tfor (int j = max(0, get<2>(a)-1); j <= get<2>(a)+1; j++) {\n\t\t\t\t\tif (cut[i][j][get<1>(a)]>get<0>(a) + (double)way[get<1>(a)][i].first / get<2>(a)) {\n\t\t\t\t\t\tque.push(make_tuple(get<0>(a) + (double)way[get<1>(a)][i].first / get<2>(a), i, j));\n\t\t\t\t\t\tcut[i][j][get<1>(a)] = get<0>(a) + (double)way[get<1>(a)][i].first / get<2>(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (que.empty())cout << \"unreachable\" << endl;\n\t\telse cout << fixed << setprecision(10) << get<0>(que.top()) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n, m;\nll s, g;\n\nclass DK {\npublic:\n\tstruct edge {\n\t\tint to;\n\t\tdouble cost;\n\t\tll cap;\n\t\tedge(int _to, double _cost, ll _cap) :to(_to), cost(_cost), cap(_cap) {}\n\t};\n\n\tdouble d[110][110];\n\tvector<edge> G[110];//各頂点からの辺\n\n\tvoid dijkstra() {\n\t\trep(i, 110)rep(j, 110)d[i][j] = INF;\n\t\td[s][0] = 0;\n\n\t\ttypedef pair<pair<double, ll>, ll> PP;\n\t\tpriority_queue<PP, vector<PP>, greater<PP>> que;\n\t\tque.push({ {0, 0},s });\n\n\t\twhile (!que.empty()) {\n\t\t\tPP p = que.top();\n\t\t\tque.pop();\n\t\t\tll nn = p.second;\n\t\t\tll v = p.first.second;\n\t\t\tif (d[nn][v] < p.first.first)continue;\n\t\t\tfor (int i = 0; i < G[nn].size(); i++) {\n\t\t\t\tedge e = G[nn][i];\n\t\t\t\tFOR(j, -1, 2) {\n\t\t\t\t\tdouble nv = v + j;\n\t\t\t\t\tif (nv <= 0)continue;\n\t\t\t\t\tif (nv > e.cap)continue;\n\t\t\t\t\tif (d[e.to][(ll)nv] > d[nn][v] + e.cost / nv) {\n\t\t\t\t\t\td[e.to][(ll)nv] = d[nn][v] + e.cost / nv;\n\t\t\t\t\t\tque.push({ {d[e.to][(ll)nv], (ll)nv},e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n};\n\nDK dk;\n\nint main() {\n\twhile (cin >> n >> m&&n + m) {\n\t\trep(i, 110)dk.G[i].clear();\n\t\tcin >> s >> g;\n\t\trep(i, m) {\n\t\t\tint x, y;\n\t\t\tll c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tdk.G[x].push_back(DK::edge(y, d, c));\n\t\t\tdk.G[y].push_back(DK::edge(x, d, c));\n\t\t}\n\t\tdk.dijkstra();\n\t\t//rep(i, n) {\n\t\t//\trep(j, 30) {\n\t\t//\t\tcout << dk.d[i + 1][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tdouble ans = dk.d[g][1];\n\t\tif ((ll)ans == INF)cout << \"unreachable\" << endl;\n\t\telse printf(\"%.10lf\\n\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\nstruct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n\nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\n// (time,speed,node,pre_node)\nusing P = pair<pair<double,int>,pair<int,int>>;\n\n\nP makeP(double t,int s,int n,int np){\n    return make_pair(make_pair(t,s),make_pair(n,np));\n}\n\nvoid solve(int n,int m){\n    int start,goal; cin>>start>>goal;\n    start--;\n    goal--;\n    vector<vector<int>> g(n,vector<int>(n,INF));\n    vector<vector<int>> lim(n,vector<int>(n,0));\n    rep(i,m){\n        int x,y,d,c;\n        cin>>x>>y>>d>>c;\n        x--;\n        y--;\n        g[x][y] = d;\n        g[y][x] = d;\n        lim[x][y] = c;\n        lim[y][x] = c;\n    }\n\n    double visited[32][32][32];\n    rep(i,32) rep(j,32) rep(k,32) visited[i][j][k]=DBL_MAX/10;\n    visited[start][0][start] = 0;\n\n    priority_queue<P,vector<P>,greater<P>> que;\n    que.push(makeP(0,0,start,start));\n    while(!que.empty()){\n        auto p = que.top();\n        que.pop();\n        double ti = p.first.first;\n        int speed = p.first.second;\n        int node = p.second.first;\n        int pre = p.second.second;\n\n#ifdef DEBUG\n        cerr << \"time : \" << ti << \" \"  << \"node : \" << node+1 << \" \" << \"speed \" << speed << endl;\n#endif\n        if(node==goal and speed==1){\n            cout << Double(ti) << endl;\n            return;\n        }\n\n        if(ti > visited[node][speed][pre]) continue;\n\n        for(int next_node=0;next_node<n;next_node++){\n            if(next_node==node or next_node==pre) continue;\n            if(g[node][next_node]==INF) continue;\n            int d=g[node][next_node];\n            int c=lim[node][next_node];\n            for(int nspeed=speed-1;nspeed<=speed+1;nspeed++){\n                if(nspeed<=0 or nspeed>c) continue;\n                double nt = ti + (double)d/nspeed;\n                if(nt < visited[next_node][nspeed][pre]){\n#ifdef DEBUG\n                    cerr << \"\\ttime \" << nt << \" \" << \"node \" << next_node+1 << \" speed \" << nspeed << endl;\n#endif\n                    visited[next_node][nspeed][pre] = nt;\n                    que.push(makeP(nt,nspeed,next_node,node));\n                }\n            }\n        }\n    }\n    cout << \"unreachable\" << endl;\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m){\n        if(n==0 && m==0) break;\n        solve(n,m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\nconst int INF = 1e9 + 10;\n\nstruct Edge {\n  int to, dist, constraint;\n \n  Edge() = default;\n  Edge(int t, int d, int c): to(t), dist(d), constraint(c) { }\n};\n\nstruct Node {\n  double cost;\n  int cur, prev, v;\n  \n  Node() = default;\n  Node(double c, int cur, int prev, int v): cost(c), cur(cur), prev(prev), v(v) { }\n\n  inline bool operator<(const Node& node) const {\n    return cost < node.cost;\n  }\n\n  inline bool operator>(const Node& node) const {\n    return cost > node.cost;\n  }\n};\n\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n + m == 0) {\n      break;\n    }\n    int s, g;\n    cin >> s >> g;\n\n    vector<Edge> G[31];\n    for (int i = 0; i < m; i++) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      G[x].push_back(Edge(y, d, c));\n      G[y].push_back(Edge(x, d, c));\n    }\n\n    double min_cost[31][31][31];\n    for (int i = 0; i < 31; i++)  {\n      for (int j = 0; j < 31; j++) {\n        for (int k = 0; k < 31; k++) {\n          min_cost[i][j][k] = INF;\n        }\n      }\n    }\n\n    priority_queue<Node, vector<Node>, greater<Node>> que;\n    min_cost[s][0][1] = 0;\n    que.push(Node(0, s, -1, 0));\n\n    while (!que.empty()) {\n      Node node = que.top(); que.pop();\n\n      for (const auto& e : G[node.cur]) {\n        if (node.prev == e.to) {\n          continue;\n        }\n        const int dv[3] = { -1, 0, 1 };\n        for (int i = 0; i < 3; i++) {\n          int nv = node.v + dv[i];\n          if (nv > 0 && nv <= e.constraint) {\n            double temp = e.dist / (double)nv;\n            if (min_cost[e.to][node.cur][nv] > node.cost + temp) {\n              min_cost[e.to][node.cur][nv] = node.cost + temp;\n              que.push(Node(node.cost + temp, e.to, node.cur, nv));\n            }\n          }\n        }\n      }\n    }\n\n    double ans = INF;\n    for (int i = 1; i <= n; i++) {\n      ans = min(ans, min_cost[g][i][1]);\n    }\n    if (ans >= INF) {\n      cout << \"unreachable\" << endl;\n    } else {\n      printf(\"%.15f\\n\", ans);\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cout << x << \" \";} cout << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\n// typedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\n// const int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef tuple<double, int, int, int> TUPLE;\nconst double inf = 1e12;\n\nstruct edge {\n    int to, d, c;\n    edge(){}\n    edge(int _to, int _d, int _c) : to(_to), d(_d), c(_c) {}\n};\ntypedef vector<vector<edge>> Graph;\ndouble dijkstra(const Graph& G, int s, int g) {\n    int n = G.size();\n    priority_queue<TUPLE, vector<TUPLE>, greater<TUPLE>> pq;   // cost, i, j, pre\n    vector<vector<double>> d(n, vector<double>(31, inf));\n    d[s][0] = 0;\n    pq.push(make_tuple(0, s, 0, -1));\n\n    while (!pq.empty()) {\n        double cost;\n        int i, j, pre;\n        tie(cost, i, j, pre) = pq.top(); pq.pop();\n        // cout << cost << \" \" << i << \" \" << j << endl;\n        if (i == g && j == 1) return cost;\n        if (d[i][j] < cost) continue;\n        for (const auto& e : G[i]) {\n            for (int k = -1; k <= 1; k++) {\n                if (e.to == pre) continue;\n                // if (e.to == g && j + k != 1) continue;\n                if (1 <= j + k && j + k <= e.c && d[e.to][j + k] > d[i][j] + 1. * e.d / (j + k)) {\n                    d[e.to][j + k] = d[i][j] + 1. * e.d / (j + k);\n                    pq.push(make_tuple(d[e.to][j + k], e.to, j + k, i));\n                }\n            }\n        }\n        // cerr << \"hey!\" << endl;\n    }\n\n    return inf;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    int t = 0;\n    while (cin >> n >> m, n) {\n        // cout << \"--- t = \" << t++ << \" ---\" << endl;\n\n        int s, g;\n        cin >> s >> g;\n        s--, g--;\n        Graph G(n);\n        rep(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--, y--;\n            G[x].emplace_back(y, d, c);\n            G[y].emplace_back(x, d, c);\n        }\n\n        double ans = dijkstra(G, s, g);\n        if (ans < inf) {\n            cout << setprecision(10) << ans << endl;\n        } else {\n            cout << \"unreachable\" << endl;\n        }\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\ntypedef pair<pair<double,int>,pair<int,int> > P;\n\nclass road{\npublic:\n  int x,y,d,c;\n};\n\n\nint main(){\n  int n,m,s,g;\n\n  for(;;){\n    scanf(\"%d %d\",&n,&m);\n    if(!n && !m)break;\n    scanf(\"%d %d\",&s,&g);\n\n    road r[1000];\n    double t[31][31][31];\n    bool v[31][31][31];\n\n    for(int i=0;i<m;i++)scanf(\"%d %d %d %d\",&r[i].x,&r[i].y,&r[i].d,&r[i].c);\n    \n    for(int i=0;i<=n;i++)\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<=30;k++){\n\tt[i][j][k] = 1e10;\n\tv[i][j][k] = false;\n      }\n\n    t[s][0][0] = 0.0;\n    priority_queue<P,vector<P>,greater<P> > q;\n    q.push(P(pair<double,int>(0.0,s),pair<int,int>(0,0)));\n\n    while(q.size()){\n      P p = q.top();q.pop();\n\n      double time = p.first.first;\n      int now,prv,speed;\n      now = p.first.second;\n      prv = p.second.first;\n      speed = p.second.second;\n\n      if(v[now][prv][speed])continue;\n      v[now][prv][speed] = true;\n      //printf(\"%d %d %d\\n\",now,prv,speed);\n\n      for(int i=0;i<m;i++){\n\tif(r[i].x == now && r[i].y != prv){\n\t  for(int dif=-1;dif<=1;dif++){\n\t    if(speed+dif>0 &&  speed+dif<=r[i].c){\n\t      if(!v[r[i].y][now][speed+dif]){\n\t\tif(t[r[i].y][now][speed+dif] > time+(double)r[i].d/(speed+dif)){\n\t\t  t[r[i].y][now][speed+dif] = time+(double)r[i].d/(speed+dif);\n\t\t  q.push(P(pair<double,int>(t[r[i].y][now][speed+dif],r[i].y),pair<int,int>(now,speed+dif)));\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}else if(r[i].y == now && r[i].x != prv){\n\t  for(int dif=-1;dif<=1;dif++){\n\t    if(speed+dif>0 && speed+dif<=r[i].c){\n\t      if(!v[r[i].x][now][speed+dif]){\n\t\tif(t[r[i].x][now][speed+dif] > time+(double)r[i].d/(speed+dif)){\n\t\t  t[r[i].x][now][speed+dif] = time+(double)r[i].d/(speed+dif);\n\t\t  q.push(P(pair<double,int>(t[r[i].x][now][speed+dif],r[i].x),pair<int,int>(now,speed+dif)));\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    /*\n    for(int i=0;i<31;i++){\n      for(int j=1;j<=n;j++)printf(\"%3.3lf \",t[j][i]);\n      putchar('\\n');\n    }\n    */\n    double ans = 1e10;\n    for(int i=0;i<=n;i++)ans = min(ans,t[g][i][1]);\n    if(ans==1e10)printf(\"unreachable\\n\");\n    else printf(\"%.4lf\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n\nstruct node{\n    int index,prev,speed;\n\tdouble cost;\n    node(int index,int prev,int speed,double cost):index(index),prev(prev),speed(speed),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n    }\n};\nconst double MAX=INT_MAX/10;\nconst double NONE=-1;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<vvd> vvvd;\n\nint main(){\n\tcout.precision(16);\n    int n,m;\n    while(cin>>n>>m,n){\n\t\tint s,g;\n\t\tcin>>s>>g;\n        vvi dist(n,vi(n,NONE));\n        vvi limit(n,vi(n,NONE));\n        REP(i,m){\n            int x,y,d,c;\n            cin>>x>>y>>d>>c;\n            dist[x-1][y-1]=d;\n            dist[y-1][x-1]=d;\n            limit[x-1][y-1]=c;\n            limit[y-1][x-1]=c;\n        }\n        \n        priority_queue<node> q;\n        q.push(node(s-1,0,0,0));\n        vvvd cost(n,vvd(n,vd(31,MAX)));\n        cost[s-1][0][0]=0;\n        while(!q.empty()){\n            node cnode=q.top();q.pop();\n            if(cost[cnode.index][cnode.prev][cnode.speed]<cnode.cost){\n                continue;\n            }\n            REP(i,n){\n                if(i!=cnode.index&&dist[cnode.index][i]!=NONE&&i!=cnode.prev){\n\t\t\t\t\tfor(int ds=-1;ds<=1;ds++){\n\t\t\t\t\t\tint newspeed=cnode.speed+ds;\n\t\t\t\t\t\tif(newspeed>0&&newspeed<=limit[cnode.index][i]){\n\t\t\t\t\t\t\tdouble newcost=cnode.cost+(double)dist[cnode.index][i]/newspeed;\n\t\t\t\t\t\t\tif(cost[i][cnode.index][newspeed]>newcost){\n\t\t\t\t\t\t\t\tcost[i][cnode.index][newspeed]=newcost;\n\t\t\t\t\t\t\t\tq.push(node(i,cnode.index,newspeed,newcost));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n                }\n            }\n        }\n\t\tdouble ans=MAX;\n\t\tREP(prev,n){\n\t\t\tans=min(ans,cost[g-1][prev][1]);\n\t\t}\n\t\tif(ans==MAX){\n\t\t\tcout<<\"unreachable\"<<endl;\n\t\t}else{\n\t\t\tcout<<ans<<endl;\n\t\t}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\n\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<VVD> VVVD;\n\n/*\n\nDijstra\n頂点を拡張して属性を持たせる\nノード番号・直前の道・速度 := 時間\n終点の速度 1の状態から min_element\n\n\n元・行先・距離・制限速度\n\n*/\n\nstruct Edge\n{\n\tint to, dist, c;\n\tEdge( int t, int d, int c ) : to( t ), dist( d ), c( c ) {}\n};\n\nstruct State\n{\n\tint node, prev, speed;\n\tState( int n, int p, int s ) : node( n ), prev( p ), speed( s ) {}\n\n\tbool operator < ( const State &a ) const\n\t{\n\t\treturn node < a.node;\n\t}\n};\n\n#include <iomanip>\n\nint main()\n{\n\tcout.precision( 4 );\n\tcout << fixed;\n\n\twhile ( true )\n\t{\n\t\tint n, m;\n\t\tcin >> n >> m;\n\n\t\tif ( !( n | m ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\ts--;\n\t\tg--;\n\n\t\tvector< vector<Edge> > G( n );\n\t\tfor ( int i = 0; i < m; i++ )\n\t\t{\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tG[x].push_back( Edge( y, d, c ) );\n\t\t\tG[y].push_back( Edge( x, d, c ) );\n\t\t}\n\n\t\t// 現在地・直前のノード・速度\n\t\tVVVD dist( n, VVD( n, VD( 101, DBL_MAX ) ) );\n\t\tdist[s][s][0] = 0;\n\n\t\tpriority_queue< pair<double,State>, vector< pair<double,State> >, greater< pair<double,State> > > que;\n\t\tque.push( make_pair( 0, State( s, s, 0 ) ) );\n\t\t\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tdouble d = que.top().first;\n\t\t\tState cur = que.top().second;\n\t\t\tque.pop();\n\n\t\t\tif ( dist[ cur.node ][ cur.prev ][ cur.speed ] < d )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor ( int i = 0; i < G[ cur.node ].size(); i++ )\n\t\t\t{\n\t\t\t\tEdge &e = G[ cur.node ][i];\n\n\t\t\t\tif ( e.to == cur.prev )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor ( int ds = -1; ds <= 1; ds++ )\n\t\t\t\t{\n\t\t\t\t\tint nspeed = cur.speed + ds;\n\n\t\t\t\t\tif ( nspeed <= 0 || e.c < nspeed )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( dist[ cur.node ][ cur.prev ][ cur.speed ] + e.dist / (double)nspeed < dist[ e.to ][ cur.node ][ nspeed ] )\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[ e.to ][ cur.node ][ nspeed ] = dist[ cur.node ][ cur.prev ][ cur.speed ] + e.dist / (double)nspeed;\n\t\t\t\t\t\tque.push( make_pair( dist[ e.to ][ cur.node ][ nspeed ], State( e.to, cur.node, nspeed ) ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 解候補：終点ノード・どこからでも・速度１\n\t\tdouble res = DBL_MAX;\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tres = min( res, dist[g][i][1] );\n\t\t}\n\n\t\tif ( res == DBL_MAX )\n\t\t{\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <iomanip>\n\nusing namespace std;\n\nconst double INF = (1 << 29);\nconst double EPS = 1e-5;\n\nstruct State{\n    double cost;\n    int now, bef, speed;\n\n    State(double c, int n, int b, int s):\n        cost(c),now(n),bef(b),speed(s){}\n\n    bool operator < (State s) const{\n        return s.cost < cost;\n    }\n};\n\nstruct Edge{\n    int to, dist, limit;\n    Edge(int t, int d, int l):\n        to(t), dist(d), limit(l){}\n};\n\nint n, m, s, g;\nvector<Edge> edge[31];\ndouble minCost[31][31][31];\n\ndouble dijkstra(){\n    for(int i = 0;i < 31;i++){\n        for(int j = 0;j < 31;j++){\n            for(int k = 0;k < 31;k++){\n                minCost[i][j][k] = INF;\n            }\n        }\n    }\n    priority_queue<State> pq;\n    pq.push(State(0,s,0,1));\n\n    bool begin = true;\n    while(!pq.empty()){\n        State p = pq.top();\n        pq.pop();\n\n        if(p.now==g && p.speed==1){\n            return p.cost;\n        }\n\n        if(minCost[p.now][p.bef][p.speed] <= p.cost + EPS){\n            continue;\n        }\n        minCost[p.now][p.bef][p.speed] = p.cost;\n\n        for(int j = 0 ; j < edge[p.now].size() ; j++){\n\t        Edge e = edge[p.now][j];\n\t        if(p.bef==e.to)continue;\n\n            for(int k = -1 ; k <= 1 ; k++){\n                if(k!=0 && begin)continue;\n    \n                if(0 < p.speed + k && p.speed + k < 31 && p.speed + k <= e.limit){\n                    double t = e.dist / (double)(p.speed + k);\n                    if(minCost[e.to][p.now][p.speed+k] > p.cost+t){\n                        pq.push(State(p.cost+t, e.to, p.now, p.speed+k));\n                    }\n                }\n            }\n        }\n        if(begin)begin = false;\n    }\n    return -1.0;\n}\n\nint main(){\n    while(scanf(\"%d%d\",&n,&m)){\n        if(n==0 && m==0)break;\n\n        for(int i = 0 ; i < 31;i++){\n            edge[i].clear();\n        }\n\n        cin >> s >> g;\n      \n    for(int i = 0;i < m ; i++){\n\t    int x,y,d,c;\n        cin >> x >> y >> d >> c;\n\t    edge[x].push_back(Edge(y,d,c));\n\t    edge[y].push_back(Edge(x,d,c));\n        }\n      \n        double ans = dijkstra();\n        if(ans==-1)cout << \"unreachable\" << endl;\n        else cout << fixed << setprecision(10) << ans <<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct status {\n    int pos;\n    double time;\n    int vel;\n    int prev;\n\n    status () {}\n    ~status () {}\n\n    status(int a, double b, int c, int d): pos(a), time(b), vel(c), prev(d) {}\n\n    bool operator > (const status& o) const {\n        return time > o.time;\n    }\n};\n\nstruct edge {\n    int to;\n    int time;\n    int lim;\n\n    edge () {}\n    ~edge () {}\n\n    edge(int a, double b, int c): to(a), time(b), lim(c) {}\n};\n\nbool solve() {\n    int n, m, s, g;\n    cin >> n >> m;\n\n    if (n == 0 && m == 0) return false;\n\n    cin >> s >> g;\n\n    --s; --g;\n\n    vector<vector<edge>> graph(n, vector<edge>(0));\n\n    for (int j = 0; j < m; ++j) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        --x; --y;\n        graph[x].push_back(edge(y, d, c));\n        graph[y].push_back(edge(x, d, c));\n    }\n\n    vector<vector<char>> visited(n, vector<char>(31, false));\n    priority_queue<status, vector<status>, greater<status>> que;\n\n    que.push(status(s, 0.0, 0, -1));\n\n    double ret = -1;\n\n    while (!que.empty()) {\n        status st = que.top(); que.pop();\n\n        if (visited[st.pos][st.vel]) {\n            continue;\n        }\n\n        visited[st.pos][st.vel] = true;\n\n        if (st.pos == g && st.vel == 1) {\n            ret = st.time;\n            break;\n        }\n\n        for (edge& e : graph[st.pos]) {\n            if (e.to == st.prev) continue;\n\n            for (int a = -1; a <= 1; ++a) {\n                int nv = st.vel + a;\n                if (nv <= 0) continue;\n\n                double t = st.time + (double)e.time / nv;\n\n                if (nv <= e.lim && !visited[e.to][nv]) {\n                    que.push(status(e.to, t, nv, st.pos));\n                }\n            }\n        }\n    }\n    \n    if (ret < 0) {\n        printf(\"unreachable\\n\");\n    } else {\n        printf(\"%.12f\\n\", ret);\n    }\n\n    fflush(stdout);\n\n    return true;\n}\n\nint main () {\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000.0\nusing namespace std;\nstruct state { int n, v, l; double t; };\n\nint N, M, S, G;\nvector<int> T[301], D[301], C[301];\nint vd[3] = { -1, 0, 1 };\ndouble dp[31][51];\n\nclass Compare {\npublic:\n  bool operator() (struct state a, struct state b) {\n    return a.t > b.t;\n  }\n};\n\nint main(void) {\n  while(cin >> N >> M, N) {\n    cin >> S >> G;\n    REP(i, 0, 300) {\n      T[i].clear();\n      D[i].clear();\n      C[i].clear();\n    }\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      T[x].push_back(y); D[x].push_back(d); C[x].push_back(c);\n      T[y].push_back(x); D[y].push_back(d); C[y].push_back(c);\n    }\n\n    REP(i, 1, N) REP(j, 0, 51) dp[i][j] = INF;\n\n    priority_queue<struct state, vector<struct state>, Compare> q;\n    struct state first = { S, 0, -1, 0.0 };\n    q.push(first);\n\n    while(!q.empty()) {\n      struct state c = q.top();\n      q.pop();\n\n      // cout << c.n << \" \" << c.v << \" \" << c.t << endl;\n\n      dp[c.n][c.v] = min(dp[c.n][c.v], c.t);\n      if(c.n == G && c.v == 1) break;\n\n      for(int i = 0; i < T[c.n].size(); i++) {\n        if(T[c.n][i] == c.l) continue;\n        REP(j, 0, 3) {\n          int v = c.v + vd[j];\n          if(v <= 0 || C[c.n][i] < v) continue;\n          double t = c.t + ((double) D[c.n][i] / v);\n          struct state n = { T[c.n][i], v, c.n, t };\n          if(n.t < dp[n.n][n.v]) q.push(n);\n        }\n      }\n    }\n\n    if(dp[G][1] < INF) printf(\"%.6f\\n\", dp[G][1]);\n    else cout << \"unreachable\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 6/15 8:57 ~ 920 1129\n */\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#define INF 2000000\n\nusing namespace std;\n\nstruct edge {\n  int to;\n  double cost;\n};\ntypedef pair<int, int> P;\n\nint iN;\nint iM;\nint iS;\nint iG;\nvector<edge> G[31 * 31];\ndouble d[31 * 31][31];\n\nbool input() {\n  int i, j;\n  int x, y, d, c;\n  edge e;\n\n  scanf(\"%d %d\", &iN, &iM);\n  if (iN == 0 && iM == 0)\n    return false;\n  scanf(\"%d %d\", &iS, &iG);\n\n  for (i = 0; i < 31 * 31; i++) {\n    G[i].clear();\n  }\n\n  for (i = 0; i < iM; i++) {\n    scanf(\"%d %d %d %d\", &x, &y, &d, &c);\n    for (j = 1; j <= c; j++) {\n      e.cost = (double) d / j;\n      e.to = y * 31 + j;\n      G[x * 31 + j].push_back(e);\n      G[x * 31 + j - 1].push_back(e);\n      if (j + 1 <= c)\n        G[x * 31 + j + 1].push_back(e);\n      e.to = x * 31 + j;\n      G[y * 31 + j].push_back(e);\n      G[y * 31 + j - 1].push_back(e);\n      if (j + 1 <= c)\n        G[y * 31 + j + 1].push_back(e);\n    }\n  }\n  return true;\n}\n\nvoid dijkstraQueue() {\n  int i, j;\n  priority_queue<P, vector<P> , greater<P> > que;\n\n  fill(d[0], d[0] + 31 * 31 * 31, INF);\n  d[iS * 31 + 0][0] = 0;\n  que.push(P(0, iS * 31 + 0));\n\n  while (!que.empty()) {\n    P p = que.top();\n    que.pop();\n    int v = p.second;\n    //printf(\"%d %d\\n\", v / 31, v % 31);\n    for (j = 0; j < 31; j++) {\n      if (d[v][j] < p.first)\n        continue;\n      for (i = 0; i < (int) G[v].size(); i++) {\n        edge e = G[v][i];\n        //printf(\"%f\\n\", e.cost);\n        if (d[e.to][v / 31] > d[v][j] + e.cost) {\n          d[e.to][v / 31] = d[v][j] + e.cost;\n          que.push(P(d[e.to][v / 31], e.to));\n        }\n      }\n    }\n  }\n}\n\nvoid output() {\n  int i;\n  double out;\n  out = d[(iG - 1) * 31 + 1][1];\n  for (i = 2; i < 31; i++) {\n    out = min(out, d[(iG - 1) * 31 + 1][i]);\n  }\n  if (out == INF)\n    printf(\"unreachable\\n\");\n  else\n    printf(\"%f\\n\", out);\n}\n\nint main() {\n  while(1) {\n    if (!input()) break;\n    dijkstraQueue();\n    output();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\n\n// 🔴\n\n// O(ElogE)\n\n// pq<pair> はfirstが大きい順に出てくるのですか？\n// s:= 開始ノード  v:= 頂点数  adjlist:= 隣接リスト (first:= コスト   second:= 行先)\nvector<double> dijk(int s, int v, vector<vector<pair<double, int> > > adjlist){\n    \n    priority_queue <pair<double, int> > wait;\n    vector<double> result(v, INF);\n\n    //スタート地点を追加\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    //ダイクストラ本体\n    while(!wait.empty()){    //waitが空になるまで\n\n        int nowpoint = wait.top().second;\n        double nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint] < nowcost) continue;\n\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n\n            int nextpoint = adjlist[nowpoint][i].second;\n            double nextcost = nowcost + adjlist[nowpoint][i].first;\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint] > nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n    \n    return result;         //結果列を返す\n}\n\nint main(){\n\n\n    while(1){\n        int n, m; cin >> n >> m;\n        if(!n) break;\n        int s, g; cin >> s >> g;\n        s--;\n        g--;\n        vector<vector<vector<int> > > Map(n, vector<vector<int> > (n, vector<int> (31)));\n        int idx = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                for(int k = 1; k <= 30; k++){\n                    Map[i][j][k] = idx;\n                    idx++;\n                }\n            }\n        }\n\n        vector<vector<pair<double, int> > > adjlist(30000);      //first := コスト　second := 行先\n\n        for(int i = 0; i < m; i++){\n            int x, y, c; double d; cin >> x >> y >> d >> c;\n            x--;\n            y--;\n\n            if(x == s){\n                int now = 0;\n                int next = Map[y][x][1];\n                double cost = d;\n                adjlist[now].push_back(make_pair(cost, next));                \n            }\n\n            if(y == s){\n                int now = 0;\n                int next = Map[x][y][1];\n                double cost = d;\n                adjlist[now].push_back(make_pair(cost, next));                \n            }\n\n            for(int pre = 0; pre < n; pre++){\n            for(int v = 1; v <= 30; v++){\n\n                int now = Map[x][pre][v];\n                if(pre == y || pre == x) continue;\n                \n                //三方向\n                //-1\n                int next_v = v - 1;\n                if(0 < next_v && next_v <= c){\n                    int next = Map[y][x][next_v];\n                    double cost = d / next_v;\n                    adjlist[now].push_back(make_pair(cost, next));                    \n                }\n\n                //そのまま\n                next_v = v;\n                if(0 < next_v && next_v <= c){\n                    int next = Map[y][x][next_v];\n                    double cost = d / next_v;\n                    adjlist[now].push_back(make_pair(cost, next));                    \n                }\n\n                //+1\n                next_v = v + 1;\n                if(0 < next_v && next_v <= c){\n                    int next = Map[y][x][next_v];\n                    double cost = d / next_v;\n                    adjlist[now].push_back(make_pair(cost, next));                    \n                }\n\n            }\n            }\n\n            for(int pre = 0; pre < n; pre++){\n            for(int v = 1; v <= 30; v++){\n\n                int now = Map[y][pre][v];\n                if(pre == x || pre == y) continue;\n\n                //三方向\n                //-1\n                int next_v = v - 1;\n                if(0 < next_v && next_v <= c){\n                    int next = Map[x][y][next_v];\n                    double cost = d / next_v;\n                    adjlist[now].push_back(make_pair(cost, next));                    \n                }\n\n                //そのまま\n                next_v = v;\n                if(0 < next_v && next_v <= c){\n                    int next = Map[x][y][next_v];\n                    double cost = d / next_v;\n                    adjlist[now].push_back(make_pair(cost, next));                    \n                }\n\n                //+1\n                next_v = v + 1;\n                if(0 < next_v && next_v <= c){\n                    int next = Map[x][y][next_v];\n                    double cost = d / next_v;\n                    adjlist[now].push_back(make_pair(cost, next));                    \n                }\n            }\n        }\n        }\n        \n        int S = 0;\n        double ans = INF;\n        vector<double> result(30000);\n        result = dijk(0, 30000, adjlist);\n\n        for(int i = 0; i < n; i++){\n            if(i == g) continue;\n            int G = Map[g][i][1];\n            ans = min(ans, result[G]);\n        }\n\n        if(ans >= INF) cout << \"unreachable\" << endl; \n        else printf(\"%.10f\\n\", ans);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n    return false;\n}\nstruct Edge {\n    int to,d,c;\n    Edge(int to=0,int d=0,int c=0) :\n        to(to),d(d),c(c) {}\n};\n\nstruct State {\n    int v,u;\n    int spd;\n    double t;\n    State(int v=0,int u=0,int spd=0,double t=0) :\n        v(v),u(u),spd(spd),t(t){}\n\n    bool operator<(const State &rhs) const {\n        return t>rhs.t;\n    }\n};\nint s,g;\nint n,m;\nvector<Edge> G[40];\n\ndouble dijk() {\n    // v,u,spd;\n    double d[40][40][40];\n    rep(i,40) rep(j,40) rep(k,40) d[i][j][k]=INF;\n    //rep(i,40) d[s][i][1]=1;\n    d[s][s][0]=0;\n\n    priority_queue<State> que;\n    que.push(State(s,s,0));\n    while(que.size()) {\n        State s=que.top(); que.pop();\n\n        rep(i,G[s.v].size()) {\n            Edge e=G[s.v][i];\n            if(e.to==s.v) continue;\n            for(int k=-1;k<=1;k++) {\n                if(!(0<=s.spd+k&&s.spd+k<=e.c)) continue;\n                if(s.spd+k==0) continue;\n                if(chmin(d[e.to][s.v][s.spd+k],d[s.v][s.u][s.spd]+1.0*e.d/(s.spd+k))) {\n                    que.push(State(e.to,s.v,s.spd+k,d[e.to][s.v][s.spd+k]));\n                }\n            }\n        }\n    }\n    double ret=INF;\n    rep(i,40) chmin(ret,d[g][i][1]);\n\n    return ret;\n\n}\n\nvoid solve() {\n    rep(i,40) G[i].clear();\n    cin>>s>>g;\n    s--,g--;\n    rep(i,m) {\n        int x,y,d,c;\n        cin>>x>>y>>d>>c;\n        x--,y--;\n        G[x].push_back(Edge(y,d,c));\n        G[y].push_back(Edge(x,d,c));\n    }\n    double ans=dijk();\n    if(ans==INF) cout<<\"unreachable\"<<endl;\n    else printf(\"%.10f\\n\",ans);\n}\n\nint main() {\n    while(cin>>n>>m) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?(テァツクツョテ・ツーツ湘ァツ可?\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\nconstexpr int T = 40;\n\nint N, M, s, g;\n\n// テゥツδステ・ツクツづ」ツ?ィテゥツ?淌・ツコツヲテ」ツ?ィテ・ツ可催」ツ?ョテゥツ?淌・ツコツヲテ」ツ??、ツクツュティツコツォテ」ツ?ッテヲツ卍づゥツ鳴?\ndouble dist[40][T][T];\n\nstruct Edge {\n    int to; double cost; int lim;\n};\n\nstruct Elem {\n    int cur, speed, prev, prevs;\n};\n\nbool operator<(const Elem &a, const Elem &b) {\n    return dist[a.cur][a.speed][a.prevs] > dist[b.cur][b.speed][b.prevs];\n}\n\nint dx[] = {-INF, -1, 0, 1};\n\nsigned main() {\n    while(cin >> N >> M, N || M) {\n        cin >> s >> g; s--; g--;\n        vector< vector<Edge> > G(N);\n        rep(i,0,M) {\n            int x, y; double d; int c; cin >> x >> y >> d >> c;\n            x--; y--;\n            G[x].push_back(Edge{y, d, c});\n            G[y].push_back(Edge{x, d, c});\n        }\n\n        rep(i,0,N) rep(j,0,T) rep(k,0,4) dist[i][j][k] = INF;\n        dist[s][1][0] = 0.0;\n\n        priority_queue<Elem> q;\n        q.push(Elem{s, 1, -1, 0});\n\n        double ans = INF;\n        while(!q.empty()) {\n            Elem t = q.top(); q.pop();\n            rep(i,1,4) {\n                int sp = t.speed + dx[i];\n                if(sp == 0) continue;\n                for(auto x : G[t.cur]) {\n                    if(x.lim < t.speed || x.to == t.prev) continue;\n                    double c = x.cost / t.speed;\n                    if(dist[x.to][sp][i] >= dist[t.cur][t.speed][t.prevs] + c) {\n                        dist[x.to][sp][i] = dist[t.cur][t.speed][t.prevs] + c;\n                        if(x.to == g && t.speed == 1) {\n                            chmin(ans, dist[x.to][sp][i]);\n                            break;\n                        }\n                        q.push(Elem{x.to, sp, t.cur, i});\n                    }\n                }\n            }\n        }\n        if(ans == INF) cout << \"unreachable\" << endl;\n        else printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int INF = 1e15;\n\nstruct Edge {\n  int to, d, c;  \n};\n\nint s, g;\nint n, m;\nvector<Edge> G[31];\n\ntypedef pair<int, int> P;\ntypedef pair<double, P> E;\n\ndouble dij() {\n  double ret = INF;  \n  bool used[n][101];\n  fill_n(*used, n*101, false);\n  priority_queue<E, vector<E>, greater<E> > q;\n  q.push(E(0, P(s, 1)));\n  while ( !q.empty() ) {\n    E e = q.top(); q.pop();    \n    double c = e.first;\n    int u = e.second.first, v = e.second.second;\n    // cout << u << \" \" << v << endl;\n    if ( u == g && v == 1 ) {\n      // return c;\n    }\n\n    if ( used[u][v] ) continue;\n    used[u][v] = true;    \n    for ( Edge &f : G[u] ) {\n      if ( f.c < v ) continue;\n      if ( f.to == g && v == 1 ) {\n\tret = min(ret, c+(double)f.d);\t\n      }\n      q.push(E(c+(double)f.d/v, P(f.to, v)));\n      q.push(E(c+(double)f.d/v, P(f.to, v+1)));\n      if ( v >= 2 ) q.push(E(c+(double)f.d/v, P(f.to, v-1)));      \n    }\n  }\n\n  return ret;\n}\n\nsigned main() {  \n  while ( cin >> n >> m, n ) {\n    for ( int i = 0; i < 31; i++ ) G[i].clear();    \n    cin >> s >> g;\n    s--; g--;\n    for ( int i = 0; i < m; i++ ) {\n      int a, b, d, c;\n      cin >> a >> b >> d >> c;\n      a--; b--;\n      G[a].emplace_back(Edge{b, d, c});\n      G[b].emplace_back(Edge{a, d, c});\n    }\n\n    double ans = dij();\n    if ( ans >= INF-100 ) cout << \"unreachable\" << endl;\n    else printf(\"%.10lf\\n\", ans);    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\nusing namespace std;\nint n,m,s,g;\ndouble d[33][33][33];\nvector<pair<int,pair<int,int> > >G[33];\nmain()\n{\n\twhile(cin>>n>>m,n)\n\t{\n\t\tcin>>s>>g;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=30;j++)for(int k=1;k<=n;k++)d[i][j][k]=1e9;\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint u,v,d,c;\n\t\t\tcin>>u>>v>>d>>c;\n\t\t\tG[u].push_back({v,{d,c}});\n\t\t\tG[v].push_back({u,{d,c}});\n\t\t}\n\t\tpriority_queue<pair<pair<double,int>,pair<int,int> > >P;\n\t\tP.push({{0,0},{s,0}});\n\t\td[s][0][0]=0;\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tdouble c=-P.top().first.first;\n\t\t\tint prev=P.top().first.second;\n\t\t\tint u=P.top().second.first,speed=P.top().second.second;\n\t\t\tP.pop();\n\t\t\tif(d[u][speed][prev]<c)continue;\n\t\t\tfor(int i=0;i<G[u].size();i++)\n\t\t\t{\n\t\t\t\tint v=G[u][i].first,di=G[u][i].second.first,se=G[u][i].second.second;\n\t\t\t\tif(v==prev)continue;\n\t\t\t\tfor(int j=-1;j<=1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(speed+j<=0||speed+j>se)continue;\n\t\t\t\t\tdouble ne=c+(double)di/(speed+j);\n\t\t\t\t\tif(d[v][speed+j][u]>ne)\n\t\t\t\t\t{\n\t\t\t\t\t\td[v][speed+j][u]=ne;\n\t\t\t\t\t\tP.push({{-ne,u},{v,speed+j}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans=1e9;\n\t\tfor(int i=1;i<=n;i++)ans=min(ans,d[g][1][i]);\n\t\tif(ans<1e9)cout<<fixed<<setprecision(9)<<ans<<endl;\n\t\telse cout<<\"unreachable\"<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Problem     : AOJ1162\n * Title       : Discrete Speed (離散的速度)\n * Author      : mizo0203\n * Copyright   : Your copyright free\n * Description : ダイクストラ\n */\n#include <stdio.h>\n#include <utility> // pairライブラリを使用するのに必要\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define MAX_V (31*31)\n#define INF 3000000\nusing namespace std;\n\nstruct edge {\n  int to;\n  double cost;\n};\ntypedef pair<int, int> Q;\ntypedef pair<double, Q> P;\n\nint V;\nvector<edge> G[MAX_V];\ndouble d[31][MAX_V];\n\nint n, s, g;\n\nbool input() {\n  int i, k;\n  int m, x, y, d, c;\n  edge e;\n\n  scanf(\"%d %d\", &n, &m);\n  if (!n && !m)\n    return false;\n\n  V = (n + 1) * 31;\n  scanf(\"%d %d\", &s, &g);\n  for (i = 0; i < V; i++) {\n    G[i].clear();\n  }\n  for (i = 0; i < m; i++) {\n    scanf(\"%d %d %d %d\", &x, &y, &d, &c);\n    for (k = 1; k <= c; k++) {\n      e.cost = (double) d / k;\n      e.to = k * (n + 1) + y;\n      G[(k - 1) * (n + 1) + x].push_back(e);\n      G[k * (n + 1) + x].push_back(e);\n      if (k < 30)\n        G[(k + 1) * (n + 1) + x].push_back(e);\n      e.to = k * (n + 1) + x;\n      G[(k - 1) * (n + 1) + y].push_back(e);\n      G[k * (n + 1) + y].push_back(e);\n      if (k < 30)\n        G[(k + 1) * (n + 1) + y].push_back(e);\n    }\n    /*\n     e.cost = (double) d / k;\n     if (j != y) {\n     e.to = k * (n + 1) * (n + 1) + x * (n + 1) + y;\n     G[(k - 1) * (n + 1) * (n + 1) + j * (n + 1) + x].push_back(e);\n     e.to = k * (n + 1) * (n + 1) + x * (n + 1) + y;\n     G[k * (n + 1) * (n + 1) + j * (n + 1) + x].push_back(e);\n     }\n     if (j != x) {\n     e.to = k * (n + 1) * (n + 1) + y * (n + 1) + x;\n     G[(k - 1) * (n + 1) * (n + 1) + j * (n + 1) + y].push_back(e);\n     e.to = k * (n + 1) * (n + 1) + y * (n + 1) + x;\n     G[k * (n + 1) * (n + 1) + j * (n + 1) + y].push_back(e);\n     }\n     */\n  }\n\n  return true;\n}\n\nvoid dijkstra() {\n  priority_queue<P, vector<P>, greater<P> > que;\n  fill(d[0], d[0] + (31 * MAX_V), INF);\n  d[0][s] = 0.0;\n  que.push(P(0.0, Q(0, s)));\n\n  while (!que.empty()) {\n    P p = que.top();\n    Q q = p.second;\n    que.pop();\n    int j = q.first;\n    int v = q.second;\n    if (d[j][v] < p.first)\n      continue;\n    for (int i = 0; i < (int) G[v].size(); i++) {\n      edge e = G[v][i];\n      if (d[v % (n + 1)][e.to] > d[j][v] + e.cost) {\n        d[v % (n + 1)][e.to] = d[j][v] + e.cost;\n        que.push(P(d[v % (n + 1)][e.to], Q(v % (n + 1), e.to)));\n        /*\n         printf(\"%d => %d(%d) => %d(%d): %f\\n\", j, v % (n + 1), v / (n + 1),\n         e.to % (n + 1), e.to / (n + 1), d[v % (n + 1)][e.to]);\n         */\n      }\n    }\n  }\n}\n\nint main() {\n  int i;\n  double min_cost;\n\n  while (input()) {\n    /*\n     for (i = 0; i < V; i++) {\n     for (int j = 0; j < (int) G[i].size(); j++) {\n     printf(\"%d(%d) => %d(%d): %f\\n\", i % (n + 1), i / (n + 1),\n     G[i][j].to % (n + 1), G[i][j].to / (n + 1), G[i][j].cost);\n     }\n     }\n     */\n    dijkstra();\n    min_cost = d[0][1 * (n + 1) + g];\n    for (i = 1; i <= n; i++) {\n      if (min_cost > d[i][1 * (n + 1) + g])\n        min_cost = d[i][1 * (n + 1) + g];\n    }\n    if (min_cost != INF)\n      printf(\"%f\\n\", min_cost);\n    else\n      printf(\"unreachable\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\n\nusing namespace std;\n\ntypedef vector< vector<int> > graph;\n\nclass Node{\npublic:\n\tint p, v, prev; double cost;\n\tNode(int p, int v, int prev, double cost) : p(p), v(v), prev(prev), cost(cost) {}\n\tbool operator < (const Node &nd) const { return cost > nd.cost; }\n};\n\nint main(){\n\tint n, m, s, g;\n\twhile(cin >> n >> m){\n\t\tif(!(n||m)) break;\n\t\tcin >> s >> g;\n\t\tgraph gp(n);\n\t\tint dist[30][30];\n\t\tint limit[30][30];\n\t\tbool visit[30][31][30];\n\t\tmemset(visit, false, sizeof(visit));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tgp[x-1].push_back(y-1);\n\t\t\tgp[y-1].push_back(x-1);\n\t\t\tdist[x-1][y-1] = d,  dist[y-1][x-1] = d;\n\t\t\tlimit[x-1][y-1] = c, limit[y-1][x-1] = c;\n\t\t}\n\t\tpriority_queue<Node> qu; qu.push(Node(s-1,0,s-1,0.0));\n\t\tdouble ans = -1.0;\n\t\twhile(!qu.empty()){\n\t\t\tNode nd = qu.top(); qu.pop();\n\t\t\tint p = nd.p, v = nd.v, prev = nd.prev;\n\t\t\tif(visit[p][v][prev]) continue;\n\t\t\tvisit[p][v][prev] = true;\n\t\t\tif(p==g-1 && v==1){\n\t\t\t\tans = nd.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<gp[p].size();i++){\n\t\t\t\tint next = gp[p][i];\n\t\t\t\tif(next==prev) continue;\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tint nv = v+j;\n\t\t\t\t\tif(nv<=0||limit[p][next]<nv) continue;\n\t\t\t\t\tqu.push(Node(next,nv,p,nd.cost+(double)dist[p][next]/nv));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans < 0.0) cout << \"unreachable\" << endl;\n\t\telse          printf(\"%.5f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nstruct State {\n    int i, prev, sp; double cost;\n};\n\nbool operator>(const State& a, const State& b)\n{\n    return a.cost > b.cost;\n}\n\nconst double INF = 1<<29;\nint vis[40][40][40];\ndouble dist[40][40];\nint lim[40][40];\n\nint main()\n{\n    while (1) {\n        int n, m, s, g; cin >> n >> m >> s >> g;\n        if (!n) break;\n        s--, g--;\n\n        fill(dist[0], dist[39]+40, INF);\n        fill(lim[0], lim[39]+40, 0);\n\n        while (m--) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--, y--;\n            dist[x][y] = dist[y][x] = d;\n            lim[x][y] = lim[y][x] = c;\n        }\n\n        fill(vis[0][0], vis[39][39]+40, 0);\n        priority_queue<State, vector<State>, greater<State>> Q;\n        Q.push({ s, -1, 0, 0 });\n\n        double ans = INF;\n        while (Q.size()) {\n            auto e = Q.top(); Q.pop();\n            if (vis[e.i][e.sp][e.prev]) continue;\n            vis[e.i][e.sp][e.prev] = 1;\n            if (e.i == g && e.sp == 1) ans = min(ans, e.cost);\n            loop (n, i) loop (3, d) {\n                int sp = e.sp-1+d;\n                if (dist[e.i][i] == INF || i == e.prev ||\n                        sp < 1 || sp > lim[e.i][i]) continue;\n                Q.push({ i, e.i, sp, e.cost + dist[e.i][i] / sp });\n            }\n        }\n        if (ans != INF) cout << setprecision(12) << fixed << ans << endl;\n        else cout << \"unreachable\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct road {\n  int from, to, d, c;\n  road(int x, int y, int z, int w) : from(x), to(y), d(z), c(w) {}\n};\n\n\nstruct state {\n  int node;\n  int prev;\n  int v;\n  double time;\n  state(int a, int p, int b, double c) : node(a), prev(p), v(b), time(c) {}\n\n  bool operator<(const state& s) const\n  {\n    return time > s.time;\n  }\n};\n\nint main()\n{\n  int n, m;\n  while (cin >> n >> m && n != 0) {\n    int start, goal;\n    cin >> start >> goal;\n    start--;  goal--;\n\n    vector<vector<road> > g(n);\n    for (int i = 0; i < m; i++) {\n      int u, v, d, c;\n      cin >> u >> v >> d >> c;\n      u--;  v--;\n      g[u].push_back(road(u, v, d, c));\n      g[v].push_back(road(v, u, d, c));\n    }\n\n    priority_queue<state> q;\n    q.push(state(start, -1, 0, 0.0));\n    vector<vector<double> > costs(n, vector<double>(32, 1e10));\n    costs[0][0] = 0.0;\n    while (!q.empty()) {\n      state s = q.top();\n      q.pop();\n\n      if (s.node == goal) {\n        if (s.v == 1) {\n          printf(\"%.4f\\n\", s.time);\n          goto NEXT;\n        }\n      }\n\n      for (int i = 0; i < g[s.node].size(); i++) {\n        const road r = g[s.node][i];\n        for (int dv = -1; dv <= 1; dv++) {\n          const int v = s.v + dv;\n          if (v <= 0 || v > r.c) {\n            continue;\n          }\n          if (r.to == s.prev) {\n            continue;\n          }\n          double c = double(r.d) / v;\n          if (s.time + c < costs[r.to][v]) {\n            costs[r.to][v] = s.time + c;\n            q.push(state(r.to, s.node, v, s.time + c));\n          }\n        }\n      }\n    }\n    cout << \"unreachable\" << endl;\nNEXT:\n    ;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst double EPS=1e-7;\nstruct edge{\n    int to,dis,lim;\n    edge(int a,int b,int c):to(a),dis(b),lim(c){}\n};\ntypedef tuple<double,int,int,int>state;\nvector<edge>G[30];\ndouble dist[30][30][31];\n\nsigned main(){\n    int N,M;\n    int S,T;\n    while(cin>>N>>M,N||M){\n        cin>>S>>T;\n        S--;T--;\n\n        rep(i,N)G[i].clear();\n\n        rep(i,M){\n            int a,b,c,d;\n            cin>>a>>b>>c>>d;\n            a--;b--;\n            G[a].pb(edge(b,c,d));\n            G[b].pb(edge(a,c,d));\n        }\n        fill_n(**dist,30*30*31,1001001001);\n        dist[S][S][0]=0;\n        priority_queue<state,vector<state>,greater<state>>que;\n        que.push(make_tuple(0,S,S,0));\n        while(que.size()){\n            double c;\n            int v,p,vv;\n            tie(c,v,p,vv)=que.top();\n            que.pop();\n            if(dist[v][p][vv]<c)continue;\n            for(auto &e:G[v]){\n                if(e.to==p)continue;\n                for(int dv=-1;dv<=1;dv++){\n                    int nv=vv+dv;\n                    if(nv<=0||nv>e.lim)continue;\n                    double nc=c+1.0*e.dis/nv;\n                    if(dist[e.to][v][nv]<nc+EPS)continue;\n                    dist[e.to][v][nv]=nc;\n                    que.push(make_tuple(nc,e.to,v,nv));\n                }\n            }\n        }\n\n        double ans=1001001001;\n        for(int i=0;i<N;i++)chmin(ans,dist[T][i][1]);\n        if(ans==1001001001)cout<<\"unreachable\"<<endl;\n        else printf(\"%.20f\\n\",ans);\n        }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1e9\nusing namespace std;\ndouble cost[30][30][31]; int d[30][30],c[30][30],v[30][30][31];\nstruct S{\n\tdouble cc;int c,p,v;\n\tS(double cc,int c,int p,int v):cc(cc),c(c),p(p),v(v){}\n\tbool operator<(const S &a)const{\n\t\treturn cc>a.cc;\n\t}\n};\nint main(){\n\tint n,m,s,g,x,y,a,b; double nc;\n\twhile(~scanf(\"%d%d\",&n,&m)&&n){\n\t\tscanf(\"%d%d\",&s,&g),s--,g--;\n\t\trep(i,n)rep(j,n){\n\t\t\trep(k,31)cost[i][j][k]=INF,v[i][j][k]=0;\n\t\t\td[i][j]=c[i][j]=0;\n\t\t}\n\t\trep(i,m)scanf(\"%d%d%d%d\",&x,&y,&a,&b),\n\t\tx--,y--,d[x][y]=d[y][x]=a,c[x][y]=c[y][x]=b;\n\t\tpriority_queue<S> F; F.push(S(0,s,s,0)); cost[s][s][0]=0;\n\t\twhile(!F.empty()){\n\t\t\tS cs=F.top(); F.pop();\n\t\t\tv[cs.c][cs.p][cs.v]=1;\n\t\t\tif(cs.c==g&&cs.v==1){\n\t\t\t\tprintf(\"%.5f\\n\",cs.cc); goto END;\n\t\t\t}\n\t\t\trep(i,n)if(i!=cs.p&&d[cs.c][i])\n\t\t\tfor(int dv=-1;dv<2;dv++)if(!v[i][cs.c][dv+cs.v]&&0<dv+cs.v&&dv+cs.v<=c[cs.c][i]){\n\t\t\t\tnc=cost[cs.c][cs.p][cs.v]+1.*d[cs.c][i]/(dv+cs.v);\n\t\t\t\tif(cost[i][cs.c][dv+cs.v]>nc)\n\t\t\t\tcost[i][cs.c][dv+cs.v]=nc,F.push(S(nc,i,cs.c,dv+cs.v));\n\t\t\t}\n\t\t}\n\t\tprintf(\"unreachable\\n\"); END:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nclass Node {\npublic:\n  int pre;\n  int now;\n  int vel;\n  double time;\n\n  Node(int p, int n, int v, double t) {\n    pre = p;\n    now = n;\n    vel = v;\n    time = t;\n  }\n\n  bool operator<(const Node &n) const {\n    return time > n.time;\n  }\n};\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n\n    if (n == 0) {\n      break;\n    }\n\n    int s, g;\n    cin >> s >> g;\n\n    vector<vector<int> > d(n + 1), c(n + 1);\n    for (int i = 0; i <= n; i++) {\n      d[i].resize(n + 1);\n      c[i].resize(n + 1);\n      fill(d[i].begin(), d[i].end(), -1);\n      fill(c[i].begin(), c[i].end(), 0);\n    }\n\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      cin >> d[x][y] >> c[x][y];\n      d[y][x] = d[x][y];\n      c[y][x] = c[x][y];\n    }\n  \n    bool goal = false;\n    Node snd(0, 1, 0, 0.0);\n    priority_queue<Node> q;\n    q.push(snd);\n    while (!q.empty()) {\n      Node nd = q.top();\n      q.pop();\n      if (nd.now == g && nd.vel == 1) {\n\tgoal = true;\n\tcout << nd.time << endl;\n\tbreak;\n      }\n    \n      for (int i = 1; i <= n; i++) {\n\tif (i != nd.now && d[nd.now][i] != -1) {\n\t  for (int j = -1; j <= 1; j++) {\n\t    int vel = nd.vel + j;\n\t    if (vel > 0 && vel <= c[nd.now][i]) {\n\t      Node next(nd.now, i, vel, nd.time + (double)d[nd.now][i] / vel);\n\t      q.push(next);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    if (!goal) {\n      cout << \"unreachable\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n最初にスタート地点からでるときはスピードが１でなければならないのを忘れてた\nゴールは到着したら即終了というわけではない\nというかゴールにスピード１以外で到着しても良い（でもゴールしたいときは１でないといけない）\n*/\n\n#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<iomanip>\n#include<deque>\n#define F first\n#define S second\n#define MAX_N 32\n#define MAX_D 32\n#define INF (1<<28)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef pair<int,P> iP;\ntypedef pair<int,int> iiP;\ntypedef pair<iiP,P> PP;\ntypedef vector<vector<iP> > VViP;\nint n,m,s,g;\nVViP G;\ndouble mincost[MAX_N][MAX_N][MAX_D]; // mincost[from][to][speed]\nint sp[] = {-1,0,+1};\n\nvoid dijkstra()\n{\n\n  deque<PP> deq; // iiPP(iiP(now,pre),P(cost,speed))\n\n  \n  deq.push_front(PP(iiP(s,s),P(0,1)));\n\n  mincost[s][s][1] = 0; \n  double ans = INF;  \n\n  \n  while(!deq.empty())\n    {\n      PP p = deq.front(); deq.pop_front();\n      int now,pre;\n      double cost,speed;\n      now = p.F.F, pre = p.F.S;\n      cost = p.S.F, speed = p.S.S;\n\n      if(cost >= ans)\n\tcontinue;      \n\n      if(now == g && speed == 1)\n\t{\n\t  ans = min(ans,cost);\t\n\t  continue;\n\t}\t\n\n      for(int i=0;i<G[now].size();i++)\n\t{\n\t  iP ip = G[now][i]; // VViP -> iP(to,P(distance,limit))\n\t  int to = ip.F;\n\t  double dis,lim;\n\t  dis = ip.S.F, lim = ip.S.S;\n\t  if(pre == to)\n\t    continue;\n\n\t  for(int j=0;j<3;j++)\n\t    {\n\t      double new_speed = speed + sp[j];\n\t      if(new_speed <= 0 || new_speed > lim)\n\t\tcontinue;\n\n\t      if(now == s && pre == s && new_speed != 1)\n\t\tcontinue;\n\n\t      if(mincost[now][to][(int)new_speed] > cost + (double)dis/new_speed)\n\t\t{\n\t\t  mincost[now][to][(int)new_speed] = cost + (double)dis/new_speed;\n\t\t  if(mincost[now][to][(int)new_speed] < deq.front().S.F)deq.push_front(PP(iiP(to,now),P(mincost[now][to][(int)new_speed],new_speed)));\n\t\t  else \n\t\t    deq.push_back(PP(iiP(to,now),P(mincost[now][to][(int)new_speed],new_speed)));\n\t\t}\n\t    }\n\n\t}\n\n    }\n  \n\n  if(ans == INF)\n    cout << \"unreachable\" << endl;\n  else \n    cout << setiosflags(ios::fixed) << setprecision(5) << ans << endl;\n  \n}\n\nint main()\n{\n\n  while(true)\n    {\n      cin >> n >> m;\n      if(n+m == 0)\n\tbreak;\n      G.clear();\n      G.resize(n+1);\n      rep(i,n+1)\n\trep(j,n+1)\n\t  rep(k,31)\n\t    mincost[i][j][k] = INF;\n\n      cin >> s >> g;\n      rep(i,m)\n\t{\n\t  int x,y;\n\t  double d,c;\n\t  cin >> x >> y >> d >> c;\n\t  G[x].push_back(iP(y,P(d,c)));\n\t  G[y].push_back(iP(x,P(d,c)));\n\t}\n      \n      dijkstra();\n  \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <string.h>\n#include <numeric>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(i,v) for(auto &(i):(v))\n#define eachr(i,v) for(auto &(i)=(v).rbegin();(i)!=(v).rend();(i)++)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n#define endl \"\\n\"\n\n//typedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a/gcd(a,b)*b;}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n    oreno_initializer() {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n} oreno_initializer;\n\n\n\nint n, m, s, g, x, y, b;\n// 町iに到達したとき速度jであるような最短距離 たどり着いた瞬間の値ってことに注意\ndouble d[33][33], a, res;\n// 町i速度jから伸びる(移動先、コスト)の辺\nvector<pair<int, pair<double, int> > > e[33][33];\n\ntypedef pair<double, pair<int, pair<int, int > > > ppap;\nvoid dijkstra() {\n    priority_queue<ppap, vector<ppap>, greater<ppap> > q;\n    // dist v p speed\n    q.push({0.0, {s, {-1, 1}}});\n    while(!q.empty()) {\n        int v = q.top().second.first, pa = q.top().second.second.first, sp = q.top().second.second.second;\n        double dis = q.top().first;\n        q.pop();\n        if (d[v][sp]<dis) continue;\n        int spl = max(1, sp-1), spr = min(30, sp+1);\n        if (dis==0.0) spl = spr = 1;\n        reps(ts,spl,spr+1) for (int i = 0; i < e[v][ts].size(); i++) {\n            int to = e[v][ts][i].first, id = e[v][ts][i].second.second;\n            if (id==pa) continue;\n            double cost = e[v][ts][i].second.first;\n            if (d[to][ts] > d[v][sp] + cost) {\n                d[to][ts] = d[v][sp] + cost;\n                q.push({d[to][ts], {to, {id, ts}}});\n                if (to==g && ts==1) chmin(res, d[to][ts]);\n            }\n        }\n    }\n}\n\nsigned main() {\n    while (1) {\n        cin >> n >> m;\n        if (n==0) break;\n        rep(i,n) rep(j,33) e[i][j].clear(), d[i][j] = 1e100;\n        cin >> s >> g;\n        s--, g--;\n        d[s][1] = 0;\n        rep(j,m) {\n            cin >> x >> y >> a >> b;\n            x--, y--;\n            int id = 0;\n            reps(i,1,b+1) {\n                e[x][i].push_back({y, {a/i, id}});\n                e[y][i].push_back({x, {a/i, id++}});\n            }\n        }\n        res = 1e100;\n        dijkstra();\n        //rep(i,n) rep(j,30) cout << d[i][j] << bln(j,30);\n        if (res==1e100) printf(\"unreachable\\n\");\n        else printf(\"%.14lf\\n\", res);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n||m){\n    cin>>s>>g;\n    s--;g--;\n    int d[n][n],c[n][n];\n    memset(d,-1,sizeof(d));\n    memset(c,-1,sizeof(c));\n    int i,j,k,l,x,y;\n    for(i=0;i<m;i++){\n      cin>>x>>y>>j>>k;\n      x--;y--;\n      d[x][y]=d[y][x]=j;\n      c[x][y]=c[y][x]=k;\n    }\n    double v[n][50];\n    double inf=1<<28,p;\n    for(i=0;i<n;i++) for(j=0;j<50;j++) v[i][j]=inf;\n    v[s][0]=0;\n    typedef pair<int,int> PPP;\n    typedef pair<int,PPP> P;\n    typedef pair<double,P> PP;\n    priority_queue<PP,vector<PP>,greater<PP> > q;\n    q.push(PP(v[s][0],P(s,PPP(1,-1))));\n    while(!q.empty()){\n      x=q.top().second.first;\n      y=q.top().second.second.first;\n      k=q.top().second.second.second;\n      p=q.top().first;q.pop();\n      //cout << x << y << k << p << endl;\n      if(v[x][y]<=p) continue;\n      v[x][y]=p;\n      if(x==g&&y==1) break;\n      for(i=0;i<n;i++){\n\tif(!~d[x][i]||i==k) continue;\n\tfor(j=-1;j<=1;j++){\n\t  if(x==s&&p==0&&j!=0) continue;\n\t  if(y+j<=0||c[x][i]<y+j) continue;\n\t  q.push(PP(p+(double)d[x][i]/(y+j),P(i,PPP(y+j,x))));\n\t}\n      }\n    }\n    if(v[g][1]!=inf) printf(\"%.8f\\n\",v[g][1]);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<cmath>\n#include<vector>\n#include<functional>\n#define ull unsigned long long int \n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define min_(a,b) ((a)<(b)?(a):(b))\nusing namespace std;\n\n#define INF 10000000\n#define MAX_V 1000 \nstruct edge{ int to; double time; };\nvector<edge>G[MAX_V];\ndouble d[MAX_V];\nstruct T{\n\tdouble time;\n\tint from, to;\n};\nint V,E,st,gl;\n\nstruct StructGreater {\n\tbool operator() (const T a, const T b) {\n\t\treturn a.time > b.time;\n\t}\n};\nvoid dk(int s){\n\tfill(d, d + MAX_V, INF);\n\tpriority_queue<T, vector<T>, StructGreater >que;\n\ts = s * 30 + 0;\n\t//d[s] = 0;\n\trep(i, 0, (int)G[s].size())\n\tif (G[s][i].to%30==0){\n\t\t//printf(\"to=%d,time=%f\\n\", G[s][i].to / 30 + 1, G[s][i].time);\n\t\tT t = { G[s][i].time, s / 30, G[s][i].to };\n\t\tque.push(t);\n\t\td[G[s][i].to] = G[s][i].time;\n\t}\n\t//T tx = { 0,-1, 0 };\n\t//que.push(tx);\n\twhile (!que.empty()){\n\t\tT t = que.top(); que.pop();\n\t\tint v = t.to;\n\n\t\tif (d[v] < t.time)continue;\n\t\trep(i, 0, (int)G[v].size()){\n\t\t\tedge e = G[v][i];\n\t//\t\tprintf(\"%d->%d,%d->%d,\\n\", v / 30 + 1, e.to / 30 + 1,v % 30 + 1, e.to % 30 + 1);\n\t\t\tif (e.to / 30 != t.from&&d[e.to]>d[v] + e.time){\n\t\t\t\td[e.to] = d[v] + e.time;\n\t//\t\t\tprintf(\"(%d<%d<%d)%d,%f\\n\", e.to / 30 + 1, t.to / 30 + 1, t.from + 1, e.to % 30 + 1,d[e.to]);\n\t\t\t\tT tmp = { d[e.to], v / 30, e.to };\n\t\t\t\tque.push(tmp);\n\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i, 0, MAX_V)if (d[i] < INF)\n\t\t//printf(\"to=%d,time=%f\\n\", i / 30 + 1, d[i]);\n}\n\nint main(void){\n\twhile (true){\n\t\tcin >> V >> E;\n\t\tif (V == 0)return 0;\n\t\tcin >> st >> gl;\n\t\tst--; gl--;\n\t\trep(i, 0, E){\n\t\t\tint first, second, lim;\n\t\t\tdouble length;\n\t\t\tcin >> first >> second >> length >> lim;\n\t\t\tfirst--;\n\t\t\tsecond--;\n\t\t//\tcout << first << second << endl;\n\t\t\trep(i, 1, 31){\n\t\t\t\tdouble real_v;\n\t\t\t\t//始点\n\t\t\t\tint f = first * 30 + i - 1;\n\t\t\t\tint s = second * 30 + i - 1;\n\t\t\t\trep(j, -1, 2){\n\t\t\t\t\treal_v = i + j;\n\t\t\t\t\t//cout << real_v << endl;\n\t\t\t\t\tif (real_v<1 || real_v>lim)continue;\n\t\t\t\t\treal_v = length / real_v;\n\t\t\t\t\tedge f_e = { f + j, real_v }; edge s_e = { s + j, real_v };\n\t\t\t\t//\tcout << first << second << gl<<endl;\n\t\t\t\t\tG[f].push_back(s_e); \n\t\t\t\t\tG[s].push_back(f_e);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*rep(i, 0, MAX_V)\n\t\t\trep(j, 0, (int)G[i].size()){\n\t\t\t\tprintf(\"from=%d,to=%d,v=%d->%d,time=%f\\n\", i / 30 + 1, G[i][j].to / 30 + 1, i % 30 + 1, G[i][j].to % 30 + 1, G[i][j].time);\n\n\t\t\t}\n*/\n\t\tdk(st);\n\t\tif (d[gl * 30]<INF)\n\t\tprintf(\"%.8f\\n\", d[gl * 30]);\n\t\telse cout << \"unreachable\" << endl;\n\t\trep(i, 0, MAX_V)\n\t\twhile (!G[i].empty())\n\t\t\t\tG[i].pop_back();\n\t\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nstruct node{\n    int pos,v,prev;\n    double dist;\n    \n    node(){}\n    \n    node(int _pos, int _v, int _prev, double _dist) : pos(_pos), v(_v), prev(_prev), dist(_dist) {}\n    \n    bool operator < (node X)const{\n        return dist > X.dist;\n    }\n};\n\nint main(){\n    int n,m,s,e,dist[31][31],sp[31][31];\n    bool visited[31][31][31];\n    double best[31][31][31];\n    \n    while(true){\n        scanf(\"%d %d\",&n,&m);\n        \n        if(n == 0) break;\n        \n        scanf(\"%d %d\",&s,&e);\n        \n        memset(dist,-1,sizeof dist);\n        \n        for(int i = 0,u,v,w,x;i < m;++i){\n            scanf(\"%d %d %d %d\",&u,&v,&w,&x);\n            dist[u][v] = dist[v][u] = w;\n            sp[u][v] = sp[v][u] = x;\n        }\n        \n        priority_queue<node> Q;\n        \n        memset(visited,false,sizeof visited);\n        bool found = false;\n        \n        for(int i = 1;i <= n;++i)\n            for(int j = 0;j <= 30;++j)\n                for(int k = 1;k <= n;++k)\n                    best[i][j][k] = 1e10;\n        \n        Q.push(node(s,0,s,0));\n        best[s][0][s] = 0;\n        \n        while(!Q.empty()){\n            node cur = Q.top();\n            Q.pop();\n            \n            if(visited[cur.pos][cur.v][cur.prev]) continue;\n            visited[cur.pos][cur.v][cur.prev] = true;\n            \n            if(cur.pos == e && cur.v == 1){\n                printf(\"%.6f\\n\",cur.dist);\n                found = true;\n                break;\n            }\n            \n            for(int dv = -1;dv <= 1;++dv)\n                for(int i = 1;i <= n;++i)\n                    if(dist[cur.pos][i] != -1 && i != cur.prev && cur.v + dv > 0 && cur.v + dv <= sp[cur.pos][i] && !visited[i][cur.v + dv][cur.pos])\n                        if(cur.dist + (double)dist[cur.pos][i] / (cur.v + dv) < best[i][cur.v + dv][cur.pos]){\n                            Q.push(node(i,cur.v + dv,cur.pos,cur.dist + (double)dist[cur.pos][i] / (cur.v + dv)));\n                            best[i][cur.v + dv][cur.pos] = cur.dist + (double)dist[cur.pos][i] / (cur.v + dv);\n                        }\n        }\n        \n        if(!found) puts(\"unreachable\");\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<set>\n#include<string>\n#include<map>\n#include<cmath>\n#include<queue>\n#define P pair<int ,int>\nusing namespace std;\n\nint spd[3] = {1, 0, -1};\n\nstruct E {\n\tint dst, cost, lim;\n\tE(int d, int c, int l) {\n\t\tdst = d;\n\t\tcost = c;\n\t\tlim = l;\n\t}\n};\n\nstruct N {\n\tint pos, bef, spd;\n\tdouble ti;\n\tN(int p, int b, int s, double t) {\n\t\tpos = p;\n\t\tbef = b;\n\t\tspd = s;\n\t\tti = t;\n\t}\n\tN(){}\n};\n\nbool operator < (N n1, N n2) {\n\treturn n1.ti > n2.ti;\n}\n\nint main()\n{\n\tint n, m, s, g;\n\tint x, y, d, c;\n\tN no;\n\twhile (cin >> n >> m, n) {\n\t\tcin >> s >> g;\n\t\tbool ef = 0;\n\t\tbool f[31][31][31];\n\t\tmemset(f, 0, sizeof(f));\n\t\tvector<vector<E> > e(n + 1);\n\t\t\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\te[x].push_back(E(y, d, c));\n\t\t\te[y].push_back(E(x, d, c));\n\t\t}\n\t\t\n\t\tpriority_queue<N> pq;\n\t\tpq.push(N(s, s, 0, 0));\n\t\t\n\t\twhile (!pq.empty()) {\n\t\t\tno = pq.top();\n\t\t\tpq.pop();\n\t\t\tif (f[no.pos][no.bef][no.spd]) continue;\n\t\t\tf[no.pos][no.bef][no.spd] = 1;\n\t\t\t\n\t\t\tif (no.pos == g && no.spd == 1) {\n\t\t\t\tef = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < e[no.pos].size(); i++) {\n\t\t\t\tif (no.bef == e[no.pos][i].dst) continue;\n\t\t\t\t\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (no.spd + spd[j] > 0 && e[no.pos][i].lim >= no.spd + spd[j])\n\t\t\t\t\t\tpq.push(N(e[no.pos][i].dst, no.pos, no.spd + spd[j], no.ti + e[no.pos][i].cost / (double)(no.spd + spd[j])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ef) printf(\"%.5lf\\n\", no.ti);\n\t\telse cout << \"unreachable\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define NODE 30\n#define LIM 31\nconst double inf = 1e200;\n\nclass state{\npublic:\n  int cur,prev,speed;\n  double c;\n  state(){};\n  state(int tcur,int tprev,int tspeed,double tc):cur(tcur),prev(tprev),\n\t\t\t\t\t\t speed(tspeed),c(tc){};\n  bool operator<(const state & a)const{\n    return c >a.c;\n  }\n};\n\ndouble cost[30][30][31];\ndouble dist[30][30];\nint lim[30][30];\nbool visited[30][30][31];\n\nvoid solve(int n,int s,int g){\n  rep(i,n)rep(j,n)rep(k,31)cost[i][j][k]=inf,visited[i][j][k]=false;\n  priority_queue<state> Q;\n  cost[0][0][1]=0;\n  rep(i,n){\n    if ( lim[s][i] >= 1){\n      cost[i][s][1]=dist[s][i];\n      Q.push(state(i,s,1,cost[i][s][1]));\n    }\n  }\n\n  while(!Q.empty()){\n    state now = Q.top();\n    Q.pop();\n    if ( visited[now.cur][now.prev][now.speed])continue;\n    visited[now.cur][now.prev][now.speed]=true;\n    if ( now.cur == g && now.speed == 1){\n      printf(\"%.3lf\\n\",now.c);\n      return;\n    }\n    rep(i,n){\n      if ( i == now.prev || i == now.cur)continue;\n      REP(j,-1,2){\n\tif ( now.speed + j > 0 && now.speed + j <= lim[now.cur][i] &&\n\t     cost[i][now.cur][now.speed+j] - now.c - dist[now.cur][i]/(now.speed+j) >0){\n\t  cost[i][now.cur][now.speed+j]=now.c+dist[now.cur][i]/(now.speed+j);\n\t  Q.push(state(i,now.cur,now.speed+j,cost[i][now.cur][now.speed+j]));\n\t}\n      }\n    }\n  }\n\n  puts(\"unreachable\");\n}\n\n\nmain(){\n  int n,m;\n  while(cin>>n>>m && n){\n    rep(i,n)rep(j,n)lim[i][j]=0,dist[i][j]=inf;\n    int s,g;\n    cin>>s>>g;\n    s--;g--;\n    rep(i,m){\n      int f,t,v;\n      double d;\n      cin>>f>>t>>d>>v;\n      f--;t--;\n      dist[f][t]=dist[t][f]=d;\n      lim[f][t]=lim[t][f]=v;\n    }\n    solve(n,s,g);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint to;\n\tdouble cost;\n};\n\ntypedef pair<double,int> P;\n\nint V;\nvector<edge> G[1000];\n\nconst double INF = 1000000000.0;\n\nvoid dijkstra(int s,int g){\n\tdouble d[1000];\n\tint prev[40];\n\n\tfill(prev,prev+40,(int)INF);\n\tfill(d,d+V,INF);\n\t\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\td[s] = 0.0;\n\tque.push(P(0.0,s));\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost && prev[(v-1)/30] != (e.to-1)/30){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t\tprev[(e.to-1)/30] = (v-1)/30;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(EQ(d[g],INF)){\n\t\tcout << \"unreachable\" << endl;\n\t}\n\telse{\n\t\tcout << d[g] << endl;\n\t}\n\n}\n\nint main(){\n\t\n\t// ツ各ツ凝ヲツ甘板づづ債督ッツ暗ェツ都ツ市ツづーツ督楪達ツスツピツーツドツつイツづづ可ノツーツドツづ可閉ェツつッツづつ「ツづゥ\n\t// G 1-30,31-60,61-90...\n\tint n,m,s,g;\n\twhile(cin >> n >> m >> s >> g && !(n == 0 && m == 0)){\n\t\tV = n*30+1;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint to,from,di,c;\n\t\t\tcin >> from >> to >> di >> c;\n\t\t\t// from -> to\n\t\t\tfor(int j = 1; j <= 30; j++){\n\t\t\t\tif(from == s && j == 1){\n\t\t\t\t\tedge e;\n\t\t\t\t\te.to = (to-1)*30+1;\n\t\t\t\t\te.cost = di;\n\t\t\t\t\tG[(s-1)*30+1].push_back(e);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint from2 = (from-1)*30+j;\n\t\t\t\t\tfor(int k = -1; k <= 1; k++){\n\t\t\t\t\t\tif(k+j > 0 && k + j <= c){\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.to = (to-1)*30 + (j+k);\n\t\t\t\t\t\t\te.cost = (double)di/(j+k);\n\t\t\t\t\t\t\tG[from2].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// to -> from\n\t\t\tfor(int j = 1; j <= 30; j++){\n\t\t\t\tif(to == s && j == 1){\n\t\t\t\t\tedge e;\n\t\t\t\t\te.to = (from-1)*30+1;\n\t\t\t\t\te.cost = di;\n\t\t\t\t\tG[(s-1)*30+1].push_back(e);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint from2 = (to-1)*30+j;\n\t\t\t\t\tfor(int k = -1; k <= 1; k++){\n\t\t\t\t\t\tif(k+j > 0 && k + j <= c){\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.to = (from-1)*30 + (j+k);\n\t\t\t\t\t\t\te.cost = (double)di/(j+k);\n\t\t\t\t\t\t\tG[from2].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdijkstra((s-1)*30+1,(g-1)*30+1);\n\n\t\tfor(int i = 0; i < 1000; i++){\n\t\t\tG[i].clear();\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n\tint cost,limit;\n\tedge(int c,int l){\n\t\tcost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tvector<vector<edge> > E(n+1,vector<edge>(n+1,edge(-1,-1)));\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in][out]=edge(c,l);\n\t\tE[out][in]=edge(c,l);\n\t}\n\tvector<vector<double> > Ans(n+1,vector<double>(31,INF));\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){\n\t\tNode t=Q.top(); Q.pop();\n\t\tif(Ans[t.now][t.speed]<=t.time) continue;\t\t\n//\t\tcout<<t.now<<\" \"<<t.speed<<\" \"<<t.time<<endl;\n\t\tif(t.now==g && t.speed==1){cout<<t.time<<endl; return;}\n\t\tAns[t.now][t.speed]=t.time;\n\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tif(i==t.before) continue;\n\t\t\tif(E[t.now][i].cost>0){\n\t\t\t\tif(E[t.now][i].limit>=t.speed && t.speed>=1)\n\t\t\t\t\tQ.push(Node(i,t.speed,t.time+E[t.now][i].cost/(double)t.speed,t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed+1)\n\t\t\t\t\tQ.push(Node(i,t.speed+1,t.time+E[t.now][i].cost/(double)(t.speed+1.0),t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed-1 && t.speed-1>=1)\n\t\t\t\t\tQ.push(Node(i,t.speed-1,t.time+E[t.now][i].cost/(double)(t.speed-1.0),t.now));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\\n\";\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 100 // いつもは1<<29だが小さくすれば時間はやくなる？\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n//自身だー\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 30;\nconst double EPS = 1E-9;\n\nint n, m, s, g;\nstruct edge{\n\tint to;\n\tint cost;\n\tint limit;\n};\nvector<edge> G[101];\ndouble t[101][31];\n\nint main(){\n\twhile(cin >> n >> m && (n || m)){\n\t\tcin >> s >> g;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint from, to;\n\t\t\tedge e;\n\t\t\tcin >> from >> to >> e.cost >> e.limit;\n\t\t\te.to = to;\n\t\t\tG[from].push_back(e);\n\t\t\te.to = from;\n\t\t\tG[to].push_back(e);\n\t\t}\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tfill(t[i], t[i] + 101, -1.0);\n\t\t}\n\t\tt[s][1] = 0;\n\t\tpriority_queue<pair<double, PP>, vector<pair<double, PP> >, greater<pair<double, PP> > > que;\n\t\tque.push(make_pair(0, PP(-1, P(s, 1))));\n\t\twhile(!que.empty()){\n\t\t\tpair<double, PP > ppp = que.top(); que.pop();\n\t\t\tPP pp = ppp.second;\n\t\t\tdouble tm = ppp.first;\n\t\t\tint place = pp.second.first;\n\t\t\tint v = pp.second.second;\n\t\t\tint pre = pp.first;\n\t\t\tif(v == 0) continue;\n\t\t\tfor(size_t i = 0; i < G[place].size(); i++){\n\t\t\t\tedge e = G[place][i];\n\t\t\t\tif(v > e.limit || e.to == pre) continue;\n\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\tif(v + j >= 0 && v + j <= 30){\n\t\t\t\t\t\tif(t[e.to][v+j] < -0.5 || t[e.to][v+j] > t[place][v] + (double)e.cost / v + EPS){\n\t\t\t\t\t\t\tt[e.to][v+j] = t[place][v] + (double)e.cost / (double)v;\n\t\t\t\t\t\t\tque.push(make_pair(t[e.to][v+j], PP(place, P(e.to, v+j))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint a = g;\n\t\tint b = 0;\n\t\tif(t[g][0] < 0) cout << \"unreachable\" << endl;\n\t\telse cout << t[g][0] << endl;\n\t\tfor(int i = 0; i < 101; i++) G[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fs first\n#define sc second\nstruct edge{\n\tint to;\n\tdouble dist;\n\tint conf;\n};\ntypedef pair<double,int> P;\ndouble d[30*30*31],ans,inf=1e9;\nvector<edge> G[31];\nint s,g;\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\trep(i,30*30*31) d[i]=inf;\n\td[s]=0;\n\tans=inf;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint ii=p.sc/900,jj=p.sc%900/30,kk=p.sc%30+1;\n\t\tif(p.fs>d[p.sc]) continue;\n\t\tint v=G[ii][jj].to;\n\t\tif(v==g && kk==1) ans=min(ans,p.fs);\n\t\trep(i,G[v].size()){\n\t\t\tedge e=G[v][i];\n\t\t\tif(e.to==ii) continue;\n\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\tif(ii==30 & kk+j!=1) continue;\n\t\t\t\tif(1<=kk+j && kk+j<=e.conf){\n\t\t\t\t\tint nx=900*v+30*i+(kk+j-1);\n\t\t\t\t\tif(d[nx]>d[p.sc]+e.dist/(kk+j)){\n\t\t\t\t\t\tdouble aa=d[p.sc],bb=e.dist,cc=kk+j;\n//\t\t\t\t\t\tcout << d[p.sc] << \" \" << e.dist/(kk+j) << endl;\n//\t\t\t\t\t\tcout << aa << \" \" << bb << \" \" << cc << \" \" << aa+bb/cc << endl;\n\t\t\t\t\t\td[nx]=aa+bb/cc;\n//\t\t\t\t\t\tprintf(\"%lf\\n\",aa+bb/cc);\n//\t\t\t\t\t\tprintf(\"(from=%d , to=%d , speed=%d)    d=%lf\\n\",v,G[v][i].to,kk+j,d[nx]);\n\t\t\t\t\t\tque.push(P(d[nx],nx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0) break;\n\t\tscanf(\"%d%d\",&s,&g);\n\t\ts--,g--;\n\t\trep(i,31) G[i].clear();\n\t\trep(i,m){\n\t\t\tint x,y,c;\n\t\t\tdouble dd;\n\t\t\tscanf(\"%d%d%lf%d\",&x,&y,&dd,&c);\n\t\t\tx--,y--;\n\t\t\tG[x].push_back({y,dd,c});\n\t\t\tG[y].push_back({x,dd,c});\n\t\t}\n\t\tG[30].push_back({s,0,1});\n\t\tdijkstra(30*900);\n/*\t\trep(i,n){\n\t\t\trep(j,G[i].size()){\n\t\t\t\trep(k,G[i][j].conf){\n\t\t\t\t\tprintf(\"(from=%d , to=%d , speed=%d)    d=%lf\\n\",i,G[i][j].to,k+1,d[i*900+j*30+k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tif(ans==inf) printf(\"unreachable\\n\");\n\t\telse printf(\"%.6f\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\nstruct node{\n\tint pos;\n\tint prev;\n\tint speed;\n\tdouble cost;\n\n\tnode(int t_pos,int t_prev,int t_speed,double t_cost){\n\t\tpos = t_pos; prev = t_prev; speed = t_speed; cost = t_cost;\n\t}\n\n\tbool operator<(const node& a) const { //キューの中身を逆転\n\t\treturn cost > a.cost;\n\t}\n};\n\nstruct root{\n\tint to;\n\tdouble cost;\n\tint speed;\n\n\troot(int t_to,double t_cost,int t_sp){\n\t\tto = t_to; cost = t_cost; speed = t_sp;\n\t}\n\n};\n\nvector< vector <root> > roots;\nint n,m,s,g;\n\ndouble dp[31][31][31];\n\nconst double INF = (1 << 29);\n\nvoid search(){\n\n\tfill_n((double *)dp,sizeof(dp)/sizeof(double),INF);\t\n\t\n\tpriority_queue<node> pq;\n\n\trep(i,roots[s].size()){\n\t\n\t\troot r = roots[s][i];\n\t\t\n\t\tpq.push( node(r.to,s,1,r.cost) );\n\t\tdp[r.to][s][1] = r.cost;\n\t}\n\n\twhile(!pq.empty()){\n\n\t\tnode tn = pq.top();\n\t\tpq.pop();\n\n\t\tif( dp[tn.pos][tn.prev][tn.speed] != tn.cost) continue;\n\n\t\tif( tn.pos == g && tn.speed ==1){\n\t\t\tcout << tn.cost << endl;\n\t\t\treturn;\n\t\t}\t\n\n\t\trep(i,roots[tn.pos].size()){\n\t\t\troot r = roots[tn.pos][i];\n\t\t\tif(r.to == tn.prev) continue;\n\n\t\t\tfor( int j = -1; j< 2; j++){\n\t\t\t\tif( tn.speed + j > 0 && tn.speed +j <= r.speed){\n\t\t\t\t\tdouble cost = tn.cost + r.cost/(tn.speed+j);\n\t\t\t\t\tif( dp[r.to][tn.pos][tn.speed+j] > cost){\n\t\t\t\t\t\tdp[r.to][tn.pos][tn.speed + j] = cost;\n\t\t\t\t\t\tpq.push( node( r.to,tn.pos,tn.speed + j,cost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"unreachable\" << endl;\n}\n\n\nint main(){\n\n\twhile(1){\n\n\t\tcin >> n >> m >> s >> g;\n\t\ts--;g--;\n\t\tif(m==0&&n==0) break;\n\n\t\troots = vector< vector<root> >(n);\n\n\t\trep(i,m){\n\t\t\tint r1,r2,cost,sp;\n\t\t\tcin >> r1 >> r2 >> cost >> sp;\n\t\t\tr1--;r2--;\n\t\t\troots[r1].push_back( root(r2,cost,sp));\n\t\t\troots[r2].push_back( root(r1,cost,sp));\n\t\t}\n\t\tsearch();\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\nint n,m,s,g;\ndouble d[40][40][40];\n\nint main(){\n  int inx,iny,ind,inc;\n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n\n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=0;i<31;i++)for(int j=0;j<31;j++)for(int k=0;k<31;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      //if(p.S.F >= d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n    \n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <iomanip>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n\nusing namespace std;\n\ntypedef long long int lli;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\n\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nstruct Edge {\n    int to, mxspeed, cost;\n    Edge(int t, int m, int c)\n        : to(t), mxspeed(m), cost(c) {}\n    Edge() {}\n};\n\nstruct Data {\n    int to, spd, lst;\n    double cost;\n    Data(int t, int s, int lt, double c)\n        : to(t), spd(s), lst(lt), cost(c) {}\n    Data() {}\n    bool operator<(const Data &d1) const {\n        return cost > d1.cost;\n    }\n};\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n + m) {\n        vector<vector<Edge>> G(n);\n        int s, g;\n        cin >> s >> g;\n        s--;\n        g--;\n        REP(i, 0, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            G[x].push_back(Edge(y, c, d));\n            G[y].push_back(Edge(x, c, d));\n        }\n        priority_queue<Data, vector<Data>> pq;\n        const double inf = 1e+15;\n        vector<vector<double>> Cost(n, vector<double>(35, inf));\n        vector<vector<bool>> used(n, vector<bool>(35, false));\n        pq.emplace(s, 0, -1, 0.0);\n        while (pq.size()) {\n            auto d = pq.top();\n            pq.pop();\n            //if (used[d.to][d.spd]) continue;\n            used[d.to][d.spd] = true;\n            for (auto &e : G[d.to]) {\n                if (e.to == d.lst) continue;\n                REP(i, -1, 2) {\n                    int ns = d.spd + i;\n                    if (ns <= 0 || ns > e.mxspeed) continue;\n                    double nc = d.cost + (double)e.cost / ns;\n                    if (Cost[e.to][ns] > nc) {\n                        Cost[e.to][ns] = nc;\n                        pq.emplace(e.to, ns, d.to, nc);\n                    }\n                }\n            }\n        }\n        if (used[g][1]) {\n            cout << fixed << setprecision(10) << Cost[g][1] << endl;\n        } else {\n            cout << \"unreachable\" << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define INF 100000000\n#define rep(i,n) for(int i=0;i<n;i++)\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<double,int> pp;\ntypedef pair<pp,p> P;\nstruct edge{\n\tint to,d,c;\n};\nint main(){\n\tdouble dp[31][31][31];\n\tint n,m,s,g,x,y,d,c,ds[]={1,-1,0};\n\twhile(cin>>n>>m,n||m){\n\t\tvector<edge> G[31];\n\t\tcin>>s>>g;\n\t\ts--;g--;\n\t\trep(i,m){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tx--;y--;\n\t\t\tedge e;\n\t\t\te.d=d;e.c=c;\n\t\t\te.to=y;\n\t\t\tG[x].push_back(e);\n\t\t\te.to=x;\n\t\t\tG[y].push_back(e);\n\t\t}\n\t\trep(i,31)\n\t\trep(j,31)\n\t\trep(k,31)\n\t\tdp[i][j][k]=INF;\n\t\tdp[0][s][s]=0.0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(pp(0.0,-1),p(0,s)));\n\t\tdouble ans=INF;\n\t\twhile(!que.empty()){\n\t\t\tP q=que.top();que.pop();\n\t\t\tif(q.second.second==g&&q.second.first==1){\n\t\t\t\tans=min(ans,dp[q.second.first][q.second.second][q.first.second]);\n\t\t\t//\tcout<<ans<<endl;\n\t\t\t}\n\t\t\t//cout<<q.second.second<<' '<<q.second.first<<' '<<q.first<<endl;\n\t\t\tif(dp[q.second.first][q.second.second][q.first.second]<q.first.first)\n\t\t\t\tcontinue;\n\t\t\trep(i,G[q.second.second].size()){\n\t\t\t\tedge e=G[q.second.second][i];\n\t\t\t\tif(e.to==q.first.second)\n\t\t\t\tcontinue;\n\t\t\t\trep(j,3){\n\t\t\t\t\tint pre=q.second.first+ds[j];\n\t\t\t\t\tif(pre<1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble tes=(double)e.d/pre+q.first.first;\n\t\t\t\t\tif(pre<=e.c&&dp[pre][e.to][q.second.second]>tes){\n\t\t\t\t\t\tque.push(P(pp(tes,q.second.second),p(pre,e.to)));\n\t\t\t\t\t\tdp[pre][e.to][q.second.second]=tes;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans==INF)\n\t\tcout<<\"unreachable\"<<endl;\n\t\telse\n\t\tprintf(\"%.5lf\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 31\n#define INF (1e9)\nusing namespace std;\ntypedef pair<double,int> P;\ntypedef  pair<P,int> PP;\nstruct dat{\n  double cost;\n  int pos,pre,v;\n  bool operator > (dat x)const{return cost>x.cost;}\n};\nint n,m;\nvector<dat> G[N];\n\ndouble dijkstra(int s,int g){\n  double D[N][N][N];\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++)D[i][j][k]=INF;\n  priority_queue<dat,vector<dat>,greater<dat> >Q;\n  Q.push((dat){0,s,-1,0});\n  D[s][s][1]=0;\n  while(!Q.empty()){\n    dat t=Q.top();Q.pop();\n    double cost=t.cost;\n    int pos=t.pos;\n    int pre=t.pre;  \n    int v=t.v;\n    if(D[pos][pre][v]<cost)continue;\n    if(pos==g&&v==1) return cost;\n    \n    for(int i=max(1,v-1);i<=v+1;i++){\n      for(int j=0;j<G[pos].size();j++){\n\tdouble ncost=cost+G[pos][j].cost/i;\n\tint mxv=G[pos][j].v;\n\tint nx=G[pos][j].pos;\n\tif(nx==pre||mxv<i||D[nx][pos][i]<=ncost)continue;\n\tQ.push((dat){ncost,nx,pos,i});\n\tD[nx][pos][i]=ncost;\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    int s,g;\n    cin>>s>>g;s--,g--;\n    for(int i=0;i<n;i++)G[i].clear();\n    for(int i=0,a,b,d,c;i<m;i++){\n      cin>>a>>b>>d>>c;a--,b--;\n      G[a].push_back((dat){d,b,-1,c});\n      G[b].push_back((dat){d,a,-1,c});\n    }\n    double ans=dijkstra(s,g);\n    if(ans==-1) cout<<\"unreachable\"<<endl;\n    else printf(\"%.12f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstdio>\nusing namespace std;\n\nconst int max_velo = 32;\nconst int inf = 1<<29;\n\nstruct Edge{\n    int src,dst;\n    double cost;\n    Edge(int src,int dst,double cost) : src(src), dst(dst), cost(cost) {;}\n};\n\nbool operator<(const Edge &e,const Edge &f) {\n    return e.cost > f.cost;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid shortest(const Graph &g, int st,vector<double> &dist) {\n    const int n = g.size();\n    dist.assign(n, inf);\n    vector<int> prev(n, -1);\n    dist[st] = 0;\n\n    priority_queue<Edge> Q;\n    for(Q.push(Edge(-2, st, 0)); !Q.empty(); ) {\n        Edge e = Q.top(); Q.pop();\n        //cout<<\"now \"<<e.dst/max_velo<<\" \"<<e.cost<<endl;\n        if(prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n        for(Edges::const_iterator it = g[e.dst].begin(); it != g[e.dst].end(); ++it) {\n            if(dist[it->dst] > e.cost + it->cost) {\n                dist[it->dst] = e.cost + it->cost;\n                Q.push(Edge(it->src, it->dst, e.cost + it->cost));\n            }\n        }\n    }\n\n}\n\nint main() {\n    int n,m,s,go,x,y,c,l;\n    while(cin>>n>>m, n|m) {\n        Graph g(n*max_velo);\n        cin>>s>>go;\n        s--,go--;\n        for(int i=0; i<m; ++i) {\n            cin>>x>>y>>c>>l;\n            x--,y--;\n\n\n            for(int j=1; j<=30; ++j) {\n\n                double cost = (double) c/j;\n                if(j+1 <= l) {\n                    double cost = (double)c/(j+1);\n                    if(y != s) g[y*max_velo+j].push_back(\n                        Edge(y*max_velo+j,x*max_velo+j+1,cost));\n                    if(x != s) g[x*max_velo+j].push_back(\n                        Edge(x*max_velo+j,y*max_velo+j+1,cost));\n                }\n\n                g[y*max_velo+j].push_back(Edge(y*max_velo+j,x*max_velo+j,cost));\n                g[x*max_velo+j].push_back(Edge(x*max_velo+j,y*max_velo+j,cost));\n\n                if(j-1 > 0) {\n                    double cost = (double)c/(j-1);\n                    g[x*max_velo+j].push_back(\n                        Edge(x*max_velo+j,y*max_velo+j-1,cost));\n                    g[y*max_velo+j].push_back(\n                        Edge(y*max_velo+j,x*max_velo+j-1,cost));\n                }\n\n            }\n        }\n\n        vector<double> dist(g.size(), inf);\n        shortest(g,s*max_velo+1,dist);\n        double ans = dist[go*max_velo+1];\n        if(ans == inf) printf(\"unreachable\\n\");\n        else printf(\"%.5lf\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000.0\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<double,int> P;\n\nint n, m;\nint s, g;\ndouble dp[40*900+30*30+30];\nvector<P> e[40*900+30*30+30];\n\nvoid solve(){\n\tcin >> s >> g;\n\ts--; g--;\n\trep(i,40*900+30*30+30){\n\t\tdp[i] = INF;\n\t\te[i].clear();\n\t}\n\trep(i,m){\n\t\tint x, y, c;\n\t\tdouble d;\n\t\tcin >> x >> y >> d >> c;\n\t\tx--; y--;\n\t\tfor(int j = 1; j <= c; j++) rep(k,n){\n\t\t\tif(k == y) continue;\n\t\t\te[j*900+k*30+x].push_back(P(d/j,j*900+x*30+y));\n\t\t\te[j*900+k*30+x].push_back(P(d/j,(j+1)*900+x*30+y));\n\t\t\te[j*900+k*30+x].push_back(P(d/j,(j-1)*900+x*30+y));\n\t\t}\n\t\tfor(int j = 1; j <= c; j++) rep(k,n){\n\t\t\tif(k == x) continue;\n\t\t\te[j*900+k*30+y].push_back(P(d/j,j*900+y*30+x));\n\t\t\te[j*900+k*30+y].push_back(P(d/j,(j+1)*900+y*30+x));\n\t\t\te[j*900+k*30+y].push_back(P(d/j,(j-1)*900+y*30+x));\n\t\t}\n\t}\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tque.push(P(0.0,1*900+s*30+s));\n\tdp[1*900+s*30+s] = 0.0;\n\twhile(true){\n\t\tif(que.size() == 0) break;\n\t\tP q = que.top();\n\t\tque.pop();\n\t\tif(q.first > dp[q.second]) continue;\n\t\trep(i,e[q.second].size()){\n\t\t\tP p = e[q.second][i];\n\t\t\tif(dp[p.second] > q.first+p.first){\n\t\t\t\tdp[p.second] = q.first+p.first;\n\t\t\t\tque.push(P(dp[p.second],p.second));\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans = INF;\n\trep(i,n) ans = min(ans,dp[0*900+i*30+g]);\n\tif(ans == INF) puts(\"unreachable\");\n\telse printf(\"%.9f\\n\",ans);\n}\n\nint main(){\n\twhile(cin >> n >> m){\n\t\tif(n == 0 && m == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nstruct Node{\n    int num, v, before;\n    double cost;\n    bool operator<(const Node& obj)const{\n        return cost > obj.cost + EPS;\n    }\n};\n\nstruct Edge{\n    int to, from, v, distance;\n};\n\ndouble mini[33][33][33];\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n != 0){\n        int s, g;\n        cin >> s >> g;\n        vector<Edge> graph[33];\n        for(int i=0;i<m;++i){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            graph[x].push_back((Edge){y, x, c, d});\n            graph[y].push_back((Edge){x, y, c, d});\n        }\n\n        for(int i=0;i<=30;++i){\n            for(int j=0;j<=30;++j){\n                for(int k=0;k<=30;++k){\n                    mini[i][j][k] = 1e9;\n                }\n            }\n        }\n\n        priority_queue<Node> que;\n        que.push((Node){s, 1, -1, 0});\n        bool ok = false;\n        while(!que.empty()){\n            Node curr = que.top(); que.pop();\n            if(curr.num == g && curr.v == 0){\n                printf(\"%.10f\\n\", curr.cost);\n                ok = true;\n                break;\n            }\n            for(Edge e : graph[curr.num]){\n                if(curr.v > e.v)continue;\n                if(curr.before != -1 && curr.before == e.to)continue;\n                double newcost = curr.cost + e.distance / (double)(curr.v);\n                for(int i=1;i>=-1;--i){\n                    if(e.to != g && curr.v + i <= 0 || e.to == g && curr.v + i < 0)continue;\n                    if(newcost + EPS < mini[curr.num][e.to][curr.v+i]){\n                        mini[curr.num][e.to][curr.v+i] = newcost;\n                        que.push((Node){e.to, curr.v+i, curr.num, newcost});\n                    }\n                }\n            }\n        }\n        if(!ok)cout << \"unreachable\" << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a <= x && x < b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL << 30)\n#define LLINF (1LL << 60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstruct S {\n  int x, p, v;\n  double t;\n  bool operator<(S s) const { return t > s.t; }\n};\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (!n && !m)\n      break;\n    int s, g;\n    cin >> s >> g;\n    int d[31][31];\n    int l[31][31] = {};\n    for (int i = 0; i < m; i++) {\n      int x, y, di, c;\n      cin >> x >> y >> di >> c;\n      d[x][y] = d[y][x] = di;\n      l[x][y] = l[y][x] = c;\n    }\n    bool p[31][31][31] = {};\n    priority_queue<S> que;\n    que.push({s, 0, 0, 0});\n    while (!que.empty()) {\n      S cs = que.top();\n      if (cs.x == g && cs.v == 1)\n        break;\n      que.pop();\n      if (p[cs.x][cs.p][cs.v]++)\n        continue;\n      for (int i = 0; i <= n; i++) {\n        if (cs.p == i)\n          continue;\n        for (int j = -1; j <= 1; j++) {\n          int nv = cs.v + j;\n          if (nv <= 0 || l[cs.x][i] < nv)\n            continue;\n          que.push({i, cs.x, nv, cs.t + d[cs.x][i] * 1. / nv});\n        }\n      }\n    }\n    if (que.empty()) {\n      cout << \"unreachable\" << endl;\n    } else {\n      cout << fixed << que.top().t << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 100000\n\nusing namespace std;\n\nint n,m;\n\nstruct edge {\n\tint t;\n\tint dis;\n\tint lim;\n};\n\nstruct Point {\n\tint pos;\n\tdouble time;\n\tint speed;\n\tint pres;\n\n\tbool operator<(const Point& right) const {\n\t\treturn (time > right.time);\n\t}\n};\n\nint main(void) {\n\twhile (cin >> n >> m, n) {\n\t\tint s,g;\n\t\tcin >> s >> g;\n\n\t\tint x,y,d,c;\n\t\tvector< vector<edge> > adj(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tadj[x-1].push_back((edge){y-1,d,c});\n\t\t\tadj[y-1].push_back((edge){x-1,d,c});\n\t\t}\n\n\t\tpriority_queue<Point> pq;\n\t\tpq.push((Point){s-1,0,1,1});\n\t\tdouble dp[n][31];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < 31; ++j) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][1] = 0;\n\n\t\tbool find = false;\n\t\twhile (!pq.empty()) {\n\t\t\tPoint pn = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tif (pn.pos == g-1 && pn.speed == 1 && pn.pres == 1) {\n\t\t\t\tprintf(\"%llf\\n\",pn.time);\n\t\t\t\tfind = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (size_t i = 0; i < adj[pn.pos].size(); ++i) {\n\t\t\t\tdouble rt = ((double)adj[pn.pos][i].dis/pn.speed);\n\t\t\t\tif (pn.time + rt < dp[adj[pn.pos][i].t][pn.speed] && pn.speed <= adj[pn.pos][i].lim) {\n\t\t\t\t\tdp[adj[pn.pos][i].t][pn.speed] = pn.time + rt;\n\t\t\t\t\tpq.push((Point){adj[pn.pos][i].t,pn.time+rt,pn.speed,pn.speed});\n\t\t\t\t\tif (pn.speed != 30) {\n\t\t\t\t\t\tpq.push((Point){adj[pn.pos][i].t,pn.time+rt,pn.speed+1,pn.speed});\n\t\t\t\t\t}\n\t\t\t\t\tif (pn.speed != 1) {\n\t\t\t\t\t\tpq.push((Point){adj[pn.pos][i].t,pn.time+rt,pn.speed-1,pn.speed});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!find) {\n\t\t\tcout << \"unreachable\" <<  endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI       3.14159265358979323846   // pi\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> VI;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\n\n#define rep(a,n) for(ll a = 0;a < n;a++)\n#define repi(a,b,n) for(ll a = b;a < n;a++)\n\nconst ll INF = 1e15;\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct edge {\n\tll to;\n\tll dist;\n\tll c;\n\tedge(ll to, ll dist, ll c) : to(to), dist(dist), c(c){}\n};\n\nstruct Data {\n\tll cv;\n\tll from;\n\tll to;\n\tdouble time;\n\n\tData(ll cv, ll from, ll to, double time) : cv(cv), from(from), to(to), time(time){}\n\n\tbool operator < (const Data& data) const {\n\t\treturn time > data.time;\n\t}\n\tbool operator > (const Data& data) const {\n\t\treturn time < data.time;\n\t}\n};\n\nint main(void)\n{\n\tvector<double> ans;\n\twhile (true) {\n\t\tll n, m;\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\t\tll s, g;\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\t\tvector<vector<edge>> graph(n);\n\t\trep(i, m) {\n\t\t\tll x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tgraph[x].emplace_back(y, d, c);\n\t\t\tgraph[y].emplace_back(x, d, c);\n\t\t}\n\t\tpriority_queue<Data> q;\n\t\tconst int max_v = 33;\n\t\tvector<vector<vector<double>>> dp(n, vector<vector<double>>(n, vector<double>(max_v, INF)));\n\t\tauto push = [&](ll cv, ll from, ll current, double time) {\n\t\t\tfor (auto e : graph[current]) {\n\t\t\t\tif (from == e.to) continue;\n\t\t\t\tfor (int i = -1; i < 2; i++) {\n\t\t\t\t\tdouble nv = cv + i;\n\t\t\t\t\tif (nv <= 0) continue;\n\t\t\t\t\tif (nv > e.c) continue;\n\t\t\t\t\tdouble nt = time + e.dist / nv;\n\t\t\t\t\tif (dp[current][e.to][nv] <= nt) continue;\n\t\t\t\t\tdp[current][e.to][nv] = nt;\n\t\t\t\t\tq.emplace(Data(nv, current, e.to, nt));\n\t\t\t\t\t//cout << \"from=\" << node << \",to=\" << e.to << \",v=\" << nv << \",time=\" << nt << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tq.push(Data(0, -1, s, 0));\n\n\t\twhile (q.size()) {\n\t\t\tauto t = q.top(); q.pop();\n\t\t\tpush(t.cv, t.from, t.to, t.time);\n\t\t}\n\t\tdouble r = INF;\n\t\trep(i, n) {\n\t\t\tr = min(dp[i][g][1], r);\n\t\t}\n\t\tans.push_back(r);\n\t}\n\tfor (auto a : ans) {\n\t\tif (a == INF) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << fixed << setprecision(10) << a << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n// #include <ctime>\n#include <algorithm>\nusing namespace std;\nint visited[31][31][31];\n\ntypedef struct edge\n{\n    int to, cost, limit;\n    edge(int x, int y, int z): to(x), cost(y), limit(z) {}\n} Edge;\n\n\ntypedef struct status {\n    int from, to, speed;\n    double time;\n    status(int x, int x2, double y, int z): from(x), to(x2), time(y), speed(z) {}\n} CurrentStatus;\n\n\nstruct cmp_statue {\n    bool operator() (const CurrentStatus &a, const CurrentStatus &b) {\n        return a.time > b.time;\n    }\n};\n\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n\n    // clock_t begin = clock();\n\n    int ncities, nroads;\n    int x, y, d, c;\n\n    while(scanf(\"%d%d\", &ncities, &nroads) != EOF && !(ncities == 0 && nroads == 0)) {\n\n        priority_queue< CurrentStatus, vector<CurrentStatus>, cmp_statue > Q;\n\n        vector< vector<Edge> > path(ncities);\n\n        memset(visited, 0, sizeof(visited));\n\n        // Input\n        int start_index, end_index;\n        scanf(\"%d%d\" , &start_index, &end_index);\n        start_index--;\n        end_index--;\n\n        for(int n = 0; n < nroads; ++n) {\n            scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n            path[x - 1].push_back(Edge(y - 1, d, c));\n            path[y - 1].push_back(Edge(x - 1, d, c));\n        }\n\n        double minimun_v = 0;\n        Q.push(CurrentStatus(start_index, start_index, 0.0, 0));\n\n        while(!Q.empty()) {\n            CurrentStatus cs = Q.top();\n            Q.pop();\n\n            if(cs.to == end_index) {\n                if(cs.speed == 1) {\n                    minimun_v = cs.time;\n                    break;\n                } else {\n                    continue;\n                }\n            }\n\n            if(visited[cs.from][cs.to][cs.speed]) continue;\n\n            visited[cs.from][cs.to][cs.speed] = 1;\n\n            for(int j = 0; j < path[cs.to].size(); ++j) {\n                int next_pt = path[cs.to][j].to;\n                int limit = path[cs.to][j].limit;\n                if(next_pt == cs.from) continue;\n\n                for(int z = -1; z <= 1; ++z) {\n                    int new_speed = cs.speed + z;\n                    if(!visited[cs.to][next_pt][new_speed] && new_speed > 0 && new_speed <= limit) {\n                        Q.push(CurrentStatus(cs.to, next_pt, cs.time + ((double)path[cs.to][j].cost)/new_speed, new_speed));\n                    }\n                }\n            }\n        }\n\n        if(minimun_v) {\n            printf(\"%0.5lf\\n\", minimun_v);\n        } else {\n            printf(\"unreachable\\n\");\n        }\n    }\n    // clock_t end = clock();\n    // double elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;\n    // printf(\"time: %lf\\n\", elapsed_secs);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double INF = 1e8;\n\nstruct Edge {\n\tint dst, cost, lim;\n\tEdge(){}\n\tEdge(int dst, int cost, int lim): dst(dst), cost(cost), lim(lim){}\n};\n\nstruct State {\n\tint pos, prev, speed;\n\tdouble sum;\n\tState(){}\n\tState(int pos, int prev, int speed, double sum): pos(pos), prev(prev), speed(speed), sum(sum){}\n\tbool operator < (const State &t) const {return sum > t.sum;}\n};\n\nint n, m;\nint st, gl;\nvector<Edge> g[30];\ndouble dist[30][30][31];\n\nvoid solve()\n{\n\tpriority_queue<State> pq;\n\tfill_n(**dist, 30 * 30 * 31, INF);\n\tdist[st][st][0] = 0.0;\n\tpq.push(State(st, st, 0, 0.0));\n\tdouble res = INF;\n\twhile (pq.size()){\n\t\tauto s = pq.top(); pq.pop();\n\t\tif (s.pos == gl && s.speed == 1) res = min(res, s.sum);\n\t\tif (dist[s.pos][s.prev][s.speed] < s.sum) continue;\n\t\tfor (auto &e : g[s.pos]){\n\t\t\tif (e.dst == s.prev) continue;\n\t\t\tfor (int ns = s.speed - 1; ns <= s.speed + 1; ns++){\n\t\t\t\tif (ns <= 0 || ns > e.lim) continue;\n\t\t\t\tdouble cost = (double)e.cost / ns;\n\t\t\t\tif (dist[e.dst][s.pos][ns] > s.sum + cost){\n\t\t\t\t\tdist[e.dst][s.pos][ns] = s.sum + cost;\n\t\t\t\t\tpq.push(State(e.dst, s.pos, ns, s.sum + cost));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (res == INF) puts(\"unreachable\");\n\telse printf(\"%.20f\\n\", res);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tscanf(\"%d %d\", &st, &gl); --st; --gl;\n\t\tfor (int i = 0; i < 30; i++) g[i].clear();\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint x, y, d, c;\n\t\t\tscanf(\"%d %d %d %d\", &x, &y, &d, &c); --x; --y;\n\t\t\tg[x].push_back(Edge(y, d, c));\n\t\t\tg[y].push_back(Edge(x, d, c));\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\n#define INF 1e15\n\nint n, m;\n\nstruct edge{\n    int to;\n    double cost;\n    int limit;\n    edge(int t, double c, int l): to(t), cost(c), limit(l){}\n};\n\nstruct state{\n    int node, speed, prev;\n    double dist;\n    state(int n, int s, int p, double d): node(n), speed(s), prev(p), dist(d) {}\n    bool operator > (const state s) const {\n        return dist > s.dist;\n    }\n};\n \nvoid dijkstra(int start, vector<vector<vector<double> > > &d, vector<vector<edge> > graph){\n    d[start][0][0] = 0.0;\n    priority_queue<state, vector<state>, greater<state> > q;\n    q.push(state(start, 0, 0, 0.0));\n    while (!q.empty()){\n        state a = q.top();\n        q.pop();\n        int now = a.node, prev = a.prev, speed = a.speed;\n        if(d[now][speed][prev] < a.dist) continue;\n        REP(i,graph[now].size()){\n            edge e = graph[now][i];\n            int next = e.to, limit = e.limit;\n            if (next == prev) continue;\n            FOR(dif,-1,1){\n                int next_speed = speed + dif;\n                if (next_speed <= 0 || next_speed > limit) continue;\n                if (d[next][next_speed][now] > d[now][speed][prev] + e.cost/next_speed){\n                    d[next][next_speed][now] = d[now][speed][prev] + e.cost/next_speed;\n                    q.push(state(next, next_speed, now, d[next][next_speed][now]));\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    while (cin >> n >> m && n){\n        vector<vector<edge> > graph(n);\n        int s, g;\n        cin >> s >> g;\n        s--;\n        g--;\n        REP(i,m){\n            int x, y, c;\n            double d;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            graph[x].push_back(edge(y,d,c));\n            graph[y].push_back(edge(x,d,c));\n        }\n        vector<vector<vector<double> > > dist(n, vector<vector<double> > (31, vector<double> (n, INF)));\n        dijkstra(s, dist, graph);\n        double ans = INF;\n        REP(i,n) ans = min(ans, dist[g][1][i]);\n        if (ans == INF) cout << \"unreachable\" << endl;\n        else printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<pair<int,int>,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a2,a4;\ndouble d[31][31],a3;\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      scanf(\"%d%d%lf%d\",&a1,&a2,&a3,&a4);\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P>q;\n    d[st][0]=0;\n    P xtt;xtt.fi.fi=0,xtt.fi.se=st,xtt.se=-1;\n    q.push(xtt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.fi.se;\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=p.se)r(j,3){\n          int x=p.fi.fi+dx[j];\n          if(0<x&&x<=e.lim){\n            double t=e.dist/x+d[cur][p.fi.fi];\n            if(d[e.to][x]>t){\n              d[e.to][x]=t;\n              P xt;xt.fi.fi=x,xt.fi.se=e.to,xt.se=cur;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cfloat>\n\nusing namespace std;\n\nint n, m;\n\nstruct edge {\n\tint dist, lim;\n};\n\nstruct P {\n\tint from, pos, v;\n\tdouble time;\n\n\tbool operator >(const P& p) const {\n\t\treturn time > p.time;\n\t}\n};\n\nedge elist[31][31];\ndouble G[31][31][31];\n\nint main() {\n\tint s, g;\n\twhile (cin >> n >> m, n|m) {\n\t\tfor(int i=0; i<31; i++){\n\t\t\tfor(int j=0; j<31; j++){\n\t\t\t\telist[i][j] = {-1, -1};\n\t\t\t}\n\t\t}\n\t\tfill_n((double *)G, 31*31*31, DBL_MAX);\n\t\tcin >> s >> g;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\telist[x][y] = {d, c};\n\t\t\telist[y][x] = {d, c};\n\t\t}\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\tq.push({-1, s, 0, 0.0});\n\t\tbool goal = false;\n\t\twhile(!q.empty()){\n\t\t\tP p = q.top(); q.pop();\n\t\t\t// goal\n\t\t\tif (p.pos == g && p.v == 1) {\n\t\t\t\tprintf(\"%f\\n\", p.time);\n\t\t\t\tgoal = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=1; i<=n; i++) {\n\t\t\t\tif(elist[p.pos][i].dist != -1 && p.from != i) {\n\t\t\t\t\t// v+1\n\t\t\t\t\tif(p.v + 1 <= elist[p.pos][i].lim) {\n\t\t\t\t\t\tdouble time = p.time + (double)elist[p.pos][i].dist / (double)(p.v+1);\n\t\t\t\t\t\tif(time < G[p.pos][i][p.v+1]){\n\t\t\t\t\t\t\tq.push({p.pos, i, p.v+1, time});\n\t\t\t\t\t\t\tG[p.pos][i][p.v+1] = time;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// v\n\t\t\t\t\tif(p.v <= elist[p.pos][i].lim) {\n\t\t\t\t\t\tdouble time = p.time + (double)elist[p.pos][i].dist / (double)p.v;\n\t\t\t\t\t\tif(time < G[p.pos][i][p.v]){\n\t\t\t\t\t\t\tq.push({p.pos, i, p.v, time});\n\t\t\t\t\t\t\tG[p.pos][i][p.v] = time;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// v-1\n\t\t\t\t\tif(p.v -1 <= elist[p.pos][i].lim && p.v-1 > 0) {\n\t\t\t\t\t\tdouble time = p.time + (double)elist[p.pos][i].dist / (double)(p.v-1);\n\t\t\t\t\t\tif(time < G[p.pos][i][p.v-1]){\n\t\t\t\t\t\t\tq.push({p.pos, i, p.v-1, time});\n\t\t\t\t\t\t\tG[p.pos][i][p.v-1] = time;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!goal) cout << \"unreachble\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n\tint cost,limit;\n\tedge(int c,int l){\n\t\tcost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tdouble mini=INF;\n\tvector<vector<edge> > E(n+1,vector<edge>(n+1,edge(-1,-1)));\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in][out]=edge(c,l);\n\t\tE[out][in]=edge(c,l);\n\t}\n\n\tvector<vector<vector<double> > > Ans(n+1,vector<vector<double> >(n+1,vector<double>(31,INF)));\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){\n\t\tNode t=Q.top(); Q.pop();\n\t\t\n\t\tif(t.now==g && t.speed==1){printf(\"%.12lf\\n\", t.time );  return;}\n\t\tif(t.time>=mini) continue;\n\t\tif(Ans[t.now][t.before][t.speed]<=t.time) continue;\n//\t\tcout<<t.now<<\" \"<<t.speed<<\" \"<<t.time<<endl;\n\t\tAns[t.now][t.before][t.speed]=t.time;\n\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tif(i==t.before) continue;\n\t\t\tif(E[t.now][i].cost>0){\n\t\t\t\tif(E[t.now][i].limit>=t.speed && t.speed>=1){\n\t\t\t\t\tQ.push(Node(i,t.speed,t.time+E[t.now][i].cost/(double)t.speed,t.now));\n\t\t\t\t\tif(i==g && t.speed==1) mini=min(mini,t.time+E[t.now][i].cost/(double)t.speed);\n\t\t\t\t}\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed+1){\n\t\t\t\t\tQ.push(Node(i,t.speed+1,t.time+E[t.now][i].cost/(double)(t.speed+1.0),t.now));\n\t\t\t\t\tif(i==g && t.speed+1==1) mini=min(mini,t.time+E[t.now][i].cost/(double)(t.speed+1.0));\n\t\t\t\t}\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed-1 && t.speed-1>=1){\n\t\t\t\t\tQ.push(Node(i,t.speed-1,t.time+E[t.now][i].cost/(double)(t.speed-1.0),t.now));\n\t\t\t\t\tif(i==g && t.speed-1==1) mini=min(mini,t.time+E[t.now][i].cost/(double)(t.speed-1.0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\"<<endl;\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <iomanip>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n\nusing namespace std;\n\ntypedef long long int lli;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\n\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nstruct Edge {\n    int to, mxspeed, cost;\n    Edge(int t, int m, int c)\n        : to(t), mxspeed(m), cost(c) {}\n    Edge() {}\n};\n\nstruct Data {\n    int to, spd, lst;\n    double cost;\n    Data(int t, int s, int lt, double c) {\n        to = t;\n        spd = s;\n        lst = lt;\n        cost = c;\n    }\n    Data() {}\n    bool operator<(const Data &d1) const {\n        return cost > d1.cost;\n    }\n};\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n + m) {\n        vector<vector<Edge>> G(n);\n        int s, g;\n        cin >> s >> g;\n        s--;\n        g--;\n        REP(i, 0, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            G[x].push_back(Edge(y, c, d));\n            G[y].push_back(Edge(x, c, d));\n        }\n        priority_queue<Data, vector<Data>> pq;\n        const double inf = 1e+15;\n        auto Cost = make_v(n, n, 35, inf);\n        auto used = make_v(n, n, 35, false);\n        //vector<vector<double>> Cost(n, vector<double>(35, inf));\n        pq.emplace(s, 0, s, 0.0);\n        double ans = inf;\n        while (pq.size()) {\n            auto d = pq.top();\n            pq.pop();\n            if (used[d.to][d.lst][d.spd]) continue;\n            used[d.to][d.lst][d.spd] = true;\n            if (d.to == g && d.spd == 1) {\n                ans = min(ans, d.cost);\n            }\n            for (auto &e : G[d.to]) {\n                if (e.to == d.lst) continue;\n                REP(i, -1, 2) {\n                    int ns = d.spd + i;\n                    if (ns <= 0 || ns > e.mxspeed) continue;\n                    double nc = d.cost + static_cast<double>(e.cost) / ns;\n                    if (Cost[e.to][d.to][ns] > nc) {\n                        Cost[e.to][d.to][ns] = nc;\n                        pq.emplace(e.to, ns, d.to, nc);\n                    }\n                }\n            }\n        }\n        if (ans <= inf / 2) {\n            cout << fixed << setprecision(10) << ans << endl;\n        } else {\n            cout << \"unreachable\" << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nclass data\n{\npublic:\n    int p, q, c;\n    data(int p0, int q0, int c0){\n        p = p0;\n        q = q0;\n        c = c0;\n    }\n};\n\nvoid solve(int n, int start, int goal, vector<vector<int> > distance, vector<vector<int> > limit)\n{\n    vector<bool> easyCheck(n, false);\n    queue<int> q;\n    q.push(start);\n    while(!q.empty()){\n        int a = q.front();\n        if(!easyCheck[a]){\n            easyCheck[a] = true;\n            for(int i=0; i<n; ++i){\n                if(distance[a][i] > -1)\n                    q.push(i);\n            }\n        }\n        q.pop();\n    }\n    if(!easyCheck[goal]){\n        cout << \"unreachable\" << endl;\n        return;\n    }\n\n    vector<vector<vector<bool> > > check(n, vector<vector<bool> >(n, vector<bool>(31, false)));\n    multimap<double, data> m;\n    for(int i=0; i<n; ++i){\n        if(distance[start][i] > -1)\n            m.insert(make_pair(distance[start][i], data(i, start, 1)));\n    }\n\n    for(;;){\n        multimap<double, data>::iterator it = m.begin();\n        double t = it->first;\n        int p = it->second.p;\n        int q = it->second.q;\n        int c = it->second.c;\n        if(p == goal && c == 1){\n            printf(\"%.10f\\n\", t);\n            return;\n        }\n        m.erase(it);\n\n        if(!check[p][q][c]){\n            check[p][q][c] = true;\n            for(int i=0; i<n; ++i){\n                if(i == p || i == q || distance[i][p] == -1)\n                    continue;\n                for(int j=-1; j<=1; ++j){\n                    if(0 < c+j && c+j <= limit[p][i] && !check[i][p][c+j])\n                        m.insert(make_pair(t+distance[p][i]/static_cast<double>(c+j), data(i, p, c+j)));\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, s, g;\n        cin >> n >> m;\n        if(n == 0 && m == 0)\n            break;\n        cin >> s >> g;\n        -- s;\n        -- g;\n\n        vector<vector<int> > distance(n, vector<int>(n, -1));\n        vector<vector<int> > limit(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int x, y;\n            cin >> x >> y;\n            -- x;\n            -- y;\n            cin >> distance[x][y] >> limit[x][y];\n            distance[y][x] = distance[x][y];\n            limit[y][x] = limit[x][y];\n        }\n\n        solve(n, s, g, distance, limit);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n \nusing namespace std;\n \n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF 1e11\nconst int MAX_SPEED = 30;\n\nstruct P {\n    int city;\n    int speed;\n    float dist;\n\n    bool operator >(const P& p) const {\n        return dist > p.dist;\n    }\n};\n\nstruct edge{\n    int to, dist, limit;\n};\n \nint main() {\n    int city_n, road_n, start, goal;\n\n    while(cin >> city_n >> road_n, city_n | road_n){\n        cin >> start >> goal;\n\n        vector<vector<edge>> E(city_n + 1);\n\n        REP(i, road_n){\n            int x, y, d, l;\n            cin >> x >> y >> d >> l;\n            E[x].push_back({y, d, l});\n            E[y].push_back({x, d, l});\n        }\n        vector<vector<float>> G(city_n + 1, vector<float>(MAX_SPEED + 1, INF));\n        G[start][1] = 0;\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({start, 0, 0.0});\n\n        float res = -1;\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n\n            if(p.city == goal && p.speed == 1){\n                res = p.dist;\n                break;\n            }\n\n            for(auto e : E[p.city]) {\n                FOR(d, -1, 1 + 1){\n                    int next_speed = p.speed + d;\n                    if (next_speed == 0) continue;\n                    float next_dist = p.dist + (float)e.dist / next_speed;\n                    if (0 < next_speed && next_speed <= MAX_SPEED &&\n                        next_speed <= e.limit &&\n                        G[e.to][next_speed] > next_dist) {\n                        G[e.to][next_speed] = next_dist;\n                        que.push({e.to, next_speed, next_dist});\n                    }\n                }\n            }\n        }\n\n        if(res == -1)\n            cout << \"unreachable\" << endl;\n        else\n            printf(\"%f\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1000\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[40];    \n    \n    int inx,iny,ind,inc;\n    double d[40][40][40];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n \nusing namespace std;\n \n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF 1e11\nconst int MAX_SPEED = 30;\n\nstruct P {\n    int city, pcity;\n    int speed;\n    float time;\n\n    bool operator >(const P& p) const {\n        return time > p.time;\n    }\n};\n\nstruct edge{\n    int to, dist, limit;\n};\n\ntypedef vector<float> vf;\ntypedef vector<vf> vvf;\ntypedef vector<vvf> vvvf;\n\nint main() {\n    int city_n, road_n, start, goal;\n\n    while(cin >> city_n >> road_n, city_n | road_n){\n        cin >> start >> goal;\n\n        vector<vector<edge>> E(city_n + 1);\n\n        REP(i, road_n){\n            int x, y, d, l;\n            cin >> x >> y >> d >> l;\n            E[x].push_back({y, d, l});\n            E[y].push_back({x, d, l});\n        }\n        vvf G(city_n + 1, vf(MAX_SPEED + 1, INF));\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({start, start, 0, 0.0});\n\n        float res = -1;\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n\n            if(p.city == goal && p.speed == 1){\n                res = p.time;\n                break;\n            }\n\n            for(auto e : E[p.city]) {\n                if(e.to == p.pcity) continue;\n                FOR(d, -1, 1 + 1){\n                    int next_speed = p.speed + d;\n                    if (next_speed == 0) continue;\n                    float next_time = p.time + (float)e.dist / next_speed;\n                    if (0 < next_speed && next_speed <= e.limit &&\n                        G[e.to][next_speed] > next_time) {\n                        G[e.to][next_speed] = next_time;\n                        que.push({e.to, p.city, next_speed, next_time});\n                    }\n                }\n            }\n        }\n\n        if(res == -1)\n            cout << \"unreachable\" << endl;\n        else\n            printf(\"%f\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#define INF 1e9\nusing namespace std;\n\nint v[31][31];\ndouble dp[31][31];\nint g[31][31];\nint lim[31][31];\n\nint n,m,s,go;\n\nmain(){\n\tint i,j,x,y,d,c;\n\twhile(cin>>n>>m,n){\n\t\tmemset(g, 0, sizeof(g));\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tmemset(lim, 0, sizeof(lim));\n\t\tmemset(v, 0, sizeof(v));\n\t\tcin>>s>>go;\n\t\t\n\t\tfor(i=1;i<=m;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tg[x][y]=g[y][x]=d;\n\t\t\tlim[x][y]=lim[y][x] = c;\n\t\t}\n\t\n\t\tfor(i=0;i<=n;i++)for(j=0;j<=30;j++)dp[i][j]=INF;\n\t\n\t\tint t, s;\n\t\tdouble mmin;\n\t\tdp[1][0] = 0;\n\t\twhile(!v[go][1]){\n\t\t\tmmin=INF;\n\t\t\tfor(i=1;i<=n;i++)for(j=0;j<=30;j++)if(!v[i][j] && dp[i][j] < mmin){\n\t\t\t\tmmin = dp[i][j];\n\t\t\t\tt=i;s=j;\n\t\t\t}\n\t\t\tif(mmin==INF) break;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tif(!g[t][i]) continue;\n\t\t\t\tfor(j=s-1;j<=s+1;j++){\n\t\t\t\t\tif(v[i][j] || lim[t][i] < j || j < 1 || j > 30) continue;\n\t\t\t\t\tif(dp[i][j] > dp[t][s] + g[t][i] / (double)j)\n\t\t\t\t\t   dp[i][j] = dp[t][s] + g[t][i] / (double)j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv[t][s] = 1;\n\t\t}\n\t\tif(v[go][1]) printf(\"%.5lf\\n\", dp[go][1]);\n\t\telse cout << \"unreachable\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j;\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int f,g;\n    cin>>f>>g;\n    f--;\n    g--;\n    int a[30][30],b[30][30];\n    memset(a,-1,sizeof(a));\n    for(i=0;i<m;i++){\n      int p,q,r,s;\n      cin>>p>>q>>r>>s;\n      p--;\n      q--;\n      a[p][q]=a[q][p]=r;\n      b[p][q]=b[q][p]=s;\n    }\n    int c[31][30][30];\n    memset(c,-1,sizeof(c));\n    priority_queue<pair<pair<double,int>,pair<int,int> >,vector<pair<pair<double,int>,pair<int,int> > >,greater<pair<pair<double,int>,pair<int,int> > > > d;\n    for(i=0;i<n;i++){\n      if(a[f][i]!=-1)\n\td.push(make_pair(make_pair(a[f][i],1),make_pair(f,i)));\n    }\n    while(d.empty()==0){\n      double p;\n      int q,r,s;\n      p=d.top().first.first;\n      q=d.top().first.second;\n      r=d.top().second.first;\n      s=d.top().second.second;\n      if(q==1&&s==g)\n\tbreak;\n      d.pop();\n      if(c[q][r][s]){\n\tc[q][r][s]=0;\n\tfor(i=0;i<n;i++){\n\t  if(i!=r&&a[s][i]!=-1){\n\t    for(j=-1;j<=1;j++){\n\t      if(1<=q+j&&q+j<=b[s][i])\n\t\td.push(make_pair(make_pair(p+(double)a[s][i]/(q+j),q+j),make_pair(s,i)));\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(d.empty())\n      cout<<\"unreachable\"<<endl;\n    else\n      cout<<d.top().first.first<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1162\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1162&lang=jp\n\n#include <iostream>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\nconst double inf = (double)(1<<24);\n\nclass Node {\npublic:\n    double time;\n    int v, town, prev;\n    Node() {}\n    Node( double time_, int v_, int town_, int prev_ ) \n    {\n        time = time_;\n        v = v_;\n        town = town_;\n        prev = prev_;\n    }\n    bool operator < ( const Node& right ) const \n    {\n        return time > right.time;\n    }\n    bool operator > ( const Node& right ) const\n    {\n        return time < right.time;\n    }\n    bool operator == ( const Node& right ) const\n    {\n        return v == right.v && town == right.town && prev == right.prev;\n    }\n};\ntypedef priority_queue <Node> QUEUE;\nconst int size = 31;\n\nint n, m;\nbool P[size][size];\ndouble G[size][size];\ndouble MC[size][size];\nint L[size][size];\nint CN[size][size];\nint CN_count[size];\n\n// dijkstra\nvoid solve( int start, int goal )\n{\n    // init\n    QUEUE Q;\n    Node start_node( 0.0, 0, start, -1 );\n    Q.push( start_node );\n    MC[0][start] = 0.0;\n\n    // proc\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        // proc init\n        double time = node.time;\n        int v = node.v;\n        int town = node.town;\n        int prev = node.prev;\n\n        // move\n        for ( int i = 0; i < CN_count[town]; i++ ) {\n            int next_town = CN[town][i];\n            if ( next_town == prev ) continue;\n            for ( int j = 1; j >= -1; j-- ) {\n                int next_v = v + j;\n                if ( prev == -1 && next_v != 1 ) continue;\n                if ( next_v <= 0 || next_v > L[town][next_town] ) continue;\n                double cost = (double)G[town][next_town] / next_v;\n                double next_time = time + cost;\n                int next_prev = town;\n\n                if ( next_town == goal && next_v == 1 ) {\n                    printf( \"%.5f\\n\", next_time );\n                    return;\n                }\n\n                if ( next_time > MC[next_v][next_town] || fabs( next_time - MC[next_v][next_town] ) < eps ) continue;\n                MC[next_v][next_town] = next_time;\n                Node next_node( next_time, next_v, next_town, next_prev );\n                Q.push( next_node );\n            }\n        }\n    }\n\n    cout << \"unreachable\" << endl;\n}\n\nint main( void )\n{\n    while ( cin >> n >> m ) {\n        // quit\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        for ( int i = 0; i < size; i++ ) {\n            CN_count[i] = 0;\n            for ( int j = 0; j < size; j++ ) {\n                P[i][j] = false;\n                MC[i][j] = inf;\n                G[i][j] = inf;\n                L[i][j] = 0;\n            }\n        }\n\n        // input\n        int s, g;\n        cin >> s >> g;\n        for ( int i = 0; i < m; i++ ) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n\n            P[x][y] = P[y][x] = true;\n            G[x][y] = G[y][x] = d;\n            L[x][y] = L[y][x] = c;\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( i == j ) continue;\n                if ( P[i][j] ) CN[i][CN_count[i]++] = j;\n            }\n        }\n\n        solve( s-1, g-1 );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<int,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a3,a2,a4;\ndouble d[31][31];\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)if(d[i][j]!=1e12)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      scanf(\"%d%d%d%d\",&a1,&a2,&a3,&a4);\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P>q;\n    d[st][0]=0;\n    P xtt;xtt.fi=0,xtt.se=st*1000+0;\n    q.push(xtt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.se/1000,xx=p.se%1000;\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=xx)r(j,3){\n          int x=p.fi+dx[j];\n          if(0<x&&x<=e.lim){\n            double t=e.dist/x+d[cur][p.fi];\n            if(d[e.to][x]>t){\n              d[e.to][x]=t;\n              P xt;xt.fi=x,xt.se=cur+e.to*1000;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 100\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(que.size()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000.0\nusing namespace std;\nstruct state { int n, v, l; double t; };\n\nint N, M, S, G;\nvector<int> T[101], D[101], C[101];\nint vd[3] = { -1, 0, 1 };\ndouble dp[101][101];\n\nclass Compare {\npublic:\n  bool operator() (struct state a, struct state b) {\n    return a.t > b.t;\n  }\n};\n\nint main(void) {\n  while(cin >> N >> M, N) {\n    cin >> S >> G;\n    REP(i, 0, 100) {\n      T[i].clear();\n      D[i].clear();\n      C[i].clear();\n    }\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      T[x].push_back(y); D[x].push_back(d); C[x].push_back(c);\n      T[y].push_back(x); D[y].push_back(d); C[y].push_back(c);\n    }\n\n    REP(i, 1, N) REP(j, 0, 100) dp[i][j] = INF;\n\n    priority_queue<struct state, vector<struct state>, Compare> q;\n    struct state first = { S, 0, -1, 0.0 };\n    q.push(first);\n\n    while(!q.empty()) {\n      struct state c = q.top();\n      q.pop();\n\n      // cout << c.n << \" \" << c.v << \" \" << c.t << endl;\n\n      if(dp[c.n][c.v] <= c.t) continue;\n      dp[c.n][c.v] = min(dp[c.n][c.v], c.t);\n      if(c.n == G && c.v == 1) break;\n\n      for(int i = 0; i < T[c.n].size(); i++) {\n        if(T[c.n][i] == c.l) continue;\n        REP(j, 0, 3) {\n          int v = c.v + vd[j];\n          if(v <= 0 || C[c.n][i] < v) continue;\n          double t = c.t + ((double) D[c.n][i] / v);\n          struct state n = { T[c.n][i], v, c.n, t };\n          if(n.t < dp[n.n][n.v]) q.push(n);\n        }\n      }\n    }\n\n    if(dp[G][1] < INF) printf(\"%.6f\\n\", dp[G][1]);\n    else cout << \"unreachable\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst double eps = 1e-8, inf = 1e+8;\n\ntemplate<typename T> inline void chmin(T& t, T f){if(t > f)t = f;}\n\nstruct Edge {\n    int to; double wt; int cap;\n    Edge(int to, double wt, int cap):to(to), wt(wt), cap(cap){}\n};\n\nint n, m, s, g;\n\ndouble solve(vector<vector<Edge> >& G){\n    double res = inf;\n    vector<vector<vector<double> > > mem(n, vector<vector<double> >(n, vector<double>(35, inf)));\n    mem[s][s][0] = 0.;\n    typedef tuple<double, int, int, int> State;\n    priority_queue<State> q;\n    for(q.emplace(0., 0, s, s); !q.empty();){\n        double t; int v, u, p;\n        tie(t, v, u, p) = q.top(); q.pop();\n        if(mem[u][p][v] + t < -eps || res + t <= -eps)continue;\n        if(u == g && v == 1)chmin(res, -t);\n        for(auto e: G[u])if(e.to != p){\n            for(int dv=-1; dv<=1; ++dv){\n                int nv = v + dv <= 0? 1: v + dv;\n                double nt = e.wt / nv - t;\n                if(30 < nv || e.cap < nv || mem[e.to][u][nv] <= nt + eps)continue;\n                mem[e.to][u][nv] = nt;\n                q.emplace(-mem[e.to][u][nv], nv, e.to, u);\n            }\n        }\n    }\n    if(inf - res < eps)throw \"unreachable\";\n    return res;\n}\n\nint main(){\n    while(cin >> n >> m, n|m){\n        cin >> s >> g;\n        s--; g--;\n        vector<vector<Edge> > G(n);\n        rep(i, m){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            G[x].emplace_back(y, d, c);\n            G[y].emplace_back(x, d, c);\n        }\n        try{\n            cout << fixed << setprecision(5) << solve(G) << '\\n';\n        }\n        catch(const char* mes){\n            cout << mes << '\\n';\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector< vector<int> > vvi;\n\nint dist[31][31];\nint cap[31][31];\nbool visit[31][31][31]; // city, speed, pre\nconst int INF = 1e7;\n\nstruct node {\n\tint s, p, c;\n\tdouble t;\n\tnode(int _s, int _p, int _c, double _t) {\n\t\ts = _s;\n\t\tp = _p;\n\t\tc = _c;\n\t\tt = _t;\n\t}\n};\nbool operator<(const node& l, const node& r) {\n\treturn l.t > r.t;\n}\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\trep(i,31) rep(j,31) dist[i][j] = cap[i][j] = INF;\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\trep(i, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tdist[x][y] = dist[y][x] = d;\n\t\t\tcap[x][y] = cap[y][x] = c;\n\t\t}\n\t\tpriority_queue<node> que;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tif( dist[s][i] < INF && 1 <= cap[s][i] ) {\n\t\t\t\tque.push( node(1, i, s, 1.*dist[s][i]) );\n\t\t\t}\n\t\t}\n\t\tbool found = false;\n\t\twhile(!que.empty()) {\n\t\t\tnode nd = que.top();\n\t\t\tque.pop();\n\t\t\tif( nd.p==g && nd.s==1 ) {\n\t\t\t\tcout << setprecision(10) << nd.t << endl;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( visit[nd.p][nd.s][nd.c] ) continue;\n\t\t\tvisit[nd.p][nd.s][nd.c] = true;\n\t\t\tfor(int nxt=1; nxt<=n; nxt++) {\n\t\t\t\tif( nd.c == nxt ) continue;\n\t\t\t\tfor(int sp=max(1,nd.s-1); sp<=min(30,nd.s+1); sp++) {\n\t\t\t\t\tif( !visit[nxt][sp][nd.p] && dist[nd.p][nxt] < INF && sp <= cap[nd.p][nxt] ) {\n\t\t\t\t\tdouble nt = nd.t + 1.*dist[nd.p][nxt]/sp;\n\t\t\t\t\t\tque.push(node(sp, nxt, nd.p, nt));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!found) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef pair<pair<double,int>,pair<int,int> > P;\n\nclass road{\npublic:\n  int to,d,c;\n  road(int x,int y,int z){to = x;d = y;c = z;};\n};\n\nvector<road> G[31];\n\nint main(){\n  int n,m,s,g;\n  int x,y,d,c;\n\n  for(;;){\n    scanf(\"%d %d\",&n,&m);\n    if(!n && !m)break;\n    scanf(\"%d %d\",&s,&g);\n\n    double t[31][31][31];\n    bool v[31][31][31];\n\n    for(int i=0;i<=n;i++)G[i].clear();\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d %d %d\",&x,&y,&d,&c);\n      G[x].push_back(road(y,d,c));\n      G[y].push_back(road(x,d,c));\n    }\n    \n    for(int i=0;i<=n;i++)\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<=30;k++){\n\tt[i][j][k] = 1e10;\n\tv[i][j][k] = false;\n      }\n\n    t[s][0][0] = 0.0;\n    priority_queue<P,vector<P>,greater<P> > q;\n    q.push(P(pair<double,int>(0.0,s),pair<int,int>(0,0)));\n\n    while(q.size()){\n      P p = q.top();q.pop();\n\n      double time = p.first.first;\n      int now,prv,speed;\n      now = p.first.second;\n      prv = p.second.first;\n      speed = p.second.second;\n\n      if(v[now][prv][speed])continue;\n      v[now][prv][speed] = true;\n\n      for(int i=0;i<(int)G[now].size();i++){\n\troad r = G[now][i];\n\tif(r.to != prv){\n\t  for(int dif=-1;dif<=1;dif++){\n\t    if(speed+dif>0 &&  speed+dif<=r.c){\n\t      if(!v[r.to][now][speed+dif]){\n\t\tif(t[r.to][now][speed+dif] > time+(double)r.d/(speed+dif)){\n\t\t  t[r.to][now][speed+dif] = time+(double)r.d/(speed+dif);\n\t\t  q.push(P(pair<double,int>(t[r.to][now][speed+dif],r.to),pair<int,int>(now,speed+dif)));\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    double ans = 1e10;\n    for(int i=0;i<=n;i++)ans = min(ans,t[g][i][1]);\n    if(ans==1e10)printf(\"unreachable\\n\");\n    else printf(\"%.4lf\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            /*\n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n            vector<pa3> G[130];\nint a[130];\ndouble memo[40][40][40]={0};\npriority_queue<pa4,vector<pa4>,greater<pa4> > pq;\n   signed main(){\nint n,m,s,g;\n   \t\n   \twhile(1){\n   \tfor(int i=0;i<40;i++)for(int j=0;j<40;j++)for(int k=0;k<40;k++)memo[i][j][k]=-10;\n   \tcin>>n>>m;\n   \t//\tcout<<n<<\" \"<<m<<endl;\n   \t\tif(n==0 && m==0) return 0;\n   \t\tfor(int i=0;i<130;i++)G[i].clear();\n   \t\twhile(pq.size()>0) pq.pop();\n   \t\tcin>>s>>g;\n   \tfor(int i=0;i<m;i++){\n   \t\tint x,y,d,c;\n   \t\tcin>>x>>y>>d>>c;\n   \t\t\tG[x].pb((pa3){y,d,c});\n   \t\t\tG[y].pb((pa3){x,d,c});\n   \t\t\n   \t\t\n   \t}\n   \t// .y basho\n   \t// .z dokokara\n   \t// .w sokudo\n   \t\tpq.push((pa4){0.0,s,0,0});\n   \twhile(pq.size()>0){\n   \t\tpa4 r=pq.top();\n   \t\tpq.pop();\n   \t\tif(memo[r.y][r.z][r.w]>-1) continue;\n   \t\tmemo[r.y][r.z][r.w]=r.x;\n   \t//\tcout<<r.y<<\" \"<<r.z<<\" \"<<r.w<<\" \"<<r.x<<endl;\n   \t\tif(r.y==g && r.w==1){\n   \t\t\tprintf(\"%.10lf\\n\",r.x);\n   \t\t\tgoto lll;\n   \t\t}\n   \t\t\n   \t\tfor(auto v:G[r.y])if(v.x!=r.z){\n   \t\t\tif(1<= r.w-1 && r.w-1<= v.z){\n   \t\t\t\t\t\tpq.push((pa4){r.x+(v.y+0.0)/(r.w-1.0),v.x,r.y,r.w-1});\n   \t\t\t}\n   \t\t\tif(1<= r.w && r.w<= v.z){\n   \t\t\t\t\t\tpq.push((pa4){r.x+(v.y+0.0)/(r.w-0.0),v.x,r.y,r.w});\n   \t\t\t}\n   \t\t\tif(1<= r.w +1&& r.w+1<= v.z){\n   \t\t\t\t\t\tpq.push((pa4){r.x+(v.y+0.0)/(r.w+1.0),v.x,r.y,r.w+1});\n   \t\t\t}\n   \t\t}\n   \t\t}\n   \tcout<<\"unreachable\"<<endl;\n   \t\tlll:;\n   }\n   \t\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<cstring>\n#define INF 1e10\nusing namespace std;\nstruct edge{\n  int to,limit;\n  double dist;\n};\nstruct Point{\n  int speed,prev,v;\n  double cost;\n  Point(){}\n  Point(int speed_,int prev_,int v_,double cost_)\n    :speed(speed_),prev(prev_),v(v_),cost(cost_){}\n  bool operator>(const Point &a)const{\n    return cost > a.cost;\n  }\n};\nvector<edge> G[100];\ndouble d[40][40][40];//speed,pos,prev\nbool used[40][40][40];\ntypedef pair<int,int> pii; //speed,prev\ntypedef pair<int,pii> PII;//to,speed,prev\ntypedef pair<double,PII> P;//cost,to,speed\n\ndouble dikstra(int s,int g){\n  int ds[3]={-1,0,1};\n  priority_queue<Point,vector<Point>,greater<Point> > que;\n  \n  for(int i=0;i<40;i++)\n    for(int j=0;j<40;j++)\n      for(int k=0;k<40;k++)\n\td[i][j][k]=INF;\n  \n  memset(used,0,sizeof(used));\n  d[0][s][0]=0;\n  Point tmp(0,0,s,0);\n  que.push(tmp);\n  \n  while(!que.empty()){\n    Point p=que.top();que.pop();\n    if(d[p.speed][p.v][p.prev]<p.cost)continue;\n    if(p.speed==1 && p.v==g)return p.cost;\n\n    for(int i=0;i<G[p.v].size();i++){\n\tedge e=G[p.v][i];\n      for(int j=0;j<3;j++){\n\tint ns=p.speed+ds[j];\n\tif(1<=ns && ns<= e.limit &&\n\t   used[ns][e.to][p.v]==false &&\n\t   e.to!=p.prev && \n\t   d[ns][e.to][p.v]>p.cost+e.dist/ns){\n\n\t  used[ns][e.to][p.v]=true;\n\t  Point tmp(ns,p.v,e.to,p.cost+e.dist/ns);\n\t  que.push(tmp);\n\t  d[ns][e.to][p.v]=p.cost+e.dist/ns;\n\t  //cout << \"d[\" << ns << \"][\" << e.to << \"][\" << p.v << \"]:\" << d[ns][e.to][p.v] << endl;\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n){\n    for(int i=0;i<100;i++)G[i].clear();\n    cin>>s>>g;\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      G[x].push_back((edge){y,c,d});\n      G[y].push_back((edge){x,c,d});\n    }\n    double ans=dikstra(s,g);\n    if(ans==-1)cout << \"unreachable\" << endl;\n    else printf(\"%.5lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n,m;\nint d[35][35];\nint c[35][35];\n\ndouble dist[35][35];\n\ntypedef tuple<double,int,int,int> state;\n\ndouble dijkstra(int src,int dest){\n\trep(i,35)rep(j,35) dist[i][j]=inf;\n\tdist[src][0]=0.0;\n\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\n\tstate init(0.0,src,-1,0);\n\tq.push(init);\n\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\tdouble distance;\n\t\tint v,p,s;\n\t\ttie(distance,v,p,s)=cur;\n\t\trep(i,n){\n\t\t\tif(i==p||d[v][i]==-1)\n\t\t\t\tcontinue;\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tint nv=i;\n\t\t\t\tint ns=s+j;\n\t\t\t\tif(ns<=0||c[v][i]<ns) continue;\n\t\t\t\tdouble nd=distance+(1.0*d[v][i]/ns);\n\t\t\t\tif(dist[nv][ns]>nd){\n\t\t\t\t\tdist[nv][ns]=nd;\n\t\t\t\t\tstate next(nd,nv,v,ns);\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (dist[dest][1]>=inf)?-1:dist[dest][1];\n}\n\nint main(void){\n\twhile(cin >> n >> m){\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tclr(d,-1);\n\t\tint s,g;\n\t\tcin >> s >> g;\n\t\ts--,g--;\n\t\trep(i,m){\n\t\t\tint x,y,dd,cc;\n\t\t\tcin >> x >> y >> dd >> cc;\n\t\t\tx--,y--;\n\t\t\td[x][y]=d[y][x]=dd;\n\t\t\tc[x][y]=c[y][x]=cc;\n\t\t}\n\t\tcout.precision(9);\n\t\tdouble ans=dijkstra(s,g);\n\t\tif(ans==-1.0)\n\t\t\tcout << \"unreachable\" << endl;\n\t\telse\n\t\t\tcout << fixed << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> R;\ntypedef pair<double, R> Q;\nconst double INF = 1000000.0;\n\nint n, m, s, g;\n\nint V;\nstruct edge { int to, cost, maxspeed; };\nvector<edge> G[30];\ndouble d[30][30][31]; // city, before, speed\n\ndouble dijkstra() {\n  for (int i = 0; i < n; i++) for (int k = 0; k < n; k++) for (int j = 0; j <= 30; j++) d[i][k][j] = INF;\n  d[s][s][0] = 0.0;\n  priority_queue<Q, vector<Q>, greater<Q> > que;\n  que.push(Q(0.0, R(P(s, 0), s)));\n  while (!que.empty()) {\n    Q q = que.top(); que.pop();\n    double cost = q.first;\n    int from = q.second.first.first, speed = q.second.first.second, before = q.second.second;\n    if (cost > d[from][before][speed]) continue;\n    for (int i = 0; i < G[from].size(); i++) {\n      edge e = G[from][i];\n      int to = e.to, length = e.cost, maxspeed = e.maxspeed;\n      if (to == before) continue;\n      for (int j = -1; j <= 1; j++) {\n        int newspeed = speed + j;\n        if (newspeed <= 0 || newspeed > maxspeed) continue;\n        if (d[to][from][newspeed] > d[from][before][speed] + (double) length / newspeed) {\n          d[to][from][newspeed] = d[from][before][speed] + (double) length / newspeed;\n          que.push(Q(d[to][from][newspeed], R(P(to, newspeed), from)));\n        }\n      }\n    }\n  }\n  double ans = INF;\n  for (int i = 0; i < n; i++) ans = min(ans, d[g][i][1]);\n  return ans;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0) break;\n    scanf(\"%d%d\", &s, &g);\n    s--; g--;\n    int x, y, d, c;\n    for (int i = 0; i < m; i++) {\n      scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n      x--; y--;\n      edge e1, e2;\n      e1.cost = e2.cost = d;\n      e1.maxspeed = e2.maxspeed = c;\n      e1.to = y, e2.to = x;\n      G[x].push_back(e1);\n      G[y].push_back(e2);\n    }\n    double ans = dijkstra();\n    if (ans == INF) printf(\"unreachable\\n\");\n    else printf(\"%f\\n\", ans);\n    for (int i = 0; i < n; i++) G[i].clear();\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<functional>\n \n \n#define rep(i,n) for(int i=0;i<(n);i++)\n \nusing namespace std;\nconst int INF = 100000000;\ntypedef pair<int,int> P;\n\nint n,m;\n\nstruct edge\n{\n\t//どこから来た,コスト,速度制限\n\tint to,cost,ub;\n\tedge(int to,int cost,int ub) {\n\t\tthis->to = to;\n\t\tthis->cost = cost;\n\t\tthis->ub = ub;\n\t}\n};\n\nvector<edge> G[103];\nint s,g;\ndouble dist[103][103][33];\n\ntypedef pair<double,int> PD;\ntypedef pair<PD,P> PP;\n\ndouble dijkstra() {\n\trep(i,103) rep(j,103) rep(k,33) dist[i][j][k]=INF;\n\trep(i,103) dist[s][i][1]=0;\n\n\t//最短距離 頂点 前の頂点 今の速さ\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(PD(0,s),P(0,1)));\n\n\twhile (!que.empty())\n\t{\n\t\tPP pp = que.top(); que.pop();\n\t\tint v = pp.first.second;\n\n\t\tint prev = pp.second.first;\n\t\tint u = pp.second.second;\n\n\t\tif(dist[v][u][prev] < pp.first.first) continue;\n\n\t\trep(i,G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tfor(int j=-1;j<=1;j++) {\n\t\t\t\tif(j+u<=0 || u+j > e.ub) continue;\n\n\t\t\t\tif(dist[e.to][v][u+j] > dist[v][prev][u] + (1.0*e.cost/(u+j))) {\n\t\t\t\t\tdist[e.to][v][u+j] = dist[v][prev][u] + (1.0*e.cost/(u+j));\n\t\t\t\t\tque.push(PP(PD(dist[e.to][v][u+j],e.to),P(v,u+j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tdouble ans=INF;\n\trep(i,103) ans=min(ans,dist[g][i][1]);\n\n\treturn ans;\n\t\n}\n\nvoid solve() {\n\trep(i,103) G[i].clear();\n\tcin>>s>>g;\n\trep(i,m) {\n\t\tint x,y,d,c;\n\t\tcin>>x>>y>>d>>c;\n\t\tG[x].push_back(edge(y,d,c));\n\t\tG[y].push_back(edge(x,d,c));\n\t}\n\n\tdouble ans;\n\tans = dijkstra();\n\tif(ans==INF) {\n\t\tcout<<\"unreachable\"<<endl;\n\t}\n\telse\n\t{\n\t\tcout<<ans+1.0<<endl;\n\t}\n\n\n}\n\nint main() {\n\twhile (cin>>n>>m)\n\t{\n\t\tif(n+m==0) return 0;\n\t\tsolve();\n\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double dINF = 1e11;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef pair<double,PP> PPP;\n\nint main ()\n{\n    int n, m;\n    while (cin >> n >> m, n + m) {\n        int s, g;\n        cin >> s >> g;\n        vector<vector<PP> > e(n + 1);\n\n        for (int i = 0; i < m; i++) {\n            int sx, sy, d, c;\n            cin >> sx >> sy >> d >> c;\n            e[sx].push_back(PP(sy, P(d, c) ));\n            e[sy].push_back(PP(sx, P(d, c) ));\n        }\n\n        priority_queue<PPP, vector<PPP>, greater<PPP> > pq;\n//        vector<vector<double> > dp(31, vector<double>(n + 1, dINF));\n        vector<vector<vector<double> > > dp(31, vector<vector<double> >(n + 1, vector<double>(n + 1, dINF)));\n        // dp[0][0][s] = 0.;\n        double res = dINF;\n\n        for (int j = 0; j < e[s].size(); j++) {\n            int dir = e[s][j].first;\n            int dis = e[s][j].second.first;\n            int limit = e[s][j].second.second;\n\n            dp[1][s][dir] = (double)dis;\n            pq.push(PPP((double)dis, PP(1, P(dir, s)) ));\n        }\n\n        while (pq.size()) {\n            PPP ppp = pq.top(); pq.pop();\n            double cost = ppp.first;\n            int v = ppp.second.first;\n            int now = ppp.second.second.first;\n            int pre = ppp.second.second.second;\n\n            if (dp[v][pre][now] < cost) continue;\n            // if (now == g && v == 1 && dp) break;\n\n            // cout << now << \" \" << pre  << \" \" << v << endl;\n\n            for (int i = 0; i < e[now].size(); i++) {\n                if (e[now][i].first == pre) continue;\n\n                for (int j = -1; j <= 1; j++) {\n                    if (v + j <=  0 || v + j > e[now][i].second.second) continue;\n                    double cost_ = cost + (double)e[now][i].second.first / (double)(v + j);\n                    int to_ = e[now][i].first;\n                    if (dp[v + j][now][to_] > cost_) {\n                        dp[v + j][now][to_] = cost_;\n                        pq.push(PPP(cost_, PP(v + j, P(to_, now))) );\n                        if (to_ == g && v + j == 1)\n                        {\n                            res = min(res, cost_);\n                            // cout << \"DBG > cost : \" << cost_ << \" v : \" << v + j << \" to : \" << to_ << endl;\n                        }\n                    }\n                }\n            }\n        }\n\n        for (int i = 1; i <= n; i++) {\n            res = min(res, dp[1][i][g]);\n        }\n        // if (dp[1][g] == dINF) cout << \"unreachable\" << endl;\n        // else printf(\"%.12f\\n\", dp[1][g]);\n        if (res == dINF) cout << \"unreachable\" << endl;\n        else printf(\"%.12f\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct S{\n  double t;\n  int v;\n  int p;\n  S(){}\n  S(double t, int v, int p) :\n    t(t), v(v), p(p) {}\n};\nstruct edge{\n  int to, dist, lim;\n  edge(int to, int dist, int lim) :\n    to(to), dist(dist), lim(lim) {}\n};\ntypedef vector<edge> edges;\nbool operator < (const S& s, const S& t){\n  return s.t > t.t;\n}\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m>>s>>g, n){\n    s--; g--;\n    vector<edges> graph(n);\n    REP(i,m){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c; x--; y--;\n      graph[x].push_back(edge(y, d, c));\n      graph[y].push_back(edge(x, d, c));\n    }\n    priority_queue<S> que;\n    que.push(S(0,0,s));\n    bool used[40][40] = {};\n    double ans = -1;\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      //printf(\"quesize:%d time:%lf speed:%d point:%d\\n\",que.size(), s.t,s.v,s.p);\n      if(s.p == g && s.v == 1){\n        ans = s.t;\n        break;\n      }\n      if(used[s.v][s.p]) continue;\n      used[s.v][s.p] = true;\n      for(int nv = s.v - 1; nv <= s.v + 1; nv++)if(nv > 0){\n        FORIT(it, graph[s.p])if(it->lim >= nv){\n          que.push(S(s.t + (double)it->dist/nv, nv, it->to));\n        }\n      }\n    }\n    if(ans != -1) cout<<ans<<endl;\n    else cout<<\"unreachable\"<<endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\n#define EPS (double)1e-9\n#define INF (double)1e9\n#define MAX_SPEED 30\n\nvector<vector<vector<double> > > dijk(int s_point, int s_speed, vector<vector<vector<pair<double, pair<int, int> > > > >& adj){\n  int v = adj.size();\n  int t = adj[0].size();\n  vector<vector<vector<double> > > result(v, vector<vector<double> >(v, vector<double>(t, INF)));\n  priority_queue<pair<double, pair<int, pair<int, int> > > > wait;\n  wait.push(make_pair(0, make_pair(0, make_pair(s_point, s_speed))));\n  for(int i = 0; i < v; i++){ result[s_point][i][s_speed] = 0; }\n  \n  while(!wait.empty()){\n    double nowcost = -wait.top().first;\n    int prevpoint = wait.top().second.first;\n    int nowpoint = wait.top().second.second.first;\n    int nowspeed = wait.top().second.second.second;\n    wait.pop();\n    if(result[nowpoint][prevpoint][nowspeed] + EPS < nowcost){ continue; }\n\n    for(size_t i = 0; i < adj[nowpoint][nowspeed].size(); i++){\n      double nextcost = adj[nowpoint][nowspeed][i].first + nowcost;\n      int nextpoint = adj[nowpoint][nowspeed][i].second.first;\n      int nextspeed = adj[nowpoint][nowspeed][i].second.second;\n      if(nextpoint != prevpoint && result[nextpoint][nowpoint][nextspeed] - EPS > nextcost){\n        wait.push(make_pair(-nextcost, make_pair(nowpoint, make_pair(nextpoint, nextspeed))));\n        result[nextpoint][nowpoint][nextspeed] = nextcost;\n      }\n    }\n  }\n\n  return result;\n}\n\nint main(void){\n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    int s, g;\n    cin >> s >> g;\n\n    int x, y, d, c;\n    vector<vector<vector<pair<double, pair<int, int> > > > > adjlist(n + 1,\n                                                                     vector<vector<pair<double, pair<int, int> > > >(MAX_SPEED + 1));\n    for(int i = 0; i < m; i++){\n      cin >> x >> y >> d >> c;\n      for(int j = 0; j <= MAX_SPEED; j++){\n        if(1 <= j - 1 && j - 1 <= c){\n          adjlist[x][j].push_back(make_pair((double)d / (j - 1), make_pair(y, j - 1)));\n          adjlist[y][j].push_back(make_pair((double)d / (j - 1), make_pair(x, j - 1)));\n        }\n        if(1 <= j && j <= c){\n          adjlist[x][j].push_back(make_pair((double)d / j, make_pair(y, j)));\n          adjlist[y][j].push_back(make_pair((double)d / j, make_pair(x, j)));\n        }\n        if(j + 1 <= c){\n          adjlist[x][j].push_back(make_pair((double)d / (j + 1), make_pair(y, j + 1)));\n          adjlist[y][j].push_back(make_pair((double)d / (j + 1), make_pair(x, j + 1)));\n        }\n      }\n    }\n    \n    double ans = INF;\n    vector<vector<vector<double> > > result = dijk(s, 0, adjlist);\n    for(int i = 0; i < n; i++){ ans = min(ans, result[g][i][1]); }\n    if(ans + EPS >= INF){ printf(\"unreachable\\n\"); }\n    else{ printf(\"%.10f\\n\", ans); }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define EPS 1e-8\n#define INF DBL_MAX\n\ndouble cost[30][35]; // place,velocity\n\nstruct P{\n  double t;\n  char v,p,pre;\n  P(double T=0.0,int V=0,int pp=0,int PRE=0){\n    t=T;v=V;p=pp;pre=PRE;\n  };\n  bool operator<(const P &p)const{\n    return t>p.t;\n  }\n};\nstruct Path{\n  char d,c;\n  Path(int D=0,int C=0){ d=D;c=C;};\n};\n\nint main(){\n  int n,m, s,g, x,y,d,c;\n  Path path[30][30];\n  priority_queue<P> q;\n\n  while( cin>>n>>m && (n|m) ){\n    cin >> s >> g;\n    s--; g--;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tpath[i][j].d=-1.0; path[i][j].c=-1;\n      }\n\n    for( int i=0;i<m;i++ ){\n      cin >> x >> y >> d >> c;\n      x--;y--;\n      path[x][y].d=d; path[x][y].c=c;\n      path[y][x] = path[x][y];\n    }\n\n    int dv[3] = {1,0,-1};\n    for( int i=0;i<n;i++ )\n      for( int j=1;j<31;j++ )\n\tcost[i][j] = INF;\n\n    while( !q.empty() ) q.pop();\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      q.push( P(cost[i][1]=path[s][i].d,1,i,-1) );\n    }\n\n    while( !q.empty() ){\n      P p = q.top(); q.pop();\n      double t = p.t;\n      int v=p.v, np=p.p, pre=p.pre;\n      if( np==g && v==1 ) break;\n\n      for( int i=0;i<n;i++ ){\n\tif( path[np][i].c<0 ) continue;// たどり着けないノード\n\tif( i==pre ) continue; // 前回のノード\n\n\tint j=0;\n\tif( i==g ) j=2;\n\tfor( ;j<3;j++ ){\n\t  int nv = v + dv[j];\n\t  if( nv==0 || nv>path[np][i].c )    continue;\n\t  double nCost = t + (double)path[np][i].d/nv;\n\t  if( nCost>cost[g][1] || fabs(nCost-cost[g][1])<EPS ) continue;\n\t  if( cost[i][nv] < nCost ) continue;\n\t  cost[i][nv]=nCost;\n\n\t  q.push( P(nCost,nv,i,np) );\n\t}\n      }\n\n    }\n    if( fabs(cost[g][1]-INF)<EPS )\n      cout << \"unreachable\" << endl;\n    else\n      printf(\"%.6lf\\n\",cost[g][1]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?(テァツクツョテ・ツーツ湘ァツ可?\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\nconstexpr int T = 40;\n\nint N, M, s, g;\n\n// cur, prev, speed, prevsテ」ツ??、ツクツュティツコツォテ」ツ?ッテヲツ卍づゥツ鳴?\ndouble dist[40][40][T][4];\n\nstruct Edge {\n    int to; double cost; int lim;\n};\n\nstruct Elem {\n    int cur, prev, speed, prevs;\n};\n\nbool operator<(const Elem &a, const Elem &b) {\n    return dist[a.cur][a.prev][a.speed][a.prevs] > dist[b.cur][b.prev][b.speed][b.prevs];\n}\n\nint dx[] = {-INF, -1, 0, 1};\n\nsigned main() {\n    while(cin >> N >> M, N || M) {\n        N++;\n        cin >> s >> g;\n        vector< vector<Edge> > G(N);\n        rep(i,0,M) {\n            int x, y; double d; int c; cin >> x >> y >> d >> c;\n            G[x].push_back(Edge{y, d, c});\n            G[y].push_back(Edge{x, d, c});\n        }\n\n        rep(i,0,N) rep(j,0,N) rep(k,0,T) rep(l,0,4) dist[i][j][k][l] = INF;\n        dist[s][0][1][0] = 0.0;\n\n        priority_queue<Elem> q;\n        q.push(Elem{s, 0, 1, 0});\n\n        double ans = INF;\n        while(!q.empty()) {\n            Elem t = q.top(); q.pop();\n            rep(i,1,4) {\n                int sp = t.speed + dx[i];\n                if(sp == 0) continue;\n                for(auto x : G[t.cur]) {\n                    if(x.lim < t.speed || x.to == t.prev) continue;\n                    double c = x.cost / t.speed;\n                    // cur, prev, speed, prevs\n                    if(dist[x.to][t.cur][sp][i] > dist[t.cur][t.prev][t.speed][t.prevs] + c) {\n                        dist[x.to][t.cur][sp][i] = dist[t.cur][t.prev][t.speed][t.prevs] + c;\n                        if(x.to == g && t.speed == 1) {\n                            chmin(ans, dist[x.to][t.cur][sp][i]);\n                        }\n                        q.push(Elem{x.to, t.cur, sp, i});\n                    }\n                }\n            }\n        }\n        if(ans == INF) cout << \"unreachable\" << endl;\n        else printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n \n \nstruct node{\n    int index,prev,speed;\n    double cost;\n    node(int index,int prev,int speed,double cost):index(index),prev(prev),speed(speed),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n    }\n};\nconst double MAX=INT_MAX/10;\nconst double NONE=-1;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<vvd> vvvd;\n \nint main(){\n    cout.precision(16);\n    int n,m;\n    while(cin>>n>>m,n){\n        int s,g;\n        cin>>s>>g;\n        vvi dist(n,vi(n,NONE));\n        vvi limit(n,vi(n,NONE));\n        REP(i,m){\n            int x,y,d,c;\n            cin>>x>>y>>d>>c;\n            dist[x-1][y-1]=d;\n            dist[y-1][x-1]=d;\n            limit[x-1][y-1]=c;\n            limit[y-1][x-1]=c;\n        }\n         \n        priority_queue<node> q;\n        q.push(node(s-1,s-1,0,0));\n        vvvd cost(n,vvd(n,vd(31,MAX)));\n        cost[s-1][s-1][0]=0;\n        while(!q.empty()){\n            node cnode=q.top();q.pop();\n            if(cost[cnode.index][cnode.prev][cnode.speed]<cnode.cost){\n                continue;\n            }\n            REP(i,n){\n                if(i!=cnode.index&&dist[cnode.index][i]!=NONE&&i!=cnode.prev){\n                    for(int ds=-1;ds<=1;ds++){\n                        int newspeed=cnode.speed+ds;\n                        if(newspeed>0&&newspeed<=limit[cnode.index][i]){\n                            double newcost=cnode.cost+(double)dist[cnode.index][i]/newspeed;\n                            if(cost[i][cnode.index][newspeed]>newcost){\n                                cost[i][cnode.index][newspeed]=newcost;\n                                q.push(node(i,cnode.index,newspeed,newcost));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        double ans=MAX;\n        REP(prev,n){\n            ans=min(ans,cost[g-1][prev][1]);\n        }\n        if(ans==MAX){\n            cout<<\"unreachable\"<<endl;\n        }else{\n            cout<<ans<<endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nstruct State {\n    int i, prev, sp; double cost;\n};\n\nbool operator>(const State& a, const State& b)\n{\n    return a.cost > b.cost;\n}\n\nconst double INF = 1<<29;\n\nint main()\n{\n    while (1) {\n        int n, m, s, g; cin >> n >> m >> s >> g;\n        if (!n) break;\n        s--, g--;\n\n        vector<vector<double>> dist(n, vector<double>(n, INF));\n        vector<vector<int>> lim(n, vector<int>(n));\n\n        while (m--) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--, y--;\n            dist[x][y] = dist[y][x] = d;\n            lim[x][y] = lim[y][x] = c;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> Q;\n        Q.push({ s, -1, 0, 0 });\n\n        pair<int, int> debug[40][40];\n\n        int vis[40][40][40] = {};\n        double ans = INF;\n        while (Q.size()) {\n            auto e = Q.top(); Q.pop();\n            if (vis[e.i][e.sp][e.prev]) continue;\n            vis[e.i][e.sp][e.prev] = 1;\n            if (e.i == g && e.sp == 1) ans = min(ans, e.cost);\n            loop (n, i) loop (3, d) {\n                int sp = e.sp-1+d;\n                if (dist[e.i][i] == INF || i == e.prev ||\n                        sp < 1 || sp > lim[e.i][i]) continue;\n                Q.push({ i, e.i, sp, e.cost + dist[e.i][i] / sp });\n            }\n        }\n        if (ans != INF) cout << setprecision(12) << fixed << ans << endl;\n        else cout << \"unreachable\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 90 // いつもは1<<29だが小さくすれば時間はやくなる？\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n//自身だー\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\n// prototype\nbool big_equal( double a, double b );\n\n// constraint\nconst int size = 31;\nconst double eps = 1e-9;\nconst double inf = (double)(1<<24);\n\n//\n// global\n//\n\n// dijkstra\nclass Node {\npublic:\n    double time;\n    int town, prev, v;\n    bool operator < ( const Node& right ) const\n    {\n        return fabs( time - right.time ) < eps ? v < right.v : time > right.time;\n    }\n    Node(){}\n    Node( double time_, int town_, int prev_, int v_ )\n    {\n        time = time_;\n        town = town_;\n        prev = prev_;\n        v = v_;\n    }\n};\ndouble MC[size][size][size];\ntypedef priority_queue <Node > QUEUE;\n\n// data\nint n;\nint CN[size][size]; // connection\nint CNcnt[size];\ndouble D[size][size]; // distance of path\nint L[size][size]; // speed limit\n\nbool big_equal( double a, double b )\n{\n    return fabs( a - b ) < eps ? true : a < b;\n}\n\nvoid solve( int start, int goal )\n{\n    // init\n    QUEUE Q;\n    Node start_node( 0.0, start, -1, 1 );\n    Q.push( start_node );\n\n    // proc\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        // proc init\n        double time = node.time;\n        int town = node.town;\n        int prev = node.prev;\n        int v = node.v;\n\n        if ( town == goal && v == 1 ) {\n            printf( \"%.5f\\n\", time );\n            return;\n        }\n\n        // move\n        for ( int i = 0; i < CNcnt[town]; i++ ) {\n            int next_town = CN[town][i];\n            int next_prev = town;\n            if ( next_town == prev ) continue;\n\n            for ( int j = -1; j <= 1; j++ ) {\n                int next_v = v + j;\n                if ( prev == -1 && j != 0 ) continue;\n                if ( next_v <= 0 || next_v > L[town][next_town] ) continue;\n                double next_time = time + (double)D[town][next_town] / next_v;\n\n                if ( big_equal( MC[next_town][next_prev][next_v], next_time ) ) continue;\n                MC[next_town][next_prev][next_v] = next_time;\n                Node next_node( next_time, next_town, next_prev, next_v );\n                Q.push( next_node );\n            }\n        }\n    }\n\n    cout << \"unreachable\" << endl;\n}\n\nint main( void )\n{\n    while ( cin >> n && n ) {\n        // init\n        for ( int i = 0; i < size; i++ ) {\n            CNcnt[i] = 0;\n            for ( int j = 0; j < size; j++ ) {\n                for ( int k = 0; k < size; k++ ) {\n                    MC[i][j][k] = inf;\n                }\n            }\n        }\n\n        // input\n        int m;\n        cin >> m;\n        int s, g;\n        cin >> s >> g;\n        for ( int i = 0; i < m; i++ ) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            D[x][y] = D[y][x] = d;\n            L[x][y] = L[y][x] = c;\n            CN[x][CNcnt[x]++] = y;\n            CN[y][CNcnt[y]++] = x;\n        }\n\n        // proc\n        solve( s-1, g-1 );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\n\nconst double INF = 1e9;\n\nint n, m, s, g;\n\n// [n][v];\ndouble dp[32][32];\n\nstruct edge {\n\tint to, c;\n\tdouble length;\n\n\tedge(int to, int c, double l) :to(to), c(c), length(l){\n\t}\n};\n\nvector<edge> G[32];\n\nstruct state {\n\tint n, prev, v;\n\tdouble time;\n\n\tstate(int n, int prev, int v, double time) :n(n), prev(prev),v(v), time(time){\n\t}\n};\n\nint main(){\n\twhile(cin >> n >> m , n | m) {\n\t\tcin >> s >> g;\n\n\t\tfor(int i = 0; i < 31; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint x, y, c;\n\t\t\tdouble d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tG[x].push_back(edge(y, c, d));\n\t\t\tG[y].push_back(edge(x, c, d));\n\t\t}\n\n\t\tfor(int i = 0; i < 31; i++) {\n\t\t\tfor(int j = 0; j < 31; j++) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tqueue<state> q;\n\t\tq.push(state(s, -1, 1, 0.0));\n\t\twhile(!q.empty()) {\n\t\t\tstate s = q.front();\n\t\t\tq.pop();\n\t\t\tif(dp[s.n][s.v] <= s.time) continue;\n\t\t\tdp[s.n][s.v] = s.time;\n\t\t\tint dv[] = {0, 1, -1};\n\t\t\tfor(int i = 0; i < G[s.n].size(); i++) {\n\t\t\t\tfor(int j = 0; j < ((s.prev == -1) ? 1 : 3); j++) {\n\t\t\t\t\tint nv = s.v + dv[j];\n\t\t\t\t\tif(nv > 0 && nv <= G[s.n][i].c && G[s.n][i].to != s.prev)\n\t\t\t\t\t\tq.push(state(G[s.n][i].to, s.n, nv, s.time + G[s.n][i].length / nv));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = dp[g][1];\n\t\tif(ans == INF)\n\t\t\tcout << \"unreachable\" << endl;\n\t\telse\n\t\t\tcout << dp[g][1] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n\nint N, M, s, g;\nstruct Edge {\n    int to;\n    double d, c;\n    Edge(int to, double d, double c) : to(to), d(d), c(c) {}\n};\nstruct Data {\n    double res;\n    int n;\n    int pre;\n    int v;\n    bool operator<(const Data &rhs) const { return res < rhs.res; };\n    bool operator>(const Data &rhs) const { return res > rhs.res; };\n};\nvector<Edge> G[33];\ndouble dp[33][33][33];  // jから速度kでiに来た時の最短時間\nvoid init() {\n    REP(i, N + 1) REP(j, N + 1) REP(k, 31) { dp[i][j][k] = 1e9; }\n    REP(i, N) G[i].clear();\n    dp[s][s][0] = 0;\n}\n\nusing arr4 = array<int, 4>;\nbool solve() {\n    cin >> N >> M;\n    if (N == 0) return false;\n    cin >> s >> g;\n    s--, g--;\n    init();\n    REP(i, M) {\n        int u, v;\n        double d, c;\n        cin >> u >> v >> d >> c;\n        u--, v--;\n        G[u].push_back({v, d, c});\n        G[v].push_back({u, d, c});\n    }\n    priority_queue<Data, vector<Data>, greater<Data>> que;\n    que.push({0, s, s, 0});\n    while (!que.empty()) {\n        Data dat = que.top();\n        que.pop();\n        double res = dat.res;\n        int n = dat.n;\n        int pre = dat.pre;\n        int v = dat.v;\n        for (auto e : G[n]) {\n            if (e.to == pre) continue;\n            REP(i, 3) {\n                int nv = v - 1 + i;\n                if (nv <= 0 || nv > e.c) continue;\n                if (dp[e.to][n][nv] > dp[n][pre][v] + (double)e.d / nv) {\n                    dp[e.to][n][nv] = dp[n][pre][v] + (double)e.d / nv;\n                    que.push({dp[e.to][n][nv], e.to, n, nv});\n                }\n            }\n        }\n    }\n    double ans = 1e9;\n    REP(i, N) { ans = min(ans, dp[g][i][1]); }\n    if (ans >= 1e9)\n        cout << \"unreachable\" << endl;\n    else\n        cout << fixed << setprecision(10) << ans << endl;\n    return true;\n}\nsigned main() {\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "//1162\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nconst int MAX_N=30,MAX_C=30;\nconst double INF=1e8;\nconst double ESP=1e-8;\n\n#define EQ(a,b) fabs(a-b)<ESP\n\nint n,m;\nint s,g;\nstruct edge{\n\tint to,dist,c;\n};\nvector<edge> G[MAX_N];\n\nstruct S{\n\tint town,v,pre;\n\tdouble cost;\n\tbool operator<(const S &a) const{\n\t\treturn cost>a.cost;\n\t}\n};\n\ndouble cost[MAX_N][MAX_C+1][MAX_N];\nbool used[MAX_N][MAX_C+1][MAX_N];\n\nvoid dijkstra(){\n\tREP(i,n){\n\t\tREP(j,MAX_C+1){\n\t\t\tREP(k,n){\n\t\t\t\tcost[i][j][k]=INF;\n\t\t\t\tused[i][j][k]=false;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<S> pq;\n\tpq.push(S{s,0,0,0.0});\n\tcost[s][0][0]=0;\n\twhile (!pq.empty()){\n\t\tS s=pq.top();\n\t\tpq.pop();\n\t\tif (used[s.town][s.v][s.pre]){\n\t\t\tcontinue;\n\t\t}\n\t\tused[s.town][s.v][s.pre]=true;\n\t\tFOR(acc,-1,1+1){\n\t\t\tif (s.v+acc<=0) continue;\n\t\t\tFOR(i,0,G[s.town].size()){\n\t\t\t\tedge e=G[s.town][i];\n\t\t\t\tif (s.v+acc>e.c){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (e.to==s.pre) continue;\n\t\t\t\tif (s.cost+(double)e.dist/(s.v+acc)<cost[e.to][s.v+acc][s.town]+0.001){\n\t\t\t\t\tcost[e.to][s.v+acc][s.town]=s.cost+(double)e.dist/(s.v+acc);\n\t\t\t\t\tpq.push(S{e.to,s.v+acc,s.town,cost[e.to][s.v+acc][s.town]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif (n){\n\t\t\tscanf(\"%d %d\",&s,&g);\n\t\t\ts--;\n\t\t\tg--;\n\t\t\tREP(i,n){\n\t\t\t\tG[i].clear();\n\t\t\t}\n\t\t\tREP(i,m){\n\t\t\t\tint x,y,d,c;\n\t\t\t\tscanf(\"%d %d %d %d\",&x,&y,&d,&c);\n\t\t\t\tx--;\n\t\t\t\ty--;\n\t\t\t\tG[x].push_back(edge{y,d,c});\n\t\t\t\tG[y].push_back(edge{x,d,c});\n\t\t\t}\n\t\t\tdijkstra();\n\t\t\tdouble ans=INF;\n\t\t\tREP(i,n){\n\t\t\t\tans=min(ans,cost[g][1][i]);\n\t\t\t}\n\t\t\tif (EQ(ans,INF)){\n\t\t\t\tprintf(\"unreachable\\n\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"%.6f\\n\",ans);\n\t\t\t}\n\t\t}\n\t}while (n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\nint n, m, s, g;\n\ndouble solve(pair<double, double> r[31][31])\n{\n    double result[31][31][31];\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            for(int k = 1; k <= 31; k++){\n                result[i][j][k] = mod;\n            }\n        }\n    }\n    priority_queue<pair<double, pair<pair<int, int>, int> > > qu;\n    qu.push(make_pair(0.0, make_pair(make_pair(s, -1), 0.0)));\n    while(!qu.empty()){\n        double nowcost = (qu.top()).first;\n        pair<int, int> nowandbefore = ((qu.top()).second).first;\n        int nowv = ((qu.top()).second).second;\n        int nowp = nowandbefore.first;\n        int beforep = nowandbefore.second;\n        // cout << nowp << \" \" << beforep << \" \" << -nowcost << \" \" << nowv << endl;\n        qu.pop();\n        if(nowp == g && nowv == 1) {\n            return -nowcost;\n        }\n        if(beforep != -1 && result[nowp][beforep][nowv] < -nowcost) continue;\n        result[nowp][beforep][nowv] = -nowcost;\n        for(int i = 1; i <= n; i++){\n            if(r[nowp][i].first == 0 || i == beforep) continue;\n            double kyori = r[nowp][i].first;\n            double limit = r[nowp][i].second;\n            double nextcost;\n            for(int j = -1; j <= 1; j++){\n                if(nowv + j <= 0) continue;\n                nextcost = nowcost - (double)kyori / (nowv + j);\n                if(nowv + j <= limit && -nextcost < result[i][nowp][nowv + j]){\n                    result[i][nowp][nowv + j] = -nextcost;\n                    qu.push(make_pair(nextcost, make_pair(make_pair(i, nowp), nowv + j)));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    while(1){\n        cin >> n >> m;\n        if(n == 0) break;\n        cin >> s >> g;\n        pair<double, double> road[31][31];\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= n; j++){\n                road[i][j] = make_pair(0, 0);\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int x, y;\n            double d, c;\n            cin >> x >> y >> d >> c;\n            road[x][y] = road[y][x] = make_pair(d, c);\n        }\n        double ans =  solve(road);\n        if(ans == -1) cout << \"unreachable\" << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n\n///////////////////ダイクストラで使うクラス//////////////////\nclass E{\n\tpublic:\n\tint dir,cost,limit;\n\tE(int dir,int cost,int limit):dir(dir),cost(cost),limit(limit){}\n};\n\nclass T{\n\tpublic:\n\tint pos,speed;\n\tdouble val;\n\tT(int pos,double val,int speed):pos(pos),val(val),speed(speed){}\n\t\n\tbool operator<(const T& a)const{\n\t\treturn val>a.val;\n\t}\n};\n\n////////////////////////////main/////////////////////////\nint main(){\n\t\n\twhile(1){\n\t\t/////////////入力/////////////////////////////////\n\t\tint n,m,start,goal;\n\t\tvector<E> edge[33];\n\t\t\n\t\tcin>>n>>m; if(n==0)break;\n\t\tcin>>start>>goal;\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tedge[a].push_back(E(b,c,d));\n\t\t\tedge[b].push_back(E(a,c,d));\n\t\t}\n\t\t\n\t\t///////////ダイクストラ本体//////////////////////\n\t\tpriority_queue<T> que;\n\t\tque.push(T(start,0,0)); //初期位置設定\n\t\t\n\t\tint visit[33][33]={0};\n\t\twhile(1){\n\t\t\tif(que.empty())break; //異常終了\n\t\t\t\n\t\t\tT u = que.top();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(visit[u.pos][u.speed]==1)continue; //一度訪れた状態の場合は弾く\n\t\t\tvisit[u.pos][u.speed]=1;\n\t\t\t\n\t\t\t\n\t\t\tif(u.pos==goal && u.speed==1){ //終了判定\n\t\t\t\tprintf(\"%lf\\n\",u.val);\n\t\t\t\tgoto A;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<edge[u.pos].size();i++){ //状態遷移\n\t\t\t\tE e = edge[u.pos][i];\n\t\t\t\t\n\t\t\t\t//-1:減速 0:等速 1:加速\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\n\t\t\t\t\tint next = u.speed + j;\n\t\t\t\t\tif(next > e.limit || next <= 0)continue; //速度の制約で弾く\n\t\t\t\t\t\n\t\t\t\t\tque.push( T(e.dir, u.val + double(e.cost)/next, next) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"unreachable\\n\");\n\t\tA:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <iomanip>\nusing namespace std;\nconst int S_MAX = 30;\nconst double inf = 1e9;\n\nstruct info{\n    int curr;\n    int prev;\n    int v;\n    double t;\n    info(int c, int p, int v, double t):curr(c),prev(p),v(v),t(t){}\n};\nnamespace std{\n    bool operator < (const info &a, const info &b){\n        return b.t < a.t;\n    }\n}\n\nint main(){\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n==0) break;\n\n        int s,g;\n        cin >> s >> g;\n        vector<vector<vector<info> > > adj(n+1, vector<vector<info> >(S_MAX+1));\n        for(int i=0; i<m; i++){\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            for(int v=1; v<=S_MAX; v++){\n                for(int r=-1; r<=1; r++){\n                    if(v+r>0 && v+r<=c){\n                        adj[x][v].push_back(info(y, x, v+r, (double)d/(v+r)));\n                        adj[y][v].push_back(info(x, y, v+r, (double)d/(v+r)));\n                    }\n                }\n            }\n        }\n\n        priority_queue<info> pq;\n        pq.push(info(s, 0, 1, 0));\n        vector<vector<vector<double> > > mincost(n+1, vector<vector<double> >(n+1, vector<double>(S_MAX, inf)));\n        mincost[s][0][1] = 0;\n        while(!pq.empty()){\n            int curr = pq.top().curr;\n            int prev = pq.top().prev;\n            int v = pq.top().v;\n            double cost = pq.top().t;\n            pq.pop();\n            if(cost > mincost[curr][prev][v]) continue;\n            if(curr==g && v==1) break;\n            for(int i=0; i<(int)adj[curr][v].size(); i++){\n                info next = adj[curr][v][i];\n                if(next.curr == prev) continue;\n                if(prev == 0 && next.v != 1) continue;\n                if(cost + next.t < mincost[next.curr][next.prev][next.v]){\n                    pq.push(info(next.curr, next.prev, next.v, cost+next.t));\n                    mincost[next.curr][next.prev][next.v] = cost + next.t;\n                }\n            }\n        }\n        double ans=inf;\n        for(int i=1; i<=n; i++){\n            ans = min(ans, mincost[g][i][1]);\n        }\n        if(ans == inf){\n            cout << \"unreachable\" << endl;\n        }else{\n            cout << fixed;\n            cout << setprecision(10);\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> edge;\ntypedef pair<int, P> PP;\ntypedef pair<double, PP> PPP;\n\nvector<edge> G[100];\ndouble memo[40][40][40];\ndouble need[200][40];\n priority_queue<PPP, vector<PPP>,greater<PPP> > que;\n\nint main(){\n  int n, m;\n  int s, g;\n  for(int i = 0; i < 200; i++){\n    for(int j = 1; j < 40; j++) need[i][j] = (double)i / j;\n  }\n  while(cin >> n >> m && (n || m)){\n    cin >> s >> g;\n    while(!que.empty()) que.pop();\n    fill(&memo[0][0][0], &memo[30][30][30]+1, 1e10);\n    for(int i = 0; i < m; i++){\n      int x1,y1,d,c;\n      cin >> x1 >> y1 >> d >> c;\n      G[x1].push_back(edge(y1, P(d, c)));\n      G[y1].push_back(edge(x1, P(d, c)));\n    }\n    memo[s][0][32] = 0;\n   \n    que.push(PPP(memo[s][0][32], PP(0, P(s, 32))));\n    bool ok = false;\n\n    while(!que.empty()){\n      PPP ppp = que.top();\n      que.pop();\n      double dis = ppp.first;\n      int v = ppp.second.first;\n      int pos = ppp.second.second.first;\n      int pre = ppp.second.second.second;\n\n      if(dis > memo[pos][v][pre]) continue;\n     \n      if(pos == g && v == 1){\n\tcout << dis << endl;\n\tok = true;\n\tbreak;\n      }\n\n      for(int i = -1; i <= 1; i++){\n\tint v2 = v + i;\n\tfor(int j= 0; j < (int)G[pos].size(); j++){\n\t  int to = G[pos][j].first;\n\t  int li = G[pos][j].second.second;\n\t  int d = G[pos][j].second.first;\n\n\t  if(1 <= v2 && v2 <= li && to != pre){\n\t    if(memo[to][v2][pos] > dis + need[d][v2]){\n\t      memo[to][v2][pos] = dis + need[d][v2];\n\t      que.push(PPP(memo[to][v2][pos], PP(v2, P(to, pos))));\n\t    }\n\t  }\n\t}\n      }\n\n    }\n    if(!ok){\n      cout << \"unreachable\" << endl;\n    }\n    for(int i = 1; i <= 30; i++) G[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<cmath>\n#include<vector>\n#include<functional>\n#define ull unsigned long long int \n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define min_(a,b) ((a)<(b)?(a):(b))\nusing namespace std;\n\n#define INF 10000000\n#define MAX_V 1000 \nstruct edge{ int to; double time; };\nvector<edge>G[MAX_V];\ndouble d[MAX_V];\nstruct T{\n\tdouble time;\n\tint from, to;\n};\nint V,E,st,gl;\n\nstruct StructGreater {\n\tbool operator() (const T a, const T b) {\n\t\treturn a.time > b.time;\n\t}\n};\nvoid dk(int s){\n\tfill(d, d + MAX_V, INF);\n\tpriority_queue<T, vector<T>, StructGreater >que;\n\ts = s * 30 + 0;\n\td[s] = 0;\n\trep(i, 0, (int)G[s].size())\n\tif (G[s][i].to%30==0){\n\t\t//printf(\"to=%d,time=%f\\n\", G[s][i].to / 30 + 1, G[s][i].time);\n\t\tT t = { G[s][i].time, s / 30, G[s][i].to };\n\t\tque.push(t);\n\t\td[G[s][i].to] = G[s][i].time;\n\t}\n\t//T tx = { 0,-1, 0 };\n\t//que.push(tx);\n\twhile (!que.empty()){\n\t\tT t = que.top(); que.pop();\n\t\tint v = t.to;\n\n\t\tif (d[v] < t.time)continue;\n\t\trep(i, 0, (int)G[v].size()){\n\t\t\tedge e = G[v][i];\n\t//\t\tprintf(\"%d->%d,%d->%d,\\n\", v / 30 + 1, e.to / 30 + 1,v % 30 + 1, e.to % 30 + 1);\n\t\t\tif (e.to / 30 != t.from&&d[e.to]>d[v] + e.time){\n\t\t\t\td[e.to] = d[v] + e.time;\n\t//\t\t\tprintf(\"(%d<%d<%d)%d,%f\\n\", e.to / 30 + 1, t.to / 30 + 1, t.from + 1, e.to % 30 + 1,d[e.to]);\n\t\t\t\tT tmp = { d[e.to], v / 30, e.to };\n\t\t\t\tque.push(tmp);\n\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i, 0, MAX_V)if (d[i] < INF)\n\t\t//printf(\"to=%d,time=%f\\n\", i / 30 + 1, d[i]);\n}\n\nint main(void){\n\twhile (true){\n\t\tcin >> V >> E;\n\t\tif (V == 0)return 0;\n\t\tcin >> st >> gl;\n\t\tst--; gl--;\n\t\trep(i, 0, E){\n\t\t\tint first, second, lim;\n\t\t\tdouble length;\n\t\t\tcin >> first >> second >> length >> lim;\n\t\t\tfirst--;\n\t\t\tsecond--;\n\t\t//\tcout << first << second << endl;\n\t\t\trep(i, 1, 31){\n\t\t\t\tdouble real_v;\n\t\t\t\t//始点\n\t\t\t\tint f = first * 30 + i - 1;\n\t\t\t\tint s = second * 30 + i - 1;\n\t\t\t\trep(j, -1, 2){\n\t\t\t\t\treal_v = i + j;\n\t\t\t\t\t//cout << real_v << endl;\n\t\t\t\t\tif (real_v<1 || real_v>lim)continue;\n\t\t\t\t\treal_v = length / real_v;\n\t\t\t\t\tedge f_e = { f + j, real_v }; edge s_e = { s + j, real_v };\n\t\t\t\t//\tcout << first << second << gl<<endl;\n\t\t\t\t\tG[f].push_back(s_e); \n\t\t\t\t\tG[s].push_back(f_e);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*rep(i, 0, MAX_V)\n\t\t\trep(j, 0, (int)G[i].size()){\n\t\t\t\tprintf(\"from=%d,to=%d,v=%d->%d,time=%f\\n\", i / 30 + 1, G[i][j].to / 30 + 1, i % 30 + 1, G[i][j].to % 30 + 1, G[i][j].time);\n\n\t\t\t}\n*/\n\t\tdk(st);\n\t\tprintf(\"%.8f\\n\", d[gl * 30]);\n\t\trep(i, 0, MAX_V)\n\t\twhile (!G[i].empty())\n\t\t\t\tG[i].pop_back();\n\t\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define NODE 30\n#define LIM 31\nconst double inf = 1e200;\n\nclass state{\npublic:\n  int cur,prev,speed;\n  double c;\n  state(){};\n  state(int tcur,int tprev,int tspeed,double tc):cur(tcur),prev(tprev),\n\t\t\t\t\t\t speed(tspeed),c(tc){};\n  bool operator<(const state & a)const{\n    return c >a.c;\n  }\n};\n\ndouble cost[30][30][31];\ndouble dist[30][30];\nint lim[30][30];\n\n\nvoid solve(int n,int s,int g){\n  rep(i,n)rep(j,n)rep(k,31)cost[i][j][k]=inf;\n  priority_queue<state> Q;\n  cost[0][0][1]=0;\n  rep(i,n){\n    if ( lim[s][i] >= 1){\n      cost[i][s][1]=dist[s][i];\n      Q.push(state(i,s,1,cost[i][s][1]));\n    }\n  }\n\n  while(!Q.empty()){\n    state now = Q.top();\n    Q.pop();\n    if ( cost[now.cur][now.prev][now.speed] <now.c)continue;\n    //    cout << now.cur <<\" \" << now.prev << \" \" << now.speed << endl;\n    if ( now.cur == g && now.speed == 1){\n      printf(\"%.3lf\\n\",now.c);\n      return;\n    }\n    rep(i,n){\n      if ( i == now.prev)continue;\n      REP(j,-1,2){\n\tif ( now.speed + j > 0 && now.speed + j <= lim[now.cur][i] &&\n\t     cost[i][now.cur][now.speed+j] > now.c + dist[now.cur][i]/(now.speed+j)){\n\t  cost[i][now.cur][now.speed+j]=now.c+dist[now.cur][i]/(now.speed+j);\n\t  Q.push(state(i,now.cur,now.speed+j,cost[i][now.cur][now.speed+j]));\n\t}\n      }\n    }\n  }\n  \n\n  puts(\"unreachable\");\n  \n}\n\n\nmain(){\n  int n,m;\n  while(cin>>n>>m && n){\n    rep(i,n)rep(j,n)lim[i][j]=0,dist[i][j]=inf;\n    int s,g;\n    cin>>s>>g;\n    s--;g--;\n    rep(i,m){\n      int f,t,v;\n      double d;\n      cin>>f>>t>>d>>v;\n      f--;t--;\n      dist[f][t]=dist[t][f]=d;\n      lim[f][t]=lim[t][f]=v;\n    }\n    solve(n,s,g);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\n\n\n\nint main(){\n  int inx,iny,ind,inc;\n  double d[40][40][40];\n  int n,m,s,g;\n \n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n    \n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000.0\nusing namespace std;\nstruct state { int n, v, l; double t; };\n\nint N, M, S, G;\nint vd[3] = { -1, 0, 1 };\n\nclass Compare {\npublic:\n  bool operator() (struct state a, struct state b) {\n    return a.t > b.t;\n  }\n};\n\nint main(void) {\n  while(cin >> N >> M, N) {\n    cin >> S >> G;\n\n    vector<int> T[101], D[101], C[101];\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      T[x].push_back(y); D[x].push_back(d); C[x].push_back(c);\n      T[y].push_back(x); D[y].push_back(d); C[y].push_back(c);\n    }\n\n    double dp[101][101][101];\n    REP(i, 0, 100) REP(j, 0, 100) REP(k, 0, 100) dp[i][j][k] = INF;\n\n    priority_queue<struct state, vector<struct state>, Compare> q;\n    struct state first = { S, 0, -1, 0.0 };\n    q.push(first);\n\n    while(!q.empty()) {\n      struct state c = q.top();\n      q.pop();\n\n      // cout << c.n << \" \" << c.v << \" \" << c.t << endl;\n\n      if(dp[c.n][c.l][c.v] <= c.t) continue;\n      dp[c.n][c.l][c.v] = min(dp[c.n][c.l][c.v], c.t);\n\n      for(int i = 0; i < T[c.n].size(); i++) {\n        if(T[c.n][i] == c.l) continue;\n        for(int j = 0; j < 3; j++) {\n          int v = c.v + vd[j];\n          if(v <= 0 || C[c.n][i] < v) continue;\n          double t = c.t + ((double) D[c.n][i] / v);\n          struct state n = { T[c.n][i], v, c.n, t };\n          // if(n.t < dp[n.n][n.v]) q.push(n);\n          q.push(n);\n        }\n      }\n    }\n\n    double ret = INF;\n    REP(i, 1, N) ret = min(ret, dp[G][i][1]);\n    if(ret < INF) printf(\"%.6f\\n\", ret);\n    else cout << \"unreachable\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint n, m;\n\t\tcin>>n>>m;\n\t\tif(n == 0 && m == 0) break;\n\t\tint s, g;\n\t\tcin>>s>>g;\n\t\t--s;\n\t\t--g;\n\t\tvector<vector<pair<ll, P> > > p(n);\n\t\tvector<vector<vector<double> > > d(n, vector<vector<double> >(n, vector<double>(31, INF)));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\t--x;\n\t\t\t--y;\n\t\t\tp[x].pb({y, P(d, c)});\n\t\t\tp[y].pb({x, P(d, c)});\n\t\t}\n\t\tpriority_queue<pair<pair<double, ll>, P>, vector<pair<pair<double, ll>, P> >, greater<pair<pair<double, ll>, P> > > q;\n\t\td[s][s][1] = 0;\n\t\tq.push({{0, s}, {s, 1}});\n\t\twhile(!q.empty()) {\n\t\t\tpair<pair<double, ll>, P> np = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[np.first.second][np.second.first][np.second.second] != np.first.first) continue;\n\t\t\tFOR(i, -1, 2) {\n\t\t\t\tll ns = np.second.second + i;\n\t\t\t\tif(np.first.second == s && np.second.first == s) {\n\t\t\t\t\tif(ns != 1) continue;\n\t\t\t\t}\n\t\t\t\tif(ns <= 0) continue;\n\t\t\t\tREP(j, p[np.first.second].size()) {\n\t\t\t\t\tll next = p[np.first.second][j].first;\n\t\t\t\t\tif(next == np.second.first) continue;\n\t\t\t\t\tif(p[np.first.second][j].second.second < ns) continue;\n\t\t\t\t\tif(d[next][np.first.second][ns] > d[np.first.second][np.second.first][np.second.second] + p[np.first.second][j].second.first / (double)ns) {\n\t\t\t\t\t\td[next][np.first.second][ns]  = d[np.first.second][np.second.first][np.second.second] + p[np.first.second][j].second.first / (double)ns;\n\t\t\t\t\t\tq.push({{d[next][np.first.second][ns], next}, {np.first.second, ns}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = INF;\n\t\tREP(i, n) {\n\t\t\tans = min(ans, d[g][i][1]);\n\t\t}\n\t\tif(ans != INF) cout<<fixed<<showpoint<<setprecision(39)<<ans<<endl;\n\t\telse cout<<\"unreachable\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nstruct edge{\n\tint to,cost,limit;\n\tedge(int t,int c,int l){\n\t\tto=t;cost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tbool visit[31][31][31];\n\tmemset(visit,false,sizeof(visit));\n\tvector<vector<edge> > E(n+1);\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in].push_back(edge(out,c,l));\n\t\tE[out].push_back(edge(in,c,l));\n\t}\n\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){\n\t\tNode t=Q.top(); Q.pop();\n\t\tif(visit[t.now][t.before][t.speed]) continue;\n\t\tvisit[t.now][t.before][t.speed]=true;\n\t\tif(t.now==g && t.speed==1){printf(\"%.12lf\\n\", t.time );  return;}\n\n\n\t\tint size=E[t.now].size();\n\t\tfor(int i=0;i<size;i++){\n\t\t\tint to=E[t.now][i].to;\n\t\t\tif(to==t.before) continue;\n\t\t\tif(E[t.now][i].cost>0){\n\t\t\t\tif(E[t.now][i].limit>=t.speed && t.speed>=1){\n\t\t\t\t\tQ.push(Node(to,t.speed,t.time+E[t.now][i].cost/(double)t.speed,t.now));\n\t\t\t\t}\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed+1)\n\t\t\t\t\tQ.push(Node(to,t.speed+1,t.time+E[t.now][i].cost/(double)(t.speed+1.0),t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed-1 && t.speed-1>=1)\n\t\t\t\t\tQ.push(Node(to,t.speed-1,t.time+E[t.now][i].cost/(double)(t.speed-1.0),t.now));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\"<<endl;\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\nconst double inf = (double)(1<<24);\n\nclass Node {\npublic:\n    double time;\n    int v, town, prev;\n    Node() {}\n    Node( double time_, int v_, int town_, int prev_ ) \n    {\n        time = time_;\n        v = v_;\n        town = town_;\n        prev = prev_;\n    }\n    bool operator > ( const Node& right ) const \n    {\n        return fabs( time - right.time ) < eps ? v > right.v : time < right.time;\n    }\n    bool operator < ( const Node& right ) const\n    {\n        return fabs( time - right.time ) < eps ? v < right.v : time > right.time;\n    }\n};\ntypedef priority_queue <Node> QUEUE;\nconst int size = 31;\n\nint n, m;\nbool P[size][size];\ndouble G[size][size];\ndouble MC[size][size];\nint L[size][size];\nint CN[size][size];\nint CN_count[size];\n\nvoid solve( int start, int goal )\n{\n    double answer = inf;\n    bool flag = true;\n\n    QUEUE Q;\n    Node start_node( 0.0, 1, start, -1 );\n    Q.push( start_node );\n    MC[1][start] = 0.0;\n\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        double time = node.time;\n        int v = node.v;\n        int town = node.town;\n        int prev = node.prev;\n\n        if ( town == goal && v == 1 ) {\n            answer = min( answer, time );\n            flag = false;\n        }\n\n        for ( int i = 0; i < CN_count[town]; i++ ) {\n            int next_town = CN[town][i];\n            if ( next_town == prev ) continue;\n            for ( int j = 1; j >= -1; j-- ) {\n                if ( prev == -1 && j != 0 ) continue;\n                int next_v = v + j;\n                if ( next_v <= 0 || next_v > L[town][next_town] ) continue;\n                double cost = (double)G[town][next_town] / next_v;\n                double next_time = time + cost;\n                int next_prev = town;\n\n                if ( next_time > MC[next_v][next_town] || fabs( next_time - MC[next_v][next_town] ) < eps ) continue;\n                MC[next_v][next_town] = next_time;\n                Node next_node( next_time, next_v, next_town, next_prev );\n                Q.push( next_node );\n            }\n        }\n    }\n\n    if ( flag ) cout << \"unreachable\" << endl;\n    else printf( \"%.5f\\n\", answer );\n}\n\nint main( void )\n{\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        // init\n        for ( int i = 0; i < size; i++ ) {\n            CN_count[i] = 0;\n            for ( int j = 0; j < size; j++ ) {\n                P[i][j] = false;\n                MC[i][j] = inf;\n                G[i][j] = inf;\n                L[i][j] = 0;\n            }\n        }\n\n        // input\n        int s, g;\n        cin >> s >> g;\n        for ( int i = 0; i < m; i++ ) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n\n            P[x][y] = P[y][x] = true;\n            G[x][y] = G[y][x] = d;\n            L[x][y] = L[y][x] = c;\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( i == j ) continue;\n                if ( P[i][j] ) CN[i][CN_count[i]++] = j;\n            }\n        }\n\n        solve( s-1, g-1 );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nstringstream __ss__;\n#define debug __ss__\n#endif\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) debug << *i << \" \"; debug << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;i--)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);i--)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint x[900],y[900],d[900],c[900];\ndouble mn[40][40];\n\nint main() {\n\tint n,m,s,g;\n\tIL{\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)break;\n\t\tcin>>s>>g;\n\t\trep(i,m){\n\t\t\tcin>>x[i]>>y[i]>>d[i]>>c[i];\n\t\t}\n\t\trep(i,40)rep(j,40)mn[i][j]=1000000000;\n\t\tpriority_queue<pair<double,pint>,vector<pair<double,pint> >,greater<pair<double,pint> > > que;\n\t\tque.push(MP(0,MP(s,1)));\n\t\twhile(!que.empty()){\n\t\t\tpair<double,pint> now=que.top();\n\t\t\tpair<double,pint> next;\n\t\t\tque.pop();\n\t\t\tif(mn[now.second.first][now.second.second]<=now.first)continue;\n\t\t\tmn[now.second.first][now.second.second]=now.first;\n\t\t\trep(i,m){\n\t\t\t\tif(x[i]==now.second.first){\n\t\t\t\t\tif(now.second.second>c[i])continue;\n\t\t\t\t\tnext.second.first=y[i];\n\t\t\t\t\tnext.first=now.first+(double)d[i]/(now.second.second);\n\t\t\t\t\tnext.second.second=now.second.second;\n\t\t\t\t\tque.push(next);\n\t\t\t\t\tnext.second.second=now.second.second+1;\n\t\t\t\t\tque.push(next);\n\t\t\t\t\tif(now.second.second==1){\n\t\t\t\t\t\tif(y[i]==g){\n\t\t\t\t\t\t\tprintf(\"%.12lf\\n\",next.first);\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnext.second.second=now.second.second-1;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t\tif(y[i]==now.second.first){\n\t\t\t\t\tif(now.second.second>c[i])continue;\n\t\t\t\t\tnext.second.first=x[i];\n\t\t\t\t\tnext.first=now.first+(double)d[i]/(now.second.second);\n\t\t\t\t\tnext.second.second=now.second.second;\n\t\t\t\t\tque.push(next);\n\t\t\t\t\tnext.second.second=now.second.second+1;\n\t\t\t\t\tque.push(next);\n\t\t\t\t\tif(now.second.second==1){\n\t\t\t\t\t\tif(x[i]==g){\n\t\t\t\t\t\t\tprintf(\"%.12lf\\n\",next.first);\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnext.second.second=now.second.second-1;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<\"unreachable\"<<endl;\n\t\tcontinue;\n\t\tend:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\n#define INF 1e9\nusing namespace std;\n\nclass DP{\npublic:\n\tdouble cost;\n\tunsigned char cur, sp, prev;\n\t\n\tDP(){}\n\tDP(double c, int cu, int s, int pr){\n\t\tcost = c;cur=cu;sp=s;prev=pr;\n\t}\n\t\n\tbool operator< (const DP &opp) const {\n\t\treturn cost>opp.cost;\n\t}\n};\nint n,m,s,go;\n\npriority_queue<DP> dp;\nchar visit[31][31][31];\nint g[31][31];\nint lim[31][31];\n\nmain(){\n\tint i,j,d,c,x,y;\n\twhile(cin>>n>>m,n){\n\t\tmemset(g, 0, sizeof(g));\n\t\tmemset(visit, 0, sizeof(visit));\n\t\twhile(!dp.empty()) dp.pop();\n\t\tcin>>s>>go;\n\t\t\n\t\tfor(i=1;i<=m;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tg[x][y]=g[y][x]=d;\n\t\t\tlim[x][y]=lim[y][x] = c;\n\t\t}\n\t\n\t\tDP T,S;\n\t\tdp.push(DP(0,1,0,0));\n\t\twhile(!dp.empty()){\n\t\t\tS = dp.top();\n\t\t\tdp.pop();\n//\t\t\tprintf(\"dp %.5lf, [%d][%d] from %d\\n\", S.cost, S.cur, S.sp, S.prev);\n\t\t\tif(S.cur == go && S.sp == 1) break;\n\t\t\tfor(i=1;i<=n;i++){\n//\t\t\t\tprintf(\"g[%d][%d]\\n\", t, i);\n\t\t\t\tif(!g[S.cur][i]) continue;\n\t\t\t\tfor(j=S.sp-1;j<=S.sp+1;j++){\n\t\t\t\t\tif(lim[S.cur][i] < j || j < 1 || i == S.prev || visit[i][j][S.cur]) continue;\n\t\t\t\t\tT.cost = S.cost + g[S.cur][i] / (double)j;\n\t\t\t\t\tT.cur = i;\n\t\t\t\t\tT.sp = j;\n\t\t\t\t\tT.prev = S.cur;\n//\t\t\t\t\tprintf(\"ps %.5lf, [%d][%d] from %d\\n\", T.cost, T.cur, T.sp, T.prev);\n\t\t\t\t\tdp.push(T);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvisit[S.cur][S.sp][S.prev] = 1;\n\t\t}\n\t\tif(S.cur == go && S.sp == 1) printf(\"%.5lf\\n\", S.cost);\n\t\telse cout << \"unreachable\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <cstdio>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dy[] = {1, 0, -1, 1, -1, 1, 0, -1};\n\nstruct edge{\n\tint to;\n\tdouble dist;\n\tint c;\n\tedge(int t, double d, int c_){to = t, dist = d, c = c_;}\n};\n\nstruct state{\n\tint pos;\n\tdouble total;\n\tint speed;\n\tint prev;\n\tstate(int p, double t, int s, int pr){pos = p, total = t, speed = s, prev = pr;}\n\tbool operator<(const state &r)const{\n\t\treturn total > r.total;\n\t}\n};\n\nconst double INF = 1e30;\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\ts--, g--;\n\t\tvector<vector<edge> > G(n);\n\t\trep(i, m){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--, y--;\n\t\t\tG[x].push_back(edge(y, d, c));\n\t\t\tG[y].push_back(edge(x, d, c));\n\t\t}\n\n\t\tpriority_queue<state> q;\n\t\tq.push(state(s, 0, 0, 0));\n\n\t\tvector<vector<vi> > visit(31, vector<vi>(n, vi(n, 0))); //speed, pos, prev\n\n\t\tdouble ans = INF;\n\t\twhile(!q.empty()){\n\t\t\tstate st = q.top();\n\t\t\tq.pop();\n\n\t\t\tif(visit[st.speed][st.pos][st.prev]) continue;\n\t\t\tvisit[st.speed][st.pos][st.prev] = 1;\n\n\t\t\tif(st.speed == 1 && st.pos == g){\n\t\t\t\tans = st.total;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, G[st.pos].size()){\n\t\t\t\tif(st.prev == G[st.pos][i].to) continue;\n\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\tstate next = st;\n\t\t\t\t\tnext.speed += j;\n\t\t\t\t\tif(next.speed <= 0 || next.speed > G[st.pos][i].c) continue;\n\t\t\t\t\tnext.pos = G[st.pos][i].to;\n\t\t\t\t\tnext.prev = st.pos;\n\t\t\t\t\tnext.total += G[st.pos][i].dist/next.speed;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == INF) cout << \"unreachable\" << endl;\n\t\telse printf(\"%.8lf\\n\", ans);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-7;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\n\nstruct edge{\n\tint to;\n\tint limitSpeed;\n\tint dist;\n};\nvector<edge> G[101];\nvoid add_edge(int x,int y,int d,int c){\n\tedge e;\n\tint from=x;\n\tint to=y;\n\te.to=y;\n\te.limitSpeed=c;\n\te.dist=d;\n\tG[from].push_back(e);\n\te.to=x;\n\tG[to].push_back(e);\n}\nconst double INF=1e+10;\n\ntypedef pair<double,int> pdi;\ntypedef pair<pdi,pii> Sit;\n\ndouble d[51][51][51];\ndouble dijkstra(int s,int g,int n){\n\tfor(int i=0;i<51;i++)\n\t\tfor(int j=0;j<51;j++)\n\t\t\tfor(int k=0;k<51;k++)\n\t\t\t\td[i][j][k]=INF;\n\tpriority_queue<Sit> pq;\n\tpq.push(make_pair(pdi(0,0),pii(s,1)));\n\td[0][s][1]=0;\n\twhile(pq.size()){\n\t\tSit p=pq.top();pq.pop();\n\t\tdouble ccost=p.first.first;\n\t\tint prvNode=p.first.second;\n\t\tint curNode=p.second.first;\n\t\tint curSpeed=p.second.second;\n\t\tif(!EQ(d[prvNode][curNode][curSpeed],ccost)&&d[prvNode][curNode][curSpeed]<ccost)continue;\n\t\tfor(int j=0;j<G[curNode].size();j++){\n\t\t\tedge &e=G[curNode][j];\n\t\t\tint toNode=e.to;\n\t\t\tif(toNode==prvNode)\n\t\t\t\tcontinue;\n\t\t\tint limitSpeed=e.limitSpeed;\n\t\t\tint dist=e.dist;\n\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\tif(prvNode==0&&i!=0)continue;\n\t\t\t\tint nxtSpeed=curSpeed+i;\n\t\t\t\tif(nxtSpeed==0||nxtSpeed>limitSpeed)continue;\n\t\t\t\tdouble ncost=ccost+1.0*dist/nxtSpeed;\n\t\t\t\tif(!EQ(ncost,d[curNode][toNode][nxtSpeed])&&ncost<d[curNode][toNode][nxtSpeed]){\n\t\t\t\t\td[curNode][toNode][nxtSpeed]=ncost;\n\t\t\t\t\tpq.push(make_pair(pdi(ncost,curNode),pii(toNode,nxtSpeed)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble res=INF;\n\tfor(int i=1;i<=n;i++)\n\t\tres=min(res,d[i][g][1]);\n\treturn res;\n}\n\nvoid solve(){\n\tint n,m,s,g;\n\twhile(cin>>n>>m&&(n|m)){\n\t\tcin>>s>>g;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tadd_edge(x,y,d,c);\n\t\t}\n\t\tdouble res=dijkstra(s,g,n);\n\t\tif(EQ(res,INF))cout<<\"unreachable\"<<endl;\n\t\telse printf(\"%.10f\\n\",res);\n\t\tfor(int i=0;i<101;i++)G[i].clear();\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 92 // いつもは1<<29だが小さくすれば時間はやくなる？\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[40];    \n    \n    int inx,iny,ind,inc;\n    double d[40][40][40];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n \nusing namespace std;\n \n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF 1e11\nconst int MAX_SPEED = 30;\n\nstruct P {\n    int city, pcity;\n    int speed;\n    float time;\n\n    bool operator >(const P& p) const {\n        return time > p.time;\n    }\n};\n\nstruct edge{\n    int to, dist, limit;\n};\n\ntypedef vector<float> vf;\ntypedef vector<vf> vvf;\ntypedef vector<vvf> vvvf;\n\nint main() {\n    int city_n, road_n, start, goal;\n\n    while(cin >> city_n >> road_n, city_n | road_n){\n        cin >> start >> goal;\n\n        vector<vector<edge>> E(city_n + 1);\n\n        REP(i, road_n){\n            int x, y, d, l;\n            cin >> x >> y >> d >> l;\n            E[x].push_back({y, d, l});\n            E[y].push_back({x, d, l});\n        }\n        vvvf G(city_n + 1, vvf(city_n + 1, vf(MAX_SPEED + 1, INF)));\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({start, start, 0, 0.0});\n\n        float res = -1;\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n\n            if(p.city == goal && p.speed == 1){\n                res = p.time;\n                break;\n            }\n\n            for(auto e : E[p.city]) {\n                if(e.to == p.pcity) continue;\n                FOR(d, -1, 1 + 1){\n                    int next_speed = p.speed + d;\n                    if (next_speed == 0) continue;\n                    float next_time = p.time + (float)e.dist / next_speed;\n                    if (0 < next_speed && next_speed <= e.limit &&\n                        G[e.to][p.city][next_speed] > next_time) {\n                        G[e.to][p.city][next_speed] = next_time;\n                        que.push({e.to, p.city, next_speed, next_time});\n                    }\n                }\n            }\n        }\n\n        if(res == -1)\n            cout << \"unreachable\" << endl;\n        else\n            printf(\"%f\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong double memo[1000][32];\nstruct edge {\n\tint id;\n\tint from;\n\tint to;\n\tint lim;\n\tlong double dis;\n};\nstruct aa {\n\tint id;\n\tint speed;\n\tlong double  time;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nint main() {\n\tcout << fixed << setprecision(22);\n\twhile (1) {\n\t\tmemset(memo, 9999999, sizeof(memo));\n\t\tint n, m; cin >> n >> m;\n\t\tif (!n)break;\n\t\tint s, g; cin >> s >> g; s--; g--;\n\t\tvector<edge>edges;\n\t\tvector<vector<int>>edgeids(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tlong double d;\n\t\t\tint x, y, c; cin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tedges.push_back(edge{ 2*i,x,y,c,d });\n\t\t\tedges.push_back(edge{ 2*i+1,y,x,c,d });\n\t\t\tedgeids[x].push_back(2 * i);\n\t\t\tedgeids[y].push_back(2 * i + 1);\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tfor (auto i : edgeids[s]) {\n\n\t\t\tque.push(aa{ i,1,edges[i].dis });\n\t\t\tmemo[i][1] = edges[i].dis;\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst edge oldedge(edges[atop.id]);\n\t\t\tconst int oldsp(atop.speed);\n\t\t\tconst long double oldtime(atop.time);\n\t\t\tfor (auto i : edgeids[oldedge.to]) {\n\t\t\t\tconst edge nextedge(edges[i]);\n\t\t\t\tif (nextedge.to == oldedge.from)continue;\n\t\t\t\telse {\n\t\t\t\t\tfor (int change = -1; change <= 1; ++change) {\n\t\t\t\t\t\tconst int nextsp = oldsp + change;\n\t\t\t\t\t\tif (nextsp == 0)continue;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (nextsp <= nextedge.lim) {\n\t\t\t\t\t\t\t\tconst long double nexttime= nextedge.dis / nextsp + oldtime;\n\t\t\t\t\t\t\t\tif (memo[i][nextsp] > nexttime) {\n\t\t\t\t\t\t\t\t\tmemo[i][nextsp] = nexttime;\n\t\t\t\t\t\t\t\t\tque.push(aa{ i,nextsp,nexttime });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong double amin = 999999999;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tif (edges[i].to == g) {\n\t\t\t\tamin = min(amin, memo[i][1]);\n\t\t\t}\n\t\t}\n\t\tif (amin > 99999999) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << amin << endl;\n\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n\n/* ----- Type Alias ----- */\nusing Bool = bool;\nusing Int = long long int;\nusing Real = long double;\nusing Char = char;\nusing String = std::string;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\n\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing Matrix = Vector<Vector<T>>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\ntemplate <class T>\nusing Deque = std::deque<T>;\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class T, class... Us>\nusing Func = std::function<T(Us...)>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\nstruct Edge {\n    Int src, dst;\n    Real len;\n    Int cap;\n    Edge(Int src = -1, Int dst = -1, Real len = -1, Int cap = -1)\n        : src(src), dst(dst), len(len), cap(cap){};\n};\n\nusing Graph = Vector<Vector<Edge>>;\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\n// constexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\n// constexpr Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nconstexpr Real INF = std::numeric_limits<Real>::max() / 10;\nconstexpr Int C = 30;\n\nBool solve() {\n    Int n, m;\n    std::cin >> n >> m;\n    if (n == 0) return false;\n\n    Int s, g;\n    std::cin >> s >> g;\n    --s, --g;\n\n    Graph graph(n);\n    for (Int i = 0; i < m; ++i) {\n        Int u, v, l, c;\n        std::cin >> u >> v >> l >> c;\n        --u, --v;\n        graph[u].emplace_back(u, v, l, c);\n        graph[v].emplace_back(v, u, l, c);\n    }\n\n    auto dp = genv<Real>(n, n, C + 1, INF);\n    dp[s][s][0] = 0;\n    MinHeap<Tuple<Real, Int, Int, Int>> heap;\n    heap.emplace(0, s, s, 0);\n\n    while (!heap.empty()) {\n        Real d;\n        Int v, p, s;\n        std::tie(d, v, p, s) = heap.top();\n        heap.pop();\n        if (d > dp[v][p][s]) continue;\n\n        for (Int ss = s - 1; ss <= s + 1; ++ss) {\n            if (ss <= 0) continue;\n\n            for (auto e : graph[v]) {\n                if (e.dst == p || e.cap < ss) continue;\n\n                Real dt = e.len / ss;\n                if (dp[e.dst][e.src][ss] > d + dt) {\n                    dp[e.dst][e.src][ss] = d + dt;\n                    heap.emplace(dp[e.dst][e.src][ss], e.dst, e.src, ss);\n                }\n            }\n        }\n    }\n\n    Real ans = INF;\n    for (Int v = 0; v < n; ++v) {\n        ans = std::min(ans, dp[g][v][1]);\n    }\n\n    if (ans == INF) {\n        std::cout << \"unreachable\" << std::endl;\n    } else {\n        std::cout << Fout(12) << ans << std::endl;\n    }\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> P;\nstruct edge{int to;double cost;};\n\nint n,m,s,go;\ndouble d[27002];\nvector<edge> g[27002];\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > q;\n\tfill(d,d+27002,INF);\n\td[s]=0;\n\tq.push(P(0,s));\n\twhile(!q.empty()){\n\t\tP p=q.top();q.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\trep(i,g[v].size()){\n\t\t\tedge e=g[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>m&&n){\n\t\trep(i,27002)g[i].clear();\n\t\tcin>>s>>go;s--;go--;\n\t\tedge e;\n\t\trep(i,n){\n\t\t\te.to=1;\n\t\t\te.cost=0;\n\t\t\tg[i*n+go+2].push_back(e);\n\t\t}\n\t\trep(i,m){\n\t\t\tint x,y,c;\n\t\t\tdouble dd;\n\t\t\tcin>>x>>y>>dd>>c;\n\t\t\tx--;y--;\n\t\t\trep(v,c+2)rep(p,n){\n\t\t\t\tif(v==31)break;\n\t\t\t\tif(v==0){\n\t\t\t\t\tif(x==s){\n\t\t\t\t\t\te.to=x*n+y+2;\n\t\t\t\t\t\te.cost=dd;\n\t\t\t\t\t\tg[0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\tif(y==s){\n\t\t\t\t\t\te.to=y*n+x+2;\n\t\t\t\t\t\te.cost=dd;\n\t\t\t\t\t\tg[0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int j=-1;j<2;j++){\n\t\t\t\t\t\tif(v+j>0&&v+j<=c&&p!=x&&p!=y){\n\t\t\t\t\t\t\te.to=(v+j-1)*n*n+x*n+y+2;\n\t\t\t\t\t\t\te.cost=dd/(v+j);\n\t\t\t\t\t\t\tg[(v-1)*n*n+p*n+x+2].push_back(e);\n\t\t\t\t\t\t\te.to=(v+j-1)*n*n+y*n+x+2;\n\t\t\t\t\t\t\tg[(v-1)*n*n+p*n+y+2].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(0);\n\t\tif(d[1]<INF)cout<<d[1]<<endl;\n\t\telse cout<<\"unreachable\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\n\nusing Real = double;\n\nvector<Real> dijkstra(int start, vector<vector<pair<int, Real>>>& graph) {\n\tvector<Real> dist(graph.size(), INF); dist[start] = 0;\n\tpriority_queue<pair<Real, int>, vector<pair<Real, int>>, greater<pair<Real, int>>> pq; pq.emplace(0, start);\n\twhile (!pq.empty()) {\n\t\tReal cost; int idx; tie(cost, idx) = pq.top(); pq.pop();\n\t\tif (dist[idx] < cost) continue;\n\t\tfor (auto next : graph[idx]) if (chmin(dist[next.first], cost + next.second)) pq.emplace(dist[next.first], next.first);\n\t}\n\treturn dist;\n}\n\nint n;\n\nint cnv(int cur, int pre, int v) {\n\treturn v + pre * 31 + cur * n * 31;\n}\n\nvoid solve() {\n\tint m; cin >> n >> m; if (n == 0 and m == 0) exit(0);\n\tint s, t; cin >> s >> t; s--; t--;\n\tvector<vector<pair<int, Real>>> g(n * n * 35);\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, c; Real d;\n\t\tcin >> u >> v >> d >> c;\n\t\tu--; v--;\n\t\tfor (int j = 0; j <= 30; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (j > 0 and j <= c and v != k) g[cnv(u, k, j)].emplace_back(cnv(v, u, j), d / j);\n\t\t\t\tif (j > 0 and j <= c and u != k) g[cnv(v, k, j)].emplace_back(cnv(u, v, j), d / j);\n\t\t\t\tif (j > 1 and j - 1 <= c) {\n\t\t\t\t\tif (k != v) g[cnv(u, k, j)].emplace_back(cnv(v, u, j - 1), d / (j - 1));\n\t\t\t\t\tif (k != u) g[cnv(v, k, j)].emplace_back(cnv(u, v, j - 1), d / (j - 1));\n\t\t\t\t}\n\t\t\t\tif (j + 1 <= c) {\n\t\t\t\t\tif (k != v) g[cnv(u, k, j)].emplace_back(cnv(v, u, j + 1), d / (j + 1));\n\t\t\t\t\tif (k != u) g[cnv(v, k, j)].emplace_back(cnv(u, v, j + 1), d / (j + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tauto d = dijkstra(cnv(s, s, 0), g);\n\tReal res = 1e18;\n\tfor (int k = 0; k < n; k++) chmin(res, d[cnv(t, k, 1)]);\n\tif (res > 1e15) cout << \"unreachable\" << \"\\n\";\n\telse cout << fixed << setprecision(12) << res << \"\\n\";\n}\n\nint main()\n{\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint kkt = 89; while (kkt) solve();\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> P;\nstruct edge{int to;double cost;};\n\nint n,m,s,go;\ndouble d[27002];\nvector<edge> g[27002];\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > q;\n\tfill(d,d+27002,INF);\n\td[s]=0;\n\tq.push(P(0,s));\n\twhile(!q.empty()){\n\t\tP p=q.top();q.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tif(v==1)break;\n\t\trep(i,g[v].size()){\n\t\t\tedge e=g[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>m&&n){\n\t\trep(i,27002)g[i].clear();\n\t\tcin>>s>>go;s--;go--;\n\t\tedge e;\n\t\trep(i,n){\n\t\t\te.to=1;\n\t\t\te.cost=0;\n\t\t\tg[i*n+go+2].push_back(e);\n\t\t}\n\t\trep(i,m){\n\t\t\tint x,y,c;\n\t\t\tdouble dd;\n\t\t\tcin>>x>>y>>dd>>c;\n\t\t\tx--;y--;\n\t\t\trep(v,c+2)rep(p,n){\n\t\t\t\tif(v==31)break;\n\t\t\t\tif(v==0){\n\t\t\t\t\tif(x==s){\n\t\t\t\t\t\te.to=x*n+y+2;\n\t\t\t\t\t\te.cost=dd;\n\t\t\t\t\t\tg[0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\tif(y==s){\n\t\t\t\t\t\te.to=y*n+x+2;\n\t\t\t\t\t\te.cost=dd;\n\t\t\t\t\t\tg[0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int j=-1;j<2;j++){\n\t\t\t\t\t\tif(v+j>0&&v+j<=c&&p!=x&&p!=y){\n\t\t\t\t\t\t\te.to=(v+j-1)*n*n+x*n+y+2;\n\t\t\t\t\t\t\te.cost=dd/(v+j);\n\t\t\t\t\t\t\tg[(v-1)*n*n+p*n+x+2].push_back(e);\n\t\t\t\t\t\t\te.to=(v+j-1)*n*n+y*n+x+2;\n\t\t\t\t\t\t\tg[(v-1)*n*n+p*n+y+2].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(0);\n\t\tif(d[1]<INF)cout<<d[1]<<endl;\n\t\telse cout<<\"unreachable\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct S{\n  double t;\n  int v;\n  int p;\n  int from;\n  S(){}\n  S(double t, int v, int p,int from) :\n    t(t), v(v), p(p),from(from) {}\n};\nstruct edge{\n  int to, dist, lim;\n  edge(int to, int dist, int lim) :\n    to(to), dist(dist), lim(lim) {}\n};\ntypedef vector<edge> edges;\nbool operator < (const S& s, const S& t){\n  return s.t > t.t;\n}\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m>>s>>g, n){\n    s--; g--;\n    vector<edges> graph(n);\n    REP(i,m){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c; x--; y--;\n      graph[x].push_back(edge(y, d, c));\n      graph[y].push_back(edge(x, d, c));\n    }\n    priority_queue<S> que;\n    FORIT(it, graph[s]){\n      que.push(S(it->dist, 1, it->to, s));\n    }\n    bool used[40][40][40] = {};\n    double ans = -1;\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      //printf(\"quesize:%d time:%lf speed:%d point:%d\\n\",que.size(), s.t,s.v,s.p);\n      if(s.p == g && s.v == 1){\n        ans = s.t;\n        break;\n      }\n      if(used[s.v][s.p][s.from]) continue;\n      used[s.v][s.p][s.from] = true;\n      for(int nv = s.v - 1; nv <= s.v + 1; nv++)if(nv > 0){\n        FORIT(it, graph[s.p])if(it->lim >= nv && it->to != s.from){\n          que.push(S(s.t + (double)it->dist/nv, nv, it->to, s.p));\n        }\n      }\n    }\n    if(ans != -1) printf(\"%.4lf\\n\",ans);\n    else cout<<\"unreachable\"<<endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n#define N 30\n#define INF 100000\nstruct road{int to,cost,lim;};\n\nstruct situ{int v,now,from;double d;};\nbool operator < (const situ &a,const situ &b){\n\treturn a.d > b.d;\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m,s,g;\n\t\tvector<road> roads[N];\n\t\tcin >> n >> m;\n\t\tif(!n&&!m) break;\n\t\tcin >> s >> g;\n\t\ts--;g--;\n\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,d,c;\n\t\t\tscanf(\"%d%d%d%d\",&x,&y,&d,&c);\n\t\t\tx--;y--;\n\t\t\troads[x].push_back((road){y,d,c});\n\t\t\troads[y].push_back((road){x,d,c});\n\t\t}\n\t\n\t\tpriority_queue<situ> que;\n\t\tfor(int i=0;i<roads[s].size();i++){\n\t\t\tint to = roads[s][i].to;\n\t\t\tint d = roads[s][i].cost;\n\t\t\tque.push((situ){1,to,s,(double)d});\n\t\t}\n\t\tdouble dist[N][N][31];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=1;k<31;k++){\n\t\t\t\t\tdist[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool isClear = false;\n\t\twhile(que.size()){\n\t\t\tsitu st = que.top(); que.pop();\n\t\t\tif(dist[st.now][st.from][st.v]<st.d) continue;\n\t\t\tdist[st.now][st.from][st.v] = st.d;\n\t\t\tif(st.now==g&&st.v==1){\n\t\t\t\tprintf(\"%.5f\\n\",st.d);\n\t\t\t\tisClear = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<roads[st.now].size();i++){\n\t\t\t\tint to = roads[st.now][i].to;\n\t\t\t\tint d = roads[st.now][i].cost;\n\t\t\t\tif(to != st.from){\n\t\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\tif(st.v+j<=roads[st.now][i].lim&&st.v+j>0){\n\t\t\t\t\t\t\tif(dist[to][st.now][st.v+j]>st.d+(double)d/(st.v+j)){\n\t\t\t\t\t\t\t\tque.push((situ){st.v+j,to,st.now,st.d+(double)d/(st.v+j)});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!isClear) cout << \"unreachable\" << endl;\n\t\t\n\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 91 // いつもは1<<29だが小さくすれば時間はやくなる？\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <functional>\n#include <cstring>\n#include <utility>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nstruct edge {\n  int dist, limit;\n};\n\nstruct state {\n  double cost;\n  int to, v;\n  state(double d, int a, int b):cost(d),to(a),v(b){}\n  bool operator<(const state& a) const {\n    return cost < a.cost;\n  }\n  bool operator>(const state& a) const {\n    return cost > a.cost;\n  }\n};\n\nconst int INF = 100000000, MAX_N = 31, MAX_V = 31;\nint n, m;\nedge e[1000];\nint graph[MAX_N][MAX_N];\n\nvoid solve() {\n  memset(graph, -1, sizeof graph);\n  int s, g; cin>>s>>g;\n  rep(i,m) {\n    int x, y, d, c; cin>>x>>y>>d>>c;\n    e[i].dist = d;\n    e[i].limit = c;\n    graph[x][y] = i;\n    graph[y][x] = i;\n  }\n  \n  /*\n  REP(i,1,n+1) {\n    REP(j,1,n+1) printf(\"%2d\",graph[i][j]);\n    cout<<endl;\n  }*/\n  \n  double d[MAX_N][MAX_V];\n  rep(i,MAX_N) rep(j,MAX_V) d[i][j] = INF;\n  d[s][1] = 0;\n  priority_queue<state, vector<state>, greater<state> > que;\n  que.push(state(0,s,1));\n  \n  while (!que.empty()) {\n    state si = que.top(); que.pop();\n    double cost = si.cost;\n    int v = si.v, to = si.to;\n    //cout<<to<<\"|\"<<v<<\"|\"<<cost<<endl;\n    if (cost > d[to][v]) continue;\n        \n    REP(i,1,n+1) if (graph[to][i] != -1) {\n      //cout<<\"edge!\"<<i<<endl;\n      int en = graph[to][i];\n      REP(j,-1,2) {\n        if (to == s && v+j != 1) continue;\n        if (i == g && v+j != 1) continue;\n        if (v+j < 0 || v+j >= MAX_V) continue;\n        if (v+j > e[en].limit) continue;\n        double ne = cost + (double)e[en].dist / (double)(v+j);\n        if (d[i][v+j] > ne) {\n          d[i][v+j] = ne;\n          que.push(state(ne, i, v+j));\n        }\n      }\n    }\n  }\n  \n  if (d[g][1] == INF) {\n    cout<<\"unreachable\"<<endl;\n  } else {\n    printf(\"%.5lf\\n\", d[g][1]);\n  }\n  //cout<<d[g][1]<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>n>>m, n||m) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i,a) for(int i=0;i<a;i++)\n\nint n, m;\nint s, g;\n\nstruct edge\n{\n    int to, d, c;\n\n    edge() {}\n    edge(int to, int d, int c) \n        : to(to), d(d), c(c) {}\n};\n\nvector<vector<edge> > E;\n\nstruct node\n{\n    double cost;\n    int prev, v, speed;\n\n    node() {}\n    node(double cost, int prev, int v, int speed)\n        : cost(cost), prev(prev), v(v), speed(speed) {}\n    bool operator <(const node& t) const {\n        return cost > t.cost;\n    }\n};\n\ndouble mem[32][32][32];\n\nvoid solve()\n{\n    rep(i,32)rep(j,32)rep(k,32)mem[i][j][k]=1e9;\n\n    priority_queue<node> q;\n    q.push(node(0.0, n, 0, 0));\n    while (!q.empty()) {\n        double cost = q.top().cost;\n        int prev = q.top().prev;\n        int v = q.top().v;\n        int speed = q.top().speed;\n        q.pop();\n\n        // cerr<<cost<<' '<<prev<<' '<<v<<' '<<speed<<endl;\n\n        if (mem[prev][v][speed] <= cost)\n            continue;\n        if (v == g && speed == 1) {\n            printf(\"%.8f\\n\", cost);\n            return;\n        }\n            \n\n        mem[prev][v][speed] = cost;\n\n        rep(i, E[v].size()) {\n            if (E[v][i].to == prev)\n                continue;\n            for (int ns = speed - 1; ns <= speed + 1; ++ns) {\n                if (ns > 0 && ns <= E[v][i].c) {\n                    q.push(node(cost + (double) E[v][i].d / ns, v, E[v][i].to, ns));\n                }\n            }\n        }\n    }\n    cout << \"unreachable\" << endl;\n}\n\nint main()\n{\n    while (cin >> n >> m && n) {\n        cin >> s >> g;\n        --s, --g;\n        E.clear();\n        E.resize(n);\n        rep(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            --x, --y;\n            E[x].push_back(edge(y, d, c));\n            E[y].push_back(edge(x, d, c));\n        }\n\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 30\n#define V 31\n#define INF 10000\nint G[N][N];\nint C[N][N];\nint n, m, s, g;\n\ndouble dijkstra(){\n    double d[N][N][V]; // [現在の都市][前の都市][現在の都市にいるときの速さ]\n    bool used[N][N][V];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < V; k++) {\n                d[i][j][k] = INF;\n                used[i][j][k] = false;\n            }\n        }\n    }\n    d[s][s][0] = 0;\n    \n    while (true) {\n        int now, prev, v = -1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < V; k++) {\n                    if (!used[i][j][k] && (v == -1 || d[i][j][k] < d[now][prev][v])) {\n                        now = i; prev = j; v = k;\n                    }\n                }\n            }\n        }\n        if (v == -1) {\n            break;\n        }\n        used[now][prev][v] = true;\n        \n        for (int u = 0; u < n; u++) {\n            if (u == prev) {\n                continue;\n            }\n            if (G[now][u] == INF) {\n                continue;\n            }\n            for (int dv = -1; dv <= 1; dv++) {\n                int mv = v + dv;\n                if (mv < 1 || mv > C[now][u]) {\n                    continue;\n                }\n                d[u][now][mv] = min(d[u][now][mv], d[now][prev][v] + (double)G[now][u] / mv);\n            }\n        }\n    }\n\n    double ans = INF;\n    for (int i = 0; i < n; i++) {\n        ans = min(ans, d[g][i][1]);\n    }\n    return ans;\n}\n\nint main()\n{\n    int x, y, d, c;\n    while (true) {\n        cin >> n >> m;\n        if (n == 0 && m == 0) {\n            break;\n        }\n        cin >> s >> g;\n        s--; g--;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                G[i][j] = INF;\n                C[i][j] = 0;\n            }\n        }\n        \n        for (int i = 0; i < m; i++) {\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            G[y][x] = G[x][y] = d;\n            C[y][x] = C[x][y] = c;\n        }\n        double ans = dijkstra();\n        if (ans == INF) {\n            cout << \"unreachable\" << endl;\n        }\n        else {\n            cout << ans << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 100 // いつもは1<<29だが小さくすれば時間はやくなる？\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n//自身だー\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define EPS 1e-8\n \nstruct P{\n  double t;\n  char v,p,pre;\n  P(double T=0.0,int V=0,int pp=0,int PRE=0){\n    t=T;v=V;p=pp;pre=PRE;\n  };\n  bool operator<(const P &p)const{\n    return t>p.t;\n  }\n};\nstruct Path{\n  char d,c;\n  Path(int D=0,int C=0){ d=D;c=C;};\n};\n \nint main(){\n  int n,m, s,g, x,y,d,c;\n  Path path[30][30];\n  priority_queue<P> q;\n \n  while( cin>>n>>m && (n|m) ){\n    cin >> s >> g;\n    s--; g--;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tpath[i][j].d=-1.0; path[i][j].c=-1;\n      }\n \n    for( int i=0;i<m;i++ ){\n      cin >> x >> y >> d >> c;\n      x--;y--;\n      path[x][y].d=d; path[x][y].c=c;\n      path[y][x] = path[x][y];\n    }\n \n    double cost[30][35][30]; // place,velocity, pre\n    int dv[3] = {1,0,-1};\n    for( int i=0;i<n;i++ )\n      for( int j=1;j<31;j++ )\n\tfor( int k=0;k<31;k++ )\n\t  cost[i][j][k] = DBL_MAX;\n \n    while( !q.empty() ) q.pop();\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      q.push( P(path[s][i].d,1,i,s) );//t ,v, np, pre\n      cost[i][1][s] = path[s][i].d;\n    }\n\n    double ans = DBL_MAX; \n    while( !q.empty() ){\n      P p = q.top(); q.pop();\n      double t = p.t;\n      int v=p.v, np=p.p, pre=p.pre;\n      if( np==g && v==1 ){\n\tans = t;\n\tbreak;\n      }\n \n      for( int i=0;i<n;i++ ){\n\tif( path[np][i].c<0 ) continue;// たどり着けないノード\n\tif( i==pre ) continue; // 前回のノード\n\t\n\tfor( int j=0;j<3;j++ ){\n\t  int nv = v + dv[j];\n\t  if( nv==0 || nv>path[np][i].c )    continue;\n\t  double nCost = t + (double)path[np][i].d/nv;\n\t  if( nCost>cost[g][1][np] || fabs(nCost-cost[g][1][np])<EPS ) continue;\n\t  if( cost[i][nv][np] < nCost ) continue;\n\t  if( fabs(cost[i][nv][np]-nCost)<EPS ) continue;\n\t  cost[i][nv][np]=nCost;\n\t  \n\t  q.push( P(nCost,nv,i,np) );\n\t}\n      }\n      \n    }\n    if( fabs(ans-DBL_MAX)<EPS )\n      cout << \"unreachable\" << endl;\n    else\n      printf(\"%.6lf\\n\",ans);\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n\nvoid solve(int n, int m) {\n    int s,t; cin >> s >> t; --s,--t;\n    struct edge { int to,d,c; };\n    vector<vector<edge>> g(n);\n    rep (i,m) {\n        int x,y,d,c; cin >> x >> y >> d >> c; --x,--y;\n        g[x].pb({y,d,c});\n        g[y].pb({x,d,c});\n    }\n\n    using state = tuple<int,int,int>;\n    // (cur,speed,pre)\n    const int v_max = 35;\n    auto dist = make_v<double,3>(n,v_max,n+1,INF);\n    pque_min<pair<double,state>> pq;\n    dist[s][0][n] = 0;\n    pq.emplace(0,state{s,0,n});\n    while (pq.size()) {\n        auto top = pq.top(); pq.pop();\n        auto d = top.fst;\n        auto st = top.snd;\n        int x,v,p; tie(x,v,p) = st;\n        if (dist[x][v][p] < d) continue;\n        for (auto e : g[x]) {\n            int nx = e.to;\n            if (nx == p) continue;\n            for (int nv : {v-1,v,v+1}) {\n                if (nv <= 0) continue;\n                if (nv > e.c) continue;\n                double cost = double(e.d)/nv;\n                if (chmin(dist[nx][nv][x], d + cost)) {\n                    pq.emplace(d + cost, state{nx,nv,x});\n                }\n            }\n        }\n    }\n\n    double mi = INF;\n    rep (p,n) chmin(mi, dist[t][1][p]);\n    if (mi > INF/2) {\n        cout << \"unreachable\\n\";\n    } else {\n        cout << mi << \"\\n\";\n    }\n\n}\n\nint32_t main() {\n    while (true) {\n        int n,m; cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        solve(n,m);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nclass data\n{\npublic:\n    int p, q, c;\n    data(int p0, int q0, int c0){\n        p = p0;\n        q = q0;\n        c = c0;\n    }\n};\n\nvoid solve(int n, int start, int goal, vector<vector<int> > distance, vector<vector<int> > limit)\n{\n    vector<bool> easyCheck(n, false);\n    queue<int> q;\n    q.push(start);\n    while(!q.empty()){\n        int a = q.front();\n        if(!easyCheck[a]){\n            easyCheck[a] = true;\n            for(int i=0; i<n; ++i){\n                if(distance[a][i] > -1)\n                    q.push(i);\n            }\n        }\n        q.pop();\n    }\n    if(!easyCheck[goal]){\n        cout << \"unreachable\" << endl;\n        return;\n    }\n\n    vector<vector<vector<bool> > > check(n, vector<vector<bool> >(n, vector<bool>(31, false)));\n\tvector<vector<vector<double> > > time(n, vector<vector<double> >(n, vector<double>(31, DBL_MAX)));\n    for(int i=0; i<n; ++i){\n        if(distance[start][i] > -1)\n\t\t\ttime[i][start][1] = distance[start][i];\n    }\n\n    for(;;){\n\t\tint p, q, c;\n\t\tdouble minTime = DBL_MAX;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tfor(int j=0; j<n; ++j){\n\t\t\t\tfor(int k=1; k<=limit[i][j]; ++k){\n\t\t\t\t\tif(!check[i][j][k] && time[i][j][k] < minTime){\n\t\t\t\t\t\tp = i;\n\t\t\t\t\t\tq = j;\n\t\t\t\t\t\tc = k;\n\t\t\t\t\t\tminTime = time[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(p == goal && c == 1){\n\t\t\tprintf(\"%.10f\\n\", minTime);\n\t\t\treturn;\n\t\t}\n\n        check[p][q][c] = true;\n        for(int i=0; i<n; ++i){\n            if(i == p || i == q || distance[i][p] == -1)\n                continue;\n            for(int j=-1; j<=1; ++j){\n                if(1 <= c+j && c+j <= limit[p][i] && !check[i][p][c+j])\n\t\t\t\t\ttime[i][p][c+j] = min(time[i][p][c+j], minTime + distance[p][i]/static_cast<double>(c+j));\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, s, g;\n        cin >> n >> m;\n        if(n == 0 && m == 0)\n            break;\n        cin >> s >> g;\n        -- s;\n        -- g;\n\n        vector<vector<int> > distance(n, vector<int>(n, -1));\n        vector<vector<int> > limit(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int x, y;\n            cin >> x >> y;\n            -- x;\n            -- y;\n            cin >> distance[x][y] >> limit[x][y];\n            distance[y][x] = distance[x][y];\n            limit[y][x] = limit[x][y];\n        }\n\n        solve(n, s, g, distance, limit);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nstruct NODE{\n\tint from,to,speed;\n\tdouble cost;\n\tNODE(int from,int to,int speed,double cost) : from(from) , to(to) , speed(speed) , cost(cost) {\n\t}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\n\nvector< vector<NODE> > G;\nbool done[32][32][80] = {};\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m && n){\n\t\tmemset(done,0,sizeof(done));\n\t\tint s,g;\n\t\tcin >> s >> g;\n\t\ts--,g--;\n\t\tG.clear();\n\t\tG.resize(n);\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c,d;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--,b--;\t\n\t\t\tG[a].push_back(NODE(a,b,c,d));\n\t\t\tG[b].push_back(NODE(b,a,c,d));\n\t\t\t//cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n\t\t}\n\t\tpriority_queue<NODE> Q;\n\t\t\n\t\tQ.push(NODE(n,s,0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( q.speed >= 80) continue;\n\t\t\tif( done[q.from][q.to][q.speed] ) continue;\n\t\t\telse done[q.from][q.to][q.speed] = true;\n\t\t\tif( q.to == g && q.speed == 1 ){\n\t\t\t\tprintf(\"%.10lf\\n\",q.cost);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < G[q.to].size() ; i++){\n\t\t\t\tif( q.speed+0 > 0 && q.speed+0 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed+0,q.cost+G[q.to][i].cost / (q.speed+0)));\n\t\t\t\tif( q.speed+1 > 0 && q.speed+1 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed+1,q.cost+G[q.to][i].cost / (q.speed+1)));\n\t\t\t\tif( q.speed-1 > 0 && q.speed-1 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed-1,q.cost+G[q.to][i].cost / (q.speed-1)));\n\t\t\t}\n\t\t}\n\t\tcout << \"unreachable\" << endl;\n\t\texit:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000.0\nusing namespace std;\nstruct state { int n, v, l; double t; };\n\nint N, M, S, G;\nvector<int> T[101], D[101], C[101];\nint vd[3] = { -1, 0, 1 };\ndouble dp[101][101];\n\nclass Compare {\npublic:\n  bool operator() (struct state a, struct state b) {\n    return a.t > b.t;\n  }\n};\n\nint main(void) {\n  while(cin >> N >> M, N) {\n    cin >> S >> G;\n    REP(i, 0, 100) {\n      T[i].clear();\n      D[i].clear();\n      C[i].clear();\n    }\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      T[x].push_back(y); D[x].push_back(d); C[x].push_back(c);\n      T[y].push_back(x); D[y].push_back(d); C[y].push_back(c);\n    }\n\n    REP(i, 1, N) REP(j, 0, 100) dp[i][j] = INF;\n\n    priority_queue<struct state, vector<struct state>, Compare> q;\n    struct state first = { S, 0, -1, 0.0 };\n    q.push(first);\n\n    while(!q.empty()) {\n      struct state c = q.top();\n      q.pop();\n\n      // cout << c.n << \" \" << c.v << \" \" << c.t << endl;\n\n      if(dp[c.n][c.v] <= c.t) continue;\n      dp[c.n][c.v] = min(dp[c.n][c.v], c.t);\n      if(c.n == G && c.v == 1) break;\n\n      for(int i = 0; i < T[c.n].size(); i++) {\n        if(T[c.n][i] == c.l) continue;\n        for(int j = 0; j < 3; j++) {\n          int v = c.v + vd[j];\n          if(v <= 0 || C[c.n][i] < v) continue;\n          double t = c.t + ((double) D[c.n][i] / v);\n          struct state n = { T[c.n][i], v, c.n, t };\n          if(n.t < dp[n.n][n.v]) q.push(n);\n        }\n      }\n    }\n\n    if(dp[G][1] < INF) printf(\"%.6f\\n\", dp[G][1]);\n    else cout << \"unreachable\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define EPS 1e-8\n\nstruct P{\n  double t;\n  char v,p,pre;\n  P(double T=0.0,int V=0,int pp=0,int PRE=0){\n    t=T;v=V;p=pp;pre=PRE;\n  };\n  bool operator<(const P &p)const{\n    return t>p.t;\n  }\n};\nstruct Path{\n  short d,c;\n  Path(int D=0,int C=0){ d=D;c=C;};\n};\n\nint main(){\n  int n,m, s,g, x,y,d,c;\n  Path path[30][30];\n  priority_queue<P> q;\n\n  while( cin>>n>>m && (n|m) ){\n    cin >> s >> g;\n    s--; g--;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tpath[i][j].d=-1.0; path[i][j].c=-1;\n      }\n\n    for( int i=0;i<m;i++ ){\n      cin >> x >> y >> d >> c;\n      x--;y--;\n      path[x][y].d=d; path[x][y].c=c;\n      path[y][x] = path[x][y];\n    }\n\n    double cost[30][35]; // place,velocity\n    int dv[3] = {1,0,-1};\n    for( int i=0;i<n;i++ )\n      for( int j=1;j<31;j++ )\n\tcost[i][j] = DBL_MAX;\n\n    while( !q.empty() ) q.pop();\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      q.push( P(cost[i][1]=path[s][i].d,1,i,-1) );\n    }\n\n    while( !q.empty() ){\n      P p = q.top(); q.pop();\n      double t = p.t;\n      int v=p.v, np=p.p, pre=p.pre;\n      if( t>cost[g][1] ) break;\n\n      for( int i=0;i<n;i++ ){\n\tif( path[np][i].c<0 ) continue;// たどり着けないノード\n\tif( i==pre ) continue; // 前回のノード\n\n\tint j=0;\n\tif( i==g ) j=2;\n\tfor( ;j<3;j++ ){\n\t  int nv = v + dv[j];\n\t  if( nv==0 ) continue;\n\t  if( nv>path[np][i].c )    continue;\n\t  double nCost = t + (double)path[np][i].d/nv;\n\t  if( nCost>cost[g][1] )    continue;\n\t  if( fabs(nCost-cost[g][1])<EPS ) continue;\n\t  if( cost[i][nv] < nCost ) continue;\n\t  cost[i][nv]=nCost;\n\n\t  if( i==g && nv==1 ) continue;\n\t  q.push( P(nCost,nv,i,np) );\n\t}\n      }\n\n    }\n    if( fabs(cost[g][1]-DBL_MAX)<EPS )\n      cout << \"unreachable\" << endl;\n    else\n      printf(\"%.6lf\\n\",cost[g][1]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\nconst int INF = 1e9 + 10;\n\nstruct Edge {\n  int to, dist, constraint;\n \n  Edge() = default;\n  Edge(int t, int d, int c): to(t), dist(d), constraint(c) { }\n};\n\nstruct Node {\n  double cost;\n  int cur, prev, v;\n  \n  Node() = default;\n  Node(double c, int cur, int prev, int v): cost(c), cur(cur), prev(prev), v(v) { }\n\n  inline bool operator<(const Node& node) const {\n    return cost < node.cost;\n  }\n\n  inline bool operator>(const Node& node) const {\n    return cost > node.cost;\n  }\n};\n\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n + m == 0) {\n      break;\n    }\n    int s, g;\n    cin >> s >> g;\n\n    vector<Edge> G[31];\n    for (int i = 0; i < m; i++) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      G[x].push_back(Edge(y, d, c));\n      G[y].push_back(Edge(x, d, c));\n    }\n\n    double min_cost[31][31][31];\n    for (int i = 0; i < 31; i++)  {\n      for (int j = 0; j < 31; j++) {\n        for (int k = 0; k < 31; k++) {\n          min_cost[i][j][k] = INF;\n        }\n      }\n    }\n\n    priority_queue<Node, vector<Node>, greater<Node>> que;\n    min_cost[s][0][1] = 0;\n    que.push(Node(0, s, -1, 1));\n\n    double ans = INF;\n\n    while (!que.empty()) {\n      Node node = que.top(); que.pop();\n\n      if (min_cost[node.cur][node.prev][node.v] < node.cost) {\n        continue;\n      }\n\n      for (const auto& e : G[node.cur]) {\n        if (node.prev == e.to) {\n          continue;\n        }\n        double temp = e.dist / (double)(node.v);\n        if (min_cost[e.to][node.cur][node.v] > node.cost + temp) {\n          min_cost[e.to][node.cur][node.v] = node.cost + temp;\n          que.push(Node(node.cost + temp, e.to, node.cur, node.v));\n        }\n        if (node.prev != -1) {\n          if (node.v < e.constraint) {\n            temp = e.dist / (double)(node.v + 1);\n            if (min_cost[e.to][node.cur][node.v + 1] > node.cost + temp) {\n              min_cost[e.to][node.cur][node.v + 1] = node.cost + temp;\n              que.push(Node(node.cost + temp, e.to, node.cur, node.v + 1));\n            }\n          }\n          if (node.v > 1) {\n            temp = e.dist / (double)(node.v - 1);\n            if (min_cost[e.to][node.cur][node.v - 1] > node.cost + temp) {\n              min_cost[e.to][node.cur][node.v - 1] = node.cost + temp;\n              que.push(Node(node.cost + temp, e.to, node.cur, node.v - 1));\n            }\n          }\n        }\n        \n        if (e.to == g && node.v <= 2) {\n          ans = min(ans, node.cost + e.dist);\n        }\n      }\n    }\n\n\n    if (ans >= INF) {\n      cout << \"unreachable\" << endl;\n    } else {\n      printf(\"%.15f\\n\", ans);\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <iomanip>\nusing namespace std;\nconst int S_MAX = 30;\nconst double inf = 1e9;\n\nstruct info{\n    int curr;\n    int prev;\n    int v;\n    double t;\n    info(int c, int p, int v, double t):curr(c),prev(p),v(v),t(t){}\n};\nnamespace std{\n    bool operator < (const info &a, const info &b){\n        return b.t < a.t;\n    }\n}\n\nint main(){\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n==0) break;\n\n        int s,g;\n        cin >> s >> g;\n        vector<vector<vector<info> > > adj(n+1, vector<vector<info> >(S_MAX+1));\n        for(int i=0; i<m; i++){\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            for(int v=1; v<=S_MAX; v++){\n                for(int r=-1; r<=1; r++){\n                    if(v+r>0 && v+r<=c){\n                        adj[x][v].push_back(info(y, x, v+r, (double)d/(v+r)));\n                        adj[y][v].push_back(info(x, y, v+r, (double)d/(v+r)));\n                    }\n                }\n            }\n        }\n\n        priority_queue<info> pq;\n        pq.push(info(s, 0, 1, 0));\n        vector<vector<vector<double> > > mincost(n+1, vector<vector<double> >(n+1, vector<double>(S_MAX+1, inf)));\n        mincost[s][0][1] = 0;\n        while(!pq.empty()){\n            int curr = pq.top().curr;\n            int prev = pq.top().prev;\n            int v = pq.top().v;\n            double cost = pq.top().t;\n            pq.pop();\n            if(cost > mincost[curr][prev][v]) continue;\n            if(curr==g && v==1) break;\n            for(int i=0; i<(int)adj[curr][v].size(); i++){\n                info next = adj[curr][v][i];\n                if(next.curr == prev) continue;\n                if(prev == 0 && next.v != 1) continue;\n                if(cost + next.t < mincost[next.curr][next.prev][next.v]){\n                    pq.push(info(next.curr, next.prev, next.v, cost+next.t));\n                    mincost[next.curr][next.prev][next.v] = cost + next.t;\n                }\n            }\n        }\n        double ans=inf;\n        for(int i=1; i<=n; i++){\n            ans = min(ans, mincost[g][i][1]);\n        }\n        if(ans == inf){\n            cout << \"unreachable\" << endl;\n        }else{\n            cout << fixed;\n            cout << setprecision(12);\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__\",\", __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000123456789LL\n\nvoid solve(int n, int m){\n  int s,t;\n  cin>>s>>t;\n  s--;t--;\n  vector<vector<pair<int,double>>> vec(n*n*31 + 2);\n  // (f*n+v)*31 + V : ??´??????f??§v??????????????????V\n\n  rep(i,m){\n    int a,b,c; double d;\n    cin>>a>>b>>d>>c;\n    a--;b--;\n    rep(j,n)if(j!=b && j!=a){\n      rep(k,31){\n        int from = (j*n+a)*31+k;\n        if(k-1>0 && k-1<=c) vec[from].pb(mp((a*n+b)*31+k-1, d/(k-1)));\n        if(k>0 && k<=c) vec[from].pb(mp((a*n+b)*31+k, d/k));\n        if(k+1>0 && k+1<=c) vec[from].pb(mp((a*n+b)*31+k+1, d/(k+1)));\n      }\n    }\n  }\n\n  int from = n*n*31, dest = from+1;\n\n  rep(i,n) if(i!=s) vec[from].pb(mp((i*n+s)*31+0, 0));\n  rep(i,n) if(i!=t) vec[(i*n+t)*31+1].pb(mp(dest, 0));\n\n  // dijkstra\n  vector<double> d(n*n*31+2, INF);\n  d[from] = 0;\n  typedef pair<double,int> P;\n  priority_queue<P, vector<P>, greater<P>> pq;\n  pq.push(mp(0,from));\n  while(!pq.empty()){\n    auto p = pq.top(); pq.pop();\n    int v = p.second; double dis = p.first;\n    if(d[v] < dis) continue;\n    for(auto &to : vec[v]){\n      double nd = dis + to.second;\n      if(d[to.first] <= nd) continue;\n      d[to.first] = nd;\n      pq.push(mp(nd, to.first));\n    }\n  }\n  if(d[dest] == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.6f\\n\", d[dest]);\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m) solve(n,m);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 200 // いつもは1<<29だが小さくすれば時間はやくなる？\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n//自身だー\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <cstdio>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dy[] = {1, 0, -1, 1, -1, 1, 0, -1};\n\nstruct edge{\n\tint to;\n\tdouble dist;\n\tint c;\n\tedge(int t, double d, int c_){to = t, dist = d, c = c_;}\n};\n\nstruct state{\n\tint pos;\n\tdouble total;\n\tint speed;\n\tint prev;\n\tstate(int p, double t, int s, int pr){pos = p, total = t, speed = s, prev = pr;}\n\tbool operator<(const state &r)const{\n\t\treturn total > r.total;\n\t}\n};\n\nconst double INF = 1e30;\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\ts--, g--;\n\t\tvector<vector<edge> > G(n);\n\t\trep(i, m){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--, y--;\n\t\t\tG[x].push_back(edge(y, d, c));\n\t\t\tG[y].push_back(edge(x, d, c));\n\t\t}\n\n\t\tpriority_queue<state> q;\n\t\tq.push(state(s, 0, 0, s));\n\n\t\tvector<vector<vi> > visit(31, vector<vi>(n, vi(n, 0))); //speed, pos, prev\n\n\t\tdouble ans = INF;\n\t\twhile(!q.empty()){\n\t\t\tstate st = q.top();\n\t\t\tq.pop();\n\n\t\t\tif(visit[st.speed][st.pos][st.prev]) continue;\n\t\t\tvisit[st.speed][st.pos][st.prev] = 1;\n\n\t\t\tif(st.speed == 1 && st.pos == g){\n\t\t\t\tans = st.total;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, G[st.pos].size()){\n\t\t\t\tif(st.prev == G[st.pos][i].to) continue;\n\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\tstate next = st;\n\t\t\t\t\tnext.speed += j;\n\t\t\t\t\tif(next.speed <= 0 || next.speed > G[st.pos][i].c) continue;\n\t\t\t\t\tnext.pos = G[st.pos][i].to;\n\t\t\t\t\tnext.prev = st.pos;\n\t\t\t\t\tnext.total += G[st.pos][i].dist/next.speed;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == INF) cout << \"unreachable\" << endl;\n\t\telse printf(\"%.8lf\\n\", ans);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Road{\npublic:\n  int distance;\n  int speed_limit;\n  Road(int _d,int _s) : distance(_d),speed_limit(_s) {}\n  Road() : distance(INF),speed_limit(0) {}\n};\n\nclass State{\npublic:\n  int city;\n  int speed;\n  double time;\n  int prev;\n  State() : city(0),speed(1),time(0.0), prev(0){}\n  State(int _c,int _s,double _t,int _p) : city(_c),speed(_s),time(_t),prev(_p){}\n  \n  bool operator<(const State& s) const{\n    return time < s.time;\n  }\n\n  bool operator>(const State& s) const{\n    return time > s.time;\n  }\n};\n\nint main(){\n  int total_cities;\n  int total_roads;\n  while(~scanf(\"%d %d\",&total_cities,&total_roads)){\n    if(total_cities == 0 && total_roads == 0) break;\n    int start,goal;\n    scanf(\"%d %d\",&start,&goal);\n\n    Road edges[100][100];\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      int from,to,distance,speed_limit;\n      scanf(\"%d %d %d %d\",&from,&to,&distance,&speed_limit);\n      edges[from][to].distance = distance;\n      edges[from][to].speed_limit = speed_limit;\n      edges[to][from].distance = distance;\n      edges[to][from].speed_limit = speed_limit;\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(start,1,0.0,0)); //pos,speed,time\n\n    bool dp[50][50][50];\n\n    memset(dp,false,sizeof(dp));\n    double res = -0.1;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.prev][s.city][s.speed]) continue;\n\n      if(s.city == goal && s.speed == 1){\n\tres = s.time;\n\tbreak;\n      }\n\n      dp[s.prev][s.city][s.speed] = true;\n\n      for(int to = 1; to <= total_cities; to++){\n\tif(edges[s.city][to].distance >= INF) continue;\n\n\tif(edges[s.city][to].speed_limit >= s.speed - 1\n\t   && s.speed-1 >= 1){\n\t  que.push(State(to,\n\t\t\t s.speed -1,\n\t\t\t s.time + (double)edges[s.city][to].distance/(double)(s.speed - 1),\n\t\t\t s.city));\n\t}\n\n\tif(edges[s.city][to].speed_limit >= s.speed + 1\n\t   && s.time != 0.0){\n\t  que.push(State(to,\n\t\t\t s.speed + 1,\n\t\t\t s.time + (double)edges[s.city][to].distance/(double)(s.speed + 1),\n\t\t\t s.city));\n\t}\n\t\n\tif(edges[s.city][to].speed_limit >= s.speed){\n\t  que.push(State(to,\n\t\t\t s.speed,\n\t\t\t s.time + (double)edges[s.city][to].distance/(double)(s.speed),\n\t\t\t s.city));\n\n\t}\n      }\n    }\n\n    if(res < 0){\n      printf(\"unreachable\\n\");\n    }\n    else{\n      printf(\"%.5f\\n\",res);\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// (x,y)\ntypedef pair<int,int> P;\n// ( 速度 , (前の町,今の町) )\ntypedef pair<int,P> Node;\n// (cost,Node)\ntypedef pair<double,Node> State;\n\nconst int MAX_V = 31;\nconst double INF = 100000;\n\nstruct edge{\n\tint to, d, c;\n\tedge(int to_, int d_, int c_){\n\t\tto = to_; d = d_; c = c_;\n\t}\n};\n\n// グラフ\nvector<edge> G[MAX_V];\n// スタートからゴールに辿りつけるかどうか\nbool is_connect;\n\n// 入力\nint n, m;\n\n// 初期化\nvoid init(){\n\tis_connect = false;\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tG[i].clear();\n\t}\n}\n\n// 辺の追加\nvoid add_edge(int x, int y, int d, int c){\n\tedge e( y , d , c );\n\tG[x].push_back( e );\n\te.to = x;\n\tG[y].push_back( e );\n}\n\n// スタートからゴールに辿りつけるかどうかチェック\nvoid check(int v, int g, map<int,bool> memo){\n\tif( v == g ){\n\t\tis_connect = true;\n\t}\n\tif( memo[v] ) return;\n\tmemo[v] = true;\n\t\n\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\tint to = G[v][i].to;\n\t\tif( memo[to] ) continue;\n\t\tcheck( to , g , memo );\n\t}\n}\n\n// ダイクストラ法\ndouble solve(int s, int g){\n\t// d[v][x][y] := 速度v, 前の町x, 今の町yまでの最小コスト\n\tdouble d[31][31][31];\n\t// 初期化\n\tfor(int y=0 ; y < MAX_V ; y++ ){\n\t\tfor(int x=0 ; x < MAX_V ; x++ ){\n\t\t\tfor(int v=0 ; v < 31 ; v++ ){\n\t\t\t\td[v][y][x] = INF;\n\t\t\t\td[v][y][x] = INF;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ( 速度 , (前の町,今の町) ), 始点は前の町を0としてどの町にも Uターンできる扱い\n\tNode start( 1 , P(0,s) );\n\td[1][0][s] = 0;\n\tpriority_queue< State, vector<State> , greater<State> > q;\n\tq.push( State(0,start) );\n\t\n\tdouble ans = INF;\n\twhile( !q.empty() ){\n\t\t// 値を取り出す\n\t\tdouble now_cost = q.top().first;\n\t\tint v = q.top().second.first;\n\t\tint x = q.top().second.second.first;\n\t\tint y = q.top().second.second.second;\n\t\tq.pop();\n\t\t\n\t\t// 目的地のとき\n\t\tif( y == g ){\n\t\t\tans = min( ans , now_cost );\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < G[y].size() ; i++ ){\n\t\t\tint to = G[y][i].to;\n\t\t\tint dis = G[y][i].d;\n\t\t\tint c = G[y][i].c;\n\t\t\tif( to == x ) continue;\n\t\t\t\n\t\t\tfor(int dv = -1 ; dv <= 1 ; dv++ ){\n\t\t\t\tint next_v = v + dv;\n\t\t\t\tif( next_v > c ) continue;\n\t\t\t\t\n\t\t\t\tdouble cost = (double)dis / next_v;\n\t\t\t\tif( now_cost + cost < d[next_v][y][to] ){\n\t\t\t\t\td[next_v][y][to] = now_cost + cost;\n\t\t\t\t\t\n\t\t\t\t\tNode next( next_v , P(y,to) );\n\t\t\t\t\tState p( now_cost + cost , next );\n\t\t\t\t\tq.push( p );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile( cin >> n >> m , n || m ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\t\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tadd_edge( x , y , d , c );\n\t\t}\n\t\t\n\t\t{\n\t\t\t// スタートからゴールに辿りつけるかどうか\n\t\t\tmap<int,bool> memo;\n\t\t\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\t\t\tmemo[i] = false;\n\t\t\t}\n\t\t\tcheck( s , g , memo );\n\t\t}\n\t\t\n\t\t// ゴールに辿りつけないとき\n\t\tif( is_connect == false ){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t\tdouble ans = solve( s , g );\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n//#define LOG(...) printf(__VA_ARGS__)\n#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\n\nstruct edge{\n    int to, cost, limit;\n};\n\nstruct P{\n    int v;\n    double cost;\n    int ptown,speed;\n\n    bool operator >(const P &p)const{\n        return cost>p.cost;\n    }\n};\n\n#define MAX_TOWN 31\n#define MAX_V 31\n#define INF INT64_MAX\ndouble d[MAX_TOWN][MAX_TOWN][MAX_V];//town, from, v\n\nint main() {\n    int town, road, s, g;\n    while(cin >> town >> road, town|road){\n        cin >> s >> g;\n\n        fill_n((double*)d, MAX_TOWN*MAX_TOWN*MAX_V, INF);\n\n        vector<vector<edge> > G(town+1);\n        REP(i, road){\n            int from,to,cost,limit;\n            cin >> from >> to >> cost >> limit;\n            G[from].push_back((edge){to, cost, limit});\n            G[to].push_back((edge){from, cost, limit});\n        }\n\n        d[s][0][1]=0;\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push((P){s,0,-1,1});\n\n        double ans = INF;\n\n        while(!que.empty()){\n            P p=que.top();que.pop();\n            int v=p.v;\n            int sp=p.speed;\n//            LOG(\"town %d speed %d cost %f\\n\",v,sp,p.cost);\n\n            if(v==g&&sp==1){\n                ans = d[g][p.ptown][1];\n                break;\n            }\n\n            if(d[v][p.ptown][sp]<p.cost)continue;\n            REP(i, G[v].size()){\n                edge e=G[v][i];\n                if(p.ptown==e.to)continue;\n\n                for(int i=-1;i<=1;i++){\n                    if(i!=0&&p.cost==0){\n                        continue;\n                    }\n                    int nexts=sp+i;\n                    if(nexts<=0||30<nexts)continue;\n                    if(nexts>e.limit)continue;\n                    double time=p.cost+(double)e.cost/(double)nexts;\n                    if(d[e.to][v][nexts]>time){\n                        d[e.to][v][nexts]=time;\n                        que.push((P){e.to,time,v,nexts});\n                    }\n                }\n            }\n        }\n\n        if(ans==INF)\n            printf(\"unreachable\\n\");\n        else\n            printf(\"%0.5f\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\n// グラフ用ヘッダ\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    int limit;\n    Edge(int src, int dst, Weight weight, int limit) :\n        src(src), dst(dst), weight(weight), limit(limit) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n#include <queue>\n\n// d,speed,v,from\ntypedef tuple<double,int,int,int> State;\n\nconst double inf = 1e100;\n\n// speed,v,from\ndouble dp[32][32][32];\nGraph g;\nint src,dst;\n\nconst char* solve(){\n    priority_queue<State> q;\n    q.emplace(0.0,0,src,31);\n    rep(i,32)rep(j,32)rep(k,32) dp[i][j][k] = inf;\n    dp[0][src][31] = 0;\n    while(q.size()){\n        double d; int speed, v, from;\n        tie(d,speed,v,from) = q.top(); q.pop();\n        d = -d;\n        if(v==dst && speed==1){\n            static char ans[100];\n            sprintf(ans,\"%.12lf\",d);\n            return ans;\n        }\n        if(d > dp[speed][v][from]) continue;\n        for(Edge & e : g[v]){\n            for(int diff : {-1,0,1}){\n                int ns = speed + diff;\n                if(ns < 1 || e.limit < ns) continue;\n                double nd = d + (double)e.weight / ns;\n                int nv = e.dst;\n                if(nv == from) continue;\n                if(dp[ns][nv][v] > nd){\n                    dp[ns][nv][v] = nd;\n                    q.emplace(-nd,ns,nv,v);\n                }\n            }\n        }\n    }\n    return \"unreachable\";\n}\n\nint main(){\n    int n,m;\n    while(~scanf(\"%d%d\", &n,&m) && n){\n        scanf(\"%d%d\",&src,&dst);\n        g.assign(n+1,{});\n        rep(i,m){\n            int x,y,d,c;\n            scanf(\"%d%d%d%d\", &x,&y,&d,&c);\n            g[x].eb(x,y,d,c);\n            g[y].eb(y,x,d,c);\n        }\n        puts(solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nbool memo[30][30][110];\npair<int, int> g[30][30];\nint dist[30][30];\nconst int MAX = 10000;\n\nint main(){\n  int n, m;\n  while(scanf(\"%d%d\", &n, &m), n + m){\n    int st, gl;\n    int cm = 0;\n    scanf(\"%d%d\", &st, &gl); st--; gl--;\n\n    REP(i,n) REP(j,n) g[i][j] = mp(MAX, MAX);\n\n    REP(i,m){\n      int a, b, d, c;\n      scanf(\"%d%d%d%d\", &a, &b, &d, &c);\n      a--; b--;\n      g[a][b] = g[b][a] = mp(d, c);\n      cm = max(cm, c);\n    }\n\n    REP(i,n) REP(j,n) dist[i][j] = g[i][j].f;\n    REP(i,n) dist[i][i] = 0;\n\n    REP(k,n) REP(i,n) REP(j,n)\n      dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    if(dist[st][gl] == MAX){\n      puts(\"unreachable\");\n      continue;\n    }\n\n    REP(i,n) REP(j,n) REP(k,cm + 1)\n      memo[i][j][k] = false;\n\n    typedef pair<double, pair<int, pair<int, int> > > data;\n    priority_queue<data, vector<data>, greater<data> > pq;\n    pq.push(mp(0, mp(0, mp(st, st))));\n\n    while(pq.size()){\n      data d = pq.top(); pq.pop();\n      double tm = d.f;\n      int v     = d.s.f;\n      int pos   = d.s.s.f;\n      int prev  = d.s.s.s;\n      //printf(\"%f %d %d\\n\", tm, pos, prev);\n\n      if(memo[pos][prev][v]) continue;\n      memo[pos][prev][v] = true;\n\n      if(pos == gl && v == 1){\n        printf(\"%.5f\\n\", tm);\n        break;\n      }\n\n      REP(i,n) if(prev != i && g[pos][i].f != MAX){\n        int pp = i;\n        REP(j,3){\n          int vv = v + (j - 1);\n          if(vv <= 0 || vv > g[pos][i].s) continue;\n          if(memo[pp][pos][vv]) continue;\n          double tt = tm + (double)g[pos][i].f / vv;\n          pq.push(mp(tt, mp(vv, mp(pp, pos))));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nconst int MAX = 35;\nconst int INF = (1<<25);\nint n,m;\n\nstruct Edge{\n  int to;\n  double dis,lim;\n  Edge(int a, double b, double c){\n    to = a;\n    dis = b;\n    lim = c;\n  }\n};\n\nstruct State{\n  int pos,from;\n  double speed,t;\n  State(int a, double b, double c, int f){\n    pos = a;\n    speed = b;\n    t = c;\n    from = f;\n  }\n  bool operator < (const State& s) const{ return t > s.t;}\n};\n\nvector<Edge> E[MAX];\ndouble T[MAX][MAX];\n//T[i][j] := shortest time to i with speed j.\n\n\nvoid init(){\n  for(int i = 0; i < MAX; i++){\n    fill(T[i],T[i]+MAX,(double)INF);\n    E[i].clear();\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++){\n    int x,y;\n    double d,c;\n    cin >> x >> y >> d >> c;\n    //   cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    E[x].push_back(Edge(y,d,c));\n    E[y].push_back(Edge(x,d,c));\n  }\n}\n\nvoid solve(int s, int g){\n\n  priority_queue<State> Q;\n  T[s][0] = 0;\n  Q.push(State(s,0,0,-1));\n\n  while(!Q.empty()){\n    State sta = Q.top();\n    Q.pop();\n\n    if(sta.t > T[sta.pos][(int)sta.speed]) continue;\n\n    for(int i = 0; i < E[sta.pos].size(); i++){\n      int np = E[sta.pos][i].to;\n\n      if(np == sta.from) continue;\n\n      double sp[] = {-1.0,0.0,1.0};\n      \n      for(int j = 0; j < 3; j++){\n\tdouble ns = sta.speed+sp[j];\n\tif(ns <= 0 || ns > E[sta.pos][i].lim) continue;\n\tdouble nt = sta.t+E[sta.pos][i].dis/ns;\n\tif(T[np][(int)ns] > nt){\n\t  T[np][(int)ns] = nt;\n\t  Q.push(State(np,ns,nt,sta.pos));\n\t}\n      }\n    }\n  }\n  \n\n  if(T[g][1] == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.4f\\n\",T[g][1]);\n}\n\nint main(){\n\n  while(cin >> n >> m && n+m){\n    init();\n    int s,g;\n    cin >> s >> g;\n    input();\n    solve(s,g);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/std.h++>\n#define INF 1e10\n#define EPS 1e-10\nusing namespace std;\nstruct edge{\n  int to,limit;\n  double dist;\n};\nvector<edge> G[100];\ndouble d[40][100];\nbool used[40][100];\ntypedef pair<int,int> pii; //to,speed\ntypedef pair<double,pii> P;//cost,to,speed\n\ndouble dikstra(int s,int g){\n  int ds[3]={-1,0,1};\n  priority_queue<P,vector<P>,greater<P> > que;\n  for(int i=0;i<40;i++)\n    for(int j=0;j<100;j++)\n      d[i][j]=INF;\n  memset(used,0,sizeof(used));\n  d[0][s]=0;\n  que.push(P(0,pii(s,0)));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int speed=p.second.second;\n    int v=p.second.first;\n    double cost=p.first;\n    //cout << v << \";\" << speed <<\":\" << cost << endl;\n    if(d[speed][v]<cost)continue;\n    for(int i=0;i<G[v].size();i++){\n      for(int j=0;j<3;j++){\n\tedge e=G[v][i];\n\tint ns=speed+ds[j];\n\tif(1<=ns && ns<= e.limit &&\n\t   used[ns][e.to]==false){\n\t  used[ns][e.to]=true;\n\t  que.push(P(cost+e.dist/ns,pii(e.to,ns)));\n\t  if(d[ns][e.to]>cost+e.dist/ns){\n\t    d[ns][e.to]=cost+e.dist/ns;\n\t    //cout << \"d[\" << ns << \"][\" << e.to << \"]:\" << d[ns][e.to] << endl;\n\t    //cout << \"d[\" << v << \"]:\" << d[speed][v] << \" speed:\" << speed<< endl;\n\t  }\n\t}\n      }\n    }\n  }\n  if(d[1][g]==INF)return -1;\n  return d[1][g];\n}\n\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n){\n    for(int i=0;i<100;i++)G[i].clear();\n    cin>>s>>g;\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      G[x].push_back((edge){y,c,d});\n      G[y].push_back((edge){x,c,d});\n    }\n    double ans=dikstra(s,g);\n    if(ans==-1)cout << \"unreachable\" << endl;\n    else printf(\"%lf\\n\",ans);\n    // for(int i=0;i<=n;i++)\n    // \tcout << i << \" \" << d[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nstruct P{\n  double t;\n  short v,p,pre;\n  P(){};\n  P(double T,int V,int pp,int PRE){\n    t=T;v=V;p=pp;pre=PRE;\n  };\n  bool operator<(const P &p)const{\n    return t>p.t;\n  }\n};\nstruct Path{\n  int d,c;\n  Path(){};\n  Path(int D,int C){ d=D;c=C;};\n};\n\nint main(){\n  int n,m;\n  int s,g;\n  int x,y,d,c;\n  Path path[30][30];\n  //priority_queue<P,vector<P>,greater<P> > q;\n  priority_queue<P> q;\n\n  while( cin>>n>>m && (n|m) ){\n    cin >> s >> g;\n    s--; g--;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tpath[i][j].d=-1.0; path[i][j].c=-1;\n      }\n\n    for( int i=0;i<m;i++ ){\n      cin >> x >> y >> d >> c;\n      x--;y--;\n      path[x][y].d=d; path[x][y].c=c;\n      path[y][x] = path[x][y];\n    }\n\n    while( !q.empty() ) q.pop();\n\n    double cost[30][35]; // place,velocity\n    int dv[3] = {-1,0,1};\n    for( int i=0;i<n;i++ ){\n      for( int j=1;j<31;j++ )\n\tcost[i][j] = DBL_MAX;\n    }\n\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      double nt = path[s][i].d;\n      q.push( P(nt,1,i,-1) );\n      cost[i][1] = nt;\n    }\n\n    while( !q.empty() ){\n      P p = q.top(); q.pop();\n      double t = p.t;\n      int v = p.v;\n      int np = p.p; // 現在地\n      int pre = p.pre;\n\n      if( t>cost[g][1] ) break;\n\n      /*\n      cout << \"v=\" << v << \" p=\" << np << \" pre=\" << pre \n\t   << \" t=\" << t << endl;\n      */\n\n      for( int i=0;i<n;i++ ){\n\tif( path[np][i].c<0 ) continue;// たどり着けないノード\n\tif( i==pre ) continue; // 前回のノード\n\n\tfor( int j=0;j<3;j++ ){\n\t  int nv = v + dv[j];\n\t  if( nv==0 ) continue;\n\t  if( nv>path[np][i].c ) continue;\n\t  double nCost = t + (double)path[np][i].d/nv;\n\t  if( cost[i][nv] < nCost ) continue;\n\t  cost[i][nv]=nCost;\n\t  if( cost[i][nv]>cost[g][1] ) continue;\n\t  if( i==g && nv==1 ) continue;\n\t  q.push( P(nCost,nv,i,np) );\n\t}\n      }\n\n    }\n    if( fabs(cost[g][1]-DBL_MAX)<1e-4 )\n      cout << \"unreachable\" << endl;\n    else\n      //      cout << cost[g][1] << endl;\n      printf(\"%.6lf\\n\",cost[g][1]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<functional>\n \n \n#define rep(i,n) for(int i=0;i<(n);i++)\n \nusing namespace std;\nconst int INF = 100000000;\ntypedef pair<int,int> P;\n\nint n,m;\n\nstruct edge\n{\n\t//どこから来た,コスト,速度制限\n\tint to,cost,ub;\n\tedge(int to,int cost,int ub) {\n\t\tthis->to = to;\n\t\tthis->cost = cost;\n\t\tthis->ub = ub;\n\t}\n};\n\nvector<edge> G[103];\nint s,g;\ndouble dist[103][103][33];\n\ntypedef pair<double,int> PD;\ntypedef pair<PD,P> PP;\n\ndouble dijkstra() {\n\trep(i,103) rep(j,103) rep(k,33) dist[i][j][k]=INF;\n\trep(i,103) rep(j,33) dist[s][i][j]=0;\n\n\t//最短距離 頂点 前の頂点 今の速さ\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(PD(0,s),P(0,1)));\n\n\twhile (!que.empty())\n\t{\n\t\tPP pp = que.top(); que.pop();\n\t\tint v = pp.first.second;\n\n\t\tint prev = pp.second.first;\n\t\tint u = pp.second.second;\n\n\t\tif(dist[v][u][prev] < pp.first.first) continue;\n\n\t\trep(i,G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tfor(int j=-1;j<=1;j++) {\n\t\t\t\tif(j+u<=0 || u+j > e.ub) continue;\n\n\t\t\t\tif(dist[e.to][v][u+j] > dist[v][prev][u] + (1.0*e.cost/(u+j))) {\n\t\t\t\t\tdist[e.to][v][u+j] = dist[v][prev][u] + (1.0*e.cost/(u+j));\n\t\t\t\t\tque.push(PP(PD(dist[e.to][v][u+j],e.to),P(v,u+j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tdouble ans=INF;\n\trep(i,103) ans=min(ans,dist[g][i][1]);\n\n\treturn ans;\n\t\n}\n\nvoid solve() {\n\trep(i,103) G[i].clear();\n\tcin>>s>>g;\n\trep(i,m) {\n\t\tint x,y,d,c;\n\t\tcin>>x>>y>>d>>c;\n\t\tG[x].push_back(edge(y,d,c));\n\t\tG[y].push_back(edge(x,d,c));\n\t}\n\n\tdouble ans;\n\tans = dijkstra();\n\tif(ans==INF) {\n\t\tcout<<\"unreachable\"<<endl;\n\t}\n\telse\n\t{\n\t\tcout<<ans+1.0<<endl;\n\t}\n\n\n}\n\nint main() {\n\twhile (cin>>n>>m)\n\t{\n\t\tif(n+m==0) return 0;\n\t\tsolve();\n\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nusing tp = tuple<int, int, int>;\nusing ttp = tuple<ld, int, int>;\n\nconst ld INF = 1e20;\n\nint main()\n{\n\tcout << fixed << setprecision(8);\n\tint n, m;\n\twhile (cin >> n >> m, n | m) {\n\t\tint s, g;\n\t\tcin >> s >> g; s--, g--;\n\t\tvector<vector<tp>> G(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c; x--, y--;\n\t\t\tG[x].emplace_back(y, d, c);\n\t\t}\n\t\tvector<vector<ld>> d(n, vector<ld>(31, INF));\n\t\tpriority_queue<ttp, vector<ttp>, greater<ttp>> pq;\n\t\tpq.emplace(0.0, s, 1);\n\t\twhile (!pq.empty()) {\n\t\t\tauto p = pq.top(); pq.pop();\n\t\t\tint v = get<1>(p), ve = get<2>(p);\n\t\t\tld cos = get<0>(p);\n\t\t\tif (d[v][ve] != INF) continue;\n\t\t\td[v][ve] = cos;\n\t\t\tif (ve == 0) continue;\n\t\t\tfor (auto e : G[v]) {\n\t\t\t\tint to = get<0>(e), st = get<2>(e);\n\t\t\t\tld dis = get<1>(e);\n\t\t\t\tif (st < ve) continue;\n\t\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\t\tif (d[to][ve + i] == INF) {\n\t\t\t\t\t\tpq.emplace(cos + dis / ve, to, ve + i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[g][0] == INF) cout << \"unreachable\" << endl;\n\t\telse cout << d[g][0] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n \ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n \ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n \ntypedef vector<double> VD;\ntypedef vector< VD > VVD;\ntypedef vector< VVD > VVVD;\n \ntypedef long long LL;\n \ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n \n#define X first\n#define Y second\n \nconst LL MOD = 1000000007;\nconst double EPS = 1e-6;\n \nstruct Edge{\n    Edge (int t, int d, int s) : to(t), dist(d), speed(s) {};\n    int to, dist, speed;\n};\n \ntypedef tuple<double, int, int, int> State;\n \nconst double INF = DBL_MAX / 2;\nconst int SPEED_MAX = 30;\n \nint main(void) {\n    for (int N, M, S, G; cin >> N >> M, N;) {\n        cin >> S >> G;\n        S--; G--;\n         \n        vector< vector<Edge> > edges(N);\n        for (int i = 0; i < M; i++) {\n            int from, to, dist, speed;\n            cin >> from >> to >> dist >> speed;\n            from--; to--;\n            edges[from].push_back(Edge(to, dist, speed));\n            edges[to].push_back(Edge(from, dist, speed));\n        }\n \n        // current, before, speed\n        VVVD times(N, VVD(N, VD(SPEED_MAX+1, INF)));\n        times[S][S][0] = 0;\n \n        priority_queue<State, vector<State>, greater<State>> q;\n        q.emplace(0, S, S, 0);\n \n        while (q.size()) {\n            State p = q.top();\n            double now_time = get<0>(p);\n            int current = get<1>(p);\n            int before = get<2>(p);\n            int speed = get<3>(p);\n            q.pop();\n \n            if (times[current][before][speed] + EPS < now_time) {\n                continue;\n            }\n \n            for (int di = -1; di <= 1; di++) {\n                int next_speed = speed + di;\n                if (next_speed < 1 || SPEED_MAX < next_speed) {\n                    continue;\n                }\n \n                for (auto &edge : edges[current]) {\n                    if (edge.to == before) { // U turn!!\n                        continue;\n                    }\n \n                    if (edge.speed < next_speed) { // スピード違反!\n                        continue;\n                    }\n \n                    auto &next_time = times[edge.to][current][next_speed];\n                    double cost = 1. * edge.dist / next_speed;\n \n                    if (next_time > cost + now_time + EPS) {\n                        next_time = cost + now_time;\n                        q.emplace(next_time, edge.to, current, next_speed);\n                    }\n                }\n            }\n        }\n \n        double ans = INF;\n        for (int i = 0; i < N; i++) {\n            ans = min(ans, times[G][i][1]);\n        }\n \n        if (ans == INF) {\n            cout << \"unreachable\" << endl;\n        }else {\n            cout << fixed << setprecision(5) << ans << endl;\n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 35\n#define INF 1e9\n#define F first\n#define S second\ntypedef pair<double,int> pdi;\ntypedef pair<int,int> pii;\ntypedef pair<pdi,pii> State;\n\nstruct Edge{\n  int to,d,c;\n  Edge(int to,int d,int c) : to(to),d(d),c(c) {}\n};\n\nint N,M,s,g;\nvector<Edge> G[MAX];\n\ndouble dijkstra(){\n  priority_queue<State,vector<State>,greater<State> > Q;\n  Q.push(State(pdi(0,s),pii(1,1)));\n  double Time[MAX][MAX][MAX];\n\n  fill(Time[0][0],Time[0][0]+MAX*MAX*MAX,INF);\n  Time[s][1][1] = 0;\n\n  while(!Q.empty()){\n    State p = Q.top(); Q.pop();\n    int v = p.F.S, vel = p.S.F;\n    if(Time[v][vel][p.S.S] < p.F.F) continue;\n\n    if(v == g && vel == 1){\n      return Time[g][1][p.S.S];\n    }\n\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      for(int j = -1 ; j <= 1 ; j++){\n        if(vel+j <= 0) continue;\n        if(Time[v][vel][p.S.S] == 0 && j){\n          continue;\n        }\n        Edge e = G[v][i];\n        double t = (double)e.d/(vel+j);\n        if(vel+j <= e.c && \n           Time[v][vel][p.S.S] + t < Time[e.to][vel+j][v]){\n          Time[e.to][vel+j][v] = Time[v][vel][p.S.S] + t;\n          Q.push(State(pdi(Time[e.to][vel+j][v],e.to),pii(vel+j,v)));\n        }\n      }\n    }\n  }\n  return INF;\n}\n\nint main(){\n  int x,y,d,c;\n  while(cin >> N >> M, N){\n    for(int i = 0 ; i < MAX ; i++){\n      G[i].clear();\n    }\n    cin >> s >> g; s--; g--;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> d >> c;\n      x--; y--;\n      G[x].push_back(Edge(y,d,c));\n      G[y].push_back(Edge(x,d,c));\n    }\n    double res = dijkstra();\n    if(res == INF){\n      cout << \"unreachable\" << endl;\n    }else{\n      printf(\"%.8f\\n\",res);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\nnamespace ShortestPath{\n    typedef double Cost;\n    const Cost CINF=1e18;\n    typedef  vector<vector<Cost> > Mat;\n    struct Edge{\n    \tint id;\n        int from,to;Cost cost;int Mc;\n        Edge(int id,int from,int to,Cost cost,int Mc)\n            : id(id),from(from),to(to),cost(cost),Mc(Mc) {};\n    };\n    ostream& operator <<(ostream& os,const Edge& e){\n            os<<\"(\"<<e.from<<\"->\"<<e.to<<\")\";\n            return os;\n    }\n    typedef vector<vector<Edge> > Graph;\n\n    struct Task{\n        int prev,pos;Cost cost;\n        Task(int prev,int pos,Cost cost)\n            :prev(prev),pos(pos),cost(cost){};\n        bool operator>(const Task& r) const{\n            return cost>r.cost;\n        }\n    };\n \n    // 最大も可\n    // 負の閉路が判定可能\n    //O(V*E)\n    vector<Cost> bellmanFord(Graph g,int s,vector<int>& prev){\n        const int V=g.size();\n        vector<Cost> d(V,CINF);d[s]=0;\n        fill(ALL(prev),-2);\n        REP(k,V){\n            REP(i,V)REP(j,g[i].size()){\n                Edge& e=g[i][j];\n                if(d[e.to]>d[e.from]+e.cost){\n                    d[e.to]=d[e.from]+e.cost;\n                    prev[e.to]=e.from;\n                    if(k==V-1)d[e.to]=-CINF;\n                }\n            }\n        }\n        return d;\n    }\n\n    //verified by codoforces 144D http://codeforces.com/contest/144/submission/4976825\n    // // 負の辺がない\n    // // O(E*logV)\n    vector<Cost> dijkstra(const Graph& g,const int s,vector<int>& prev){\n        const int V=g.size();\n        vector<Cost> d(V,CINF);d[s]=0;\n        fill(ALL(prev), -2);\n        priority_queue<Task,vector<Task>,greater<Task> > que;\n        que.push(Task(-1,s,0));\n        while(!que.empty()){\n            Task task=que.top();que.pop();\n            //if(prev[task.pos]!=-2)continue;\n            if(d[task.pos]<task.cost)continue;\n            prev[task.pos]=task.prev;\n            EACH(e,g[task.pos]){\n            \tif(e->id==task.prev)continue;// not U ターン\n                if(d[e->to]>d[e->from]+e->cost){\n                    d[e->to]=d[e->from]+e->cost;\n                    que.push(Task(e->from,e->to,d[e->to]));\n                }\n            }   \n        }\n        return d;\n    }\n    vector<Cost> dijkstra(const Graph& g,const int s){\n        vector<int> prev(g.size());return dijkstra(g,s,prev);\n    }\n}\n\nusing namespace ShortestPath;\n\nclass Main{\n\tpublic:\n\n\tint enc(int pos,int V){\n\t\treturn pos*31+V;\n\t}\n\tint dec_pos(int c){\n\t\treturn c/31;\n\t}\n\tint dec_v(int c){\n\t\treturn c%31;\n\t}\n\n\tvoid run(){\n\t//\tifstream cin(\"in\");\n\t//\tofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tint N,M;nextInt(N);nextInt(M);\n\t\t\tif(N==0)break;\n\t\t\tint s,g;nextInt(s);nextInt(g);s--;g--;\n\t\t\tGraph G(N*31);\n\t\t\tREP(i,M){\n\t\t\t\tint x,y;double d;int c;nextInt(x);nextInt(y);nextDouble(d);nextInt(c);x--;y--;\n\t\t\t\tif(s==x)G[enc(x,0)].push_back(Edge(i,enc(x,0),enc(y,1),d,c));\n\t\t\t\tif(s==y)G[enc(y,0)].push_back(Edge(i,enc(y,0),enc(x,1),d,c));\n\t\t\t\t// V\n\t\t\t\tfor(int v=1;v<=c && v<=30;v++)G[enc(x,v)].push_back(Edge(i,enc(x,v),enc(y,v),d/v,c));\n\t\t\t\tfor(int v=1;v<=c && v<=30;v++)G[enc(y,v)].push_back(Edge(i,enc(y,v),enc(x,v),d/v,c));\n\t\t\t\t// V++ スタートを考えるとv=0\n\t\t\t\tfor(int v=1;v+1<=c && v<=30;v++)G[enc(x,v)].push_back(Edge(i,enc(x,v),enc(y,v+1),d/(v+1),c));\n\t\t\t\tfor(int v=1;v+1<=c && v<=30;v++)G[enc(y,v)].push_back(Edge(i,enc(y,v),enc(x,v+1),d/(v+1),c));\n\t\t\t\t// V--\n\t\t\t\tfor(int v=2;v-1<=c && v<=30;v++)G[enc(x,v)].push_back(Edge(i,enc(x,v),enc(y,v-1),d/(v-1),c));\n\t\t\t\tfor(int v=2;v-1<=c && v<=30;v++)G[enc(x,v)].push_back(Edge(i,enc(y,v),enc(x,v-1),d/(v-1),c));\n\t\t\t}\n\t\t\tvector<Cost> res=dijkstra(G,enc(s,0));\n\t\t\tif(res[enc(g,1)]==CINF) cout <<\"unreachable\"<<endl;\n\t\t\telse cout << res[enc(g,1)]<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef pair<pair<double,int>,pair<int,int> > P;\n\nclass road{\npublic:\n  int to,d,c;\n  road(int x,int y,int z){to = x;d = y;c = z;};\n};\n\nvector<road> G[31];\n\nint main(){\n  int n,m,s,g;\n  int x,y,d,c;\n\n  for(;;){\n    scanf(\"%d %d\",&n,&m);\n    if(!n && !m)break;\n    scanf(\"%d %d\",&s,&g);\n\n    double t[31][31][31];\n    bool v[31][31][31];\n\n    for(int i=0;i<n;i++)G[i].clear();\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d %d %d\",&x,&y,&d,&c);\n      G[x].push_back(road(y,d,c));\n      G[y].push_back(road(x,d,c));\n    }\n    \n    for(int i=0;i<=n;i++)\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<=30;k++){\n\tt[i][j][k] = 1e10;\n\tv[i][j][k] = false;\n      }\n\n    t[s][0][0] = 0.0;\n    priority_queue<P,vector<P>,greater<P> > q;\n    q.push(P(pair<double,int>(0.0,s),pair<int,int>(0,0)));\n\n    while(q.size()){\n      P p = q.top();q.pop();\n\n      double time = p.first.first;\n      int now,prv,speed;\n      now = p.first.second;\n      prv = p.second.first;\n      speed = p.second.second;\n\n      if(v[now][prv][speed])continue;\n      v[now][prv][speed] = true;\n\n      for(int i=0;i<(int)G[now].size();i++){\n\troad r = G[now][i];\n\tif(r.to != prv){\n\t  for(int dif=-1;dif<=1;dif++){\n\t    if(speed+dif>0 &&  speed+dif<=r.c){\n\t      if(!v[r.to][now][speed+dif]){\n\t\tif(t[r.to][now][speed+dif] > time+(double)r.d/(speed+dif)){\n\t\t  t[r.to][now][speed+dif] = time+(double)r.d/(speed+dif);\n\t\t  q.push(P(pair<double,int>(t[r.to][now][speed+dif],r.to),pair<int,int>(now,speed+dif)));\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    double ans = 1e10;\n    for(int i=0;i<=n;i++)ans = min(ans,t[g][i][1]);\n    if(ans==1e10)printf(\"unreachable\\n\");\n    else printf(\"%.4lf\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\nconst double EPS = 1e-8;\n\nclass State{\npublic:\n  int pos, v, pre;\n  double time;\n  State(){}\n  State(int pos, int v, int pre, double time) : pos(pos), v(v), pre(pre), time(time) {}\n  bool operator < (const State& s) const { return time > s.time; }\n};\n\nint n, m, s, g;\nP edge[30][30];\ndouble cost[30][30][31];\nbool vis[30][30][31];\n\nbool equals(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nvoid solve(){\n  State u, v;\n  u = State(s, 0, 0, 0.0);\n  priority_queue<State> que;\n  fill(vis[0][0], vis[30][0], (double)INF);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<31;k++){\n        cost[i][j][k] = INF;\n        vis[i][j][k] = false;\n      }\n    }\n  }\n  //cost[0][0][1] = 0.0;\n  for(int i=0;i<n;i++){\n    if(edge[s][i].first != INF){\n      cost[s][i][1] = edge[s][i].first;\n      que.push(State(i, 1, s, (double)edge[s][i].first));\n    }\n  }\n  while(!que.empty()){\n    u = que.top(); que.pop();\n    //cout << u.pos << ' ' << u.v << ' ' << u.pre << ' ' << u.time << endl;\n    if(vis[u.pre][u.pos][u.v]) continue;\n    vis[u.pre][u.pos][u.v] = true;\n    if(u.pos == g && u.v == 1){\n      printf(\"%.5f\\n\", u.time);\n      return;\n    }\n    for(int i=0;i<n;i++){\n      if(edge[u.pos][i].first == INF) continue;\n      if(u.pre == i) continue;\n      for(int k=-1;k<=1;k++){\n        if(u.v + k > edge[u.pos][i].second) continue;\n        if(u.v + k <= 0) continue;\n        v = State(i, u.v + k, u.pos, u.time + edge[u.pos][i].first / (double)(u.v + k));\n        //cout << '\\t' << v.pos << ' ' << v.v << ' ' << v.pre << ' ' << v.time << ' ' << vis[v.pre][v.pos][v.v] << endl;\n        if(cost[v.pre][v.pos][v.v] > v.time){\n          cost[v.pre][v.pos][v.v] = v.time;\n          que.push(v);\n        }\n      }\n    }\n  }\n  printf(\"unreachable\\n\");\n}\n\nmain(){\n  while(scanf(\"%d%d\", &n, &m) && (n|m)){\n    scanf(\"%d%d\", &s, &g);\n    s--; g--;\n    fill(edge[0], edge[30], P(INF, 0));\n    for(int i=0;i<m;i++){\n      int a, b, c, d;\n      scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n      a--; b--;\n      edge[a][b] = edge[b][a] = P(c, d);\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": " D (AOJ 1162) by iga_xx\nContest: 2189    RunID: 1002065    Status: Wrong Answer    Date: Sun Jun 29 18:37:44 JST 2014\n?\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n\t\n#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n  \n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REP1(i,n) for(int i=1;i<(n);i++)\n#define REP2(i,d,n) for(int i=(d);i<(n);i++)\n#define RREP(i,n) for(int i=(n);i>=0;i--)\n#define CLR(a) memset((a),0,sizeof(a))\n#define MCLR(a) memset((a),-1,sizeof(a))\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n  \nusing namespace std;\n  \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI > VVI;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef pair<int,int> PII;\n  \nconst int INF = 0x3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-9;\n  \nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n  \n  \nstruct edge {\n    int to, from, cost;\n    edge(int _to, int _from, int _cost) {to = _to; from = _from; cost=_cost;}\n};\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\n  \nint maxspeed[31][31];\n  \nclass Dijkstra{\npublic:\n    int V;\n    vector<vector<edge> > G;\n    vector<vector<double> > d;\n     \n    Dijkstra(int _V){\n        V = _V;\n        G.resize(V);\n        d.resize(31);\n \n        REP(i,31){\n            d[i].resize(V);\n        }\n    }\n     \n    void add_edge(int from, int to, int cost){\n        G[from].PB(edge(to,from,cost));\n    }\n     \n    void solve(int s){\n        priority_queue<PP, vector<PP>, greater<PP> > que;\n\t\t// コスト、直前、頂点、速度\n        REP(i,31){\n            REP(j, V){\n                d[i][j] = INF;\n            }\n        }\n        d[0][s] = 0;\n\t\t// d := 速度、位置\n        que.push(PP(P(0,0),P(s,0)));\n         \n        while(!que.empty()){\n            PP p = que.top();\n            que.pop();\n            int v = p.second.first; // 現在地\n            int mv = p.second.second; // 速度\n            int old = p.first.second; // 直前\n            REP2(i,-1,2){\n                if(mv+i <= 0 || 30 < mv+i) continue;\n                if(d[mv][v] < p.first.first) continue;\n                REP(j,G[v].size()){\n                    edge e = G[v][j];\n                    if(e.to == old) continue;\n                    //cout << e.from << \":\" << e.to << \" \" << maxspeed[e.from][e.to] << \" \" << (mv+i) <<  endl;\n                    if(maxspeed[e.from][e.to] < mv+i) { continue; }\n                    if(d[mv+i][e.to] > d[mv][v] + (double)e.cost/(mv+i)){\n                        d[mv+i][e.to] = d[mv][v] + (double)e.cost/(mv+i);\n                        //cout << (mv+i) << \" - \" << e.to << \" - \" << d[mv+i][e.to] << endl;\n                        que.push(PP(P(d[mv+i][e.to],v), P(e.to,mv+i)));\n                    }\n                }\n            }\n        }\n    }\n};\n \nint main(){\n    while(true){\n        int n,m;\n         \n        cin >> n >> m;\n        Dijkstra dijkstra(n);\n        if(n==0&&m==0){\n            break;\n        }\n        REP(i,31){\n            REP(j,31){\n                maxspeed[i][j] = 0;\n            }\n        }\n \n        int s,g;\n        cin >> s >> g;\n        s--; g--;\n        REP(i,m){\n            int x,y,d,c;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            dijkstra.add_edge(x,y,d);\n            dijkstra.add_edge(y,x,d);\n            maxspeed[x][y] = c;\n            maxspeed[y][x] = c;\n        }\n \n        dijkstra.solve(s);\n \n        if(abs(dijkstra.d[1][g]-INF) < 1e-5){\n            cout << \"unreachable\" << endl;\n        }else{\n            printf(\"%.5f\\n\",dijkstra.d[1][g]);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nint n, m;\n\nstruct edge{\n    int from, to, lim;\n    double dist;\n    edge(int f, int t, double d, int l): from(f), to(t), dist(d), lim(l){}\n};\n\nstruct state{\n    int v, pv, speed;\n    double time;\n    state(int v, int pv, int s, double t): v(v), pv(pv), speed(s), time(t){}\n};\n\nvoid solve(){\n    int s, g;\n    scanf(\"%d%d\", &s, &g);\n    --s; --g;\n    vector<edge> G[n];\n    rep(i, m){\n        int a, b, c;\n        double d;\n        scanf(\"%d%d%lf%d\", &a, &b, &d, &c);\n        --a; --b;\n        G[a].emplace_back(a, b, d, c);\n        G[b].emplace_back(b, a, d, c);\n    }\n\n    double d[n][n][35]; // v, pv, speed\n    rep(i, n)rep(j, n)rep(k, 35) d[i][j][k] = INF;\n    auto cmp = [](const state &s1, const state &s2){\n        return s1.time > s2.time;\n    };\n    priority_queue<state, vector<state>, decltype(cmp)> que(cmp);\n    d[s][s][0] = 0;\n    que.emplace(s, s, 0, 0);\n    while(!que.empty()){\n        auto now = que.top();\n        que.pop();\n        if(now.time > d[now.v][now.pv][now.speed]) continue;\n        for(auto &e: G[now.v])if(e.to != now.pv){\n            for(int i=-1; i<=1; ++i){\n                int ns = now.speed + i;\n                if(1 <= ns && ns <= e.lim && chmin(d[e.to][now.v][ns], now.time + (double)e.dist / ns)){\n                    que.emplace(e.to, now.v, ns, d[e.to][now.v][ns]);\n                }\n            }\n        }\n    }\n    double ans = INF;\n    rep(i, n) chmin(ans, d[g][i][1]);\n    if(ans == INF) puts(\"unreachable\");\n    else printf(\"%.10lf\\n\", ans);\n}\n\nint main(){\n    while(scanf(\"%d%d\", &n, &m) && n){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nclass state {\npublic:\n  double cost;\t\t\t// 所要時間\n  int pp;                       // 前の位置\n  int np;\t\t\t// 今の位置\n  int v;\t\t\t// 速度\n  state(double _cost, int _pp, int _np, int _v) {\n    cost = _cost;\n    pp = _pp;\n    np = _np;\n    v = _v;\n  }\n  bool operator > (const state &s) const {\n    return cost > s.cost;\n  }\n};\n\nint main() {\n  int n, m;\n  while (true) {\n    cin >> n >> m;\n    if (n == 0 && m == 0) {\n      break;\n    }\n\n    int s, g;\n    cin >> s >> g;\n    s--; g--;\n    if (m == 0) {\n      std::cout << \"unreachable\" << std::endl;\n      continue;\n    }\n\n    vector <int> graph[n];\n    double cost[n][n];\n    double dist[n][n];\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      double d, c;\n      cin >> x >> y >> d >> c;\n      x--; y--;\n      graph[x].push_back(y);\n      graph[y].push_back(x);\n      cost[x][y] = c;\n      cost[y][x] = c;\n      dist[x][y] = d;\n      dist[y][x] = d;\n    }\n\n    double memo[n][n][32];\t\t// prev now v\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n\tfor (int k = 0; k < 32; k++) {\n\t  memo[i][j][k] = -1;\n\t}\n      }\n    }\n\n    priority_queue <state, vector<state>, greater<state> > pque;\n    for (int i = 0; i < graph[s].size(); i++) {\n      int np = graph[s][i];\n      double nt = dist[s][np];\n      memo[s][np][1] = nt;\n      pque.push(state(nt, s, np, 1));\n    }\n    while(!pque.empty()) {\n      state p = pque.top(); pque.pop();\n\n      for (int i = 0; i < graph[p.np].size(); i++) {\n\tint np = graph[p.np][i];\n        if (p.pp == np) {\n          continue;\n        }\n\tfor (int j = -1; j <= 1; j++) {\n\t  int v = p.v+j;\n\t  if (v <= 0 || v > cost[p.np][np]) {\n\t    continue;\n\t  }\n\n\t  double nt = p.cost+dist[p.np][np]/double(v);\n\n\t  if (memo[p.np][np][v] == -1 ||\n\t      memo[p.np][np][v] > nt) {\n\t    memo[p.np][np][v] = nt;\n\t    pque.push(state(nt, p.np, np, v));\n\t  }\n\t}\n      }\n    }\n\n    double ans = -1;\n    for (int i = 0; i < n; i++) {\n      if (memo[i][g][1] == -1) {\n        continue;\n      }\n      if (ans == -1 ||\n          memo[i][g][1] < ans) {\n        ans = memo[i][g][1];\n      }\n    }\n\n    if (ans == -1) {\n      std::cout << \"unreachable\" << std::endl;\n    }else {\n      printf(\"%.5f\\n\", ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define INF 100000000\n#define rep(i,n) for(int i=0;i<n;i++)\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef pair<double,int> pp;\ntypedef pair<pp,p> P;\nstruct edge{\n\tint to,d,c;\n};\nint main(){\n\tdouble dp[31][31];\n\tint n,m,s,g,x,y,d,c,ds[]={1,-1,0};\n\twhile(cin>>n>>m,n||m){\n\t\tvector<edge> G[31];\n\t\tcin>>s>>g;\n\t\ts--;g--;\n\t\trep(i,m){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tx--;y--;\n\t\t\tedge e;\n\t\t\te.d=d;e.c=c;\n\t\t\te.to=y;\n\t\t\tG[x].push_back(e);\n\t\t\te.to=x;\n\t\t\tG[y].push_back(e);\n\t\t}\n\t\trep(i,31)\n\t\trep(j,31)\n\t\tdp[i][j]=INF;\n\t\tdp[0][s]=0.0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(pp(0.0,-1),p(0,s)));\n\t\tdouble ans=INF;\n\t\twhile(!que.empty()){\n\t\t\tP q=que.top();que.pop();\n\t\t\tif(q.second.second==g&&q.second.first==1){\n\t\t\t\tans=min(ans,dp[q.second.first][q.second.second]);\n\t\t\t\tbreak;\n\t\t\t//\tcout<<ans<<endl;\n\t\t\t}\n\t\t\t//cout<<q.second.second<<' '<<q.second.first<<' '<<q.first<<endl;\n\t\t\tif(dp[q.second.first][q.second.second]<q.first.first)\n\t\t\t\tcontinue;\n\t\t\trep(i,G[q.second.second].size()){\n\t\t\t\tedge e=G[q.second.second][i];\n\t\t\t\tif(e.to==q.first.second)\n\t\t\t\tcontinue;\n\t\t\t\trep(j,3){\n\t\t\t\t\tint pre=q.second.first+ds[j];\n\t\t\t\t\tif(pre<1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble tes=(double)e.d/pre+q.first.first;\n\t\t\t\t\tif(pre<=e.c&&dp[pre][e.to]>tes){\n\t\t\t\t\t\tque.push(P(pp(tes,q.second.second),p(pre,e.to)));\n\t\t\t\t\t\tdp[pre][e.to]=tes;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans==INF)\n\t\tcout<<\"unreachable\"<<endl;\n\t\telse\n\t\tprintf(\"%.5lf\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\nconst double EPS = 1e-8;\n\nclass State{\npublic:\n  int pos, v, pre;\n  double time;\n  State(){}\n  State(int pos, int v, int pre, double time) : pos(pos), v(v), pre(pre), time(time) {}\n  bool operator < (const State& s) const { return time > s.time; }\n};\n\nint n, m, s, g;\nP edge[30][30];\ndouble vis[30][30][31];\n\nbool equals(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nvoid solve(){\n  State u, v;\n  bool reach = false;\n  u = State(s, 0, 0, 0.0);\n  priority_queue<State> que;\n  fill(vis[0][0], vis[30][0], (double)INF);\n  for(int i=0;i<n;i++){\n    if(edge[s][i].first != INF){\n      vis[s][i][1] = edge[s][i].first;\n      que.push(State(i, 1, s, (double)edge[s][i].first));\n    }\n  }\n  while(!que.empty()){\n    u = que.top(); que.pop();\n    //cout << u.pos << ' ' << u.v << ' ' << u.pre << ' ' << u.time << endl;\n    if(vis[u.pre][u.pos][u.v] < u.time) continue;\n    vis[u.pre][u.pos][u.v] = u.time;\n    if(u.pos == g && u.v == 1){\n      printf(\"%.5f\\n\", u.time);\n      return;\n    }\n    for(int i=0;i<n;i++){\n      if(edge[u.pos][i].first == INF) continue;\n      if(u.pre == i) continue;\n      for(int k=-1;k<=1;k++){\n        if(u.v + k > edge[u.pos][i].second) continue;\n        if(u.v + k <= 0) continue;\n        v = State(i, u.v + k, u.pos, u.time + edge[u.pos][i].first / (double)(u.v + k));\n        //cout << '\\t' << v.pos << ' ' << v.v << ' ' << v.pre << ' ' << v.time << ' ' << vis[v.pre][v.pos][v.v] << endl;\n        if(vis[v.pre][v.pos][v.v] > v.time && 1){\n          vis[v.pre][v.pos][v.v] = v.time;\n          que.push(v);\n        }\n      }\n    }\n  }\n  printf(\"unreachable\\n\");\n}\n\nmain(){\n  while(scanf(\"%d%d\", &n, &m) && (n|m)){\n    scanf(\"%d%d\", &s, &g);\n    s--; g--;\n    fill(edge[0], edge[30], P(INF, 0));\n    for(int i=0;i<m;i++){\n      int a, b, c, d;\n      scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n      a--; b--;\n      edge[a][b] = edge[b][a] = P(c, d);\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nint n, m, s, g;\nstruct edge\n{\n    int to, dist, limit;\n    edge(int to, int dist, int limit) : to(to), dist(dist), limit(limit) {};\n};\nstruct info\n{\n    double nt;\n    int to, v, pre;\n    info(double nt, int to, int v, int pre) : nt(nt), to(to), v(v), pre(pre) {};\n};\nbool operator<(const info &a, const info &b) { return a.nt > b.nt; }\ndouble solve(vector<edge> G[])\n{\n    priority_queue<info> que;\n    que.push(info(0.0, s, 1, 0));\n    double memo[40][40][40];\n    for(int i = 0; i < 40; i++) for(int j = 0; j < 40; j++) for(int k = 0; k < 40; k++) memo[i][j][k] = INF;\n    memo[s][1][0] = 0.0;\n    while(que.size())\n    {\n        info p = que.top(); que.pop();\n        //cout << p.nt << \" \" << p.to << \" \" << p.v << \" \" << p.pre << endl;\n        if(p.to == g && p.v == 1) return p.nt;\n        for(int u = 0; u < G[p.to].size(); u++)\n        {\n            edge e = G[p.to][u];\n            if(p.pre == e.to) continue;\n            if(p.to == s && p.nt == 0.0)\n            {\n                memo[e.to][p.v][p.to] = e.dist / (double)p.v;\n                que.push(info(memo[e.to][p.v][p.to], e.to, p.v, p.to));\n                continue;\n            }\n            for(int d = -1; d <= 1; d++)\n            {\n                if(p.v + d == 0 || p.v + d > e.limit) continue;\n                double t = e.dist / (double)(p.v + d);\n                if(memo[p.to][p.v][p.pre] + t < memo[e.to][p.v + d][p.to])\n                {\n                    memo[e.to][p.v + d][p.to] = memo[p.to][p.v][p.pre] + t;\n                    que.push(info(memo[e.to][p.v + d][p.to], e.to, p.v + d, p.to)); \n                }\n            }\n        }\n    }\n    return -1.0;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(5);\n    while(cin >> n >> m, n | m)\n    {\n        cin >> s >> g;\n        vector<edge> G[n + 1];\n        for(int i = 0; i < m; i++)\n        {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            G[x].push_back(edge(y, d, c));\n            G[y].push_back(edge(x, d, c));\n        }\n        double ans = solve(G);\n        if(ans == -1.0) cout << \"unreachable\" << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\nnamespace ShortestPath{\n    typedef double Cost;\n    const Cost CINF=1e18;\n    typedef  vector<vector<Cost> > Mat;\n    struct Edge{\n        int from,to;Cost cost;int Mc;\n        Edge(int from,int to,Cost cost,int Mc)\n            : from(from),to(to),cost(cost),Mc(Mc) {};\n    };\n    ostream& operator <<(ostream& os,const Edge& e){\n            os<<\"(\"<<e.from<<\"->\"<<e.to<<\")\";\n            return os;\n    }\n    typedef vector<vector<Edge> > Graph;\n\n    struct Task{\n        int prev,pos;Cost cost;\n        Task(int prev,int pos,Cost cost)\n            :prev(prev),pos(pos),cost(cost){};\n        bool operator>(const Task& r) const{\n            return cost>r.cost;\n        }\n    };\n \n    // 最大も可\n    // 負の閉路が判定可能\n    //O(V*E)\n    vector<Cost> bellmanFord(Graph g,int s,vector<int>& prev){\n        const int V=g.size();\n        vector<Cost> d(V,CINF);d[s]=0;\n        fill(ALL(prev),-2);\n        REP(k,V){\n            REP(i,V)REP(j,g[i].size()){\n                Edge& e=g[i][j];\n                if(d[e.to]>d[e.from]+e.cost){\n                    d[e.to]=d[e.from]+e.cost;\n                    prev[e.to]=e.from;\n                    if(k==V-1)d[e.to]=-CINF;\n                }\n            }\n        }\n        return d;\n    }\n\n\tint dec_pos(int c){\n\t\treturn c/31;\n\t}\n\n    //verified by codoforces 144D http://codeforces.com/contest/144/submission/4976825\n    // // 負の辺がない\n    // // O(E*logV)\n    vector<Cost> dijkstra(const Graph& g,const int s,vector<int>& prev){\n        const int V=g.size();\n        vector<Cost> d(V,CINF);d[s]=0;\n        fill(ALL(prev), -2);\n        priority_queue<Task,vector<Task>,greater<Task> > que;\n        que.push(Task(-1,s,0));\n        while(!que.empty()){\n            Task task=que.top();que.pop();\n            //if(prev[task.pos]!=-2)continue;\n            if(d[task.pos]<task.cost)continue;\n            prev[task.pos]=task.prev;\n            EACH(e,g[task.pos]){\n            \tif(dec_pos(e->to)==dec_pos(task.prev))continue;// not U ターン\n                if(d[e->to]>d[e->from]+e->cost){\n                    d[e->to]=d[e->from]+e->cost;\n                    que.push(Task(e->from,e->to,d[e->to]));\n                }\n            }   \n        }\n        return d;\n    }\n    vector<Cost> dijkstra(const Graph& g,const int s){\n        vector<int> prev(g.size());return dijkstra(g,s,prev);\n    }\n}\n\nusing namespace ShortestPath;\n\nclass Main{\n\tpublic:\n\n\tint enc(int pos,int V){\n\t\treturn pos*31+V;\n\t}\n\tint dec_pos(int c){\n\t\treturn c/31;\n\t}\n\tint dec_v(int c){\n\t\treturn c%31;\n\t}\n\n\tvoid run(){\n\t//\tifstream cin(\"in\");\n\t//\tofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tint N,M;nextInt(N);nextInt(M);\n\t\t\tif(N==0)break;\n\t\t\tint s,g;nextInt(s);nextInt(g);s--;g--;\n\t\t\tGraph G(N*31);\n\t\t\tREP(i,M){\n\t\t\t\tint x,y;double d;int c;nextInt(x);nextInt(y);nextDouble(d);nextInt(c);x--;y--;\n\t\t\t\t// V\n\t\t\t\tfor(int v=1;v<=c && v<=30;v++)G[enc(x,v)].push_back(Edge(enc(x,v),enc(y,v),d/v,c));\n\t\t\t\tfor(int v=1;v<=c && v<=30;v++)G[enc(y,v)].push_back(Edge(enc(y,v),enc(x,v),d/v,c));\n\t\t\t\t// V++ スタートを考えるとv=0\n\t\t\t\tfor(int v=0;v+1<=c && v<=30;v++)G[enc(x,v)].push_back(Edge(enc(x,v),enc(y,v+1),d/(v+1),c));\n\t\t\t\tfor(int v=0;v+1<=c && v<=30;v++)G[enc(y,v)].push_back(Edge(enc(y,v),enc(x,v+1),d/(v+1),c));\n\t\t\t\t// V--\n\t\t\t\tfor(int v=2;v-1<=c && v<=30;v++)G[enc(x,v)].push_back(Edge(enc(x,v),enc(y,v-1),d/(v-1),c));\n\t\t\t\tfor(int v=2;v-1<=c && v<=30;v++)G[enc(x,v)].push_back(Edge(enc(y,v),enc(x,v-1),d/(v-1),c));\n\t\t\t}\n\t\t\tvector<Cost> res=dijkstra(G,enc(s,0));\n\t\t\tif(res[enc(g,1)]==CINF) cout <<\"unreachable\"<<endl;\n\t\t\telse cout << res[enc(g,1)]<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<vector>\n#define INF 1e10\n#define EPS 1e-10\nusing namespace std;\nstruct edge{\n  int to,limit;\n  double dist;\n};\nvector<edge> G[100];\ndouble d[40][100];\nbool used[40][100];\ntypedef pair<int,int> pii; //to,speed\ntypedef pair<double,pii> P;//cost,to,speed\n\ndouble dikstra(int s,int g){\n  int ds[3]={-1,0,1};\n  priority_queue<P,vector<P>,greater<P> > que;\n  for(int i=0;i<40;i++)\n    for(int j=0;j<100;j++)\n      d[i][j]=INF;\n  memset(used,0,sizeof(used));\n  d[0][s]=0;\n  que.push(P(0,pii(s,0)));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int speed=p.second.second;\n    int v=p.second.first;\n    double cost=p.first;\n    //cout << v << \";\" << speed <<\":\" << cost << endl;\n    if(d[speed][v]<cost)continue;\n    for(int i=0;i<G[v].size();i++){\n      for(int j=0;j<3;j++){\n\tedge e=G[v][i];\n\tint ns=speed+ds[j];\n\tif(1<=ns && ns<= e.limit &&\n\t   used[ns][e.to]==false){\n\t  used[ns][e.to]=true;\n\t  que.push(P(cost+e.dist/ns,pii(e.to,ns)));\n\t  if(d[ns][e.to]>cost+e.dist/ns){\n\t    d[ns][e.to]=cost+e.dist/ns;\n\t    //cout << \"d[\" << ns << \"][\" << e.to << \"]:\" << d[ns][e.to] << endl;\n\t    //cout << \"d[\" << v << \"]:\" << d[speed][v] << \" speed:\" << speed<< endl;\n\t  }\n\t}\n      }\n    }\n  }\n  if(d[1][g]==INF)return -1;\n  return d[1][g];\n}\n\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n){\n    for(int i=0;i<100;i++)G[i].clear();\n    cin>>s>>g;\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      G[x].push_back((edge){y,c,d});\n      G[y].push_back((edge){x,c,d});\n    }\n    double ans=dikstra(s,g);\n    if(ans==-1)cout << \"unreachable\" << endl;\n    else printf(\"%lf\\n\",ans);\n    // for(int i=0;i<=n;i++)\n    // \tcout << i << \" \" << d[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n/** Problem1162 : Discrete Speed **/\nconst int MAX_V = 30, MAX_C = 31;\nint N, M;\ndouble d[MAX_V][MAX_C];\n\nstruct Node {\n\tint c, v, prev; double time;\n\tNode (double _t, int _v, int _c, int _p) : v(_v), c(_c), time(_t), prev(_p){}\n\tbool operator<(const Node &n)const{return time>n.time;}\n};\n\nstruct Edge {\n\tint to, cost, lim;\n\tEdge(int t, int c, int l) :  to(t), cost(c), lim(l){}\n};\nvector<Edge> G[MAX_V];\n\nint tmp[] = {-1, 0, 1};\n\nvoid dijkstra(int s)\n{\n\tpriority_queue<Node> Q;\n\t\n\tfill(d[0], d[0]+MAX_V*MAX_C, INF);\n\td[s][1] = d[s][0] = 0;\n\tQ.push(Node(0, s, 0, -1));\n\t\n\twhile (Q.size()) {\n\t\tNode n = Q.top(); Q.pop();\n\t\tint v = n.v, c = n.c;\n\t\t//cerr << \"(\" << v+1 << \", \" << c << \", \" << n.time << \")\" << endl;\n\t\t\n#if 0\n\t\tbool ok=true;\n\t\tfor (int cc=0; cc<c; cc++) {\n\t\t\tif (d[v][cc] < n.time) ok=false;\n\t\t}\n\t\tif (!ok) continue;\n#endif\n\t\tif (d[v][c] < n.time) continue;\n\t\t\n\t\tfor (int i=0; i<G[v].size(); i++) {\n\t\t\tEdge e = G[v][i];\n\t\t\t\n\t\t\tfor (int j=0; j<3; j++) {\n\t\t\t\tint nc = c+tmp[j];\n\t\t\t\tif (nc>G[v][i].lim || e.to == n.prev) continue;\n\n\t\t\t\tif (0<nc && nc<=30) {\n\t\t\t\t\tif (d[e.to][nc] > d[v][c] + (double)e.cost/nc) {\n\t\t\t\t\t\td[e.to][nc] = d[v][c] + (double)e.cost/nc;\n\t\t\t\t\t\tQ.push(Node(d[e.to][nc], e.to, nc, v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (cin>>N>>M, N||M) {\n\t\trep(i, MAX_V) G[i].clear();\n\t\tint s, g; cin>>s>>g; s--, g--;\n\t\t\n\t\trep(i, M) {\n\t\t\tint x, y, d, c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tG[x-1].push_back(Edge(y-1, d, c));\n\t\t\tG[y-1].push_back(Edge(x-1, d, c));\n\t\t}\n\t\t\n\t\tdijkstra(s);\n\t\t\n\t\tdouble ans = d[g][1];\n\t\t\n\t\tif (ans < INF) {\n\t\t\tcout << fixed << setprecision(10);\n\t\t\tcout << ans << endl;\n\t\t} else {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint dv[] = {-1, 0, 1};\n\nstruct state {\n  int city;\n  int from;\n  double cost;\n  int v;\n};\n\nbool operator<(const state &a, const state &b){return a.cost > b.cost;}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n, m;\n\n  while(cin >> n >> m, n) {\n    int s, g;\n    cin >> s >> g;\n    s--; g--;\n\n    int d[n][n] = {}, limit[n][n] = {};\n    rep(i, m) {\n      int x, y;\n      cin >> x >> y;\n      x--, y--;\n      cin >> d[x][y] >> limit[x][y];\n      d[y][x] = d[x][y];\n      limit[y][x] = limit[y][x];\n    }\n\n    priority_queue<state> q;\n    bool visited[n][n][30] = {};\n    q.push(state{s, s, 0, 0});\n    double ans = INF;\n    while(!q.empty()) {\n      state st = q.top(); q.pop();\n      if (st.city == g && st.v == 1) {\n        ans = st.cost;\n        break;\n      }\n\n      if (visited[st.city][st.from][st.v]) continue;\n      else visited[st.city][st.from][st.v] = true;\n\n      rep(i, n) {\n        if (d[st.city][i] != 0 && i != st.from) {\n          rep(j, 3) {\n            if (st.v+dv[j] > 0 && st.v+dv[j] <= limit[st.city][i] && !visited[i][st.city][st.v+dv[j]]) {\n              q.push(state{i, st.city, st.cost+(double)d[st.city][i]/(st.v+dv[j]), st.v+dv[j]});\n            }\n          }\n        }\n      }\n    }\n    if (ans != INF) {\n      printf(\"%.5f\\n\", ans);\n    } else {\n      print(\"unreachable\");\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 6/15 8:57 ~ 920 1129\n */\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#define INF 2000000\n\nusing namespace std;\n\nstruct edge {\n  int to;\n  double cost;\n};\ntypedef pair<int, int> P;\n\nint iN;\nint iM;\nint iS;\nint iG;\nvector<edge> G[31 * 31];\ndouble d[31 * 31][31];\n\nbool input() {\n  int i, j;\n  int x, y, d, c;\n  edge e;\n\n  scanf(\"%d %d\", &iN, &iM);\n  if (iN == 0 && iM == 0)\n    return false;\n  scanf(\"%d %d\", &iS, &iG);\n\n  for (i = 0; i < (iN + 1) * 31; i++) {\n    G[i].clear();\n  }\n\n  for (i = 0; i < iM; i++) {\n    scanf(\"%d %d %d %d\", &x, &y, &d, &c);\n    for (j = 1; j <= c; j++) {\n      e.cost = (double) d / j;\n      e.to = y * 31 + j;\n      G[x * 31 + j].push_back(e);\n      G[x * 31 + j - 1].push_back(e);\n      if (j + 1 <= c)\n        G[x * 31 + j + 1].push_back(e);\n      e.to = x * 31 + j;\n      G[y * 31 + j].push_back(e);\n      G[y * 31 + j - 1].push_back(e);\n      if (j + 1 <= c)\n        G[y * 31 + j + 1].push_back(e);\n    }\n  }\n  return true;\n}\n\nvoid dijkstraQueue() {\n  int i, j;\n  priority_queue<P, vector<P> , greater<P> > que;\n\n  fill(d[0], d[0] + (iN + 1) * 31 * 31, INF);\n  d[iS * 31 + 0][0] = 0;\n  que.push(P(0, iS * 31 + 0));\n\n  while (!que.empty()) {\n    P p = que.top();\n    que.pop();\n    int v = p.second;\n    //printf(\"%d %d\\n\", v / 31, v % 31);\n    for (j = 0; j < iN; j++) {\n      if (d[v][j] < p.first)\n        continue;\n      for (i = 0; i < (int) G[v].size(); i++) {\n        edge e = G[v][i];\n        //printf(\"%f\\n\", e.cost);\n        if (d[e.to][v / 31] > d[v][j] + e.cost) {\n          d[e.to][v / 31] = d[v][j] + e.cost;\n          que.push(P(d[e.to][v / 31], e.to));\n        }\n      }\n    }\n  }\n}\n\nvoid output() {\n  int i;\n  double out;\n  out = d[(iG - 1) * 31 + 1][1];\n  for (i = 2; i < 31; i++) {\n    out = min(out, d[(iG - 1) * 31 + 1][i]);\n  }\n  if (out == INF)\n    printf(\"unreachable\\n\");\n  else\n    printf(\"%f\\n\", out);\n}\n\nint main() {\n  while(1) {\n    if (!input()) break;\n    dijkstraQueue();\n    output();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n \nusing namespace std;\n \nconst int MAX = 50;\nconst int INF = (1<<25);\nint n,m;\nstruct Edge{\n  int to;\n  double dis,lim;\n  Edge(int a, double b, double c){\n    to = a;\n    dis = b;\n    lim = c;\n  }\n};\n \nstruct State{\n  int pos,from;\n  double speed,t;\n  State(int a, double b, double c, int f){\n    pos = a;\n    speed = b;\n    t = c;\n    from = f;\n  }\n  bool operator < (const State& s) const{ return t > s.t;}\n};\n \nvector<Edge> E[MAX];\ndouble T[MAX][MAX];\n//T[i][j] := shortest time to i with speed j.\n \n \nvoid init(){\n  for(int i = 0; i < MAX; i++){\n    fill(T[i],T[i]+MAX,INF);\n    E[i].clear();\n  }\n}\n \nvoid input(){\n  for(int i = 0; i < m; i++){\n    int x,y;\n    double d,c;\n    cin >> x >> y >> d >> c;\n    //   cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    E[x].push_back(Edge(y,d,c));\n    E[y].push_back(Edge(x,d,c));\n  }\n}\n \nvoid solve(int s, int g){\n \n  priority_queue<State> Q;\n  T[s][0] = 0;\n  Q.push(State(s,0,0,-1));\n \n  while(!Q.empty()){\n    State s = Q.top();\n    Q.pop();\n \n    if(s.t > T[s.pos][(int)s.speed]) continue;\n \n    for(int i = 0; i < E[s.pos].size(); i++){\n      int np = E[s.pos][i].to;\n \n      if(np == s.from) continue;\n \n      double sp[] = {-1,0,1};\n       \n      for(int j = 0; j < 3; j++){\n    double ns = s.speed+sp[j];\n    if(ns <= 0 || ns > E[s.pos][i].lim) continue;\n    double nt = s.t+E[s.pos][i].dis/ns;\n    if(T[np][(int)ns] > nt){\n      T[np][(int)ns] = nt;\n      Q.push(State(np,ns,nt,s.pos));\n    }\n      }\n    }\n  }\n   \n \n  if(T[g][1] == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.6f\\n\",T[g][1]);\n}\n \nint main(){\n   \n  while(cin >> n >> m && n+m){\n    init();\n    int s,g;\n    cin >> s >> g;\n    input();\n    solve(s,g);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nint n,m;\nint st,gl;\ndouble dp[35][35];\n\nint ds[35][35];\nint rs[35][35];\n\ntypedef pair<double,mp> dmp;\n\nint main(void){\n\tfor(;;){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0)break;\n\t\tscanf(\"%d%d\",&st,&gl);\n\t\tmemst(ds,-1);\n\t\tmemst(rs,-1);\n\t\trep(i,m){\n\t\t\tint a,b,c,d;\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\tds[a][b]=ds[b][a]=c; \n\t\t\trs[a][b]=rs[b][a]=d; \n\t\t}\n\t\t\n\t\trep(i,35)rep(j,35)dp[i][j]=1e10;\n\t\t\n\t\tpque(dmp) que;\n\t\tque.push(dmp(0,mp(st,0)));\n\t\tdouble ans=-1;\n\t\twhile(!que.empty()){\n\t\t\tdmp pa=que.top();\n\t\t\tque.pop();\n\t\t\tdouble t=pa.fir;\n\t\t\tint no=pa.sec.fir,\n\t\t\t\tnv=pa.sec.sec;\n\t\t\tif(dp[no][nv]<=t)continue;\n\t\t\tdp[no][nv]=t;\n\t\t\tif(no==gl && nv==1){\n\t\t\t\tans=t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treg(tv,max(nv-1,1),nv+1){\n\t\t\t\trep(to,35){\n\t\t\t\t\tif(ds[no][to]<0)continue;\n\t\t\t\t\tif(rs[no][to]<tv)continue;\n\t\t\t\t\tdouble tt=t+ds[no][to]/((double)tv);\n\t\t\t\t\tif(dp[to][tv]<=tt)continue;\n\t\t\t\t\tque.push(dmp(tt,mp(to,tv)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans<0)printf(\"unreachable\\n\");\n\t\telse printf(\"%lf\\n\",ans);\n\t}\n\t\t\n\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef pair<double, int>DI;\ntypedef pair<int, int>II;\ntypedef pair<DI, II>DIII;\n\ndouble dp[33][33][33];\nvector<int>path[33];\nint length[33][33];\nint limit[33][33];\nvoid init(){\n    for(int i = 0; i < 33; i++){\n        for(int j = 0; j < 33; j++){\n            for(int k = 0; k < 33; k++){\n                dp[i][j][k] = 5000;\n            }\n            length[i][j] = -1;\n            limit[i][j] = -1;\n        }\n        path[i].clear();\n    }\n}\n\nint main(){\n\n    for(int n, m, s, g; cin >> n >> m, n;){\n        cin >> s >> g;\n        init();\n        for(int i = 0; i < m; i++){\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            path[x].push_back(y);\n            length[x][y] = d;\n            limit[x][y] = c;            \n            path[y].push_back(x);\n            length[y][x] = d;\n            limit[y][x] = c;            \n        }\n        priority_queue<DIII, vector<DIII>, greater<DIII> >Q;\n        Q.push(DIII(DI(0, 1), II(s, -1)));\n        double ans = -1;\n        while(!Q.empty()){\n            double cost = Q.top().first.first;\n            int v = Q.top().first.second;\n            int now = Q.top().second.first;\n            int pre = Q.top().second.second;\n            Q.pop();\n            if(dp[v][now][pre] < 4900)continue;\n            dp[v][now][pre] = cost;\n            // cout << \"cost[\"<< v << \"][\" << now << \"][\" << pre << \"] -> \" << cost << endl;\n            if(now == g && v==0){\n                ans = cost;\n                break;\n            }\n            if(v == 0)continue;\n            for(int i = 0; i < path[now].size(); i++){\n                int nxt = path[now][i];\n                if(nxt == pre)continue;\n                if(limit[now][nxt] < v)continue;\n                double tim = (double)length[now][nxt] / v;\n                for(int dv = -1; dv <= 1; dv++){\n                    if(dp[v + dv][nxt][now] >= cost + tim){\n                        Q.push(DIII(DI(cost + tim, v + dv), II(nxt, now)));\n                    }\n                }\n            }\n        }\n        if(ans < 0)cout << \"unreachable\" << endl;\n        else printf(\"%.9f\\n\", ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vd = std::vector<double>;\n\tusing v2d = std::vector<vd>;\n\tusing v3d = std::vector<v2d>;\n\t\n\tusing i3 = std::array<int, 3>;\n\tusing vi3 = std::vector<i3>;\n\tusing v2i3 = std::vector<vi3>;\n\n\tusing pdi3 = std::pair<double, i3>;\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n == 0 && m == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tint s, g;\n\t\tscanf(\"%d%d\", &s, &g);\n\t\ts--; g--;\n\n\t\t// from->{to, distance, limit}\n\t\tv2i3 edge(n);\n\t\tfor (int i{}; i < m; i++)\n\t\t{\n\t\t\tint x, y, d, c;\n\t\t\tscanf(\"%d%d%d%d\", &x, &y, &d, &c);\n\t\t\tx--; y--;\n\t\t\tedge[x].push_back({y, d, c});\n\t\t\tedge[y].push_back({x, d, c});\n\t\t}\n\n\t\t// distance[頂点][来た速度][来た頂点] = 最短距離\n\t\tv3d distance(n, v2d(31, vd(n, 1e9)));\n\t\tfor (auto& e: distance[s][0]) e = 0;\n\t\t// {距離、{頂点、来た速度、来た頂点}\n\t\tstd::priority_queue<pdi3, std::vector<pdi3>, std::greater<pdi3>> dij;\n\t\tdij.push({0, {s, 0, 0}});\n\t\twhile (!dij.empty())\n\t\t{\n\t\t\tdouble now_dist{dij.top().first};\n\t\t\tint now_city{dij.top().second[0]}, now_velo{dij.top().second[1]}, now_from{dij.top().second[2]};\n\t\t\tdij.pop();\n\t\t\tif (now_dist > distance[now_city][now_velo][now_from])\n\t\t\t\tcontinue;\n\t\t\tif (now_city == g && now_velo == 1) break;\n\n\t\t\tfor (auto& road: edge[now_city])\n\t\t\t{\n\t\t\t\tif (road[0] == now_from) continue;\n\t\t\t\tfor (int add{-1}; add <= 1; add++)\n\t\t\t\t{\n\t\t\t\t\t// {to, velocity, from}\n\t\t\t\t\ti3 next_vertex{road[0], now_velo + add, now_city};\n\t\t\t\t\tif (next_vertex[1] <= 0 || road[2] < next_vertex[1]) continue;\n\t\t\n\t\t\t\t\tdouble next_dist{now_dist + (double)road[1] / next_vertex[1]};\n\t\t\t\t\tauto& table_dist{distance[next_vertex[0]][next_vertex[1]][next_vertex[2]]};\n\t\t\t\t\tif (next_dist >= table_dist) continue;\n\n\t\t\t\t\ttable_dist = next_dist;\n\t\t\t\t\tdij.push({next_dist, next_vertex});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble min{*std::min_element(distance[g][1].begin(), distance[g][1].end())};\n\t\tif (min == 1e9) puts(\"unreachable\");\n\t\telse printf(\"%.4lf\\n\", min);\n\t}\n\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 35\n#define INF 1e9\n#define F first\n#define S second\ntypedef pair<double,int> pdi;\ntypedef pair<pdi,int> State;\n\nstruct Edge{\n  int to,d,c;\n  Edge(int to,int d,int c) : to(to),d(d),c(c) {}\n};\n\nint N,M,s,g;\nvector<Edge> G[MAX];\n\ndouble dijkstra(){\n  priority_queue<State,vector<State>,greater<State> > Q;\n  Q.push(State(pdi(0,s),1));\n  double Time[MAX][MAX];\n  fill(Time[0],Time[0]+MAX*MAX,INF);\n  Time[s][1] = 0;\n\n  while(!Q.empty()){\n    State p = Q.top(); Q.pop();\n    int v = p.F.S, vel = p.S;\n    if(Time[v][vel] < p.F.F) continue;\n\n    if(v == g && vel == 1){\n      return Time[g][1];\n    }\n\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      for(int j = -1 ; j <= 1 ; j++){\n        if(vel+j <= 0) continue;\n        if(Time[v][vel] == 0){\n          if(j == -1 || j == 1) continue;\n        }\n        Edge e = G[v][i];\n        double t = (double)e.d/(vel+j);\n        if(vel+j <= e.c && \n           Time[v][vel] + t < Time[e.to][vel+j]){\n          Time[e.to][vel+j] = Time[v][vel] + t;\n          Q.push(State(pdi(Time[e.to][vel+j],e.to),vel+j));\n        }\n      }\n    }\n  }\n  return INF;\n}\n\nint main(){\n  int x,y,d,c;\n  while(cin >> N >> M, N){\n    for(int i = 0 ; i < MAX ; i++){\n      G[i].clear();\n    }\n    cin >> s >> g; s--; g--;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> d >> c;\n      x--; y--;\n      G[x].push_back(Edge(y,d,c));\n      G[y].push_back(Edge(x,d,c));\n    }\n    double res = dijkstra();\n    if(res == INF){\n      cout << \"unreachable\" << endl;\n    }else{\n      printf(\"%.8f\\n\",res);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define EPS 1e-8\n \nstruct P{\n  double t;\n  char v,p,pre;\n  P(double T=0.0,int V=0,int pp=0,int PRE=0){\n    t=T;v=V;p=pp;pre=PRE;\n  };\n  bool operator<(const P &p)const{\n    return t>p.t;\n  }\n};\nstruct Path{\n  char d,c;\n  Path(int D=0,int C=0){ d=D;c=C;};\n};\n \nint main(){\n  int n,m, s,g, x,y,d,c;\n  Path path[30][30];\n\n \n  while( cin>>n>>m && (n|m) ){\n    cin >> s >> g;\n    s--; g--;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tpath[i][j].d=-1.0; path[i][j].c=-1;\n      }\n \n    for( int i=0;i<m;i++ ){\n      cin >> x >> y >> d >> c;\n      x--;y--;\n      path[x][y].d=d; path[x][y].c=c;\n      path[y][x] = path[x][y];\n    }\n \n    double cost[30][35][30]; // place,velocity, pre\n    int dv[3] = {1,0,-1};\n    for( int i=0;i<n;i++ )\n      for( int j=1;j<31;j++ )\n\tfor( int k=0;k<n;k++ )\n\t  cost[i][j][k] = DBL_MAX;\n\n    priority_queue<P> q;//    while( !q.empty() ) q.pop();\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      q.push( P(path[s][i].d,1,i,s) );//t ,v, np, pre\n      cost[i][1][s] = path[s][i].d;\n    }\n\n    double ans = DBL_MAX; \n    while( !q.empty() ){\n      P p = q.top(); q.pop();\n      double t = p.t;\n      int v=p.v, np=p.p, pre=p.pre;\n      if( np==g && v==1 ){\n\tans = t;\n\tbreak;\n      }\n \n      for( int i=0;i<n;i++ ){\n\tif( path[np][i].c<0 ) continue;// たどり着けないノード\n\tif( i==pre ) continue; // 前回のノード\n\t\n\tfor( int j=0;j<3;j++ ){\n\t  int nv = v + dv[j];\n\t  if( nv==0 || nv>path[np][i].c )    continue;\n\t  double nCost = t + (double)path[np][i].d/nv;\n\t  if( nCost>cost[g][1][np] || fabs(nCost-cost[g][1][np])<EPS ) continue;\n\t  if( cost[i][nv][np] < nCost ) continue;\n\t  if( fabs(cost[i][nv][np]-nCost)<EPS ) continue;\n\t  cost[i][nv][np]=nCost;\n\t  \n\t  q.push( P(nCost,nv,i,np) );\n\t}\n      }\n      \n    }\n    if( fabs(ans-DBL_MAX)<EPS )\n      cout << \"unreachable\" << endl;\n    else\n      printf(\"%.6lf\\n\",ans);\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstruct P {\n\tint to, c, d;\n};\nvector<P>E[30];\ndouble d[30][31][30];\n\nstruct st {\n\tint p, h, pr; double c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tint s, g; scanf(\"%d%d\", &s, &g); s--; g--;\n\t\trep(i, n)E[i].clear();\n\t\trep(i, m) {\n\t\t\tint x, y, d, c; scanf(\"%d%d%d%d\", &x, &y, &d, &c); x--; y--;\n\t\t\tE[x].push_back({ y,c,d }); E[y].push_back({ x,c,d });\n\t\t}\n\t\tpriority_queue<st>que;\n\t\tfill(d[0][0], d[30][0], INF);\n\t\tfor (P v : E[0]) {\n\t\t\td[v.to][1][0] = v.d; que.push({ v.to,1,0,d[v.to][1][0] });\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.p][p.h][p.pr] != p.c)continue;\n\t\t\tfor (P v : E[p.p]) {\n\t\t\t\tif (v.to == p.pr)continue;\n\t\t\t\tif (p.h > 1) {\n\t\t\t\t\tif (d[v.to][p.h - 1][p.p] > p.c + v.d / double(p.h - 1)) {\n\t\t\t\t\t\td[v.to][p.h - 1][p.p] = p.c + v.d / double(p.h - 1);\n\t\t\t\t\t\tque.push({ v.to,p.h - 1,p.p,d[v.to][p.h - 1][p.p] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (p.h < v.c) {\n\t\t\t\t\tif (d[v.to][p.h + 1][p.p] > p.c + v.d / double(p.h + 1)) {\n\t\t\t\t\t\td[v.to][p.h + 1][p.p] = p.c + v.d / double(p.h + 1);\n\t\t\t\t\t\tque.push({ v.to,p.h + 1,p.p,d[v.to][p.h + 1][p.p] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (p.h <= v.c) {\n\t\t\t\t\tif (d[v.to][p.h][p.p] > p.c + v.d / double(p.h)) {\n\t\t\t\t\t\td[v.to][p.h][p.p] = p.c + v.d / double(p.h);\n\t\t\t\t\t\tque.push({ v.to,p.h,p.p,d[v.to][p.h][p.p] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble Min = INF;\n\t\trep(i, n)Min = min(Min, d[g][1][i]);\n\t\tif (Min == INF)puts(\"unreachable\");\n\t\telse printf(\"%.7lf\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nconst int MAX = 35;\nconst int INF = (1<<25);\nint n,m;\n\nstruct Edge{\n  int to;\n  double dis,lim;\n  Edge(int a, double b, double c):to(a),dis(b),lim(c){}\n};\n\nstruct State{\n  int pos,from;\n  double speed,t;\n  State(int a, double b, double c, int f):pos(a),speed(b),t(c),from(f){}\n  bool operator < (const State& s) const{ return t > s.t;}\n};\n\nvector<Edge> E[MAX];\ndouble T[MAX][MAX][MAX];\n//T[i][j][k] := shortest time from i to j with speed k.\n\n\nvoid init(){\n  for(int i = 0; i < MAX; i++){\n    for(int j = 0; j < MAX; j++)\n      for(int k = 0; k < MAX; k++) T[i][j][k] = INF;\n    E[i].clear();\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++){\n    int x,y;\n    double d,c;\n    cin >> x >> y >> d >> c;\n    //   cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    E[x].push_back(Edge(y,d,c));\n    E[y].push_back(Edge(x,d,c));\n  }\n}\n\nvoid solve(int s, int g){\n\n  priority_queue<State> Q;\n  T[0][s][0] = 0;\n  Q.push(State(s,0,0,0));\n\n  while(!Q.empty()){\n    State sta = Q.top();\n    Q.pop();\n\n    if(sta.t > T[sta.from][sta.pos][(int)sta.speed]) continue;\n\n    for(int i = 0; i < E[sta.pos].size(); i++){\n      int np = E[sta.pos][i].to;\n\n      if(np == sta.from) continue;\n\n      double sp[] = {-1,0,1};\n      \n      for(int j = 0; j < 3; j++){\n\tdouble ns = sta.speed+sp[j];\n\tif(ns <= 0 || ns > E[sta.pos][i].lim) continue;\n\tdouble nt = sta.t+E[sta.pos][i].dis/ns;\n\tif(T[sta.pos][np][(int)ns] > nt){\n\t  T[sta.pos][np][(int)ns] = nt;\n\t  Q.push(State(np,ns,nt,sta.pos));\n\t}\n      }\n    }\n  }\n\n  double ans = INF;\n\n  for(int i = 0; i < MAX; i++)\n    ans = min(ans,T[i][g][1]);\n  \n\n  if(ans == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.5f\\n\",ans);\n}\n\nint main(){\n\n  while(cin >> n >> m && n+m){\n    init();\n    int s,g;\n    cin >> s >> g;\n    input();\n    solve(s,g);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nstruct Edge {\n  int from;\n  int to;\n  double dist;\n  int speed;\n  Edge() {;}\n  Edge(int f, int t, double d, int s) : from(f), to(t), dist(d), speed(s) {;}\n  bool operator<(const Edge &rhs) const { return dist > rhs.dist; }\n};\n\ndouble visit[40][40][40];\nvector<Edge> edge[40];\n\nint main() {\n  int n, m, s, g;\n  while (scanf(\"%d %d\", &n, &m), n|m) {\n    scanf(\"%d %d\", &s, &g);\n    s--; g--;\n    REP(i, n) { edge[i].clear(); }\n    REP(i, m) {\n      int f, t, c;\n      double d;\n      scanf(\"%d %d %lf %d\", &f, &t, &d, &c);\n      f--; t--;\n      edge[f].push_back(Edge(f, t, d, c));\n      edge[t].push_back(Edge(t, f, d, c));\n    }\n    priority_queue<Edge> que;\n    MEMSET(visit, false);\n    que.push(Edge(32, s, 0, 1));\n    while (!que.empty()) {\n      Edge node = que.top();\n      que.pop();\n      if (visit[node.from][node.to][node.speed]) { continue; }\n      visit[node.from][node.to][node.speed] = true;\n      if (node.to == g && node.speed == 0) {\n        printf(\"%.4lf\\n\", node.dist);\n        goto next;\n      }\n      if (node.speed == 0) { continue; }\n      int from = node.to;\n      REP(i, edge[from].size()) {\n        int to = edge[from][i].to;\n        FOREQ(s, -1, 1) {\n          int ns = node.speed + s;\n          if (to == node.from || visit[from][to][ns] || ns > edge[from][i].speed) { continue; }\n          double ndist = node.dist + edge[from][i].dist / (double)node.speed;\n          que.push(Edge(from, to, ndist, ns));\n        }\n      }\n    }\n    puts(\"unreachable\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <queue>\n#include <set>\nusing namespace std;\n\ndouble memo[32][32][32];\nchar\tvisited[32][32][32];\nint N,M,S,G;\nstruct e {\n\tint d,c;\n}edge[32][32];\n\nint main()\n{\n\tfor(;cin>>N>>M,N||M;){\n\t\tdouble inf = 9999999.0;\n\t\tfor(int i=0;i<32;i++)for(int j=0;j<32;j++)\n\t\t\tedge[i][j].d = edge[i][j].c = -1;\n\t\tfor(int i=0;i<32;i++)for(int j=0;j<32;j++)for(int k=0;k<32;k++)\n\t\t\tmemo[i][j][k]=inf, visited[i][j][k]=0;\n\t\t\n\t\tcin>>S>>G;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tedge[x][y].d = edge[y][x].d = d;\n\t\t\tedge[x][y].c = edge[y][x].c = c;\n\t\t}\n\n\t\tmemo[S][S][0] = 0.0;\n\t\twhile(1){\n\t\t\tint currentCity, prevCity, currentVelocity;\n\t\t\tdouble  currentTime = inf;\n\t\t\t\n\t\t\tfor(int i=1;i<=N;i++)\n\t\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\t\tfor(int k=0;k<=30;k++){\n\t\t\t\t\t\tif(visited[i][j][k] || currentTime < memo[i][j][k])continue;\n\t\t\t\t\t\tcurrentTime = memo[i][j][k];\n\t\t\t\t\t\tcurrentCity = i;\n\t\t\t\t\t\tprevCity = j;\n\t\t\t\t\t\tcurrentVelocity = k;\n\t\t\t\t\t}\n\t\t\tif(currentTime == inf){ puts(\"unreachable\"); break; }\n\t\t\tif(currentCity == G && currentVelocity == 1){\n\t\t\t\tprintf(\"%lf\\n\",currentTime);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tvisited[currentCity][prevCity][currentVelocity] = 1;\n\t\t\t\n\t\t\tfor(int nextVelocity=currentVelocity-1;nextVelocity<=currentVelocity+1;nextVelocity++){\n\t\t\t\tif(nextVelocity<=0)continue;\n\t\t\t\tfor(int next=1;next<=N;next++){\n\t\t\t\t\tif(edge[currentCity][next].d == -1 || next==prevCity)continue;\n\t\t\t\t\tif(edge[currentCity][next].c < nextVelocity)continue;\n\t\t\t\t\tmemo[next][currentCity][nextVelocity] = min( memo[next][currentCity][nextVelocity],\n\t\t\t\t\t\t\t\t\t\t\t\t\t (double)edge[currentCity][next].d/nextVelocity+currentTime);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nclass Node {\npublic:\n    double time;\n    int v, town, prev;\n    Node() {}\n    Node( double time_, int v_, int town_, int prev_ ) \n    {\n        time = time_;\n        v = v_;\n        town = town_;\n        prev = prev_;\n    }\n    bool operator > ( const Node& right ) const \n    {\n        return time == right.time ? v > right.v : time < right.time;\n    }\n    bool operator < ( const Node& right ) const\n    {\n        return time == right.time ? v < right.v : time > right.time;\n    }\n};\ntypedef priority_queue <Node> QUEUE;\nconst int size = 31;\nconst double eps = 1e-9;\nconst double inf = (double)(1<<24);\n\nint n, m;\n\n\nbool P[size][size];\ndouble G[size][size];\ndouble MC[size][size];\nint L[size][size];\nint CN[size][size];\nint CN_count[size];\n\nvoid solve( int start, int goal )\n{\n    // cout << \"sg: \" << start << \", \" << goal << endl; // debug\n    QUEUE Q;\n    Node start_node( 0.0, 1, start, -1 );\n    Q.push( start_node );\n    MC[1][start] = 0.0;\n\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        double time = node.time;\n        int v = node.v;\n        int town = node.town;\n        int prev = node.prev;\n        // cout << time << \",\" << v << \",\" << town << \",\" << prev << endl; // debug\n\n        if ( town == goal && v == 1 ) {\n            printf( \"%.5f\\n\", time );\n            return;\n        }\n\n        for ( int i = 0; i < CN_count[town]; i++ ) {\n            int next_town = CN[town][i];\n            if ( next_town == prev ) continue;\n            for ( int j = 1; j >= -1; j-- ) {\n                if ( prev == -1 && j != 0 ) continue;\n                int next_v = v + j;\n                if ( next_v <= 0 || next_v > L[town][next_town] ) continue;\n                double cost = (double)G[town][next_town] / next_v;\n                double next_time = time + cost;\n                int next_prev = town;\n\n                if ( next_time >= MC[next_v][next_town] ) continue;\n                MC[next_v][next_town] = next_time;\n                // cout << time << \": \" << town << \",\" << v << \",\" << prev << \" => \";\n                // cout << next_time << \": \" << next_town << \",\" << next_v << \",\" << next_prev << endl;\n                Node next_node( next_time, next_v, next_town, next_prev );\n                // cout << town << \" => \" << next_town << \": \" << next_time << \"(+\" << cost << \")\" << endl; // debug\n                Q.push( next_node );\n            }\n        }\n    }\n\n    cout << \"unreachable\" << endl;\n}\n\nint main( void )\n{\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        // init\n        for ( int i = 0; i < size; i++ ) {\n            CN_count[i] = 0;\n            for ( int j = 0; j < size; j++ ) {\n                P[i][j] = false;\n                MC[i][j] = inf;\n            }\n        }\n\n        // input\n        int s, g;\n        cin >> s >> g;\n        for ( int i = 0; i < m; i++ ) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n\n            P[x][y] = P[y][x] = true;\n            G[x][y] = G[y][x] = d;\n            L[x][y] = L[y][x] = c;\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( i == j ) continue;\n                if ( P[i][j] ) CN[i][CN_count[i]++] = j;\n            }\n        }\n\n        solve( s-1, g-1 );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define NODE 30\n#define LIM 31\nconst double inf = 1e200;\n\nclass state{\npublic:\n  int cur,prev,speed;\n  double c;\n  state(){};\n  state(int tcur,int tprev,int tspeed,double tc):cur(tcur),prev(tprev),\n\t\t\t\t\t\t speed(tspeed),c(tc){};\n  bool operator<(const state & a)const{\n    return c >a.c;\n  }\n};\n\ndouble cost[30][30][31];\ndouble dist[30][30];\nint lim[30][30];\nbool visited[30][30][31];\n\nvoid solve(int n,int s,int g){\n  rep(i,n)rep(j,n)rep(k,31)cost[i][j][k]=inf,visited[i][j][k]=false;\n  priority_queue<state> Q;\n  cost[0][0][1]=0;\n  rep(i,n){\n    if ( lim[s][i] >= 1){\n      cost[i][s][1]=dist[s][i];\n      Q.push(state(i,s,1,cost[i][s][1]));\n    }\n  }\n\n  while(!Q.empty()){\n    state now = Q.top();\n    Q.pop();\n    //cout << now.cur <<\" \" << now.prev<<\" \" << now.speed <<\" \"<< visited[now.cur][now.prev][now.speed] << \" \"<<\n    //  abs(cost[now.cur][now.prev][now.speed]-now.c)<<endl;\n    if ( cost[now.cur][now.prev][now.speed] <now.c){\n      //puts(\"test\");\n      continue;\n    }\n    //if ( visited[now.cur][now.prev][now.speed])continue;\n    visited[now.cur][now.prev][now.speed]=true;\n    if ( now.cur == g && now.speed == 1){\n      printf(\"%.3lf\\n\",now.c);\n      return;\n    }\n    rep(i,n){\n      if ( i == now.prev || i == now.cur)continue;\n      REP(j,-1,2){\n\tif ( now.speed + j > 0 && now.speed + j <= lim[now.cur][i] &&\n\t     cost[i][now.cur][now.speed+j] > now.c + dist[now.cur][i]/(now.speed+j)){\n\t  //cout <<\"advance \" << \n\t  //  i <<\" \" << now.cur <<\" \" << now.speed+j << \" \" << abs(cost[i][now.cur][now.speed+j]-now.c+dist[now.cur][i]/(now.speed+j))<<endl;\n\t  \n\t  cost[i][now.cur][now.speed+j]=now.c+dist[now.cur][i]/(now.speed+j);\n\t  Q.push(state(i,now.cur,now.speed+j,cost[i][now.cur][now.speed+j]));\n\t}\n      }\n    }\n  }\n  \n\n  puts(\"unreachable\");\n  \n}\n\n\nmain(){\n  int n,m;\n  while(cin>>n>>m && n){\n    rep(i,n)rep(j,n)lim[i][j]=0,dist[i][j]=inf;\n    int s,g;\n    cin>>s>>g;\n    s--;g--;\n    rep(i,m){\n      int f,t,v;\n      double d;\n      cin>>f>>t>>d>>v;\n      f--;t--;\n      dist[f][t]=dist[t][f]=d;\n      lim[f][t]=lim[t][f]=v;\n    }\n    solve(n,s,g);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\nstruct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n\nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\n// (time,speed,node,pre_node)\nusing P = pair<pair<double,int>,pair<int,int>>;\n\nP makeP(double t,int s,int n,int np){\n    return make_pair(make_pair(t,s),make_pair(n,np));\n}\n\nvoid solve(int n,int m){\n    int st,go; cin>>st>>go;\n    st--;\n    go--;\n    vector<vector<int>> g(n,vector<int>(n,INF));\n    vector<vector<int>> lim(n,vector<int>(n,0));\n    rep(i,m){\n        int x,y,d,c;\n        cin>>x>>y>>d>>c;\n        x--;\n        y--;\n        g[x][y] = d;\n        g[y][x] = d;\n        lim[x][y] = c;\n        lim[y][x] = c;\n    }\n\n    double visited[32][32][32];\n    rep(i,32) rep(j,32) rep(k,32) visited[i][j][k]=INF;\n\n    priority_queue<P,vector<P>,greater<P>> que;\n    que.push(makeP(0,0,st,st));\n    while(!que.empty()){\n        auto p = que.top();\n        que.pop();\n        double t = p.first.first;\n        int speed = p.first.second;\n        int v = p.second.first;\n        int pre = p.second.second;\n\n//        cerr << \"time : \" << t << \" \"  << \"node : \" << v+1 << \" \" << \"speed \" << speed << endl;\n        if(v==go and speed==1){\n            cout << Double(t) << endl;\n            return;\n        }\n\n        if(t > visited[v][speed][pre]) continue;\n\n\n        for(int u=0;u<n;u++){\n            if(u==v or u==pre) continue;\n            if(g[v][u]==INF) continue;\n            int d=g[v][u];\n            int c=lim[v][u];\n            for(int nspeed=max(speed-1,0);nspeed<=speed+1;nspeed++){\n                if(nspeed>c) continue;\n                double nt = t + (double)d/nspeed;\n//                cerr << nt << \" \" << visited[u][nspeed] << endl;\n                if(nt < visited[u][nspeed][pre]){\n//                    cerr << \"\\t time \" << nt << \" \" << \"node \" << u+1 << \" speed \" << nspeed << endl;\n                    visited[u][nspeed][pre] = nt;\n                    que.push(makeP(nt,nspeed,u,v));\n                }\n            }\n        }\n    }\n    cout << \"unreachable\" << endl;\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m){\n        if(n==0 && m==0) break;\n        solve(n,m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n,m;\nint d[35][35];\nint c[35][35];\n\ndouble dist[35][35];\n\ntypedef tuple<double,int,int,int> state;\n\ndouble dijkstra(int src,int dest){\n\trep(i,35)rep(j,35) dist[i][j]=inf;\n\tdist[src][0]=0.0;\n\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\n\tstate init(0.0,src,-1,0);\n\tq.push(init);\n\n\twhile(!q.empty()){\n\t\tstate cur=q.top();q.pop();\n\t\tdouble distance;\n\t\tint v,p,s;\n\t\ttie(distance,v,p,s)=cur;\n\t\trep(i,n){\n\t\t\tif(d[v][i]==-1)\n\t\t\t\tcontinue;\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tint nv=i;\n\t\t\t\tint ns=s+j;\n\t\t\t\tif(ns<=0||c[v][i]<ns) continue;\n\t\t\t\tdouble nd=distance+(1.0*d[v][i]/ns);\n\t\t\t\tif(dist[nv][ns]>nd){\n\t\t\t\t\tdist[nv][ns]=nd;\n\t\t\t\t\tstate next(nd,nv,v,ns);\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (dist[dest][1]>=inf)?-1:dist[dest][1];\n}\n\nint main(void){\n\twhile(cin >> n >> m){\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tclr(d,-1);\n\t\tint s,g;\n\t\tcin >> s >> g;\n\t\ts--,g--;\n\t\trep(i,m){\n\t\t\tint x,y,dd,cc;\n\t\t\tcin >> x >> y >> dd >> cc;\n\t\t\tx--,y--;\n\t\t\td[x][y]=d[y][x]=dd;\n\t\t\tc[x][y]=c[y][x]=cc;\n\t\t}\n\t\tcout.precision(9);\n\t\tdouble ans=dijkstra(s,g);\n\t\tif(ans==-1.0)\n\t\t\tcout << \"unreachable\" << endl;\n\t\telse\n\t\t\tcout << fixed << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\nconst double EPS = 1e-8;\n\nclass State{\npublic:\n  int pos, v, pre;\n  double time;\n  State(){}\n  State(int pos, int v, int pre, double time) : pos(pos), v(v), pre(pre), time(time) {}\n  bool operator < (const State& s) const { return time > s.time; }\n};\n\nint n, m, s, g;\nP edge[30][30];\ndouble cost[30][30][31];\nbool vis[30][30][31];\n\nbool equals(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nvoid solve(){\n  State u, v;\n  u = State(s, 0, 0, 0.0);\n  priority_queue<State> que;\n  fill(vis[0][0], vis[30][0], (double)INF);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<31;k++){\n        cost[i][j][k] = INF;\n        vis[i][j][k] = false;\n      }\n    }\n  }\n  cost[0][0][1] = 0.0;\n  for(int i=0;i<n;i++){\n    if(edge[s][i].first != INF){\n      cost[s][i][1] = edge[s][i].first;\n      que.push(State(i, 1, s, (double)edge[s][i].first));\n    }\n  }\n  while(!que.empty()){\n    u = que.top(); que.pop();\n    //cout << u.pos << ' ' << u.v << ' ' << u.pre << ' ' << u.time << endl;\n    if(vis[u.pre][u.pos][u.v]) continue;\n    vis[u.pre][u.pos][u.v] = true;\n    if(u.pos == g && u.v == 1){\n      printf(\"%.5f\\n\", u.time);\n      return;\n    }\n    for(int i=0;i<n;i++){\n      if(edge[u.pos][i].first == INF) continue;\n      if(u.pre == i) continue;\n      for(int k=-1;k<=1;k++){\n        if(u.v + k > edge[u.pos][i].second) continue;\n        if(u.v + k <= 0) continue;\n        v = State(i, u.v + k, u.pos, u.time + edge[u.pos][i].first / (double)(u.v + k));\n        //cout << '\\t' << v.pos << ' ' << v.v << ' ' << v.pre << ' ' << v.time << ' ' << vis[v.pre][v.pos][v.v] << endl;\n        if(cost[v.pre][v.pos][v.v] > v.time){\n          cost[v.pre][v.pos][v.v] = v.time;\n          que.push(v);\n        }\n      }\n    }\n  }\n  printf(\"unreachable\\n\");\n}\n\nmain(){\n  while(scanf(\"%d%d\", &n, &m) && (n|m)){\n    scanf(\"%d%d\", &s, &g);\n    s--; g--;\n    fill(edge[0], edge[30], P(INF, 0));\n    for(int i=0;i<m;i++){\n      int a, b, c, d;\n      scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n      a--; b--;\n      edge[a][b] = edge[b][a] = P(c, d);\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define D first\n#define C second\n\nusing namespace std;\n\nconst double INF = 1000000000.0;\n\ndouble d[31][31][31]; //?????????????????????????????¨?????????????????¨??????????????°?????????????????????\nbool visited[31][31][31];\nint N,M,S,G;\npair<int, int> p[31][31];\n\nstruct ST{\n  double ti;\n  int bn;\n  int cn;\n  int sp;\n  ST(double _ti, int _bn, int _cn, int _sp){\n    ti = _ti;\n    bn = _bn;\n    cn = _cn;\n    sp = _sp;\n  }\n  bool operator >(const ST &e) const{\n    return ti > e.ti;\n  }\n};\n\nint main() {\n  while(1){\n    cin>>N>>M;\n    if(N==0 && M==0) break;\n    cin>>S>>G;\n    S--; G--;\n\n    REP(i,0,N)REP(j,0,N)REP(k,0,31) d[i][j][k] = INF;\n    REP(i,0,N)REP(j,0,N)REP(k,0,31) visited[i][j][k] = false;\n    REP(i,0,N)REP(j,0,N) p[i][j].D = p[i][j].C = -1;\n\n    bool flag = true;\n\n    REP(i,0,M){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      p[x-1][y-1].D = p[y-1][x-1].D = d;\n      p[x-1][y-1].C = p[y-1][x-1].C = c;\n    }\n\n    d[S][S][0] = 0.0;\n    //\n    priority_queue< ST, vector<ST>, greater<ST> > PQ;\n    ST st(0.0,S,S,0);\n    PQ.push(st);\n    //\n\n    //while(1){\n    while(!PQ.empty()){\n      /*\n      int ubn=-1, ucn=-1, usp=-1;\n      double mtime = INF;\n      REP(i,0,N){\n        REP(j,0,N){\n          REP(k,0,31){\n            if(visited[i][j][k]) continue;\n            if(mtime > d[i][j][k]){\n              ubn = i;\n              ucn = j;\n              usp = k;\n              mtime = d[i][j][k];\n            }\n          }\n        }\n      }\n      */\n      //\n      ST u = PQ.top(); PQ.pop();\n      double mtime = u.ti;\n      int ubn=u.bn, ucn=u.cn, usp=u.sp;\n      //cout<<\"u.ti: \"<<u.ti<<\"; u.bn: \"<<u.bn<<\"; u.cn: \"<<u.cn<<\"; u.sp: \"<<u.sp<<endl;\n      //\n      if(ucn == G && usp == 1){\n        printf(\"%.5lf\\n\",d[ubn][ucn][usp]);\n        flag = false;\n        break;\n      }\n      /*\n      if(ucn == -1){\n        cout<<\"unreachable\"<<endl;\n        break;\n      }\n      */\n\n      visited[ubn][ucn][usp] = true;\n      for(int v = usp-1; v <= usp+1; v++){\n        if(v <= 0) continue;\n        REP(next,0,N){\n          if(p[ucn][next].D == -1 || p[ucn][next].C < v || ucn == next) continue;\n          /*\n          d[ucn][next][v] = min(d[ucn][next][v], d[ubn][ucn][usp] + (double)p[ucn][next].D/(double)v);\n          */\n          //\n          if(d[ucn][next][v] > d[ubn][ucn][usp] + (double)p[ucn][next].D/(double)v){\n            d[ucn][next][v] = d[ubn][ucn][usp] + (double)p[ucn][next].D/(double)v;\n            ST tst(d[ucn][next][v], ucn,next,v);\n            PQ.push(tst);\n          }\n          //\n        }\n      }\n\n    }\n    if(flag){\n      cout<<\"unreachable\"<<endl;\n    }\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nstruct edge{\n\tint to,cost,limit;\n\tedge(int t,int c,int l){\n\t\tto=t;cost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tvector<vector<edge> > E(n+1);\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in].push_back(edge(out,c,l));\n\t\tE[out].push_back(edge(in,c,l));\n\t}\n\n\tdouble Ans[31][31][31];\n\tmemset(Ans,-1,sizeof(Ans));\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){\n\t\tNode t=Q.top(); Q.pop();\n\t\tif(Ans[t.now][t.before][t.speed]<=t.time && Ans[t.now][t.before][t.speed]>=0) continue;\n//\t\tcout<<t.now<<\" \"<<t.speed<<\" \"<<t.time<<endl;\n\t\tif(t.now==g && t.speed==1){printf(\"%.12lf\\n\", t.time );  return;}\n\t\tAns[t.now][t.before][t.speed]=t.time;\n\n\t\tfor(int i=0;i<E[t.now].size();i++){\n\t\t\tint to=E[t.now][i].to;\n\t\t\tif(to==t.before) continue;\n\t\t\tif(E[t.now][i].cost>0){\n\t\t\t\tif(E[t.now][i].limit>=t.speed && t.speed>=1){\n\t\t\t\t\tQ.push(Node(to,t.speed,t.time+E[t.now][i].cost/(double)t.speed,t.now));\n\t\t\t\t}\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed+1)\n\t\t\t\t\tQ.push(Node(to,t.speed+1,t.time+E[t.now][i].cost/(double)(t.speed+1.0),t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed-1 && t.speed-1>=1)\n\t\t\t\t\tQ.push(Node(to,t.speed-1,t.time+E[t.now][i].cost/(double)(t.speed-1.0),t.now));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\"<<endl;\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n\nstruct edge {\n  int src, dst;\n  int d, c;\n  edge();\n  edge(int x, int y, int z, int w) : src(x), dst(y), d(z), c(w) {}\n};\n\nstruct state {\n  int node;\n  int prev;\n  int v;\n  double t;\n  state();\n  state(int a, int b, int c, double d) : node(a), prev(b), v(c), t(d) {}\n  bool operator<(const state& s) const\n  {\n    return t > s.t;\n  }\n};\n\nint main()\n{\n  int n, m;\n  while (cin >> n >> m && !(n == 0 && m == 0)) {\n    int start, goal;\n    cin >> start >> goal;\n    start--;  goal--;\n\n    vector<vector<edge> > g(n);\n    for (int i = 0; i < m; i++) {\n      int u, v, d, c;\n      cin >> u >> v >> d >> c;\n      u--;  v--;\n      g[u].push_back(edge(u, v, d, c));\n      g[v].push_back(edge(v, u, d, c));\n    }\n\n    vector<vector<vector<double> > > costs(n, vector<vector<double> >(n, vector<double>(32, numeric_limits<double>::max())));\n    priority_queue<state> q;\n    costs[start][start][0] = 0;\n    q.push(state(start, 0, start, 0.0));\n    while (!q.empty()) {\n      const state s = q.top();\n      if (s.node == goal && s.v == 1) {\n        break;\n      }\n      q.pop();\n\n      for (vector<edge>::const_iterator it(g[s.node].begin()); it != g[s.node].end(); ++it) {\n        if (s.prev == it->dst) {\n          continue;\n        }\n        for (int dv = -1; dv <= 1; dv++) {\n          const int v = s.v + dv;\n          if (v <= 0 || v > it->c) {\n            continue;\n          }\n          const double t = s.t + (double(it->d) / v);\n          if (t < costs[it->dst][it->src][v]) {\n            costs[it->dst][it->src][v] = t;\n            q.push(state(it->dst, it->src, v, t));\n          }\n        }\n      }\n    }\n    if (q.empty()) {\n      cout << \"unreachable\" << endl;\n    } else {\n      cout << q.top().t << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define EPS (1.0e-9)\n#define LT(x, y) ((x) - (y) <= -EPS) // x < y\n#define INF (1<<19)\nusing namespace std;\ntypedef struct DisLim {\n int d, c; // dist, limit v\n DisLim() {}\n DisLim(int d, int c) : d(d),c(c) {}\n} DisLim;\nint N,M;\nint S,G; // start, goal\nDisLim F[31][31];\n\ndouble dist[31][31][31];\nbool visited[31][31][31];\nclass State {\npublic:\n int bpos, cpos; // before,current\n double d; // ツ仰猟猟」\n int v; // ツ堕ャツ度\n State (int bpos, int cpos, double d, int v) :\n   bpos(bpos),cpos(cpos),d(d),v(v) {}\n bool operator < (const State &s) const {\n   //return d > s.d;\n   return LT(s.d,d);\n }\n};\n\npriority_queue<State> PQ;\ndouble solve() {\n  while(!PQ.empty()) {\n    State u = PQ.top(); PQ.pop();\n    int bpos=u.bpos, cpos=u.cpos, v=u.v;\n    double d = u.d;\n    \n    visited[bpos][cpos][v] = true;\n    if(cpos == G && v == 1) {\n      return dist[bpos][G][1];\n    }\n\n    for(int i=1;i<=N;i++) { // ツ篠淞づ個都ツ市\n      if(i==bpos || i==cpos) continue; // ツ古」ツ姪淞づィツ凝鳴止\n      for(int j=-1;j<=1;j++) { // ツ嘉個クツ堕ャツ堕閉置\n\tif(v+j <= 0) continue;\n\tif(v+j > F[cpos][i].c) continue;\n\tif(visited[cpos][i][v+j]) continue;\n\tif(F[cpos][i].d >= INF) continue;\n\tdouble cost = dist[bpos][cpos][v] + (double)F[cpos][i].d / (v+j);\n\tif(LT(cost,dist[cpos][i][v+j])) {\n\t  dist[cpos][i][v+j] = cost;\n\t  PQ.push(State(cpos,i,cost,v+j));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nmain() {\n while(cin>>N>>M,N) {\n   PQ = priority_queue<State>();\n   memset(visited,0,sizeof(visited));\n   for(int i=1;i<=N;i++) {\n     for(int j=1;j<=N;j++) {\n       F[i][j].d=INF;\n     }\n   }\n   cin>>S>>G;\n   for(int i=1;i<=N;i++) {\n     for(int j=1;j<=N;j++) {\n       for(int k=0;k<31;k++) {\n         dist[i][j][k] = INF;\n       }\n     }\n   }\n   for(int i=0;i<31;i++) {\n     dist[S][S][i] = 0;\n   }\n   PQ.push(State(S,S,0,1));\n   for(int i=0;i<M;i++) {\n     int x,y,d,c; cin>>x>>y>>d>>c;\n     F[x][y]=F[y][x]=DisLim(d,c);\n   }\n   double ans = solve();\n   if(ans==-1) puts(\"unreachable\");\n   else printf(\"%.5lf\\n\",ans);\n }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n\tint cost,limit;\n\tedge(int c,int l){\n\t\tcost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tvector<vector<edge> > E(n+1,vector<edge>(n+1,edge(-1,-1)));\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in][out]=edge(c,l);\n\t\tE[out][in]=edge(c,l);\n\t}\n\tvector<vector<double> > Ans(n+1,vector<double>(31,INF));\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){\n\t\tNode t=Q.top(); Q.pop();\n\t\tif(Ans[t.now][t.speed]<t.time) continue;\t\t\n//\t\tcout<<t.now<<\" \"<<t.speed<<\" \"<<t.time<<endl;\n\t\tif(t.now==g && t.speed==1){printf(\"%.12lf\\n\", t.time );  return;}\n\t\tAns[t.now][t.speed]=t.time;\n\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tif(i==t.before) continue;\n\t\t\tif(E[t.now][i].cost>0){\n\t\t\t\tif(E[t.now][i].limit>=t.speed && t.speed>=1)\n\t\t\t\t\tQ.push(Node(i,t.speed,t.time+E[t.now][i].cost/(double)t.speed,t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed+1)\n\t\t\t\t\tQ.push(Node(i,t.speed+1,t.time+E[t.now][i].cost/(double)(t.speed+1.0),t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed-1 && t.speed-1>=1)\n\t\t\t\t\tQ.push(Node(i,t.speed-1,t.time+E[t.now][i].cost/(double)(t.speed-1.0),t.now));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\"<<endl;\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n\tint cost,limit;\n\tedge(int c,int l){\n\t\tcost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tvector<vector<edge> > E(n+1,vector<edge>(n+1,edge(-1,-1)));\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in][out]=edge(c,l);\n\t\tE[out][in]=edge(c,l);\n\t}\n\tvector<vector<double> > Ans(n+1,vector<double>(31,INF));\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){\n\t\tNode t=Q.top(); Q.pop();\n\t\tif(Ans[t.now][t.speed]<=t.time) continue;\t\t\n//\t\tcout<<t.now<<\" \"<<t.speed<<\" \"<<t.time<<endl;\n\t\tif(t.now==g && t.speed==1){printf(\"%.12lf\\n\", t.time );  return;}\n\t\tAns[t.now][t.speed]=t.time;\n\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tif(i==t.before) continue;\n\t\t\tif(E[t.now][i].cost>0){\n\t\t\t\tif(E[t.now][i].limit>=t.speed && t.speed>=1)\n\t\t\t\t\tQ.push(Node(i,t.speed,t.time+E[t.now][i].cost/(double)t.speed,t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed+1)\n\t\t\t\t\tQ.push(Node(i,t.speed+1,t.time+E[t.now][i].cost/(double)(t.speed+1.0),t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed-1 && t.speed-1>=1)\n\t\t\t\t\tQ.push(Node(i,t.speed-1,t.time+E[t.now][i].cost/(double)(t.speed-1.0),t.now));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\"<<endl;\n\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define INF 2e+9\n#define mp make_pair\nusing namespace std;\n\nstruct edge{ int to,cost,limit; };\ntypedef pair<int,int> SV;//speed,vertex\ntypedef pair<double,SV> P;//cost\n\nint main(){\n\tint n,m,s,g;\n\twhile(cin >> n >> m,n){\n\t\tcin >> s >> g; s--;g--;\n\t\tvector<edge> G[30];\n\t\tdouble d[30][31];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j <= 30;j++) d[i][j] = INF;\n\t\t}\n\t\td[s][0] = 0.0;\n\t\tfor(int i = 0;i < m;i++) {\n\t\t\tint x,y,d,c;\n\t\t\tcin >> x >> y >> d >> c; x--;y--;\n\t\t\tG[x].push_back({y,d,c});\n\t\t\tG[y].push_back({x,d,c});\n\t\t}\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(mp(0.0,mp(0,s)));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top();que.pop();\n\t\t\tdouble cost = p.first;\n\t\t\tint speed = p.second.first,v = p.second.second;\n\t\t\tif(d[v][speed] < cost) continue;\n\t\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\t\tedge e = G[v][i];\n\t\t\t\tfor(int j = max(1,speed - 1);j <= min(e.limit,speed + 1);j++){\n\t\t\t\t\tif(d[v][speed] + (double)e.cost / (double)j < d[e.to][j]){\n\t\t\t\t\t\td[e.to][j] = d[v][speed] + (double)e.cost / (double)j;\n\t\t\t\t\t\tque.push(mp(d[e.to][j],mp(j,e.to)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(d[g][1] > (1e+9)) cout << \"unreachable\" << endl;\n\t\telse printf(\"%.8f\\n\",d[g][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <cstdio>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dy[] = {1, 0, -1, 1, -1, 1, 0, -1};\n\nstruct edge{\n\tint to;\n\tdouble dist;\n\tint c;\n\tedge(int t, double d, int c_){to = t, dist = d, c = c_;}\n};\n\nstruct state{\n\tint pos;\n\tdouble total;\n\tint speed;\n\tstate(int p, double t, int s){pos = p, total = t, speed = s;}\n\tbool operator<(const state &r)const{\n\t\treturn total > r.total;\n\t}\n};\n\nconst double INF = 1e30;\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\ts--, g--;\n\t\tvector<vector<edge> > G(n);\n\t\trep(i, m){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--, y--;\n\t\t\tG[x].push_back(edge(y, d, c));\n\t\t\tG[y].push_back(edge(x, d, c));\n\t\t}\n\n\t\tpriority_queue<state> q;\n\t\tq.push(state(s, 0, 0));\n\n\t\tvector<vi> visit(31, vi(n, 0)); //speed, pos\n\n\t\tdouble ans = INF;\n\t\twhile(!q.empty()){\n\t\t\tstate st = q.top();\n\t\t\tq.pop();\n\n\t\t\tif(visit[st.speed][st.pos]) continue;\n\t\t\tvisit[st.speed][st.pos] = 1;\n\n\t\t\tif(st.speed == 1 && st.pos == g){\n\t\t\t\tans = st.total;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, G[st.pos].size()){\n\t\t\t\tif( G[st.pos][i].dist == INF ) continue;\n\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\tstate next = st;\n\t\t\t\t\tnext.speed += j;\n\t\t\t\t\tif(next.speed <= 0 || next.speed > G[st.pos][i].c) continue;\n\t\t\t\t\tnext.pos = G[st.pos][i].to;\n\t\t\t\t\tnext.total += G[st.pos][i].dist/next.speed;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == INF) cout << \"unreachable\" << endl;\n\t\telse printf(\"%.8lf\\n\", ans);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];    \n    \n int inx,iny,ind,inc;\n  double d[40][40][40];\n  int s,g;\n \n\n    scanf(\"%d %d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\n#define REP(i,a,n) for(i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n\n\nint speed[33][33], dist[33][33];\nbool used[33][33][33];\ndouble dp[33][33][33]; // [ツ個サツ催敖づ個都ツ市][ツ前ツづ個都ツ市][ツ堕ャツ度]\nconst double inf = 999999999.0;\n\nstruct state{\n  int no, pr, sp;\n  double t;\n  \n  state(int n, int p, int s, double _t)\n       :no(n), pr(p), sp(s), t(_t){}\n  bool operator<(const state& a)const{\n    return t > a.t;\n  }\n};\n\nint main(){\n  int i,j,k,n,u, m,s,g;\n  while( cin >> n >> m, n|m ){\n\n    // init\n    rep(i,33) rep(j,33) rep(k,33) dp[i][j][k] = inf;\n    memset(speed, -1, sizeof(speed));\n    memset(dist, -1, sizeof(dist));\n    memset(used, false, sizeof(used));\n\n    // input\n    cin >> s >> g;\n    rep(i,m){\n      int x,y,d,c; cin >> x >> y >> d >> c;\n      dist[x][y] = dist[y][x] = d;\n      speed[x][y] = speed[y][x] = c;\n    }\n\n    priority_queue<state> q;\n    // start\n    \n    REP(i,1,n+1) if( dist[s][i] != -1 ) {\n      dp[i][s][1] = (double)dist[s][i];\n      q.push(state(i,s,1,(double)dist[s][i]));\n    }\n      \n    while( !q.empty() ){\n      int now = q.top().no;\n      int prev = q.top().pr;\n      int sp = q.top().sp;\n      double t = dp[now][prev][sp];\n\n      //printf(\"dp[%d][%d][%d] = %lf\\n\",now,prev,sp,t);\n      q.pop();\n\n      if( now == g && sp == 1 ) break;\n      if( used[now][prev][sp] ) continue;\n      used[now][prev][sp] = true;\n\n      REP(i,1,n+1) if( dist[now][i] != -1 && prev != i ) { // ツ篠淞づ可行ツつォツつスツつ「ツ都ツ市\n        for(int v=sp-1; v<=sp+1; v++){\n          if( v <= 0 || v > speed[now][i] ) continue;\n\n          if( dp[i][now][v] > t + (double)dist[now][i]/(double)v ){\n            double cost = t + (double)dist[now][i]/(double)v;\n            dp[i][now][v] = cost;\n            q.push(state(i,now,v,cost));\n          }\n        }\n      }\n    }\n\n    double res = inf;\n    REP(i,1,n+1) if( dp[g][i][1] != inf ) res = min(res, dp[g][i][1]);\n    if( res == inf ){\n      puts(\"unreachable\");\n    }\n    else{\n      printf(\"%lf\\n\",res);\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define NODE 30\n#define LIM 31\nconst double inf = 1e200;\n\nclass state{\npublic:\n  int cur,prev,speed;\n  double c;\n  state(){};\n  state(int tcur,int tprev,int tspeed,double tc):cur(tcur),prev(tprev),\n\t\t\t\t\t\t speed(tspeed),c(tc){};\n  bool operator<(const state & a)const{\n    return c >a.c;\n  }\n};\n\ndouble cost[30][30][31];\ndouble dist[30][30];\nint lim[30][30];\nbool visited[30][30][31];\n\nvoid solve(int n,int s,int g){\n  rep(i,n)rep(j,n)rep(k,31)cost[i][j][k]=inf,visited[i][j][k]=false;\n  priority_queue<state> Q;\n  cost[0][0][1]=0;\n  rep(i,n){\n    if ( lim[s][i] >= 1){\n      cost[i][s][1]=dist[s][i];\n      Q.push(state(i,s,1,cost[i][s][1]));\n    }\n  }\n\n  while(!Q.empty()){\n    state now = Q.top();\n    Q.pop();\n    \n    if ( cost[now.cur][now.prev][now.speed] <now.c){\n      //puts(\"test\");\n      continue;\n    }\n    //if ( visited[now.cur][now.prev][now.speed])continue;\n    //visited[now.cur][now.prev][now.speed]=true;\n    if ( now.cur == g && now.speed == 1){\n      printf(\"%.3lf\\n\",now.c);\n      return;\n    }\n    rep(i,n){\n      if ( i == now.prev)continue;\n      REP(j,-1,2){\n\tif ( now.speed + j > 0 && now.speed + j <= lim[now.cur][i] &&\n\t     cost[i][now.cur][now.speed+j] > now.c + dist[now.cur][i]/(now.speed+j)){\n\t  cost[i][now.cur][now.speed+j]=now.c+dist[now.cur][i]/(now.speed+j);\n\t  Q.push(state(i,now.cur,now.speed+j,cost[i][now.cur][now.speed+j]));\n\t}\n      }\n    }\n  }\n  \n\n  puts(\"unreachable\");\n  \n}\n\n\nmain(){\n  int n,m;\n  while(cin>>n>>m && n){\n    rep(i,n)rep(j,n)lim[i][j]=0,dist[i][j]=inf;\n    int s,g;\n    cin>>s>>g;\n    s--;g--;\n    rep(i,m){\n      int f,t,v;\n      double d;\n      cin>>f>>t>>d>>v;\n      f--;t--;\n      dist[f][t]=dist[t][f]=d;\n      lim[f][t]=lim[t][f]=v;\n    }\n    solve(n,s,g);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\n\nconst int INF = 1e9;\n\nsigned main() {\n\n\tint n, m;\n\twhile (cin >> n >> m && n) {\n\t\tint s, g;\n\t\tcin >> s >> g; s--; g--;\n\t\ttypedef pair<int, int> p;\n\t\tvector<vector<p>> v(n, vector<p>(n, p(-1, -1)));\n\t\trep(i, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tv[x][y] = p(d, c);\n\t\t\tv[y][x] = p(d, c);\n\t\t}\n\t\tdouble d[31][31][31];\n\t\trep(i, 31)rep(j, 31)rep(k, 31)d[i][j][k] = INF;\n\n\t\ttypedef tuple<int, int, int> t;\n\t\tqueue<t> q;\n\t\tq.push(t(s, s, 1));\n\t\td[s][s][1] = 0;\n\t\tdouble ans = INF;\n\n\t\twhile (q.size()) {\n\n\t\t\tint now = get<0>(q.front());\n\t\t\tint prev = get<1>(q.front()); \n\t\t\tint speed = get<2>(q.front());\n\t\t\tq.pop();\n\n\t\t\trep(i, n) {\n\t\t\t\tif (i != prev && v[now][i].first != -1 && v[now][i].second >= speed) {\n\t\t\t\t\tdouble time = double(v[now][i].first) / double(speed);\n\n\t\t\t\t\tfor (int t_speed = max(1, speed - 1); t_speed <= speed + 1; t_speed++) {\n\t\t\t\t\t\tif (i == g && speed == 1) {\n\t\t\t\t\t\t\tans = min(ans, d[now][prev][speed] + time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (d[i][now][t_speed] > d[now][prev][speed] + time) {\t\n\t\t\t\t\t\t\td[i][now][t_speed] = d[now][prev][speed] + time;\n\t\t\t\t\t\t\tq.push(t(i, now, t_speed));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (ans == INF) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << fixed << setprecision(30) << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct Edge {\n  int from, to, cost, cap;\n  Edge(int from_, int to_, int cost_, int cap_)\n    : from(from_), to(to_), cost(cost_), cap(cap_) { }\n};\n\nint main() {\n  cout.setf(ios::fixed);\n  cout.precision(4);\n  while(true) {\n    int N, M; cin >> N >> M;\n    if(N == 0) break;\n    int S, G; cin >> S >> G;\n    --S, --G;\n    vector<Edge> g;\n    for(int i = 0; i < M; ++i) {\n      int x,y,d,c; cin >> x >> y >> d >> c;\n      --x, --y;\n      g.emplace_back(x,y,d,c);\n      g.emplace_back(y,x,d,c);\n    }\n    M *= 2;\n    // [from][to][speed]\n    double d[N][N][31];\n    for(int i = 0; i < N; ++i)\n      for(int j = 0; j < N; ++j)\n        for(int c = 0; c < 31; ++c)\n          d[i][j][c] = 1e10;\n    for(int i = 0; i < M; ++i) {\n      if(g[i].from == S) {\n        d[S][g[i].to][1] = min(d[S][g[i].to][1], 1.0 * g[i].cost);\n      }\n    }\n    while(true) {\n      bool update = false;\n      for(int i = 0; i < M; ++i) {\n        for(int u = 0; u < N; ++u) {\n          if(g[i].to == u) continue;\n          for(int c = 1; c <= g[i].cap; ++c) {\n            for(int dc = -1; dc <= 1; ++dc) {\n              int nc = c + dc;\n              if(nc <= 0 || nc > g[i].cap) continue;\n              if(d[g[i].from][g[i].to][nc] > d[u][g[i].from][c] + 1.0 * g[i].cost / nc) {\n                d[g[i].from][g[i].to][nc] = d[u][g[i].from][c] + 1.0 * g[i].cost / nc;\n                update = true;\n              }\n            }\n          }\n        }\n      }\n      if(!update) break;\n    }\n    double ans = 1e10;\n    for(int u = 0; u < N; ++u) ans = min(ans, d[u][G][1]);\n    if(ans == 1e10) {\n      cout << \"unreachable\" << endl;\n    }\n    else {\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\nconst double inf = (double)(1<<24);\n\nclass Node {\npublic:\n    double time;\n    int v, town, prev;\n    Node() {}\n    Node( double time_, int v_, int town_, int prev_ ) \n    {\n        time = time_;\n        v = v_;\n        town = town_;\n        prev = prev_;\n    }\n    bool operator > ( const Node& right ) const \n    {\n        return fabs( time - right.time ) < eps ? v > right.v : time < right.time;\n    }\n    bool operator < ( const Node& right ) const\n    {\n        return fabs( time - right.time ) < eps ? v < right.v : time > right.time;\n    }\n};\ntypedef priority_queue <Node> QUEUE;\nconst int size = 31;\n\nint n, m;\nbool P[size][size];\ndouble G[size][size];\ndouble MC[size][size];\nint L[size][size];\nint CN[size][size];\nint CN_count[size];\n\nvoid solve( int start, int goal )\n{\n    QUEUE Q;\n    Node start_node( 0.0, 1, start, -1 );\n    Q.push( start_node );\n    MC[1][start] = 0.0;\n\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        double time = node.time;\n        int v = node.v;\n        int town = node.town;\n        int prev = node.prev;\n\n        if ( town == goal && v == 1 ) {\n            printf( \"%.5f\\n\", time );\n            return;\n        }\n\n        for ( int i = 0; i < CN_count[town]; i++ ) {\n            int next_town = CN[town][i];\n            if ( next_town == prev ) continue;\n            for ( int j = 1; j >= -1; j-- ) {\n                if ( prev == -1 && j != 0 ) continue;\n                int next_v = v + j;\n                if ( next_v <= 0 || next_v > L[town][next_town] ) continue;\n                double cost = (double)G[town][next_town] / next_v;\n                double next_time = time + cost;\n                int next_prev = town;\n\n                if ( next_time > MC[next_v][next_town] || fabs( next_time - MC[next_v][next_town] ) < eps ) continue;\n                MC[next_v][next_town] = next_time;\n                Node next_node( next_time, next_v, next_town, next_prev );\n                Q.push( next_node );\n            }\n        }\n    }\n\n    cout << \"unreachable\" << endl;\n}\n\nint main( void )\n{\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        // init\n        for ( int i = 0; i < size; i++ ) {\n            CN_count[i] = 0;\n            for ( int j = 0; j < size; j++ ) {\n                P[i][j] = false;\n                MC[i][j] = inf;\n                G[i][j] = inf;\n                L[i][j] = 0;\n            }\n        }\n\n        // input\n        int s, g;\n        cin >> s >> g;\n        for ( int i = 0; i < m; i++ ) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n\n            P[x][y] = P[y][x] = true;\n            G[x][y] = G[y][x] = d;\n            L[x][y] = L[y][x] = c;\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( i == j ) continue;\n                if ( P[i][j] ) CN[i][CN_count[i]++] = j;\n            }\n        }\n\n        solve( s-1, g-1 );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ntypedef pair<pair<double,int> ,pair<int,int> > ppi;\nvector<pair<pair<double,int>,int> > vp[31];\nint dv[]={-1,0,1};\ndouble d[31][31][32];\ndouble INF=1000100010;\nint m,n,s,g;\ndouble dijkstra(){\n    priority_queue<ppi,vector<ppi>,greater<ppi> > pq;\n    rep(i,n)rep(k,n)rep(j,32) d[i][k][j]=INF;\n    d[s][s][1]=0.0;\n    pq.push({{0.0,-1},{1,s}});\n    while(!pq.empty()){\n        ppi pi=pq.top();pq.pop();\n        int t=pi.second.second;\n        int u=pi.second.first;\n        double cost=pi.first.first;\n        if(t==g&&u==0) return cost;\n        for(auto it:vp[t]){\n            if(it.second==pi.first.second) continue;\n            int lm=it.first.second;\n            double dist=it.first.first;\n            if(lm<u||u<=0) continue;\n            rep(i,3){\n                int tv=u+dv[i];\n                if(d[it.second][t][tv]>cost+dist/u){\n                    d[it.second][t][tv]=cost+dist/u;\n                    pq.push({{d[it.second][t][tv],t},{tv,it.second}});\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    while(cin>>n>>m,n|m){\n        rep(i,n) vp[i].clear();\n        cin>>s>>g;\n        --s,--g;\n        int x,y,ci;\n        double di;\n        rep(i,m){\n            cin>>x>>y>>di>>ci;\n            --x,--y;\n            vp[x].pb(make_pair(di,ci),y);\n            vp[y].pb(make_pair(di,ci),x);\n        }\n        double ans=dijkstra();\n        if(ans==-1)cout<<\"unreachable\"<<endl;\n        else cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint visited[31][31][31];\nint d[31];\n\ntypedef struct edge\n{\n    int to, cost, limit;\n    edge(int x, int y, int z): to(x), cost(y), limit(z) {}\n} Edge;\n\n\ntypedef struct status {\n    int from, to, speed;\n    double time;\n    status(int x, int x2, double y, int z): from(x), to(x2), time(y), speed(z) {}\n} CurrentStatus;\n\n\nstruct cmp_statue {\n    bool operator() (const CurrentStatus &a, const CurrentStatus &b) {\n        return a.time > b.time;\n    }\n};\n\n\nint main() {\n\n    int ncities, nroads;\n    int x, y, d, c;\n    int start_index, end_index;\n\n    while(scanf(\"%d%d\", &ncities, &nroads) != EOF && !(ncities == 0 && nroads == 0)) {\n\n        vector< vector<Edge> > path(ncities);\n        memset(visited, 0, sizeof(visited));\n        memset(d, 0, sizeof(d));\n\n        // Input\n        scanf(\"%d%d\" , &start_index, &end_index);\n        start_index--;\n        end_index--;\n\n        for(int n = 0; n < nroads; ++n) {\n            scanf(\"%d%d%d%d\", &x, &y, &d, &c);\n            path[x - 1].push_back(Edge(y - 1, d, c));\n            path[y - 1].push_back(Edge(x - 1, d, c));\n        }\n\n\n        double minimun_v = 0;\n        for(int q = 0; q < nroads; ++q) {\n            Edge *cs = NULL;\n            int min = 1e9;\n            for(int k = 0; k < ncities; ++k) {\n                if(d[k] < min) {\n                    cs = path[]\n                }\n            }\n\n            if(cs.to == end_index) {\n                if(cs.speed == 1) {\n                    minimun_v = cs.time;\n                    break;\n                } else {\n                    continue;\n                }\n            }\n\n            if(cs == NULL) break;\n            if(visited[cs.from][cs.to][cs.speed]) continue;\n\n            visited[cs.from][cs.to][cs.speed] = 1;\n\n            for(int j = 0; j < path[cs.to].size(); ++j) {\n                int next_pt = path[cs.to][j].to;\n                int limit = path[cs.to][j].limit;\n                if(next_pt == cs.from) continue;\n\n                for(int z = -1; z <= 1; ++z) {\n                    int new_speed = cs.speed + z;\n                    if(!visited[cs.to][next_pt][new_speed] && new_speed > 0 && new_speed <= limit) {\n                        Q.push(CurrentStatus(cs.to, next_pt, cs.time + ((double)path[cs.to][j].cost)/new_speed, new_speed));\n                    }\n                }\n            }\n        }\n\n        if(minimun_v) {\n            printf(\"%0.5lf\\n\", minimun_v);\n        } else {\n            printf(\"unreachable\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1162\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1162&lang=jp\n\n#include <iostream>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double eps = 1e-9;\nconst double inf = (double)(1<<24);\n\nclass Node {\npublic:\n    double time;\n    int v, town, prev;\n    Node() {}\n    Node( double time_, int v_, int town_, int prev_ ) \n    {\n        time = time_;\n        v = v_;\n        town = town_;\n        prev = prev_;\n    }\n    bool operator < ( const Node& right ) const \n    {\n        return time > right.time;\n    }\n    bool operator > ( const Node& right ) const\n    {\n        return time < right.time;\n    }\n    bool operator == ( const Node& right ) const\n    {\n        return v == right.v && town == right.town && prev == right.prev;\n    }\n};\ntypedef priority_queue <Node> QUEUE;\nconst int size = 31;\n\nint n, m;\nbool P[size][size];\ndouble G[size][size];\ndouble MC[size][size];\nint L[size][size];\nint CN[size][size];\nint CN_count[size];\n\n// dijkstra\nvoid solve( int start, int goal )\n{\n    // init\n    QUEUE Q;\n    Node start_node( 0.0, 0, start, -1 );\n    Q.push( start_node );\n    MC[0][start] = 0.0;\n\n    // proc\n    while ( !Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        // proc init\n        double time = node.time;\n        int v = node.v;\n        int town = node.town;\n        int prev = node.prev;\n\n        // goal\n        if ( town == goal && v == 1 ) {\n            printf( \"%.5f\\n\", time );\n            return;\n        }\n\n        // move\n        for ( int i = 0; i < CN_count[town]; i++ ) {\n            int next_town = CN[town][i];\n            if ( next_town == prev ) continue;\n            for ( int j = 1; j >= -1; j-- ) {\n                int next_v = v + j;\n                if ( prev == -1 && next_v != 1 ) continue;\n                if ( next_v <= 0 || next_v > L[town][next_town] ) continue;\n                double cost = (double)G[town][next_town] / next_v;\n                double next_time = time + cost;\n                int next_prev = town;\n\n                if ( next_time > MC[next_v][next_town] || fabs( next_time - MC[next_v][next_town] ) < eps ) continue;\n                MC[next_v][next_town] = next_time;\n                Node next_node( next_time, next_v, next_town, next_prev );\n                Q.push( next_node );\n            }\n        }\n    }\n\n    cout << \"unreachable\" << endl;\n}\n\nint main( void )\n{\n    while ( cin >> n >> m ) {\n        // quit\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        for ( int i = 0; i < size; i++ ) {\n            CN_count[i] = 0;\n            for ( int j = 0; j < size; j++ ) {\n                P[i][j] = false;\n                MC[i][j] = inf;\n                G[i][j] = inf;\n                L[i][j] = 0;\n            }\n        }\n\n        // input\n        int s, g;\n        cin >> s >> g;\n        for ( int i = 0; i < m; i++ ) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n\n            P[x][y] = P[y][x] = true;\n            G[x][y] = G[y][x] = d;\n            L[x][y] = L[y][x] = c;\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( i == j ) continue;\n                if ( P[i][j] ) CN[i][CN_count[i]++] = j;\n            }\n        }\n\n        solve( s-1, g-1 );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF 1000000007\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef pair<int,int>pi;\ntypedef pair<double,int>pd;\ntypedef pair<pd,pi>PP;\n\nstruct edge\n{\n    int to,dist,limit;\n};\n\nint n,m,s,g;\ndouble dp[31][31][31];\nvector<edge> G[31];\n\nvoid dijkstra()\n{\n    rep(i,n){\n        rep(j,n){\n            rep(k,31){\n                dp[i][j][k] = INF;\n            }\n        }\n    }\n    priority_queue<PP,vector<PP>,greater<PP> > que;\n    que.push(PP(pd(0.0,s),pi(s,0)));\n    dp[s][s][0] = 0.0;\n    while(!que.empty()){\n        PP pp = que.top();\n        pd p = pp.fi;\n        pi q = pp.se;\n        que.pop();\n        double cost = p.fi;\n        int v = p.se, prv = q.fi, sp = q.se;\n        if(dp[v][prv][sp] < cost) continue;\n        if(v == g && sp == 1){\n            printf(\"%.12lf\\n\",cost);\n            return;\n        }\n        for(int i=sp-1;i<=sp+1;i++){\n            if(i <= 0) continue;\n            for(auto& e : G[v]){\n                if(e.to != prv && i <= e.limit && dp[e.to][v][i] > cost+(double)e.dist/i){\n                    dp[e.to][v][i] = cost+(double)e.dist/i;\n                    que.push(PP(pd(dp[e.to][v][i],e.to),pi(v,i)));\n                }\n            }\n        }\n    }\n    printf(\"unreachble\\n\");\n}\n\nint main()\n{\n    while(1){\n        cin >> n >> m;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear();\n        }\n        cin >> s >> g;\n        s--,g--;\n        rep(i,m){\n            int a,b,c,d;\n            cin >> a >> b >> c >> d;\n            G[a-1].push_back((edge){b-1,c,d});\n            G[b-1].push_back((edge){a-1,c,d});\n        }\n        dijkstra();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nclass data\n{\npublic:\n\tint p, q, c;\n\tdata(int p0, int q0, int c0){\n\t\tp = p0;\n\t\tq = q0;\n\t\tc = c0;\n\t}\n};\n\nvoid solve(int n, int start, int goal, vector<vector<int> > distance, vector<vector<int> > limit)\n{\n\tvector<vector<vector<bool> > > check(n, vector<vector<bool> >(n, vector<bool>(31, false)));\n\tmultimap<double, data> m;\n\tfor(int i=0; i<n; ++i){\n\t\tif(distance[start][i] > -1)\n\t\t\tm.insert(make_pair(distance[start][i], data(i, start, 1)));\n\t}\n\n\twhile(!m.empty()){\n\t\tmultimap<double, data>::iterator it = m.begin();\n\t\tdouble t = it->first;\n\t\tint p = it->second.p;\n\t\tint q = it->second.q;\n\t\tint c = it->second.c;\n\t\tif(p == goal && c == 1){\n\t\t\tprintf(\"%.10f\\n\", t);\n\t\t\treturn;\n\t\t}\n\t\tm.erase(it);\n\t\t\n\t\tif(!check[p][q][c]){\n\t\t\tcheck[p][q][c] = true;\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tfor(int j=-1; j<=1; ++j){\n\t\t\t\t\tif(i != p && i != q && distance[i][p] > -1 && 0 < c+j && c+j <= limit[p][i])\n\t\t\t\t\t\tm.insert(make_pair(t+distance[p][i]/static_cast<double>(c+j), data(i, p, c+j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"unreachable\" << endl;\n}\n\nint main()\n{\n\tfor(;;){\n\t\tint n, m, s, g;\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0)\n\t\t\tbreak;\n\t\tcin >> s >> g;\n\t\t-- s;\n\t\t-- g;\n\n\t\tvector<vector<int> > distance(n, vector<int>(n, -1));\n\t\tvector<vector<int> > limit(n, vector<int>(n, -1));\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\t-- x;\n\t\t\t-- y;\n\t\t\tcin >> distance[x][y] >> limit[x][y];\n\t\t\tdistance[y][x] = distance[x][y];\n\t\t\tlimit[y][x] = limit[x][y];\n\t\t}\n\n\t\tsolve(n, s, g, distance, limit);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdio>\n#include<cmath>\n#define inf 100000007\nusing namespace std;\n\nstruct State{\n  int speed,now,before;\n  double time;\n  State(double time,int speed,int now,int before):\n    time(time),speed(speed),now(now),before(before){}\n  bool operator<(State S)const{\n    return S.time < time;\n    }\n};\n\nint main()\n{\n  int n,m,s,g,a,b,d,l;\n  int dis[31][31],lim[31][31],S[3]={-1,0,1};\n  double dp[31][31][31],eps=1e-8; \n\n  while(1){\n    cin>>n>>m;\n    if(n+m==0)break;\n    cin>>s>>g;\n    s--;g--;\n    for(int i=0;i<30;i++){\n      for(int j=0;j<30;j++){\n\tdis[i][j]=inf;\n\tlim[i][j]=inf;\n\tfor(int k=0;k<30;k++)dp[i][j][k]=inf;\n      }\n    }\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>d>>l;\n      a--;b--;\n      dis[a][b]=d;\n      dis[b][a]=d;\n      lim[a][b]=l;\n      lim[b][a]=l;\n    }\n\n    double ans=inf;\n    priority_queue<State> pq;\n    pq.push(State(0,0,s,s));\n    dp[s][s][0]=0;\n    while(!pq.empty()){\n      State u=pq.top();\n      pq.pop();\n      //  cout<<u.now<<\" \"<<u.before<<endl;\n      if(u.now==g && u.speed==1){\n\tans=min(u.time,ans);\n\tcontinue;\n      }\n      if(u.time > dp[u.before][u.now][u.speed]+eps)continue;\n      /*\n      printf(\"%.10f\",u.f.f);\n      cout<<\" \"<<u.f.s<<\" \"<<u.s.f<<\" \"<<u.s.s<<endl;\n      */\n      for(int i=0;i<n;i++){\n\tif(i==u.now)continue;\n\tif(i==u.before)continue;\n      \tif(dis[u.now][i]==inf)continue;\n\tfor(int k=0;k<3;k++){\n\t  int speed = u.speed+S[k];\n\t  if( speed<1 || 30<speed )continue;\n\t  if( lim[u.now][i] < speed )continue;\n\t  double time=(double)dis[u.now][i]/(double)speed;\n\t  if( dp[u.now][i][speed] < time + u.time+eps)continue;\n\t  dp[u.now][i][speed] = time + u.time;\n\t  pq.push(State(time+u.time,speed,i,u.now));\n\t}\n      }\n    }\n    if(ans>=inf-1)cout<<\"unreachable\"<<endl;\n    else printf(\"%.5f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nstruct State {\n    int i, prev, sp; double cost;\n};\n\nbool operator>(const State& a, const State& b)\n{\n    return a.cost > b.cost;\n}\n\nconst double INF = 1<<29;\n\nint main()\n{\n    while (1) {\n        int n, m, s, g; cin >> n >> m >> s >> g;\n        s--, g--;\n\n        vector<vector<double>> dist(n, vector<double>(n, INF));\n        vector<vector<int>> lim(n, vector<int>(n));\n\n        while (m--) {\n            int x, y, d, c; cin >> x >> y >> d >> c;\n            x--, y--;\n            dist[x][y] = dist[y][x] = d;\n            lim[x][y] = lim[y][x] = c;\n        }\n\n        priority_queue<State, vector<State>, greater<State>> Q;\n        Q.push({ s, -1, 0, 0 });\n\n        pair<int, int> debug[40][40];\n\n        int vis[40][40][40] = {};\n        double ans = INF;\n        while (Q.size()) {\n            auto e = Q.top(); Q.pop();\n            if (vis[e.i][e.sp][e.prev]) continue;\n            vis[e.i][e.sp][e.prev] = 1;\n            if (e.i == g && e.sp == 1) ans = min(ans, e.cost);\n            loop (n, i) loop (3, d) {\n                int sp = e.sp-1+d;\n                if (dist[e.i][i] == INF || i == e.prev ||\n                        sp < 1 || sp > lim[e.i][i]) continue;\n                Q.push({ i, e.i, sp, e.cost + dist[e.i][i] / sp });\n            }\n        }\n        if (ans != INF) cout << ans << endl;\n        else cout << \"unreachable\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\n\n\n\nint main(){\n  int inx,iny,ind,inc;\n  double d[40][40][40];\n  int n,m,s,g;\n \n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n    \n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 6/15 8:57 ~ 920 1129\n */\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#define INF 2000000\n\nusing namespace std;\n\nstruct edge {\n  int to;\n  int dis;\n  int lim;\n};\ntypedef pair<int, int> P;\n\nint iN;\nint iM;\nint iS;\nint iG;\nvector<edge> G[31];\ndouble d[31][31 * 31];\n\nbool input() {\n  int i;\n  int x, y, d, c;\n  edge e;\n\n  scanf(\"%d %d\", &iN, &iM);\n  if (iN == 0 && iM == 0)\n    return false;\n  scanf(\"%d %d\", &iS, &iG);\n\n  for (i = 1; i <= iN; i++) {\n    G[i].clear();\n  }\n\n  for (i = 0; i < iM; i++) {\n    scanf(\"%d %d %d %d\", &x, &y, &d, &c);\n    e.dis = d;\n    e.lim = c;\n    e.to = y;\n    G[x].push_back(e);\n    e.to = x;\n    G[y].push_back(e);\n  }\n  return true;\n}\n\nvoid dijkstraQueue() {\n  int i;\n  priority_queue<P, vector<P> , greater<P> > que;\n\n  for (i = 1; i <= iN; i++)\n    fill(d[i], d[i] + (iN + 1) * 31, INF);\n  d[iS][0 * 31 + 0] = 0;\n  que.push(P(0, iS * 31 * 31 + 0 * 31 + 0));\n\n  while (!que.empty()) {\n    P p = que.top();\n    que.pop();\n    int v = p.second / 31 / 31;\n    int b = p.second / 31 % 31;\n    int s = p.second % 31;\n    if (d[v][b * 31 + s] < p.first)\n      continue;\n    for (i = 0; i < (int) G[v].size(); i++) {\n      edge e = G[v][i];\n      if (e.to == b)\n        continue;\n      if (s > 0 && s <= e.lim) {\n        double cost = (double)e.dis / s;\n        if (d[e.to][v * 31 + s] > d[v][b * 31 + s] + cost) {\n          d[e.to][v * 31 + s] = d[v][b * 31 + s] + cost;\n          que.push(P(d[e.to][v * 31 + s], e.to * 31 * 31 + v * 31 + s));\n        }\n      }\n      if (s - 1 > 0 && s - 1 <= e.lim) {\n        double cost = (double)e.dis / (s - 1);\n        if (d[e.to][v * 31 + s - 1] > d[v][b * 31 + s] + cost) {\n          d[e.to][v * 31 + s - 1] = d[v][b * 31 + s] + cost;\n          que.push(P(d[e.to][v * 31 + s - 1], e.to * 31 * 31 + v * 31 + (s - 1)));\n        }\n      }\n      if (s + 1 <= e.lim) {\n        double cost = (double)e.dis / (s + 1);\n        //printf(\"%d %d %d %f\\n\", v, b, s, d[v][b * 31 + s] + cost);\n        if (d[e.to][v * 31 + (s + 1)] > d[v][b * 31 + s] + cost) {\n          d[e.to][v * 31 + (s + 1)] = d[v][b * 31 + s] + cost;\n          que.push(P(d[e.to][v * 31 + (s + 1)], e.to * 31 * 31 + v * 31 + (s + 1)));\n        }\n      }\n    }\n  }\n}\n\nvoid output() {\n  int i;\n  double out;\n  out = d[iG][1 * 31 + 1];\n  for (i = 2; i <= iN; i++) {\n    out = min(out, d[iG][i * 31 + 1]);\n  }\n  if (out == INF)\n    printf(\"unreachable\\n\");\n  else\n    printf(\"%.4f\\n\", out);\n}\n\nint main() {\n  while (1) {\n    if (!input())\n      break;\n    dijkstraQueue();\n    output();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int n, m; cin >> n >> m&&n;) {\n\t\tint s, g; cin >> s >> g; s--, g--;\n\t\tvector<vector<double>> D(n, vector<double>(n, INF));\n\t\tvector<vector<int>> C(n, vector<int>(n, 0));\n\t\trep(i, 0, m) {\n\t\t\tint x, y, d, c; cin >> x >> y >> d >> c; x--, y--;\n\t\t\tD[x][y] = D[y][x] = d;\n\t\t\tC[x][y] = C[y][x] = c;\n\t\t}\n\t\tstatic double dp[33][33][33];\n\t\trep(i, 0, 33)rep(j, 0, 33)rep(k, 0, 33)dp[i][j][k] = INF;\n\t\tusing T = tuple<int, int, int>;\n\t\tqueue<T> q;\n\t\tq.emplace(s, -1, 0);\n\t\twhile (q.size()) {\n\t\t\tint cur, prev, e;\n\t\t\ttie(cur, prev, e) = q.front(); q.pop();\n\t\t\trep(next, 0, n) {\n\t\t\t\tif (next == prev)continue;\n\t\t\t\tif (C[cur][next] == 0)continue;\n\t\t\t\trep(k, e - 1, e + 2) {\n\t\t\t\t\tif (k <= 0)continue;\n\t\t\t\t\tif (C[cur][next] < k)continue;\n\t\t\t\t\tif (chmin(dp[next][cur][k], dp[cur][prev][e] + D[cur][next] / k))\n\t\t\t\t\t\tq.emplace(next, cur, k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = INF;\n\t\trep(i, 0, n) {\n\t\t\tif (chmin(ans, dp[g][i][1]))dump(ans);\n\t\t}\n\t\tcout << fixed << setprecision(10);\n\t\tif (ans == INF) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 95\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[40];    \n    \n    int inx,iny,ind,inc;\n    double d[40][40][40];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2009à\\ID £UI¬x\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\ntypedef vector< vector<int> > graph;\n\nclass Node{\npublic:\n\t// p : »ÝÊu\n\t// v : »ÝÌXs[h\n\t// prev : OÉ¢½XÔ\n\t// cost : ±±ÜÅÌ£\n\tint p, v, prev; double cost;\n\tNode(int p, int v, int prev, double cost) : p(p), v(v), prev(prev), cost(cost) {}\n\t// priority_queueÅ¸\\[gÉ·éÌªÊ|ÈÌÅCsðtÉè`µÄµÜ¤\n\tbool operator < (const Node &nd) const { return cost > nd.cost; }\n};\n\nint main(){\n\tint n, m, s, g;\n\twhile(cin >> n >> m){\n\t\tif(!(n||m)) break;\n\t\tcin >> s >> g;\n\t\tgraph gp(n);\n\t\t// £sñÆC§À¬xsñ(?)\n\t\tint dist[30][30];\n\t\tint limit[30][30];\n\t\t// óÔ(Êu, ¬x, OÌÊu)ª`FbNÏÝ©ð`FbN·éD\n\t\tbool visit[30][31][30];\n\t\tdouble len[30][31][30];\n\t\tmemset(visit, false, sizeof(visit));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tgp[x-1].push_back(y-1);\n\t\t\tgp[y-1].push_back(x-1);\n\t\t\tdist[x-1][y-1] = d,  dist[y-1][x-1] = d;\n\t\t\tlimit[x-1][y-1] = c, limit[y-1][x-1] = c;\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<=30;j++)\n\t\t\t\tfor(int k=0;k<n;k++) len[i][j][k] = 1e15;\n\t\tpriority_queue<Node> qu; qu.push(Node(s-1,0,s-1,0.0));\n\t\tdouble ans = -1.0;\n\t\t// _CLXg@ÅÅZoH·ðßé\n\t\twhile(!qu.empty()){\n\t\t\tNode nd = qu.top(); qu.pop();\n\t\t\tint p = nd.p, v = nd.v, prev = nd.prev;\n\t\t\t// `FbNÏÝÌóÔÈçcontinue\n\t\t\tif(visit[p][v][prev]) continue;\n\t\t\tvisit[p][v][prev] = true;\n\t\t\t// S[óÔ\n\t\t\tif(p==g-1 && v==1){\n\t\t\t\tans = nd.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<gp[p].size();i++){\n\t\t\t\tint next = gp[p][i];\n\t\t\t\t// U^[ÍÖ~\n\t\t\t\tif(next==prev) continue;\n\t\t\t\t// ¬xðÆµ½èã°½è\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tint nv = v+j;\n\t\t\t\t\tif(nv<=0||limit[p][next]<nv) continue;\n\t\t\t\t\tif(len[next][nv][p]-1e-8 > nd.cost+(double)dist[p][next]/nv){\n\t\t\t\t\t\tlen[next][nv][p] = nd.cost+(double)dist[p][next]/nv;\n\t\t\t\t\t\tqu.push(Node(next,nv,p,len[next][nv][p]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans < 0.0) cout << \"unreachable\" << endl;\n\t\telse          printf(\"%.5f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 91 // いつもは1<<29だが小さくすれば時間はやくなる？\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(int i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cxxabi.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    ((ll)1ll<60)\n#define INF     ((int)1<<30)\n#define EPS     (1e-9)\n#define MOD     (1000000007)\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\n//template<class S>auto&operator<<(ostream&os,vector<S>t){bool b=1;for(auto s:t)os<<(exchange(b,0)||strlen(abi::__cxa_demangle(typeid(S).name(),0,0,0))>20?\"\":\" \")<<s;return os<<endl;}\n\ntemplate<class E, class Q,typename C=typename remove_reference<decltype(get<0>(declval<Q&>()))>::type>\nstruct Dijkstra{\n    C maxVal=numeric_limits<C>::max();\n    int n;\n    vector<vector<E>> edge;\n    vector<vector<vector<C>>> distance;\n    Dijkstra(int N):n(N){\n        edge.resize(n);\n        distance=vector<vector<vector<C>>>(n,vector<vector<C>>(n,vector<C>(31,maxVal)));\n    }\n    void add(int a, E stat, bool dir=true){\n        edge[a].push_back(stat);\n        if(!dir)return;\n        swap(a,get<0>(stat));\n        edge[a].push_back(stat);\n    }\n    C dist(int s,int g){\n        auto cmp=[](Q a,Q b){return get<0>(a)>get<0>(b);};\n        priority_queue<Q,vector<Q>,decltype(cmp)> pq(cmp);\n        C ret=maxVal;\n        pq.emplace(0,s,s,0); /*初期値*/\n        while(!pq.empty()){ /*中身は自分で書く*/\n            double cost;\n            int prev,curr,spd;\n            tie(cost,prev,curr,spd)=pq.top(); pq.pop();\n            if(distance[curr][prev][spd]!=maxVal) continue;\n            distance[curr][prev][spd]=cost;\n            if(curr==g and spd==1){\n                ret=cost;\n                break;\n            }\n            for(auto e:edge[curr]){\n                int next,len,limit;\n                tie(next,len,limit)=e;\n                if(next==prev)continue;\n                if(spd+1<=limit and distance[next][curr][spd+1]==maxVal)\n                    pq.emplace(cost+(C)len/(spd+1),curr,next,spd+1);\n                if(spd<=limit and distance[next][curr][spd]==maxVal)\n                    pq.emplace(cost+(C)len/(spd),curr,next,spd);\n                if(spd-1<=limit and spd-1>0 and distance[next][curr][spd-1]==maxVal)\n                    pq.emplace(cost+(C)len/(spd-1),curr,next,spd-1);\n            }\n        }\n        return ret;\n    }\n};\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t    int s,g; cin>>s>>g;\n\t    Dijkstra<tuple<int,int,int>,tuple<double,int,int,int>> ds(n+1);\n\t    rep(i,m){\n\t        int x,y,d,c;\n\t        cin>>x>>y>>d>>c;\n\t        ds.add(x,make_tuple(y,d,c));\n\t    }\n\t    auto ans=ds.dist(s,g);\n\t    if(ans==numeric_limits<double>::max()){\n    \t    cout<<\"unreachable\"<<endl;\n\t    }else{\n\t        cout<<setprecision(5)<<fixed<<ans<<endl;\n\t    }\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\nint n,m,s,g;\ndouble d[40][40][40];\n\nint main(){\n  int inx,iny,ind,inc;\n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n\n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=0;i<31;i++)for(int j=0;j<31;j++)for(int k=0;k<31;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n    \n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<iomanip>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define sc second\n#define pb push_back\n#define mk make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntemplate<class S,class T>\nostream &operator<<(ostream &out, const pair<S,T> p){\n\treturn out << \"(\" << p.fs << \", \" << p.sc << \")\";\n}\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \", \";\n\treturn out << \"}\" << endl;\n}\n\n#define N 30\ndouble d[N+1][N];\n// time, from, current, ver\nstruct elem{\n\tdouble t;\n\tint f,c,s;\n\telem(){};\n\telem(double time, int from, int cur, int sp){\n\t\tt = time; f = from; c = cur; s = sp;\n\t}\n\tbool operator<(const elem r) const{ return mk(mk(t, f),mk(c,s)) < mk(mk(r.t,r.f), mk(r.c,r.s)); }\n};\nostream &operator<<(ostream &out, const elem &e){\n\treturn out << \"{\" << e.t << \", \" << e.f << \", \" << e.c << \", \" << e.s << \"}\";\n}\n\n\nint main(){\n\tint n, m, s, g;\n\twhile(cin >> n >> m, n){\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\t\tfill(d[0], d[0] + (N+1) * N, -1);\n\t\tvector<pair<int,double> > e[N+2][N];// e[c][x] : from x at vert c list\n\t\trep(i, m){\n\t\t\tint x, y, di, c;\n\t\t\tcin >> x >> y >> di >> c;\n\t\t\tx--; y--;\n\t\t\treps(j,1,c+1){\n\t\t\t\tdouble time = di / (double) j;\n\t\t\t\te[j][x].pb(mk(y, time));\n\t\t\t\te[j][y].pb(mk(x, time));\n\t\t\t}\n\t\t}\n\t\tpriority_queue<elem> q;\n\t\tq.push(elem(-0.0, -1, s, 0));//initial state\n\t\twhile(!q.empty()){\n\t\t\telem el = q.top();\n\t\t\tdouble dst = - el.t;\n\t\t\tint from = el.f, cur = el.c, sp = el.s;\n\t\t\tq.pop();\n\t\t\tif(d[sp][cur] > -0.5){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[sp][cur] = dst;\n//\t\t\tcout << el << endl;\n\t\t\tif(sp == 1 && cur == g) break;\n\t\t\trep(i,3){\n\t\t\t\tint ci = sp - 1 + i;\n\t\t\t\tif(ci<1 || ci > N+1) continue;\n\t\t\t\trep(j, e[ci][cur].size()){\n\t\t\t\t\tpair<int, double> p = e[ci][cur][j];\n\t\t\t\t\tint to = p.fs;\n\t\t\t\t\tif (from == to) continue;\n\t\t\t\t\tdouble tmp = dst + p.sc;\n\t\t\t\t\tq.push(elem(-tmp, cur, to, ci));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\treps(i, 1, N+1){\n\t\t\tcout << \"v : \" << i << endl;\n\t\t\trep(j, n) cout << d[i][j] << \", \";\n\t\t\tcout << endl;\n\t\t}\n*/\n\t\tif(d[1][g] < 0) cout << \"unreachable\" << endl;\n\t\telse cout <<fixed << setprecision(10)<< d[1][g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n\tint cost,limit;\n\tedge(int c,int l){\n\t\tcost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tvector<vector<edge> > E(n+1,vector<edge>(n+1,edge(-1,-1)));\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in][out]=edge(c,l);\n\t\tE[out][in]=edge(c,l);\n\t}\n\n\tdouble Ans[31][31][31];\n\tmemset(Ans,-1,sizeof(Ans));\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){\n\t\tNode t=Q.top(); Q.pop();\n\t\tif(Ans[t.now][t.before][t.speed]<=t.time && Ans[t.now][t.before][t.speed]>=0) continue;\n//\t\tcout<<t.now<<\" \"<<t.speed<<\" \"<<t.time<<endl;\n\t\tif(t.now==g && t.speed==1){printf(\"%.12lf\\n\", t.time );  return;}\n\t\tAns[t.now][t.before][t.speed]=t.time;\n\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tif(i==t.before) continue;\n\t\t\tif(E[t.now][i].cost>0){\n\t\t\t\tif(E[t.now][i].limit>=t.speed && t.speed>=1){\n\t\t\t\t\tQ.push(Node(i,t.speed,t.time+E[t.now][i].cost/(double)t.speed,t.now));\n\t\t\t\t}\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed+1)\n\t\t\t\t\tQ.push(Node(i,t.speed+1,t.time+E[t.now][i].cost/(double)(t.speed+1.0),t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed-1 && t.speed-1>=1)\n\t\t\t\t\tQ.push(Node(i,t.speed-1,t.time+E[t.now][i].cost/(double)(t.speed-1.0),t.now));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\"<<endl;\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<pair<double,int>,pair<int,int> >P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a2,a3,a4;\ndouble d[31][31][31];\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)r(k,31)d[i][j][k]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      cin>>a1>>a2>>a3>>a4;\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P,vector<P>,greater<P> >q;\n    P xt;xt.fi.fi=0,xt.fi.se=0,xt.se.fi=st,xt.se.se=-1;\n    q.push(xt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.se.fi,pp=p.se.se;\n      if(cur==go&&p.fi.se==1){\n        printf(\"%.9f\\n\",p.fi.fi);\n        goto L;\n      }\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=p.se.se)r(j,3){\n          int x=p.fi.se+dx[j];\n          if(0<x&&x<31&&x<=e.lim){\n            if(d[e.to][pp][x]>1.0*e.dist/x+p.fi.fi){\n              d[e.to][pp][x]=1.0*e.dist/x+p.fi.fi;\n              P xt;xt.fi.fi=d[e.to][pp][x],xt.fi.se=x,xt.se.fi=e.to,xt.se.se=cur;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    cout<<\"unreachable\"<<endl;L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\n\nclass State{\npublic:\n  int pos, v, pre;\n  double time;\n  State(){}\n  State(int pos, int v, int pre, double time) : pos(pos), v(v), pre(pre), time(time) {}\n};\n\nint n, m, s, g;\nP edge[30][30];\n\nvoid solve(){\n  State u, v;\n  bool reach = false;\n  u = State(s, 0, 0, 0.0);\n  queue<State> que;\n  double vis[30][900];\n  fill(vis[0], vis[30], 100000000.0);\n  vis[u.pos][u.v] = u.time;\n  que.push(u);\n  while(!que.empty()){\n    u = que.front(); que.pop();\n    //cout << u.pos << ' ' << u.v << ' ' << u.pre << ' ' << u.time << endl;\n    if(u.pos == g && u.v == 1){\n      reach = true;\n      continue;\n    }\n    for(int i=0;i<n;i++){\n      if(edge[u.pos][i].first == INF) continue;\n      if(u.pre == i) continue;\n      for(int k=-1;k<=1;k++){\n        if(u.v + k > edge[u.pos][i].second) continue;\n        if(u.v + k <= 0) continue;\n        v = State(i, u.v + k, u.pos, u.time + edge[u.pos][i].first / (double)(u.v + k));\n        //cout << '\\t' << v.pos << ' ' << v.v << ' ' << v.pre << ' ' << v.time << ' ' << vis[v.pos][v.v] << endl;\n        if(vis[v.pos][v.v] > v.time){\n          vis[v.pos][v.v] = v.time;\n          que.push(v);\n        }\n      }\n    }\n  }\n  if(reach) printf(\"%.5f\\n\", vis[g][1]);\n  else printf(\"unreachable\\n\");\n}\n\n\nmain(){\n  while(scanf(\"%d%d\", &n, &m) && (n|m)){\n    scanf(\"%d%d\", &s, &g);\n    s--; g--;\n    fill(edge[0], edge[30], P(INF, 0));\n    for(int i=0;i<m;i++){\n      int a, b, c, d;\n      scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n      a--; b--;\n      edge[a][b] = edge[b][a] = P(c, d);\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  int x,p,v;\n  double t;\n  bool operator<(S s)const{\n    return t>s.t;\n  }\n};\n\nint main(){\n  for(int n,m;cin>>n>>m,n;){\n    int s,g;\n    cin>>s>>g;\n    int d[31][31];\n    int l[31][31]={};\n    for(int i=0;i<m;i++){\n      int x,y,di,c;\n      cin>>x>>y>>di>>c;\n      d[x][y]=d[y][x]=di;\n      l[x][y]=l[y][x]=c;\n    }\n    bool p[31][31][31]={};\n    priority_queue<S> que;\n    que.push({s,0,0,0});\n    while(!que.empty()){\n      S cs=que.top();\n      if(cs.x==g&&cs.v==1)break;\n      que.pop();\n      if(p[cs.x][cs.p][cs.v]++)continue;\n      for(int i=0;i<=n;i++){\n\tif(cs.p==i)continue;\n\tfor(int j=-1;j<=1;j++){\n\t  int nv=cs.v+j;\n\t  if(nv<=0||l[cs.x][i]<nv)continue;\n\t  que.push({i,cs.x,nv,cs.t+d[cs.x][i]*1./nv});\n\t}\n      }\n    }\n    if(que.empty()){\n      cout<<\"unreachable\"<<endl;\n    }else{\n      cout<<fixed<<que.top().t<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<double,int> P;\nstruct edge{int to;double cost;};\n\nint n,m,s,go;\ndouble d[27002];\nvector<edge> g[27002];\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> > q;\n\tfill(d,d+27002,INF);\n\td[s]=0;\n\tq.push(P(0,s));\n\twhile(!q.empty()){\n\t\tP p=q.top();q.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tif(v==1)break;\n\t\trep(i,g[v].size()){\n\t\t\tedge e=g[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>m&&n){\n\t\trep(i,27002)g[i].clear();\n\t\tcin>>s>>go;s--;go--;\n\t\tedge e;\n\t\trep(i,n){\n\t\t\te.to=1;\n\t\t\te.cost=0;\n\t\t\tg[i*n+go+2].push_back(e);\n\t\t}\n\t\trep(i,m){\n\t\t\tint x,y,c;\n\t\t\tdouble dd;\n\t\t\tcin>>x>>y>>dd>>c;\n\t\t\tx--;y--;\n\t\t\trep(v,c+2)rep(p,n){\n\t\t\t\tif(v==31)break;\n\t\t\t\tif(v==0){\n\t\t\t\t\tif(x==s){\n\t\t\t\t\t\te.to=x*n+y+2;\n\t\t\t\t\t\te.cost=dd;\n\t\t\t\t\t\tg[0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t\tif(y==s){\n\t\t\t\t\t\te.to=y*n+x+2;\n\t\t\t\t\t\te.cost=dd;\n\t\t\t\t\t\tg[0].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int j=-1;j<2;j++){\n\t\t\t\t\t\tif(v+j>0&&v+j<=c&&p!=x&&p!=y){\n\t\t\t\t\t\t\te.to=(v+j-1)*n*n+x*n+y+2;\n\t\t\t\t\t\t\te.cost=dd/(v+j);\n\t\t\t\t\t\t\tg[(v-1)*n*n+p*n+x+2].push_back(e);\n\t\t\t\t\t\t\te.to=(v+j-1)*n*n+y*n+x+2;\n\t\t\t\t\t\t\tg[(v-1)*n*n+p*n+y+2].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijkstra(0);\n\t\tif(d[1]<INF)cout<<d[1]<<endl;\n\t\telse cout<<\"unreachable\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n \nusing namespace std;\n \nconst int MAX = 50;\nconst int INF = (1<<25);\nint n,m;\nstruct Edge{\n  int to;\n  double dis,lim;\n  Edge(int a, double b, double c){\n    to = a;\n    dis = b;\n    lim = c;\n  }\n};\n \nstruct State{\n  int pos,from;\n  double speed,t;\n  State(int a, double b, double c, int f){\n    pos = a;\n    speed = b;\n    t = c;\n    from = f;\n  }\n  bool operator < (const State& s) const{ return t > s.t;}\n};\n \nvector<Edge> E[MAX];\ndouble T[MAX][MAX];\n//T[i][j] := shortest time to i with speed j.\n \n \nvoid init(){\n  for(int i = 0; i < MAX; i++){\n    fill(T[i],T[i]+MAX,INF);\n    E[i].clear();\n  }\n}\n \nvoid input(){\n  for(int i = 0; i < m; i++){\n    int x,y;\n    double d,c;\n    cin >> x >> y >> d >> c;\n    cerr << x << \" \" << y << \" \" << d << \" \" << c << endl;  \n    //   cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    E[x].push_back(Edge(y,d,c));\n    E[y].push_back(Edge(x,d,c));\n  }\n}\n \nvoid solve(int s, int g){\n \n  priority_queue<State> Q;\n  T[s][0] = 0;\n  Q.push(State(s,0,0,-1));\n \n  while(!Q.empty()){\n    State s = Q.top();\n    Q.pop();\n \n    if(s.t > T[s.pos][(int)s.speed]) continue;\n \n    for(int i = 0; i < E[s.pos].size(); i++){\n      int np = E[s.pos][i].to;\n \n      if(np == s.from) continue;\n \n      double sp[] = {-1,0,1};\n       \n      for(int j = 0; j < 3; j++){\n    double ns = s.speed+sp[j];\n    if(ns <= 0 || ns > E[s.pos][i].lim) continue;\n    double nt = s.t+E[s.pos][i].dis/ns;\n    if(T[np][(int)ns] > nt){\n      T[np][(int)ns] = nt;\n      Q.push(State(np,ns,nt,s.pos));\n    }\n      }\n    }\n  }\n   \n \n  if(T[g][1] == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.6f\\n\",T[g][1]);\n}\n \nint main(){\n   \n  while(cin >> n >> m && n+m){\n    cerr << n << \" \" << m << endl;\n    init();\n    int s,g;\n    cin >> s >> g;\n    cerr << s << \" \" << g << endl;\n    input();\n    solve(s,g);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst double INF = 1 << 29;\n\nstruct edge {\n    int to;\n    int cost;\n    int limit;\n\n    edge() {}\n    edge(int a, int b, int c): to(a), cost(b), limit(c) {}\n};\n\nstruct state {\n    int pos;\n    double cost;\n    int speed;\n    int prev;\n\n    state() {}\n    state(int a, double b, int c, int d): pos(a), cost(b), speed(c), prev(d) {}\n\n    bool operator < (const state& o) const {\n        return cost > o.cost;\n    }\n};\n\nint N, M, S, G;\n\nvector<edge> graph[30];\n\ndouble memo[30][31][30];\n\n\nbool solve() {\n    cin >> N >> M;\n    if (N+M == 0) { return false; }\n\n    for (int j = 0; j < N; ++j) { graph[j].clear(); }\n    for (int j = 0; j < N; ++j) {\n        for (int k = 0; k <= 30; ++k) {\n            fill(memo[j][k], memo[j][k]+30, INF);\n        }\n    }\n\n\n    cin >> S >> G;\n    --S; --G;\n    for (int j = 0; j < M; ++j) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        --x; --y;\n\n        graph[x].emplace_back(y, d, c);\n        graph[y].emplace_back(x, d, c);\n    }\n\n    priority_queue<state> pq;\n    pq.emplace(S, 0, 1, 0);\n    memo[S][1][S] = 0;\n    while (!pq.empty()) {\n        state st = pq.top(); pq.pop();\n        if (st.cost > memo[st.pos][st.speed][st.prev]) { continue; }\n\n        for (edge& e: graph[st.pos]) {\n            if (st.prev == e.to) { continue; }\n            for (int dv = -1; dv <= 1; ++dv) {\n                if (st.pos == S && dv != 0) { continue; }\n\n                int next_speed = st.speed + dv;\n                if (next_speed <= 0 || e.limit < next_speed) { continue; }\n\n                double next_cost = st.cost + (double)e.cost / next_speed;\n                if (next_cost < memo[e.to][next_speed][st.pos]) {\n                    memo[e.to][next_speed][st.pos] = next_cost;\n                    pq.emplace(e.to, next_cost, next_speed, st.pos);\n                }\n            }\n\n        }\n    }\n    double ans = INF;\n    for (int j = 0; j < N; ++j) {\n        ans = min(ans, memo[G][1][j]);\n    }\n    if (fabs(ans-INF) < 1e-7) { printf(\"unreachable\\n\"); }\n    else { printf(\"%.12f\\n\", ans); }\n    return true;\n}\n\nint main() { for (; solve(); ); return 0; }"
  },
  {
    "language": "C++",
    "code": "\n#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong double memo[10000][32];\nstruct edge {\n\tint id;\n\tint from;\n\tint to;\n\tint lim;\n\tlong double dis;\n};\nstruct aa {\n\tint id;\n\tint speed;\n\tlong double  time;\n};\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 10000; ++i) {\n\t\t\tfor (int j = 0; j < 32; ++j) {\n\t\t\t\tmemo[i][j] = 999999999;\n\t\t\t}\n\t\t}\n\t\tint n, m; cin >> n >> m;\n\t\tif (!n)break;\n\t\tint s, g; cin >> s >> g; s--; g--;\n\t\tvector<edge>edges;\n\t\tvector<vector<int>>edgeids(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tlong double d;\n\t\t\tint x, y, c; cin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tedges.push_back(edge{ 2*i,x,y,c,d });\n\t\t\tedges.push_back(edge{ 2*i+1,y,x,c,d });\n\t\t\tedgeids[x].push_back(2 * i);\n\t\t\tedgeids[y].push_back(2 * i + 1);\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tfor (auto i : edgeids[s]) {\n\n\t\t\tque.push(aa{ i,1,edges[i].dis });\n\t\t\tmemo[i][1] = edges[i].dis;\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst edge oldedge(edges[atop.id]);\n\t\t\tconst int oldsp(atop.speed);\n\t\t\tconst long double oldtime(atop.time);\n\t\t\tfor (auto i : edgeids[oldedge.to]) {\n\t\t\t\tconst edge nextedge(edges[i]);\n\t\t\t\tif (nextedge.to == oldedge.from)continue;\n\t\t\t\telse {\n\t\t\t\t\tfor (int change = -1; change <= 1; ++change) {\n\t\t\t\t\t\tconst int nextsp = oldsp + change;\n\t\t\t\t\t\tif (nextsp == 0)continue;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (nextsp <= nextedge.lim) {\n\t\t\t\t\t\t\t\tconst long double nexttime= nextedge.dis / nextsp + oldtime;\n\t\t\t\t\t\t\t\tif (memo[i][nextsp] > nexttime) {\n\t\t\t\t\t\t\t\t\tmemo[i][nextsp] = nexttime;\n\t\t\t\t\t\t\t\t\tque.push(aa{ i,nextsp,nexttime });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong double amin = 999999999;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tif (edges[i].to == g) {\n\t\t\t\tamin = min(amin, memo[i][1]);\n\t\t\t}\n\t\t}\n\t\tif (amin > 99999999) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << amin << endl;\n\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\nint n,m,s,g;\ndouble d[40][40][40];\n\nint main(){\n  int inx,iny,ind,inc;\n  while(true){\n    cin >> n >> m;\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n\n    cin >> s >> g;\n    for(int i=0;i<40;i++)for(int j=0;j<40;j++)for(int k=0;k<40;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n      cin >> inx >> iny >> ind >> inc;\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\tif(q.F.F == p.F.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1)que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n   \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else cout << \"unreachable\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string.h>\n#define EPS (1.0e-9)\n#define LT(x, y) ((x) - (y) <= -EPS) // x < y\n#define INF (1<<19)\nusing namespace std;\ntypedef struct DisLim {\n int d, c; // dist, limit v\n DisLim() {}\n DisLim(int d, int c) : d(d),c(c) {}\n} DisLim;\nint N,M;\nint S,G; // start, goal\nDisLim F[31][31];\n\ndouble dist[31][31][31];\nbool visited[31][31][31];\nclass State {\npublic:\n int bpos, cpos; // before,current\n double d; // ツ仰猟猟」\n int v; // ツ堕ャツ度\n State (int bpos, int cpos, double d, int v) :\n   bpos(bpos),cpos(cpos),d(d),v(v) {}\n bool operator < (const State &s) const {\n   //return d > s.d;\n   return LT(s.d,d);\n }\n};\n\npriority_queue<State> PQ;\ndouble solve() {\n  while(!PQ.empty()) {\n    State u = PQ.top(); PQ.pop();\n    int bpos=u.bpos, cpos=u.cpos, v=u.v;\n    double d = u.d;\n    \n    visited[bpos][cpos][v] = true;\n    if(cpos == G && v == 1) {\n      return dist[bpos][G][1];\n    }\n\n    for(int i=1;i<=N;i++) { // ツ篠淞づ個都ツ市\n      if(i==bpos || i==cpos) continue; // ツ古」ツ姪淞づィツ凝鳴止\n      for(int j=-1;j<=1;j++) { // ツ嘉個クツ堕ャツ堕閉置\n\tif(bpos==S && S==cpos && j != 0) continue;\n\tif(v+j <= 0) continue;\n\tif(v+j > F[cpos][i].c) continue;\n\tif(visited[cpos][i][v+j]) continue;\n\tif(F[cpos][i].d >= INF) continue;\n\tdouble cost = dist[bpos][cpos][v] + (double)F[cpos][i].d / (v+j);\n\tif(LT(cost,dist[cpos][i][v+j])) {\n\t  dist[cpos][i][v+j] = cost;\n\t  PQ.push(State(cpos,i,cost,v+j));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nmain() {\n while(cin>>N>>M,N) {\n   PQ = priority_queue<State>();\n   memset(visited,0,sizeof(visited));\n   for(int i=1;i<=N;i++) {\n     for(int j=1;j<=N;j++) {\n       F[i][j].d=INF;\n     }\n   }\n   cin>>S>>G;\n   for(int i=1;i<=N;i++) {\n     for(int j=1;j<=N;j++) {\n       for(int k=0;k<31;k++) {\n         dist[i][j][k] = INF;\n       }\n     }\n   }\n   for(int i=0;i<31;i++) {\n     dist[S][S][i] = 0;\n   }\n   PQ.push(State(S,S,0,1));\n   for(int i=0;i<M;i++) {\n     int x,y,d,c; cin>>x>>y>>d>>c;\n     F[x][y]=F[y][x]=DisLim(d,c);\n   }\n   double ans = solve();\n   if(ans==-1) puts(\"unreachable\");\n   else printf(\"%.5lf\\n\",ans);\n }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<queue>\n#include<iomanip>\n\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vvi = vector<vector<int> >;\nusing vvd = vector<vd>;\nusing pii = pair<int, int>;\nusing ppi = pair<pii, int>;\n\n#define INF 10000.0\n\nclass city{\npublic:\n  int to; double d; int c;\n  city(int x, double y, int z):to(x), d(y), c(z){}\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int ti = clock();\n  // start-----------------------------------------------\n  int n, m;\n  while(cin >> n >> m, n){\n    int s, g; cin >> s >> g;\n    s--, g--;\n    vector<vector<city>> edges(n, vector<city>(n, {0, 0, 0}));\n    vector<vvd> costs(n, vvd(31, vd(n, INF)));\n    for(int i = 0; i < m; i++){\n      int x, y; double d; int c;\n      cin >> x >> y >> d >> c;\n      x--; y--;\n      edges[x][y] = {y, d, c};\n      edges[y][x] = {x, d, c};\n    }\n    priority_queue<pair<pair<double, int>, pii>, vector<pair<pair<double, int>, pii>>, greater<pair<pair<double, int>, pii>>> q;\n    for(int i = 0; i < n; i++){\n      if(edges[s][i].c != 0){\n        q.push({{edges[s][i].d, 1}, {s, i}});\n      }\n    }\n    while(!q.empty()){\n      pair<pair<double, int>, pii> now = q.top(); q.pop();\n      int from = now.second.first;\n      int to = now.second.second;\n      int  vel = now.first.second;\n      double dist = now.first.first;\n      if(costs[to][vel][from] <= dist) continue;\n      costs[to][vel][from] = dist;\n      // if(to == g && vel == 1) break;\n      for(int i = 0; i < n; i++){\n        if(i == from || i == to) continue;\n        if(edges[to][i].c == 0) continue;\n        for(int j = -1; j <= 1; j++){\n          if(vel + j <= 0 || edges[to][i].c < vel+j) continue;\n          q.push({{dist + edges[to][i].d / (double)(vel+j), vel+j}, {to, i}});\n        }\n      }\n    }\n    double ans = INF;\n    for(int i = 0; i < n; i++) ans = min(ans, costs[g][1][i]);\n    if(ans != INF) cout << fixed << setprecision(16) << ans << endl;\n    else cout << \"unreachable\" << endl;\n  }\n\n  // end-----------------------------------------------\n  // cerr << 1.0 * (clock() - ti) / CLOCKS_PER_SEC << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\nstruct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n\nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\n// (time,speed,node,pre_node)\nusing P = pair<pair<double,int>,pair<int,int>>;\n\n\nP makeP(double t,int s,int n,int np){\n    return make_pair(make_pair(t,s),make_pair(n,np));\n}\n\nvoid solve(int n,int m){\n    int start,goal; cin>>start>>goal;\n    start--;\n    goal--;\n    vector<vector<int>> g(n,vector<int>(n,INF));\n    vector<vector<int>> lim(n,vector<int>(n,0));\n    rep(i,m){\n        int x,y,d,c;\n        cin>>x>>y>>d>>c;\n        x--;\n        y--;\n        g[x][y] = d;\n        g[y][x] = d;\n        lim[x][y] = c;\n        lim[y][x] = c;\n    }\n\n    double visited[32][32][32];\n    rep(i,32) rep(j,32) rep(k,32) visited[i][j][k]=DBL_MAX/3;\n    visited[start][0][start] = 0;\n\n    priority_queue<P,vector<P>,greater<P>> que;\n    que.push(makeP(0,0,start,start));\n    while(!que.empty()){\n        auto p = que.top();\n        que.pop();\n        double time = p.first.first;\n        int speed = p.first.second;\n        int node = p.second.first;\n        int pre = p.second.second;\n\n#ifdef DEBUG\n        cerr << \"time : \" << time << \" \"  << \"node : \" << node+1 << \" \" << \"speed \" << speed << endl;\n#endif\n        if(node==goal and speed==1){\n            cout << Double(time) << endl;\n            return;\n        }\n\n        if(time > visited[node][speed][pre]) continue;\n\n        for(int next_node=0;next_node<n;next_node++){\n            if(next_node==node or next_node==pre) continue;\n            if(g[node][next_node]==INF) continue;\n            int d=g[node][next_node];\n            int c=lim[node][next_node];\n            for(int nspeed=max(speed-1,0);nspeed<=speed+1;nspeed++){\n                if(nspeed>c) continue;\n                double nt = time + (double)d/nspeed;\n                if(nt < visited[next_node][nspeed][pre]){\n#ifdef DEBUG\n                    cerr << \"\\t time \" << nt << \" \" << \"node \" << next_node+1 << \" speed \" << nspeed << endl;\n#endif\n                    visited[next_node][nspeed][pre] = nt;\n                    que.push(makeP(nt,nspeed,next_node,node));\n                }\n            }\n        }\n    }\n    cout << \"unreachable\" << endl;\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m){\n        if(n==0 && m==0) break;\n        solve(n,m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\nstruct edge {int to, dist, c;} ;\n\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pi3;\ntypedef pair<double, pi3> P; // time, vertex, from, velocity\n\nint main() {\n    while(true) {\n        int n, m;\n        cin >> n >> m;\n        if (n==0) break;\n\n        int s, g;\n        cin >> s >> g;\n\n        double time[40][40][40]; // vertex, velocity, from\n        REP(i, n) {\n            REP(j, 31) {\n                REP(k, n) {\n                    time[i][j][k] = 1000000000;\n                }\n            }\n        }\n        time[s-1][0][s-1] = 0;\n\n        vector<edge> gr[40];\n        REP(i, m) {\n            int x, y, d, c;\n            cin >> x >> y >> d >> c;\n            \n            edge e1;\n            e1.to = y-1;\n            e1.dist = d;\n            e1.c = c;\n            gr[x-1].push_back(e1);\n\n            edge e2;\n            e2.to = x-1;\n            e2.dist = d;\n            e2.c = c;\n            gr[y-1].push_back(e2);\n        }\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        P q = P(0.0, pi3(s-1, pii(s-1, 0)));\n        que.push(q);\n\n        while(!que.empty()) {\n            P q = que.top(); que.pop();\n            double t = q.first;\n            int v = q.second.first;\n            int from = q.second.second.first;\n            int velo = q.second.second.second;\n            if (time[v][velo][from] < t) continue;\n\n            REP(i, gr[v].size()) {\n                if (gr[v][i].to == from) continue; // u-turn\n                REP(a, 3) {\n                    int accel = a-1;\n                    if(velo+accel <= 0 || velo+accel > gr[v][i].c) continue;\n\n                    if (time[gr[v][i].to][velo+accel][v] >\n                            time[v][velo][from] + (double)gr[v][i].dist / (double)(velo+accel)){\n                        time[gr[v][i].to][velo+accel][v]= \n                            time[v][velo][from] + (double)gr[v][i].dist / (double)(velo+accel);\n                        \n                        P q = P(time[gr[v][i].to][velo+accel][v],\n                                pi3(gr[v][i].to, pii(v, velo+accel)));\n                        que.push(q);\n                    }\n                }\n            }\n        }\n        \n        double output = 1000000000;\n        REP(i, n) {\n            output = min(time[g-1][1][i], output);\n        }\n\n        if (output == 1000000000) {\n            cout << \"unreachable\" << endl;\n        } else {\n            printf(\"%.10lf\\n\", output);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n#define INF INT_MAX/3\n#define EPS 1e-14\n\ntypedef long long int lli;\ntypedef tuple<int,double,int> Road; // node/distance/limit\ntypedef tuple<double, int, int, int> Dat; \n  // time/current node/verocity/previous node\n\nconst int NMAX = 32, CMAX = 32;\ndouble dp[NMAX][CMAX];\nint n, m, s, g;\n\nint main() {\n  while (cin >> n >> m and n) {\n    cin >> s >> g;\n    vector<vector<Road>> G(n + 1);\n    REP(i, m) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      G[x].push_back(Road(y, d, c));\n      G[y].push_back(Road(x, d, c));\n    }\n    REP(i, NMAX) REP(j, CMAX) { dp[i][j] = INF; }\n    priority_queue<Dat,vector<Dat>, greater<Dat>> que;\n    que.push(Dat(0, s, 1, INF));\n    dp[s][1] = 0;\n    while (!que.empty()) {\n      Dat dat = que.top(); que.pop();\n      double cost = get<0>(dat);\n      int v = get<1>(dat), speed = get<2>(dat), from = get<3>(dat);\n      if (v == 0) throw 1;\n//      printf(\"(%d->%d, %fs,\\t%dm/s)\\n\", from, v, cost, speed);\n      if (cost > dp[v][speed]) continue;\n      for (Road r : G[v]) FOR(dv, -1, 2) {\n        int to = get<0>(r), limit = get<2>(r);\n        double dist = get<1>(r);\n        if (to == from or speed <= 0 or limit < speed) continue;\n        double newtime = dp[v][speed] + dist / speed;\n        if (dp[to][speed + dv] > newtime) {\n          dp[to][speed + dv] = newtime;\n          que.push(Dat(newtime, to, speed + dv, v));\n//          printf(\"push (%d->%d, %fs,\\t%dm/s)\\n\", v, to, newtime, speed);\n        }\n      }\n    }\n    if (dp[g][0] > INF / 2) {\n      cout << \"unreachable\" << endl;\n    } else {\n      cout << fixed << setprecision(6) << dp[g][0] << endl;\n    }\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nusing tp = tuple<int, int, int>;\nusing ttp = tuple<ld, int, int>;\n\nconst ld INF = 1e20;\n\nint main()\n{\n\tcout << fixed << setprecision(8);\n\tint n, m;\n\twhile (cin >> n >> m, n | m) {\n\t\tint s, g;\n\t\tcin >> s >> g; s--, g--;\n\t\tvector<vector<tp>> G(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c; x--, y--;\n\t\t\tG[x].emplace_back(y, d, c);\n\t\t\tG[y].emplace_back(x, d, c);\n\t\t}\n\t\tvector<vector<ld>> d(n, vector<ld>(33, INF));\n\t\tpriority_queue<ttp, vector<ttp>, greater<ttp>> pq;\n\t\tpq.emplace(0.0, 1, s);\n\t\twhile (!pq.empty()) {\n\t\t\tauto p = pq.top(); pq.pop();\n\t\t\tint v = get<2>(p), ve = get<1>(p);\n\t\t\tld cos = get<0>(p);\n\t\t\tif (d[v][ve] != INF) continue;\n\t\t\td[v][ve] = cos;\n\t\t\tif (ve == 0) continue;\n\t\t\tfor (auto e : G[v]) {\n\t\t\t\tint to = get<0>(e), st = get<2>(e);\n\t\t\t\tld dis = get<1>(e);\n\t\t\t\tif (st < ve) continue;\n\t\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\t\tif (d[to][ve + i] == INF) {\n\t\t\t\t\t\tpq.emplace(cos + dis / ve, ve + i, to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[g][0] == INF) cout << \"unreachable\" << endl;\n\t\telse cout << d[g][0] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst double INF = 1 << 29;\n\nstruct edge {\n    int to;\n    int cost;\n    int limit;\n\n    edge() {}\n    edge(int a, int b, int c): to(a), cost(b), limit(c) {}\n};\n\nstruct state {\n    int pos;\n    double cost;\n    int speed;\n    int prev;\n\n    state() {}\n    state(int a, double b, int c, int d): pos(a), cost(b), speed(c), prev(d) {}\n\n    bool operator < (const state& o) const {\n        return cost > o.cost;\n    }\n};\n\nint N, M, S, G;\n\nvector<edge> graph[30];\n\ndouble memo[30][31][30];\n\n\nbool solve() {\n    cin >> N >> M;\n    if (N+M == 0) { return false; }\n\n    for (int j = 0; j < N; ++j) { graph[j].clear(); }\n    for (int j = 0; j < N; ++j) {\n        for (int k = 0; k <= 30; ++k) {\n            fill(memo[j][k], memo[j][k]+30, INF);\n        }\n    }\n\n\n    cin >> S >> G;\n    --S; --G;\n    for (int j = 0; j < M; ++j) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        --x; --y;\n\n        graph[x].emplace_back(y, d, c);\n        graph[y].emplace_back(x, d, c);\n    }\n\n    priority_queue<state> pq;\n    pq.emplace(S, 0, 0, S);\n    memo[S][0][S] = 0;\n    while (!pq.empty()) {\n        state st = pq.top(); pq.pop();\n        if (st.cost > memo[st.pos][st.speed][st.prev]) { continue; }\n\n        for (edge& e: graph[st.pos]) {\n            if (st.prev == e.to) { continue; }\n            for (int dv = -1; dv <= 1; ++dv) {\n                int next_speed = st.speed + dv;\n                if (next_speed <= 0 || e.limit < next_speed) { continue; }\n\n                double next_cost = st.cost + (double)e.cost / next_speed;\n                if (next_cost < memo[e.to][next_speed][st.pos]) {\n                    memo[e.to][next_speed][st.pos] = next_cost;\n                    pq.emplace(e.to, next_cost, next_speed, st.pos);\n                }\n            }\n\n        }\n    }\n    double ans = INF;\n    for (int j = 0; j < N; ++j) {\n        ans = min(ans, memo[G][1][j]);\n    }\n    if (fabs(ans-INF) < 1e-7) { printf(\"unreachable\\n\"); }\n    else { printf(\"%.12f\\n\", ans); }\n    return true;\n}\n\nint main() { for (; solve(); ); return 0; }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define F first\n#define S second\n#define MP make_pair\n#define INF (1<<29)\n\ntypedef pair<pair<double, int>,pair<int, int> > P;\n\nstruct Edge{\n  int to,d,c;\n  Edge(int to, int d, int c):to(to),d(d),c(c){}\n};\n\nint N,M;\nvector<Edge>G[32];\ndouble dist[32][32][32];\n\nvoid dijkstra(int s){\n  rep(i,32) rep(j,32) rep(k,32)dist[i][j][k] = INF;\n  priority_queue<P, vector<P>, greater<P> >q;\n  dist[0][s][31] = 0.0;\n  q.push(MP(MP(0.0, 0),MP(s, 31)));\n  \n  while(!q.empty()){\n    P p = q.top(); q.pop();\n    int d = p.F.F, speed = p.F.S, cur = p.S.F, prev = p.S.S;\n    if(dist[speed][cur][prev] < d) continue;\n    for(int d=-1;d<=1;d++){\n      int sp = speed+d;\n      if(sp <= 0 || sp > 30) continue;\n      rep(i,G[cur].size()){\n\tEdge e = G[cur][i];\n\tif(e.to == prev) continue;\n\tif(sp <= e.c && dist[sp][e.to][cur] > dist[speed][cur][prev] + (double)e.d/sp){\n\t  dist[sp][e.to][cur] = dist[speed][cur][prev] + (double)e.d/sp;\n\t  q.push(MP(MP(dist[sp][e.to][cur], sp), MP(e.to, cur)));\n\t}\n      }\n    }\n  }\n}\n\nint main(){\n  while(scanf(\"%d%d\",&N,&M) && N||M){\n    rep(i,32) G[i].clear();\n    int s, g;\n    scanf(\"%d%d\",&s,&g); s--; g--;\n    rep(i,M){\n      int x,y,d,c;\n      scanf(\"%d%d%d%d\",&x,&y,&d,&c); x--;y--;\n      G[x].push_back(Edge(y,d,c));\n      G[y].push_back(Edge(x,d,c));\n    }\n\n    dijkstra(s);\n    double res = INF;\n    rep(i,32) res = min(res, dist[1][g][i]);\n    if(res>INF-1) puts(\"unreachable\");\n    else printf(\"%.12lf\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ndouble cut[32][32][32];\npair<int,int> way[32][32];\nint main() {\n\tint n, m, s, g;\n\twhile(cin >> n >> m, n) {\n\t\tcin >> s >> g;\n\t\tfill((double*)cut, (double*)cut + 32 * 1024, 1e100);\n\t\tfill((pair<int,int>*)way, (pair<int,int>*)way + 1024,make_pair(0,0);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tway[x][y] = way[y][x] = make_pair(d,c);\n\t\t}\n\t\tpriority_queue<tuple<double, int, int>,vector<tuple<double, int, int>>,greater<tuple<double, int, int>>> que;\n\t\tque.push(make_tuple(0., s, 1));\n\t\twhile (!que.empty()&&(get<1>(que.top())!=g||get<2>(que.top())!=0)){\n\t\t\tauto a = que.top();\n\t\t\tque.pop();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (way[get<1>(a)][i].second == 0)continue;\n\t\t\t\tif (i == get<1>(a))continue;\n\t\t\t\tif (get<2>(a)>way[get<1>(a)][i].second)continue;\n\t\t\t\tif (get<2>(a) == 0)continue;\n\t\t\t\tfor (int j = max(0, get<2>(a)-1); j <= get<2>(a)+1; j++) {\n\t\t\t\t\tif (cut[i][j][get<1>(a)]>get<0>(a) + (double)way[get<1>(a)][i].first / get<2>(a)) {\n\t\t\t\t\t\tque.push(make_tuple(get<0>(a) + (double)way[get<1>(a)][i].first / get<2>(a), i, j));\n\t\t\t\t\t\tcut[i][j][get<1>(a)] = get<0>(a) + (double)way[get<1>(a)][i].first / get<2>(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (que.empty())cout << \"unreachable\" << endl;\n\t\telse cout << fixed << setprecision(10) << get<0>(que.top()) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\n#define INF 1e15\n\nstruct edge{\n    int to;\n    double cost;\n    int limit;\n    edge(int t, double c, int l): to(t), cost(c), limit(l){}\n};\n\nstruct state{\n    int node, speed, prev;\n    double dist;\n    state(int n, int s, int p, double d): node(n), speed(s), prev(p), dist(d) {}\n    bool operator > (const state s) const {\n        return dist > s.dist;\n    }\n};\n \nvoid dijkstra(int start, vector<vector<double> > &d, vector<vector<edge> > graph){\n    d[start][0] = 0.0;\n    priority_queue<state, vector<state>, greater<state> > q;\n    q.push(state(start, 0, 0, 0.0));\n    while (!q.empty()){\n        state a = q.top();\n        q.pop();\n        int now = a.node, prev = a.prev, speed = a.speed;\n        if(d[now][speed] < a.dist) continue;\n        REP(i,graph[now].size()){\n            edge e = graph[now][i];\n            int next = e.to, limit = e.limit;\n            if (next == prev) continue;\n            FOR(dif,-1,1){\n                int next_speed = speed + dif;\n                if (next_speed <= 0 || next_speed > limit) continue;\n                if (d[next][next_speed] > d[now][speed] + e.cost/next_speed){\n                    d[next][next_speed] = d[now][speed] + e.cost/next_speed;\n                    q.push(state(next, next_speed, now, d[next][next_speed]));\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    while (cin >> n >> m && n){\n        vector<vector<edge> > graph(n);\n        int s, g;\n        cin >> s >> g;\n        s--;\n        g--;\n        REP(i,m){\n            int x, y, c;\n            double d;\n            cin >> x >> y >> d >> c;\n            x--;\n            y--;\n            graph[x].push_back(edge(y,d,c));\n            graph[y].push_back(edge(x,d,c));\n        }\n        vector<vector<double> > dist(n,vector<double>(31,INF));\n        dijkstra(s, dist, graph);\n        if (dist[g][1] == INF) cout << \"unreachable\" << endl;\n        else printf(\"%.10f\\n\", dist[g][1]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstruct P {\n\tint to, c, d;\n};\nvector<P>E[30];\ndouble d[30][31][30];\n\nstruct st {\n\tint p, h, pr; double c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tint s, g; scanf(\"%d%d\", &s, &g); s--; g--;\n\t\trep(i, n)E[i].clear();\n\t\trep(i, m) {\n\t\t\tint x, y, d, c; scanf(\"%d%d%d%d\", &x, &y, &d, &c); x--; y--;\n\t\t\tE[x].push_back({ y,c,d }); E[y].push_back({ x,c,d });\n\t\t}\n\t\tpriority_queue<st>que;\n\t\tfill(d[0][0], d[30][0], INF);\n\t\tfor (P v : E[s]) {\n\t\t\td[v.to][1][s] = v.d; que.push({ v.to,1,0,d[v.to][1][s] });\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (d[p.p][p.h][p.pr] != p.c)continue;\n\t\t\tfor (P v : E[p.p]) {\n\t\t\t\tif (v.to == p.pr)continue;\n\t\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\t\tif (p.h + i > 0 && p.h + i <= v.c) {\n\t\t\t\t\t\tif (d[v.to][p.h + i][p.p] > p.c + v.d / double(p.h + i)) {\n\t\t\t\t\t\t\td[v.to][p.h + i][p.p] = p.c + v.d / double(p.h + i);\n\t\t\t\t\t\t\tque.push({ v.to,p.h + i,p.p,d[v.to][p.h + i][p.p] });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble Min = INF;\n\t\trep(i, n)Min = min(Min, d[g][1][i]);\n\t\tif (Min == INF)puts(\"unreachable\");\n\t\telse printf(\"%.7lf\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e10\n#define EPS 1e-10\nusing namespace std;\nstruct edge{\n  int to,limit;\n  double dist;\n};\nvector<edge> G[100];\ndouble d[40][100];\nbool used[40][100][40];\ntypedef pair<int,int> pii; //speed,prev\ntypedef pair<int,pii> PII;//to,speed,prev\ntypedef pair<double,PII> P;//cost,to,speed\n\ndouble dikstra(int s,int g){\n  int ds[3]={-1,0,1};\n  priority_queue<P,vector<P>,greater<P> > que;\n  for(int i=0;i<40;i++)\n    for(int j=0;j<100;j++)\n      d[i][j]=INF;\n  memset(used,0,sizeof(used));\n  d[0][s]=0;\n  que.push(P(0,PII(s,pii(0,-1))));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int speed=p.second.second.first;\n    int v=p.second.first;\n    int prev=p.second.second.second;\n    double cost=p.first;\n    cout << v << \":\" << speed <<\":\" << cost << endl;\n    if(d[speed][v]<cost)continue;\n    for(int i=0;i<G[v].size();i++){\n      for(int j=0;j<3;j++){\n\tedge e=G[v][i];\n\tint ns=speed+ds[j];\n\tif(1<=ns && ns<= e.limit &&\n\t   used[ns][e.to][v]==false){\n\t  used[ns][e.to][v]=true;\n\t  que.push(P(cost+e.dist/ns,PII(e.to,pii(ns,v))));\n\t  if(d[ns][e.to]>cost+e.dist/ns){\n\t    d[ns][e.to]=cost+e.dist/ns;\n\t    //cout << \"d[\" << ns << \"][\" << e.to << \"]:\" << d[ns][e.to] << endl;\n\t    //cout << \"d[\" << v << \"]:\" << d[speed][v] << \" speed:\" << speed<< endl;\n\t  }\n\t}\n      }\n    }\n  }\n  if(d[1][g]==INF)return -1;\n  return d[1][g];\n}\n\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m,n){\n    for(int i=0;i<100;i++)G[i].clear();\n    cin>>s>>g;\n    for(int i=0;i<m;i++){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c;\n      G[x].push_back((edge){y,c,d});\n      G[y].push_back((edge){x,c,d});\n    }\n    double ans=dikstra(s,g);\n    if(ans==-1)cout << \"unreachable\" << endl;\n    else printf(\"%.5lf\\n\",ans);\n    // for(int i=0;i<=n;i++)\n    // \tcout << i << \" \" << d[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint n, m;\n\t\tcin>>n>>m;\n\t\tif(n == 0 && m == 0) break;\n\t\tint s, g;\n\t\tcin>>s>>g;\n\t\t--s;\n\t\t--g;\n\t\tvector<vector<pair<ll, P> > > p(n);\n\t\tvector<vector<vector<double> > > d(n, vector<vector<double> >(n, vector<double>(31, INF)));\n\t\tREP(i, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\t--x;\n\t\t\t--y;\n\t\t\tp[x].pb({y, P(d, c)});\n\t\t\tp[y].pb({x, P(d, c)});\n\t\t}\n\t\tpriority_queue<pair<pair<double, ll>, P>, vector<pair<pair<double, ll>, P> >, greater<pair<pair<double, ll>, P> > > q;\n\t\td[0][0][1] = 0;\n\t\tq.push({{0, 0}, {0, 1}});\n\t\twhile(!q.empty()) {\n\t\t\tpair<pair<double, ll>, P> np = q.top();\n\t\t\tq.pop();\n\t\t\tif(d[np.first.second][np.second.first][np.second.second] != np.first.first) continue;\n\t\t\tFOR(i, -1, 2) {\n\t\t\t\tll ns = np.second.second + i;\n\t\t\t\tif(np.first.second == 0 && np.second.first == 0) {\n\t\t\t\t\tif(ns != 1) continue;\n\t\t\t\t}\n\t\t\t\tif(ns <= 0) continue;\n\t\t\t\tREP(j, p[np.first.second].size()) {\n\t\t\t\t\tll next = p[np.first.second][j].first;\n\t\t\t\t\tif(next == np.second.first) continue;\n\t\t\t\t\tif(p[np.first.second][j].second.second < ns) continue;\n\t\t\t\t\tif(d[next][np.first.second][ns] > d[np.first.second][np.second.first][np.second.second] + p[np.first.second][j].second.first / (double)ns) {\n\t\t\t\t\t\td[next][np.first.second][ns]  = d[np.first.second][np.second.first][np.second.second] + p[np.first.second][j].second.first / (double)ns;\n\t\t\t\t\t\tq.push({{d[next][np.first.second][ns], next}, {np.first.second, ns}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = INF;\n\t\tREP(i, n) {\n\t\t\tans = min(ans, d[g][i][1]);\n\t\t}\n\t\tif(ans != INF) cout<<fixed<<showpoint<<setprecision(39)<<ans<<endl;\n\t\telse cout<<\"unreachable\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <cstdio>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dy[] = {1, 0, -1, 1, -1, 1, 0, -1};\n\nstruct edge{\n\tint to;\n\tdouble dist;\n\tint c;\n\tedge(int t, double d, int c_){to = t, dist = d, c = c_;}\n};\n\nstruct state{\n\tint pos;\n\tdouble total;\n\tint speed;\n\tint prev;\n\tstate(int p, double t, int s, int pr){pos = p, total = t, speed = s, prev = pr;}\n\tbool operator<(const state &r)const{\n\t\treturn total > r.total;\n\t}\n};\n\nconst double INF = 1e30;\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\ts--, g--;\n\t\tvector<vector<edge> > G(n);\n\t\trep(i, m){\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--, y--;\n\t\t\tG[x].push_back(edge(y, d, c));\n\t\t\tG[y].push_back(edge(x, d, c));\n\t\t}\n\n\t\tpriority_queue<state> q;\n\t\tq.push(state(s, 0, 0, 0));\n\n\t\tvector<vector<vi> > visit(31, vector<vi>(n, vi(n, 0))); //speed, pos, prev\n\n\t\tdouble ans = INF;\n\t\twhile(!q.empty()){\n\t\t\tstate st = q.top();\n\t\t\tq.pop();\n\n\t\t\tif(visit[st.speed][st.pos][st.prev]) continue;\n\t\t\tvisit[st.speed][st.pos][st.prev] = 1;\n\n\t\t\tif(st.speed == 1 && st.pos == g){\n\t\t\t\tans = st.total;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, G[st.pos].size()){\n\t\t\t\tif( G[st.pos][i].dist == INF ) continue;\n\t\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\t\tstate next = st;\n\t\t\t\t\tnext.speed += j;\n\t\t\t\t\tif(next.speed <= 0 || next.speed > G[st.pos][i].c) continue;\n\t\t\t\t\tnext.pos = G[st.pos][i].to;\n\t\t\t\t\tif(next.prev == next.pos) continue;\n\t\t\t\t\tnext.prev = st.pos;\n\t\t\t\t\tnext.total += G[st.pos][i].dist/next.speed;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == INF) cout << \"unreachable\" << endl;\n\t\telse printf(\"%.8lf\\n\", ans);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\n\nstruct data {\n  int p, prep, s;\n  double t;\n};\nstruct e {\n  int to, d, c;\n};\nbool operator<(const data &l, const data &r) {\n  if(l.t != r.t) return l.t > r.t;\n  return l.p > r.p;\n}\n\nint n, m, s, g;\ndouble dis[35][35][35] = {0}, ans = 0;\nvector<e> edge[55];\npriority_queue<data> pq;\n\nvoid solve();\n\nint main() {\n  cout << fixed << setprecision(10);\n  while(1) {\n    cin >> n >> m;\n    if(n + m == 0) break;\n    cin >> s >> g;\n    --s, --g;\n    for(int i = 0; i < m; ++i) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      --x, --y;\n      edge[x].push_back({y, d, c});\n      edge[y].push_back({x, d, c});\n    }\n    solve();\n    if(ans == inf)\n      cout << \"unreachable\" << endl;\n    else\n      cout << ans << endl;\n    for(int i = 0; i < n; ++i)\n      edge[i].erase(edge[i].begin(), edge[i].end());\n  }\n  return 0;\n}\n\nvoid solve() {\n  ans = inf;\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < n; ++j)\n      for(int k = 0; k <= 30; ++k) dis[i][j][k] = inf;\n  pq.push({s, s, 0, 0});\n  dis[s][s][0] = 0;\n  while(!pq.empty()) {\n    data now = pq.top();\n    pq.pop();\n    for(int i = 0; i < edge[now.p].size(); ++i)\n      if(now.prep != edge[now.p][i].to) {\n        for(int j = -1; j <= 1; ++j) {\n          data nextp = now;\n          nextp.prep = now.p;\n          nextp.p = edge[now.p][i].to;\n          nextp.s += j;\n          if(nextp.s > 0 && nextp.s <= edge[now.p][i].c) {\n            nextp.t +=\n                (long double)edge[now.p][i].d / nextp.s;\n            if(dis[nextp.p][nextp.prep][nextp.s] <= nextp.t)\n              continue;\n            dis[nextp.p][nextp.prep][nextp.s] = nextp.t;\n            pq.push(nextp);\n          }\n        }\n      }\n  }\n  ans = inf;\n  for(int i = 0; i < n; ++i) ans = min(ans, dis[g][i][1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1e9\nusing namespace std;\ndouble cost[30][30][31]; int d[30][30],c[30][30],v[30][30][31];\nclass S{\n\tdouble cc;int c,p,v;\n\tS(double cc,int c,int p,int v):cc(cc),c(c),p(p),v(v){}\n\tbool operator<(const S &a)const{\n\t\treturn cc>a.cc;\n\t}\n};\nint main(){\n\tint n,m,s,g,x,y,a,b; double nc;\n\twhile(scanf(\"%d%d\",&n,&m),n){\n\t\tscanf(\"%d%d\",&s,&g),s--,g--;\n\t\trep(i,n)rep(j,n){\n\t\t\trep(k,31)cost[i][j][k]=INF,v[i][j][k]=0;\n\t\t\td[i][j]=c[i][j]=0;\n\t\t}\n\t\trep(i,m)scanf(\"%d%d%d%d\",&x,&y,&a,&b),\n\t\tx--,y--,d[x][y]=d[y][x]=a,c[x][y]=c[y][x]=b;\n\t\tpriority_queue<S> F; F.push(S(0,s,s,0)); cost[s][s][0]=0;\n\t\twhile(!F.empty()){\n\t\t\tS cs=F.top(); F.pop();\n\t\t\tv[cs.c][cs.p][cs.v]=1;\n\t\t\tif(cs.c==g&&cs.v==1){\n\t\t\t\tprintf(\"%.5f\\n\",cs.cc); goto END;\n\t\t\t}\n\t\t\trep(i,n)if(i!=cs.p&&d[cs.c][i])\n\t\t\tfor(int dv=-1;dv<2;dv++)if(!v[i][cs.c][dv+cs.v]&&0<dv+cs.v&&dv+cs.v<=c[cs.c][i]){\n\t\t\t\tnc=cost[cs.c][cs.p][cs.v]+1.*d[cs.c][i]/(dv+cs.v);\n\t\t\t\tif(cost[i][cs.c][dv+cs.v]>nc)\n\t\t\t\tcost[i][cs.c][dv+cs.v]=nc,F.push(S(nc,i,cs.c,dv+cs.v));\n\t\t\t}\n\t\t}\n\t\tprintf(\"unreachable\\n\"); END:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n#define EPS 1e-8\n\nstruct P{\n  double t;\n  char v,p,pre;\n  P(double T=0.0,int V=0,int pp=0,int PRE=0){\n    t=T;v=V;p=pp;pre=PRE;\n  };\n  bool operator<(const P &p)const{\n    return t>p.t;\n  }\n};\nstruct Path{\n  char d,c;\n  Path(int D=0,int C=0){ d=D;c=C;};\n};\n\nint main(){\n  int n,m, s,g, x,y,d,c;\n  Path path[30][30];\n  priority_queue<P> q;\n\n  while( cin>>n>>m && (n|m) ){\n    cin >> s >> g;\n    s--; g--;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tpath[i][j].d=-1.0; path[i][j].c=-1;\n      }\n\n    for( int i=0;i<m;i++ ){\n      cin >> x >> y >> d >> c;\n      x--;y--;\n      path[x][y].d=d; path[x][y].c=c;\n      path[y][x] = path[x][y];\n    }\n\n    double cost[30][35]; // place,velocity\n    int dv[3] = {1,0,-1};\n    for( int i=0;i<n;i++ )\n      for( int j=1;j<31;j++ )\n\tcost[i][j] = DBL_MAX;\n\n    while( !q.empty() ) q.pop();\n    for( int i=0;i<n;i++ ){\n      if( path[s][i].c<0 ) continue;\n      q.push( P(cost[i][1]=path[s][i].d,1,i,-1) );\n    }\n\n    while( !q.empty() ){\n      P p = q.top(); q.pop();\n      double t = p.t;\n      int v=p.v, np=p.p, pre=p.pre;\n      if( np==g && v==1 ) break;\n\n      for( int i=0;i<n;i++ ){\n\tif( path[np][i].c<0 ) continue;// たどり着けないノード\n\tif( i==pre ) continue; // 前回のノード\n\n\tint j=0;\n\tif( i==g ) j=2;\n\tfor( ;j<3;j++ ){\n\t  int nv = v + dv[j];\n\t  if( nv==0 || nv>path[np][i].c )    continue;\n\t  double nCost = t + (double)path[np][i].d/nv;\n\t  if( nCost>cost[g][1] || fabs(nCost-cost[g][1])<EPS ) continue;\n\t  if( cost[i][nv] < nCost ) continue;\n\t  cost[i][nv]=nCost;\n\n\t  q.push( P(nCost,nv,i,np) );\n\t}\n      }\n\n    }\n    if( fabs(cost[g][1]-DBL_MAX)<EPS )\n      cout << \"unreachable\" << endl;\n    else\n      printf(\"%.6lf\\n\",cost[g][1]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 30;\n\ntypedef struct Edge\n{\n  int d, c;\n};\n\nclass State\n{\npublic:\n  int nc, pc, nv;\n  double nt;\n\n  State() {}\n  State(int a, int b, int c, double d)\n    :nc(a), pc(b), nv(c), nt(d) {}\n\n  inline void set(int a, int b, int c, double d)\n  {\n    nc = a;\n    pc = b;\n    nv = c;\n    nt = d;\n  }\n\n  bool operator <(const State& rhs) const\n  {\n    return this->nt > rhs.nt;\n  }\n\n};\n\nint main()\n{\n  int n, m, s, g;\n  Edge cost[MAX][MAX];\n  double time[MAX][MAX][MAX+1];\n  bool visited[MAX][MAX][MAX+1];\n\n  while (scanf(\"%d %d\", &n, &m) != EOF) {\n    if (n == 0 && m == 0)\n      break;\n\n    scanf(\"%d %d\", &s, &g);\n    --s;\n    --g;\n\n    for (int i = 0; i < MAX; ++i) {\n      for (int j = 0; j < MAX; ++j)\n\tcost[i][j].d = cost[i][j].c = -1;\n    }\n\n    for (int i = 0; i < m; ++i) {\n      int x, y, d, c;\n      scanf(\"%d %d %d %d\", &x, &y, &d, &c);\n      --x;\n      --y;\n      cost[x][y].d = cost[y][x].d = d;\n      cost[x][y].c = cost[y][x].c = c;\n    }\n\n    for (int i = 0; i < MAX; ++i) {\n      for (int j = 0; j < MAX; ++j) {\n\tfor (int k = 0; k < MAX+1; ++k) {\n\t  time[i][j][k] = 999999999.0;\n\t  visited[i][j][k] = false;\n\t}\n      }\n    }\n    time[s][s][0] = 0.0;\n\n    \n    double ans = -1.0;\n    priority_queue<State> que;\n    State st(s, s, 0, 0.0), q;\n    que.push(st);\n\n    while (!que.empty()) {\n      st = que.top();\n      que.pop();\n\n      if (st.nc == g && st.nv == 1) {\n\tans = st.nt;\n\tbreak;\n      }\n\n      visited[st.nc][st.pc][st.nv] = true;\n      for (int i = 0; i < n; ++i) {\n\tif (i == st.nc || i == st.pc || cost[st.nc][i].d == -1)\n\t  continue;\n\tfor (int j = st.nv-1; j < st.nv+2; ++j) {\n\t  if (j > 0 && cost[st.nc][i].c >= j) {\n\t    double tmp = st.nt + cost[st.nc][i].d / (double)j;\n\t    if (time[i][st.nc][j] > tmp) {\n\t      time[i][st.nc][j] = tmp;\n\t      q.set(i, st.nc, j, tmp);\n\t      que.push(q);\n\t    }\n\t  }\n\t}\n      }\n\n    }\n\n    if (ans == -1.0)\n      printf(\"unreachable\\n\");\n    else\n      printf(\"%.5f\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nstruct edge{\n\tint to,cost,limit;\n\tedge(int t,int c,int l){\n\t\tto=t;cost=c;limit=l;\n\t}\n};\n\n#define INF 1000000\n\nstruct Node{\n\tint now,speed,before;\n\tdouble time;\n\tNode(int n,int s,double t,int bef){\n\t\tnow=n;speed=s;time=t;before=bef;\n\t}\n};\n\nbool operator < (Node a,Node b){\n\treturn a.time>b.time;\n}\n\nint n,m,s,g;\n\nvoid solve(){\n\tbool visit[31][31][31];\n\tmemset(visit,false,sizeof(visit));\n\tvector<vector<edge> > E(n+1);\n\tcin>>s>>g;\n\tfor(int i=0;i<m;i++){\n\t\tint in,out,c,l;\n\t\tcin>>in>>out>>c>>l;\n\t\tE[in].push_back(edge(out,c,l));\n\t\tE[out].push_back(edge(in,c,l));\n\t}\n\n\tdouble Ans[31][31][31];\n\tmemset(Ans,-1,sizeof(Ans));\n\n\tpriority_queue<Node> Q;\n\tQ.push(Node(s,0,0.0,s));\n\twhile(!Q.empty()){\n\t\tNode t=Q.top(); Q.pop();\n\t\tif(visit[t.now][t.before][t.speed]) continue;\n\t\tvisit[t.now][t.before][t.speed]=true;\n\t\tif(Ans[t.now][t.before][t.speed]<=t.time+0.0001 && Ans[t.now][t.before][t.speed]>=0) continue;\n//\t\tcout<<t.now<<\" \"<<t.speed<<\" \"<<t.time<<endl;\n\t\tif(t.now==g && t.speed==1){printf(\"%.12lf\\n\", t.time );  return;}\n\t\tAns[t.now][t.before][t.speed]=t.time;\n\n\t\tfor(int i=0;i<E[t.now].size();i++){\n\t\t\tint to=E[t.now][i].to;\n\t\t\tif(to==t.before) continue;\n\t\t\tif(E[t.now][i].cost>0){\n\t\t\t\tif(E[t.now][i].limit>=t.speed && t.speed>=1){\n\t\t\t\t\tQ.push(Node(to,t.speed,t.time+E[t.now][i].cost/(double)t.speed,t.now));\n\t\t\t\t}\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed+1)\n\t\t\t\t\tQ.push(Node(to,t.speed+1,t.time+E[t.now][i].cost/(double)(t.speed+1.0),t.now));\n\n\t\t\t\tif(E[t.now][i].limit>=t.speed-1 && t.speed-1>=1)\n\t\t\t\t\tQ.push(Node(to,t.speed-1,t.time+E[t.now][i].cost/(double)(t.speed-1.0),t.now));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"unreachable\"<<endl;\n}\n\nint main()\n{\n\twhile(cin>>n>>m && n!=0)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\nstruct node{\n\tint pos;\n\tint prev;\n\tint speed;\n\tdouble dist;\n\n\tnode( int pos_, int prev_, int speed_, double dist_ )\n\t\t: pos(pos_), prev(prev_), speed(speed_), dist(dist_) {}\n\n\tbool operator< (const node &n) const{\n\t\treturn dist > n.dist;\t//逆\n\t}\n};\n\nstruct road{\n\tint to;\n\tdouble dist;\n\tint c;\n\t\n\troad( int t, double d, int c_ )\n\t\t: to(t), dist(d), c(c_) {}\n};\n\nint n, m;\nint s, g;\n\nvector<vector<road> > roads;\ndouble mindist[31][31][31];\n\n\nvoid solve(){\n\tfill( mindist[0][0], mindist[31][0], 9e9 );\n\n\tpriority_queue<node> pq;\n\tfor( int i = 0; i < roads[s].size(); ++i ){\n\t\troad r = roads[s][i];\n\t\tpq.push( node( r.to, s, 1, r.dist ) );\n\t\tmindist[r.to][s][1] = r.dist;\n\t}\n\t\n\twhile( !pq.empty() ){\n\t\tnode nd = pq.top();\n\t\tpq.pop();\n\n\t\tif( mindist[nd.pos][nd.prev][nd.speed] != nd.dist ){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif( nd.pos == g && nd.speed == 1 ){\n\t\t\tprintf(\"%f\\n\", nd.dist );\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor( int i = 0; i < roads[nd.pos].size(); ++i ){\n\t\t\troad r = roads[nd.pos][i];\n\t\t\tif( r.to == nd.prev ){\tcontinue;\t}\n\t\t\t\n\t\t\tfor( int j = -1; j < 2; ++j ){\n\t\t\t\tif( nd.speed + j > 0 && nd.speed + j <= r.c ){\n\t\t\t\t\tdouble nextdist = nd.dist + r.dist / ( nd.speed + j );\n\t\t\t\t\tif( mindist[r.to][nd.pos][nd.speed + j] > nextdist ){\n\t\t\t\t\t\tmindist[r.to][nd.pos][nd.speed + j] = nextdist;\n\t\t\t\t\t\tpq.push( node( r.to, nd.pos, nd.speed + j, nextdist ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tputs(\"unreachable\");\n}\n\n\nint main(){\n\tint x, y, d, c;\n\twhile( cin >> n >> m, n != 0 ){\n\t\troads = vector<vector<road> >( n + 1 );\n\t\t\n\t\tcin >> s >> g;\n\t\t\n\t\tfor( int i = 0; i < m; ++i ){\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\troads[x].push_back( road( y, d, c ) );\n\t\t\troads[y].push_back( road( x, d, c ) );\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nstruct NODE{\n\tint from,to,speed;\n\tdouble cost;\n\tNODE(int from,int to,int speed,double cost) : from(from) , to(to) , speed(speed) , cost(cost) {\n\t}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\n\nvector< vector<NODE> > G;\nbool done[32][32][80] = {};\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m && n){\n\t\tmemset(done,0,sizeof(done));\n\t\tint s,g;\n\t\tcin >> s >> g;\n\t\ts--,g--;\n\t\tG.clear();\n\t\tG.resize(n);\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c,d;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--,b--;\t\n\t\t\tG[a].push_back(NODE(a,b,c,d));\n\t\t\tG[b].push_back(NODE(b,a,c,d));\n\t\t\t//cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n\t\t}\n\t\tpriority_queue<NODE> Q;\n\t\t\n\t\tQ.push(NODE(n,s,0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( q.speed >= 80) continue;\n\t\t\tif( done[q.from][q.to][q.speed] ) continue;\n\t\t\telse done[q.from][q.to][q.speed] = true;\n\t\t\tif( q.to == g && q.speed == 1 ){\n\t\t\t\tprintf(\"%.10lf\\n\",q.cost);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < G[q.to].size() ; i++){\n\t\t\t\tif( q.speed+0 > 0 && q.speed+0 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed+0,q.cost+G[q.to][i].cost / (q.speed+0)));\n\t\t\t\tif( q.speed+1 > 0 && q.speed+1 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed+1,q.cost+G[q.to][i].cost / (q.speed+1)));\n\t\t\t\tif( q.speed-1 > 0 && q.speed-1 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed-1,q.cost+G[q.to][i].cost / (q.speed-1)));\n\t\t\t}\n\t\t}\n\t\tcout << \"unreachable\" << endl;\n\t\texit:;\n\t}\n}#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nstruct NODE{\n\tint from,to,speed;\n\tdouble cost;\n\tNODE(int from,int to,int speed,double cost) : from(from) , to(to) , speed(speed) , cost(cost) {\n\t}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\n\nvector< vector<NODE> > G;\nbool done[32][32][100] = {};\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m && n){\n\t\tmemset(done,0,sizeof(done));\n\t\tint s,g;\n\t\tcin >> s >> g;\n\t\ts--,g--;\n\t\tG.clear();\n\t\tG.resize(n);\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c,d;\n\t\t\tcin >> a >> b >> d >> c;\n\t\t\ta--,b--;\t\n\t\t\tG[a].push_back(NODE(a,b,c,d));\n\t\t\tG[b].push_back(NODE(b,a,c,d));\n\t\t\t//cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n\t\t}\n\t\tpriority_queue<NODE> Q;\n\t\t\n\t\tQ.push(NODE(n,s,0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( q.speed >= 100) continue;\n\t\t\tif( done[q.from][q.to][q.speed] ) continue;\n\t\t\telse done[q.from][q.to][q.speed] = true;\n\t\t\tif( q.to == g && q.speed == 1 ){\n\t\t\t\tprintf(\"%.10lf\\n\",q.cost);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < G[q.to].size() ; i++){\n\t\t\t\tif( q.speed+0 > 0 && q.speed+0 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed+0,q.cost+G[q.to][i].cost / (q.speed+0)));\n\t\t\t\tif( q.speed+1 > 0 && q.speed+1 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed+1,q.cost+G[q.to][i].cost / (q.speed+1)));\n\t\t\t\tif( q.speed-1 > 0 && q.speed-1 <= G[q.to][i].speed && q.from != G[q.to][i].to ) Q.push(NODE(q.to,G[q.to][i].to,q.speed-1,q.cost+G[q.to][i].cost / (q.speed-1)));\n\t\t\t}\n\t\t}\n\t\tcout << \"unreachable\" << endl;\n\t\texit:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.000001\n#define INF 1e7\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\n\nstruct data{\n    int to, cost, limit;\n};\n\nstruct edge{\n    int now, speed, prev;\n    double cost;\n\n    bool operator>(const edge &e) const {\n      return cost + EPS > e.cost;\n    }\n\n};\n\n\n\nint main(void) {\n\n    int n, m;\n    while(cin >> n >> m, n){\n        int s,g;\n        cin >> s >> g;\n        s--,g--;\n\n        vector<vector<data> > v(n);\n\n        rep(i,m){\n            int a,b;\n            struct data d;\n            cin >> a >> b >> d.cost >> d.limit;\n            a--,b--;\n            d.to = b;\n            v[a].push_back(d);\n            d.to = a;\n            v[b].push_back(d);\n        }\n\n        double dist[35][35][35];\n\n        rep(i,35)rep(j,35)rep(k,35){\n            dist[i][j][k] = INF;\n        }\n\n        priority_queue< edge, vector<edge>, greater<edge> > q;\n\n        struct edge e;\n        e.now = s;\n        e.speed = 0;\n        e.cost = 0;\n        e.prev = s;\n\n        q.push(e);\n        dist[e.now][e.speed][e.prev] = e.cost;\n\n        while(q.size()){\n            struct edge e = q.top();\n            q.pop();\n\n            //cout << \"! \" << e.now << \" \" << e.speed << \" \"<< e.cost << endl;\n            if(dist[e.now][e.speed][e.prev] + EPS < e.cost)continue;\n\n            for(int i = 0; i < v[e.now].size(); i++){\n                struct edge next;\n                next.now = v[e.now][i].to;\n                double d = v[e.now][i].cost;\n                next.prev = e.now;\n\n                if(next.now == e.prev)continue;\n\n                for(int j = -1; j <= 1; j++){\n                    next.speed = e.speed + j;\n                    if(next.speed > v[e.now][i].limit || next.speed <= 0)continue;\n                    next.cost = dist[e.now][e.speed][e.prev] + d / next.speed;\n\n                    if(dist[next.now][next.speed][next.prev] - EPS > next.cost){\n                        dist[next.now][next.speed][next.prev] = next.cost;\n                        q.push(next);\n                    }\n\n                }\n            }\n        }\n\n        double ans = INF;\n        rep(i,35)ans = min(ans, dist[g][1][i]);\n\n        if(ans + EPS > INF){\n            cout << \"unreachable\" << endl;\n        }else{\n            cout << shosu(10) << ans << endl;\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<iomanip>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define sc second\n#define pb push_back\n#define mk make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntemplate<class S,class T>\nostream &operator<<(ostream &out, const pair<S,T> p){\n\treturn out << \"(\" << p.fs << \", \" << p.sc << \")\";\n}\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \", \";\n\treturn out << \"}\" << endl;\n}\n\n#define N 30\ndouble d[N+1][N][N];\n// -time, from, current, speed\nstruct elem{\n\tdouble t;\n\tint f,c,s;\n\telem(){};\n\telem(double time, int from, int cur, int sp){\n\t\tt = time; f = from; c = cur; s = sp;\n\t}\n\tbool operator<(const elem r) const{ return mk(mk(t, f),mk(c,s)) < mk(mk(r.t,r.f), mk(r.c,r.s)); }\n};\nostream &operator<<(ostream &out, const elem &e){\n\treturn out << \"{\" << e.t << \", \" << e.f << \", \" << e.c << \", \" << e.s << \"}\";\n}\n\n\n#define INF (1e12)\nint main(){\n\tint n, m, s, g;\n\twhile(cin >> n >> m, n){\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\t\tfill(d[0][0], d[0][0] + (N+1) * N * N, -1.0);\n\t\tvector<pair<int,double> > e[N+2][N];// e[c][x] : from x at vert c : (to, time) list\n\t\trep(i, m){\n\t\t\tint x, y, di, c;\n\t\t\tcin >> x >> y >> di >> c;\n\t\t\tx--; y--;\n\t\t\treps(j,1,c+1){\n\t\t\t\tdouble time = di / (double) j;\n\t\t\t\te[j][x].pb(mk(y, time));\n\t\t\t\te[j][y].pb(mk(x, time));\n\t\t\t}\n\t\t}\n\t\tpriority_queue<elem> q;\n\t\tq.push(elem(-0.0, -1, s, 0));//initial state\n\t\twhile(!q.empty()){\n\t\t\telem el = q.top();\n\t\t\tdouble dst = - el.t;\n\t\t\tint from = el.f, cur = el.c, sp = el.s;\n\t\t\tq.pop();\n\t\t\tif(d[sp][cur][from] >= 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[sp][cur][from] = dst;\n//\t\t\tcout << el << endl;\n//\t\t\tif(sp == 1 && cur == g) break;\n\t\t\trep(i,3){\n\t\t\t\tint ci = sp - 1 + i;\n\t\t\t\tif(ci<1 || ci > N) continue;\n\t\t\t\trep(j, e[ci][cur].size()){\n\t\t\t\t\tpair<int, double> p = e[ci][cur][j];\n\t\t\t\t\tint to = p.fs;\n\t\t\t\t\tif (from == to) continue;\n\t\t\t\t\tdouble tmp = dst + p.sc;\n\t\t\t\t\tq.push(elem(-tmp, cur, to, ci));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\treps(i, 1, N+1){\n\t\t\tcout << \"v : \" << i << endl;\n\t\t\trep(j, n) cout << d[i][j] << \", \";\n\t\t\tcout << endl;\n\t\t}\n*/\n\t\tdouble ans = INF;\n\t\trep(i,n) if(d[1][g][i] >= 0) ans = min(ans, d[1][g][i]);\n\t\tif(ans >= INF) cout << \"unreachable\" << endl;\n\t\telse cout <<fixed << setprecision(10)<< ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nconst double INF=1e9;\nconst double eps=1e-6;\n\ntypedef pair<int,int> pi;\ntypedef pair<pi,int> P;\n\nstruct edge{int to,d,c;};\nvector<edge> G[30];\n\nint main()\n{\n    int n,m;\n    while(cin >>n >>m,n)\n    {\n        rep(i,30) G[i].clear();\n\n        int s,g;\n        cin >>s >>g;\n        --s;\n        --g;\n\n        rep(i,m)\n        {\n            int x,y,dist,cst;\n            cin >>x >>y >>dist >>cst;\n            --x;\n            --y;\n            G[x].pb(edge{y,dist,cst});\n            G[y].pb(edge{x,dist,cst});\n        }\n\n        double t[30][31][30];\n        rep(i,30)rep(j,31)rep(k,30) t[i][j][k]=INF;\n\n        t[s][1][s]=0;\n\n        queue<P> que;\n        rep(i,G[s].size())\n        {\n            edge e=G[s][i];\n            t[e.to][1][s]=(double)e.d;\n            que.push(P(pi(e.to,1),s));\n            //printf(\"push %d\\n\", e.to+1);\n        }\n        while(!que.empty())\n        {\n            P p=que.front();\n            que.pop();\n\n            pi now=p.fi;\n            int par=p.se;\n\n            //printf(\"now %d, speed %d, par %d\\n\", now.fi,now.se,par);\n\n            rep(i,G[now.fi].size())\n            {\n                edge e=G[now.fi][i];\n                int nx=e.to;\n                if(nx==par) continue;\n\n                for(int dv=-1; dv<=1; ++dv)\n                {\n                    int nv=now.se+dv;\n                    if(1<=nv && nv<=e.c)\n                    {\n                        double add=(double)e.d/nv;\n                        if(t[nx][nv][now.fi]>t[now.fi][now.se][par]+add)\n                        {\n                            t[nx][nv][now.fi]=t[now.fi][now.se][par]+add;\n                            que.push(P(pi(nx,nv),now.fi));\n                        }\n                    }\n                }\n            }\n        }\n\n        double ans=INF;\n        rep(i,n) ans=min(t[g][1][i],ans);\n\n        if(fabs(ans-INF)<eps) printf(\"unreachable\\n\");\n        else printf(\"%.10lf\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 100\ntypedef std::pair<short,short> P;\ntypedef std::pair<P,short> PP;\ntypedef std::pair<float,short> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    short n,m;\n\n    scanf(\"%hd%hd\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    short inx,iny,ind,inc;\n    float d[31][31][31];\n    short s,g;\n \n\n    scanf(\"%hd%hd\",&s,&g);\n    for(short i=1;i<=n;i++)for(short j=1;j<=n;j++)for(short k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(short i=0;i<m;i++){\n      scanf(\"%hd%hd%hd%hd\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    \n    while(que.size()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(short i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<pair<int,int>,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a2,a4;\ndouble d[31][31],a3;\nint dx[]={-1,0,1};\nedge e;\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      scanf(\"%d%d%lf%d\",&a1,&a2,&a3,&a4);\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P>q;\n    d[st][0]=0;\n    P xt;xt.fi.fi=0,xt.fi.se=st,xt.se=-1;\n    q.push(xt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.fi.se;\n      r(i,v[cur].size()){\n        e=v[cur][i];\n        if(e.to!=p.se)r(j,3){\n          int x=p.fi.fi+dx[j];\n          if(0<x&&x<=e.lim){\n            double t=e.dist/x+d[cur][p.fi.fi];\n            if(d[e.to][x]>t){\n              d[e.to][x]=t;\n              xt.fi.fi=x,xt.fi.se=e.to,xt.se=cur;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REP1(i,n) for(int i=1;i<(n);i++)\n#define REP2(i,d,n) for(int i=(d);i<(n);i++)\n#define RREP(i,n) for(int i=(n);i>=0;i--)\n#define CLR(a) memset((a),0,sizeof(a))\n#define MCLR(a) memset((a),-1,sizeof(a))\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI > VVI;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef pair<int,int> PII;\n \nconst int INF = 0x3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-9;\n \nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n \n \nstruct edge {\n\tint to, from, cost;\n\tedge(int _to, int _from, int _cost) {to = _to; from = _from; cost=_cost;}\n};\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\n \nint maxspeed[31][31];\n \nclass Dijkstra{\npublic:\n\tint V;\n\tvector<vector<edge> > G;\n\tvector<vector<double> > d;\n\t\n\tDijkstra(int _V){\n\t\tV = _V;\n\t\tG.resize(V);\n\t\td.resize(31);\n\n\t\tREP(i,31){\n\t\t\td[i].resize(V);\n\t\t}\n\t}\n\t\n\tvoid add_edge(int from, int to, int cost){\n\t\tG[from].PB(edge(to,from,cost));\n\t}\n\t\n\tvoid solve(int s){\n\t\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\t\tREP(i,31){\n\t\t\tREP(j, V){\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\td[0][s] = 0;\n\t\tque.push(PP(P(0,0),P(s,0)));\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tPP p = que.top();\n\t\t\tque.pop();\n\t\t\tint v = p.second.first;\n\t\t\tint mv = p.second.second;\n\t\t\tint old = p.first.second;\n\t\t\tREP2(i,-1,2){\n\t\t\t\tif(mv+i <= 0 || 30 < mv+i) continue;\n\t\t\t\tif(d[mv+i][v] < p.first.first) continue;\n\t\t\t\tREP(j,G[v].size()){\n\t\t\t\t\tedge e = G[v][j];\n\t\t\t\t\tif(e.to == old) continue;\n\t\t\t\t\t//cout << e.from << \":\" << e.to << \" \" << maxspeed[e.from][e.to] << \" \" << (mv+i) <<  endl;\n\t\t\t\t\tif(maxspeed[e.from][e.to] < mv+i) { continue; }\n\t\t\t\t\tif(d[mv+i][e.to] > d[mv][v] + (double)e.cost/(mv+i)){\n\t\t\t\t\t\td[mv+i][e.to] = d[mv][v] + (double)e.cost/(mv+i);\n\t\t\t\t\t\t//cout << (mv+i) << \" - \" << e.to << \" - \" << d[mv+i][e.to] << endl;\n\t\t\t\t\t\tque.push(PP(P(d[mv+i][e.to],v), P(e.to,mv+i)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\t\n\t\tcin >> n >> m;\n\t\tDijkstra dijkstra(n);\n\t\tif(n==0&&m==0){\n\t\t\tbreak;\n\t\t}\n\t\tREP(i,31){\n\t\t\tREP(j,31){\n\t\t\t\tmaxspeed[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint s,g;\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\t\tREP(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--; y--;\n\t\t\tdijkstra.add_edge(x,y,d);\n\t\t\tdijkstra.add_edge(y,x,d);\n\t\t\tmaxspeed[x][y] = c;\n\t\t\tmaxspeed[y][x] = c;\n\t\t}\n\n\t\tdijkstra.solve(s);\n\n\t\tif(abs(dijkstra.d[1][g]-INF) < 1e-5){\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}else{\n\t\t\tprintf(\"%.5f\\n\",dijkstra.d[1][g]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint n,m,s,g;\nmap<int, vector<TIII> > r;\nmap<TIII, double> v;\n\nint main(){\n\twhile(1){\n\t\tdouble ret = -1.0;\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)return 0;\n\t\tcin>>s>>g;\n\t\tr.clear();\n\t\tv.clear();\n\t\tREP(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tr[x].PB(MT(y,d,c));\n\t\t\tr[y].PB(MT(x,d,c));\n\t\t}\n\t\tpriority_queue<pair<double, TIII > , vector<pair<double, TIII > >, greater<pair<double, TIII > > > q;\n\t\tq.push(MP(0.0,MP(s, 0)));\n\t\twhile(!q.empty()){\n\t\t\tpair<double, TIII > tmp = q.top();\n\t\t\tq.pop();\n\t\t\tif(EXIST(v, tmp.second))continue;\n\t\t\tif(tmp.second.first == g && tmp.second.second.second == 1){\n\t\t\t\tret = tmp.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv[tmp.second]=tmp.first;\n\t\t\tint city = tmp.second.first;\n\t\t\tint speed = tmp.second.second.second;\n\t\t\tint pre = tmp.second.second.first;\n\t\t\tdouble now = tmp.first;\n\t\t\tREP(i, r[city].size()){\n\t\t\t\tFOR(sp, speed-1, speed+2){\n\t\t\t\t\tif(sp<1)continue;\n\t\t\t\t\tTIII f = r[city][i];\n\t\t\t\t\tif(f.second.second >= sp && sp > 0 && f.first != pre)q.push(MP(now+(f.second.first*1.0)/(sp*1.0), MP(f.first, sp)));\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ret < 0.0)cout << \"unreachable\" <<endl;\n\t\telse printf(\"%.6f\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<iomanip>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define sc second\n#define pb push_back\n#define mk make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntemplate<class S,class T>\nostream &operator<<(ostream &out, const pair<S,T> p){\n\treturn out << \"(\" << p.fs << \", \" << p.sc << \")\";\n}\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \", \";\n\treturn out << \"}\" << endl;\n}\n\n#define N 30\n#define inf (1e12)\ndouble d[N+1][N];\nint main(){\n\tint n, m, s, g;\n\twhile(cin >> n >> m, n){\n\t\tcin >> s >> g;\n\t\ts--; g--;\n\t\tfill(d[0], d[0] + (N+1) * N, -1);\n\t\td[1][s] = 0;\n\t\tvector<pair<int,double> > e[N+2][N];// e[c][x] : from x at vert c list\n\t\trep(i, m){\n\t\t\tint x, y, di, c;\n\t\t\tcin >> x >> y >> di >> c;\n\t\t\tx--; y--;\n\t\t\treps(j,1,c+1){\n\t\t\t\tdouble time = di / (double) j;\n\t\t\t\te[j][x].pb(mk(y, time));\n\t\t\t\te[j][y].pb(mk(x, time));\n\t\t\t}\n\t\t}\n\t\t// dst, from, current, ver\n\t\tpriority_queue<pair<double, pair<pii, int> > > q;\n\t\trep(i,e[1][s].size()){\n\t\t\tdouble tmp = e[1][s][i].sc;\n\t\t\tint to = e[1][s][i].fs;\n\t\t\tq.push(mk(-tmp, mk(pii(s, to), 1)));\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tdouble dst = -q.top().fs;\n\t\t\tint from = q.top().sc.fs.fs;\n\t\t\tint cur = q.top().sc.fs.sc, ver = q.top().sc.sc;\n\t\t\tq.pop();\n\t\t\tif(d[ver][cur] >= 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[ver][cur] = dst;\n\t\t\tif(ver == 1 && cur == g) break;\n\t\t\trep(i,3){\n\t\t\t\tint ci = ver - 1 + i;\n\t\t\t\tif(ci<1 || ci > N+1) continue;\n\t\t\t\trep(j, e[ci][cur].size()){\n\t\t\t\t\tpair<int, double> p = e[ci][cur][j];\n\t\t\t\t\tint to = p.fs;\n\t\t\t\t\tif (from == to) continue;\n\t\t\t\t\tdouble tmp = dst + p.sc;\n\t\t\t\t\tq.push(mk(-tmp, mk( pii(from, to), ci)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(d[1][g] < 0) cout << \"unreachable\" << endl;\n\t\telse cout <<fixed << setprecision(10)<< d[1][g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\nnamespace ShortestPath{\n    typedef double Cost;\n    const Cost CINF=1e17;\n    typedef  vector<vector<Cost> > Mat;\n    struct Edge{\n    \t  int id;\n        int from,to;Cost cost;\n        Edge(int id,int from,int to,Cost cost)\n            : id(id),from(from),to(to),cost(cost){};\n    };\n    ostream& operator <<(ostream& os,const Edge& e){\n            os<<\"(\"<<e.from<<\"->\"<<e.to<<\")\";\n            return os;\n    }\n    typedef vector<vector<Edge> > Graph;\n\n    struct Task{\n        int prev,pos;Cost cost;\n        Task(int prev,int pos,Cost cost)\n            :prev(prev),pos(pos),cost(cost){};\n        bool operator>(const Task& r) const{\n            return cost>r.cost;\n        }\n    };\n\n      inline vector<Cost> dijkstra(const Graph& g,const int s,vector<int>& prev){\n        const int V=g.size();\n        vector<Cost> d(V,CINF);d[s]=0;\n        \n        priority_queue<Task,vector<Task>,greater<Task> > que;que.push(Task(-1,s,0));\n        vector<bool> passed(V);\n        while(!que.empty()){\n            Task task=que.top();que.pop();\n            //if(prev[task.pos]!=-2)continue;\n            if(passed[task.pos])continue;\n            //if(d[task.pos]<task.cost)continue;\n            passed[task.pos]=true;\n            EACH(e,g[task.pos]){\n                if(d[e->to]>d[e->from]+e->cost){\n                    d[e->to]=d[e->from]+e->cost;\n                    que.push(Task(e->from,e->to,d[e->to]));\n                }\n            }   \n        }\n        return d;\n    }\n    vector<Cost> dijkstra(const Graph& g,const int s){\n        vector<int> prev(g.size());return dijkstra(g,s,prev);\n    }\n}\nusing namespace ShortestPath;\n\nclass Main{\n\tpublic:\n\n\tint enc(int pos,int prev,int V){\n\t\treturn pos*35*N+prev*35+V;\n\t}\n\tint N,M;\n\t\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\tcout <<fixed<<setprecision(15);\t\n\t\n\t\twhile(true){\n\t\t\t // cin >> N >> M;\n\t\t\t scanf(\"%d%d\",&N,&M);\n\t\t\tif(N==0)break;\n\t\t\tint s,g;\n\t\t\t// cin >> s >> g;\n\t\t\tscanf(\"%d%d\",&s,&g);\n\t\t\ts--;g--;\n\t\t\t\n\t\t\tGraph G(N*N*35);\n\t\t\tREP(i,M){\n\t\t\t\tint x,y;double d;int c;\n\t\t\t\t// cin >> x >> y >> d >> c;\n\t\t\t\tscanf(\"%d%d%lf%d\",&x,&y,&d,&c);\n\t\t\t\tx--;y--;\n\t\t\t\tfor(int v=0;v<=35;v++)for(int nv=v-1;nv<=v+1;nv++){\n\t\t\t\t\tif(!IN(1,nv,c+1))continue;\n\t\t\t\t\tREP(prev,N)if(prev!=y)G[enc(x,prev,v)].push_back(Edge(i,enc(x,prev,v),enc(y,x,nv),d/nv));\n\t\t\t\t\tREP(prev,N)if(prev!=x)G[enc(y,prev,v)].push_back(Edge(i,enc(y,prev,v),enc(x,y,nv),d/nv));\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<Cost> res=dijkstra(G,enc(s,s,0));\n\t\t\tCost mv=CINF;\n\t\t\tREP(prev,N)mv=min(mv,res[enc(g,prev,1)]);\n\t\t\tif(mv>=CINF) cout <<\"unreachable\"<<endl;\n\t\t\telse cout << mv<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n \nusing namespace std;\n \n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF 1e11\nconst int MAX_SPEED = 30;\n\nstruct P {\n    int city, pcity;\n    int speed;\n    float time;\n\n    bool operator >(const P& p) const {\n        return time > p.time;\n    }\n};\n\nstruct edge{\n    int to, dist, limit;\n};\n\ntypedef vector<float> vf;\ntypedef vector<vf> vvf;\ntypedef vector<vvf> vvvf;\n\nint main() {\n    int city_n, road_n, start, goal;\n\n    while(cin >> city_n >> road_n, city_n | road_n){\n        cin >> start >> goal;\n\n        vector<vector<edge>> E(city_n + 1);\n\n        REP(i, road_n){\n            int x, y, d, l;\n            cin >> x >> y >> d >> l;\n            E[x].push_back({y, d, l});\n            E[y].push_back({x, d, l});\n        }\n        vvf G(city_n + 1, vf(MAX_SPEED + 1, INF));\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({start, start, 0, 0.0});\n\n        float res = -1;\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n\n            if(p.city == goal && p.speed == 1){\n                res = p.time;\n                break;\n            }\n\n            for(auto e : E[p.city]) {\n                if(e.to == p.pcity) continue;\n                FOR(d, -1, 1 + 1){\n                    int next_speed = p.speed + d;\n                    if (next_speed == 0) continue;\n                    float next_time = p.time + (float)e.dist / next_speed;\n                    if (0 < next_speed && next_speed <= e.limit &&\n                        G[e.to][next_speed] > next_time) {\n                        G[e.to][next_speed] = next_time;\n                        que.push({e.to, p.city, next_speed, next_time});\n                    }\n                }\n            }\n        }\n\n        if(res == -1)\n            cout << \"unreachable\" << endl;\n        else\n            printf(\"%f\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n\nstruct Edge {\n\tint to, dist, cap;\n\tEdge(int t, int d, int c) {\n\t\tto = t;\n\t\tdist = d;\n\t\tcap = c;\n\t}\n};\n\nstruct State {\n\tint pos, prev, v;\n\tdouble time;\n\tState(int p, int pr, int v_, double t) {\n\t\tpos = p;\n\t\tprev = pr;\n\t\tv = v_;\n\t\ttime = t;\n\t}\n\tbool operator<(const State& right) const {\n\t\treturn time > right.time;\n\t}\n};\n\ndouble min_time[32][32][32];\nbool visited[32][32][32];\n\nint main() {\n\twhile(true) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif (n == 0) break;\n\n\t\tint start, goal;\n\t\tcin >> start >> goal;\n\t\tstart--;\n\t\tgoal--;\n\n\t\tvector<vector<Edge>> G(n);\n\t\tfor (int i = 0; i<m; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tG[x].emplace_back(y, d, c);\n\t\t\tG[y].emplace_back(x, d, c);\n\t\t}\n\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tpriority_queue<State> que;\n\t\tque.emplace(start, start, 0, 0);\n\t\tvisited[start][start][0] = true;\n\t\tmin_time[start][start][0] = 0;\n\n\t\tdouble ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\tauto s = que.top();\n\t\t\tque.pop();\n\t\t\tif (min_time[s.pos][s.prev][s.v] < s.time) continue;\n\t\t\tif (s.pos == goal && s.v == 1) {\n\t\t\t\tans = s.time;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int dv = -1; dv <= 1; dv++) {\n\t\t\t\tint nv = s.v + dv;\n\t\t\t\tfor (auto& e : G[s.pos]) {\n\t\t\t\t\tif (e.to == s.prev) continue;\n\t\t\t\t\tif (nv < 1 || e.cap < nv) continue;\n\t\t\t\t\tdouble nt = s.time + double(e.dist) / nv;\n\t\t\t\t\tif (!visited[e.to][s.pos][nv] || min_time[e.to][s.pos][nv] > nt) {\n\t\t\t\t\t\tvisited[e.to][s.pos][nv] = true;\n\t\t\t\t\t\tmin_time[e.to][s.pos][nv] = nt;\n\t\t\t\t\t\tque.emplace(e.to, s.pos, nv, nt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ans < 0) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t} else {\n\t\t\tprintf(\"%.5f\\n\", ans);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint n, m, s, g;\n\nstruct S{\n    int to;\n    double cost;\n    int speed;\n    int prev;\n    bool operator<(const S &s) const{\n        return cost > s.cost;\n    }\n};\nstruct edge{\n   int to, len, speed;\n};\n\nvector<edge> G[31];\ndouble d[31][31][32];\n\nvoid dijkstra(int s){\n    rep(i, 0, n) rep(j, 0, 31) rep(k, 0, 32) d[i][j][k] = INF;\n    d[s][0][31] = 0;\n    priority_queue<S> q;\n    q.push({s, 0, 0, 31});\n    while(!q.empty()){\n        S p = q.top(); q.pop();\n        int from = p.to;\n        double cost = p.cost;\n        int speed = p.speed;\n        int prv = p.prev;\n        if(d[from][speed][prv] < cost) continue;\n        rep(i, 0, G[from].size()){\n            edge e = G[from][i];\n            int next = e.to;\n            if(prv == next) continue;\n            for(int j = -1; j <= 1; j++){\n                if(speed + j <= 0 || speed + j > 30) continue;\n                if(speed + j > e.speed) continue;\n                double newCost = (double)e.len / (double)(speed + j) + cost;\n                if(d[next][speed + j][from] > newCost){\n                    // cout << next << \n                    // ' ' << speed + j << ' ' << newCost << endl;\n                    d[next][speed + j][from] = newCost;\n                    q.push({next, newCost, speed + j, from});\n                } \n            }\n        }\n    }\n}\n\nsigned main(){\n    while(1){\n        cin >> n >> m;\n        if(n + m == 0) break;\n        cin >> s >> g;\n        s--; g--;\n        rep(i, 0, n) G[i].clear();\n        rep(i, 0, m){\n            int x, y, dd, c;\n            cin >> x >> y >> dd >> c;\n            x--; y--;\n            G[x].push_back({y, dd, c});\n            G[y].push_back({x, dd, c});\n        }\n        dijkstra(s);\n        double ans = INF;\n        rep(i, 0, n) chmin(ans, d[g][1][i]);\n        if(ans > INF - 1) cout << \"unreachable\" << endl;\n        else printf(\"%.10f\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<pair<int,int>,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a2,a4;\ndouble d[31][31],a3;\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      scanf(\"%d%d%lf%d\",&a1,&a2,&a3,&a4);\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P>q;\n    d[st][0]=0;\n    P xtt;xtt.fi.fi=0,xtt.fi.se=st,xtt.se=-1;\n    q.push(xtt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.fi.se;\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=p.se)r(j,3){\n          int x=p.fi.fi+dx[j];\n          if(0<x&&x<=e.lim){\n            double t=e.dist/x+d[cur][p.fi.fi];\n            if(d[e.to][x]>t){\n              d[e.to][x]=t;\n              P xt;xt.fi.fi=x,xt.fi.se=e.to,xt.se=cur;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double INF = 1e4;\n\ntemplate <typename T>\nstruct Dijkstra {\n  struct Edge {\n    int to;\n    int cost;\n    int cap;\n  };\n  vector<vector<Edge>> g;\n  Dijkstra(int n) : g(n) {}\n\n  void addEdge(int u, int v, int d, int c) {\n    g[u].push_back({v, d, c});\n    g[v].push_back({u, d, c});\n  }\n  T build(int s, int t) {\n    vector<vector<vector<T>>> dp(\n        g.size(), vector<vector<T>>(g.size(), vector<T>(31, INF)));\n    struct Node {\n      T time;\n      int speed;\n      int to;\n      int rev;\n      bool operator>(const Node& other) const { return speed > other.speed; }\n    };\n    priority_queue<Node, vector<Node>, greater<Node>> pq;\n    pq.push({0.0, 0, s, s});\n\n    while (!pq.empty()) {\n      auto now = pq.top();\n      pq.pop();\n      if (dp[now.to][now.rev][now.speed] < now.time) continue;\n      for (auto&& nxt : g[now.to]) {\n        if (nxt.to == now.rev) continue;\n        for (int ds = -1; ds <= 1; ds++) {\n          int speed = now.speed + ds;\n          if (speed < 1 || nxt.cap < speed) continue;\n          double time = now.time + 1.0 * nxt.cost / speed;\n          if (dp[nxt.to][now.to][speed] > time) {\n            dp[nxt.to][now.to][speed] = time;\n            pq.push({time, speed, nxt.to, now.to});\n          }\n        }\n      }\n    }\n    T res = INF;\n    for (int i = 0; i < g.size(); i++) {\n      res = min(res, dp[t][i][1]);\n    }\n    return res;\n  }\n};\n\nint main() {\n  int n, m;\n  while (cin >> n >> m, n) {\n    int s, g;\n    cin >> s >> g;\n    s--, g--;\n    Dijkstra<double> graph(n);\n    for (int i = 0; i < m; i++) {\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      x--, y--;\n      graph.addEdge(x, y, d, c);\n    }\n    auto ans = graph.build(s, g);\n    if (ans < INF) {\n      cout << ans << endl;\n    } else {\n      cout << \"unreachable\" << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; double w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 100;\n\nvoid dijkstra(int n, vector< vector<edge> >& G, int s, vector<double>& d) {\n    fill(d.begin(), d.end(), DBL_MAX); d[s] = 0;\n    priority_queue<d_i, vector<d_i>, greater<d_i> > q;\n    q.push(d_i(0, s));\n    while (!q.empty()) {\n        d_i p = q.top(); q.pop();\n        int u = p.second;\n        if (p.first > d[u]) continue;\n        for (int i = 0; i < G[u].size(); i++) {\n            edge e = G[u][i];\n            if (d[e.v] > d[u] + e.w) {\n                d[e.v] = d[u] + e.w;\n                q.push(d_i(d[e.v], e.v));\n            }\n        }\n    }\n}\n\nvoid add_edge(vector< vector<edge> >& G, int u, int v, double w) {\n\tedge e = {u, v, w};\n\tG[u].push_back(e);\n}\n\nint f(int n, int x, int y, int v) {\n\treturn (n * x + y) * 32 + v;\n}\n\nint main() {\n\tfor (;;) {\n\t\tint n, m; cin >> n >> m;\n\t\tif (n == 0) break;\n\t\tn++;\n\t\tint s, g; cin >> s >> g;\n\t\tvector< vector<edge> > G(n * n * 32);\n\t\twhile (m--) {\n\t\t\tint x, y, c; double d;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tfor (int z = 0; z < n; z++) {\n\t\t\t\tif (z == x || z == y) continue;\n\t\t\t\tfor (int v = 1; v <= c; v++) {\n\t\t\t\t\tadd_edge(G, f(n, z, x, v), f(n, x, y, v - 1), d / v);\n\t\t\t\t\tadd_edge(G, f(n, z, x, v), f(n, x, y, v), d / v);\n\t\t\t\t\tadd_edge(G, f(n, z, x, v), f(n, x, y, v + 1), d / v);\n\t\t\t\t\tadd_edge(G, f(n, z, y, v), f(n, y, x, v - 1), d / v);\n\t\t\t\t\tadd_edge(G, f(n, z, y, v), f(n, y, x, v), d / v);\n\t\t\t\t\tadd_edge(G, f(n, z, y, v), f(n, y, x, v + 1), d / v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<double> d(n * n * 32);\n\t\tdijkstra(n * n * 32, G, f(n, 0, s, 1), d);\n\t\tdouble mini = DBL_MAX;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmini = min(mini, d[f(n, i, g, 0)]);\n\t\tif (mini < DBL_MAX) printf(\"%.10f\\n\", mini);\n\t\telse cout << \"unreachable\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//16\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  int c,p,s;\n  double t;\n  bool operator<(S a)const{\n    return t>a.t;\n  }\n};\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    int s,g;\n    cin>>s>>g;\n    int d[31][31]={{}};\n    int cs[31][31]={{}};\n    while(m--){\n      int x,y,di,ci;\n      cin>>x>>y>>di>>ci;\n      d[x][y]=d[y][x]=di;\n      cs[x][y]=cs[y][x]=ci;\n    }\n    bool p[31][31][31]={{{}}};\n    priority_queue<S> que;\n    S is={s,-1,0,0};\n    que.push(is);\n    while(!que.empty()){\n      S c=que.top();\n      if(c.c==g&&c.s==1)break;\n      que.pop();\n      if(p[c.c][c.p][c.s]++)continue;\n      for(int i=1;i<=n;i++){\n\tif(d[c.c][i]&&i!=c.p){\n\t  for(int a=-1;a<=1;a++){\n\t    S n;\n\t    n.c=i;\n\t    n.p=n.c;\n\t    n.s=c.s+a;\n\t    if(n.s>0&&n.s<=cs[c.c][i]){\n\t      n.t=c.t+d[c.c][i]*1./n.s;\n\t      que.push(n);\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(que.empty()){\n      cout<<\"unreachable\"<<endl;\n    }else{\n      cout<<fixed<<que.top().t<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        vector<vector<tuple<int,long double,long double>>> graph(n);\n        int s,g;\n        cin >> s >> g;\n        --s;\n        --g;\n        rep(i,0,m){\n            int x,y;\n            long double d,c;\n            cin >> x >> y >> d >> c;\n            --x;\n            --y;\n            graph[x].emplace_back(make_tuple(y,d,c));\n            graph[y].emplace_back(make_tuple(x,d,c));\n        }\n\n        vector<vector<vector<long double>>> dist(n,vector<vector<long double>>(n,vector<long double>(31,inf)));\n        priority_queue<tuple<long double,int,int,int>,vector<tuple<long double,int,int,int>>,greater<tuple<long double,int,int,int>>> que;\n        dist[s][s][0]=0;\n        que.push(make_tuple(0,s,s,0));\n        while(!que.empty()){\n            const tuple<long double,int,int,int> tup=que.top();\n            que.pop();\n            const long double d=get<0>(tup);\n            const int u=get<1>(tup),v=get<2>(tup),spd=get<3>(tup);\n            if(d>dist[u][v][spd]) continue;\n            for(const auto& e:graph[v]){\n                const auto w=get<0>(e);\n                if(w==u) continue;\n                rep(i,-1,2){\n                    const int next_spd=spd+i;\n                    if(next_spd<=0 or next_spd>get<2>(e)) continue;\n                    const long double tmp_d=d+get<1>(e)/next_spd;\n                    if(tmp_d>=dist[v][w][next_spd]) continue;\n                    dist[v][w][next_spd]=tmp_d;\n                    que.push(make_tuple(tmp_d,v,w,next_spd));\n                }\n            }\n        }\n\n        long double ans=inf;\n        rep(i,0,n) ans=min(ans,dist[i][g][1]);\n        if(ans==inf) cout << \"unreachable\" << endl;\n        else cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define INF 2e+9\n#define EPS 1e-14\n#define mp make_pair\nusing namespace std;\n\nstruct edge{ int to,cost,limit; };\ntypedef pair<int,int> SV;//prev,vertex\ntypedef pair<int,SV> VV;//speed\ntypedef pair<double,VV> P;//cost\n\nint main(){\n\tint n,m,s,g;\n\twhile(cin >> n >> m,n){\n\t\tcin >> s >> g; s--;g--;\n\t\tvector<edge> G[30];\n\t\tdouble d[30][31][30];\n\t\tbool used[30][31][30] = {};\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j <= 30;j++) {\n\t\t\t\tfor(int k = 0;k < 30;k++){\n\t\t\t\t\td[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td[s][0][s] = 0.0;\n\t\tfor(int i = 0;i < m;i++) {\n\t\t\tint x,y,d,c;\n\t\t\tcin >> x >> y >> d >> c; x--;y--;\n\t\t\tG[x].push_back({y,d,c});\n\t\t\tG[y].push_back({x,d,c});\n\t\t}\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(mp(0.0,mp(0,mp(s,s))));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top();que.pop();\n\t\t\tdouble cost = p.first;\n\t\t\tint speed = p.second.first,prev = p.second.second.first,v = p.second.second.second;\n\t\t\tif(used[v][speed][prev]) continue;\n\t\t\tused[v][speed][prev] = false;\n\t\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\t\tedge e = G[v][i];\n\t\t\t\tif(e.to == prev) continue;\n\t\t\t\tfor(int j = max(1,speed - 1);j <= min(e.limit,speed + 1);j++){\n\t\t\t\t\tif(!used[e.to][j][v] && d[v][speed][prev] + (double)e.cost / (double)j < d[e.to][j][v]){\n\t\t\t\t\t\td[e.to][j][v] = d[v][speed][prev] + (double)e.cost / (double)j;\n\t\t\t\t\t\tque.push(mp(d[e.to][j][v],mp(j,mp(v,e.to))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble mi = INF;\n\t\tfor(int i = 0;i < n;i++) mi = min(d[g][1][i],mi);\n\t\tif(mi > (1e+9)) cout << \"unreachable\" << endl;\n\t\telse printf(\"%.8f\\n\",mi);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\nstruct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n\nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\n// (time,speed,node,pre_node)\nusing P = pair<pair<double,int>,pair<int,int>>;\n\n\nP makeP(double t,int s,int n,int np){\n    return make_pair(make_pair(t,s),make_pair(n,np));\n}\n\nvoid solve(int n,int m){\n    int start,goal; cin>>start>>goal;\n    start--;\n    goal--;\n    vector<vector<int>> g(n,vector<int>(n,INF));\n    vector<vector<int>> lim(n,vector<int>(n,0));\n    rep(i,m){\n        int x,y,d,c;\n        cin>>x>>y>>d>>c;\n        x--;\n        y--;\n        g[x][y] = d;\n        g[y][x] = d;\n        lim[x][y] = c;\n        lim[y][x] = c;\n    }\n\n    double visited[32][32][32];\n    rep(i,32) rep(j,32) rep(k,32) visited[i][j][k]=DBL_MAX/10;\n    visited[start][0][start] = 0;\n\n    priority_queue<P,vector<P>,greater<P>> que;\n    que.push(makeP(0,0,start,start));\n    while(!que.empty()){\n        auto p = que.top();\n        que.pop();\n        double ti = p.first.first;\n        int speed = p.first.second;\n        int node = p.second.first;\n        int pre = p.second.second;\n\n#ifdef DEBUG\n        cerr << \"time : \" << ti << \" \"  << \"node : \" << node+1 << \" \" << \"speed \" << speed << endl;\n#endif\n        if(node==goal and speed==1){\n            cout << Double(ti) << endl;\n            return;\n        }\n\n        if(ti > visited[node][speed][pre]) continue;\n\n        for(int next_node=0;next_node<n;next_node++){\n            if(next_node==node or next_node==pre or g[node][next_node]==INF) continue;\n            int d=g[node][next_node];\n            int c=lim[node][next_node];\n            for(int nspeed=speed-1;nspeed<=speed+1;nspeed++){\n                if(nspeed<=0 or nspeed>c) continue;\n                double nt = ti + (double)d/(double)nspeed;\n                if(nt < visited[next_node][nspeed][pre]){\n#ifdef DEBUG\n                    cerr << \"\\ttime \" << nt << \" \" << \"node \" << next_node+1 << \" speed \" << nspeed << endl;\n#endif\n                    visited[next_node][nspeed][pre] = nt;\n                    que.push(makeP(nt,nspeed,next_node,node));\n                }\n            }\n        }\n    }\n    cout << \"unreachable\" << endl;\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m){\n        if(n==0 && m==0) break;\n        solve(n,m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nclass Node {\npublic:\n  int pre;\n  int now;\n  int vel;\n  double time;\n\n  Node(int p, int n, int v, double t) {\n    pre = p;\n    now = n;\n    vel = v;\n    time = t;\n  }\n\n  bool operator<(const Node &n) const {\n    return time > n.time;\n  }\n};\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n\n    if (n == 0) {\n      break;\n    }\n\n    int s, g;\n    cin >> s >> g;\n\n    vector<vector<int> > d(n + 1), c(n + 1);\n    for (int i = 0; i <= n; i++) {\n      d[i].resize(n + 1);\n      c[i].resize(n + 1);\n      fill(d[i].begin(), d[i].end(), -1);\n      fill(c[i].begin(), c[i].end(), 0);\n    }\n\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      cin >> d[x][y] >> c[x][y];\n      d[y][x] = d[x][y];\n      c[y][x] = c[x][y];\n    }\n\n    bool f[31][31][31];\n    for (int i = 0; i < 31; i++) {\n      for (int j = 0; j < 31; j++) {\n\tfor (int k = 0; k < 31; k++) {\n\t  f[i][j][k] = false;\n\t}\n      }\n    }\n  \n    bool goal = false;\n    Node snd(0, s, 0, 0.0);\n    priority_queue<Node> q;\n    q.push(snd);\n    while (!q.empty()) {\n      Node nd = q.top();\n      q.pop();\n      if (nd.now == g && nd.vel == 1) {\n\tgoal = true;\n\tcout << nd.time << endl;\n\tbreak;\n      }\n      if (f[nd.pre][nd.now][nd.vel]) {\n\tcontinue;\n      }\n      f[nd.pre][nd.now][nd.vel] = true;\n      for (int i = 1; i <= n; i++) {\n\tif (i != nd.pre && d[nd.now][i] != -1) {\n\t  for (int j = -1; j <= 1; j++) {\n\t    int vel = nd.vel + j;\n\t    if (vel > 0 && vel <= c[nd.now][i]) {\n\t      Node next(nd.now, i, vel, nd.time + (double)d[nd.now][i] / vel);\n\t      q.push(next);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    if (!goal) {\n      cout << \"unreachable\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{int n,m;\nwhile(cin>>n>>m){\nfor(;;)\nreturn 0;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\n\nclass Dijkstra {\n    using T = double;\npublic:\n    struct edge {\n        int to;\n        T cost;\n    };\n    typedef pair<T, int> P;//firstは最短距離、secondは頂点の番号\n\n    int V;//超点数\n    vector<vector<edge> > G;//グラフ,G[i]はiから出る辺の集合,G[i][j]はiから出る辺のj番目の辺\n    vector<T> d; //最短距離\n\n    //0origin\n    Dijkstra(int N) {\n        V = N;\n        G = vector<vector<edge> >(N);\n        d = vector<T>(N);\n    };\n\n    void dijkstra(int s) {\n        priority_queue<P, vector<P>, greater<P> > que;\n        fill(d.begin(), d.end(), INFl);\n        d[s] = 0;\n        que.push(P(0, s));\n\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if (d[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge e = G[v][i];\n                if (d[e.to] > d[v] + e.cost && !(d[e.to] == INFl && d[v] == INFl)) {\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n\n    }\n\n    /* 頂点fromに頂点toに達するコストcostの辺を貼る */\n    void addEdge(int from, int to, T cost) {\n        edge e;\n        e.to = to;\n        e.cost = cost;\n        G[from].push_back(e);\n    }\n};\n\nvoid solve(int n, int m) {\n    int s, g;\n    cin >> s >> g;\n    s--;\n    g--;\n\n    auto conv = [&](int f, int t, int v) {\n        //(頂点、速度)\n        return v * n * n + f * n + t;\n    };\n\n    Dijkstra dij(200 * n * n + n * n + n);\n\n    rep(i, 0, m) {\n        int x, y, d, c;\n        cin >> x >> y >> d >> c;\n        x--;\n        y--;\n        auto check = [&](int v) {\n            return v > 0 && v <= c;\n        };\n        rep(v, 0, 31) {\n            for (int V = v - 1; V <= v + 1; V++) {\n//                if(check(V)){\n//                    double tmp = 1.0 * d / V;\n//                    dij.addEdge(conv(x,v),conv(y,V),tmp);\n//                    dij.addEdge(conv(y,v),conv(x,V),tmp);\n//                }\n                for (int f = 0; f < n; f++) {\n                    if (check(V)) {\n                        double tmp = 1.0 * d / V;\n                        if (f != y) {\n                            dij.addEdge(conv(f, x, v), conv(x, y, V), tmp);\n                        }\n                        if (f != x) {\n                            dij.addEdge(conv(f, y, v), conv(y, x, V), tmp);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    dij.dijkstra(conv(s, s, 0));\n//    cout << dij.d[conv(g,1)] << endl;\n    double ans = INFl;\n    rep(i, 0, n) {\n        ans = min(ans, dij.d[conv(i, g, 1)]);\n    }\n    if (ans > 1e7) {\n        cout << \"unreachable\" << endl;\n    } else {\n//        cout << ans << endl;\n        printf(\"%.12lf\", ans);\n        cout << endl;\n    }\n\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nclass data\n{\npublic:\n    int p, q, c;\n    data(int p0, int q0, int c0){\n        p = p0;\n        q = q0;\n        c = c0;\n    }\n};\n\nvoid solve(int n, int start, int goal, vector<vector<int> > distance, vector<vector<int> > limit)\n{\n    vector<bool> easyCheck(n, false);\n    queue<int> q;\n    q.push(start);\n    while(!q.empty()){\n        int a = q.front();\n        if(!easyCheck[a]){\n            easyCheck[a] = true;\n            for(int i=0; i<n; ++i){\n                if(distance[a][i] > -1)\n                    q.push(i);\n            }\n        }\n        q.pop();\n    }\n    if(!easyCheck[goal]){\n        cout << \"unreachable\" << endl;\n        return;\n    }\n\n\tbool check[30][30][31];\n\tdouble time[30][30][31];\n    for(int i=0; i<n; ++i){\n        if(distance[start][i] > -1)\n\t\t\ttime[i][start][1] = distance[start][i];\n    }\n\n    for(;;){\n\t\tint p, q, c;\n\t\tdouble minTime = DBL_MAX;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tfor(int j=0; j<n; ++j){\n\t\t\t\tfor(int k=1; k<=limit[i][j]; ++k){\n\t\t\t\t\tif(!check[i][j][k] && time[i][j][k] < minTime){\n\t\t\t\t\t\tp = i;\n\t\t\t\t\t\tq = j;\n\t\t\t\t\t\tc = k;\n\t\t\t\t\t\tminTime = time[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(p == goal && c == 1){\n\t\t\tprintf(\"%.10f\\n\", minTime);\n\t\t\treturn;\n\t\t}\n\n        check[p][q][c] = true;\n        for(int i=0; i<n; ++i){\n            if(i == p || i == q || distance[i][p] == -1)\n                continue;\n            for(int j=-1; j<=1; ++j){\n                if(1 <= c+j && c+j <= limit[p][i] && !check[i][p][c+j])\n\t\t\t\t\ttime[i][p][c+j] = min(time[i][p][c+j], minTime + distance[p][i]/static_cast<double>(c+j));\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, s, g;\n        cin >> n >> m;\n        if(n == 0 && m == 0)\n            break;\n        cin >> s >> g;\n        -- s;\n        -- g;\n\n        vector<vector<int> > distance(n, vector<int>(n, -1));\n        vector<vector<int> > limit(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int x, y;\n            cin >> x >> y;\n            -- x;\n            -- y;\n            cin >> distance[x][y] >> limit[x][y];\n            distance[y][x] = distance[x][y];\n            limit[y][x] = limit[x][y];\n        }\n\n        solve(n, s, g, distance, limit);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct S{\n  double t;\n  int v;\n  int p;\n  int from;\n  S(){}\n  S(double t, int v, int p,int from) :\n    t(t), v(v), p(p),from(from) {}\n};\nstruct edge{\n  int to, dist, lim;\n  edge(int to, int dist, int lim) :\n    to(to), dist(dist), lim(lim) {}\n};\ntypedef vector<edge> edges;\nbool operator < (const S& s, const S& t){\n  return s.t > t.t;\n}\nint main(){\n  int n,m,s,g;\n  while(cin>>n>>m>>s>>g, n){\n    s--; g--;\n    vector<edges> graph(n);\n    REP(i,m){\n      int x,y,d,c;\n      cin>>x>>y>>d>>c; x--; y--;\n      graph[x].push_back(edge(y, d, c));\n      graph[y].push_back(edge(x, d, c));\n    }\n    priority_queue<S> que;\n    que.push(S(0,0,s,-1));\n    bool used[40][40][40] = {};\n    double ans = -1;\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      //printf(\"quesize:%d time:%lf speed:%d point:%d\\n\",que.size(), s.t,s.v,s.p);\n      if(s.p == g && s.v == 1){\n        ans = s.t;\n        break;\n      }\n      if(used[s.v][s.p][s.from]) continue;\n      used[s.v][s.p][s.from] = true;\n      for(int nv = s.v - 1; nv <= s.v + 1; nv++)if(nv > 0){\n        FORIT(it, graph[s.p])if(it->lim >= nv && it->to != s.from){\n          que.push(S(s.t + (double)it->dist/nv, nv, it->to, s.from));\n        }\n      }\n    }\n    if(ans != -1) cout<<ans<<endl;\n    else cout<<\"unreachable\"<<endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#include <queue>\nusing namespace std;\n\ndouble memo[32][32]; //[vol][vertex] = time\nint N,M,S,G;\nstruct e {\n\tint d,c;\n}edge[32][32];\n\nvoid solve(int vertex,int vol,int befor,double cost,int cnt)\n{\n\tif(cost > memo[1][G])return;\n\t//printf(\"%d,%d,%d,%lf,%d\\n\",vertex,vol,befor,cost,cnt);\n\t\n\tint v;\n\tfor(int i=1;i<=N;i++){\n\t\tif(vertex==i || i==befor || edge[vertex][i].d == 0)continue;\n\t\tif(vol>0 && vol<=edge[vertex][i].c){\n\t\t\tif(memo[vol][i] > (double)edge[vertex][i].d/(double)vol + cost){\n\t\t\t\tmemo[vol][i] = (double)edge[vertex][i].d/(double)vol + cost;\n\t\t\t\tsolve(i,vol,vertex,memo[vol][i],cnt+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(vol+1>0 && vol+1<=edge[vertex][i].c){\n\t\t\tif(memo[vol+1][i] > (double)edge[vertex][i].d/(double)(vol+1) + cost){\n\t\t\t\tmemo[vol+1][i] = (double)edge[vertex][i].d/(double)(vol+1) + cost;\n\t\t\t\tsolve(i,vol+1,vertex,memo[vol+1][i],cnt+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(vol-1>0 && vol-1<=edge[vertex][i].c){\n\t\t\tif(memo[vol-1][i] > (double)edge[vertex][i].d/(double)(vol-1) + cost){\n\t\t\t\tmemo[vol-1][i] = (double)edge[vertex][i].d/(double)(vol-1) + cost;\n\t\t\t\tsolve(i,vol-1,vertex,memo[vol-1][i],cnt+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint x,y,d,c;\n\tfor(;cin>>N>>M,N||M;){\n\t\tcin>>S>>G;\n\t\tfor(int i=0;i<32;i++)for(int j=0;j<32;j++)\n\t\t\tmemo[i][j]=999999.0;\n\t\tmemset(edge,0,sizeof(edge));\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tedge[x][y].d = edge[y][x].d = d;\n\t\t\tedge[x][y].c = edge[y][x].c = c;\n\t\t}\n\t\tmemo[1][S] = 0.0;\n\t\t//solve(S, 0, 0, 0.0, 0);\n\t\tqueue<pair<int,int> > qq;\n\t\tqueue<int> befor;\n\t\tqueue<double> cc;\n\t\tqq.push(make_pair(0,S));\n\t\tbefor.push(S);\n\t\tcc.push(0.0);\n\t\tfor(;!qq.empty();qq.pop()){\n\t\t\tint vol = qq.front().first;\n\t\t\tint vertex = qq.front().second;\n\t\t\tint b = befor.front();\n\t\t\tdouble cost = cc.front();\n\t\t\tbefor.pop();\n\t\t\tcc.pop();\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\tif(i==vertex || i==b || edge[vertex][i].d == 0)continue;\n\t\t\t\tif(vol>0 && vol<=edge[vertex][i].c){\n\t\t\t\t\tif(memo[vol][i] > (double)edge[vertex][i].d/vol + cost){\n\t\t\t\t\t\tmemo[vol][i] = (double)edge[vertex][i].d/vol + cost;\n\t\t\t\t\t\tqq.push(make_pair(vol,i));\n\t\t\t\t\t\tbefor.push(vertex);\n\t\t\t\t\t\tcc.push(memo[vol][i]);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(vol+1>0 && vol+1<=edge[vertex][i].c){\n\t\t\t\t\tif(memo[vol+1][i] > (double)edge[vertex][i].d/(vol+1) + cost){\n\t\t\t\t\t\tmemo[vol+1][i] = (double)edge[vertex][i].d/(vol+1) + cost;\n\t\t\t\t\t\tqq.push(make_pair(vol+1,i));\n\t\t\t\t\t\tbefor.push(vertex);\n\t\t\t\t\t\tcc.push(memo[vol+1][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(vol-1>0 && vol-1<=edge[vertex][i].c){\n\t\t\t\t\tif(memo[vol-1][i] > (double)edge[vertex][i].d/(vol-1) + cost){\n\t\t\t\t\t\tmemo[vol-1][i] = (double)edge[vertex][i].d/(vol-1) + cost;\n\t\t\t\t\t\tqq.push(make_pair(vol-1,i));\n\t\t\t\t\t\tbefor.push(vertex);\n\t\t\t\t\t\tcc.push(memo[vol-1][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif(memo[1][G]==999999.0)\n\t\t\tputs(\"unreachable\");\n\t\telse printf(\"%lf\\n\",memo[1][G]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdio>\n#include<cmath>\n#define inf 100000007\nusing namespace std;\n\nstruct State{\n\n  int speed,now,before;\n  double time;\n  State(double time,int speed,int now,int before):\n    time(time),speed(speed),now(now),before(before){}\n  bool operator<(State S)const{\n    return S.time < time;\n    }\n};\n\nint main()\n{\n  int n,m,s,g,a,b,d,l;\n  int dis[30][30],lim[30][30],S[3]={-1,0,1};\n  double dp[30][30][30],eps=1e-8; \n\n  while(1){\n    cin>>n>>m;\n    if(n+m==0)break;\n    cin>>s>>g;\n    s--;g--;\n    for(int i=0;i<30;i++){\n      for(int j=0;j<30;j++){\n\tdis[i][j]=inf;\n\tlim[i][j]=inf;\n\tfor(int k=0;k<30;k++)dp[i][j][k]=inf;\n      }\n    }\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>d>>l;\n      a--;b--;\n      dis[a][b]=d;\n      dis[b][a]=d;\n      lim[a][b]=l;\n      lim[b][a]=l;\n    }\n\n    double ans=inf;\n    priority_queue<State> pq;\n    pq.push(State(0,0,s,s));\n    dp[s][s][1]=0;\n    while(!pq.empty()){\n      State u=pq.top();\n      pq.pop();\n\n      if(u.now==g && u.speed==1){\n\tans=min(u.time,ans);\n\tcontinue;\n      }\n      if(u.time > dp[u.before][u.now][u.speed]+eps)continue;\n      /*\n      printf(\"%.10f\",u.f.f);\n      cout<<\" \"<<u.f.s<<\" \"<<u.s.f<<\" \"<<u.s.s<<endl;\n      */\n      for(int i=0;i<n;i++){\n\tif(i==u.now)continue;\n\tif(i==u.before)continue;\n      \tif(dis[u.now][i]==inf)continue;\n\tfor(int k=0;k<3;k++){\n\t  int speed = u.speed+S[k];\n\t  if( speed<1 || 30<speed )continue;\n\t  if( lim[u.now][i] < speed )continue;\n\t  double time=(double)dis[u.now][i]/(double)speed;\n\t  if( dp[u.now][i][speed]+eps < time + u.time)continue;\n\t  dp[u.now][i][speed] = time + u.time;\n\t  pq.push(State(time+u.time,speed,i,u.now));\n\t}\n      }\n    }\n    if(ans>=inf-1)cout<<\"unreachable\"<<endl;\n    else printf(\"%.5f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Road{\npublic:\n  int distance;\n  int speed_limit;\n  Road(int _d,int _s) : distance(_d),speed_limit(_s) {}\n  Road() : distance(INF),speed_limit(0) {}\n};\n\nclass State{\npublic:\n  int city;\n  int speed;\n  double time;\n  int prev;\n  State() : city(0),speed(1),time(0.0), prev(0){}\n  State(int _c,int _s,double _t,int _p) : city(_c),speed(_s),time(_t),prev(_p){}\n  \n  bool operator<(const State& s) const{\n    return time < s.time;\n  }\n\n  bool operator>(const State& s) const{\n    return time > s.time;\n  }\n};\n\nint main(){\n  int total_cities;\n  int total_roads;\n  while(~scanf(\"%d %d\",&total_cities,&total_roads)){\n    if(total_cities == 0 && total_roads == 0) break;\n    int start,goal;\n    scanf(\"%d %d\",&start,&goal);\n\n    Road edges[100][100];\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      int from,to,distance,speed_limit;\n      scanf(\"%d %d %d %d\",&from,&to,&distance,&speed_limit);\n      edges[from][to].distance = distance;\n      edges[from][to].speed_limit = speed_limit;\n      edges[to][from].distance = distance;\n      edges[to][from].speed_limit = speed_limit;\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(start,1,0.0,0)); //pos,speed,time\n\n    bool dp[50][50][50];\n\n    memset(dp,false,sizeof(dp));\n    double res = -0.1;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n\n      if(dp[s.prev][s.city][s.speed]) continue;\n\n      if(s.city == goal && s.speed == 1){\n\tres = s.time;\n\tbreak;\n      }\n\n      dp[s.prev][s.city][s.speed] = true;\n\n      for(int to = 1; to <= total_cities; to++){\n\tif(edges[s.city][to].distance >= INF) continue;\n\tif(s.prev == to) continue;\n\n\tif(edges[s.city][to].speed_limit >= s.speed - 1\n\t   && s.speed-1 >= 1){\n\t  que.push(State(to,\n\t\t\t s.speed -1,\n\t\t\t s.time + (double)edges[s.city][to].distance/(double)(s.speed - 1),\n\t\t\t s.city));\n\t}\n\n\tif(edges[s.city][to].speed_limit >= s.speed + 1\n\t   && s.time != 0.0){\n\t  que.push(State(to,\n\t\t\t s.speed + 1,\n\t\t\t s.time + (double)edges[s.city][to].distance/(double)(s.speed + 1),\n\t\t\t s.city));\n\t}\n\t\n\tif(edges[s.city][to].speed_limit >= s.speed){\n\t  que.push(State(to,\n\t\t\t s.speed,\n\t\t\t s.time + (double)edges[s.city][to].distance/(double)(s.speed),\n\t\t\t s.city));\n\n\t}\n      }\n    }\n\n    if(res < 0){\n      printf(\"unreachable\\n\");\n    }\n    else{\n      printf(\"%.5f\\n\",res);\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint to;\n\tdouble cost;\n};\n\ntypedef pair<double,pair<int,int> > P;\n\nint V;\nvector<edge> G[1000];\n\nconst double INF = 1000000000.0;\n\nvoid dijkstra(int s,int g){\n\tdouble d[1000];\n\tint prev[40];\n\n\tfill(prev,prev+40,(int)INF);\n\tfill(d,d+V,INF);\n\t\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\td[s] = 0.0;\n\tque.push(P(0.0,make_pair(s,-1)));\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second.first;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost && p.second.second != (e.to-1)/30){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to],make_pair(e.to,((v-1)/30))));\n//\t\t\t\tprev[(e.to-1)/30] = (v-1)/30;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(EQ(d[g],INF)){\n\t\tcout << \"unreachable\" << endl;\n\t}\n\telse{\n\t\tprintf(\"%.5f\\n\",d[g]);\n\t}\n\n}\n\nint main(){\n\t\n\t// ツ各ツ凝ヲツ甘板づづ債督ッツ暗ェツ都ツ市ツづーツ督楪達ツスツピツーツドツつイツづづ可ノツーツドツづ可閉ェツつッツづつ「ツづゥ\n\t// G 1-30,31-60,61-90...\n\tint n,m,s,g;\n\twhile(cin >> n >> m >> s >> g && !(n == 0 && m == 0)){\n\t\tV = n*30+1;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint to,from,di,c;\n\t\t\tcin >> from >> to >> di >> c;\n\t\t\t// from -> to\n\t\t\tfor(int j = 1; j <= 30; j++){\n\t\t\t\tif(from == s && j == 1){\n\t\t\t\t\tedge e;\n\t\t\t\t\te.to = (to-1)*30+1;\n\t\t\t\t\te.cost = di;\n\t\t\t\t\tG[(s-1)*30+1].push_back(e);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint from2 = (from-1)*30+j;\n\t\t\t\t\tfor(int k = -1; k <= 1; k++){\n\t\t\t\t\t\tif(k+j > 0 && k + j <= c){\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.to = (to-1)*30 + (j+k);\n\t\t\t\t\t\t\te.cost = (double)di/(j+k);\n\t\t\t\t\t\t\tG[from2].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// to -> from\n\t\t\tfor(int j = 1; j <= 30; j++){\n\t\t\t\tif(to == s && j == 1){\n\t\t\t\t\tedge e;\n\t\t\t\t\te.to = (from-1)*30+1;\n\t\t\t\t\te.cost = di;\n\t\t\t\t\tG[(s-1)*30+1].push_back(e);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint from2 = (to-1)*30+j;\n\t\t\t\t\tfor(int k = -1; k <= 1; k++){\n\t\t\t\t\t\tif(k+j > 0 && k + j <= c){\n\t\t\t\t\t\t\tedge e;\n\t\t\t\t\t\t\te.to = (from-1)*30 + (j+k);\n\t\t\t\t\t\t\te.cost = (double)di/(j+k);\n\t\t\t\t\t\t\tG[from2].push_back(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdijkstra((s-1)*30+1,(g-1)*30+1);\n\n\t\tfor(int i = 0; i < 1000; i++){\n\t\t\tG[i].clear();\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair((a),(b))\n#define list3(a,b,c) mp((a),mp((b),(c)))\n#define list4(a,b,c,d) mp((a),list3((b),(c),(d)))\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint vis[40][40][40];\nint n,m;\nvector<pair<int,PI > > G[40];\n\nvoid solve(){\n  int s,g;\n  cin >> s >> g;\n  --s,--g;\n  rep(i,n) G[i].clear();\n  rep(i,m){\n    int x,y,d,c;\n    cin >> x >> y >> d >> c;\n    --x,--y;\n    G[x].pb(mp(y,mp(d,c)));\n    G[y].pb(mp(x,mp(d,c)));\n  }\n  \n  priority_queue<pair<double,pair<int,PI > > > q;\n  q.push(list4(0.,s,1,s));\n  CLR(vis);\n  bool fl=true;\n  while(!q.empty()){\n    double cc=-q.top().F;\n    int cv=q.top().S.F;\n    int cs=q.top().S.S.F;\n    int be=q.top().S.S.S;\n    q.pop();\n\n    if(vis[cv][cs][be]) continue;\n    //cout << cc << ' ' << cv << ' ' << cs << ' ' << be << endl;\n    if(cv==g && cs==1){\n      printf(\"%.8f\\n\",cc);\n      return;\n    }    \n    vis[cv][cs][be] = true;\n    FOR(it,G[cv]){\n      if(it->F==be) continue;\n      for(int di=-1;di<=1;++di){\n\tint ns=cs+di;\n\tif(ns<=0 || ns>it->S.S) continue;\n\tif(fl && ns!=1) continue;\n\tq.push(list4(-cc-it->S.F*1./ns,it->F,ns,cv));\n      }\n    }\n    fl=false;\n  }\n  cout << \"unreachable\" << endl;\n}\n\nint main(){\n  while(cin >> n >> m && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define EPS 1e-8\n#define DEB 0\n\nconst double inf = 9999999999.0;\ndouble dp[32][32][32];  // [id][speed][prev]\nint node[32][32];\nint speed[32][32];\n\nclass state{\n  public:\n\tint id,prev,speed;\n\tdouble cost;\n\tstate(int _id, int _p, int _sp, double _c){\n\t\tid = _id;\n\t\tprev = _p;\n\t\tspeed = _sp;\n\t\tcost = _c;\n\t}\n\tbool operator<(const state& a)const{\n\t\treturn cost > a.cost;\n\t}\n};\nint main(){\n\tint n,m,s,g;\n\twhile(scanf(\"%d%d\",&n,&m),n|m){\n\t\tscanf(\"%d%d\",&s,&g);\n\t\trep(i,32)rep(j,32)rep(k,32)dp[i][j][k]=inf;\n\t\trep(i,32)rep(j,32)node[i][j]=speed[i][j]=0;\n\t\trep(i,m){\n\t\t\tint x,y,d,c; scanf(\"%d%d%d%d\",&x,&y,&d,&c);\n\t\t\tnode[x][y] = node[y][x] = d;\n\t\t\tspeed[x][y] = speed[y][x] = c;\n\t\t}\n\n#if DEB\n\t\tprintf(\"%d %d %d %d\\n\",n,m,s,g);\n\n\t\tprintf(\"node\\n\");\n\t\tREP(i,1,n+1){\n\t\t\tREP(j,1,n+1){\n\t\t\t\tprintf(\"%d \",node[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\n\t\tprintf(\"speed\\n\");\n\t\tREP(i,1,n+1){\n\t\t\tREP(j,1,n+1){\n\t\t\t\tprintf(\"%d \",speed[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n#endif\t\t\n\n\t\t\n\t\tdouble karikari = inf;\n\t\tpriority_queue<state> q;\n\t\tbool f = true;\n\t\tq.push(state(s, s, 1, 0.0));\n\t\twhile( !q.empty() ){\n\t\t\tint id = q.top().id;\n\t\t\tint prev = q.top().prev;\n\t\t\tint v = q.top().speed;\n\t\t\tdouble cost = q.top().cost;\n\t\t\tq.pop();\n\t\t\tif( karikari<cost ) break;\n\n\t\t\tREP(i,1,n+1)if( node[id][i] && i!=prev ){\n\t\t\t\tfor(int k=-1; k<=1; k++){\n\t\t\t\t\tif( id==s && f && k!=0 ){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#if DEB\n\t\t\t\t\tif( id==s ){\n\t\t\t\t\t\tprintf(\"kkk:%d   v:%d\\n\",k,v+k);\n\t\t\t\t\t}\n#endif\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif( 1<=v+k && v+k<=speed[id][i] ){\n\t\t\t\t\t\tif( dp[i][v+k][id] > cost + (double)node[id][i]/(double)(v+k) ){\n\t\t\t\t\t\t\tdp[i][v+k][id] = cost + (double)node[id][i]/(double)(v+k);\n\t\t\t\t\t\t\tq.push( state(i, id, v+k, dp[i][v+k][id]) );\n#if DEB\n\t\t\t\t\t\t\tprintf(\"%d --> %d  v:%d   cost:%lf\\n\",id,i,v+k,dp[i][v+k][id]);\n#endif\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tf = false;\n\t\t}\n\t\tdouble ans = inf;\n\t\tREP(i,1,n+1)if( dp[g][1][i]<ans ){\n\t\t\tans = dp[g][1][i];\n\t\t}\n\t\tif( ans==inf ){\n\t\t\tputs(\"unreachable\");\n\t\t}else{\n\t\t\tprintf(\"%lf\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nconst int MAX = 35;\nconst int INF = (1<<25);\nint n,m;\n\nstruct Edge{\n  int to;\n  double dis,lim;\n  Edge(int a, double b, double c):to(a),dis(b),lim(c){}\n};\n\nstruct State{\n  int pos,from;\n  double speed,t;\n  State(int a, double b, double c, int f):pos(a),speed(b),t(c),from(f){}\n  bool operator < (const State& s) const{ return t > s.t;}\n};\n\nvector<Edge> E[MAX];\ndouble T[MAX][MAX][MAX];\n//T[i][j][k] := shortest time from i to j with speed k.\n\n\nvoid init(){\n  for(int i = 0; i < MAX; i++){\n    for(int j = 0; j < MAX; j++)\n      for(int k = 0; k < MAX; k++) T[i][j][k] = INF;\n    E[i].clear();\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++){\n    int x,y;\n    double d,c;\n    cin >> x >> y >> d >> c;\n    //   cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    E[x].push_back(Edge(y,d,c));\n    E[y].push_back(Edge(x,d,c));\n  }\n}\n\nvoid solve(int s, int g){\n\n  priority_queue<State> Q;\n  T[0][s][0] = 0;\n  Q.push(State(s,0,0,-1));\n\n  while(!Q.empty()){\n    State sta = Q.top();\n    Q.pop();\n    \n    cerr << Q.size() << endl;\n\n    if(sta.t > T[sta.from][sta.pos][(int)sta.speed]) continue;\n\n    for(int i = 0; i < E[sta.pos].size(); i++){\n      int np = E[sta.pos][i].to;\n\n      if(np == sta.from) continue;\n\n      double sp[] = {-1,0,1};\n      \n      for(int j = 0; j < 3; j++){\n\tdouble ns = sta.speed+sp[j];\n\tif(ns <= 0 || ns > E[sta.pos][i].lim) continue;\n\tdouble nt = sta.t+E[sta.pos][i].dis/ns;\n\tif(T[sta.pos][np][(int)ns] > nt){\n\t  T[sta.pos][np][(int)ns] = nt;\n\t  Q.push(State(np,ns,nt,sta.pos));\n\t}\n      }\n    }\n  }\n\n  // cerr << \"come \" << endl;\n\n  double ans = INF;\n\n  for(int i = 0; i < MAX; i++)\n    ans = min(ans,T[i][g][1]);\n  \n\n  if(ans == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.5f\\n\",ans);\n}\n\nint main(){\n\n  while(cin >> n >> m && n+m){\n    init();\n    int s,g;\n    cin >> s >> g;\n    input();\n    solve(s,g);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000.0\n#define EPS 1e-8\nusing namespace std;\nstruct state { int n, v, l; double t; };\n\nint N, M, S, G;\nvector<int> T[31], D[31], C[31];\nint vd[3] = { -1, 0, 1 };\ndouble dp[31][51];\n\nclass Compare {\npublic:\n  bool operator() (struct state a, struct state b) {\n    return a.t > b.t;\n  }\n};\n\nint main(void) {\n  while(cin >> N >> M, N) {\n    cin >> S >> G;\n    REP(i, 0, 30) {\n      T[i].clear();\n      D[i].clear();\n      C[i].clear();\n    }\n    REP(i, 1, M) {\n      int x, y, d, c; cin >> x >> y >> d >> c;\n      T[x].push_back(y); D[x].push_back(d); C[x].push_back(c);\n      T[y].push_back(x); D[y].push_back(d); C[y].push_back(c);\n    }\n\n    REP(i, 1, N) REP(j, 0, 50) dp[i][j] = INF;\n\n    priority_queue<struct state, vector<struct state>, Compare> q;\n    struct state first = { S, 0, -1, 0.0 };\n    q.push(first);\n\n    while(!q.empty()) {\n      struct state c = q.top();\n      q.pop();\n\n      // cout << c.n << \" \" << c.v << \" \" << c.t << endl;\n\n      if(dp[c.n][c.v] <= c.t) continue;\n      dp[c.n][c.v] = min(dp[c.n][c.v], c.t);\n      if(c.n == G && c.v == 1) break;\n\n      for(int i = 0; i < T[c.n].size(); i++) {\n        if(T[c.n][i] == c.l) continue;\n        REP(j, 0, 3) {\n          int v = c.v + vd[j];\n          if(v <= 0 || C[c.n][i] < v) continue;\n          double t = c.t + ((double) D[c.n][i] / v);\n          struct state n = { T[c.n][i], v, c.n, t };\n          if(n.t < dp[n.n][n.v] - EPS) q.push(n);\n        }\n      }\n    }\n\n    if(dp[G][1] < INF - EPS) printf(\"%.6f\\n\", dp[G][1]);\n    else cout << \"unreachable\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 1<<29\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\ntypedef pair<double,int> dP;\ntypedef pair<P,dP> PPP;\nint n,m,s,g;\n\n\nint main(){\n  int inx,iny,ind,inc;\n  double d[40][40][40];\n  while(true){\n    scanf(\"%d %d\",&n,&m);\n    if(n+m == 0)break;\n    vector<PP> matrix[40];\n    \n    \n    scanf(\"%d %d\",&s,&g);\n    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=1;k<=30;k++)d[i][j][k] = INF;\n    for(int i=0;i<m;i++){\n     \n      scanf(\"%d %d %d %d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    priority_queue<PPP,vector<PPP>,greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    int counter = 0;\n    while(!que.empty()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n      for(int i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1e9\nusing namespace std;\ndouble cost[30][30][31]; int d[30][30],c[30][30];\nstruct S{\n\tdouble cc;int c,p,v;\n\tS(double cc,int c,int p,int v):cc(cc),c(c),p(p),v(v){}\n\tbool operator<(const S &a)const{\n\t\treturn cc>a.cc;\n\t}\n};\nint main(){\n\tint n,m,s,g,x,y,a,b; double nc;\n\twhile(scanf(\"%d%d\",&n,&m),n){\n\t\tscanf(\"%d%d\",&s,&g),s--,g--;\n\t\trep(i,n)rep(j,n){\n\t\t\trep(k,31)cost[i][j][k]=INF;\n\t\t\td[i][j]=c[i][j]=0;\n\t\t}\n\t\trep(i,m)scanf(\"%d%d%d%d\",&x,&y,&a,&b),\n\t\tx--,y--,d[x][y]=d[y][x]=a,c[x][y]=c[y][x]=b;\n\t\tpriority_queue<S> F; F.push(S(0,s,s,0)); cost[s][s][0]=0;\n\t\twhile(!F.empty()){\n\t\t\tS cs=F.top(); F.pop();\n\t\t\trep(i,n)if(i!=cs.p&&d[cs.c][i])\n\t\t\tfor(int dv=-1;dv<2;dv++)if(0<dv+cs.v&&dv+cs.v<=c[cs.c][i]){\n\t\t\t\tnc=cost[cs.c][cs.p][cs.v]+1.*d[cs.c][i]/(dv+cs.v);\n\t\t\t\tif(cost[i][cs.c][dv+cs.v]>nc){\n\t\t\t\t\tcost[i][cs.c][dv+cs.v]=nc,F.push(S(nc,i,cs.c,dv+cs.v));\n\t\t\t\t\tif(i==g&&dv+cs.v==1){\n\t\t\t\t\t\tprintf(\"%.5f\\n\",nc); goto END;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"unreachable\\n\"); END:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define se second\n#define fi first\nusing namespace std;\ntypedef pair<pair<int,int>,int>P;\nstruct edge{int to,lim;double dist;};\nint n,m,st,go,a1,a2,a4;\ndouble d[31][31],a3;\nint dx[]={-1,0,1};\nvector<edge> v[31];\nint main(){\n  while(cin>>n>>m,n){\n    r(i,31)v[i].clear();\n    r(i,31)r(j,31)d[i][j]=1e12;\n    cin>>st>>go;\n    r(i,m){\n      edge e;\n      scanf(\"%d%d%lf%d\",&a1,&a2,&a3,&a4);\n      e.to=a2,e.dist=a3,e.lim=a4;\n      v[a1].push_back(e);\n      e.to=a1;\n      v[a2].push_back(e);\n    }\n    priority_queue<P>q;\n    d[st][0]=0;\n    P xt;xt.fi.fi=0,xt.fi.se=st,xt.se=-1;\n    q.push(xt);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int cur=p.fi.se;\n      r(i,v[cur].size()){\n        edge e=v[cur][i];\n        if(e.to!=p.se)r(j,3){\n          int x=p.fi.fi+dx[j];\n          if(0<x&&x<=e.lim){\n            double t=e.dist/x+d[cur][p.fi.fi];\n            if(d[e.to][x]>t){\n              d[e.to][x]=t;\n              xt.fi.fi=x,xt.fi.se=e.to,xt.se=cur;\n              q.push(xt);\n            }\n          }\n        }\n      }\n    }\n    if(d[go][1]==1e12)cout<<\"unreachable\"<<endl;\n    else printf(\"%.9f\\n\",d[go][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n//#define LOG(...) printf(__VA_ARGS__)\n#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\n\nstruct edge{\n    int to, cost, limit;\n};\n\nstruct P{\n    int v;\n    double cost;\n    int ptown,speed;\n\n    bool operator >(const P &p)const{\n        return cost>p.cost;\n    }\n};\n\n#define MAX_TOWN 31\n#define MAX_V 31\n#define INF INT64_MAX\ndouble d[MAX_TOWN][MAX_V];//town, v\n\nint main() {\n    int town, road, s, g;\n    while(cin >> town >> road, town|road){\n        cin >> s >> g;\n        fill_n((double*)d, MAX_TOWN*MAX_V, INF);\n\n        vector<vector<edge> > G(town+1);\n        REP(i, road){\n            int from,to,cost,limit;\n            cin >> from >> to >> cost >> limit;\n            G[from].push_back((edge){to, cost, limit});\n            G[to].push_back((edge){from, cost, limit});\n        }\n\n        d[s][1]=0;\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push((P){s,0,-1,1});\n\n        while(!que.empty()){\n            P p=que.top();que.pop();\n            int v=p.v;\n            int sp=p.speed;\n            LOG(\"town %d speed %d cost %f\\n\",v,sp,p.cost);\n\n            if(v==g&&sp==1){\n                break;\n            }\n\n            if(d[v][sp]<p.cost)continue;\n            REP(i, G[v].size()){\n                edge e=G[v][i];\n                if(p.ptown==e.to)continue;\n\n                for(int i=-1;i<=1;i++){\n                    if(i!=0&&p.cost==0){\n                        continue;\n                    }\n                    int nexts=sp+i;\n                    if(nexts<=0||30<nexts)continue;\n                    if(nexts>e.limit)continue;\n                    double time=p.cost+(double)e.cost/(double)nexts;\n                    if(d[e.to][nexts]>time){\n                        d[e.to][nexts]=time;\n                        que.push((P){e.to,time,v,nexts});\n                    }\n                }\n            }\n        }\n\n        if(d[g][1]==INF)\n            printf(\"unreachable\\n\");\n        else\n            printf(\"%0.5f\\n\",d[g][1]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\n\ndouble H[33][33][33];\nconst double INF = 1e100;\n\nstruct state{\n  int n,p,v;\n  double c;\n  state(int n,int p,int v,double c) : n(n),p(p),v(v),c(c) {}\n  bool operator<(const state &st) const{\n    return c > st.c;\n  }\n};\n\nstruct edge {\n  int to,d,c;\n  edge(int to,int d,int c) : to(to),d(d),c(c) {}\n};\n\nvector<edge> G[33];\n\nvoid dijk(int s,int g){\n  fill(H[0][0],H[32][32],INF);\n\n  priority_queue<state> q;\n  q.push( state( s, s, 0, 0.0 ) );\n  H[s][s][0] = 0.0;\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    if( p.c > H[p.n][p.p][p.v] ) continue;\n    if( p.n == g && p.v == 1 ) {\n      printf(\"%.9lf\\n\", p.c); return;\n    }\n    for(int i=0;i<(int)G[p.n].size();i++){\n      edge e = G[p.n][i];\n      for(int nv=p.v-1;nv<=p.v+1;nv++){\n        if( 0 < nv && nv <= e.c ) {\n          double nc = p.c + (double)e.d/(double)nv;\n          if( H[e.to][p.n][nv] > nc ){\n            H[e.to][p.n][nv] = nc;\n            q.push( state( e.to, p.n, nv , nc ) );\n          }\n        }\n      }\n    }\n  }\n  cout << \"unreachable\" << endl;\n}\n\nint main(){\n  int s,g;\n  while(cin >> N >> M && (N|M) ){\n    cin >> s >> g;\n    --s; --g;\n    for(int i=0;i<M;i++){\n      int x,y,d,c;\n      cin >> x >> y >> d >> c;\n      --x;--y;\n      G[x].push_back( edge(y,d,c) );\n      G[y].push_back( edge(x,d,c) );\n    }\n    dijk( s, g );\n    for(int i=0;i<N;i++)\n      G[i].clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double INF = 1e9;\nconst double eps = 1e-5;\nusing pdi = pair<double, pair<int, int>>;\nusing tp4 = tuple<double, int, int, int>;\n\nint N, M;\n\nstruct edge\n{\n    int to;\n    double cost;\n    int lim;\n    edge(int t, double d, int l) : to(t), cost(d), lim(l) {}\n};\n// dist,v,pv,velocity\nvoid dijkstra(int s, vector<vector<vector<double>>> &dist, vector<vector<edge>> &G)\n{\n    priority_queue<tp4, vector<tp4>, greater<tp4>> que;\n    for (auto e : G[s])\n    {\n        int ns = e.to;\n        que.push(make_tuple(e.cost, ns, s, 1));\n        dist[ns][s][1] = e.cost;\n    }\n    while (!que.empty())\n    {\n        auto p = que.top();\n        que.pop();\n        double d = get<0>(p);\n        int v = get<1>(p);\n        int par = get<2>(p);\n        int velo = get<3>(p);\n\n        if (dist[v][par][velo] - d < -eps)\n            continue;\n        for (edge e : G[v])\n        {\n            if (e.to == par)\n                continue;\n            for (int nvelo = max(velo - 1, 1); nvelo <= min(velo + 1, e.lim); nvelo++)\n            {\n                if (dist[e.to][v][nvelo] - dist[v][par][velo] - e.cost / (double)nvelo > eps)\n                {\n                    dist[e.to][v][nvelo] = dist[v][par][velo] + e.cost / (double)nvelo;\n                    que.push(make_tuple(dist[e.to][v][nvelo], e.to, v, nvelo));\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (cin >> N >> M, N | M)\n    {\n        int s, g;\n        cin >> s >> g;\n        s--, g--;\n        vector<vector<edge>> G(N);\n        for (int i = 0; i < M; i++)\n        {\n            int a, b, c, d;\n            cin >> a >> b >> c >> d;\n            a--, b--;\n            G[a].push_back(edge(b, c, d));\n            G[b].push_back(edge(a, c, d));\n        }\n        double res = INF;\n        vector<vector<vector<double>>> dist(N, vector<vector<double>>(N, vector<double>(31, INF)));\n        dijkstra(s, dist, G);\n        for (int v = 0; v < N; v++)\n        {\n            res = min(res, dist[g][v][1]);\n        }\n\n        if (abs(res - INF) < eps)\n        {\n            cout << \"unreachable\" << endl;\n        }\n        else\n        {\n            cout << fixed << setprecision(10) << res << endl;\n        }\n        // s+N -> g+N\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint n,m,s,g;\nmap<int, vector<TIII> > r;\nmap<pair<int, int>, double> v;\n\nint main(){\n\twhile(1){\n\t\tdouble ret = -1.0;\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)return 0;\n\t\tcin>>s>>g;\n\t\tr.clear();\n\t\tv.clear();\n\t\tREP(i,m){\n\t\t\tint x,y,d,c;\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tr[x].PB(MT(y,d,c));\n\t\t\tr[y].PB(MT(x,d,c));\n\t\t}\n\t\tpriority_queue<pair<double, pair<int, int> > , vector<pair<double, pair<int, int> > >, greater<pair<double, pair<int, int> > > > q;\n\t\tq.push(MP(0.0,MP(s, 0)));\n\t\twhile(!q.empty()){\n\t\t\tpair<double, pair<int, int> > tmp = q.top();\n\t\t\tq.pop();\n\t\t\tif(EXIST(v, tmp.second))continue;\n\t\t\tif(tmp.second == MP(g, 1)){\n\t\t\t\tret = tmp.first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv[tmp.second]=tmp.first;\n\t\t\tint city = tmp.second.first;\n\t\t\tint speed = tmp.second.second;\n\t\t\tdouble now = tmp.first;\n\t\t\tREP(i, r[city].size()){\n\t\t\t\tFOR(sp, speed-1, speed+2){\n\t\t\t\t\tif(sp<1)continue;\n\t\t\t\t\tTIII f = r[city][i];\n\t\t\t\t\tif(f.second.second >= sp && sp > 0)q.push(MP(now+(f.second.first*1.0)/(sp*1.0), MP(f.first, sp)));\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ret < 0.0)cout << \"unreachable\" <<endl;\n\t\telse printf(\"%.6f\", ret);;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\ntemplate<typename T>\nusing RQ = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nint main() {\n   for(;;) {\n      Int n, m;\n      std::cin >> n >> m;\n      if( n == 0 and m == 0 ) break;\n      Int s, g;\n      std::cin >> s >> g;\n      double inf = 1e16;\n      std::vector<std::pair<Int,double>> edges[32*32];\n      rep(ii,m) {\n         Int x, y, d, c;\n         std::cin >> x >> y >> d >> c;\n         for(Int kk = 0; kk < 2; ++kk) {\n            for(Int k = 1; k <= c; ++k) {\n               if( y != g ) {\n                  edges[x*32+k].emplace_back(y*32+k+1, (double)d/k);\n                  if( k >= 2 ) {\n                     edges[x*32+k].emplace_back(y*32+k-1, (double)d/k);\n                  }\n               }\n               edges[x*32+k].emplace_back(y*32+k+0, (double)d/k);\n            }\n            std::swap(x,y);\n         }\n      }\n      RQ<std::tuple<double,Int,Int>> q;\n      q.emplace(0.0, s*32+1, -1);\n      std::vector<double> dist(32*32, inf);\n      dist[s*32+1] = 0;\n      while( not q.empty() ) {\n         double d;\n         Int v;\n         Int prev;\n         std::tie(d, v, prev) = q.top(); q.pop();\n         for(auto next : edges[v]) {\n            Int nv;\n            double dd;\n            std::tie(nv, dd) = next;\n            if( nv/32 == prev ) continue;\n            double nd = d + dd;\n            if( nd < dist[nv] ) {\n               dist[nv] = nd;\n               q.emplace(nd, nv, v/32);\n            }\n         }\n      }\n      if( dist[g*32+1] >= inf ) {\n         puts(\"unreachable\");\n      }\n      else {\n         printf(\"%lf\\n\", dist[g*32+1]);\n      }\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\ntypedef pair<double,ll> dmp;\ntypedef pair<dmp,mp> mmp;\ndouble inf =1e9;\nstruct edge{\n\tint to,d,c;\n\tedge(){}\n\tedge(int to,int d,int c):to(to),d(d),c(c){}\n};\n\nint main(){\n    while(1){\n\tint n,m,s,t;\n\tcin>>n>>m;\n\tif(n==0)break;\n\tcin>>s>>t;\n\ts--,t--;\n\tvector<vector<edge> > g(n);\n\tfor(int i=0;i<m;i++){\n\t\tint x,y,d,c;\n\t\tcin>>x>>y>>d>>c;\n\t\tx--,y--;\n\t\tg[x].push_back(edge(y,d,c) );\n\t\tg[y].push_back(edge(x,d,c) );\n\t}\n\tbool f = true;\n\tvector<vector<vector<bool> > > used(n,vector<vector<bool> >(n,vector<bool>(31,false) ) );\n\tpriority_queue<mmp,vector<mmp>,greater<mmp> > q;\n\tq.push( mmp ( dmp( 0.0 , 0 ), mp( s , s )  ) );\n\twhile(!q.empty() ){\n\t    mmp now = q.top();\n\t    q.pop();\n\t    double time = now.first.first;\n\t    ll speed = now.first.second;\n\t    ll nn = now.second.first;\n\t    ll prev = now.second.second;\n\t    //cout<<nn<<' '<<prev<<' '<<speed<<endl;\n\t    if( nn == t && speed == 1){\n\t\t\tprintf(\"%0.10lf\\n\",time);\n\t\t\tf = false;\n\t\t\tbreak;\n\t    }\n\t    //if(used[nn][prev][speed])continue;\n\t    //used[nn][prev][speed] = true;\n\t    for(int i=0;i<g[nn].size();i++){\n\t\tll next = g[nn][i].to;\n\t\tdouble dis = g[nn][i].d;\n\t\tll c = g[nn][i].c;\n\t\tif(next == prev) continue;\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tll nspeed = speed + j;\n\t\t\tif( nspeed <= 0 || c < nspeed )continue;\n\t\t\tif( used[next][nn][nspeed] ) continue;\n\t\t\tused[next][nn][nspeed] = true;\n\t\t\tq.push( mmp( dmp( time + dis/nspeed , nspeed ) , mp(next,nn )  )  );\n\t\t}\n\n\t    }\n\t}\n\tif(f)cout<<\"unreachable\"<<endl;\n\n    }\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 6/15 8:57 ~ 920 1129\n */\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#define INF 2000000\n\nusing namespace std;\n\nstruct edge {\n  int to;\n  int dis;\n  int lim;\n};\ntypedef pair<int, int> P;\n\nint iN;\nint iM;\nint iS;\nint iG;\nvector<edge> G[31];\ndouble d[31][31 * 31];\n\nbool input() {\n  int i;\n  int x, y, d, c;\n  edge e;\n\n  scanf(\"%d %d\", &iN, &iM);\n  if (iN == 0 && iM == 0)\n    return false;\n  scanf(\"%d %d\", &iS, &iG);\n\n  for (i = 0; i <= iN; i++) {\n    G[i].clear();\n  }\n\n  for (i = 0; i < iM; i++) {\n    scanf(\"%d %d %d %d\", &x, &y, &d, &c);\n    e.dis = d;\n    e.lim = c;\n    e.to = y;\n    G[x].push_back(e);\n    e.to = x;\n    G[y].push_back(e);\n  }\n  return true;\n}\n\nvoid dijkstraQueue() {\n  int i;\n  priority_queue<P, vector<P> , greater<P> > que;\n\n  for (i = 0; i <= iN; i++)\n    fill(d[i], d[i] + (iN + 1) * 31, INF);\n  d[iS][0 * 31 + 0] = 0;\n  que.push(P(0, iS * 31 * 31 + 0 * 31 + 0));\n\n  while (!que.empty()) {\n    P p = que.top();\n    que.pop();\n    int v = p.second / 31 / 31;\n    int b = p.second / 31 % 31;\n    int s = p.second % 31;\n    if (d[v][b * 31 + s] < p.first)\n      continue;\n    for (i = 0; i < (int) G[v].size(); i++) {\n      edge e = G[v][i];\n      if (e.to == b)\n        continue;\n      if (s > 0 && s <= e.lim) {\n        double cost = (double)e.dis / s;\n        if (d[e.to][v * 31 + s] > d[v][b * 31 + s] + cost) {\n          d[e.to][v * 31 + s] = d[v][b * 31 + s] + cost;\n          que.push(P(d[e.to][v * 31 + s], e.to * 31 * 31 + v * 31 + s));\n        }\n      }\n      if (s - 1 > 0 && s - 1 <= e.lim) {\n        double cost = (double)e.dis / (s - 1);\n        if (d[e.to][v * 31 + s - 1] > d[v][b * 31 + s] + cost) {\n          d[e.to][v * 31 + s - 1] = d[v][b * 31 + s] + cost;\n          que.push(P(d[e.to][v * 31 + s - 1], e.to * 31 * 31 + v * 31 + (s - 1)));\n        }\n      }\n      if (s + 1 <= e.lim) {\n        double cost = (double)e.dis / (s + 1);\n        //printf(\"%d %d %d %f\\n\", v, b, s, d[v][b * 31 + s] + cost);\n        if (d[e.to][v * 31 + (s + 1)] > d[v][b * 31 + s] + cost) {\n          d[e.to][v * 31 + (s + 1)] = d[v][b * 31 + s] + cost;\n          que.push(P(d[e.to][v * 31 + (s + 1)], e.to * 31 * 31 + v * 31 + (s + 1)));\n        }\n      }\n    }\n  }\n}\n\nvoid output() {\n  int i;\n  double out;\n  out = d[iG][1 * 31 + 1];\n  for (i = 2; i < iN; i++) {\n    out = min(out, d[iG][i * 31 + 1]);\n  }\n  if (out == INF)\n    printf(\"unreachable\\n\");\n  else\n    printf(\"%f\\n\", out);\n}\n\nint main() {\n  while (1) {\n    if (!input())\n      break;\n    dijkstraQueue();\n    output();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nconst int MAX = 31;\nconst int INF = (1<<25);\nint n,m;\nstruct Edge{\n  int to;\n  double dis,lim;\n  Edge(int a, double b, double c){\n    to = a;\n    dis = b;\n    lim = c;\n  }\n};\n\nstruct State{\n  int pos,from;\n  double speed,t;\n  State(int a, double b, double c, int f){\n    pos = a;\n    speed = b;\n    t = c;\n    from = f;\n  }\n  bool operator < (const State& s) const{ return t > s.t;}\n};\n\nvector<Edge> E[MAX];\ndouble T[MAX][MAX];\n//T[i][j] := shortest time to i with speed j.\n\n\nvoid init(){\n  for(int i = 0; i < MAX; i++){\n    fill(T[i],T[i]+MAX,INF);\n    E[i].clear();\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++){\n    int x,y;\n    double d,c;\n    cin >> x >> y >> d >> c;\n    //   cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    E[x].push_back(Edge(y,d,c));\n    E[y].push_back(Edge(x,d,c));\n  }\n}\n\nvoid solve(int s, int g){\n\n  priority_queue<State> Q;\n  T[s][0] = 0;\n  Q.push(State(s,0,0,-1));\n\n  while(!Q.empty()){\n    State s = Q.top();\n    Q.pop();\n\n    if(s.t > T[s.pos][(int)s.speed]) continue;\n\n    for(int i = 0; i < E[s.pos].size(); i++){\n      int np = E[s.pos][i].to;\n\n      if(np == s.from) continue;\n\n      double sp[] = {-1,0,1};\n      \n      for(int j = 0; j < 3; j++){\n\tdouble ns = s.speed+sp[j];\n\tif(ns <= 0 || ns > E[s.pos][i].lim) continue;\n\tdouble nt = s.t+E[s.pos][i].dis/ns;\n\tif(T[np][(int)ns] > nt){\n\t  T[np][(int)ns] = nt;\n\t  Q.push(State(np,ns,nt,s.pos));\n\t}\n      }\n    }\n  }\n  \n\n  if(T[g][1] == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.5f\\n\",T[g][1]);\n}\n\nint main(){\n  \n  while(cin >> n >> m && n+m){\n    init();\n    int s,g;\n    cin >> s >> g;\n    input();\n    solve(s,g);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<class EdgeInfo>\nclass Graph {\nprotected:\n\tusing size_type = ::std::size_t;\n\tstruct Edge {\n\t\tsize_type to;\n\t\tEdgeInfo info;\n\t\tEdge() : to(-1) {}\n\t\tEdge(size_type to_, EdgeInfo info_) : to(to_), info(info_) {}\n\t};\n\tusing edge_type = Edge;\n\n\t::std::vector<::std::vector<edge_type>> edges;\n\npublic:\n\tGraph() {}\n\tGraph(size_type n) : edges(n) {}\n\tGraph(const Graph& g) : edges(g.edges) {}\n\tGraph(Graph&& g) { ::std::swap(edges, g.edges); }\n\tGraph& operator=(const Graph& g) { edges = g.edges; }\n\tGraph& operator=(Graph&& g) { ::std::swap(edges, g.edges); }\n\n\tconst size_type size() { return edges.size(); }\n\tvirtual void add_edge (size_type from, size_type to, EdgeInfo info) = 0;\n\n\tconst ::std::vector<edge_type>& operator[](size_type k) { return edges[k]; }\n\n};\n\ntemplate<class EdgeInfo>\nclass DirectedGraph : public Graph<EdgeInfo> {\nprotected:\n\tusing size_type = ::std::size_t;\npublic:\n\tusing edge_type = typename Graph<EdgeInfo>::edge_type;\n\tDirectedGraph() {}\n\tDirectedGraph(size_type n) : Graph<EdgeInfo>(n) {}\n\tDirectedGraph(const DirectedGraph& g) : Graph<EdgeInfo>(g) {}\n\tDirectedGraph(DirectedGraph&& g) : Graph<EdgeInfo>(g) {}\n\tDirectedGraph& operator=(const DirectedGraph& g) { this->edges = g.edges; return *this;}\n\tDirectedGraph& operator=(DirectedGraph&& g) noexcept { ::std::swap(this->edges, g.edges); return *this; }\n\n\tvoid add_edge (size_type from, size_type to, EdgeInfo info = EdgeInfo()) {\n\t\tthis->edges[from].push_back(edge_type(to, info));\n\t}\n};\n\ntemplate<class DistanceType>\nclass Dijkstra {\nprivate:\n\tusing size_type = ::std::size_t;\n\tusing distance_type = DistanceType;\n\tusing Graph = DirectedGraph<distance_type>;\n\n\tGraph graph;\npublic:\n\tDijkstra() {}\n\tDijkstra(size_type n) : graph(n) {}\n\tDijkstra(const Graph& g) : graph(g) {}\n\n\tvoid add_edge (size_type from, size_type to, distance_type d) {\n\t\tgraph.add_edge(from, to, d);\n\t}\n\n\t::std::vector<distance_type> build(size_type start) {\n\t\t::std::vector<distance_type> dis(graph.size(), invalid_value());\n\n\t\tusing P = ::std::pair<distance_type, size_type>;\n\t\t::std::priority_queue<P, ::std::vector<P>, ::std::greater<P>> pq;\n\t\tdis[start] = 0;\n\t\tpq.push(P(dis[start], start));\n\t\twhile (pq.size()) {\n\t\t\tP p = pq.top(); pq.pop();\n\t\t\tif (p.first > dis[p.second]) continue;\n\t\t\tfor (auto e : graph[p.second]) {\n\t\t\t\tif (dis[e.to] > dis[p.second] + e.info) {\n\t\t\t\t\tdis[e.to] = dis[p.second] + e.info;\n\t\t\t\t\tpq.push(P(dis[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dis;\n\t}\n\n\tstatic const distance_type invalid_value () {\n\t\tstatic const distance_type inf = ::std::numeric_limits<distance_type>::max() / 2 - 1;\n\t\treturn inf;\n\t}\n};\n\nint64 n, m;\nint64 to_idx(int64 v, int64 s, int64 from, int64 is_to) {\n  return (is_to ? n*n*40 : 0) + n*40*from + n*s + v;\n}\n\nint main(void) {\n  while (cin >> n >> m && n+m) {\n    Dijkstra<double> shp(2*n*n*(40));\n    int64 s, g;\n    cin >> s >> g; s--; g--;\n    REP(i, n) {\n      REP(j, 35) {\n        REP(k, n) {\n          shp.add_edge(to_idx(i, j, k, 0), to_idx(i, j, k, 1), 0);\n          shp.add_edge(to_idx(i, j, k, 0), to_idx(i, j+1, k, 1), 0);\n          if (j > 0)\n            shp.add_edge(to_idx(i, j, k, 0), to_idx(i, j-1, k, 1), 0);\n        }\n      }\n    }\n    REP(i, m) {\n      int64 x, y, d, c;\n      cin >> x >> y >> d >> c; x--; y--;\n      REP(j, c) {\n        REP(k, n) {\n          if (y != k)\n            shp.add_edge(to_idx(x, j, k, 1), to_idx(y, j, x, 0), (double)d/(double)(j+1));\n          if (x != k)\n            shp.add_edge(to_idx(y, j, k, 1), to_idx(x, j, y, 0), (double)d/(double)(j+1));\n        }\n      }\n    }\n    auto ret = shp.build(to_idx(s, 0, s, 1));\n    double res = shp.invalid_value();\n    REP(i, n) {\n      chmin(res, ret[to_idx(g, 0, i, 0)]);\n    }\n    if (res == shp.invalid_value()) {\n      cout << \"unreachable\" << endl;\n    } else {\n      cout << fixed << setprecision(10) << res << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int,P> P3;\ntypedef pair<double, P3> P4;\nconst ll MOD = ll(1e9+7);\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(3e5 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nstruct edge{\n    int to, c;\n    double d;\n};\n\nint n, m, s, g;\nvector<vector<edge> > G;\ndouble tmin[35][35];  // 頂点iに速さjで到着するときの最短時間\n\nvoid dijkstra(){\n    REP(i,n)fill(tmin[i],tmin[i]+35,IINF);\n    priority_queue<P4, vector<P4>, greater<P4> > que;\n    tmin[s][0] = 0.0;\n    que.push({0.0,{-1,{s,0}}});\n    while(!que.empty()){\n        P4 p = que.top();\n        que.pop();\n        int from = p.second.second.first, v = p.second.second.second;\n        if(p.first > tmin[from][v] + EPS)continue;\n        for(auto &e : G[from]){\n            if(e.to == p.second.first)continue;\n            for(int dv=-1; dv<=1; dv++){\n                int nv = v+dv;\n                if(nv<=0 || nv>e.c)continue;\n                if(tmin[e.to][nv] > tmin[from][v] + e.d/double(nv) + EPS){\n                    tmin[e.to][nv] = tmin[from][v] + e.d/double(nv);\n                    que.push({tmin[e.to][nv],{from,{e.to,nv}}});\n                }\n            }\n        }\n    }\n}\n\n\nint main() {\n    while(cin >> n >> m, n){\n        cin >> s >> g;\n        s--; g--;\n        G.clear();\n        G.resize(n);\n        REP(i,m){\n            int x, y, c;\n            double d;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            G[x].push_back({y,c,d});\n            G[y].push_back({x,c,d});\n        }\n        dijkstra();\n        if(tmin[g][1]<IINF/2){\n            printf(\"%.8lf\\n\",tmin[g][1]);\n        }\n        else{\n            cout << \"unreachable\" << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#define F first\n#define S second\n#define EPS 1e-10\n#define INF 100\ntypedef std::pair<int,int> P;\ntypedef std::pair<P,int> PP;\ntypedef std::pair<double,int> dP;\ntypedef std::pair<P,dP> PPP;\n\n\n\nint main(){\n \n  while(true){\n    int n,m;\n\n    scanf(\"%d%d\",&n,&m);\n    if(n+m == 0)break;\n    std::vector<PP> matrix[31];    \n    \n    int inx,iny,ind,inc;\n    double d[31][31][31];\n    int s,g;\n \n\n    scanf(\"%d%d\",&s,&g);\n    for(short i=1;i<=n;i++)for(short j=1;j<=n;j++)for(short k=1;k<=30;k++)d[i][j][k] = INF;\n   \n    for(short i=0;i<m;i++){\n      scanf(\"%d%d%d%d\",&inx,&iny,&ind,&inc);\n      matrix[inx].push_back(PP(P(iny,ind),inc));\n      matrix[iny].push_back(PP(P(inx,ind),inc));\n    }\n\n    d[s][s][1] = 0;\n    // PPP(P(now,prev),dP(cost,speed))\n    std::priority_queue<PPP,std::vector<PPP>,std::greater<PPP> > que;\n    que.push(PPP(P(s,0),dP(0.0,1)));\n\n    double test = INF;\n    \n    while(que.size()){\n      PPP p = que.top();que.pop();\n      if(p.S.F > d[p.F.F][p.F.S][p.S.S])continue;\n     \n\n      for(short i=0;i<matrix[p.F.F].size();i++){\n\tPP q = matrix[p.F.F][i];\n\n\tif(q.F.F == p.F.S || d[p.F.F][q.F.F][p.S.S] <= p.S.F+(double)q.F.S/(double)p.S.S || p.S.S > q.S)continue;\n\tif(d[p.F.F][q.F.F][p.S.S] > p.S.F+(double)q.F.S/(double)p.S.S && p.S.S <= q.S){  \n\t  if(q.F.F == g && p.S.S == 1){\n\t    d[p.F.F][q.F.F][p.S.S]=  d[q.F.F][p.F.F][p.S.S]  = p.S.F+(double)q.F.S/(double)p.S.S;\n\t    if(test > d[p.F.F][q.F.F][p.S.S])test = d[p.F.F][q.F.F][p.S.S];\n\t    //test = min(test, d[p.F.F][q.F.F][p.S.S]);\n\t  }    \n\t  else{\t  \n\t    d[p.F.F][q.F.F][p.S.S] =  d[q.F.F][p.F.F][p.S.S]  = p.S.F + (double)q.F.S/(double)p.S.S;\n\t    if(d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S)));\n\t    if(p.S.S+1<=30 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S+1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S+1)));\n\t    if(p.S.S-1>=1 && d[p.F.F][q.F.F][p.S.S] <= d[q.F.F][p.F.F][p.S.S-1])que.push(PPP(P(q.F.F,p.F.F),dP(d[p.F.F][q.F.F][p.S.S],p.S.S-1)));\n\t  }\n\t}\n      }\n\n    }\n \n    if(test != INF)printf(\"%.5f\\n\",test);\n    else printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <tuple>\n#include <queue>\nusing namespace std;\n\nstruct road {\n  int to, len, max_v;\n  road(int to, int len, int max_v) : to(to), len(len), max_v(max_v) {}\n};\n\nint main(){\n  int n, m;\n  while(cin >> n >> m, n){\n    int s, g;\n    cin >> s >> g;\n    --s,--g;\n    vector<vector<road>> G(n);\n    for(int i = 0; i < m; ++i){\n      int x, y, d, c;\n      cin >> x >> y >> d >> c;\n      --x,--y;\n      G[x].emplace_back(y,d,c);\n      G[y].emplace_back(x,d,c);\n    }\n    const double INF = 1e9;\n    vector<vector<vector<double>>> T(n,vector<vector<double>>(n,vector<double>(31,INF)));\n    priority_queue<tuple<double,int,int,int>> Q;\n    Q.emplace(0,s,s,0);\n    while(Q.size()){\n      double t;\n      int cur, from, v;\n      tie(t,cur,from,v) = Q.top();\n      t *= -1;\n      Q.pop();\n      if(T[cur][from][v] < t) continue;\n      T[cur][from][v] = t;\n      for(auto e : G[cur]){\n        if(e.to == from) continue;\n        for(int dv = -1; dv < 2; ++dv){\n          int v_ = v+dv;\n          if(v_ <= 0) continue;\n          if(v_ > e.max_v) break;\n          double t_ = t + (double)e.len/v_;\n          if(T[e.to][cur][v_] > t_){\n            T[e.to][cur][v_] = t_;\n            Q.emplace(-t_,e.to,cur,v_);\n          }\n        }\n      }\n    }\n    double ans = INF;\n    for(int i = 0; i < n; ++i){\n      ans = min(ans,T[g][i][1]);\n    }\n    if(ans >= INF) puts(\"unreachable\");\n    else printf(\"%.12lf\\n\",ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector< vector<int> > vvi;\n\nint dist[31][31];\nint cap[31][31];\nbool visit[31][31]; // city, speed\nconst int INF = 1e7;\n\nstruct node {\n\tint s, p, c;\n\tdouble t;\n\tnode(int _s, int _p, int _c, double _t) {\n\t\ts = _s;\n\t\tp = _p;\n\t\tc = _c;\n\t\tt = _t;\n\t}\n};\nbool operator<(const node& l, const node& r) {\n\treturn l.t > r.t;\n}\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\trep(i,31) rep(j,31) dist[i][j] = cap[i][j] = INF;\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tint s, g;\n\t\tcin >> s >> g;\n\t\trep(i, m) {\n\t\t\tint x, y, d, c;\n\t\t\tcin >> x >> y >> d >> c;\n\t\t\tdist[x][y] = dist[y][x] = d;\n\t\t\tcap[x][y] = cap[y][x] = c;\n\t\t}\n\t\tpriority_queue<node> que;\n\t\tvisit[s][1] = true;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tif( dist[s][i] < INF && 1 <= cap[s][i] ) {\n\t\t\t\tque.push( node(1, i, s, 1.*dist[s][i]) );\n\t\t\t}\n\t\t}\n\t\tbool found = false;\n\t\twhile(!que.empty()) {\n\t\t\tnode nd = que.top();\n\t\t\tque.pop();\n\t\t\tif( nd.p==g && nd.s==1 ) {\n\t\t\t\tcout << setprecision(10) << nd.t << endl;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( visit[nd.p][nd.s] ) continue;\n\t\t\tvisit[nd.p][nd.s] = true;\n\t\t\tfor(int nxt=1; nxt<=n; nxt++) {\n\t\t\t\tif( nd.c == nxt ) continue;\n\t\t\t\tfor(int sp=max(1,nd.s-1); sp<=min(30,nd.s+1); sp++) {\n\t\t\t\t\tif( !visit[nxt][sp] && dist[nd.p][nxt] < INF && sp <= cap[nd.p][nxt] ) {\n\t\t\t\t\tdouble nt = nd.t + 1.*dist[nd.p][nxt]/sp;\n\t\t\t\t\t\tque.push(node(sp, nxt, nd.p, nt));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!found) {\n\t\t\tcout << \"unreachable\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nconst int MAX = 35;\nconst int INF = (1<<25);\nint n,m;\n\nstruct Edge{\n  int to;\n  double dis,lim;\n  Edge(int a, double b, double c):to(a),dis(b),lim(c){}\n};\n\nstruct State{\n  int pos,from;\n  double speed,t;\n  State(int a, double b, double c, int f):pos(a),speed(b),t(c),from(f){}\n  bool operator < (const State& s) const{ return t > s.t;}\n};\n\nvector<Edge> E[MAX];\ndouble T[MAX][MAX][MAX];\n//T[i][j][k] := shortest time from i to j with speed k.\n\n\nvoid init(){\n  for(int i = 0; i < MAX; i++){\n    for(int j = 0; j < MAX; j++)\n      for(int k = 0; k < MAX; k++) T[i][j][k] = INF;\n    E[i].clear();\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++){\n    int x,y;\n    double d,c;\n    cin >> x >> y >> d >> c;\n    //   cout << x << \" \" << y << \" \" << d << \" \" << c << endl;\n    E[x].push_back(Edge(y,d,c));\n    E[y].push_back(Edge(x,d,c));\n  }\n}\n\nvoid solve(int s, int g){\n\n  priority_queue<State> Q;\n  T[0][s][0] = 0;\n  Q.push(State(s,0,0,-1));\n\n  while(!Q.empty()){\n    State sta = Q.top();\n    Q.pop();\n\n    if(sta.t > T[sta.from][sta.pos][(int)sta.speed]) continue;\n\n    for(int i = 0; i < E[sta.pos].size(); i++){\n      int np = E[sta.pos][i].to;\n\n      if(np == sta.from) continue;\n\n      double sp[] = {-1,0,1};\n      \n      for(int j = 0; j < 3; j++){\n\tdouble ns = sta.speed+sp[j];\n\tif(ns <= 0 || ns > E[sta.pos][i].lim) continue;\n\tdouble nt = sta.t+E[sta.pos][i].dis/ns;\n\tif(T[sta.pos][np][(int)ns] > nt){\n\t  T[sta.pos][np][(int)ns] = nt;\n\t  Q.push(State(np,ns,nt,sta.pos));\n\t}\n      }\n    }\n  }\n\n  double ans = INF;\n\n  for(int i = 0; i < MAX; i++)\n    ans = min(ans,T[i][g][1]);\n  \n\n  if(ans == INF) cout << \"unreachable\" << endl;\n  else printf(\"%.5f\\n\",ans);\n}\n\nint main(){\n\n  while(cin >> n >> m && n+m){\n    init();\n    int s,g;\n    cin >> s >> g;\n    input();\n    solve(s,g);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n \nusing namespace std;\n \n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF 1e11\nconst int MAX_SPEED = 30;\n\nstruct P {\n    int city, pcity;\n    int speed;\n    float time;\n\n    bool operator >(const P& p) const {\n        return time > p.time;\n    }\n};\n\nstruct edge{\n    int to, dist, limit;\n};\n\ntypedef vector<float> vf;\ntypedef vector<vf> vvf;\ntypedef vector<vvf> vvvf;\n\nint main() {\n    int city_n, road_n, start, goal;\n\n    while(cin >> city_n >> road_n, city_n | road_n){\n        cin >> start >> goal;\n\n        vector<vector<edge>> E(city_n + 1);\n\n        REP(i, road_n){\n            int x, y, d, l;\n            cin >> x >> y >> d >> l;\n            E[x].push_back({y, d, l});\n            E[y].push_back({x, d, l});\n        }\n        vvvf G(city_n + 1, vvf(city_n + 1, vf(MAX_SPEED + 1, INF)));\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({start, start, 0, 0.0});\n\n        float res = -1;\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n\n            if(p.city == goal && p.speed == 1){\n                res = p.time;\n                break;\n            }\n\n            for(auto e : E[p.city]) {\n                if(e.to == p.pcity) continue;\n                FOR(d, -1, 1 + 1){\n                    int next_speed = p.speed + d;\n                    if (next_speed == 0) continue;\n                    float next_time = p.time + (float)e.dist / next_speed;\n                    if (0 < next_speed && next_speed <= e.limit &&\n                        G[e.to][p.city][next_speed] > next_time) {\n                        G[e.to][p.city][next_speed] = next_time;\n                        que.push({e.to, p.city, next_speed, next_time});\n                    }\n                }\n            }\n        }\n\n        if(res == -1)\n            cout << \"unreachable\" << endl;\n        else\n            printf(\"%f\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\n#define INF 1e9\nusing namespace std;\n\nclass DP{\npublic:\n\tdouble cost;\n\tint cur, sp, prev;\n\t\n\tDP(){}\n\tDP(double c, int cu, int s, int pr){\n\t\tcost = c;cur=cu;sp=s;prev=pr;\n\t}\n\t\n\tbool operator< (const DP &opp) const {\n\t\treturn cost>opp.cost;\n\t}\n};\nint n,m,s,go;\n\npriority_queue<DP> dp;\nchar visit[31][31][31];\nint g[31][31];\nint lim[31][31];\n\nmain(){\n\tint i,j,d,c,x,y;\n\twhile(cin>>n>>m,n){\n\t\tmemset(g, 0, sizeof(g));\n\t\tmemset(visit, 0, sizeof(visit));\n\t\twhile(!dp.empty()) dp.pop();\n\t\tcin>>s>>go;\n\t\t\n\t\tfor(i=1;i<=m;i++){\n\t\t\tcin>>x>>y>>d>>c;\n\t\t\tg[x][y]=g[y][x]=d;\n\t\t\tlim[x][y]=lim[y][x] = c;\n\t\t}\n\t\n\t\tDP T,S;\n\t\tdp.push(DP(0,1,0,0));\n\t\twhile(!dp.empty()){\n\t\t\tS = dp.top();\n\t\t\tdp.pop();\n\t\t\tif(S.cur == go && S.sp == 1) break;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tif(!g[S.cur][i]) continue;\n\t\t\t\tfor(j=S.sp-1;j<=S.sp+1;j++){\n\t\t\t\t\tif(lim[S.cur][i] < j || j < 1 || i == S.prev || visit[i][j][S.cur]) continue;\n\t\t\t\t\tT.cost = S.cost + g[S.cur][i] / (double)j;\n\t\t\t\t\tT.cur = i;\n\t\t\t\t\tT.sp = j;\n\t\t\t\t\tT.prev = S.cur;\n\t\t\t\t\tdp.push(T);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvisit[S.cur][S.sp][S.prev] = 1;\n\t\t}\n\t\tif(S.cur == go && S.sp == 1) printf(\"%.5lf\\n\", S.cost);\n\t\telse cout << \"unreachable\" << endl;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1162: Discrete Speed\n// 2017.9.18 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 30000\ntypedef struct { double t; int k, c, p; } QUE;\nQUE que[MAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n  int l, r;\n  int smallest;\n\n  l = LEFT(i), r = RIGHT(i);\n  if (l < qsize && que[l].t < que[i].t) smallest = l; else smallest = i;\n  if (r < qsize && que[r].t < que[smallest].t) smallest = r;\n  if (smallest != i) {\n    QUE t = que[i]; que[i] = que[smallest]; que[smallest] = t;\n    min_heapify(smallest);\n  }\n}\n\nint deq(int *k, int *c, int *p)\n{\n  if (qsize == 0) return 0;\n  *k = que[0].k, *c = que[0].c, *p = que[0].p;\n  que[0] = que[--qsize];\n  min_heapify(0);\n  return 1;\n}\n\nvoid enq(double t, int k, int c, int p)\n{\n  int i, ii;\n\n  i = qsize++;\n  que[i].t = t, que[i].k = k, que[i].c = c, que[i].p = p;\n  while (i > 0 && que[ii = PARENT(i)].t > que[i].t) {\n    QUE tt = que[i]; que[i] = que[ii]; que[ii] = tt;\n    i = ii;\n  }\n}\n\ntypedef struct { int len, to[32], d[32], c[32]; } TBL;\nTBL tbl[32];\ndouble node[32][32][32]; int size;\nint start, goal;\n\ndouble search()\n{\n\tint i, j, a, b, v, pre, v2;\n\tdouble t;\n\tTBL *p;\n\n\tqsize = 0;\n\tmemset(node, 0, sizeof(node));\n\tnode[start][0][0] = 0;\n\tenq(0, start, 0, 0);\n\twhile(deq(&a, &v, &pre)) {\n\t\tif (a == goal && v == 1) return node[goal][pre][v];\n\t\tfor (p = tbl+a, i = 0; i < p->len; i++) {\n\t\t\tif ((b = p->to[i]) == pre) continue;\n\t\t\tfor (j = -1; j <= 1; j++) {\n\t\t\t\tif ((v2 = v + j) > p->c[i] || v2 <= 0) continue;\n\t\t\t\tt = node[a][pre][v] + (double)p->d[i] / (double)v2;\n\t\t\t\tif (node[b][a][v2] == 0 || t < node[b][a][v2]) node[b][a][v2] = t, enq(t, b, v2, a);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1.0;\n}\n\nint main()\n{\n\tint m, a, b, d, c;\n\tTBL *p;\n\tdouble ans;\n\n\twhile (scanf(\"%d%d\", &size, &m) && size) {\n\t\tscanf(\"%d%d\", &start, &goal);\n\t\tmemset(tbl, 0, sizeof(tbl));\n\t\twhile (m-- > 0) {\n\t\t\tscanf(\"%d%d%d%d\", &a, &b, &d, &c);\n\t\t\tp = tbl + a, p->to[p->len] = b, p->d[p->len] = d, p->c[p->len] = c, p->len++;\n\t\t\tp = tbl + b, p->to[p->len] = a, p->d[p->len] = d, p->c[p->len] = c, p->len++;\n\t\t}\n\t\tif ((ans = search()) < 0) puts(\"unreachable\");\n\t\telse printf(\"%.10lf\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\nconst int route_max = 100000;\n\ntypedef struct _edge_t edge_t;\nstruct _edge_t {\n    int target;\n    int distance;\n    int slimit;\n    edge_t *next;\n};\n\ntypedef struct {\n    int id;\n    int adj_goal;\n    edge_t *edge;\n} vertex_t;\n\n\ntypedef struct {\n    int current;\n    int prev;\n    int speed;\n    double elapsed;\n} route_t;\n\nroute_t *_route;\nint _route_idx;\nroute_t *route_new(int size) {\n    _route = (route_t*)malloc(size * sizeof(route_t));\n    _route_idx = 0;\n}\n\nvoid route_reset() {\n    _route_idx = 0;\n}\n\nvoid route_delete() {\n    free(_route);\n    _route = NULL;\n}\n\nroute_t *route_next() {\n    route_t *r;\n    if (_route_idx >= route_max) {\n        r = &_route[_route_idx-1];\n        printf(\"ROUTE OVERFLOW :%d (%d, %.2lf)\\n\", r->current, r->speed, r->elapsed);\n        exit(75);\n    }\n    r = &_route[_route_idx++];\n    r->current = 0;\n    r->prev = 0;\n    r->speed = 1;\n    r->elapsed = 0;\n    return r;\n}\n\ntypedef struct {\n    route_t **e;\n    int count;\n    int capacity;\n} binheap;\n\n\nbinheap *bh_new(int size) {\n    binheap *bh;\n    bh = (binheap*)malloc(sizeof(binheap));\n    bh->e = (route_t**)malloc((size+1) * sizeof(route_t*));\n    bh->count = 0;\n    bh->capacity = size;\n    return bh;\n}\n\nvoid bh_delete(binheap *bh) {\n    free(bh->e);\n    free(bh);\n}\n\nvoid bh_reset(binheap *bh) {\n    bh->count = 0;\n}\n\nroute_t *bh_top(binheap *bh) {\n    return bh->e[1];\n}\n\nint bh_prior(route_t *a, route_t *b) {\n    return a->elapsed < b->elapsed;\n}\n\nint bh_priorchild(binheap *bh, int i) {\n    route_t *vl, *vr;\n    if (i * 2 + 1 > bh->count) {\n        return i * 2;\n    }\n    else {\n        vl = bh->e[i * 2];\n        vr = bh->e[i * 2 + 1];\n        if (bh_prior(vl, vr))\n            return i * 2;\n        else\n            return i * 2 + 1;\n    }\n}\n\nvoid bh_percup(binheap *bh, int i) {\n    route_t *vp, *vc, *tmp;\n    while (i / 2 > 0) {\n        vc = bh->e[i];\n        vp = bh->e[i/2];\n        if (bh_prior(vc, vp)) {\n            bh->e[i/2] = vc;\n            bh->e[i] = vp;\n        }\n        i = i / 2;\n    }\n}\n\nvoid bh_percdown(binheap *bh, int i) {\n    int ci;\n    route_t *vp, *vc, *tmp;\n    while (i*2 <= bh->count) {\n        ci = bh_priorchild(bh, i);\n        vp = bh->e[i];\n        vc = bh->e[ci];\n        if (bh_prior(vc, vp)) {\n            bh->e[i] = vc;\n            bh->e[ci] = vp;\n        }\n        i = ci;\n    }\n}\n\nvoid bh_push(binheap *bh, route_t *v) {\n    if (bh->count + 1 > bh->capacity) {\n        printf(\"HEAP OVERFLOW\\n\");\n        exit(75);\n    }\n    bh->count++;\n    bh->e[bh->count] = v;\n    bh_percup(bh, bh->count);\n}\n\nroute_t *bh_pop(binheap *bh) {\n    if (bh->count <= 0) return NULL;\n    route_t *v = bh->e[1];\n    bh->e[1] = bh->e[bh->count];\n    bh->count--;\n    bh_percdown(bh, 1);\n    return v;\n}\n\n\n\nint main(void) {\n    int n, m, s, g, x, y, d, c, i, k, next_speed;\n    binheap *bh;\n    route_t *route, *r, *nr, *fastest;\n    edge_t *edge, *e;\n    vertex_t vertex[31], *v;\n\n    bh = bh_new(route_max);\n    route_new(route_max);\n\n    while (scanf(\"%d%d\\n\", &n, &m) != EOF && n) {\n        int loopcheck[31][31][30] = {};\n        scanf(\"%d%d\\n\", &s, &g);\n        fastest = NULL;\n        edge = (edge_t*)malloc((m*2) * sizeof(edge_t));\n        for (i = 1; i <= n; i++) {\n            v = &vertex[i];\n            v->id = i;\n            v->adj_goal = 0;\n            v->edge = NULL;\n        }\n        for (i = 0, k = 0; i < m; i++) {\n            scanf(\"%d%d%d%d\\n\", &x, &y, &d, &c);\n            v = &vertex[x];\n            e = &edge[k++];\n            e->target = y;\n            e->distance = d;\n            e->slimit = c;\n            e->next = v->edge;\n            v->edge = e;\n            if (y == g) v->adj_goal = 1;\n\n            v = &vertex[y];\n            e = &edge[k++];\n            e->target = x;\n            e->distance = d;\n            e->slimit = c;\n            e->next = v->edge;\n            v->edge = e;\n            if (x == g) v->adj_goal = 1;\n        }\n\n        bh_reset(bh);\n        route_reset();\n        r = route_next();\n        r->current = s;\n        r->prev = -1;\n        r->speed = 1;\n        bh_push(bh, r);\n        while (bh->count) {\n            r = bh_pop(bh);\n            if (r->current == g && r->speed == 1) {\n                fastest = r;\n                break;\n            }\n            e = vertex[r->current].edge;\n            while (e != NULL) {\n                if (e->target == r->prev) goto next_edge;\n                for (i = -1; i <= 1; i++) {\n                    next_speed = r->speed + i;\n                    if (next_speed == 0 || next_speed > e->slimit) continue;\n                    if (loopcheck[r->current][e->target][next_speed]) continue;\n                    loopcheck[r->current][e->target][next_speed] = 1;\n                    nr = route_next();\n                    nr->current = e->target;\n                    nr->prev = r->current;\n                    nr->speed = next_speed;\n                    nr->elapsed = r->elapsed + (double)e->distance/next_speed;\n                    bh_push(bh, nr);\n\n                    if (r->prev == -1) break;\n                }\n\n                next_edge:; \n                e = e->next;\n            }\n        }\n\n        if (fastest) {\n            printf(\"%.5lf\\n\", fastest->elapsed);\n        }\n        else {\n            printf(\"unreachable\\n\");\n        }\n        free(edge);\n    }\n\n    route_delete();\n    bh_delete(bh);\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1162: Discrete Speed\n// 2017.9.18 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 3000\ntypedef struct { double t; int k, c, p; } QUE;\nQUE que[MAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n  int l, r;\n  int smallest;\n\n  l = LEFT(i), r = RIGHT(i);\n  if (l < qsize && que[l].t < que[i].t) smallest = l; else smallest = i;\n  if (r < qsize && que[r].t < que[smallest].t) smallest = r;\n  if (smallest != i) {\n    QUE t = que[i]; que[i] = que[smallest]; que[smallest] = t;\n    min_heapify(smallest);\n  }\n}\n\nint deq(int *k, int *c, int *p)\n{\n  if (qsize == 0) return 0;\n  *k = que[0].k, *c = que[0].c, *p = que[0].p;\n  que[0] = que[--qsize];\n  min_heapify(0);\n  return 1;\n}\n\nvoid enq(int k, double t, int c, int p)\n{\n  int i, ii;\n\n  i = qsize++;\n  que[i].t = t, que[i].k = k, que[i].c = c, que[i].p = p;\n  while (i > 0 && que[ii = PARENT(i)].t > que[i].t) {\n    QUE tt = que[i]; que[i] = que[ii]; que[ii] = tt;\n    i = ii;\n  }\n}\n\ntypedef struct { int len, to[32], d[32], c[32]; } TBL;\nTBL tbl[32];\ndouble node[32][32]; int size;\nint start, goal, cmax;\n\ndouble search()\n{\n\tint s, i, j, v, pre, s2, v2;\n\tdouble t;\n\tTBL *p;\n\n\tqsize = 0;\n\tmemset(node, 0, sizeof(node));\n\tnode[start][1] = 0;\n\tenq(start, 0, 0, 0);\n\twhile(deq(&s, &v, &pre)) {\n\t\tif (s == goal && v == 1) return node[goal][v];\n\t\tfor (p = tbl+s, i = 0; i < p->len; i++) {\n\t\t\tif ((s2 = p->to[i]) == pre) continue;\n\t\t\tfor (j = -1; j <= 1; j++) {\n\t\t\t\tif ((v2 = v + j) > p->c[i] || v2 <= 0) continue;\n\t\t\t\tt = node[s][v] + (double)p->d[i] / (double)v2;\n\t\t\t\tif (node[s2][v2] == 0 || t < node[s2][v2]) node[s2][v2] = t, enq(s2, t, v2, s);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1.0;\n}\n\nint main()\n{\n\tint m, a, b, d, c;\n\tTBL *p;\n\tdouble ans;\n\n\twhile (scanf(\"%d%d\", &size, &m) && size) {\n\t\tscanf(\"%d%d\", &start, &goal);\n\t\tmemset(tbl, 0, sizeof(TBL)*(size+1));\n\t\twhile (m-- > 0) {\n\t\t\tscanf(\"%d%d%d%d\", &a, &b, &d, &c);\n\t\t\tp = tbl + a, p->to[p->len] = b, p->d[p->len] = d, p->c[p->len] = c, p->len++;\n\t\t\tp = tbl + b, p->to[p->len] = a, p->d[p->len] = d, p->c[p->len] = c, p->len++;\n\t\t}\n\t\tif ((ans = search()) < 0) puts(\"unreachable\");\n\t\telse printf(\"%.8lf\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,i,j,k,mi,mj,mk,s,e;\n  double min;\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    int d[31][31]={0};\n    int l[31][31]={0};\n    scanf(\"%d %d\",&mi,&e);\n    while(m--){\n      scanf(\"%d %d %d %d\",&i,&j,&k,&s);\n      d[i][j]=d[j][i]=k;\n      l[i][j]=l[j][i]=s;\n    }\n    double c[31][31][31]={0};\n    int f[31][31][31]={0};//printf(\"a\\n\");\n    mj=mk=0;\n    while(mi-e||mk-1){\n      f[mi][mj][mk]=1;\n      for(i=1;i<=n;i++){\n\tif(i==mj||d[mi][i]==0)continue;\n\tfor(j=mk-1;j<mk+2;j++){\n\t  if(j<1||l[mi][i]<j||f[i][mj][j])continue;\n\t  if(c[i][mi][j]==0||c[i][mi][j]>c[mi][mj][mk]+1.0*d[mi][i]/j){\n\t    c[i][mi][j]=c[mi][mj][mk]+1.0*d[i][mi]/j;\n\t  }\n\t}\n      }\n      min=100000000;\n      for(i=1;i<=n;i++){\n\tfor(j=1;j<=n;j++){\n\t  for(k=1;k<=30;k++){\n\t    if(f[i][j][k]||c[i][j][k]==0)continue;\n\t    if(min>c[i][j][k])min=c[mi=i][mj=j][mk=k];\n\t  }\n\t}\n      }\n      if(min==100000000)break;\n    }\n    if(min-100000000)printf(\"%f\\n\",min);\n    else             printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,i,j,k,mi,mj,mk,s,e;\n  double min;\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    int d[31][31]={0};\n    int l[31][31]={0};\n    scanf(\"%d %d\",&mi,&e);\n    while(m--){\n      scanf(\"%d %d %d %d\",&i,&j,&k,&s);\n      d[i][j]=d[j][i]=k;\n      l[i][j]=l[j][i]=s;\n    }\n    double c[31][31][31]={0};\n    int f[31][31][31]={0};//printf(\"a\\n\");\n    int ff[31][31]={0};\n    mj=mk=0;\n    while(mi-e||mk-1){\n      f[mi][mj][mk]=1;\n      ff[mi][mk]++;\n      for(i=1;i<=n;i++){\n\tif(i==mj||d[mi][i]==0)continue;\n\tfor(j=mk-1;j<mk+2;j++){\n\t  if(j<1||l[mi][i]<j||f[i][mi][j]||ff[i][j]>1)continue;\n\t  if(c[i][mi][j]==0||c[i][mi][j]>c[mi][mj][mk]+1.0*d[mi][i]/j){\n\t    c[i][mi][j]=c[mi][mj][mk]+1.0*d[i][mi]/j;\n\t  }\n\t}\n      }\n      min=100000000;\n      for(i=1;i<=n;i++){\n\tfor(j=1;j<=n;j++){\n\t  for(k=1;k<=30;k++){\n\t    if(f[i][j][k]||ff[i][k]>1||c[i][j][k]==0)continue;\n\t    if(min>c[i][j][k])min=c[mi=i][mj=j][mk=k];\n\t  }\n\t}\n      }\n      if(min==100000000)break;\n    }\n    if(min-100000000)printf(\"%f\\n\",min);\n    else             printf(\"unreachable\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 100000000\ntypedef struct{\n    int prev;\n    int cur;\n    int v;\n}node_t;\nnode_t queue[N];\nint head,num;\nvoid enqueue(int prev,int cur,int v){\n    if(num<N){\n        queue[(head+num)%N].prev=prev;\n        queue[(head+num)%N].cur=cur;\n        queue[(head+num)%N].v=v;\n        num++;\n    }\n    else{\n        printf(\"エラー\\n\");\n        exit(1);\n    }\n}\nnode_t dequeue(const double cost[31][31][31]){\n    int index=head;\n    double min=cost[queue[head].prev][queue[head].cur][queue[head].v];\n    for(int i=head+1;i<head+num;i++){\n        if(min>cost[queue[i%N].prev][queue[i%N].cur][queue[i%N].v]){\n            min=cost[queue[i%N].prev][queue[i%N].cur][queue[i%N].v];\n            index=i%N;\n        }\n    }\n    node_t tmp=queue[head]; queue[head]=queue[index]; queue[index]=tmp;\n    node_t d={-1,-1,-1};\n    if(num>0){\n        d=queue[head];\n        head=(head+1)%N;\n        num--;\n    }\n    return d;\n}\nint main(void){\n    while(1){\n        head=num=0;\n        int n,m,s,g;\n        int x,y,d,c;\n        node_t tmp;\n        int dist[31][31]={0},lim[31][31]={0},used[31][31][31]={0};\n        //int node[31][31]={0};\n        double cost[31][31][31]={0};\n        scanf(\"%d%d%d%d\",&n,&m,&s,&g);\n        if(n+m==0) break;\n        for(int i=1;i<=m;i++){\n            scanf(\"%d%d%d%d\",&x,&y,&d,&c);\n            dist[x][y]=dist[y][x]=d; lim[x][y]=lim[y][x]=c;\n        }\n        enqueue(0,s,0);\n        while(1){\n            tmp=dequeue(cost);\n            int prev=tmp.prev,cur=tmp.cur,v=tmp.v;\n            if(prev==-1) break;\n            for(int i=1;i<=n;i++){//i:新しい場所\n                if(prev==i||cur==i||dist[cur][i]==0) continue;\n                for(int j=v-1;j<v+2;j++){//速度 v-1,v,v+1\n                    if(j<1||lim[cur][i]<j||used[cur][i][j]) continue;\n                    if(cost[cur][i][j]==0||\n                       cost[cur][i][j]>cost[prev][cur][v]+1.0*dist[cur][i]/j){\n                        enqueue(cur,i,j);\n                        used[cur][i][j]=1;\n                        cost[cur][i][j]=cost[prev][cur][v]+1.0*dist[cur][i]/j;\n                    }\n                }\n            }\n        }\n        double min=N;\n        for(int i=1;i<=n;i++){\n            if(cost[i][g][1]>0&&min>cost[i][g][1])\n                min=cost[i][g][1];\n        }\n        if(min==N) printf(\"unreachable\\n\");\n        else printf(\"%f\\n\",min);\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\t\n\tint n, m;\n\t\n\tint[][] edge;\n\tdouble[][][] minCost;\n\tint[][] maxSpeed;\t\n\t\n\tdouble INF = 100000000;\n\t\n\tclass State implements Comparable<State> {\n\t\tint n, speed, prev;\n\n\t\tState(int n, int speed, int prev) {\n\t\t\tthis.n = n;\n\t\t\tthis.speed = speed;\n\t\t\tthis.prev = prev;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(State arg0) {\n\t\t\tdouble c1 = minCost[n][prev][speed], c2 = minCost[arg0.n][arg0.prev][arg0.speed];\n\t\t\tif (c1 > c2) return 1;\n\t\t\telse if (c1 < c2) return -1;\n\t\t\telse return 0;\n\t\t}\n\t}\n\t\n\tvoid dijkstra(int start) {\n\t\tminCost = new double[n][n][31];\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++)\n\t\t\tArrays.fill(minCost[i][j], INF);\n\t\t\n\t\tminCost[start][start][0] = 0;\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.add(new State(start, 0, start));\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (edge[s.n][i] == INF) continue;\n\t\t\t\tif (s.prev == i) continue;\n\t\t\t\tint c = s.speed;\n\t\t\t\tfor (int v = -1; v <= 1; v++) {\n\t\t\t\t\tif (c+v > 0 && c+v <= maxSpeed[i][s.n] && minCost[i][s.n][c+v] > minCost[s.n][s.prev][c] + (double)edge[i][s.n] / (c+v)) {\n\t\t\t\t\t\tminCost[i][s.n][c+v] = minCost[s.n][s.prev][c] + (double)edge[i][s.n] / (c+v);\n\t\t\t\t\t\tpq.add(new State(i, c+v, s.n));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = in.nextInt(); m = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint s = in.nextInt() - 1, g = in.nextInt() - 1;\n\n\t\t\tmaxSpeed = new int[n][n];\n\t\t\tedge = new int[n][n];\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = in.nextInt() - 1, y = in.nextInt() - 1, d = in.nextInt(), c = in.nextInt();\n\t\t\t\tedge[x][y] = edge[y][x] = d;\n\t\t\t\tmaxSpeed[x][y] = maxSpeed[y][x] = c;\n\t\t\t}\n\t\t\t\n\t\t\tdijkstra(s);\n\t\t\t\n\t\t\tdouble res = INF;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tres = Math.min(minCost[g][i][1], res);\n\t\t\t\n\t\t\t/*\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t\t\tSystem.out.print(minCost[i][j] + \" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tSystem.out.println(res == INF ? \"unreachable\" : res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\t\n\tint n, m;\n\t\n\tint[][] edge;\n\tdouble[][] minCost;\n\tint[][] maxSpeed;\t\n\t\n\tdouble INF = 100000000;\n\t\n\tclass State implements Comparable<State> {\n\t\tint n, speed, prev;\n\n\t\tState(int n, int speed, int prev) {\n\t\t\tthis.n = n;\n\t\t\tthis.speed = speed;\n\t\t\tthis.prev = prev;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(State arg0) {\n\t\t\tdouble c1 = minCost[n][speed], c2 = minCost[arg0.n][arg0.speed];\n\t\t\tif (c1 > c2) return 1;\n\t\t\telse if (c1 < c2) return -1;\n\t\t\telse return 0;\n\t\t}\n\t}\n\t\n\tvoid dijkstra(int start) {\n\t\tminCost = new double[n][31];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tArrays.fill(minCost[i], INF);\n\t\t\n\t\tminCost[start][0] = 0;\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.add(new State(start, 0, start));\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (edge[s.n][i] == INF) continue;\n\t\t\t\tif (s.prev == i) continue;\n\t\t\t\tint c = s.speed;\n\t\t\t\tfor (int v = -1; v <= 1; v++) {\n\t\t\t\t\tif (c+v > 0 && c+v <= maxSpeed[i][s.n] && minCost[i][c+v] > minCost[s.n][c] + (double)edge[i][s.n] / (c+v)) {\n\t\t\t\t\t\tminCost[i][c+v] = minCost[s.n][c] + (double)edge[i][s.n] / (c+v);\n\t\t\t\t\t\tpq.add(new State(i, c+v, s.n));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = in.nextInt(); m = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint s = in.nextInt() - 1, g = in.nextInt() - 1;\n\n\t\t\tmaxSpeed = new int[n][n];\n\t\t\tedge = new int[n][n];\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = in.nextInt() - 1, y = in.nextInt() - 1, d = in.nextInt(), c = in.nextInt();\n\t\t\t\tedge[x][y] = edge[y][x] = d;\n\t\t\t\tmaxSpeed[x][y] = maxSpeed[y][x] = c;\n\t\t\t}\n\t\t\t\n\t\t\tdijkstra(s);\n\t\t\t\n\t\t\tdouble res = INF;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tres = Math.min(minCost[g][i][1], res);\n\t\t\t\n\t\t\t/*\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t\t\tSystem.out.print(minCost[i][j] + \" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tSystem.out.println(res == INF ? \"unreachable\" : res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int start, goal;\t\t\t\t// スタート都市、ゴール都市\n\tstatic int n_city, m_road;\t\t// 都市の数、道の数\n\tstatic int[][] road_dist;\t\t\t// 道の距離情報\n\tstatic int[][] speed_limit;\t\t// 道の制限速度情報\n\tstatic double[][][] city;\t\t\t// ダイクストラ　最短時間保管表\n\tstatic boolean[][][] enter;\t\t// ダイクストラ　最短時間確定\n\tstatic final int speed_law = 30;\n\t\n\t// ダイクストラアルゴリズム\n\tstatic double Dijkstra(){\n\t\t// 初期設定。最短時間をMAX値で初期化。\n\t\tcity = new double[n_city+1][n_city+1][speed_law+1];\n\t\tenter = new boolean[n_city+1][n_city+1][speed_law+1];\n\t\tfor(int i=0;i<=n_city;i++){\n\t\t\tfor(int j=0;j<=n_city;j++){\n\t\t\t\tfor(int k=0;k<=speed_law;k++){\n\t\t\t\t\tcity[i][j][k] = Double.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcity[start][start][1] = 0;\t\t// スタート→スタートで速度1の場合、所要時間0\n\t\t// ループアルゴ(状態遷移を次々と決める)\n\t\t// \tcf. 状態遷移とは「ある都市→ある都市の移動(速度も含む)」\n\t\twhile(true){\n\t\t\t// 最短時間表から最も最短時間な状態遷移を探す\n\t\t\tdouble fast = Double.MAX_VALUE;\n\t\t\tint x, y, z;\t\t// fastのindex\n\t\t\tx = y = z = -1;\n\t\t\tfor(int i=1;i<=n_city;i++){\n\t\t\t\tfor(int j=1;j<=n_city;j++){\n\t\t\t\t\tfor(int k=1;k<=speed_law;k++){\n\t\t\t\t\t\tif(!enter[i][j][k]&&city[i][j][k]<fast){\t\t// 確定されてない & 最短時間\n\t\t\t\t\t\t\tfast = city[i][j][k];\n\t\t\t\t\t\t\tx = i;\ty = j;\tz = k;\t\t// 設定されるxはstartと同値が既知\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 表において探した最も最短時間な状態遷移が、\n\t\t\t//\t\tスタート→ゴールで速度が1の場合は解が得られる\n\t\t\tif(x==start&&y==goal&&z==1){\n\t\t\t\treturn city[x][y][1];\n\t\t\t}\n\t\t\t// 最短時間の更新が一度もされない→状態遷移がすべて確定してしまった\n\t\t\t// \t(ゴールに辿りつける道がない or ゴール時に速度が1とならない)\n\t\t\telse if(x==-1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tenter[x][y][z] = true;\t\t// 探した最短時間状態遷移を確定する\n//\t\t\tSystem.out.println(\"enter : x=\"+x+\", y=\"+y+\", z=\"+z+\" time=\"+city[x][y][z]);\n\t\t\t// 確定した状態遷移から移動できる都市を更新しにいく (yからnexの移動)\n\t\t\tfor(int nex=1;nex<=n_city;nex++){\t\t// nex = 遷移先(次)\n\t\t\t\t// 速度3パターン(-1,0,1)、zは元の速度、spdは遷移時の速度\n\t\t\t\tfor(int spd=z-1;spd<=z+1;spd++){\n\t\t\t\t\t// スピード負値、制限速度オーバー、道路がない　場合は除外\n\t\t\t\t\tif(spd<=0||spd>speed_limit[y][nex]||road_dist[y][nex]==Double.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// スタート地点から出る道とゴール地点に到達する道は必ず速度1 (この問題においての超重要点)\n\t\t\t\t\t// \tさらには今来た道(x->y y->nex(x) ... x=nex=start)\n\t\t\t\t\tif(((y==start||nex==goal)&&spd!=1)||start==nex){\n//\t\t\t\t\t\tSystem.out.println(\"s=\"+start+\" g=\"+goal+\" y=\"+y+\" z=\"+z+\" nex=\"+nex+\" spd=\"+spd);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println(\"connect : y=\"+y+\", nex=\"+nex+\", spd=\"+spd);\n\t\t\t\t\t// 時間 = 距離 / 速度\n\t\t\t\t\tcity[x][nex][spd] = Math.min(city[x][y][z] + road_dist[y][nex]*1.0/spd , city[x][nex][spd]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn_city = stdIn.nextInt();\n\t\t\tm_road = stdIn.nextInt();\n\t\t\tif((n_city|m_road)==0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstart = stdIn.nextInt();\n\t\t\tgoal = stdIn.nextInt();\n\t\t\troad_dist = new int[n_city+1][n_city+1];\n\t\t\tspeed_limit = new int[n_city+1][n_city+1];\n\t\t\tfor(int i=0;i<m_road;i++){\n\t\t\t\tint x = stdIn.nextInt();\n\t\t\t\tint y = stdIn.nextInt();\n\t\t\t\tint d = stdIn.nextInt();\n\t\t\t\tint c = stdIn.nextInt();\n\t\t\t\troad_dist[x][y] = road_dist[y][x] = d;\n\t\t\t\tspeed_limit[x][y] = speed_limit[y][x] = c;\n\t\t\t}\n\t\t\tdouble ans = Dijkstra();\n\t\t\tif(ans!=-1){\n\t\t\t\tSystem.out.printf(\"%.5f\\n\",ans);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"unreachable\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass State implements Comparable<State> {\n\t\tint s;\n\t\tint x;\n\t\tint p;\n\t\tdouble t;\n\t\tboolean end = false;\n\n\t\tState(int s, int x, int p, double t) {\n\t\t\tthis.s = s;\n\t\t\tthis.x = x;\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State arg0) {\n\t\t\treturn this.t - arg0.t < 0 ? -1 : 1;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn++;\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\n\t\t\tint map[][] = new int[n][n];\n\t\t\tint lim[][] = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(map[i], Integer.MAX_VALUE >> 2);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tmap[x][y] = d;\n\t\t\t\tmap[y][x] = d;\n\t\t\t\tlim[x][y] = c;\n\t\t\t\tlim[y][x] = c;\n\t\t\t}\n\n\t\t\tdouble ans[][][] = new double[n][n][31];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tArrays.fill(ans[i][j], Integer.MAX_VALUE >> 3);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\t\tq.add(new State(1, s, 0, 0));\n\t\t\tans[s][0][1] = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"unreachable\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tState now = q.poll();\n\t\t\t\tif (now.end) {\n\t\t\t\t\tSystem.out.println(now.t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ans[now.x][now.p][now.s] < now.t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int i = 1; i < n; i++) {\n\n\t\t\t\t\tif (i == now.p) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (now.x == i) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (map[now.x][i] > Integer.MAX_VALUE >> 3) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (lim[now.x][i] < now.s) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int ns = now.s - 1; ns <= now.s + 1; ns++) {\n\t\t\t\t\t\tif (ns <= 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ns > 30) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (now.s == 1 && i == g) {\n\t\t\t\t\t\t\tState st = new State(ns, i, now.x, now.t\n\t\t\t\t\t\t\t\t\t+ (double) map[now.x][i] / (double) now.s);\n\t\t\t\t\t\t\tst.end = true;\n\t\t\t\t\t\t\tq.add(st);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (now.t + (double) map[now.x][i] / (double) now.s < ans[i][now.x][ns]) {\n\t\t\t\t\t\t\tans[i][now.x][ns] = now.t + (double) map[now.x][i]\n\t\t\t\t\t\t\t\t\t/ (double) now.s;\n\t\t\t\t\t\t\tState st = new State(ns, i, now.x, now.t\n\t\t\t\t\t\t\t\t\t+ (double) map[now.x][i] / (double) now.s);\n\t\t\t\t\t\t\tif (now.s == 1 && i == g) {\n\t\t\t\t\t\t\t\tst.end = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tq.add(st);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      int m = ni();\n      if (n == 0) {\n        break;\n      }\n      int s = ni();\n      int g = ni();\n      int[] x = new int[m + 1];\n      int[] y = new int[m + 1];\n      int[] d = new int[m + 1];\n      int[] c = new int[m + 1];\n      for (int i = 1; i <= m; ++i) {\n        x[i] = ni();\n        y[i] = ni();\n        d[i] = ni();\n        c[i] = ni();\n      }\n      ArrayList<LinkedList<Data>> list = new ArrayList<>();\n      for (int i = 0; i <= n; ++i) {\n        list.add(new LinkedList<>());\n      }\n      for (int i = 1; i <= m; ++i) {\n        Data left = new Data();\n        left.dist = y[i];\n        left.kyori = d[i];\n        left.seigen = c[i];\n        list.get(x[i]).add(left);\n        Data right = new Data();\n        right.dist = x[i];\n        right.kyori = d[i];\n        right.seigen = c[i];\n        list.get(y[i]).add(right);\n      }\n      Check atom = new Check();\n      atom.now = s;\n      atom.v = -1;\n      atom.prev = -1;\n      TreeSet<Check> done = new TreeSet<>();\n      done.add(atom);\n      Node btom = new Node();\n      btom.check = atom;\n      btom.time = 0;\n      PriorityQueue<Node> queue = new PriorityQueue<>(\n          (a, b) -> {\n            if (a.time != b.time) {\n              return Double.compare(a.time, b.time);\n            }\n            return Integer.compare(a.check.v, b.check.v);\n          }\n      );\n      queue.add(btom);\n      boolean flag = false;\n      double ans = -1;\n      while (queue.size() > 0) {\n        Node node = queue.poll();\n        if (node.check.now == g && node.check.v == 1) {\n          flag = true;\n          ans = node.time;\n          break;\n        }\n        for (Data ite : list.get(node.check.now)) {\n          if (ite.dist == node.check.prev) {\n            continue;\n          }\n          for (int add = -1; add <= 1; ++add) {\n            int nv;\n            if (node.check.v == -1) {\n              nv = 1;\n            } else {\n              nv = node.check.v + add;\n            }\n            if (nv <= 0 || ite.seigen < nv) {\n              continue;\n            }\n            double nt = node.time + (double) ite.kyori / nv;\n\n            Check check = new Check();\n            check.now = ite.dist;\n            check.v = nv;\n            check.prev = node.check.now;\n            if (done.contains(check)) {\n              continue;\n            }\n            done.add(check);\n\n            Node next = new Node();\n            next.check = check;\n            next.time = nt;\n            queue.add(next);\n          }\n        }\n      }\n      if (flag) {\n        System.out.println(ans);\n      } else {\n        System.out.println(\"unreachable\");\n      }\n    }\n  }\n\n  class Check implements Comparable<Check> {\n    int now;\n    int v;\n    int prev;\n\n    @Override\n    public int compareTo(Check ch) {\n      if (now != ch.now) {\n        return now - ch.now;\n      }\n      if (v != ch.v) {\n        return v - ch.v;\n      }\n      return prev - ch.prev;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o.getClass() != this.getClass()) {\n        return false;\n      }\n      Check ch = (Check) o;\n      return this.compareTo(ch) == 0;\n    }\n  }\n\n  class Node {\n    Check check;\n    double time;\n  }\n\n  class Data {\n    int dist;\n    int kyori;\n    int seigen;\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\t\n\tint n, m;\n\t\n\tint[][] edge;\n\tdouble[][] minCost;\n\tint[][] maxSpeed;\t\n\t\n\tdouble INF = 1000000000;\n\t\n\tclass State implements Comparable<State> {\n\t\tint n, speed;\n\n\t\tState(int n, int speed) {\n\t\t\tthis.n = n;\n\t\t\tthis.speed = speed;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(State arg0) {\n\t\t\tdouble c1 = minCost[n][speed], c2 = minCost[arg0.n][arg0.speed];\n\t\t\tif (c1 > c2) return 1;\n\t\t\telse if (c1 < c2) return -1;\n\t\t\telse return 0;\n\t\t}\n\t}\n\t\n\tboolean isOk(int x) {\n\t\treturn x >= 0 && x <= 30;\n\t}\n\t\n\tvoid dijkstra(int start) {\n\t\tminCost = new double[n][31];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tArrays.fill(minCost[i], INF);\n\t\t\n\t\tminCost[start][0] = 0;\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.add(new State(0, 0));\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int c = 0; c <= 30; c++) {\n\t\t\t\t\tfor (int v = -1; v <= 1; v++) {\n\t\t\t\t\t\tif (isOk(c+v) && c+v <= maxSpeed[i][s.n] && minCost[i][c+v] > minCost[s.n][c] + (double)edge[i][s.n] / (c+v)) {\n\t\t\t\t\t\t\tminCost[i][c+v] = minCost[s.n][c] + (double)edge[i][s.n] / (c+v);\n\t\t\t\t\t\t\tpq.add(new State(i, c+v));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = in.nextInt(); m = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint s = in.nextInt() - 1, g = in.nextInt() - 1;\n\n\t\t\tmaxSpeed = new int[n][n];\n\t\t\tedge = new int[n][n];\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = in.nextInt() - 1, y = in.nextInt() - 1, d = in.nextInt(), c = in.nextInt();\n\t\t\t\tedge[x][y] = edge[y][x] = d;\n\t\t\t\tmaxSpeed[x][y] = maxSpeed[y][x] = c;\n\t\t\t}\n\t\t\t\n\t\t\tdijkstra(s);\n\t\t\t\n\t\t\tdouble res = minCost[g][1];\n\t\t\t\n\t\t\tSystem.out.println(res == INF ? \"unreachable\" : res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\t\n\tint n, m;\n\t\n\tint[][] edge;\n\tdouble[][] minCost;\n\tint[][] maxSpeed;\t\n\t\n\tdouble INF = 100000000;\n\t\n\tclass State implements Comparable<State> {\n\t\tint n, speed, prev;\n\n\t\tState(int n, int speed, int prev) {\n\t\t\tthis.n = n;\n\t\t\tthis.speed = speed;\n\t\t\tthis.prev = prev;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(State arg0) {\n\t\t\tdouble c1 = minCost[n][speed], c2 = minCost[arg0.n][arg0.speed];\n\t\t\tif (c1 > c2) return 1;\n\t\t\telse if (c1 < c2) return -1;\n\t\t\telse return 0;\n\t\t}\n\t}\n\t\n\tvoid dijkstra(int start) {\n\t\tminCost = new double[n][31];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tArrays.fill(minCost[i], INF);\n\t\t\n\t\tminCost[start][0] = 0;\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.add(new State(start, 0, start));\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (edge[s.n][i] == INF) continue;\n\t\t\t\tif (s.prev == i) continue;\n\t\t\t\tint c = s.speed;\n\t\t\t\tfor (int v = -1; v <= 1; v++) {\n\t\t\t\t\tif (c+v > 0 && c+v <= maxSpeed[i][s.n] && minCost[i][c+v] > minCost[s.n][c] + (double)edge[i][s.n] / (c+v)) {\n\t\t\t\t\t\tminCost[i][c+v] = minCost[s.n][c] + (double)edge[i][s.n] / (c+v);\n\t\t\t\t\t\tpq.add(new State(i, c+v, s.n));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = in.nextInt(); m = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint s = in.nextInt() - 1, g = in.nextInt() - 1;\n\n\t\t\tmaxSpeed = new int[n][n];\n\t\t\tedge = new int[n][n];\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = in.nextInt() - 1, y = in.nextInt() - 1, d = in.nextInt(), c = in.nextInt();\n\t\t\t\tedge[x][y] = edge[y][x] = d;\n\t\t\t\tmaxSpeed[x][y] = maxSpeed[y][x] = c;\n\t\t\t}\n\t\t\t\n\t\t\tdijkstra(s);\n\t\t\t\n\t\t\tdouble res = INF;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tres = Math.min(minCost[g][1], res);\n\t\t\t\n\t\t\t/*\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t\t\tSystem.out.print(minCost[i][j] + \" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tSystem.out.println(res == INF ? \"unreachable\" : res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint MAX = 30;\n\tdouble EPS = 1e-5;\n\tint n, m;\n\tint s, g;\n\tint map[][];\n\tint lim[][];\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\ts = sc.nextInt()-1;\n\t\t\tg = sc.nextInt()-1;\n\t\t\tmap = new int[n][n];\n\t\t\tlim = new int[n][n];\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint a = sc.nextInt()-1;\n\t\t\t\tint b = sc.nextInt()-1;\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tmap[a][b] = map[b][a] = d;\n\t\t\t\tlim[a][b] = lim[b][a] = l;\n\t\t\t}\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\tint dv[] = {-1,0,1};\n\tString dijkstra() {\n\t\tdouble t[][][] = new double[n][n+1][MAX+1];\n\t\tfor(double[][] a:t ) for(double[] b:  a) fill(b, INF);\n\t\tt[s][n][0] = 0;\n\t\tPriorityQueue<Pair> que = new PriorityQueue<Pair>(1, new MyComp());\n\t\tPair now = new Pair(s, -1, 1, 0, 0);\n\t\tque.add(now);\n\t\tfor(;!que.isEmpty();) {\n\t\t\tnow = que.remove();\n//\t\t\tdebug(que);\n//\t\t\tdebug(now.p, now.past_p, now.v, now.t);\n\t\t\tif( now.p == g && now.past_v == 1 ) return String.valueOf(now.t);\n\t\t\tif( 0 == now.v ) continue;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif( map[now.p][i] == 0 || now.p == i || now.past_p == i) continue;\n\t\t\t\tif( now.v > lim[now.p][i] ) continue;\n\t\t\t\tdouble time = now.t + (double)map[now.p][i] / now.v;\n//\t\t\t\tdebug(now.p, i, map[now.p][i]*1.0/now.v);\n\t\t\t\tif(time < t[i][now.p][now.v]) {\n\t\t\t\t\tfor(int j=0;j<3;j++) {\n\t\t\t\t\t\tif( now.v + dv[j] >= 0 ) {\t\t\t\t\t\n\t\t\t\t\t\t\tque.add(new Pair(i, now.p, now.v+dv[j], now.v, time));\n//\t\t\t\t\t\t\tdebug(i, now.p, now.v+dv[j], time);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt[i][now.p][now.v] = time;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"unreachable\";\n\t}\n\t\n\tclass Pair {\n\t\tint p, v, past_p, past_v;\n\t\tdouble t;\n\t\tPair(int p, int past_p, int v, int past_v, double t) {\n\t\t\tthis.p = p;\n\t\t\tthis.v = v;\n\t\t\tthis.t = t;\n\t\t\tthis.past_p = past_p;\n\t\t\tthis.past_v = past_v;\n\t\t}\n\t}\n\t\n\tclass MyComp implements Comparator<Pair> {\n\n\t\t@Override\n\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\tif(o1.t > o2.t ) return 1;\n\t\t\telse if(o1.t < o2.t) return -1;\n\t\t\treturn o1.v - o2.v;\n\t\t}\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = true;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tint m = ir.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\treturn;\n\t\t\tint a = ir.nextInt() - 1;\n\t\t\tint b = ir.nextInt() - 1;\n\t\t\tGraph[] g1 = new Graph[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tg1[i] = new Graph();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = ir.nextInt() - 1;\n\t\t\t\tint y = ir.nextInt() - 1;\n\t\t\t\tint d = ir.nextInt();\n\t\t\t\tint c = ir.nextInt();\n\t\t\t\tg1[x].add(new double[] { y, d, c });\n\t\t\t\tg1[y].add(new double[] { x, d, c });\n\t\t\t}\n\t\t\tGraph[] g2 = new Graph[31 * n];\n\t\t\tfor (int i = 0; i < 31 * n; i++)\n\t\t\t\tg2[i] = new Graph();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < g1[i].size(); j++) {\n\t\t\t\t\tint to = (int) g1[i].get(j)[0];\n\t\t\t\t\tfor (int k = 0; k <= 30; k++) {\n\t\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\t\tif (k + l >= 1 && k + l <= (int) g1[i].get(j)[2]) {\n\t\t\t\t\t\t\t\tg2[i * 31 + k]\n\t\t\t\t\t\t\t\t\t\t.add(new double[] { to * 31 + k + l, g1[i].get(j)[1] / (double) (k + l) });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble[] d = dijkstra(a * 31, g2)[b * 31 + 1];\n\t\t\tdouble ret = 1e8;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tret = Math.min(ret, d[i]);\n\t\t\tout.println(ret == 1e8 ? \"unreachable\" : ret);\n\t\t}\n\t}\n\n\tprivate static double[][] dijkstra(int s, Graph[] g) {\n\t\tdouble[][] d = new double[g.length][g.length / 31 + 1];\n\t\tPriorityQueue<double[]> pq = new PriorityQueue<double[]>(new Comparator<double[]>() {\n\t\t\tpublic int compare(double[] a, double[] b) {\n\t\t\t\treturn Double.compare(a[1], b[1]);\n\t\t\t}\n\t\t});\n\t\tfor (int i = 0; i < g.length; i++)\n\t\t\tArrays.fill(d[i], 1e8);\n\t\td[s][0] = 0;\n\t\tpq.offer(new double[] { s, 0, -1 });\n\t\twhile (!pq.isEmpty()) {\n\t\t\tdouble[] p = pq.poll();\n\t\t\tint from = (int) p[0];\n\t\t\tfor (int i = 0; i < g[from].size(); i++) {\n\t\t\t\tdouble[] e = g[from].get(i);\n\t\t\t\tint to = (int) e[0];\n\t\t\t\tif (to / 31 != (int) p[2] && d[to][from / 31 + 1] > d[from][(int) p[2] + 1] + e[1]) {\n\t\t\t\t\td[to][from / 31 + 1] = d[from][(int) p[2] + 1] + e[1];\n\t\t\t\t\tpq.offer(new double[] { to, d[to][from / 31 + 1], from / 31 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tstatic class Graph extends ArrayList<double[]> {\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Descrete Speed\npublic class Main{\n\n\tpublic static int n;\n\tpublic static int m;\n\tpublic static int start;\n\tpublic static int goal;\n\n\tpublic static double[][][] dist;\n\tpublic static int[][] r;\n\tpublic static int[][] limit;\n\n\tpublic static double dijkstra(){\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tfor(int k=0;k<31;k++)\n\t\t\t\t\tdist[i][j][k] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tdist[start][0][1] = 0;\n\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(n, new Comparator<int[]>(){\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn dist[a[0]][a[1]][a[2]]-dist[b[0]][b[1]][b[2]]<0?-1:dist[a[0]][a[1]][a[2]]-dist[b[0]][b[1]][b[2]]>0?1:0;\n\t\t\t}\n\t\t});\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(r[start][i]!=0){\n\t\t\t\tdouble nc = r[start][i]/1.0;\n\t\t\t\tdist[i][start][1] = nc;\n\t\t\t\tq.add(new int[]{i,start,1});\n\t\t\t}\n\t\t}\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] uu = q.poll();\n\t\t\tint u = uu[0];\n\t\t\tint pre = uu[1];\n\t\t\tint v = uu[2];\n\t\t\tif(u==goal&&v==1)return dist[u][pre][v];\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(i!=pre && r[u][i]!=0){\n\t\t\t\t\tfor(int x=v-1;x<=v+1;x++){\n\t\t\t\t\t\tif(x<=0)continue;\n\t\t\t\t\t\tif(x>limit[u][i])continue;\n\t\t\t\t\t\tdouble nc = dist[u][pre][v] + r[u][i]*1.0/x;\n\t\t\t\t\t\tif(nc < dist[i][u][x]){\n\t\t\t\t\t\t\tdist[i][u][x] = nc;\n\t\t\t\t\t\t\tq.add(new int[]{i, u, x});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif(n==0&&m==0)break;\n\t\t\tdist = new double[n+1][n+1][31];\n\t\t\tr = new int[n+1][n+1];\n\t\t\tlimit = new int[n+1][n+1];\n\t\t\tstart = sc.nextInt();\n\t\t\tgoal = sc.nextInt();\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint u = sc.nextInt();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tr[u][v] = r[v][u] = d;\n\t\t\t\tlimit[u][v] = limit[v][u] = l;\n\t\t\t}\n\t\t\tdouble ans = dijkstra();\n\t\t\tif(ans==-1)System.out.println(\"unreachable\");\n\t\t\telse System.out.printf(\"%.5f\\n\", ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint MAX = 30;\n\tdouble EPS = 1e-5;\n\tint n, m;\n\tint s, g;\n\tint map[][];\n\tint lim[][];\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\ts = sc.nextInt()-1;\n\t\t\tg = sc.nextInt()-1;\n\t\t\tmap = new int[n][n];\n\t\t\tlim = new int[n][n];\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint a = sc.nextInt()-1;\n\t\t\t\tint b = sc.nextInt()-1;\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tmap[a][b] = map[b][a] = d;\n\t\t\t\tlim[a][b] = lim[b][a] = l;\n\t\t\t}\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\tint dv[] = {-1,0,1};\n\tString dijkstra() {\n\t\tdouble t[][] = new double[n][MAX+1];\n\t\tfor(double[] a:t ) fill(a, INF);\n\t\tt[s][0] = 0;\n\t\tPriorityQueue<Pair> que = new PriorityQueue<Pair>(1, new MyComp());\n\t\tPair now = new Pair(s, -1, 1, 0);\n\t\tque.add(now);\n\t\tfor(;!que.isEmpty();) {\n\t\t\tnow = que.remove();\n//\t\t\tdebug(que);\n//\t\t\tdebug(now.p, now.past_p, now.v, now.t);\n\t\t\tif( now.p == g && now.v == 0 ) return String.valueOf(now.t);\n\t\t\tif( 0 == now.v ) continue;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif( map[now.p][i] == 0 || now.p == i || now.past_p == i) continue;\n\t\t\t\tif( now.v > lim[now.p][i] ) continue;\n\t\t\t\tdouble time = now.t + map[now.p][i]*1.0 / now.v;\n//\t\t\t\tdebug(now.p, i, map[now.p][i]*1.0/now.v);\n\t\t\t\tif(time < t[i][now.v]) {\n\t\t\t\t\tfor(int j=0;j<3;j++) {\n\t\t\t\t\t\tif( now.v + dv[j] >= 0 ) {\t\t\t\t\t\n\t\t\t\t\t\t\tque.add(new Pair(i, now.p, now.v+dv[j], time));\n//\t\t\t\t\t\t\tdebug(i, now.p, now.v+dv[j], time);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt[i][now.v] = time;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"unreachable\";\n\t}\n\t\n\tclass Pair {\n\t\tint p, v, past_p;\n\t\tdouble t;\n\t\tPair(int p, int past_p, int v, double t) {\n\t\t\tthis.p = p;\n\t\t\tthis.v = v;\n\t\t\tthis.t = t;\n\t\t\tthis.past_p = past_p;\n\t\t}\n\t}\n\t\n\tclass MyComp implements Comparator<Pair> {\n\n\t\t@Override\n\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつスツδソツッツドツ・ツスツタツブ\n\t\t\tif(o1.t > o2.t ) return 1;\n\t\t\telse if(o1.t < o2.t) return -1;\n\t\t\treturn o1.v - o2.v;\n\t\t}\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int start, goal;\t\t\t\t// スタート都市、ゴール都市\n\tstatic int n_city, m_road;\t\t// 都市の数、道の数\n\tstatic int[][] road_dist;\t\t\t// 道の距離情報\n\tstatic int[][] speed_limit;\t\t// 道の制限速度情報\n\tstatic double[][][] city;\t\t\t// ダイクストラ　最短時間保管表\n\tstatic boolean[][][] enter;\t\t// ダイクストラ　最短時間確定\n\tstatic final int speed_law = 30;\n\t\n\t// ダイクストラアルゴリズム\n\tstatic double Dijkstra(){\n\t\t// 初期設定。最短時間をMAX値で初期化。\n\t\tcity = new double[n_city+1][n_city+1][speed_law+1];\n\t\tenter = new boolean[n_city+1][n_city+1][speed_law+1];\n\t\tfor(int i=0;i<=n_city;i++){\n\t\t\tfor(int j=0;j<=n_city;j++){\n\t\t\t\tfor(int k=0;k<=speed_law;k++){\n\t\t\t\t\tcity[i][j][k] = Double.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcity[start][start][1] = 0;\t\t// スタート→スタートで速度1の場合、所要時間0\n\t\t// ループアルゴ(状態遷移を次々と決める)\n\t\t// \tcf. 状態遷移とは「ある都市→ある都市の移動(速度も含む)」\n\t\twhile(true){\n\t\t\t// 最短時間表から最も最短時間な状態遷移を探す\n\t\t\tdouble fast = Double.MAX_VALUE;\n\t\t\tint x, y, z;\t\t// fastのindex\n\t\t\tx = y = z = -1;\n\t\t\tfor(int i=1;i<=n_city;i++){\n\t\t\t\tfor(int j=1;j<=n_city;j++){\n\t\t\t\t\tfor(int k=1;k<=speed_law;k++){\n\t\t\t\t\t\tif(!enter[i][j][k]&&city[i][j][k]<fast){\t\t// 確定されてない & 最短時間\n\t\t\t\t\t\t\tfast = city[i][j][k];\n\t\t\t\t\t\t\tx = i;\ty = j;\tz = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 表において探した最も最短時間な状態遷移が、\n\t\t\t//\t\tスタート→ゴールで速度が1の場合は解が得られる\n\t\t\tif(x==start&&y==goal&&z==1){\n\t\t\t\treturn city[x][y][1];\n\t\t\t}\n\t\t\t// 最短時間の更新が一度もされない→状態遷移がすべて確定してしまった\n\t\t\t// \t(ゴールに辿りつける道がない or ゴール時に速度が1とならない)\n\t\t\telse if(x==-1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tenter[x][y][z] = true;\t\t// 探した最短時間状態遷移を確定する\n//\t\t\tSystem.out.println(\"enter : x=\"+x+\", y=\"+y+\", z=\"+z+\" time=\"+city[x][y][z]);\n\t\t\t// 確定した状態遷移から移動できる都市を更新しにいく (yからnexの移動)\n\t\t\tfor(int nex=1;nex<=n_city;nex++){\t\t// nex = 遷移先(次)\n\t\t\t\t// 速度3パターン(-1,0,1)、zは元の速度、spdは遷移時の速度\n\t\t\t\tfor(int spd=z-1;spd<=z+1;spd++){\n\t\t\t\t\t// スピード負値、制限速度オーバー、道路がない　場合は除外\n\t\t\t\t\tif(spd<=0||spd>speed_limit[y][nex]||road_dist[y][nex]==Double.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// スタート地点から出る道は必ず速度1 (この問題においての超重要点)\n\t\t\t\t\tif(x==start&&(y==start||nex==goal)&&spd!=1){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println(\"connect : y=\"+y+\", nex=\"+nex+\", spd=\"+spd);\n\t\t\t\t\t// 時間 = 距離 / 速度\n\t\t\t\t\tcity[x][nex][spd] = Math.min(city[x][y][z] + road_dist[y][nex]*1.0/spd , city[x][nex][spd]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn_city = stdIn.nextInt();\n\t\t\tm_road = stdIn.nextInt();\n\t\t\tif((n_city|m_road)==0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstart = stdIn.nextInt();\n\t\t\tgoal = stdIn.nextInt();\n\t\t\troad_dist = new int[n_city+1][n_city+1];\n\t\t\tspeed_limit = new int[n_city+1][n_city+1];\n\t\t\tfor(int i=0;i<m_road;i++){\n\t\t\t\tint x = stdIn.nextInt();\n\t\t\t\tint y = stdIn.nextInt();\n\t\t\t\tint d = stdIn.nextInt();\n\t\t\t\tint c = stdIn.nextInt();\n\t\t\t\troad_dist[x][y] = road_dist[y][x] = d;\n\t\t\t\tspeed_limit[x][y] = speed_limit[y][x] = c;\n\t\t\t}\n\t\t\tdouble ans = Dijkstra();\n\t\t\tif(ans!=-1){\n\t\t\t\tSystem.out.printf(\"%.5f\\n\",ans);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"unreachable\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n, m;\n\tint s, g;\n\tLinkedList<E>[] es;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tm=sc.nextInt();\n\t\t\tif((n|m)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tes=new LinkedList[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tes[i]=new LinkedList<E>();\n\t\t\t}\n\t\t\ts=sc.nextInt()-1;\n\t\t\tg=sc.nextInt()-1;\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint x=sc.nextInt()-1;\n\t\t\t\tint y=sc.nextInt()-1;\n\t\t\t\tint d=sc.nextInt();\n\t\t\t\tint c=sc.nextInt();\n\t\t\t\tes[x].add(new E(y, d, c));\n\t\t\t\tes[y].add(new E(x, d, c));\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tdouble[][][] d=new double[n][n][40];\n\t\tPriorityQueue<P> que=new PriorityQueue<P>();\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfill(d[j][i], INF);\n\t\t\t}\n\t\t}\n\t\t// Uツタツーツδ督づ債凝鳴止\n\t\t// [ツ前][ツ債。][ツ陳つ「ツつスツ瞬ツ甘板づ個堕ャツ度]\n\t\td[s][s][1]=0;\n\t\tque.offer(new P(s, s, 0, 0));\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.poll();\n\t\t\t// debug(p.q, p.p, p.v,p.d);\n\t\t\tif(d[p.q][p.p][p.v]+EPS<p.d){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(E e : es[p.p]){\n\t\t\t\tif(p.q==e.to){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=-1; i<=1; i++){\n\t\t\t\t\tif(p.v+i<=0||p.v+i>e.c){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(d[p.p][e.to][p.v+i]>p.d+(double)e.d/(p.v+i)+EPS){\n\t\t\t\t\t\td[p.p][e.to][p.v+i]=p.d+(double)e.d/(p.v+i);\n\t\t\t\t\t\tque.offer(new P(p.p, e.to, p.v+i, d[p.p][e.to][p.v+i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble min=INF;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmin=min(min, d[i][g][1]);\n\t\t}\n\t\t// debug(min);\n\t\tprintln(\"\"+(min<INF/2?min:\"unreachable\"));\n\t}\n\n\tclass E{\n\t\tint to, d, c;\n\n\t\tE(int to, int d, int c){\n\t\t\tthis.to=to;\n\t\t\tthis.d=d;\n\t\t\tthis.c=c;\n\t\t}\n\t}\n\n\tclass P implements Comparable<P>{\n\t\tint q, p, v;\n\t\tdouble d;\n\n\t\tP(int q, int p, int v, double d){\n\t\t\tthis.q=q;\n\t\t\tthis.p=p;\n\t\t\tthis.v=v;\n\t\t\tthis.d=d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P p){\n\t\t\tif(d+EPS<p.d){\n\t\t\t\treturn -1;\n\t\t\t}else if(d>p.d+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-5;\n\t\n\tint n, m;\n\tLinkedList<E>[] edges;\n\tdouble[][][] map;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\t\n\t\t\tshort s = (short)(sc.nextInt()-1);\n\t\t\tshort g = (short)(sc.nextInt()-1);\n\t\t\t\n\t\t\tedges = new LinkedList[n];\n\t\t\tfor(int i=0;i<n;i++) edges[i] = new LinkedList<E>();\n\t\t\t\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tshort a = (short)(sc.nextShort()-1);\n\t\t\t\tshort b = (short)(sc.nextShort()-1);\n\t\t\t\tshort d = sc.nextShort();\n\t\t\t\tshort c = sc.nextShort();\n\t\t\t\t\n\t\t\t\tedges[a].add( new E(b, c, d));\n\t\t\t\tedges[b].add( new E(a, c, d));\n\t\t\t}\n\t\t\t\n//\t\t\tfor(LinkedList<E> es: edges) for(E e: es) debug(e.to, e.c, e.d);\n\t\t\t\n\t\t\tdouble d = dijkstra(s, g);\n\t\t\t\n\t\t\tSystem.out.println((d<-EPS? \"unreachable\": d));\n\t\t}\n\t\t\n\t}\n\t\n\tdouble dijkstra(short s, short g) {\n\t\tPriorityQueue<V> que = new PriorityQueue<V>();\n\t\t\n\t\tque.add(new V(s, (short)0, s, 0.0));\n\t\t\n\t\tmap = new double[n][31][n];\n\t\tfor(double[][] a: map) for(double[] b: a) fill(b, INF);\n\t\t\n\t\tmap[s][0][s] = 0.0;\n\t\t\n\t\twhile(!que.isEmpty()) {\n\t\t\tV now = que.poll();\n\t\t\t\n\t\t\tdebug(now.u, now.v, now.p, now.t, map[now.u][now.p]);\n\t\t\t\n\t\t\tif( now.u == g && now.v == 1 ) return now.t;\n\t\t\tif( abs( map[now.u][now.v][now.p] -now.t ) > EPS ) continue;\n\n\t\t\tfor(E edge: edges[now.u]) if( edge.to != now.p ) {\n\t\t\t\tfor(int dv = 1;dv>=-1;dv--) if( 0 < now.v+dv && now.v + dv<=edge.c ) {\n\t\t\t\tdebug(\"a\");\n\t\t\t\t\tdouble t = now.t + 1.0 * edge.d / (now.v+dv);\n\t\t\t\t\tif( t - map[edge.to][now.v+dv][now.u] < EPS ) {\n\t\t\t\t\t\tmap[edge.to][now.v+dv][now.u] = t;\n\t\t\t\t\t\tque.add(new V(edge.to, (short)(now.v+dv), now.u, t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tclass E {\n\t\tshort to, c, d;\n\t\tE ( short to, short c, short d) {\n\t\t\tthis.to = to;\n\t\t\tthis.c = c;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\t\n\tclass V implements Comparable<V>{\n\t\tshort u, v, p;\n\t\tdouble t;\n\t\tV(short u, short v, short p, double t) {\n\t\t\tthis.u = u;\n\t\t\tthis.v = v;\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(V o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tif(t - o.t > EPS ) return 1;\n\t\t\telse if( o.t - t > EPS ) return -1;\n\t\t\treturn o.v - v;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n//\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tint [] xdis = {0,1,0,-1};\n\tint [] ydis = {1,0,-1,0};\n\tclass C implements Comparable<C>{\n\t\tint v,town,lasttown;\n\t\tdouble time;\n\t\tpublic C(int v, int town, int lasttown, double time) {\n\t\t\tthis.v = v;\tthis.town = town;this.lasttown = lasttown;this.time = time;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(C o) {\n\t\t\tif(time < o.time) return -1;\n\t\t\tif(time > o.time) return 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tprivate double getT(int dis, int v){\n\t\tdouble res = (double) dis / v;\n\t\treturn res;\n\t}\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\t\t\tint [][] pass = new int[n+1][n+1];\n\t\t\tint [][] maxs = new int[n+1][n+1];\n\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\tArrays.fill(pass[i], INF);\n\t\t\t\tArrays.fill(maxs[i], INF);\n\t\t\t}\n\t\t\tfor(int i=0; i < m; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tpass[x][y] = d; pass[y][x] = d;\n\t\t\t\tmaxs[x][y] = c; maxs[y][x] = c;\n\t\t\t}\n\t\t\tPriorityQueue<C> open = new PriorityQueue<C>();\n\t\t\topen.add(new C(1,s,-1,0.0));\n\t\t\tdouble [][][] close = new double[n+1][n+1][31];\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\t\tArrays.fill(close[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose[0][0][0] = 0.0;\n\t\t\t\n\t\t\tdouble ans = INF;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\t\n\t\t\t\tfor(int speed = -1; speed <= 1; speed++){\n\t\t\t\t\tint v = now.v + speed;\n\t\t\t\t\tif(now.lasttown == -1 && v != 1) continue;\n\t\t\t\t\tif(! (0 < v && v < 31)) continue;\n\t\t\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\t\t\tif(pass[now.town][i] == INF) continue;\n\t\t\t\t\t\tif(i == now.lasttown) continue;\n\t\t\t\t\t\tif(maxs[now.town][i] < v) continue;\n\t\t\t\t\t\tint dis = pass[now.town][i];\n\t\t\t\t\t\tdouble nexttime = now.time + getT(dis,v);\n\t\t\t\t\t\tif(close[now.town][i][v] < nexttime) continue;\n\t\t\t\t\t\tif(i == g && v == 1){\n\t\t\t\t\t\t\tans = Math.min(ans, nexttime);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\topen.add(new C(v, i, now.town, nexttime));\n\t\t\t\t\t\tclose[now.town][i][v] = nexttime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.print(\"ANS=\");\n\t\t\tif(ans == INF){\n\t\t\t\tSystem.out.println(\"unreachable\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.printf(\"%1.5f\\n\",ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tint m = ir.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\treturn;\n\t\t\tint a = ir.nextInt() - 1;\n\t\t\tint b = ir.nextInt() - 1;\n\t\t\tGraph[] g1 = new Graph[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tg1[i] = new Graph();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = ir.nextInt() - 1;\n\t\t\t\tint y = ir.nextInt() - 1;\n\t\t\t\tint d = ir.nextInt();\n\t\t\t\tint c = ir.nextInt();\n\t\t\t\tg1[x].add(new double[] { y, d, c });\n\t\t\t\tg1[y].add(new double[] { x, d, c });\n\t\t\t}\n\t\t\tGraph[] g2 = new Graph[31 * n];\n\t\t\tfor (int i = 0; i < 31 * n; i++)\n\t\t\t\tg2[i] = new Graph();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < g1[i].size(); j++) {\n\t\t\t\t\tint to = (int) g1[i].get(j)[0];\n\t\t\t\t\tfor (int k = 0; k <= 30; k++) {\n\t\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\t\tif (k + l >= 1 && k + l <= (int) g1[i].get(j)[2]) {\n\t\t\t\t\t\t\t\tg2[i * 31 + k].add(new double[] { to * 31 + k + l, g1[i].get(j)[1] / (k + l) });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble ret = dijkstra(a * 31, g2)[b * 31 + 1];\n\t\t\tout.println(ret == 1e9 ? \"unreachable\" : ret);\n\t\t}\n\t}\n\n\tprivate static double[] dijkstra(int s, Graph[] g) {\n\t\tdouble[] d = new double[g.length];\n\t\tPriorityQueue<double[]> pq = new PriorityQueue<double[]>(new Comparator<double[]>() {\n\t\t\tpublic int compare(double[] a, double[] b) {\n\t\t\t\treturn Double.compare(a[1], b[1]);\n\t\t\t}\n\t\t});\n\t\tArrays.fill(d, 1e9);\n\t\td[s] = 0;\n\t\tpq.offer(new double[] { s, 0, -1 });\n\t\twhile (!pq.isEmpty()) {\n\t\t\tdouble[] p = pq.poll();\n\t\t\tint from = (int) p[0];\n\t\t\tfor (int i = 0; i < g[from].size(); i++) {\n\t\t\t\tdouble[] e = g[from].get(i);\n\t\t\t\tint to = (int) e[0];\n\t\t\t\tif (to / 31 != (int) p[2] && d[to] > d[from] + e[1]) {\n\t\t\t\t\td[to] = d[from] + e[1];\n\t\t\t\t\tpq.offer(new double[] { to, d[to], from / 31 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tstatic class Graph extends ArrayList<double[]> {\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tstatic final int INF = 1<<29;\n\n\tint N, start, goal;\n\tint[][] graph;\n\tint[][] limit;\n\t\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = in.nextInt();\n\t\t\tint M = in.nextInt();\n\t\t\tif(N==0) return;\n\t\t\tstart = in.nextInt()-1; goal = in.nextInt()-1;\n\t\t\tgraph = new int[N][N];\n\t\t\tlimit = new int[N][N];\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint x,y,d,c;\n\t\t\t\tx = in.nextInt()-1; y = in.nextInt()-1; d = in.nextInt(); c = in.nextInt();\n\t\t\t\tgraph[x][y] = graph[y][x] = d;\n\t\t\t\tlimit[x][y] = limit[y][x] = c;\n\t\t\t}\n\t\t\tdouble ans = solve();\n\t\t\tif(ans < 0) System.out.println(\"unreachable\");\n\t\t\telse System.out.printf(\"%.7f\\n\", ans);\n\t\t}\n\t}\n\n\tclass State{\n\t\tdouble dist;\n\t\tint prev, cur, v;\n\t\tState(double _d, int _p, int _c, int _v){\n\t\t\tthis.dist  = _d;\n\t\t\tthis.prev = _p;\n\t\t\tthis.cur = _c;\n\t\t\tthis.v = _v;\n\t\t}\n\t}\n\n\tclass Cmp implements Comparator<State>{\n\t\tpublic int compare(State a, State b){\n\t\t\treturn a.dist>b.dist?1:a.dist<b.dist?-1:0;\n\t\t}\n\t}\n\n\tdouble solve(){\n\t\tdouble[][] sub = new double[N][N];\n\t\tfor(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\tsub[i][j] = graph[i][j]>0?(double)graph[i][j] / limit[i][j]:INF;\n\t\t\t}\n\t\t}\n\t\tsub[goal][goal] = 0.0;\n\t\tfor(int k=0; k<N; k++)for(int i=0; i<N; i++)for(int j=0; j<N; j++)\n\t\t\tsub[i][j] = min(sub[i][j], sub[i][k] + sub[k][j]);\n\t\tif(sub[start][goal] == INF) return -1;\n\t\t\n\t\tdouble[][][] dist = new double[N][N][31];\n\t\tfor(int i=0; i<N; i++)for(int j=0; j<N; j++)for(int k=0; k<31; k++)\n\t\t\tdist[i][j][k] = INF;\n\t\t\n\t\tPriorityQueue<State> Q = new PriorityQueue<State>(11,new Cmp())\t;\n\t\tQ.add(new State(sub[start][goal], start, start, 0));\n\t\t\n\t\twhile(!Q.isEmpty()){\n\t\t\tState tp = Q.poll();\n\t\t\tif(tp.cur == goal && tp.v == 1) return tp.dist;\n\t\t\tif(dist[tp.prev][tp.cur][tp.v] != INF) continue;\n\t\t\tdouble d = tp.dist - sub[tp.cur][goal];\n\t\t\tdist[tp.prev][tp.cur][tp.v] = d;\n\t\t\tfor(int i=0; i<N; i++)if(i!=tp.prev && graph[tp.cur][i] > 0){\n\t\t\t\tfor(int dv=-1;dv<=1;dv++){\n\t\t\t\t\tint nv = tp.v + dv;\n\t\t\t\t\tif(0<nv && nv<=limit[tp.cur][i] && dist[tp.cur][i][nv] == INF){\n\t\t\t\t\t\tdouble nd = d + (double)graph[tp.cur][i]/nv;\n\t\t\t\t\t\tQ.add(new State(nd + sub[i][goal], tp.cur, i, nv));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tfinal int[] vvx={0,1,0,-1,-1,1,1,-1}, vvy={-1,0,1,0,-1,-1,1,1};\n\tfinal int INF=1<<24;\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ1162();\n\t}\n\t\n\tvoid AOJ1162(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt();\n\t\t\tif((N|M)==0)\tbreak;\n\t\t\tint start=sc.nextInt()-1,goal=sc.nextInt()-1;\n\t\t\tint[][] d=new int[N][N],s=new int[N][N];\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\td[x][y]=INF;\ts[x][y]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint a1=sc.nextInt()-1,a2=sc.nextInt()-1,dd=sc.nextInt(),ss=sc.nextInt();\n\t\t\t\td[a1][a2]=dd;\td[a2][a1]=dd;\n\t\t\t\ts[a1][a2]=ss;\ts[a2][a1]=ss;\n\t\t\t}\n\t\t\tPriorityQueue<C1162> open=new PriorityQueue<C1162>();\n\t\t\topen.add(new C1162(start,-1,1,0.0));\n\t\t\tdouble[][][] close=new double[N][N][31];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tfor(int k=0; k<=30; k++)\tclose[i][j][k]=(double)INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble ans=(double)INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1162 now=open.poll();\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tif(now.now==i)\tcontinue;\n\t\t\t\t\tif(d[now.now][i]>=INF)\tcontinue;\n\t\t\t\t\tif(now.last==i)\tcontinue;\n\t\t\t\t\tfor(int j=-1; j<=1; j++){\n\t\t\t\t\t\t//out.println(\"N\"+N+\" i\"+i+\" j\"+j);\n\t\t\t\t\t\tint sp2=now.sp+j;\n\t\t\t\t\t\tif(now.last<0 && sp2!=1)\tcontinue;\n\t\t\t\t\t\tif(sp2<=0)\tcontinue;\n\t\t\t\t\t\tif(sp2>s[now.now][i])\tcontinue;\n\t\t\t\t\t\tdouble time=now.t+((double)d[now.now][i]/(double)sp2);\n\t\t\t\t\t\tif(close[now.now][i][sp2]<=time)\tcontinue;\n\t\t\t\t\t\tif(i==goal && sp2==1){\n\t\t\t\t\t\t\t//out.println(\"ANS1:\"+i+\" SP\"+sp2+\" T\"+time);\n\t\t\t\t\t\t\tans=min(ans,time);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//out.println(\"ADD\"+i+\" SP\"+(sp2)+\" T\"+time);\n\t\t\t\t\t\topen.add(new C1162(i,now.now,sp2,time));\n\t\t\t\t\t\tclose[now.now][i][sp2]=time;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println((ans==INF?\"unreachable\":ans));\n\t\t}\n\t}\n\tclass C1162 implements Comparable<C1162>{\n\t\tint now,last,sp;\n\t\tdouble t;\n\t\tC1162(int now,int last,int sp,double t){this.now=now; this.last=last; this.sp=sp; this.t=t;}\n\t\t@Override public int compareTo(C1162 o) {\n\t\t\tif(this.t<o.t)\treturn -1;\n\t\t\tif(this.t>o.t)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t@Override public boolean equals(Object o){\n\t\t\tif(o==null)\treturn false;\n\t\t\tif(this==o)\treturn true;\n\t\t\tif(this.getClass()!=o.getClass())\treturn false;\n\t\t\tC1162 oth=(C1162)o;\n\t\t\tif(this.t==oth.t && this.sp==oth.sp && this.now==oth.now)\treturn true;\n\t\t\treturn false;\n\t\t}\n\t\t@Override public int hashCode(){\n\t\t\tint r=1;\n\t\t\tr=r*31+this.sp;\n\t\t\tr=r*31+(int)this.t;\n\t\t\tr=r*31+this.last;\n\t\t\treturn r;\n\t\t}\n\t\t*/\n\t}\n\t\n\tint ans1161;\n\tint n1161;\n\tHashMap<Character,Integer> map1161;\n\tString [] data1161;\n\t\n\tprivate void solve1161(char c, int deep){\n\t\t\n\t\tif(deep == map1161.size()){\n\t\t\t//calc\n\t\t\tint sum = 0;\n\t\t\tfor(int i =0; i < n1161 -1;i++){\n\t\t\t\tint temp = 0;\n\t\t\t\tfor(int j = 0 ; j < data1161[i].length(); j++){\n\t\t\t\t\tchar tempchar = data1161[i].charAt(j);\n\t\t\t\t\ttemp += tempchar + '0';\n\t\t\t\t\ttemp *= 10;\n\t\t\t\t}\n\t\t\t\tsum += temp;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor(int i =0; i < data1161[n1161 - 1].length(); i++){\n\t\t\t\tchar tempchar = data1161[n1161 - 1].charAt(i);\n\t\t\t\tans += tempchar + '0';\n\t\t\t\tans *= 10;\n\t\t\t}\n\t\t\tSystem.out.println(ans +\" \" + sum);\n\t\t\tif(ans == sum){\n\t\t\t\tans1161++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telse{\n\t\t\tfor(Character ch: map1161.keySet()){\n\t\t\t\tif(map1161.get(ch) == -1){\n\t\t\t\t\tmap1161.put(ch, deep);\n\t\t\t\t\tsolve1161(ch, deep + 1);\n\t\t\t\t\tmap1161.put(ch, -1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid AOJ1161(){\n\t\twhile(true){\n\t\t\tn1161 = sc.nextInt();\n\t\t\tif(n1161 == 0) break;\n\t\t\tans1161 = 0;\n\t\t\tdata1161 = new String[n1161];\n\t\t\tmap1161 = new HashMap<Character,Integer>();\n\t\t\tfor(int i=0; i< n1161; i++){\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j = 0; j <str.length();j++){\n\t\t\t\t\tchar tempchar = str.charAt(j);\n\t\t\t\t\tmap1161.put(tempchar, -1);\n\t\t\t\t}\n\t\t\t\tdata1161[i] = str;\n\t\t\t}\n\t\t\tfor(Character c: map1161.keySet()){\n\t\t\t\tSystem.out.println(\"pass\" +ans1161);\n\t\t\t\tsolve1161(c, 0);\n\t\t\t}\n\t\t\tSystem.out.println(\"ANS=\");\n\t\t\tSystem.out.println(ans1161);\n\t\t}\n\t}\n\t\n\tvoid AOJ1160(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tboolean[][] b=new boolean[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tfor(int x=0; x<W; x++)\tb[x][y]=(sc.nextInt()==1);\n\t\t\t}\n\t\t\tboolean[][] close=new boolean[W][H];\n\t\t\tLinkedList<Point> open=new LinkedList<Point>();\n\t\t\tint ans=0;\n\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\t\tif(b[x][y]&&!close[x][y]){\n\t\t\t\t\t\topen.add(new Point(x,y));\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\t\t\tPoint now=open.poll();\n\t\t\t\t\t\t\tfor(int i=0; i<8; i++){\n\t\t\t\t\t\t\t\tint xx=now.x+vvx[i],yy=now.y+vvy[i];\n\t\t\t\t\t\t\t\tif(!Point.ok(xx, yy, W, H))\tcontinue;\n\t\t\t\t\t\t\t\tif(!b[xx][yy])\tcontinue;\n\t\t\t\t\t\t\t\tif(close[xx][yy])\tcontinue;\n\t\t\t\t\t\t\t\topen.add(new Point(xx,yy));\n\t\t\t\t\t\t\t\tclose[xx][yy]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tvoid AOJ1159(){\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif(n == 0 && q == 0) break;\n\t\t\tint [] data = new int[n];\n\t\t\t//int num = 0;\n\t\t\tfor(int i = 0; i < 1000000; i++){\n\t\t\t\tif(q == 0){\n\t\t\t\t\tq += data[i%n];\n\t\t\t\t\tdata[i%n] = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdata[i%n]++;\n\t\t\t\t\tq--;\n\t\t\t\t\t//System.out.println(q + \" \" + data[i%n]);\n\t\t\t\t\tif(q == 0){\n\t\t\t\t\t\tboolean flg = true;\n\t\t\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\t\t\tif((i % n) == j) continue;\n\t\t\t\t\t\t\tif(data[j] != 0){\n\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg == true){\n\t\t\t\t\t\t\tSystem.out.println(i%n);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\t//public static Random rand=new Random();\n\n\tstatic final int INF =1<<30;\n\n\tstatic class Node{\n\t\tint id;\n\t\tList<Edge> link=new LinkedList<Edge>();\n\t\tNode(int _id){\n\t\t\tid=_id;\n\t\t}\n\t}\n\tstatic class Edge{\n\t\tint from,to;\n\t\tdouble cost;\n\t\tEdge(int _from,int _to,double _cost){\n\t\t\tfrom=_from;to=_to;cost=_cost;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn from+\"->\"+to;\n\t\t}\n\t}\n\tstatic class Task implements Comparable<Task>{\n\t\tint prev,pos;\n\t\tdouble cost;\n\t\tTask(int _prev,int _pos,double _cost){\n\t\t\tprev=_prev;pos=_pos;cost=_cost;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Task T) {\n\t\t\treturn cost>T.cost?1:cost<T.cost?-1:0;\n\t\t}\n\t}\n\n\tpublic static double[] dijkstra(Node[] graph,int s,int[] prev){\n\t\tfinal int V=graph.length;\n\t\tdouble[] d=new double[V];Arrays.fill(d,INF);d[s]=0;\n\t\tArrays.fill(prev,-2);\n\t\tPriorityQueue<Task> que=new PriorityQueue<Task>();\n\t\tque.add(new Task(-1,s,0));\n\t\twhile(!que.isEmpty()){\n\t\t\tTask task=que.poll();\n\t\t\tif(prev[task.pos]!=-2)continue;\n\t\t\t//if(d[task.pos]<task.cost)continue;\n\t\t\tprev[task.pos]=task.prev;\n\t\t\tfor(Edge e:graph[task.pos].link){\n\t\t\t\tif(task.prev==e.to)continue;\n\t\t\t\tif(d[e.to]>d[e.from]+e.cost){\n\t\t\t\t\td[e.to]=d[e.from]+e.cost;\n\t\t\t\t\tque.add(new Task(e.from,e.to,d[e.to]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tpublic int enc(int v,int l){\n\t\treturn (L+1)*v+l;\n\t}\n\tpublic int decL(int id){\n\t\treturn id%(L+1);\n\t}\n\tpublic int decV(int id){\n\t\treturn id/(L+1);\n\t}\n\tint N,M,L;\n\tpublic void run() {\n\t\tTCase:while(true){\n\t\t\tN=sc.nextInt();M=sc.nextInt();L=30;\n\t\t\tif(N==0)return;\n\t\t\tint s=sc.nextInt()-1,e=sc.nextInt()-1;\n\n\t\t\tNode[] graph=new Node[N*(L+1)];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<=L;j++)\n\t\t\t\tgraph[enc(i,j)]=new Node(enc(i,j));\n\n\t\t\t//edge\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tint f=sc.nextInt()-1,t=sc.nextInt()-1;\n\t\t\t\tint d=sc.nextInt(),c=sc.nextInt();\n\t\t\t\tfor(int l=0;l<=L;l++){\n\t\t\t\t\tif(l+1<=L && l+1<=c){\n\t\t\t\t\t\tgraph[enc(f,l)].link.add(new Edge(enc(f,l),enc(t,l+1),1.0*d/(l+1)));\n\t\t\t\t\t\tgraph[enc(t,l)].link.add(new Edge(enc(t,l),enc(f,l+1),1.0*d/(l+1)));\n\t\t\t\t\t}\n\t\t\t\t\tif(l>=1  && l<=c){\n\t\t\t\t\t\tgraph[enc(f,l)].link.add(new Edge(enc(f,l),enc(t,l),1.0*d/l));\n\t\t\t\t\t\tgraph[enc(t,l)].link.add(new Edge(enc(t,l),enc(f,l),1.0*d/l));\n\t\t\t\t\t}\n\t\t\t\t\tif(l-1>=1&& l-1<=c){\n\t\t\t\t\t\tgraph[enc(f,l)].link.add(new Edge(enc(f,l),enc(t,l-1),1.0*d/(l-1)));\n\t\t\t\t\t\tgraph[enc(t,l)].link.add(new Edge(enc(t,l),enc(f,l-1),1.0*d/(l-1)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] prev=new int[N*(L+1)];\n\t\t\tdouble[] d=dijkstra(graph,enc(s,0),prev);\n\n\t\t\tif(INF==d[enc(e,1)])\n\t\t\t\tln(\"unreachable\");\n\t\t\telse{\n\t\t\t\t//ln(strPath(path(prev,enc(e,1))));\n\t\t\t\tln(d[enc(e,1)]);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic String strPath(List<Integer> path){\n\t\tString res=\"\";\n\t\tfor(Integer v:path){\n\t\t\tres+=\"(\"+decV(v)+\",\"+decL(v)+\")--\";\n\t\t}\n\t\treturn res;\n\t}\n\t//パスの出力\n\tpublic static List<Integer> path(int[] prev,int e){\n\t\tList<Integer> path=new ArrayList<Integer>();\n\t\tfor (int u = e; u >= 0; u = prev[u])\n\t\t\tpath.add(u);\n\t\tCollections.reverse(path);\n\t\treturn path;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(Boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n//\tstatic String str(Double o){\n//\t\treturn String.format(\"%.8f\",o);\n//\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((Boolean)o);\n\t\t//if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tint [] xdis = {0,1,0,-1};\n\tint [] ydis = {1,0,-1,0};\n\tclass C implements Comparable<C>{\n\t\tint v,town,lasttown;\n\t\tdouble time;\n\t\tpublic C(int v, int town, int lasttown, double time) {\n\t\t\tthis.v = v;\tthis.town = town;this.lasttown = lasttown;this.time = time;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(C o) {\n\t\t\tif(time < o.time) return -1;\n\t\t\tif(time > o.time) return 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tprivate double getT(int dis, int v){\n\t\tdouble res = (double) dis / v;\n\t\treturn res;\n\t}\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\t\t\tint [][] pass = new int[n+1][n+1];\n\t\t\tint [][] maxs = new int[n+1][n+1];\n\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\tArrays.fill(pass[i], INF);\n\t\t\t\tArrays.fill(maxs[i], INF);\n\t\t\t}\n\t\t\tfor(int i=0; i < m; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tpass[x][y] = d; pass[y][x] = d;\n\t\t\t\tmaxs[x][y] = c; maxs[y][x] = c;\n\t\t\t}\n\t\t\tPriorityQueue<C> open = new PriorityQueue<C>();\n\t\t\topen.add(new C(1,s,-1,0.0));\n\t\t\tdouble [][] close = new double[n+1][31];\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tArrays.fill(close[i], INF);\n\t\t\t}\n\t\t\tclose[0][0] = 0.0;\n\t\t\t\n\t\t\tdouble ans = INF;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\t\n\t\t\t\tfor(int speed = -1; speed <= 1; speed++){\n\t\t\t\t\tint v = now.v + speed;\n\t\t\t\t\tif(now.lasttown == -1 && v != 1) continue;\n\t\t\t\t\tif(! (0 < v && v < 31)) continue;\n\t\t\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\t\t\tif(pass[now.town][i] == INF) continue;\n\t\t\t\t\t\tif(i == now.lasttown) continue;\n\t\t\t\t\t\tint dis = pass[now.town][i];\n\t\t\t\t\t\tdouble nexttime = now.time + getT(dis,v);\n\t\t\t\t\t\tif(close[i][v] < nexttime) continue;\n\t\t\t\t\t\tif(i == g && v == 1){\n\t\t\t\t\t\t\tans = Math.min(ans, nexttime);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\topen.add(new C(v, i, now.town, nexttime));\n\t\t\t\t\t\tclose[i][v] = nexttime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.print(\"ANS=\");\n\t\t\tif(ans == INF){\n\t\t\t\tSystem.out.println(\"unreachable\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.printf(\"%1.5f\\n\",ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Descrete Speed\npublic class Main{\n\n\tpublic static int n;\n\tpublic static int m;\n\tpublic static int start;\n\tpublic static int goal;\n\n\tpublic static double[][][] dist;\n\tpublic static int[][] r;\n\tpublic static int[][] limit;\n\n\tpublic static double dijkstra(){\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tfor(int k=0;k<31;k++)\n\t\t\t\t\tdist[i][j][k] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tdist[1][0][1] = 0;\n\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(n, new Comparator<int[]>(){\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn dist[a[0]][a[1]][a[2]]-dist[b[0]][b[1]][b[2]]<0?-1:dist[a[0]][a[1]][a[2]]-dist[b[0]][b[1]][b[2]]>0?1:0;\n\t\t\t}\n\t\t});\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tif(r[1][i]!=0){\n\t\t\t\tdouble nc = r[1][i]/1.0;\n\t\t\t\tdist[i][1][1] = nc;\n\t\t\t\tq.add(new int[]{i,1,1});\n\t\t\t}\n\t\t}\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] uu = q.poll();\n\t\t\tint u = uu[0];\n\t\t\tint pre = uu[1];\n\t\t\tint v = uu[2];\n\t\t\tif(u==goal&&v==1)return dist[u][pre][v];\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(i!=pre && r[u][i]!=0){\n\t\t\t\t\tfor(int x=v-1;x<=v+1;x++){\n\t\t\t\t\t\tif(x<=0)continue;\n\t\t\t\t\t\tif(x>limit[u][i])continue;\n\t\t\t\t\t\tdouble nc = dist[u][pre][v] + r[u][i]*1.0/x;\n\t\t\t\t\t\tif(nc < dist[i][u][x]){\n\t\t\t\t\t\t\tdist[i][u][x] = nc;\n\t\t\t\t\t\t\tq.add(new int[]{i, u, x});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif(n==0&&m==0)break;\n\t\t\tdist = new double[n+1][n+1][31];\n\t\t\tr = new int[n+1][n+1];\n\t\t\tlimit = new int[n+1][n+1];\n\t\t\tstart = sc.nextInt();\n\t\t\tgoal = sc.nextInt();\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint u = sc.nextInt();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tr[u][v] = r[v][u] = d;\n\t\t\t\tlimit[u][v] = limit[v][u] = l;\n\t\t\t}\n\t\t\tdouble ans = dijkstra();\n\t\t\tif(ans==-1)System.out.println(\"unreachable\");\n\t\t\telse System.out.printf(\"%.5f\\n\", ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint MAX = 30;\n\tdouble EPS = 1e-5;\n\tint n, m;\n\tint s, g;\n\tint map[][];\n\tint lim[][];\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\ts = sc.nextInt()-1;\n\t\t\tg = sc.nextInt()-1;\n\t\t\tmap = new int[n][n];\n\t\t\tlim = new int[n][n];\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint a = sc.nextInt()-1;\n\t\t\t\tint b = sc.nextInt()-1;\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tmap[a][b] = map[b][a] = d;\n\t\t\t\tlim[a][b] = lim[b][a] = l;\n\t\t\t}\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\tint dv[] = {-1,0,1};\n\tString dijkstra() {\n\t\tdouble t[][] = new double[n][MAX+1];\n\t\tfor(double[] a:t ) fill(a, INF);\n\t\tt[s][0] = 0;\n\t\tPriorityQueue<Pair> que = new PriorityQueue<Pair>(1, new MyComp());\n\t\tPair now = new Pair(s, -1, 1, 0);\n\t\tque.add(now);\n\t\tfor(;!que.isEmpty();) {\n\t\t\tnow = que.remove();\n//\t\t\tdebug(que);\n//\t\t\tdebug(now.p, now.past_p, now.v, now.t);\n\t\t\tif( now.p == g && now.v == 0 ) return String.valueOf(now.t);\n\t\t\tif( 0 == now.v ) continue;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif( map[now.p][i] == 0 || now.p == i || now.past_p == i) continue;\n\t\t\t\tif( now.v > lim[now.p][i] ) continue;\n\t\t\t\tdouble time = now.t + map[now.p][i]*1.0 / now.v;\n//\t\t\t\tdebug(now.p, i, map[now.p][i]*1.0/now.v);\n\t\t\t\tif(time < t[i][now.v]) {\n\t\t\t\t\tfor(int j=0;j<3;j++) {\n\t\t\t\t\t\tif( now.v + dv[j] >= 0 ) {\t\t\t\t\t\n\t\t\t\t\t\t\tque.add(new Pair(i, now.p, now.v+dv[j], time));\n//\t\t\t\t\t\t\tdebug(i, now.p, now.v+dv[j], time);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt[i][now.v] = time;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"unreachable\";\n\t}\n\t\n\tclass Pair {\n\t\tint p, v, past_p;\n\t\tdouble t;\n\t\tPair(int p, int past_p, int v, double t) {\n\t\t\tthis.p = p;\n\t\t\tthis.v = v;\n\t\t\tthis.t = t;\n\t\t\tthis.past_p = past_p;\n\t\t}\n\t}\n\t\n\tclass MyComp implements Comparator<Pair> {\n\n\t\t@Override\n\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつスツδソツッツドツ・ツスツタツブ\n\t\t\tif(o1.t-EPS > o2.t ) return 1;\n\t\t\telse if(o1.t < o2.t+EPS) return -1;\n\t\t\treturn o1.v - o2.v;\n\t\t}\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\npublic class Main {\n    static int n, m;\n    static int s, g;\n    static P[][] t;\n\n    static class P{\n        int d;\n        int c;\n        P(int d, int c){\n            this.d = d; this.c = c;\n        }\n    }\n\n    static class State implements Comparable<State>{\n        int id;\n        int from;\n        int v;\n        double cost;\n\n        State(int id, int from, int v, double cost){\n            this.id = id;\n            this.from = from;\n            this.v = v;\n            this.cost = cost;\n        }\n\n        public boolean equals(Object o){\n            State st = (State) o;\n            return id == st.id && from == st.from && v == st.v;\n        }\n\n        public int hashCode(){\n            return (this.id << 20) | (this.v << 10) | this.from;\n        }\n\n         public int compareTo(State st){\n            if(this.cost - st.cost < 0) return -1;\n            if(this.cost - st.cost > 0) return 1;\n            return 0;\n        }\n\n        public String toString(){\n            return \"[\" + this.id + \",\" + this.from + \",\" + this.v + \",\" + this.cost + \"]\";\n        }\n    }\n\n    static void solve(){\n        PriorityQueue<State> open = new PriorityQueue<State>();\n        HashSet<State> closed = new HashSet<State>();\n        State st = new State(s, -1, 0, 0);\n\n        open.add(st);\n        while(!open.isEmpty()){\n            st = open.poll();\n            if(closed.contains(st)) continue;\n            closed.add(st);\n\n//            out.println(st);\n\n            if(st.id == g && st.v == 1){\n                out.println(st.cost);\n                return;\n            }\n\n            for(int i=1;i<=n;i++){\n                if(st.from == i) continue;\n                P p = t[st.id][i];\n                if(p == null) continue;\n                for(int j=-1;j<=1;j++){\n                    int v = st.v + j;\n                    if(v <= 0) continue;\n                    if(v > p.c) continue;\n\n                    int id = i;\n                    int from = st.id;\n                    double cost = st.cost + 1.0 * p.d / v;\n                    State ns = new State(id, from, v, cost);\n                    open.add(ns);\n                }\n            }\n        }\n\n        out.println(\"unreachable\");\n    }\n\n    static void disp(){\n        for(int i=1;i<=n;i++){\n            for(int j=i+1;j<=n;j++){\n                if(t[i][j] != null){\n                    out.print(i+\"-\"+j+\":[\"+t[i][j].d+\",\"+t[i][j].c+\"] \");\n                    out.println(j+\"-\"+i+\":[\"+t[j][i].d+\",\"+t[j][i].c+\"] \");\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(in);\n        while(true){\n            n = sc.nextInt();\n            m = sc.nextInt();\n\n            if(n == 0 && m == 0) break;\n\n            t = new P[n+1][n+1];\n\n            s = sc.nextInt();\n            g = sc.nextInt();\n\n            for(int i=0;i<m;i++){\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                int d = sc.nextInt();\n                int c = sc.nextInt();\n\n                P p = new P(d, c);\n                t[x][y] = t[y][x] = p;\n            }\n\n//            disp();\n\n            solve();\n        }\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass State implements Comparable<State> {\n\t\tdouble t;\n\t\tint c, v, pre;\n\n\t\tState(double t, int c, int v, int pre) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t\tthis.v = v;\n\t\t\tthis.pre = pre;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State arg0) {\n\t\t\treturn this.t - arg0.t > 0 ? 1 : -1;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tint[][] d = new int[n][n];\n\t\t\tint[][] c = new int[n][n];\n\t\t\tdouble[][] t = new double[n][31];\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tArrays.fill(d[j], Integer.MAX_VALUE >> 3);\n\t\t\t\tArrays.fill(c[j], 0);\n\t\t\t\tArrays.fill(t[j], Double.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint d1 = sc.nextInt();\n\t\t\t\tint c1 = sc.nextInt();\n\t\t\t\td[x][y] = d1;\n\t\t\t\td[y][x] = d1;\n\t\t\t\tc[x][y] = c1;\n\t\t\t\tc[y][x] = c1;\n\t\t\t}\n\n\t\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\n\t\t\tt[s][0] = 0;\n\t\t\tq.add(new State(0, s, 0, -1));\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tState pop = q.poll();\n\t\t\t\tif (t[pop.c][pop.v] < pop.t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pop.c == g && pop.v == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\t\tif (pop.pre == i) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int dv = -1; dv <= 1; dv++) {\n\t\t\t\t\t\tint nv = pop.v + dv;\n\t\t\t\t\t\tif (nv > 30) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nv <= 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (c[pop.c][i] < nv) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdouble dt = (double) d[pop.c][i] / (double) (nv);\n\t\t\t\t\t\tif (t[i][nv] > t[pop.c][pop.v] + dt) {\n\t\t\t\t\t\t\tt[i][nv] = t[pop.c][pop.v] + dt;\n\t\t\t\t\t\t\tq.add(new State(t[i][nv], i, nv, pop.c));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[g][1] >= Double.MAX_VALUE / 4) {\n\t\t\t\tSystem.out.println(\"unreachable\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(t[g][1]);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n  \npublic class Main {\n     \n    static int N, M;\n    static int S, G;\n    static int[][] D, C;\n     \n    static void start()\n    {\n        double[][][] times = new double[N+1][N+1][31];\n        boolean[][][] check = new boolean[N+1][N+1][31];\n         \n        for (int n = 0; n < N+1; n++) {\n            for (int pren = 0; pren < N+1; pren++) {\n                for (int c = 0; c < 31; c++) {\n                    times[n][pren][c] = Double.MAX_VALUE;\n                    check[n][pren][c] = false;\n                }\n            }\n        }\n         \n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] a, int[] b)\n            {\n                if(times[ a[0] ][ a[1] ][ a[2] ] < times[ b[0] ][ b[1] ][ b[2] ])\n                    return -1;\n                else if(times[ a[0] ][ a[1] ][ a[2] ] == times[ b[0] ][ b[1] ][ b[2] ])\n                    return 0;\n                else {\n                    return 1;\n                }\n            }\n        });\n         \n        times[S][0][1] = 0;\n        queue.offer(new int[]{S, 0, 1});\n         \n        while(!queue.isEmpty())\n        {\n            int now_n = 0, now_pren = 0, now_c = 0;\n             \n            // スタート位置の決定\n            int[] qq = queue.poll();\n            now_n = qq[0];\n            now_pren = qq[1];\n            now_c = qq[2];\n             \n            if(now_n == G && now_c == 1)\n            {\n                System.out.printf(\"%.05f\\n\", times[now_n][now_pren][now_c]);\n                return;\n            }\n             \n            if(check[now_n][now_pren][now_c] == true) continue;\n             \n            // 処理\n            check[now_n][now_pren][now_c] = true;\n             \n            for (int n = 1; n <= N; n++) {\n                if(now_n == n) continue;\n                if(now_pren == n) continue;\n                if(D[now_n][n] < 0) continue;\n                 \n                // 速度-1\n                if(1 < now_c)\n                {\n                    if((now_c-1) <= C[now_n][n])\n                    {\n                        double ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c-1);\n                        if(ntime < times[n][now_n][now_c-1])\n                        {\n                            times[n][now_n][now_c-1] = ntime;\n                            queue.offer(new int[]{n, now_n, now_c-1});\n                        }\n                    }\n                }\n                 \n                // 速度そのまま\n                if(true)\n                {\n                    if(now_c <= C[now_n][n])\n                    {\n                        double ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)now_c;\n                        if(ntime < times[n][now_n][now_c])\n                        {\n                            times[n][now_n][now_c] = ntime;\n                            queue.offer(new int[]{n, now_n, now_c});\n                        }\n                    }\n                }\n                 \n                if(now_n == S && now_c == 1) continue;\n                 \n                // 速度+1\n                if(now_c < 30)\n                {\n                    if((now_c+1) <= C[now_n][n])\n                    {\n                        double ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c+1);\n                        if(ntime < times[n][now_n][now_c+1])\n                        {\n                            times[n][now_n][now_c+1] = ntime;\n                            queue.offer(new int[]{n, now_n, now_c+1});\n                        }\n                    }\n                }\n            }\n        }\n         \n        System.out.println(\"unreachable\");\n    }\n      \n    public static void main(String[] args)\n    {\n        Scanner sca = new Scanner(System.in);\n         \n        while(true)\n        {\n            N = sca.nextInt();\n            M = sca.nextInt();\n            if(N == 0) break;\n             \n            S = sca.nextInt();\n            G = sca.nextInt();\n             \n            D = new int[N+1][N+1];\n            C = new int[N+1][N+1];\n            for (int i = 0; i <= N; i++) {\n                for (int j = 0; j <= N; j++) {\n                    D[i][j] = C[i][j] = -1;\n                }\n            }\n             \n            for (int i = 0; i < M; i++) {\n                int x = sca.nextInt();\n                int y = sca.nextInt();\n                int d = sca.nextInt();\n                int c = sca.nextInt();\n                 \n                D[y][x] = D[x][y] = d;\n                C[y][x] = C[x][y] = c;\n            }\n             \n            start();\n        }\n         \n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint MAX = 30;\n\tdouble EPS = 1e-5;\n\tint n, m;\n\tint s, g;\n\tint map[][];\n\tint lim[][];\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\ts = sc.nextInt()-1;\n\t\t\tg = sc.nextInt()-1;\n\t\t\tmap = new int[n][n];\n\t\t\tlim = new int[n][n];\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint a = sc.nextInt()-1;\n\t\t\t\tint b = sc.nextInt()-1;\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tmap[a][b] = map[b][a] = d;\n\t\t\t\tlim[a][b] = lim[b][a] = l;\n\t\t\t}\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\tint dv[] = {-1,0,1};\n\tString dijkstra() {\n\t\tdouble t[][][] = new double[n][n+1][MAX+1];\n\t\tfor(double[][] a:t ) for(double[] b:  a) fill(b, INF);\n\t\tt[s][n][0] = 0;\n\t\tPriorityQueue<Pair> que = new PriorityQueue<Pair>(1, new MyComp());\n\t\tPair now = new Pair(s, -1, 1, 0, 0);\n\t\tque.add(now);\n\t\tfor(;!que.isEmpty();) {\n\t\t\tnow = que.remove();\n//\t\t\tdebug(que);\n//\t\t\tdebug(now.p, now.past_p, now.v, now.t);\n\t\t\tif( now.p == g && now.past_v == 1 ) return String.valueOf(now.t);\n\t\t\tif( 0 == now.v ) continue;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif( map[now.p][i] == 0 || now.p == i || now.past_p == i) continue;\n\t\t\t\tif( now.v > lim[now.p][i] ) continue;\n\t\t\t\tdouble time = now.t + (double)map[now.p][i] / now.v;\n//\t\t\t\tdebug(now.p, i, map[now.p][i]*1.0/now.v);\n\t\t\t\tif(time < t[i][now.p][now.v]) {\n\t\t\t\t\tfor(int j=0;j<3;j++) {\n\t\t\t\t\t\tif( now.v + dv[j] >= 0 ) {\t\t\t\t\t\n\t\t\t\t\t\t\tque.add(new Pair(i, now.p, now.v+dv[j], now.v, time));\n//\t\t\t\t\t\t\tdebug(i, now.p, now.v+dv[j], time);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt[i][now.p][now.v] = time;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"unreachable\";\n\t}\n\t\n\tclass Pair {\n\t\tint p, v, past_p, past_v;\n\t\tdouble t;\n\t\tPair(int p, int past_p, int v, int past_v, double t) {\n\t\t\tthis.p = p;\n\t\t\tthis.v = v;\n\t\t\tthis.t = t;\n\t\t\tthis.past_p = past_p;\n\t\t\tthis.past_v = past_v;\n\t\t}\n\t}\n\t\n\tclass MyComp implements Comparator<Pair> {\n\n\t\t@Override\n\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつスツδソツッツドツ・ツスツタツブ\n\t\t\tif(o1.t > o2.t ) return 1;\n\t\t\telse if(o1.t < o2.t) return -1;\n\t\t\treturn o1.v - o2.v;\n\t\t}\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\t\n\tint n, m;\n\t\n\tint[][] edge;\n\tdouble[][] minCost;\n\tint[][] maxSpeed;\t\n\t\n\tdouble INF = 1000000000;\n\t\n\tclass State implements Comparable<State> {\n\t\tint n, speed, prev;\n\n\t\tState(int n, int speed, int prev) {\n\t\t\tthis.n = n;\n\t\t\tthis.speed = speed;\n\t\t\tthis.prev = prev;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(State arg0) {\n\t\t\tdouble c1 = minCost[n][speed], c2 = minCost[arg0.n][arg0.speed];\n\t\t\tif (c1 > c2) return 1;\n\t\t\telse if (c1 < c2) return -1;\n\t\t\telse return 0;\n\t\t}\n\t}\n\t\n\tboolean isOk(int x) {\n\t\treturn x > 0 && x <= 30;\n\t}\n\t\n\tvoid dijkstra(int start) {\n\t\tminCost = new double[n][31];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tArrays.fill(minCost[i], INF);\n\t\t\n\t\tminCost[start][0] = 0;\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.add(new State(0, 0, -1));\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (s.prev == i) continue;\n\t\t\t\tfor (int c = 0; c <= 30; c++) {\n\t\t\t\t\tfor (int v = -1; v <= 1; v++) {\n\t\t\t\t\t\tif (isOk(c+v) && c+v <= maxSpeed[i][s.n] && minCost[i][c+v] > minCost[s.n][c] + (double)edge[i][s.n] / (c+v)) {\n\t\t\t\t\t\t\tminCost[i][c+v] = minCost[s.n][c] + (double)edge[i][s.n] / (c+v);\n\t\t\t\t\t\t\tpq.add(new State(i, c+v, s.n));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = in.nextInt(); m = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint s = in.nextInt() - 1, g = in.nextInt() - 1;\n\n\t\t\tmaxSpeed = new int[n][n];\n\t\t\tedge = new int[n][n];\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = in.nextInt() - 1, y = in.nextInt() - 1, d = in.nextInt(), c = in.nextInt();\n\t\t\t\tedge[x][y] = edge[y][x] = d;\n\t\t\t\tmaxSpeed[x][y] = maxSpeed[y][x] = c;\n\t\t\t}\n\t\t\t\n\t\t\tdijkstra(s);\n\t\t\t\n\t\t\tdouble res = minCost[g][1];\n\t\t\t\n\t\t\t/*\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t\t\tSystem.out.print(minCost[i][j] + \" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tSystem.out.println(res == INF ? \"unreachable\" : res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n//\t\tint idx = 0;\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint g = in.nextInt()-1;\n\t\t\tboolean[][][] used = new boolean[n][n][31];\n\t\t\tint[][] rist = new int[n][n];\n\t\t\tint[][] dist = new int[n][n];\n\t\t\tNode[] node = new Node[n];\n\t\t\tfor(int i=0; i<n; i++) node[i] = new Node(i);\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint x = in.nextInt()-1;\n\t\t\t\tint y = in.nextInt()-1;\n\t\t\t\tint d = in.nextInt();\n\t\t\t\tint c = in.nextInt();\n\t\t\t\tnode[x].createEdge(node[y]);\n\t\t\t\tnode[y].createEdge(node[x]);\n\t\t\t\tdist[x][y] = dist[y][x] = d;\n\t\t\t\trist[x][y] = rist[y][x] = c;\n\t\t\t}\n//\t\t\tdouble[][][] best = new double[n][n][31];\n\t\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n\t\t\tqu.add(new Pos(s, s, 0, 0));\n\t\t\tdouble time = 1e9;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(p.city == g && p.vel == 1){\n\t\t\t\t\ttime = p.dist;\n\t\t\t\t\tbreak;\n//\t\t\t\t\ttime = Math.min(time, p.dist);\n\t\t\t\t}\n//\t\t\t\tif(best[p.city][p.back][p.vel] != 0\n//\t\t\t\t\t\t&& best[p.city][p.back][p.vel] <= p.dist) continue;\n//\t\t\t\tbest[p.city][p.back][p.vel] = p.dist;\n\t\t\t\tif(used[p.city][p.back][p.vel]) continue;\n\t\t\t\tused[p.city][p.back][p.vel] = true;\n\t\t\t\tfor(Node nd: node[p.city].list){\n\t\t\t\t\tif(p.back == nd.id) continue;\n\t\t\t\t\tfor(int i=-1; i<=1; i++){\n\t\t\t\t\t\tint v = p.vel+i;\n\t\t\t\t\t\tif(v < 1 || v > rist[p.city][nd.id]) continue;\n\t\t\t\t\t\tqu.add(new Pos(nd.id, p.city, v, p.dist + (double)dist[p.city][nd.id]/v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(time >= 1e9 ? \"unreachable\" : time);\n//\t\t\tidx++;\n\t\t}\n\t}\n}\n\nclass Node{\n\tint id;\n\tList<Node> list = new ArrayList<Node>();\n\tpublic Node(int id){\n\t\tthis.id = id;\n\t}\n\t\n\tpublic void createEdge(Node nd){\n\t\tlist.add(nd);\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tint city;\n\tint back;\n\tint vel;\n\tdouble dist;\n\tpublic Pos(int c, int back, int v, double dist){\n\t\tcity = c;\n\t\tvel = v;\n\t\tthis.back = back;\n\t\tthis.dist = dist;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn Double.compare(dist, o.dist);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\t\n\tint n, m;\n\t\n\tint[][] edge;\n\tdouble[][][] minCost;\n\tint[][] maxSpeed;\t\n\t\n\tdouble INF = 100000000;\n\t\n\tclass State implements Comparable<State> {\n\t\tint n, speed, prev;\n\n\t\tState(int n, int speed, int prev) {\n\t\t\tthis.n = n;\n\t\t\tthis.speed = speed;\n\t\t\tthis.prev = prev;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(State arg0) {\n\t\t\tdouble c1 = minCost[n][prev][speed], c2 = minCost[arg0.n][arg0.prev][arg0.speed];\n\t\t\tif (c1 > c2) return 1;\n\t\t\telse if (c1 < c2) return -1;\n\t\t\telse return 0;\n\t\t}\n\t}\n\t\n\tvoid dijkstra(int start) {\n\t\tminCost = new double[n][n][31];\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++)\n\t\t\tArrays.fill(minCost[i][j], INF);\n\t\t\n\t\tminCost[start][start][0] = 0;\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.add(new State(start, 0, start));\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (edge[s.n][i] == INF) continue;\n\t\t\t\tif (s.prev == i) continue;\n\t\t\t\tfor (int c = 0; c <= 30; c++) {\n\t\t\t\t\tfor (int v = -1; v <= 1; v++) {\n\t\t\t\t\t\tif (c+v > 0 && c+v <= maxSpeed[i][s.n] && minCost[i][s.n][c+v] > minCost[s.n][s.prev][c] + (double)edge[i][s.n] / (c+v)) {\n\t\t\t\t\t\t\tminCost[i][s.n][c+v] = minCost[s.n][s.prev][c] + (double)edge[i][s.n] / (c+v);\n\t\t\t\t\t\t\tpq.add(new State(i, c+v, s.n));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = in.nextInt(); m = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint s = in.nextInt() - 1, g = in.nextInt() - 1;\n\n\t\t\tmaxSpeed = new int[n][n];\n\t\t\tedge = new int[n][n];\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = in.nextInt() - 1, y = in.nextInt() - 1, d = in.nextInt(), c = in.nextInt();\n\t\t\t\tedge[x][y] = edge[y][x] = d;\n\t\t\t\tmaxSpeed[x][y] = maxSpeed[y][x] = c;\n\t\t\t}\n\t\t\t\n\t\t\tdijkstra(s);\n\t\t\t\n\t\t\tdouble res = INF;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tres = Math.min(minCost[g][i][1], res);\n\t\t\t\n\t\t\t/*\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t\t\tSystem.out.print(minCost[i][j] + \" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tSystem.out.println(res == INF ? \"unreachable\" : res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tint [] xdis = {0,1,0,-1};\n\tint [] ydis = {1,0,-1,0};\n\tclass C implements Comparable<C>{\n\t\tint v,town,lasttown;\n\t\tdouble time;\n\t\tpublic C(int v, int town, int lasttown, double time) {\n\t\t\tthis.v = v;\tthis.town = town;this.lasttown = lasttown;this.time = time;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(C o) {\n\t\t\tif(time < o.time) return -1;\n\t\t\tif(time > o.time) return 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tprivate double getT(int dis, int v){\n\t\tdouble res = (double) dis / v;\n\t\treturn res;\n\t}\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\t\t\tint [][] pass = new int[n+1][n+1];\n\t\t\tint [][] maxs = new int[n+1][n+1];\n\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\tArrays.fill(pass[i], INF);\n\t\t\t\tArrays.fill(maxs[i], INF);\n\t\t\t}\n\t\t\tfor(int i=0; i < m; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tpass[x][y] = d; pass[y][x] = d;\n\t\t\t\tmaxs[x][y] = c; maxs[y][x] = c;\n\t\t\t}\n\t\t\tPriorityQueue<C> open = new PriorityQueue<C>();\n\t\t\topen.add(new C(1,s,-1,0.0));\n\t\t\tdouble [][][] close = new double[n+1][n+1][31];\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\t\tArrays.fill(close[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose[0][0][0] = 0.0;\n\t\t\tdouble ans = INF;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\t\n\t\t\t\tfor(int speed = -1; speed <= 1; speed++){\n\t\t\t\t\tint v = now.v + speed;\n\t\t\t\t\tif(now.lasttown == -1 && v != 1) continue;\n\t\t\t\t\tif(! (0 < v && v < 31)) continue;\n\t\t\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\t\t\tif(pass[now.town][i] == INF) continue;\n\t\t\t\t\t\tif(i == now.lasttown) continue;\n\t\t\t\t\t\tif(maxs[now.town][i] < v) continue;\n\t\t\t\t\t\tint dis = pass[now.town][i];\n\t\t\t\t\t\tdouble nexttime = now.time + getT(dis,v);\n\t\t\t\t\t\tif(close[now.town][i][v] <= nexttime) continue;\n\t\t\t\t\t\tif(i == g && v == 1){\n\t\t\t\t\t\t\tans = Math.min(ans, nexttime);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\topen.add(new C(v, i, now.town, nexttime));\n\t\t\t\t\t\tclose[now.town][i][v] = nexttime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.print(\"ANS=\");\n\t\t\tif(ans == INF){\n\t\t\t\tSystem.out.println(\"unreachable\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.printf(\"%1.5f\\n\",ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\n\t\t\tEdge[][] map = new Edge[n+1][n+1];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint from = sc.nextInt();\n\t\t\t\tint to = sc.nextInt();\n\t\t\t\tdouble d = sc.nextDouble();\n\t\t\t\tdouble c = sc.nextDouble();\n\t\t\t\tmap[from][to] = new Edge(from,to,d,c);\n\t\t\t\tmap[to][from] = new Edge(to,from,d,c);\n\t\t\t}\n\n\t\t\tPriorityQueue<State> open = new PriorityQueue<State>();\n\t\t\tHashSet<State> closed = new HashSet<State>();\n\t\t\tState ans = null;\n\t\t\topen.add(new State(s,-1,0,0));\n\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState st = open.poll();\n\n\t\t\t\tif(st.n == g && st.v == 1){\n\t\t\t\t\tans = st;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\topen.addAll(st.nexts(map,closed));\n\t\t\t}\n\n\t\t\tif(ans == null) System.out.println(\"unreachable\");\n\t\t\telse System.out.printf(\"%.4f\\n\",ans.cost);\n\t\t}\n\t}\n}\n\nclass State implements Comparable<State>{\n\tint n,before;\n\tdouble cost,v;\n\n\tState(int n,int before,double cost,double v){\n\t\tthis.n = n;\n\t\tthis.before = before;\n\t\tthis.cost = cost;\n\t\tthis.v = v;\n\t}\n\n\tList<State> nexts(Edge[][] map,HashSet<State> closed){\n\t\tint m = map.length;\n\t\tList<State> sts = new ArrayList<State>();\n\n\t\tfor(int i=1;i<m;i++){\n\t\t\tif(map[n][i] != null && before != i){\n\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\tif(v + j > 0 && v + j <= map[n][i].c){\n\t\t\t\t\t\tState nst = new State(i,n,cost+map[n][i].d/(v+j),v+j);\n\t\t\t\t\t\tif(closed.contains(nst)) continue;\n\t\t\t\t\t\tsts.add(nst);\n\t\t\t\t\t\tclosed.add(nst);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sts;\n\t}\n\n\tpublic int compareTo(State st){\n\t\tif(cost < st.cost) return -1;\n\t\tif(cost > st.cost) return 1;\n\t\treturn 0;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tState st = (State)o;\n\t\treturn n == st.n && before == st.before && v == st.v;\n\t}\n\n\tpublic int hashCode(){\n\t\treturn n + 100 * before + 10000 * (int)v;\n\t}\n}\n\nclass Edge{\n\tint from,to;\n\tdouble d,c;\n\n\tEdge(int from,int to,double d,double c){\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t\tthis.d = d;\n\t\tthis.c = c;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n  \npublic class Main {\n     \n    static int N, M;\n    static int S, G;\n    static int[][] D, C;\n    static double[][][] times;\n     \n    static void start()\n    {\n        times = new double[N+1][N+1][31];\n        boolean[][][] check = new boolean[N+1][N+1][31];\n         \n        for (int n = 0; n < N+1; n++) {\n            for (int pren = 0; pren < N+1; pren++) {\n                for (int c = 0; c < 31; c++) {\n                    times[n][pren][c] = Double.MAX_VALUE;\n                    check[n][pren][c] = false;\n                }\n            }\n        }\n         \n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] a, int[] b)\n            {\n                if(times[ a[0] ][ a[1] ][ a[2] ] < times[ b[0] ][ b[1] ][ b[2] ])\n                    return -1;\n                else if(times[ a[0] ][ a[1] ][ a[2] ] == times[ b[0] ][ b[1] ][ b[2] ])\n                    return 0;\n                else {\n                    return 1;\n                }\n            }\n        });\n         \n        times[S][0][1] = 0;\n        queue.offer(new int[]{S, 0, 1});\n         \n        while(!queue.isEmpty())\n        {\n            int now_n = 0, now_pren = 0, now_c = 0;\n             \n            // スタート位置の決定\n            int[] qq = queue.poll();\n            now_n = qq[0];\n            now_pren = qq[1];\n            now_c = qq[2];\n             \n            if(now_n == G && now_c == 1)\n            {\n                System.out.printf(\"%.05f\\n\", times[now_n][now_pren][now_c]);\n                return;\n            }\n             \n            if(check[now_n][now_pren][now_c] == true) continue;\n             \n            // 処理\n            check[now_n][now_pren][now_c] = true;\n             \n            for (int n = 1; n <= N; n++) {\n                if(now_n == n) continue;\n                if(now_pren == n) continue;\n                if(D[now_n][n] < 0) continue;\n                 \n                // 速度-1\n                if(1 < now_c)\n                {\n                    if((now_c-1) <= C[now_n][n])\n                    {\n                        double ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c-1);\n                        if(ntime < times[n][now_n][now_c-1])\n                        {\n                            times[n][now_n][now_c-1] = ntime;\n                            queue.offer(new int[]{n, now_n, now_c-1});\n                        }\n                    }\n                }\n                 \n                // 速度そのまま\n                if(true)\n                {\n                    if(now_c <= C[now_n][n])\n                    {\n                        double ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)now_c;\n                        if(ntime < times[n][now_n][now_c])\n                        {\n                            times[n][now_n][now_c] = ntime;\n                            queue.offer(new int[]{n, now_n, now_c});\n                        }\n                    }\n                }\n                 \n                if(now_n == S && now_c == 1) continue;\n                 \n                // 速度+1\n                if(now_c < 30)\n                {\n                    if((now_c+1) <= C[now_n][n])\n                    {\n                        double ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c+1);\n                        if(ntime < times[n][now_n][now_c+1])\n                        {\n                            times[n][now_n][now_c+1] = ntime;\n                            queue.offer(new int[]{n, now_n, now_c+1});\n                        }\n                    }\n                }\n            }\n        }\n         \n        System.out.println(\"unreachable\");\n    }\n      \n    public static void main(String[] args)\n    {\n        Scanner sca = new Scanner(System.in);\n         \n        while(true)\n        {\n            N = sca.nextInt();\n            M = sca.nextInt();\n            if(N == 0) break;\n             \n            S = sca.nextInt();\n            G = sca.nextInt();\n             \n            D = new int[N+1][N+1];\n            C = new int[N+1][N+1];\n            for (int i = 0; i <= N; i++) {\n                for (int j = 0; j <= N; j++) {\n                    D[i][j] = C[i][j] = -1;\n                }\n            }\n             \n            for (int i = 0; i < M; i++) {\n                int x = sca.nextInt();\n                int y = sca.nextInt();\n                int d = sca.nextInt();\n                int c = sca.nextInt();\n                 \n                D[y][x] = D[x][y] = d;\n                C[y][x] = C[x][y] = c;\n            }\n             \n            start();\n        }\n         \n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-5;\n\t\n\tint n, m;\n\tLinkedList<E>[] edges;\n\tdouble[][][] map;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\t\n\t\t\tint s = sc.nextInt()-1;\n\t\t\tint g = sc.nextInt()-1;\n\t\t\t\n\t\t\tedges = new LinkedList[n];\n\t\t\tfor(int i=0;i<n;i++) edges[i] = new LinkedList<E>();\n\t\t\t\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint a = sc.nextInt()-1;\n\t\t\t\tint b = sc.nextInt()-1;\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\t\n\t\t\t\tedges[a].add( new E(b, c, d));\n\t\t\t\tedges[b].add( new E(a, c, d));\n\t\t\t}\n\t\t\t\n//\t\t\tfor(LinkedList<E> es: edges) for(E e: es) debug(e.to, e.c, e.d);\n\t\t\t\n\t\t\tdouble d = dijkstra(s, g);\n\t\t\t\n\t\t\tSystem.out.println((d<-EPS? \"unreachable\": d));\n\t\t}\n\t\t\n\t}\n\t\n\tdouble dijkstra(int s, int g) {\n\t\tPriorityQueue<V> que = new PriorityQueue<V>();\n\t\t\n\t\tque.add(new V(s, 0, s, 0.0));\n\t\t\n\t\tmap = new double[n][31][n];\n\t\tfor(double[][] a: map) for(double[] b: a) fill(b, INF);\n\t\t\n\t\tmap[s][0][s] = 0.0;\n\t\t\n\t\twhile(!que.isEmpty()) {\n\t\t\tV now = que.poll();\n\t\t\t\n\t\t\tdebug(now.u, now.v, now.p, now.t, map[now.u][now.p]);\n\t\t\t\n\t\t\tif( now.u == g && now.v == 1 ) return now.t;\n\t\t\tif( abs( map[now.u][now.v][now.p] -now.t ) > EPS ) continue;\n\n\t\t\tfor(E edge: edges[now.u]) if( edge.to != now.p ) {\n\t\t\t\tfor(int dv = 1;dv>=-1;dv--) if( 0 < now.v+dv && now.v + dv<=edge.c ) {\n\t\t\t\tdebug(\"a\");\n\t\t\t\t\tdouble t = now.t + 1.0 * edge.d / (now.v+dv);\n\t\t\t\t\tif( t - map[edge.to][now.v+dv][now.u] < EPS ) {\n\t\t\t\t\t\tmap[edge.to][now.v+dv][now.u] = t;\n\t\t\t\t\t\tque.add(new V(edge.to, now.v+dv, now.u, t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tclass E {\n\t\tint to, c, d;\n\t\tE ( int to, int c, int d) {\n\t\t\tthis.to = to;\n\t\t\tthis.c = c;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\t\n\tclass V implements Comparable<V>{\n\t\tint u, v, p;\n\t\tdouble t;\n\t\tV(int u, int v, int p, double t) {\n\t\t\tthis.u = u;\n\t\t\tthis.v = v;\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(V o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn (t-o.t) > EPS? 1: -1;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n//\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Descrete Speed\npublic class Main{\n\n\tpublic static int n;\n\tpublic static int m;\n\tpublic static int start;\n\tpublic static int goal;\n\n\tpublic static double[][][] dist;\n\tpublic static int[][] r;\n\tpublic static int[][] limit;\n\n\tpublic static int zip(int a, int b, int c){\n\t\treturn a<<10|b<<5|c;\n\t}\n\n\tpublic static int[] unzip(int a){\n\t\tint[] r = new int[3];\n\t\tr[2] = a&31;\n\t\ta >>= 5;\n\t\tr[1] = a&31;\n\t\tr[0] = a>>5;\n\t\treturn r;\n\t}\n\n\tpublic static double dijkstra(){\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tfor(int k=0;k<31;k++)\n\t\t\t\t\tdist[i][j][k] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tdist[1][0][0] = 0;\n\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(n, new Comparator<int[]>(){\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn dist[a[0]][a[1]][a[2]]-dist[b[0]][b[1]][b[2]]<0?-1:dist[a[0]][a[1]][a[2]]-dist[b[0]][b[1]][b[2]]>0?1:0;\n\t\t\t}\n\t\t});\n\t\tq.add(new int[]{1, 0, 0});\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] uu = q.poll();\n\t\t\tint u = uu[0];\n\t\t\tint pre = uu[1];\n\t\t\tint v = uu[2];\n\t\t\tif(u==goal&&v==1)return dist[u][pre][v];\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(i!=pre && r[u][i]!=0){\n\t\t\t\t\tfor(int x=v-1;x<=v+1;x++){\n\t\t\t\t\t\tif(x<=0)continue;\n\t\t\t\t\t\tif(x>limit[u][i])continue;\n\t\t\t\t\t\tdouble nc = dist[u][pre][v] + r[u][i]*1.0/x;\n\t\t\t\t\t\tif(nc < dist[i][u][x]){\n\t\t\t\t\t\t\tdist[i][u][x] = nc;\n\t\t\t\t\t\t\tq.add(new int[]{i, u, x});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif(n==0&&m==0)break;\n\t\t\tdist = new double[n+1][n+1][31];\n\t\t\tr = new int[n+1][n+1];\n\t\t\tlimit = new int[n+1][n+1];\n\t\t\tstart = sc.nextInt();\n\t\t\tgoal = sc.nextInt();\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint u = sc.nextInt();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tr[u][v] = r[v][u] = d;\n\t\t\t\tlimit[u][v] = limit[v][u] = l;\n\t\t\t}\n\t\t\tdouble ans = dijkstra();\n\t\t\tif(ans==-1)System.out.println(\"unreachable\");\n\t\t\telse System.out.printf(\"%.5f\\n\", ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n \npublic class Main {\n    \n\tstatic int N, M;\n\tstatic int S, G;\n\tstatic int[][] D, C;\n\t\n    static void start()\n    {\n    \tdouble[][][] times = new double[N+1][N+1][31];\n    \tboolean[][][] check = new boolean[N+1][N+1][31];\n    \t\n    \tfor (int n = 0; n < N+1; n++) {\n\t\t\tfor (int pren = 0; pren < N+1; pren++) {\n\t\t\t\tfor (int c = 0; c < 31; c++) {\n\t\t\t\t\ttimes[n][pren][c] = Double.MAX_VALUE;\n\t\t\t\t\tcheck[n][pren][c] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \t\n    \ttimes[S][0][1] = 0;\n    \t\n    \twhile(true)\n    \t{\n    \t\tint now_n = 0, now_pren = 0, now_c = 0;\n    \t\t\n    \t\t// スタート位置の決定\n    \t\tdouble min = Double.MAX_VALUE;\n    \t\tfor (int n = 1; n < N+1; n++) {\n    \t\t\tfor (int pren = 0; pren < N+1; pren++) {\n    \t\t\t\tfor (int c = 1; c < 31; c++) {\n    \t\t\t\t\tif(check[n][pren][c] == true) continue;\n    \t\t\t\t\tif(times[n][pren][c] < min)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tmin = times[n][pren][c];\n    \t\t\t\t\t\tnow_n = n;\n    \t\t\t\t\t\tnow_pren = pren;\n    \t\t\t\t\t\tnow_c = c;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tif(min == Double.MAX_VALUE)\n    \t\t{\n    \t\t\tSystem.out.println(\"unreachable\");\n    \t\t\treturn;\n    \t\t}\n    \t\tif(now_n == G && now_c == 1)\n    \t\t{\n    \t\t\tSystem.out.printf(\"%.05f\\n\", min);\n    \t\t}\n    \t\t\n    \t\t// 処理\n    \t\tcheck[now_n][now_pren][now_c] = true;\n    \t\t\n    \t\tfor (int n = 1; n <= N; n++) {\n    \t\t\tif(now_n == n) continue;\n\t\t\t\tif(now_pren == n) continue;\n\t\t\t\tif(D[now_n][n] < 0) continue;\n\t\t\t\t\n\t\t\t\t// 速度-1\n\t\t\t\tif(1 < now_c)\n\t\t\t\t{\n\t\t\t\t\tif((now_c-1) <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c-1);\n\t\t\t\t\t\ttimes[n][now_n][now_c-1] = Math.min(times[n][now_n][now_c-1], ntime);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 速度そのまま\n\t\t\t\tif(true)\n\t\t\t\t{\n\t\t\t\t\tif(now_c <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)now_c;\n\t\t\t\t\t\ttimes[n][now_n][now_c] = Math.min(times[n][now_n][now_c], ntime);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(now_n == S && now_c == 1) continue;\n\t\t\t\t\n\t\t\t\t// 速度+1\n\t\t\t\tif(now_c < 30)\n\t\t\t\t{\n\t\t\t\t\tif((now_c+1) <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c+1);\n\t\t\t\t\t\ttimes[n][now_n][now_c+1] = Math.min(times[n][now_n][now_c+1], ntime);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n    \t}\n    }\n     \n    public static void main(String[] args)\n    {\n        Scanner sca = new Scanner(System.in);\n        \n        while(true)\n        {\n        \tN = sca.nextInt();\n        \tM = sca.nextInt();\n        \tif(N == 0) break;\n        \t\n        \tS = sca.nextInt();\n        \tG = sca.nextInt();\n        \t\n        \tD = new int[N+1][N+1];\n        \tC = new int[N+1][N+1];\n        \tfor (int i = 0; i <= N; i++) {\n\t\t\t\tfor (int j = 0; j <= N; j++) {\n\t\t\t\t\tD[i][j] = C[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n        \t\n        \tfor (int i = 0; i < M; i++) {\n\t\t\t\tint x = sca.nextInt();\n\t\t\t\tint y = sca.nextInt();\n\t\t\t\tint d = sca.nextInt();\n\t\t\t\tint c = sca.nextInt();\n\t\t\t\t\n\t\t\t\tD[y][x] = D[x][y] = d;\n\t\t\t\tC[y][x] = C[x][y] = c;\n\t\t\t}\n            \n            start();\n        }\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tint n, m;\n\tint s, g;\n\tint[][] dist, speed;\n\tList<Integer>[] e;\n\n\tclass D implements Comparable<D> {\n\t\tint pos;\n\t\tint spd;\n\t\tint pre;\n\t\tdouble min;\n\n\t\tpublic D(int pos, int spd, int pre, double min) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.spd = spd;\n\t\t\tthis.pre = pre;\n\t\t\tthis.min = min;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(D o) {\n\t\t\tif (this.min != o.min) {\n\t\t\t\tdouble diff = this.min - o.min;\n\t\t\t\treturn diff > 0 ? 1 : -1;\n\t\t\t}\n\t\t\tif (this.pos != o.pos) {\n\t\t\t\treturn this.pos - o.pos;\n\t\t\t}\n\t\t\tif (this.pre != o.pre) {\n\t\t\t\treturn this.pre - o.pre;\n\t\t\t}\n\t\t\tif (this.spd != o.spd) {\n\t\t\t\treturn this.spd - o.spd;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + pos + \", \" + spd + \", \" + min + \")\";\n\t\t}\n\t}\n\n\tdouble dijkstra() {\n\t\tPriorityQueue<D> queue = new PriorityQueue<D>();\n\t\tqueue.add(new D(s, 0, n, 0));\n\t\tboolean[][][] vis = new boolean[n][n + 1][31];\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tD d = queue.poll();\n\t\t\tint pos = d.pos;\n\t\t\tint spd = d.spd;\n\t\t\tint pre = d.pre;\n\t\t\tdouble min = d.min;\n\n\t\t\tif (vis[pos][pre][spd]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis[pos][pre][spd] = true;\n\n\t\t\tif (pos == g && spd == 1) {\n\t\t\t\treturn min;\n\t\t\t}\n\n\t\t\tfor (Integer to : e[pos]) {\n\t\t\t\tint npos = to;\n\t\t\t\tif (npos == pre) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\t\tint nspd = spd + i;\n\t\t\t\t\tif (nspd <= 0 || speed[pos][npos] < nspd) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble nmin = min + (1. * dist[pos][npos] / nspd);\n\t\t\t\t\tqueue.add(new D(npos, nspd, pos, nmin));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\ts = sc.nextInt() - 1;\n\t\t\tg = sc.nextInt() - 1;\n\n\t\t\te = new LinkedList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\te[i] = new LinkedList<Integer>();\n\t\t\t}\n\t\t\tdist = new int[n][n];\n\t\t\tspeed = new int[n][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\te[x].add(y);\n\t\t\t\te[y].add(x);\n\t\t\t\tdist[x][y] = dist[y][x] = d;\n\t\t\t\tspeed[x][y] = speed[y][x] = c;\n\t\t\t}\n\n\t\t\tdouble ans = dijkstra();\n\t\t\tSystem.out.println(ans < 0 ? \"unreachable\" : ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n \npublic class Main {\n    \n\tstatic int N, M;\n\tstatic int S, G;\n\tstatic int[][] D, C;\n\t\n    static void start()\n    {\n    \tdouble[][][] times = new double[N+1][N+1][31];\n    \tboolean[][][] check = new boolean[N+1][N+1][31];\n    \t\n    \tfor (int n = 0; n < N+1; n++) {\n\t\t\tfor (int pren = 0; pren < N+1; pren++) {\n\t\t\t\tfor (int c = 0; c < 31; c++) {\n\t\t\t\t\ttimes[n][pren][c] = Double.MAX_VALUE;\n\t\t\t\t\tcheck[n][pren][c] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \t\n    \t/*PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n    \t\tpublic int compare(int[] a, int[] b)\n    \t\t{\n    \t\t\tdouble ia = times[ a[0] ][ a[1] ][ a[2] ];\n    \t\t\tdouble ib = times[ b[0] ][ b[1] ][ b[2] ];\n    \t\t\tif(ia < ib)\n    \t\t\t\treturn -1;\n    \t\t\telse if(ia == ib)\n    \t\t\t\treturn 0;\n    \t\t\telse {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n    \t\t}\n\t\t});*/\n    \t\n    \tPriorityQueue<int[]> queue = new PriorityQueue<int[]>();\n    \t\n    \ttimes[S][0][1] = 0;\n    \tqueue.offer(new int[]{S, 0, 1});\n    \t\n    \twhile(!queue.isEmpty())\n    \t{\n    \t\tint now_n = 0, now_pren = 0, now_c = 0;\n    \t\t\n    \t\t// スタート位置の決定\n    \t\tint[] qq = queue.poll();\n    \t\tnow_n = qq[0];\n    \t\tnow_pren = qq[1];\n    \t\tnow_c = qq[2];\n    \t\t\n    \t\tif(now_n == G && now_c == 1)\n    \t\t{\n    \t\t\tSystem.out.printf(\"%.05f\\n\", times[now_n][now_pren][now_c]);\n    \t\t\treturn;\n    \t\t}\n    \t\t\n    \t\tif(check[now_n][now_pren][now_c] == true) continue;\n    \t\t\n    \t\t// 処理\n    \t\tcheck[now_n][now_pren][now_c] = true;\n    \t\t\n    \t\tfor (int n = 1; n <= N; n++) {\n    \t\t\tif(now_n == n) continue;\n\t\t\t\tif(now_pren == n) continue;\n\t\t\t\tif(D[now_n][n] < 0) continue;\n\t\t\t\t\n\t\t\t\t// 速度-1\n\t\t\t\tif(1 < now_c)\n\t\t\t\t{\n\t\t\t\t\tif((now_c-1) <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c-1);\n\t\t\t\t\t\tif(ntime < times[n][now_n][now_c-1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttimes[n][now_n][now_c-1] = ntime;\n\t\t\t\t\t\t\tqueue.offer(new int[]{n, now_n, now_c-1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 速度そのまま\n\t\t\t\tif(true)\n\t\t\t\t{\n\t\t\t\t\tif(now_c <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)now_c;\n\t\t\t\t\t\tif(ntime < times[n][now_n][now_c])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttimes[n][now_n][now_c] = ntime;\n\t\t\t\t\t\t\tqueue.offer(new int[]{n, now_n, now_c});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(now_n == S && now_c == 1) continue;\n\t\t\t\t\n\t\t\t\t// 速度+1\n\t\t\t\tif(now_c < 30)\n\t\t\t\t{\n\t\t\t\t\tif((now_c+1) <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c+1);\n\t\t\t\t\t\tif(ntime < times[n][now_n][now_c+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttimes[n][now_n][now_c+1] = ntime;\n\t\t\t\t\t\t\tqueue.offer(new int[]{n, now_n, now_c+1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n    \t}\n    \t\n    \tSystem.out.println(\"unreachable\");\n    }\n     \n    public static void main(String[] args)\n    {\n        Scanner sca = new Scanner(System.in);\n        \n        while(true)\n        {\n        \tN = sca.nextInt();\n        \tM = sca.nextInt();\n        \tif(N == 0) break;\n        \t\n        \tS = sca.nextInt();\n        \tG = sca.nextInt();\n        \t\n        \tD = new int[N+1][N+1];\n        \tC = new int[N+1][N+1];\n        \tfor (int i = 0; i <= N; i++) {\n\t\t\t\tfor (int j = 0; j <= N; j++) {\n\t\t\t\t\tD[i][j] = C[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n        \t\n        \tfor (int i = 0; i < M; i++) {\n\t\t\t\tint x = sca.nextInt();\n\t\t\t\tint y = sca.nextInt();\n\t\t\t\tint d = sca.nextInt();\n\t\t\t\tint c = sca.nextInt();\n\t\t\t\t\n\t\t\t\tD[y][x] = D[x][y] = d;\n\t\t\t\tC[y][x] = C[x][y] = c;\n\t\t\t}\n            \n            start();\n        }\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint g = in.nextInt()-1;\n\t\t\tboolean[][] used = new boolean[n][31];\n\t\t\tint[][] rist = new int[n][n];\n\t\t\tint[][] dist = new int[n][n];\n\t\t\tNode[] node = new Node[n];\n\t\t\tfor(int i=0; i<n; i++) node[i] = new Node(i);\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint x = in.nextInt()-1;\n\t\t\t\tint y = in.nextInt()-1;\n\t\t\t\tint d = in.nextInt();\n\t\t\t\tint c = in.nextInt();\n\t\t\t\tnode[x].createEdge(node[y]);\n\t\t\t\tnode[y].createEdge(node[x]);\n\t\t\t\tdist[x][y] = dist[y][x] = d;\n\t\t\t\trist[x][y] = rist[y][x] = c;\n\t\t\t}\n\t\t\tdouble[][] best = new double[n][31];\n\t\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n\t\t\tqu.add(new Pos(s, -1, 0, 0));\n\t\t\tdouble time = -1;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(p.city == g && p.vel == 1){\n\t\t\t\t\ttime = p.dist;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif((best[p.city][p.vel] != 0\n\t\t\t\t\t\t\t\t&& best[p.city][p.vel] <= p.dist)) continue;\n\t\t\t\tbest[p.city][p.vel] = p.dist;\n\t\t\t\tused[p.city][p.vel] = true;\n\t\t\t\tfor(Node nd: node[p.city].list){\n\t\t\t\t\tif(p.back == nd.id) continue;\n\t\t\t\t\tfor(int i=-1; i<=1; i++){\n\t\t\t\t\t\tint v = p.vel+i;\n\t\t\t\t\t\tif(v < 1 || v > rist[p.city][nd.id]) continue;\n\t\t\t\t\t\tqu.add(new Pos(nd.id, p.city, v, p.dist + (double)dist[p.city][nd.id]/v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(time < 0 ? \"unreachable\" : time);\n\t\t}\n\t}\n}\n\nclass Node{\n\tint id;\n\tList<Node> list = new ArrayList<Node>();\n\tpublic Node(int id){\n\t\tthis.id = id;\n\t}\n\t\n\tpublic void createEdge(Node nd){\n\t\tlist.add(nd);\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tint city;\n\tint back;\n\tint vel;\n\tdouble dist;\n\tpublic Pos(int c, int back, int v, double dist){\n\t\tcity = c;\n\t\tvel = v;\n\t\tthis.back = back;\n\t\tthis.dist = dist;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn Double.compare(dist, o.dist);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n \npublic class Main {\n    \n\tstatic int N, M;\n\tstatic int S, G;\n\tstatic int[][] D, C;\n\t\n    static void start()\n    {\n    \tdouble[][][] times = new double[N+1][N+1][31];\n    \tboolean[][][] check = new boolean[N+1][N+1][31];\n    \t\n    \tfor (int n = 0; n < N+1; n++) {\n\t\t\tfor (int pren = 0; pren < N+1; pren++) {\n\t\t\t\tfor (int c = 0; c < 31; c++) {\n\t\t\t\t\ttimes[n][pren][c] = Double.MAX_VALUE;\n\t\t\t\t\tcheck[n][pren][c] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \t\n    \tPriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n    \t\tpublic int compare(int[] a, int[] b)\n    \t\t{\n    \t\t\tdouble ia = times[ a[0] ][ a[1] ][ a[2] ];\n    \t\t\tdouble ib = times[ b[0] ][ b[1] ][ b[2] ];\n    \t\t\tif(ia < ib)\n    \t\t\t\treturn -1;\n    \t\t\telse if(ia == ib)\n    \t\t\t\treturn 0;\n    \t\t\telse {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n    \t\t}\n\t\t});\n    \t\n    \ttimes[S][0][1] = 0;\n    \tqueue.offer(new int[]{S, 0, 1});\n    \t\n    \twhile(!queue.isEmpty())\n    \t{\n    \t\tint now_n = 0, now_pren = 0, now_c = 0;\n    \t\t\n    \t\t// スタート位置の決定\n    \t\tint[] qq = queue.poll();\n    \t\tnow_n = qq[0];\n    \t\tnow_pren = qq[1];\n    \t\tnow_c = qq[2];\n    \t\t\n    \t\tif(now_n == G && now_c == 1)\n    \t\t{\n    \t\t\tSystem.out.printf(\"%.05f\\n\", times[now_n][now_pren][now_c]);\n    \t\t\treturn;\n    \t\t}\n    \t\t\n    \t\tif(check[now_n][now_pren][now_c] == true) continue;\n    \t\t\n    \t\t// 処理\n    \t\tcheck[now_n][now_pren][now_c] = true;\n    \t\t\n    \t\tfor (int n = 1; n <= N; n++) {\n    \t\t\tif(now_n == n) continue;\n\t\t\t\tif(now_pren == n) continue;\n\t\t\t\tif(D[now_n][n] < 0) continue;\n\t\t\t\t\n\t\t\t\t// 速度-1\n\t\t\t\tif(1 < now_c)\n\t\t\t\t{\n\t\t\t\t\tif((now_c-1) <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c-1);\n\t\t\t\t\t\tif(ntime < times[n][now_n][now_c-1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttimes[n][now_n][now_c-1] = ntime;\n\t\t\t\t\t\t\tint[] next = {n, now_n, now_c-1};\n\t\t\t\t\t\t\tqueue.offer(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 速度そのまま\n\t\t\t\tif(true)\n\t\t\t\t{\n\t\t\t\t\tif(now_c <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)now_c;\n\t\t\t\t\t\tif(ntime < times[n][now_n][now_c])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttimes[n][now_n][now_c] = ntime;\n\t\t\t\t\t\t\tint[] next = {n, now_n, now_c};\n\t\t\t\t\t\t\tqueue.offer(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(now_n == S && now_c == 1) continue;\n\t\t\t\t\n\t\t\t\t// 速度+1\n\t\t\t\tif(now_c < 30)\n\t\t\t\t{\n\t\t\t\t\tif((now_c+1) <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c+1);\n\t\t\t\t\t\tif(ntime < times[n][now_n][now_c+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttimes[n][now_n][now_c+1] = ntime;\n\t\t\t\t\t\t\tint[] next = {n, now_n, now_c+1};\n\t\t\t\t\t\t\tqueue.offer(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n    \t}\n    \t\n    \tSystem.out.println(\"unreachable\");\n    }\n     \n    public static void main(String[] args)\n    {\n        Scanner sca = new Scanner(System.in);\n        \n        while(true)\n        {\n        \tN = sca.nextInt();\n        \tM = sca.nextInt();\n        \tif(N == 0) break;\n        \t\n        \tS = sca.nextInt();\n        \tG = sca.nextInt();\n        \t\n        \tD = new int[N+1][N+1];\n        \tC = new int[N+1][N+1];\n        \tfor (int i = 0; i <= N; i++) {\n\t\t\t\tfor (int j = 0; j <= N; j++) {\n\t\t\t\t\tD[i][j] = C[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n        \t\n        \tfor (int i = 0; i < M; i++) {\n\t\t\t\tint x = sca.nextInt();\n\t\t\t\tint y = sca.nextInt();\n\t\t\t\tint d = sca.nextInt();\n\t\t\t\tint c = sca.nextInt();\n\t\t\t\t\n\t\t\t\tD[y][x] = D[x][y] = d;\n\t\t\t\tC[y][x] = C[x][y] = c;\n\t\t\t}\n            \n            start();\n        }\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "// Discrete Speed\nimport java.util.*;\n\npublic class Main {\n\tstatic final double EPS = 1e-4;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint s = sc.nextInt() - 1, g = sc.nextInt() - 1;\n\t\t\tint[][] d = new int[n][n];\n\t\t\tint[][] l = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(d[i], 0);\n\t\t\t\tArrays.fill(l[i], 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() - 1, y = sc.nextInt() - 1;\n\t\t\t\tint td = sc.nextInt();\n\t\t\t\tint tc = sc.nextInt();\n\t\t\t\td[x][y] = td;\n\t\t\t\td[y][x] = td;\n\t\t\t\tl[x][y] = tc;\n\t\t\t\tl[y][x] = tc;\n\t\t\t}\n\t\t\tdouble[][] costs = new double[n][31];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tArrays.fill(costs[i], -1);\n\t\t\tPriorityQueue<Node> queue = new PriorityQueue<Node>();\n\t\t\tqueue.add(new Node(s, 0, 0, -1));\n\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\tNode node = queue.poll();\n\t\t\t\tint tn = node.num;\n\t\t\t\tdouble tc = node.cost;\n\t\t\t\tint tv = node.v;\n\t\t\t\tint tb = node.before;\n\t\t\t\tif (costs[tn][tv] > 0 && costs[tn][tv] < tc-EPS)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tcosts[tn][tv] = tc;\n\t\t\t\tif (tn == g && tv == 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (d[tn][i] >= 0 && i != tb) {\n\t\t\t\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\t\t\t\tint v = tv + j;\n\t\t\t\t\t\t\tdouble c = (double) d[tn][i] / v;\n\t\t\t\t\t\t\tif (v >= 1 && v <= l[tn][i])\n\t\t\t\t\t\t\t\tqueue.add(new Node(i, tc + c, v, tn));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (costs[g][1] == -1)\n\t\t\t\tSystem.out.println(\"unreachable\");\n\t\t\telse\n\t\t\t\tSystem.out.println(costs[g][1]);\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic class Node implements Comparable<Node> {\n\t\tint num, v, before;\n\t\tdouble cost;\n\n\t\tNode(int n, double c, int tv, int b) {\n\t\t\tnum = n;\n\t\t\tcost = c;\n\t\t\tv = tv;\n\t\t\tbefore = b;\n\t\t}\n\n\t\tpublic int compareTo(Node anotherNode) {\n\t\t\treturn this.cost < anotherNode.cost ? -1 : 1;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static char[] s;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint g = in.nextInt()-1;\n\t\t\tboolean[][] used = new boolean[n][31];\n\t\t\tint[][] rist = new int[n][n];\n\t\t\tint[][] dist = new int[n][n];\n\t\t\tNode[] node = new Node[n];\n\t\t\tfor(int i=0; i<n; i++) node[i] = new Node(i);\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint x = in.nextInt()-1;\n\t\t\t\tint y = in.nextInt()-1;\n\t\t\t\tint d = in.nextInt();\n\t\t\t\tint c = in.nextInt();\n\t\t\t\tnode[x].createEdge(node[y]);\n\t\t\t\tnode[y].createEdge(node[x]);\n\t\t\t\tdist[x][y] = dist[y][x] = d;\n\t\t\t\trist[x][y] = rist[y][x] = c;\n\t\t\t}\n\t\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n\t\t\tqu.add(new Pos(s, 0, 0));\n\t\t\tdouble time = -1;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(used[p.city][p.vel]) continue;\n\t\t\t\tif(p.city == g && p.vel == 1){\n\t\t\t\t\ttime = p.dist;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tused[p.city][p.vel] = true;\n\t\t\t\tfor(Node nd: node[p.city].list){\n\t\t\t\t\tfor(int i=-1; i<=1; i++){\n\t\t\t\t\t\tint v = p.vel+i;\n\t\t\t\t\t\tif(v < 1 || v > rist[p.city][nd.id]) continue;\n\t\t\t\t\t\tqu.add(new Pos(nd.id, v, p.dist + (double)dist[p.city][nd.id]/v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(time < 0 ? \"unreachable\" : time);\n\t\t}\n\t}\n}\n\nclass Node{\n\tint id;\n\tList<Node> list = new ArrayList<Node>();\n\tpublic Node(int id){\n\t\tthis.id = id;\n\t}\n\t\n\tpublic void createEdge(Node nd){\n\t\tlist.add(nd);\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tint city;\n\tint vel;\n\tdouble dist;\n\tpublic Pos(int c, int v, double dist){\n\t\tcity = c;\n\t\tvel = v;\n\t\tthis.dist = dist;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn Double.compare(dist, o.dist);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int n,m,s,g;\n\tstatic boolean[][][] visited;   //node,pref,v\n\tstatic double[][][] cost;       //node,pref,v\n\tstatic int[][] D,C;\n\tstatic int[] dspeed = {-1, 0, 1};\n\tstatic final int INF = (1 << 21);\n\n\tpublic static void main(String[] args) {\n\t\twhile(read()) {\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tstatic boolean read() {\n\t\tn = sc.nextInt(); m = sc.nextInt();\n\t\tif(n == 0 && m == 0) return false;\n\t\ts = sc.nextInt(); g = sc.nextInt();\n\t\tD = new int[n+1][n+1]; C = new int[n+1][n+1];\n\t\tfor(int v = 0; v < n+1; v++) {\n\t\t\tArrays.fill(D[v], INF);\n\t\t\tArrays.fill(C[v], INF);\n\t\t}\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint x = sc.nextInt(), y = sc.nextInt(), d = sc.nextInt(), c = sc.nextInt();\n\t\t\tD[y][x] = D[x][y] = d;\n\t\t\tC[y][x] = C[x][y] = c;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic void solve() {\n\t\tcost = new double[n+1][n+1][30+1];\n\t\tfor(int i = 0; i < n+1; i++) for(int j = 0; j < n+1; j++) Arrays.fill(cost[i][j], INF);\n\t\tPriorityQueue<IState> que = new PriorityQueue<IState>();\n\t\tfor(int v = 1; v <= n; v++) {\n\t\t\tif(D[s][v] == INF) continue;\n\t\t\tcost[v][s][1] = D[s][v] / 1.0;\n\t\t\tIState st = new Main().new IState(v,s,1, D[s][v] / 1.0);\n\t\t\tque.add(st);\n\t\t}\n\t\twhile(!que.isEmpty()) {\n\t\t\tIState u = que.poll();\n\t\t\tif(u.node == g && u.speed == 1) {\n\t\t\t\tSystem.out.printf(\"%.5f\\n\", cost[u.node][u.pref][u.speed]);\n\t\t\t\treturn;\n\t\t\t}\n \t\t\tfor(int v = 1; v <= n; v++) {\n\t\t\t\tif(D[u.node][v] == INF) continue;\n\t\t\t\tfor(int k = 0; k < 3; k++) {\n\t\t\t\t\tint nspeed = u.speed + dspeed[k];\n\t\t\t\t\tif(nspeed > C[u.node][v] || v == u.pref) continue;\n\t\t\t\t\tdouble new_cost = cost[u.node][u.pref][u.speed] + D[u.node][v] / (double)nspeed;\n\t\t\t\t\tif(new_cost < cost[v][u.node][nspeed]) {\n\t\t\t\t\t\tcost[v][u.node][nspeed] = new_cost;\n\t\t\t\t\t\tIState st = new Main().new IState(v, u.node, nspeed, new_cost);\n\t\t\t\t\t\tque.add(st);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"unreachable\");\n\t}\n\n\tpublic class IState implements Comparable<IState>{\n\t\tint node,pref,speed;\n\t\tdouble cost;\n\t\tIState(int node, int pref, int speed, double cost) {\n\t\t\tthis.node = node; this.pref = pref; this.speed = speed; this.cost = cost;\n\t\t}\n\t\tpublic int compareTo(IState s) {\n\t\t\tif(this.cost < s.cost) {\n\t\t\t\treturn -1;\n\t\t\t} else if(this.cost > s.cost) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"\" + node + \" \" + pref + \" \" + speed + \" \" + cost;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "// Discrete Speed\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint s = sc.nextInt() - 1, g = sc.nextInt() - 1;\n\t\t\tint[][] d = new int[n][n];\n\t\t\tint[][] l = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(d[i], 0);\n\t\t\t\tArrays.fill(l[i], 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() - 1, y = sc.nextInt() - 1;\n\t\t\t\tint td = sc.nextInt();\n\t\t\t\tint tc = sc.nextInt();\n\t\t\t\td[x][y] = td;\n\t\t\t\td[y][x] = td;\n\t\t\t\tl[x][y] = tc;\n\t\t\t\tl[y][x] = tc;\n\t\t\t}\n\t\t\tdouble[][] costs = new double[n][31];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tArrays.fill(costs[i], -1);\n\t\t\tPriorityQueue<Node> queue = new PriorityQueue<Node>();\n\t\t\tqueue.add(new Node(s, 0, 0, -1));\n\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\tNode node = queue.poll();\n\t\t\t\tint tn = node.num;\n\t\t\t\tdouble tc = node.cost;\n\t\t\t\tint tv = node.v;\n\t\t\t\tint tb = node.before;\n\t\t\t\tif (costs[tn][tv] > 0 && costs[tn][tv] < tc)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tcosts[tn][tv] = tc;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (d[tn][i] >= 0 && i != tb) {\n\t\t\t\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\t\t\t\tint v = tv + j;\n\t\t\t\t\t\t\tdouble c = (double) d[tn][i] / v;\n\t\t\t\t\t\t\tif (v >= 1 && v <= l[tn][i])\n\t\t\t\t\t\t\t\tqueue.add(new Node(i, tc + c, v, tn));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (costs[g][1] == -1)\n\t\t\t\tSystem.out.println(\"unreachable\");\n\t\t\telse\n\t\t\t\tSystem.out.println(costs[g][1]);\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic class Node implements Comparable<Node> {\n\t\tint num, v, before;\n\t\tdouble cost;\n\n\t\tNode(int n, double c, int tv, int b) {\n\t\t\tnum = n;\n\t\t\tcost = c;\n\t\t\tv = tv;\n\t\t\tbefore = b;\n\t\t}\n\n\t\tpublic int compareTo(Node anotherNode) {\n\t\t\treturn this.cost < anotherNode.cost ? -1 : 1;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Descrete Speed\npublic class Main{\n\n\tpublic static int n;\n\tpublic static int m;\n\tpublic static int start;\n\tpublic static int goal;\n\n\tpublic static double[][][] dist;\n\tpublic static int[][] r;\n\tpublic static int[][] limit;\n\n\tpublic static int zip(int a, int b, int c){\n\t\treturn a<<10|b<<5|c;\n\t}\n\n\tpublic static int[] unzip(int a){\n\t\tint[] r = new int[3];\n\t\tr[2] = a&31;\n\t\ta >>= 5;\n\t\tr[1] = a&31;\n\t\tr[0] = a>>5;\n\t\treturn r;\n\t}\n\n\tpublic static double dijkstra(){\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tfor(int k=0;k<31;k++)\n\t\t\t\t\tdist[i][j][k] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tdist[1][0][0] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>(){\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\tint[] a = unzip(o1);\n\t\t\t\tint[] b = unzip(o2);\n\t\t\t\treturn dist[a[0]][a[1]][a[2]]-dist[b[0]][b[1]][b[2]]<0?-1:dist[a[0]][a[1]][a[2]]-dist[b[0]][b[1]][b[2]]>0?1:0;\n\t\t\t}\n\t\t});\n\t\tq.add(zip(1, 0, 0));\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] uu = unzip(q.poll());\n\t\t\tint u = uu[0];\n\t\t\tint pre = uu[1];\n\t\t\tint v = uu[2];\n\t\t\tif(u==goal&&v==1)return dist[u][pre][v];\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(i!=pre && r[u][i]!=-1){\n\t\t\t\t\tfor(int x=v-1;x<=v+1;x++){\n\t\t\t\t\t\tif(x<=0)continue;\n\t\t\t\t\t\tif(x>limit[u][i])continue;\n\t\t\t\t\t\tdouble nc = dist[u][pre][v] + r[u][i]*1.0/x;\n\t\t\t\t\t\tif(nc < dist[i][u][x]){\n\t\t\t\t\t\t\tdist[i][u][x] = nc;\n\t\t\t\t\t\t\tq.add(zip(i,u,x));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif(n==0&&m==0)break;\n\t\t\tdist = new double[n+1][n+1][31];\n\t\t\tr = new int[n+1][n+1];\n\t\t\tfor(int[]a:r)Arrays.fill(a, -1);\n\t\t\tlimit = new int[n+1][n+1];\n\t\t\tstart = sc.nextInt();\n\t\t\tgoal = sc.nextInt();\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint u = sc.nextInt();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tr[u][v] = r[v][u] = d;\n\t\t\t\tlimit[u][v] = limit[v][u] = l;\n\t\t\t}\n\t\t\tdouble ans = dijkstra();\n\t\t\tif(ans==-1)System.out.println(\"unreachable\");\n\t\t\telse System.out.printf(\"%.5f\\n\", ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tint m = ir.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\treturn;\n\t\t\tint a = ir.nextInt() - 1;\n\t\t\tint b = ir.nextInt() - 1;\n\t\t\tGraph[] g1 = new Graph[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tg1[i] = new Graph();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = ir.nextInt() - 1;\n\t\t\t\tint y = ir.nextInt() - 1;\n\t\t\t\tint d = ir.nextInt();\n\t\t\t\tint c = ir.nextInt();\n\t\t\t\tg1[x].add(new double[] { y, d, c });\n\t\t\t\tg1[y].add(new double[] { x, d, c });\n\t\t\t}\n\t\t\tGraph[] g2 = new Graph[31 * n];\n\t\t\tfor (int i = 0; i < 31 * n; i++)\n\t\t\t\tg2[i] = new Graph();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < g1[i].size(); j++) {\n\t\t\t\t\tint to = (int) g1[i].get(j)[0];\n\t\t\t\t\tfor (int k = 0; k <= 30; k++) {\n\t\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\t\tif (k + l >= 1 && k + l <= (int) g1[i].get(j)[2]) {\n\t\t\t\t\t\t\t\tg2[i * 31 + k].add(new double[] { to * 31 + k + l, g1[i].get(j)[1] / (k + l) });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble ret = dijkstra(a * 31, g2)[b * 31 + 1];\n\t\t\tout.println(ret == 1e9 ? \"unreachable\" : ret);\n\t\t}\n\t}\n\n\tprivate static double[] dijkstra(int s, Graph[] g) {\n\t\tdouble[] d = new double[g.length];\n\t\tPriorityQueue<double[]> pq = new PriorityQueue<double[]>(new Comparator<double[]>() {\n\t\t\tpublic int compare(double[] a, double[] b) {\n\t\t\t\treturn Double.compare(a[1], b[1]);\n\t\t\t}\n\t\t});\n\t\tArrays.fill(d, 1e9);\n\t\td[s] = 0;\n\t\tpq.offer(new double[] { s, 0, -1 });\n\t\twhile (!pq.isEmpty()) {\n\t\t\tdouble[] p = pq.poll();\n\t\t\tint from = (int) p[0];\n\t\t\tfor (int i = 0; i < g[from].size(); i++) {\n\t\t\t\tdouble[] e = g[from].get(i);\n\t\t\t\tint to = (int) e[0];\n\t\t\t\tif (to / 31 != (int) p[2] && d[to] > d[from] + e[1]) {\n\t\t\t\t\td[to] = d[from] + e[1];\n\t\t\t\t\tpq.offer(new double[] { to, d[to], from / 31 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tstatic class Graph extends ArrayList<double[]> {\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint MAX = 30;\n\tdouble EPS = 1e-5;\n\tint n, m;\n\tint s, g;\n\tint map[][];\n\tint lim[][];\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\ts = sc.nextInt()-1;\n\t\t\tg = sc.nextInt()-1;\n\t\t\tmap = new int[n][n];\n\t\t\tlim = new int[n][n];\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint a = sc.nextInt()-1;\n\t\t\t\tint b = sc.nextInt()-1;\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tmap[a][b] = map[b][a] = d;\n\t\t\t\tlim[a][b] = lim[b][a] = l;\n\t\t\t}\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\tint dv[] = {-1,0,1};\n\tString dijkstra() {\n\t\tdouble t[][][] = new double[n][n+1][MAX+1];\n\t\tfor(double[][] a:t ) for(double[] b:  a) fill(b, INF);\n\t\tt[s][n][0] = 0;\n\t\tPriorityQueue<Pair> que = new PriorityQueue<Pair>(1, new MyComp());\n\t\tPair now = new Pair(s, -1, 1, 0, 0);\n\t\tque.add(now);\n\t\tfor(;!que.isEmpty();) {\n\t\t\tnow = que.remove();\n//\t\t\tdebug(que);\n\t\t\tdebug(now.p, now.past_p, now.v, now.t);\n\t\t\tif( now.p == g && now.past_v == 1 ) return String.valueOf(now.t);\n\t\t\tif( 0 == now.v ) continue;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif( map[now.p][i] == 0 || now.p == i || now.past_p == i) continue;\n\t\t\t\tif( now.v > lim[now.p][i] ) continue;\n\t\t\t\tdouble time = now.t + (double)map[now.p][i] / now.v;\n//\t\t\t\tdebug(now.p, i, map[now.p][i]*1.0/now.v);\n\t\t\t\tif(time < t[i][now.p][now.v]) {\n\t\t\t\t\tfor(int j=0;j<3;j++) {\n\t\t\t\t\t\tif( now.v + dv[j] >= 0 ) {\t\t\t\t\t\n\t\t\t\t\t\t\tque.add(new Pair(i, now.p, now.v+dv[j], now.v, time));\n//\t\t\t\t\t\t\tdebug(i, now.p, now.v+dv[j], time);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt[i][now.p][now.v] = time;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"unreachable\";\n\t}\n\t\n\tclass Pair {\n\t\tint p, v, past_p, past_v;\n\t\tdouble t;\n\t\tPair(int p, int past_p, int v, int past_v, double t) {\n\t\t\tthis.p = p;\n\t\t\tthis.v = v;\n\t\t\tthis.t = t;\n\t\t\tthis.past_p = past_p;\n\t\t\tthis.past_v = past_v;\n\t\t}\n\t}\n\t\n\tclass MyComp implements Comparator<Pair> {\n\n\t\t@Override\n\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつスツδソツッツドツ・ツスツタツブ\n\t\t\tif(o1.t > o2.t ) return 1;\n\t\t\telse if(o1.t < o2.t) return -1;\n\t\t\treturn o1.v - o2.v;\n\t\t}\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n \n    static int start, goal;             // スタート都市、ゴール都市\n    static int n_city, m_road;      // 都市の数、道の数\n    static int[][] road_dist;           // 道の距離情報\n    static int[][] speed_limit;     // 道の制限速度情報\n    static double[][][] city;           // ダイクストラ　最短時間保管表\n    static boolean[][][] enter;     // ダイクストラ　最短時間確定\n    static final int speed_law = 30;\n    static double ans2;\n    static int[][][] pre;\n     \n    // ダイクストラアルゴリズム\n    static double Dijkstra(){\n        // 初期設定。最短時間をMAX値で初期化。\n        city = new double[n_city+1][n_city+1][speed_law+1];\n        enter = new boolean[n_city+1][n_city+1][speed_law+1];\n//        pre = new int[n_city+1][n_city+1][speed_law+1];\n        for(int i=0;i<=n_city;i++){\n            for(int j=0;j<=n_city;j++){\n                for(int k=0;k<=speed_law;k++){\n                    city[i][j][k] = Double.MAX_VALUE;\n                }\n            }\n        }\n        city[start][start][1] = 0;      // スタート→スタートで速度1の場合、所要時間0\n        // ループアルゴ(状態遷移を次々と決める)\n        //  cf. 状態遷移とは「ある都市→ある都市の移動(速度も含む)」\n        while(true){\n            // 最短時間表から最も最短時間な状態遷移を探す\n            double fast = Double.MAX_VALUE;\n            int x, y, z;        // fastのindex\n            x = y = z = -1;\n            for(int i=1;i<=n_city;i++){\n                for(int j=1;j<=n_city;j++){\n                    for(int k=1;k<=speed_law;k++){\n                        if(!enter[i][j][k]&&city[i][j][k]<fast){     // 確定されてない & 最短時間\n                            fast = city[i][j][k];\n                            x = i;  y = j;  z = k;      // 設定されるxはstartと同値が既知\n                        }\n                    }\n                }\n            }\n            // 表において探した最も最短時間な状態遷移が、\n            //      スタート→ゴールで速度が1の場合は解が得られる\n//            System.out.println(\"time=\"+city[x][y][z]);\n            if(y==goal&&z==1){\n            \tans2 = Math.min(ans2, city[x][y][z]);\n                return city[x][y][1];\n            }\n            // 最短時間の更新が一度もされない→状態遷移がすべて確定してしまった\n            //  (ゴールに辿りつける道がない or ゴール時に速度が1とならない)\n            else if(x==-1){\n                break;\n            }\n            enter[x][y][z] = true;      // 探した最短時間状態遷移を確定する\n//          System.out.println(\"enter : x=\"+x+\", y=\"+y+\", z=\"+z+\" pre=\"+pre[x][y][z]+\" time=\"+city[x][y][z]);\n            // 確定した状態遷移から移動できる都市を更新しにいく (yからnexの移動)\n            for(int nex=1;nex<=n_city;nex++){        // nex = 遷移先(次)\n                // 速度3パターン(-1,0,1)、zは元の速度、spdは遷移時の速度\n            \tif(x==nex){\n            \t\tcontinue;\n            \t}\n                for(int spd=z-1;spd<=z+1;spd++){\n                    // スピード負値、制限速度オーバー、道路がない　場合は除外\n                    if(spd<=0||spd>speed_limit[y][nex]||road_dist[y][nex]==Double.MAX_VALUE){\n                        continue;\n                    }\n                    // スタート地点から出る道とゴール地点に到達する道は必ず速度1 (この問題においての超重要点)\n                    //  さらには今来た道なら引き返しなのでNG(x->y y->nex(x) ... x=nex=start)\n                    //      さらには状態遷移が決定していれば更新の必要性はない\n                    if(x==start&&y==start&&z==1&&spd!=1){\n//                      System.out.println(\"s=\"+start+\" g=\"+goal+\" y=\"+y+\" z=\"+z+\" nex=\"+nex+\" spd=\"+spd);\n                        continue;\n                    }\n//                  System.out.println(\"connect : x=\"+x+\" y=\"+y+\", nex=\"+nex+\", spd=\"+spd);\n                    // 時間 = 距離 / 速度\n                  if(city[y][nex][spd]>city[x][y][z] + road_dist[y][nex]*1.0/spd){\n                \t  city[y][nex][spd] = city[x][y][z] + road_dist[y][nex]*1.0/spd; \n                  }\n                                  \n                  \n                  \n//                    city[x][nex][spd] = Math.min(city[x][y][z] + road_dist[y][nex]*1.0/spd , city[x][nex][spd]);\n                }\n            }\n        }\n//        System.out.println(ans2);\n        return -1;\n    }\n     \n    public static void main(String[] args) {\n        Scanner stdIn = new Scanner(System.in);\n        while(true){\n            n_city = stdIn.nextInt();\n            m_road = stdIn.nextInt();\n            if((n_city|m_road)==0){\n                return;\n            }\n            start = stdIn.nextInt();\n            goal = stdIn.nextInt();\n            road_dist = new int[n_city+1][n_city+1];\n            speed_limit = new int[n_city+1][n_city+1];\n            for(int i=0;i<m_road;i++){\n                int x = stdIn.nextInt();\n                int y = stdIn.nextInt();\n                int d = stdIn.nextInt();\n                int c = stdIn.nextInt();\n                road_dist[x][y] = road_dist[y][x] = d;\n                speed_limit[x][y] = speed_limit[y][x] = c;\n            }\n            ans2 = 10000000;\n            double ans = Dijkstra();\n            if(ans2!=10000000){\n                System.out.printf(\"%.5f\\n\",ans2);\n            }\n            else{\n                System.out.println(\"unreachable\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tint [] xdis = {0,1,0,-1};\n\tint [] ydis = {1,0,-1,0};\n\tclass C implements Comparable<C>{\n\t\tint v,town,lasttown;\n\t\tdouble time;\n\t\tpublic C(int v, int town, int lasttown, double time) {\n\t\t\tthis.v = v;\tthis.town = town;this.lasttown = lasttown;this.time = time;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(C o) {\n\t\t\tif(time < o.time) return -1;\n\t\t\tif(time > o.time) return 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tprivate double getT(int dis, int v){\n\t\tdouble res = (double) dis / v;\n\t\treturn res;\n\t}\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\t\t\tint [][] pass = new int[n+1][n+1];\n\t\t\tint [][] maxs = new int[n+1][n+1];\n\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\tArrays.fill(pass[i], INF);\n\t\t\t\tArrays.fill(maxs[i], INF);\n\t\t\t}\n\t\t\tfor(int i=0; i < m; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tpass[x][y] = d; pass[y][x] = d;\n\t\t\t\tmaxs[x][y] = c; maxs[y][x] = c;\n\t\t\t}\n\t\t\tPriorityQueue<C> open = new PriorityQueue<C>();\n\t\t\topen.add(new C(1,s,-1,0.0));\n\t\t\tdouble [][] close = new double[n+1][31];\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tArrays.fill(close[i], INF);\n\t\t\t}\n\t\t\tclose[0][0] = 0.0;\n\t\t\tdouble ans = INF;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\t\n\t\t\t\tfor(int speed = -1; speed <= 1; speed++){\n\t\t\t\t\tint v = now.v + speed;\n\t\t\t\t\tif(now.lasttown == -1 && v != 1) continue;\n\t\t\t\t\tif(! (0 < v && v < 31)) continue;\n\t\t\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\t\t\tif(pass[now.town][i] == INF) continue;\n\t\t\t\t\t\tif(i == now.lasttown) continue;\n\t\t\t\t\t\tif(maxs[now.town][i] < v) continue;\n\t\t\t\t\t\tint dis = pass[now.town][i];\n\t\t\t\t\t\tdouble nexttime = now.time + getT(dis,v);\n\t\t\t\t\t\tif(close[i][v] <= nexttime) continue;\n\t\t\t\t\t\tif(i == g && v == 1){\n\t\t\t\t\t\t\tans = Math.min(ans, nexttime);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\topen.add(new C(v, i, now.town, nexttime));\n\t\t\t\t\t\tclose[i][v] = nexttime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.print(\"ANS=\");\n\t\t\tif(ans == INF){\n\t\t\t\tSystem.out.println(\"unreachable\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.printf(\"%1.5f\\n\",ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n  \npublic class Main {\n     \n    static int N, M;\n    static int S, G;\n    static int[][] D, C;\n     \n    static void start()\n    {\n        double[][][] times = new double[N+1][N+1][31];\n        boolean[][][] check = new boolean[N+1][N+1][31];\n         \n        for (int n = 0; n < N+1; n++) {\n            for (int pren = 0; pren < N+1; pren++) {\n                for (int c = 0; c < 31; c++) {\n                    times[n][pren][c] = Double.MAX_VALUE;\n                    check[n][pren][c] = false;\n                }\n            }\n        }\n         \n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] a, int[] b)\n            {\n                double ia = times[ a[0] ][ a[1] ][ a[2] ];\n                double ib = times[ b[0] ][ b[1] ][ b[2] ];\n                if(ia < ib)\n                    return -1;\n                else if(ia == ib)\n                    return 0;\n                else {\n                    return 1;\n                }\n            }\n        });\n         \n        times[S][0][1] = 0;\n        queue.offer(new int[]{S, 0, 1});\n         \n        while(!queue.isEmpty())\n        {\n            int now_n = 0, now_pren = 0, now_c = 0;\n             \n            // スタート位置の決定\n            int[] qq = queue.poll();\n            now_n = qq[0];\n            now_pren = qq[1];\n            now_c = qq[2];\n             \n            if(now_n == G && now_c == 1)\n            {\n                System.out.printf(\"%.05f\\n\", times[now_n][now_pren][now_c]);\n                return;\n            }\n             \n            if(check[now_n][now_pren][now_c] == true) continue;\n             \n            // 処理\n            check[now_n][now_pren][now_c] = true;\n             \n            for (int n = 1; n <= N; n++) {\n                if(now_n == n) continue;\n                if(now_pren == n) continue;\n                if(D[now_n][n] < 0) continue;\n                 \n                // 速度-1\n                if(1 < now_c)\n                {\n                    if((now_c-1) <= C[now_n][n])\n                    {\n                        double ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c-1);\n                        if(ntime < times[n][now_n][now_c-1])\n                        {\n                            times[n][now_n][now_c-1] = ntime;\n                            queue.offer(new int[]{n, now_n, now_c-1});\n                        }\n                    }\n                }\n                 \n                // 速度そのまま\n                if(true)\n                {\n                    if(now_c <= C[now_n][n])\n                    {\n                        double ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)now_c;\n                        if(ntime < times[n][now_n][now_c])\n                        {\n                            times[n][now_n][now_c] = ntime;\n                            queue.offer(new int[]{n, now_n, now_c});\n                        }\n                    }\n                }\n                 \n                if(now_n == S && now_c == 1) continue;\n                 \n                // 速度+1\n                if(now_c < 30)\n                {\n                    if((now_c+1) <= C[now_n][n])\n                    {\n                        double ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c+1);\n                        if(ntime < times[n][now_n][now_c+1])\n                        {\n                            times[n][now_n][now_c+1] = ntime;\n                            queue.offer(new int[]{n, now_n, now_c+1});\n                        }\n                    }\n                }\n            }\n        }\n         \n        System.out.println(\"unreachable\");\n    }\n      \n    public static void main(String[] args)\n    {\n        Scanner sca = new Scanner(System.in);\n         \n        while(true)\n        {\n            N = sca.nextInt();\n            M = sca.nextInt();\n            if(N == 0) break;\n             \n            S = sca.nextInt();\n            G = sca.nextInt();\n             \n            D = new int[N+1][N+1];\n            C = new int[N+1][N+1];\n            for (int i = 0; i <= N; i++) {\n                for (int j = 0; j <= N; j++) {\n                    D[i][j] = C[i][j] = -1;\n                }\n            }\n             \n            for (int i = 0; i < M; i++) {\n                int x = sca.nextInt();\n                int y = sca.nextInt();\n                int d = sca.nextInt();\n                int c = sca.nextInt();\n                 \n                D[y][x] = D[x][y] = d;\n                C[y][x] = C[x][y] = c;\n            }\n             \n            start();\n        }\n         \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      int m = ni();\n      if (n == 0) {\n        break;\n      }\n      int s = ni();\n      int g = ni();\n      int[] x = new int[m + 1];\n      int[] y = new int[m + 1];\n      int[] d = new int[m + 1];\n      int[] c = new int[m + 1];\n      for (int i = 1; i <= m; ++i) {\n        x[i] = ni();\n        y[i] = ni();\n        d[i] = ni();\n        c[i] = ni();\n      }\n      ArrayList<LinkedList<Data>> list = new ArrayList<>();\n      for (int i = 0; i <= n; ++i) {\n        list.add(new LinkedList<>());\n      }\n      for (int i = 1; i <= m; ++i) {\n        Data left = new Data();\n        left.dist = y[i];\n        left.kyori = d[i];\n        left.seigen = c[i];\n        list.get(x[i]).add(left);\n        Data right = new Data();\n        right.dist = x[i];\n        right.kyori = d[i];\n        right.seigen = c[i];\n        list.get(y[i]).add(right);\n      }\n      Check atom = new Check();\n      atom.now = s;\n      atom.v = -1;\n      TreeSet<Check> done = new TreeSet<>();\n      done.add(atom);\n      Node btom = new Node();\n      btom.check = atom;\n      btom.time = 0;\n      PriorityQueue<Node> queue = new PriorityQueue<>(\n          (a, b) -> {\n            if (a.time != b.time) {\n              return Double.compare(a.time, b.time);\n            }\n            return Integer.compare(a.check.v, b.check.v);\n          }\n      );\n      queue.add(btom);\n      boolean flag = false;\n      double ans = -1;\n      while (queue.size() > 0) {\n        Node node = queue.poll();\n        if (node.check.now == g && node.check.v == 1) {\n          flag = true;\n          ans = node.time;\n          break;\n        }\n        for (Data ite : list.get(node.check.now)) {\n          for (int add = -1; add <= 1; ++add) {\n            int nv;\n            if (node.check.v == -1) {\n              nv = 1;\n            } else {\n              nv = node.check.v + add;\n            }\n            if (nv <= 0 || ite.seigen < nv) {\n              continue;\n            }\n            double nt = node.time + (double) ite.kyori / nv;\n\n            Check check = new Check();\n            check.now = ite.dist;\n            check.v = nv;\n            if (done.contains(check)) {\n              continue;\n            }\n            done.add(check);\n\n            Node next = new Node();\n            next.check = check;\n            next.time = nt;\n            queue.add(next);\n          }\n        }\n      }\n      if (flag) {\n        System.out.println(ans);\n      } else {\n        System.out.println(\"unreachable\");\n      }\n    }\n  }\n\n  class Check implements Comparable<Check> {\n    int now;\n    int v;\n\n    @Override\n    public int compareTo(Check ch) {\n      if (now != ch.now) {\n        return now - ch.now;\n      }\n      return v - ch.v;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o.getClass() != this.getClass()) {\n        return false;\n      }\n      Check ch = (Check) o;\n      return this.compareTo(ch) == 0;\n    }\n  }\n\n  class Node {\n    Check check;\n    double time;\n  }\n\n  class Data {\n    int dist;\n    int kyori;\n    int seigen;\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tint m = ir.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\treturn;\n\t\t\tint a = ir.nextInt() - 1;\n\t\t\tint b = ir.nextInt() - 1;\n\t\t\tGraph[] g1 = new Graph[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tg1[i] = new Graph();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = ir.nextInt() - 1;\n\t\t\t\tint y = ir.nextInt() - 1;\n\t\t\t\tint d = ir.nextInt();\n\t\t\t\tint c = ir.nextInt();\n\t\t\t\tg1[x].add(new double[] { y, d, c });\n\t\t\t\tg1[y].add(new double[] { x, d, c });\n\t\t\t}\n\t\t\tGraph[] g2 = new Graph[31 * n];\n\t\t\tfor (int i = 0; i < 31 * n; i++)\n\t\t\t\tg2[i] = new Graph();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < g1[i].size(); j++) {\n\t\t\t\t\tint to = (int) g1[i].get(j)[0];\n\t\t\t\t\tfor (int k = 0; k <= 30; k++) {\n\t\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\t\tif (k + l >= 1 && k + l <= (int) g1[i].get(j)[2]) {\n\t\t\t\t\t\t\t\tg2[i * 31 + k].add(new double[] { to * 31 + k + l, g1[i].get(j)[1] / (k + l) });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble ret = dijkstra(a * 31, g2)[b * 31 + 1];\n\t\t\tout.println(ret == 1e9 ? \"unreachable\" : ret);\n\t\t}\n\t}\n\n\tprivate static double[] dijkstra(int s, Graph[] g) {\n\t\tdouble[] d = new double[g.length];\n\t\tPriorityQueue<double[]> pq = new PriorityQueue<double[]>(new Comparator<double[]>() {\n\t\t\tpublic int compare(double[] a, double[] b) {\n\t\t\t\treturn Double.compare(a[1], b[1]);\n\t\t\t}\n\t\t});\n\t\tArrays.fill(d, 1e9);\n\t\td[s] = 0;\n\t\tpq.offer(new double[] { s, 0, -1 });\n\t\twhile (!pq.isEmpty()) {\n\t\t\tdouble[] p = pq.poll();\n\t\t\tint from = (int) p[0];\n\t\t\tfor (int i = 0; i < g[from].size(); i++) {\n\t\t\t\tdouble[] e = g[from].get(i);\n\t\t\t\tint to = (int) e[0];\n\t\t\t\tif (to / 30 != (int) p[2] && d[to] > d[from] + e[1]) {\n\t\t\t\t\td[to] = d[from] + e[1];\n\t\t\t\t\tpq.offer(new double[] { to, d[to], from });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tstatic class Graph extends ArrayList<double[]> {\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\twhile (read())\n\t\t\tsolve();\n\t}\n\t\n\tstatic int N, M, S, G;\n\tstatic final double EPS = 1e-8;\n\tstatic final int    INF = 1 << 20;\n\tstatic int[][] W = new int[31][31], C = new int[31][31];\n\tstatic boolean read() {\n\t\tN = sc.nextInt(); M = sc.nextInt();\n\t\tif (N == 0) return false;\n\t\t\n\t\tS = sc.nextInt(); G = sc.nextInt();\n\t\tfor (int i = 0; i < 31; i++) {\n\t\t\tfill(W[i], INF);\n\t\t\tW[i][i] = 0;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\td = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tW[x][y] = W[y][x] = d;\n\t\t\tC[x][y] = C[y][x] = c;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tstatic void solve() {\n\t\tdouble[][][] cost = new double[31][31][31];\n\t\tfor (int i = 0; i < 31; i++)\n\t\t\tfor (int j = 0; j < 31; j++)\n\t\t\t\tfill(cost[i][j], INF);\n\t\t\n\t\tPriorityQueue<State> que = new PriorityQueue<State>();\n\t\tque.add(new State(S, 0, 1, 0));\n\t\tboolean find = false;\n\t\tdouble ans = INF;\n\t\twhile (!que.isEmpty()) {\n\t\t\tState s = que.poll();\n\t\t\tint cur = s.cur, prev = s.prev, v = s.v;\n\t\t\tdouble c = s.cost;\n\t\t\tif (cost[cur][prev][v] < c) continue;\n\t\t\t\n\t\t\tcost[cur][prev][v] = c;\n\t\t\t\n\t\t\tif (cur == G && v == 0) {\n\t\t\t\tans = c;\n\t\t\t\tfind = true;\n\t\t\t\tbreak;\n\t\t\t} else if (v == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint from = cur;\n\t\t\tfor (int to = 1; to < 31; to++) {\n\t\t\t\tif (W[from][to] + EPS > INF || to == prev) continue;\n\t\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\t\tint nv = v + j;\n\t\t\t\t\tdouble nc = c + ((double)W[from][to] / v);\n\t\t\t\t\tif (v >= 0 && v <= C[from][to] && nv >= 0 && nv <= 30 && cost[to][from][nv] > nc) {\n\t\t\t\t\t\tque.add(new State(to, from, nv, nc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (find)\n\t\t\tSystem.out.println(ans);\n\t\telse \n\t\t\tSystem.out.println(\"unreachable\");\n\t}\t\n}\n\nclass State implements Comparable<State> {\n\tint cur, prev, v;\n\tdouble cost;\n\t\n\tState(int cur, int prev, int v, double cost) {\n\t\tthis.cur = cur;\n\t\tthis.prev = prev;\n\t\tthis.v = v;\n\t\tthis.cost = cost;\n\t}\n\t\n\tpublic int compareTo(State s) {\n\t\treturn (new Double(this.cost).compareTo(s.cost));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n, m;\n\tint s, g;\n\tLinkedList<E>[] es;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tm=sc.nextInt();\n\t\t\tif((n|m)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tes=new LinkedList[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tes[i]=new LinkedList<E>();\n\t\t\t}\n\t\t\ts=sc.nextInt()-1;\n\t\t\tg=sc.nextInt()-1;\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint x=sc.nextInt()-1;\n\t\t\t\tint y=sc.nextInt()-1;\n\t\t\t\tint d=sc.nextInt();\n\t\t\t\tint c=sc.nextInt();\n\t\t\t\tes[x].add(new E(y, d, c));\n\t\t\t\tes[y].add(new E(x, d, c));\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tdouble[][][] d=new double[n][n][40];\n\t\tPriorityQueue<P> que=new PriorityQueue<P>();\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfill(d[j][i], INF);\n\t\t\t}\n\t\t}\n\t\t// Uツタツーツδ督づ債凝鳴止\n\t\t// [ツ前][ツ債。][ツ陳つ「ツつスツ瞬ツ甘板づ個堕ャツ度]\n\t\td[s][s][1]=0;\n\t\tque.offer(new P(s, s, 0, 0));\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.poll();\n\t\t\t// debug(p.q, p.p, p.v,p.d);\n\t\t\tif(d[p.q][p.p][p.v]+EPS<p.d){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(E e : es[p.p]){\n\t\t\t\tif(p.q==e.to){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=-1; i<=1; i++){\n\t\t\t\t\tif(p.v+i<=0||p.v+i>e.c){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(d[p.p][e.to][p.v+i]>p.d+(double)e.d/(p.v+i)+EPS){\n\t\t\t\t\t\td[p.p][e.to][p.v+i]=p.d+(double)e.d/(p.v+i);\n\t\t\t\t\t\tque.offer(new P(p.p, e.to, p.v+i, d[p.p][e.to][p.v+i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble min=INF;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmin=min(min, d[i][g][1]);\n\t\t}\n\t\t// debug(min);\n\t\tprintln(\"\"+(min<INF/2?min:\"unreachable\"));\n\t}\n\n\tclass E{\n\t\tint to, d, c;\n\n\t\tE(int to, int d, int c){\n\t\t\tthis.to=to;\n\t\t\tthis.d=d;\n\t\t\tthis.c=c;\n\t\t}\n\t}\n\n\tclass P implements Comparable<P>{\n\t\tint q, p, v;\n\t\tdouble d;\n\n\t\tP(int q, int p, int v, double d){\n\t\t\tthis.q=q;\n\t\t\tthis.p=p;\n\t\t\tthis.v=v;\n\t\t\tthis.d=d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P p){\n\t\t\tif(d+EPS<p.d){\n\t\t\t\treturn -1;\n\t\t\t}else if(d>p.d+EPS){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\t\n\tint n, m;\n\t\n\tint[][] edge;\n\tdouble[][][] minCost;\n\tint[][] maxSpeed;\t\n\t\n\tdouble INF = 100000000;\n\t\n\tclass State implements Comparable<State> {\n\t\tint n, speed, prev;\n\n\t\tState(int n, int speed, int prev) {\n\t\t\tthis.n = n;\n\t\t\tthis.speed = speed;\n\t\t\tthis.prev = prev;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(State arg0) {\n\t\t\tdouble c1 = minCost[n][prev][speed], c2 = minCost[arg0.n][arg0.prev][arg0.speed];\n\t\t\tif (c1 > c2) return 1;\n\t\t\telse if (c1 < c2) return -1;\n\t\t\telse return 0;\n\t\t}\n\t}\n\t\n\tvoid dijkstra(int start) {\n\t\tminCost = new double[n][n][31];\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++)\n\t\t\tArrays.fill(minCost[i][j], INF);\n\t\t\n\t\tminCost[start][start][0] = 0;\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.add(new State(start, 0, start));\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (s.prev == i) continue;\n\t\t\t\tfor (int c = 0; c <= 30; c++) {\n\t\t\t\t\tfor (int v = -1; v <= 1; v++) {\n\t\t\t\t\t\tif (c+v > 0 && c+v <= maxSpeed[i][s.n] && minCost[i][s.n][c+v] > minCost[s.n][s.prev][c] + (double)edge[i][s.n] / (c+v)) {\n\t\t\t\t\t\t\tminCost[i][s.n][c+v] = minCost[s.n][s.prev][c] + (double)edge[i][s.n] / (c+v);\n\t\t\t\t\t\t\tpq.add(new State(i, c+v, s.n));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = in.nextInt(); m = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint s = in.nextInt() - 1, g = in.nextInt() - 1;\n\n\t\t\tmaxSpeed = new int[n][n];\n\t\t\tedge = new int[n][n];\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = in.nextInt() - 1, y = in.nextInt() - 1, d = in.nextInt(), c = in.nextInt();\n\t\t\t\tedge[x][y] = edge[y][x] = d;\n\t\t\t\tmaxSpeed[x][y] = maxSpeed[y][x] = c;\n\t\t\t}\n\t\t\t\n\t\t\tdijkstra(s);\n\t\t\t\n\t\t\tdouble res = INF;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tres = Math.min(minCost[g][i][1], res);\n\t\t\t\n\t\t\t/*\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t\t\tSystem.out.print(minCost[i][j] + \" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tSystem.out.println(res == INF ? \"unreachable\" : res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\t\n\tint n, m;\n\t\n\tint[][] edge;\n\tdouble[][] minCost;\n\tint[][] maxSpeed;\t\n\t\n\tdouble INF = 1_000_000_000;\n\t\n\tclass State implements Comparable<State> {\n\t\tint n, speed;\n\n\t\tState(int n, int speed) {\n\t\t\tthis.n = n;\n\t\t\tthis.speed = speed;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(State arg0) {\n\t\t\tdouble c1 = minCost[n][speed], c2 = minCost[arg0.n][arg0.speed];\n\t\t\tif (c1 > c2) return 1;\n\t\t\telse if (c1 < c2) return -1;\n\t\t\telse return 0;\n\t\t}\n\t}\n\t\n\tboolean isOk(int x) {\n\t\treturn x >= 0 && x <= 30;\n\t}\n\t\n\tvoid dijkstra(int start) {\n\t\tminCost = new double[n][31];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tArrays.fill(minCost[i], INF);\n\t\t\n\t\tminCost[start][0] = 0;\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.add(new State(0, 0));\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int c = 0; c <= 30; c++) {\n\t\t\t\t\tfor (int v = -1; v <= 1; v++) {\n\t\t\t\t\t\tif (isOk(c+v) && c+v <= maxSpeed[i][s.n] && minCost[i][c+v] > minCost[s.n][c] + (double)edge[i][s.n] / (c+v)) {\n\t\t\t\t\t\t\tminCost[i][c+v] = minCost[s.n][c] + (double)edge[i][s.n] / (c+v);\n\t\t\t\t\t\t\tpq.add(new State(i, c+v));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = in.nextInt(); m = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint s = in.nextInt() - 1, g = in.nextInt() - 1;\n\n\t\t\tmaxSpeed = new int[n][n];\n\t\t\tedge = new int[n][n];\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = in.nextInt() - 1, y = in.nextInt() - 1, d = in.nextInt(), c = in.nextInt();\n\t\t\t\tedge[x][y] = edge[y][x] = d;\n\t\t\t\tmaxSpeed[x][y] = maxSpeed[y][x] = c;\n\t\t\t}\n\t\t\t\n\t\t\tdijkstra(s);\n\t\t\t\n\t\t\tdouble res = minCost[g][1];\n\t\t\t\n\t\t\tSystem.out.println(res == INF ? \"unreachable\" : res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n==0 && m==0) break;\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\t\t\t\n\t\t\tint[][] d = new int[n+1][n+1];\n\t\t\tint[][] c = new int[n+1][n+1];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\td[x][y] = d[y][x] =  sc.nextInt();\n\t\t\t\tc[x][y] = c[y][x] =  sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tdouble[][][] dp = new double[31][n+1][n+1];\n\t\t\tfor(int i=0;i<31;i++){\n\t\t\t\tfor(int j=0;j<=n;j++) Arrays.fill(dp[i][j], Integer.MAX_VALUE);\n\t\t\t}\n\t\t\t\n\t\t\tArrayDeque<Integer> p = new ArrayDeque<Integer>();\n\t\t\tArrayDeque<Integer> v = new ArrayDeque<Integer>();\n\t\t\tArrayDeque<Integer> pre = new ArrayDeque<Integer>();\n\t\t\tp.offer(s);\n\t\t\tv.offer(0);\n\t\t\tpre.offer(0);\n\t\t\tdp[0][s][0] = 0;\n\t\t\twhile(p.size()!=0){\n\t\t\t\tint q = p.poll();\n\t\t\t\tint u = v.poll();\n\t\t\t\tint r = pre.poll();\n\t\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\t\tif(i!=r && d[q][i]>0){\n\t\t\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\t\t\t\t\tif(0<u+j && u+j<=c[q][i] && dp[u+j][i][r] > dp[u][q][k] + (double)d[q][i]/(u+j)){\n\t\t\t\t\t\t\t\t\tdp[u+j][i][r] = dp[u][q][k] + (double)d[q][i]/(u+j);\n\t\t\t\t\t\t\t\t\tp.offer(i);\n\t\t\t\t\t\t\t\t\tv.offer(u+j);\n\t\t\t\t\t\t\t\t\tpre.offer(q);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t\n\t\t\tdouble min = Integer.MAX_VALUE;\n\t\t\tfor(int i=0;i<=n;i++) min = Math.min(min, dp[1][g][i]);\n\t\t\t\n\t\t\tif(min==Integer.MAX_VALUE) System.out.println(\"unreachable\");\n\t\t\telse System.out.println(min);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tint m = ir.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\treturn;\n\t\t\tint a = ir.nextInt() - 1;\n\t\t\tint b = ir.nextInt() - 1;\n\t\t\tGraph[] g1 = new Graph[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tg1[i] = new Graph();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = ir.nextInt() - 1;\n\t\t\t\tint y = ir.nextInt() - 1;\n\t\t\t\tint d = ir.nextInt();\n\t\t\t\tint c = ir.nextInt();\n\t\t\t\tg1[x].add(new double[] { y, d, c });\n\t\t\t\tg1[y].add(new double[] { x, d, c });\n\t\t\t}\n\t\t\tGraph[] g2 = new Graph[31 * n];\n\t\t\tfor (int i = 0; i < 31 * n; i++)\n\t\t\t\tg2[i] = new Graph();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < g1[i].size(); j++) {\n\t\t\t\t\tint to = (int) g1[i].get(j)[0];\n\t\t\t\t\tfor (int k = 0; k <= 30; k++) {\n\t\t\t\t\t\tfor (int l = -1; l <= 1; l++) {\n\t\t\t\t\t\t\tif (k + l >= 1 && k + l <= (int) g1[i].get(j)[2]) {\n\t\t\t\t\t\t\t\tg2[i * 31 + k].add(new double[] { to * 31 + k + l, g1[i].get(j)[1] / (k + l) });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble ret = dijkstra(a * 31, g2)[b * 31 + 1];\n\t\t\tout.println(ret == 1e9 ? \"unreachable\" : ret);\n\t\t}\n\t}\n\n\tprivate static double[] dijkstra(int s, Graph[] g) {\n\t\tdouble[] d = new double[g.length];\n\t\tPriorityQueue<double[]> pq = new PriorityQueue<double[]>(new Comparator<double[]>() {\n\t\t\tpublic int compare(double[] a, double[] b) {\n\t\t\t\treturn Double.compare(a[1], b[1]);\n\t\t\t}\n\t\t});\n\t\tArrays.fill(d, 1e9);\n\t\td[s] = 0;\n\t\tpq.offer(new double[] { s, 0 });\n\t\twhile (!pq.isEmpty()) {\n\t\t\tdouble[] p = pq.poll();\n\t\t\tint from = (int) p[0];\n\t\t\tfor (int i = 0; i < g[from].size(); i++) {\n\t\t\t\tdouble[] e = g[from].get(i);\n\t\t\t\tint to = (int) e[0];\n\t\t\t\tif (d[to] > d[from] + e[1]) {\n\t\t\t\t\td[to] = d[from] + e[1];\n\t\t\t\t\tpq.offer(new double[] { to, d[to] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tstatic class Graph extends ArrayList<double[]> {\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-5;\n\t\n\tint n, m;\n\tLinkedList<E>[] edges;\n\tdouble[][][] map;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\t\n\t\t\tshort s = (short)(sc.nextInt()-1);\n\t\t\tshort g = (short)(sc.nextInt()-1);\n\t\t\t\n\t\t\tedges = new LinkedList[n];\n\t\t\tfor(int i=0;i<n;i++) edges[i] = new LinkedList<E>();\n\t\t\t\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tshort a = (short)(sc.nextShort()-1);\n\t\t\t\tshort b = (short)(sc.nextShort()-1);\n\t\t\t\tshort d = sc.nextShort();\n\t\t\t\tshort c = sc.nextShort();\n\t\t\t\t\n\t\t\t\tedges[a].add( new E(b, c, d));\n\t\t\t\tedges[b].add( new E(a, c, d));\n\t\t\t}\n\t\t\t\n//\t\t\tfor(LinkedList<E> es: edges) for(E e: es) debug(e.to, e.c, e.d);\n\t\t\t\n\t\t\tdouble d = dijkstra(s, g);\n\t\t\t\n\t\t\tSystem.out.println((d<-EPS? \"unreachable\": d));\n\t\t}\n\t\t\n\t}\n\t\n\tdouble dijkstra(short s, short g) {\n\t\tPriorityQueue<V> que = new PriorityQueue<V>();\n\t\t\n\t\tque.add(new V(s, (short)0, s, 0.0));\n\t\t\n\t\tmap = new double[n][31][n];\n\t\tfor(double[][] a: map) for(double[] b: a) fill(b, INF);\n\t\t\n\t\tmap[s][0][s] = 0.0;\n\t\t\n\t\twhile(!que.isEmpty()) {\n\t\t\tV now = que.poll();\n\t\t\t\n\t\t\tdebug(now.u, now.v, now.p, now.t, map[now.u][now.p]);\n\t\t\t\n\t\t\tif( now.u == g && now.v == 1 ) return now.t;\n\t\t\tif( map[now.u][now.v][now.p] -now.t < 0.0 ) continue;\n\n\t\t\tfor(E edge: edges[now.u]) if( edge.to != now.p ) {\n\t\t\t\tfor(int dv = 1;dv>=-1;dv--) if( 0 < now.v+dv && now.v + dv<=edge.c ) {\n\t\t\t\tdebug(\"a\");\n\t\t\t\t\tdouble t = now.t + 1.0 * edge.d / (now.v+dv);\n\t\t\t\t\tif( t - map[edge.to][now.v+dv][now.u] < 0.0 ) {\n\t\t\t\t\t\tmap[edge.to][now.v+dv][now.u] = t;\n\t\t\t\t\t\tque.add(new V(edge.to, (short)(now.v+dv), now.u, t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tclass E {\n\t\tshort to, c, d;\n\t\tE ( short to, short c, short d) {\n\t\t\tthis.to = to;\n\t\t\tthis.c = c;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\t\n\tclass V implements Comparable<V>{\n\t\tshort u, v, p;\n\t\tdouble t;\n\t\tV(short u, short v, short p, double t) {\n\t\t\tthis.u = u;\n\t\t\tthis.v = v;\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(V o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tif(t - o.t > 0 ) return 1;\n\t\t\telse if( o.t - t > 0 ) return -1;\n\t\t\treturn o.v - v;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n//\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// Discrete Speed\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint s = sc.nextInt() - 1, g = sc.nextInt() - 1;\n\t\t\tint[][] d = new int[n][n];\n\t\t\tint[][] l = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(d[i], 0);\n\t\t\t\tArrays.fill(l[i], 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() - 1, y = sc.nextInt() - 1;\n\t\t\t\tint td = sc.nextInt();\n\t\t\t\tint tc = sc.nextInt();\n\t\t\t\td[x][y] = td;\n\t\t\t\td[y][x] = td;\n\t\t\t\tl[x][y] = tc;\n\t\t\t\tl[y][x] = tc;\n\t\t\t}\n\t\t\tdouble[][] costs = new double[n][31];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tArrays.fill(costs[i], -1);\n\t\t\tPriorityQueue<Node> queue = new PriorityQueue<Node>();\n\t\t\tqueue.add(new Node(s, 0, 0, -1));\n\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\tNode node = queue.poll();\n\t\t\t\tint tn = node.num;\n\t\t\t\tdouble tc = node.cost;\n\t\t\t\tint tv = node.v;\n\t\t\t\tint tb = node.before;\n\t\t\t\tif (costs[tn][tv] > 0 && costs[tn][tv] <= tc)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tcosts[tn][tv] = tc;\n\t\t\t\tif (tn == g && tv == 1)\n\t\t\t\t\tbreak;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (d[tn][i] >= 0 && i != tb) {\n\t\t\t\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\t\t\t\tint v = tv + j;\n\t\t\t\t\t\t\tdouble c = (double) d[tn][i] / v;\n\t\t\t\t\t\t\tif (v >= 1 && v <= l[tn][i])\n\t\t\t\t\t\t\t\tqueue.add(new Node(i, tc + c, v, tn));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (costs[g][1] == -1)\n\t\t\t\tSystem.out.println(\"unreachable\");\n\t\t\telse\n\t\t\t\tSystem.out.println(costs[g][1]);\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic class Node implements Comparable<Node> {\n\t\tint num, v, before;\n\t\tdouble cost;\n\n\t\tNode(int n, double c, int tv, int b) {\n\t\t\tnum = n;\n\t\t\tcost = c;\n\t\t\tv = tv;\n\t\t\tbefore = b;\n\t\t}\n\n\t\tpublic int compareTo(Node anotherNode) {\n\t\t\treturn this.cost < anotherNode.cost ? -1 : 1;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n \npublic class Main {\n    \n\tstatic int N, M;\n\tstatic int S, G;\n\tstatic int[][] D, C;\n\t\n    static void start()\n    {\n    \tdouble[][][] times = new double[N+1][N+1][31];\n    \tboolean[][][] check = new boolean[N+1][N+1][31];\n    \t\n    \tfor (int n = 0; n < N+1; n++) {\n\t\t\tfor (int pren = 0; pren < N+1; pren++) {\n\t\t\t\tfor (int c = 0; c < 31; c++) {\n\t\t\t\t\ttimes[n][pren][c] = Double.MAX_VALUE;\n\t\t\t\t\tcheck[n][pren][c] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \t\n    \ttimes[S][0][1] = 0;\n    \t\n    \twhile(true)\n    \t{\n    \t\tint now_n = 0, now_pren = 0, now_c = 0;\n    \t\t\n    \t\t// スタート位置の決定\n    \t\tdouble min = Double.MAX_VALUE;\n    \t\tfor (int n = 1; n < N+1; n++) {\n    \t\t\tfor (int pren = 0; pren < N+1; pren++) {\n    \t\t\t\tfor (int c = 1; c < 31; c++) {\n    \t\t\t\t\tif(check[n][pren][c] == true) continue;\n    \t\t\t\t\tif(times[n][pren][c] < min)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tmin = times[n][pren][c];\n    \t\t\t\t\t\tnow_n = n;\n    \t\t\t\t\t\tnow_pren = pren;\n    \t\t\t\t\t\tnow_c = c;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tif(min == Double.MAX_VALUE) break;\n    \t\t\n    \t\t// 処理\n    \t\tcheck[now_n][now_pren][now_c] = true;\n    \t\t\n    \t\tfor (int n = 1; n <= N; n++) {\n    \t\t\tif(now_n == n) continue;\n\t\t\t\tif(now_pren == n) continue;\n\t\t\t\tif(D[now_n][n] < 0) continue;\n\t\t\t\t\n\t\t\t\t// 速度-1\n\t\t\t\tif(1 < now_c)\n\t\t\t\t{\n\t\t\t\t\tif((now_c-1) <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c-1);\n\t\t\t\t\t\ttimes[n][now_n][now_c-1] = Math.min(times[n][now_n][now_c-1], ntime);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 速度そのまま\n\t\t\t\tif(true)\n\t\t\t\t{\n\t\t\t\t\tif(now_c <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)now_c;\n\t\t\t\t\t\ttimes[n][now_n][now_c] = Math.min(times[n][now_n][now_c], ntime);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(now_n == S && now_c == 1) continue;\n\t\t\t\t\n\t\t\t\t// 速度+1\n\t\t\t\tif(now_c < 30)\n\t\t\t\t{\n\t\t\t\t\tif((now_c+1) <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c+1);\n\t\t\t\t\t\ttimes[n][now_n][now_c+1] = Math.min(times[n][now_n][now_c+1], ntime);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n    \t}\n    \t\n    \tdouble min = Double.MAX_VALUE;\n    \tfor (int pren = 1; pren <= N; pren++) {\n\t\t\tmin = Math.min(min, times[G][pren][1]);\n\t\t}\n    \t\n    \tif(min == Double.MAX_VALUE)\n    \t\tSystem.out.println(\"unreachable\");\n    \telse {\n\t\t\tSystem.out.printf(\"%.05f\\n\", min);\n\t\t}\n    }\n     \n    public static void main(String[] args)\n    {\n        Scanner sca = new Scanner(System.in);\n        \n        while(true)\n        {\n        \tN = sca.nextInt();\n        \tM = sca.nextInt();\n        \tif(N == 0) break;\n        \t\n        \tS = sca.nextInt();\n        \tG = sca.nextInt();\n        \t\n        \tD = new int[N+1][N+1];\n        \tC = new int[N+1][N+1];\n        \tfor (int i = 0; i <= N; i++) {\n\t\t\t\tfor (int j = 0; j <= N; j++) {\n\t\t\t\t\tD[i][j] = C[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n        \t\n        \tfor (int i = 0; i < M; i++) {\n\t\t\t\tint x = sca.nextInt();\n\t\t\t\tint y = sca.nextInt();\n\t\t\t\tint d = sca.nextInt();\n\t\t\t\tint c = sca.nextInt();\n\t\t\t\t\n\t\t\t\tD[y][x] = D[x][y] = d;\n\t\t\t\tC[y][x] = C[x][y] = c;\n\t\t\t}\n            \n            start();\n        }\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint n, m, s, g;\n\tE[] G;\n\tint MAX = 30;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif ((n|m) == 0) break;\n\n\t\t\ts = sc.nextInt() - 1;\n\t\t\tg = sc.nextInt() - 1;\n\t\t\tif ((n|m|s|g) == 0) break;\n\n\t\t\tG = new E[n];\n\t\t\tfor (int i = 0; i < n; i++) G[i] = new E();\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() - 1, y = sc.nextInt() - 1, d = sc.nextInt(), c = sc.nextInt();\n\t\t\t\tG[x].add(new V(y, d, c));\n\t\t\t\tG[y].add(new V(x, d, c));\n\t\t\t}\n\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\n\tString dijkstra() {\n\t\tdouble[][][] d = new double[MAX + 1][n][n];\n\t\tfor(double[][] a : d) for (double[] b : a) fill(b, INF);\n\t\td[0][s][s] = 0;\n\t\tPriorityQueue<S> q = new PriorityQueue<S>();\n\t\tq.add(new S(0, s, s, 0));\n\n\t\tfor (;!q.isEmpty();) {\n\t\t\tS cur = q.remove();\n//\t\t\tdebug(cur);\n\t\t\tif (d[cur.v][cur.p][cur.f] != cur.c) continue;\n\t\t\tif (cur.p == g && cur.v == 1) return \"\" + cur.c;\n\n\t\t\tfor (V v : G[cur.p]) if (v.t != cur.f) {\n\t\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\t\tint nv = cur.v + i;\n\t\t\t\t\tif (nv <= 0 || nv > v.c) continue;\n\t\t\t\t\tdouble nc = cur.c + 1.0 * v.d / nv;\n\t\t\t\t\tif (d[nv][v.t][cur.p] > nc) {\n\t\t\t\t\t\td[nv][v.t][cur.p] = nc;\n\t\t\t\t\t\tq.add(new S(nv, v.t, cur.p, nc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\treturn \"unreachable\";\n\t}\n\n\tclass S implements Comparable<S>{\n\t\tint v, p, f;\n\t\tdouble c;\n\t\tS(int v, int p, int f, double c) {\n\t\t\tthis.v = v;\n\t\t\tthis.p = p;\n\t\t\tthis.f = f;\n\t\t\tthis.c = c;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(S o) {\n\t\t\t// TODO ティツ?ェテ・ツ仰陛ァツ板淌ヲツ按静」ツ?陛」ツつ古」ツ?淌」ツδ。テ」ツつステ」ツδε」ツδ嘉」ツδサテ」ツつケテ」ツつソテ」ツδ?\n\t\t\treturn c - o.c > 0 ? 1 : -1;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"[\" + v + \", \" + p + \", \" + f + \", \" + c + \"]\";\n\t\t}\n\t}\n\n\n\tclass E extends ArrayList<V>{};\n\tclass V {\n\t\tint t, d, c;\n\t\tV(int t, int d, int c) {\n\t\t\tthis.t = t;\n\t\t\tthis.d = d;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n  \n    static int start, goal;             // スタート都市、ゴール都市\n    static int n_city, m_road;      // 都市の数、道の数\n    static int[][] road_dist;           // 道の距離情報\n    static int[][] speed_limit;     // 道の制限速度情報\n    static double[][][] city;           // ダイクストラ　最短時間保管表\n    static boolean[][][] enter;     // ダイクストラ　最短時間確定\n    static final int speed_law = 30;\n    static int[][][] pre;\n      \n    // ダイクストラアルゴリズム\n    static double Dijkstra(){\n        // 初期設定。最短時間をMAX値で初期化。\n        city = new double[n_city+1][n_city+1][speed_law+1];\n        enter = new boolean[n_city+1][n_city+1][speed_law+1];\n        pre = new int[n_city+1][n_city+1][speed_law+1];\n        for(int i=0;i<=n_city;i++){\n            for(int j=0;j<=n_city;j++){\n                for(int k=0;k<=speed_law;k++){\n                    city[i][j][k] = Double.MAX_VALUE;\n                }\n            }\n        }\n        city[start][start][1] = 0;      // スタート→スタートで速度1の場合、所要時間0\n        // ループアルゴ(状態遷移を次々と決める)\n        //  cf. 状態遷移とは「ある都市→ある都市の移動(速度も含む)」\n        while(true){\n            // 最短時間表から最も最短時間な状態遷移を探す\n            double fast = Double.MAX_VALUE;\n            int x, y, z;        // fastのindex\n            x = y = z = -1;\n            for(int i=1;i<=n_city;i++){\n                for(int j=1;j<=n_city;j++){\n                    for(int k=1;k<=speed_law;k++){\n                        if(!enter[i][j][k]&&city[i][j][k]<fast){     // 確定されてない & 最短時間\n                            fast = city[i][j][k];\n                            x = i;  y = j;  z = k;      // 設定されるxはstartと同値が既知\n                        }\n                    }\n                }\n            }\n            // 表において探した最も最短時間な状態遷移が、\n            //      スタート→ゴールで速度が1の場合は解が得られる\n//            System.out.println(\"time=\"+city[x][y][z]);\n //           if(x==start&&y==goal&&z==1){\n               // ans2 = Math.min(ans2, city[x][y][z]);\n//                return city[x][y][1];\n   //         }\n            // 最短時間の更新が一度もされない→状態遷移がすべて確定してしまった\n            //  (ゴールに辿りつける道がない or ゴール時に速度が1とならない)\n            if(x==-1){\n                break;\n            }\n            enter[x][y][z] = true;      // 探した最短時間状態遷移を確定する\n//          System.out.println(\"enter : x=\"+x+\", y=\"+y+\", z=\"+z+\" pre=\"+pre[x][y][z]+\" time=\"+city[x][y][z]);\n            // 確定した状態遷移から移動できる都市を更新しにいく (yからnexの移動)\n            for(int nex=1;nex<=n_city;nex++){        // nex = 遷移先(次)\n                // 速度3パターン(-1,0,1)、zは元の速度、spdは遷移時の速度\n                for(int spd=z-1;spd<=z+1;spd++){\n                    // スピード負値、制限速度オーバー、道路がない　場合は除外\n                    if(spd<=0||spd>speed_limit[y][nex]||road_dist[y][nex]==Double.MAX_VALUE){\n                        continue;\n                    }\n                    // スタート地点から出る道とゴール地点に到達する道は必ず速度1 (この問題においての超重要点)\n                    //  さらには今来た道なら引き返しなのでNG(x->y y->nex(x) ... x=nex=start)\n                    //      さらには状態遷移が決定していれば更新の必要性はない\n                    if((x==start&&y==start&&z==1&&spd!=1)||y==nex||pre[x][y][z]==nex){\n//                      System.out.println(\"s=\"+start+\" g=\"+goal+\" y=\"+y+\" z=\"+z+\" nex=\"+nex+\" spd=\"+spd);\n                        continue;\n                    }\n//                  System.out.println(\"connect : y=\"+y+\", nex=\"+nex+\", spd=\"+spd);\n                    // 時間 = 距離 / 速度\n                  if(city[x][nex][spd]>=city[x][y][z] + road_dist[y][nex]*1.0/spd){\n                      //city[x][nex][spd] = city[x][y][z] + road_dist[y][nex]*1.0/spd;\n                      pre[x][nex][spd] = y; \n                  }\n                  city[x][nex][spd] = Math.min(city[x][y][z] + road_dist[y][nex]*1.0/spd , city[x][nex][spd]);\n                }\n            }\n        }\n//        System.out.println(ans2);\n        return -1;\n    }\n      \n    public static void main(String[] args) {\n        Scanner stdIn = new Scanner(System.in);\n        while(true){\n            n_city = stdIn.nextInt();\n            m_road = stdIn.nextInt();\n            if((n_city|m_road)==0){\n                return;\n            }\n            start = stdIn.nextInt();\n            goal = stdIn.nextInt();\n            road_dist = new int[n_city+1][n_city+1];\n            speed_limit = new int[n_city+1][n_city+1];\n            for(int i=0;i<m_road;i++){\n                int x = stdIn.nextInt();\n                int y = stdIn.nextInt();\n                int d = stdIn.nextInt();\n                int c = stdIn.nextInt();\n                road_dist[x][y] = road_dist[y][x] = d;\n                speed_limit[x][y] = speed_limit[y][x] = c;\n            }\n            Dijkstra();\n            if(city[start][goal][1]!=Double.MAX_VALUE){\n                System.out.printf(\"%.5f\\n\",city[start][goal][1]);\n            }\n            else{\n                System.out.println(\"unreachable\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n  \npublic class Main {\n     \n    static int N, M;\n    static int S, G;\n    static int[][] D, C;\n    static double[][][] times;\n     \n    static void start()\n    {\n        times = new double[N+1][N+1][31];\n        boolean[][][] check = new boolean[N+1][N+1][31];\n         \n        for (int n = 0; n < N+1; n++) {\n            for (int pren = 0; pren < N+1; pren++) {\n                for (int c = 0; c < 31; c++) {\n                    times[n][pren][c] = Double.MAX_VALUE;\n                    check[n][pren][c] = false;\n                }\n            }\n        }\n         \n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(N, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b)\n            {\n                double ia = times[ a[0] ][ a[1] ][ a[2] ];\n                double ib = times[ b[0] ][ b[1] ][ b[2] ];\n                if(ia < ib)\n                    return -1;\n                else if(ia == ib)\n                    return 0;\n                else {\n                    return 1;\n                }\n            }\n        });\n         \n        times[S][0][1] = 0;\n        queue.offer(new int[]{S, 0, 1});\n         \n        while(!queue.isEmpty())\n        {\n            int now_n = 0, now_pren = 0, now_c = 0;\n             \n            // スタート位置の決定\n            int[] qq = queue.poll();\n            now_n = qq[0];\n            now_pren = qq[1];\n            now_c = qq[2];\n             \n            if(now_n == G && now_c == 1)\n            {\n                System.out.printf(\"%.05f\\n\", times[now_n][now_pren][now_c]);\n                return;\n            }\n             \n            if(check[now_n][now_pren][now_c] == true) continue;\n             \n            // 処理\n            check[now_n][now_pren][now_c] = true;\n             \n            for (int n = 1; n <= N; n++) {\n                if(now_n == n) continue;\n                if(now_pren == n) continue;\n                if(D[now_n][n] < 0) continue;\n                 \n                // 速度-1\n                if(1 < now_c)\n                {\n                    if((now_c-1) <= C[now_n][n])\n                    {\n                        double ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c-1);\n                        if(ntime < times[n][now_n][now_c-1])\n                        {\n                            times[n][now_n][now_c-1] = ntime;\n                            queue.offer(new int[]{n, now_n, now_c-1});\n                        }\n                    }\n                }\n                 \n                // 速度そのまま\n                if(true)\n                {\n                    if(now_c <= C[now_n][n])\n                    {\n                        double ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)now_c;\n                        if(ntime < times[n][now_n][now_c])\n                        {\n                            times[n][now_n][now_c] = ntime;\n                            queue.offer(new int[]{n, now_n, now_c});\n                        }\n                    }\n                }\n                 \n                if(now_n == S && now_c == 1) continue;\n                 \n                // 速度+1\n                if(now_c < 30)\n                {\n                    if((now_c+1) <= C[now_n][n])\n                    {\n                        double ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c+1);\n                        if(ntime < times[n][now_n][now_c+1])\n                        {\n                            times[n][now_n][now_c+1] = ntime;\n                            queue.offer(new int[]{n, now_n, now_c+1});\n                        }\n                    }\n                }\n            }\n        }\n         \n        System.out.println(\"unreachable\");\n    }\n      \n    public static void main(String[] args)\n    {\n        Scanner sca = new Scanner(System.in);\n         \n        while(true)\n        {\n            N = sca.nextInt();\n            M = sca.nextInt();\n            if(N == 0) break;\n             \n            S = sca.nextInt();\n            G = sca.nextInt();\n             \n            D = new int[N+1][N+1];\n            C = new int[N+1][N+1];\n            for (int i = 0; i <= N; i++) {\n                for (int j = 0; j <= N; j++) {\n                    D[i][j] = C[i][j] = -1;\n                }\n            }\n             \n            for (int i = 0; i < M; i++) {\n                int x = sca.nextInt();\n                int y = sca.nextInt();\n                int d = sca.nextInt();\n                int c = sca.nextInt();\n                 \n                D[y][x] = D[x][y] = d;\n                C[y][x] = C[x][y] = c;\n            }\n             \n            start();\n        }\n         \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass State implements Comparable<State> {\n\t\tdouble t;\n\t\tint c, v, pre;\n\n\t\tState(double t, int c, int v, int pre) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t\tthis.v = v;\n\t\t\tthis.pre = pre;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State arg0) {\n\t\t\treturn this.t - arg0.t > 0 ? 1 : -1;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t\tint[][] d = new int[n][n];\n\t\t\tint[][] c = new int[n][n];\n\t\t\tdouble[][] t = new double[n][31];\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tArrays.fill(d[j], Integer.MAX_VALUE >> 3);\n\t\t\t\tArrays.fill(c[j], 0);\n\t\t\t\tArrays.fill(t[j], Double.MAX_VALUE / 4);\n\t\t\t}\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint d1 = sc.nextInt();\n\t\t\t\tint c1 = sc.nextInt();\n\t\t\t\td[x][y] = d1;\n\t\t\t\td[y][x] = d1;\n\t\t\t\tc[x][y] = c1;\n\t\t\t\tc[y][x] = c1;\n\t\t\t}\n\n\t\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\n\t\t\tt[s][0] = 0;\n\t\t\tq.add(new State(0, s, 0, -1));\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tState pop = q.poll();\n\t\t\t\tif (t[pop.c][pop.v] < pop.t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pop.c == g && pop.v == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\t\tif (pop.pre == i) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int dv = -1; dv <= 1; dv++) {\n\t\t\t\t\t\tint nv = pop.v + dv;\n\t\t\t\t\t\tif (nv > 30) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nv <= 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (c[pop.c][i] < nv) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdouble dt = (double) d[pop.c][i] / (double) (nv);\n\t\t\t\t\t\tif (t[i][nv] > t[pop.c][pop.v] + dt) {\n\t\t\t\t\t\t\tt[i][nv] = t[pop.c][pop.v] + dt;\n\t\t\t\t\t\t\tq.add(new State(t[i][nv], i, nv, pop.c));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[g][1] >= Double.MAX_VALUE / 4) {\n\t\t\t\tSystem.out.println(\"unreachable\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(t[g][1]);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int start, goal;\t\t\t\t// スタート都市、ゴール都市\n\tstatic int n_city, m_road;\t\t// 都市の数、道の数\n\tstatic int[][] road_dist;\t\t\t// 道の距離情報\n\tstatic int[][] speed_limit;\t\t// 道の制限速度情報\n\tstatic double[][][] city;\t\t\t// ダイクストラ　最短時間保管表\n\tstatic boolean[][][] enter;\t\t// ダイクストラ　最短時間確定\n\tstatic final int speed_law = 30;\n\t\n\t// ダイクストラアルゴリズム\n\tstatic double Dijkstra(){\n\t\t// 初期設定。最短時間をMAX値で初期化。\n\t\tcity = new double[n_city+1][n_city+1][speed_law+1];\n\t\tenter = new boolean[n_city+1][n_city+1][speed_law+1];\n\t\tfor(int i=0;i<=n_city;i++){\n\t\t\tfor(int j=0;j<=n_city;j++){\n\t\t\t\tfor(int k=0;k<=speed_law;k++){\n\t\t\t\t\tcity[i][j][k] = Double.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcity[start][start][1] = 0;\t\t// スタート→スタートで速度1の場合、所要時間0\n\t\t// ループアルゴ(状態遷移を次々と決める)\n\t\t// \tcf. 状態遷移とは「ある都市→ある都市の移動(速度も含む)」\n\t\twhile(true){\n\t\t\t// 最短時間表から最も最短時間な状態遷移を探す\n\t\t\tdouble fast = Double.MAX_VALUE;\n\t\t\tint x, y, z;\t\t// fastのindex\n\t\t\tx = y = z = -1;\n\t\t\tfor(int i=1;i<=n_city;i++){\n\t\t\t\tfor(int j=1;j<=n_city;j++){\n\t\t\t\t\tfor(int k=1;k<=speed_law;k++){\n\t\t\t\t\t\tif(!enter[i][j][k]&&city[i][j][k]<fast){\t\t// 確定されてない & 最短時間\n\t\t\t\t\t\t\tfast = city[i][j][k];\n\t\t\t\t\t\t\tx = i;\ty = j;\tz = k;\t\t// 設定されるxはstartと同値が既知\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 表において探した最も最短時間な状態遷移が、\n\t\t\t//\t\tスタート→ゴールで速度が1の場合は解が得られる\n\t\t\tif(x==start&&y==goal&&z==1){\n\t\t\t\treturn city[x][y][1];\n\t\t\t}\n\t\t\t// 最短時間の更新が一度もされない→状態遷移がすべて確定してしまった\n\t\t\t// \t(ゴールに辿りつける道がない or ゴール時に速度が1とならない)\n\t\t\telse if(x==-1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tenter[x][y][z] = true;\t\t// 探した最短時間状態遷移を確定する\n//\t\t\tSystem.out.println(\"enter : x=\"+x+\", y=\"+y+\", z=\"+z+\" time=\"+city[x][y][z]);\n\t\t\t// 確定した状態遷移から移動できる都市を更新しにいく (yからnexの移動)\n\t\t\tfor(int nex=1;nex<=n_city;nex++){\t\t// nex = 遷移先(次)\n\t\t\t\t// 速度3パターン(-1,0,1)、zは元の速度、spdは遷移時の速度\n\t\t\t\tfor(int spd=z-1;spd<=z+1;spd++){\n\t\t\t\t\t// スピード負値、制限速度オーバー、道路がない　場合は除外\n\t\t\t\t\tif(spd<=0||spd>speed_limit[y][nex]||road_dist[y][nex]==Double.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// スタート地点から出る道とゴール地点に到達する道は必ず速度1 (この問題においての超重要点)\n\t\t\t\t\t// \tさらには今来た道なら引き返しなのでNG(x->y y->nex(x) ... x=nex=start)\n\t\t\t\t\t//\t\tさらには状態遷移が決定していれば更新の必要性はない\n\t\t\t\t\tif(((y==start||nex==goal)&&spd!=1)||start==nex||enter[x][nex][spd]){\n//\t\t\t\t\t\tSystem.out.println(\"s=\"+start+\" g=\"+goal+\" y=\"+y+\" z=\"+z+\" nex=\"+nex+\" spd=\"+spd);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println(\"connect : y=\"+y+\", nex=\"+nex+\", spd=\"+spd);\n\t\t\t\t\t// 時間 = 距離 / 速度\n\t\t\t\t\tcity[x][nex][spd] = Math.min(city[x][y][z] + road_dist[y][nex]*1.0/spd , city[x][nex][spd]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn_city = stdIn.nextInt();\n\t\t\tm_road = stdIn.nextInt();\n\t\t\tif((n_city|m_road)==0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstart = stdIn.nextInt();\n\t\t\tgoal = stdIn.nextInt();\n\t\t\troad_dist = new int[n_city+1][n_city+1];\n\t\t\tspeed_limit = new int[n_city+1][n_city+1];\n\t\t\tfor(int i=0;i<m_road;i++){\n\t\t\t\tint x = stdIn.nextInt();\n\t\t\t\tint y = stdIn.nextInt();\n\t\t\t\tint d = stdIn.nextInt();\n\t\t\t\tint c = stdIn.nextInt();\n\t\t\t\troad_dist[x][y] = road_dist[y][x] = d;\n\t\t\t\tspeed_limit[x][y] = speed_limit[y][x] = c;\n\t\t\t}\n\t\t\tdouble ans = Dijkstra();\n\t\t\tif(ans!=-1){\n\t\t\t\tSystem.out.printf(\"%.5f\\n\",ans);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"unreachable\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int start, goal;\t\t\t\t// スタート都市、ゴール都市\n\tstatic int n_city, m_road;\t\t// 都市の数、道の数\n\tstatic int[][] road_dist;\t\t\t// 道の距離情報\n\tstatic int[][] speed_limit;\t\t// 道の制限速度情報\n\tstatic double[][][] city;\t\t\t// ダイクストラ　最短時間保管表\n\tstatic boolean[][][] enter;\t\t// ダイクストラ　最短時間確定\n\tstatic final int speed_law = 30;\n\t\n\t// ダイクストラアルゴリズム\n\tstatic double Dijkstra(){\n\t\t// 初期設定。最短時間をMAX値で初期化。\n\t\tcity = new double[n_city+1][n_city+1][speed_law+1];\n\t\tenter = new boolean[n_city+1][n_city+1][speed_law+1];\n\t\tfor(int i=0;i<=n_city;i++){\n\t\t\tfor(int j=0;j<=n_city;j++){\n\t\t\t\tfor(int k=0;k<=speed_law;k++){\n\t\t\t\t\tcity[i][j][k] = Double.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcity[start][start][1] = 0;\t\t// スタート→スタートで速度1の場合、所要時間0\n\t\t// ループアルゴ(状態遷移を次々と決める)\n\t\t// \tcf. 状態遷移とは「ある都市→ある都市の移動(速度も含む)」\n\t\twhile(true){\n\t\t\t// 最短時間表から最も最短時間な状態遷移を探す\n\t\t\tdouble fast = Double.MAX_VALUE;\n\t\t\tint x, y, z;\t\t// fastのindex\n\t\t\tx = y = z = -1;\n\t\t\tfor(int i=1;i<=n_city;i++){\n\t\t\t\tfor(int j=1;j<=n_city;j++){\n\t\t\t\t\tfor(int k=1;k<=speed_law;k++){\n\t\t\t\t\t\tif(!enter[i][j][k]&&city[i][j][k]<fast){\t\t// 確定されてない & 最短時間\n\t\t\t\t\t\t\tfast = city[i][j][k];\n\t\t\t\t\t\t\tx = i;\ty = j;\tz = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 表において探した最も最短時間な状態遷移が、\n\t\t\t//\t\tスタート→ゴールで速度が1の場合は解が得られる\n\t\t\tif(x==start&&y==goal&&z==1){\n\t\t\t\treturn city[x][y][1];\n\t\t\t}\n\t\t\t// 最短時間の更新が一度もされない→状態遷移がすべて確定してしまった\n\t\t\t// \t(ゴールに辿りつける道がない or ゴール時に速度が1とならない)\n\t\t\telse if(x==-1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tenter[x][y][z] = true;\t\t// 探した最短時間状態遷移を確定する\n//\t\t\tSystem.out.println(\"enter : x=\"+x+\", y=\"+y+\", z=\"+z+\" time=\"+city[x][y][z]);\n\t\t\t// 確定した状態遷移から移動できる都市を更新しにいく (yからnexの移動)\n\t\t\tfor(int nex=1;nex<=n_city;nex++){\t\t// nex = 遷移先(次)\n\t\t\t\t// 速度3パターン(-1,0,1)、zは元の速度、spdは遷移時の速度\n\t\t\t\tfor(int spd=z-1;spd<=z+1;spd++){\n\t\t\t\t\t// スピード負値、制限速度オーバー、道路がない　場合は除外\n\t\t\t\t\tif(spd<=0||spd>speed_limit[y][nex]||road_dist[y][nex]==Double.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// 初めのスタート地点から出る道は必ず速度1\n\t\t\t\t\tif(x==start&&y==start&&z==1&&z!=spd){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println(\"connect : y=\"+y+\", nex=\"+nex+\", spd=\"+spd);\n\t\t\t\t\t// 時間 = 距離 / 速度\n\t\t\t\t\tcity[x][nex][spd] = Math.min(city[x][y][z] + road_dist[y][nex]*1.0/spd , city[x][nex][spd]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn_city = stdIn.nextInt();\n\t\t\tm_road = stdIn.nextInt();\n\t\t\tif((n_city|m_road)==0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstart = stdIn.nextInt();\n\t\t\tgoal = stdIn.nextInt();\n\t\t\troad_dist = new int[n_city+1][n_city+1];\n\t\t\tspeed_limit = new int[n_city+1][n_city+1];\n\t\t\tfor(int i=0;i<m_road;i++){\n\t\t\t\tint x = stdIn.nextInt();\n\t\t\t\tint y = stdIn.nextInt();\n\t\t\t\tint d = stdIn.nextInt();\n\t\t\t\tint c = stdIn.nextInt();\n\t\t\t\troad_dist[x][y] = road_dist[y][x] = d;\n\t\t\t\tspeed_limit[x][y] = speed_limit[y][x] = c;\n\t\t\t}\n\t\t\tdouble ans = Dijkstra();\n\t\t\tif(ans!=-1){\n\t\t\tSystem.out.printf(\"%.5f\\n\",ans);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"unreachable\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n  \n    static int start, goal;             // スタート都市、ゴール都市\n    static int n_city, m_road;      // 都市の数、道の数\n    static int[][] road_dist;           // 道の距離情報\n    static int[][] speed_limit;     // 道の制限速度情報\n    static double[][][] city;           // ダイクストラ　最短時間保管表\n    static boolean[][][] enter;     // ダイクストラ　最短時間確定\n    static final int speed_law = 30;\n    static double ans2;\n    static int[][][] pre;\n      \n    static int nextInt(){\n    \ttry{\n    \t\tint c=System.in.read(),r=0;\n    \t\tfor(;c!='-'&&(c<'0'||'9'<c);)c=System.in.read();\n    \t\tif(c=='-') return -nextInt();\n    \t\tdo{\n    \t\t\tr*=10;\n    \t\t\tr+=c-'0';\n    \t\t\tc=System.in.read();\n    \t\t}\n    \t\twhile('0'<=c&&c<='9');\n    \t\treturn r;\n    \t\t\n    \t} catch (Exception e){\n    \t\treturn -1;\n    \t}\n    }\n    \n    // ダイクストラアルゴリズム\n    static double Dijkstra(){\n        // 初期設定。最短時間をMAX値で初期化。\n        city = new double[n_city+1][n_city+1][speed_law+1];\n        enter = new boolean[n_city+1][n_city+1][speed_law+1];\n//        pre = new int[n_city+1][n_city+1][speed_law+1];\n        for(int i=0;i<=n_city;i++){\n            for(int j=0;j<=n_city;j++){\n                for(int k=0;k<=speed_law;k++){\n                    city[i][j][k] = Double.MAX_VALUE;\n                }\n            }\n        }\n        city[start][start][1] = 0;      // スタート→スタートで速度1の場合、所要時間0\n        // ループアルゴ(状態遷移を次々と決める)\n        //  cf. 状態遷移とは「ある都市→ある都市の移動(速度も含む)」\n        while(true){\n            // 最短時間表から最も最短時間な状態遷移を探す\n            double fast = Double.MAX_VALUE;\n            int x, y, z;        // fastのindex\n            x = y = z = -1;\n            for(int i=1;i<=n_city;i++){\n                for(int j=1;j<=n_city;j++){\n                    for(int k=1;k<=speed_law;k++){\n                        if(!enter[i][j][k]&&city[i][j][k]<fast){     // 確定されてない & 最短時間\n                            fast = city[i][j][k];\n                            x = i;  y = j;  z = k;      // 設定されるxはstartと同値が既知\n                        }\n                    }\n                }\n            }\n            // 表において探した最も最短時間な状態遷移が、\n            //      スタート→ゴールで速度が1の場合は解が得られる\n//            System.out.println(\"time=\"+city[x][y][z]);\n            if(y==goal&&z==1){\n                ans2 = Math.min(ans2, city[x][y][z]);\n                return city[x][y][1];\n            }\n            // 最短時間の更新が一度もされない→状態遷移がすべて確定してしまった\n            //  (ゴールに辿りつける道がない or ゴール時に速度が1とならない)\n            else if(x==-1){\n                break;\n            }\n            enter[x][y][z] = true;      // 探した最短時間状態遷移を確定する\n//          System.out.println(\"enter : x=\"+x+\", y=\"+y+\", z=\"+z+\" pre=\"+pre[x][y][z]+\" time=\"+city[x][y][z]);\n            // 確定した状態遷移から移動できる都市を更新しにいく (yからnexの移動)\n            for(int nex=1;nex<=n_city;nex++){        // nex = 遷移先(次)\n                // 速度3パターン(-1,0,1)、zは元の速度、spdは遷移時の速度\n                if(x==nex){\n                    continue;\n                }\n                for(int spd=z-1;spd<=z+1;spd++){\n                    // スピード負値、制限速度オーバー、道路がない　場合は除外\n                    if(spd<=0||spd>speed_limit[y][nex]||road_dist[y][nex]==Double.MAX_VALUE){\n                        continue;\n                    }\n                    // スタート地点から出る道とゴール地点に到達する道は必ず速度1 (この問題においての超重要点)\n                    //  さらには今来た道なら引き返しなのでNG(x->y y->nex(x) ... x=nex=start)\n                    //      さらには状態遷移が決定していれば更新の必要性はない\n                    if(x==start&&y==start&&z==1&&spd!=1){\n//                      System.out.println(\"s=\"+start+\" g=\"+goal+\" y=\"+y+\" z=\"+z+\" nex=\"+nex+\" spd=\"+spd);\n                        continue;\n                    }\n//                  System.out.println(\"connect : x=\"+x+\" y=\"+y+\", nex=\"+nex+\", spd=\"+spd);\n                    // 時間 = 距離 / 速度\n                  if(city[y][nex][spd]>city[x][y][z] + road_dist[y][nex]*1.0/spd){\n                      city[y][nex][spd] = city[x][y][z] + road_dist[y][nex]*1.0/spd; \n                  }\n                                   \n                   \n                   \n//                    city[x][nex][spd] = Math.min(city[x][y][z] + road_dist[y][nex]*1.0/spd , city[x][nex][spd]);\n                }\n            }\n        }\n//        System.out.println(ans2);\n        return -1;\n    }\n      \n    public static void main(String[] args) {\n//        Scanner stdIn = new Scanner(System.in);\n        while(true){\n            n_city = nextInt();\n            m_road = nextInt();\n            if((n_city|m_road)==0){\n                return;\n            }\n            start = nextInt();\n            goal = nextInt();\n            road_dist = new int[n_city+1][n_city+1];\n            speed_limit = new int[n_city+1][n_city+1];\n            for(int i=0;i<m_road;i++){\n                int x = nextInt();\n                int y = nextInt();\n                int d = nextInt();\n                int c = nextInt();\n                road_dist[x][y] = road_dist[y][x] = d;\n                speed_limit[x][y] = speed_limit[y][x] = c;\n            }\n            ans2 = 10000000;\n            double ans = Dijkstra();\n            if(ans2!=10000000){\n                System.out.printf(\"%.5f\\n\",ans2);\n            }\n            else{\n                System.out.println(\"unreachable\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-5;\n\t\n\tint n, m;\n\tLinkedList<E>[] edges;\n\tdouble[][][] map;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\t\n\t\t\tshort s = (short)(sc.nextInt()-1);\n\t\t\tshort g = (short)(sc.nextInt()-1);\n\t\t\t\n\t\t\tedges = new LinkedList[n];\n\t\t\tfor(int i=0;i<n;i++) edges[i] = new LinkedList<E>();\n\t\t\t\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tshort a = (short)(sc.nextShort()-1);\n\t\t\t\tshort b = (short)(sc.nextShort()-1);\n\t\t\t\tshort d = sc.nextShort();\n\t\t\t\tshort c = sc.nextShort();\n\t\t\t\t\n\t\t\t\tedges[a].add( new E(b, c, d));\n\t\t\t\tedges[b].add( new E(a, c, d));\n\t\t\t}\n\t\t\t\n//\t\t\tfor(LinkedList<E> es: edges) for(E e: es) debug(e.to, e.c, e.d);\n\t\t\t\n\t\t\tdouble d = dijkstra(s, g);\n\t\t\t\n\t\t\tSystem.out.println((d<-EPS? \"unreachable\": d));\n\t\t}\n\t\t\n\t}\n\t\n\tdouble dijkstra(short s, short g) {\n\t\tPriorityQueue<V> que = new PriorityQueue<V>();\n\t\t\n\t\tque.add(new V(s, (short)0, s, 0.0));\n\t\t\n\t\tmap = new double[n][31][n];\n\t\tfor(double[][] a: map) for(double[] b: a) fill(b, INF);\n\t\t\n\t\tmap[s][0][s] = 0.0;\n\t\t\n\t\twhile(!que.isEmpty()) {\n\t\t\tV now = que.poll();\n\t\t\t\n\t\t\tdebug(now.u, now.v, now.p, now.t, map[now.u][now.p]);\n\t\t\t\n\t\t\tif( now.u == g && now.v == 1 ) return now.t;\n\t\t\tif( abs( map[now.u][now.v][now.p] -now.t ) > EPS ) continue;\n\n\t\t\tfor(E edge: edges[now.u]) if( edge.to != now.p ) {\n\t\t\t\tfor(int dv = 1;dv>=-1;dv--) if( 0 < now.v+dv && now.v + dv<=edge.c ) {\n\t\t\t\tdebug(\"a\");\n\t\t\t\t\tdouble t = now.t + 1.0 * edge.d / (now.v+dv);\n\t\t\t\t\tif( t - map[edge.to][now.v+dv][now.u] < EPS ) {\n\t\t\t\t\t\tmap[edge.to][now.v+dv][now.u] = t;\n\t\t\t\t\t\tque.add(new V(edge.to, (short)(now.v+dv), now.u, t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tclass E {\n\t\tshort to, c, d;\n\t\tE ( short to, short c, short d) {\n\t\t\tthis.to = to;\n\t\t\tthis.c = c;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\t\n\tclass V implements Comparable<V>{\n\t\tshort u, v, p;\n\t\tdouble t;\n\t\tV(short u, short v, short p, double t) {\n\t\t\tthis.u = u;\n\t\t\tthis.v = v;\n\t\t\tthis.p = p;\n\t\t\tthis.t = t;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(V o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn (t-o.t) > EPS? 1: -1;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n//\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int INF = Integer.MAX_VALUE;\n    int n, m, s, g;\n    int[][] dist, seigen;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            n = sc.nextInt(); m = sc.nextInt();\n            if(n==0 && m==0) break;\n            s = sc.nextInt()-1; g = sc.nextInt()-1;\n            dist = new int[n][n];\n            seigen = new int[n][n];\n            for(int i=0; i<n; i++) Arrays.fill(dist[i], INF);\n            for(int i=0; i<m; i++){\n                int x = sc.nextInt()-1, y = sc.nextInt()-1;\n                int d = sc.nextInt(), c = sc.nextInt();\n                dist[x][y] = d; dist[y][x] = d;\n                seigen[x][y] = c; seigen[y][x] = c;\n            }\n            System.out.println(dijkstra());\n        }\n    }\n\n    class P{\n        int pos, bpos, speed;\n        double cost;\n        P(int pos, int bpos, int speed, double cost){\n            this.pos = pos;\n            this.bpos = bpos;\n            this.speed = speed;\n            this.cost = cost;\n        }\n    }\n\n    String dijkstra(){\n        PriorityQueue<P> q = new PriorityQueue<P>(10, new Comparator<P>(){\n                public int compare(P p1, P p2){\n                    if(p1.cost<p2.cost) return -1;\n                    else if(p1.cost>p2.cost) return 1;\n                    return 0;\n                }\n            });\n        q.add(new P(s, -1, 1, 0));\n        boolean[][][] v = new boolean[n][n][10000];\n\n        while(q.size()>0){\n            P pp = q.poll();\n            int pos = pp.pos, bpos = pp.bpos, speed = pp.speed;\n            double cost = pp.cost;\n\n            if(pos==g && speed==1) return String.valueOf(cost);\n            if(bpos==-1){\n                for(int i=0; i<n; i++) v[pos][i][speed] = true;\n            }else{\n                if(v[pos][bpos][speed]) continue;\n                v[pos][bpos][speed] = true;\n            }\n\n            for(int i=0; i<n; i++){\n                if(i==pos || i==bpos || dist[pos][i]==INF) continue;\n                for(int j=-1; j<=1; j++){\n                    int nspeed = speed + j;\n                    if(nspeed<=0 || seigen[pos][i]<nspeed) continue;\n                    if(bpos==-1 && nspeed!=1) continue;\n                    q.add(new P(i, pos, nspeed, cost+(double)dist[pos][i]/nspeed));\n                }\n            }\n\n        }\n\n        return \"unreachable\";\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n \npublic class Main {\n    \n\tstatic int N, M;\n\tstatic int S, G;\n\tstatic int[][] D, C;\n\t\n    static void start()\n    {\n    \tdouble[][][] times = new double[N+1][N+1][31];\n    \tboolean[][][] check = new boolean[N+1][N+1][31];\n    \t\n    \tfor (int n = 0; n < N+1; n++) {\n\t\t\tfor (int pren = 0; pren < N+1; pren++) {\n\t\t\t\tfor (int c = 0; c < 31; c++) {\n\t\t\t\t\ttimes[n][pren][c] = Double.MAX_VALUE;\n\t\t\t\t\tcheck[n][pren][c] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \t\n    \tPriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n    \t\tpublic int compare(int[] a, int[] b)\n    \t\t{\n    \t\t\tdouble ia = times[ a[0] ][ a[1] ][ a[2] ];\n    \t\t\tdouble ib = times[ b[0] ][ b[1] ][ b[2] ];\n    \t\t\tif(ia < ib)\n    \t\t\t\treturn -1;\n    \t\t\telse if(ia == ib)\n    \t\t\t\treturn 0;\n    \t\t\telse {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n    \t\t}\n\t\t});\n    \t\n    \ttimes[S][0][1] = 0;\n    \tqueue.offer(new int[]{S, 0, 1});\n    \t\n    \twhile(!queue.isEmpty())\n    \t{\n    \t\tint now_n = 0, now_pren = 0, now_c = 0;\n    \t\t\n    \t\t// スタート位置の決定\n    \t\tint[] qq = queue.poll();\n    \t\tnow_n = qq[0];\n    \t\tnow_pren = qq[1];\n    \t\tnow_c = qq[2];\n    \t\t\n    \t\tif(now_n == G && now_c == 1)\n    \t\t{\n    \t\t\tSystem.out.printf(\"%.05f\\n\", times[now_n][now_pren][now_c]);\n    \t\t\treturn;\n    \t\t}\n    \t\t\n    \t\tif(check[now_n][now_pren][now_c] == true) continue;\n    \t\t\n    \t\t// 処理\n    \t\tcheck[now_n][now_pren][now_c] = true;\n    \t\t\n    \t\tfor (int n = 1; n <= N; n++) {\n    \t\t\tif(now_n == n) continue;\n\t\t\t\tif(now_pren == n) continue;\n\t\t\t\tif(D[now_n][n] < 0) continue;\n\t\t\t\t\n\t\t\t\t// 速度-1\n\t\t\t\tif(1 < now_c)\n\t\t\t\t{\n\t\t\t\t\tif((now_c-1) <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c-1);\n\t\t\t\t\t\tif(ntime < times[n][now_n][now_c-1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttimes[n][now_n][now_c-1] = ntime;\n\t\t\t\t\t\t\tqueue.offer(new int[]{n, now_n, now_c-1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 速度そのまま\n\t\t\t\tif(true)\n\t\t\t\t{\n\t\t\t\t\tif(now_c <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)now_c;\n\t\t\t\t\t\tif(ntime < times[n][now_n][now_c])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttimes[n][now_n][now_c] = ntime;\n\t\t\t\t\t\t\tqueue.offer(new int[]{n, now_n, now_c});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(now_n == S && now_c == 1) continue;\n\t\t\t\t\n\t\t\t\t// 速度+1\n\t\t\t\tif(now_c < 30)\n\t\t\t\t{\n\t\t\t\t\tif((now_c+1) <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c+1);\n\t\t\t\t\t\tif(ntime < times[n][now_n][now_c+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttimes[n][now_n][now_c+1] = ntime;\n\t\t\t\t\t\t\tqueue.offer(new int[]{n, now_n, now_c+1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n    \t}\n    \t\n    \tSystem.out.println(\"unreachable\");\n    }\n     \n    public static void main(String[] args)\n    {\n        Scanner sca = new Scanner(System.in);\n        \n        while(true)\n        {\n        \tN = sca.nextInt();\n        \tM = sca.nextInt();\n        \tif(N == 0) break;\n        \t\n        \tS = sca.nextInt();\n        \tG = sca.nextInt();\n        \t\n        \tD = new int[N+1][N+1];\n        \tC = new int[N+1][N+1];\n        \tfor (int i = 0; i <= N; i++) {\n\t\t\t\tfor (int j = 0; j <= N; j++) {\n\t\t\t\t\tD[i][j] = C[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n        \t\n        \tfor (int i = 0; i < M; i++) {\n\t\t\t\tint x = sca.nextInt();\n\t\t\t\tint y = sca.nextInt();\n\t\t\t\tint d = sca.nextInt();\n\t\t\t\tint c = sca.nextInt();\n\t\t\t\t\n\t\t\t\tD[y][x] = D[x][y] = d;\n\t\t\t\tC[y][x] = C[x][y] = c;\n\t\t\t}\n            \n            start();\n        }\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n \npublic class Main {\n    \n\tstatic int N, M;\n\tstatic int S, G;\n\tstatic int[][] D, C;\n\t\n    static void start()\n    {\n    \tdouble[][][] times = new double[N+1][N+1][31];\n    \tboolean[][][] check = new boolean[N+1][N+1][31];\n    \t\n    \tfor (int n = 0; n < N+1; n++) {\n\t\t\tfor (int pren = 0; pren < N+1; pren++) {\n\t\t\t\tfor (int c = 0; c < 31; c++) {\n\t\t\t\t\ttimes[n][pren][c] = Double.MAX_VALUE;\n\t\t\t\t\tcheck[n][pren][c] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \t\n    \tPriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n    \t\tpublic int compare(int[] a, int[] b)\n    \t\t{\n    \t\t\tdouble ia = times[ a[0] ][ a[1] ][ a[2] ];\n    \t\t\tdouble ib = times[ b[0] ][ b[1] ][ b[2] ];\n    \t\t\tif(ia < ib)\n    \t\t\t\treturn -1;\n    \t\t\telse if(ia == ib)\n    \t\t\t\treturn 0;\n    \t\t\telse {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n    \t\t}\n\t\t});\n    \t\n    \ttimes[S][0][1] = 0;\n    \tqueue.offer(new int[]{S, 0, 1});\n    \t\n    \twhile(!queue.isEmpty())\n    \t{\n    \t\tint now_n = 0, now_pren = 0, now_c = 0;\n    \t\t\n    \t\t// スタート位置の決定\n    \t\tint[] qq = queue.poll();\n    \t\tnow_n = qq[0];\n    \t\tnow_pren = qq[1];\n    \t\tnow_c = qq[2];\n    \t\t\n    \t\tif(now_n == G && now_c == 1)\n    \t\t{\n    \t\t\tSystem.out.printf(\"%.05f\\n\", times[now_n][now_pren][now_c]);\n    \t\t\treturn;\n    \t\t}\n    \t\t\n    \t\tif(check[now_n][now_pren][now_c] == true) continue;\n    \t\t\n    \t\t// 処理\n    \t\tcheck[now_n][now_pren][now_c] = true;\n    \t\t\n    \t\tfor (int n = 1; n <= N; n++) {\n    \t\t\tif(now_n == n) continue;\n\t\t\t\tif(now_pren == n) continue;\n\t\t\t\tif(D[now_n][n] < 0) continue;\n\t\t\t\t\n\t\t\t\t// 速度-1\n\t\t\t\tif(1 < now_c)\n\t\t\t\t{\n\t\t\t\t\tif((now_c-1) <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c-1);\n\t\t\t\t\t\tif(ntime < times[n][now_n][now_c-1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttimes[n][now_n][now_c-1] = ntime;\n\t\t\t\t\t\t\tqueue.offer(new int[]{n, now_n, now_c-1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 速度そのまま\n\t\t\t\tif(true)\n\t\t\t\t{\n\t\t\t\t\tif(now_c <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)now_c;\n\t\t\t\t\t\tif(ntime < times[n][now_n][now_c])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttimes[n][now_n][now_c] = ntime;\n\t\t\t\t\t\t\tqueue.offer(new int[]{n, now_n, now_c});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(now_n == S && now_c == 1) continue;\n\t\t\t\t\n\t\t\t\t// 速度+1\n\t\t\t\tif(now_c < 30)\n\t\t\t\t{\n\t\t\t\t\tif((now_c+1) <= C[now_n][n])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble ntime = times[now_n][now_pren][now_c] + (double)D[now_n][n] / (double)(now_c+1);\n\t\t\t\t\t\tif(ntime < times[n][now_n][now_c+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttimes[n][now_n][now_c+1] = ntime;\n\t\t\t\t\t\t\tqueue.offer(new int[]{n, now_n, now_c+1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n    \t}\n    \t\n    \tSystem.out.println(\"unreachable\");\n    }\n     \n    public static void main(String[] args)\n    {\n        Scanner sca = new Scanner(System.in);\n        \n        while(true)\n        {\n        \tN = sca.nextInt();\n        \tM = sca.nextInt();\n        \tif(N == 0) break;\n        \t\n        \tS = sca.nextInt();\n        \tG = sca.nextInt();\n        \t\n        \tD = new int[N+1][N+1];\n        \tC = new int[N+1][N+1];\n        \tfor (int i = 0; i <= N; i++) {\n\t\t\t\tfor (int j = 0; j <= N; j++) {\n\t\t\t\t\tD[i][j] = C[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n        \t\n        \tfor (int i = 0; i < M; i++) {\n\t\t\t\tint x = sca.nextInt();\n\t\t\t\tint y = sca.nextInt();\n\t\t\t\tint d = sca.nextInt();\n\t\t\t\tint c = sca.nextInt();\n\t\t\t\t\n\t\t\t\tD[y][x] = D[x][y] = d;\n\t\t\t\tC[y][x] = C[x][y] = c;\n\t\t\t}\n            \n            start();\n        }\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint g = in.nextInt()-1;\n\t\t\tboolean[][] used = new boolean[n][31];\n\t\t\tint[][] rist = new int[n][n];\n\t\t\tint[][] dist = new int[n][n];\n\t\t\tNode[] node = new Node[n];\n\t\t\tfor(int i=0; i<n; i++) node[i] = new Node(i);\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint x = in.nextInt()-1;\n\t\t\t\tint y = in.nextInt()-1;\n\t\t\t\tint d = in.nextInt();\n\t\t\t\tint c = in.nextInt();\n\t\t\t\tnode[x].createEdge(node[y]);\n\t\t\t\tnode[y].createEdge(node[x]);\n\t\t\t\tdist[x][y] = dist[y][x] = d;\n\t\t\t\trist[x][y] = rist[y][x] = c;\n\t\t\t}\n\t\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n\t\t\tqu.add(new Pos(s, 0, 0, 0));\n\t\t\tdouble time = -1;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(used[p.city][p.vel]) continue;\n\t\t\t\tif(p.city == g && p.vel == 1){\n\t\t\t\t\ttime = p.dist;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tused[p.city][p.vel] = true;\n\t\t\t\tfor(Node nd: node[p.city].list){\n\t\t\t\t\tif(p.back == nd.id) continue;\n\t\t\t\t\tfor(int i=-1; i<=1; i++){\n\t\t\t\t\t\tint v = p.vel+i;\n\t\t\t\t\t\tif(v < 1 || v > rist[p.city][nd.id]) continue;\n\t\t\t\t\t\tqu.add(new Pos(nd.id, p.city, v, p.dist + (double)dist[p.city][nd.id]/v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(time < 0 ? \"unreachable\" : time);\n\t\t}\n\t}\n}\n\nclass Node{\n\tint id;\n\tList<Node> list = new ArrayList<Node>();\n\tpublic Node(int id){\n\t\tthis.id = id;\n\t}\n\t\n\tpublic void createEdge(Node nd){\n\t\tlist.add(nd);\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tint city;\n\tint back;\n\tint vel;\n\tdouble dist;\n\tpublic Pos(int c, int back, int v, double dist){\n\t\tcity = c;\n\t\tvel = v;\n\t\tthis.back = back;\n\t\tthis.dist = dist;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn Double.compare(dist, o.dist);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n \n    static int start, goal;             // スタート都市、ゴール都市\n    static int n_city, m_road;      // 都市の数、道の数\n    static int[][] road_dist;           // 道の距離情報\n    static int[][] speed_limit;     // 道の制限速度情報\n    static double[][][] city;           // ダイクストラ　最短時間保管表\n    static boolean[][][] enter;     // ダイクストラ　最短時間確定\n    static final int speed_law = 30;\n    static double ans2;\n     \n    // ダイクストラアルゴリズム\n    static double Dijkstra(){\n        // 初期設定。最短時間をMAX値で初期化。\n        city = new double[n_city+1][n_city+1][speed_law+1];\n        enter = new boolean[n_city+1][n_city+1][speed_law+1];\n        for(int i=0;i<=n_city;i++){\n            for(int j=0;j<=n_city;j++){\n                for(int k=0;k<=speed_law;k++){\n                    city[i][j][k] = Double.MAX_VALUE;\n                }\n            }\n        }\n        city[start][start][1] = 0;      // スタート→スタートで速度1の場合、所要時間0\n        // ループアルゴ(状態遷移を次々と決める)\n        //  cf. 状態遷移とは「ある都市→ある都市の移動(速度も含む)」\n        while(true){\n            // 最短時間表から最も最短時間な状態遷移を探す\n            double fast = Double.MAX_VALUE;\n            int x, y, z;        // fastのindex\n            x = y = z = -1;\n            for(int i=1;i<=n_city;i++){\n                for(int j=1;j<=n_city;j++){\n                    for(int k=1;k<=speed_law;k++){\n                        if(!enter[i][j][k]&&city[i][j][k]<fast){     // 確定されてない & 最短時間\n                            fast = city[i][j][k];\n                            x = i;  y = j;  z = k;      // 設定されるxはstartと同値が既知\n                        }\n                    }\n                }\n            }\n            // 表において探した最も最短時間な状態遷移が、\n            //      スタート→ゴールで速度が1の場合は解が得られる\n            if(x==start&&y==goal&&z==1){\n            \tans2 = Math.min(ans2, city[x][y][z]);\n//                return city[x][y][1];\n            }\n            // 最短時間の更新が一度もされない→状態遷移がすべて確定してしまった\n            //  (ゴールに辿りつける道がない or ゴール時に速度が1とならない)\n            else if(x==-1){\n                break;\n            }\n            enter[x][y][z] = true;      // 探した最短時間状態遷移を確定する\n//          System.out.println(\"enter : x=\"+x+\", y=\"+y+\", z=\"+z+\" time=\"+city[x][y][z]);\n            // 確定した状態遷移から移動できる都市を更新しにいく (yからnexの移動)\n            for(int nex=1;nex<=n_city;nex++){        // nex = 遷移先(次)\n                // 速度3パターン(-1,0,1)、zは元の速度、spdは遷移時の速度\n                for(int spd=z-1;spd<=z+1;spd++){\n                    // スピード負値、制限速度オーバー、道路がない　場合は除外\n                    if(spd<=0||spd>speed_limit[y][nex]||road_dist[y][nex]==Double.MAX_VALUE){\n                        continue;\n                    }\n                    // スタート地点から出る道とゴール地点に到達する道は必ず速度1 (この問題においての超重要点)\n                    //  さらには今来た道なら引き返しなのでNG(x->y y->nex(x) ... x=nex=start)\n                    //      さらには状態遷移が決定していれば更新の必要性はない\n                    if(x==start&&y==start&&z==1&&spd!=1){\n//                      System.out.println(\"s=\"+start+\" g=\"+goal+\" y=\"+y+\" z=\"+z+\" nex=\"+nex+\" spd=\"+spd);\n                        continue;\n                    }\n//                  System.out.println(\"connect : y=\"+y+\", nex=\"+nex+\", spd=\"+spd);\n                    // 時間 = 距離 / 速度\n                    city[x][nex][spd] = Math.min(city[x][y][z] + road_dist[y][nex]*1.0/spd , city[x][nex][spd]);\n                }\n            }\n        }\n//        System.out.println(ans2);\n        return -1;\n    }\n     \n    public static void main(String[] args) {\n        Scanner stdIn = new Scanner(System.in);\n        while(true){\n            n_city = stdIn.nextInt();\n            m_road = stdIn.nextInt();\n            if((n_city|m_road)==0){\n                return;\n            }\n            start = stdIn.nextInt();\n            goal = stdIn.nextInt();\n            road_dist = new int[n_city+1][n_city+1];\n            speed_limit = new int[n_city+1][n_city+1];\n            for(int i=0;i<m_road;i++){\n                int x = stdIn.nextInt();\n                int y = stdIn.nextInt();\n                int d = stdIn.nextInt();\n                int c = stdIn.nextInt();\n                road_dist[x][y] = road_dist[y][x] = d;\n                speed_limit[x][y] = speed_limit[y][x] = c;\n            }\n            ans2 = 10000;\n            double ans = Dijkstra();\n            if(ans2!=10000){\n                System.out.printf(\"%.5f\\n\",ans2);\n            }\n            else{\n                System.out.println(\"unreachable\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint g = in.nextInt()-1;\n//\t\t\tboolean[][] used = new boolean[n][31];\n\t\t\tint[][] rist = new int[n][n];\n\t\t\tint[][] dist = new int[n][n];\n\t\t\tNode[] node = new Node[n];\n\t\t\tfor(int i=0; i<n; i++) node[i] = new Node(i);\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint x = in.nextInt()-1;\n\t\t\t\tint y = in.nextInt()-1;\n\t\t\t\tint d = in.nextInt();\n\t\t\t\tint c = in.nextInt();\n\t\t\t\tnode[x].createEdge(node[y]);\n\t\t\t\tnode[y].createEdge(node[x]);\n\t\t\t\tdist[x][y] = dist[y][x] = d;\n\t\t\t\trist[x][y] = rist[y][x] = c;\n\t\t\t}\n\t\t\tdouble[][] best = new double[n][31];\n\t\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n\t\t\tqu.add(new Pos(s, -1, 0, 0));\n\t\t\tdouble time = -1;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif((best[p.city][p.vel] != 0\n\t\t\t\t\t\t\t\t&& best[p.city][p.vel] < p.dist)) continue;\n\t\t\t\tbest[p.city][p.vel] = p.dist;\n\t\t\t\tif(p.city == g && p.vel == 1){\n\t\t\t\t\ttime = p.dist;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n//\t\t\t\tused[p.city][p.vel] = true;\n\t\t\t\tfor(Node nd: node[p.city].list){\n\t\t\t\t\tif(p.back == nd.id) continue;\n\t\t\t\t\tfor(int i=-1; i<=1; i++){\n\t\t\t\t\t\tint v = p.vel+i;\n\t\t\t\t\t\tif(v < 1 || v > rist[p.city][nd.id]) continue;\n\t\t\t\t\t\tqu.add(new Pos(nd.id, p.city, v, p.dist + (double)dist[p.city][nd.id]/v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(time < 0 ? \"unreachable\" : time);\n\t\t}\n\t}\n}\n\nclass Node{\n\tint id;\n\tList<Node> list = new ArrayList<Node>();\n\tpublic Node(int id){\n\t\tthis.id = id;\n\t}\n\t\n\tpublic void createEdge(Node nd){\n\t\tlist.add(nd);\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tint city;\n\tint back;\n\tint vel;\n\tdouble dist;\n\tpublic Pos(int c, int back, int v, double dist){\n\t\tcity = c;\n\t\tvel = v;\n\t\tthis.back = back;\n\t\tthis.dist = dist;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn Double.compare(dist, o.dist);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n==0 && m==0) break;\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\t\t\t\n\t\t\tint[][] d = new int[n+1][n+1];\n\t\t\tint[][] c = new int[n+1][n+1];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\td[x][y] = d[y][x] =  sc.nextInt();\n\t\t\t\tc[x][y] = c[y][x] =  sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tdouble[][] dp = new double[31][n+1];\n\t\t\tfor(int i=0;i<31;i++) Arrays.fill(dp[i], Integer.MAX_VALUE);\n\t\t\t\n\t\t\tArrayDeque<Integer> p = new ArrayDeque<Integer>();\n\t\t\tArrayDeque<Integer> v = new ArrayDeque<Integer>();\n\t\t\tp.offer(s);\n\t\t\tv.offer(0);\n\t\t\tdp[0][s] = 0;\n\t\t\twhile(p.size()!=0){\n\t\t\t\tint q = p.poll();\n\t\t\t\tint u = v.poll();\n\t\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\tif(d[q][i]>0){\n\t\t\t\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\t\t\t\tif(0<u+j && u+j<=c[q][i] && dp[u+j][i] > dp[u][q] + (double)d[q][i]/(u+j)){\n\t\t\t\t\t\t\t\tdp[u+j][i] = dp[u][q] + (double)d[q][i]/(u+j);\n\t\t\t\t\t\t\t\tp.offer(i);\n\t\t\t\t\t\t\t\tv.offer(u+j);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tif(dp[1][g]==Integer.MAX_VALUE) System.out.println(\"unreachable\");\n\t\t\telse System.out.println(dp[1][g]);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Descrete Speed\npublic class Main{\n\n\tpublic static int n;\n\tpublic static int m;\n\tpublic static int start;\n\tpublic static int goal;\n\n\tpublic static double[][][] dist;\n\tpublic static int[][] r;\n\tpublic static int[][] limit;\n\n\tpublic static double dijkstra(){\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tfor(int k=0;k<31;k++)\n\t\t\t\t\tdist[i][j][k] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tdist[start][0][0] = 0;\n\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(n, new Comparator<int[]>(){\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn dist[a[0]][a[1]][a[2]]-dist[b[0]][b[1]][b[2]]<0?-1:dist[a[0]][a[1]][a[2]]-dist[b[0]][b[1]][b[2]]>0?1:0;\n\t\t\t}\n\t\t});\n\t\tq.add(new int[]{start,0,0});\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] uu = q.poll();\n\t\t\tint u = uu[0];\n\t\t\tint pre = uu[1];\n\t\t\tint v = uu[2];\n\t\t\tif(u==goal&&v==1)return dist[u][pre][v];\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(i!=pre && r[u][i]!=0){\n\t\t\t\t\tfor(int x=v-1;x<=v+1;x++){\n\t\t\t\t\t\tif(x<=0)continue;\n\t\t\t\t\t\tif(x>limit[u][i])continue;\n\t\t\t\t\t\tdouble nc = dist[u][pre][v] + r[u][i]*1.0/x;\n\t\t\t\t\t\tif(nc < dist[i][u][x]){\n\t\t\t\t\t\t\tdist[i][u][x] = nc;\n\t\t\t\t\t\t\tq.add(new int[]{i, u, x});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif(n==0&&m==0)break;\n\t\t\tdist = new double[n+1][n+1][31];\n\t\t\tr = new int[n+1][n+1];\n\t\t\tlimit = new int[n+1][n+1];\n\t\t\tstart = sc.nextInt();\n\t\t\tgoal = sc.nextInt();\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint u = sc.nextInt();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tr[u][v] = r[v][u] = d;\n\t\t\t\tlimit[u][v] = limit[v][u] = l;\n\t\t\t}\n\t\t\tdouble ans = dijkstra();\n\t\t\tif(ans==-1)System.out.println(\"unreachable\");\n\t\t\telse System.out.printf(\"%.5f\\n\", ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  // constant\n  static final double INF = Double.POSITIVE_INFINITY;\n  static final int MAX_V = 30;\n\n  // global variables\n  static double[][][] times;\n\n  // inner classes\n  static class Node implements Comparable<Node> {\n    int n, f, v;\n\n    Node(int n, int f, int v) {\n      this.n = n;\n      this.f = f;\n      this.v = v;\n    }\n\n    public boolean equals(Node nd) {\n      return (n == nd.n && f == nd.f && v == nd.v);\n    }\n\n    public int compareTo(Node nd) {\n      double t = times[n][f][v] - times[nd.n][nd.f][nd.v];\n      return ((t < 0.0) ? -1 : (t > 0.0) ? 1 : 0);\n    }\n  }\n\n  static class Edge {\n    double d;\n    int c;\n    \n    Edge(double d, int c) {\n      this.d = d;\n      this.c = c;\n    }\n  }\n  \n  // main\n  public static final void main(String[] args) throws Exception {\n    Scanner sc = new Scanner(System.in);\n\n    for (;;) {\n      int n = sc.nextInt();\n      int m = sc.nextInt();\n      if ((n | m) == 0) break;\n\n      int st = sc.nextInt() - 1;\n      int gl = sc.nextInt() - 1;\n\n      Edge[][] edges = new Edge[n][n];\n\n      ArrayList<ArrayList<Integer>> nbrs = new ArrayList<ArrayList<Integer>>();\n      for (int i = 0; i < n; i++) nbrs.add(new ArrayList<Integer>());\n\n      for (int i = 0; i < m; i++) {\n\tint xi = sc.nextInt() - 1;\n\tint yi = sc.nextInt() - 1;\n\tdouble di = sc.nextDouble();\n\tint ci = sc.nextInt();\n\n\tedges[xi][yi] = edges[yi][xi] = new Edge(di, ci);\n\tnbrs.get(xi).add(yi);\n\tnbrs.get(yi).add(xi);\n      }\n\n      times = new double[n][n][MAX_V + 1];\n      for (int i = 0; i < n; i++)\n\tfor (int j = 0; j < n; j++)\n\t  for (int k = 0; k <= MAX_V; k++)\n\t    times[i][j][k] = INF;\n      times[st][st][0] = 0.0;\n\n      PriorityQueue<Node> q = new PriorityQueue<Node>();\n      q.add(new Node(st, st, 0));\n\n      double min_t = INF;\n  \n      while (! q.isEmpty()) {\n\tNode u = q.poll();\n\n\tint un = u.n;\n\tint uf = u.f;\n\tint uv = u.v;\n\tdouble ut = times[un][uf][uv];\n\n\tif (un == gl && uv == 1) {\n\t  if (min_t > ut) min_t = ut;\n\t  continue;\n\t}\n\n\tfor (int vn: nbrs.get(un)) {\n\t  if (vn == uf) continue;\n\n\t  Edge ve = edges[un][vn];\n\t  double vd = ve.d;\n\t  int vc = ve.c;\n\t  if (uv - 1 > vc) continue;\n      \n\t  for (int vv = uv - 1; vv <= uv + 1; vv++) {\n\t    if (vv <= 0 || vv > vc) continue;\n\n\t    double nvt = ut + vd / vv;\n\t    double vt = times[vn][un][vv];\n\n\t    if (vt > nvt) {\n\t      Node v = new Node(vn, un, vv);\n\t      if (vt < INF) q.remove(v);\n\t      times[vn][un][vv] = nvt;\n\t      q.add(v);\n\t    }\n\t  }\n\t}\n      }\n\n      if (min_t >= INF)\n\tSystem.out.println(\"unreachable\");\n      else\n\tSystem.out.printf(\"%.5f\\n\", min_t);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n \n    static int start, goal;             // スタート都市、ゴール都市\n    static int n_city, m_road;      // 都市の数、道の数\n    static int[][] road_dist;           // 道の距離情報\n    static int[][] speed_limit;     // 道の制限速度情報\n    static double[][][] city;           // ダイクストラ　最短時間保管表\n    static boolean[][][] enter;     // ダイクストラ　最短時間確定\n    static final int speed_law = 30;\n    static double ans2;\n    static int[][][] pre;\n     \n    // ダイクストラアルゴリズム\n    static double Dijkstra(){\n        // 初期設定。最短時間をMAX値で初期化。\n        city = new double[n_city+1][n_city+1][speed_law+1];\n        enter = new boolean[n_city+1][n_city+1][speed_law+1];\n//        pre = new int[n_city+1][n_city+1][speed_law+1];\n        for(int i=0;i<=n_city;i++){\n            for(int j=0;j<=n_city;j++){\n                for(int k=0;k<=speed_law;k++){\n                    city[i][j][k] = Double.MAX_VALUE;\n                }\n            }\n        }\n        city[start][start][1] = 0;      // スタート→スタートで速度1の場合、所要時間0\n        // ループアルゴ(状態遷移を次々と決める)\n        //  cf. 状態遷移とは「ある都市→ある都市の移動(速度も含む)」\n        while(true){\n            // 最短時間表から最も最短時間な状態遷移を探す\n            double fast = Double.MAX_VALUE;\n            int x, y, z;        // fastのindex\n            x = y = z = -1;\n            for(int i=1;i<=n_city;i++){\n                for(int j=1;j<=n_city;j++){\n                    for(int k=1;k<=speed_law;k++){\n                        if(!enter[i][j][k]&&city[i][j][k]<fast){     // 確定されてない & 最短時間\n                            fast = city[i][j][k];\n                            x = i;  y = j;  z = k;      // 設定されるxはstartと同値が既知\n                        }\n                    }\n                }\n            }\n            // 表において探した最も最短時間な状態遷移が、\n            //      スタート→ゴールで速度が1の場合は解が得られる\n//            System.out.println(\"time=\"+city[x][y][z]);\n            if(y==goal&&z==1){\n            \tans2 = Math.min(ans2, city[x][y][z]);\n//                return city[x][y][1];\n            }\n            // 最短時間の更新が一度もされない→状態遷移がすべて確定してしまった\n            //  (ゴールに辿りつける道がない or ゴール時に速度が1とならない)\n            else if(x==-1){\n                break;\n            }\n            enter[x][y][z] = true;      // 探した最短時間状態遷移を確定する\n//          System.out.println(\"enter : x=\"+x+\", y=\"+y+\", z=\"+z+\" pre=\"+pre[x][y][z]+\" time=\"+city[x][y][z]);\n            // 確定した状態遷移から移動できる都市を更新しにいく (yからnexの移動)\n            for(int nex=1;nex<=n_city;nex++){        // nex = 遷移先(次)\n                // 速度3パターン(-1,0,1)、zは元の速度、spdは遷移時の速度\n                for(int spd=z-1;spd<=z+1;spd++){\n                    // スピード負値、制限速度オーバー、道路がない　場合は除外\n                    if(spd<=0||spd>speed_limit[y][nex]||road_dist[y][nex]==Double.MAX_VALUE){\n                        continue;\n                    }\n                    // スタート地点から出る道とゴール地点に到達する道は必ず速度1 (この問題においての超重要点)\n                    //  さらには今来た道なら引き返しなのでNG(x->y y->nex(x) ... x=nex=start)\n                    //      さらには状態遷移が決定していれば更新の必要性はない\n                    if((x==start&&y==start&&z==1&&spd!=1)||x==nex){\n//                      System.out.println(\"s=\"+start+\" g=\"+goal+\" y=\"+y+\" z=\"+z+\" nex=\"+nex+\" spd=\"+spd);\n                        continue;\n                    }\n//                  System.out.println(\"connect : x=\"+x+\" y=\"+y+\", nex=\"+nex+\", spd=\"+spd);\n                    // 時間 = 距離 / 速度\n                  if(city[y][nex][spd]>city[x][y][z] + road_dist[y][nex]*1.0/spd){\n                \t  city[y][nex][spd] = city[x][y][z] + road_dist[y][nex]*1.0/spd; \n                  }\n                                  \n                  \n                  \n//                    city[x][nex][spd] = Math.min(city[x][y][z] + road_dist[y][nex]*1.0/spd , city[x][nex][spd]);\n                }\n            }\n        }\n//        System.out.println(ans2);\n        return -1;\n    }\n     \n    public static void main(String[] args) {\n        Scanner stdIn = new Scanner(System.in);\n        while(true){\n            n_city = stdIn.nextInt();\n            m_road = stdIn.nextInt();\n            if((n_city|m_road)==0){\n                return;\n            }\n            start = stdIn.nextInt();\n            goal = stdIn.nextInt();\n            road_dist = new int[n_city+1][n_city+1];\n            speed_limit = new int[n_city+1][n_city+1];\n            for(int i=0;i<m_road;i++){\n                int x = stdIn.nextInt();\n                int y = stdIn.nextInt();\n                int d = stdIn.nextInt();\n                int c = stdIn.nextInt();\n                road_dist[x][y] = road_dist[y][x] = d;\n                speed_limit[x][y] = speed_limit[y][x] = c;\n            }\n            ans2 = 10000000;\n            double ans = Dijkstra();\n            if(ans2!=10000000){\n                System.out.printf(\"%.5f\\n\",ans2);\n            }\n            else{\n                System.out.println(\"unreachable\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n \n    static int start, goal;             // スタート都市、ゴール都市\n    static int n_city, m_road;      // 都市の数、道の数\n    static int[][] road_dist;           // 道の距離情報\n    static int[][] speed_limit;     // 道の制限速度情報\n    static double[][][] city;           // ダイクストラ　最短時間保管表\n    static boolean[][][] enter;     // ダイクストラ　最短時間確定\n    static final int speed_law = 30;\n    static double ans2;\n    static int[][][] pre;\n     \n    // ダイクストラアルゴリズム\n    static double Dijkstra(){\n        // 初期設定。最短時間をMAX値で初期化。\n        city = new double[n_city+1][n_city+1][speed_law+1];\n        enter = new boolean[n_city+1][n_city+1][speed_law+1];\n        pre = new int[n_city+1][n_city+1][speed_law+1];\n        for(int i=0;i<=n_city;i++){\n            for(int j=0;j<=n_city;j++){\n                for(int k=0;k<=speed_law;k++){\n                    city[i][j][k] = Double.MAX_VALUE;\n                }\n            }\n        }\n        city[start][start][1] = 0;      // スタート→スタートで速度1の場合、所要時間0\n        // ループアルゴ(状態遷移を次々と決める)\n        //  cf. 状態遷移とは「ある都市→ある都市の移動(速度も含む)」\n        while(true){\n            // 最短時間表から最も最短時間な状態遷移を探す\n            double fast = Double.MAX_VALUE;\n            int x, y, z;        // fastのindex\n            x = y = z = -1;\n            for(int i=1;i<=n_city;i++){\n                for(int j=1;j<=n_city;j++){\n                    for(int k=1;k<=speed_law;k++){\n                        if(!enter[i][j][k]&&city[i][j][k]<fast){     // 確定されてない & 最短時間\n                            fast = city[i][j][k];\n                            x = i;  y = j;  z = k;      // 設定されるxはstartと同値が既知\n                        }\n                    }\n                }\n            }\n            // 表において探した最も最短時間な状態遷移が、\n            //      スタート→ゴールで速度が1の場合は解が得られる\n//            System.out.println(\"time=\"+city[x][y][z]);\n            if(x==start&&y==goal&&z==1){\n            \tans2 = Math.min(ans2, city[x][y][z]);\n//                return city[x][y][1];\n            }\n            // 最短時間の更新が一度もされない→状態遷移がすべて確定してしまった\n            //  (ゴールに辿りつける道がない or ゴール時に速度が1とならない)\n            else if(x==-1){\n                break;\n            }\n            enter[x][y][z] = true;      // 探した最短時間状態遷移を確定する\n//          System.out.println(\"enter : x=\"+x+\", y=\"+y+\", z=\"+z+\" pre=\"+pre[x][y][z]+\" time=\"+city[x][y][z]);\n            // 確定した状態遷移から移動できる都市を更新しにいく (yからnexの移動)\n            for(int nex=1;nex<=n_city;nex++){        // nex = 遷移先(次)\n                // 速度3パターン(-1,0,1)、zは元の速度、spdは遷移時の速度\n                for(int spd=z-1;spd<=z+1;spd++){\n                    // スピード負値、制限速度オーバー、道路がない　場合は除外\n                    if(spd<=0||spd>speed_limit[y][nex]||road_dist[y][nex]==Double.MAX_VALUE){\n                        continue;\n                    }\n                    // スタート地点から出る道とゴール地点に到達する道は必ず速度1 (この問題においての超重要点)\n                    //  さらには今来た道なら引き返しなのでNG(x->y y->nex(x) ... x=nex=start)\n                    //      さらには状態遷移が決定していれば更新の必要性はない\n                    if((x==start&&y==start&&z==1&&spd!=1)||y==nex||pre[x][y][z]==nex){\n//                      System.out.println(\"s=\"+start+\" g=\"+goal+\" y=\"+y+\" z=\"+z+\" nex=\"+nex+\" spd=\"+spd);\n                        continue;\n                    }\n//                  System.out.println(\"connect : y=\"+y+\", nex=\"+nex+\", spd=\"+spd);\n                    // 時間 = 距離 / 速度\n                  if(city[x][nex][spd]>=city[x][y][z] + road_dist[y][nex]*1.0/spd){\n                \t  city[x][nex][spd] = city[x][y][z] + road_dist[y][nex]*1.0/spd;\n                \t  pre[x][nex][spd] = y; \n                  }\n//                    city[x][nex][spd] = Math.min(city[x][y][z] + road_dist[y][nex]*1.0/spd , city[x][nex][spd]);\n                }\n            }\n        }\n//        System.out.println(ans2);\n        return -1;\n    }\n     \n    public static void main(String[] args) {\n        Scanner stdIn = new Scanner(System.in);\n        while(true){\n            n_city = stdIn.nextInt();\n            m_road = stdIn.nextInt();\n            if((n_city|m_road)==0){\n                return;\n            }\n            start = stdIn.nextInt();\n            goal = stdIn.nextInt();\n            road_dist = new int[n_city+1][n_city+1];\n            speed_limit = new int[n_city+1][n_city+1];\n            for(int i=0;i<m_road;i++){\n                int x = stdIn.nextInt();\n                int y = stdIn.nextInt();\n                int d = stdIn.nextInt();\n                int c = stdIn.nextInt();\n                road_dist[x][y] = road_dist[y][x] = d;\n                speed_limit[x][y] = speed_limit[y][x] = c;\n            }\n            ans2 = 10000;\n            double ans = Dijkstra();\n            if(ans2!=10000){\n                System.out.printf(\"%.5f\\n\",ans2);\n            }\n            else{\n                System.out.println(\"unreachable\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint g = in.nextInt()-1;\n\t\t\tboolean[][] used = new boolean[n][31];\n\t\t\tint[][] rist = new int[n][n];\n\t\t\tint[][] dist = new int[n][n];\n\t\t\tNode[] node = new Node[n];\n\t\t\tfor(int i=0; i<n; i++) node[i] = new Node(i);\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint x = in.nextInt()-1;\n\t\t\t\tint y = in.nextInt()-1;\n\t\t\t\tint d = in.nextInt();\n\t\t\t\tint c = in.nextInt();\n\t\t\t\tnode[x].createEdge(node[y]);\n\t\t\t\tnode[y].createEdge(node[x]);\n\t\t\t\tdist[x][y] = dist[y][x] = d;\n\t\t\t\trist[x][y] = rist[y][x] = c;\n\t\t\t}\n\t\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n\t\t\tqu.add(new Pos(s, 0, 0));\n\t\t\tdouble time = -1;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(used[p.city][p.vel]) continue;\n\t\t\t\tif(p.city == g && p.vel == 1){\n\t\t\t\t\ttime = p.dist;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n//\t\t\t\telse if(p.city == g) continue;\n\t\t\t\tused[p.city][p.vel] = true;\n\t\t\t\tfor(Node nd: node[p.city].list){\n\t\t\t\t\tfor(int i=-1; i<=1; i++){\n\t\t\t\t\t\tint v = p.vel+i;\n\t\t\t\t\t\tif(v < 1 || v > rist[p.city][nd.id]) continue;\n\t\t\t\t\t\tqu.add(new Pos(nd.id, v, p.dist + (double)dist[p.city][nd.id]/v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(time < 0 ? \"unreachable\" : time);\n\t\t}\n\t}\n}\n\nclass Node{\n\tint id;\n\tList<Node> list = new ArrayList<Node>();\n\tpublic Node(int id){\n\t\tthis.id = id;\n\t}\n\t\n\tpublic void createEdge(Node nd){\n\t\tlist.add(nd);\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tint city;\n\tint vel;\n\tdouble dist;\n\tpublic Pos(int c, int v, double dist){\n\t\tcity = c;\n\t\tvel = v;\n\t\tthis.dist = dist;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn Double.compare(dist, o.dist);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint pos;\n\t\tint prev_pos;\n\t\tint speed;\n\t\tdouble time;\n\t\t\n\t\tpublic Walk(int pos, int prev_pos, int speed, double time) {\n\t\t\tsuper();\n\t\t\tthis.pos = pos;\n\t\t\tthis.prev_pos = prev_pos;\n\t\t\tthis.speed = speed;\n\t\t\tthis.time = time;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk o) {\n\t\t\treturn Double.compare(this.time, o.time);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int s = sc.nextInt() - 1;\n\t\t\tfinal int g = sc.nextInt() - 1;\n\t\t\t\n\t\t\tint[][] dist  = new int[n][n];\n\t\t\tint[][] limit = new int[n][n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tdist[i][j] = -1;\n\t\t\t\t\tlimit[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int x = sc.nextInt() - 1;\n\t\t\t\tfinal int y = sc.nextInt() - 1;\n\t\t\t\tfinal int d = sc.nextInt();\n\t\t\t\tfinal int c = sc.nextInt();\n\t\t\t\t\n\t\t\t\tdist[x][y]  = dist[y][x]  = d;\n\t\t\t\tlimit[x][y] = limit[y][x] = c;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][][] is_visited = new boolean[n][n][30 + 1];\n\t\t\t\n\t\t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>();\n\t\t\tqueue.add(new Walk(s, -1, 1, 0));\n\t\t\t\n\t\t\tboolean flag = false;\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(walk.pos + \" \" + walk.prev_pos + \" \" + walk.time + \" \" + walk.speed);\n\t\t\t\t\n\t\t\t\tif(walk.prev_pos != -1 && is_visited[walk.pos][walk.prev_pos][walk.speed]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(walk.prev_pos != -1){\n\t\t\t\t\tis_visited[walk.pos][walk.prev_pos][walk.speed] = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.pos == g && walk.speed == 1){\n\t\t\t\t\tSystem.out.printf(\"%f\\n\", walk.time);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int to = 0; to < n; to++){\n\t\t\t\t\tif(dist[walk.pos][to] < 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(to == walk.prev_pos){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(walk.prev_pos == -1){\n\t\t\t\t\t\tif(limit[walk.pos][to] >= 1 && !is_visited[to][walk.pos][1]){\n\t\t\t\t\t\t\tqueue.add(new Walk(to, walk.pos, 1, walk.time + dist[walk.pos][to]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int speed = -1; speed <= 1; speed++){\n\t\t\t\t\t\t\tfinal int next_speed = walk.speed + speed;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(next_speed <= 0){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}else if(limit[walk.pos][to] < next_speed){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(is_visited[to][walk.pos][next_speed]){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tqueue.add(new Walk(to, walk.pos, next_speed, walk.time + (double)(dist[walk.pos][to]) / next_speed));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!flag){\n\t\t\t\tSystem.out.println(\"unreachable\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\twhile (read())\n\t\t\tsolve();\n\t}\n\t\n\tstatic int N, M, S, G;\n\tstatic final double EPS = 1e-8;\n\tstatic final int    INF = 1 << 20;\n\tstatic int[][] W = new int[31][31], C = new int[31][31];\n\tstatic boolean read() {\n\t\tN = sc.nextInt(); M = sc.nextInt();\n\t\tif (N == 0) return false;\n\t\t\n\t\tS = sc.nextInt(); G = sc.nextInt();\n\t\tfor (int i = 0; i < 31; i++) {\n\t\t\tfill(W[i], INF);\n\t\t\tW[i][i] = 0;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint x, y, d, c;\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\td = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tW[x][y] = W[y][x] = d;\n\t\t\tC[x][y] = C[y][x] = c;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tstatic void solve() {\n\t\tdouble[][][] cost = new double[31][31][31];\n\t\tfor (int i = 0; i < 31; i++)\n\t\t\tfor (int j = 0; j < 31; j++)\n\t\t\t\tfill(cost[i][j], INF);\n\t\t\n\t\tPriorityQueue<State> que = new PriorityQueue<State>();\n\t\tque.add(new State(S, 0, 1, 0));\n\t\tboolean find = false;\n\t\tdouble ans = INF;\n\t\twhile (!que.isEmpty()) {\n\t\t\tState s = que.poll();\n\t\t\tint cur = s.cur, prev = s.prev, v = s.v;\n\t\t\tdouble c = s.cost;\n\t\t\tif (cost[cur][prev][v] + EPS < INF) continue;\n\t\t\t\n\t\t\tcost[cur][prev][v] = c;\n\t\t\t\n\t\t\tif (cur == G && v == 0) {\n\t\t\t\tans = c;\n\t\t\t\tfind = true;\n\t\t\t\tbreak;\n\t\t\t} else if (v == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint from = cur;\n\t\t\tfor (int to = 1; to < 31; to++) {\n\t\t\t\tif (W[from][to] + EPS > INF || to == prev) continue;\n\t\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\t\tint nv = v + j;\n\t\t\t\t\tdouble nc = c + ((double)W[from][to] / v);\n\t\t\t\t\tif (v >= 0 && v <= C[from][to] && nv >= 0 && nv <= 30 && cost[to][from][nv] + EPS > INF) {\n\t\t\t\t\t\tque.add(new State(to, from, nv, nc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (find)\n\t\t\tSystem.out.println(ans);\n\t\telse \n\t\t\tSystem.out.println(\"unreachable\");\n\t}\t\n}\n\nclass State implements Comparable<State> {\n\tint cur, prev, v;\n\tdouble cost;\n\t\n\tState(int cur, int prev, int v, double cost) {\n\t\tthis.cur = cur;\n\t\tthis.prev = prev;\n\t\tthis.v = v;\n\t\tthis.cost = cost;\n\t}\n\t\n\tpublic int compareTo(State s) {\n\t\treturn (new Double(this.cost).compareTo(s.cost));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tint [] xdis = {0,1,0,-1};\n\tint [] ydis = {1,0,-1,0};\n\tclass C implements Comparable<C>{\n\t\tint v,town,lasttown;\n\t\tdouble time;\n\t\tpublic C(int v, int town, int lasttown, double time) {\n\t\t\tthis.v = v;\tthis.town = town;this.lasttown = lasttown;this.time = time;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(C o) {\n\t\t\tif(time < o.time) return -1;\n\t\t\tif(time > o.time) return 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tprivate double getT(int dis, int v){\n\t\tdouble res = (double) dis / v;\n\t\treturn res;\n\t}\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\tint s = sc.nextInt();\n\t\t\tint g = sc.nextInt();\n\t\t\tint [][] pass = new int[n+1][n+1];\n\t\t\tint [][] maxs = new int[n+1][n+1];\n\t\t\tfor(int i=1; i <= n; i++){\n\t\t\t\tArrays.fill(pass[i], INF);\n\t\t\t\tArrays.fill(maxs[i], INF);\n\t\t\t}\n\t\t\tfor(int i=0; i < m; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tpass[x][y] = d; pass[y][x] = d;\n\t\t\t\tmaxs[x][y] = c; maxs[y][x] = c;\n\t\t\t}\n\t\t\tPriorityQueue<C> open = new PriorityQueue<C>();\n\t\t\topen.add(new C(1,s,-1,0.0));\n\t\t\tdouble [][] close = new double[n+1][31];\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tArrays.fill(close[i], INF);\n\t\t\t}\n\t\t\tclose[0][0] = 0.0;\n\t\t\t\n\t\t\tdouble ans = INF;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\t\n\t\t\t\tfor(int speed = -1; speed <= 1; speed++){\n\t\t\t\t\tint v = now.v + speed;\n\t\t\t\t\tif(now.lasttown == -1 && v != 1) continue;\n\t\t\t\t\tif(! (0 < v && v < 31)) continue;\n\t\t\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\t\t\tif(pass[now.town][i] == INF) continue;\n\t\t\t\t\t\tif(i == now.lasttown) continue;\n\t\t\t\t\t\tif(maxs[now.town][i] < v) continue;\n\t\t\t\t\t\tint dis = pass[now.town][i];\n\t\t\t\t\t\tdouble nexttime = now.time + getT(dis,v);\n\t\t\t\t\t\tif(close[i][v] < nexttime) continue;\n\t\t\t\t\t\tif(i == g && v == 1){\n\t\t\t\t\t\t\tans = Math.min(ans, nexttime);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\topen.add(new C(v, i, now.town, nexttime));\n\t\t\t\t\t\tclose[i][v] = nexttime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.print(\"ANS=\");\n\t\t\tif(ans == INF){\n\t\t\t\tSystem.out.println(\"unreachable\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.printf(\"%1.5f\\n\",ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\t\n\tint n, m;\n\t\n\tint[][] edge;\n\tdouble[][] minCost;\n\tint[][] maxSpeed;\t\n\t\n\tdouble INF = 100000000;\n\t\n\tclass State implements Comparable<State> {\n\t\tint n, speed, prev;\n\n\t\tState(int n, int speed, int prev) {\n\t\t\tthis.n = n;\n\t\t\tthis.speed = speed;\n\t\t\tthis.prev = prev;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(State arg0) {\n\t\t\tdouble c1 = minCost[n][speed], c2 = minCost[arg0.n][arg0.speed];\n\t\t\tif (c1 > c2) return 1;\n\t\t\telse if (c1 < c2) return -1;\n\t\t\telse return 0;\n\t\t}\n\t}\n\t\n\tvoid dijkstra(int start) {\n\t\tminCost = new double[n][31];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tArrays.fill(minCost[i], INF);\n\t\t\n\t\tminCost[start][0] = 0;\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.add(new State(start, 0, -1));\n\t\t\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (s.prev == i) continue;\n\t\t\t\tfor (int c = 0; c <= 30; c++) {\n\t\t\t\t\tfor (int v = -1; v <= 1; v++) {\n\t\t\t\t\t\tif (c+v > 0 && c+v <= maxSpeed[i][s.n] && minCost[i][c+v] > minCost[s.n][c] + (double)edge[i][s.n] / (c+v)) {\n\t\t\t\t\t\t\tminCost[i][c+v] = minCost[s.n][c] + (double)edge[i][s.n] / (c+v);\n\t\t\t\t\t\t\tpq.add(new State(i, c+v, s.n));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = in.nextInt(); m = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint s = in.nextInt() - 1, g = in.nextInt() - 1;\n\n\t\t\tmaxSpeed = new int[n][n];\n\t\t\tedge = new int[n][n];\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = in.nextInt() - 1, y = in.nextInt() - 1, d = in.nextInt(), c = in.nextInt();\n\t\t\t\tedge[x][y] = edge[y][x] = d;\n\t\t\t\tmaxSpeed[x][y] = maxSpeed[y][x] = c;\n\t\t\t}\n\t\t\t\n\t\t\tdijkstra(s);\n\t\t\t\n\t\t\tdouble res = minCost[g][1];\n\t\t\t\n\t\t\t/*\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t\t\tSystem.out.print(minCost[i][j] + \" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tSystem.out.println(res == INF ? \"unreachable\" : res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\t//public static Random rand=new Random();\n\n\tstatic final int INF =1<<30;\n\n\tstatic class Node{\n\t\tint id;\n\t\tList<Edge> link=new LinkedList<Edge>();\n\t\tNode(int _id){\n\t\t\tid=_id;\n\t\t}\n\t}\n\tstatic class Edge{\n\t\tint from,to;\n\t\tdouble cost;\n\t\tEdge(int _from,int _to,double _cost){\n\t\t\tfrom=_from;to=_to;cost=_cost;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn from+\"->\"+to;\n\t\t}\n\t}\n\tstatic class Task implements Comparable<Task>{\n\t\tint prev,pos;\n\t\tdouble cost;\n\t\tTask(int _prev,int _pos,double _cost){\n\t\t\tprev=_prev;pos=_pos;cost=_cost;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Task T) {\n\t\t\treturn cost>T.cost?1:cost<T.cost?-1:0;\n\t\t}\n\t}\n\n\tpublic static double[] dijkstra(Node[] graph,int s,int[] prev){\n\t\tfinal int V=graph.length;\n\t\tdouble[] d=new double[V];Arrays.fill(d,INF);d[s]=0;\n\t\tArrays.fill(prev,-2);\n\t\tPriorityQueue<Task> que=new PriorityQueue<Task>();\n\t\tque.add(new Task(-1,s,0));\n\t\twhile(!que.isEmpty()){\n\t\t\tTask task=que.poll();\n\t\t\tif(prev[task.pos]!=-2)continue;\n\t\t\t//if(d[task.pos]<task.cost)continue;\n\t\t\tprev[task.pos]=task.prev;\n\t\t\tfor(Edge e:graph[task.pos].link){\n\t\t\t\tif(d[e.to]>d[e.from]+e.cost){\n\t\t\t\t\td[e.to]=d[e.from]+e.cost;\n\t\t\t\t\tque.add(new Task(e.from,e.to,d[e.to]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tpublic int enc(int v,int l){\n\t\treturn (L+1)*v+l;\n\t}\n\tpublic int decL(int id){\n\t\treturn id%(L+1);\n\t}\n\tpublic int decV(int id){\n\t\treturn id/(L+1);\n\t}\n\tint N,M,L;\n\tpublic void run() {\n\t\tTCase:while(true){\n\t\t\tN=sc.nextInt();M=sc.nextInt();L=30;\n\t\t\tif(N==0)return;\n\t\t\tint s=sc.nextInt()-1,e=sc.nextInt()-1;\n\n\t\t\tNode[] graph=new Node[N*(L+1)];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<=L;j++)\n\t\t\t\tgraph[enc(i,j)]=new Node(enc(i,j));\n\n\t\t\t//edge\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tint f=sc.nextInt()-1,t=sc.nextInt()-1;\n\t\t\t\tint d=sc.nextInt(),c=sc.nextInt();\n\t\t\t\tfor(int l=0;l<=L;l++){\n\t\t\t\t\tif(l+1<=L && l+1<=c){\n\t\t\t\t\t\tgraph[enc(f,l)].link.add(new Edge(enc(f,l),enc(t,l+1),1.0*d/(l+1)));\n\t\t\t\t\t\tgraph[enc(t,l)].link.add(new Edge(enc(t,l),enc(f,l+1),1.0*d/(l+1)));\n\t\t\t\t\t}\n\t\t\t\t\tif(l>=1  && l<=c){\n\t\t\t\t\t\tgraph[enc(f,l)].link.add(new Edge(enc(f,l),enc(t,l),1.0*d/l));\n\t\t\t\t\t\tgraph[enc(t,l)].link.add(new Edge(enc(t,l),enc(f,l),1.0*d/l));\n\t\t\t\t\t}\n\t\t\t\t\tif(l-1>=1&& l-1<=c){\n\t\t\t\t\t\tgraph[enc(f,l)].link.add(new Edge(enc(f,l),enc(t,l-1),1.0*d/(l-1)));\n\t\t\t\t\t\tgraph[enc(t,l)].link.add(new Edge(enc(t,l),enc(f,l-1),1.0*d/(l-1)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] prev=new int[N*(L+1)];\n\t\t\tdouble[] d=dijkstra(graph,enc(s,0),prev);\n\n\t\t\tif(INF==d[enc(e,1)])\n\t\t\t\tln(\"unreachable\");\n\t\t\telse{\n\t\t\t\t//ln(strPath(path(prev,enc(e,1))));\n\t\t\t\tln(d[enc(e,1)]);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic String strPath(List<Integer> path){\n\t\tString res=\"\";\n\t\tfor(Integer v:path){\n\t\t\tres+=\"(\"+decV(v)+\",\"+decL(v)+\")--\";\n\t\t}\n\t\treturn res;\n\t}\n\t//パスの出力\n\tpublic static List<Integer> path(int[] prev,int e){\n\t\tList<Integer> path=new ArrayList<Integer>();\n\t\tfor (int u = e; u >= 0; u = prev[u])\n\t\t\tpath.add(u);\n\t\tCollections.reverse(path);\n\t\treturn path;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(Boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n//\tstatic String str(Double o){\n//\t\treturn String.format(\"%.8f\",o);\n//\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((Boolean)o);\n\t\t//if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef dijkstra(start)\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, 0)\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_to_node_of(u){|v|\n\t\t\t\t\td = f_dist[u] + edge_length(u, v)\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_from_node_of(u){|v|\n\t\t\t\t\td = b_dist[u] + edge_length(v, u)\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield [e.opposite[u], e.length]\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nloop {\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\tstart, goal = gets.split.map &:to_i\n\n\t$g = Graph.new\n\tnodes = (0..n).map {|i| $g.add_node({:name => i}) }\n\t$limit = {}\n\tm.times {\n\t\ti, j, d, c = gets.split.map &:to_i\n\t\t$g.add_edge(nodes[i], nodes[j], {:length => d})\n\t\t$limit[Set[nodes[i], nodes[j]]] = c\n\t}\n\n\tunless $g.reachable_from(nodes[start]).include?(nodes[goal])\n\t\tputs 'unreachable'\n\t\tnext\n\tend\n\n\textend Graphical\n\tdef each_out_connection_of(a)\n\t\tu, prev, speed = a\n\t\t$g.each_out_connection_of(u){|v, d|\n\t\t\tnext if v == prev\n\t\t\t[speed-1, speed, speed+1].each{|next_speed|\n\t\t\t\tnext if next_speed <= 0\n\t\t\t\tyield [[v, u, next_speed], d / next_speed.to_f] if next_speed <= $limit[Set[u, v]]\n\t\t\t}\n\t\t}\n\tend\n\n\tt = dijkstra([nodes[start], nil, 0]){|a, key|\n\t\tu, prev, speed = a\n\t\tu == nodes[goal] && speed == 1\n\t}\n\n\tprintf(\"%.7f\\n\", t);\n}"
  },
  {
    "language": "Ruby",
    "code": "\nclass Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef dijkstra(start)\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, 0)\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield [e.opposite[u], e.length]\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nitr = 0\nloop {\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\tstart, goal = gets.split.map &:to_i\n\n\t$g = Graph.new\n\t$nodes = (0..n).map {|i| $g.add_node({:index => i}) }\n\t$limit = {}\n\tm.times {\n\t\ti, j, d, c = gets.split.map &:to_i\n\t\t$g.add_edge($nodes[i], $nodes[j], {:length => d})\n\t\tif i < j\n\t\t\t$limit[[i,j]] = c\n\t\telse\n\t\t\t$limit[[j, i]] = c\n\t\tend\n\t}\n\n\tunless $g.reachable_from($nodes[start]).include?($nodes[goal])\n\t\tputs 'unreachable'\n\t\tnext\n\tend\n\n\textend Graphical\n\tdef each_out_connection_of(a)\n\t\ti, prev, speed = a\n\t\t$g.each_out_connection_of($nodes[i]){|v, d|\n\t\t\tj = v.property[:index]\n\t\t\tnext if j == prev\n\t\t\t[speed-1, speed, speed+1].each{|next_speed|\n\t\t\t\tnext if next_speed <= 0\n\t\t\t\t\t\n\t\t\t\tyield [[j, i, next_speed], d / next_speed.to_f] if next_speed <= $limit[(i < j ? [i, j] : [j, i])]\n\t\t\t}\n\t\t}\n\tend\n\n\tt = dijkstra([start, nil, 0]){|a, key|\n\t\ti, prev, speed = a\n\t\ti == goal && speed == 1\n\t}\n\n\tprintf(\"%.7f\\n\", t);\n}"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef dijkstra(start)\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, 0)\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(ss, ts)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tss.each{|s|\n\t\t\tf_heap.add(s, 0)\n\t\t}\n\t\tts.each{|t|\n\t\t\tb_heap.add(t, 0)\n\t\t}\n\n\t\tf_reached = Set[*ss]\n\t\tb_reached = Set[*ts]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nitr = 0\nloop {\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\tstart, goal = gets.split.map &:to_i\n\n\t$g = Graph.new\n\t$nodes = (0..n).map {|i| $g.add_node({:index => i, :name => i}) }\n\t$limit = {}\n\tm.times {\n\t\ti, j, d, c = gets.split.map &:to_i\n\t\t$g.add_edge($nodes[i], $nodes[j], {:length => d, :limit => c, :name => \"#{i}-#{j}\"})\n\t}\n\n\tunless $g.reachable_from($nodes[start]).include?($nodes[goal])\n\t\tputs 'unreachable'\n\t\tnext\n\tend\n\n\textend Graphical\n\tdef each_out_connection_of(a)\n\t\tu, used_edge, speed = a\n\t\tu.each_edge{|e|\n\t\t\tnext if e == used_edge\n\t\t\tv = e.opposite[u]\n\t\t\t[speed-1, speed, speed+1].each{|next_speed|\n\t\t\t\tnext if next_speed <= 0\n\t\t\t\tyield([v, e, next_speed], e.length / next_speed.to_f) if next_speed <= e.property[:limit]\n\t\t\t}\n\t\t}\n\tend\n\n\tdef each_in_connection_of(a)\n\t\tw, used_edge, speed = a\n\t\tv = used_edge.opposite[w]\n\t\tv.each_edge{|e|\n\t\t\tnext if e == used_edge\n\t\t\tu = e.opposite[v]\n\t\t\t[speed-1, speed, speed+1].each{|prev_speed|\n\t\t\t\tnext if prev_speed <= 0\n\t\t\t\tyield([v, e, prev_speed], used_edge.length / speed.to_f) if prev_speed <= e.property[:limit]\n\t\t\t}\n\t\t}\n\tend\n\n\tt = dijkstra([$nodes[start], nil, 0]){|a, key|\n\t\tv, prev, speed = a\n\t\tv == $nodes[goal] && speed == 1\n\t}\n\n\tprintf(\"%.7f\\n\", t);\n\n\tstarts = []\n\t$nodes[start].each_edge{|e|\n\t\tstarts << [$nodes[start], e, 1]\n\t}\n\n\tgoals = []\n\t$nodes[goal].each_edge{|e|\n\t\tgoals << [$nodes[goal], e, 1]\n\t}\n\n\tt = bidir_dijkstra(starts, goals) \n\tprintf(\"%.7f\\n\", t);\n}"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef dijkstra(start)\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, 0)\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, ts)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tts.each{|t|\n\t\t\tb_heap.add(t, 0)\n\t\t}\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[*ts]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nitr = 0\nloop {\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\tstart, goal = gets.split.map &:to_i\n\n\tg = Graph.new\n\tnodes = (0..n).map {|i| g.add_node}\n\tm.times {\n\t\ti, j, d, c = gets.split.map &:to_i\n\t\tg.add_edge(nodes[i], nodes[j], {:length => d, :limit => c})\n\t}\n\n\tunless g.reachable_from(nodes[start]).include?(nodes[goal])\n\t\tputs 'unreachable'\n\t\tnext\n\tend\n\n\textend Graphical\n\tdef each_out_connection_of(a)\n\t\tu, used_edge, speed = a\n\t\tu.each_edge{|e|\n\t\t\tnext if e == used_edge\n\t\t\tv = e.opposite[u]\n\t\t\t[speed-1, speed, speed+1].each{|next_speed|\n\t\t\t\tnext if next_speed <= 0\n\t\t\t\tyield([v, e, next_speed], e.length / next_speed.to_f) if next_speed <= e.property[:limit]\n\t\t\t}\n\t\t}\n\tend\n\n\tdef each_in_connection_of(a)\n\t\tw, used_edge, speed = a\n\t\treturn unless used_edge \n\t\tv = used_edge.opposite[w]\n\t\tv.each_edge{|e|\n\t\t\tnext if e == used_edge\n\t\t\tu = e.opposite[v]\n\t\t\t[speed-1, speed, speed+1].each{|prev_speed|\n\t\t\t\tnext if prev_speed <= 0\n\t\t\t\tyield([v, e, prev_speed], used_edge.length / speed.to_f) if prev_speed <= e.property[:limit]\n\t\t\t}\n\t\t}\n\t\tyield([v, nil, 0], used_edge.length / speed.to_f) if speed == 1\n\tend\n\n\tgoals = []\n\tnodes[goal].each_edge{|e|\n\t\tgoals << [nodes[goal], e, 1]\n\t}\n\n\tt = bidir_dijkstra([nodes[start], nil, 0], goals) \n\tprintf(\"%.7f\\n\", t);\n}"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef dijkstra(start)\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, 0)\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, ts)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tts.each{|t|\n\t\t\tb_heap.add(t, 0)\n\t\t}\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[*ts]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nitr = 0\nloop {\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\tstart, goal = gets.split.map &:to_i\n\n\t$g = Graph.new\n\t$nodes = (0..n).map {|i| $g.add_node({:index => i}) }\n\t$limit = {}\n\tm.times {\n\t\ti, j, d, c = gets.split.map &:to_i\n\t\t$g.add_edge($nodes[i], $nodes[j], {:length => d, :limit => c})\n\t}\n\n\tunless $g.reachable_from($nodes[start]).include?($nodes[goal])\n\t\tputs 'unreachable'\n\t\tnext\n\tend\n\n\textend Graphical\n\tdef each_out_connection_of(a)\n\t\tu, used_edge, speed = a\n\t\tu.each_edge{|e|\n\t\t\tnext if e == used_edge\n\t\t\tv = e.opposite[u]\n\t\t\t[speed-1, speed, speed+1].each{|next_speed|\n\t\t\t\tnext if next_speed <= 0\n\t\t\t\tyield([v, e, next_speed], e.length / next_speed.to_f) if next_speed <= e.property[:limit]\n\t\t\t}\n\t\t}\n\tend\n\n\tdef each_in_connection_of(a)\n\t\tw, used_edge, speed = a\n\t\tv = used_edge.opposite[w]\n\t\tv.each_edge{|e|\n\t\t\tnext if e == used_edge\n\t\t\tu = e.opposite[v]\n\t\t\t[speed-1, speed, speed+1].each{|prev_speed|\n\t\t\t\tnext if prev_speed <= 0\n\t\t\t\tyield([v, e, prev_speed], used_edge.length / speed.to_f) if prev_speed <= e.property[:limit]\n\t\t\t}\n\t\t}\n\tend\n\n\tgoals = []\n\t$nodes[goal].each_edge{|e|\n\t\tgoals << [$nodes[goal], e, 1]\n\t}\n\n\tt = bidir_dijkstra([$nodes[start], nil, 0], goals) \n\tprintf(\"%.7f\\n\", t);\n}"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef dijkstra(start)\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, 0)\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nitr = 0\nloop {\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\tstart, goal = gets.split.map &:to_i\n\n\t$g = Graph.new\n\t$nodes = (0..n).map {|i| $g.add_node({:index => i}) }\n\t$limit = {}\n\tm.times {\n\t\ti, j, d, c = gets.split.map &:to_i\n\t\t$g.add_edge($nodes[i], $nodes[j], {:length => d})\n\t\tif i < j\n\t\t\t$limit[[i,j]] = c\n\t\telse\n\t\t\t$limit[[j,i]] = c\n\t\tend\n\t}\n\n\tunless $g.reachable_from($nodes[start]).include?($nodes[goal])\n\t\tputs 'unreachable'\n\t\tnext\n\tend\n\n\textend Graphical\n\tdef each_out_connection_of(a)\n\t\ti, prev, speed = a\n\t\t$g.each_out_connection_of($nodes[i]){|v, d|\n\t\t\tj = v.property[:index]\n\t\t\tnext if j == prev\n\t\t\t[speed-1, speed, speed+1].each{|next_speed|\n\t\t\t\tnext if next_speed <= 0\n\t\t\t\tyield([j, i, next_speed], d / next_speed.to_f) if next_speed <= $limit[(i < j ? [i, j] : [j, i])]\n\t\t\t}\n\t\t}\n\tend\n\n\tdef each_in_connection_of(a)\n\t\ti, prev, speed = a\n\t\t$g.each_in_connection_of($nodes[prev]){|v, d|\n\t\t\tj = v.property[:index]\n\t\t\tnext if j == i\n\t\t\t[speed-1, speed, speed+1].each{|prev_speed|\n\t\t\t\tnext if prev_speed <= 0\n\t\t\t\tyield([prev, j, prev_speed], d / prev_speed.to_f) if prev_speed <= $limit[(prev < j ? [prev, j] : [j, prev])]\n\t\t\t}\n\t\t}\n\tend\n\n\t#t = dijkstra([start, nil, 0]){|a, key|\n\t#\ti, prev, speed = a\n\t#\ti == goal && speed == 1\n\t#}\n\n\tt = bidir_dijkstra([start, nil, 0], [nil, goal, 0])\n\n\tprintf(\"%.7f\\n\", t);\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nINF = Float::INFINITY\nMAX_V = 30\n\n### main\n\nloop do\n  n, m = gets.split.map(&:to_i)\n  break if (n | m) == 0\n\n  st, gl = gets.split.map{|s| s.to_i - 1}\n\n  edges = n.times.map{[]}\n  nbrs = n.times.map{[]}\n  \n  m.times do\n    xi, yi, di, ci = gets.split.map(&:to_i)\n    xi -= 1\n    yi -= 1\n    di = di.to_f\n\n    edges[xi][yi] = edges[yi][xi] = [di, ci]\n    nbrs[xi] << yi\n    nbrs[yi] << xi\n  end\n  #p edges\n  #p nbrs\n\n  times = n.times.map{n.times.map{(MAX_V + 1).times.map{INF}}}\n  times[st][st][0] = 0.0\n\n  q = [[st, st, 0]]\n  min_t = INF\n  \n  while ! q.empty?\n    u = q.min{|a, b| times[a[0]][a[1]][a[2]] <=> times[b[0]][b[1]][b[2]]}\n    q.delete(u)\n\n    un, uf, uv = u\n    ut = times[un][uf][uv]\n\n    if un == gl && uv == 1\n      min_t = ut if min_t > ut\n      next\n    end\n\n    for vn in nbrs[un]\n      next if vn == uf\n\n      vd, vc = edges[un][vn]\n      next if uv - 1 > vc\n      \n      for vv in [uv - 1, uv, uv + 1]\n        next if vv <= 0 || vv > vc\n        dt = vd / vv\n        vt = times[vn][un][vv]\n        nvt = ut + dt\n        if vt > nvt\n          times[vn][un][vv] = nvt\n          q << [vn, un, vv] if vt >= INF\n        end\n      end\n    end\n  end\n\n  puts (min_t >= INF ? 'unreachable' : \"%.5f\" % min_t)\nend"
  },
  {
    "language": "Ruby",
    "code": "start_time = Time.new\n\n\nclass Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef dijkstra(start)\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, 0)\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, ts)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tts.each{|t|\n\t\t\tb_heap.add(t, 0)\n\t\t}\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[*ts]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nitr = 0\nloop {\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\tstart, goal = gets.split.map &:to_i\n\n\t$g = Graph.new\n\t$nodes = (0..n).map {|i| $g.add_node({:index => i, :name => i}) }\n\t$limit = {}\n\tm.times {\n\t\ti, j, d, c = gets.split.map &:to_i\n\t\t$g.add_edge($nodes[i], $nodes[j], {:length => d, :limit => c, :name => \"#{i}-#{j}\"})\n\t}\n\n\tunless $g.reachable_from($nodes[start]).include?($nodes[goal])\n\t\tputs 'unreachable'\n\t\tnext\n\tend\n\n\t$hoge = $nodes[start]\n\n\textend Graphical\n\tdef each_out_connection_of(a)\n\t\tu, used_edge, speed = a\n\t\tu.each_edge{|e|\n\t\t\tnext if e == used_edge\n\t\t\tv = e.opposite[u]\n\t\t\t[speed-1, speed, speed+1].each{|next_speed|\n\t\t\t\tnext if next_speed <= 0\n\t\t\t\tyield([v, e, next_speed], e.length / next_speed.to_f) if next_speed <= e.property[:limit]\n\t\t\t}\n\t\t}\n\tend\n\n\tdef each_in_connection_of(a)\n\t\tw, used_edge, speed = a\n\t\tv = used_edge.opposite[w]\n\t\tv.each_edge{|e|\n\t\t\tnext if e == used_edge\n\t\t\tu = e.opposite[v]\n\t\t\t[speed-1, speed, speed+1].each{|prev_speed|\n\t\t\t\tnext if prev_speed <= 0\n\t\t\t\tyield([v, e, prev_speed], used_edge.length / speed.to_f) if prev_speed <= e.property[:limit]\n\t\t\t}\n\t\t}\n\t\tif v == $hoge && speed == 1\n\t\t\tyield([$hoge, nil, 0], used_edge.length / speed.to_f)\n\t\tend\n\tend\n\n\tgoals = []\n\t$nodes[goal].each_edge{|e|\n\t\tgoals << [$nodes[goal], e, 1]\n\t}\n\n\tt = bidir_dijkstra([$nodes[start], nil, 0], goals) \n\tprintf(\"%.7f\\n\", t);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst INF = 1e10;\n\nstruct Edge {\n    int from, to;\n    double cost;\n    int limit;\n}\n \nvoid main() {\n    int N, M;\n    int S, G;\n    Edge[][] Graph;\n\n    bool input() {\n        scanf(\"%d %d\\n\", &N, &M);\n        if (N == 0 && M == 0) return false;\n        scanf(\"%d %d\\n\", &S, &G);\n        Graph = new Edge[][N + 1];\n        foreach (i; 0 .. M) {\n            int x, y, d, c;\n            scanf(\"%d %d %d %d\\n\", &x, &y, &d, &c);\n            Graph[x] ~= Edge(x, y, d, c);\n            Graph[y] ~= Edge(y, x, d, c);\n        }\n        return true;\n    }\n\n    void solve() {\n        auto D = new double[][][](N + 1, 31, 31);\n        foreach (i; 0 .. N + 1) foreach (j; 0 .. 31) D[i][j][] = INF;\n        struct P {\n            int prev, v, city;\n            double cost;\n        }\n        BinaryHeap!(Array!P, \"a.cost > b.cost\") PQ;\n        PQ.insert(P(0, 0, S, 0));\n        D[0][0][S] = 0;\n        while (!PQ.empty) {\n            P cur = PQ.front; PQ.removeFront;\n            foreach (edge; Graph[cur.city]) {\n                for (int d = -1; d <= 1; d++) {\n                    int v = cur.v + d;\n                    if (v <= 0 || v > edge.limit) continue;\n                    if (edge.to == cur.prev) continue;\n                    auto next = P(cur.city, v, edge.to, cur.cost + edge.cost / v);\n                    if (D[next.prev][next.v][next.city] > next.cost) {\n                        D[next.prev][next.v][next.city] = next.cost;\n                        PQ.insert(next);\n                    }\n                }\n            }\n        }\n        double Ans = INF;\n        foreach (i; 0 .. N + 1) {\n            Ans = min(Ans, D[i][1][G]);\n        }\n        if (Ans == INF) {\n            writeln(\"unreachable\");\n        } else {\n            writefln(\"%.10f\", Ans);\n        }\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "#2006_D\n\"\"\"\nimport sys\nfrom collections import defaultdict\ndef dfs(d,y,x,f):\n    global ans\n    if d >= 10:\n        return\n    f_ = defaultdict(int)\n    for i in f.keys():\n        f_[i] = f[i]\n    for t,s in vr[(y,x)]:\n        if a[t][s] == 3:\n            ans = min(ans,d+1)\n            break\n        elif f[(t,s)]:\n            if s == x+1:\n                break\n            f_[(t,s)] = 0\n            dfs(d+1,t,s-1,f_)\n            f_[(t,s)] = 1\n            break\n\n    for t,s in vl[(y,x)]:\n        if a[t][s] == 3:\n            ans = min(ans,d+1)\n            break\n        elif f[(t,s)]:\n            if s == x-1:\n                break\n            f_[(t,s)] = 0\n            dfs(d+1,t,s+1,f_)\n            f_[(t,s)] = 1\n            break\n\n    for t,s in vd[(y,x)]:\n        if a[t][s] == 3:\n            ans = min(ans,d+1)\n            break\n        elif f[(t,s)]:\n            if t == y+1:\n                break\n            f_[(t,s)] = 0\n            dfs(d+1,t-1,s,f_)\n            f_[(t,s)] = 1\n            break\n\n    for t,s in vu[(y,x)]:\n        if a[t][s] == 3:\n            ans = min(ans,d+1)\n            break\n        elif f[(t,s)]:\n            if t == y-1:\n                break\n            f_[(t,s)] = 0\n            dfs(d+1,t+1,s,f_)\n            f_[(t,s)] = 1\n            break\n    return\nwhile 1:\n    w,h = map(int, sys.stdin.readline()[:-1].split())\n    if w == h == 0:\n        break\n    a = [list(map(int, sys.stdin.readline()[:-1].split())) for i in range(h)]\n    vr = defaultdict(list)\n    vl = defaultdict(list)\n    vd = defaultdict(list)\n    vu = defaultdict(list)\n    f = defaultdict(int)\n    for y in range(h):\n        for x in range(w):\n            if a[y][x] == 1:\n                f[(y,x)] = 1\n            if a[y][x] in [1,3]:\n                for x_ in range(x):\n                    vr[(y,x_)].append((y,x))\n            elif a[y][x] == 2:\n                sy,sx = y,x\n    for y in range(h):\n        for x in range(w)[::-1]:\n            if a[y][x] in (1,3):\n                for x_ in range(x+1,w):\n                    vl[(y,x_)].append((y,x))\n    for x in range(w):\n        for y in range(h):\n            if a[y][x] in (1,3):\n                for y_ in range(y):\n                    vd[(y_,x)].append((y,x))\n    for x in range(w):\n        for y in range(h)[::-1]:\n            if a[y][x] in (1,3):\n                for y_ in range(y+1,h):\n                    vu[(y_,x)].append((y,x))\n    ind = [[[0]*4 for i in range(w)] for j in range(h)]\n    ans = 11\n    dfs(0,sy,sx,f)\n    ans = ans if ans < 11 else -1\n    print(ans)\n\"\"\"\n\n#2018_D\n\"\"\"\nimport sys\nfrom collections import defaultdict\nsys.setrecursionlimit(1000000)\n\ndef dfs(d,s,l,v,dic):\n    s_ = tuple(s)\n    if dic[(d,s_)] != None:\n        return dic[(d,s_)]\n    if d == l:\n        dic[(d,s_)] = 1\n        for x in s:\n            if x > (n>>1):\n                dic[(d,s_)] = 0\n                return 0\n        return 1\n    else:\n        res = 0\n        i,j = v[d]\n        if s[i] < (n>>1):\n            s[i] += 1\n            res += dfs(d+1,s,l,v,dic)\n            s[i] -= 1\n        if s[j] < (n>>1):\n            s[j] += 1\n            res += dfs(d+1,s,l,v,dic)\n            s[j] -= 1\n        dic[(d,s_)] = res\n        return res\n\ndef solve(n):\n    dic = defaultdict(lambda : None)\n    m = int(sys.stdin.readline())\n    s = [0]*n\n    f = [[1]*n for i in range(n)]\n    for i in range(n):\n        f[i][i] = 0\n    for i in range(m):\n        x,y = [int(x) for x in sys.stdin.readline().split()]\n        x -= 1\n        y -= 1\n        s[x] += 1\n        f[x][y] = 0\n        f[y][x] = 0\n    v = []\n    for i in range(n):\n        for j in range(i+1,n):\n            if f[i][j]:\n                v.append((i,j))\n    l = len(v)\n    print(dfs(0,s,l,v,dic))\n\nwhile 1:\n    n = int(sys.stdin.readline())\n    if n == 0:\n        break\n    solve(n)\n\"\"\"\n#2011_D\n\"\"\"\nimport sys\ndef dfs(s,d,f,v):\n    global ans\n    if ans == n-n%2:\n        return\n    if d > ans:\n        ans = d\n    for i in range(n):\n        if s[i] == 0:\n            for j in range(i+1,n):\n                if s[j] == 0:\n                    if f[i] == f[j]:\n                        s[i] = -1\n                        s[j] = -1\n                        for k in v[i]:\n                            s[k] -= 1\n                        for k in v[j]:\n                            s[k] -= 1\n                        dfs(s,d+2,f,v)\n                        s[i] = 0\n                        s[j] = 0\n                        for k in v[i]:\n                            s[k] += 1\n                        for k in v[j]:\n                            s[k] += 1\n\ndef solve(n):\n    p = [[int(x) for x in sys.stdin.readline().split()] for i in range(n)]\n    v = [[] for i in range(n)]\n    f = [0]*n\n    s = [0]*n\n    for i in range(n):\n        x,y,r,f[i] = p[i]\n        for j in range(i+1,n):\n            xj,yj,rj,c = p[j]\n            if (x-xj)**2+(y-yj)**2 < (r+rj)**2:\n                v[i].append(j)\n                s[j] += 1\n    dfs(s,0,f,v)\n    print(ans)\nwhile 1:\n    n = int(sys.stdin.readline())\n    ans = 0\n    if n == 0:\n        break\n    solve(n)\n\"\"\"\n\n#2003_D\n\"\"\"\nimport sys\ndef root(x,par):\n    if par[x] == x:\n        return x\n    par[x] = root(par[x],par)\n    return par[x]\n\ndef unite(x,y,par,rank):\n    x = root(x,par)\n    y = root(y,par)\n    if rank[x] < rank[y]:\n        par[x] = y\n    else:\n        par[y] = x\n        if rank[x] == rank[y]:\n            rank[x] += 1\n\ndef solve(n):\n    p = [[float(x) for x in sys.stdin.readline().split()] for i in range(n)]\n    v = []\n    for i in range(n):\n        for j in range(i):\n            xi,yi,zi,ri = p[i]\n            xj,yj,zj,rj = p[j]\n            d = max(0,((xi-xj)**2+(yi-yj)**2+(zi-zj)**2)**0.5-(ri+rj))\n            v.append((i,j,d))\n    par = [i for i in range(n)]\n    rank = [0]*n\n    v.sort(key = lambda x:x[2])\n    ans = 0\n    for x,y,d in v:\n        if root(x,par) != root(y,par):\n            unite(x,y,par,rank)\n            ans += d\n    print(\"{:.3f}\".format(round(ans,3)))\n\nwhile 1:\n    n = int(sys.stdin.readline())\n    if n == 0:\n        break\n    solve(n)\n\"\"\"\n\n#2009_D\nimport sys\nfrom heapq import heappop,heappush\nfrom collections import defaultdict\ndef solve(n,m):\n    s,g = [int(x) for x in sys.stdin.readline().split()]\n    s -= 1\n    g -= 1\n    e = [[] for i in range(n)]\n    for i in range(m):\n        a,b,d,c = [int(x) for x in sys.stdin.readline().split()]\n        a -= 1\n        b -= 1\n        e[a].append((b,d,c))\n        e[b].append((a,d,c))\n    dist = defaultdict(lambda : float(\"inf\"))\n    dist[(s,0,-1)] = 0\n    q = [(0,s,0,-1)]\n    while q:\n        dx,x,v,p = heappop(q)\n        if x == g and v == 1:\n            print(dx)\n            return\n        for i in range(-1,2):\n            v_ = v+i\n            if v_ < 1 :continue\n            for y,d,c in e[x]:\n                if p == y:\n                    continue\n                if v_ > c:\n                    continue\n                z = d/v_\n                if dx+z < dist[(y,v_,x)]:\n                    dist[(y,v_,x)] = dx+z\n                    heappush(q,(dist[(y,v_,x)],y,v_,x))\n    print(\"unreachable\")\n    return\n\nwhile 1:\n    n,m = [int(x) for x in sys.stdin.readline().split()]\n    if n == 0:\n        break\n    solve(n,m)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport heapq\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\nMAX_SPEED = 30\nwhile True:\n    N, M = map(int, input().split())\n    if not (N | M):\n        break\n    S, G = map(lambda x: int(x) - 1, input().split())\n    edge = [[] for _ in range(N)]\n    for _ in range(M):\n        x, y, d, c = map(int, input().split())\n        edge[x - 1].append((y - 1, d, c))\n        edge[y - 1].append((x - 1, d, c))\n    INF = 1e18\n    dist = [[[INF for _ in range(N)] for _ in range(MAX_SPEED + 1)] for _ in range(N)]\n    que = [(0.0, S, 0, S)]\n    while que:\n        cost, now, v, prev = heapq.heappop(que)\n        if cost > dist[now][v][prev]:\n            continue\n        if now == G and v == 1:\n            print(\"{:.20f}\".format(cost))\n            break\n        dist[now][v][prev] = cost\n        for x, d, c in edge[now]:\n            if x == prev:\n                continue\n            for dv in (-1, 0, 1):\n                nv = v + dv\n                if 0 < nv <= c and dist[x][nv][now] > dist[now][v][prev] + d / nv:\n                    dist[x][nv][now] = dist[now][v][prev] + d / nv\n                    heapq.heappush(que, (dist[x][nv][now], x, nv, now))\n    else:\n        print(\"unreachable\")"
  },
  {
    "language": "Python",
    "code": "MAX_SPEED = 30\nwhile True:\n    N, M = map(int, input().split())\n    if not (N | M):\n        break\n    S, G = map(lambda x: int(x) - 1, input().split())\n    edge = []\n    for _ in range(M):\n        x, y, d, c = map(int, input().split())\n        edge.append((x - 1, y - 1, d, c))\n        edge.append((y - 1, x - 1, d, c))\n    INF = float('inf')\n    dist = [[[INF for _ in range(N)] for _ in range(MAX_SPEED + 1)] for _ in range(N)]\n    dist[S][0][S] = 0.0\n    while True:\n        flag = False\n        for x, y, d, c in edge:\n            for j in range(min(MAX_SPEED + 1, c + 2)):\n                for k in range(N):\n                    if k == y or (j <= c and dist[x][j][k] == INF):\n                        continue\n                    # print(x, y, d, c, j, k, dist[x][j][k])\n                    if j > 1 and dist[y][j - 1][x] > dist[x][j][k] + d / (j - 1):\n                        dist[y][j - 1][x] = dist[x][j][k] + d / (j - 1)\n                        flag = True\n                    if 0 < j <= c and dist[y][j][x] > dist[x][j][k] + d / j:\n                        dist[y][j][x] = dist[x][j][k] + d / j\n                        flag = True\n                    if j < c and dist[y][j + 1][x] > dist[x][j][k] + d / (j + 1):\n                        dist[y][j + 1][x] = dist[x][j][k] + d / (j + 1)\n                        flag = True\n        if not flag:\n            break\n    \"\"\"\n    for i in range(N):\n        print(*dist[i], sep='\\n')\n        print()\n    \"\"\"\n    ans = min(dist[G][1][j] for j in range(N))\n    print(\"unreachable\" if ans == INF else \"{:.20f}\".format(ans))"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    from heapq import heappush, heappop\n    file_input = sys.stdin\n    inf = float('inf')\n    \n    while True:\n        n, m = map(int, file_input.readline().split())\n        if n == 0:\n            break\n        \n        s, g = map(int, file_input.readline().split())\n        \n        adj_list = [[] for i in range(n)]\n        for i in range(m):\n            x, y, d, c = map(int, file_input.readline().split())\n            x -= 1\n            y -= 1\n            adj_list[x].append((y, d, c))\n            adj_list[y].append((x, d, c))\n        \n        # Dijkstra's algorithm\n        s -= 1\n        g -= 1\n        time_rec = [[[inf] * 31 for j in range(n)] for i in range(n)]\n        time_rec[s][s][1] = 0\n        \n        # pq element: (time, current city, previous city, speed)\n        pq = [(0, s, s, 0)]\n        \n        while pq:\n            t, c, p, s = heappop(pq)\n            \n            if time_rec[p][c][s] < t:\n                continue\n            \n            if c == g and s == 1:\n                print(t)\n                break\n            \n            for next_city, d, s_limit in adj_list[c]:\n                if next_city == p:\n                    continue\n                \n                if s <= 1:\n                    lower_limit = 1\n                else:\n                    lower_limit = s - 1\n                    \n                for shifted_s in range(lower_limit, s + 2):\n                    if shifted_s > s_limit:\n                        continue\n                    \n                    next_t = t + d / shifted_s\n                    \n                    if time_rec[c][next_city][shifted_s] <= next_t:\n                        continue\n                    else:\n                        heappush(pq, (next_t, next_city, c, shifted_s))\n                        time_rec[c][next_city][shifted_s] = next_t\n        else:\n            print('unreachable')\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 1162: Discrete Speed\n# Python3 2018.7.15 bal4u\n\nINF = 10e8\nimport heapq\n\ndef dijkstra(V, to, start, goal):\n\tnode = [[[INF for k in range(31)] for j in range(V)] for i in range(V)]\n\tQ = []\n\tnode[start][0][0] = 0\n\theapq.heappush(Q, (0, start, -1, 0))\n\twhile Q:\n\t\tt, s, p, v = heapq.heappop(Q)\n\t\tif s == goal and v == 1: return t\n\t\tfor e, d, c in to[s]:\n\t\t\tif e == p: continue    # Uターン禁止\n\t\t\tfor i in range(-1, 2):\n\t\t\t\tnv = v+i\n\t\t\t\tif nv > c or nv <= 0: continue\n\t\t\t\tnt = t + d/nv\n\t\t\t\tif nt < node[e][s][nv]:\n\t\t\t\t\tnode[e][s][nv] = nt\n\t\t\t\t\theapq.heappush(Q, (nt, e, s, nv))\n\treturn -1\n\t\nwhile True:\n\tn, m = map(int, input().split())\n\tif n == 0: break\n\ts, g = map(int, input().split())\n\ts -= 1; g -= 1\n\tto = [[] for i in range(n)]\n\tfor i in range(m):\n\t\tx, y, d, c = map(int, input().split())\n\t\tx -= 1; y -= 1\n\t\tto[x].append((y, d, c))\n\t\tto[y].append((x, d, c))\n\tans = dijkstra(n, to, s, g)\n\tprint(ans if ans >= 0 else \"unreachable\")\n\n"
  },
  {
    "language": "Python",
    "code": "from Queue import Queue\n\nwhile True:\n    n,m=map(int,raw_input().split())\n    if n==m==0:break\n    INF=100000\n    Q=Queue()\n    s,g=map(int,raw_input().split())\n    s,g=s-1,g-1\n    D=[[INF]*n for i in range(n)]\n    C=[[0]*n for i in range(n)]\n    for i in range(n):\n        D[i][i]=0\n    for i in range(m):\n        x,y,d,c=map(int,raw_input().split())\n        x,y=x-1,y-1\n        D[y][x]=D[x][y]=d\n        C[y][x]=C[x][y]=c\n        if x==s:\n            Q.put((x,y,1,1))\n    T=[[INF]*31 for i in range(n)]\n    T[s][1]=0.0\n    while not Q.empty():\n        x,y,v,pv=Q.get()\n        if v==0:continue\n        if v>C[x][y]:continue\n        if T[y][v]>D[x][y]/float(v)+T[x][pv]:\n            T[y][v]=D[x][y]/float(v)+T[x][pv]\n            for i in range(n):\n                if D[y][i]!=INF or D[y][i]!=0 and i!=x:\n                    Q.put((y,i,v-1,v))\n                    Q.put((y,i,v,v))\n                    Q.put((y,i,v+1,v))\n    print T[g][1] if T[g][1]!=INF else \"unreachable\""
  },
  {
    "language": "Python",
    "code": "import sys\nimport heapq\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\nMAX_SPEED = 30\nwhile True:\n    N, M = map(int, input().split())\n    if not (N | M):\n        break\n    S, G = map(lambda x: int(x) - 1, input().split())\n    edge = [[] for _ in range(N)]\n    for _ in range(M):\n        x, y, d, c = map(int, input().split())\n        edge[x - 1].append((y - 1, d, c))\n        edge[y - 1].append((x - 1, d, c))\n    INF = float('inf')\n    dist = [[[INF for _ in range(N)] for _ in range(MAX_SPEED + 1)] for _ in range(N)]\n    que = [(0.0, S, 0, S)]\n    while que:\n        cost, now, v, prev = heapq.heappop(que)\n        if cost > dist[now][v][prev]:\n            continue\n        if now == G and v == 1:\n            print(\"{:.20f}\".format(cost))\n            break\n        dist[now][v][prev] = cost\n        for x, d, c in edge[now]:\n            if x == prev:\n                continue\n            for dv in (-1, 0, 1):\n                nv = v + dv\n                if 0 < nv <= c and dist[x][nv][now] > dist[now][v][prev] + d / nv:\n                    dist[x][nv][now] = dist[now][v][prev] + d / nv\n                    heapq.heappush(que, (dist[x][nv][now], x, nv, now))\n    else:\n        print(\"unreachable\")"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport heapq\n\nwhile True:\n  n,m = map(int, raw_input().split())\n  if n == 0 and m == 0: break\n  s,g = map(int, raw_input().split())\n  s -= 1\n  g -= 1\n  dist = [[10.0**9 for _ in xrange(n)] for _ in xrange(n)]\n  limit = [[0.0 for _ in xrange(n)] for _ in xrange(n)]\n  mintime = [[10.0**9 for _ in xrange(40)] for _ in xrange(n)]\n  for _ in xrange(m):\n    x,y,d,c = map(int, raw_input().split())\n    x -= 1\n    y -= 1\n    dist[x][y] = float(d)\n    dist[y][x] = float(d)\n    limit[x][y] = float(c)\n    limit[y][x] = float(c)\n  mintime[s][1] = 0.0\n\n# dijkstra\n  # dp[i][j][k] : pos i from j with speed k\n  isChecked = [[[False for _ in xrange(40)] for _ in xrange(n)] for _ in xrange(n)]\n  q = []\n  heapq.heappush(q, (0.0, s, -1, 1))\n  while len(q) > 0:\n    a = heapq.heappop(q)\n    time   = a[0]\n    pos    = a[1]\n    before = a[2]\n    speed  = a[3]\n    if isChecked[pos][before][speed]: continue\n    if speed == 0: continue\n    for nxt in xrange(n):\n      if nxt == pos or nxt == before or dist[pos][nxt] == 10.0**9 or limit[pos][nxt] < speed: continue\n      for k in xrange(-1, 2):\n        if speed + k < 0: continue\n        if time + dist[pos][nxt] / float(speed) < mintime[nxt][speed + k]:\n          mintime[nxt][speed + k] = time + dist[pos][nxt] / float(speed)\n          heapq.heappush(q, (mintime[nxt][speed + k], nxt, pos, speed+k))\n  if mintime[g][0] == 10.0**9: print 'unreachable'\n  else: print mintime[g][0]"
  },
  {
    "language": "Python",
    "code": "# AOJ 1162: Discrete Speed\n# Python3 2018.7.15 bal4u\n\nINF = 0x7fffffff\nimport heapq\ndef dijkstra(V, to, start, goal):\n\tnode = [[[INF for k in range(32)] for j in range(V)] for i in range(V)]\n\tQ = []\n\tnode[start][0][0] = 0\n\theapq.heappush(Q, (0, start, 0, 0))\n\twhile Q:\n\t\tt, s, v, p = heapq.heappop(Q)\n\t\tif s == goal and v == 1: return node[goal][p][v]\n\t\tfor e, d, c in to[s]:\n\t\t\tif e == p: continue\n\t\t\tfor i in range(-1, 2):\n\t\t\t\tnv = v+i\n\t\t\t\tif nv > c or nv <= 0: continue\n\t\t\t\tnt = node[s][p][v]+d/nv\n\t\t\t\tif nt < node[e][s][nv]:\n\t\t\t\t\tnode[e][s][nv] = nt\n\t\t\t\t\theapq.heappush(Q, (nt, e, nv, s))\n\treturn -1\n\t\nwhile True:\n\tn, m = map(int, input().split())\n\tif n == 0: break\n\ts, g = map(int, input().split())\n\ts -= 1; g -= 1\n\tto = [[] for i in range(n)]\n\tfor i in range(m):\n\t\tx, y, d, c = map(int, input().split())\n\t\tx -= 1; y -= 1\n\t\tto[x].append((y, d, c))\n\t\tto[y].append((x, d, c))\n\tans = dijkstra(n, to, s, g)\n\tprint(ans if ans >= 0 else \"unreachable\")\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport heapq\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\nMAX_SPEED = 30\ndvs = (-1, 0, 1)\nwhile True:\n    N, M = map(int, input().split())\n    if not (N | M):\n        break\n    S, G = map(lambda x: int(x) - 1, input().split())\n    edge = [[] for _ in range(N)]\n    for _ in range(M):\n        x, y, d, c = map(int, input().split())\n        edge[x - 1].append((y - 1, d, c))\n        edge[y - 1].append((x - 1, d, c))\n    INF = 1e9\n    dist = [[[INF for _ in range(N)] for _ in range(MAX_SPEED + 1)] for _ in range(N)]\n    que = [(0.0, S, 0, S)]\n    while que:\n        cost, now, v, prev = heapq.heappop(que)\n        if cost > dist[now][v][prev]:\n            continue\n        if now == G and v == 1:\n            print(\"{:.20f}\".format(cost))\n            break\n        dist[now][v][prev] = cost\n        for x, d, c in edge[now]:\n            if x == prev:\n                continue\n            for dv in dvs:\n                nv = v + dv\n                if 0 < nv <= c and dist[x][nv][now] > dist[now][v][prev] + d / nv:\n                    dist[x][nv][now] = dist[now][v][prev] + d / nv\n                    heapq.heappush(que, (dist[x][nv][now], x, nv, now))\n    else:\n        print(\"unreachable\")"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom heapq import heappop, heappush\ndef inpl(): return list(map(int, input().split()))\n\nINF = 50000\n\nN, M = inpl()\nwhile N:\n    s, g = inpl()\n    G = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a, b, d, c = inpl()\n        G[a].append([b, c, d])\n        G[b].append([a, c, d])\n    DP = [[INF]*(31) for _ in range(N+1)]\n    DP[s][1] = 0\n    Q = [[0, 0, s]]  # time, speed, where\n    while Q:\n        t, v, p = heappop(Q)\n        if DP[p][v] < t:\n            continue\n        for q, c, d in G[p]:\n            for dv in range(-1, 2):\n                nv = v+dv\n                if not (0 < nv <= min(30, c)):\n                    continue\n                nt = t + d/(nv)\n                if DP[q][nv] > nt:\n                    DP[q][nv] = nt\n                    heappush(Q, [nt, nv, q])\n    if DP[g][1] == INF:\n        print(\"unreachable\")\n    else:\n        print(DP[g][1])\n    N, M = inpl()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom heapq import heappop, heappush\ndef inpl(): return list(map(int, input().split()))\n\nINF = 50000\n\nN, M = inpl()\nwhile N:\n    s, g = inpl()\n    G = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a, b, d, c = inpl()\n        G[a].append([b, c, d])\n        G[b].append([a, c, d])\n    DP =  [[[INF]*(N+1) for _ in range(31)] for _ in range(N+1)]\n    DP[s][0][0] = 0\n    Q = [[0, 0, s, 0]]  # time, speed, where, pre\n    while Q:\n        t, v, p, bp = heappop(Q)\n        if DP[p][v][bp] < t:\n            continue\n        for q, c, d in G[p]:\n            if q == bp:\n                continue\n\n            for dv in range(-1, 2):\n                nv = v+dv\n                if not (0 < nv <= c):\n                    continue\n                nt = t + d/(nv)\n                if DP[q][nv][p] > nt:\n                    DP[q][nv][p] = nt\n                    heappush(Q, [nt, nv, q, p])\n\n    ans = min(DP[g][1])\n    if ans == INF:\n        print(\"unreachable\")\n    else:\n        print(ans)\n    N, M = inpl()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport heapq\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\nMAX_SPEED = 30\nwhile True:\n    N, M = map(int, input().split())\n    if not (N | M):\n        break\n    S, G = map(lambda x: int(x) - 1, input().split())\n    edge = [[] for _ in range(N)]\n    for _ in range(M):\n        x, y, d, c = map(int, input().split())\n        edge[x - 1].append((y - 1, d, c))\n        edge[y - 1].append((x - 1, d, c))\n    INF = float('inf')\n    dist = [[[INF for _ in range(N)] for _ in range(MAX_SPEED + 1)] for _ in range(N)]\n    que = [(0.0, S, 0, S)]\n    while que:\n        cost, now, v, prev = heapq.heappop(que)\n        if cost > dist[now][v][prev]:\n            continue\n        if now == G and v == 1:\n            print(\"{:.20f}\".format(cost))\n            break\n        dist[now][v][prev] = cost\n        for x, d, c in edge[now]:\n            if x == prev:\n                continue\n            if 0 < v <= c and dist[x][v][now] > dist[now][v][prev] + d / v:\n                dist[x][v][now] = dist[now][v][prev] + d / v\n                heapq.heappush(que, (dist[x][v][now], x, v, now))\n            if v < c and dist[x][v + 1][now] > dist[now][v][prev] + d / (v + 1):\n                dist[x][v + 1][now] = dist[now][v][prev] + d / (v + 1)\n                heapq.heappush(que, (dist[x][v + 1][now], x, v + 1, now))\n            if 1 < v <= c + 1 and dist[x][v - 1][now] > dist[now][v][prev] + d / (v - 1):\n                dist[x][v - 1][now] = dist[now][v][prev] + d / (v - 1)\n                heapq.heappush(que, (dist[x][v - 1][now], x, v - 1, now))\n    else:\n        print(\"unreachable\")"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    while True:\n        n,m = LI()\n        if n == 0:\n            break\n\n        s,g = LI()\n        a = [LI() for _ in range(m)]\n        e = collections.defaultdict(list)\n        for x,y,d,c in a:\n            e[x].append((y,d,c))\n            e[y].append((x,d,c))\n\n        def search(s):\n            d = collections.defaultdict(lambda: inf)\n            d[(s,0,-1)] = 0\n            q = []\n            heapq.heappush(q, (0, (s, 0, -1)))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n                if u[0] == g and u[1] == 1:\n                    return '{:0.9f}'.format(k)\n                c = u[1]\n                b = u[2]\n\n                for uv, ud, uc in e[u[0]]:\n                    if uv == b:\n                        continue\n                    for tc in range(max(c-1,1),min(uc+1,c+2)):\n                        nuv = (uv, tc, u[0])\n                        if v[nuv]:\n                            continue\n                        vd = k + ud / tc\n                        if d[nuv] > vd:\n                            d[nuv] = vd\n                            heapq.heappush(q, (vd, nuv))\n\n            return 'unreachable'\n\n        rr.append(search(s))\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nwhile 1:\n    n, m = map(int, raw_input().split())\n    if n==m==0:\n        break\n    s, g = map(int, raw_input().split())\n    G = [[] for i in xrange(n+1)]\n    for i in xrange(m):\n        x, y, d, c = map(int, raw_input().split())\n        d = float(d)\n        G[x].append((y, d, c))\n        G[y].append((x, d, c))\n\n    dist = {}\n    # (cost, v, prev, speed)\n    que = [(0, (s, -1, 1))]\n    dist[s, -1, 1] = 0\n    ans = 1e18\n    while que:\n        cost, key = heappop(que)\n        if dist[key] < cost:\n            continue\n        v, prev, sp = key\n        for t, d, c in G[v]:\n            if t == prev or sp > c:\n                continue\n            n_cost = cost + d/sp\n            for dv in [-1, 0, 1]:\n                if not 0 < sp+dv <= 30:\n                    continue\n                n_key = (t, v, sp+dv)\n                if n_cost < dist.get(n_key, 1e18):\n                    dist[n_key] = n_cost\n                    heappush(que, (n_cost, n_key))\n            if t == g and sp==1:\n                ans = min(ans, n_cost)\n    print \"%.10f\" % ans if ans < 1e17 else \"unreachable\""
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\nwhile True:\n  n, m = map(int, input().split())\n  if n==0 and m==0:\n    break\n\n  s, g = map(int, input().split())\n  graph = defaultdict(list)\n  for _ in range(m):\n    x, y, d, c = map(int, input().split())\n    graph[x].append((y, d, c))\n    graph[y].append((x, d, c))\n\n  def dijkstra(s):\n    d = defaultdict(lambda:float(\"INF\"))\n    d[(s, 0, -1)] = 0\n    used = defaultdict(bool)\n\n    q = []\n    heappush(q, (0, (s, 0, -1)))\n\n    while len(q):\n      elapsed, v = heappop(q)\n\n      cur, vel1, prev1 = v[0], v[1], v[2]\n      if cur==g and vel1 == 1:\n        return elapsed\n\n      if used[v]:\n        continue\n      used[v] = True\n\n      for to, dist, ct in graph[cur]:\n        if to==prev1:\n          continue\n        for vel2 in range(vel1-1, vel1+2):\n          if vel2<1 or ct<vel2:\n            continue\n\n          nxt = (to, vel2, cur)\n          if used[nxt]:\n            continue\n          elapsed2 = elapsed+dist/vel2\n          if d[nxt] > elapsed2:\n            d[nxt] = elapsed2\n            heappush(q, (elapsed2, nxt))\n\n    return \"unreachable\"\n  \n  print(dijkstra(s))\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\n\ndef main():\n    while True:\n        n, m = map(int, input().split())\n        if n == 0:\n            break\n        s, g = map(int, input().split())\n        s -= 1\n        g -= 1\n        edges = [[] for _ in range(n)]\n        for _ in range(m):\n            x, y, d, c = map(int, input().split())\n            x -= 1\n            y -= 1\n            edges[x].append((y, d, c))\n            edges[y].append((x, d, c))\n\n        que = []\n        heappush(que, (0, 1, s, None))\n        dic = {}\n        dic[(1, None, s, None)] = 0\n        INF = 10 ** 20\n        ans = INF\n        while que:\n            score, speed, node, pre_node= heappop(que)\n            if score >= ans:break\n            for to, dist, limit in edges[node]:\n                if to == pre_node or speed > limit:continue\n                new_score = score + dist / speed\n                if speed == 1 and to == g and ans > new_score:ans = new_score\n                for new_speed in (speed - 1, speed, speed + 1):\n                    if new_speed <= 0:continue\n                    if (new_speed, to, node) not in dic or dic[(new_speed, to, node)] > new_score:\n                        dic[(new_speed, to, node)] = new_score\n                        heappush(que, (new_score, new_speed, to, node))\n        if ans == INF:\n            print(\"unreachable\")\n        else:\n            print(ans)\n\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "from fractions import Fraction\nMAX_SPEED = 30\nwhile True:\n    N, M = map(int, input().split())\n    if not (N | M):\n        break\n    S, G = map(lambda x: int(x) - 1, input().split())\n    edge = []\n    for _ in range(M):\n        x, y, d, c = map(int, input().split())\n        edge.append((x - 1, y - 1, d, c))\n        edge.append((y - 1, x - 1, d, c))\n    INF = float('inf')\n    dist = [[[INF for _ in range(N)] for _ in range(MAX_SPEED + 1)] for _ in range(N)]\n    dist[S][0][S] = Fraction()\n    while True:\n        flag = False\n        for x, y, d, c in edge:\n            for j in range(min(MAX_SPEED + 1, c + 2)):\n                for k in range(N):\n                    if k == y or (j <= c and dist[x][j][k] == INF):\n                        continue\n                    # print(x, y, d, c, j, k, dist[x][j][k])\n                    if j > 1 and dist[y][j - 1][x] > dist[x][j][k] + Fraction(d, j - 1):\n                        dist[y][j - 1][x] = dist[x][j][k] + Fraction(d, j - 1)\n                        flag = True\n                    if 0 < j <= c and dist[y][j][x] > dist[x][j][k] + Fraction(d, j):\n                        dist[y][j][x] = dist[x][j][k] + Fraction(d, j)\n                        flag = True\n                    if j < c and dist[y][j + 1][x] > dist[x][j][k] + Fraction(d, j + 1):\n                        dist[y][j + 1][x] = dist[x][j][k] + Fraction(d, j + 1)\n                        flag = True\n        if not flag:\n            break\n    \"\"\"\n    for i in range(N):\n        print(*dist[i], sep='\\n')\n        print()\n    \"\"\"\n    ans = min(dist[G][1][j] for j in range(N))\n    print(\"unreachable\" if ans == INF else \"{:.20f}\".format(float(ans)))"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nwhile True:\n  n,m = map(int, raw_input().split())\n  if n == 0 and m == 0: break\n  s,g = map(int, raw_input().split())\n  s -= 1\n  g -= 1\n  dist = [[10.0**9 for _ in xrange(n)] for _ in xrange(n)]\n  limit = [[0.0 for _ in xrange(n)] for _ in xrange(n)]\n  mintime = [[10.0**9 for _ in xrange(40)] for _ in xrange(n)]\n  for _ in xrange(m):\n    x,y,d,c = map(int, raw_input().split())\n    x -= 1\n    y -= 1\n    dist[x][y] = float(d)\n    dist[y][x] = float(d)\n    limit[x][y] = float(c)\n    limit[y][x] = float(c)\n  mintime[s][1] = 0.0\n\n  q = deque()\n  q.appendleft((s, 1))\n  while len(q) > 0:\n    a = q.popleft()\n    if a[1] == 0: continue\n    for i in xrange(n):\n      if limit[a[0]][i] < a[1]: continue\n      for k in xrange(-1, 2):\n        if 0 <= a[1] + k and mintime[a[0]][a[1]] + dist[a[0]][i] / a[1] < mintime[i][a[1] + k]:\n          mintime[i][a[1] + k] = mintime[a[0]][a[1]] + dist[a[0]][i] / a[1]\n          q.appendleft((i, a[1] + k))\n  if mintime[g][0] == 10.0**9: print 'unreachable'\n  else: print mintime[g][0]"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::collections::BinaryHeap;\nuse std::cmp::Ordering;\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n#[derive(Copy, Clone)]\nstruct Road{\n    to: usize,\n    distance: f64,\n    limit: usize\n}\n#[derive(Copy, Clone)]\nstruct State {\n    prev: usize,\n    current: usize,\n    time: f64,\n    speed: usize,\n}\nimpl Ord for State {\n    fn cmp(&self, other: &Self) -> Ordering {\n        ((other.time - self.time).signum() as i32).cmp(&0_i32)\n    }\n}\nimpl PartialOrd for State {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\nimpl PartialEq for State {\n    fn eq(&self, other: &Self) -> bool {\n        self.current == other.current && self.time == other.time && self.speed == other.speed\n    }\n}\nimpl Eq for State {}\nfn main() {\n    loop {\n        let_all!(n: usize, m: usize);\n        if n == 0 && m == 0 {\n            break\n        }\n        let_all!(s: usize, g: usize);\n        let mut memo = vec![vec![vec![std::f64::MAX; 30]; n]; n];\n        let mut queue = BinaryHeap::<State>::new();\n        let mut roads = vec![Vec::<Road>::new(); n];\n        for _ in 0..m {\n            let_all!(x: usize, y: usize, d: f64, c: usize);\n            roads[x - 1].push(Road { to: y - 1, distance: d, limit: c });\n            roads[y - 1].push(Road { to: x - 1, distance: d, limit: c });\n        }\n        for &road in &roads[s - 1] {\n            memo[s - 1][road.to][0] = road.distance;\n            queue.push(State{prev: s - 1, current: road.to, time: road.distance, speed: 1});\n        }\n        let mut result = 0_f64;\n        while let Some(State { prev, current, time, speed }) = queue.pop() {\n            if current == g - 1 && speed == 1 {\n                result = time;\n                break\n            }\n            if memo[prev][current][speed - 1] == time {\n                for &road in &roads[current] {\n                    if road.to != prev {\n                        for v in speed - 1..speed + 2 {\n                            if v > 0 && v <= road.limit {\n                                let new_time = time + road.distance / v as f64;\n                                if memo[current][road.to][v - 1] > new_time {\n                                    memo[current][road.to][v - 1] = new_time;\n                                    queue.push(State { prev: current, current: road.to, time: new_time, speed: v });\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if result == 0_f64 {\n            println!(\"unreachable\");\n        } else {\n            println!(\"{:.*}\", 10, result);\n        }\n    }\n}\n"
  }
]