[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <climits>\n#include <deque>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nint m[1000];\nint l[1000];\nint k[1000];\n\nint main(){\n  while(true){\n    int n = getInt();\n    int t = getInt();\n\n    if(n + t == 0) break;\n\n    int mm = 0;\n\n    REP(i,n){\n      m[i] = getInt();\n      l[i] = getInt();\n      k[i] = getInt();\n\n      mm += m[i];\n    }\n\n    for(int p = max(1, mm / t); ; p++){\n      vector<bool> ok(n, false);\n      int cnt = 0;\n      priority_queue<int> op;\n\n      REP(i,p) op.push(0);\n\n      while(op.size() && cnt != n){\n\tint tm = - op.top(); op.pop();\n\n\tif(tm >= t) break;\n\n\tpair<int, int> process = make_pair(INT_MAX, INT_MAX);\n\n\tint tmp = 0;\n\n\tREP(i,n) if(!ok[i]){\n\t  int next;\n\t  if(tm % (l[i] + k[i]) <= l[i]) next = tm;\n\t  else next = (l[i] + k[i]) * ((tm + k[i]) / (l[i] + k[i]));\n\t  process = min(process, make_pair(next, i));\n\t  tmp += m[i];\n\t}\n\n\tif(tmp > p * (t - tm)) break;\n\n\tif(process.first != INT_MAX){\n\t  if(process.first + m[process.second] <= t){\n\t    op.push(- (process.first + m[process.second]));\n\t    ok[process.second] = true;\n\t    cnt++;\n\t  }else{\n\t    break;\n\t  }\n\t}\n      }\n\n      if(cnt == n){\n\tprintf(\"%d\\n\", p);\n\tbreak;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<functional>\nusing namespace std;\nconst int MAX=1000;\nstruct S{int m,l,k;}s,a[MAX];\nint F(int n, int N, int T)\n{\n\tbool f[MAX]={0};\n\tpriority_queue<int,vector<int>,greater<int> >q;\n\tint c=0,i,t;\n\tfor(t=0;t<T+1;++t)\n\t{\n\t\twhile(!q.empty() && q.top()<=t)q.pop(),++n,++c;\n\t\tif(c==N)break;\n\t\tif(n)\n\t\t{\n\t\t\tfor(i=0;i<N;++i)\n\t\t\t{\n\t\t\t\tif(!f[i] && t%(a[i].l+a[i].k)<a[i].l)\n\t\t\t\t{\n\t\t\t\t\tf[i]=1;\n\t\t\t\t\tq.push(t+a[i].m-1);\n\t\t\t\t\t--n;\n\t\t\t\t\tif(!n)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn c==N;\n}\nint main()\n{\n\tint N,T,i;\n\twhile(scanf(\"%d%d\",&N,&T),N)\n\t{\n\t\tfor(i=0;i<N;++i)scanf(\"%d%d%d\",&a[i].m,&a[i].l,&a[i].k);\n\t\tint l=1,r=N+1,m,s;\n\t\twhile(l<r)\n\t\t{\n\t\t\tm=(l+r)/2;\n\t\t\tif(F(m,N,T))r=m,s=m;\n\t\t\telse l=m+1;\n\t\t}\n\t\tprintf(\"%d\\n\",s);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,t,m[1000],l[1000],k[1000];\n\nbool check(int x){\n  int c[1001]={},used[1000]={},cnt=n;\n  for(int i=0;i<t&&cnt;i++){\n    x+=c[i];\n    for(int j=0;j<n&&x;j++){\n      if(used[j])continue;\n      if(i+m[j]>t)return 0;\n      if(i%(l[j]+k[j])<=l[j])c[i+m[j]]++,cnt--,used[j]=1,x--;\n    }\n  }\n  return !cnt;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&t),n){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    int ans=0;\n    for(int i=1;i<=n&&!ans;i++)if(check(i))ans=i;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n \nint main() {\n  int n,t;\n  while(cin >> n >> t && n) {\n    PP a[n];\n    for(int i=0; i<n; i++) {\n      cin >> a[i].F.F >> a[i].S.F >> a[i].S.S;\n      a[i].F.S=i;\n    }\n    for(int m=1; m<=n; m++) {\n      bool f=0;\n      int b[n],c[t+1],cnt=0;\n      memset(b,0,sizeof(b));\n      memset(c,0,sizeof(c));\n      c[0]=m;\n      for(int k=0; k<t; k++) {\n        for(int i=0; i<n; i++) {\n          if(b[i]==-1) continue;\n          if(c[k]&&b[i]<=k&&k<=b[i]+a[i].S.F) {\n            if(k+a[i].F.F>t) break;\n            c[k]--;\n            c[k+a[i].F.F]++;\n            b[i]=-1;\n            cnt++;\n          } else if(b[i]+a[i].S.F==k) b[i]=k+a[i].S.S;\n        }\n        if(cnt==n) {f=1;break;}\n        c[k+1]+=c[k];\n      }\n      if(f) {cout << m << endl;break;}\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\nusing namespace std;\n\nclass State\n{\npublic:\n\tint id, t;\n\tState(int id, int t)\n\t\t:id(id),t(t)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\tif(t!=s.t) return t>s.t;\n\t\treturn id>s.id;\n\t}\n};\n\nint N, T;\nint M[1000], L[1000], K[1000];\n\nbool simulate(int opnum)\n{\n\tpriority_queue<int, vector<int>, greater<int> > ops;\n\tfor(int i=0; i<opnum; i++) ops.push(0);\n\n\tpriority_queue<State> q;\n\tfor(int i=0; i<N; i++) q.push(State(i,0));\n\n\twhile(!q.empty()) {\n\t\tState s = q.top(); q.pop();\n\t\tint id = s.id;\n\t\tint op = ops.top(); ops.pop();\n\n\t\tif(op > s.t + L[id]) {\n\t\t\tint nt = s.t + L[id] + K[id];\n\t\t\tif(nt > T) return false;\n\n\t\t\tq.push(State(id, nt));\n\t\t\tops.push(op);\n\t\t}\n\t\telse {\n\t\t\tint nt = M[id];\n\t\t\tif(op < s.t) nt += s.t;\n\t\t\telse nt += min(op, s.t + L[id]);\n\n\t\t\tif(nt > T) return false;\n\n\t\t\tops.push(nt);\n\t\t}\n\t}\n\t\t\n\n\treturn true;\n}\n\nint solve()\n{\n\tint res = 1;\n\tfor(;; res++) {\n\t\tif(simulate(res)) break;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\twhile(cin >> N >> T, (N||T)) {\n\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tcin >> M[i] >> L[i] >> K[i];\n\t\t}\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint c[1100];\nint d[1100];\nint e[1100];\nint fin[1100];\nint next[1100];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%d%d%d\",c+i,d+i,e+i);\n\t\tint left=0;\n\t\tint right=1001;\n\t\twhile(left+1<right){\n\t\t\tint M=(left+right)/2;\n\t\t\tfor(int i=0;i<M;i++)fin[i]=0;\n\t\t\tfor(int i=0;i<a;i++)next[i]=0;\n\t\t\tint last=0;\n\t\t\tfor(int i=0;i<b;i++){\n\t\t\t\tfor(int j=0;j<M;j++){\n\t\t\t\t\tif(fin[j]<=i){\n\t\t\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\t\t\tif(~next[k]&&next[k]<=i){\n\t\t\t\t\t\t\t\tnext[k]=-1;\n\t\t\t\t\t\t\t\tfin[j]=i+c[k];\n\t\t\t\t\t\t\t\tlast=max(last,fin[j]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\t\tif(~next[j]&&i==next[j]+d[j]){\n\t\t\t\t\t\tnext[j]=next[j]+d[j]+e[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<a;i++)if(~next[i])last=9999999;\n\t\t\tif(last<=b){\n\t\t\t\tright=M;\n\t\t\t}else left=M;\n\t\t}\n\t\tprintf(\"%d\\n\",right);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nstruct Customer {\n\tint M, L, K;\n};\n\nbool simulate(const vector<Customer> &customers, int ops, int T){\n\tconst int INDEX_MASK = 0x0ffff;\n\tconst int TIME_SHIFT = 4;\n\tconst int MODE_DONE = 0;\n\tconst int MODE_CALL = 1;\n\tconst int MODE_HANG = 2;\n\tint N = customers.size();\n\tpriority_queue< pii, vector<pii>, greater<pii> > cq;\n\tpriority_queue< int, vector<int>, greater<int> > wq;\n\tvector<bool> done(N), waiting(N);\n\tfor(int i = 0; i < N; ++i){ cq.push(pii(MODE_CALL, i)); }\n\tint freeOps = ops, doneCount = 0, lastTime = 0;\n\twhile(!cq.empty()){\n\t\tpii p = cq.top();\n\t\tint time = p.first >> TIME_SHIFT;\n\t\tint mode = p.first & ((1 << TIME_SHIFT) - 1);\n\t\tint idx = p.second;\n\t\tlastTime = time;\n\t\tif(time > T){ return false; }\n\t\tcq.pop();\n\t\tif(mode == MODE_CALL){\n\t\t\tif(freeOps > 0){\n\t\t\t\tdone[idx] = true;\n\t\t\t\tcq.push(pii(\n\t\t\t\t\t((time + customers[idx].M) << TIME_SHIFT) | MODE_DONE, idx));\n\t\t\t\t--freeOps;\n\t\t\t}else{\n\t\t\t\tcq.push(pii(\n\t\t\t\t\t((time + customers[idx].L) << TIME_SHIFT) | MODE_HANG, idx));\n\t\t\t\twq.push(idx);\n\t\t\t\twaiting[idx] = true;\n\t\t\t}\n\t\t}else if(mode == MODE_HANG){\n\t\t\tif(!done[idx]){\n\t\t\t\tcq.push(pii(\n\t\t\t\t\t((time + customers[idx].K) << TIME_SHIFT) | MODE_CALL, idx));\n\t\t\t\twaiting[idx] = false;\n\t\t\t}\n\t\t}else if(mode == MODE_DONE){\n\t\t\t++freeOps;\n\t\t\tif(++doneCount == N){ break; }\n\t\t\twhile(!wq.empty()){\n\t\t\t\tint wi = wq.top();\n\t\t\t\twq.pop();\n\t\t\t\tif(waiting[wi]){\n\t\t\t\t\t--freeOps;\n\t\t\t\t\twaiting[wi] = false;\n\t\t\t\t\tdone[wi] = true;\n\t\t\t\t\tcq.push(pii(\n\t\t\t\t\t\t((time + customers[wi].M) << TIME_SHIFT) | MODE_DONE, wi));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint N, T;\n\t\tcin >> N >> T;\n\t\tif(N == 0 && T == 0){ break; }\n\t\tvector<Customer> customers(N);\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tcin >> customers[i].M;\n\t\t\tcin >> customers[i].L;\n\t\t\tcin >> customers[i].K;\n\t\t}\n\t\tint answer = 1;\n\t\twhile(!simulate(customers, answer, T)){ ++answer; }\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define M 1001\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint n,t,m[M],l[M],k[M],add[M*M];\nbool used[M];\nbool ch(int x){\n  memset(add,0,sizeof(add));\n  memset(used,0,sizeof(used));\n  int cnt=0;\n  r(i,t+1){\n    x+=add[i];\n    r(j,n)if(!used[j]){\n      int p=l[j]+k[j];\n      if(i%p<=l[j]&&x){\n\tadd[i+m[j]]++;\n\tused[j]=1;\n\tx--;\n\tcnt++;\n      }\n    }\n  }\n  return cnt==n;\n}\nint main(){\n  while(cin>>n>>t,t){\n    r(i,n)cin>>m[i]>>l[i]>>k[i];\n    r(i,M){\n      if(ch(i)){\n\tcout<<i<<endl;\n\tbreak;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <set>\n\nusing namespace std;\n\nbool isCalling[1001];\nbool isTelling[1001];\nbool isFin[1001];\nint N,T;\nint Mi[1001];\nint Li[1001];\nint Ki[1001];\n\nclass Event{\npublic:\n    // 0->qªhang up\n    // 1->qªdbJn\n    // 2->operatorªdbðI¹\n    int cid;\n    int time;\n    Event(int c,int t){\n        cid=c,time=t;\n    }\n    Event();\n    bool operator<(const Event &e)const{\n        return(this->time>e.time);\n    }\n};\ntypedef pair<int,int> pii;\n// nlÌIy[^ªvéÆ«ÌV~[V\nbool check(int n){\n    memset(isFin,0,sizeof(isFin));\n    priority_queue<Event> pq;\n    int curTime=0;\n    for(int i=0;i<n;i++){\n        pq.push(Event(i,Mi[i]));\n        isFin[i]=true;\n    }\n    // »Ýq}ÈopÌ\n    int opr=0;\n    int cnt=N;\n    while(pq.size()){\n        // ¡ñÌCxgªI¹µ½opðæèo·\n        Event e=pq.top();pq.pop();\n        curTime=e.time;\n        cnt--;\n        opr++;\n        // óÅ©ÂÜ¾IíÁÄ¢È¢Cxgª¶Ý\n        if(pq.size()==0){\n            if(cnt!=0){\n                priority_queue<pii> pqpi;\n                // ÊbÂ\\ÉÈéÜÅª¢ÔÉÀ×é\n                for(int i=0;i<N;i++){\n                    if(isFin[i])continue;\n                    int a=e.time%(Ki[i]+Li[i]);\n                    if(a>=0&&a<=Li[i])\n                        pqpi.push(make_pair(0,-i));\n                    else{\n                        int b=Ki[i]-(a-Li[i]);\n                        pqpi.push(make_pair(b,-i));\n                    }\n                }\n                // ÔÉæèo·\n                while(pqpi.size()&&opr){\n                    pii p=pqpi.top();pqpi.pop();\n                    opr--;\n                    pq.push(Event(-p.second,curTime+p.first+Mi[-p.second]));\n                    isFin[-p.second]=true;\n                }\n            }\n        }\n        // ñÌCxgªI¹·éÜÅÌÔÜÅÉAdbÂ\\ÔÉÈéàÌð·×Ä·\n        else{\n            priority_queue<pii> pqpi;\n            int neft=pq.top().time;\n            // ÊbÂ\\ÉÈéÜÅª¢ÔÉÀ×é\n            for(int i=0;i<N;i++){\n                if(isFin[i])continue;\n                int a=e.time%(Ki[i]+Li[i]);\n                if(a>=0&&a<=Li[i])\n                    pqpi.push(make_pair(0,-i));\n                else{\n                    int b=Ki[i]-(a-Li[i]);\n                    // ÊbÂ\\ÉÈéÔªneftæè¬³¢ÈçÎ\n                    if(b+curTime<neft)pqpi.push(make_pair(b,-i));\n                }\n            }\n            // ÔÉæèo·\n            while(pqpi.size()&&opr){\n                pii p=pqpi.top();pqpi.pop();\n                opr--;\n                pq.push(Event(-p.second,curTime+p.first+Mi[-p.second]));\n                isFin[-p.second]=true;\n            }\n        }\n    }\n    return curTime<=T;\n}\n\nint main(){\n    while(cin>>N>>T&&(N|T)){\n        for(int i=0;i<N;i++)cin>>Mi[i]>>Li[i]>>Ki[i];\n        for(int i=1;i<=N;i++){\n            if(check(i)){\n                cout<<i<<endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct cust {\n\tint  m;\n\tint l;\n\tint k;\n};\n \nstruct query {\n\tint type;\n\tint time;\n\tint id;\n};\nstruct aa {\n\tint id;\n\tint time;\n};\nclass Compare {\npublic:\n\tbool operator()(const query&l,const query&r) {\n\t\treturn l.time==r.time?l.type==r.type?l.id>r.id:l.type>r.type:l.time > r.time;\n\t}\n\tbool operator()(const aa&l, aa&r) {\n\t\treturn l.time > r.time;\n\t}\n};\n\nbool check(const int T, const vector<cust>&cus, const int n) {\n\tint waitnum = n;\n\tpriority_queue<query,vector<query>,Compare>que;\n\t//vector<int>waits(cus.size());\n\tset<int>waits;\n\tfor (int i = 0; i < cus.size(); ++i) {\n\t\tque.push(query{ 0,0,i });\n\t}\n\twhile (!que.empty()) {\n\t\tquery q(que.top());\n\t\tque.pop();\n\t\tif (q.type == 1) {\n\t\t\tauto it = waits.begin();\n\t\t\tif (it == waits.end()) {\n\t\t\t\twaitnum++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst int cid = *it;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\twaits.erase(it);\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}\n\t\t\t\telse if (nexttime == T) {\n\t\t\t\t\twaits.erase(it);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\telse if (q.type == 0) {\n\t\t\tconst int cid = q.id;\n\t\t\tif (waitnum) {\n\t\t\t\twaitnum--;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}\n\t\t\t\telse if (nexttime == T) {\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\twaits.emplace(cid);\n\t\t\t\tconst int nexttime = q.time + cus[cid].l;\n\t\t\t\tque.push(query{ 2,nexttime,cid });\n\t\t\t}\n\t\t}\n\t\telse if (q.type == 2) {\n\t\t\tconst int cid = q.id;\n\t\t\tauto it = waits.find(cid);\n\t\t\tif (it!=waits.end()) {\n\t\t\t\twaits.erase(it);\n\t\t\t\tconst int nexttime = q.time + cus[cid].k;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\tque.push(query{ 0,nexttime,cid });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, T; cin >> N >> T;\n\t\tif (!N)break;\n\t\tvector<cust>cus;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint m, l, k; cin >> m >> l >> k;\n\t\t\tcus.push_back(cust{ m,l,k });\n\t\t}\n\t\t/*int amin = 0;\n\t\tint amax = N;\n\t\twhile (amin + 1 != amax) {\n\t\t\tint amid = (amin + amax) / 2;\n\t\t\tif (check(T, cus, amid)) {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t}\n\t\tcout << amax << endl;*/\n\t\tint ans = 0;\n\t\tfor (int n = 1; n <= N; ++n) {\n\t\t\tif (check(T, cus, n)) {\n\t\t\t\tans = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,t,m[1000],l[1000],k[1000];\n\nbool check(int x){\n  int c[1001]={},used[1000]={},cnt=0;\n  for(int i=0;i<t;i++){\n    x+=c[i];\n    for(int j=0;j<n&&x;j++){\n      if(used[j])continue;\n      if(i+m[j]>t)return 0;\n      if(i%(l[j]+k[j])<=l[j])c[i+m[j]]++,cnt++,used[j]=1,x--;\n    }\n  }\n  return cnt==n;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&t),n){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    int ans=0;\n    for(int i=1;i<=n&&!ans;i++)if(check(i))ans=i;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\ntypedef long long LL;\nusing namespace std;\n\nstruct node{\n    int i,w;\n    node(int _i=0,int _w=0){\n        i=_i; w=_w;\n    }\n    bool operator<(const node &t)const{\n        return w>t.w;\n    }\n};\nint N,T,M[1100],L[1100],K[1100];\n\nint b[1100]={0},in[1100]={0};     \npriority_queue<node> hang,wait,dial;\npriority_queue<int,vector<int>,greater<int> > Q;\n\nbool gao(int rest){\n    memset(b,0,sizeof(b));\n    memset(in,0,sizeof(in));\n    while (!hang.empty()) hang.pop();\n    while (!wait.empty()) wait.pop();\n    while (!dial.empty()) dial.pop();\n    while (!Q.empty()) Q.pop();\n    int t,i;\n    for (i=1;i<=N;i++){\n        hang.push(node(i,0));\n    }\n    for (t=0;t<=T;t++){\n        while (!hang.empty() && hang.top().w==t){\n            i=hang.top().i; hang.pop();\n            wait.push(node(i,t+L[i])); b[i]=1;\n            if (!in[i]){\n                Q.push(i); in[i]=1;\n            }\n        }\n        while (!dial.empty() && dial.top().w==t){\n            b[dial.top().i]=3; dial.pop(); ++rest;\n        }\n        while (!Q.empty() && rest){\n            i=Q.top(); Q.pop(); in[i]=0;\n            if (b[i]!=1) continue;\n            b[i]=2; dial.push(node(i,t+M[i]));  --rest;\n        }\n        while (!wait.empty() && wait.top().w==t){\n            i=wait.top().i; wait.pop(); \n            if (b[i]==1){\n                b[i]=0; hang.push(node(i,t+K[i]));\n                if (t+K[i]+W[i]>T) return 0;\n            }\n        }\n    }\n    for (i=1;i<=N;i++){\n        if (b[i]<3) return 0;\n    }\n    return 1;\n}\n\nint main(){\n    while (scanf(\"%d%d\",&N,&T),N | T){\n        int i;\n        for (i=1;i<=N;i++){\n            scanf(\"%d%d%d\",&M[i],&L[i],&K[i]);\n        }\n        for (i=1;i<=N;i++)\n            if (gao(i)) break;\n        printf(\"%d\\n\",i);\n    }       \n}   "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,t,m[1000],l[1000],k[1000];\n\nbool check(int x){\n  int c[1001]={},used[1000]={},cnt=n;\n  for(int i=0;i<t;i++){\n    x+=c[i];\n    for(int j=0;j<n&&x;j++){\n      if(used[j])continue;\n      if(i+m[j]>t)return 0;\n      if(i%(l[j]+k[j])<=l[j])c[i+m[j]]++,cnt--,used[j]=1,x--;\n    }\n  }\n  return !cnt;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&t),n){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    int ans=0;\n    for(int i=1;i<=n&&!ans;i++)if(check(i))ans=i;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n#define MAXN 1010\n\nint n,t;\nstruct node\n{\n    int m,l,k;\n}a[MAXN];\nint cnt,wait[MAXN];\nint st[MAXN],sta[MAXN];\nbool check(int num)\n{\n    memset(st,0,sizeof(st));\n    memset(sta,0,sizeof(sta));\n    for (int i=0;i<=t;i++)\n    {\n        cnt=0;\n        for (int j=1;j<=n;j++)\n        {\n            if (sta[j]==1&&st[j]+a[j].k==i) sta[j]=0,st[j]=i;\n            if (sta[j]==0) wait[++cnt]=j;\n            if (sta[j]==2&&st[j]+a[j].m==i)\n            {\n                sta[j]=3,st[j]=i;\n                num++;\n            }\n        }\n        for (int j=1;j<=min(num,cnt);j++)\n        {\n            int x=wait[j];\n            sta[x]=2;\n            st[x]=i;\n        }\n        num=max(0,num-cnt);\n        for (int j=1;j<=n;j++)\n        {\n            if (sta[j]==0&&st[j]+a[j].l==i) sta[j]=1,st[j]=i;\n        }\n    }\n    for (int i=1;i<=n;i++)\n        if (sta[i]!=3) return false;\n    return true;\n}\nint main()\n{\n    //freopen(\"/home/moor/Code/input\",\"r\",stdin);\n    while (scanf(\"%d%d\",&n,&t)&&n+t)\n    {\n        for (int i=1;i<=n;i++)\n            scanf(\"%d%d%d\",&a[i].m,&a[i].l,&a[i].k);\n        int l=1,r=n,ans;\n       while (l<=r)\n        {\n            int mid=(l+r)>>1;\n            if (check(mid)) r=mid-1,ans=mid;\n            else l=mid+1;\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N,T;\nint M[1000],L[1000],K[1000];\n\nint flg[1000];\nbool used[1000];\n\nbool check(int x){\n  fill(flg,flg+x,0);\n  fill(used,used+N,false);\n  \n  for(int t=0;t<=T;t++){\n\n    for(int i=0;i<x;i++){\n      if(flg[i]>t)continue;\n      for(int j=0;j<N;j++){\n        if(used[j])continue;\n        int f=t%(L[j]+K[j]);\n        if(L[j]<f){\n          continue;\n        }\n        used[j]=true;\n        flg[i]=t+M[j];\n        //        cout<<\"t=\"<<t<<\" i=\"<<i<<' '<<j<<' '<<flg[i]<<endl;\n        break;\n      }\n    }\n    \n    int mini=1e9;\n    for(int j=0;j<N;j++){\n      if(used[j])continue;\n      int f=t%(L[j]+K[j]);\n      if(L[j]<f){\n        mini=min(mini,K[j]-(f-L[j]));\n      }else mini=0;\n    }\n    \n    //    cout<<t<<' '<<mini<<endl;\n\n    int mini2=1e9;\n    for(int j=0;j<x;j++){\n      if(flg[j]>t)mini2=min(mini2,flg[j]-t);\n      else mini2=0;\n    }\n    \n    t+=max(0,mini-1);\n  }\n  \n  for(int i=0;i<N;i++)\n    if(!used[i])return false;\n  \n  for(int i=0;i<x;i++)\n    if(flg[i]>T)return false;\n  return true;\n}\n\nint main(){\n  while(1){\n    cin>>N>>T;\n    if(N==0&&T==0)break;\n    for(int i=0;i<N;i++){\n      cin>>M[i]>>L[i]>>K[i];\n    }\n\n    int left=1,right=N,mid;\n\n    while(left<right){\n      mid=(left+right)/2;\n      bool result=check(mid);\n\n      if(result)right=mid;\n      else left=mid+1;\n    }\n\n    \n    cout<<left<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<functional>\nusing namespace std;\nconst int MAX=1000;\nstruct S{int m,l,k;}s,a[MAX];\nint F(int n, int N, int T)\n{\n\tbool f[MAX]={0};\n\tpriority_queue<int,vector<int>,greater<int> >q;\n\tint c=0,i,t;\n\tfor(t=0;t<T;++t)\n\t{\n\t\twhile(!q.empty() && q.top()<=t)q.pop(),++n,++c;\n\t\tif(c==N)break;\n\t\tif(n)\n\t\t{\n\t\t\tfor(i=0;i<N;++i)\n\t\t\t{\n\t\t\t\tif(!f[i] && t%(a[i].l+a[i].k)<a[i].l)\n\t\t\t\t{\n\t\t\t\t\tf[i]=1;\n\t\t\t\t\tq.push(t+a[i].m-1);\n\t\t\t\t\t--n;\n\t\t\t\t\tif(!n)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn c==N;\n}\nint main()\n{\n\tint N,T,i;\n\twhile(scanf(\"%d%d\",&N,&T),N)\n\t{\n\t\tfor(i=0;i<N;++i)scanf(\"%d%d%d\",&a[i].m,&a[i].l,&a[i].k);\n\t\tint l=1,r=N+1,m,s;\n\t\twhile(l<r)\n\t\t{\n\t\t\tm=(l+r)/2;\n\t\t\tif(F(m,N,T))r=m,s=m;\n\t\t\telse l=m+1;\n\t\t}\n\t\tprintf(\"%d\\n\",s);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct cust {\n\tint m;\n\tint l;\n\tint k;\n};\n \nstruct query {\n\tint type;\n\tint time;\n\tint id;\n};\nclass Compare {\npublic:\n\tbool operator()(const query&l,const query&r) {\n\t\treturn l.time==r.time?l.type==r.type?l.id>r.id:l.type>r.type:l.time > r.time;\n\t}\n};\n\nbool check(const int T, const vector<cust>&cus, const int n) {\n\tint waitnum = n;\n\tpriority_queue<query,vector<query>,Compare>que;\n\tset<int>waits;\n\tfor (int i = 0; i < cus.size(); ++i) {\n\t\tque.push(query{ 0,0,i });\n\t}\n\twhile (!que.empty()) {\n\t\tquery q(que.top());\n\t\tque.pop();\n\t\t//call start\n\t\t if (q.type == 0) {\n\t\t\tconst int cid = q.id;\n\t\t\tif (waitnum) {\n\t\t\t\twaitnum--;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime <= T) {\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\twaits.emplace(cid);\n\t\t\t\tconst int nexttime = q.time + cus[cid].l;\n\t\t\t\tque.push(query{ 2,nexttime,cid });\n\t\t\t}\n\t\t//call end\n\t\t}else if (q.type == 1) {\n\t\t\tauto it = waits.begin();\n\t\t\tif (it == waits.end()) {\n\t\t\t\twaitnum++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst int cid = *it;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime <= T) {\n\t\t\t\t\twaits.erase(it);\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t//give up call\n\t\t}else if (q.type == 2) {\n\t\t\tconst int cid = q.id;\n\t\t\tauto it = waits.find(cid);\n\t\t\tif (it!=waits.end()) {\n\t\t\t\twaits.erase(it);\n\t\t\t\tconst int nexttime = q.time + cus[cid].k;\n\t\t\t\tif (nexttime <= T-cus[cid].m) {\n\t\t\t\t\tque.push(query{ 0,nexttime,cid });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, T; cin >> N >> T;\n\t\tif (!N)break;\n\t\tvector<cust>cus;\n\t\tint totalm = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint m, l, k; cin >> m >> l >> k;\n\t\t\ttotalm += m;\n\t\t\tcus.push_back(cust{ m,l,k });\n\t\t}\n\t\tint amin = (totalm-1) / T + 1;\n\t\tfor (int n = amin; n <= N; ++n) {\n\t\t\tif (check(T, cus, n)) {\n\t\t\t\tcout << n << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nstruct Customer {\n\tint M, L, K;\n};\n\nbool simulate(const vector<Customer> &customers, int ops, int T){\n\tint N = customers.size();\n\tpriority_queue< int, vector<int>, greater<int> > opfree;\n\tfor(int i = 0; i < ops; ++i){ opfree.push(0); }\n\tbitset<1000> done;\n\tint doneCount = 0;\n\twhile(!opfree.empty()){\n\t\tint t = opfree.top();\n\t\topfree.pop();\n\t\tint minCustomer = -1, minTime = T + 1;\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tif(done[i]){ continue; }\n\t\t\tint cycle = customers[i].L + customers[i].K;\n\t\t\tint nextTime = 0;\n\t\t\tif(t % cycle <= customers[i].L){\n\t\t\t\tnextTime = t;\n\t\t\t}else{\n\t\t\t\tnextTime = (t / cycle + 1) * cycle;\n\t\t\t}\n\t\t\tif(nextTime < minTime){\n\t\t\t\tminTime = nextTime;\n\t\t\t\tminCustomer = i;\n\t\t\t\tif(minTime == t){ break; }\n\t\t\t}\n\t\t}\n\t\tint doneTime = minTime + customers[minCustomer].M;\n\t\tif(doneTime > T){ return false; }\n\t\tdone[minCustomer] = true;\n\t\topfree.push(doneTime);\n\t\tif(++doneCount == N){ break; }\n\t}\n\treturn true;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint N, T;\n\t\tcin >> N >> T;\n\t\tif(N == 0 && T == 0){ break; }\n\t\tvector<Customer> customers(N);\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tcin >> customers[i].M;\n\t\t\tcin >> customers[i].L;\n\t\t\tcin >> customers[i].K;\n\t\t}\n\t\tint answer = 1;\n\t\twhile(!simulate(customers, answer, T)){ ++answer; }\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nint const M = 10000;\nstruct node {\n int id;\n int m,l,k;\n int ov;\n friend bool operator < (node r, node t){\n  return r.id < t.id;\n }\n}q[M],stack_[M];\nint op[M],T,n;\nbool iscall(node t,int p){\n int l = (p)%(t.l+t.k);\n if(l<=t.l) return 1;\n return 0;\n}\nbool check(int num) {\n memset(op,0,sizeof(op));\n op[0]=num;\n for(int i=0;i<n;i++) stack_[i]=q[i];\n int len = n;\n int o = len;\n sort(stack_,stack_+len);\n for(int i=0;i<T;i++){\n    int u  = 0;\n    if(op[i]){\n        for(int j=0;j<len;j++){\n            if(stack_[j].ov==0&&iscall(stack_[j],i)&&i+stack_[j].m<=T){\n                stack_[j].ov=1;\n                op[i+stack_[j].m]++;\n                u++;\n                o--;\n                if(!o) return 1;\n                if(u==op[i]) break ;\n            }\n        }\n    }\n        op[i+1]+=(op[i]-u);\n    }\n if(o<=0) return 1;\n return 0;\n}\nint bin(int l,int r) {\n while(l<r){\n    int mid = (l+r) >>1;\n     bool m =check(mid);\n    if(m==1) r=mid;\n    else l=mid+1;\n }\n return l;\n}\nint main(){\n\n  while(cin>>n>>T,n+T){\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d%d\",&q[i].m,&q[i].l,&q[i].k);\n        q[i].id = i;\n        q[i].ov = 0;\n    }\n    printf(\"%d\\n\",bin(1,n));\n  }\n}\n/*\n\n3 30\n10 5 15\n10 5 15\n10 5 15\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <climits>\n#include <deque>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nint m[1000];\nint l[1000];\nint k[1000];\nint t;\nint n;\n\nint cando(int p){\n  vector<bool> ok(n, false);\n  int cnt = 0;\n  priority_queue<int> op;\n  \n  REP(i,p) op.push(0);\n  \n  while(op.size() && cnt != n){\n    int tm = - op.top(); op.pop();\n    \n    if(tm >= t) break;\n    \n    pair<int, int> process = make_pair(INT_MAX, INT_MAX);\n    \n    int tmp = 0;\n    \n    REP(i,n) if(!ok[i]){\n      int next;\n      if(tm % (l[i] + k[i]) <= l[i]) next = tm;\n      else next = (l[i] + k[i]) * ((tm + k[i]) / (l[i] + k[i]));\n      process = min(process, make_pair(next, i));\n      tmp += m[i];\n    }\n    \n    if(tmp > p * (t - tm)) break;\n    \n    if(process.first != INT_MAX){\n      if(process.first + m[process.second] <= t){\n\top.push(- (process.first + m[process.second]));\n\tok[process.second] = true;\n\tcnt++;\n      }else{\n\tbreak;\n      }\n    }\n  }\n  \n  return cnt == n;\n}\n\nint main(){\n  while(true){\n    n = getInt();\n    t = getInt();\n\n    if(n + t == 0) break;\n\n    int mm = 0;\n\n    REP(i,n){\n      m[i] = getInt();\n      l[i] = getInt();\n      k[i] = getInt();\n\n      mm += m[i];\n    }\n\n    int low  = 1;\n    int high = n;\n\n    while(low + 1 < high){\n      int mid = (low + high) / 2;\n\n      if(cando(mid)){\n\thigh = mid;\n      }else{\n\tlow = mid;\n      }\n    }\n\n    // printf(\"mid = %d\\n\", (low + high) / 2);\n    for(int i = max(1, low - 2); ; i++){\n      if(cando(i)){\n\tprintf(\"%d\\n\", i);\n\tbreak;\n      }\n    }\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N,T;\nint M[1000],L[1000],K[1000];\n\nint flg[1000];\nbool used[1000];\n\nbool check(int x){\n  fill(flg,flg+x,0);\n  fill(used,used+N,false);\n\n  int cc=0;\n  \n  for(int t=0;t<=T;t++){\n    for(int i=0;i<x;i++){\n      if(flg[i]>t)continue;\n      for(int j=0;j<N;j++){\n        if(used[j])continue;\n        int f=t%(L[j]+K[j]);\n        if(L[j]<f)continue;\n        used[j]=true;\n        flg[i]=t+M[j];\n        if(flg[i]>T)return false;\n        cc++;\n        break;\n      }\n    }\n    if(cc==N)break;\n              \n    int mini=1e9;\n    for(int j=0;j<N;j++){\n      if(used[j])continue;\n      int f=t%(L[j]+K[j]);\n      if(L[j]<f){\n        mini=min(mini,K[j]-(f-L[j]));\n      }else mini=0;\n    }\n    int mini2=1e9;\n    for(int j=0;j<x;j++){\n      if(flg[j]>t)mini2=min(mini2,flg[j]-t);\n      else mini2=0;\n    }\n    \n    t+=max(0,max(mini,mini2)-1);\n  }\n  \n  if(cc<N)return false;\n  return true;\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d\",&N,&T);\n    if(N==0&&T==0)break;\n    for(int i=0;i<N;i++)\n      scanf(\"%d %d %d\",&M[i],&L[i],&K[i]);\n    \n    int ans=N;\n    for(int i=1;i<N;i++){\n      if(check(i)){\n        ans=i;\n        break;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, t;\nint m[1010];\nint l[1010];\nint k[1010];\nbool used[1010];\n\nbool calc(int op, int sum) {\n  MEMSET(used, false);\n  priority_queue<int> que;\n  REP(i, op) {\n    que.push(-m[i]);\n    used[i] = true;\n    sum -= m[i];\n  }\n  while (!que.empty()) {\n    int start = -que.top();\n    que.pop();\n    if (start + sum / op > t) { return false; }\n    int mintime = 1000000000;\n    int target = -1;\n    REP(i, n) {\n      if (used[i]) { continue; }\n      int p = start % (l[i] + k[i]);\n      if (p <= l[i]) {\n        mintime = start;\n        target = i;\n        break;\n      } else {\n        p = start + (l[i] + k[i] - p);\n        if (p < mintime) {\n          mintime = p;\n          target = i;\n        }\n      }\n    }\n    if (target != -1 && mintime + m[target] > t) { return false; }\n    if (target != -1) {\n      que.push(-mintime - m[target]);\n      used[target] = true;\n      sum -= m[target];\n    }\n  }\n  return true;\n}\n\nint main() {\n  int test_case = 0;\n  while (scanf(\"%d %d\", &n, &t), n|t) {\n    test_case++;\n    int sum = 0;\n    REP(i, n) {\n      scanf(\"%d %d %d\", &m[i], &l[i], &k[i]);\n      sum += m[i];\n    }\n    if (test_case == 28) {\n      cout << n << \" \" << t << endl;\n      REP(i, n) {\n        cout << m[i] << \" \" << l[i] << \" \" << k[i] << endl;\n      }\n    }\n    REP(iter, n) {\n      if (calc(iter + 1, sum)) {\n        printf(\"%d\\n\", iter + 1);\n        goto next;\n      }\n    }\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, T;\nint M[1000], L[1000], K[1000];\n\nbool check(int x){\n\n  int res=0, used[1000]={}, add[1001]={};\n  \n  for(int i=0;i<=T;i++){\n    \n    x+=add[i];\n    \n    for(int j=0;j<N;j++){\n\n      if(used[j]) continue;\n      \n      int mod=L[j]+K[j];\n      \n      if(x&&(i%mod<=L[j])&&i+M[j]<=T){\n\tx--;\n\tadd[i+M[j]]++;\n\tused[j]=true;\n\tres++;\n      }\n      \n      if(x==0) break;\n    }\n    \n  }\n  \n  return res==N;\n}\n\nvoid solve(){\n  \n  int l=0, r=1005;\n  \n  while(l<r){\n    \n    int m=(l+r)/2;\n    \n    if(!check(m)) l=m+1;\n    else r=m;\n  }\n\n  cout<<l<<endl;\n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>N>>T;\n    if(!N&&!T) break;\n    \n    for(int i=0;i<N;i++) scanf(\"%d %d %d\", &M[i], &L[i], &K[i]);\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\ntypedef long long LL;\nusing namespace std;\n\nstruct node{\n    int i,w;\n    node(int _i=0,int _w=0){\n        i=_i; w=_w;\n    }\n    bool operator<(const node &t)const{\n        return w>t.w;\n    }\n};\nint N,T,M[1100],L[1100],K[1100];\n\nbool gao(int rest){\n    bool in[1100];\n    int ok[1100];\n    memset(ok,-1,sizeof(ok));\n    priority_queue<node> wait,dial;\n    priority_queue<int,vector<int>,greater<int> > Q;\n    int t,i;\n    for (t=0;t<=T;t++){\n        for (i=1;i<=N;i++){\n            if (ok[i]<0 && t%(L[i]+K[i])==0){\n                wait.push(node(i,t+L[i]));\n                if (!in[i]){\n                    Q.push(i); in[i]=1;\n                }\n            }\n        }\n        while (!dial.empty() && dial.top().w==t){\n            ok[dial.top().i]=1; dial.pop(); ++rest;\n        }\n        while (!Q.empty() && !in[Q.top()]) Q.pop();\n        while (!Q.empty() && rest){\n            i=Q.top(); Q.pop(); in[i]=0; ok[i]=0; dial.push(node(i,t+M[i]));  --rest;\n        }\n        while (!wait.empty() && wait.top().w==t){\n            in[wait.top().i]=0; wait.pop();\n        }\n    }\n    for (i=1;i<=N;i++){\n        if (ok[i]<0) return 0;\n    }\n    return 1;\n}\n\nint main(){\n    while (scanf(\"%d%d\",&N,&T),N | T){\n        int i;\n        for (i=1;i<=N;i++){\n            scanf(\"%d%d%d\",&M[i],&L[i],&K[i]);\n        }\n        int l=1,r=N;\n        while (l<r){\n            int mid=l+r>>1;\n            if (gao(mid)) r=mid;\n            else l=mid+1;\n        }\n        printf(\"%d\\n\",r);\n    }       \n}   "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <set>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nbool isCalling[1001];\nbool isTelling[1001];\nbool isFin[1001];\nint N,T;\nint Mi[1001];\nint Li[1001];\nint Ki[1001];\npii datas[1001];\n\nclass Event{\npublic:\n    // 0->qªhang up\n    // 1->qªdbJn\n    // 2->operatorªdbðI¹\n    int cid;\n    int time;\n    Event(int c,int t){\n        cid=c,time=t;\n    }\n    Event();\n    bool operator<(const Event &e)const{\n        return(this->time>e.time);\n    }\n};\n// nlÌIy[^ªvéÆ«ÌV~[V\nbool check(int n){\n    memset(isFin,0,sizeof(isFin));\n    priority_queue<Event> pq;\n    int curTime=0;\n    for(int i=0;i<n;i++){\n        pq.push(Event(i,Mi[i]));\n        isFin[i]=true;\n    }\n    // »Ýq}ÈopÌ\n    int opr=0;\n    int cnt=N;\n    while(pq.size()){\n        // ¡ñÌCxgªI¹µ½opðæèo·\n        Event e=pq.top();pq.pop();\n        curTime=e.time;\n        cnt--;\n        opr++;\n        // óÅ©ÂÜ¾IíÁÄ¢È¢Cxgª¶Ý\n        if(pq.size()==0){\n            if(cnt!=0&&opr!=0){\n                // ÊbÂ\\ÉÈéÜÅª¢ÔÉÀ×é\n                int idx=0;\n                for(int i=0;i<N;i++){\n                    if(isFin[i])continue;\n                    int a=e.time%(Ki[i]+Li[i]);\n                    if(a>=0&&a<=Li[i]){\n                        if(opr>0){\n                            pq.push(Event(i,curTime+Mi[i]));\n                            isFin[i]=true;\n                            opr--;\n                        }\n                    }\n                    else{\n                        int b=Ki[i]-(a-Li[i]);\n                        datas[idx].first=b;\n                        datas[idx].second=-i;\n                        idx++;\n                    }\n                    // ·ÅÉcèÌopðz¦Ä¢é\n                    if(idx>=opr)break;\n                }\n                sort(datas,datas+idx,greater<pii>());\n                int nxt=opr;\n                for(int i=0;i<min(idx,opr);i++){\n                    pq.push(Event(-datas[i].second,curTime+datas[i].first+Mi[-datas[i].second]));\n                    isFin[-datas[i].second]=true;\n                    nxt--;\n                }\n                opr=nxt;\n            }\n        }\n        // ñÌCxgªI¹·éÜÅÌÔÜÅÉAdbÂ\\ÔÉÈéàÌð·×Ä·\n        else{\n            if(opr==0)continue;\n            int neft=pq.top().time;\n            // ÊbÂ\\ÉÈéÜÅª¢ÔÉÀ×é\n            int idx=0;\n            for(int i=0;i<N;i++){\n                if(isFin[i])continue;\n                int a=e.time%(Ki[i]+Li[i]);\n                if(a>=0&&a<=Li[i]){\n                    if(opr>0){\n                        pq.push(Event(i,curTime+Mi[i]));\n                        isFin[i]=true;\n                        opr--;\n                    }\n                }\n                else{\n                    int b=Ki[i]-(a-Li[i]);\n                    // ÊbÂ\\ÉÈéÔªneftæè¬³¢ÈçÎ\n                    if(b+curTime<neft){\n                        datas[idx].first=b;\n                        datas[idx].second=-i;\n                        idx++;\n                    }\n                }\n                // ·ÅÉcèÌopðz¦Ä¢é\n                if(idx>=opr)break;\n            }\n            sort(datas,datas+idx,greater<pii>());\n            int nxt=opr;\n            for(int i=0;i<min(idx,opr);i++){\n                pq.push(Event(-datas[i].second,curTime+datas[i].first+Mi[-datas[i].second]));\n                isFin[-datas[i].second]=true;\n                nxt--;\n            }\n            opr=nxt;\n        }\n    }\n    return curTime<=T;\n}\n\nint main(){\n    while(cin>>N>>T&&(N|T)){\n        for(int i=0;i<N;i++)cin>>Mi[i]>>Li[i]>>Ki[i];\n        for(int i=1;i<=N;i++){\n            if(check(i)){\n                cout<<i<<endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, T;\nint M[1000], L[1000], K[1000];\n\nbool check(int x){\n\n  int res=0, used[1000]={}, add[1001]={};\n  \n  for(int i=0;i<=T;i++){\n    \n    x+=add[i];\n    \n    for(int j=0;j<N;j++){\n      \n      if(used[j]) continue;\n      if(x==0) break;\n      \n      int mod=L[j]+K[j];\n      \n      if((i%mod<=L[j])&&i+M[j]<=T){\n\tx--;\n\tadd[i+M[j]]++;\n\tused[j]=1;\n\tres++;\n      }      \n      \n    }\n    \n  }\n  \n  return res==N;\n}\n\nvoid solve(){\n  \n  int l=0, r=1005;\n  \n  while(l<r){\n    \n    int m=(l+r)/2;\n    \n    if(!check(m)) l=m+1;\n    else r=m;\n  }\n  \n  assert(l!=0&&l!=1005);\n  \n  cout<<l<<endl;\n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>N>>T;\n    if(!N&&!T) break;\n    \n    for(int i=0;i<N;i++) scanf(\"%d %d %d\", &M[i], &L[i], &K[i]);\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 1001\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint n,t,m[M],l[M],k[M],add[M*M];\nbool used[M];\nbool ch(int x){\n  memset(add,0,sizeof(add));\n  memset(used,0,sizeof(used));\n  int cnt=0;\n  r(i,t+1){\n    x+=add[i];\n    r(j,n)if(!used[j]){\n      int p=l[j]+k[j];\n      if(i%p<=l[j]&&x){\n\tadd[i+m[j]]++;\n\tused[j]=1;\n\tx--;\n\tcnt++;\n      }\n    }\n  }\n  return cnt==n;\n}\nint main(){\n  while(cin>>n>>t,t){\n    r(i,n)cin>>m[i]>>l[i]>>k[i];\n    r(i,M){\n      if(ch(i)){\n\tcout<<i<<endl;\n\tbreak;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nstruct Event{\n    int time;\n    int type; // 0 - custermer on, 1 - custermer off, 2 - operation end, \n    int id;\n};\nbool operator < (const Event& e, const Event& f) { // !!! reversed !!!\n    if(e.time != f.time) return e.time > f.time;\n    if(e.type != f.type) return e.type > f.type;\n    return e.id > f.id;\n}\n\nbool check(int OPE, int T, const vector<int>& M, const vector<int>& L, const vector<int>& K) {\n    int N = M.size();\n    priority_queue<Event> que;\n    //priority_queue<int, vector<int>, greater<int>> wait;\n    set<int> wait;\n\n    vector<int> state(N);\n    REP(i, N) {\n        wait.insert(i);\n        if(K[i] != 1) que.push({L[i] + 1, 1, i});\n    }\n\n    int rest = N;\n\n    for(int t = 0; t <= T; t++) {\n        while(!que.empty() && que.top().time == t) {\n            auto e = que.top(); que.pop();\n            //printf(\"{time:%d, type:%d, id:%d}\\n\", e.time, e.type, e.id);\n            if(e.type == 0) {\n                //wait.push(e.id);\n                wait.insert(e.id);\n                que.push({t + L[e.id], 1, e.id});\n                state[e.id] = 0;\n            } else if(e.type == 1 && state[e.id] == 0) {\n                wait.erase(wait.find(e.id));\n                que.push({t + K[e.id] - 1, 0, e.id});\n                state[e.id] = 1;\n            } else if(e.type == 2) {\n                rest--;\n                OPE++;\n            }\n        }\n\n        while(OPE > 0 && !wait.empty()){\n            auto it = wait.begin();\n            int id = *it;\n            wait.erase(it);\n            //int id = wait.top(); wait.pop();\n            if(state[id] != 0) continue;\n            state[id] = 2;\n            que.push({t + M[id], 2, id});\n            OPE--;\n        }\n    }\n\n    //cout << rest << endl;\n    return rest == 0;\n}\n\nint main(){\n    int N, T;\n    while(cin >> N >> T && (N > 0)) {\n        vector<int> M(N), L(N), K(N);\n        REP(i, N) cin >> M[i] >> L[i] >> K[i];\n\n        for(int i = 1; i <= N; i++) {\n            if(check(i, T, M, L, K)) {\n                cout << i << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,t,m[1000],l[1000],k[1000];\n\nbool check(int x){\n  int c[1001]={},used[1000]={},cnt=n;\n  for(int i=0;i<t;i++,x+=c[i])\n    for(int j=0;j<n&&x;j++){\n      if(used[j])continue;\n      if(i+m[j]>t)return 0;\n      if(i%(l[j]+k[j])<=l[j])c[i+m[j]]++,cnt--,used[j]=1,x--;\n    }\n  return !cnt;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&t),n){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    int ans=0;\n    for(int i=1;i<=n&&!ans;i++)if(check(i))ans=i;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int N = 1005;\n\nstruct E{\n    int m, l, k;\n} e[N];\n\nint del[N], cnt[N], T, n;\nbool check(int u){\n    memset(cnt, 0, sizeof(cnt));\n    memset(del, 0, sizeof(del));\n    cnt[0] = u;\n    int t, i;\n    for(t = 0; t <= T; ++t) if(cnt[t]){\n        for(i=1;i<=n;++i) if(!del[i] && t%(e[i].l+e[i].k)<=e[i].l){\n            if(t+e[i].m > T) return 0;\n            cnt[t+e[i].m]++;\n            del[i] = 1;\n            cnt[t]--;\n            if(!cnt[t]) break;\n        }\n        cnt[t+1] += cnt[t];\n    }\n    for(i=1;i<=n;++i) if(!del[i]) return 0;\n    return 1;\n}\n\nint main(){\n    int i;\n    while(scanf(\"%d%d\",&n,&T)&&(n+T)){\n        for(i=1;i<=n;++i)\n            scanf(\"%d%d%d\",&e[i].m, &e[i].l, &e[i].k);\n        //int l = 1, r = n;\n        for(i=1;i<=n;++i) if(check(i)) break;\n        printf(\"%d\\n\", i);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,t,m[1000],l[1000],k[1000];\n\nbool check(int x){\n  int c[1001]={},used[1000]={},cnt=n;\n  for(int i=0;i<t;i++,x+=c[i])\n    for(int j=0;j<n&&x;j++){\n      if(used[j])continue;\n      if(i+m[j]>t)return 0;\n      if(i%(l[j]+k[j])<=l[j])c[i+m[j]]++,cnt--,used[j]=1,x--;\n    }\n  return !cnt;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&t),n){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    int ans=0;\n    for(int i=1;i<=n&&!ans;i++)if(check(i))ans=i;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 1000;\n\nenum {wait=0,hang,talk,end};\n\nbool sim(int n,int *M,int *L,int *K,int T,int op){\n  int now=0,can=op;\n  static int event[N],state[N];\n  rep(i,n)event[i]=0,state[i]=hang;\n  while(now <= T){\n    int next=T+1;\n\n    rep(i,n)if(state[i] != end)next=min(next,event[i]);\n    \n//     cout << now <<\" \" <<next <<  endl;\n//     cout <<\"state \";rep(i,n)cout << state[i]<<\" \";cout << endl;\n//     cout <<\"event \";rep(i,n)cout<<event[i]<<\" \";cout << endl;\n\n    if (next > T)break;\n   \n    rep(i,n){\n      if (state[i] == talk && event[i] == next){\n\tstate[i]=end;\n\tcan++;\n      }\n    }\n    \n    rep(i,n){\n      if (state[i] == hang && event[i] == next){\n\tstate[i]=wait;\n\tevent[i]=next+L[i];\n      }\n    }\n\n    rep(i,n){\n      if (state[i] == wait && can > 0){\n\tstate[i]=talk;\n\tevent[i]=next+M[i];\n\tcan--;\n      }\n    }\n\n    rep(i,n){\n      if (state[i] == wait && event[i] == next){\n\tstate[i]=hang;\n\tevent[i]=next+K[i];\n      }\n    }\n\n    now=next;\n  }\n  rep(i,n)if (state[i] != end)return false;\n  return true;\n}\n\nint solve(int n,int *M,int *L,int *K,int T){\n  int l=0,r=n-1, mid,ok=n;\n  while(l <= r){\n    mid=(l+r)/2;\n    if (sim(n,M,L,K,T,mid))r=mid-1,ok=mid;\n    else l=mid+1;\n  }\n  \n  int ans=ok;\n  for(int i=mid-1;i>0 && i >= mid-100;i--){\n    if (sim(n,M,L,K,T,i))ans=i;\n  }\n  return ans;\n}\n\nmain(){\n  int n,t;\n  int M[N],L[N],K[N];\n  while(cin>>n>>t && n){\n    rep(i,n)cin>>M[i]>>L[i]>>K[i];\n    cout << solve(n,M,L,K,t) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint N, T;\nstruct C{\n    int M, L, K;\n    C(int M, int L, int K):M(M),L(L),K(K){}\n};\nvector<C> customers;\n\nbool can(int n){\n    priority_queue<int> op;\n    vector<C> cust = customers;\n    bool done[1024] = {false};\n    rep(i,n) op.push(0);\n    while(-op.top() <= T){\n\tint tim = -op.top(); op.pop();\n\tint use = -1, dif = INF;\n//\tcerr << tim << endl;\n\tbool exist = false;\n\trep(i,cust.size())if(!done[i]){\n\t    int t = tim % (cust[i].L + cust[i].K);\n\t    int tmp = cust[i].L + cust[i].K - t;\n\t    if( tmp >= cust[i].K ) tmp = 0;\n\t    if(tmp < dif){\n\t\tuse = i;\n\t\tdif = tmp;\n\t    }\n\t    exist = true;\n\t}\n\tif(!exist) return true;\n\tint tmp = -cust[use].M - dif - tim;\n\tif(tmp < -T) return false;\n\top.push(tmp);\n\tdone[use] = true;\n    }\n    return true;\n}\n\nint main()\n{\n    while(cin >> N >> T, N || T){\n\tcustomers.clear();\n\trep(i,N){\n\t    int m, l, k;\n\t    cin >> m >> l >> k;\n\t    customers.pb(C(m,l,k));\n\t}\n\trep(i,N)if(can(i+1)){\n\t    cout << i + 1 << endl;\n\t    break;\n\t}\n/*\n\twhile(lb + 1 < ub){\n\t    mid = (ub + lb) / 2;\n\t    if(can(mid)) ub = mid;\n\t    else lb = mid;\n\t    cerr << endl;\n\t}\n\tcout << ub << endl;\n*/\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cmath>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\n\nusing namespace std;\n\n#define For(i,forN) for(int i=0;i<(forN);i++)\n#define Fori(i,si,forN) for(int i=si;i<(forN);i++)\n\n#define pb push_back\n#define mp make_pair\n#define sf scanf\n#define pf printf\n\ntypedef pair < int ,int > pii;\ntypedef pair < int , pii > piii;\n\nconst int Maxn=1100;\nint M[Maxn],L[Maxn],K[Maxn];\nint n,m;\nbool vis[Maxn];\nbool call[Maxn][Maxn];\n\nbool solve(int num)\n{\n    priority_queue < int > optq;\n    priority_queue < pii > cuq;\n    For(i,num)  optq.push(0);\n    For(i,n)    cuq.push(mp(0,-i));\n    int lastT,res=0,near;\n    while(!cuq.empty())\n    {\n        lastT=-optq.top();\n        optq.pop();\n        int ct,k;\n        while(1)\n        {\n            ct=-cuq.top().first,k=-cuq.top().second;\n            //if(num==3)  cout<<ct<<\" k=\"<<k<<endl;\n            if(ct>=lastT)\n            {\n                near=ct;\n                break;\n            }\n            cuq.pop();\n            if(lastT-ct<=L[k])\n            {\n                cuq.push(mp(-lastT,-k));\n            }\n            else\n            {\n                if(ct==K[k]+L[k])   return false;\n                cuq.push(mp(-(K[k]+L[k]),-k));\n            }\n        }\n        //if(num==3)  cout<<k<<\" \"<<near<<endl;\n        res=max(res,near+M[k]);\n        if(res>m)   return false;\n        optq.push(-(near+M[k]));\n        cuq.pop();\n    }\n    return true;\n}\n\nint main()\n{\n    while(~sf(\"%d%d\",&n,&m) && (n || m))\n    {\n        For(i,n)    sf(\"%d%d%d\",&M[i],&L[i],&K[i]);\n        int l=1,r=m,res=m;\n        for(int mid=1;mid<m;mid++)\n        {\n            if(solve(mid))\n            {\n                res=mid;\n                break;\n            }\n        }\n        pf(\"%d\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct cust {\n\tint  m;\n\tint l;\n\tint k;\n};\n \nstruct query {\n\tint type;\n\tint time;\n\tint id;\n};\nstruct aa {\n\tint id;\n\tint time;\n};\nclass Compare {\npublic:\n\tbool operator()(const query&l,const query&r) {\n\t\treturn l.time==r.time?l.type==r.type?l.id>r.id:l.type>r.type:l.time > r.time;\n\t}\n\tbool operator()(const aa&l, aa&r) {\n\t\treturn l.time > r.time;\n\t}\n};\n\nbool check(const int T, const vector<cust>&cus, const int n) {\n\tint waitnum = n;\n\tpriority_queue<query,vector<query>,Compare>que;\n\t//vector<int>waits(cus.size());\n\tset<int>waits;\n\tfor (int i = 0; i < cus.size(); ++i) {\n\t\tque.push(query{ 0,0,i });\n\t}\n\twhile (!que.empty()) {\n\t\tquery q(que.top());\n\t\tque.pop();\n\t\tif (q.type == 1) {\n\t\t\tauto it = waits.begin();\n\t\t\tif (it == waits.end()) {\n\t\t\t\twaitnum++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst int cid = *it;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\twaits.erase(it);\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}\n\t\t\t\telse if (nexttime == T) {\n\t\t\t\t\twaits.erase(it);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\telse if (q.type == 0) {\n\t\t\tconst int cid = q.id;\n\t\t\tif (waitnum) {\n\t\t\t\twaitnum--;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}\n\t\t\t\telse if (nexttime == T) {\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\twaits.emplace(cid);\n\t\t\t\tconst int nexttime = q.time + cus[cid].l;\n\t\t\t\tque.push(query{ 2,nexttime,cid });\n\t\t\t}\n\t\t}\n\t\telse if (q.type == 2) {\n\t\t\tconst int cid = q.id;\n\t\t\tauto it = waits.find(cid);\n\t\t\tif (it!=waits.end()) {\n\t\t\t\twaits.erase(it);\n\t\t\t\tconst int nexttime = q.time + cus[cid].k;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\tque.push(query{ 0,nexttime,cid });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, T; cin >> N >> T;\n\t\tif (!N)break;\n\t\tvector<cust>cus;\n\t\tint totalm = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint m, l, k; cin >> m >> l >> k;\n\t\t\ttotalm += m;\n\t\t\tcus.push_back(cust{ m,l,k });\n\t\t}\n\t\tint amin = (totalm-1) / T + 1;\n\t\tfor (int n = amin; n <= N; ++n) {\n\t\t\tif (check(T, cus, n)) {\n\t\t\t\tcout << n << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nint n, t;\nvector<int> m, l, k;\n\nbool solve(int ope)\n{\n    set<int> call;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    for(int i=0; i<n; ++i)\n        q.push(make_pair(0, i));\n    int cusRest = n;\n    int opeRest = ope;\n    vector<bool> ok(n, false);\n\n    for(;;){\n        if(cusRest == 0)\n            return true;\n\n        int curr = q.top().first;\n        int s = q.top().second;\n        q.pop();\n\n        if(curr > t)\n            return false;\n\n        if(s == INT_MAX){\n            -- cusRest;\n            if(call.empty()){\n                ++ opeRest;\n            }else{\n                s = *call.begin();\n                call.erase(call.begin());\n                ok[s] = true;\n                q.push(make_pair(curr + m[s], INT_MAX));\n            }\n        }else if(!ok[s]){\n            if(call.find(s) == call.end()){\n                if(opeRest > 0){\n                    -- opeRest;\n                    ok[s] = true;\n                    q.push(make_pair(curr + m[s], INT_MAX));\n                }else{\n                    call.insert(s);\n                    q.push(make_pair(curr + l[s] + 1, s));\n                }\n            }else{\n                call.erase(call.find(s));\n                q.push(make_pair(curr + k[s] - 1, s));\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        cin >> n >> t;\n        if(n == 0)\n            return 0;\n\n        m.resize(n);\n        l.resize(n);\n        k.resize(n);\n        for(int i=0; i<n; ++i)\n            cin >> m[i] >> l[i] >> k[i];\n\n        int ret = 1;\n        while(!solve(ret))\n            ++ ret;\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,t,m[1000],l[1000],k[1000];\n\nbool check(int x){\n  int c[1001]={},used[1000]={},cnt=n;\n  for(int i=0;i<t;i++){\n    x+=c[i];\n    for(int j=0;j<n&&x;j++){\n      if(used[j])continue;\n      if(i+m[j]>t)return 0;\n      if(i%(l[j]+k[j])<=l[j])c[i+m[j]]++,cnt--,used[j]=1,x--;\n    }\n  }\n  return !cnt;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&t),n){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    int ans=0;\n    for(int i=1;i<=n&&!ans;i++)if(check(i))ans=i;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int n,t;\n  while(cin>>n>>t,n){\n    vector<int> m(n),l(n),k(n);\n    for(int i=0;i<n;i++) cin>>m[i]>>l[i]>>k[i];\n    auto check=[&](int x){\n      vector<int> a(n,0);\n      vector<int> o(x,0);\n      int cnt=0;\n      for(int i=0;i<=t;i++){\n\tint p=0;\n\tfor(int j=0;j<n;j++){\n\t  if(a[j]<0||a[j]>i) continue;\n\t  while(p<x&&o[p]>i) p++;\n\t  if(p==x) break;\n\t  //if(i+m[j]>t) return 0;\n\t  if(i+m[j]>t) continue;\n\t  o[p]=i+m[j];\n\t  a[j]=-1;\n\t  cnt++;\n\t  //cout<<i<<\" \"<<j<<\":\"<<i+m[j]<<endl;\n\t}\n\tfor(int j=0;j<n;j++)\n\t  if(a[j]>=0&&i>=a[j]+l[j]) a[j]=i+k[j];\n      }\n      //cout<<x<<\":\"<<cnt<<\":\"<<n<<endl;\n      return 1*(cnt==n);\n    };\n    for(int i=1;i<=n;i++){\n      //cout<<i<<\":\"<<check(i)<<endl;\n      if(check(i)){\n\tcout<<i<<endl;\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint n,T;\nvector<int> M,L,K;\nbool check(int x){\n  int cnt = 0;\n  vector<int> call(n,0);\n  vector<int> compute = M;\n  vector<int> used(n,0);\n\n  for(int t=0;t<=T;t++){\n\n    for(int i=0;i<n;i++) if(used[i] && compute[i] && --compute[i] == 0) cnt--;\n    for(int i=0;i<n;i++) if(t-call[i] == L[i] + K[i]) call[i] = t; \n    \n    for(int i=0;i<n && cnt < x ;i++){\n      if(used[i]) continue;\n      if(t - call[i] <= L[i]) used[i] = 1,cnt++;\n    }\n  }\n    \n  for(int i=0;i<n;i++) if(compute[i] > 0) return 0;\n  return 1;\n}\n\n  \nsigned main(){\n  while(1){\n    int sum = 0;\n    cin>>n>>T;\n    if( n == 0 && T == 0) break;\n    M.clear(),L.clear(),K.clear();\n    M.resize(n),L.resize(n),K.resize(n);\n    for(int i=0;i<n;i++) cin>> M[i]>>L[i]>>K[i],sum += M[i];\n    \n    //for(int i=0;i<=n;i++) cout<<i<<\" \"<<check(i)<<endl;\n\n    int ans = sum / T;\n    for(;check(ans) == 0;ans++);\n    cout<<ans<<endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nstruct node{\n\tint len,t1,t2;\n}va[1100];\nbool mark[1100];\nint n,t,rem[1100];\nint inwait(int t,int index){\n\tint time = t%(va[index].t1+va[index].t2);\n\t//if(time==0) time=va[index].t1+va[index].t2;\n\tif(time<=va[index].t1) return 1;\n\treturn 0;\n}\nint check(int num){\n\tint re=num,now=0;\n\tfor(int j=0;j<n;j++){\n\t\tif(!mark[j]&&re&&inwait(1,j)){\n\t\t\tmark[j]=1; re--; rem[j]=va[j].len;\n\t\t\t//printf(\"%d %d\\n\",1,j);\n\t\t}\n\t}\n\tfor(int i=1;i<=t;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(mark[j]&&rem[j]){\n\t\t\t\trem[j]--;\n\t\t\t\tif(rem[j]==0){\n\t\t\t\t\tnow++;\n\t\t\t\t\tre++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(re){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(!mark[j]&&re&&inwait(i,j)){\n\t\t\t\t\tmark[j]=1; re--; rem[j]=va[j].len;\n\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(now==n) return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(scanf(\"%d%d\",&n,&t)!=EOF){\n\t\tif(n==0&&t==0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d\",&va[i].len,&va[i].t1,&va[i].t2);\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tmemset(mark,0,sizeof(mark));\n\t\t\tif(check(i)){\n\t\t\t\tprintf(\"%d\\n\",i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nll N, T;\nll M[1005], L[1005], K[1005];\n\nbool f(ll border) {\n    ll op = border;\n    ll clear = 0;\n    vector<ll> mpop(2020);\n    vector<bool> cleared(N);\n    for(int t = 0; t <= T; t++) {\n        clear += mpop[t];\n        op += mpop[t];\n        int idx = -1;\n        while(op and idx < N) {\n            idx++;\n            if(idx == N) break;\n            if(cleared[idx]) continue;\n            //cerr << t << \" \" << op << \" \" << idx << endl;\n            ll timer = t % (L[idx] + K[idx]);\n            if(timer > L[idx]) continue;\n            mpop[t+M[idx]]++;\n            op--;\n            cleared[idx] = true;\n        }\n    }\n    return clear == N;\n}\n\nvoid solve() {\n    for(int i = 0; i < N; i++) {\n        cin >> M[i] >> L[i] >> K[i];\n    }\n    for(int i = 1; i <= N; i++) {\n        if(f(i)) {\n            cout << i << endl;\n            return;\n        }\n    }\n}\n\nint main() {\n    while(cin >> N >> T) {\n        if(N == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,t;\nint m[1001],l[1001],k[1001];\nbool used[1001];\nint pl[2001];\nint cnt[1001];\nint nxt[1001];\n\nbool C(int v){\n\tmemset(used,0,sizeof(used));\n\tmemset(pl,0,sizeof(pl));\n\tmemset(cnt,0,sizeof(cnt));\n\tmemset(nxt,0,sizeof(nxt));\n\tint call=0;\n\tfor(int i=0;i<t;i++){\n\t\tcall-=pl[i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(call==v)break;\n\t\t\tif(!used[j] && nxt[j]<=i){\n\t\t\t\tused[j]=true;\n\t\t\t\tpl[i+m[j]]++;\n\t\t\t\tif(i+m[j]>t)return false;\n\t\t\t\tcall++;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(!used[j]){\n\t\t\t\tif(nxt[j]<=i){\n\t\t\t\t\tcnt[j]++;\n\t\t\t\t}\n\t\t\t\tif(cnt[j]==(l[j]+1)){\n\t\t\t\t\tcnt[j]=0;\n\t\t\t\t\tnxt[j]=i+k[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(!used[i])return false;\n\t}\n\treturn true;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&t);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(C(i)){\n\t\t\t\tprintf(\"%d\\n\",i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,t,m[1000],l[1000],k[1000];\n\nbool check(int x){\n  int c[1001]={},used[1000]={},cnt=n;\n  for(int i=0;i<t;i++,x+=c[i])\n    for(int j=0;j<n&&x;j++){\n      if(used[j])continue;\n      if(i+m[j]>t)return 0;\n      if(i%(l[j]+k[j])<l[j])c[i+m[j]]++,cnt--,used[j]=1,x--;\n    }\n  return !cnt;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&t),n){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    int ans=0;\n    for(int i=1;i<=n&&!ans;i++)if(check(i))ans=i;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 1003\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint n,t,m[M],l[M],k[M],add[M];\nbool used[M];\nbool ch(int x){\n  memset(add,0,sizeof(add));\n  memset(used,0,sizeof(used));\n  int cnt=0;\n  r(i,t+1){\n    x+=add[i];\n    r(j,n)if(!used[j]&&x){\n      int p=l[j]+k[j];\n      if((i%p<=l[j])&&m[j]+i<M){\n        add[i+m[j]]++;\n\tused[j]=1;\n\tx--;\n\tcnt++;\n      }\n    }\n  }\n  return cnt==n;\n}\nint main(){\n  while(cin>>n>>t,t){\n    r(i,n)cin>>m[i]>>l[i]>>k[i];\n    r(i,M){\n      if(ch(i)){\n\tcout<<i<<endl;\n\tbreak;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nint main(){\n  for(int N,T;cin>>N>>T,N|T;){\n    int M[1234],L[1234],K[1234];\n    for(int i=0;i<N;i++){\n      cin>>M[i]>>L[i]>>K[i];\n    }\n    for(int no=1;;no++){\n      int et[1234]={};\n      int nw=no;\n      bool done[1234]={};\n      int nd=0;\n      bool res;\n      for(int i=0;;i++){\n\tnw+=et[i];\n\tfor(int j=0;j<N;j++){\n\t  if(nw&&!done[j]&&i%(L[j]+K[j])<=L[j]){\n\t    if(i+M[j]>T){\n\t      res=false;\n\t      goto end;\n\t    }else{\n\t      done[j]=true;\n\t      et[i+M[j]]++;\n\t      nw--;\n\t      nd++;\n\t      if(nd==N){\n\t\tres=true;\n\t\tgoto end;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    end:\n      if(res){\n\tcout<<no<<endl;\n\tbreak;\n      }\n    }\n  }\n}\n\n\t      \n\t  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 1005\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint n,t,m[M],l[M],k[M],add[M];\nbool used[M];\nbool ch(int x){\n  memset(add,0,sizeof(add));\n  memset(used,0,sizeof(used));\n  int cnt=0;\n  r(i,t+1){\n    x+=add[i];\n    r(j,n)if(!used[j]&&x){\n      int p=l[j]+k[j];\n      if(i%p<=l[j]&&m[j]+i<M){\n        add[i+m[j]]++;\n\tused[j]=1;\n\tx--;\n\tcnt++;\n      }\n    }\n  }\n  return cnt==n;\n}\nint main(){\n  while(cin>>n>>t,t){\n    r(i,n)cin>>m[i]>>l[i]>>k[i];\n    r(i,M){\n      if(ch(i)){\n\tcout<<i<<endl;\n\tbreak;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint c[1100];\nint d[1100];\nint e[1100];\nint fin[1100];\nint next[1100];\nint a,b;\nint can(int M){\n\tfor(int i=0;i<M;i++)fin[i]=0;\n\tfor(int i=0;i<a;i++)next[i]=0;\n\tint last=0;\n\tint rem=a;\n\tfor(int i=0;i<b;i++){\n\t\tfor(int j=0;j<M;j++){\n\t\t\tif(fin[j]<=i){\n\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\tif(~next[k]&&next[k]<=i){\n\t\t\t\t\t\tnext[k]=-1;\n\t\t\t\t\t\tfin[j]=i+c[k];\n\t\t\t\t\t\tlast=max(last,fin[j]);\n\t\t\t\t\t\trem--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(~next[j]&&i==next[j]+d[j]){\n\t\t\t\tnext[j]=next[j]+d[j]+e[j];\n\t\t\t}\n\t\t}\n\t\tif(!rem)break;\n\t}\n\tfor(int i=0;i<a;i++)if(~next[i])last=9999999;\n\tif(last<=b)return 1;\n\treturn 0;\n}\nint main(){\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%d%d%d\",c+i,d+i,e+i);\n\t\tint left=0;\n\t\tint right=1001;\n\t\twhile(left+1<right){\n\t\t\tint M=(left+right)/2;\n\t\t\tif(can(M)){\n\t\t\t\tright=M;\n\t\t\t}else left=M;\n\t\t}\n\t\tint tr=right;\n\t\tfor(int i=1;i<=10&&tr-i>0;i++){\n\t\t\tif(can(tr-i))right=tr-i;\n\t\t}\n\t\tprintf(\"%d\\n\",right);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <climits>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nint m[1000];\nint l[1000];\nint k[1000];\n\nint main(){\n  while(true){\n    int n = getInt();\n    int t = getInt();\n\n    if(n + t == 0) break;\n\n    REP(i,n){\n      m[i] = getInt();\n      l[i] = getInt();\n      k[i] = getInt();\n    }\n\n    for(int p = 1; ; p++){\n      vector<bool> ok(n, false);\n      int cnt = 0;\n      priority_queue<int, vector<int>, greater<int> > op;\n\n      REP(i,p) op.push(0);\n\n      while(op.size() && cnt != n){\n\tint tm = op.top(); op.pop();\n\n\t// printf(\"operator: %d\\n\", tm);\n\tif(tm >= t) break;\n\n\tpair<int, int> process = make_pair(INT_MAX, INT_MAX);\n\n\tREP(i,n) if(!ok[i]){\n\t  int next;\n\t  if(tm % (l[i] + k[i]) <= l[i]) next = tm;\n\t  else next = (l[i] + k[i]) * ((tm + k[i]) / (l[i] + k[i]));\n\n\t  process = min(process, make_pair(next, i));\n\t}\n\n\tif(process.first != INT_MAX){\n\t  if(process.first + m[process.second] <= t){\n\t    // printf(\"%d => process %d\\n\", process.first, process.second);\n\t    op.push(process.first + m[process.second]);\n\t    ok[process.second] = true;\n\t    cnt++;\n\t  }else{\n\t    // printf(\"%d => cannot %d\\n\", process.first, m[process.second]);\n\t  }\n\t}\n      }\n\n      // puts(\"\");\n      if(cnt == n){\n\tprintf(\"%d\\n\", p);\n\tbreak;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint n, t;\nvector<int> m, l, k;\n\nbool solve(int ope)\n{\n    vector<int> opeEnd(t+1, 0);\n    opeEnd[0] = ope;\n    vector<bool> check(n, false);\n    int opeRest = 0;\n    int cusRest = n;\n\n    for(int i=0; i<=t; ++i){\n        opeRest += opeEnd[i];\n        for(int j=0; j<n; ++j){\n            if(opeRest == 0)\n                break;\n            if(!check[j] && i % (l[j] + k[j]) <= l[j]){\n                if(i + m[j] > t)\n                    return false;\n                ++ opeEnd[i+m[j]];\n                check[j] = true;\n                -- opeRest;\n                if(-- cusRest == 0)\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nint main()\n{\n    for(;;){\n        cin >> n >> t;\n        if(n == 0)\n            return 0;\n\n        m.resize(n);\n        l.resize(n);\n        k.resize(n);\n        for(int i=0; i<n; ++i)\n            cin >> m[i] >> l[i] >> k[i];\n\n        int ret = 1;\n        while(!solve(ret))\n            ++ ret;\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define M 1001\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint n,t,m[M],l[M],k[M],add[M];\nbool used[M];\nbool ch(int x){\n  memset(add,0,sizeof(add));\n  memset(used,0,sizeof(used));\n  int cnt=0;\n  r(i,t+1){\n    x+=add[i];\n    r(j,n)if(!used[j]&&x){\n      int p=l[j]+k[j];\n      if(i%p<=l[j]&&m[j]+i<M){\n        add[i+m[j]]++;\n\tused[j]=1;\n\tx--;\n\tcnt++;\n      }\n    }\n  }\n  return cnt==n;\n}\nint main(){\n  while(cin>>n>>t,t){\n    r(i,n)cin>>m[i]>>l[i]>>k[i];\n    r(i,M){\n      if(ch(i)){\n\tcout<<i<<endl;\n\tbreak;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\nusing namespace std;\n\nclass State\n{\npublic:\n\tint id, t;\n\tState(int id, int t)\n\t\t:id(id),t(t)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\tif(t!=s.t) return t>s.t;\n\t\treturn id>s.id;\n\t}\n};\n\nint N, T;\nint M[1000], L[1000], K[1000];\n\nbool simulate(int opnum)\n{\n\tpriority_queue<int, vector<int>, greater<int> > ops;\n\tfor(int i=0; i<opnum; i++) ops.push(0);\n\n\tpriority_queue<State> q;\n\tfor(int i=0; i<N; i++) q.push(State(i,0));\n\n\twhile(!q.empty()) {\n\t\tState s = q.top(); q.pop();\n\t\tint id = s.id;\n\t\tint op = ops.top(); ops.pop();\n\n\t\tif(op > s.t + L[id]) {\n\t\t\tint nt = s.t + L[id] + K[id];\n\t\t\tif(nt > T) return false;\n\n\t\t\tq.push(State(id, nt));\n\t\t\tops.push(op);\n\t\t}\n\t\telse {\n\t\t\tint nt = M[id];\n\t\t\tif(op < s.t) nt += s.t;\n\t\t\telse nt += min(op, s.t + L[id]);\n\n\t\t\tif(nt > T) return false;\n\n\t\t\tops.push(nt);\n\t\t}\n\t}\n\t\t\n\n\treturn true;\n}\n\nint solve()\n{\n\tint res = 1;\n\tfor(;; res++) {\n\t\tif(simulate(res)) break;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin >> N >> T, (N||T)) {\n\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tcin >> M[i] >> L[i] >> K[i];\n\t\t}\n\n\t\tcout << solve() << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,t,m[1000],l[1000],k[1000];\n\nbool check(int x){\n  int c[1001]={},used[1000]={},cnt=n;\n  for(int i=0;i<t;i++,x+=c[i])\n    for(int j=0;j<n&&x;j++){\n      if(i+m[j]>t)return 0;\n      if(used[j]||i%(l[j]+k[j])>l[j])continue;\t    \n      c[i+m[j]]++,cnt--,used[j]=1,x--;\n    }\n  return !cnt;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&t),n){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    int ans=0;\n    for(int i=1;i<=n&&!ans;i++)if(check(i))ans=i;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,t,m[1000],l[1000],k[1000];\n\nbool check(int x){\n  int c[1001]={},used[1000]={},cnt=n;\n  for(int i=0;i<t;i++,x+=c[i])\n    for(int j=0;j<n&&x;j++){\n      if(used[j]||i%(l[j]+k[j])>l[j])continue;\n      if(i+m[j]>t)return 0;\n      c[i+m[j]]++,cnt--,used[j]=1,x--;\n    }\n  return !cnt;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&t),n){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    int ans=0;\n    for(int i=1;i<=n&&!ans;i++)if(check(i))ans=i;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct cust {\n\tint  m;\n\tint l;\n\tint k;\n};\n \nstruct query {\n\tint type;\n\tint time;\n\tint id;\n};\nstruct aa {\n\tint id;\n\tint time;\n};\nclass Compare {\npublic:\n\tbool operator()(const query&l,const query&r) {\n\t\treturn l.time==r.time?l.type==r.type?l.id>r.id:l.type>r.type:l.time > r.time;\n\t}\n\tbool operator()(const aa&l, aa&r) {\n\t\treturn l.time > r.time;\n\t}\n};\n\nbool check(const int T, const vector<cust>&cus, const int n) {\n\tint waitnum = n;\n\tpriority_queue<query,vector<query>,Compare>que;\n\tset<int>waits;\n\tfor (int i = 0; i < cus.size(); ++i) {\n\t\tque.push(query{ 0,0,i });\n\t}\n\twhile (!que.empty()) {\n\t\tquery q(que.top());\n\t\tque.pop();\n\t\tif (q.type == 1) {\n\t\t\tauto it = waits.begin();\n\t\t\tif (it == waits.end()) {\n\t\t\t\twaitnum++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst int cid = *it;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime <= T) {\n\t\t\t\t\twaits.erase(it);\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (q.type == 0) {\n\t\t\tconst int cid = q.id;\n\t\t\tif (waitnum) {\n\t\t\t\twaitnum--;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime <= T) {\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\twaits.emplace(cid);\n\t\t\t\tconst int nexttime = q.time + cus[cid].l;\n\t\t\t\tque.push(query{ 2,nexttime,cid });\n\t\t\t}\n\t\t}\n\t\telse if (q.type == 2) {\n\t\t\tconst int cid = q.id;\n\t\t\tauto it = waits.find(cid);\n\t\t\tif (it!=waits.end()) {\n\t\t\t\twaits.erase(it);\n\t\t\t\tconst int nexttime = q.time + cus[cid].k;\n\t\t\t\tif (nexttime <= T-cus[cid].m) {\n\t\t\t\t\tque.push(query{ 0,nexttime,cid });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, T; cin >> N >> T;\n\t\tif (!N)break;\n\t\tvector<cust>cus;\n\t\tint totalm = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint m, l, k; cin >> m >> l >> k;\n\t\t\ttotalm += m;\n\t\t\tcus.push_back(cust{ m,l,k });\n\t\t}\n\t\tint amin = (totalm-1) / T + 1;\n\t\tfor (int n = amin; n <= N; ++n) {\n\t\t\tif (check(T, cus, n)) {\n\t\t\t\tcout << n << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1111;\nbool visit[N];\nint n, T;\nstruct Costomer {\n\tint m, l, k;\n\tvoid read() {\n\t\tscanf(\"%d%d%d\", &m, &l, &k);\n\t}\n} c[N];\n\nbool check(int mid) {\n\tint supported = 0;\n\tint cnt = mid;\n\tpriority_queue<int, vector<int>, greater<int> > pq;\n\tmemset(visit, false, sizeof(visit));\n\tfor (int i = 0; i < cnt; i++) {\n\t\tpq.push(0);\n\t}\n\tcnt = 0;\n\tfor (int i = 0; i <= T; i++) {\n\t\twhile (!pq.empty() && pq.top() == i) {\n\t\t\tpq.pop();\n\t\t\tcnt++;\n\t\t}\n\t\tfor (int j = 0; j < n && cnt; j++) {\n\t\t\tif (visit[j]) continue;\n\t\t\tif (i % (c[j].l + c[j].k) <= c[j].l) {\n\t\t\t\tcnt--;\n\t\t\t\tif (i + c[j].m > T) return false;\n\t\t\t\tpq.push(i + c[j].m);\n\t\t\t\tvisit[j] = true;\n\t\t\t\tsupported++;\n\t\t\t}\n\t\t}\n\t}\n\treturn supported == n;\n}\n\nint main() {\n\twhile (~scanf(\"%d%d\", &n, &T), n + T) {\n\t\tfor (int i = 0; i < n; i++) c[i].read();\n\t\tint l = 1, r = n;\n\t\tint ans = -1;\n\t\twhile (l <= r) {\n\t\t\tint mid = l + r >> 1;\n\t\t\tif (check(mid)) ans = mid, r = mid - 1;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint n,T;\nvector<int> M,L,K;\nbool check(int x){\n  int cnt = 0;\n  vector<int> call(n,0);\n  vector<int> compute = M;\n  vector<int> used(n,0);\n \n  for(int t=0;t<=T;t++){\n \n    for(int i=0;i<n;i++) if(used[i] && compute[i] && --compute[i] == 0) cnt--;\n    for(int i=0;i<n;i++) if(t-call[i] == L[i] + K[i]) call[i] = t; \n     \n    for(int i=0;i<n && cnt < x ;i++){\n      if(used[i]) continue;\n      if(t - call[i] <= L[i]) used[i] = 1,cnt++;\n    }\n  }\n     \n  for(int i=0;i<n;i++) if(compute[i] > 0) return 0;\n  return 1;\n}\n \n   \nsigned main(){\n  while(1){\n    int sum = 0;\n    cin>>n>>T;\n    if( n == 0 && T == 0) break;\n    M.clear(),L.clear(),K.clear();\n    M.resize(n),L.resize(n),K.resize(n);\n    for(int i=0;i<n;i++) cin>> M[i]>>L[i]>>K[i],sum += M[i];\n     \n    //for(int i=0;i<=n;i++) cout<<i<<\" \"<<check(i)<<endl;\n \n    int ans = sum / T;\n    for(;check(ans) == 0;ans++);\n    cout<<ans<<endl;\n  }\n     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct cust {\n\tint  m;\n\tint l;\n\tint k;\n};\n \nstruct query {\n\tint type;\n\tint time;\n\tint id;\n};\nstruct aa {\n\tint id;\n\tint time;\n};\nclass Compare {\npublic:\n\tbool operator()(const query&l,const query&r) {\n\t\treturn l.time==r.time?l.type==r.type?l.id>r.id:l.type>r.type:l.time > r.time;\n\t}\n\tbool operator()(const aa&l, aa&r) {\n\t\treturn l.time > r.time;\n\t}\n};\n\nbool check(const int T, const vector<cust>&cus, const int n) {\n\tint waitnum = n;\n\tpriority_queue<query,vector<query>,Compare>que;\n\tset<int>waits;\n\tfor (int i = 0; i < cus.size(); ++i) {\n\t\tque.push(query{ 0,0,i });\n\t}\n\twhile (!que.empty()) {\n\t\tquery q(que.top());\n\t\tque.pop();\n\t\t if (q.type == 0) {\n\t\t\tconst int cid = q.id;\n\t\t\tif (waitnum) {\n\t\t\t\twaitnum--;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime <= T) {\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\twaits.emplace(cid);\n\t\t\t\tconst int nexttime = q.time + cus[cid].l;\n\t\t\t\tque.push(query{ 2,nexttime,cid });\n\t\t\t}\n\t\t}else if (q.type == 1) {\n\t\t\tauto it = waits.begin();\n\t\t\tif (it == waits.end()) {\n\t\t\t\twaitnum++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst int cid = *it;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime <= T) {\n\t\t\t\t\twaits.erase(it);\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if (q.type == 2) {\n\t\t\tconst int cid = q.id;\n\t\t\tauto it = waits.find(cid);\n\t\t\tif (it!=waits.end()) {\n\t\t\t\twaits.erase(it);\n\t\t\t\tconst int nexttime = q.time + cus[cid].k;\n\t\t\t\tif (nexttime <= T-cus[cid].m) {\n\t\t\t\t\tque.push(query{ 0,nexttime,cid });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, T; cin >> N >> T;\n\t\tif (!N)break;\n\t\tvector<cust>cus;\n\t\tint totalm = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint m, l, k; cin >> m >> l >> k;\n\t\t\ttotalm += m;\n\t\t\tcus.push_back(cust{ m,l,k });\n\t\t}\n\t\tint amin = (totalm-1) / T + 1;\n\t\tfor (int n = amin; n <= N; ++n) {\n\t\t\tif (check(T, cus, n)) {\n\t\t\t\tcout << n << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nint const M = 10000+888;\nstruct node {\n int id;\n int m,l,k;\n int ov;\n}q[M],stack_[M];\nint op[M],T,n;\nbool iscall(node t,int p){\n int l = (p)%(t.l+t.k);\n if(l==0&&p) return 0;\n if(l<=t.l) return 1;\n return 0;\n}\nbool check(int num) {\n memset(op,0,sizeof(op));\n op[1]=num;\n for(int i=0;i<n;i++) stack_[i].ov=0;\n int len = n;\n int o = len;\n for(int i=1;i<=T;i++){\n        for(int j=0;op[i]&&j<len;op[i]--,j++){\n            if(stack_[j].ov==0&&iscall(stack_[j],i)&&i+stack_[j].m-1<=T){\n                stack_[j].ov=1;\n                op[i+stack_[j].m-1]++;\n                o--;\n              //  if(!o) return 1;\n            }\n        }\n        op[i+1]+=op[i];\n    }\n return o<=0? 1: 0;\n}\nint bin(int l,int r) {\n while(l<r){\n    int mid = (l+r) >>1;\n     bool m =check(mid);\n    if(m==1) r=mid;\n    else l=mid+1;\n }\n return l;\n}\nint main(){\n\n  while(cin>>n>>T,n+T){\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d%d\",&q[i].m,&q[i].l,&q[i].k);\n        q[i].id = i;\n        q[i].ov = 0;\n        stack_[i]=q[i];\n    }\n    for(int i=1;i<=n;i++){\n         if(check(i)){\n            printf(\"%d\\n\",i);\n            break ;\n        }\n    }\n  }\n}\n/*\n\n3 30\n10 5 15\n10 5 15\n10 5 15\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 1001\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint n,t,m[M],l[M],k[M],add[M];\nbool used[M];\nbool ch(int x){\n  memset(add,0,sizeof(add));\n  memset(used,0,sizeof(used));\n  int cnt=0;\n  r(i,t+1){\n    x+=add[i];\n    r(j,n)if(!used[j]){\n      int p=l[j]+k[j];\n      if(i%p<=l[j]&&x){\n\tif(m[j]+i<M)add[i+m[j]]++;\n\tused[j]=1;\n\tx--;\n\tcnt++;\n      }\n    }\n  }\n  return cnt==n;\n}\nint main(){\n  while(cin>>n>>t,t){\n    r(i,n)cin>>m[i]>>l[i]>>k[i];\n    r(i,M){\n      if(ch(i)){\n\tcout<<i<<endl;\n\tbreak;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1000\n\nstruct Info{\n\tint M,L,K;\n};\n\nstruct Data{\n\tData(int arg_next_free_time){\n\t\tnext_free_time = arg_next_free_time;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn next_free_time > arg.next_free_time;\n\t}\n\tint next_free_time;\n};\n\nint N,T;\nInfo info[NUM];\nbool check[NUM];\n\nbool is_ok(int num){\n\n\tpriority_queue<Data> Q;\n\tfor(int i = 0; i < num; i++)Q.push(0);\n\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\tint count = 0,current_time,id,tmp,min_time,next_time;\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tcurrent_time = Q.top().next_free_time;\n\t\tQ.pop();\n\n\t\tmin_time = BIG_NUM;\n\t\tFLG = false;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(check[i])continue;\n\n\t\t\ttmp = current_time%(info[i].K+info[i].L);\n\t\t\tif(tmp >= 0 && tmp <= info[i].L){\n\t\t\t\tid = i;\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\n\t\t\t}else{\n\t\t\t\tif(min_time > current_time+(info[i].K+info[i].L)-current_time%(info[i].K+info[i].L)){\n\t\t\t\t\tmin_time = current_time+(info[i].K+info[i].L)-current_time%(info[i].K+info[i].L);\n\t\t\t\t\tid = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(FLG){\n\n\t\t\tnext_time = current_time+info[id].M;\n\n\t\t}else{\n\n\t\t\tnext_time = min_time+info[id].M;\n\t\t}\n\t\tif(next_time > T)return false;\n\n\t\tcount++;\n\t\tif(count == N)return true;\n\t\tcheck[id] = true;\n\t\tQ.push(next_time);\n\t}\n\treturn false;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&info[i].M,&info[i].L,&info[i].K);\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tif(is_ok(i)){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&T);\n\t\tif(N == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define M 1001\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint n,t,m[M],l[M],k[M],add[M];\nbool used[M];\nbool ch(int x){\n  memset(add,0,sizeof(add));\n  memset(used,0,sizeof(used));\n  int cnt=0;\n  r(i,t+1){\n    x+=add[i];\n    r(j,n)if(!used[j]){\n      int p=l[j]+k[j];\n      if(i%p<=l[j]&&x){\n\tif(m[j]+i<M)add[i+m[j]]++;\n\tused[j]=1;\n\tx--;\n\tcnt++;\n      }\n    }\n  }\n  return cnt==n;\n}\nint main(){\n  while(cin>>n>>t,t){\n    r(i,n)cin>>m[i]>>l[i]>>k[i];\n    r(i,M){\n      if(ch(i)){\n\tcout<<i<<endl;\n\tbreak;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n#define N 1010\nvector <int> ope;\nvector <int> ask;\nint vis[N],cur[N];\nint m[N],l[N],k[N];\nint n,t;\nbool work(int val){\n    //printf(\"%d\\n\",val);\n    memset(vis,0,sizeof(vis));\n    memset(cur,0,sizeof(cur));\n    for (int i=1;i<=t;i++){\n        ope.clear();\n        ask.clear();\n        for (int j=1;j<=val;j++)\n            if (vis[j]<i) ope.push_back(j);\n        for (int j=1;j<=n;j++){\n            if (cur[j]) continue;\n            int tp=i%(l[j]+k[j]);\n            if (tp>0&&tp<=l[j]) ask.push_back(j);\n        }\n        //printf(\"%d %d %d\\n\",i,ope.size(),ask.size());\n        int num=min(ope.size(),ask.size());\n        for (int j=0;j<num;j++){\n            vis[ope[j]]=i+m[ask[j]]-1;\n            cur[ask[j]]=1;\n        }\n    }\n    for (int i=1;i<=val;i++)\n        if (vis[i]>t) return 0;\n    for (int i=1;i<=n;i++)\n        if (cur[i]==0) return 0;\n    return 1;\n}\nint main(){\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    while (scanf(\"%d%d\",&n,&t)==2){\n        if (n==0&&t==0) continue;\n        for (int i=1;i<=n;i++)\n            scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n        int l=1,r=n,mid,ans;\n        while (l<=r){\n            int mid=(l+r)/2;\n            if (work(mid)) {ans=mid;r=mid-1;}\n            else l=mid+1;\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint n,T,talk[1000],call[1000],wait[1000];\n\nbool solve(int p){\n\tpriority_queue<int> pq;\n\trep(i,p) pq.push(0);\n\n\tint n_cus=0;\n\tbool cus[1000]={};\n\twhile(1){\n\t\tint t=-pq.top(); pq.pop();\n\n\t\tint i;\n\t\tfor(i=0;i<n;i++) if(!cus[i] && t%(call[i]+wait[i])<=call[i]) break;\n\t\tif(i<n){\n\t\t\tn_cus++;\n\t\t\tcus[i]=true;\n\t\t\tpq.push(-(t+talk[i]));\n\n\t\t\tif(t+talk[i]>T) return false;\n\t\t\tif(n_cus==n) break;\n\t\t}\n\t\telse{\n\t\t\tpq.push(-(t+1));\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&n,&T),n;){\n\t\trep(i,n) scanf(\"%d%d%d\",talk+i,call+i,wait+i);\n\n\t\tint p;\n\t\tfor(p=1;!solve(p);p++);\n\n\t\tprintf(\"%d\\n\",p);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"cstring\"\n#include \"cstdio\"\n#include \"vector\"\nusing namespace std;\nconst int N = 2010;\nint vis[N], M[N], L[N], K[N], v[N];\nint n, T;\nbool gao(int x)\n{\n\tmemset(v, 0, sizeof(v));\n\tmemset(vis, 0, sizeof(vis));\n\tv[0] = x;\n\tfor(int i = 0; i <= T; ++ i){\n\t\tif(i != 0) v[i] += v[i - 1];\n\t\tfor(int j = 1; j <= n; ++ j){\n\t\t\tif(v[i] == 0) break;\n\t\t\tif(vis[j]) continue;\n\t\t\tif(i % (L[j] + K[j]) <= L[j] && i + M[j] <= T){\n\t\t\t\tv[i] --;\n\t\t\t\tv[i + M[j]] ++;\n\t\t\t\tvis[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i){\n\t\tif(vis[i] == 0) return false;\n\t}\n\treturn true;\n}\n\t\t\t\t\nint main(void)\n{\n\twhile(scanf(\"%d %d\", &n, &T) && (n || T)){\n\t\tfor(int i = 1; i <= n; ++ i){\n\t\t\tscanf(\"%d %d %d\", &M[i], &L[i], &K[i]);\n\t\t}\n\t\tint l = 1, r = 1111;\n\t\twhile(l < r){\n\t\t\tint m = (l + r) / 2;\n\t\t\tif(gao(m)){\n\t\t\t\tr = m;\n\t\t\t}else{\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t}\n\t\tcout << l << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define maxn 3000000\nusing namespace std;\nint i,j,k,n,m,x,y,z,t,now,tt,f[1500],d[1500],flag,l,r,mid,nn;\n\nstruct node{\n    int x,y,z,w;\n} a[maxn];\n\nbool cmp(struct node a,struct node b)\n{\n    if (a.x<b.x) return true;\n    if (a.x>b.x) return false;\n    if (a.w<b.w) return true;\n    return false;\n}\n\nbool check(int x)\n{\n    int i,j,k,now,tmp;\n    now=0;\n    memset(d,0,sizeof(d));\n    memset(f,0,sizeof(f));\n    for(i=0;i<tt;i++)\n        {\n            if (f[a[i].w]==0)\n            {\n                f[a[i].w]=1;\n                flag=2147483647;z=-1;\n                for(j=1;j<=now;j++)\n                {\n                    if (d[j]<flag) \n                    {\n                        flag=d[j];\n                        z=j;\n                    }\n                }\n                if ((flag<=a[i].x+a[i].y)&&(max(flag,a[i].x)+a[i].z<=t))\n                {\n                    d[z]=max(flag,a[i].x)+a[i].z;\n                }\n                else\n                {\n                    if ((now<x)&&(a[i].x+a[i].z<=t))\n                    {\n                        now++;\n                        d[now]=a[i].x+a[i].z;\n                    }\n                    else\n                    {\n                            f[a[i].w]=0;\n                    }\n                }\n            \n            }\n        }\n        for(i=1;i<=n;i++)\n         if (f[i]==0) return false;\n         return true;\n}\n\nint main()\n{\n    \n    while(1)\n    {\n        scanf(\"%d%d\",&n,&t);\n        if ((n==0)&&(t==0)) break;\n        memset(a,0,sizeof(a));\n        tt=0;\n        for(i=0;i<n;i++)\n        {\n            scanf(\"%d%d%d\",&x,&y,&z);\n            now=0;\n            while(now<=t)\n            {\n                a[tt].x=now;\n                a[tt].y=y;\n                a[tt].z=x;\n                a[tt].w=i+1;\n                now+=(y+z);\n                tt++;\n            }\n        }\n        now=0;\n        sort(a,a+tt,cmp);\n        \n        for(mid=1;mid<=n;mid++)\n       \n            if (check(mid)) break;\n     \n        printf(\"%d\\n\",mid);\n    }\n    \n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint c[1100];\nint d[1100];\nint e[1100];\nint fin[1100];\nint next[1100];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%d%d%d\",c+i,d+i,e+i);\n\t\tint left=0;\n\t\tint right=1001;\n\t\twhile(left+1<right){\n\t\t\tint M=(left+right)/2;\n\t\t\tfor(int i=0;i<M;i++)fin[i]=0;\n\t\t\tfor(int i=0;i<a;i++)next[i]=0;\n\t\t\tint last=0;\n\t\t\tint rem=a;\n\t\t\tfor(int i=0;i<b;i++){\n\t\t\t\tfor(int j=0;j<M;j++){\n\t\t\t\t\tif(fin[j]<=i){\n\t\t\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\t\t\tif(~next[k]&&next[k]<=i){\n\t\t\t\t\t\t\t\tnext[k]=-1;\n\t\t\t\t\t\t\t\tfin[j]=i+c[k];\n\t\t\t\t\t\t\t\tlast=max(last,fin[j]);\n\t\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\t\tif(~next[j]&&i==next[j]+d[j]){\n\t\t\t\t\t\tnext[j]=next[j]+d[j]+e[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!rem)break;\n\t\t\t}\n\t\t\tfor(int i=0;i<a;i++)if(~next[i])last=9999999;\n\t\t\tif(last<=b){\n\t\t\t\tright=M;\n\t\t\t}else left=M;\n\t\t}\n\t\tprintf(\"%d\\n\",right);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <set>\nusing namespace std;\nint m[1000], hang[1000], next[1000];\nbool vis[1000];\nint last[1000], tim[1000];\nbool check(int p, int n, int t)\n{\n\tmemset(vis, 0, n);\n\tmemset(tim, 0, 4 * p);\n\tmemset(last, 0, 4 * n);\n\tint ret = 0;\n\tfor (int i = 0; i <= t; ++ i)\n\t{\n\t\tfor (int j = 0, k = 0; j < p && k < n; ++ j)\n\t\t\tif (tim[j] <= i)\n\t\t\t{\n\t\t\t\twhile (k < n && (last[k] > i || last[k] + hang[k] < i || vis[k] == 1))\n\t\t\t\t\t++ k;\n\t\t\t\tif (k < n)\n\t\t\t\t{\n\t\t\t\t\ttim[j] = i + m[k];\n\t\t\t\t\tif (tim[j] > t)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tvis[k] = 1;\n\t\t\t\t\t++ ret;\n\t\t\t\t}\n\t\t\t}\n\t\tfor (int k = 0; k < n; ++ k)\n\t\t\tif (!vis[k] && last[k] + hang[k] <= i)\n\t\t\t\tlast[k] += hang[k] + next[k];\n\t}\n\treturn ret == n;\n}\nint main()\n{\n\tint n, t;\n\twhile (scanf(\"%d%d\", &n, &t), n)\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t{\n\t\t\tscanf(\"%d%d%d\", &m[i], &hang[i], &next[i]);\n\t\t\tsum += m[i];\n\t\t}\n\t\tfor (int i = max(1, sum / t); i <= n; ++ i)\n\t\t\tif (check(i, n, t))\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct cust {\n\tint  m;\n\tint l;\n\tint k;\n};\n \nstruct query {\n\tint type;\n\tint time;\n\tint id;\n};\nstruct aa {\n\tint id;\n\tint time;\n};\nclass Compare {\npublic:\n\tbool operator()(const query&l,const query&r) {\n\t\treturn l.time==r.time?l.type==r.type?l.id>r.id:l.type>r.type:l.time > r.time;\n\t}\n\tbool operator()(const aa&l, aa&r) {\n\t\treturn l.time > r.time;\n\t}\n};\n\nbool check(const int T, const vector<cust>&cus, const int n) {\n\tint waitnum = n;\n\tpriority_queue<query,vector<query>,Compare>que;\n\tset<int>waits;\n\tfor (int i = 0; i < cus.size(); ++i) {\n\t\tque.push(query{ 0,0,i });\n\t}\n\twhile (!que.empty()) {\n\t\tquery q(que.top());\n\t\tque.pop();\n\t\t//call start\n\t\t if (q.type == 0) {\n\t\t\tconst int cid = q.id;\n\t\t\tif (waitnum) {\n\t\t\t\twaitnum--;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\twaits.emplace(cid);\n\t\t\t\tconst int nexttime = q.time + cus[cid].l;\n\t\t\t\tque.push(query{ 2,nexttime,cid });\n\t\t\t}\n\t\t//call end\n\t\t}else if (q.type == 1) {\n\t\t\tauto it = waits.begin();\n\t\t\tif (it == waits.end()) {\n\t\t\t\twaitnum++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst int cid = *it;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\twaits.erase(it);\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t//give up call\n\t\t}else if (q.type == 2) {\n\t\t\tconst int cid = q.id;\n\t\t\tauto it = waits.find(cid);\n\t\t\tif (it!=waits.end()) {\n\t\t\t\twaits.erase(it);\n\t\t\t\tconst int nexttime = q.time + cus[cid].k;\n\t\t\t\tif (nexttime <= T-cus[cid].m) {\n\t\t\t\t\tque.push(query{ 0,nexttime,cid });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, T; cin >> N >> T;\n\t\tif (!N)break;\n\t\tvector<cust>cus;\n\t\tint totalm = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint m, l, k; cin >> m >> l >> k;\n\t\t\ttotalm += m;\n\t\t\tcus.push_back(cust{ m,l,k });\n\t\t}\n\t\tint amin = (totalm-1) / T + 1;\n\t\tfor (int n = amin; n <= N; ++n) {\n\t\t\tif (check(T, cus, n)) {\n\t\t\t\tcout << n << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 1000;\n\nenum {wait=0,hang,talk,end};\n\nbool solve(int n,int *M,int *L,int *K,int T,int op){\n  int now=0,can=op;\n  static int event[N],state[N];\n  rep(i,n)event[i]=0,state[i]=hang;\n  while(now <= T){\n    int next=T+1;\n\n    rep(i,n)if(state[i] != end)next=min(next,event[i]);\n    \n//     cout << now <<\" \" <<next <<  endl;\n//     cout <<\"state \";rep(i,n)cout << state[i]<<\" \";cout << endl;\n//     cout <<\"event \";rep(i,n)cout<<event[i]<<\" \";cout << endl;\n\n    if (next > T)break;\n   \n    rep(i,n){\n      if (state[i] == talk && event[i] == next){\n\tstate[i]=end;\n\tcan++;\n      }\n    }\n    \n    rep(i,n){\n      if (state[i] == hang && event[i] == next){\n\tstate[i]=wait;\n\tevent[i]=next+L[i];\n      }\n    }\n\n    rep(i,n){\n      if (state[i] == wait && can > 0){\n\tstate[i]=talk;\n\tevent[i]=next+M[i];\n\tcan--;\n      }\n    }\n\n    rep(i,n){\n      if (state[i] == wait && event[i] == next){\n\tstate[i]=hang;\n\tevent[i]=next+K[i];\n      }\n    }\n\n    now=next;\n  }\n  rep(i,n)if (state[i] != end)return false;\n  return true;\n}\n\n\nint solve(int n,int *M,int *L,int *K,int T){\n  REP(i,1,n)if (solve(n,M,L,K,T,i))return i;\n  return n;\n}\n\nmain(){\n  int n,t;\n  int M[N],L[N],K[N];\n  while(cin>>n>>t && n){\n    rep(i,n)cin>>M[i]>>L[i]>>K[i];\n    cout << solve(n,M,L,K,t) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint N, T;\nint M[1005], L[1005], K[1005];\nint used[1005], add[1005];\n \nbool check(int x){\n   \n  memset(used,0,sizeof(used));\n  memset(add,0,sizeof(add));\n   \n  for(int i=0;i<=T;i++){\n     \n    x+=add[i];\n     \n    for(int j=0;j<N;j++){\n       \n      if(x==0) break;\n       \n      if(used[j]) continue;\n       \n      int mod=L[j]+K[j];\n       \n      if((i%mod<=L[j])&&i+M[j]<=T){\n    x--;\n    add[i+M[j]]++;\n    used[j]=1;\n      }      \n       \n    }\n \n  }\n   \n  int res=0;\n  for(int i=0;i<N;i++) res+=used[i];\n   \n  return res==N;\n}\n \nvoid solve(){\n   \n  for(int i=0;i<=1000;i++)\n    if(check(i)){\n      cout<<i<<endl;\n      return;\n    }\n   \n}\n \nint main(){\n   \n  while(1){\n     \n    cin>>N>>T;\n    if(!N&&!T) break;\n     \n    for(int i=0;i<N;i++) scanf(\"%d %d %d\", &M[i], &L[i], &K[i]);\n     \n    solve();\n     \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define maxn 3000000\nusing namespace std;\nint i,j,k,n,m,x,y,z,t,now,tt,f[1500],d[1500],flag,l,r,mid,nn;\nstruct node{\n\tint x,y,z,w;\n} a[maxn];\n\nbool cmp(struct node a,struct node b)\n{\n\tif (a.x<b.x) return true;\n\tif (a.x>b.x) return false;\n\treturn (a.w<b.w);\n}\n\nbool check(int x)\n{\n\tint i,j,k,now,tmp;\n\tnow=0;\n\tmemset(d,0,sizeof(d));\n\tmemset(f,0,sizeof(f));\n\t\tfor(i=0;i<tt;i++)\n\t\t{\n\t\t\tif (f[a[i].w]==0)\n\t\t\t{\n\t\t\t\tf[a[i].w]=1;\n\t\t\t\tflag=2147483647;z=-1;\n\t\t\t\tfor(j=1;j<=now;j++)\n\t\t\t\t{\n\t\t\t\t\tif (d[j]<flag) \n\t\t\t\t\t{\n\t\t\t\t\t\tflag=d[j];\n\t\t\t\t\t\tz=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((flag<=a[i].x+a[i].y)&&(max(flag,a[i].x)+a[i].z<=t))\n\t\t\t\t{\n\t\t\t\t\td[z]=max(flag,a[i].x)+a[i].z;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ((now<x)&&(a[i].x+a[i].z<=t))\n\t\t\t\t\t{\n\t\t\t\t\t\tnow++;\n\t\t\t\t\t\td[now]=a[i].x+a[i].z;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t\tf[a[i].w]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t if (f[i]==0) return false;\n\t\t return true;\n}\n\nint main()\n{\n\t\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d\",&n,&t);\n\t\tmemset(a,0,sizeof(a));\n\t\ttt=0;\n\t\tif ((n==0)&&(t==0)) break;\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tnow=0;\n\t\t\twhile(now<=t)\n\t\t\t{\n\t\t\t\ta[tt].x=now;\n\t\t\t\ta[tt].y=y;\n\t\t\t\ta[tt].z=x;\n\t\t\t\ta[tt].w=i+1;\n\t\t\t\tnow+=(y+z);\n\t\t\t\ttt++;\n\t\t\t}\n\t\t}\n\t\tnow=0;\n\t\tsort(a,a+tt,cmp);\n\t\tl=1;r=n;\n\t\twhile(l+1<r)\n\t\t{\n\t\t\tmid=(l+r)/2;\n\t\t\tif (check(mid)) r=mid;\n\t\t\telse l=mid;\n\t\t}\n\t\tnn=r;\n\t\tif (check(l)) nn=l;\n\n\t\tprintf(\"%d\\n\",nn);\n\t}\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<map>\n#include<algorithm>\ntypedef long long LL;\n\nconst int N = 1005;\nconst int inf = 1e9+7;\nusing namespace std;\nint n,T;\nstruct pnt{\n    int m,l,k;\n}p[N];\n\nvoid input(){\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d\",&p[i].m,&p[i].l,&p[i].k);\n    }\n}\n\nstruct node{\n    int val;\n    node() {};\n    node(int _val) {val=_val;}\n    bool operator<(const node &a)const{\n        return a.val<val;\n    }\n};\n\nbool judge(int mid){\n//    printf(\"mid=%d\\n\",mid);\n    bool vis[N];\n    memset(vis,0,sizeof(vis));\n    priority_queue<node> q;\n    for(int i=0;i<mid;i++) q.push(node(0));\n    for(int j=0;j<n;j++){\n        if(q.empty()) break;\n        int val=q.top().val;\n        q.pop();\n//        printf(\"%d \\n\",val);\n        bool flag=0;\n        int kk=-1,nt;\n        for(int i=1;i<=n;i++){\n            if(vis[i]) continue;\n            int tt=val%(p[i].l+p[i].k);\n            //if(val>0&&tt==0) tt=p[i].l+p[i].k;\n            if(tt>p[i].l){\n                int tmp=p[i].l+p[i].k-tt;\n                if(tmp+p[i].m<=T && (kk==-1||tmp<nt)) kk=i,nt=tmp;\n                continue;\n            }\n            if(val+p[i].m>T) continue;\n            val+=p[i].m,vis[i]=1,flag=1;\n//            printf(\"%d %d\\n\",i,val);\n            q.push(node(val));\n            break;\n        }\n        if(!flag&&kk!=-1){\n            val+=nt,val+=p[kk].m;\n            if(val<=T){\n                vis[kk]=1;\n                q.push(node(val));\n            }\n        }\n    }\n    for(int i=1;i<=n;i++){\n        if(!vis[i]) return 0;\n    }\n    return 1;\n}\n\nint bs(){\n    int L=1,R=n,mid,res=n;\n    while(L<=R){\n        mid=(L+R)>>1;\n        if(judge(mid)) R=mid-1,res=mid;\n        else L=mid+1;\n    }\n    return res;\n}\n\nint main(){\n   // freopen(\"in\",\"r\",stdin);\n    while(scanf(\"%d%d\",&n,&T)>0){\n        if(n==0&&T==0) break;\n        input();\n        printf(\"%d\\n\",bs());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n#define maxn 1100\n#define oo 1000000000\n#define clearAll(a) memset(a,0,sizeof(a))\n#define sq(a) ((a)*(a))\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,t;\n\nint M[maxn],L[maxn],K[maxn];\nint S[maxn];\nint T[maxn];\nbool vis[maxn];\n\nclass cmp\n{\n\tpublic :\n\tbool operator() (int x,int y)\n\t{\n\t\treturn x>y;\n\t}\n};\n\nbool check(int x)\n{\n\tpriority_queue<int,vector<int>,cmp > ser;\n\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tS[i]=0;\n\t\tT[i]=L[i];\n\t}\n\n\tfor (int i=1;i<=x;i++)\n\t\tser.push(0);\n\n\tint now = 0;\n\tint cnt=0;\n\tint i;\n\tclearAll(vis);\n\n\twhile (true)\n\t{\n\t\tnow = ser.top(); ser.pop();\n\t\tif (now>t) break;\n\n\t\tfor (i=1;i<=n;i++)\n\t\t\tif (vis[i]==false)\n\t\t\twhile (T[i]<now)\n\t\t\t{\n\t\t\t\tS[i]=T[i]+K[i];\n\t\t\t\tT[i]=S[i]+L[i];\n\t\t\t\tif (S[i]>t) return false;\n\t\t\t}\n\n        int mi = oo;\n        for (int i=1;i<=n;i++)\n            if (!vis[i])\n                mi = min(S[i],mi);\n\n        if (now<mi)\n            now = mi;\n\n\t\tfor (i=1;i<=n;i++)\n\t\t\tif (!vis[i]&&S[i]<=now&&now<=T[i])\n\t\t\t\tbreak;\n\n        if (i>n) break;\n\t\tif (max(now,S[i])+M[i]>t) return false;\n\t\tvis[i] = true;\n\t\tcnt++;\n\t\tif (cnt==n) return true;\n\t\tser.push(max(now,S[i])+M[i]);\n\t}\n\n\treturn (cnt==n);\n}\n\nint main()\n{\n    //freopen(\"C:\\\\Users\\\\py\\\\Desktop\\\\input.txt\",\"r\",stdin);\n    //freopen(\"C:\\\\Users\\\\py\\\\Desktop\\\\output.txt\",\"w\",stdout);\n\n    while (scanf(\"%d%d\",&n,&t)&&(n||t))\n    {\n    \tfor (int i=1;i<=n;i++)\n    \t\tscanf(\"%d%d%d\",&M[i],&L[i],&K[i]);\n\n    \tint l = 1 , r = n+1;\n    \tint mid;\n\n\t\twhile (l<r)\n\t\t{\tmid=(l+r)/2;\n\t\t\tif (check(mid)) r=mid;\n\t\t\telse l=mid+1;\n\t\t}\n\n\t\tprintf(\"%d\\n\",l);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,t,m[1000],l[1000],k[1000];\n\nbool check(int x){\n  int c[1001]={},used[1000]={},cnt=n;\n  for(int i=0;i<t;i++,x+=c[i])\n    for(int j=0;j<n&&x;j++){\n      if(used[j])continue;\n      if(i+m[j]>t)return 0;\n      if(i%(l[j]+k[j])<=l[j])c[i+m[j]]++,cnt--,used[j]=1,x--;\n    }\n  return !cnt;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&t),n){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    int ans=0;\n    for(int i=1;i<=n&&!ans;i++)if(check(i))ans=i;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n#define N 1010\n\nint num[N],cur[N];\nint m[N],l[N],k[N];\nint n,t;\nbool work(int val){\n    memset(cur,0,sizeof(cur));\n    memset(num,0,sizeof(num));\n    num[0]=val;\n    int tot=n;\n    for (int i=0;i<t;i++){\n        if (tot==0) return 1;\n        if (num[i] == 0) continue;\n        for (int j=1;j<=n;j++){\n            if (cur[j]) continue;\n            if (i%(l[j]+k[j]) <= l[j]){\n                if (i+m[j]>t) return 0;\n                cur[j]=1;\n                tot--;\n                num[i]--;\n                num[i+m[j]]++;\n            }\n            if (num[i]==0) break;\n        }\n        num[i+1]+=num[i];\n    }\n    if (tot==0) return 1;\n    return 0;\n}\nint main(){\n   // freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    while (scanf(\"%d%d\",&n,&t),n+t){\n        for (int i=1;i<=n;i++)\n            scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n        int l=1,r=n,mid,ans;\n        while (l<=r){\n            int mid=(l+r)/2;\n            if (work(mid)) {\n                ans=mid;\n                r=mid-1;\n            }\n            else l=mid+1;\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n, ll m) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%m;\n\t\ta = a * a%m; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nusing mP = pair<modint, modint>;\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\nint take_first(bitset<1000> bt) {\n\tint c = bt.count();\n\tint res = 0;\n\tper(i, 10) {\n\t\tif ((bt >> (1 << i)).count() == c) {\n\t\t\tres += (1 << i);\n\t\t\tbt >>= (1 << i);\n\t\t}\n\t}\n\treturn res;\n}\n\nint n, t;\nvoid solve() {\n\tvector<vector<bool>> exi(n, vector<bool>(t + 1));\n\tvector<int> m(n);\n\n\tvector<bitset<1000>> loc(t + 1);\n\trep(i, n) {\n\t\tcin >> m[i];\n\t\tint l, k; cin >> l >> k;\n\t\tint cur = 0;\n\t\twhile (cur <= t) {\n\t\t\tRep1(j, cur, cur + l) {\n\t\t\t\tif (j > t)break;\n\t\t\t\texi[i][j] = true;\n\t\t\t\tloc[j][i] = 1;\n\t\t\t}\n\t\t\tcur += l + k;\n\t\t}\n\t}\n\tfor (int x = 1; x <= n; x++) {\n\t\tbitset<1000> rest; rep(i, n)rest[i] = 1;\n\t\tvector<int> ad(t + 1, 0);\n\t\tint cur = x;\n\t\trep(i, t + 1) {\n\t\t\tcur += ad[i];\n\t\t\tif (cur == 0)continue;\n\t\t\tbitset<1000> bt = rest & loc[i];\n\t\t\tint c = bt.count();\n\t\t\tbool fin = false;\n\t\t\tint len = min(c, cur);\n\t\t\trep(j, len) {\n\t\t\t\tint f = bt._Find_first();\n\t\t\t\t//cout << \"! \" << x << \" \" << i << \" \" << f << endl;\n\t\t\t\tif (i + m[f] <= t) {\n\t\t\t\t\trest[f] = 0;\n\t\t\t\t\tbt[f] = 0;\n\t\t\t\t\tcur--;\n\t\t\t\t\tad[i + m[f]]++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfin = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fin)break;\n\t\t}\n\t\tbool valid = true;\n\t\trep(i, n)if (rest[i])valid = false;\n\t\tif (valid) {\n\t\t\t//cout << \"ans is \";\n\t\t\tcout << x << endl; return;\n\t\t}\n\t}\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init_f();\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\twhile (cin >> n >> t, n) {\n\t\tsolve();\n\t}\n\t//solve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <set>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nbool isCalling[2001];\nbool isTelling[2001];\nbool isFin[2001];\nint N,T;\nint Mi[2001];\nint Li[2001];\nint Ki[2001];\npii datas[2001];\n\nclass Event{\npublic:\n    // 0->qªhang up\n    // 1->qªdbJn\n    // 2->operatorªdbðI¹\n    int cid;\n    int time;\n    Event(int c,int t){\n        cid=c,time=t;\n    }\n    Event();\n    bool operator<(const Event &e)const{\n        return(this->time>e.time);\n    }\n};\n// nlÌIy[^ªvéÆ«ÌV~[V\nbool check(int n){\n    memset(isFin,0,sizeof(isFin));\n    priority_queue<Event> pq;\n    int curTime=0;\n    for(int i=0;i<n;i++){\n        pq.push(Event(i,Mi[i]));\n        isFin[i]=true;\n    }\n    // »Ýq}ÈopÌ\n    int opr=0;\n    int cnt=N;\n    while(pq.size()){\n        // ¡ñÌCxgªI¹µ½opðæèo·\n        Event e=pq.top();pq.pop();\n        curTime=e.time;\n        cnt--;\n        opr++;\n        // óÅ©ÂÜ¾IíÁÄ¢È¢Cxgª¶Ý\n        if(pq.size()==0){\n            if(cnt!=0&&opr!=0){\n                // ÊbÂ\\ÉÈéÜÅª¢ÔÉÀ×é\n                int idx=0;\n                for(int i=0;i<N;i++){\n                    if(isFin[i])continue;\n                    int a=e.time%(Ki[i]+Li[i]);\n                    if(a>=0&&a<=Li[i]){\n                        if(opr>0){\n                            pq.push(Event(i,curTime+Mi[i]));\n                            isFin[i]=true;\n                            opr--;\n                        }\n                    }\n                    else{\n                        int b=Ki[i]-(a-Li[i]);\n                        datas[idx].first=b;\n                        datas[idx].second=-i;\n                        idx++;\n                    }\n                    // ·ÅÉcèÌopðz¦Ä¢é\n                    //if(idx>=opr)break;\n                }\n                sort(datas,datas+idx,greater<pii>());\n                int nxt=opr;\n                for(int i=0;i<min(idx,opr);i++){\n                    pq.push(Event(-datas[i].second,curTime+datas[i].first+Mi[-datas[i].second]));\n                    isFin[-datas[i].second]=true;\n                    nxt--;\n                }\n                opr=nxt;\n            }\n        }\n        // ñÌCxgªI¹·éÜÅÌÔÜÅÉAdbÂ\\ÔÉÈéàÌð·×Ä·\n        else{\n            if(opr==0)continue;\n            int neft=pq.top().time;\n            // ÊbÂ\\ÉÈéÜÅª¢ÔÉÀ×é\n            int idx=0;\n            for(int i=0;i<N;i++){\n                if(isFin[i])continue;\n                int a=e.time%(Ki[i]+Li[i]);\n                if(a>=0&&a<=Li[i]){\n                    if(opr>0){\n                        pq.push(Event(i,curTime+Mi[i]));\n                        isFin[i]=true;\n                        opr--;\n                    }\n                }\n                else{\n                    int b=Ki[i]-(a-Li[i]);\n                    // ÊbÂ\\ÉÈéÔªneftæè¬³¢ÈçÎ\n                    if(b+curTime<neft){\n                        datas[idx].first=b;\n                        datas[idx].second=-i;\n                        idx++;\n                    }\n                }\n                // ·ÅÉcèÌopðz¦Ä¢é\n                //if(idx>=opr)break;\n            }\n            sort(datas,datas+idx,greater<pii>());\n            int nxt=opr;\n            for(int i=0;i<min(idx,opr);i++){\n                pq.push(Event(-datas[i].second,curTime+datas[i].first+Mi[-datas[i].second]));\n                isFin[-datas[i].second]=true;\n                nxt--;\n            }\n            opr=nxt;\n        }\n    }\n    return curTime<=T;\n}\n\nint main(){\n\n    while(cin>>N>>T&&(N|T)){\n        for(int i=0;i<N;i++)cin>>Mi[i]>>Li[i]>>Ki[i];\n        for(int i=1;i<=N;i++){\n            if(check(i)){\n                cout<<i<<endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<cstdlib>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<map>\n#include<algorithm>\ntypedef long long LL;\n\nconst int N = 1005;\nconst int inf = 1e9+7;\nusing namespace std;\nint n,T;\nstruct pnt{\n    int m,l,k;\n}p[N];\n\nvoid input(){\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d\",&p[i].m,&p[i].l,&p[i].k);\n    }\n}\n\nstruct node{\n    int val;\n    node() {};\n    node(int _val) {val=_val;}\n    bool operator<(const node &a)const{\n        return a.val<val;\n    }\n};\n\nbool judge(int mid){\n//    printf(\"mid=%d\\n\",mid);\n    bool vis[N];\n    memset(vis,0,sizeof(vis));\n    priority_queue<node> q;\n    for(int i=0;i<mid;i++) q.push(node(0));\n    while(!q.empty()){\n        int val=q.top().val;\n        q.pop();\n//        printf(\"%d \\n\",val);\n        bool flag=0;\n        int kk=-1,nt;\n        for(int i=1;i<=n;i++){\n            if(vis[i]) continue;\n            int tt=val%(p[i].l+p[i].k);\n            //if(val>0&&tt==0) tt=p[i].l+p[i].k;\n            if(tt>p[i].l){\n                int tmp=p[i].l+p[i].k-tt;\n                if(tmp+p[i].m<=T && (kk==-1||tmp<nt)) kk=i,nt=tmp;\n                continue;\n            }\n            if(val+p[i].m>T) continue;\n            val+=p[i].m,vis[i]=1,flag=1;\n//            printf(\"%d %d\\n\",i,val);\n            q.push(node(val));\n            break;\n        }\n        if (flag==1) continue;\n        if(kk!=-1){\n            val+=nt,val+=p[kk].m;\n            if(val<=T){\n                vis[kk]=1;\n                q.push(node(val));\n            }\n        }\n    }\n    for(int i=1;i<=n;i++){\n        if(!vis[i]) return 0;\n    }\n    return 1;\n}\n\nint bs(){\n    int L=1,R=n,mid,res=n;\n    while(L<=R){\n        mid=(L+R)>>1;\n        if(judge(mid)) R=mid-1,res=min(res,mid);\n        else L=mid+1;\n    }\n    return res;\n}\n\nint main(){\n   // freopen(\"in\",\"r\",stdin);\n    while(scanf(\"%d%d\",&n,&T)>0){\n        if(n==0&&T==0) break;\n        input();\n        printf(\"%d\\n\",bs());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n\nusing namespace std;\n\nbool simulate(const vector<int> &L, const vector< pair<int, int> > &vp, int T, int M){\n\tint N = vp.size();\n\tvector<int> lest(T+1, 0);\n\tvector<bool> ok(vp.size(), false);\n\tfor(int i=0;i<M;i++) lest[L[i]]++;\n\tint cnt = N-M;\n\tfor(int i=1;i<T;i++){\n\t\tif(cnt == 0) return true;\n\t\tif(lest[i]==0) continue;\n\t\tfor(int j=M;j<N;j++){\n\t\t\tif(ok[j]) continue;\n\t\t\tif(i%vp[j].second <= vp[j].first){\n\t\t\t\tif(i+L[j] > T) return false;\n\t\t\t\tcnt--;\n\t\t\t\tok[j] = true;\n\t\t\t\tlest[i]--;\n\t\t\t\tlest[i+L[j]]++; \n\t\t\t}\n\t\t\tif(lest[i] == 0) break;\n\t\t}\n\t\tlest[i+1] += lest[i];\n\t}\n\treturn cnt == 0;\n}\n\nint main(){\n\tint N, T;\n\tifstream fin(\"I.txt\");\n\twhile(fin >> N >> T, N){\n\t\tvector<int> L(N);\n\t\tvector< pair<int, int> > vp(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfin >> L[i] >> vp[i].first >> vp[i].second;\n\t\t\tvp[i].second += vp[i].first;\n\t\t}\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(simulate(L, vp, T, i)){\n\t\t\t\tcout << i << endl; break;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 1000;\n\nenum {wait=0,hang,talk,end};\n\nbool sim(int n,int *M,int *L,int *K,int T,int op){\n  int now=0,can=op;\n  static int event[N],state[N];\n  rep(i,n)event[i]=0,state[i]=hang;\n  while(now <= T){\n    int next=T+1;\n\n    rep(i,n)if(state[i] != end)next=min(next,event[i]);\n\n    if (next > T)break;\n   \n    rep(i,n){\n      if (state[i] == talk && event[i] == next){\n\tstate[i]=end;\n\tcan++;\n      }\n    }\n    \n    rep(i,n){\n      if (state[i] == hang && event[i] == next){\n\tstate[i]=wait;\n\tevent[i]=next+L[i];\n      }\n    }\n\n    rep(i,n){\n      if (state[i] == wait && can > 0){\n\tstate[i]=talk;\n\tevent[i]=next+M[i];\n\tcan--;\n      }\n    }\n\n    rep(i,n){\n      if (state[i] == wait && event[i] == next){\n\tstate[i]=hang;\n\tevent[i]=next+K[i];\n      }\n    }\n\n    now=next;\n  }\n  rep(i,n)if (state[i] != end)return false;\n  return true;\n}\n\nint solve(int n,int *M,int *L,int *K,int T){\n  int l=0,r=n-1, mid,ok=n;\n  while(l <= r){\n    mid=(l+r)/2;\n    if (sim(n,M,L,K,T,mid))r=mid-1,ok=mid;\n    else l=mid+1;\n  }\n  \n  int ans=ok;\n  for(int i=mid-1;i>0 && i >= mid-100;i--){\n    if (sim(n,M,L,K,T,i))ans=i;\n  }\n  return ans;\n}\n\nmain(){\n  int n,t;\n  int M[N],L[N],K[N];\n  while(cin>>n>>t && n){\n    rep(i,n)cin>>M[i]>>L[i]>>K[i];\n    cout << solve(n,M,L,K,t) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nstruct Call{\n    int m,l,k;\n    int finish;\n    int nextcall;\n}call[1010];\n\nint m,t;\n\nint gao(int n){\n    priority_queue<int, vector<int>, greater<int> > que;\n    printf(\"n: %d\\n\",n);\n    int i;\n    for(i=0;i<n;i++){\n        printf(\"push: %d\\n\",call[i].m);\n        que.push(call[i].m);\n        call[i].finish=1;\n    }\n    for(i=n;i<m;i++){\n        call[i].finish=0;\n        call[i].nextcall=0;\n    }\n    for(i=1;i<=t;i++){\n        int j;\n        printf(\"time: %d\\n\",i);\n        for(j=0;j<m;j++){\n            if(call[j].finish==0 && call[j].nextcall<=i && call[j].nextcall+call[j].l>=i){\n                if(que.top()<=i){\n                    que.pop();\n                    que.push(i+call[j].m);\n                    call[j].finish=1;\n                    printf(\"finish:%d\\n\",j);\n                }else{\n                    if(call[j].nextcall+call[j].l==i){\n                        call[j].nextcall=i+call[j].k;\n                        printf(\"next: %d\\n\",j);\n                    }\n                }\n            }\n        }\n    }\n    for(i=0;i<m;i++){\n        printf(\"%d,%d\\n\",call[i].finish,call[i].nextcall);\n        if(call[i].finish==0) return 0;\n    }\n    for(i=0;i<n;i++){\n        if(que.top()>t) return 0;\n        que.pop();\n    }\n    return 1;\n}\n\nint main(void){\n    while(1){\n        scanf(\"%d%d\",&m,&t);\n        if(m==0 && t==0) break;\n        int i;\n        for(i=0;i<m;i++) scanf(\"%d%d%d\",&call[i].m,&call[i].l,&call[i].k);\n        int l=0,r=m;\n        while(l!=r){\n            int mid=(l+r)/2;\n            int re=gao(mid);\n            if(re==0) l=mid+1;\n            else r=mid;\n            printf(\"  %d %d\\n\",re,mid);\n        }\n        printf(\"%d\\n\",r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <set>\nusing namespace std;\nint m[1000], l[1000], k[1000];\nint tim[1000];\nbool check(int p, int n, int t)\n{\n\tset <pair <int, int> > ev, ev2;\n\tmultiset <int> per;\n\tset <int> tod;\n\tfor (int i = 0; i < n; ++ i)\n\t\tev.insert(make_pair(0, i));\n\tint now = 0;\n\twhile (now <= t)\n\t{\n\t\tif (!per.empty() && *per.begin() == now)\n\t\t\tper.erase(now);\n\t\twhile (!ev.empty() && (*ev.begin()).first == now)\n\t\t{\n\t\t\tpair <int, int> tmp;\n\t\t\tint id = (*ev.begin()).second;\n\t\t\ttim[id] = tmp.first = (*ev.begin()).first + l[id];\n\t\t\ttmp.second = id;\n\t\t\tev2.insert(tmp);\n\t\t\ttod.insert(id);\n\t\t\tev.erase(ev.begin());\n\t\t}\n\t\twhile (!tod.empty() && (int) per.size() < p)\n\t\t{\n\t\t\tint id = *tod.begin();\n\t\t\tper.insert(now + m[id]);\n\t\t\ttod.erase(tod.begin());\n\t\t\tev2.erase(make_pair(tim[id], id));\n\t\t}\n\t\twhile (!ev2.empty() && (*ev2.begin()).first == now)\n\t\t{\n\t\t\tpair <int, int> tmp;\n\t\t\tint id = (*ev2.begin()).second;\n\t\t\ttmp.first = (*ev2.begin()).first + k[id];\n\t\t\ttmp.second = id;\n\t\t\tev.insert(tmp);\n\t\t\tev2.erase(ev2.begin());\n\t\t\ttod.erase(id);\n\t\t}\n\t\tif (ev.empty() && per.empty())\n\t\t\tbreak;\n\t\tnow = t + 1;\n\t\tif (!ev.empty())\n\t\t\tnow = min(now, (*ev.begin()).first);\n\t\tif (!ev2.empty())\n\t\t\tnow = min(now, (*ev2.begin()).first);\n\t\tif (!per.empty())\n\t\t\tnow = min(now, *per.begin());\n\t}\n\treturn now <= t;\n}\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"ans.txt\", \"w\", stdout);\n\tint n, t;\n\twhile (scanf(\"%d%d\", &n, &t), n)\n\t{\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(\"%d%d%d\", &m[i], &l[i], &k[i]);\n\t\tfor (int i = 1; i <= n; ++ i)\n\t\t\tif (check(i, n, t))\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <set>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nbool isCalling[1001];\nbool isTelling[1001];\nbool isFin[1001];\nint N,T;\nint Mi[1001];\nint Li[1001];\nint Ki[1001];\npii datas[1001];\n\nclass Event{\npublic:\n    // 0->qªhang up\n    // 1->qªdbJn\n    // 2->operatorªdbðI¹\n    int cid;\n    int time;\n    Event(int c,int t){\n        cid=c,time=t;\n    }\n    Event();\n    bool operator<(const Event &e)const{\n        return(this->time>e.time);\n    }\n};\n// nlÌIy[^ªvéÆ«ÌV~[V\nbool check(int n){\n    memset(isFin,0,sizeof(isFin));\n    priority_queue<Event> pq;\n    int curTime=0;\n    for(int i=0;i<n;i++){\n        pq.push(Event(i,Mi[i]));\n        isFin[i]=true;\n    }\n    // »Ýq}ÈopÌ\n    int opr=0;\n    int cnt=N;\n    while(pq.size()){\n        // ¡ñÌCxgªI¹µ½opðæèo·\n        Event e=pq.top();pq.pop();\n        curTime=e.time;\n        cnt--;\n        opr++;\n        // óÅ©ÂÜ¾IíÁÄ¢È¢Cxgª¶Ý\n        if(pq.size()==0){\n            if(cnt!=0&&opr!=0){\n                //while(pqpi.size())pqpi.pop();\n                // ÊbÂ\\ÉÈéÜÅª¢ÔÉÀ×é\n                int idx=0;\n                for(int i=0;i<N;i++){\n                    if(isFin[i])continue;\n                    int a=e.time%(Ki[i]+Li[i]);\n                    if(a>=0&&a<=Li[i]){\n                        if(opr>0){\n                            pq.push(Event(i,curTime+Mi[i]));\n                            isFin[i]=true;\n                            opr--;\n                        }\n                    }\n                    else{\n                        int b=Ki[i]-(a-Li[i]);\n                        datas[idx].first=b;\n                        datas[idx].second=-i;\n                        idx++;\n                        //pqpi.push(make_pair(b,-i));\n                    }\n                }\n                sort(datas,datas+idx,greater<pii>());\n                for(int i=0;i<min(idx,opr);i++){\n                    pq.push(Event(-datas[i].second,curTime+datas[i].first+Mi[-datas[i].second]));\n                    isFin[-datas[i].second]=true;\n                }\n                opr=0;\n                //// ÔÉæèo·\n                //while(pqpi.size()&&opr){\n                //    pii p=pqpi.top();pqpi.pop();\n                //    opr--;\n                //    pq.push(Event(-p.second,curTime+p.first+Mi[-p.second]));\n                //    isFin[-p.second]=true;\n                //}\n            }\n        }\n        // ñÌCxgªI¹·éÜÅÌÔÜÅÉAdbÂ\\ÔÉÈéàÌð·×Ä·\n        else{\n            if(opr==0)continue;\n            int neft=pq.top().time;\n            // ÊbÂ\\ÉÈéÜÅª¢ÔÉÀ×é\n            //while(pqpi.size())pqpi.pop();\n            int idx=0;\n            for(int i=0;i<N;i++){\n                if(isFin[i])continue;\n                int a=e.time%(Ki[i]+Li[i]);\n                if(a>=0&&a<=Li[i]){\n                    if(opr>0){\n                        pq.push(Event(i,curTime+Mi[i]));\n                        isFin[i]=true;\n                        opr--;\n                    }\n                }\n                else{\n                    int b=Ki[i]-(a-Li[i]);\n                    // ÊbÂ\\ÉÈéÔªneftæè¬³¢ÈçÎ\n                    if(b+curTime<neft){\n                        datas[idx].first=b;\n                        datas[idx].second=-i;\n                        idx++;\n                        //pqpi.push(make_pair(b,-i));\n                    }\n                }\n            }\n            sort(datas,datas+idx,greater<pii>());\n            for(int i=0;i<min(idx,opr);i++){\n                pq.push(Event(-datas[i].second,curTime+datas[i].first+Mi[-datas[i].second]));\n                isFin[-datas[i].second]=true;\n            }\n            opr=0;\n            //// ÔÉæèo·\n            //while(pqpi.size()&&opr){\n            //    pii p=pqpi.top();pqpi.pop();\n            //    opr--;\n            //    pq.push(Event(-p.second,curTime+p.first+Mi[-p.second]));\n            //    isFin[-p.second]=true;\n            //}\n        }\n    }\n    return curTime<=T;\n}\n\nint main(){\n    while(cin>>N>>T&&(N|T)){\n        for(int i=0;i<N;i++)cin>>Mi[i]>>Li[i]>>Ki[i];\n        for(int i=1;i<=N;i++){\n            if(check(i)){\n                cout<<i<<endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct cust {\n\tint  m;\n\tint l;\n\tint k;\n};\n \nstruct query {\n\tint type;\n\tint time;\n\tint id;\n};\nstruct aa {\n\tint id;\n\tint time;\n};\nclass Compare {\npublic:\n\tbool operator()(const query&l,const query&r) {\n\t\treturn l.time==r.time?l.type==r.type?l.id>r.id:l.type>r.type:l.time > r.time;\n\t}\n\tbool operator()(const aa&l, aa&r) {\n\t\treturn l.time > r.time;\n\t}\n};\n\nbool check(const int T, const vector<cust>&cus, const int n) {\n\tint waitnum = n;\n\tpriority_queue<query,vector<query>,Compare>que;\n\t//vector<int>waits(cus.size());\n\tset<int>waits;\n\tfor (int i = 0; i < cus.size(); ++i) {\n\t\tque.push(query{ 0,0,i });\n\t}\n\twhile (!que.empty()) {\n\t\tquery q(que.top());\n\t\tque.pop();\n\t\tif (q.type == 1) {\n\t\t\tauto it = waits.begin();\n\t\t\tif (it == waits.end()) {\n\t\t\t\twaitnum++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst int cid = *it;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime <= T) {\n\t\t\t\t\twaits.erase(it);\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\telse if (q.type == 0) {\n\t\t\tconst int cid = q.id;\n\t\t\tif (waitnum) {\n\t\t\t\twaitnum--;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime <= T) {\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\twaits.emplace(cid);\n\t\t\t\tconst int nexttime = q.time + cus[cid].l;\n\t\t\t\tque.push(query{ 2,nexttime,cid });\n\t\t\t}\n\t\t}\n\t\telse if (q.type == 2) {\n\t\t\tconst int cid = q.id;\n\t\t\tauto it = waits.find(cid);\n\t\t\tif (it!=waits.end()) {\n\t\t\t\twaits.erase(it);\n\t\t\t\tconst int nexttime = q.time + cus[cid].k;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\tque.push(query{ 0,nexttime,cid });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, T; cin >> N >> T;\n\t\tif (!N)break;\n\t\tvector<cust>cus;\n\t\tint totalm = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint m, l, k; cin >> m >> l >> k;\n\t\t\ttotalm += m;\n\t\t\tcus.push_back(cust{ m,l,k });\n\t\t}\n\t\tint amin = (totalm-1) / T + 1;\n\t\tfor (int n = amin; n <= N; ++n) {\n\t\t\tif (check(T, cus, n)) {\n\t\t\t\tcout << n << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nstruct customer{\n  int state,t;\n  void change_state(int new_state){\n    state=new_state;\n    t=0;\n  }\n};\nenum{\n  Calling,\n  Talking,\n  Waiting,\n  Done,\n};\nint n,t;\nbool ok(vi &m,vi &l,vi &k,int o){\n  int open_operators=o;\n  vector<customer> customers(m.size());\n  int cur=0;\n  while(1){\n    int dt=INT_MAX/100;\n    REP(j,n){\n      customer &c=customers[j];\n      switch(c.state){\n        case Calling:\n          if(open_operators){\n            dt=0;\n          }else{\n            dt=min(dt,l[j]-c.t);\n          }\n          break;\n        case Talking:\n          dt=min(dt,m[j]-c.t);\n          break;\n        case Waiting:\n          dt=min(dt,k[j]-c.t);\n          break;\n      }\n    }\n    if(cur+dt>t){\n      break;\n    }\n    cur+=dt;\n    REP(j,n){\n      customers[j].t+=dt;\n    }\n    REP(j,n){\n      customer &c=customers[j];\n      switch(c.state){\n        case Talking:\n          if(c.t==m[j]){\n            c.change_state(Done);\n            open_operators++;\n          }\n          break;\n      }\n    }\n    REP(j,n){\n      customer &c=customers[j];\n      switch(c.state){\n        case Waiting:\n          if(c.t==k[j]){\n            c.change_state(Calling);\n          }\n          break;\n      }\n    }\n    REP(j,n){\n      customer &c=customers[j];\n      switch(c.state){\n        case Calling:\n          if(open_operators){\n            c.change_state(Talking);\n            open_operators--;\n          }else if(c.t==l[j]){\n            c.change_state(Waiting);\n          }\n          break;\n      }\n\n      /*\n      cerr<<cur<<\",\"<<j<<\": \";\n      cerr<<c.state<<\" \"<<c.t<<endl;\n      */\n    }\n  }\n  REP(i,n){\n    if(customers[i].state==Talking&&customers[i].t==m[i]){\n      continue;\n    }\n    if(customers[i].state!=Done){\n      return false;\n    }\n  }\n  return true;\n}\nint main(){\n  while(cin>>n>>t,n|t){\n    vi m(n),l(n),k(n);\n    REP(i,n){\n      cin>>m[i]>>l[i]>>k[i];\n    }\n\n//    ok(m,l,k,4);\n    int ans=INT_MAX/10;\n    FOR(i,1,n+1){\n      if(ok(m,l,k,i)){\n        ans=min(ans,i);break;\n      }\n      //cerr<<ok(m,l,k,i)<<endl;\n    }\n    cout<<ans<<endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, t;\nint m[1010];\nint l[1010];\nint k[1010];\nbool used[1010];\n\nbool calc(int op, int sum) {\n  MEMSET(used, false);\n  priority_queue<int> que;\n  REP(i, op) {\n    que.push(-m[i]);\n    used[i] = true;\n    sum -= m[i];\n  }\n  while (!que.empty()) {\n    int start = -que.top();\n    que.pop();\n    if (start + sum / op > t) { return false; }\n    int mintime = 1000000000;\n    int target = -1;\n    REP(i, n) {\n      if (used[i]) { continue; }\n      int p = start % (l[i] + k[i]);\n      if (p <= l[i]) {\n        mintime = start;\n        target = i;\n        break;\n      } else {\n        p = start + (l[i] + k[i] - p);\n        if (p < mintime) {\n          mintime = p;\n          target = i;\n        }\n      }\n    }\n    if (target != -1 && mintime + m[target] > t) { return false; }\n    if (target != -1) {\n      que.push(-mintime - m[target]);\n      used[target] = true;\n      sum -= m[target];\n    }\n  }\n  return true;\n}\n\nint main() {\n  int test_case = 0;\n  while (scanf(\"%d %d\", &n, &t), n|t) {\n    test_case++;\n    int sum = 0;\n    REP(i, n) {\n      scanf(\"%d %d %d\", &m[i], &l[i], &k[i]);\n      sum += m[i];\n    }\n    REP(iter, n) {\n      if (calc(iter + 1, sum)) {\n        printf(\"%d\\n\", iter + 1);\n        goto next;\n      }\n    }\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nstruct customer{\n  int state,t;\n  void change_state(int new_state){\n    state=new_state;\n    t=0;\n  }\n};\nenum{\n  Calling,\n  Talking,\n  Waiting,\n  Done,\n};\nint n,t;\nbool ok(vi &m,vi &l,vi &k,int o){\n  int open_operators=o;\n  vector<customer> customers(m.size());\n  int cur=0;\n  while(1){\n    int dt=INT_MAX/100;\n    REP(j,n){\n      customer &c=customers[j];\n      switch(c.state){\n        case Calling:\n          if(open_operators){\n            dt=0;\n          }else{\n            dt=min(dt,l[j]-c.t);\n          }\n          break;\n        case Talking:\n          dt=min(dt,m[j]-c.t);\n          break;\n        case Waiting:\n          dt=min(dt,k[j]-c.t);\n          break;\n      }\n    }\n    if(cur+dt>t){\n      break;\n    }\n    cur+=dt;\n    REP(j,n){\n      customers[j].t+=dt;\n    }\n    REP(j,n){\n      customer &c=customers[j];\n      switch(c.state){\n        case Talking:\n          if(c.t==m[j]){\n            c.change_state(Done);\n            open_operators++;\n          }\n          break;\n      }\n    }\n    REP(j,n){\n      customer &c=customers[j];\n      switch(c.state){\n        case Waiting:\n          if(c.t==k[j]){\n            c.change_state(Calling);\n          }\n          break;\n      }\n    }\n    REP(j,n){\n      customer &c=customers[j];\n      switch(c.state){\n        case Calling:\n          if(open_operators){\n            c.change_state(Talking);\n            open_operators--;\n          }else if(c.t==l[j]){\n            c.change_state(Waiting);\n          }\n          break;\n      }\n\n      /*\n      cerr<<cur<<\",\"<<j<<\": \";\n      cerr<<c.state<<\" \"<<c.t<<endl;\n      */\n    }\n  }\n  REP(i,n){\n    if(customers[i].state==Talking&&customers[i].t==m[i]){\n      continue;\n    }\n    if(customers[i].state!=Done){\n      return false;\n    }\n  }\n  return true;\n}\nint main(){\n  while(cin>>n>>t,n|t){\n    vi m(n),l(n),k(n);\n    REP(i,n){\n      cin>>m[i]>>l[i]>>k[i];\n    }\n\n    int lb=-1,ub=n;\n    while(ub-lb>1){\n      int mid=(lb+ub)/2;\n      if(ok(m,l,k,mid)){\n        ub=mid;\n      }else{\n        lb=mid;\n      }\n    }\n//    ok(m,l,k,4);\n    int ans=INT_MAX/10;\n    FOR(i,1,ub+1){\n      if(ok(m,l,k,i)){\n        ans=min(ans,i);\n        break;\n      }\n      //cerr<<ok(m,l,k,i)<<endl;\n    }\n    cout<<ans<<endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\nusing namespace std;\n\nclass Customer\n{\npublic:\n\tint id,m,l,k,t;\n\tCustomer() {}\n\tCustomer(int id, int m, int l, int k, int t)\n\t\t:id(id),m(m),l(l),k(k),t(t)\n\t{}\n\n\tbool operator<(const Customer& c) const\n\t{\n\t\tif(t != c.t) return t > c.t;\n\t\treturn id > c.id;\n\t}\n\n};\n\nbool simulate(int T, int opnum, vector<Customer>& customers)\n{\n\tpriority_queue<int, vector<int>, greater<int> > ops;\n\tfor(int i=0; i<opnum; i++) ops.push(0);\n\n\tpriority_queue<Customer> q;\n\tfor(int i=0; i<customers.size(); i++) q.push(customers[i]);\n\n\twhile(!q.empty()) {\n\t\tCustomer c = q.top(); q.pop();\n\t\tint op = ops.top(); ops.pop();\n\n\t\tif(op > c.t + c.l) {\n\t\t\tint nt = c.t + c.l + c.k;\n\t\t\tif(nt > T) return false;\n\n\t\t\tq.push(Customer(c.id, c.m, c.l, c.k, nt));\n\t\t\tops.push(op);\n\t\t}\n\t\telse {\n\t\t\tint nt = c.m;\n\t\t\tif(op < c.t) nt += c.t;\n\t\t\telse nt += min(op, c.t + c.l);\n\n\t\t\tif(nt > T) return false;\n\n\t\t\tops.push(nt);\n\t\t}\n\t}\n\t\t\n\n\treturn true;\n}\n\nint solve(int T, vector<Customer>& customers)\n{\n\tint res = 1;\n\tfor(;; res++) {\n\t\tif(simulate(T, res, customers)) break;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint N,T;\n\twhile(cin >> N >> T, (N||T)) {\n\t\tvector<Customer> c(N);\n\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tint m,l,k;\n\t\t\tcin >> m >> l >> k;\n\t\t\tc[i] = Customer(i,m,l,k,0);\n\t\t}\n\n\t\tcout << solve(T, c) << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, t;\nint m[1010];\nint l[1010];\nint k[1010];\nbool used[1010];\n\nbool calc(int op, int sum) {\n  MEMSET(used, false);\n  priority_queue<int> que;\n  REP(i, op) {\n    que.push(-m[i]);\n    used[i] = true;\n    sum -= m[i];\n  }\n  while (!que.empty()) {\n    int start = -que.top();\n    que.pop();\n    if (start + sum / op > t) { return false; }\n    int mintime = 1001;\n    int target = -1;\n    REP(i, n) {\n      if (used[i]) { continue; }\n      int p = start % (l[i] + k[i]);\n      if (p <= l[i]) { p = start; }\n      else { p = start + (l[i] + k[i] - p); }\n      if (p < mintime) {\n        mintime = p;\n        target = i;\n      }\n    }\n    if (target != -1 && mintime > t) { return false; }\n    if (target != -1) {\n      que.push(-mintime - m[target]);\n      used[target] = true;\n      sum -= m[target];\n    }\n  }\n  return true;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &n, &t), n|t) {\n    int sum = 0;\n    REP(i, n) {\n      scanf(\"%d %d %d\", &m[i], &l[i], &k[i]);\n      sum += m[i];\n    }\n    REP(iter, n) {\n      if (calc(iter + 1, sum)) {\n        printf(\"%d\\n\", iter + 1);\n        goto next;\n      }\n    }\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int maxn = 1005;\n\nint m[maxn], l[maxn], k[maxn], n, t;\nint st[maxn], time[maxn];\n\nbool judge(int oper)\n{\n\tint cnt = 0;\n\tfor(int i = 0; i < n; i++)\n\t\tst[i] = 2, time[i] = l[i] - 1;\n\tfor(int i = 1; i <= t; i++)\n\t{\n\t\tfor(int j = 0; j < n; j++)\n\t\t{\n\t\t\tif(st[j] == 1 && time[j] < 0)\n\t\t\t\tst[j] = -1, oper++, cnt++;\n\t\t\tif(st[j] == 0 && time[j] < 0)\n\t\t\t\tst[j] = 2, time[j] = l[j] - 1;\n\t\t}\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tif(st[j] == 2 && oper)\n\t\t\t\tst[j] = 1, time[j] = m[j] - 1, oper--;\n        for(int j = 0; j < n; j++)\n            if(st[j] == 2 && time[j] < 0)\n                st[j] = 0, time[j] = k[j] - 1;\n\t\tfor(int j = 0; j < n; j++)\n\t\t\ttime[j]--;\n\t\tif(cnt == n)\n\t\t\treturn true;\n\t}\n\tfor(int i = 0; i < n; i++)\n        if(st[i] == 1 && time[i] < 0)\n            st[i] = -1, oper++, cnt++;\n    if(cnt == n)\n        return true;\n\treturn false;\n}\n\nint main()\n{\n\tint min, max, mid, ans;\n\n\twhile(scanf(\"%d %d\", &n, &t) == 2)\n\t{\n\t\tif(!n && !t)\n\t\t\tbreak;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tscanf(\"%d %d %d\", &m[i], &l[i], &k[i]);\n        for(ans = 0; ans <= n; ans++)\n            if(judge(ans))\n                break;\n        /*min = 0, max = ans = n;\n        while(min <= max)\n        {\n            mid = min + max >> 1;\n            if(judge(mid))\n            {\n                ans = mid;\n                max = mid - 1;\n            }\n            else\n                min = mid + 1;\n        }*/\n        printf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <cmath>\n\nusing namespace std;\nint n,T;\n#define call 0\n#define wait 1\n#define serve 2\nstruct Customer\n{\n    int t[3];\n    int state;\n    bool over;\n}p[100010];\nint M[10000],L[10000],K[10000];\nbool Judge(int tot)\n{\n    int num=tot;\n    for(int j=1;j<=n;j++)\n        p[j].over=false;\n    for(int j=1;j<=n;j++)\n    {\n        p[j].state=call;\n        for(int i=0;i<3;i++)\n            p[j].t[i]=0;\n    }\n\n    int cnt=0;\n    for(int i=0;i<=T;)\n    {\n        if(cnt==n)\n            return true;\n        for(int j=1;j<=n;j++)\n        if(!p[j].over)\n        {\n            if(p[j].state==serve)\n                if(p[j].t[serve]==M[j])\n                {\n                    num++;\n                    p[j].t[0]=0;\n                    p[j].t[1]=0;\n                    p[j].t[2]=0;\n                    p[j].over=true;\n                    cnt++;\n                }\n        }\n        //serve\n        for(int j=1;j<=n;j++)\n        if(!p[j].over)\n        {\n            if(p[j].state==wait)\n                if(p[j].t[wait]==K[j])\n                {\n                    p[j].t[0]=0;\n                    p[j].t[1]=0;\n                    p[j].t[2]=0;\n                    p[j].state=call;\n                }\n        }\n        //wait\n        for(int j=1;j<=n;j++)\n        if(!p[j].over)\n        {\n            if(p[j].state==call)\n            {\n                if(num)\n                {\n                    num--;\n                    p[j].state=serve;\n                    if(i+M[j]>T)\n                    \treturn false;\n                    p[j].t[0]=0;\n                    p[j].t[1]=0;\n                    p[j].t[2]=0;\n                }\n                else if(p[j].t[call]==L[j])\n                {\n                    p[j].t[0]=0;\n                    p[j].t[1]=0;\n                    p[j].t[2]=0;\n                    p[j].state=wait;\n                }\n            }\n        }\n        //call\n        int MIN=9999999999;\n        for(int j=1;j<=n;j++)\n            if(!p[j].over)\n            {\n            \tif(p[j].state==call)\n            \t\tMIN=min(MIN,L[j]-p[j].t[call]);\n            \telse if(p[j].state==wait)\n            \t\tMIN=min(MIN,K[j]-p[j].t[wait]);\n            \telse\n            \t\tMIN=min(MIN,M[j]-p[j].t[serve]);\n            }\n        for(int j=1;j<=n;j++)\n            if(!p[j].over)\n\t            p[j].t[p[j].state]+=MIN;\n        i+=MIN;\n    }\n    return cnt==n;\n}\nint main()\n{\n\n    //freopen(\"//home/fpy/input.txt\",\"r\",stdin);\n    while(scanf(\"%d%d\",&n,&T)!=EOF)\n    {\n        if(!n && !T)\n            break;\n        for(int i=1;i<=n;i++)\n            scanf(\"%d%d%d\",&M[i],&L[i],&K[i]);\n        int l,r=-1;\n        for(int mid=1;mid<=n;mid++)\n        {\n            if(r!=-1)break;\n            if(Judge(mid))\n                r=mid;\n            else\n                l=mid+1;\n        }\n        printf(\"%d\\n\",r);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N,T;\nint M[1000],L[1000],K[1000];\n\nint flg[1000];\nbool used[1000];\n\nbool check(int x){\n  fill(flg,flg+x,0);\n  fill(used,used+N,false);\n  \n  for(int t=0;t<=T;t++){\n\n    for(int i=0;i<x;i++){\n      if(flg[i]>t)continue;\n      for(int j=0;j<N;j++){\n        if(used[j])continue;\n        int f=t%(L[j]+K[j]);\n        if(L[j]<f){\n          continue;\n        }\n        used[j]=true;\n        flg[i]=t+M[j];\n        //        cout<<\"t=\"<<t<<\" i=\"<<i<<' '<<j<<' '<<flg[i]<<endl;\n        break;\n      }\n    }\n    \n    int mini=1e9;\n    for(int j=0;j<N;j++){\n      if(used[j])continue;\n      int f=t%(L[j]+K[j]);\n      if(L[j]<f){\n        mini=min(mini,K[j]-(f-L[j]));\n      }else mini=0;\n    }\n    \n    //    cout<<t<<' '<<mini<<endl;\n\n    int mini2=1e9;\n    for(int j=0;j<x;j++){\n      if(flg[j]>t)mini2=min(mini2,flg[j]-t);\n      else mini2=0;\n    }\n    \n    t+=max(0, max(mini,mini2)-1);\n  }\n  \n  for(int i=0;i<N;i++)\n    if(!used[i])return false;\n  \n  for(int i=0;i<x;i++)\n    if(flg[i]>T)return false;\n  return true;\n}\n\nint main(){\n  while(1){\n    cin>>N>>T;\n    if(N==0&&T==0)break;\n    for(int i=0;i<N;i++){\n      cin>>M[i]>>L[i]>>K[i];\n    }\n\n    int left=1,right=N,mid;\n\n    while(left<right){\n      mid=(left+right)/2;\n      bool result=check(mid);\n\n      if(result)right=mid;\n      else left=mid+1;\n    }\n\n    \n    cout<<left<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nstruct Event{\n    int time;\n    int type; // 0 - custermer on, 1 - custermer off, 2 - operation end, \n    int id;\n};\nbool operator < (const Event& e, const Event& f) { // !!! reversed !!!\n    if(e.time != f.time) return e.time > f.time;\n    if(e.type != f.type) return e.type > f.type;\n    return e.id > f.id;\n}\n\nbool check(int OPE, int T, const vector<int>& M, const vector<int>& L, const vector<int>& K) {\n    int N = M.size();\n    priority_queue<Event> que;\n    //priority_queue<int, vector<int>, greater<int>> wait;\n    set<int> wait;\n\n    vector<int> state(N);\n    REP(i, N) {\n        wait.insert(i);\n        if(K[i] != 1) que.push({L[i] + 1, 1, i});\n    }\n\n    int rest = N;\n\n    for(int t = 0; t <= T; t++) {\n        while(!que.empty() && que.top().time == t) {\n            auto e = que.top(); que.pop();\n            //printf(\"{time:%d, type:%d, id:%d}\\n\", e.time, e.type, e.id);\n            if(e.type == 0) {\n                //wait.push(e.id);\n                wait.insert(e.id);\n                que.push({t + L[e.id] + 1, 1, e.id});\n                state[e.id] = 0;\n            } else if(e.type == 1 && state[e.id] == 0) {\n                wait.erase(wait.find(e.id));\n                que.push({t + K[e.id] - 1, 0, e.id});\n                state[e.id] = 1;\n            } else if(e.type == 2) {\n                rest--;\n                OPE++;\n            }\n        }\n\n        while(OPE > 0 && !wait.empty()){\n            auto it = wait.begin();\n            int id = *it;\n            wait.erase(it);\n            //int id = wait.top(); wait.pop();\n            if(state[id] != 0) continue;\n            state[id] = 2;\n            que.push({t + M[id], 2, id});\n            OPE--;\n        }\n    }\n\n    //cout << rest << endl;\n    return rest == 0;\n}\n\nint main(){\n    int N, T;\n    while(cin >> N >> T && (N > 0)) {\n        vector<int> M(N), L(N), K(N);\n        REP(i, N) cin >> M[i] >> L[i] >> K[i];\n\n        for(int i = 1; i <= N; i++) {\n            if(check(i, T, M, L, K)) {\n                cout << i << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N (1<<19)\n#define INF 100000000\n#define MOD 1000000007\n#define MO2 1000000009\n#define BAS 1009\n#define BA2 1007\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint n, t;\nint m[1000], l[1000], k[1000];\nbool saw[1000];\nbool ok[1000][1001];\nint cnt[1001];\n\nvoid solve(){\n    rep(i,n) cin >> m[i] >> l[i] >> k[i];\n    memset(ok,0,sizeof(ok));\n    rep(i,n){\n        for(int j = 0; j <= t;){\n            for(int u = 0; u <= l[i]; u++){\n                ok[i][j] = true;\n                j++;\n            }\n            j += k[i]-1;\n        }\n    }\n    /*\n    int ss = 0, ee = n, mid;\n    while(ee-ss > 1){\n    */\n    int mid;\n    for(mid = 1; mid <= n; mid++){\n        memset(saw,0,sizeof(saw));\n        //mid = (ee+ss)/2;\n        //cout << \"mid\" << mid << endl;\n        memset(cnt,0,sizeof(cnt));\n        cnt[0] = mid;\n        for(int u = 0; u <= t; u++){\n            if(u != 0) cnt[u] += cnt[u-1];\n            rep(i,n){\n                if(cnt[u] == 0) break;\n                if(saw[i]) continue;\n                if(ok[i][u] && u+m[i] <= t){\n                    saw[i] = true;\n                    cnt[u+m[i]]++;\n                    cnt[u]--;\n                }\n            }\n        }\n        bool yes = true;\n        rep(i,n) if(saw[i] == false) yes = false;\n        //if(yes) ee = mid;\n        //else ss = mid;\n        if(yes) break;\n    }\n    //cout << ee << endl;\n    cout << mid << endl;\n}\n\nint main(){\n    while(cin >> n >> t){\n        if(n == 0 && t == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define iss istringstream\n#define sst stringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint N,T,M[1010],L[1010],K[1010],a[1010];\n\nint main(){\n\twhile(cin>>N>>T&&N){\n\t\trep(i,N)cin>>M[i]>>L[i]>>K[i];\n\t\trep2(P,1,N+1){\n\t\t\tfill(a,a+N,0);\n\t\t\tint t=0,d=0;\n\t\t\tmultiset<int> S;\n\t\t\trep(i,P)S.insert(0);\n\t\t\tint e=0;\n\t\t\twhile(d<N&&t<=T&&e<=T){\n\t\t\t\tint nx=-1;\n\t\t\t\trep(i,N)if(!a[i]&&t%(L[i]+K[i])<=L[i]){nx=i;break;}\n\t\t\t\tif(nx>-1&&*S.begin()<=t)a[nx]=1,d++,e=max(e,t+M[nx]),S.erase(S.begin()),S.insert(t+M[nx]);\n\t\t\t\telse{t++;continue;}\n\t\t\t}\n\t\t\tif(d==N&&e<=T){cout<<P<<endl;break;}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> Ev;\nint N,T;\nint M[1000], L[1000], K[1000];\n\nbool simulate(int P)\n{\n\tint opeT[1000]={0};\n\tpriority_queue<Ev, vector<Ev>, greater<Ev> > q;\n\tfor(int i=0; i<N; i++)\n\t\tq.push(make_pair(0,i));\n\n\twhile(!q.empty())\n\t{\n\t\tEv e=q.top(); q.pop();\n\t\t\n\t\tint mop=T+1;\n\t\tfor(int i=0; i<P; i++) mop=min(opeT[i], mop);\n\n\t\tif(e.first+M[e.second]+max(0,(mop-e.first)) > T) return false;\n\n\t\tfor(int i=0; i<P; i++)\n\t\t{\n\t\t\tif(opeT[i]==mop)\n\t\t\t{\n\t\t\t\tif(opeT[i] > e.first+L[e.second])\n\t\t\t\t{\n\t\t\t\t\tq.push(make_pair(e.first+K[e.second]+L[e.second], e.second));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\topeT[i]=e.first+M[e.second]+max(0,(opeT[i]-e.first));\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main()\n{\n\twhile(cin >> N >> T, (N||T))\n\t{\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> M[i] >> L[i] >> K[i];\n\n\t\tfor(int P=1; P<=N; P++)\n\t\t{\n\t\t\tif(simulate(P))\n\t\t\t{\n\t\t\t\tcout << P << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,t,m[1000],l[1000],k[1000];\n\nbool check(int x){\n  int c[1001]={},used[1000]={},cnt=n;\n  for(int i=0;i<t;i++){\n    x+=c[i];\n    for(int j=0;j<n&&x;j++){\n      if(used[j])continue;\n      if(i+m[j]>t)return 0;\n      if(i%(l[j]+k[j])<=l[j])c[i+m[j]]++,cnt--,used[j]=1,x--;\n    }\n  }\n  return !cnt;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&t),n){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    int ans=0;\n    for(int i=1;i<=n&&!ans;i++)if(check(i))ans=i;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n#define N 1010\nvector <int> ope;\nvector <int> ask;\nint vis[N],cur[N];\nint m[N],l[N],k[N];\nint n,t;\nbool work(int val){\n    //printf(\"%d\\n\",val);\n    memset(vis,0,sizeof(vis));\n    memset(cur,0,sizeof(cur));\n    for (int i=0;i<=t;i++){\n        ope.clear();\n        ask.clear();\n        for (int j=1;j<=val;j++)\n            if (vis[j]<=i) ope.push_back(j);\n        for (int j=1;j<=n;j++){\n            if (cur[j]) continue;\n            int tp=i%(l[j]+k[j]);\n            if (tp<=l[j]) ask.push_back(j);\n        }\n        //printf(\"%d %d %d\\n\",i,ope.size(),ask.size());\n        int num=min(ope.size(),ask.size());\n        for (int j=0;j<num;j++){\n            vis[ope[j]]=i+m[ask[j]]-1;\n            cur[ask[j]]=1;\n        }\n    }\n    for (int i=1;i<=val;i++)\n        if (vis[i]>t) return 0;\n    for (int i=1;i<=n;i++)\n        if (cur[i]==0) return 0;\n    return 1;\n}\nint main(){\n    freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    while (scanf(\"%d%d\",&n,&t)==2){\n        if (n==0&&t==0) continue;\n        for (int i=1;i<=n;i++)\n            scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n        int l=1,r=n,mid,ans;\n        while (l<=r){\n            int mid=(l+r)/2;\n            if (work(mid)) {ans=mid;r=mid-1;}\n            else l=mid+1;\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool simulate(const vector<int> &L, const vector< pair<int, int> > &vp, int T, int M){\n\tint N = vp.size();\n\tvector<int> lest(T+1, 0);\n\tvector<bool> ok(vp.size(), false);\n\tfor(int i=0;i<M;i++) lest[L[i]]++;\n\tint cnt = N-M;\n\tfor(int i=1;i<T;i++){\n\t\tif(cnt == 0) return true;\n\t\tif(lest[i]==0) continue;\n\t\tfor(int j=M;j<N;j++){\n\t\t\tif(ok[j]) continue;\n\t\t\tif(i%vp[j].second <= vp[j].first){\n\t\t\t\tif(i+L[j] > T) return false;\n\t\t\t\tcnt--;\n\t\t\t\tok[j] = true;\n\t\t\t\tlest[i]--;\n\t\t\t\tlest[i+L[j]]++; \n\t\t\t}\n\t\t\tif(lest[i] == 0) break;\n\t\t}\n\t\tlest[i+1] += lest[i];\n\t}\n\treturn cnt == 0;\n}\n\nint main(){\n\tint N, T;\n\twhile(cin >> N >> T, N){\n\t\tvector<int> L(N);\n\t\tvector< pair<int, int> > vp(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin >> L[i] >> vp[i].first >> vp[i].second;\n\t\t\tvp[i].second += vp[i].first;\n\t\t}\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(simulate(L, vp, T, i)){\n\t\t\t\tcout << i << endl; break;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <set>\n\nusing namespace std;\n\nbool isCalling[1001];\nbool isTelling[1001];\nbool isFin[1001];\nint N,T;\nint Mi[1001];\nint Li[1001];\nint Ki[1001];\n\nclass Event{\npublic:\n    // 0->qªhang up\n    // 1->qªdbJn\n    // 2->operatorªdbðI¹\n    int kind;\n    int cid;\n    int time;\n    Event(int k,int c,int t){\n        kind=k,cid=c,time=t;\n    }\n    Event();\n    bool operator<(const Event &e)const{\n        if(this->time>e.time)return true;\n        else if(this->time<e.time)return false;\n        // kindªå«¢Ù¤ðDæ\n        if(this->kind<e.kind)return true;\n        else if(this->kind>e.kind)return false;\n        return(this->cid>e.cid);\n    }\n};\n\nbool check(int n){\n    if(n==0)return false;\n    memset(isCalling,0,sizeof(isCalling));\n    memset(isTelling,0,sizeof(isTelling));\n    memset(isFin,0,sizeof(isFin));\n    int opNum=n;\n    int cnt=0;\n    int finT=0;\n    priority_queue<Event> pq;\n    set<int> callingList;\n    // qªdbðJn·éEventðo^µÄ¨­\n    for(int i=0;i<N;i++)pq.push(Event(1,i,0));\n    while(cnt!=N){\n        Event e=pq.top();pq.pop();\n        if(e.kind==1){\n            finT=e.time;\n            // àµopNum>0ÈçÎAÊbJnµAI¹eventðo^\n            if(opNum>0){\n                isTelling[e.cid]=true;\n                pq.push(Event(2,e.cid,Mi[e.cid]+finT));\n                opNum--;\n            }\n            // »¤ÅÈ¯êÎAÒ¿L[ÉÇÁ\n            else{\n                isCalling[e.cid]=true;\n                callingList.insert(e.cid);\n                pq.push(Event(0,e.cid,Li[e.cid]+finT));\n            }\n        }\n        // ïbI¹\n        else if(e.kind==2){\n            cnt++;\n            finT=e.time;\n            opNum++;\n            isTelling[e.cid]=false;\n            // I¹tO\n            isFin[e.cid]=true;\n            // àµisCallingÈ¨ª¢êÎAdb(v¬»)\n            if(callingList.size()!=0){\n                int i=*callingList.begin();\n                callingList.erase(callingList.begin());\n                isCalling[i]=false;\n                isTelling[i]=true;\n                opNum--;\n                pq.push(Event(2,i,Mi[i]+finT));\n            }\n        }\n        // qªhang up\n        else{\n            // àµdbAÜ½ÍdbªI¹µÄ¢éÌÅ êÎA³\n            if(!(isFin[e.cid]||isTelling[e.cid])){\n                isCalling[e.cid]=false;\n                finT=e.time;\n                pq.push(Event(1,e.cid,Ki[e.cid]+finT));\n                set<int>::iterator it=callingList.find(e.cid);\n                if(it!=callingList.end())\n                    callingList.erase(it);\n            }\n            else{\n                set<int>::iterator it=callingList.find(e.cid);\n                if(it!=callingList.end())\n                    callingList.erase(it);\n            }\n        }\n    }\n    return(finT<=T);\n}\n\nint main(){\n    while(cin>>N>>T&&(N|T)){\n        for(int i=0;i<N;i++)cin>>Mi[i]>>Li[i]>>Ki[i];\n        for(int i=1;i<=N;i++){\n            if(check(i)){\n                cout<<i<<endl;\n                break;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1000\n\nstruct Info{\n\tint M,L,K;\n};\n\nstruct Data{\n\tData(int arg_next_free_time){\n\t\tnext_free_time = arg_next_free_time;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn next_free_time > arg.next_free_time;\n\t}\n\tint next_free_time;\n};\n\nint N,T;\nInfo info[NUM];\nbool check[NUM];\n\nbool is_ok(int num){\n\n\tpriority_queue<Data> Q;\n\tfor(int i = 0; i < num; i++)Q.push(0);\n\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\tint count = 0,current_time,id,tmp,min_time,next_time;\n\n\twhile(!Q.empty()){\n\n\t\tcurrent_time = Q.top().next_free_time;\n\t\tQ.pop();\n\n\t\tmin_time = BIG_NUM;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(check[i])continue;\n\n\t\t\ttmp = current_time%(info[i].K+info[i].L);\n\t\t\tif(tmp >= 0 && tmp <= info[i].L){\n\t\t\t\tid = i;\n\t\t\t\tbreak;\n\n\t\t\t}else{\n\t\t\t\tif(min_time > current_time+(info[i].K+info[i].L)-current_time%(info[i].K+info[i].L)){\n\t\t\t\t\tmin_time = current_time+(info[i].K+info[i].L)-current_time%(info[i].K+info[i].L);\n\t\t\t\t\tid = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(min_time == BIG_NUM){\n\n\t\t\tnext_time = current_time+info[id].M;\n\n\t\t}else{\n\n\t\t\tnext_time = min_time+info[id].M;\n\t\t}\n\t\tif(next_time > T)return false;\n\n\t\tcount++;\n\t\tif(count == N)return true;\n\t\tcheck[id] = true;\n\t\tQ.push(next_time);\n\t}\n\treturn false;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&info[i].M,&info[i].L,&info[i].K);\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tif(is_ok(i)){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&T);\n\t\tif(N == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst int mod=998244353 ;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-4;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nbool solve(void){\n\tint i,n,j,T;cin>>n>>T;\n\tif(n==0){return false;}\n\tstatic bool call[1001][1001];\n\tvector<int>M(n),L(n),K(n);\n\tfor(i=0;i<n;i++){cin>>M[i]>>L[i]>>K[i];}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<T;j++){call[j][i]=((j%(L[i]+K[i]))<=L[i]);}\n\t}\n\t\n\tint bmin=0,bmax=n;\n\twhile(bmax-bmin>1){\n\t\tint bgen=(bmin+bmax)/2;\n\t\tint ope=bgen;\n\t\tvector<int>owa(T+1);\n\t\tvector<bool>finC(n);\n\t\tbool can=true;\n\t\tfor(i=0;i<T;i++){\n\t\t\tope+=owa[i];\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(finC[j]||ope==0||(!call[i][j])){continue;}\n\t\t\t\tif(i+M[j]>T){can=false;break;}\n\t\t\t\tope--;\n\t\t\t\towa[i+M[j]]++;\n\t\t\t\tfinC[j]=1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(!finC[j]){can=false;break;}\n\t\t}\n\t\tif(can){bmax=bgen;}\n\t\telse{bmin=bgen;}\n\t}\n\tfor(int bgen=bmax-1;bgen>=1&&bmax-bgen<100;bgen-=5){\n\t\tint ope=bgen;\n\t\tvector<int>owa(T+1);\n\t\tvector<bool>finC(n);\n\t\tbool can=true;\n\t\tfor(i=0;i<T;i++){\n\t\t\tope+=owa[i];\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(finC[j]||ope==0||(!call[i][j])){continue;}\n\t\t\t\tif(i+M[j]>T){can=false;break;}\n\t\t\t\tope--;\n\t\t\t\t//cerr<<\"i,j\"<<i<<' '<<j<<endl;\n\t\t\t\towa[i+M[j]]++;\n\t\t\t\tfinC[j]=1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(!finC[j]){can=false;break;}\n\t\t}\n\t\tif(can){bmax=bgen;}\n\t\t\n\t}\n\tfor(int bgen=bmax-1;bgen>=1&&bmax-bgen<100;bgen--){\n\t\tint ope=bgen;\n\t\tvector<int>owa(T+1);\n\t\tvector<bool>finC(n);\n\t\tbool can=true;\n\t\tfor(i=0;i<T;i++){\n\t\t\tope+=owa[i];\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(finC[j]||ope==0||(!call[i][j])){continue;}\n\t\t\t\tif(i+M[j]>T){can=false;break;}\n\t\t\t\tope--;\n\t\t\t\t//cerr<<\"i,j\"<<i<<' '<<j<<endl;\n\t\t\t\towa[i+M[j]]++;\n\t\t\t\tfinC[j]=1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(!finC[j]){can=false;break;}\n\t\t}\n\t\tif(can){bmax=bgen;}\n\t\t\n\t}\n\tcout<<bmax<<endl;\n\treturn true;\n}\nint main(void){\n\tcout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);\n\twhile(solve()){}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N,T;\nint M[1000],L[1000],K[1000];\n\nint flg[1000];\nbool used[1000];\n\nbool check(int x){\n  fill(flg,flg+x,0);\n  fill(used,used+N,false);\n  \n  for(int t=0;t<=T;t++){\n\n    for(int i=0;i<x;i++){\n      if(flg[i]>t)continue;\n      for(int j=0;j<N;j++){\n        if(used[j])continue;\n        int f=t%(L[j]+K[j]);\n        if(L[j]<f)continue;\n        used[j]=true;\n        flg[i]=t+M[j];\n        //        cout<<\"t=\"<<t<<\" i=\"<<i<<' '<<j<<' '<<flg[i]<<endl;\n        break;\n      }\n    }\n    \n    int mini=1e9;\n    for(int j=0;j<N;j++){\n      if(used[j])continue;\n      int f=t%(L[j]+K[j]);\n      if(L[j]<f){\n        mini=min(mini,K[j]-(f-L[j]));\n      }else mini=0;\n    }\n    \n    //    cout<<t<<' '<<mini<<endl;\n\n    int mini2=1e9;\n    for(int j=0;j<x;j++){\n      if(flg[j]>t)mini2=min(mini2,flg[j]-t);\n      else mini2=0;\n    }\n    \n    //    t+=max(0,mini-1);\n  }\n  \n  for(int i=0;i<N;i++)\n    if(!used[i])return false;\n  \n  for(int i=0;i<x;i++)\n    if(flg[i]>T)return false;\n  return true;\n}\n\nint main(){\n  while(1){\n    cin>>N>>T;\n    if(N==0&&T==0)break;\n    for(int i=0;i<N;i++){\n      cin>>M[i]>>L[i]>>K[i];\n    }\n\n    int left=1,right=N,mid;\n\n    while(left<right){\n      mid=(left+right)/2;\n      bool result=check(mid);\n\n      if(result)right=mid;\n      else left=mid+1;\n    }\n\n    \n    cout<<left<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, T;\nint M[1000], L[1000], K[1000];\n\nbool check(int x){\n\n  int res=0, used[1000]={}, add[1001]={};\n  \n  for(int i=0;i<=T;i++){\n    \n    x+=add[i];\n    \n    for(int j=0;j<N;j++){\n\n      if(used[j]) continue;\n      \n      if(x==0) break;\n      \n      int mod=L[j]+K[j];\n      \n      if(x&&(i%mod<=L[j])&&i+M[j]<=T){\n\tx--;\n\tadd[i+M[j]]++;\n\tused[j]=true;\n\tres++;\n      }\n      \n    }\n    \n  }\n  \n  return res==N;\n}\n\nvoid solve(){\n  \n  int l=0, r=1005;\n  \n  while(l<r){\n    \n    int m=(l+r)/2;\n    \n    if(!check(m)) l=m+1;\n    else r=m;\n  }\n\n  cout<<l<<endl;\n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>N>>T;\n    if(!N&&!T) break;\n    \n    for(int i=0;i<N;i++) scanf(\"%d %d %d\", &M[i], &L[i], &K[i]);\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct cust {\n\tint  m;\n\tint l;\n\tint k;\n};\n \nstruct query {\n\tint type;\n\tint time;\n\tint id;\n};\nstruct aa {\n\tint id;\n\tint time;\n};\nclass Compare {\npublic:\n\tbool operator()(const query&l,const query&r) {\n\t\treturn l.time==r.time?l.type==r.type?l.id>r.id:l.type>r.type:l.time > r.time;\n\t}\n\tbool operator()(const aa&l, aa&r) {\n\t\treturn l.time > r.time;\n\t}\n};\n\nbool check(const int T, const vector<cust>&cus, const int n) {\n\tint waitnum = n;\n\tpriority_queue<query,vector<query>,Compare>que;\n\tset<int>waits;\n\tfor (int i = 0; i < cus.size(); ++i) {\n\t\tque.push(query{ 0,0,i });\n\t}\n\twhile (!que.empty()) {\n\t\tquery q(que.top());\n\t\tque.pop();\n\t\tif (q.type == 1) {\n\t\t\tauto it = waits.begin();\n\t\t\tif (it == waits.end()) {\n\t\t\t\twaitnum++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst int cid = *it;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\twaits.erase(it);\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\telse if (q.type == 0) {\n\t\t\tconst int cid = q.id;\n\t\t\tif (waitnum) {\n\t\t\t\twaitnum--;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime <= T) {\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\twaits.emplace(cid);\n\t\t\t\tconst int nexttime = q.time + cus[cid].l;\n\t\t\t\tque.push(query{ 2,nexttime,cid });\n\t\t\t}\n\t\t}\n\t\telse if (q.type == 2) {\n\t\t\tconst int cid = q.id;\n\t\t\tauto it = waits.find(cid);\n\t\t\tif (it!=waits.end()) {\n\t\t\t\twaits.erase(it);\n\t\t\t\tconst int nexttime = q.time + cus[cid].k;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\tque.push(query{ 0,nexttime,cid });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, T; cin >> N >> T;\n\t\tif (!N)break;\n\t\tvector<cust>cus;\n\t\tint totalm = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint m, l, k; cin >> m >> l >> k;\n\t\t\ttotalm += m;\n\t\t\tcus.push_back(cust{ m,l,k });\n\t\t}\n\t\tint amin = (totalm-1) / T + 1;\n\t\tfor (int n = amin; n <= N; ++n) {\n\t\t\tif (check(T, cus, n)) {\n\t\t\t\tcout << n << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <set>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nbool isCalling[2001];\nbool isTelling[2001];\nbool isFin[2001];\nint N,T;\nint Mi[2001];\nint Li[2001];\nint Ki[2001];\npii datas[2001];\n\nclass Event{\npublic:\n    // 0->qªhang up\n    // 1->qªdbJn\n    // 2->operatorªdbðI¹\n    int cid;\n    int time;\n    Event(int c,int t){\n        cid=c,time=t;\n    }\n    Event();\n    bool operator<(const Event &e)const{\n        return(this->time>e.time);\n    }\n};\n// nlÌIy[^ªvéÆ«ÌV~[V\nbool check(int n){\n    memset(isFin,0,sizeof(isFin));\n    priority_queue<Event> pq;\n    int curTime=0;\n    for(int i=0;i<n;i++){\n        pq.push(Event(i,Mi[i]));\n        isFin[i]=true;\n    }\n    // »Ýq}ÈopÌ\n    int opr=0;\n    int cnt=N;\n    while(pq.size()){\n        // ¡ñÌCxgªI¹µ½opðæèo·\n        Event e=pq.top();pq.pop();\n        curTime=e.time;\n        cnt--;\n        opr++;\n        // ÊbÂ\\ÉÈéÜÅª¢ÔÉÀ×é\n        int idx=0;\n        for(int i=0;i<N;i++){\n            if(isFin[i])continue;\n            int a=e.time%(Ki[i]+Li[i]);\n                if(a>=0&&a<=Li[i]){\n                    if(opr>0){\n                        pq.push(Event(i,curTime+Mi[i]));\n                        isFin[i]=true;\n                        opr--;\n                        if(opr==0)break;\n                    }\n                }\n                else{\n                    int b=Ki[i]-(a-Li[i]);\n                    if(pq.size()==0||(pq.size()!=0&&b+curTime<pq.top().time)){\n                        datas[idx].first=b;\n                        datas[idx].second=-i;\n                        idx++;\n                    }\n                }\n        }\n        sort(datas,datas+idx,greater<pii>());\n        int nxt=opr;\n        for(int i=0;i<min(idx,opr);i++){\n            pq.push(Event(-datas[i].second,curTime+datas[i].first+Mi[-datas[i].second]));\n            isFin[-datas[i].second]=true;\n            nxt--;\n        }\n        opr=nxt;\n    }\n    return curTime<=T;\n}\n\nint main(){\n\n    while(cin>>N>>T&&(N|T)){\n        for(int i=0;i<N;i++)cin>>Mi[i]>>Li[i]>>Ki[i];\n        for(int i=1;i<=N;i++){\n            if(check(i)){\n                cout<<i<<endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint M[1000],L[1000],K[1000];\nbool flag[1000];\nint N, T;\nint owaru[1001];\n\nbool check(int num) {\n  int aki = num;\n  memset(flag,0,sizeof(flag));\n  memset(owaru,0,sizeof(owaru));\n  int cnt = 0;\n  REP(i,T) {\n    aki += owaru[i];\n    REP(j,N) {\n      if (aki == 0) break;\n      if (flag[j]) continue;\n      if (i%(L[j]+K[j]) <= L[j]) {\n        // if (num == 3) {\n        //   cout << i << \":\" << j << \" \" << aki << \" \" << i+M[j] << endl;\n        // }\n        if (i+M[j]>T) return 0;\n        aki--;\n        owaru[i+M[j]]++;\n        cnt++;\n        flag[j] = 1;\n        if (cnt == N) return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>N>>T,N||T) {\n    REP(i,N) {\n      cin >> M[i] >> L[i] >> K[i];\n    }\n    int low = 0, high = N+1;\n    while(low+1<high) {\n      int mid = (low+high)/2;\n      if (check(mid)) {\n        high = mid;\n      } else {\n        low = mid;\n      }\n    }\n    cout << high << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint M[1000],L[1000],K[1000];\nbool flag[1000];\nint N, T;\nint owaru[1001];\n\nbool check(int num) {\n  int aki = num;\n  REP(i,N)flag[i]=0;\n  REP(i,T)owaru[i]=0;\n  int cnt = 0;\n  REP(i,T) {\n    aki += owaru[i];\n    REP(j,N) {\n      if (aki == 0) break;\n      if (flag[j]) continue;\n      if (i%(L[j]+K[j]) <= L[j]) {\n        if (i+M[j]>T) return 0;\n        aki--;\n        owaru[i+M[j]]++;\n        cnt++;\n        flag[j] = 1;\n        if (cnt == N) return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main() {\n  while(scanf(\"%d%d\",&N,&T),N||T) {\n    REP(i,N) scanf(\"%d%d%d\",M+i,L+i,K+i);\n    int ans = -1;\n    for (int i=1; i<=N; ++i) {\n      if (check(i)) {\n        ans = i;\n        break;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nint n, t;\nvector<int> m, l, k;\n\nbool solve(int ope)\n{\n    set<int> call;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    for(int i=0; i<n; ++i)\n        q.push(make_pair(0, i));\n    int cusRest = n;\n    int opeRest = ope;\n    vector<bool> ok(n, false);\n\n    for(;;){\n        if(cusRest == 0)\n            return true;\n\n        int curr = q.top().first;\n        int s = q.top().second;\n        q.pop();\n\n        if(curr > t)\n            return false;\n\n        if(s == INT_MAX){\n            -- cusRest;\n            if(call.empty()){\n                ++ opeRest;\n            }else{\n                s = *call.begin();\n                call.erase(call.begin());\n                ok[s] = true;\n                q.push(make_pair(curr + m[s], INT_MAX));\n            }\n        }else if(!ok[s]){\n            if(call.find(s) == call.end()){\n                if(opeRest > 0){\n                    -- opeRest;\n                    ok[s] = true;\n                    q.push(make_pair(curr + m[s], INT_MAX));\n                }else{\n                    call.insert(s);\n                    q.push(make_pair(curr + l[s]+1, s));\n                }\n            }else{\n                call.erase(call.find(s));\n                q.push(make_pair(curr + k[s]-1, s));\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        cin >> n >> t;\n        if(n == 0)\n            return 0;\n\n        m.resize(n);\n        l.resize(n);\n        k.resize(n);\n        for(int i=0; i<n; ++i)\n            cin >> m[i] >> l[i] >> k[i];\n\n        int left = 1;\n        int right = n;\n        while(left < right){\n            int mid = (left + right) / 2;\n            if(solve(mid))\n                right = mid;\n            else\n                left = mid + 1;\n        }\n\n        cout << left << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool simulate(const vector<int> &L, const vector< pair<int, int> > &vp, int T, int M){\n\tint N = vp.size();\n\tvector<int> lest(T+1, 0);\n\tvector<bool> ok(vp.size(), false);\n\tfor(int i=0;i<M;i++) lest[L[i]]++;\n\tint cnt = N-M;\n\tfor(int i=1;i<T;i++){\n\t\tif(cnt == 0) return true;\n\t\tif(lest[i]==0) continue;\n\t\tfor(int j=M;j<N;j++){\n\t\t\tif(ok[j]) continue;\n\t\t\tif(i%vp[j].second <= vp[j].first){\n\t\t\t\tif(i+L[j] > T) return false;\n\t\t\t\tcnt--;\n\t\t\t\tok[j] = true;\n\t\t\t\tlest[i]--;\n\t\t\t\tlest[i+L[j]]++; \n\t\t\t}\n\t\t\tif(lest[i] == 0) break;\n\t\t}\n\t\tlest[i+1] += lest[i];\n\t}\n\treturn cnt == 0;\n}\n\nint main(){\n\tint N, T;\n\twhile(cin >> N >> T, N){\n\t\tvector<int> L(N);\n\t\tvector< pair<int, int> > vp(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin >> L[i] >> vp[i].first >> vp[i].second;\n\t\t\tvp[i].second += vp[i].first;\n\t\t}\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(simulate(L, vp, T, i)){\n\t\t\t\tcout << i << endl; break;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nbool isCalling[1001];\nbool isTelling[1001];\nbool isFin[1001];\nint N,T;\nint Mi[1001];\nint Li[1001];\nint Ki[1001];\n\nclass Event{\npublic:\n    // 0->qªhang up\n    // 1->qªdbJn\n    // 2->operatorªdbðI¹\n    int kind;\n    int cid;\n    int time;\n    Event(int k,int c,int t){\n        kind=k,cid=c,time=t;\n    }\n    Event();\n    bool operator<(const Event &e)const{\n        if(this->time>e.time)return true;\n        else if(this->time<e.time)return false;\n        // kindªå«¢Ù¤ðDæ\n        if(this->kind<e.kind)return true;\n        else if(this->kind>e.kind)return false;\n        return(this->cid>e.cid);\n    }\n};\n\nbool check(int n){\n    if(n==0)return false;\n    memset(isCalling,0,sizeof(isCalling));\n    memset(isTelling,0,sizeof(isTelling));\n    memset(isFin,0,sizeof(isFin));\n    int opNum=n;\n    int cnt=0;\n    int finT=0;\n    priority_queue<Event> pq;\n    // qªdbðJn·éEventðo^µÄ¨­\n    for(int i=0;i<N;i++)pq.push(Event(1,i,0));\n    while(cnt!=N){\n        Event e=pq.top();pq.pop();\n        if(e.kind==1){\n            finT=e.time;\n            // àµopNum>0ÈçÎAÊbJnµAI¹eventðo^\n            if(opNum>0){\n                isTelling[e.cid]=true;\n                pq.push(Event(2,e.cid,Mi[e.cid]+finT));\n                opNum--;\n            }\n            // »¤ÅÈ¯êÎAÒ¿L[ÉÇÁ\n            else{\n                isCalling[e.cid]=true;\n                pq.push(Event(0,e.cid,Li[e.cid]+finT));\n            }\n        }\n        // ïbI¹\n        else if(e.kind==2){\n            cnt++;\n            finT=e.time;\n            opNum++;\n            isTelling[e.cid]=false;\n            // I¹tO\n            isFin[e.cid]=true;\n            // àµisCallingÈ¨ª¢êÎAdb(v¬»)\n            for(int i=0;i<N;i++){\n                if(isCalling[i]){\n                    isCalling[i]=false;\n                    isTelling[i]=true;\n                    opNum--;\n                    pq.push(Event(2,i,Mi[i]+finT));\n                    break;\n                }\n            }\n        }\n        // qªhang up\n        else{\n            // àµdbAÜ½ÍdbªI¹µÄ¢éÌÅ êÎA³\n            if(!(isFin[e.cid]||isTelling[e.cid])){\n                isCalling[e.cid]=false;\n                finT=e.time;\n                pq.push(Event(1,e.cid,Ki[e.cid]+finT));\n            }\n        }\n    }\n    return(finT<=T);\n}\n\nint main(){\n    while(cin>>N>>T&&(N|T)){\n        for(int i=0;i<N;i++)cin>>Mi[i]>>Li[i]>>Ki[i];\n        for(int i=1;i<=N;i++){\n            if(check(i)){\n                cout<<i<<endl;\n                break;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nstruct customer{\n  int state,t;\n  void change_state(int new_state){\n    state=new_state;\n    t=0;\n  }\n};\nenum{\n  Calling,\n  Talking,\n  Waiting,\n  Done,\n};\nint n,t;\nbool ok(vi &m,vi &l,vi &k,int o){\n  int open_operators=o;\n  vector<customer> customers(m.size());\n  int cur=0;\n  while(1){\n    int dt=INT_MAX/100;\n    REP(j,n){\n      customer &c=customers[j];\n      switch(c.state){\n        case Calling:\n          if(open_operators){\n            dt=0;\n          }else{\n            dt=min(dt,l[j]-c.t);\n          }\n          break;\n        case Talking:\n          dt=min(dt,m[j]-c.t);\n          break;\n        case Waiting:\n          dt=min(dt,k[j]-c.t);\n          break;\n      }\n    }\n    if(cur+dt>t){\n      break;\n    }\n    cur+=dt;\n    REP(j,n){\n      customers[j].t+=dt;\n    }\n    REP(j,n){\n      customer &c=customers[j];\n      switch(c.state){\n        case Talking:\n          if(c.t==m[j]){\n            c.change_state(Done);\n            open_operators++;\n          }\n          break;\n      }\n    }\n    REP(j,n){\n      customer &c=customers[j];\n      switch(c.state){\n        case Waiting:\n          if(c.t==k[j]){\n            c.change_state(Calling);\n          }\n          break;\n      }\n    }\n    REP(j,n){\n      customer &c=customers[j];\n      switch(c.state){\n        case Calling:\n          if(open_operators){\n            c.change_state(Talking);\n            open_operators--;\n          }else if(c.t==l[j]){\n            c.change_state(Waiting);\n          }\n          break;\n      }\n\n      /*\n      cerr<<cur<<\",\"<<j<<\": \";\n      cerr<<c.state<<\" \"<<c.t<<endl;\n      */\n    }\n  }\n  REP(i,n){\n    if(customers[i].state==Talking&&customers[i].t==m[i]){\n      continue;\n    }\n    if(customers[i].state!=Done){\n      return false;\n    }\n  }\n  return true;\n}\nint main(){\n  while(cin>>n>>t,n|t){\n    vi m(n),l(n),k(n);\n    REP(i,n){\n      cin>>m[i]>>l[i]>>k[i];\n    }\n\n//    ok(m,l,k,4);\n    int ans=INT_MAX/10;\n    FOR(i,1,n+1){\n      if(ok(m,l,k,i)){\n        ans=min(ans,i);\n      }\n      //cerr<<ok(m,l,k,i)<<endl;\n    }\n    cout<<ans<<endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n#define N 1010\nvector <int> ope;\nvector <int> ask;\nint vis[N],cur[N];\nint m[N],l[N],k[N];\nint n,t;\nbool work(int val){\n    //printf(\"%d\\n\",val);\n    memset(vis,0,sizeof(vis));\n    memset(cur,0,sizeof(cur));\n    for (int i=0;i<=t;i++){\n        ope.clear();\n        ask.clear();\n        for (int j=1;j<=val;j++)\n            if (vis[j]<=i) ope.push_back(j);\n        for (int j=1;j<=n;j++){\n            if (cur[j]) continue;\n            int tp=i%(l[j]+k[j]);\n            if (tp<=l[j]) ask.push_back(j);\n        }\n        //printf(\"%d %d %d\\n\",i,ope.size(),ask.size());\n        int num=min(ope.size(),ask.size());\n        for (int j=0;j<num;j++){\n            vis[ope[j]]=i+m[ask[j]]-1;\n            cur[ask[j]]=1;\n        }\n    }\n    for (int i=1;i<=val;i++)\n        if (vis[i]>t) return 0;\n    for (int i=1;i<=n;i++)\n        if (cur[i]==0) return 0;\n    return 1;\n}\nint main(){\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    while (scanf(\"%d%d\",&n,&t)==2){\n        if (n==0&&t==0) continue;\n        for (int i=1;i<=n;i++)\n            scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n        int l=1,r=n,mid,ans;\n        while (l<=r){\n            int mid=(l+r)/2;\n            if (work(mid)) {ans=mid;r=mid-1;}\n            else l=mid+1;\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,t,m[1000],l[1000],k[1000];\n\nbool check(int x){\n  int c[1001]={},used[1000]={},cnt=n;\n  for(int i=0;i<t;i++){\n    x+=c[i];\n    for(int j=0;j<n&&x;j++){\n      if(used[j])continue;\n      if(i+m[j]>t)return 0;\n      if(i%(l[j]+k[j])<=l[j])c[i+m[j]]++,cnt--,used[j]=1,x--;\n    }\n  }\n  return !cnt;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&t),n){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    int ans=0;\n    for(int i=1;i<=n&&!ans;i++)if(check(i))ans=i;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint N, T;\nstruct C{\n    int M, L, K;\n    C(int M, int L, int K):M(M),L(L),K(K){}\n};\nvector<C> customers;\n\nbool can(int n){\n    priority_queue<int> op;\n    vector<C> cust = customers;\n    bool done[1024] = {false};\n    rep(i,n) op.push(0);\n    while(-op.top() <= T){\n\tint tim = -op.top(); op.pop();\n\tint use = -1, dif = INF;\n//\tcerr << tim << endl;\n\tbool exist = false;\n\trepit(itr,cust)if(!*(done + (int)(itr - cust.begin()))){\n\t    int t = tim % (itr->L + itr->K);\n\t    int tmp = itr->L + itr->K - t;\n\t    if( tmp >= itr->K ) tmp = 0;\n\t    if(tmp < dif){\n\t\tuse = itr - cust.begin();\n\t\tdif = tmp;\n\t    }\n\t    exist = true;\n\t}\n\tif(!exist) return true;\n\tint tmp = -cust[use].M - dif - tim;\n\tif(tmp < -T) return false;\n\top.push(tmp);\n\tdone[use] = true;\n    }\n    return true;\n}\n\nint main()\n{\n    while(cin >> N >> T, N || T){\n\tcustomers.clear();\n\trep(i,N){\n\t    int m, l, k;\n\t    cin >> m >> l >> k;\n\t    customers.pb(C(m,l,k));\n\t}\n\trep(i,N)if(can(i+1)){\n\t    cout << i + 1 << endl;\n\t    break;\n\t}\n/*\n\twhile(lb + 1 < ub){\n\t    mid = (ub + lb) / 2;\n\t    if(can(mid)) ub = mid;\n\t    else lb = mid;\n\t    cerr << endl;\n\t}\n\tcout << ub << endl;\n*/\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 1003\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint n,t,m[M],l[M],k[M],add[M];\nbool used[M];\nbool ch(int x){\n  memset(add,0,sizeof(add));\n  memset(used,0,sizeof(used));\n  int cnt=0;\n  r(i,t+1){\n    x+=add[i];\n    r(j,n)if(!used[j]&&x){\n      int p=l[j]+k[j];\n      if((i%p<=l[j])&&m[j]+i<=t){\n        add[i+m[j]]++;\n\tused[j]=1;\n\tx--;\n\tcnt++;\n      }\n    }\n  }\n  return cnt==n;\n}\nint main(){\n  while(cin>>n>>t,t){\n    r(i,n)cin>>m[i]>>l[i]>>k[i];\n    r(i,M){\n      if(ch(i)){\n\tcout<<i<<endl;\n\tbreak;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <set>\nusing namespace std;\nint m[1000], l[1000], k[1000];\nint tim[1000];\nbool check(int p, int n, int t)\n{\n\tset <pair <int, int> > ev, ev2;\n\tmultiset <int> per;\n\tset <int> tod;\n\tfor (int i = 0; i < n; ++ i)\n\t\tev.insert(make_pair(0, i));\n\tint now = 0;\n\twhile (now <= t)\n\t{\n\t\tif (!per.empty() && *per.begin() == now)\n\t\t\tper.erase(now);\n\t\twhile (!ev.empty() && (*ev.begin()).first == now)\n\t\t{\n\t\t\tpair <int, int> tmp;\n\t\t\tint id = (*ev.begin()).second;\n\t\t\ttim[id] = tmp.first = (*ev.begin()).first + l[id];\n\t\t\ttmp.second = id;\n\t\t\tev2.insert(tmp);\n\t\t\ttod.insert(id);\n\t\t\tev.erase(ev.begin());\n\t\t}\n\t\twhile (!tod.empty() && (int) per.size() < p)\n\t\t{\n\t\t\tint id = *tod.begin();\n\t\t\tper.insert(now + m[id]);\n\t\t\ttod.erase(tod.begin());\n\t\t\tev2.erase(make_pair(tim[id], id));\n\t\t}\n\t\twhile (!ev2.empty() && (*ev2.begin()).first == now)\n\t\t{\n\t\t\tpair <int, int> tmp;\n\t\t\tint id = (*ev2.begin()).second;\n\t\t\ttmp.first = (*ev2.begin()).first + k[id];\n\t\t\ttmp.second = id;\n\t\t\tev.insert(tmp);\n\t\t\tev2.erase(ev2.begin());\n\t\t\ttod.erase(id);\n\t\t}\n\t\tif (ev.empty() && per.empty())\n\t\t\tbreak;\n\t\tnow = t + 1;\n\t\tif (!ev.empty())\n\t\t\tnow = min(now, (*ev.begin()).first);\n\t\tif (!ev2.empty())\n\t\t\tnow = min(now, (*ev2.begin()).first);\n\t\tif (!per.empty())\n\t\t\tnow = min(now, *per.begin());\n\t}\n\treturn now <= t;\n}\nint main()\n{\n\tint n, t;\n\twhile (scanf(\"%d%d\", &n, &t), n)\n\t{\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(\"%d%d%d\", &m[i], &l[i], &k[i]);\n\t\tint l = 1, r = n;\n\t\twhile (l < r)\n\t\t{\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (check(mid, n, t))\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <set>\n\nusing namespace std;\n\nbool isCalling[1001];\nbool isTelling[1001];\nbool isFin[1001];\nint N,T;\nint Mi[1001];\nint Li[1001];\nint Ki[1001];\n\nclass Event{\npublic:\n    // 0->qªhang up\n    // 1->qªdbJn\n    // 2->operatorªdbðI¹\n    int cid;\n    int time;\n    Event(int c,int t){\n        cid=c,time=t;\n    }\n    Event();\n    bool operator<(const Event &e)const{\n        return(this->time>e.time);\n    }\n};\ntypedef pair<int,int> pii;\n// nlÌIy[^ªvéÆ«ÌV~[V\nbool check(int n){\n    memset(isFin,0,sizeof(isFin));\n    priority_queue<Event> pq;\n    int curTime=0;\n    for(int i=0;i<n;i++){\n        pq.push(Event(i,Mi[i]));\n        isFin[i]=true;\n    }\n    // »Ýq}ÈopÌ\n    int opr=0;\n    int cnt=N;\n    priority_queue<pii> pqpi;\n    while(pq.size()){\n        // ¡ñÌCxgªI¹µ½opðæèo·\n        Event e=pq.top();pq.pop();\n        curTime=e.time;\n        cnt--;\n        opr++;\n        // óÅ©ÂÜ¾IíÁÄ¢È¢Cxgª¶Ý\n        if(pq.size()==0){\n            if(cnt!=0&&opr!=0){\n                while(pqpi.size())pqpi.pop();\n                // ÊbÂ\\ÉÈéÜÅª¢ÔÉÀ×é\n                for(int i=0;i<N;i++){\n                    if(isFin[i])continue;\n                    int a=e.time%(Ki[i]+Li[i]);\n                    if(a>=0&&a<=Li[i]){\n                        if(opr>0){\n                            pq.push(Event(i,curTime+Mi[i]));\n                            isFin[i]=true;\n                            opr--;\n                        }\n                    }\n                    else{\n                        int b=Ki[i]-(a-Li[i]);\n                        pqpi.push(make_pair(b,-i));\n                    }\n                }\n                // ÔÉæèo·\n                while(pqpi.size()&&opr){\n                    pii p=pqpi.top();pqpi.pop();\n                    opr--;\n                    pq.push(Event(-p.second,curTime+p.first+Mi[-p.second]));\n                    isFin[-p.second]=true;\n                }\n            }\n        }\n        // ñÌCxgªI¹·éÜÅÌÔÜÅÉAdbÂ\\ÔÉÈéàÌð·×Ä·\n        else{\n            if(opr==0)continue;\n            int neft=pq.top().time;\n            // ÊbÂ\\ÉÈéÜÅª¢ÔÉÀ×é\n            while(pqpi.size())pqpi.pop();\n            for(int i=0;i<N;i++){\n                if(isFin[i])continue;\n                int a=e.time%(Ki[i]+Li[i]);\n                if(a>=0&&a<=Li[i]){\n                    if(opr>0){\n                        pq.push(Event(i,curTime+Mi[i]));\n                        isFin[i]=true;\n                        opr--;\n                    }\n                }\n                else{\n                    int b=Ki[i]-(a-Li[i]);\n                    // ÊbÂ\\ÉÈéÔªneftæè¬³¢ÈçÎ\n                    if(b+curTime<neft)pqpi.push(make_pair(b,-i));\n                }\n            }\n            // ÔÉæèo·\n            while(pqpi.size()&&opr){\n                pii p=pqpi.top();pqpi.pop();\n                opr--;\n                pq.push(Event(-p.second,curTime+p.first+Mi[-p.second]));\n                isFin[-p.second]=true;\n            }\n        }\n    }\n    return curTime<=T;\n}\n\nint main(){\n    while(cin>>N>>T&&(N|T)){\n        for(int i=0;i<N;i++)cin>>Mi[i]>>Li[i]>>Ki[i];\n        for(int i=1;i<=N;i++){\n            if(check(i)){\n                cout<<i<<endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,t,m[1000],l[1000],k[1000];\n\nbool check(int x){\n  int c[1001]={},used[1000]={},cnt=n;\n  for(int i=0;i<t;i++,x+=c[i])\n    for(int j=0;j<n&&x;j++){\n      if(used[j])continue;\n      if(i+m[j]>t)return 0;\n      if(i%(l[j]+k[j])<=l[j])c[i+m[j]]++,cnt--,used[j]=1,x--;\n    }\n  return !cnt;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&t),n){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    int ans=0;\n    for(int i=1;i<=n&&!ans;i++)if(check(i))ans=i;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nstruct Call{\n    int m,l,k;\n    int finish;\n    int nextcall;\n}call[1010];\n\nint m,t;\n\nint gao(int n){\n    priority_queue<int, vector<int>, greater<int> > que;\n//    printf(\"n: %d\\n\",n);\n    int i;\n    for(i=0;i<n;i++){\n//        printf(\"push: %d\\n\",call[i].m);\n        que.push(call[i].m);\n        call[i].finish=1;\n    }\n    for(i=n;i<m;i++){\n        call[i].finish=0;\n        call[i].nextcall=0;\n    }\n    for(i=1;i<=t;i++){\n        int j;\n//        printf(\"time: %d\\n\",i);\n        for(j=0;j<m;j++){\n            if(call[j].finish==0 && call[j].nextcall<=i && call[j].nextcall+call[j].l>=i){\n                if(que.top()<=i){\n                    que.pop();\n                    que.push(i+call[j].m);\n                    call[j].finish=1;\n//                    printf(\"finish:%d\\n\",j);\n                }else{\n                    if(call[j].nextcall+call[j].l==i){\n                        call[j].nextcall=i+call[j].k;\n//                        printf(\"next: %d top: %d\\n\",j,que.top());\n                    }\n                }\n            }\n        }\n    }\n    for(i=0;i<m;i++){\n//        printf(\"%d,%d\\n\",call[i].finish,call[i].nextcall);\n        if(call[i].finish==0) return 0;\n    }\n    for(i=0;i<n;i++){\n        if(que.top()>t) return 0;\n        que.pop();\n    }\n    return 1;\n}\n\nint main(void){\n    while(1){\n        scanf(\"%d%d\",&m,&t);\n        if(m==0 && t==0) break;\n        int i;\n        for(i=0;i<m;i++) scanf(\"%d%d%d\",&call[i].m,&call[i].l,&call[i].k);\n        \n        for(i=1;i<=m;i++){\n            if(gao(i)){\n                printf(\"%d\\n\",i);\n                break;\n            }\n        }\n        \n//        int l=0,r=m;\n//        while(l!=r){\n//            int mid=(l+r)/2;\n//            int re=gao(mid);\n//            if(re==0) l=mid+1;\n//            else r=mid;\n//            printf(\"  %d %d\\n\",re,mid);\n//        }\n//        printf(\"%d\\n\",r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 1010;\n\nint n,t;\nint M[N],L[N],K[N];\nint mod[N];\n\nint c[N];\nint ed[N];\n\nconst int INF = 191919;\ninline bool check(int x){\n    fill(c,c+N,INF);\n    fill(ed,ed+N,0);\n    int op = x;\n\n    rep(i,t+1){\n        // end operation\n        op += ed[i];\n\n        rep(j,n)if(c[j]==INF){\n            if(i+M[j]>t) return false;\n\n            int mt = i%mod[j];\n            if(mt<=L[j] && op>0){\n                --op;\n                int et = i+M[j];\n                c[j] = et;\n\n                if(et<=t) ++ed[et];\n            }\n        }\n    }\n\n    rep(i,n)if(c[i]>t) return false;\n    return true;\n}\n\nint main(){\n    while(scanf(\" %d %d\", &n, &t),n){\n        rep(i,n){\n            scanf(\" %d %d %d\", &M[i], &L[i], &K[i]);\n            mod[i] = (L[i]+K[i]);\n        }\n\n        int ok=1;\n        while(ok<=n && !check(ok)) ++ok;\n        printf(\"%d\\n\",ok);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,t,m[1000],l[1000],k[1000];\n\nbool check(int x){\n  int c[1001]={},used[1000]={},cnt=n;\n  for(int i=0;i<t;i++){\n    x+=c[i];\n    for(int j=0;j<n&&x;j++){\n      if(used[j])continue;\n      if(i+m[j]>t)return 0;\n      if(i%(l[j]+k[j])<=l[j])c[i+m[j]]++,cnt--,used[j]=1,x--;\n    }\n  }\n  return !cnt;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&t),n){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    int ans=0;\n    for(int i=1;i<=n&&!ans;i++)if(check(i))ans=i;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct cust {\n\tint  m;\n\tint l;\n\tint k;\n};\n \nstruct query {\n\tint type;\n\tint time;\n\tint id;\n};\nstruct aa {\n\tint id;\n\tint time;\n};\nclass Compare {\npublic:\n\tbool operator()(const query&l,const query&r) {\n\t\treturn l.time==r.time?l.type==r.type?l.id>r.id:l.type>r.type:l.time > r.time;\n\t}\n\tbool operator()(const aa&l, aa&r) {\n\t\treturn l.time > r.time;\n\t}\n};\n\nbool check(const int T, const vector<cust>&cus, const int n) {\n\tint waitnum = n;\n\tpriority_queue<query,vector<query>,Compare>que;\n\t//vector<int>waits(cus.size());\n\tset<int>waits;\n\tfor (int i = 0; i < cus.size(); ++i) {\n\t\tque.push(query{ 0,0,i });\n\t}\n\twhile (!que.empty()) {\n\t\tquery q(que.top());\n\t\tque.pop();\n\t\tif (q.type == 1) {\n\t\t\tauto it = waits.begin();\n\t\t\tif (it == waits.end()) {\n\t\t\t\twaitnum++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst int cid = *it;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\twaits.erase(it);\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}\n\t\t\t\telse if (nexttime == T) {\n\t\t\t\t\twaits.erase(it);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\telse if (q.type == 0) {\n\t\t\tconst int cid = q.id;\n\t\t\tif (waitnum) {\n\t\t\t\twaitnum--;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}\n\t\t\t\telse if (nexttime == T) {\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\twaits.emplace(cid);\n\t\t\t\tconst int nexttime = q.time + cus[cid].l;\n\t\t\t\tque.push(query{ 2,nexttime,cid });\n\t\t\t}\n\t\t}\n\t\telse if (q.type == 2) {\n\t\t\tconst int cid = q.id;\n\t\t\tauto it = waits.find(cid);\n\t\t\tif (it!=waits.end()) {\n\t\t\t\twaits.erase(it);\n\t\t\t\tconst int nexttime = q.time + cus[cid].k;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\tque.push(query{ 0,nexttime,cid });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, T; cin >> N >> T;\n\t\tif (!N)break;\n\t\tvector<cust>cus;\n\t\tint totalm = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint m, l, k; cin >> m >> l >> k;\n\t\t\ttotalm += m;\n\t\t\tcus.push_back(cust{ m,l,k });\n\t\t}\n\t\t/*int amin = 0;\n\t\tint amax = N;\n\t\twhile (amin + 1 != amax) {\n\t\t\tint amid = (amin + amax) / 2;\n\t\t\tif (check(T, cus, amid)) {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t}\n\t\tcout << amax << endl;*/\n\t\tint ans = 0;\n\t\tint amin = (totalm-1) / T + 1;\n\t\tfor (int n = amin; n <= N; ++n) {\n\t\t\tif (check(T, cus, n)) {\n\t\t\t\tans = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N,T;\nint M[1000],L[1000],K[1000];\n\nint flg[1000];\nbool used[1000];\n\nbool check(int x){\n  fill(flg,flg+x,0);\n  fill(used,used+N,false);\n  for(int t=0;t<=T;t++){\n    for(int i=0;i<x;i++){\n      if(flg[i]>t)continue;\n      for(int j=0;j<N;j++){\n        if(used[j])continue;\n        int f=t%(L[j]+K[j]);\n        if(L[j]<f)continue;\n        used[j]=true;\n        flg[i]=t+M[j];\n        break;\n      }\n    }\n    int mini=1e9;\n    for(int j=0;j<N;j++){\n      if(used[j])continue;\n      int f=t%(L[j]+K[j]);\n      if(L[j]<f){\n        mini=min(mini,K[j]-(f-L[j]));\n      }else mini=0;\n    }\n    int mini2=1e9;\n    for(int j=0;j<x;j++){\n      if(flg[j]>t)mini2=min(mini2,flg[j]-t);\n      else mini2=0;\n    }\n    t+=max(0,max(mini,mini2)-1);\n  }\n  for(int i=0;i<N;i++)if(!used[i])return false;\n  for(int i=0;i<x;i++)if(flg[i]>T)return false;\n  return true;\n}\n\nint main(){\n  while(1){\n    cin>>N>>T;\n    if(N==0&&T==0)break;\n    for(int i=0;i<N;i++)\n      cin>>M[i]>>L[i]>>K[i];\n\n    \n    int ans=N;\n    for(int i=1;i<N;i++){\n      if(check(i)){\n        ans=i;\n        break;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n\n#define LL long long\n#define eps le-10\n#define maxn 100100\n#define inf 1e7\n#define ls v<<1\n#define rs v<<1|1\n\nLL min(LL a,LL b){return a>b?b:a;}\nLL max(LL a,LL b){return a>b?a:b;}\nLL absi(LL a){return a>0?a:-a;}\ndouble abslf(double a){return a>0.0?a:-a;}\n\n\nstruct AA{\n\tLL m,l,k,cnt,sum,now;\n}A[1100];\n\nint main()\n{\n\tLL n,t;\n\tlong long i,j;\n\twhile(scanf(\"%lld%lld\",&n,&t)!=EOF){\n\t\tif(!n || !t) break;\n\t\tLL sum=0,now=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%lld%lld%lld\",&A[i].m,&A[i].l,&A[i].k);\n\t\t\tA[i].now=0;\n\t\t\tA[i].cnt=0;\n\t\t\tA[i].sum=A[i].m/A[i].l+(A[i].m%A[i].l?1:0);\n\t\t\tsum+=A[i].sum;\n\t\t}\n\t\tfor(i=0;i<sum;){\n\t\t\tLL res=-1;\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(A[j].now<=now &&A[j].cnt<A[j].sum){\n\t\t\t\t\tif(A[j].m<A[j].l) now+=A[j].m;\n\t\t\t\t\telse now+=A[j].l;\n\t\t\t\t\tA[j].now=now+A[j].k;\n\t\t\t\t\tA[j].cnt++;\n\t\t\t\t\tres=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res!=-1) i++;\n\t\t\telse{\n\t\t\t\tLL re=1e17;\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif(A[j].now>now && A[j].cnt<A[j].sum) re=min(re,A[j].now);\n\t\t\t\t}\n\t\t\t\tnow=re;\n\t\t\t}\n\t\t\t//printf(\"%lld @@@@\\n\",now);\n\t\t}\n\t\tLL ans=now/t;\n\t\tif(now%t) ans++;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n/*\n3 300\n100 50 150\n100 50 150\n100 50 150\n3 300\n100 50 150\n100 50 150\n200 50 150\n9 18\n3 1 1\n3 1 1\n3 1 1\n4 100 1\n5 100 1\n5 100 1\n10 5 3\n10 5 3\n1 7 1000\n10 18\n1 2 3\n2 3 4\n3 4 5\n4 5 6\n5 6 7\n6 7 8\n7 8 9\n8 9 10\n9 10 11\n10 11 12\n0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"cstring\"\n#include \"cstdio\"\n#include \"vector\"\nusing namespace std;\nconst int N = 2010;\nint vis[N], M[N], L[N], K[N], v[N];\nint n, T;\nbool gao(int x)\n{\n\tmemset(v, 0, sizeof(v));\n\tmemset(vis, 0, sizeof(vis));\n\tv[0] = x;\n\tfor(int i = 0; i <= T; ++ i){\n\t\tif(i != 0) v[i] += v[i - 1];\n\t\tfor(int j = 1; j <= n; ++ j){\n\t\t\tif(v[i] == 0) break;\n\t\t\tif(vis[j]) continue;\n\t\t\tif(i % (L[j] + K[j]) <= L[j] && i + M[j] <= T){\n\t\t\t\tv[i] --;\n\t\t\t\tv[i + M[j]] ++;\n\t\t\t\tvis[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i){\n\t\tif(vis[i] == 0) return false;\n\t}\n\treturn true;\n}\n\t\t\t\t\nint main(void)\n{\n\twhile(scanf(\"%d %d\", &n, &T) && (n || T)){\n\t\tfor(int i = 1; i <= n; ++ i){\n\t\t\tscanf(\"%d %d %d\", &M[i], &L[i], &K[i]);\n\t\t}\n\t\tfor(int i = 1; i <= n; ++ i){\n\t\t\tif(gao(i)){\n\t\t\t\tcout << l << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define M 1005\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint n,t,m[M],l[M],k[M],add[M];\nbool used[M];\nbool ch(int x){\n  memset(add,0,sizeof(add));\n  memset(used,0,sizeof(used));\n  int cnt=0;\n  r(i,t+1){\n    x+=add[i];\n    r(j,n)if(!used[j]&&x){\n      int p=l[j]+k[j];\n      if(i%p<=l[j]&&m[j]+i<M){\n        add[i+m[j]]++;\n\tused[j]=1;\n\tx--;\n\tcnt++;\n      }\n    }\n  }\n  return cnt==n;\n}\nint main(){\n  while(cin>>n>>t,t){\n    r(i,n)cin>>m[i]>>l[i]>>k[i];\n    r(i,M){\n      if(ch(i)){\n\tcout<<i<<endl;\n\tbreak;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct cust {\n\tint  m;\n\tint l;\n\tint k;\n};\n \nstruct query {\n\tint type;\n\tint time;\n\tint id;\n};\nstruct aa {\n\tint id;\n\tint time;\n};\nclass Compare {\npublic:\n\tbool operator()(const query&l,const query&r) {\n\t\treturn l.time==r.time?l.type==r.type?l.id>r.id:l.type>r.type:l.time > r.time;\n\t}\n\tbool operator()(const aa&l, aa&r) {\n\t\treturn l.time > r.time;\n\t}\n};\n\nbool check(const int T, const vector<cust>&cus, const int n) {\n\tint waitnum = n;\n\tpriority_queue<query,vector<query>,Compare>que;\n\tvector<int>waits(cus.size());\n\tfor (int i = 0; i < cus.size(); ++i) {\n\t\tque.push(query{ 0,0,i });\n\t}\n\twhile (!que.empty()) {\n\t\tquery q(que.top());\n\t\tque.pop();\n\t\tif (q.type == 1) {\n\t\t\tauto it = find(waits.begin(), waits.end(), 1);\n\t\t\tif (it == waits.end()) {\n\t\t\t\twaitnum++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst int cid = it - waits.begin();\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\t*it = false;\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}\n\t\t\t\telse if (nexttime == T) {\n\t\t\t\t\t*it = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\telse if (q.type == 0) {\n\t\t\tconst int cid = q.id;\n\t\t\tif (waitnum) {\n\t\t\t\twaitnum--;\n\t\t\t\tconst int nexttime = q.time + cus[cid].m;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\tque.push(query{ 1,nexttime,0 });\n\t\t\t\t}\n\t\t\t\telse if (nexttime == T) {\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\twaits[cid] = true;\n\t\t\t\tconst int nexttime = q.time + cus[cid].l;\n\t\t\t\tque.push(query{ 2,nexttime,cid });\n\t\t\t}\n\t\t}\n\t\telse if (q.type == 2) {\n\t\t\tconst int cid = q.id;\n\t\t\tif (waits[cid]) {\n\t\t\t\twaits[cid] = false;\n\t\t\t\tconst int nexttime = q.time + cus[cid].k;\n\t\t\t\tif (nexttime < T) {\n\t\t\t\t\tque.push(query{ 0,nexttime,cid });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, T; cin >> N >> T;\n\t\tif (!N)break;\n\t\tvector<cust>cus;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint m, l, k; cin >> m >> l >> k;\n\t\t\tcus.push_back(cust{ m,l,k });\n\t\t}\n\t\t/*int amin = 0;\n\t\tint amax = N;\n\t\twhile (amin + 1 != amax) {\n\t\t\tint amid = (amin + amax) / 2;\n\t\t\tif (check(T, cus, amid)) {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t}\n\t\tcout << amax << endl;*/\n\t\tint ans = 0;\n\t\tfor (int n = 1; n <= N; ++n) {\n\t\t\tif (check(T, cus, n)) {\n\t\t\t\tans = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, T;\nint M[1005], L[1005], K[1005];\nint used[1005], add[1005];\n\nbool check(int x){\n  \n  int res=0;\n  \n  memset(used,0,sizeof(used));\n  memset(add,0,sizeof(add));\n  \n  for(int i=0;i<=T;i++){\n    \n    x+=add[i];\n    \n    for(int j=0;j<N;j++){\n      \n      if(x==0) break;\n      \n      if(used[j]) continue;\n      \n      int mod=L[j]+K[j];\n      \n      if((i%mod<=L[j])&&i+M[j]<=T){\n\tx--;\n\tadd[i+M[j]]++;\n\tused[j]=1;\n\tres++;\n      }      \n      \n    }\n    \n  }\n  \n  return res==N;\n}\n\nvoid solve(){\n  \n  int l=0, r=1000005;\n  \n  while(l<r){\n    \n    int m=(l+r)/2;\n    \n    if(!check(m)) l=m+1;\n    else r=m;\n    \n  }\n  \n  cout<<l<<endl;\n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>N>>T;\n    if(!N&&!T) break;\n    \n    for(int i=0;i<N;i++) scanf(\"%d %d %d\", &M[i], &L[i], &K[i]);\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint n,T,talk[1000],call[1000],wait[1000];\n\nbool solve(int p){\n\tpriority_queue<int> pq;\n\trep(i,p) pq.push(0);\n\n\tint n_cus=0;\n\tbool cus[1000]={};\n\twhile(!pq.empty()){\n\t\tint t=-pq.top(); pq.pop();\n\n\t\tint i,next=T+1;\n\t\tfor(i=0;i<n;i++) if(!cus[i]) {\n\t\t\tint total=call[i]+wait[i];\n\t\t\tif(t%total<=call[i]) break;\n\t\t\telse next=min(next,t+total-t%total);\n\t\t}\n\t\tif(i<n){\n\t\t\tn_cus++;\n\t\t\tcus[i]=true;\n\n\t\t\tif(t+talk[i]<=T) pq.push(-(t+talk[i]));\n\t\t\telse return false;\n\n\t\t\tif(n_cus==n) return true;\n\t\t}\n\t\telse{\n\t\t\tif(next<=T) pq.push(-next);\n\t\t\telse return false;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&n,&T),n;){\n\t\trep(i,n) scanf(\"%d%d%d\",talk+i,call+i,wait+i);\n\n\t\tint p;\n\t\tfor(p=1;!solve(p);p++);\n\n\t\tprintf(\"%d\\n\",p);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint main() {\n  int n,t;\n  while(cin >> n >> t && n) {\n    PP a[n];\n    for(int i=0; i<n; i++) {\n      cin >> a[i].F.F >> a[i].S.F >> a[i].S.S;\n      a[i].F.S=i;\n    }\n    for(int m=1; m<=n; m++) {\n      bool f=0;\n      int b[n],c[t+1],cnt=0;\n      memset(b,0,sizeof(b));\n      memset(c,0,sizeof(c));\n      c[0]=m;\n      for(int k=0; k<t; k++) {\n        for(int i=0; i<n; i++) {\n          if(b[i]==-1) continue;\n          if(c[k]&&b[i]<=k&&k<=b[i]+a[i].S.F) {\n            if(k+a[i].F.F>t) break;\n            c[k]--;\n            c[k+a[i].F.F]++;\n            b[i]=-1;\n            cnt++;\n          } else if(b[i]+a[i].S.F==k) b[i]=k+a[i].S.S;\n        }\n        if(cnt==n) {\n          f=1;\n          break;\n        }\n        c[k+1]+=c[k];\n      }\n      if(f) {\n        cout << m << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n#define N 1010\nvector <int> ope;\nvector <int> ask;\nint vis[N],cur[N];\nint m[N],l[N],k[N];\nint n,t;\nbool work(int val){\n    //printf(\"%d\\n\",val);\n    memset(vis,0,sizeof(vis));\n    memset(cur,0,sizeof(cur));\n    for (int i=0;i<=t;i++){\n        ope.clear();\n        ask.clear();\n        for (int j=1;j<=val;j++)\n            if (vis[j]<=i) ope.push_back(j);\n        for (int j=1;j<=n;j++){\n            if (cur[j]) continue;\n            int tp=i%(l[j]+k[j]);\n            if (tp<=l[j]) ask.push_back(j);\n        }\n        //printf(\"%d %d %d\\n\",i,ope.size(),ask.size());\n        int num=min(ope.size(),ask.size());\n        for (int j=0;j<num;j++){\n            vis[ope[j]]=i+m[ask[j]];\n            cur[ask[j]]=1;\n        }\n    }\n    for (int i=1;i<=val;i++)\n        if (vis[i]>t) return 0;\n    for (int i=1;i<=n;i++)\n        if (cur[i]==0) return 0;\n    return 1;\n}\nint main(){\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    while (scanf(\"%d%d\",&n,&t)==2){\n        if (n==0&&t==0) continue;\n        for (int i=1;i<=n;i++)\n            scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n        int l=1,r=n,mid,ans;\n        while (l<=r){\n            int mid=(l+r)/2;\n            if (work(mid)) {ans=mid;r=mid-1;}\n            else l=mid+1;\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,t,m[1000],l[1000],k[1000];\n\nbool check(int x){\n  int c[1001]={},used[1000]={},cnt=n;\n  for(int i=0;i<t&&cnt;i++){\n    x+=c[i];\n    for(int j=0;j<n&&x;j++){\n      if(used[j])continue;\n      if(i+m[j]>t)return 0;\n      if(i%(l[j]+k[j])<=l[j])c[i+m[j]]++,cnt--,used[j]=1,x--;\n    }\n  }\n  return !cnt;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&t),n){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    int ans=0;\n    for(int i=1;i<=n&&!ans;i++)if(check(i))ans=i;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define maxn 3000000\nusing namespace std;\nint i,j,k,n,m,x,y,z,t,now,tt,f[1500],d[1500],flag,l,r,mid,nn;\n\nstruct node{\n\tint x,y,z,w;\n} a[maxn];\n\nbool cmp(struct node a,struct node b)\n{\n\tif (a.x<b.x) return true;\n\tif (a.x>b.x) return false;\n\tif (a.w<b.w) return true;\n\treturn false;\n}\n\nbool check(int x)\n{\n\tint i,j,k,now,tmp;\n\tnow=0;\n\tmemset(d,0,sizeof(d));\n\tmemset(f,0,sizeof(f));\n\tfor(i=0;i<tt;i++)\n\t\t{\n\t\t\tif (f[a[i].w]==0)\n\t\t\t{\n\t\t\t\tf[a[i].w]=1;\n\t\t\t\tflag=-1;z=-1;\n\t\t\t\tfor(j=1;j<=now;j++)\n\t\t\t\t{\n\t\t\t\t\tif ((d[j]<=a[i].x)&&(d[j]>=flag)) \n\t\t\t\t\t{\n\t\t\t\t\t\tflag=d[j];\n\t\t\t\t\t\tz=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag==-1) flag=9999999;\n\t\t\t\tif ((flag<=a[i].x+a[i].y)&&(max(flag,a[i].x)+a[i].z<=t))\n\t\t\t\t{\n\t\t\t\t\td[z]=max(flag,a[i].x)+a[i].z;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ((now<x)&&(a[i].x+a[i].z<=t))\n\t\t\t\t\t{\n\t\t\t\t\t\tnow++;\n\t\t\t\t\t\td[now]=a[i].x+a[i].z;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tflag=2147483647;z=-1;\n\t\t\t\t\t\tfor(j=1;j<=now;j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (d[j]<flag) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflag=d[j];\n\t\t\t\t\t\t\t\tz=j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((flag<=a[i].x+a[i].y)&&(max(flag,a[i].x)+a[i].z<=t))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\td[z]=max(flag,a[i].x)+a[i].z;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse f[a[i].w]=0;\n\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t}\n\n\t\t\t\n\t\tfor(i=1;i<=n;i++)\n\t\t if (f[i]==0) return false;\n\t\t return true;\n}\n\nint main()\n{\n\t\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d\",&n,&t);\n\t\tif ((n==0)&&(t==0)) break;\n\t\tmemset(a,0,sizeof(a));\n\t\ttt=0;\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tnow=0;\n\t\t\twhile(now<=t)\n\t\t\t{\n\t\t\t\ta[tt].x=now;\n\t\t\t\ta[tt].y=y;\n\t\t\t\ta[tt].z=x;\n\t\t\t\ta[tt].w=i+1;\n\t\t\t\tnow+=(y+z);\n\t\t\t\ttt++;\n\t\t\t}\n\t\t}\n\t\tnow=0;\n\t\tsort(a,a+tt,cmp);\n\t\tfor(mid=1;mid<=n;mid++)\n\t\t\tif (check(mid)) break;\n\t\n\t\tnn=mid;\n\t\tprintf(\"%d\\n\",nn);\n\t}\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 1001\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint n,t,m[M],l[M],k[M],add[M];\nbool used[M];\nbool ch(int x){\n  memset(add,0,sizeof(add));\n  memset(used,0,sizeof(used));\n  int cnt=0;\n  r(i,t+1){\n    x+=add[i];\n    r(j,n)if(!used[j]&&x){\n      int p=l[j]+k[j];\n      if(i%p<=l[j]&&m[j]+i<M){\n        add[i+m[j]]++;\n\tused[j]=1;\n\tx--;\n\tcnt++;\n      }\n    }\n  }\n  return cnt==n;\n}\nint main(){\n  while(cin>>n>>t,t){\n    r(i,n)cin>>m[i]>>l[i]>>k[i];\n    r(i,M){\n      if(ch(i)){\n\tcout<<i<<endl;\n\tbreak;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,t,m[1000],l[1000],k[1000];\n\nbool check(int x){\n  int c[1001]={},used[1000]={},cnt=0;\n  for(int i=0;i<t;i++){\n    x+=c[i];\n    for(int j=0;j<n&&x;j++){\n      if(used[j])continue;\n      if(i+m[j]>t)return 0;\n      if(i%(l[j]+k[j])<=l[j])c[i+m[j]]++,cnt++,used[j]=1,x--;\n    }\n  }\n  return cnt==n;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&t),n){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    int ans=0;\n    for(int i=1;i<=n&&!ans;i++)if(check(i))ans=i;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <set>\nusing namespace std;\nint m[1000], next[1000], hang[1000];\nint tim[1000], last[1000];\nbool vis[1000];\nbool check(int p, int n, int t)\n{\n\tmemset(vis, 0, n);\n\tmemset(tim, 0, 4 * p);\n\tmemset(last, 0, 4 * n);\n\tint ret = 0;\n\tfor (int i = 0; i <= t; ++ i)\n\t{\n\t\tfor (int j = 0, k = 0; j < p && k < n; ++ j)\n\t\t\tif (tim[j] <= i)\n\t\t\t{\n\t\t\t\twhile (k < n && (last[k] > i || last[k] + hang[k] < i || vis[k] == 1))\n\t\t\t\t\t++ k;\n\t\t\t\tif (k < n)\n\t\t\t\t{\n\t\t\t\t\ttim[j] = i + m[k];\n\t\t\t\t\tif (tim[j] > t)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tvis[k] = 1;\n\t\t\t\t\t++ ret;\n\t\t\t\t}\n\t\t\t}\n\t\tfor (int k = 0; k < n; ++ k)\n\t\t\tif (!vis[k] && last[k] + hang[k] <= i)\n\t\t\t\tlast[k] += hang[k] + next[k];\n\t}\n\treturn ret == n;\n}\nint main()\n{\n\tint n, t;\n\twhile (scanf(\"%d%d\", &n, &t), n)\n\t{\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(\"%d%d%d\", &m[i], &hang[i], &next[i]);\n\t\tint l = 1, r = n;\n\t\twhile (l < r)\n\t\t{\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (check(mid, n, t))\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define iss istringstream\n#define sst stringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint N,T,M[1010],L[1010],K[1010],a[1010];\n\nint main(){\n\twhile(cin>>N>>T&&N){\n\t\trep(i,N)cin>>M[i]>>L[i]>>K[i];\n\t\trep2(P,1,N+1){\n\t\t\tfill(a,a+N,0);\n\t\t\tint t=0,d=0;\n\t\t\tmultiset<int> S;\n\t\t\trep(i,P)S.insert(0);\n\t\t\twhile(d<N&&t<=T){\n\t\t\t\tint nx=-1;\n\t\t\t\trep(i,N)if(!a[i]&&t%(L[i]+K[i])<=L[i]){nx=i;break;}\n\t\t\t\tif(nx>-1&&*S.begin()<=t)a[nx]=1,d++,S.erase(S.begin()),S.insert(t+M[nx]);\n\t\t\t\telse{t++;continue;}\n\t\t\t}\n\t\t\tif(d==N){cout<<P<<endl;break;}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nint main() {\n    int n, t;\n    while(cin >> n >> t, n) {\n        vector<int> m(n), l(n), k(n);\n        for(int i = 0; i < n; ++i) {\n            cin >> m[i] >> l[i] >> k[i];\n        }\n\n        auto check = [&] (int num) {\n            vector<int> restore(t + 1);\n            list<int> ls;\n            for(int i = 0; i < n; ++i) ls.push_back(i);\n            int remain = num;\n            for(int i = 0; i <= t; ++i) {\n                remain += restore[i];\n                auto it = ls.begin();\n                while(remain > 0 && it != ls.end()) {\n                    const int idx = *it;\n                    if(i % (l[idx] + k[idx]) <= l[idx]) {\n                        --remain;\n                        if(i + m[idx] > t) return false;\n                        restore[i + m[idx]] += 1;\n                        it = ls.erase(it);\n                    } else {\n                        ++it;\n                    }\n                }\n            }\n            return ls.empty();\n        };\n        for(int i = 1; i <= n; ++i) {\n            if(check(i)) {\n                cout << i << endl;\n                break;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <climits>\n#include <deque>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nint m[1000];\nint l[1000];\nint k[1000];\n\nint main(){\n  while(true){\n    int n = getInt();\n    int t = getInt();\n\n    if(n + t == 0) break;\n\n    REP(i,n){\n      m[i] = getInt();\n      l[i] = getInt();\n      k[i] = getInt();\n    }\n\n    for(int p = 1; ; p++){\n      vector<bool> ok(n, false);\n      int cnt = 0;\n      priority_queue<int> op;\n\n      REP(i,p) op.push(0);\n\n      while(op.size() && cnt != n){\n\tint tm = - op.top(); op.pop();\n\n\tif(tm >= t) break;\n\n\tpair<int, int> process = make_pair(INT_MAX, INT_MAX);\n\n\tint tmp = 0;\n\n\tREP(i,n) if(!ok[i]){\n\t  int next;\n\t  if(tm % (l[i] + k[i]) <= l[i]) next = tm;\n\t  else next = (l[i] + k[i]) * ((tm + k[i]) / (l[i] + k[i]));\n\t  process = min(process, make_pair(next, i));\n\t  tmp += m[i];\n\t}\n\n\tif(tmp > p * (t - tm)) break;\n\n\tif(process.first != INT_MAX){\n\t  if(process.first + m[process.second] <= t){\n\t    op.push(- (process.first + m[process.second]));\n\t    ok[process.second] = true;\n\t    cnt++;\n\t  }else{\n\t    break;\n\t  }\n\t}\n      }\n\n      if(cnt == n){\n\tprintf(\"%d\\n\", p);\n\tbreak;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nint n, t;\nvector<int> m, l, k;\n\nbool solve(int ope)\n{\n    multiset<int> ms;\n    for(int i=0; i<ope; ++i)\n        ms.insert(0);\n\n    vector<bool> check(n, false);\n    for(int i=0; i<n; ++i){\n        int currTime = *ms.begin();\n        ms.erase(ms.begin());\n\n        int minTime = INT_MAX;\n        int select;\n        for(int j=0; j<n; ++j){\n            if(check[j])\n                continue;\n            int time = currTime / (l[j] + k[j]) * (l[j] + k[j]);\n            if(currTime > time + l[j])\n                time += l[j] + k[j];\n            else\n                time = currTime;\n            if(time < minTime){\n                select = j;\n                minTime = time;\n            }\n        }\n\n        check[select] = true;\n        ms.insert(minTime + m[select]);\n    }\n\n    if(*ms.rbegin() > t)\n        return false;\n    else\n        return true;\n}\n\nint main()\n{\n    for(;;){\n        cin >> n >> t;\n        if(n == 0)\n            return 0;\n\n        m.resize(n);\n        l.resize(n);\n        k.resize(n);\n        for(int i=0; i<n; ++i)\n            cin >> m[i] >> l[i] >> k[i];\n\n        int ret = 1;\n        while(!solve(ret))\n            ++ ret;\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 1001\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint n,t,m[M],l[M],k[M],add[M];\nbool used[M];\nbool ch(int x){\n  memset(add,0,sizeof(add));\n  memset(used,0,sizeof(used));\n  int cnt=0;\n  r(i,t+1){\n    x+=add[i];\n    r(j,n)if(!used[j]){\n      int p=l[j]+k[j];\n      if(i%p<=l[j]&&x){\n\tif(m[j]+i<M)add[i+m[j]]++;\n\tused[j]=1;\n\tx--;\n\tcnt++;\n      }\n    }\n  }\n  return cnt==n;\n}\nint main(){\n  while(cin>>n>>t,t){\n    r(i,n)scanf(\"%d%d%d\",&m[i],&l[i],&k[i]);\n    r(i,M){\n      if(ch(i)){\n\tcout<<i<<endl;\n\tbreak;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, T;\nint M[1005], L[1005], K[1005];\nint used[1005], add[1005];\n\nbool check(int x){\n  \n  memset(used,0,sizeof(used));\n  memset(add,0,sizeof(add));\n  \n  for(int i=0;i<=T;i++){\n    \n    x+=add[i];\n    \n    for(int j=0;j<N;j++){\n      \n      if(x==0) break;\n      \n      if(used[j]) continue;\n      \n      int mod=L[j]+K[j];\n      \n      if((i%mod<=L[j])&&i+M[j]<=T){\n\tx--;\n\tadd[i+M[j]]++;\n\tused[j]=1;\n      }      \n      \n    }\n\n  }\n  \n  int res=0;\n  for(int i=0;i<N;i++) res+=used[i];\n  \n  return res==N;\n}\n\nvoid solve(){\n  \n  /*int l=0, r=1005;\n  \n  while(l<r){\n    \n    int m=(l+r)/2;\n    \n    if(!check(m)) l=m+1;\n    else r=m;\n    \n    }*/\n  \n  //for(int i=0;i<=N;i++) cout<<check(i)<<' ';\n  //  cout<<endl;\n  //  cout<<l<<endl;\n\n  for(int i=0;i<=1000;i++)\n    if(check(i)){\n      cout<<i<<endl;\n      return;\n    }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>N>>T;\n    if(!N&&!T) break;\n    \n    for(int i=0;i<N;i++) scanf(\"%d %d %d\", &M[i], &L[i], &K[i]);\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <cmath>\n\nusing namespace std;\nint n,T;\n#define call 0\n#define wait 1\n#define serve 2\nstruct Customer\n{\n    int t[3];\n    int state;\n    bool over;\n}p[100010];\nint M[10000],L[10000],K[10000];\nbool Judge(int tot)\n{\n    int num=tot;\n    for(int j=1;j<=n;j++)\n        p[j].over=false;\n    for(int j=1;j<=n;j++)\n    {\n        p[j].state=call;\n        for(int i=0;i<3;i++)\n            p[j].t[i]=0;\n    }\n\n    int cnt=0;\n    for(int i=0;i<=T;i++)\n    {\n        for(int j=1;j<=n;j++)\n        if(!p[j].over)\n        {\n            if(p[j].state==serve)\n                if(p[j].t[serve]==M[j])\n                {\n                    num++;\n                    p[j].t[0]=0;\n                    p[j].t[1]=0;\n                    p[j].t[2]=0;\n                    p[j].over=true;\n                    cnt++;\n                }\n        }\n        //serve\n\n        for(int j=1;j<=n;j++)\n        if(!p[j].over)\n        {\n            if(p[j].state==wait)\n                if(p[j].t[wait]==K[j])\n                {\n                    p[j].t[0]=0;\n                    p[j].t[1]=0;\n                    p[j].t[2]=0;\n                    p[j].state=call;\n                }\n        }\n        //wait\n        for(int j=1;j<=n;j++)\n        if(!p[j].over)\n        {\n            if(p[j].state==call)\n            {\n                if(num)\n                {\n                    num--;\n                    p[j].state=serve;\n                    p[j].t[0]=0;\n                    p[j].t[1]=0;\n                    p[j].t[2]=0;\n                }\n                else if(p[j].t[call]==L[j])\n                {\n                    p[j].t[0]=0;\n                    p[j].t[1]=0;\n                    p[j].t[2]=0;\n                    p[j].state=wait;\n                }\n            }\n        }\n        //call\n        for(int j=1;j<=n;j++)\n            if(!p[j].over)\n            for(int q=0;q<3;q++)\n                if(q==p[j].state)\n                    p[j].t[q]++;\n                else\n                    p[j].t[q]=0;\n    }\n\n    return cnt==n;\n}\nint main()\n{\n\n  //  freopen(\"//home/fpy/input.txt\",\"r\",stdin);\n    while(scanf(\"%d%d\",&n,&T)!=EOF)\n    {\n        if(!n && !T)\n            break;\n        for(int i=1;i<=n;i++)\n            scanf(\"%d%d%d\",&M[i],&L[i],&K[i]);\n        int l,r;\n        for(int mid=1;mid<=n;mid++)\n        {\n            if(Judge(mid))\n                r=mid;\n            else\n                l=mid+1;\n        }\n        printf(\"%d\\n\",r);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, T;\nint M[1005], L[1005], K[1005];\nint used[1005], add[1005];\n\nbool check(int x){\n  \n  int res=0;\n  \n  memset(used,0,sizeof(used));\n  memset(add,0,sizeof(add));\n  \n  for(int i=0;i<=T;i++){\n    \n    x+=add[i];\n    \n    for(int j=0;j<N;j++){\n      \n      if(x==0) break;\n      \n      if(used[j]) continue;\n      \n      int mod=L[j]+K[j];\n      \n      if((i%mod<=L[j])&&i+M[j]<=T){\n\tx--;\n\tadd[i+M[j]]++;\n\tused[j]=1;\n\tres++;\n      }      \n      \n    }\n    \n  }\n  \n  return res==N;\n}\n\nvoid solve(){\n  \n  int l=0, r=1005;\n  \n  while(l<r){\n    \n    int m=(l+r)/2;\n    \n    if(!check(m)) l=m+1;\n    else r=m;\n    \n  }\n  \n  cout<<l<<endl;\n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>N>>T;\n    if(!N&&!T) break;\n    \n    for(int i=0;i<N;i++) scanf(\"%d %d %d\", &M[i], &L[i], &K[i]);\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, T;\nint M[1000], L[1000], K[1000];\n\nbool check(int x){\n\n  int res=0, used[1000]={}, add[1000]={};\n  \n  for(int i=0;i<=T;i++){\n    \n    x+=add[i];\n    \n    for(int j=0;j<N;j++){\n\n      if(used[j]) continue;\n      \n      int mod=L[j]+K[j];\n      \n      if(x&&(i%mod<=L[j])&&i+M[j]<=T){\n\tx--;\n\tadd[i+M[j]]++;\n\tused[j]=true;\n\tres++;\n      }\n      \n      if(x==0) break;\n    }\n    \n  }\n  \n  return res==N;\n}\n\nvoid solve(){\n  \n  int l=0, r=1005;\n  \n  while(l<r){\n    \n    int m=(l+r)/2;\n    \n    if(!check(m)) l=m+1;\n    else r=m;\n  }\n\n  cout<<l<<endl;\n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>N>>T;\n    if(!N&&!T) break;\n    \n    for(int i=0;i<N;i++) scanf(\"%d %d %d\", &M[i], &L[i], &K[i]);\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <set>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nbool isCalling[2001];\nbool isTelling[2001];\nbool isFin[2001];\nint N,T;\nint Mi[2001];\nint Li[2001];\nint Ki[2001];\npii datas[2001];\n\nclass Event{\npublic:\n    // 0->qªhang up\n    // 1->qªdbJn\n    // 2->operatorªdbðI¹\n    int cid;\n    int time;\n    Event(int c,int t){\n        cid=c,time=t;\n    }\n    Event();\n    bool operator<(const Event &e)const{\n        return(this->time>e.time);\n    }\n};\n// nlÌIy[^ªvéÆ«ÌV~[V\nbool check(int n){\n    memset(isFin,0,sizeof(isFin));\n    priority_queue<Event> pq;\n    int curTime=0;\n    for(int i=0;i<n;i++){\n        pq.push(Event(i,Mi[i]));\n        isFin[i]=true;\n    }\n    // »Ýq}ÈopÌ\n    int opr=0;\n    int cnt=N;\n    while(pq.size()){\n        // ¡ñÌCxgªI¹µ½opðæèo·\n        Event e=pq.top();pq.pop();\n        curTime=e.time;\n        cnt--;\n        opr++;\n        // óÅ©ÂÜ¾IíÁÄ¢È¢Cxgª¶Ý\n        if(pq.size()==0){\n            if(cnt!=0&&opr!=0){\n                // ÊbÂ\\ÉÈéÜÅª¢ÔÉÀ×é\n                int idx=0;\n                for(int i=0;i<N;i++){\n                    if(isFin[i])continue;\n                    int a=e.time%(Ki[i]+Li[i]);\n                    if(a>=0&&a<=Li[i]){\n                        if(opr>0){\n                            pq.push(Event(i,curTime+Mi[i]));\n                            isFin[i]=true;\n                            opr--;\n                            if(opr==0)break;\n                        }\n                    }\n                    else{\n                        int b=Ki[i]-(a-Li[i]);\n                        datas[idx].first=b;\n                        datas[idx].second=-i;\n                        idx++;\n                    }\n                }\n                sort(datas,datas+idx,greater<pii>());\n                int nxt=opr;\n                for(int i=0;i<min(idx,opr);i++){\n                    pq.push(Event(-datas[i].second,curTime+datas[i].first+Mi[-datas[i].second]));\n                    isFin[-datas[i].second]=true;\n                    nxt--;\n                }\n                opr=nxt;\n            }\n        }\n        // ñÌCxgªI¹·éÜÅÌÔÜÅÉAdbÂ\\ÔÉÈéàÌð·×Ä·\n        else{\n            if(opr==0)continue;\n            int neft=pq.top().time;\n            // ÊbÂ\\ÉÈéÜÅª¢ÔÉÀ×é\n            int idx=0;\n            for(int i=0;i<N;i++){\n                if(isFin[i])continue;\n                int a=e.time%(Ki[i]+Li[i]);\n                if(a>=0&&a<=Li[i]){\n                    if(opr>0){\n                        pq.push(Event(i,curTime+Mi[i]));\n                        isFin[i]=true;\n                        opr--;\n                        if(opr==0)break;\n                    }\n                }\n                else{\n                    int b=Ki[i]-(a-Li[i]);\n                    // ÊbÂ\\ÉÈéÔªneftæè¬³¢ÈçÎ\n                    if(b+curTime<neft){\n                        datas[idx].first=b;\n                        datas[idx].second=-i;\n                        idx++;\n                    }\n                }\n            }\n            sort(datas,datas+idx,greater<pii>());\n            int nxt=opr;\n            for(int i=0;i<min(idx,opr);i++){\n                pq.push(Event(-datas[i].second,curTime+datas[i].first+Mi[-datas[i].second]));\n                isFin[-datas[i].second]=true;\n                nxt--;\n            }\n            opr=nxt;\n        }\n    }\n    return curTime<=T;\n}\n\nint main(){\n\n    while(cin>>N>>T&&(N|T)){\n        for(int i=0;i<N;i++)cin>>Mi[i]>>Li[i]>>Ki[i];\n        for(int i=1;i<=N;i++){\n            if(check(i)){\n                cout<<i<<endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cmath>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\n\nusing namespace std;\n\n#define For(i,forN) for(int i=0;i<(forN);i++)\n#define Fori(i,si,forN) for(int i=si;i<(forN);i++)\n\n#define pb push_back\n#define mp make_pair\n#define sf scanf\n#define pf printf\n\ntypedef pair < int ,int > pii;\ntypedef pair < int , pii > piii;\n\nconst int Maxn=1100;\nint M[Maxn],L[Maxn],K[Maxn];\nint n,m;\nbool vis[Maxn];\n\nbool solve(int num)\n{\n    priority_queue < int > optq;\n    For(i,num)  optq.push(0);\n    For(i,n)    vis[i]=false;\n    int cnt=n,lastT=0;\n    while(cnt)\n    {\n        lastT=-optq.top();\n        optq.pop();\n        int near=Maxn*2,k=-1;\n        For(i,n){\n            if(!vis[i])\n            {\n                int tmp=lastT%(L[i]+K[i]);\n                if(tmp<=L[i])\n                {\n                       near=lastT,k=i;\n                       break;\n                }\n                else\n                {\n                    int tt=lastT+(L[i]+K[i]-tmp);\n                    if(tt<near) near=tt,k=i;\n                }\n            }\n        }\n        if(k==-1)   while(1)    puts(\"error\");\n        vis[k]=true;    cnt--;\n      //  if(num==4)\n       // cout<<M[k]<<\" \"<<k<<\" near=\"<<near<<\" lastT=\"<<lastT<<endl;\n        optq.push(-(near+M[k]));\n    }\n    while(!optq.empty())\n    {\n        lastT=-optq.top(),optq.pop();\n        //cout<<\"pop \"<<lastT<<endl;\n    }\n    return lastT<=m;\n}\n\nint main()\n{\n    while(~sf(\"%d%d\",&n,&m) && (n || m))\n    {\n        For(i,n)    sf(\"%d%d%d\",&M[i],&L[i],&K[i]);\n        int l=1,r=m,res=m;\n        for(int mid=1;mid<=m;mid++)\n        {\n            if(solve(mid))\n            {\n                res=mid;\n                break;\n            }\n        }\n        pf(\"%d\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 1000;\n\n/* typedef */\n\nstruct Cstmr {\n  int m, l, k;\n};\n\n/* global variables */\n\nint n, tt;\nCstmr cs[MAX_N];\nint ons[MAX_N + 2];\nbool used[MAX_N];\n\n/* subroutines */\n\nbool simulate(int on) {\n  memset(ons, 0, sizeof(ons));\n  ons[0] = on;\n  memset(used, 0, sizeof(used));\n\n  int nu = n;\n  \n  for (int t = 0; t < tt; t++) {\n    for (int i = 0; ons[t] > 0 && i < n; i++)\n      if (! used[i] && t % (cs[i].l + cs[i].k) <= cs[i].l) {\n\tint t0 = t + cs[i].m;\n\tif (t0 > tt) return false;\n\tused[i] = true;\n\tif (! --nu) return true;\n\tons[t0]++;\n\tons[t]--;\n      }\n    ons[t + 1] += ons[t];\n  }\n  \n  return (nu == 0);\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n >> tt;\n    if (n == 0) break;\n\n    for (int i = 0; i < n; i++)\n      cin >> cs[i].m >> cs[i].l >> cs[i].k;\n\n    int m;\n    for (m = 1; m <= n; m++)\n      if (simulate(m)) break;\n\n    cout << m << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <set>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nbool isCalling[2001];\nbool isTelling[2001];\nbool isFin[2001];\nint N,T;\nint Mi[2001];\nint Li[2001];\nint Ki[2001];\npii datas[2001];\n\nclass Event{\npublic:\n    // 0->qªhang up\n    // 1->qªdbJn\n    // 2->operatorªdbðI¹\n    int cid;\n    int time;\n    Event(int c,int t){\n        cid=c,time=t;\n    }\n    Event();\n    bool operator<(const Event &e)const{\n        return(this->time>e.time);\n    }\n};\n// nlÌIy[^ªvéÆ«ÌV~[V\nbool check(int n){\n    memset(isFin,0,sizeof(isFin));\n    priority_queue<Event> pq;\n    int curTime=0;\n    for(int i=0;i<n;i++){\n        pq.push(Event(i,Mi[i]));\n        isFin[i]=true;\n    }\n    // »Ýq}ÈopÌ\n    int opr=0;\n    int cnt=N;\n    while(pq.size()){\n        // ¡ñÌCxgªI¹µ½opðæèo·\n        Event e=pq.top();pq.pop();\n        curTime=e.time;\n        cnt--;\n        opr++;\n        // ÊbÂ\\ÉÈéÜÅª¢ÔÉÀ×é\n        int idx=0;\n        for(int i=0;i<N;i++){\n            if(isFin[i])continue;\n            int a=e.time%(Ki[i]+Li[i]);\n                if(a>=0&&a<=Li[i]){\n                    if(opr>0){\n                        pq.push(Event(i,curTime+Mi[i]));\n                        isFin[i]=true;\n                        opr--;\n                        if(opr==0)break;\n                    }\n                }\n                else{\n                    int b=Ki[i]-(a-Li[i]);\n                    if(pq.size()==0||(pq.size()!=0&&b+curTime<pq.top().time)){\n                        datas[idx].first=b;\n                        datas[idx].second=-i;\n                        idx++;\n                    }\n                }\n        }\n        sort(datas,datas+idx,greater<pii>());\n        int nxt=opr;\n        for(int i=0;i<min(idx,opr);i++){\n            pq.push(Event(-datas[i].second,curTime+datas[i].first+Mi[-datas[i].second]));\n            isFin[-datas[i].second]=true;\n            nxt--;\n        }\n        opr=nxt;\n    }\n    return curTime<=T;\n}\n\nint main(){\n\n    while(cin>>N>>T&&(N|T)){\n        for(int i=0;i<N;i++)cin>>Mi[i]>>Li[i]>>Ki[i];\n        for(int i=1;i<=N;i++){\n            if(check(i)){\n                cout<<i<<endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N,T;\nint M[1000],L[1000],K[1000];\n\nint flg[1000];\nbool used[1000];\n\nbool check(int x){\n  fill(flg,flg+x,0);\n  fill(used,used+N,false);\n  \n  for(int t=0;t<=T;t++){\n\n    for(int i=0;i<x;i++){\n      if(flg[i]>t)continue;\n      for(int j=0;j<N;j++){\n        if(used[j])continue;\n        int f=t%(L[j]+K[j]);\n        if(L[j]<f)continue;\n        used[j]=true;\n        flg[i]=t+M[j];\n        //        cout<<\"t=\"<<t<<\" i=\"<<i<<' '<<j<<' '<<flg[i]<<endl;\n        break;\n      }\n    }\n    \n    int mini=1e9;\n    for(int j=0;j<N;j++){\n      if(used[j])continue;\n      int f=t%(L[j]+K[j]);\n      if(L[j]<f){\n        mini=min(mini,K[j]-(f-L[j]));\n      }else mini=0;\n    }\n    \n    //    cout<<t<<' '<<mini<<endl;\n\n    int mini2=1e9;\n    for(int j=0;j<x;j++){\n      if(flg[j]>t)mini2=min(mini2,flg[j]-t);\n      else mini2=0;\n    }\n    \n    t+=max(0,mini2-1);\n  }\n  \n  for(int i=0;i<N;i++)\n    if(!used[i])return false;\n  \n  for(int i=0;i<x;i++)\n    if(flg[i]>T)return false;\n  return true;\n}\n\nint main(){\n  while(1){\n    cin>>N>>T;\n    if(N==0&&T==0)break;\n    for(int i=0;i<N;i++){\n      cin>>M[i]>>L[i]>>K[i];\n    }\n\n    int left=1,right=N,mid;\n\n    while(left<right){\n      mid=(left+right)/2;\n      bool result=check(mid);\n\n      if(result)right=mid;\n      else left=mid+1;\n    }\n\n    \n    cout<<left<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint M[1000],L[1000],K[1000];\nbool flag[1000];\nint N, T;\nint owaru[1001];\n\nbool check(int num) {\n  int aki = num;\n  memset(flag,0,sizeof(flag));\n  memset(owaru,0,sizeof(owaru));\n  int cnt = 0;\n  REP(i,T) {\n    aki += owaru[i];\n    REP(j,N) {\n      if (aki == 0) break;\n      if (flag[j]) continue;\n      if (i%(L[j]+K[j]) <= L[j]) {\n        if (i+M[j]>T) return 0;\n        aki--;\n        owaru[i+M[j]]++;\n        cnt++;\n        flag[j] = 1;\n        if (cnt == N) return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>N>>T,N||T) {\n    REP(i,N) {\n      cin >> M[i] >> L[i] >> K[i];\n    }\n    int ans = -1;\n    for (int i=1; i<=N; ++i) {\n      if (check(i)) {\n        ans = i;\n        break;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int n,t;\n  while(cin>>n>>t,n){\n    vector<int> m(n),l(n),k(n);\n    for(int i=0;i<n;i++) cin>>m[i]>>l[i]>>k[i];\n    auto check=[&](int x){\n      vector<int> a(n,0);\n      vector<int> o(x,0);\n      int cnt=0;\n      for(int i=0;i<=t;i++){\n\tint p=0;\n\tfor(int j=0;j<n;j++){\n\t  if(a[j]<0||a[j]>i) continue;\n\t  while(p<x&&o[p]>i) p++;\n\t  if(p==x) break;\n\t  if(i+m[j]>t) return 0;\n\t  //if(i+m[j]>t) continue;\n\t  o[p]=i+m[j];\n\t  a[j]=-1;\n\t  cnt++;\n\t  //cout<<i<<\" \"<<j<<\":\"<<i+m[j]<<endl;\n\t}\n\tfor(int j=0;j<n;j++)\n\t  if(a[j]>=0&&i>=a[j]+l[j]) a[j]=i+k[j];\n      }\n      //cout<<x<<\":\"<<cnt<<\":\"<<n<<endl;\n      return 1*(cnt==n);\n    };\n    for(int i=1;i<=n;i++){\n      //cout<<i<<\":\"<<check(i)<<endl;\n      if(check(i)){\n\tcout<<i<<endl;\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <tuple>\n#include <queue>\n#include <list>\nusing namespace std;\n// #define fprintf(...) void(0)\n\nbool judge(int N, int T,\n           const vector< tuple<int, int, int> > &info, int O) {\n    priority_queue< int, vector<int>, greater<int> > op;\n    list< pair<int, int> > cs;\n    for(int i=0; i<O; i++) op.emplace(0);\n    for(int i=0; i<N; i++) cs.emplace_back(0, i);\n\n    // fprintf(stderr, \"# num of operators = %d\\n\", O);\n    for(int t=0; t<=T and cs.size(); t++) {\n        // customer 選ぶ\n        for(auto itr = cs.begin(); itr!=cs.end(); ) {\n            int p, k; tie(p, k) = *itr;\n            int M, L, K; tie(M, L, K) = info[k];\n\n            bool inc = false;\n            if(p <= t and t + M <= T) {\n                int o = op.top(); op.pop();\n                if(o > t) {\n                    // 対応できる operator がいない\n                    op.emplace(o);\n                    inc = true;\n                }\n                else {\n                    // 対応\n                    // fprintf(stderr, \"t = %d, customer = %d, op time = %d\\n\", t, k + 1, o);\n                    itr = cs.erase(itr);\n                    op.emplace(t + M);\n                }\n            }\n            else if(t + M > T) {\n                return false;\n            }\n            else {\n                inc = true;\n            }\n            \n            if(inc) {\n                // update time\n                if(t - L == p) {\n                    // fprintf(stderr, \"t = %d, update: customer = %d, time = %d\\n\", t, k+1, t+K);\n                    *itr = make_pair(t+K, k);\n                    if(t + K > T) return false;\n                }\n                itr++;\n            }\n        }\n    }\n\n    return cs.empty();\n}\n\nint solve_testcase() {\n    int N, T; cin >> N >> T;\n    if(N == 0 and T == 0) return 1;\n\n    vector< tuple<int, int, int> > info;\n    for(int i=0; i<N; i++) {\n        int M, L, K; cin >> M >> L >> K;\n        info.emplace_back(M, L, K);\n    }\n\n    for(int m=1; m<=N; m++) {\n        if(judge(N, T, info, m)) {\n            cout << m << endl;\n            return 0;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> Ev;\nint N,T;\nint M[1000], L[1000], K[1000];\n\nbool simulate(int P)\n{\n\tint waitT[1000]={0},opeT[1000]={0};\n\tpriority_queue<Ev, vector<Ev>, greater<Ev> > q;\n\tfor(int i=0; i<N; i++)\n\t\tq.push(make_pair(0,i));\n\n\twhile(!q.empty())\n\t{\n\t\tEv e=q.top(); q.pop();\n\t\tif(e.first+M[e.second] > T) return false;\n\n\t\tbool ok=false;\n\t\tfor(int i=0; i<P; i++)\n\t\t{\n\t\t\tif(opeT[i] <= e.first)\n\t\t\t{\n\t\t\t\topeT[i]=e.first+M[e.second];\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!ok)\n\t\t{\n\t\t\twaitT[e.second]++;\n\t\t\tif(waitT[e.second] > L[e.second])\n\t\t\t{\n\t\t\t\twaitT[e.second]=0;\n\t\t\t\tq.push(make_pair(e.first+K[e.second], e.second));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tq.push(make_pair(e.first+1, e.second));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main()\n{\n\twhile(cin >> N >> T, (N||T))\n\t{\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> M[i] >> L[i] >> K[i];\n\n\t\tfor(int P=1; P<=N; P++)\n\t\t{\n\t\t\tif(simulate(P))\n\t\t\t{\n\t\t\t\tcout << P << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nstruct Event{\n    int time;\n    int type; // 0 - custermer on, 1 - custermer off, 2 - operation end, \n    int id;\n};\nbool operator < (const Event& e, const Event& f) { // !!! reversed !!!\n    if(e.time != f.time) return e.time > f.time;\n    if(e.type != f.type) return e.type > f.type;\n    return e.id > f.id;\n}\n\nbool check(int OPE, int T, const vector<int>& M, const vector<int>& L, const vector<int>& K) {\n    int N = M.size();\n    priority_queue<Event> que;\n    priority_queue<int, vector<int>, greater<int>> wait;\n\n    vector<int> state(N);\n    REP(i, N) {\n        wait.push(i);\n        que.push({L[i] + 1, 1, i});\n    }\n\n    int rest = N;\n\n    for(int t = 0; t <= T; t++) {\n        while(!que.empty() && que.top().time == t) {\n            auto e = que.top(); que.pop();\n            //printf(\"{time:%d, type:%d, id:%d}\\n\", e.time, e.type, e.id);\n            if(e.type == 0) {\n                wait.push(e.id);\n                que.push({t + L[e.id], 1, e.id});\n                state[e.id] = 0;\n            } else if(e.type == 1 && state[e.id] == 0) {\n                que.push({t + K[e.id] - 1, 0, e.id});\n                state[e.id] = 1;\n            } else if(e.type == 2) {\n                rest--;\n                OPE++;\n            }\n        }\n\n        while(OPE > 0 && !wait.empty()){\n            int id = wait.top(); wait.pop();\n            if(state[id] != 0) continue;\n            state[id] = 2;\n            //printf(\"get %d (%d -> %d)\\n\", id, t, t + M[id]);\n            que.push({t + M[id], 2, id});\n            OPE--;\n        }\n    }\n\n    //cout << rest << endl;\n    return rest == 0;\n}\n\nint main(){\n    int N, T;\n    while(cin >> N >> T && (N > 0)) {\n        vector<int> M(N), L(N), K(N);\n        REP(i, N) cin >> M[i] >> L[i] >> K[i];\n\n        for(int i = 1; i <= N; i++) {\n            if(check(i, T, M, L, K)) {\n                cout << i << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2250 Operator\n// 2018.2.1 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\nint N, T;\nint M[1001], L[1001], K[1001];\nint avai[1001];\nchar done[1001];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint check(int p)\n{\n\tint i, t, left;\n\n\tif (p >= N) return 1;\n\n\tmemset(avai, 0, sizeof(avai));\n\tmemset(done, 0, sizeof(done));\n\n    for (i = 0; i < p; i++) avai[M[i]]++;\n    left = N-p;\n\n\tfor (t = 1; ; t++) {\n\t\tif (t > T) return 0;\n\t\tif (left <= 0) break;\n\t\tif (!avai[t]) continue;\n\t\tfor (i = p; i < N; i++) {\n\t\t\tif (done[i]) continue;\n\t\t\tif (t % (L[i]+K[i]) <= L[i]) {\n\t\t\t\tif (t + M[i] > T) return 0;\n\t\t\t\tleft--, done[i] = 1;\n\t\t\t\tavai[t]--, avai[t+M[i]]++;\n\t\t\t\tif (!avai[t]) break;\n\t\t\t}\n\t\t}\n\t\tavai[t+1] += avai[t];\n\t}\n    return 1;\n}\n\nint main()\n{\n\tint i;\n\n\twhile (N = in()) {\n\t\tT = in();\n\t\tfor (i = 0; i < N; i++) M[i] = in(), L[i] = in(), K[i] = in();\n\t\tfor (i = 1; !check(i); i++);\n\t\tprintf(\"%d\\n\", i);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2250 Operator\n// 2018.2.1 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\nint N, T;\nint M[1001], L[1001], K[1001];\nint avai[1001];\nchar done[1001];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint check(int p)\n{\n\tint i, t, left;\n\n\tif (p >= N) return 1;\n\tif (!p) return 0;\n\n\tmemset(avai, 0, sizeof(avai));\n\tmemset(done, 0, sizeof(done));\n\n    for (i = 0; i < p; i++) avai[M[i]]++;\n    left = N-p;\n\n\tfor (t = 1; ; t++) {\n\t\tif (t >= T) return 0;\n\t\tif (left <= 0) break;\n\t\tif (!avai[t]) continue;\n\t\tfor (i = p; i < N; i++) {\n\t\t\tif (done[i]) continue;\n\t\t\tif (t % (L[i]+K[i]) <= L[i]) {\n\t\t\t\tif (t + M[i] > T) return 0;\n\t\t\t\tleft--, done[i] = 1;\n\t\t\t\tavai[t]--, avai[t+M[i]]++;\n\t\t\t\tif (!avai[t]) break;\n\t\t\t}\n\t\t}\n\t\tavai[t+1] += avai[t];\n\t}\n    return 1;\n}\n\nint main()\n{\n\tint i;\n\n\twhile (N = in()) {\n\t\tT = in();\n\t\tfor (i = 0; i < N; i++) M[i] = in(), L[i] = in(), K[i] = in();\n\t\tfor (i = 1; !check(i); i+=2);\n\t\tif (check(i-1)) i--;\n\t\tprintf(\"%d\\n\", i);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tif ((n | t) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[] m = new int[n];\n\t\t\tint[] l = new int[n];\n\t\t\tint[] k = new int[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tm[i] = sc.nextInt();\n\t\t\t\tl[i] = sc.nextInt();\n\t\t\t\tk[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint ml[] = new int[n];\n\t\t\tint ll[] = new int[n];\n\t\t\tint kl[] = new int[n];\n\t\t\tint st[] = new int[n];\n\t\t\tint min = 1;\n\t\t\tint max = n;\n\t\t\tfor (;;) {\n\t\t\t\tif (min == max) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint o = (max + min) / 2;\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tll[i] = l[i];\n\t\t\t\t\tst[i] = 0;\n\t\t\t\t}\n\t\t\t\tint ol = o;\n\t\t\t\tint f = 0;\n\n\t\t\t\tfor (int j = 0;; j++) {\n\t\t\t\t\tif (f == n) {\n\t\t\t\t\t\tmax = o;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (t <= j) {\n\t\t\t\t\t\tmin = 1 + o;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 2) {\n\t\t\t\t\t\t\tkl[i]--;\n\t\t\t\t\t\t\tif (kl[i] == 0) {\n\t\t\t\t\t\t\t\tll[i] = l[i];\n\t\t\t\t\t\t\t\tst[i] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (st[i] == 0) {\n\t\t\t\t\t\t\tif (ol > 0) {\n\t\t\t\t\t\t\t\tol--;\n\t\t\t\t\t\t\t\tst[i] = 1;\n\t\t\t\t\t\t\t\tml[i] = m[i];\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tll[i]--;\n\t\t\t\t\t\t\t\tif (ll[i] == 0) {\n\t\t\t\t\t\t\t\t\tst[i] = 2;\n\t\t\t\t\t\t\t\t\tkl[i] = k[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (st[i] == 1) {\n\t\t\t\t\t\t\tml[i]--;\n\t\t\t\t\t\t\tif (ml[i] == 0) {\n\t\t\t\t\t\t\t\tst[i] = 3;\n\t\t\t\t\t\t\t\tol++;\n\t\t\t\t\t\t\t\tf++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// ml[i]--;\n\t\t\t\t\t\t} \n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * if (j % 10 == 0) { System.out.println(j + \" \" + o +\n\t\t\t\t\t\t * \" \" + i + \" \" + st[i] + \" \" + ll[i] + \" \" + ml[i] +\n\t\t\t\t\t\t * \" \" + kl[i]); }\n\t\t\t\t\t\t */}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (int c = 0;; c++) {\n\n\t\t\tint n = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tif (n + t == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m[] = new int[n];\n\t\t\tint l[] = new int[n];\n\t\t\tint k[] = new int[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tm[i] = sc.nextInt();\n\t\t\t\tl[i] = sc.nextInt();\n\t\t\t\tk[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint max = n;\n\t\t\tint min = 1;\n\t\t\tfor (int z = 0; z <= n; z++) {\n\t\t\t\tif (max == min) {\n\t\t\t\t\t break;\n\t\t\t\t}\n\t\t\t\tint med = (max + min) / 2;\n\t\t\t\tmed = z;\n\n\t\t\t\tint f = 0;\n\t\t\t\tint m2[] = new int[n];\n\t\t\t\tint st[] = new int[n]; // l,m , k\n\t\t\t\tint ope = med;\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tm2[i] = l[i];\n\t\t\t\t}\n\n\t\t\t\tfor (int a = 0;;) {\n\t\t\t\t\n\t\t\t\t\tif (f == n) {\n\t\t\t//\t\t\tSystem.out.println(med + \" ok\");\n\t\t\t\t\t\tmax = med;\n\t\t\t\t\t\tmin = z;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (a >= t+1 ) {\n\t\t\t\t//\t\tSystem.out.println(med + \" xx\");\n\t\t\t\t\t\tmin = med + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 2) {\n\t\t\t\t\t\t\tif (m2[i] == 0) {\n\t\t\t\t\t\t\t\tst[i] = 0;\n\t\t\t\t\t\t\t\tm2[i] = l[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 1) {\n\t\t\t\t\t\t\tif (m2[i] == 0) {\n\t\t\t\t\t\t\t\tf++;\n\t\t\t\t\t\t\t\tst[i] = 3;\n\t\t\t\t\t\t\t\tope++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 0) {\n\t\t\t\t\t\t\t// if (m2[i] == l[i]) {\n\t\t\t\t\t\t\t// st[i] = 2;\n\t\t\t\t\t\t\t// m2[i] = 0;\n\t\t\t\t\t\t\t// } else if (ope > 0) {\n\t\t\t\t\t\t\t// ope--;\n\t\t\t\t\t\t\t// st[i] = 1;\n\t\t\t\t\t\t\t// m2[i] = 0;\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\tif (ope > 0) {\n\t\t\t\t\t\t\t\tope--;\n\t\t\t\t\t\t\t\tst[i] = 1;\n\t\t\t\t\t\t\t\tm2[i] = m[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint mini = n;\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 1)\n\t\t\t\t\t\t\tmini = Math.min(m2[i], mini);\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tm2[i] -= mini;\n\t\t\t\t\t\tif(st[i] == 0){\n\t\t\t\t\t\t\tif(m2[i] < 0 ){\n\t\t\t\t\t\t\t\tint val = -m2[i];\n\t\t\t\t\t\t\t\tint val2 = (l[i]+k[i]) - (val%(l[i]+k[i])) ;\n\t\t\t\t\t\t\t\tif( val2 == l[i]+k[i]) {\n\t\t\t\t\t\t\t\t\tval2=0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(val2 < l[i]){\n\t\t\t\t\t\t\t\t\tst[i] = 0;\n\t\t\t\t\t\t\t\t\tm2[i] = val2;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tst[i] = 2;\n\t\t\t\t\t\t\t\t\tm2[i] = val2 - l[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(st[i] == 2){\n\t\t\t\t\t\t\t\tif(m2[i] < 0 ){\n\t\t\t\t\t\t\t\t\tint val = l[i]-m2[i];\n\t\t\t\t\t\t\t\t\tint val2 = (l[i]+k[i]) - (val%(l[i]+k[i])) ;\n\t\t\t\t\t\t\t\t\tif( val2 == l[i]+k[i]) {\n\t\t\t\t\t\t\t\t\t\tval2=0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(val2 < l[i]){\n\t\t\t\t\t\t\t\t\t\tst[i] = 0;\n\t\t\t\t\t\t\t\t\t\tm2[i] = val2;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tst[i] = 2;\n\t\t\t\t\t\t\t\t\t\tm2[i] = val2 - l[i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ta += mini;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tif (n + t == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m[] = new int[n];\n\t\t\tint l[] = new int[n];\n\t\t\tint k[] = new int[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tm[i] = sc.nextInt();\n\t\t\t\tl[i] = sc.nextInt();\n\t\t\t\tk[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint max = n;\n\t\t\tint min = 1;\n\t\t\tfor (int z = 0; z<= n ;z++) {\n\t\t\t\tif (max == min) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint med = (max + min) / 2;\n\t//\t\t\tmed = z;\n\t\t\t\t\n\t\t\t\tint f = 0;\n\t\t\t\tint m2[] = new int[n];\n\t\t\t\tint st[] = new int[n]; // l,m , k\n\t\t\t\tint ope = med;\n\t\t\t\tfor (int a = 0;; a++) {\n\t\t\t\t\tif (f == n) {\n\t\t\t//\t\t\tSystem.out.println(med + \" ok\");\n\t\t\t\t\t\tmax = med;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (a == t+1) {\n\t\t\t//\t\t\tSystem.out.println(med + \" xx\");\n\t\t\t\t\t\tmin = med + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 2) {\n\t\t\t\t\t\t\tif (m2[i] == k[i]) {\n\t\t\t\t\t\t\t\tst[i] = 0;\n\t\t\t\t\t\t\t\tm2[i] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 1) {\n\t\t\t\t\t\t\tif (m2[i] == m[i]) {\n\t\t\t\t\t\t\t\tf++;\n\t\t\t\t\t\t\t\tst[i] = 3;\n\t\t\t\t\t\t\t\tope++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 0) {\n//\t\t\t\t\t\t\tif (m2[i] == l[i]) {\n//\t\t\t\t\t\t\t\tst[i] = 2;\n//\t\t\t\t\t\t\t\tm2[i] = 0;\n//\t\t\t\t\t\t\t} else if (ope > 0) {\n//\t\t\t\t\t\t\t\tope--;\n//\t\t\t\t\t\t\t\tst[i] = 1;\n//\t\t\t\t\t\t\t\tm2[i] = 0;\n//\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ope > 0) {\n\t\t\t\t\t\t\t\tope--;\n\t\t\t\t\t\t\t\tst[i] = 1;\n\t\t\t\t\t\t\t\tm2[i] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m2[i] == l[i]) {\n\t\t\t\t\t\t\t\tst[i] = 2;\n\t\t\t\t\t\t\t\tm2[i] = 0;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tm2[i]++;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (int c = 0;; c++) {\n\n\t\t\tint n = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tif (n + t == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m[] = new int[n];\n\t\t\tint l[] = new int[n];\n\t\t\tint k[] = new int[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tm[i] = sc.nextInt();\n\t\t\t\tl[i] = sc.nextInt();\n\t\t\t\tk[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint max = n;\n\t\t\tint min = 1;\n\t\t\tfor (int z = 0; z <= n; z++) {\n\t\t\t\tif (max == min) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint med = (max + min) / 2;\n\t\t\t\tmed = z;\n\n\t\t\t\tint f = 0;\n\t\t\t\tint m2[] = new int[n];\n\t\t\t\tint st[] = new int[n]; // l,m , k\n\t\t\t\tint ope = med;\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tm2[i] = l[i];\n\t\t\t\t}\n\n\t\t\t\tfor (int a = 0;;) {\n\n\t\t\t\t\tif (f == n) {\n\t\t\t\t\t\t// System.out.println(med + \" ok\");\n\t\t\t\t\t\tmax = med;\n\t\t\t\t\t\tmin = z;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (a >= t + 1) {\n\t\t\t\t\t\t// System.out.println(med + \" xx\");\n\t\t\t\t\t\tmin = med + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * for (int i = 0; i < n; i++) { if (st[i] == 2) { if (m2[i]\n\t\t\t\t\t * == 0) { st[i] = 0; m2[i] = l[i]; } } }\n\t\t\t\t\t */\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 1) {\n\t\t\t\t\t\t\tif (m2[i] <= a) {\n\t\t\t\t\t\t\t\tf++;\n\t\t\t\t\t\t\t\tst[i] = 3;\n\t\t\t\t\t\t\t\tope++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint mini2 = t + 1;\n\t\t\t\t\tint mini = t + 1;\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 1)\n\t\t\t\t\t\t\tmini = Math.min(m2[i], mini);\n\t\t\t\t\t\tif (st[i] == 0) {\n\t\t\t\t\t\t\tint za = a % (l[i] + k[i]);\n\t\t\t\t\t\t\tif (za <= l[i]) {\n\t\t\t\t\t\t\t\tif (ope > 0) {\n\t\t\t\t\t\t\t\t\tope--;\n\t\t\t\t\t\t\t\t\tst[i] = 1;\n\t\t\t\t\t\t\t\t\tm2[i] = m[i] + a;\n\t\t\t\t\t\t\t\t\tmini = Math.min(mini, m2[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tm2[i] = za + a;\n\t\t\t\t\t\t\t\tmini2 = Math.min(mini2, m2[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ope > 0) {\n\t\t\t\t\t\tmini = Math.min(mini2, mini);\n\t\t\t\t\t}\n\t\t\t\t\ta = mini;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (int c = 0;; c++) {\n\n\t\t\tint n = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tif (n + t == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m[] = new int[n];\n\t\t\tint l[] = new int[n];\n\t\t\tint k[] = new int[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tm[i] = sc.nextInt();\n\t\t\t\tl[i] = sc.nextInt();\n\t\t\t\tk[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint max = n;\n\t\t\tint min = 1;\n\t\t\tfor (int z = 0; z <= n; z++) {\n\t\t\t\tif (max == min) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint med = (max + min) / 2;\n\t\t\t\tmed = z;\n\n\t\t\t\tint f = 0;\n\t\t\t\tint m2[] = new int[n];\n\t\t\t\tint st[] = new int[n]; // l,m , k\n\t\t\t\tint ope = med;\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tm2[i] = l[i];\n\t\t\t\t}\n\t\t\t\tfor (int a = 0;;) {\n\n\t\t\t\t\tif (f == n) {\n\t\t\t\t\t\t// System.out.println(med + \" ok\");\n\t\t\t\t\t\tmax = med;\n\t\t\t\t\t\tmin = z;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (a >= t + 1) {\n\t\t\t\t\t\t// System.out.println(med + \" xx\");\n\t\t\t\t\t\tmin = med + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * for (int i = 0; i < n; i++) { if (st[i] == 2) { if (m2[i]\n\t\t\t\t\t * == 0) { st[i] = 0; m2[i] = l[i]; } } }\n\t\t\t\t\t */\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 1) {\n\t\t\t\t\t\t\tif (m2[i] <= a) {\n\t\t\t\t\t\t\t\tf++;\n\t\t\t\t\t\t\t\tst[i] = 3;\n\t\t\t\t\t\t\t\tope++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint mini2 = t + 1;\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 0) {\n\t\t\t\t\t\t\tint za = a % (l[i] + k[i]);\n\t\t\t\t\t\t\tif (za <= l[i]) {\n\t\t\t\t\t\t\t\tif (ope > 0) {\n\t\t\t\t\t\t\t\t\tope--;\n\t\t\t\t\t\t\t\t\tst[i] = 1;\n\t\t\t\t\t\t\t\t\tm2[i] = m[i] + a;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmini2 = Math.min(mini2, za);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint mini = t + 1;\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 1)\n\t\t\t\t\t\t\tmini = Math.min(m2[i], mini);\n\t\t\t\t\t}\n\t\t\t\t\tif (mini == t + 1) {\n\t\t\t\t\t\tmini = mini2 + a;\n\t\t\t\t\t}\n\t\t\t\t\t// for (int i = 0; i < n; i++) {\n\t\t\t\t\t// m2[i] -= mini;\n\t\t\t\t\t// }\n\t\t\t\t\t// a += mini;\n\t\t\t\t\t// System.out.println(mini);\n\t\t\t\t\ta = mini;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (int c = 0;; c++) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tif (n + t == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m[] = new int[n];\n\t\t\tint l[] = new int[n];\n\t\t\tint k[] = new int[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tm[i] = sc.nextInt();\n\t\t\t\tl[i] = sc.nextInt();\n\t\t\t\tk[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tfor (int z = 1;; z++) {\n\t\t\t\tboolean ok = false;\n\t\t\t\tint f = 0;\n\t\t\t\tint m2[] = new int[n];\n\t\t\t\tint st[] = new int[n]; // l,m , k\n\t\t\t\tint ope = z;\n\t\t\t\tint map[] = new int[n];\n\t\t\t\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tm2[i] = l[i];\n\t\t\t\t\tmap[i] = i;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int a = 0;;) {\n\t/*\t\t\t\tSystem.out.println(a+\":\");\n\t\t\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\t\tSystem.out.println(\" \"+st[i]+\" \"+m2[i]);\n\t\t\t\t\t}*/\n\t\t\t\t\tif (f == n) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (a >= t + 1) {\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint mini = t + 1;\n\t\t\t\t\tint mini2 = t + 1;\n\n\t\t\t\t\tint j = 0;\n\t\t\t\t\tint n2 = n-f;\n\t\t\t\t\t\n\t\t\t\t\tfor (int ii = 0; ii < n2; ii++ , j++) {\n\t\t\t\t\t\tint i = map[ii];\n\t\t\t\t\t\tif (st[i] == 1) {\n\t\t\t\t\t\t\tif (m2[i] <= a) {\n\t\t\t\t\t\t\t\tf++;\n\t\t\t\t\t\t\t\tif(n==f){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tst[i] = 3;\n\t\t\t\t\t\t\t\tope++;\n\t\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmini = Math.min(m2[i], mini);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (st[i] == 0) {\n\t\t\t\t\t\t\tint za = a % (l[i] + k[i]);\n\t\t\t\t\t\t\tif (za <= l[i]) {\n\t\t\t\t\t\t\t\tif (ope > 0) {\n\t\t\t\t\t\t\t\t\tope--;\n\t\t\t\t\t\t\t\t\tst[i] = 1;\n\t\t\t\t\t\t\t\t\tm2[i] = m[i] + a;\n\t\t\t\t\t\t\t\t\tmini = Math.min(mini, m2[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tm2[i] =l[i]+k[i] - za + a;\n\t\t\t\t\t\t\t\tmini2 = Math.min(mini2, m2[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmap[j] = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (f == n) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ope > 0) {\n\t\t\t\t\t\tmini = Math.min(mini2, mini);\n\t\t\t\t\t}\n\n\t\t\t\t\ta = mini;\n\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tSystem.out.println( z);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tif ((n | t) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[] m = new int[n];\n\t\t\tint[] l = new int[n];\n\t\t\tint[] k = new int[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tm[i] = sc.nextInt();\n\t\t\t\tl[i] = sc.nextInt();\n\t\t\t\tk[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint ml[] = new int[n];\n\t\t\tint ll[] = new int[n];\n\t\t\tint kl[] = new int[n];\n\t\t\tint st[] = new int[n];\n\t\t\tint min = 1;\n\t\t\tint max = n;\n\t\t\tfor (;;) {\n\t\t\t\tif (min == max) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint o = (max + min) / 2;\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tll[i] = l[i];\n\t\t\t\t\tst[i] = 0;\n\t\t\t\t}\n\t\t\t\tint ol = o;\n\t\t\t\tint f = 0;\n\n\t\t\t\tfor (int j = 0;; j++) {\n\t\t\t\t\tif (f == n) {\n\t\t\t\t\t\tmax = o;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (t <= j) {\n\t\t\t\t\t\tmin = 1 + o;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\t\t\t\tif (st[i] == 0) {\n\t\t\t\t\t\t\tif (ol > 0) {\n\t\t\t\t\t\t\t\tol--;\n\t\t\t\t\t\t\t\tst[i] = 1;\n\t\t\t\t\t\t\t\tml[i] = m[i];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tll[i]--;\n\t\t\t\t\t\t\t\tif (ll[i] == 0) {\n\t\t\t\t\t\t\t\t\tst[i] = 2;\n\t\t\t\t\t\t\t\t\tkl[i] = k[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (st[i] == 1) {\n\t\t\t\t\t\t\tml[i]--;\n\t\t\t\t\t\t\tif (ml[i] == 0) {\n\t\t\t\t\t\t\t\tst[i] = 3;\n\t\t\t\t\t\t\t\tol++;\n\t\t\t\t\t\t\t\tf++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// ml[i]--;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (st[i] == 2) {\n\t\t\t\t\t\t\t\tkl[i]--;\n\t\t\t\t\t\t\t\tif (kl[i] == 0) {\n\t\t\t\t\t\t\t\t\tll[i] = l[i];\n\t\t\t\t\t\t\t\t\tst[i] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * if (j % 10 == 0) { System.out.println(j + \" \" + o +\n\t\t\t\t\t\t * \" \" + i + \" \" + st[i] + \" \" + ll[i] + \" \" + ml[i] +\n\t\t\t\t\t\t * \" \" + kl[i]); }\n\t\t\t\t\t\t */}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (int c = 0;; c++) {\n\n\t\t\tint n = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tif (n + t == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m[] = new int[n];\n\t\t\tint l[] = new int[n];\n\t\t\tint k[] = new int[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tm[i] = sc.nextInt();\n\t\t\t\tl[i] = sc.nextInt();\n\t\t\t\tk[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint max = n;\n\t\t\tint min = 1;\n\t\t\tfor (int z = 0; z <= n; z++) {\n\t\t\t\tif (max == min) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint med = (max + min) / 2;\n\t\t\t\tmed = z;\n\n\t\t\t\tint f = 0;\n\t\t\t\tint m2[] = new int[n];\n\t\t\t\tint st[] = new int[n]; // l,m , k\n\t\t\t\tint ope = med;\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tm2[i] = l[i];\n\t\t\t\t}\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>();\n\n\t\t\t\tfor (int a = 0;;) {\n\n\t\t\t\t\tif (f == n) {\n\t\t\t\t\t\t// System.out.println(med + \" ok\");\n\t\t\t\t\t\tmax = med;\n\t\t\t\t\t\tmin = z;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (a >= t + 1) {\n\t\t\t\t\t\t// System.out.println(med + \" xx\");\n\t\t\t\t\t\tmin = med + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * for (int i = 0; i < n; i++) { if (st[i] == 2) { if (m2[i]\n\t\t\t\t\t * == 0) { st[i] = 0; m2[i] = l[i]; } } }\n\t\t\t\t\t */\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 1) {\n\t\t\t\t\t\t\tif (m2[i] <= a) {\n\t\t\t\t\t\t\t\tf++;\n\t\t\t\t\t\t\t\tst[i] = 3;\n\t\t\t\t\t\t\t\tope++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint mini2 = t + 1;\n\t\t\t\t\tint mini = t + 1;\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 0) {\n\t\t\t\t\t\t\tint za = a % (l[i] + k[i]);\n\t\t\t\t\t\t\tif (za <= l[i]) {\n\t\t\t\t\t\t\t\tif (ope > 0) {\n\t\t\t\t\t\t\t\t\tope--;\n\t\t\t\t\t\t\t\t\tst[i] = 1;\n\t\t\t\t\t\t\t\t\tm2[i] = m[i] + a;\n\t\t\t\t\t\t\t\t\tq.add(m2[i]);\n\t\t\t\t\t\t\t\t\t// mini = Math.min(mini, m2[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tm2[i] = za + a;\n\t\t\t\t\t\t\t\tmini2 = Math.min(mini2, m2[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (q.isEmpty()) {\n\t\t\t\t\t\tmini = mini2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ope > 0 && mini2 < q.peek()) {\n\t\t\t\t\t\t\tmini = mini2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmini = q.poll();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ta = mini;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (int c = 0;; c++) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tif (n + t == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m[] = new int[n];\n\t\t\tint l[] = new int[n];\n\t\t\tint k[] = new int[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tm[i] = sc.nextInt();\n\t\t\t\tl[i] = sc.nextInt();\n\t\t\t\tk[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tfor (int z = 1;; z++) {\n\t\t\t\tboolean ok = false;\n\t\t\t\tint f = 0;\n\t\t\t\tint m2[] = new int[n];\n\t\t\t\tint st[] = new int[n]; // l,m , k\n\t\t\t\tint ope = z;\n\t\t\t\tint map[] = new int[n];\n\t\t\t\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tm2[i] = l[i];\n\t\t\t\t\tmap[i] = i;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int a = 0;;) {\n\n\t\t\t\t\tif (f == n) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (a >= t + 1) {\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint mini = t + 1;\n\t\t\t\t\tint mini2 = t + 1;\n\n\t\t\t\t\tint j = 0;\n\t\t\t\t\tint n2 = n-f;\n\t\t\t\t\t\n\t\t\t\t\tfor (int ii = 0; ii < n2; ii++ , j++) {\n\t\t\t\t\t\tint i = map[ii];\n\t\t\t\t\t\tif (st[i] == 1) {\n\t\t\t\t\t\t\tif (m2[i] <= a) {\n\t\t\t\t\t\t\t\tf++;\n\t\t\t\t\t\t\t\tst[i] = 3;\n\t\t\t\t\t\t\t\tope++;\n\t\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmini = Math.min(m2[i], mini);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (st[i] == 0) {\n\t\t\t\t\t\t\tint za = a % (l[i] + k[i]);\n\t\t\t\t\t\t\tif (za <= l[i]) {\n\t\t\t\t\t\t\t\tif (ope > 0) {\n\t\t\t\t\t\t\t\t\tope--;\n\t\t\t\t\t\t\t\t\tst[i] = 1;\n\t\t\t\t\t\t\t\t\tm2[i] = m[i] + a;\n\t\t\t\t\t\t\t\t\tmini = Math.min(mini, m2[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tm2[i] = za + a;\n\t\t\t\t\t\t\t\tmini2 = Math.min(mini2, m2[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmap[j] = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ope > 0) {\n\t\t\t\t\t\tmini = Math.min(mini2, mini);\n\t\t\t\t\t}\n\n\t\t\t\t\ta = mini;\n\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tSystem.out.println(z);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (int c = 0;; c++) {\n\n\t\t\tint n = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tif (n + t == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m[] = new int[n];\n\t\t\tint l[] = new int[n];\n\t\t\tint k[] = new int[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tm[i] = sc.nextInt();\n\t\t\t\tl[i] = sc.nextInt();\n\t\t\t\tk[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint max = n;\n\t\t\tint min = 1;\n\t\t\tfor (int z = 0; z <= n; z++) {\n\t\t\t\tif (max == min) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint med = (max + min) / 2;\n\t\t\t\tmed = z;\n\n\t\t\t\tint f = 0;\n\t\t\t\tint m2[] = new int[n];\n\t\t\t\tint st[] = new int[n]; // l,m , k\n\t\t\t\tint ope = med;\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tm2[i] = l[i];\n\t\t\t\t}\n\t\t\t\tint s = 0;\n\t\t\t\tint w = n;\n\t\t\t\tfor (int a = 0;;) {\n\n\t\t\t\t\tif (f == n) {\n\t\t\t\t\t\tmax = med;\n\t\t\t\t\t\tmin = z;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (a >= t + 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint mini = t + 1;\n\t\t\t\t\tint mini2 = t + 1;\n\t\t\t\t\t\n\t\t\t\t\tfor (int i = s; i < w; i++) {\n\t\t\t\t\t\tif (st[i] == 1) {\n\t\t\t\t\t\t\tif (m2[i] <= a) {\n\t\t\t\t\t\t\t\tf++;\n\t\t\t\t\t\t\t\tst[i] = 3;\n\t\t\t\t\t\t\t\tope++;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ts = Math.min(s, i);\n\t\t\t\t\t\t\t\tw = Math.max(w,i);\n\t\t\t\t\t\t\t\tmini = Math.min(m2[i], mini);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (st[i] == 0) {\n\t\t\t\t\t\t\ts = Math.min(s, i);\n\t\t\t\t\t\t\tw = Math.max(w,i);\n\t\t\t\t\t\t\tint za = a % (l[i] + k[i]);\n\t\t\t\t\t\t\tif (za <= l[i]) {\n\t\t\t\t\t\t\t\tif (ope > 0) {\n\t\t\t\t\t\t\t\t\tope--;\n\t\t\t\t\t\t\t\t\tst[i] = 1;\n\t\t\t\t\t\t\t\t\tm2[i] = m[i] + a;\n\t\t\t\t\t\t\t\t\tmini = Math.min(mini, m2[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tm2[i] = za + a;\n\t\t\t\t\t\t\t\tmini2 = Math.min(mini2, m2[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ope > 0) {\n\t\t\t\t\t\tmini = Math.min(mini2, mini);\n\t\t\t\t\t}\n\t\t\t\t\ta = mini;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tif (n + t == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m[] = new int[n];\n\t\t\tint l[] = new int[n];\n\t\t\tint k[] = new int[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tm[i] = sc.nextInt();\n\t\t\t\tl[i] = sc.nextInt();\n\t\t\t\tk[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint max = n;\n\t\t\tint min = 1;\n\t\t\tfor (int z = 0; z<= n ;z++) {\n\t\t\t\tif (max == min) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint med = (max + min) / 2;\n\t\t\t\tmed = z;\n\t\t\t\t\n\t\t\t\tint f = 0;\n\t\t\t\tint m2[] = new int[n];\n\t\t\t\tint st[] = new int[n]; // l,m , k\n\t\t\t\tint ope = med;\n\t\t\t\tfor (int a = 0;; a++) {\n\t\t\t\t\tif (f == n) {\n\t\t\t//\t\t\tSystem.out.println(med + \" ok\");\n\t\t\t\t\t\tmax = med;\n\t\t\t\t\t\tmin = z;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (a == t+1) {\n\t\t\t//\t\t\tSystem.out.println(med + \" xx\");\n\t\t\t\t\t\tmin = med + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 2) {\n\t\t\t\t\t\t\tif (m2[i] == k[i]) {\n\t\t\t\t\t\t\t\tst[i] = 0;\n\t\t\t\t\t\t\t\tm2[i] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 1) {\n\t\t\t\t\t\t\tif (m2[i] == m[i]) {\n\t\t\t\t\t\t\t\tf++;\n\t\t\t\t\t\t\t\tst[i] = 3;\n\t\t\t\t\t\t\t\tope++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tif (st[i] == 0) {\n//\t\t\t\t\t\t\tif (m2[i] == l[i]) {\n//\t\t\t\t\t\t\t\tst[i] = 2;\n//\t\t\t\t\t\t\t\tm2[i] = 0;\n//\t\t\t\t\t\t\t} else if (ope > 0) {\n//\t\t\t\t\t\t\t\tope--;\n//\t\t\t\t\t\t\t\tst[i] = 1;\n//\t\t\t\t\t\t\t\tm2[i] = 0;\n//\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ope > 0) {\n\t\t\t\t\t\t\t\tope--;\n\t\t\t\t\t\t\t\tst[i] = 1;\n\t\t\t\t\t\t\t\tm2[i] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m2[i] == l[i]) {\n\t\t\t\t\t\t\t\tst[i] = 2;\n\t\t\t\t\t\t\t\tm2[i] = 0;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tm2[i]++;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\n\t}\n\n}"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(x)\n\t\t@array << x\n\t\t@index[x] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u], @index[v] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i] <=> @array[j]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min)\n\t\tmin\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef del(obj)\n\t\tdec_key(obj, Float::INFINITY)\n\t\tdel_min\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i] <=> @array[j]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j] <=> @array[k]) < 0 ? j : k)\n\t\t\tif (@array[i] <=> @array[l]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\ndef check(ope_num, customers, deadline)\n\tqueue_heap = Heap.new\n\tsupported = {}\n\tfinished = {}\n\tworking = 0\n\n\tstart_events = (0..deadline).map { [] }\n\tgiveup_events = (0..deadline).map { [] }\n\tfinish_events = (0..deadline).map { [] }\n\tstart_events[0] = (0..customers.size-1).to_a\n\n\t(0..deadline).each do |t|\n\t\tabort_flag = false\n\n\t\tstart_events[t].each do |id|\n\t\t\tsupport_time, wait_time, recall_time = customers[id]\n\t\t\tqueue_heap.add(id)\n\t\t\tgt = t + wait_time\n\t\t\tgiveup_events[gt] << id if gt <= deadline\n\t\tend\n\n\t\tfinish_events[t].each do |id|\n\t\t\tfinished[id] = 1\n\t\t\tworking -= 1\n\t\tend\n\n\t\tuntil working == ope_num || queue_heap.empty?\n\t\t\tid, _ = queue_heap.del_min\n\t\t\tsupport_time, wait_time, recall_time = customers[id]\n\t\t\tft = t + support_time\n\t\t\tif ft <= deadline\n\t\t\t\tfinish_events[ft] << id \n\t\t\t\tsupported[id] = 1\n\t\t\t\tworking += 1\n\t\t\telse\n\t\t\t\tabort_flag = true\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tbreak if abort_flag\n\n\t\tgiveup_events[t].each do |id|\n\t\t\tnext if supported[id]\n\t\t\tsupport_time, wait_time, recall_time = customers[id]\n\t\t\tqueue_heap.del(id)\n\t\t\tst = t + recall_time\n\t\t\tif st + support_time <= deadline\n\t\t\t\tstart_events[st] << id\n\t\t\telse\n\t\t\t\tabort_flag = true\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tbreak if abort_flag\n\tend\n\n\treturn finished.size == customers.size\nend\n\nloop do\n\tn, deadline = gets.split.map(&:to_i)\n\tbreak if n == 0\n\tcustomers = (1..n).map { gets.split.map(&:to_i) }\t\t\n\n\tlower_bound = (customers.map(&:first).inject(:+) / deadline.to_f).ceil\n\t(lower_bound..n).each do |o|\t\n\t\tif check(o, customers, deadline)\n\t\t\tputs o\n\t\t\tbreak\n\t\tend\n\tend\nend"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef del(obj)\n\t\tdec_key(obj, Float::INFINITY)\n\t\tdel_min\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nclass Array\n\tdef bsearch_first_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_first_index(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch_first_index(c+1, r, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_first_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_first_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\n\n\tdef bsearch_last_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_last_index(c+1, r, &pred) || c\n\t\telse\n\t\t\tbsearch_last_index(l, c-1, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_last_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_last_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\nend\n\ndef check(ope_num, customers, deadline)\n\tqueue_heap = Heap.new\n\tsupported = {}\n\tfinished = {}\n\tworking = 0\n\n\tstart_events = (0..deadline).map { [] }\n\tgiveup_events = (0..deadline).map { [] }\n\tfinish_events = (0..deadline).map { [] }\n\tstart_events[0] = (0..customers.size-1).to_a\n\n\t(0..deadline).each do |t|\n\t\tstart_events[t].each do |id|\n\t\t\tsupport_time, wait_time, recall_time = customers[id]\n\t\t\tqueue_heap.add(id, id)\n\t\t\tgt = t + wait_time\n\t\t\tgiveup_events[gt] << id if gt <= deadline\n\t\tend\n\n\t\tfinish_events[t].each do |id|\n\t\t\tfinished[id] = 1\n\t\t\tworking -= 1\n\t\tend\n\n\t\tuntil working == ope_num || queue_heap.empty?\n\t\t\tid, _ = queue_heap.del_min\n\t\t\tsupport_time, wait_time, recall_time = customers[id]\n\t\t\tft = t + support_time\n\t\t\tfinish_events[ft] << id if ft <= deadline\n\t\t\tsupported[id] = 1\n\t\t\tworking += 1\n\t\tend\n\n\t\tgiveup_events[t].each do |id|\n\t\t\tnext if supported[id]\n\t\t\tsupport_time, wait_time, recall_time = customers[id]\n\t\t\tqueue_heap.del(id)\n\t\t\tst = t + recall_time\n\t\t\tstart_events[st] << id if st <= deadline\n\t\tend\n\tend\n\n\treturn finished.size == customers.size\nend\n\nloop do\n\tn, deadline = gets.split.map(&:to_i)\n\tbreak if n == 0\n\tcustomers = (1..n).map { gets.split.map(&:to_i) }\t\t\n\t\n\tp x = (1..n).to_a.bsearch_first_item {|o| check(o, customers, deadline)}\nend"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef del(obj)\n\t\tdec_key(obj, Float::INFINITY)\n\t\tdel_min\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nloop do\n\tn, deadline = gets.split.map(&:to_i)\n\tbreak if n == 0\n\tcustomers = (1..n).map { gets.split.map(&:to_i) }\t\t\n\t\n\t(1..n).each do |o|\n\n\t\tevent_heap = Heap.new\n\t\t(0..customers.size-1).each do |i|\n\t\t\tevent_heap.add([:start, i], 0)\n\t\tend\n\n\t\tqueue_heap = Heap.new\n\t\tsupported = {}\n\t\tfinished = {}\n\n\t\tworking = 0\n\n\t\tuntil event_heap.empty?\n\t\t\tt = event_heap.min_key\n\t\t\tbreak if t > deadline\n\n\t\t\twhile !event_heap.empty? && event_heap.min_key == t\n\t\t\t\t(type, id), _ = event_heap.del_min\n\t\t\t\tsupport_time, wait_time, recall_time = customers[id]\n\t\t\t\tcase type\n\t\t\t\twhen :finish\n\t\t\t\t\tworking -= 1\n\t\t\t\t\tfinished[id] = 1\n\t\t\t\twhen :start\n\t\t\t\t\tqueue_heap.add(id, id)\n\t\t\t\t\tevent_heap.add([:give_up, id], t + wait_time + 0.1)\n\t\t\t\twhen :give_up\n\t\t\t\t\tif ! supported[id]\n\t\t\t\t\t\tqueue_heap.del(id)\n\t\t\t\t\t\tevent_heap.add([:start, id], t.to_i + recall_time)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tuntil working == o || queue_heap.empty?\n\t\t\t\tid, _ = queue_heap.del_min\n\t\t\t\tsupport_time, wait_time, recall_time = customers[id]\n\t\t\t\tevent_heap.add([:finish, id], t + support_time)\n\t\t\t\tsupported[id] = 1\n\t\t\t\tworking += 1\n\t\t\tend\n\t\tend\n\t\tif finished.size == n\n\t\t\tputs o\n\t\t\tbreak\n\t\tend\n\tend\nend"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef check(N, C, T, x):\n    used = [0]*N\n    S = [0]*(T+1)\n    cap = x\n    f = 0\n    for t in range(T):\n        cap += S[t]\n        if cap == 0:\n            continue\n        for i in range(f, N):\n            if used[i]:\n                continue\n            m, l, k = C[i]\n            if t+m > T:\n                break\n            if t % (l + k) <= l:\n                used[i] = 1\n                S[t+m] += 1\n                cap -= 1\n                if i == f:\n                    while f < N and used[f]:\n                        f += 1\n                if cap == 0:\n                    break\n    cap += S[T]\n    return sum(used) == N and cap == x\n\ndef solve():\n    N, T = map(int, readline().split())\n    if N == 0:\n        return False\n    C = [list(map(int, readline().split())) for i in range(N)]\n    for x in range(N+1):\n        if check(N, C, T, x):\n            write(\"%d\\n\" % x)\n            break\n    return True\nwhile solve():\n    ...\n"
  }
]