[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int support_time;\n    int max_wait;\n    int call_back;\n} Customer;\n\nint compare(const void *a, const void *b) {\n    Customer *c1 = (Customer *)a;\n    Customer *c2 = (Customer *)b;\n    return (c1->max_wait + c1->support_time) - (c2->max_wait + c2->support_time);\n}\n\nint minOperators(Customer customers[], int n, int time_limit) {\n    qsort(customers, n, sizeof(Customer), compare);\n    int *operators = (int *)malloc(n * sizeof(int));\n    int op_count = 0;\n\n    for (int i = 0; i < n; i++) {\n        int placed = 0;\n        for (int j = 0; j < op_count; j++) {\n            if (operators[j] <= customers[i].max_wait) {\n                operators[j] = customers[i].max_wait + customers[i].support_time + customers[i].call_back;\n                placed = 1;\n                break;\n            }\n        }\n        if (!placed) {\n            if (customers[i].max_wait + customers[i].support_time > time_limit) {\n                free(operators);\n                return -1;\n            }\n            operators[op_count] = customers[i].max_wait + customers[i].support_time + customers[i].call_back;\n            op_count++;\n        }\n    }\n\n    free(operators);\n    return op_count;\n}\n\nint main() {\n    int n, time_limit;\n    scanf(\"%d %d\", &n, &time_limit);\n    Customer *customers = (Customer *)malloc(n * sizeof(Customer));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &customers[i].support_time, &customers[i].max_wait, &customers[i].call_back);\n    }\n    int result = minOperators(customers, n, time_limit);\n    printf(\"%d\\n\", result);\n    free(customers);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:17:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nstruct Customer {\n    int supportTime;\n    int maxWaitTime;\n    int retryInterval;\n};\n\nbool isPossible(int operators, const vector<Customer>& customers, int timeLimit) {\n    priority_queue<int, vector<int>, greater<int>> availableOperators;\n    for (int i = 0; i < operators; ++i) {\n        availableOperators.push(0);\n    }\n\n    for (const auto& customer : customers) {\n        int earliestStart = availableOperators.top();\n        availableOperators.pop();\n        int startTime = max(earliestStart, 0);\n        if (startTime > customer.maxWaitTime) {\n            return false;\n        }\n        int endTime = startTime + customer.supportTime;\n        if (endTime > timeLimit) {\n            return false;\n        }\n        int nextAvailable = endTime + customer.retryInterval;\n        availableOperators.push(nextAvailable);\n    }\n    return true;\n}\n\nint findMinOperators(const vector<Customer>& customers, int timeLimit) {\n    int left = 1;\n    int right = customers.size();\n    int answer = right;\n\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (isPossible(mid, customers, timeLimit)) {\n            answer = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return answer;\n}\n\nint main() {\n    int N, T;\n    cin >> N >> T;\n    vector<Customer> customers(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> customers[i].supportTime >> customers[i].maxWaitTime >> customers[i].retryInterval;\n    }\n\n    cout << findMinOperators(customers, T) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:17:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Customer {\n    int supportTime;\n    int maxWaitTime;\n    int callBackInterval;\n\n    Customer(int supportTime, int maxWaitTime, int callBackInterval) {\n        this.supportTime = supportTime;\n        this.maxWaitTime = maxWaitTime;\n        this.callBackInterval = callBackInterval;\n    }\n}\n\npublic class OperatorScheduler {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int T = scanner.nextInt();\n        List<Customer> customers = new ArrayList<>();\n\n        for (int i = 0; i < N; i++) {\n            int s = scanner.nextInt();\n            int w = scanner.nextInt();\n            int c = scanner.nextInt();\n            customers.add(new Customer(s, w, c));\n        }\n\n        int low = 1;\n        int high = N;\n        int answer = N;\n\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (canHandle(mid, customers, T)) {\n                answer = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        System.out.println(answer);\n    }\n\n    private static boolean canHandle(int operators, List<Customer> customers, int T) {\n        PriorityQueue<Integer> operatorQueue = new PriorityQueue<>();\n        for (int i = 0; i < operators; i++) {\n            operatorQueue.add(0);\n        }\n\n        for (Customer customer : customers) {\n            int currentTime = operatorQueue.poll();\n            int startTime = Math.max(currentTime, 0);\n            if (startTime > customer.maxWaitTime) {\n                return false;\n            }\n            int nextAvailableTime = startTime + customer.supportTime;\n            if (nextAvailableTime > T) {\n                return false;\n            }\n            operatorQueue.add(nextAvailableTime + customer.callBackInterval);\n        }\n\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 21:18:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CustomerSupportSimulation {\n    public static int minimumOperators(int[] supportTimes, int[] waitTimes, int[] backoffTimes, int timeLimit) {\n        int n = supportTimes.length;\n        List<Customer> customers = new ArrayList<>();\n        \n        for (int i = 0; i < n; i++) {\n            customers.add(new Customer(supportTimes[i], waitTimes[i], backoffTimes[i]));\n        }\n        \n        customers.sort((a, b) -> a.waitTime - b.waitTime);\n        \n        int left = 1, right = n;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (canSupportAllCustomers(customers, mid, timeLimit)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        return left;\n    }\n    \n    private static boolean canSupportAllCustomers(List<Customer> customers, int operators, int timeLimit) {\n        PriorityQueue<Integer> availableOperators = new PriorityQueue<>();\n        for (int i = 0; i < operators; i++) {\n            availableOperators.offer(0);\n        }\n        \n        for (Customer customer : customers) {\n            int earliestStart = availableOperators.poll();\n            \n            if (earliestStart + customer.supportTime > customer.waitTime) {\n                return false;\n            }\n            \n            availableOperators.offer(Math.max(earliestStart, 0) + customer.supportTime);\n        }\n        \n        return true;\n    }\n    \n    static class Customer {\n        int supportTime;\n        int waitTime;\n        int backoffTime;\n        \n        Customer(int supportTime, int waitTime, int backoffTime) {\n            this.supportTime = supportTime;\n            this.waitTime = waitTime;\n            this.backoffTime = backoffTime;\n        }\n    }\n    \n    public static void main(String[] args) {\n        int[] supportTimes = {5, 3, 4};\n        int[] waitTimes = {10, 8, 12};\n        int[] backoffTimes = {2, 3, 1};\n        int timeLimit = 15;\n        \n        int result = minimumOperators(supportTimes, waitTimes, backoffTimes, timeLimit);\n        System.out.println(\"Minimum operators needed: \" + result);\n    }\n}",
    "timestamp": "2025-08-05 21:18:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int support_time;\n    int max_wait_time;\n    int callback_interval;\n} Customer;\n\nint compare(const void* a, const void* b) {\n    Customer* custA = (Customer*)a;\n    Customer* custB = (Customer*)b;\n    return custA->max_wait_time - custB->max_wait_time;\n}\n\nint min_operators(Customer* customers, int n, int time_limit) {\n    qsort(customers, n, sizeof(Customer), compare);\n    \n    int operators = 0;\n    int* operator_free_time = malloc(n * sizeof(int));\n    \n    for (int i = 0; i < n; i++) {\n        int assigned = 0;\n        \n        for (int j = 0; j < operators; j++) {\n            if (operator_free_time[j] <= customers[i].max_wait_time - customers[i].support_time) {\n                operator_free_time[j] = customers[i].max_wait_time;\n                assigned = 1;\n                break;\n            }\n        }\n        \n        if (!assigned) {\n            operator_free_time[operators] = customers[i].max_wait_time;\n            operators++;\n        }\n    }\n    \n    free(operator_free_time);\n    return operators;\n}\n\nint main() {\n    int n, time_limit;\n    scanf(\"%d %d\", &n, &time_limit);\n    \n    Customer* customers = malloc(n * sizeof(Customer));\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", \n            &customers[i].support_time, \n            &customers[i].max_wait_time, \n            &customers[i].callback_interval);\n    }\n    \n    int result = min_operators(customers, n, time_limit);\n    printf(\"%d\\n\", result);\n    \n    free(customers);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:18:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Customer {\n    int supportTime;\n    int maxWaitTime;\n    int callbackTime;\n};\n\nbool canSupportAllCustomers(vector<Customer>& customers, int operators, int timeLimit) {\n    vector<int> endTimes(operators, 0);\n    \n    sort(customers.begin(), customers.end(), [](const Customer& a, const Customer& b) {\n        return a.maxWaitTime < b.maxWaitTime;\n    });\n    \n    for (const Customer& customer : customers) {\n        bool supported = false;\n        \n        for (int& endTime : endTimes) {\n            if (endTime + customer.supportTime <= customer.maxWaitTime) {\n                endTime += customer.supportTime;\n                supported = true;\n                break;\n            }\n        }\n        \n        if (!supported) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint findMinOperators(vector<Customer>& customers, int timeLimit) {\n    int left = 1, right = customers.size();\n    \n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        \n        if (canSupportAllCustomers(customers, mid, timeLimit)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    return left;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Customer> customers(n);\n    \n    for (int i = 0; i < n; i++) {\n        cin >> customers[i].supportTime >> customers[i].maxWaitTime >> customers[i].callbackTime;\n    }\n    \n    int timeLimit;\n    cin >> timeLimit;\n    \n    int minOperators = findMinOperators(customers, timeLimit);\n    \n    cout << minOperators << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:18:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappop, heappush\nfrom collections import deque\n\ndef min_operators(customers, max_wait_time, time_limit):\n    customers = sorted(customers, key=lambda x: x[1])\n    \n    def can_handle_with_operators(num_operators):\n        available_operators = [0] * num_operators\n        queue = deque(customers)\n        \n        while queue:\n            support_time, max_wait, call_back_interval = queue.popleft()\n            if available_operators[0] <= time_limit - max_wait:\n                if available_operators[0] <= time_limit:\n                    available_operators[0] += support_time\n                    heappush(available_operators, heappop(available_operators))\n                continue\n                \n            available_time = heappop(available_operators)\n            if available_time <= time_limit:\n                if available_time + support_time <= time_limit:\n                    available_time += support_time\n                heappush(available_operators, available_time)\n            else:\n                return False\n        \n        return max(available_operators) <= time_limit\n    \n    left, right = 1, len(customers)\n    answer = right\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if can_handle_with_operators(mid):\n            answer = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return answer\n\n# Example usage\n# Assuming customers is a list of tuples with (support_time, max_wait, call_back_interval)\ncustomers = [(10, 30, 60), (20, 50, 60), (15, 40, 60)]\nmax_wait_time = 30\ntime_limit = 100\n\nprint(min_operators(customers, max_wait_time, time_limit))",
    "timestamp": "2025-08-13 05:53:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\n\npublic class SupportCenter {\n    public static int minimumOperators(int[] supportTimes, int[] maxWaitingTimes, int timeLimit) {\n        int n = supportTimes.length;\n        int[] endTimes = new int[n];\n        Arrays.fill(endTimes, Integer.MAX_VALUE);\n        \n        Arrays.sort(supportTimes);\n        \n        int low = 1, high = n;\n        while (low < high) {\n            int mid = (low + high) / 2;\n            if (canSupportWithinTime(mid, supportTimes, maxWaitingTimes, endTimes, timeLimit, n)) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        return low;\n    }\n    \n    private static boolean canSupportWithinTime(int operators, int[] supportTimes, int[] maxWaitingTimes, int[] endTimes, int timeLimit, int totalCustomers) {\n        for (int i = 0; i < totalCustomers; i++) {\n            if (endTimes[i] > timeLimit) {\n                return false;\n            }\n            for (int j = 0; j < operators; j++) {\n                if (endTimes[j] + supportTimes[i] <= maxWaitingTimes[i]) {\n                    endTimes[j] += supportTimes[i];\n                    break;\n                }\n                if (j == operators - 1) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    public static void main(String[] args) {\n        int[] supportTimes = {30, 30, 40, 50};\n        int[] maxWaitingTimes = {60, 60, 70, 80};\n        int timeLimit = 240;\n        \n        int operatorsNeeded = minimumOperators(supportTimes, maxWaitingTimes, timeLimit);\n        System.out.println(\"Minimum operators required: \" + operatorsNeeded);\n    }\n}",
    "timestamp": "2025-08-13 05:53:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int supportTime;\n    int maxWaitTime;\n    int callBackTime;\n} Customer;\n\nint canHandleAllCustomers(Customer *customers, int numCustomers, int operators, int maxTime) {\n    int *operatorEndTime = (int *)calloc(operators, sizeof(int));\n    for (int t = 0; t <= maxTime; t++) {\n        for (int i = 0; i < numCustomers; i++) {\n            if ((operatorEndTime[i % operators] <= t) && \n                (customers[i].maxWaitTime >= (t % customers[i].callBackTime))) {\n                operatorEndTime[i % operators] = t + customers[i].supportTime;\n            }\n        }\n    }\n    for (int i = 0; i < numCustomers; i++) {\n        if (operatorEndTime[i % operators] > maxTime) {\n            free(operatorEndTime);\n            return 0;\n        }\n    }\n    free(operatorEndTime);\n    return 1;\n}\n\nint minOperators(Customer *customers, int numCustomers, int maxTime) {\n    int low = 1, high = numCustomers;\n    while (low < high) {\n        int mid = (low + high) / 2;\n        if (canHandleAllCustomers(customers, numCustomers, mid, maxTime))\n            high = mid;\n        else\n            low = mid + 1;\n    }\n    return low;\n}\n\nint main() {\n    int numCustomers, maxTime;\n    scanf(\"%d %d\", &numCustomers, &maxTime);\n    Customer *customers = (Customer *)malloc(numCustomers * sizeof(Customer));\n    for (int i = 0; i < numCustomers; i++) {\n        scanf(\"%d %d %d\", &customers[i].supportTime, &customers[i].maxWaitTime, &customers[i].callBackTime);\n    }\n    printf(\"%d\\n\", minOperators(customers, numCustomers, maxTime));\n    free(customers);\n    return 0;\n}",
    "timestamp": "2025-08-13 05:53:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_operators(support_times, max_wait_times, recall_intervals):\n    n = len(support_times)\n    calls = sorted([(0, 1, i) for i in range(n)] + \n                   [(max_wait_times[i], -1, i) for i in range(n)])\n    \n    operators = 0\n    max_operators = 0\n    active_calls = set()\n\n    for time, event, call_id in calls:\n        if event == 1:\n            if operators == 0:\n                max_operators += 1\n            operators += 1\n            active_calls.add(call_id)\n        else:\n            if call_id in active_calls:\n                operators -= 1\n                active_calls.remove(call_id)\n\n    return max_operators\n\n# Example usage\nsupport_times = [5, 3, 4]\nmax_wait_times = [10, 8, 12]\nrecall_intervals = [15, 10, 20]\n\nprint(min_operators(support_times, max_wait_times, recall_intervals))",
    "timestamp": "2025-08-13 05:54:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_operators(N, T, customers):\n    left = 1\n    right = N\n    answer = N\n    \n    while left <= right:\n        mid = (left + right) // 2\n        operators = [0] * mid\n        possible = True\n        \n        for a, b, c in customers:\n            found = False\n            for i in range(mid):\n                if operators[i] <= a:\n                    end_time = a + b\n                    if end_time > T:\n                        possible = False\n                        break\n                    operators[i] = a + b + c\n                    found = True\n                    break\n            if not possible:\n                break\n            if not found:\n                possible = False\n                break\n        \n        if possible:\n            answer = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return answer\n\n# Sample usage:\n# N = 3\n# T = 10\n# customers = [(1, 5, 1), (2, 3, 2), (3, 4, 1)]\n# print(min_operators(N, T, customers))",
    "timestamp": "2025-08-13 05:54:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Customer {\n    int support_time;\n    int max_wait;\n    int interval;\n};\n\nbool canHandleAllCalls(vector<Customer>& customers, int operators, int time_limit) {\n    vector<int> end_times(operators, 0);\n    int max_time = 0;\n    \n    for (auto& customer : customers) {\n        int earliest_operator = 0;\n        for (int i = 1; i < operators; ++i) {\n            if (end_times[i] < end_times[earliest_operator]) {\n                earliest_operator = i;\n            }\n        }\n\n        max_time = max(max_time, end_times[earliest_operator] + customer.support_time);\n        if (max(end_times[earliest_operator], time_limit) > customer.max_wait || max_time > time_limit) {\n            return false;\n        }\n        \n        end_times[earliest_operator] += customer.support_time;\n    }\n    \n    return max_time <= time_limit;\n}\n\nint findMinimumOperators(vector<Customer>& customers, int time_limit) {\n    int low = 1, high = customers.size(), mid, result = high;\n    \n    while (low <= high) {\n        mid = (low + high) / 2;\n        if (canHandleAllCalls(customers, mid, time_limit)) {\n            result = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    int n, time_limit;\n    cin >> n >> time_limit;\n    vector<Customer> customers(n);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> customers[i].support_time >> customers[i].max_wait >> customers[i].interval;\n    }\n    \n    int min_operators = findMinimumOperators(customers, time_limit);\n    cout << min_operators << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:29:04"
  }
]