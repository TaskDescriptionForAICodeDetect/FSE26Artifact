[
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nsigned main(){\n\tint n,m,co=0;\n\twhile(cin>>n>>m,n){\n\t\tif(co++)cout<<endl;\n\t\tvvi cost(n,vi(n,inf));\n\t\trep(i,n)cost[i][i]=0;\n\t\tvvp G(n);\n\t\trep(i,m){\n\t\t\tint a,b,c;cin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t\tG[a].pb({b,c});\n\t\t\tG[b].pb({a,c});\n\t\t}\n\t\trep(i,n)sort(all(G[i]));\n\t\trep(k,n)rep(i,n)rep(j,n)\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n\t\tvvi go(n,vi(n,inf));\n\t\trep(i,n)rep(j,n)if(i!=j)rep(k,G[i].size())if(cost[i][j]==G[i][k].second+cost[G[i][k].first][j]){\n\t\t\tgo[i][j]=G[i][k].first;break;\n\t\t}\n\n\t\tint q;\n\t\tcin>>q;\n\t\tvi s(q),t(q),hu(n),ob(q);\n\t\tvs name(q);\n\t\trep(i,q)cin>>s[i]>>t[i]>>ob[i]>>name[i];\n\t\trep(i,q)s[i]--,t[i]--;\n\t\twhile(1){\n\t\t\tint mi=inf,from=-1;\n\t\t\trep(i,q)if(s[i]!=t[i]){\n\t\t\t\tint tim=max(ob[i],hu[s[i]]);\n\t\t\t\tif(mi>tim)mi=tim,from=s[i];\n\t\t\t}\n\t\t\tif(from==-1)break;\n\n\t\t\tint mi_t=inf,to=-1;\n\t\t\trep(i,q)if(s[i]!=t[i]&s[i]==from){\n\t\t\t\tif(mi_t>ob[i])mi_t=ob[i],to=go[s[i]][t[i]];\n\t\t\t\telse if(mi_t==ob[i])to=min(to,go[s[i]][t[i]]);\n\t\t\t}\n\n\t\t\thu[from]=mi+2*cost[from][to];\n\t\t\trep(i,q)if(ob[i]<=mi&&s[i]==from&&go[s[i]][t[i]]==to){\n\t\t\t\tob[i]=mi+cost[from][to];\n\t\t\t\ts[i]=to;\n\t\t\t}\n\t\t}\n\t\tvector<pair<int,string> >out(q);\n\t\trep(i,q)out[i]={ob[i],name[i]};\n\t\tsort(all(out));\n\t\trep(i,q)cout<<out[i].second<<\" \"<<out[i].first<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif // !_WIN32\n\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<iomanip>\n#include<map>\n#include<stack>\n#include<queue>\n#include<utility>\nusing namespace std;\ntypedef long long LL;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\ntypedef pair<LL, string> P;\ntypedef vector<int> V;\ntypedef vector<V> VV;\n//input\nint n, m, l;\nint c[32][32];\nstring label[1123];\nint bg_pos[1123];\nint ed_pos[1123];\nLL bg_time[1123];\n\n\nLL d[32][32];\nint nxt[32][32];\n\nconst LL INF = 1e15;\n\nint exist[32];\nvector<VV> post(32,VV(32));\nLL min_time[32][32];\ntypedef pair<LL, int> pli;\ntemplate<typename T>\nbool chmin(T &a, T b) { bool f = a > b; if (f)a = b; return f; }\nmap<LL, vector<pair<int,int>>> sc;\nvoid sync(LL now_time,vector<P>& answer) {\n\tREP(from, n)if(exist[from]) {\n\t\tpli res(INF,-1);\n\t\tREP(j, n)chmin(res, { min_time[from][j],j });\n\t\tint to = res.second;\n\t\tif (to != -1) {\n\t\t\texist[from] = 0;\n\t\t\tLL next_time = now_time + c[from][to];\n\t\t\tV &now_post = post[from][to];\n\t\t\twhile (now_post.size()) {\n\t\t\t\tint now_item = now_post.back();\n\t\t\t\tif (ed_pos[now_item] == to)\n\t\t\t\t\tanswer.push_back({ next_time,label[now_item] });\n\t\t\t\telse {\n\t\t\t\t\tsc[next_time].push_back({ to,now_item });\n\t\t\t\t\t//cout << label[now_item] << \" \" << from << \"->\" << to << endl;\n\t\t\t\t}\n\t\t\t\tnow_post.pop_back();\n\t\t\t}\n\t\t\tmin_time[from][to] = INF;\n\t\t\tnext_time += c[to][from];\n\t\t\tsc[next_time].push_back({ from,-1 });\n\t\t}\n\t}\n}\nLL clean(LL now_time) {\n\tauto it = sc.upper_bound(now_time);\n\tif (it == sc.end())return -1;\n\tnow_time = it->first;\n\twhile (it->second.size()) {\n\t\tint id = it->second.back().second;\n\t\tint pos = it->second.back().first;\n\t\tif (id == -1)exist[pos] = 1;\n\t\telse {\n\t\t\tint to = nxt[pos][ed_pos[id]];\n\t\t\tchmin(min_time[pos][to], now_time);\n\t\t\tpost[pos][to].push_back(id);\n\t\t}\n\t\tit->second.pop_back();\n\t}\n\treturn now_time;\n}\n\nvoid init() {\n\tsc.clear();\n\tREP(i, 32)REP(j, 32)c[i][j] = -1;\n\tREP(i, 32)REP(j, 32) {\n\t\td[i][j] = INF;\n\t\tnxt[i][j] = -1;\n\t}\n\tREP(i, 32) {\n\t\texist[i] = 1;\n\t\tREP(j,32)post[i][j].clear();\n\t\tREP(j,32)min_time[i][j] = INF;\n\t}\n}\n\nvoid set_nxt(){\n\tREP(t, n) {\n\t\tbool update = true;\n\t\td[t][t] = 0;\n\t\twhile (update) {\n\t\t\tupdate = false;\n\t\t\tREP(i, n)REP(j, n) if(c[i][j]!=-1){\n\t\t\t\tLL nxt_cost = d[i][t] + c[i][j];\n\t\t\t\tif (d[j][t] > nxt_cost) {\n\t\t\t\t\tupdate = true;\n\t\t\t\t\td[j][t] = nxt_cost;\n\t\t\t\t\tnxt[j][t] = i;\n\t\t\t\t}\n\t\t\t\tif (d[j][t] == nxt_cost) {\n\t\t\t\t\tnxt[j][t] = min(nxt[j][t], i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint xxx = 0;\n\twhile (cin >> n >> m, n + m) {\n\t\tif (xxx)cout << endl;\n\t\txxx = 1;\n\t\tinit();\n\t\tREP(i, m) {\n\t\t\tint a, b, x;\n\t\t\tcin >> a >> b >> x;\n\t\t\ta--, b--;\n\t\t\tc[a][b] = c[b][a] = x;\n\t\t}\n\t\tvector<P> res;\n\t\tset_nxt();\n\t\tcin >> l;\n\t\tREP(i, l) {\n\t\t\tcin >> bg_pos[i] >> ed_pos[i] >> bg_time[i] >> label[i];\n\t\t\tbg_pos[i]--;\n\t\t\ted_pos[i]--;\n\t\t\tsc[bg_time[i]].push_back({ bg_pos[i],i });\n\t\t}\n\t\tLL nt = 0;\n\t\twhile (true) {\n\t\t\tnt = clean(nt);\n\t\t\tif (nt == -1)break;\n\t\t\tsync(nt, res);\n\t\t}\n\n\t\tsort(ALL(res));\n\t\tfor (auto &it : res)cout << it.second << \" \" << it.first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nsigned main(){\n\tint n,m,co=0;\n\twhile(cin>>n>>m,n){\n\t\tif(co++)cout<<endl;\n\t\tvvi cost(n,vi(n,inf));\n\t\trep(i,n)cost[i][i]=0;\n\t\tvvp G(n);\n\t\trep(i,m){\n\t\t\tint a,b,c;cin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t\tG[a].pb({b,c});\n\t\t\tG[b].pb({a,c});\n\t\t}\n\t\trep(i,n)sort(all(G[i]));\n\t\trep(k,n)rep(i,n)rep(j,n)\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n\t\tvvi go(n,vi(n,inf));\n\t\trep(i,n)rep(j,n)if(i!=j)rep(k,G[i].size())if(cost[i][j]==G[i][k].second+cost[G[i][k].first][j]){\n\t\t\tgo[i][j]=G[i][k].first;break;\n\t\t}\n\n\t\tint q;\n\t\tcin>>q;\n\t\tvi s(q),t(q),hu(n),ob(q);\n\t\tvs name(q);\n\t\trep(i,q)cin>>s[i]>>t[i]>>ob[i]>>name[i];\n\t\trep(i,q)s[i]--,t[i]--;\n\t\twhile(1){\n\t\t\tint mi=inf,from=-1;\n\t\t\trep(i,q)if(s[i]!=t[i]){\n\t\t\t\tint tim=max(ob[i],hu[s[i]]);\n\t\t\t\tif(mi>tim)mi=tim,from=s[i];\n\t\t\t}\n\t\t\tif(from==-1)break;\n\n\t\t\tint mi_t=inf,to=-1;\n\t\t\trep(i,q)if(s[i]!=t[i]&s[i]==from){\n\t\t\t\tif(mi_t>ob[i])mi_t=ob[i],to=go[s[i]][t[i]];\n\t\t\t\telse if(mi_t==ob[i])to=min(to,go[s[i]][t[i]]);\n\t\t\t}\n\n\t\t\thu[from]=mi+2*cost[from][to];\n\t\t\trep(i,q)if(ob[i]<=mi&&s[i]==from&&go[s[i]][t[i]]==to){\n\t\t\t\tob[i]=mi+cost[from][to];\n\t\t\t\ts[i]=to;\n\t\t\t}\n\t\t}\n\t\tvector<pair<int,string> >out(q);\n\t\trep(i,q)out[i]={ob[i],name[i]};\n\t\tsort(all(out));\n\t\trep(i,q)cout<<out[i].second<<\" \"<<out[i].first<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1000000007)\n\ntypedef pair<int,int> Pii;\ntypedef pair<int,string> Pis;\ntypedef pair< Pii , Pis > PP;\n\nint N,M,K;\nint G[32][32];\nint g[32][32];\n\nset< PP > u[32][32];\n\nint mem[32][32];\n\nint search(int from,int to){\n  if(mem[from][to]!=-1)return mem[from][to];\n  int mini=INF, res=-1;\n  for(int i=0;i<N;i++){\n    if(from==i || g[from][i]==INF)continue;\n    if(mini>g[from][i]+G[i][to]){\n      mini=g[from][i]+G[i][to];\n      res=i;\n    }\n  }\n  assert(res!=-1);\n  return mem[from][to]=res;\n}\n\nvoid init(){\n  for(int i=0;i<32;i++){\n    for(int j=0;j<32;j++){\n      g[i][j]=(i==j?0:INF);\n      G[i][j]=(i==j?0:INF);\n      mem[i][j]=-1;\n      u[i][j].clear();\n    }\n  }\n}\n\nint main(){\n  int cnt=0;\n  while(1){\n\n    init();\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    if(cnt)cout<<endl;\n    cnt++;\n    \n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      G[a][b]=G[b][a]=c;\n    }\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n    \n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    cin>>K;\n\n    map<int, vector<PP> > mp;\n    set<int> st;\n    \n    for(int i=0;i<K;i++){\n      int from,to,ti;\n      string name;\n      cin>>from>>to>>ti>>name;\n      from--,to--;\n      mp[ti].push_back( PP( Pii(from,to) , Pis(0,name)) );\n      st.insert(ti);\n    }\n\n    vector< Pis > ans;\n    vector<int> v(N,0);\n    int last=-1;\n    \n    st.insert(0);\n    while(!st.empty()){\n\n      int p=*st.begin();\n      assert( last < p ); last=p;\n      \n      if(mp.count(p)){\n        for(int i=0;i<(int)mp[p].size();i++){\n          PP pp=mp[p][i];\n          int from=pp.first.first;\n          int to=pp.first.second;\n          string name=pp.second.second;\n          int key=search(from,to);\n          PP tmp=PP( Pii(p, key ) , Pis(to,name) );\n          u[from][key].insert(tmp);\n        }\n        //       mp[p].clear();\n      }\n      \n      for(int i=0;i<N;i++){\n        if(v[i]>p)continue;\n        \n        PP target=PP( Pii(INF,0) , Pis(0,\"\") );\n        \n        for(int j=0;j<N;j++){\n          if(u[i][j].empty())continue;\n          PP pp=*u[i][j].begin();\n          target=min(target,pp);\n        }\n        if(target.first.first==INF)continue;\n\n        int nex=target.first.second;\n        \n        set< PP > :: iterator it;\n        for( it=u[i][nex].begin(); it!= u[i][nex].end() ; it++ ){\n          PP pp=*it;\n          int to=pp.second.first;\n          string name=pp.second.second;\n\n          if(to==nex){\n            ans.push_back( Pis( p+g[i][nex] , name ) );\n          }else{\n            mp[ p+g[i][nex] ].push_back( PP(Pii(nex,to),Pis(0,name)) );\n          }\n        }// iterator\n        \n        u[i][nex].clear();\n        v[i]=p+g[i][nex]*2;\n        st.insert(p+g[i][nex]);\n        st.insert(p+g[i][nex]*2);\n      }// i\n      \n      st.erase(p);\n    }// while ( st.empty() )\n    \n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      Pis p=ans[i];\n      cout<<p.second<<' '<<p.first<<endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tint tm,pos,dist;\n\tstring name;\n\tpacket(int t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x], &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(int x,int y){\n\tconst packet &a=pac[x], &b = pac[y];\n\treturn a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tstring name;\n\tpriority_queue<int,vector<int>,cmp> qu;\n\tfor(;cin>>n>>m,n;){\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=-1;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n\n\t\tfor(;!qu.empty();){\n\t\t\tint pi = qu.top();\n\t\t\tpacket &p = pac[pi];\n\t\t\tt = p.tm;\n\t\t\tf = p.pos;\n\t\t\tif( f == p.dist ){\n\t\t\t\tqu.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( t < bac[f] ){\n\t\t\t\tp.tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n\t\t\t}else{\n\t\t\t\td = to[f][p.dist];\n\t\t\t\tbac[f] = p.tm + 2 * len[p.pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket &q = pac[qi];\n\t\t\t\t\tif(t==q.tm && f==q.pos && to[q.pos][q.dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq.tm = max(q.tm+len[f][d],bac[d]);\n\t\t\t\t\t\tq.pos = d;\n\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tsort(pac.begin(),pac.end(),cmp2);\n//\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n\t\tfor(j=0;j<l;j++)tbl[j]=j;\n\t\tsort(tbl,tbl+l,cmp2);\n\t\tfor(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),pac[tbl[j]].tm);\n\n\t\t**len = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tint tm,pos,dist;\n\tstring name;\n\tpacket(int t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x], &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(int x,int y){\n\tconst packet &a=pac[x], &b = pac[y];\n\treturn a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tstring name;\n\tfor(;cin>>n>>m,n;){\n\t\tpriority_queue<int,vector<int>,cmp> qu;\n\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=-1;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n/*\n\t\tfor(j=1;j<=n;j++)printf(\"\\t%d\",j);\n\t\tfor(i=1;i<=n;i++,puts){\n\t\t\tprintf(\"\\n%d:\",i);\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tprintf(\"\\t%d(%d)\",len[i][j],to[i][j]);\n\t\t}\n\t\treturn 0;\n*/\n\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n\n\t\tfor(;!qu.empty();){\n//printf(\"size: %d\\n\",qu.size());\n\t\t\tint pi = qu.top();\n\t\t\tpacket &p = pac[pi];\n\t\t\tt = p.tm;\n\t\t\tf = p.pos;\n\t\t\tif( f == p.dist ){\n\t\t\t\tqu.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( t < bac[f] ){\n\t\t\t\tp.tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n//\t\t\t\tprintf(\"wait: %s\\n\",p.name.c_str());\n\t\t\t}else{\n\t\t\t\td = to[f][p.dist];\n//\t\t\t\tprintf(\"%d\\t%d -> %d\\t%s\\n\",p.tm,p.pos,t,p.name.c_str());\n\t\t\t\tbac[f] = p.tm + 2 * len[p.pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket &q = pac[qi];\n\t\t\t\t\tif(t==q.tm && f==q.pos && to[q.pos][q.dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq.tm += len[f][d];\n\t\t\t\t\t\tq.pos = d;\n\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tsort(pac.begin(),pac.end(),cmp2);\n//\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n\t\tfor(j=0;j<l;j++)tbl[j]=j;\n\t\tsort(tbl,tbl+l,cmp2);\n\t\tfor(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),pac[tbl[j]].tm);\n\n\t\t**len = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nsigned main(){\n\tint n,m,co=0;\n\twhile(cin>>n>>m,n){\n\t\tif(co++)cout<<endl;\n\t\tvvi cost(n,vi(n,inf));\n\t\trep(i,n)cost[i][i]=0;\n\t\tvvi G(n);\n\t\trep(i,m){\n\t\t\tint a,b,c;cin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t\tG[a].pb(b);\n\t\t\tG[b].pb(a);\n\t\t}\n\t\trep(i,n)sort(all(G[i]));\n\t\trep(k,n)rep(i,n)rep(j,n)\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n\t\tvvi go(n,vi(n,inf));\n\t\trep(i,n)rep(j,n)if(i!=j)rep(k,G[i].size())if(cost[i][j]==cost[i][G[i][k]]+cost[G[i][k]][j]){\n\t\t\tgo[i][j]=G[i][k];break;\n\t\t}\n\n\t\tint q;\n\t\tcin>>q;\n\t\tvi hu(n),ob(q);\n\t\tvp in(q);\n\t\tvs name(q);\n\t\trep(i,q)cin>>in[i].first>>in[i].second>>ob[i]>>name[i];\n\t\trep(i,q)in[i].first--,in[i].second--;\n\t\twhile(1){\n\t\t\tint mi=inf,mii=-1;\n\t\t\trep(i,q)if(in[i].first!=in[i].second){\n\t\t\t\tint tim=max(ob[i],hu[in[i].first]);\n\t\t\t\tif(mi>tim)mi=tim,mii=in[i].first;\n\t\t\t}\n\t\t\tif(mii==-1)break;\n\t\t\tint mi_t=inf,miti=-1;\n\t\t\trep(i,q)if(in[i].first!=in[i].second&&in[i].first==mii){\n\t\t\t\tif(mi_t>ob[i])mi_t=ob[i],miti=i;\n\t\t\t\telse if(mi_t==ob[i]&&go[in[miti].first][in[miti].second]>go[in[i].first][in[i].second])miti=i;\n\t\t\t}\n\t\t\tint from=in[miti].first,to=go[in[miti].first][in[miti].second];\n\t\t\trep(i,q)if(ob[i]==mi_t&&in[i].first==from&&go[in[i].first][in[i].second]==to){\n\t\t\t\thu[from]=mi+2*cost[from][to];\n\t\t\t\tob[i]=mi+cost[from][to];\n\t\t\t\tin[i].first=to;\n\t\t\t}\n\t\t}\n\t\tvector<pair<int,string> >out(q);\n\t\trep(i,q)out[i]={ob[i],name[i]};\n\t\tsort(all(out));\n\t\trep(i,q)cout<<out[i].second<<\" \"<<out[i].first<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nstruct edge{\n    int to;\n    int cost;\n};\nint d[33][33];\n// cur,to\nint nxt[33][33];\nstring letterNames[1001];\n\nconst int INF=1000000000;\nvector<edge>G[101];\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\nvoid calcNxtPlace(int V){\n    for(int i=0;i<33;i++)for(int j=0;j<33;j++)nxt[i][j]=INF;\n    for(int i=0;i<V;i++){\n        for(int j=0;j<V;j++){\n            if(i!=j){\n                int nxtNum=INF;\n                for(int k=0;k<G[i].size();k++){\n                    edge &e=G[i][k];\n                    if(d[i][e.to]+d[e.to][j]==d[i][j])nxtNum=min(nxtNum,e.to);\n                }\n                nxt[i][j]=nxtNum;\n            }\n        }\n    }\n}\n\nstruct Letter{\n    int nxtTo;\n    int goal;\n    int start;\n    int id;\n    int arriveTime;\n    bool operator<(const Letter &lt)const{\n        return arriveTime<lt.arriveTime;\n    }\n};\n\nstruct Event{\n    // 0:,1:úÔ,2:èÌÇÁ\n    int kind;\n    int time;\n    int node;\n    int prvNode;\n    vector<Letter> lts;\n    bool operator<(const Event &e)const{\n        if(time<e.time)true;\n        else if(time>e.time)false;\n        return kind<e.kind;\n    }\n};\n\nint N,M,L;\n// Çõª¶Ý·é©Ç¤©\nbool isExist[1001];\n// eXÖÇÉÂ¢ÄA»ê¼êÌèª·ÅÉçê½©\nbool isArrivalLet[1001][1001];\n// eXÖÇ²ÆÉAèðÔÉÇ\npriority_queue<Letter> postLets[1001];\n// eXÖÇ²ÆÉAèð Äæ²ÆÉÇ\nvector<Letter> postByNxtTo[101][101];\n\nint main(){\n    bool fst=true;\n    while(cin>>N>>M&&(N|M)){\n        if(fst)fst=false;\n        else cout<<endl;\n        for(int i=0;i<1001;i++)isExist[i]=true;\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)postByNxtTo[i][j].clear();\n        memset(isArrivalLet,0,sizeof(isArrivalLet));\n        //vector<Letter> lts;\n        for(int i=0;i<N;i++)while(postLets[i].size())postLets[i].pop();\n        for(int i=0;i<N;i++)for(int j=0;j<N;j++){\n            if(i==j)d[i][j]=0;\n            else d[i][j]=INF;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            edge e;\n            cin>>a>>b>>e.cost;\n            a--;b--;\n            e.to=b;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[a][b]=d[b][a]=e.cost;\n        }\n        cin>>L;\n        priority_queue<Event> pq;\n        warshall_floyd(N);\n        calcNxtPlace(N);\n        for(int i=0;i<L;i++){\n            Letter lt;\n            cin>>lt.start>>lt.goal>>lt.arriveTime;\n            lt.start--;lt.goal--;\n            cin>>letterNames[i];\n            lt.id=i;\n            lt.nxtTo=(nxt[lt.start][lt.goal]);\n            // èÇÁCxg\n            Event ev;\n            ev.prvNode=lt.start;\n            ev.node=lt.start;\n            ev.kind=1;\n            ev.time=lt.arriveTime;\n            ev.lts.push_back(lt);\n            pq.push(ev);\n        }\n        vector<pair<int,string> > res;\n        // CxgðÔÉ\n        while(pq.size()){\n            Event e=pq.top();pq.pop();\n            // \n            if(e.kind==0){\n                // èðXÖÇÉÇÁ\n                for(int i=0;i<e.lts.size();i++){\n                    // goal\n                    if(e.lts[i].goal==e.node)\n                        res.push_back(make_pair(e.time,letterNames[e.lts[i].id]));\n                    else{\n                        //  ÄæðÌêÉÏXµÄ¨­\n                        e.lts[i].nxtTo=nxt[e.node][e.lts[i].goal];\n                        e.lts[i].arriveTime=e.time;\n                        postLets[e.node].push(e.lts[i]);\n                        postByNxtTo[e.node][e.lts[i].nxtTo].push_back(e.lts[i]);\n                    }\n                }\n                // AÒCxgðÇÁ\n                Event ev;\n                ev.node=e.prvNode;\n                ev.kind=2;\n                ev.prvNode=e.node;\n                // ÌCxgÔðo^\n                ev.time=e.time+d[e.node][e.prvNode];\n                pq.push(ev);\n            }\n            // ÇÁ\n            else if(e.kind==1){\n                // èðXÖÇÉÇÁ\n                postLets[e.node].push(e.lts[0]);\n                // èðXÖÇÉ Äæ²ÆÉª¯ÄÇÁ\n                postByNxtTo[e.node][e.lts[0].nxtTo].push_back(e.lts[0]);\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // AÒ\n            else if(e.kind==2){\n                isExist[e.node]=true;\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // o­\n            else if(e.kind==3){\n                //if(!isExist[e.node])continue;\n                //isExist[e.node]=false;\n                // ¡ éèÌÅAàÁÆàÔªÍâ¢àÌðé\n                // ½¾µAÌ Ä³«ª¨È¶àÌÍAÜÆßÄé\n                // ¡±ÌêÉèª¶ÝµÈ¢\n                if(postLets[e.node].empty()){\n                    // wõð¯ßé\n                    isExist[e.node]=true;\n                    continue;\n                }\n                Letter lt=postLets[e.node].top();postLets[e.node].pop();\n                // ·ÅÉçêÄ¢é\n                if(isArrivalLet[e.node][lt.id])continue;\n                Event ev;\n                // éèðZbg\n                ev.lts=postByNxtTo[e.node][lt.nxtTo];\n                // Á½ÌÅgðNA\n                for(int i=0;i<ev.lts.size();i++)isArrivalLet[e.node][ev.lts[i].id]=true;\n                postByNxtTo[e.node][lt.nxtTo].clear();\n                ev.kind=0;\n                ev.node=lt.nxtTo;\n                ev.prvNode=e.node;\n                ev.time=e.time+d[e.node][lt.nxtTo];\n                pq.push(ev);\n            }\n        }\n        sort(res.begin(),res.end());\n        for(int i=0;i<res.size();i++)cout<<res[i].second<<\" \"<<res[i].first<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#error \"X\"\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <map>\nusing namespace std;\nconst int INF = 1e9;\n\nstruct mail(){\n  int time, to, cur, id;\n  bool operator<(mail a, mail b){\n    if(a.time != b.time) return a.time < b.time;\n    return a.to < b.to;\n  }\n};\n\nint main(){\n  int n, m;\n  while(cin >> n >> m, n){\n    vector< vector<int> > D(n, vector<int>(n, INF));\n    vector< vector<bool> > E(n, vector<bool>(n, false));\n    for(int i = 0; i < m; ++i){\n      int u, v, d;\n      cin >> u >> v >> d;\n      --u;--v;\n      D[u][v] = d;\n      D[v][u] = d;\n    }\n    for(int i = 0; i < n; ++i) D[i][i] = 0;\n    for(int k = 0; k < n; ++k){\n      for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n          D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n        }\n      }\n    }\n    vector< vector<int> > next(n, vector<int>(n, -1));\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        int d = INF;\n        for(int k = 0; k < n; ++k){\n          if(D[i][k] + D[k][j] == D[i][j] && D[i][k] < d){\n            next[i][j] = k;\n            d = D[i][k];\n          }\n        }\n      }\n    }\n    int l;\n    cin >> l;\n    vector<string> name(l);\n    map<string, int> M;\n    priority_queue<mail> que;\n    /*\n    for(int i = 0; i < l; ++i){\n      int from, to, time;\n      cin >> from >> to >> time >> name[i];\n      M[name[i]] = i;\n      que.push((mail){time, to, from, i});\n    }\n    */\n    vector<int> T(n, 0);\n    while(!que.empty()){\n      mail x = que.top();\n      que.pop();\n      int v = next[x.cur][x.to];\n      \n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif // !_WIN32\n\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<iomanip>\n#include<map>\n#include<stack>\n#include<queue>\n#include<utility>\n#include<assert.h>\nusing namespace std;\ntypedef long long LL;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\ntypedef pair<LL, string> P;\ntypedef vector<int> V;\ntypedef vector<V> VV;\n//input\nint n, m, l;\nint c[32][32];\nstring label[1123];\nint bg_pos[1123];\nint ed_pos[1123];\nLL bg_time[1123];\n\n\nLL d[32][32];\nint nxt[32][32];\n\nconst LL INF = 1e15;\n\nint exist[32];\nvector<VV> post(32,VV(32));\nLL min_time[32][32];\ntypedef pair<LL, int> pli;\ntemplate<typename T>\nbool chmin(T &a, T b) { bool f = a > b; if (f)a = b; return f; }\nmap<LL, vector<pair<int,int>>> sc;\nvoid sync(LL now_time,vector<P>& answer) {\n\tREP(from, n)if(exist[from]) {\n\t\tpli res(INF,-1);\n\t\tREP(j, n)chmin(res, { min_time[from][j],j });\n\t\tint to = res.second;\n\t\tif (to != -1) {\n\t\t\texist[from] = 0;\n\t\t\tLL next_time = now_time + c[from][to];\n\t\t\tV &now_post = post[from][to];\n\t\t\twhile (now_post.size()) {\n\t\t\t\tint now_item = now_post.back();\n\t\t\t\tif (ed_pos[now_item] == to)\n\t\t\t\t\tanswer.push_back({ next_time,label[now_item] });\n\t\t\t\telse {\n\t\t\t\t\tsc[next_time].push_back({ to,now_item });\n\t\t\t\t\t//cout << label[now_item] << \" \" << from << \"->\" << to << endl;\n\t\t\t\t}\n\t\t\t\tnow_post.pop_back();\n\t\t\t}\n\t\t\tmin_time[from][to] = INF;\n\t\t\tnext_time += c[to][from];\n\t\t\tsc[next_time].push_back({ from,-1 });\n\t\t}\n\t}\n}\nLL clean(LL now_time) {\n\tauto it = sc.upper_bound(now_time);\n\tif (it == sc.end())return -1;\n\tnow_time = it->first;\n\twhile (it->second.size()) {\n\t\tint id = it->second.back().second;\n\t\tint pos = it->second.back().first;\n\t\tif (id == -1)exist[pos] = 1;\n\t\telse {\n\t\t\tint to = nxt[pos][ed_pos[id]];\n\t\t\tchmin(min_time[pos][to], now_time);\n\t\t\tpost[pos][to].push_back(id);\n\t\t}\n\t\tit->second.pop_back();\n\t}\n\treturn now_time;\n}\n\nvoid init() {\n\tsc.clear();\n\tREP(i, 32)REP(j, 32)c[i][j] = -1;\n\tREP(i, 32)REP(j, 32) {\n\t\td[i][j] = INF;\n\t\tnxt[i][j] = -1;\n\t}\n\tREP(i, 32) {\n\t\texist[i] = 1;\n\t\tREP(j,32)post[i][j].clear();\n\t\tREP(j,32)min_time[i][j] = INF;\n\t}\n}\n\nvoid set_nxt(){\n\tREP(t, n) {\n\t\tbool update = true;\n\t\td[t][t] = 0;\n\t\twhile (update) {\n\t\t\tupdate = false;\n\t\t\tREP(i, n)REP(j, n) if(c[i][j]!=-1){\n\t\t\t\tLL nxt_cost = d[i][t] + c[i][j];\n\t\t\t\tif (d[j][t] > nxt_cost) {\n\t\t\t\t\tupdate = true;\n\t\t\t\t\td[j][t] = nxt_cost;\n\t\t\t\t\tnxt[j][t] = i;\n\t\t\t\t}\n\t\t\t\tif (d[j][t] == nxt_cost) {\n\t\t\t\t\tnxt[j][t] = min(nxt[j][t], i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint xxx = 0;\n\twhile (cin >> n >> m, n + m) {\n\t\tif (xxx)cout << endl;\n\t\txxx = 1;\n\t\tinit();\n\t\tREP(i, m) {\n\t\t\tint a, b, x;\n\t\t\tcin >> a >> b >> x;\n\t\t\ta--, b--;\n\t\t\tc[a][b] = c[b][a] = x;\n\t\t}\n\t\tvector<P> res;\n\t\tset_nxt();\n\t\tcin >> l;\n\t\tREP(i, l) {\n\t\t\tcin >> bg_pos[i] >> ed_pos[i] >> bg_time[i] >> label[i];\n\t\t\tbg_pos[i]--;\n\t\t\ted_pos[i]--;\n\t\t\tsc[bg_time[i]].push_back({ bg_pos[i],i });\n\t\t}\n\t\tLL nt = -1;\n\t\twhile (true) {\n\t\t\tnt = clean(nt);\n\t\t\tif (nt == -1)break;\n\t\t\tsync(nt, res);\n\t\t}\n\t\tassert(res.size() == l);\n\t\tsort(ALL(res));\n\t\tfor (auto &it : res)cout << it.second << \" \" << it.first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cost;\n  Edge() {}\n  Edge(int s, int d, int c) : src(s), dst(d), cost(c) {}\n};\n\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nstruct Event{\n  int type;\n  int time;\n  int latter;\n  int office;\n  Event(int ty, int t, int l, int o) : \n    type(ty), time(t), latter(l), office(o) {}\n  bool operator < (const Event& e) const {\n    if(time != e.time) return time < e.time;\n    if(type != e.type) return type < e.type;\n    return office < e.office;\n  }\n  bool operator > (const Event& e) const {\n    return e < *this;\n  }\n};\nstruct Latter{\n  string name;\n  int src, dst;\n};\ntypedef pair<int, string> P;\nvoid print(Event& e){\n  //printf(\"type %d time %d latter %d office %d\\n\", e.type, e.time, e.latter, e.office);\n}\n\nvoid do_send(Event& e, deque<Event>& lq, priority_queue<Event, vector<Event>, greater<Event> >& que, int dist[36][36], vector<bool>& wait){\n  /*\n  printf(\"do_send : lq is\\n\");\n  REP(i, lq.size()) print(lq[i]);\n  cout << endl;\n  */\n  Event se = lq.front(); lq.pop_front();\n  que.push(Event(0, e.time + dist[e.office][se.office], se.latter, se.office));\n  //printf(\"send : \"); print(se);\n  for(deque<Event>::iterator it = lq.begin(); it != lq.end(); ){\n    if(it->office == se.office){\n      que.push(Event(0, e.time + dist[e.office][se.office], it->latter, se.office));\n      //printf(\"send2 : \"); print(*it);\n      it = lq.erase(it);\n    }else{\n      it++;\n    }\n  }\n  que.push(Event(1, e.time + 2 * dist[e.office][se.office], -1, e.office));\n  wait[e.office] = false;\n}\nint main(){\n  int N, M;\n  bool first = true;\n  while(cin >> N >> M && N){\n\n    if(first) first = false;\n    else cout << endl;\n\n    Graph G(N);\n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      G[a].push_back(Edge(a, b, c));\n      G[b].push_back(Edge(b, a, c));\n    }\n    int dist[36][36] = {};\n    REP(i, N) REP(j, N) dist[i][j] = (i != j) ? INF : 0;\n    REP(i, N) FORIT(e, G[i]) dist[e->src][e->dst] = e->cost;\n    REP(k, N) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    // next[i][j] := 現在地i, 目的地jの郵便物の次の行き先\n    int next[36][36] = {};\n    memset(next, -1, sizeof(next));\n    REP(i, N) REP(j, N) if(i != j && !G[i].empty()){\n      next[i][j] = G[i][0].dst;\n      int n_cost = G[i][0].cost + dist[G[i][0].dst][j];\n      int edge_cost = G[i][0].cost;\n      FORIT(e, G[i]){\n        if(make_pair(n_cost, next[i][j]) > make_pair(e->cost + dist[e->dst][j], e->dst)){\n          n_cost = e->cost + dist[e->dst][j];\n          next[i][j] = e->dst;\n          edge_cost = e->cost;\n        }\n      }\n      assert(edge_cost == dist[i][next[i][j]]);\n    }\n    //REP(i, N) REP(j, N) printf(\"next[%d][%d] = %d\\n\", i, j, next[i][j]);\n\n    int L; cin >> L;\n    vector<Latter> latters(L);\n    priority_queue<Event, vector<Event>, greater<Event> > que;\n    vector< deque<Event> > l_que(N);\n    REP(i, L){\n      int time;\n      cin >> latters[i].src >> latters[i].dst >> time >> latters[i].name;\n      latters[i].src--; latters[i].dst--;\n      que.push(Event(0, time, i, latters[i].src));\n    }\n    vector<P> answer;\n    vector<bool> wait(N, true);\n    while(!que.empty()){\n      Event e = que.top(); que.pop();\n      print(e);\n      deque<Event>& lq = l_que[e.office];\n      if(e.type == 0){\n        Latter& l = latters[e.latter];\n        if(l.dst == e.office){\n          answer.push_back(P(e.time, l.name));\n        }else{\n          int to = next[e.office][l.dst];\n          assert(to != -1);\n          Event send(0, e.time, e.latter, to);\n          lq.insert(lower_bound(lq.begin(), lq.end(), send), send);\n          // send\n          if(wait[e.office] && make_pair(e.time, e.office) != make_pair(que.top().time, que.top().office)){\n            do_send(e, lq, que, dist, wait);\n          }\n        }\n      }else if(e.type == 1){\n        wait[e.office] = true;\n        if(!lq.empty()){\n          do_send(e, lq, que, dist, wait);\n        }\n      }\n    }\n    sort(answer.begin(), answer.end());\n    REP(i, answer.size()){\n      printf(\"%s %d\\n\", answer[i].second.c_str(), answer[i].first);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nconst long long INF = 1e10;\ntypedef vector<vector<long long>> Matrix;\n\nstruct Event {\n  long long time;\n  function<void ()> proc;\n\n  bool operator<(const Event& rhs) const {\n    return time > rhs.time;\n  }\n};\n\nstruct Packet {\n  int src, dst;\n  string name;\n};\n\nenum OfficeState { FREE, BUSY };\n\nstruct Office {\n  OfficeState state;\n  multimap<int, Packet> packets;\n\n  Office(): state(FREE) {}\n};\n\nMatrix shortestPath(const Matrix& g) {\n  int n = g.size();\n  Matrix dist(g);\n  for (int k = 0; k < n; ++k)\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n  return dist;\n}\n\nint nextVertex(const Matrix& g, const Matrix& dist, int s, int t) {\n  int n = dist.size();\n  for (int v = 0; v < n; ++v)\n    if (v != s && g[s][v] + dist[v][t] == dist[s][t])\n      return v;\n  assert(false);\n}\n\nint n, m;\nMatrix g, dist;\nvector<Office> offices;\nvector<pair<int, string>> result;\npriority_queue<Event> Q;\n\nvoid onReturn(int time, int office) {\n  offices[office].state = FREE;\n}\n\nvoid onReceive(int time, int office, const vector<Packet>& packets) {\n  Office& o = offices[office];\n  for (auto packet : packets) {\n    if (packet.dst == office) {\n      result.push_back({time, packet.name});\n    } else {\n      int next = nextVertex(g, dist, office, packet.dst);\n      o.packets.insert({next, packet});\n    }\n  }\n}\n\nvoid deliver(int time, int office) {\n  Office& o = offices[office];\n  if (o.state == BUSY || o.packets.empty()) return;\n  o.state = BUSY;\n  auto range = o.packets.equal_range(o.packets.begin()->first);\n  int next = range.first->first;\n  int t1 = time + g[office][next];\n  int t2 = t1 + g[office][next];\n  vector<Packet> ps;\n  for (auto it = range.first; it != range.second; ++it)\n    ps.push_back(it->second);\n  Q.push({t1, bind(onReceive, t1, next, ps)});\n  Q.push({t2, bind(onReturn, t2, office)});\n  o.packets.erase(range.first, range.second);\n}\n\nint main() {\n  for (int T = 0; cin >> n >> m, n | m; ++T) {\n    if (T > 0) { cout << endl; }\n    result.clear();\n    g.assign(n, vector<long long>(n, INF));\n\n    for (int i = 0; i < m; ++i) {\n      int a, b, c; cin >> a >> b >> c; --a; --b;\n      g[a][b] = g[b][a] = c;\n    }\n    for (int i = 0; i < n; ++i)\n      g[i][i] = 0;\n\n    dist = shortestPath(g);\n    offices.assign(n, Office());\n\n    int l; cin >> l;\n    for (int i = 0; i < l; ++i) {\n      int src, dst;\n      long long time;\n      string name;\n      cin >> src >> dst >> time >> name; --src; --dst;\n      Q.push({time, bind(onReceive, time, src, vector<Packet>{{src, dst, name}})});\n    }\n\n    while (!Q.empty()) {\n      int time = Q.top().time;\n      do {\n        Event e = Q.top(); Q.pop();\n        e.proc();\n      } while (!Q.empty() && Q.top().time == time);\n      for (int i = 0; i < n; ++i)\n        deliver(time, i);\n    }\n\n    sort(result.begin(), result.end());\n    for (auto p : result)\n      cout << p.second << \" \" << p.first << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1000000007)\n\ntypedef pair<int,int> Pii;\ntypedef pair<int,string> Pis;\ntypedef pair< Pii , Pis > PP;\n\nint N,M,K;\nint G[32][32];\nint g[32][32];\n\nset< PP > u[32][32];\n\nint mem[32][32];\n\nint search(int from,int to){\n  if(mem[from][to]!=-1)return mem[from][to];\n  int mini=INF, res=-1;\n  for(int i=0;i<N;i++){\n    if(from==i || g[from][i]==INF)continue;\n    if(mini>g[from][i]+G[i][to]){\n      mini=g[from][i]+G[i][to];\n      res=i;\n    }\n  }\n  assert(res!=-1);\n  return mem[from][to]=res;\n}\n\nvoid init(){\n  for(int i=0;i<32;i++){\n    for(int j=0;j<32;j++){\n      g[i][j]=(i==j?0:INF);\n      G[i][j]=(i==j?0:INF);\n      mem[i][j]=-1;\n      u[i][j].clear();\n    }\n  }\n}\n\nint main(){\n  int cnt=0;\n  while(1){\n\n    init();\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    if(cnt)cout<<endl;\n    cnt++;\n    \n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      G[a][b]=G[b][a]=c;\n    }\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n    \n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    cin>>K;\n\n    map<int, vector<PP> > mp;\n    set<int> st;\n    \n    for(int i=0;i<K;i++){\n      int from,to,ti;\n      string name;\n      cin>>from>>to>>ti>>name;\n      from--,to--;\n      mp[ti].push_back( PP( Pii(from,to) , Pis(0,name)) );\n      st.insert(ti);\n    }\n\n    vector< Pis > ans;\n    vector<int> v(N,0);\n\n    st.insert(0);\n    while(!st.empty()){\n      int p=*st.begin();\n      \n      if(mp.count(p)){\n        for(int i=0;i<(int)mp[p].size();i++){\n          PP pp=mp[p][i];\n          int from=pp.first.first;\n          int to=pp.first.second;\n          string name=pp.second.second;\n          int key=search(from,to);\n          PP tmp=PP( Pii(p, key ) , Pis(to,name) );\n          u[from][key].insert(tmp);\n        }\n        mp[p].clear();\n      }\n      \n      for(int i=0;i<N;i++){\n        if(v[i]>p)continue;\n        PP target=PP( Pii(INF,0) , Pis(0,\"\") );\n        for(int j=0;j<N;j++){\n          if(u[i][j].empty())continue;\n          PP pp=*u[i][j].begin();\n          target=min(target,pp);\n        }\n        if(target.first.first==INF)continue;\n\n        int nex=target.first.second;\n        set< PP > :: iterator it;\n        for( it=u[i][nex].begin(); it!= u[i][nex].end() ; it++ ){\n          PP pp=*it;\n          int to=pp.second.first;\n          string name=pp.second.second;\n          \n          if(to==nex){\n            ans.push_back( Pis( p+g[i][nex] , name ) );\n          }else{\n            mp[ p+g[i][nex] ].push_back( PP(Pii(nex,to),Pis(0,name)) );\n          }\n          \n        }// iterator\n        \n        u[i][nex].clear();\n        v[i]=p+g[i][nex]*2;\n        st.insert(v[i]);\n      }// i\n      \n      st.erase(p);\n    }// while ( st.empty() )\n    \n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      Pis p=ans[i];\n      cout<<p.second<<' '<<p.first<<endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n#define mp         make_pair\n#define ALL(C)     (C).begin(),(C).end()\n\nconst int N = 32;\nconst int inf = INT_MAX;\nconst int costinf=(1<<21);\n\n\ntypedef struct{string name;int time,tar;}Mail;\n\n\nclass Postman{\npublic:\n  int time,tar;\n  vector<Mail> mail;\n};\n\n\nint cost[N][N];\nint edge[N][N];//costinf\nint next[N][N];\nvoid wf(int n){\n  rep(i,n)rep(j,n)cost[i][j]=edge[i][j];\n  rep(k,n)rep(i,n)rep(j,n)cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n  rep(i,n){\n    rep(j,n){\n      next[i][j]=100;\n      if (i == j)continue;\n      rep(k,n){\n\tif (i == k)continue;\n\tif (edge[i][k] == costinf)continue;\n\tif (cost[i][j] == edge[i][k]+cost[k][j]){\n\t  next[i][j]=k;\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nclass Postoffice{\npublic:\n  vector<Mail> mail;\n  int find_next_time(int node,int now){\n    int mintime=inf;\n    rep(i,mail.size()){\n      if (mail[i].time < now)return 0;\n      else mintime=min(mintime,mail[i].time);\n    }\n    return mintime;\n  }\n\n  void set_man(int node,int now,Postman &man){\n    int mintime=inf,mindex=100,mingo=inf;\n    rep(i,mail.size()){\n      if (mail[i].time > now)continue;\n      if (mail[i].time < mintime || \n\t  (mintime == mail[i].time && next[node][mail[i].tar] < mindex)){\n\tmintime=mail[i].time;\n\tmingo  =edge[node][next[node][mail[i].tar]];\n\tmindex =next[node][mail[i].tar];\n      }\n    }\n    \n    if (mindex == 100)return;\n\n    //    cout <<node <<\" \" <<  mintime <<\" \" <<now <<\" \" <<  mindex <<\" \" << mingo << endl;\n\n\n    rep(i,mail.size()){\n      if (mail[i].time > now)continue;\n      if (next[node][mail[i].tar] == mindex){\n\tman.mail.pb(mail[i]);\n\tmail.erase(mail.begin()+i);\n\ti--;\n      }\n    }\n    //    cout << \"set_man \" << node <<\" \" << now <<\" \" << mindex <<\" \" << mail.size() << endl;\n    man.time=mingo;\n    man.tar=mindex;\n  }\n};\n\n\nvoid solve(int n,Postman *man,Postoffice *office){\n  vector<pair<int ,string> > ans;\n  int t = 0;\n\n  //initialization\n  wf(n);\n\n  while(true){\n    int minevent=inf;\n    \n    // arrive\n    rep(i,n){\n      if (man[i].tar != -1)minevent=min(minevent,man[i].time);\n    }\n\n    rep(i,n){\n      //      cout << \"man \" << i <<\" \" << man[i].tar <<\" \" << man[i].time << endl;\n    }\n    \n    rep(i,n){\n      if (man[i].tar == -1){\n\tminevent=min(office[i].find_next_time(i,t),minevent);\n      }\n    }\n\n    //    cout << t <<\" \" << minevent << endl;\n    if (minevent == inf)break;\n\n    t+=minevent;\n    \n    rep(i,n){\n      if (man[i].tar != -1){\n\tman[i].time-=minevent;\n\tif (man[i].time == 0){\n\t  if (man[i].tar != i){\n\t    rep(j,man[i].mail.size()){\n\t      if (man[i].tar == man[i].mail[j].tar){\n\t\tans.pb(mp(t,man[i].mail[j].name));\n\t      }\n\t      else {\n\t\tman[i].mail[j].time=t;\n\t\toffice[man[i].tar].mail.pb(man[i].mail[j]);\n\t      }\n\t    }\n\t    man[i].mail.clear();\n\t    man[i].time=cost[man[i].tar][i];\n\t    man[i].tar=i;\n\t  }else if (man[i].tar == i){\n\t    man[i].tar=-1;\n\t  }\n\t}\n      }\n    }\n\n    //    cout <<\"check\" <<endl;\n    rep(i,n){\n      if (man[i].tar != -1)continue;\n      office[i].set_man(i,t,man[i]);\n    }\n    //    cout <<\"check 2 \"<<endl;\n  }\n\n\n\n  sort(ALL(ans));\n  rep(i,ans.size()){\n    cout << ans[i].second <<\" \" << ans[i].first << endl;\n  }\n}\n\nmain(){\n  int n,m;\n  int te=0;\n  while(cin>>n>>m && n){\n    if (te)cout<<endl;\n    te++;\n    rep(i,n){\n      rep(j,n)edge[i][j]=costinf;\n      edge[i][i]=0;\n    }\n    Postman    man[n];\n    Postoffice     office[n];\n    rep(i,n)man[i].tar=-1;\n    \n    \n    rep(i,m){\n      int f,t,c;\n      cin>>f>>t>>c;\n      f--;t--;\n      edge[f][t]=edge[t][f]=c;\n    }\n    \n    int l;\n    cin>>l;\n    rep(i,l){\n      int fr,to,ti;\n      string name;\n      cin>>fr>>to>>ti>>name;\n      office[fr-1].mail.pb((Mail){name,ti,to-1});\n    }\n    \n    solve(n,man,office);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n\nstruct Edge{\n\tint a,b,c;\n\tEdge(int a,int b,int c) : a(a),b(b),c(c){}\n};\n\nvector<Edge> v[32];\nint next[1000][32];\nstring name[1000];\n\n\nstruct Info{\n\tint id;\n\tint pos;\n\tint time;\n\tint otodoke;\n\tInfo(){}\n\tInfo(int id,int pos,int time,int otodoke) : id(id),pos(pos),time(time),otodoke(otodoke){}\n};\n\nbool operator < (const Info &a,const Info &b){\n\tif( a.time != b.time ) return a.time > b.time ;\n\tif( a.pos != b.pos ) return a.pos > b.pos;\n\tif( a.otodoke != b.otodoke ) return a.otodoke > b.otodoke;\n\treturn next[a.id][a.pos] > next[b.id][b.pos];\n}\n\n\nint main(){\n\tint blflg=0;\n\tint n,m;\n\twhile(cin >> n >> m && n){\n\t\tif(blflg++)cout << endl;\n\t\tlong long wf[100][100];\n\t\tfor(int i = 0 ; i < 100 ; i++){\n\t\t\tfor(int j = 0 ; j < 100 ; j++){\n\t\t\t\twf[i][j] = i==j?0:1e10;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpriority_queue<Info> Q;\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--,b--;\n\t\t\twf[a][b] = c;\n\t\t\twf[b][a] = c;\n\t\t\tv[a].push_back(Edge(a,b,c));\n\t\t\tv[b].push_back(Edge(b,a,c));\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tfor(int k = 0 ; k < n ; k++){\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l;\n\t\tcin >> l;\n\t\tfor(int i = 0 ; i < l ; i++){\n\t\t\tint a,b,t;\n\t\t\tcin >> a >> b >> t >> name[i];\n\t\t\ta--,b--;\n\t\t\tint cur = a;\n\t\t\twhile( cur != b ){\n\t\t\t\tnext[i][cur] = 1e9;\n\t\t\t\tfor(int j = 0 ; j < v[cur].size() ; j++){\n\t\t\t\t\tif( wf[cur][b] == wf[v[cur][j].b][b]+v[cur][j].c ){\n\t\t\t\t\t\tnext[i][cur] = min(next[i][cur],v[cur][j].b);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = next[i][cur];\n\t\t\t}\n\t\t\tnext[i][cur] = -1;\n\t\t\tQ.push(Info(i,a,t,t));\n\t\t}\n\t\tvector< pair<int,string> > sorted;\n\t\t\n\t\tint waiting[32]={};\n\t\t\n\t\tint prev = 0;\n\t\twhile(Q.size()){\n\t\t\tInfo q = Q.top();\n\t\t\t\n\t\t\t//cout << \"[\" << q.time << \"]\" << name[q.id] << \" \" << q.pos  << \" \" << q.otodoke << endl;\n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\twaiting[i] = max(waiting[i]-(q.time-prev),0);\n\t\t\t}\n\t\t\tprev = q.time;\n\t\t\tvector<Info> chk;\n\t\t\twhile(Q.size() && Q.top().time == q.time && Q.top().pos == q.pos && next[Q.top().id][Q.top().pos] == next[q.id][q.pos] ){\n\t\t\t\tchk.push_back(Q.top()); Q.pop();\n\t\t\t}\n\t\t\tif( next[q.id][q.pos] == -1 ){\n\t\t\t\tfor(int i = 0 ; i < chk.size() ; i++){\n\t\t\t\t\tsorted.push_back(make_pair(chk[i].otodoke,name[chk[i].id]));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( waiting[q.pos] ){\n\t\t\t\tfor(int i = 0 ; i < chk.size() ; i++){\n\t\t\t\t\tQ.push(Info(chk[i].id,chk[i].pos,chk[i].time+waiting[q.pos],chk[i].otodoke));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < chk.size() ; i++){\n\t\t\t\t//cout << chk[i].pos << \" \" << next[chk[i].id][chk[i].pos] << \" < \" << endl;\n\t\t\t\tint cst = wf[chk[i].pos][next[chk[i].id][chk[i].pos]];\n\t\t\t\tQ.push(Info(chk[i].id,next[chk[i].id][chk[i].pos],chk[i].time+cst,chk[i].time+cst));\n\t\t\t\twaiting[q.pos] = 2*cst;\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort(sorted.begin(),sorted.end());\n\t\tfor(int i = 0 ; i < sorted.size() ; i++)\n\t\t\tcout << sorted[i].second << \" \" << sorted[i].first << endl;\n\t}\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  06:38 - 03:41\n */\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cassert>\n#include<climits>\n#include<cstdio>\n#include<cmath>\n#include<map>\n#include<set>\n#include<deque>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define LLINF (LLONG_MAX)\n#define MAX_V 33\n#define MAX_E 500\n#define all(n) begin(n),end(n)\n \nusing namespace std;\n \nconst bool DEBUG = false;\n \ntypedef long long ll;\ntypedef pair<int,string> is;\n \nstruct Data{\n  ll to,cost;\n  Data(ll to=-1,ll cost=-1):to(to),cost(cost){}\n  bool operator < (const Data& data)const { return cost > data.cost; }\n};\n \nstruct Object{\n  ll from,to,timer;\n  string label;\n  ll priority;\n  Object(ll from=-1,ll to=-1,ll timer=-1,string label=\"\",ll priority=-1):from(from),to(to),timer(timer),label(label),priority(priority){}\n  bool operator < (const Object& obj)const {\n    if(priority != obj.priority)return priority < obj.priority;\n    if( timer != obj.timer )return timer < obj.timer;\n    return to < obj.to;\n  }\n};\n \nvector<Data> G[MAX_V];\nll mincost[MAX_V][MAX_V];\nll pre[MAX_V][MAX_V];\nll V,E,clist[MAX_V][MAX_V];\n \nvoid dijkstra(){\n  rep(i,V)REP(j,i,V)mincost[i][j] = mincost[j][i] = pre[i][j] = pre[j][i] = LLINF;\n  rep(goal,V){\n    mincost[goal][goal] = 0;\n    priority_queue<Data> Q;\n    Q.push(Data(goal,0));\n    while(!Q.empty()){\n      Data data = Q.top(); Q.pop();\n      ll cur = data.to;\n      ll cost = data.cost;\n      if( mincost[cur][goal] < cost )continue;\n      rep(i,(int)G[cur].size()){\n\tll next = G[cur][i].to;\n\tll ncost = G[cur][i].cost;\n\tif(mincost[next][goal] >= cost + ncost){\n\t  if(mincost[next][goal] == cost + ncost) pre[next][goal] = min(pre[next][goal],cur);\n\t  if(mincost[next][goal] > cost + ncost)  pre[next][goal] = cur;\n\t  mincost[next][goal] = cost + ncost;\n\t  Q.push(Data(next,mincost[next][goal]));\n\t}\n      }\n    }\n  }\n}\n \n \nvoid simulation(){\n  int n;\n  cin >> n;\n  ll *schedule = new ll[V]; // coefficient\n  rep(i,V)schedule[i] = 0;\n  deque<Object> *PostOffice = new deque<Object>[V];\n  deque<Object> item;\n  vector<is> ans;\n  rep(i,n){\n    ll sp,gp,tm;\n    string label;\n    cin >> sp >> gp >> tm >> label;\n    --sp,--gp;\n    item.push_back(Object(sp,gp,tm,label,0));\n  }\n  sort(all(item));\n  ll remain = n,event_time = -1,next_pos,phase = 0,pe = -1;\n  while(remain){\n    event_time = LLINF,next_pos = -1;\n    if(!item.empty()){\n      sort(all(item));\n      event_time = item.front().timer;\n    }\n    rep(i,V)if(!PostOffice[i].empty()){\n      sort(all(PostOffice[i]));\n      rep(j,(int)PostOffice[i].size()){\n\tif( event_time > PostOffice[i][j].timer+mincost[i][pre[i][PostOffice[i][j].to]]){\n\t  event_time = PostOffice[i][j].timer+mincost[i][pre[i][PostOffice[i][j].to]];\n\t  next_pos = i;\n\t}\n      }\n    }\n    if( pe != event_time ) phase++;\n\n    pe = event_time;\n    if( !item.empty() && event_time == item.front().timer){\n      while( !item.empty() && item.front().timer == event_time){\n\tObject obj = item.front(); item.pop_front();\n\tif( obj.from == obj.to ){\n\t  ans.push_back(is(obj.timer,obj.label));\n\t  remain--;\n\t  continue;\n\t}\n\tobj.timer = max(obj.timer,schedule[obj.from]);\n\tobj.priority = phase;\n\tPostOffice[obj.from].push_back(obj);\n\tsort(all(PostOffice[obj.from]));\n      }\n      continue;\n    }\n    vector<Object> use,tmp;\n    ll dest = PostOffice[next_pos].front().to,current_time = PostOffice[next_pos].front().timer;\n    for(Object& obj : PostOffice[next_pos]){\n      if( current_time >= obj.timer &&  pre[next_pos][dest] == pre[obj.from][obj.to] ) use.push_back(obj);\n      else tmp.push_back(obj);\n    }\n    PostOffice[next_pos].clear();\n    rep(j,(int)tmp.size()){\n      tmp[j].timer = max(tmp[j].timer,use[0].timer+mincost[next_pos][pre[next_pos][dest]]*2);\n      PostOffice[next_pos].push_back(tmp[j]);\n    }\n    schedule[next_pos] = use[0].timer+mincost[next_pos][pre[next_pos][dest]]*2;\n    rep(j,(int)use.size()){\n      use[j].timer +=  mincost[next_pos][pre[next_pos][dest]];\n      use[j].from = pre[next_pos][dest];\n      use[j].priority = -1;\n      item.push_back(use[j]);\n    }\n  }\n  delete [] schedule;\n  delete [] PostOffice;\n  sort(all(ans));\n  rep(i,(int)ans.size()) cout << ans[i].second << \" \" << ans[i].first << endl;\n}\n \nint main(){\n  bool F = true;\n  while(cin >> V >> E, V|E){\n    if(!F)puts(\"\");\n    F = false;\n    rep(i,V)G[i].clear();\n    rep(i,V)rep(j,V)clist[i][j] = LLINF;\n    rep(i,E){\n      int a,b,cost;\n      cin >> a >> b >> cost;\n      a--,b--;\n      G[a].push_back(Data(b,cost));\n      G[b].push_back(Data(a,cost));\n      clist[a][b] = clist[b][a] = cost;\n    }\n    dijkstra();\n    simulation();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cost;\n  Edge() {}\n  Edge(int s, int d, int c) : src(s), dst(d), cost(c) {}\n};\n\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nstruct Event{\n  int type;\n  int time;\n  int latter;\n  int office;\n  Event(int ty, int t, int l, int o) : \n    type(ty), time(t), latter(l), office(o) {}\n  bool operator < (const Event& e) const {\n    if(time != e.time) return time < e.time;\n    if(type != e.type) return type < e.type;\n    return office < e.office;\n  }\n  bool operator > (const Event& e) const {\n    return e < *this;\n  }\n};\nstruct Latter{\n  string name;\n  int src, dst;\n};\ntypedef pair<int, string> P;\nvoid print(Event& e){\n  //printf(\"type %d time %d latter %d office %d\\n\", e.type, e.time, e.latter, e.office);\n}\n\nvoid do_send(Event& e, deque<Event>& lq, priority_queue<Event, vector<Event>, greater<Event> >& que, int dist[36][36], vector<bool>& wait){\n  /*\n  printf(\"do_send : lq is\\n\");\n  REP(i, lq.size()) print(lq[i]);\n  cout << endl;\n  */\n  Event se = lq.front(); lq.pop_front();\n  que.push(Event(0, e.time + dist[e.office][se.office], se.latter, se.office));\n  //printf(\"send : \"); print(se);\n  for(deque<Event>::iterator it = lq.begin(); it != lq.end(); ){\n    if(it->office == se.office){\n      que.push(Event(0, e.time + dist[e.office][se.office], it->latter, se.office));\n      //printf(\"send2 : \"); print(*it);\n      it = lq.erase(it);\n    }else{\n      it++;\n    }\n  }\n  que.push(Event(1, e.time + 2 * dist[e.office][se.office], -1, e.office));\n  wait[e.office] = false;\n}\nint main(){\n  int N, M;\n  bool first = true;\n  while(cin >> N >> M && N){\n\n    if(first) first = false;\n    else cout << endl;\n\n    Graph G(N);\n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      G[a].push_back(Edge(a, b, c));\n      G[b].push_back(Edge(b, a, c));\n    }\n    int dist[36][36] = {};\n    REP(i, N) REP(j, N) dist[i][j] = (i != j) ? INF : 0;\n    REP(i, N) FORIT(e, G[i]) dist[e->src][e->dst] = e->cost;\n    REP(k, N) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    // next[i][j] := 現在地i, 目的地jの郵便物の次の行き先\n    int next[36][36] = {};\n    memset(next, -1, sizeof(next));\n    REP(i, N) REP(j, N) if(i != j && !G[i].empty()){\n      next[i][j] = G[i][0].dst;\n      int n_cost = G[i][0].cost + dist[G[i][0].dst][j];\n      int edge_cost = G[i][0].cost;\n      FORIT(e, G[i]){\n        if(make_pair(n_cost, next[i][j]) > make_pair(e->cost + dist[e->dst][j], e->dst)){\n          n_cost = e->cost + dist[e->dst][j];\n          next[i][j] = e->dst;\n          edge_cost = e->cost;\n        }\n      }\n      assert(edge_cost == dist[i][next[i][j]]);\n    }\n    //REP(i, N) REP(j, N) printf(\"next[%d][%d] = %d\\n\", i, j, next[i][j]);\n\n    int L; cin >> L;\n    vector<Latter> latters(L);\n    priority_queue<Event, vector<Event>, greater<Event> > que;\n    vector< deque<Event> > l_que(N);\n    REP(i, L){\n      int time;\n      cin >> latters[i].src >> latters[i].dst >> time >> latters[i].name;\n      latters[i].src--; latters[i].dst--;\n      que.push(Event(0, time, i, latters[i].src));\n    }\n    vector<P> answer;\n    vector<bool> wait(N, true);\n    while(!que.empty()){\n      Event e = que.top(); que.pop();\n      print(e);\n      deque<Event>& lq = l_que[e.office];\n      if(e.type == 0){\n        Latter& l = latters[e.latter];\n        if(l.dst == e.office){\n          answer.push_back(P(e.time, l.name));\n        }else{\n          int to = next[e.office][l.dst];\n          assert(to != -1);\n          Event send(0, e.time, e.latter, to);\n          lq.insert(lower_bound(lq.begin(), lq.end(), send), send);\n          // send\n          if(wait[e.office] && (que.empty() || (make_pair(e.time, e.office) != make_pair(que.top().time, que.top().office)))){\n            do_send(e, lq, que, dist, wait);\n          }\n        }\n      }else if(e.type == 1){\n        wait[e.office] = true;\n        if(!lq.empty()){\n          do_send(e, lq, que, dist, wait);\n        }\n      }\n    }\n    REP(i, N) assert(wait[i]);\n    sort(answer.begin(), answer.end());\n    assert(answer.size() == latters.size());\n    REP(i, answer.size()){\n      printf(\"%s %d\\n\", answer[i].second.c_str(), answer[i].first);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<26)\n \ntypedef pair<int,int> Pii;\ntypedef pair<int,string> Pis;\ntypedef pair< Pii , Pis > PP;\n \nint N,M,K;\nint G[32][32];\nint g[32][32];\n \nset< PP > t[32];\nset< PP > u[32][32];\n \nint search(int from,int to){\n  int mini=INF, res=-1;\n  for(int i=0;i<N;i++){\n    if(from!=i && mini > g[from][i] + G[i][to] ){\n      mini=g[from][i]+G[i][to];\n      res=i;\n    }\n  }\n  return res;\n}\n \nvoid init(){\n  for(int i=0;i<32;i++){\n    t[i].clear();\n    for(int j=0;j<32;j++){\n      g[i][j]=(i==j?0:INF);\n      G[i][j]=(i==j?0:INF);\n      u[i][j].clear();\n    }\n  }\n}\n \nint main(){\n  int cnt=0;\n  while(1){\n \n \n    init();\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    if(cnt)cout<<endl;\n    cnt++;\n     \n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      G[a][b]=min(G[a][b],c);\n      G[b][a]=min(G[b][a],c);\n    }\n     \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n     \n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n     \n    cin>>K;\n \n    map<int, vector<PP> > mp;\n    set<int> st;\n     \n    for(int i=0;i<K;i++){\n      int from,to,ti;\n      string name;\n      cin>>from>>to>>ti>>name;\n      from--,to--;\n      mp[ti].push_back( PP( Pii(from,to) , Pis(0,name)) );\n      st.insert(ti);\n    }\n \n    vector< Pis > ans;\n    vector<int> v(N,0);\n \n     \n    st.insert(0);\n    while(!st.empty()){\n      int p=*st.begin();\n      if(mp.count(p)){\n        for(int i=0;i<(int)mp[p].size();i++){\n          PP pp=mp[p][i];\n          int from=pp.first.first;\n          int to=pp.first.second;\n          string name=pp.second.second;\n          int key=search(from,to);\n           \n          PP tmp=PP( Pii(p, key ) , Pis(to,name) );\n          t[from].insert(tmp);\n          u[from][ key ].insert(tmp);\n        }\n      }\n       \n      for(int i=0;i<N;i++){\n        if(v[i]>p)continue;\n        if(t[i].empty())continue;\n \n        PP target=*t[i].begin();\n\n        int nex= target.first.second;\n        set< PP > :: iterator it;\n        for( it=u[i][nex].begin(); it!= u[i][nex].end() ; it++ ){\n          PP pp=*it;\n          int to=pp.second.first;\n          string name=pp.second.second;\n\n          assert( t[i].count(pp) );\n          t[i].erase(pp);\n          \n          if(to==nex){\n            ans.push_back( Pis( p+g[i][nex] , name ) );\n            continue;\n          }\n \n          mp[ p+g[i][nex] ].push_back( PP(Pii(nex,to),Pis(0,name)) );\n           \n        }// iterator\n         \n        u[i][nex].clear();\n        v[i]=p+g[i][nex]*2;\n        st.insert(v[i]);\n      }// i\n       \n      st.erase( st.begin() );\n    }// st.empty()\n \n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      Pis p=ans[i];\n      cout<<p.second<<' '<<p.first<<endl;\n    }\n  }\n \n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 10000000\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,string> P2;\n\nstruct edge{\n\tint t,c;\n\tedge(){}\n\tedge(int tt,int cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nstruct data{\n\tint f,id;\n\tint ti,gt,next;\n\tdata(){}\n\tdata(int ff,int ii,int tt,int gg,int nn){\n\t\tf=ff;\n\t\tid=ii;\n\t\tti=tt;\n\t\tgt=gg;\n\t\tnext=nn;\n\t}\n\tbool operator<(const data& d)const{\n\t\tif(ti==d.ti){\n\t\t\tif(gt==d.gt)return next>d.next;\n\t\t\treturn gt>d.gt;\n\t\t}\n\t\treturn ti>d.ti;\n\t}\n};\n\nint n,m,l;\nvector<edge> G[1001];\n\nint dist[33];\nint dijk(int f,int t){\n\tfill(dist,dist+n,INF);\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,t));\n\tint res=n;\n\tdist[t]=0;\n\twhile(que.size()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tif(dist[p.second]<p.first)continue;\n\t\tfor(int j=0;j<G[p.second].size();j++){\n\t\t\tedge e=G[p.second][j];\n\t\t\tif(e.t==f && dist[e.t]==dist[p.second]+e.c)res=min(res,p.second);\n\t\t\tif(dist[e.t]>dist[p.second]+e.c){\n\t\t\t\tif(e.t==f)res=p.second;\n\t\t\t\tdist[e.t]=dist[p.second]+e.c;\n\t\t\t\tque.push(P(dist[e.t],e.t));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\npriority_queue<data> que[35];\nstring str[1001];\nint lf[1001],lt[1001],ltime[1001];\nint next[35];\nint ntime[35];\npriority_queue<P,vector<P>,greater<P> > backer;\nvector<P2> res;\n\nint main(void){\n\tbool space=false;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tif(space)cout << endl;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tspace=true;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint f,t,c;\n\t\t\tscanf(\"%d%d%d\",&f,&t,&c);\n\t\t\tf--;\n\t\t\tt--;\n\t\t\tG[f].push_back(edge(t,c));\n\t\t\tG[t].push_back(edge(f,c));\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\twhile(que[i].size())que[i].pop();\n\t\t}\n\t\twhile(backer.size())backer.pop();\n\t\tscanf(\"%d\",&l);\n\t\tfor(int i=0;i<l;i++){\n\t\t\tcin >> lf[i] >> lt[i] >> ltime[i] >> str[i];\n\t\t\tlf[i]--;\n\t\t\tlt[i]--;\n\t\t\tque[lf[i]].push(data(-1,i,ltime[i],ltime[i],dijk(lf[i],lt[i])));\n\t\t}\n\t\tmemset(next,0,sizeof(next));\n\t\tmemset(ntime,0,sizeof(ntime));\n\t\tres.clear();\n\t\twhile(1){\n\t\t\tbool flag=false;\n\t\t\tint best=0,bt=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(que[i].size()>0){\n\t\t\t\t\tdata p=que[i].top();\n\t\t\t\t\tif(!flag){\n\t\t\t\t\t\tbest=p.ti;\n\t\t\t\t\t\tbt=i;\n\t\t\t\t\t}\n\t\t\t\t\tflag=true;\n\t\t\t\t\tif(best>p.ti){\n\t\t\t\t\t\tbt=i;\n\t\t\t\t\t\tbest=p.ti;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag)break;\n\t\t\tdata v=que[bt].top();\n\t\t\tque[bt].pop();\n\t\t\twhile(backer.size()){\n\t\t\t\tP p=backer.top();\n\t\t\t\tif(p.first<=v.ti){\n\t\t\t\t\tbacker.pop();\n\t\t\t\t\tnext[p.second]=0;\n\t\t\t\t}else break;\n\t\t\t}\n\t\t\tif(bt==lt[v.id]){\n\t\t\t\tres.push_back(P2(v.ti,str[v.id]));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(next[bt]==-1){\n\t\t\t\tv.ti=ntime[bt];\n\t\t\t\tque[bt].push(v);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nex=dijk(bt,lt[v.id]);\n\t\t\tint now=v.ti;\n\t\t\tint plu=0;\n\t\t\tfor(int i=0;i<G[bt].size();i++){\n\t\t\t\tif(nex==G[bt][i].t)plu=G[bt][i].c;\n\t\t\t}\n\t\t\tnext[bt]=-1;\n\t\t\tntime[bt]=v.ti+plu*2;\n\t\t\tbacker.push(P(v.ti+plu*2,bt));\n\t\t\tv.ti+=plu;\n\t\t\tque[nex].push(data(bt,v.id,v.ti,v.ti,(nex==lt[v.id])?-1:dijk(nex,lt[v.id])));\n\t\t\tqueue<data> tmp;\n\t\t\twhile(que[bt].size()){\n\t\t\t\tdata pp=que[bt].top();\n\t\t\t\tif(pp.ti>now)break;\n\t\t\t\tque[bt].pop();\n\t\t\t\tif(pp.next==nex){\n\t\t\t\t\tque[nex].push(data(bt,pp.id,v.ti,v.ti,(nex==lt[pp.id])?-1:dijk(nex,lt[pp.id])));\n\t\t\t\t}else{\n\t\t\t\t\ttmp.push(pp);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(tmp.size()){\n\t\t\t\tdata pp=tmp.front();\n\t\t\t\tque[bt].push(pp);\n\t\t\t\ttmp.pop();\n\t\t\t}\n\t\t}\n\t\tsort(res.begin(),res.end());\n\t\tfor(int i=0;i<res.size();i++){\n\t\t\tcout << res[i].second << \" \" << res[i].first << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n//#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define BIG_NUM INT_MAX\n#define NUM 32\n#define SIZE 1000\n\nenum Type{\n\tHuman,\n\tLetter,\n};\n\nstruct Edge{\n\tEdge(int arg_to,int arg_dist){\n\t\tto = arg_to;\n\t\tdist = arg_dist;\n\t}\n\tint to,dist;\n};\n\nstruct Porter{\n\tint home_office;\n\tvector<int> Bag;\n};\n\nstruct Item{\n\tstring name;\n\tint final_office;\n};\n\nstruct Data{\n\tData(int arg_item_id,int arg_arrive_time,int arg_next_loc){\n\t\titem_id = arg_item_id;\n\t\tarrive_time = arg_arrive_time;\n\t\tnext_loc = arg_next_loc;\n\t}\n\tbool operator<(const struct Data& arg) const{\n\t\tif(arrive_time != arg.arrive_time){\n\t\t\treturn arrive_time < arg.arrive_time;\n\t\t}else{\n\t\t\treturn next_loc < arg.next_loc;\n\t\t}\n\t}\n\tint item_id,arrive_time,next_loc;\n};\n\nstruct Office{\n\tbool can_port;\n\tint pre_time; //ポーターが前回帰ってきた時刻\n\tvector<Data> V;\n};\n\nstruct Info{\n\tInfo(Type arg_type,int arg_time,int arg_id,int arg_arrive_loc){\n\t\ttype = arg_type;\n\t\ttime = arg_time;\n\t\tid = arg_id;\n\t\tarrive_loc = arg_arrive_loc;\n\t}\n\tbool operator<(const struct Info &arg) const{ //時刻の昇順(PQ)\n\t\treturn time > arg.time;\n\t}\n\tType type;\n\tint time,id,arrive_loc;\n};\n\nstruct FINISH{\n\tFINISH(string arg_name,int arg_time){\n\t\tname = arg_name;\n\t\ttime = arg_time;\n\t}\n\tbool operator<(const struct FINISH &arg) const{\n\t\tif(time != arg.time){ //時刻または名前の昇順(PQ)\n\t\t\treturn time > arg.time;\n\t\t}else{\n\t\t\treturn name > arg.name;\n\t\t}\n\t}\n\tstring name;\n\tint time;\n};\n\nint N,E;\nint min_dist[NUM][NUM];\nint next_table[NUM][NUM];\nint num_item;\nvector<Edge> G[NUM];\nOffice office[NUM];\nPorter porter[NUM];\nItem item[SIZE];\npriority_queue<Info> EVENT;\npriority_queue<FINISH> ANS;\nint case_num;\n\n\n//転送先へ最短経路で届ける際の、次の中継点を求める\nint find_next(int current,int goal){\n\n\tint minimum = min_dist[current][goal],min_index = BIG_NUM,mid;\n\n\tfor(int i = 0; i < G[current].size(); i++){\n\t\tmid = G[current][i].to;\n\t\tif(G[current][i].dist+min_dist[mid][goal] != minimum)continue;\n\n\t\tmin_index = min(min_index,mid);\n\t}\n\n\treturn min_index;\n}\n\n//bool DEBUG = false;\n\nvoid func(){\n\n\tif(case_num > 0)printf(\"\\n\");\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t\toffice[i].V.clear();\n\t\tporter[i].Bag.clear();\n\t}\n\n\twhile(!EVENT.empty())EVENT.pop();\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(i != k){\n\t\t\t\tmin_dist[i][k] = BIG_NUM;\n\t\t\t}else{\n\t\t\t\tmin_dist[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tint from,to,dist;\n\n\tfor(int loop = 0; loop < E; loop++){\n\n\t\tscanf(\"%d %d %d\",&from,&to,&dist);\n\t\tfrom--;\n\t\tto--;\n\n\t\tmin_dist[from][to] = dist;\n\t\tmin_dist[to][from] = dist;\n\n\t\tG[from].push_back(Edge(to,dist));\n\t\tG[to].push_back(Edge(from,dist));\n\t}\n\n\t//全点対間最短経路\n\tfor(int mid = 0; mid < N; mid++){\n\t\tfor(int start = 0; start < N; start++){\n\t\t\tif(min_dist[start][mid] == BIG_NUM)continue;\n\t\t\tfor(int goal = 0; goal < N; goal++){\n\t\t\t\tif(min_dist[mid][goal] == BIG_NUM)continue;\n\t\t\t\tmin_dist[start][goal] = min(min_dist[start][goal],min_dist[start][mid]+min_dist[mid][goal]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0; a < N; a++){\n\t\tfor(int b = 0; b < N; b++){\n\t\t\tif(a == b)continue;\n\t\t\tnext_table[a][b] = find_next(a,b);\n\t\t}\n\t}\n\n\tscanf(\"%d\",&num_item);\n\n\tint tmp_time;\n\n\tfor(int i = 0; i < num_item; i++){\n\n\t\tcin >> from >> to >> tmp_time >> item[i].name;\n\n\t\tfrom--;\n\t\tto--;\n\n\t\titem[i].final_office = to;\n\n\t\tEVENT.push(Info(Letter,tmp_time,i,from));\n\t}\n\n\t//配達人を、自分の本拠地に配置する\n\tfor(int i = 0; i < N; i++){\n\n\t\tporter[i].home_office = i;\n\n\t\toffice[i].can_port = true;\n\t\toffice[i].pre_time = 0;\n\t}\n\n\tint current_time,tmp_id,tmp_loc,letter_id,tmp_next_loc;\n\n\tint num_finish = 0;\n\tvector<Data> work;\n\n\twhile(!EVENT.empty()){\n\n\t\tcurrent_time = EVENT.top().time;\n\n\t\t//同時刻のイベントを同時に処理する\n\t\twhile(EVENT.empty() == false && EVENT.top().time == current_time){\n\n\t\t\tif(EVENT.top().type == Human){\n\n\t\t\t\ttmp_id = EVENT.top().id;\n\n\t\t\t\tif(porter[tmp_id].home_office == EVENT.top().arrive_loc){ //本拠地に戻った場合\n\n\t\t\t\t\toffice[porter[tmp_id].home_office].can_port = true;\n\t\t\t\t\toffice[porter[tmp_id].home_office].pre_time = EVENT.top().time; //戻った時刻を記録\n\n\t\t\t\t}else{ //別のofficeに到着した場合[★荷物を渡す★]\n\n\t\t\t\t\ttmp_loc = EVENT.top().arrive_loc;\n\t\t\t\t\ttmp_time = EVENT.top().time;\n\n\t\t\t\t\tfor(int i = 0; i < porter[tmp_id].Bag.size(); i++){\n\n\t\t\t\t\t\tletter_id = porter[tmp_id].Bag[i];\n\n\t\t\t\t\t\tif(item[letter_id].final_office == tmp_loc){ //★最終目的地に届いた場合\n\n\t\t\t\t\t\t\tnum_finish++;\n\n\t\t\t\t\t\t\tANS.push(FINISH(item[letter_id].name,tmp_time));\n\t\t\t\t\t\t\tif(num_finish == num_item)break;\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//次の転送先を先に計算しておく\n\t\t\t\t\t\ttmp_next_loc = next_table[tmp_loc][item[letter_id].final_office];\n\t\t\t\t\t\tif(tmp_next_loc == tmp_loc){\n\t\t\t\t\t\t\tprintf(\"BUGG!!\\n\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toffice[tmp_loc].V.push_back(Data(letter_id,tmp_time,tmp_next_loc));\n\t\t\t\t\t}\n\t\t\t\t\tporter[tmp_id].Bag.clear();\n\t\t\t\t\tif(num_finish == num_item)break;\n\n\t\t\t\t\t//★porterが本拠地に戻る★\n\t\t\t\t\tEVENT.push(Info(Human,tmp_time+min_dist[tmp_loc][porter[tmp_id].home_office],tmp_id,porter[tmp_id].home_office));\n\t\t\t\t}\n\n\t\t\t}else{\n\n\t\t\t\tletter_id = EVENT.top().id;\n\t\t\t\ttmp_loc = EVENT.top().arrive_loc;\n\t\t\t\ttmp_time = EVENT.top().time;\n\n\t\t\t\t//転送先を計算\n\t\t\t\ttmp_next_loc = next_table[tmp_loc][item[letter_id].final_office];\n\t\t\t\toffice[tmp_loc].V.push_back(Data(letter_id,tmp_time,tmp_next_loc));\n\t\t\t}\n\n\t\t\tEVENT.pop();\n\t\t}\n\t\tif(num_finish == num_item)break;\n\n\t\t//home_officeにいるporterがいたら、Letterを持ち出す\n\n\t\tint min_time,min_next;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(office[i].can_port == false || office[i].V.size() == 0)continue;\n\n\t\t\t/*\n\t\t\t *最も早く、officeに届いた郵便物を探す。\n\t\t\t *複数あるなら、届先の番号が若い順\n\t\t\t */\n\n\t\t\tsort(office[i].V.begin(),office[i].V.end());\n\n\t\t\tmin_time = office[i].V[0].arrive_time; //★到着が早い順にpushされているはず★\n\t\t\tmin_next = office[i].V[0].next_loc;\n\n\t\t\tfor(int k = 1; k < office[i].V.size(); k++){\n\t\t\t\tif(min_time < office[i].V[k].arrive_time)break;\n\t\t\t\tif(min_time == office[i].V[k].arrive_time){\n\t\t\t\t\tmin_next = min(min_next,office[i].V[k].next_loc);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//届先がmin_nextのletterを、porterに持たせる。porterは出発させる\n\t\t\tfor(int k = 0; k < office[i].V.size(); k++){\n\n\t\t\t\tif(office[i].V[k].next_loc == min_next){ //ポーターのバッグに詰める\n\n\t\t\t\t\tporter[i].Bag.push_back(office[i].V[k].item_id);\n\n\t\t\t\t}else{ //今回は運ばない\n\n\t\t\t\t\twork.push_back(office[i].V[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\toffice[i].V.clear();\n\n\t\t\tif(work.size() > 0){\n\n\t\t\t\tfor(int k = 0; k < work.size(); k++){\n\t\t\t\t\toffice[i].V.push_back(work[k]);\n\t\t\t\t}\n\t\t\t\twork.clear();\n\t\t\t}\n\t\t\t//ポーターの移動\n\t\t\toffice[i].can_port = false;\n\n\t\t\tif(office[i].pre_time <= min_time){ //★porterが待つ場合\n\n\t\t\t\tEVENT.push(Info(Human,min_time+min_dist[i][min_next],i,min_next));\n\n\t\t\t}else{ //★porterが待たない場合\n\n\t\t\t\tEVENT.push(Info(Human,office[i].pre_time+min_dist[i][min_next],i,min_next));\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(!ANS.empty()){\n\n\t\tprintf(\"%s %d\\n\",ANS.top().name.c_str(),ANS.top().time);\n\t\tANS.pop();\n\t}\n\n\tcase_num++;\n}\n\nint main(){\n\n\tcase_num = 0;\n\n\twhile(true){\n\n\t\t//if(DEBUG)break;\n\n\t\tscanf(\"%d %d\",&N,&E);\n\t\tif(N == 0 && E == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<26)\n\ntypedef pair<int,int> Pii;\ntypedef pair<int,string> Pis;\ntypedef pair< Pii , Pis > PP;\n\nint N,M,K;\nint G[32][32];\nint g[32][32];\n\nset< PP > t[32];\nset< PP > u[32][32];\n\nint mem[32][32];\n\nint search(int from,int to){\n  if(mem[from][to]!=-1)\n    return mem[from][to];\n  \n  int mini=INF, res=-1;\n  for(int i=0;i<N;i++){\n    if(from!=i&&\n       g[from][i]!=INF&&\n       mini > g[from][i] + G[i][to] ){\n      mini=g[from][i]+G[i][to];\n      res=i;\n    }\n  }\n  \n  return mem[from][to]=res;\n}\n\nvoid init(){\n  for(int i=0;i<32;i++){\n    t[i].clear();\n    for(int j=0;j<32;j++){\n      g[i][j]=(i==j?0:INF);\n      G[i][j]=(i==j?0:INF);\n      mem[i][j]=-1;\n      u[i][j].clear();\n    }\n  }\n}\n\nint main(){\n  int cnt=0;\n  while(1){\n\n    init();\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    if(cnt)cout<<endl;\n    cnt++;\n    \n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      G[a][b]=min(G[a][b],c);\n      G[b][a]=min(G[b][a],c);\n    }\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n    \n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    cin>>K;\n\n    map<int, vector<PP> > mp;\n    set<int> st;\n    \n    for(int i=0;i<K;i++){\n      int from,to,ti;\n      string name;\n      cin>>from>>to>>ti>>name;\n      from--,to--;\n      mp[ti].push_back( PP( Pii(from,to) , Pis(0,name)) );\n      st.insert(ti);\n    }\n\n    vector< Pis > ans;\n    vector<int> v(N,0);\n\n    st.insert(0);\n    while(!st.empty()){\n      int p=*st.begin();\n      if(mp.count(p)){\n        for(int i=0;i<(int)mp[p].size();i++){\n          PP pp=mp[p][i];\n          int from=pp.first.first;\n          int to=pp.first.second;\n          string name=pp.second.second;\n          int key=search(from,to);\n          PP tmp=PP( Pii(p, key ) , Pis(to,name) );\n          t[from].insert(tmp);\n          u[from][key].insert(tmp);\n        }\n        mp[p].clear();\n      }\n      \n      for(int i=0;i<N;i++){\n        if(v[i]>p)continue;\n        if(t[i].empty())continue;\n\n        PP target=*t[i].begin();\n        t[i].erase( t[i].begin() );\n        int nex=target.first.second;\n        set< PP > :: iterator it;\n        for( it=u[i][nex].begin(); it!= u[i][nex].end() ; it++ ){\n          PP pp=*it;\n          t[i].erase(pp);\n          \n          int to=pp.second.first;\n          string name=pp.second.second;\n          \n          if(to==nex){\n            ans.push_back( Pis( p+g[i][nex] , name ) );\n            continue;\n          }\n\n          mp[ p+g[i][nex] ].push_back( PP(Pii(nex,to),Pis(0,name)) );\n          \n        }// iterator\n        \n        u[i][nex].clear();\n        v[i]=p+g[i][nex]*2;\n        st.insert(v[i]);\n      }// i\n      \n      st.erase( st.begin() );\n    }// st.empty()\n    \n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      Pis p=ans[i];\n      cout<<p.second<<' '<<p.first<<endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct root {\n\tint start;\n\tint goal;\n\tint time;\n\tvector<int>ways;\n\troot():ways() {\n\t\tstart = 0;\n\t\tgoal = 0;\n\t}\n\troot(const int start_, const int goal_, const int time_, const vector<int>ways_)\n\t\t:start(start_), goal(goal_), time(time_), ways(ways_) {\n\n\t}\n};\nstruct edge {\n\tint src;\n\tint dst;\n\tint cost;\n};\n\nstruct query {\n\tint type;\n\tint id;\n\tint num;\n\tint next;\n\tint time;\n\tquery(int type_, int id_, int num_, const int next_, int time_) :type(type_), id(id_), num(num_), next(next_), time(time_) {\n\n\t}\n};\nclass Compare {\npublic:\n\tbool operator()(const query&l, const query&r) {\n\t\treturn l.time==r.time?l.type==r.type?l.next>r.next:l.type<r.type:l.time> r.time;\n\t}\n};\t//aa?????????????????¶\nstruct letter {\n\tint id;\n\tstring name;\n\tvector<int>ways;\n};\nint main() {\n\tint aa = 0;\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tif(aa)\tcout << endl;\n\n\t\taa++;\n\t\t\n\t\tvector<vector<root>>roots(N, vector<root>(N));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\n\t\t\t\troots[i][j].start = i;\n\t\t\t\troots[i][j].goal = j;\n\t\t\t\tif (i == j) {\n\t\t\t\t\troots[i][j].time = 0;\n\t\t\t\t\troots[i][j].ways = vector<int>{};\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\troots[i][j].time = 1e9;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\t\troots[a][b] = root( a,b,c,vector<int>{b} );\n\t\t\troots[b][a] = root(b, a, c, vector<int>{a});\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tif (i == k || j == k||i==j)continue;\n\t\t\t\t\tif (roots[i][k].time < 1e8&&roots[k][j].time < 1e8) {\n\t\t\t\t\t\tconst int  nexttime = roots[i][k].time + roots[k][j].time;\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tvector<int>preways(roots[i][j].ways);\n\t\t\t\t\t\tvector<int>nextways(roots[i][k].ways);\n\t\t\t\t\t\tnextways.insert(nextways.end(), roots[k][j].ways.begin(), roots[k][j].ways.end());\n\t\t\t\t\t\tif (nexttime > roots[i][j].time)ok = false;\n\t\t\t\t\t\telse if (nexttime == roots[i][j].time) {\n\n\t\t\t\t\t\t\tfor (int a= 0; a < preways.size(); ++a) {\n\t\t\t\t\t\t\t\tif (preways[a] > nextways[a]) {\n\t\t\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (preways[a] < nextways[a]) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\troots[i][j].time = nexttime;\n\t\t\t\t\t\t\troots[i][j].ways = nextways;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (roots[i][j].time < 1e8) {\n\t\t\t\t\troots[i][j].ways.insert(roots[i][j].ways.begin(), i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tint L; cin >> L;\n\t\tpriority_queue<query, vector<query>, Compare>que;\n\t\tmap<int,letter>mp;\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint a, b, c; string d; cin >> a >> b >> c >> d; a--; b--;\n\t\t\tmp[i] = letter{ i,d,roots[a][b].ways };\n\t\t\tque.push(query(1,i,0,roots[a][b].ways[0],c ));\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tque.push(query{ 0,0,0,i,0 });\n\t\t}\n\t\tvector<pair< int,string>>anss;\n\t\t//vector<vector<vector<int>>>waits(N,vector<vector<int>>(N,vector<int>()));\n\t\tvector<deque<vector<tuple<int,int,int>>>>nexts(N);\n\t\tvector<int>exists(N);\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tquery q(que.top());\n\t\t\tque.pop();\n\n\t\t\tconst int nowtime = q.time;\n\n\t\t\tconst int nowplace = q.next;\n\t\t\t//??°??£?????????\n\t\t\tif (q.type == 0) {\n\t\t\t\tassert(exists[nowplace] == false);\n\t\t\t\tif (!nexts[nowplace].empty()) {\n\t\t\t\t\tauto carrys(nexts[nowplace].front());\n\t\t\t\t\tfor (auto carry : carrys) {\n\t\t\t\t\t\tint aid = get<0>(carry);\n\t\t\t\t\t\tint anum = get<1>(carry);\n\t\t\t\t\t\tconst int nextplace = mp[aid].ways[anum+1];\n\t\t\t\t\t\tassert(get<2>(carry) == nextplace);\n\t\t\t\t\t\tconst int needtime = roots[nowplace][nextplace].time;\n\t\t\t\t\t\tconst int nexttime = nowtime + needtime;\n\t\t\t\t\t\tconst int backtime = nexttime + needtime;\n\t\t\t\t\t\tque.push(query(1,aid,anum + 1,nextplace,nexttime ));\n\t\t\t\t\t\tque.push(query(0, 0, 0, nowplace, backtime));\n\t\t\t\t\t\texists[nowplace] = false;\n\t\t\t\t\t}\n\t\t\t\t\tnexts[nowplace].pop_back();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(!exists[nowplace]);\n\t\t\t\t\texists[nowplace] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//???????????\\???\n\t\t\telse {\n\t\t\t\tif (q.num == mp[q.id].ways.size() - 1) {\n\t\t\t\t\tanss.push_back(make_pair(q.time, mp[q.id].name));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst int nextplace = mp[q.id].ways[q.num + 1];\n\t\t\t\t\tif (!exists[nowplace]) {\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor (int i = 0; i < nexts[nowplace].size(); ++i) {\n\t\t\t\t\t\t\tif (get<2>(nexts[nowplace][i][0]) == nextplace) {\n\t\t\t\t\t\t\t\tnexts[nowplace][i].push_back(make_tuple(q.id, q.num, nextplace));\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\tnexts[nowplace].push_back(vector<tuple<int,int,int>>(1, make_tuple(q.id, q.num, nextplace)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tassert(nexts[nowplace].empty());\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint aid = q.id;\n\t\t\t\t\t\t\tint anum = q.num;\n\t\t\t\t\t\t\tconst int needtime = roots[nowplace][nextplace].time;\n\t\t\t\t\t\t\tconst int nexttime = nowtime + needtime;\n\t\t\t\t\t\t\tconst int backtime = nexttime + needtime;\n\t\t\t\t\t\t\tque.push(query(1,aid,anum + 1,nextplace,nexttime ));\n\t\t\t\t\t\t\tque.push(query(0, 0, 0, nowplace, backtime));\n\t\t\t\t\t\t\texists[nowplace] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tsort(anss.begin(), anss.end());\n\t\tfor (auto ans : anss) {\n\t\t\tcout << ans.second << \" \" << ans.first << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstring>\n\nusing namespace std;\nconst int INF=1000000000;\n\nstruct edge{\n    int to;\n    int cost;\n};\n\nstruct Letter{\n    int nxtTo;\n    int goal;\n    int start;\n    int id;\n    int arriveTime;\n    bool operator<(const Letter &lt)const{\n        if(arriveTime>lt.arriveTime)true;\n        else if(arriveTime<lt.arriveTime)false;\n        return nxtTo>lt.nxtTo;\n    }\n};\n\nstruct Event{\n    // 0:,1:úÔ,2:èÌÇÁ\n    int kind;\n    int time;\n    int node;\n    int prvNode;\n    vector<Letter> lts;\n    bool operator<(const Event &e)const{\n        if(time>e.time)true;\n        else if(time<e.time)false;\n        return kind>e.kind;\n    }\n};\n\nint d[33][33];\n// cur,to\nint nxt[33][33];\nstring letterNames[1001];\nvector<edge>G[101];\nint N,M,L;\n// Çõª¶Ý·é©Ç¤©\nbool isExist[1001];\n// eXÖÇÉÂ¢ÄA»ê¼êÌèª·ÅÉçê½©\nbool isArrivalLet[1001][1001];\n// eXÖÇ²ÆÉAèðÔÉÇ\npriority_queue<Letter> postLets[1001];\n// eXÖÇ²ÆÉAèð Äæ²ÆÉÇ\nvector<Letter> postByNxtTo[101][101];\n\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\nvoid calcNxtPlace(int V){\n    for(int i=0;i<33;i++)for(int j=0;j<33;j++)nxt[i][j]=INF;\n    for(int i=0;i<V;i++){\n        for(int j=0;j<V;j++){\n            if(i!=j){\n                int nxtNum=INF;\n                for(int k=0;k<G[i].size();k++){\n                    edge &e=G[i][k];\n                    if(d[i][e.to]+d[e.to][j]==d[i][j])nxtNum=min(nxtNum,e.to);\n                }\n                nxt[i][j]=nxtNum;\n            }\n        }\n    }\n}\nint main(){\n    bool fst=true;\n    while(cin>>N>>M&&(N|M)){\n        if(fst)fst=false;\n        else cout<<endl;\n        memset(isArrivalLet,0,sizeof(isArrivalLet));\n        for(int i=0;i<N;i++)G[i].clear();\n        for(int i=0;i<1001;i++)isExist[i]=true;\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)postByNxtTo[i][j].clear();\n        for(int i=0;i<N;i++)while(postLets[i].size())postLets[i].pop();\n        for(int i=0;i<N;i++)for(int j=0;j<N;j++){\n            if(i==j)d[i][j]=0;\n            else d[i][j]=INF;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            edge e;\n            cin>>a>>b>>e.cost;\n            a--;b--;\n            e.to=b;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[a][b]=d[b][a]=e.cost;\n        }\n        warshall_floyd(N);\n        calcNxtPlace(N);\n        cin>>L;\n        priority_queue<Event> pq;\n        for(int i=0;i<L;i++){\n            Letter lt;\n            cin>>lt.start>>lt.goal>>lt.arriveTime;\n            lt.start--;lt.goal--;\n            cin>>letterNames[i];\n            lt.id=i;\n            lt.nxtTo=(nxt[lt.start][lt.goal]);\n            // èÇÁCxg\n            Event ev;\n            ev.prvNode=lt.start;\n            ev.node=lt.start;\n            ev.kind=1;\n            ev.time=lt.arriveTime;\n            ev.lts.push_back(lt);\n            pq.push(ev);\n        }\n        vector<pair<int,string> > res;\n        // CxgðÔÉ\n        while(pq.size()){\n            Event e=pq.top();pq.pop();\n            // \n            if(e.kind==0){\n                // èðXÖÇÉÇÁ\n                for(int i=0;i<e.lts.size();i++){\n                    // goal\n                    if(e.lts[i].goal==e.node)\n                        res.push_back(make_pair(e.time,letterNames[e.lts[i].id]));\n                    else{\n                        //  ÄæðÌêÉÏXµÄ¨­\n                        e.lts[i].nxtTo=nxt[e.node][e.lts[i].goal];\n                        e.lts[i].arriveTime=e.time;\n                        postLets[e.node].push(e.lts[i]);\n                        postByNxtTo[e.node][e.lts[i].nxtTo].push_back(e.lts[i]);\n                    }\n                }\n                // AÒCxgðÇÁ\n                {\n                    Event ev;\n                    ev.node=e.prvNode;\n                    ev.kind=2;\n                    ev.prvNode=e.node;\n                    // ÌCxgÔðo^\n                    ev.time=e.time+d[e.node][e.prvNode];\n                    pq.push(ev);\n                }\n                // Ì]æÖéCxgðÇÁ\n                {\n                    // wõª¢éÈçÎAo­CxgðÇÁ\n                    if(isExist[e.node]){\n                        isExist[e.node]=false;\n                        Event ev;\n                        ev.kind=3;\n                        ev.time=e.time;\n                        ev.node=e.node;\n                        pq.push(ev);\n                    }\n                }\n            }\n            // ÇÁ\n            else if(e.kind==1){\n                // èðXÖÇÉÇÁ\n                postLets[e.node].push(e.lts[0]);\n                // èðXÖÇÉ Äæ²ÆÉª¯ÄÇÁ\n                postByNxtTo[e.node][e.lts[0].nxtTo].push_back(e.lts[0]);\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // AÒ\n            else if(e.kind==2){\n                isExist[e.node]=true;\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // o­\n            else if(e.kind==3){\n                // ¡ éèÌÅAàÁÆàÔªÍâ¢àÌðé\n                // ½¾µAÌ Ä³«ª¨È¶àÌÍAÜÆßÄé\n                // ¡±ÌêÉèª¶ÝµÈ¢\n                Letter lt;\n                bool ok=true;\n                while(1){\n                    if(postLets[e.node].empty()){\n                        ok=false;\n                        break;\n                    }\n                    lt=postLets[e.node].top();postLets[e.node].pop();\n                    // ·ÅÉçêÄ¢é\n                    if(isArrivalLet[e.node][lt.id])continue;\n                    else break;\n                }\n                if(!ok){\n                    isExist[e.node]=true;\n                    continue;\n                }\n                Event ev;\n                // éèðZbg\n                ev.lts=postByNxtTo[e.node][lt.nxtTo];\n                // Á½ÌÅgðNA\n                for(int i=0;i<ev.lts.size();i++)isArrivalLet[e.node][ev.lts[i].id]=true;\n                postByNxtTo[e.node][lt.nxtTo].clear();\n                ev.kind=0;\n                ev.node=lt.nxtTo;\n                ev.prvNode=e.node;\n                ev.time=e.time+d[e.node][lt.nxtTo];\n                pq.push(ev);\n            }\n        }\n        sort(res.begin(),res.end());\n        for(int i=0;i<res.size();i++)cout<<res[i].second<<\" \"<<res[i].first<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <utility>\nusing namespace std;\nconst int inf = 1e9;\n\nstruct transfer{\n    int from, to, direct_to, time;\n    string name;\n    transfer(int from, int to, int direct_to, int time, string name):\n        from(from), to(to), direct_to(direct_to), time(time), name(name){}\n    transfer(){}\n    bool operator <(const transfer &a) const{\n        return (time!=a.time)? time<a.time: direct_to<a.direct_to;\n    }\n};\n\nint main(){\n    bool is_first_dataset = true;\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n == 0) break;\n        if(is_first_dataset){\n            is_first_dataset = false;\n        }else{\n            cout << endl;\n        }\n\n        vector<vector<int>> dist_0(n, vector<int>(n, inf));\n        for(int i=0; i<n; i++){\n            dist_0[i][i] = 0;\n        }\n        for(int i=0; i<m; i++){\n            int a,b,c;\n            cin >> a >> b >> c;\n            a--; b--;\n            dist_0[a][b] = dist_0[b][a] = c;\n        }\n        auto dist = dist_0;\n        for(int k=0; k<n; k++){\n            for(int i=0; i<n; i++){\n                for(int j=0; j<n; j++){\n                    dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n                }\n            }\n        }\n        vector<vector<int>> direct(n, vector<int>(n));\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                if(i == j){\n                    direct[i][j] = i;\n                    continue;\n                }\n                for(int k=0; k<n; k++){\n                    if(k == i) continue;\n                    if(dist_0[i][k] +dist[k][j] == dist[i][j]){\n                        direct[i][j] = k;\n                        break;\n                    }\n                }\n            }\n        }\n\n        int q;\n        cin >> q;\n        vector<vector<transfer>> tr(n);\n        priority_queue<int> event;\n        for(int i=0; i<q; i++){\n            int from,to,time;\n            string name;\n            cin >> from >> to >> time >> name;\n            from--; to--;\n            tr[from].emplace_back(from, to, direct[from][to], time, name);\n            event.push(-time);\n        }\n\n        for(int i=0; i<n; i++){\n            sort(tr[i].begin(), tr[i].end());\n        }\n        vector<int> rettime(n, 0);\n        event.push(0);\n\n        vector<pair<int,string>> ans;\n        while(!event.empty()){\n            int t = event.top();\n            while(!event.empty() and event.top() == t){\n                event.pop();\n            }\n            t = -t;\n            for(int i=0; i<n; i++){\n                if(t < rettime[i]) continue;\n                if(tr[i].empty() or tr[i][0].time > t) continue;\n                int dto = tr[i][0].direct_to;\n                rettime[i] = t +2*dist[i][dto];\n                event.push(-rettime[i]);\n                event.push(-(t +dist[i][dto]));\n                for(int j=(int)tr[i].size()-1; j>=0; j--){\n                    if(tr[i][j].direct_to == dto and t >= tr[i][j].time){\n                        if(tr[i][j].to == tr[i][j].direct_to){\n                            ans.emplace_back(t +dist[i][dto], tr[i][j].name);\n                        }else{\n                            int to = tr[i][j].to;\n                            tr[dto].emplace_back(dto, to, direct[dto][to], t+dist[i][dto], tr[i][j].name);\n                        }\n                        tr[i].erase(tr[i].begin() +j);\n                    }                    \n                }\n                sort(tr[dto].begin(), tr[dto].end());\n            }\n        }\n        sort(ans.begin(), ans.end());\n        for(auto p: ans){\n            cout << p.second << \" \" << p.first << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tint tm,pos,dist;\n\tstring name;\n\tpacket(int t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x], &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(int x,int y){\n\tconst packet &a=pac[x], &b = pac[y];\n\treturn a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tstring name;\n\tfor(;cin>>n>>m,n;){\n\t\tpriority_queue<int,vector<int>,cmp> qu;\n\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=-1;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n/*\n\t\tfor(j=1;j<=n;j++)printf(\"\\t%d\",j);\n\t\tfor(i=1;i<=n;i++,puts){\n\t\t\tprintf(\"\\n%d:\",i);\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tprintf(\"\\t%d(%d)\",len[i][j],to[i][j]);\n\t\t}\n\t\treturn 0;\n*/\n\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n\t\treturn 0;\n\n\t\tfor(;!qu.empty();){\n//printf(\"size: %d\\n\",qu.size());\n\t\t\tint pi = qu.top();\n\t\t\tpacket &p = pac[pi];\n\t\t\tt = p.tm;\n\t\t\tf = p.pos;\n\t\t\tif( f == p.dist ){\n\t\t\t\tqu.pop();\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( t < bac[f] ){\n\t\t\t\tp.tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n//\t\t\t\tprintf(\"wait: %s\\n\",p.name.c_str());\n\t\t\t}else{\n\t\t\t\td = to[f][p.dist];\n//\t\t\t\tprintf(\"%d\\t%d -> %d\\t%s\\n\",p.tm,p.pos,t,p.name.c_str());\n\t\t\t\tbac[f] = p.tm + 2 * len[p.pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket &q = pac[qi];\n\t\t\t\t\tif(t==q.tm && f==q.pos && to[q.pos][q.dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq.tm += len[f][d];\n\t\t\t\t\t\tq.pos = d;\n\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tsort(pac.begin(),pac.end(),cmp2);\n//\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n//\t\tfor(j=0;j<l;j++)tbl[j]=j;\n//\t\tsort(tbl,tbl+l,cmp2);\n//\t\tfor(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),pac[tbl[j]].tm);\n\n\t\t**len = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cost;\n  Edge() {}\n  Edge(int s, int d, int c) : src(s), dst(d), cost(c) {}\n};\n\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nstruct Event{\n  int type;\n  int time;\n  int latter;\n  int office;\n  Event(int ty, int t, int l, int o) : \n    type(ty), time(t), latter(l), office(o) {}\n  bool operator < (const Event& e) const {\n    if(time != e.time) return time < e.time;\n    if(type != e.type) return type < e.type;\n    if(office != e.office) return office < e.office;\n    return latter < e.latter;\n  }\n  bool operator > (const Event& e) const {\n    return e < *this;\n  }\n};\nstruct Latter{\n  string name;\n  int src, dst;\n};\ntypedef pair<int, string> P;\nvoid print(Event& e){\n  //printf(\"type %d time %d latter %d office %d\\n\", e.type, e.time, e.latter, e.office);\n}\n\nvoid do_send(Event& e, deque<Event>& lq, priority_queue<Event, vector<Event>, greater<Event> >& que, int dist[36][36], vector<bool>& wait){\n  /*\n  printf(\"do_send : lq is\\n\");\n  REP(i, lq.size()) print(lq[i]);\n  cout << endl;\n  */\n  Event se = lq.front(); lq.pop_front();\n  que.push(Event(0, e.time + dist[e.office][se.office], se.latter, se.office));\n  //printf(\"send : \"); print(se);\n  for(deque<Event>::iterator it = lq.begin(); it != lq.end(); ){\n    if(it->office == se.office){\n      que.push(Event(0, e.time + dist[e.office][se.office], it->latter, se.office));\n      //printf(\"send2 : \"); print(*it);\n      it = lq.erase(it);\n    }else{\n      it++;\n    }\n  }\n  que.push(Event(1, e.time + 2 * dist[e.office][se.office], -1, e.office));\n  wait[e.office] = false;\n}\nint main(){\n  int N, M;\n  bool first = true;\n  while(cin >> N >> M && N){\n\n    if(first) first = false;\n    else cout << endl;\n\n    Graph G(N);\n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      G[a].push_back(Edge(a, b, c));\n      G[b].push_back(Edge(b, a, c));\n    }\n    int dist[36][36] = {};\n    REP(i, N) REP(j, N) dist[i][j] = (i != j) ? INF : 0;\n    REP(i, N) FORIT(e, G[i]) dist[e->src][e->dst] = e->cost;\n    REP(k, N) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    // next[i][j] := 現在地i, 目的地jの郵便物の次の行き先\n    int next[36][36] = {};\n    memset(next, -1, sizeof(next));\n    REP(i, N) REP(j, N) if(i != j && !G[i].empty()){\n      next[i][j] = G[i][0].dst;\n      int n_cost = G[i][0].cost + dist[G[i][0].dst][j];\n      int edge_cost = G[i][0].cost;\n      FORIT(e, G[i]){\n        if(make_pair(n_cost, next[i][j]) > make_pair(e->cost + dist[e->dst][j], e->dst)){\n          n_cost = e->cost + dist[e->dst][j];\n          next[i][j] = e->dst;\n          edge_cost = e->cost;\n        }\n      }\n      assert(edge_cost == dist[i][next[i][j]]);\n    }\n    //REP(i, N) REP(j, N) printf(\"next[%d][%d] = %d\\n\", i, j, next[i][j]);\n\n    int L; cin >> L;\n    vector<Latter> latters(L);\n    priority_queue<Event, vector<Event>, greater<Event> > que;\n    vector< deque<Event> > l_que(N);\n    REP(i, L){\n      int time;\n      cin >> latters[i].src >> latters[i].dst >> time >> latters[i].name;\n      latters[i].src--; latters[i].dst--;\n      que.push(Event(0, time, i, latters[i].src));\n    }\n    vector<P> answer;\n    vector<bool> wait(N, true);\n    while(!que.empty()){\n      Event e = que.top(); que.pop();\n      print(e);\n      deque<Event>& lq = l_que[e.office];\n      if(e.type == 0){\n        Latter& l = latters[e.latter];\n        if(l.dst == e.office){\n          answer.push_back(P(e.time, l.name));\n        }else{\n          int to = next[e.office][l.dst];\n          assert(to != -1);\n          Event send(0, e.time, e.latter, to);\n          lq.insert(lower_bound(lq.begin(), lq.end(), send), send);\n          // send\n          if(wait[e.office] && (que.empty() || (make_pair(e.time, e.office) != make_pair(que.top().time, que.top().office)))){\n            do_send(e, lq, que, dist, wait);\n          }\n        }\n      }else if(e.type == 1){\n        wait[e.office] = true;\n        if(!lq.empty()){\n          do_send(e, lq, que, dist, wait);\n        }\n      }\n    }\n    REP(i, N) assert(wait[i]);\n    sort(answer.begin(), answer.end());\n    assert(answer.size() == latters.size());\n    REP(i, answer.size()){\n      printf(\"%s %d\\n\", answer[i].second.c_str(), answer[i].first);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tvector<int> to,c;\n};\n\nclass Trl\n{\npublic:\n\tint p,c,pv;\n\tTrl(int p, int c, int pv)\n\t:p(p),c(c),pv(pv)\n\t{}\n\t\n\tbool operator<(const Trl& t) const\n\t{\n\t\tif(c!=t.c) return c>t.c;\n\t\treturn p>t.p;\n\t}\n};\n\nint nt[32][32],ld[32][32];\nNode node[32];\n\nvoid Dijkstra(int src, int dst)\n{\n\tpriority_queue<Trl> q;\n\tq.push(Trl(src,0,src));\n\t\n\tint v[32];\n\tfor(int i=0; i<32; i++) v[i]=-1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tTrl t=q.top(); q.pop();\n\t\tif(v[t.p]!=-1) continue;\n\t\tv[t.p]=t.pv;\n\t\t\n\t\tif(t.p==dst)\n\t\t{\n\t\t\tfor(int i=dst; v[i]!=i; i=v[i])\n\t\t\t\tnt[v[i]][dst]=i;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<node[t.p].to.size(); i++)\n\t\t{\n\t\t\tint next=node[t.p].to[i];\n\t\t\tif(v[next]!=-1) continue;\n\t\t\t\n\t\t\tq.push(Trl(next, t.c+node[t.p].c[i], t.p));\n\t\t}\n\t}\n}\n\nenum EV{BACK, GO};\n\nclass Event\n{\npublic:\n\tEV ev;\n\tint p, dst,t;\n\tstring n;\n\t\n\tEvent(int p, int dst, int t,EV ev, string n)\n\t:p(p),dst(dst),t(t),ev(ev),n(n)\n\t{}\n\t\n\tbool operator<(const Event& e) const\n\t{\n\t\t\n\t\tif(t!=e.t) return t>e.t;\n\t\tif(ev!=e.ev) return ev>e.ev;\n\t\tif(p==dst&&e.p==e.dst) return n>e.n;\n\t\tif(dst!=e.dst) dst>e.dst;\n\t\treturn p<e.p;\n\t}\n};\n\nvoid Sim()\n{\n\tint K;\n\tscanf(\"%d\", &K);\n\tpriority_queue<Event> q;\n\twhile(K--)\n\t{\n\t\tint s,d,t;\n\t\tchar n[51];\n\t\tscanf(\"%d%d%d%s\",&s,&d,&t,n);\n\t\ts--; d--;\n\t\tq.push(Event(s,d,t,GO,string(n)));\n\t}\n\t\n\tint tc=-1, tdst=-1, tp=-1;\n\tint lv[32]={0};\n\twhile(!q.empty())\n\t{\n\t\tEvent e=q.top(); q.pop();\n\t\tif(e.ev==BACK)\n\t\t{\n\t\t\tlv[e.dst]=0;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(e.dst==e.p)\n\t\t{\n\t\t\tprintf(\"%s %d\\n\", e.n.c_str(), e.t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(tc==e.t&&tdst==e.dst&&tp==e.p)\n\t\t\t{\n\t\t\t\tint next=nt[e.p][e.dst], cst=e.t+ld[e.p][next];\n\t\t\t\tq.push(Event(next, e.dst, cst, e.ev, e.n));\n\t\t\t}\n\t\t\telse if(lv[e.p]!=0)\n\t\t\t{\n\t\t\t\tq.push(Event(e.p, e.dst, lv[e.p], e.ev, e.n));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint next=nt[e.p][e.dst], cst=e.t+ld[e.p][next];\n\t\t\t\tlv[e.p]=cst+ld[e.p][next];\n\t\t\t\tq.push(Event(next, e.dst, cst, e.ev, e.n));\n\t\t\t\tq.push(Event(e.p, e.p, lv[e.p], BACK, \"\"));\n\t\t\t\t\n\t\t\t\ttc=e.t; tdst=e.dst; tp=e.p;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint N,M;\n\tbool fr=true;\n\twhile(scanf(\"%d%d\", &N, &M), (N||M))\n\t{\n\t\tfor(int i=0; i<32; i++)\n\t\t{\n\t\t\tnode[i].to.clear();\n\t\t\tnode[i].c.clear();\n\t\t}\n\t\twhile(M--)\n\t\t{\n\t\t\tint s,d,c;\n\t\t\tscanf(\"%d%d%d\", &s,&d,&c);\n\t\t\ts--; d--;\n\t\t\t\n\t\t\tnode[s].to.push_back(d);\n\t\t\tnode[d].to.push_back(s);\n\t\t\tnode[s].c.push_back(c);\n\t\t\tnode[d].c.push_back(c);\n\t\t\tld[s][d]=c;\n\t\t\tld[d][s]=c;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\tDijkstra(i,j);\n\t\t\t\n\t\tif(!fr) puts(\"\");\n\t\tfr=false;\n\t\t\n\t\tSim();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<cstdio>\n#include<list>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nint g[40][40];\nint og[40][40];\nconst int MAX = 10000000;\nchar name[1000][52];\nint dist[1000];\n\nenum{\n  RetPeo = 0,\n  SetLet = 1\n};\n\nstruct event{\n  int time;\n  int type;\n  int pos;\n  int id;\n\n  event(int ti, int ty, int po, int i = 0) :\n    time(ti), type(ty), pos(po), id(i){}\n};\n\nbool operator < (const event &lhs, const event &rhs){\n  if(lhs.time != rhs.time) return lhs.time > rhs.time;\n  return lhs.type < rhs.type;\n}\n\nint n, m;\n\nint nextof(int s, int d){\n  if(s == d) return d;\n  REP(i, n) if(i != s && og[s][i] + g[i][d] == g[s][d]) return i;\n  return 0;\n}\n\nint main(){\n  bool fst = true;\n  while(scanf(\"%d%d\", &n, &m), n + m){\n    if(!fst) puts(\"\");\n    else fst =false;\n\n\n    REP(i,n) REP(j,n) g[i][j] = MAX;\n    REP(i,n) g[i][i] = 0;\n\n    REP(i,m){\n      int a, b, c;\n      scanf(\"%d%d%d\", &a, &b, &c);\n      g[a - 1][b - 1] = g[b - 1][a - 1] = c;\n    }\n    REP(i,n) REP(j,n) og[i][j] = g[i][j];\n\n    REP(k,n) REP(i,n) REP(j,n)\n      g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\n    int l; scanf(\"%d\", &l);\n    priority_queue<event> pq;\n\n    REP(ll, l){\n      int s, d, t;\n      scanf(\"%d%d%d %s\", &s, &d, &t, name[ll]);\n      dist[ll] = d - 1;\n      pq.push(event(t, SetLet, s - 1, ll));\n    }\n\n    vector<int> last(n, 0);\n    vector<bool> people(n, true);\n    typedef pair<int, pair<int, int> > letter;\n    vector<list<letter> > q(n);\n\n    while(pq.size()){\n      int etime = pq.top().time;\n\n      //printf(\"time: %d\\n\", time);\n      //printf(\"type=%d pos=%d id=%d\\n\", type, pos, id);\n\n      vector<string> ans;\n\n      while(pq.size() && pq.top().time == etime){\n        event e = pq.top(); pq.pop();\n        int time = e.time;\n        int type = e.type;\n        int pos  = e.pos;\n        int id   = e.id;\n        if(type == RetPeo){\n          people[pos] = true;\n        }else if(type == SetLet){\n          if(dist[id] == pos){\n            ans.push_back(name[id]);\n          }else{\n            //printf(\"%d => %d\\n\", pos, nextof(pos, dist[id]));\n            q[pos].push_back(letter(time, make_pair(nextof(pos, dist[id]), id)));\n          }\n        }\n      }\n\n      if(ans.size() > 1) sort(ans.begin(), ans.end());\n      REP(i, ans.size()){\n        printf(\"%s %d\\n\", ans[i].c_str(), etime);\n      }\n\n      REP(pos, n) if(people[pos]){\n        if(q[pos].size()){\n          if(q[pos].size() > 1) q[pos].sort();\n\n          // int nexttime = q[pos].front().first;\n          int nextpos  = q[pos].front().second.first;\n\n          for(list<letter>::iterator it = q[pos].begin(); it != q[pos].end();){\n            int np = (*it).second.first;\n            int le = (*it).second.second;\n\n            if(np == nextpos){\n              pq.push(event(etime + og[pos][np], SetLet, np, le));\n              it = q[pos].erase(it);\n            }else{\n              ++it;\n            }\n          }\n\n          people[pos] = false;\n          last[pos]   = etime;\n          pq.push(event(etime + 2 * og[pos][nextpos], RetPeo, pos));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 50\n\nvector<pair<int,int> > way[SIZE];\n\nbool firstcase = true;\n\nstruct DATA{\n  ll t;\n  int id;\n  int now;\n  int next;\n  int goal;\n\n  const bool operator<(const DATA &B) const{\n    if(t != B.t) return t > B.t;\n    if(next != B.next) return next > B.next;\n    return false;\n  }\n\n  DATA(ll t, int id, int now, int next, int goal):\n    t(t), id(id), now(now), next(next), goal(goal){}\n};\n\nint dist[40][40];\nint n;\n\nint getNext(int a, int b){\n  if (a == b) return a;\n  for(int i=0;i<n;i++){\n    if(a != i && dist[a][i] + dist[i][b] == dist[a][b])\n      return i;\n  }\n\n  assert(false);\n  return -1;\n}\n\nbool solve(){\n  int m, q;\n  string text[1000];\n\n  debug(\"solve\");\n  \n  priority_queue<DATA> pq;\n\n  scanf(\"%d%d\", &n, &m);\n  \n  if(n == 0) return false;\n  if(firstcase) firstcase = false;\n  else puts(\"\");\n  \n  for(int i=0;i<n;i++) way[i] = vector<pair<int,int> > ();\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dist[i][j] = INF;\n    }\n    dist[i][i] = 0;\n  }\n  \n  \n  for(int i=0;i<m;i++){\n    int a, b, c; \n    scanf(\"%d%d%d\", &a, &b, &c);\n    a--; b--;\n\n    dist[a][b] = c;\n    dist[b][a] = c;\n  }\n\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n  \n  scanf(\"%d\", &q);\n\n  for(int i=0;i<q;i++){\n    int a, b, t;\n    char temp[60];\n    scanf(\"%d%d%d%s\", &a, &b, &t, temp);\n    a--; b--;\n    text[i] = temp;\n    \n    pq.push(DATA(t, i, a, getNext(a,b), b));\n  }\n\n  bool outside[40] = {};\n  ll sent[40][40] = {};\n  priority_queue<pair<ll,int> > que[40];\n  queue<DATA> post[40][40];\n  vector<pair<ll,string> > ans;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      sent[i][j] = -1;\n  \n  while(pq.size()){\n    queue<int> work;\n    ll t = pq.top().t;\n\n    while(pq.size() && pq.top().t == t){\n      auto p = pq.top(); pq.pop();\n      if(p.id != -1){\n        if(p.now == p.goal){\n          ans.push_back({p.t, text[p.id]});\n          continue;\n        }\n        \n        post[p.now][p.next].push(p);\n        que[p.now].push({-p.t, -p.next});\n        //cerr << \"[post] \" << t << \" : \" << p.now << \" -> \" << p.next << \" -> \" << p.goal << endl;\n      }else{\n        outside[p.now] = false;\n        //cerr << \"[back] \" << t << \" : \" << p.now << endl;\n      }\n\n      work.push(p.now);\n    }\n    \n\n    while(work.size()){\n      int now = work.front(); work.pop();\n      if(outside[now]) continue;\n      \n      while(que[now].size() && -que[now].top().first <= t){\n        auto p = que[now].top(); que[now].pop();\n\n        if(-p.first <= sent[now][-p.second]) continue;\n        \n        //cerr << now << \" -> \" << -p.second << endl;\n        \n        ll max_t = 0;\n        \n        while(post[now][-p.second].size()){\n          auto p2 = post[now][-p.second].front(); post[now][-p.second].pop();\n          \n          max_t = max(max_t, p2.t);\n\n          p2.t = t + dist[now][-p.second];\n          p2.next = getNext(p2.next, p2.goal);\n          p2.now = -p.second;\n          pq.push(p2);\n        }\n        \n        outside[now] = true;\n        pq.push(DATA((ll)t + dist[now][-p.second]*2, -1, now, -1, -1));\n        sent[now][-p.second] = max(sent[now][-p.second], max_t);\n        break;\n      }\n\n    }\n  }\n\n  sort(ans.begin(), ans.end());\n  \n  for(int i=0;i<ans.size();i++){\n    cout << ans[i].second << \" \" << ans[i].first << endl;\n  }\n  \n  return true;\n}\n\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tint tm,pos,dist;\n\tstring name;\n\tpacket(int t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x], &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(int x,int y){\n\tconst packet &a=pac[x], &b = pac[y];\n\treturn a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tstring name;\n\tpriority_queue<int,vector<int>,cmp> qu;\n\tfor(;cin>>n>>m,n;){\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=inf;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n//\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n\n\t\tfor(;!qu.empty();){\n\t\t\tint pi = qu.top();\n\t\t\tpacket &p = pac[pi];\n\t\t\tt = p.tm;\n\t\t\tf = p.pos;\n\t\t\tif( t < bac[f] ){\n\t\t\t\tp.tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n\t\t\t}else{\n\t\t\t\td = to[f][p.dist];\n\t\t\t\tbac[f] = p.tm + 2 * len[p.pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket &q = pac[qi];\n\t\t\t\t\tif(t==q.tm && f==q.pos && to[q.pos][q.dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq.tm += len[f][d];\n\t\t\t\t\t\tq.pos = d;\n\t\t\t\t\t\tif( d != q.dist )\n\t\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tsort(pac.begin(),pac.end(),cmp2);\n//\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n\t\tfor(j=0;j<l;j++)tbl[j]=j;\n\t\tsort(tbl,tbl+l,cmp2);\n\t\tfor(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),pac[tbl[j]].tm);\n\n\t\t**len = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct root {\n\tint start;\n\tint goal;\n\tint time;\n\tvector<int>ways;\n\troot():ways() {\n\t\tstart = 0;\n\t\tgoal = 0;\n\t}\n\troot(const int start_, const int goal_, const int time_, const vector<int>ways_)\n\t\t:start(start_), goal(goal_), time(time_), ways(ways_) {\n\n\t}\n};\nstruct edge {\n\tint src;\n\tint dst;\n\tint cost;\n};\n\nstruct query {\n\tint type;\n\tint id;\n\tint num;\n\tint next;\n\tint nextnext;\n\tint time;\n\tquery(int type_, int id_, int num_, const int next_,const int nextnext_, int time_) :type(type_), id(id_), num(num_), next(next_),nextnext(nextnext_), time(time_) {\n\n\t}\n};\nclass Compare {\npublic:\n\tbool operator()(const query&l, const query&r) {\n\t\treturn l.time==r.time?l.type==r.type?l.nextnext>r.nextnext:l.type<r.type:l.time> r.time;\n\t}\n};\t//aa?????????????????¶\nstruct letter {\n\tint id;\n\tstring name;\n\tvector<int>ways;\n};\nint main() {\n\tint aa = 0;\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tif(aa)\tcout << endl;\n\n\t\taa++;\n\t\t\n\t\tvector<vector<root>>roots(N, vector<root>(N));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\n\t\t\t\troots[i][j].start = i;\n\t\t\t\troots[i][j].goal = j;\n\t\t\t\tif (i == j) {\n\t\t\t\t\troots[i][j].time = 0;\n\t\t\t\t\troots[i][j].ways = vector<int>{};\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\troots[i][j].time = 1e9;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\t\troots[a][b] = root( a,b,c,vector<int>{b} );\n\t\t\troots[b][a] = root(b, a, c, vector<int>{a});\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tif (i == k || j == k||i==j)continue;\n\t\t\t\t\tif (roots[i][k].time < 1e8&&roots[k][j].time < 1e8) {\n\t\t\t\t\t\tconst int  nexttime = roots[i][k].time + roots[k][j].time;\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tvector<int>preways(roots[i][j].ways);\n\t\t\t\t\t\tvector<int>nextways(roots[i][k].ways);\n\t\t\t\t\t\tnextways.insert(nextways.end(), roots[k][j].ways.begin(), roots[k][j].ways.end());\n\t\t\t\t\t\tif (nexttime > roots[i][j].time)ok = false;\n\t\t\t\t\t\telse if (nexttime == roots[i][j].time) {\n\n\t\t\t\t\t\t\tfor (int a= 0; a < preways.size(); ++a) {\n\t\t\t\t\t\t\t\tif (preways[a] > nextways[a]) {\n\t\t\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (preways[a] < nextways[a]) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\troots[i][j].time = nexttime;\n\t\t\t\t\t\t\troots[i][j].ways = nextways;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (roots[i][j].time < 1e8) {\n\t\t\t\t\troots[i][j].ways.insert(roots[i][j].ways.begin(), i);\n\t\t\t\t\troots[i][j].ways.emplace_back(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tint L; cin >> L;\n\t\tpriority_queue<query, vector<query>, Compare>que;\n\t\tmap<int,letter>mp;\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint a, b, c; string d; cin >> a >> b >> c >> d; a--; b--;\n\t\t\tmp[i] = letter{ i,d,roots[a][b].ways };\n\t\t\tint nextnext = roots[a][b].ways[1];\n\t\t\tque.push(query(1,i,0,roots[a][b].ways[0],nextnext,c ));\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tque.push(query{ 0,0,0,i,0,0 });\n\t\t}\n\t\tvector<pair< int,string>>anss;\n\t\t//vector<vector<vector<int>>>waits(N,vector<vector<int>>(N,vector<int>()));\n\t\tvector<deque<vector<tuple<int,int,int>>>>nexts(N);\n\t\tvector<int>exists(N);\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tquery q(que.top());\n\t\t\tque.pop();\n\n\t\t\tconst int nowtime = q.time;\n\n\t\t\tconst int nowplace = q.next;\n\t\t\t//??°??£?????????\n\t\t\tif (q.type == 0) {\n\t\t\t\tassert(exists[nowplace] == false);\n\t\t\t\tif (!nexts[nowplace].empty()) {\n\t\t\t\t\tauto carrys(nexts[nowplace].front());\n\t\t\t\t\tconst int nextplace = get<2>(carrys[0]);\n\t\t\t\t\tfor (auto carry : carrys) {\n\t\t\t\t\t\tint aid = get<0>(carry);\n\t\t\t\t\t\tint anum = get<1>(carry);\n\t\t\t\t\t\tconst int needtime = roots[nowplace][nextplace].time;\n\t\t\t\t\t\tconst int nexttime = nowtime + needtime;\n\t\t\t\t\t\tconst int backtime = nexttime + needtime;\n\t\t\t\t\t\tque.push(query(1,aid,anum + 1,nextplace,mp[aid].ways[anum+2],nexttime ));\n\t\t\t\t\t\texists[nowplace] = false;\n\t\t\t\t\t}\n\t\t\t\t\tque.push(query(0, 0, 0, nowplace, 0,nowtime+2*roots[nowplace][nextplace].time));\n\t\t\t\t\tnexts[nowplace].pop_front();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(!exists[nowplace]);\n\t\t\t\t\texists[nowplace] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//???????????\\???\n\t\t\telse {\n\t\t\t\tif (q.nextnext==-1) {\n\t\t\t\t\tanss.push_back(make_pair(q.time, mp[q.id].name));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst int nextplace = mp[q.id].ways[q.num + 1];\n\t\t\t\t\tif (!exists[nowplace]) {\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor (int i = 0; i < nexts[nowplace].size(); ++i) {\n\t\t\t\t\t\t\tif (get<2>(nexts[nowplace][i][0]) == nextplace) {\n\t\t\t\t\t\t\t\tnexts[nowplace][i].push_back(make_tuple(q.id, q.num, nextplace));\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\tnexts[nowplace].push_back(vector<tuple<int,int,int>>(1, make_tuple(q.id, q.num, nextplace)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tassert(nexts[nowplace].empty());\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint aid = q.id;\n\t\t\t\t\t\t\tint anum = q.num;\n\t\t\t\t\t\t\tconst int needtime = roots[nowplace][nextplace].time;\n\t\t\t\t\t\t\tconst int nexttime = nowtime + needtime;\n\t\t\t\t\t\t\tconst int backtime = nexttime + needtime;\n\t\t\t\t\t\t\tque.push(query(1, aid, anum + 1, nextplace, mp[aid].ways[anum + 2], nexttime));\n\t\t\t\n\t\t\t\t\t\t\tque.push(query(0, 0, 0, nowplace, 0,backtime));\n\t\t\t\t\t\t\texists[nowplace] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tsort(anss.begin(), anss.end());\n\t\tfor (auto ans : anss) {\n\t\t\tcout << ans.second << \" \" << ans.first << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cost;\n  Edge() {}\n  Edge(int s, int d, int c) : src(s), dst(d), cost(c) {}\n};\n\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nstruct Event{\n  int type;\n  int time;\n  int latter;\n  int office;\n  Event(int ty, int t, int l, int o) : \n    type(ty), time(t), latter(l), office(o) {}\n  bool operator < (const Event& e) const {\n    if(time != e.time) return time < e.time;\n    if(type != e.type) return type < e.type;\n    return office < e.office;\n  }\n  bool operator > (const Event& e) const {\n    return e < *this;\n  }\n};\nstruct Latter{\n  string name;\n  int src, dst;\n};\ntypedef pair<int, string> P;\nvoid print(Event& e){\n  //printf(\"type %d time %d latter %d office %d\\n\", e.type, e.time, e.latter, e.office);\n}\n\nvoid do_send(Event& e, deque<Event>& lq, priority_queue<Event, vector<Event>, greater<Event> >& que, int dist[36][36], vector<bool>& wait){\n  /*\n  printf(\"do_send : lq is\\n\");\n  REP(i, lq.size()) print(lq[i]);\n  cout << endl;\n  */\n  Event se = lq.front(); lq.pop_front();\n  que.push(Event(0, e.time + dist[e.office][se.office], se.latter, se.office));\n  //printf(\"send : \"); print(se);\n  for(deque<Event>::iterator it = lq.begin(); it != lq.end(); ){\n    if(it->office == se.office){\n      que.push(Event(0, e.time + dist[e.office][se.office], it->latter, se.office));\n      //printf(\"send2 : \"); print(*it);\n      it = lq.erase(it);\n    }else{\n      it++;\n    }\n  }\n  que.push(Event(1, e.time + 2 * dist[e.office][se.office], -1, e.office));\n  wait[e.office] = false;\n}\nint main(){\n  int N, M;\n  bool first = true;\n  while(cin >> N >> M && N){\n\n    if(first) first = false;\n    else cout << endl;\n\n    Graph G(N);\n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      G[a].push_back(Edge(a, b, c));\n      G[b].push_back(Edge(b, a, c));\n    }\n    int dist[36][36] = {};\n    REP(i, N) REP(j, N) dist[i][j] = (i != j) ? INF : 0;\n    REP(i, N) FORIT(e, G[i]) dist[e->src][e->dst] = e->cost;\n    REP(k, N) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    // next[i][j] := 現在地i, 目的地jの郵便物の次の行き先\n    int next[36][36] = {};\n    memset(next, -1, sizeof(next));\n    REP(i, N) REP(j, N) if(i != j && !G[i].empty()){\n      next[i][j] = G[i][0].dst;\n      int n_cost = G[i][0].cost + dist[G[i][0].dst][j];\n      int edge_cost = G[i][0].cost;\n      FORIT(e, G[i]){\n        if(make_pair(n_cost, next[i][j]) > make_pair(e->cost + dist[e->dst][j], e->dst)){\n          n_cost = e->cost + dist[e->dst][j];\n          next[i][j] = e->dst;\n          edge_cost = e->cost;\n        }\n      }\n      assert(edge_cost == dist[i][next[i][j]]);\n    }\n    //REP(i, N) REP(j, N) printf(\"next[%d][%d] = %d\\n\", i, j, next[i][j]);\n\n    int L; cin >> L;\n    vector<Latter> latters(L);\n    priority_queue<Event, vector<Event>, greater<Event> > que;\n    vector< deque<Event> > l_que(N);\n    REP(i, L){\n      int time;\n      cin >> latters[i].src >> latters[i].dst >> time >> latters[i].name;\n      latters[i].src--; latters[i].dst--;\n      que.push(Event(0, time, i, latters[i].src));\n    }\n    vector<P> answer;\n    vector<bool> wait(N, true);\n    while(!que.empty()){\n      Event e = que.top(); que.pop();\n      print(e);\n      deque<Event>& lq = l_que[e.office];\n      if(e.type == 0){\n        Latter& l = latters[e.latter];\n        if(l.dst == e.office){\n          answer.push_back(P(e.time, l.name));\n        }else{\n          int to = next[e.office][l.dst];\n          assert(to != -1);\n          Event send(0, e.time, e.latter, to);\n          lq.insert(lower_bound(lq.begin(), lq.end(), send), send);\n          // send\n          if(wait[e.office] && make_pair(e.time, e.office) != make_pair(que.top().time, que.top().office)){\n            do_send(e, lq, que, dist, wait);\n          }\n        }\n      }else if(e.type == 1){\n        wait[e.office] = true;\n        if(!lq.empty()){\n          do_send(e, lq, que, dist, wait);\n        }\n      }\n    }\n    REP(i, N) assert(wait[i]);\n    sort(answer.begin(), answer.end());\n    assert(answer.size() == latters.size());\n    REP(i, answer.size()){\n      printf(\"%s %d\\n\", answer[i].second.c_str(), answer[i].first);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tvector<int> to,c;\n};\n\nclass Trl\n{\npublic:\n\tint p,c,pv;\n\tTrl(int p, int c, int pv)\n\t:p(p),c(c),pv(pv)\n\t{}\n\t\n\tbool operator<(const Trl& t) const\n\t{\n\t\tif(c!=t.c) return c>t.c;\n\t\treturn p>t.p;\n\t}\n};\n\nint nt[32][32],ld[32][32];\nNode node[32];\n\nvoid Dijkstra(int src, int dst)\n{\n\tpriority_queue<Trl> q;\n\tq.push(Trl(src,0,src));\n\t\n\tint v[32];\n\tfor(int i=0; i<32; i++) v[i]=-1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tTrl t=q.top(); q.pop();\n\t\tif(v[t.p]!=-1) continue;\n\t\tv[t.p]=t.pv;\n\t\t\n\t\tif(t.p==dst)\n\t\t{\n\t\t\tfor(int i=dst; v[i]!=i; i=v[i])\n\t\t\t\tnt[v[i]][dst]=i;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<node[t.p].to.size(); i++)\n\t\t{\n\t\t\tint next=node[t.p].to[i];\n\t\t\tif(v[next]!=-1) continue;\n\t\t\t\n\t\t\tq.push(Trl(next, t.c+node[t.p].c[i], t.p));\n\t\t}\n\t}\n}\n\nenum EV{BACK, GO};\n\nclass Event\n{\npublic:\n\tEV ev;\n\tint p, dst,t;\n\tstring n;\n\t\n\tEvent(int p, int dst, int t,EV ev, string n)\n\t:p(p),dst(dst),t(t),ev(ev),n(n)\n\t{}\n\t\n\tbool operator<(const Event& e) const\n\t{\n\t\t\n\t\tif(t!=e.t) return t>e.t;\n\t\tif(ev!=e.ev) return ev>e.ev;\n\t\tif(p==dst&&e.p==e.dst) return n>e.n;\n\t\tif(dst!=e.dst) dst>e.dst;\n\t\treturn p>e.p;\n\t}\n};\n\nvoid Sim()\n{\n\tint K;\n\tscanf(\"%d\", &K);\n\tpriority_queue<Event> q;\n\twhile(K--)\n\t{\n\t\tint s,d,t;\n\t\tchar n[51];\n\t\tscanf(\"%d%d%d%s\",&s,&d,&t,n);\n\t\ts--; d--;\n\t\tq.push(Event(s,d,t,GO,string(n)));\n\t}\n\t\n\tint tc=-1, tdst=-1, tp=-1;\n\tint lv[32]={0};\n\twhile(!q.empty())\n\t{\n\t\tEvent e=q.top(); q.pop();\n\t\tif(e.ev==BACK)\n\t\t{\n\t\t\tlv[e.dst]=0;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(e.dst==e.p)\n\t\t{\n\t\t\tprintf(\"%s %d\\n\", e.n.c_str(), e.t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(tc==e.t&&tdst==nt[e.p][e.dst]&&tp==e.p)\n\t\t\t{\n\t\t\t\tint next=nt[e.p][e.dst], cst=e.t+ld[e.p][next];\n\t\t\t\tq.push(Event(next, e.dst, cst, e.ev, e.n));\n\t\t\t}\n\t\t\telse if(lv[e.p]!=0)\n\t\t\t{\n\t\t\t\tq.push(Event(e.p, e.dst, lv[e.p], e.ev, e.n));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint next=nt[e.p][e.dst], cst=e.t+ld[e.p][next];\n\t\t\t\tlv[e.p]=cst+ld[e.p][next];\n\t\t\t\tq.push(Event(next, e.dst, cst, e.ev, e.n));\n\t\t\t\tq.push(Event(e.p, e.p, lv[e.p], BACK, \"\"));\n\t\t\t\t\n\t\t\t\ttc=e.t; tdst=next; tp=e.p;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint N,M;\n\tbool fr=true;\n\twhile(scanf(\"%d%d\", &N, &M), (N||M))\n\t{\n\t\tfor(int i=0; i<32; i++)\n\t\t{\n\t\t\tnode[i].to.clear();\n\t\t\tnode[i].c.clear();\n\t\t}\n\t\twhile(M--)\n\t\t{\n\t\t\tint s,d,c;\n\t\t\tscanf(\"%d%d%d\", &s,&d,&c);\n\t\t\ts--; d--;\n\t\t\t\n\t\t\tnode[s].to.push_back(d);\n\t\t\tnode[d].to.push_back(s);\n\t\t\tnode[s].c.push_back(c);\n\t\t\tnode[d].c.push_back(c);\n\t\t\tld[s][d]=c;\n\t\t\tld[d][s]=c;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\tDijkstra(i,j);\n\t\t\t\n\t\tif(!fr) puts(\"\");\n\t\tfr=false;\n\t\t\n\t\tSim();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cost;\n  Edge() {}\n  Edge(int s, int d, int c) : src(s), dst(d), cost(c) {}\n};\n\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nstruct Event{\n  int type;\n  int time;\n  int latter;\n  int office;\n  Event(int ty, int t, int l, int o) : \n    type(ty), time(t), latter(l), office(o) {}\n  bool operator < (const Event& e) const {\n    if(time != e.time) return time < e.time;\n    if(type != e.type) return type < e.type;\n    if(office != e.office) return office < e.office;\n    return latter < e.latter;\n  }\n  bool operator > (const Event& e) const {\n    if(time != e.time) return time > e.time;\n    if(type != e.type) return type > e.type;\n    if(office != e.office) return office > e.office;\n    return latter > e.latter;\n  }\n};\nstruct Latter{\n  string name;\n  int src, dst;\n};\ntypedef pair<int, string> P;\nvoid print(Event& e){\n  //printf(\"type %d time %d latter %d office %d\\n\", e.type, e.time, e.latter, e.office);\n}\n\nvoid do_send(Event& e, deque<Event>& lq, priority_queue<Event, vector<Event>, greater<Event> >& que, int dist[36][36], vector<bool>& wait){\n  /*\n  printf(\"do_send : lq is\\n\");\n  REP(i, lq.size()) print(lq[i]);\n  cout << endl;\n  */\n  Event se = lq.front(); lq.pop_front();\n  que.push(Event(0, e.time + dist[e.office][se.office], se.latter, se.office));\n  //printf(\"send : \"); print(se);\n  for(deque<Event>::iterator it = lq.begin(); it != lq.end(); ){\n    if(it->office == se.office){\n      que.push(Event(0, e.time + dist[e.office][se.office], it->latter, se.office));\n      //printf(\"send2 : \"); print(*it);\n      it = lq.erase(it);\n    }else{\n      it++;\n    }\n  }\n  que.push(Event(1, e.time + 2 * dist[e.office][se.office], -1, e.office));\n  wait[e.office] = false;\n}\nint main(){\n  int N, M;\n  bool first = true;\n  while(cin >> N >> M && N){\n\n    if(first) first = false;\n    else cout << endl;\n\n    Graph G(N);\n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      G[a].push_back(Edge(a, b, c));\n      G[b].push_back(Edge(b, a, c));\n    }\n    int dist[36][36] = {};\n    REP(i, N) REP(j, N) dist[i][j] = (i != j) ? INF : 0;\n    REP(i, N) FORIT(e, G[i]) dist[e->src][e->dst] = e->cost;\n    REP(k, N) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    // next[i][j] := 現在地i, 目的地jの郵便物の次の行き先\n    int next[36][36] = {};\n    memset(next, -1, sizeof(next));\n    REP(i, N) REP(j, N) if(i != j && !G[i].empty()){\n      next[i][j] = G[i][0].dst;\n      int n_cost = G[i][0].cost + dist[G[i][0].dst][j];\n      int edge_cost = G[i][0].cost;\n      FORIT(e, G[i]){\n        if(make_pair(n_cost, next[i][j]) > make_pair(e->cost + dist[e->dst][j], e->dst)){\n          n_cost = e->cost + dist[e->dst][j];\n          next[i][j] = e->dst;\n          edge_cost = e->cost;\n        }\n      }\n      assert(edge_cost == dist[i][next[i][j]]);\n    }\n    //REP(i, N) REP(j, N) printf(\"next[%d][%d] = %d\\n\", i, j, next[i][j]);\n\n    int L; cin >> L;\n    vector<Latter> latters(L);\n    priority_queue<Event, vector<Event>, greater<Event> > que;\n    vector< deque<Event> > l_que(N);\n    REP(i, L){\n      int time;\n      cin >> latters[i].src >> latters[i].dst >> time >> latters[i].name;\n      latters[i].src--; latters[i].dst--;\n      que.push(Event(0, time, i, latters[i].src));\n    }\n    vector<P> answer;\n    vector<bool> wait(N, true);\n    while(!que.empty()){\n      Event e = que.top(); que.pop();\n      print(e);\n      deque<Event>& lq = l_que[e.office];\n      if(e.type == 0){\n        Latter& l = latters[e.latter];\n        if(l.dst == e.office){\n          answer.push_back(P(e.time, l.name));\n        }else{\n          int to = next[e.office][l.dst];\n          assert(to != -1);\n          Event send(0, e.time, e.latter, to);\n          lq.insert(lower_bound(lq.begin(), lq.end(), send), send);\n          // send\n          if(wait[e.office] && (que.empty() || e.time != que.top().time || e.office != que.top().office)){\n            int tmp = lq.size();\n            do_send(e, lq, que, dist, wait);\n            assert(tmp > lq.size());\n          }\n        }\n      }else if(e.type == 1){\n        wait[e.office] = true;\n        if(!lq.empty()){\n          int tmp = lq.size();\n          do_send(e, lq, que, dist, wait);\n          assert(tmp > lq.size());\n        }\n      }\n    }\n    REP(i, N) assert(wait[i]);\n    REP(i, N) assert(l_que[i].empty());\n    sort(answer.begin(), answer.end());\n    assert(answer.size() == latters.size());\n    REP(i, answer.size()){\n      printf(\"%s %d\\n\", answer[i].second.c_str(), answer[i].first);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tint tm,pos,dist;\n\tstring name;\n\tpacket(int t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x], &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(int x,int y){\n\tconst packet &a=pac[x], &b = pac[y];\n\treturn a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tstring name;\n\tpriority_queue<int,vector<int>,cmp> qu;\n\tfor(;cin>>n>>m,n;){\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=inf;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n//\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n\n\t\tfor(;!qu.empty();){\n\t\t\tint pi = qu.top();\n\t\t\tpacket &p = pac[pi];\n\t\t\tt = p.tm;\n\t\t\tf = p.pos;\n\t\t\tif( f == p.dist ){\n\t\t\t\tqu.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( t < bac[f] ){\n\t\t\t\tp.tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n\t\t\t}else{\n\t\t\t\td = to[f][p.dist];\n\t\t\t\tbac[f] = p.tm + 2 * len[p.pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket &q = pac[qi];\n\t\t\t\t\tif(t==q.tm && f==q.pos && to[q.pos][q.dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq.tm += len[f][d];\n\t\t\t\t\t\tq.pos = d;\n\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tsort(pac.begin(),pac.end(),cmp2);\n//\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n\t\tfor(j=0;j<l;j++)tbl[j]=j;\n\t\tsort(tbl,tbl+l,cmp2);\n\t\tfor(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),pac[tbl[j]].tm);\n\n\t\t**len = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tint tm,pos,dist;\n\tstring name;\n\tpacket(int t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x];\n\t\tconst packet &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(int x,int y){\n\tconst packet &a=pac[x], &b = pac[y];\n\treturn a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tstring name;\n\tpriority_queue<int,vector<int>,cmp> qu;\n\tfor(;cin>>n>>m,n;){\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=-1;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n\n\t\tfor(;!qu.empty();){\n\t\t\tint pi = qu.top();\n\t\t\tpacket &p = pac[pi];\n\t\t\tt = p.tm;\n\t\t\tf = p.pos;\n\t\t\tif( f == p.dist ){\n\t\t\t\tqu.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( t < bac[f] ){\n\t\t\t\tp.tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n\t\t\t}else{\n\t\t\t\td = to[f][p.dist];\n\t\t\t\tbac[f] = p.tm + 2 * len[p.pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket &q = pac[qi];\n\t\t\t\t\tif(t==q.tm && f==q.pos && to[q.pos][q.dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq.tm += len[f][d];\n\t\t\t\t\t\tq.pos = d;\n\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tsort(pac.begin(),pac.end(),cmp2);\n//\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n\t\tfor(j=0;j<l;j++)tbl[j]=j;\n\t\tsort(tbl,tbl+l,cmp2);\n\t\tfor(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),pac[tbl[j]].tm);\n\n\t\t**len = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 50\n\nvector<pair<int,int> > way[SIZE];\n\nbool firstcase = true;\n\nstruct DATA{\n  ll t;\n  int id;\n  int now;\n  int next;\n  int goal;\n\n  const bool operator<(const DATA &B) const{\n    if(t != B.t) return t > B.t;\n    if(next != B.next) return next > B.next;\n    return false;\n  }\n\n  DATA(ll t, int id, int now, int next, int goal):\n    t(t), id(id), now(now), next(next), goal(goal){}\n};\n\nint dist[40][40];\nint n;\n\nint getNext(int a, int b){\n  if (a == b) return a;\n  for(int i=0;i<n;i++){\n    if(a != i && dist[a][i] + dist[i][b] == dist[a][b])\n      return i;\n  }\n\n  assert(false);\n  return -1;\n}\n\nbool solve(){\n  int m, q;\n  string text[1000];\n\n  priority_queue<DATA> pq;\n\n  scanf(\"%d%d\", &n, &m);\n  \n  if(n == 0) return false;\n  if(firstcase) firstcase = false;\n  else puts(\"\");\n  \n  for(int i=0;i<n;i++) way[i] = vector<pair<int,int> > ();\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dist[i][j] = INF;\n    }\n    dist[i][i] = 0;\n  }\n  \n  \n  for(int i=0;i<m;i++){\n    int a, b, c; \n    scanf(\"%d%d%d\", &a, &b, &c);\n    a--; b--;\n\n    dist[a][b] = c;\n    dist[b][a] = c;\n  }\n\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n  \n  scanf(\"%d\", &q);\n\n  for(int i=0;i<q;i++){\n    int a, b, t;\n    char temp[60];\n    scanf(\"%d%d%d%s\", &a, &b, &t, temp);\n    a--; b--;\n    text[i] = temp;\n    \n    pq.push(DATA(t, i, a, getNext(a,b), b));\n  }\n\n  bool outside[40] = {};\n  ll sent[40][40] = {};\n  priority_queue<pair<int,int> > que[40];\n  queue<DATA> post[40][40];\n  vector<pair<int,string> > ans;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      sent[i][j] = -1;\n  \n  while(pq.size()){\n    queue<int> work;\n    int t = pq.top().t;\n\n    while(pq.size() && pq.top().t == t){\n      auto p = pq.top(); pq.pop();\n      if(p.id != -1){\n        if(p.now == p.goal){\n          ans.push_back({p.t, text[p.id]});\n          continue;\n        }\n        \n        post[p.now][p.next].push(p);\n        que[p.now].push({-p.t, -p.next});\n        //cerr << \"[post] \" << t << \" : \" << p.now << \" -> \" << p.next << \" -> \" << p.goal << endl;\n      }else{\n        outside[p.now] = false;\n        //cerr << \"[back] \" << t << \" : \" << p.now << endl;\n      }\n\n      work.push(p.now);\n    }\n    \n\n    while(work.size()){\n      int now = work.front(); work.pop();\n      if(outside[now]) continue;\n      \n      while(que[now].size() && -que[now].top().first <= t){\n        auto p = que[now].top(); que[now].pop();\n\n        if(-p.first <= sent[now][-p.second]) continue;\n        \n        //cerr << now << \" -> \" << -p.second << endl;\n        \n        ll max_t = 0;\n        \n        while(post[now][-p.second].size()){\n          auto p2 = post[now][-p.second].front(); post[now][-p.second].pop();\n          \n          max_t = max(max_t, p2.t);\n\n          p2.t = t + dist[now][-p.second];\n          p2.next = getNext(p2.next, p2.goal);\n          p2.now = -p.second;\n          pq.push(p2);\n        }\n        \n        outside[now] = true;\n        pq.push(DATA((ll)t + dist[now][-p.second]*2, -1, now, -1, -1));\n        sent[now][-p.second] = max(sent[now][-p.second], max_t);\n        break;\n      }\n\n    }\n  }\n\n  sort(ans.begin(), ans.end());\n  \n  for(int i=0;i<ans.size();i++){\n    cout << ans[i].second << \" \" << ans[i].first << endl;\n  }\n  \n  return true;\n}\n\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<26)\n\ntypedef pair<int,int> Pii;\ntypedef pair<int,string> Pis;\ntypedef pair< Pii , Pis > PP;\n\nint N,M,K;\nint G[32][32];\nint g[32][32];\n\nset< PP > t[32];\nset< PP > u[32][32];\n\nint mem[32][32];\n\nint search(int from,int to){\n  //if(mem[from][to]!=-1)\n  //    return mem[from][to];\n  \n  int mini=INF, res=-1;\n  for(int i=0;i<N;i++){\n    if(from!=i&&\n       //       g[from][i]!=INF&&\n       mini > g[from][i] + G[i][to] ){\n      mini=g[from][i]+G[i][to];\n      res=i;\n    }\n  }\n  \n  return mem[from][to]=res;\n}\n\nvoid init(){\n  for(int i=0;i<32;i++){\n    t[i].clear();\n    for(int j=0;j<32;j++){\n      g[i][j]=(i==j?0:INF);\n      G[i][j]=(i==j?0:INF);\n      mem[i][j]=-1;\n      u[i][j].clear();\n    }\n  }\n}\n\nint main(){\n  int cnt=0;\n  while(1){\n\n    init();\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    if(cnt)cout<<endl;\n    cnt++;\n    \n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      G[a][b]=min(G[a][b],c);\n      G[b][a]=min(G[b][a],c);\n    }\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n    \n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    cin>>K;\n\n    map<int, vector<PP> > mp;\n    set<int> st;\n    \n    for(int i=0;i<K;i++){\n      int from,to,ti;\n      string name;\n      cin>>from>>to>>ti>>name;\n      from--,to--;\n      mp[ti].push_back( PP( Pii(from,to) , Pis(0,name)) );\n      st.insert(ti);\n    }\n\n    vector< Pis > ans;\n    vector<int> v(N,0);\n\n    st.insert(0);\n    while(!st.empty()){\n      int p=*st.begin();\n      if(mp.count(p)){\n        for(int i=0;i<(int)mp[p].size();i++){\n          PP pp=mp[p][i];\n          int from=pp.first.first;\n          int to=pp.first.second;\n          string name=pp.second.second;\n          int key=search(from,to);\n          PP tmp=PP( Pii(p, key ) , Pis(to,name) );\n          t[from].insert(tmp);\n          u[from][key].insert(tmp);\n        }\n        mp[p].clear();\n      }\n      \n      for(int i=0;i<N;i++){\n        if(v[i]>p)continue;\n        if(t[i].empty())continue;\n\n        PP target=*t[i].begin();\n        t[i].erase( t[i].begin() );\n        int nex=target.first.second;\n        set< PP > :: iterator it;\n        for( it=u[i][nex].begin(); it!= u[i][nex].end() ; it++ ){\n          PP pp=*it;\n          int to=pp.second.first;\n          string name=pp.second.second;\n          \n          if(to==nex){\n            ans.push_back( Pis( p+g[i][nex] , name ) );\n            continue;\n          }\n\n          mp[ p+g[i][nex] ].push_back( PP(Pii(nex,to),Pis(0,name)) );\n          \n        }// iterator\n        \n        u[i][nex].clear();\n        v[i]=p+g[i][nex]*2;\n        st.insert(v[i]);\n      }// i\n      \n      st.erase( st.begin() );\n    }// st.empty()\n    \n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      Pis p=ans[i];\n      cout<<p.second<<' '<<p.first<<endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 32;\n\nconst int INF = 1 << 30;\n\nconst string evnms[] = { \"E_LT_ARV\", \"E_PM_BK\", \"E_PM_DL\", \"E_PM_ST\" };\n\n/* typedef */\n\ntypedef pair<int,int> pii;\ntypedef pair<int,string> pis;\ntypedef vector<int> vi;\ntypedef vector<pis> vpis;\ntypedef queue<pii> qpii;\n\nstruct Letter {\n  int t, nexthop, dst;\n  string label;\n  Letter() {}\n  Letter(int _t, int _nexthop, int _dst, string _label) {\n    t = _t, nexthop = _nexthop, dst = _dst, label = _label;\n  }\n\n  bool operator<(const Letter& lt) const {\n    return t < lt.t || (t == lt.t && nexthop < lt.nexthop);\n  }\n\n  void print() {\n    printf(\"    Letter: t=%d, nexthop=%d, dst=%d, labe=%s\\n\",\n\t   t, nexthop, dst, label.c_str());\n  }\n};\n\ntypedef deque<Letter> dql;\n\nstruct PostMan {\n  int id, st;\n  dql mls;\n\n  void print() {\n    printf(\"  PostMan: id=%d, st=%d, mls=%lu\\n\", id, st, mls.size());\n    for (int i = 0; i < mls.size(); i++) mls[i].print();\n  }\n};\n\nenum { M_WT, M_ON };\nenum { E_LT_ARV, E_PM_BK, E_PM_DL, E_PM_ST };\n\nstruct Event {\n  int t, st;\n  int p0, p1;\n  string label;\n  PostMan *pm;\n\n  Event() {}\n  Event(int _t, int _st, int _p0, int _p1, string _label) {\n    t = _t, st = _st, p0 = _p0, p1 = _p1;\n    label = _label;\n    pm = NULL;\n  }\n  Event(int _t, int _st, int _p0, int _p1, PostMan *_pm) {\n    t = _t, st = _st, p0 = _p0, p1 = _p1;\n    label = \"\";\n    pm= _pm;\n  }\n  \n  bool operator>(const Event& ev) const {\n    return t > ev.t || (t == ev.t && st > ev.st);\n  }\n\n  void print() {\n    if (st == E_LT_ARV) {\n      printf(\"Event: t=%d, st=%s, %d->%d, label=%s\\n\",\n\t     t, evnms[st].c_str(), p0, p1, label.c_str());\n    }\n    else {\n      printf(\"Event: t=%d, st=%s, %d->%d, pm=%d\\n\",\n\t     t, evnms[st].c_str(), p0, p1, pm->id);\n      pm->print();\n    }\n  }\n};\n\n/* global variables */\n\nint n, m, l;\nvi nbrs[MAX_N];\nint costs[MAX_N][MAX_N];\nint dists[MAX_N], nhops[MAX_N];\nint rt[MAX_N][MAX_N];\n\ndql posts[MAX_N];\nPostMan pmen[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (bool first = true;; first = false) {\n    cin >> n >> m;\n    if (n == 0) break;\n    \n    if (! first) cout << endl;\n\n    for (int i = 0; i < n; i++) nbrs[i].clear();\n    \n    for (int i = 0; i < m; i++) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--, b--;\n      nbrs[a].push_back(b);\n      nbrs[b].push_back(a);\n      costs[a][b] = costs[b][a] = c;\n    }\n\n    for (int i = 0; i < n; i++) {\n      sort(nbrs[i].begin(), nbrs[i].end());\n      for (int j = 0; j < n; j++) rt[i][j] = -1;\n    }\n\n    for (int st = 0; st < n; st++) {\n      for (int i = 0; i < n; i++) dists[i] = INF;\n      dists[st] = 0;\n      nhops[st] = -1;\n\n      qpii q;\n      q.push(pii(0, st));\n\n      while (! q.empty()) {\n\tpii u = q.front();\n\tq.pop();\n\n\tint ud = u.first;\n\tint ui = u.second;\n\tif (ud != dists[ui]) continue;\n\n\tint unhop = nhops[ui];\n\tvi& nbru = nbrs[ui];\n\n\tfor (vi::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n\t  int vi = *vit;\n\t  int vd = ud + costs[ui][vi];\n\t  if (dists[vi] > vd) {\n\t    dists[vi] = vd;\n\t    nhops[vi] = (unhop >= 0) ? unhop : vi;\n\t    q.push(pii(vd, vi));\n\t  }\n\t  else if (dists[vi] == vd && nhops[vi] > unhop) {\n\t    dists[vi] = vd;\n\t    nhops[vi] = unhop;\n\t    q.push(pii(vd, vi));\n\t  }\n\t}\n      }\n\n      for (int gl = 0; gl < n; gl++) rt[st][gl] = nhops[gl];\n    }\n\n    if (false) {\n      for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < n; j++) cout << rt[i][j] << ' ';\n\tcout << endl;\n      }\n    }\n\n    for (int i = 0; i < n; i++) {\n      posts[i].clear();\n      pmen[i].id = i, pmen[i].st = M_WT;\n      pmen[i].mls.clear();\n    }\n\n    priority_queue<pis,vector<pis>,greater<pis> > arrived;\n    priority_queue<Event,vector<Event>,greater<Event> > pqe;\n\n    cin >> l;\n    \n    for (int i = 0; i < l; i++) {\n      int p0, p1, t;\n      string label;\n      cin >> p0 >> p1 >> t >> label;\n      p0--, p1--;\n      \n      pqe.push(Event(t, E_LT_ARV, p0, p1, label));\n    }\n\n    while (! pqe.empty()) {\n      Event ev = pqe.top();\n      pqe.pop();\n      //ev.print();\n      \n      if (ev.st == E_LT_ARV) {\n\tint nexthop = rt[ev.p0][ev.p1];\n\tposts[ev.p0].push_back(Letter(ev.t, nexthop, ev.p1, ev.label));\n\n\tPostMan *pm = &pmen[ev.p0];\n\tif (pm->st == M_WT) {\n\t  pm->st = M_ON;\n\t  pqe.push(Event(ev.t, E_PM_ST, ev.p0, ev.p0, pm));\n\t}\n      }\n\n      else if (ev.st == E_PM_ST) {\n\tdql& post = posts[ev.p0];\n\tsort(post.begin(), post.end());\n\n\tLetter lt0 = post.front();\n\tpost.pop_front();\n\tPostMan *pm = ev.pm;\n\tpm->mls.push_back(lt0);\n\n\tfor (dql::iterator lit = post.begin(); lit != post.end();) {\n\t  if (lit->nexthop == lt0.nexthop) {\n\t    pm->mls.push_back(*lit);\n\t    lit = post.erase(lit);\n\t  }\n\t  else lit++;\n\t}\n\n\tpqe.push(Event(ev.t + costs[ev.p0][lt0.nexthop],\n\t\t       E_PM_DL, ev.p0, lt0.nexthop, pm));\n      }\n\n      else if (ev.st == E_PM_DL) {\n\tPostMan *pm = ev.pm;\n\tdql& mls = pm->mls;\n\t\n\tfor (dql::iterator lit = mls.begin(); lit != mls.end(); lit++) {\n\t  lit->nexthop = rt[ev.p1][lit->dst];\n\t  if (lit->nexthop == -1)\n\t    arrived.push(pis(ev.t, lit->label));\n\t  else\n\t    pqe.push(Event(ev.t, E_LT_ARV, ev.p1, lit->dst, lit->label));\n\t}\n\n\tpm->mls.clear();\n\n\tpqe.push(Event(ev.t + costs[ev.p1][ev.p0],\n\t\t       E_PM_BK, ev.p1, ev.p0, pm));\n      }\n\n      else if (ev.st == E_PM_BK) {\n\tPostMan *pm = ev.pm;\n\tif (posts[pm->id].empty())\n\t  pm->st = M_WT;\n\telse {\n\t  pqe.push(Event(ev.t, E_PM_ST, ev.p1, ev.p1, pm));\n\t}\n      }\n    }\n\n    //cout << arrived.size() << endl;\n\n    while (! arrived.empty()) {\n      pis lt = arrived.top();\n      arrived.pop();\n\n      cout << lt.second << ' ' << lt.first << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nclass Data\n{\npublic:\n    int time;     // 時刻\n    int position; // 位置\n    int next;     // 次の転送先\n    int postID;   // 郵便物の番号\n    int staffID;  // 転送員の番号\n    Data(int time0, int position0, int next0, int postID0, int staffID0){\n        time = time0;\n        position = position0;\n        next = next0;\n        postID = postID0;\n        staffID = staffID0;\n    }\n    bool operator<(const Data& d) const{\n        return make_pair(time, make_pair(next, postID)) < make_pair(d.time, make_pair(d.next, d.postID));\n    }\n};\n\nint main()\n{\n    bool first = true;\n\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        if(first)\n            first = false;\n        else\n            cout << endl;\n\n        vector<vector<Edge> > edges(n);\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            -- a;\n            -- b;\n            edges[a].push_back(Edge(b, c));\n            edges[b].push_back(Edge(a, c));\n        }\n\n        int l;\n        cin >> l;\n        vector<pair<string, vector<int> > > v(l, make_pair(\"\", vector<int>(3)));\n        for(int i=0; i<l; ++i){\n            for(int j=0; j<3; ++j)\n                cin >> v[i].second[j]; // 発送元、宛先、時刻\n            -- v[i].second[0];\n            -- v[i].second[1];\n            cin >> v[i].first;\n        }\n        sort(v.begin(), v.end());\n\n        vector<vector<int> > dist(n, vector<int>(n, INT_MAX)); // dist[i][j] : iからjまでの距離\n        vector<vector<int> > next(n, vector<int>(n, INT_MAX)); // next[i][j] : iからjへ運ぶ郵便物に対する直接の転送先\n        for(int g=0; g<n; ++g){\n            dist[g][g] = 0;\n            multimap<int, int> mm;\n            mm.insert(make_pair(0, g));\n            while(!mm.empty()){\n                int d = mm.begin()->first;\n                int curr = mm.begin()->second;\n                mm.erase(mm.begin());\n                if(d > dist[curr][g])\n                    continue;\n\n                for(unsigned i=0; i<edges[curr].size(); ++i){\n                    int j = edges[curr][i].to;\n                    int d2 = d + edges[curr][i].cost;\n                    if(d2 < dist[j][g]){\n                        dist[j][g] = d2;\n                        mm.insert(make_pair(d2, j));\n                    }\n                    if(d2 <= dist[j][g] && curr < next[j][g])\n                        next[j][g] = curr;\n                }\n            }\n        }\n\n        multiset<Data> ms;\n        for(int i=0; i<l; ++i)\n            ms.insert(Data(v[i].second[2], v[i].second[0], next[v[i].second[0]][v[i].second[1]], i, -1));\n        vector<bool> isStaff(n, true);         // 郵便局に転送員がいるかどうか\n        vector<multiset<Data> > waitedPost(n); // 郵便局に届いている郵便物\n\n        while(!ms.empty()){\n            int t = ms.begin()->time;\n            while(!ms.empty() && t == ms.begin()->time){\n                Data d = *ms.begin();\n                ms.erase(ms.begin());\n\n                if(d.postID != -1){\n                    if(v[d.postID].second[1] == d.position)\n                        cout << v[d.postID].first << ' ' << t << endl;\n                    else\n                        waitedPost[d.position].insert(Data(t, -1, -1, d.postID, -1));\n                    if(d.staffID != -1)\n                        ms.insert(Data(t + dist[d.position][d.staffID], -1, -1, -1, d.staffID));\n                }else{\n                    isStaff[d.staffID] = true;\n                }\n            }\n\n            for(int i=0; i<n; ++i){\n                if(!isStaff[i] || waitedPost[i].size() == 0)\n                    continue;\n\n                int to = next[i][v[waitedPost[i].begin()->postID].second[1]];\n                multiset<Data>::iterator it = waitedPost[i].begin();\n                while(it != waitedPost[i].end()){\n                    if(to == next[i][v[it->postID].second[1]]){\n                        ms.insert(Data(t + dist[i][to], to, next[to][v[it->postID].second[1]], it->postID, i));\n                        multiset<Data>::iterator it2 = it;\n                        ++ it;\n                        waitedPost[i].erase(it2);\n                    }else{\n                        ++ it;\n                    }\n                }\n                isStaff[i] = false;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 10000000\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,string> P2;\n\nstruct edge{\n\tint t,c;\n\tedge(){}\n\tedge(int tt,int cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nstruct data{\n\tint f,id;\n\tint ti,next;\n\tdata(){}\n\tdata(int ff,int ii,int tt,int nn){\n\t\tf=ff;\n\t\tid=ii;\n\t\tti=tt;\n\t\tnext=nn;\n\t}\n\tbool operator<(const data& d)const{\n\t\tif(ti==d.ti)return next>d.next;\n\t\treturn ti>d.ti;\n\t}\n};\n\nint n,m,l;\nvector<edge> G[1001];\n\nint dist[33];\nint dijk(int f,int t){\n\tfill(dist,dist+n,INF);\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,t));\n\tint res=n;\n\tdist[t]=0;\n\twhile(que.size()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tif(dist[p.second]<p.first)continue;\n\t\tfor(int j=0;j<G[p.second].size();j++){\n\t\t\tedge e=G[p.second][j];\n\t\t\tif(e.t==f && dist[e.t]==dist[p.second]+e.c)res=min(res,p.second);\n\t\t\tif(dist[e.t]>dist[p.second]+e.c){\n\t\t\t\tif(e.t==f)res=min(res,p.second);\n\t\t\t\tdist[e.t]=dist[p.second]+e.c;\n\t\t\t\tque.push(P(dist[e.t],e.t));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\npriority_queue<data> que[35];\nstring str[1001];\nint lf[1001],lt[1001],ltime[1001];\nint next[35];\nint ntime[35];\nvector<P2> res;\n\nint main(void){\n\tbool space=false;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tif(space)cout << endl;\n\t\tspace=true;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint f,t,c;\n\t\t\tscanf(\"%d%d%d\",&f,&t,&c);\n\t\t\tf--;\n\t\t\tt--;\n\t\t\tG[f].push_back(edge(t,c));\n\t\t\tG[t].push_back(edge(f,c));\n\t\t}\n\t\tscanf(\"%d\",&l);\n\t\tfor(int i=0;i<l;i++){\n\t\t\tcin >> lf[i] >> lt[i] >> ltime[i] >> str[i];\n\t\t\tlf[i]--;\n\t\t\tlt[i]--;\n\t\t\tque[lf[i]].push(data(-1,i,ltime[i],dijk(lf[i],lt[i])));\n\t\t}\n\t\tmemset(next,0,sizeof(next));\n\t\tres.clear();\n\t\twhile(1){\n\t\t\tbool flag=false;\n\t\t\tint best=0,bt=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(que[i].size()>0){\n\t\t\t\t\tdata p=que[i].top();\n\t\t\t\t\tif(!flag){\n\t\t\t\t\t\tbest=p.ti;\n\t\t\t\t\t\tbt=i;\n\t\t\t\t\t}\n\t\t\t\t\tflag=true;\n\t\t\t\t\tif(best>p.ti){\n\t\t\t\t\t\tbt=i;\n\t\t\t\t\t\tbest=p.ti;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag)break;\n\t\t\tdata v=que[bt].top();\n\t\t\tque[bt].pop();\n\t\t\tif(v.f>=0)next[v.f]--;\n\t\t\tif(bt==lt[v.id]){\n\t\t\t\tres.push_back(P2(v.ti,str[v.id]));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(next[bt]!=0 && ntime[bt]!=v.ti){\n\t\t\t\tv.ti=ntime[bt];\n\t\t\t\tque[bt].push(v);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nex=dijk(bt,lt[v.id]);\n\t\t\tint now=v.ti;\n\t\t\tint plu=0;\n\t\t\tfor(int i=0;i<G[bt].size();i++){\n\t\t\t\tif(nex==G[bt][i].t)plu=G[bt][i].c;\n\t\t\t}\n\t\t\tnext[bt]++;\n\t\t\tntime[bt]=v.ti+plu*2;\n\t\t\tv.ti+=plu;\n\t\t\tque[nex].push(data(bt,v.id,v.ti,(nex==lt[v.id])?-1:dijk(nex,lt[v.id])));\n\t\t\tqueue<data> tmp;\n\t\t\twhile(que[bt].size()){\n\t\t\t\tdata pp=que[bt].top();\n\t\t\t\tif(pp.ti>now)break;\n\t\t\t\tque[bt].pop();\n\t\t\t\tif(pp.next==nex){\n\t\t\t\t\tnext[bt]++;\n\t\t\t\t\tque[nex].push(data(bt,pp.id,v.ti,(nex==lt[pp.id])?-1:dijk(nex,lt[v.id])));\n\t\t\t\t}else{\n\t\t\t\t\ttmp.push(pp);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(tmp.size()){\n\t\t\t\tdata pp=tmp.front();\n\t\t\t\tque[bt].push(pp);\n\t\t\t\ttmp.pop();\n\t\t\t}\n\t\t}\n\t\tsort(res.begin(),res.end());\n\t\tfor(int i=0;i<res.size();i++){\n\t\t\tcout << res[i].second << \" \" << res[i].first << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, m, l, from[1000], to[1000], tm[1000];\nint on[32];\nvector<pair<pi, int> > ls[32];\n\nstring name[1000];\nvector<pair<int, string> > ans;\nint e[32][32], next[32][32];\n\nvoid calc(int g){\n\tpriority_queue<pair<pi, int> > q; //t, prev, cur\n\tq.push(mp(mp(0, -g), g));\n\twhile(!q.empty()){\n\t\tint t = q.top().F.F;\n\t\tint c = q.top().S, p = -q.top().F.S;\n\t\tq.pop();\n\t\tif(next[c][g] >= 0) continue;\n\t\tnext[c][g] = p;\n\t\t\n\t\trep(i, n) if(e[c][i] < inf) q.push(mp(mp(t - e[c][i], -c), i));\n\t}\n}\n\nint main(){\n\tint cs = 0;\n\twhile(cin >> n >> m, n){\n\t\tif(cs++) cout << endl;\n\t\tmemset(next, -1, sizeof(next));\n\t\trep(i, n) on[i] = 1, ls[i].clear();\n\t\t\n\t\tpriority_queue<pair<int, pi> > q;\n\n\t\trep(i, n) rep(j, n) e[i][j] = i == j ? 0 : inf;\n\t\trep(i, m){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\te[a][b] = e[b][a] = c;\n\t\t}\n\t\trep(i, n) calc(i);\n\t\t\n\t\tcin >> l;\n\t\trep(i, l){\n\t\t\tcin >> from[i] >> to[i] >> tm[i] >> name[i];\n\t\t\tto[i]--; from[i]--;\n\t\t\tq.push(mp(-tm[i], mp(2, from[i] * 1000 + i)));\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tint t = -q.top().F, type = q.top().S.F;\n\t\t\tint data = q.top().S.S; q.pop();\n\t\t\t\n\t\t\tif(type == 1) on[data] = 1;\n\t\t\telse{\n\t\t\t\tint f = data / 1000, id = data % 1000;\n\t\t\t\tls[f].pb(mp(mp(t, next[f][to[id]]), id));\n\t\t\t}\n\t\t\trep(i, n) if(ls[i].size() && on[i]){\n\t\t\t\tsort(all(ls[i]));\n\t\t\t\tbool first = 1;\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(j, ls[i].size()){\n\t\t\t\t\tif(ls[i][j].F != ls[i][0].F) break;\n\t\t\t\t\t\n\t\t\t\t\tint id = ls[i][j].S, nxt = next[i][to[id]];\n\t\t\t\t\tif(ls[i][j].F.S == to[id]){\n\t\t\t\t\t\tans.pb(mp(t + e[i][to[id]], name[id]));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tq.push(mp(-t - e[i][nxt], mp(2, nxt * 1000 + id)));\n\t\t\t\t\t}\n\t\t\t\t\tif(first){\n\t\t\t\t\t\tfirst = 0;\n\t\t\t\t\t\tq.push(mp(-t - 2 * e[i][nxt], mp(1, i)));\n\t\t\t\t\t}\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tls[i].erase(ls[i].begin(), ls[i].begin() + cnt);\n\t\t\t\ton[i] = 0;\n\t\t\t}\n\t\t}\n\t\tsort(all(ans));\n\t\trep(i, l) cout << ans[i].S << \" \" << ans[i].F << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nclass Data\n{\npublic:\n    int time;     // 時刻\n    int position; // 位置\n    int next;     // 次の転送先\n    int postID;   // 郵便物の番号\n    int staffID;  // 転送員の番号\n    Data(int time0, int position0, int next0, int postID0, int staffID0){\n        time = time0;\n        position = position0;\n        next = next0;\n        postID = postID0;\n        staffID = staffID0;\n    }\n    bool operator<(const Data& d) const{\n        return make_pair(time, make_pair(next, postID)) < make_pair(d.time, make_pair(d.next, d.postID));\n    }\n};\n\nint main()\n{\n    bool first = true;\n\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        if(first)\n            first = false;\n        else\n            cout << endl;\n\n        vector<vector<Edge> > edges(n);\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            -- a;\n            -- b;\n            edges[a].push_back(Edge(b, c));\n            edges[b].push_back(Edge(a, c));\n        }\n\n        int l;\n        cin >> l;\n        vector<pair<string, vector<int> > > v(l, make_pair(\"\", vector<int>(3)));\n        for(int i=0; i<l; ++i){\n            for(int j=0; j<3; ++j)\n                cin >> v[i].second[j];\n            -- v[i].second[0];\n            -- v[i].second[1];\n            cin >> v[i].first;\n        }\n        sort(v.begin(), v.end());\n        \n        vector<string> name(l);\n        vector<int> start(l), goal(l), startTime(l); // 発送元、宛先、時刻\n        for(int i=0; i<l; ++i){\n            name[i] = v[i].first;\n            start[i] = v[i].second[0];\n            goal[i] = v[i].second[1];\n            startTime[i] = v[i].second[2];\n        }\n\n        vector<vector<int> > dist(n, vector<int>(n, INT_MAX)); // dist[i][j] : iからjまでの距離\n        vector<vector<int> > next(n, vector<int>(n, INT_MAX)); // next[i][j] : iからjへ運ぶ郵便物に対する直接の転送先\n        for(int g=0; g<n; ++g){\n            dist[g][g] = 0;\n            multimap<int, int> mm;\n            mm.insert(make_pair(0, g));\n            while(!mm.empty()){\n                int d = mm.begin()->first;\n                int curr = mm.begin()->second;\n                mm.erase(mm.begin());\n                if(d > dist[curr][g])\n                    continue;\n\n                for(unsigned i=0; i<edges[curr].size(); ++i){\n                    int j = edges[curr][i].to;\n                    int d2 = d + edges[curr][i].cost;\n                    if(d2 < dist[j][g]){\n                        dist[j][g] = d2;\n                        next[j][g] = curr;\n                        mm.insert(make_pair(d2, j));\n                    }\n                    if(d2 == dist[j][g] && curr < next[j][g])\n                        next[j][g] = curr;\n                }\n            }\n        }\n\n        multiset<Data> ms;\n        for(int i=0; i<l; ++i)\n            ms.insert(Data(startTime[i], start[i], -1, i, -1));\n        vector<bool> isStaff(n, true);         // 郵便局に転送員がいるかどうか\n        vector<multiset<Data> > waitedPost(n); // 郵便局に届いている郵便物\n\n        while(!ms.empty()){\n            int t = ms.begin()->time;\n            while(!ms.empty() && t == ms.begin()->time){\n                Data d = *ms.begin();\n                ms.erase(ms.begin());\n\n                if(d.postID != -1){\n                    if(d.position == goal[d.postID])\n                        cout << name[d.postID] << ' ' << t << endl;\n                    else\n                        waitedPost[d.position].insert(Data(t, -1, next[d.position][goal[d.postID]], d.postID, -1));\n                    if(d.staffID != -1)\n                        ms.insert(Data(t + dist[d.position][d.staffID], -1, -1, -1, d.staffID));\n                }else{\n                    isStaff[d.staffID] = true;\n                }\n            }\n\n            for(int i=0; i<n; ++i){\n                if(!isStaff[i] || waitedPost[i].size() == 0)\n                    continue;\n\n                multiset<Data>::iterator it = waitedPost[i].begin();\n                int to = it->next;\n                while(it != waitedPost[i].end()){\n                    if(to == next[i][goal[it->postID]]){\n                        ms.insert(Data(t + dist[i][to], to, -1, it->postID, i));\n                        multiset<Data>::iterator it2 = it;\n                        ++ it;\n                        waitedPost[i].erase(it2);\n                    }else{\n                        ++ it;\n                    }\n                }\n                isStaff[i] = false;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 50\n\nbool firstcase = true;\n\nstruct DATA{\n  ll t;\n  int id;\n  int now;\n  int next;\n  int goal;\n\n  const bool operator<(const DATA &B) const{\n    if(t != B.t) return t > B.t;\n    if(next != B.next) return next > B.next;\n    return false;\n  }\n\n  DATA(ll t, int id, int now, int next, int goal):\n    t(t), id(id), now(now), next(next), goal(goal){}\n};\n\nint dist[40][40];\nbool connect[40][40];\nint n;\n\nint getNext(int a, int b){\n  if (a == b) return a;\n  for(int i=0;i<n;i++){\n    if(connect[a][i] && dist[a][i] + dist[i][b] == dist[a][b])\n      return i;\n  }\n\n  assert(false);\n  return -1;\n}\n\nbool solve(){\n  int m, q;\n  string text[1000];\n  \n  priority_queue<DATA> pq;\n\n  scanf(\"%d%d\", &n, &m);\n  \n  if(n == 0) return false;\n  if(firstcase) firstcase = false;\n  else puts(\"\");\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dist[i][j] = INF;\n      connect[i][j] = false;\n    }\n    dist[i][i] = 0;\n  }\n  \n  \n  for(int i=0;i<m;i++){\n    int a, b, c; \n    scanf(\"%d%d%d\", &a, &b, &c);\n    a--; b--;\n\n    dist[a][b] = dist[b][a] = c;\n    connect[a][b] = connect[b][a] = true;\n  }\n\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n  \n  scanf(\"%d\", &q);\n\n  for(int i=0;i<q;i++){\n    int a, b, t;\n    char temp[60];\n    scanf(\"%d%d%d%s\", &a, &b, &t, temp);\n    a--; b--;\n    text[i] = temp;\n    \n    pq.push(DATA(t, i, a, getNext(a,b), b));\n  }\n\n  bool outside[40] = {};\n  ll sent[40][40] = {};\n  priority_queue<pair<ll,int> > que[40];\n  queue<DATA> post[40][40];\n  vector<pair<ll,string> > ans;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      sent[i][j] = -1;\n  \n  while(pq.size()){\n    queue<int> work;\n    ll t = pq.top().t;\n    \n    while(pq.size() && pq.top().t == t){\n      auto p = pq.top(); pq.pop();\n      if(p.id != -1){\n        if(p.now == p.goal){\n          ans.push_back({p.t, text[p.id]});\n          continue;\n        }\n        \n        post[p.now][p.next].push(p);\n        que[p.now].push({-p.t, -p.next});\n        // cerr << \"[post] \" << t << \" : \" << p.now << \" -> \" << p.next << \" -> \" << p.goal << endl;\n      }else{\n        assert(outside[p.now]);\n        outside[p.now] = false;\n        // cerr << \"[back] \" << t << \" : \" << p.now << endl;\n      }\n\n      work.push(p.now);\n    }\n    \n\n    while(work.size()){\n      int now = work.front(); work.pop();\n      if(outside[now]) continue;\n      \n      while(que[now].size() && -que[now].top().first <= t){\n        auto p = que[now].top(); que[now].pop();\n\n        if(-p.first <= sent[now][-p.second]) continue;\n        \n        //cerr << now << \" -> \" << -p.second << endl;\n        \n        while(post[now][-p.second].size()){\n          auto p2 = post[now][-p.second].front(); post[now][-p.second].pop();\n          \n          p2.t = t + dist[now][p2.next];\n          p2.now = p2.next;\n          p2.next = getNext(p2.next, p2.goal);\n          pq.push(p2);\n        }\n        \n        outside[now] = true;\n        pq.push(DATA((ll)t + dist[now][-p.second]*2, -1, now, -1, -1));\n        sent[now][-p.second] = t;\n        break;\n      }\n\n    }\n  }\n\n  sort(ans.begin(), ans.end());\n\n  assert(ans.size() == q);\n  \n  for(int i=0;i<q;i++){\n    cout << ans[i].second << \" \" << ans[i].first << endl;\n  }\n  \n  return true;\n}\n\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n#define mp         make_pair\n#define ALL(C)     (C).begin(),(C).end()\n\nconst int N = 32;\nconst int inf = INT_MAX;\nconst int costinf=(1<<21);\n\n\ntypedef struct{string name;int time,tar;}Mail;\n\nclass Postman{\npublic:\n  int time,tar;\n  vector<Mail> mail;\n};\n\nint cost[N][N];\nint edge[N][N];//costinf\nint next[N][N];\nvoid wf(int n){\n  rep(i,n)rep(j,n)cost[i][j]=edge[i][j];\n  rep(k,n)rep(i,n)rep(j,n)cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n  rep(i,n){\n    rep(j,n){\n      next[i][j]=100;\n      if (i == j)continue;\n      rep(k,n){\n\tif (i == k)continue;\n\tif (edge[i][k] == costinf)continue;\n\tif (cost[i][j] == edge[i][k]+cost[k][j]){\n\t  next[i][j]=k;\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nclass Postoffice{\npublic:\n  vector<Mail> mail;\n  int find_next_time(int node,int now){\n    int mintime=inf;\n    rep(i,mail.size()){\n      if (mail[i].time < now)return 0;\n      else mintime=min(mintime,mail[i].time);\n    }\n    if (mintime == inf)return mintime;\n    return mintime-now;\n  }\n\n  void set_man(int node,int now,Postman &man){\n    int mintime=inf,mindex=100;\n    rep(i,mail.size()){\n      if (mail[i].time > now)continue;\n      if (mail[i].time < mintime || \n\t  (mintime == mail[i].time && next[node][mail[i].tar] < mindex)){\n\tmintime=mail[i].time;\n\tmindex =next[node][mail[i].tar];\n      }\n    }\n    \n    if (mindex == 100)return;\n\n    rep(i,mail.size()){\n      if (mail[i].time > now)continue;\n      if (next[node][mail[i].tar] == mindex){\n\tman.mail.pb(mail[i]);\n\tmail.erase(mail.begin()+i);\n\ti--;\n      }\n    }\n    \n    man.time=edge[node][mindex];\n    man.tar =mindex;\n  }\n};\n\n\nvoid solve(int n,Postman *man,Postoffice *office){\n  vector<pair<int ,string> > ans;\n  int t = 0;\n\n  //initialization\n  wf(n);\n\n  while(true){\n    int minevent=inf;\n    \n    // arrive\n    rep(i,n){\n      if (man[i].tar != -1)minevent=min(minevent,man[i].time);\n    }\n\n    rep(i,n){\n      if (man[i].tar == -1){\n\tminevent=min(office[i].find_next_time(i,t),minevent);\n      }\n    }\n\n    if (minevent == inf)break;\n\n    t+=minevent;\n    \n    rep(i,n){\n      if (man[i].tar != -1){\n\tman[i].time-=minevent;\n\tif (man[i].time == 0){\n\t  if (man[i].tar != i){\n\t    rep(j,man[i].mail.size()){\n\t      if (man[i].tar == man[i].mail[j].tar){\n\t\tans.pb(mp(t,man[i].mail[j].name));\n\t      }\n\t      else {\n\t\tman[i].mail[j].time=t;\n\t\toffice[man[i].tar].mail.pb(man[i].mail[j]);\n\t      }\n\t    }\n\t    man[i].mail.clear();\n\t    man[i].time=edge[man[i].tar][i];\n\t    man[i].tar=i;\n\t  }else if (man[i].tar == i){\n\t    man[i].tar=-1;\n\t  }\n\t}\n      }\n    }\n\n    rep(i,n){\n      if (man[i].tar != -1)continue;\n      office[i].set_man(i,t,man[i]);\n    }\n  }\n\n  sort(ALL(ans));\n  rep(i,ans.size()){\n    cout << ans[i].second <<\" \" << ans[i].first << endl;\n  }\n}\n\nmain(){\n  int n,m;\n  int te=0;\n  while(cin>>n>>m && n){\n    if (te)cout<<endl;\n    te++;\n    rep(i,n){\n      rep(j,n)edge[i][j]=costinf;\n      edge[i][i]=0;\n    }\n    Postman    man[n];\n    Postoffice     office[n];\n    rep(i,n)man[i].tar=-1;\n    \n    \n    rep(i,m){\n      int f,t,c;\n      cin>>f>>t>>c;\n      f--;t--;\n      edge[f][t]=edge[t][f]=c;\n    }\n    \n    int l;\n    cin>>l;\n    rep(i,l){\n      int fr,to,ti;\n      string name;\n      cin>>fr>>to>>ti>>name;\n      office[fr-1].mail.pb((Mail){name,ti,to-1});\n    }\n    \n    solve(n,man,office);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nstruct edge{\n    int to;\n    int cost;\n};\nint d[33][33];\n// cur,to\nint nxt[33][33];\nstring letterNames[1001];\n\nconst int INF=1000000000;\nvector<edge>G[101];\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\nvoid calcNxtPlace(int V){\n    for(int i=0;i<33;i++)for(int j=0;j<33;j++)nxt[i][j]=INF;\n    for(int i=0;i<V;i++){\n        for(int j=0;j<V;j++){\n            if(i!=j){\n                int nxtNum=INF;\n                for(int k=0;k<G[i].size();k++){\n                    edge &e=G[i][k];\n                    if(d[i][e.to]+d[e.to][j]==d[i][j])nxtNum=min(nxtNum,e.to);\n                }\n                nxt[i][j]=nxtNum;\n            }\n        }\n    }\n}\n\nstruct Letter{\n    int nxtTo;\n    int goal;\n    int start;\n    int id;\n    int arriveTime;\n    bool operator<(const Letter &lt)const{\n        return arriveTime<lt.arriveTime;\n    }\n};\n\nstruct Event{\n    // 0:,1:úÔ,2:èÌÇÁ\n    int kind;\n    int time;\n    int node;\n    int prvNode;\n    vector<Letter> lts;\n    bool operator<(const Event &e)const{\n        if(time<e.time)true;\n        else if(time>e.time)false;\n        return kind<e.kind;\n    }\n};\n\nint N,M,L;\n// Çõª¶Ý·é©Ç¤©\nbool isExist[1001];\n// eXÖÇÉÂ¢ÄA»ê¼êÌèª·ÅÉçê½©\nbool isArrivalLet[1001][1001];\n// eXÖÇ²ÆÉAèðÔÉÇ\npriority_queue<Letter> postLets[1001];\n// eXÖÇ²ÆÉAèð Äæ²ÆÉÇ\nvector<Letter> postByNxtTo[101][101];\n\nint main(){\n    bool fst=true;\n    while(cin>>N>>M&&(N|M)){\n        if(fst)fst=false;\n        else cout<<endl;\n        for(int i=0;i<1001;i++)isExist[i]=true;\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)postByNxtTo[i][j].clear();\n        memset(isArrivalLet,0,sizeof(isArrivalLet));\n        //vector<Letter> lts;\n        for(int i=0;i<N;i++)while(postLets[i].size())postLets[i].pop();\n        for(int i=0;i<N;i++)for(int j=0;j<N;j++){\n            if(i==j)d[i][j]=0;\n            else d[i][j]=INF;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            edge e;\n            cin>>a>>b>>e.cost;\n            a--;b--;\n            e.to=b;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[a][b]=d[b][a]=e.cost;\n        }\n        cin>>L;\n        priority_queue<Event> pq;\n        warshall_floyd(N);\n        calcNxtPlace(N);\n        for(int i=0;i<L;i++){\n            Letter lt;\n            cin>>lt.start>>lt.goal>>lt.arriveTime;\n            lt.start--;lt.goal--;\n            cin>>letterNames[i];\n            lt.id=i;\n            lt.nxtTo=(nxt[lt.start][lt.goal]);\n            // èÇÁCxg\n            Event ev;\n            ev.prvNode=lt.start;\n            ev.node=lt.start;\n            ev.kind=1;\n            ev.time=lt.arriveTime;\n            ev.lts.push_back(lt);\n            pq.push(ev);\n        }\n        vector<pair<int,string> > res;\n        // CxgðÔÉ\n        while(pq.size()){\n            Event e=pq.top();pq.pop();\n            // \n            if(e.kind==0){\n                // èðXÖÇÉÇÁ\n                for(int i=0;i<e.lts.size();i++){\n                    // goal\n                    if(e.lts[i].goal==e.node)\n                        res.push_back(make_pair(e.time,letterNames[e.lts[i].id]));\n                    else{\n                        //  ÄæðÌêÉÏXµÄ¨­\n                        e.lts[i].nxtTo=nxt[e.node][e.lts[i].goal];\n                        e.lts[i].arriveTime=e.time;\n                        postLets[e.node].push(e.lts[i]);\n                        postByNxtTo[e.node][e.lts[i].nxtTo].push_back(e.lts[i]);\n                    }\n                }\n                // AÒCxgðÇÁ\n                Event ev;\n                ev.node=e.prvNode;\n                ev.kind=2;\n                ev.prvNode=e.node;\n                // ÌCxgÔðo^\n                ev.time=e.time+d[e.node][e.prvNode];\n                pq.push(ev);\n            }\n            // ÇÁ\n            else if(e.kind==1){\n                // èðXÖÇÉÇÁ\n                postLets[e.node].push(e.lts[0]);\n                // èðXÖÇÉ Äæ²ÆÉª¯ÄÇÁ\n                postByNxtTo[e.node][e.lts[0].nxtTo].push_back(e.lts[0]);\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // AÒ\n            else if(e.kind==2){\n                isExist[e.node]=true;\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // o­\n            else if(e.kind==3){\n                //if(!isExist[e.node])continue;\n                //isExist[e.node]=false;\n                // ¡ éèÌÅAàÁÆàÔªÍâ¢àÌðé\n                // ½¾µAÌ Ä³«ª¨È¶àÌÍAÜÆßÄé\n                // ¡±ÌêÉèª¶ÝµÈ¢\n                if(postLets[e.node].empty()){\n                    // wõð¯ßé\n                    isExist[e.node]=true;\n                    continue;\n                }\n                Letter lt=postLets[e.node].top();postLets[e.node].pop();\n                // ·ÅÉçêÄ¢é\n                if(isArrivalLet[e.node][lt.id])continue;\n                Event ev;\n                // éèðZbg\n                ev.lts=postByNxtTo[e.node][lt.nxtTo];\n                // Á½ÌÅgðNA\n                for(int i=0;i<ev.lts.size();i++)isArrivalLet[e.node][ev.lts[i].id]=true;\n                postByNxtTo[e.node][lt.nxtTo].clear();\n                ev.kind=0;\n                ev.node=lt.nxtTo;\n                ev.prvNode=e.node;\n                ev.time=e.time+d[e.node][lt.nxtTo];\n                pq.push(ev);\n            }\n        }\n        sort(res.begin(),res.end());\n        for(int i=0;i<res.size();i++)cout<<res[i].second<<\" \"<<res[i].first<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1000000007)\n\ntypedef pair<int,int> Pii;\ntypedef pair<int,string> Pis;\ntypedef pair< Pii , Pis > PP;\n\nint N,M,K;\nint G[32][32];\nint g[32][32];\n\nset< PP > u[32][32];\n\nint mem[32][32];\n\nint search(int from,int to){\n  if(mem[from][to]!=-1)return mem[from][to];\n  int mini=INF, res=-1;\n  for(int i=0;i<N;i++){\n    if(from==i || g[from][i]==INF)continue;\n    if(mini>g[from][i]+G[i][to]){\n      mini=g[from][i]+G[i][to];\n      res=i;\n    }\n  }\n  assert(res!=-1);\n  return mem[from][to]=res;\n}\n\nvoid init(){\n  for(int i=0;i<32;i++){\n    for(int j=0;j<32;j++){\n      g[i][j]=(i==j?0:INF);\n      G[i][j]=(i==j?0:INF);\n      mem[i][j]=-1;\n      u[i][j].clear();\n    }\n  }\n}\n\nint main(){\n  int cnt=0;\n  while(1){\n\n    init();\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    if(cnt)cout<<endl;\n    cnt++;\n    \n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      G[a][b]=G[b][a]=c;\n    }\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n    \n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    cin>>K;\n\n    map<int, vector<PP> > mp;\n    set<int> st;\n    \n    for(int i=0;i<K;i++){\n      int from,to,ti;\n      string name;\n      cin>>from>>to>>ti>>name;\n      from--,to--;\n      mp[ti].push_back( PP( Pii(from,to) , Pis(0,name)) );\n      st.insert(ti);\n    }\n\n    vector< Pis > ans;\n    vector<int> v(N,0);\n    int last=-1;\n    \n    st.insert(0);\n    while(!st.empty()){\n\n      int p=*st.begin();\n      assert( last < p ); last=p;\n      \n      if(mp.count(p)){\n        for(int i=0;i<(int)mp[p].size();i++){\n          PP pp=mp[p][i];\n          int from=pp.first.first;\n          int to=pp.first.second;\n          string name=pp.second.second;\n          int key=search(from,to);\n          PP tmp=PP( Pii(p, key ) , Pis(to,name) );\n          u[from][key].insert(tmp);\n        }\n        mp[p].clear();\n      }\n      \n      for(int i=0;i<N;i++){\n        if(v[i]>p)continue;\n        PP target=PP( Pii(INF,0) , Pis(0,\"\") );\n        for(int j=0;j<N;j++){\n          if(u[i][j].empty())continue;\n          PP pp=*u[i][j].begin();\n          target=min(target,pp);\n        }\n        if(target.first.first==INF)continue;\n\n        int nex=target.first.second;\n        int to2=target.second.first;\n        \n        set< PP > :: iterator it;\n        for( it=u[i][nex].begin(); it!= u[i][nex].end() ;  ){\n          PP pp=*it;\n          int to=pp.second.first;\n          string name=pp.second.second;\n\n          if(to!=to2){\n            it++;\n          }else if(to==nex){\n            ans.push_back( Pis( p+g[i][nex] , name ) );\n            it=u[i][nex].erase(it);\n          }else{\n            mp[ p+g[i][nex] ].push_back( PP(Pii(nex,to),Pis(0,name)) );\n            it=u[i][nex].erase(it);\n          }\n          \n\n        }// iterator\n        \n        u[i][nex].clear();\n        v[i]=p+g[i][nex]*2;\n        st.insert(v[i]);\n      }// i\n      \n      st.erase(p);\n    }// while ( st.empty() )\n    \n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      Pis p=ans[i];\n      cout<<p.second<<' '<<p.first<<endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tvector<int> to,c;\n};\n\nclass Trl\n{\npublic:\n\tint p,c,pv;\n\tTrl(int p, int c, int pv)\n\t:p(p),c(c),pv(pv)\n\t{}\n\t\n\tbool operator<(const Trl& t) const\n\t{\n\t\tif(c!=t.c) return c>t.c;\n\t\treturn p>t.p;\n\t}\n};\n\nint nt[32][32],ld[32][32];\nNode node[32];\n\nvoid Dijkstra(int src, int dst)\n{\n\tpriority_queue<Trl> q;\n\tq.push(Trl(src,0,src));\n\t\n\tint v[32];\n\tfor(int i=0; i<32; i++) v[i]=-1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tTrl t=q.top(); q.pop();\n\t\tif(v[t.p]!=-1) continue;\n\t\tv[t.p]=t.pv;\n\t\t\n\t\tif(t.p==dst)\n\t\t{\n\t\t\tfor(int i=dst; v[i]!=i; i=v[i])\n\t\t\t\tnt[v[i]][dst]=i;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<node[t.p].to.size(); i++)\n\t\t{\n\t\t\tint next=node[t.p].to[i];\n\t\t\tif(v[next]!=-1) continue;\n\t\t\t\n\t\t\tq.push(Trl(next, t.c+node[t.p].c[i], t.p));\n\t\t}\n\t}\n}\n\nenum EV{BACK, GO};\n\nclass Event\n{\npublic:\n\tEV ev;\n\tint p, dst,t;\n\tstring n;\n\t\n\tEvent(int p, int dst, int t,EV ev, string n)\n\t:p(p),dst(dst),t(t),ev(ev),n(n)\n\t{}\n\t\n\tbool operator<(const Event& e) const\n\t{\n\t\t\n\t\tif(t!=e.t) return t>e.t;\n\t\tif(ev!=e.ev) return ev>e.ev;\n\t\tif(p==dst&&e.p==e.dst) return n>e.n;\n\t\tif(dst!=e.dst) dst>e.dst;\n\t\treturn p>e.p;\n\t}\n};\n\nvoid Sim()\n{\n\tint K;\n\tscanf(\"%d\", &K);\n\tpriority_queue<Event> q;\n\twhile(K--)\n\t{\n\t\tint s,d,t;\n\t\tchar n[51];\n\t\tscanf(\"%d%d%d%s\",&s,&d,&t,n);\n\t\ts--; d--;\n\t\tq.push(Event(s,d,t,GO,string(n)));\n\t}\n\t\n\tint tc=-1, tdst=-1, tp=-1;\n\tint lv[32]={0};\n\twhile(!q.empty())\n\t{\n\t\tEvent e=q.top(); q.pop();\n\t\tif(e.ev==BACK)\n\t\t{\n\t\t\tlv[e.dst]=0;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(e.dst==e.p)\n\t\t{\n\t\t\tprintf(\"%s %d\\n\", e.n.c_str(), e.t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(tc==e.t&&tdst==nt[e.p][e.dst]&&tp==e.p)\n\t\t\t{\n\t\t\t\tint next=nt[e.p][e.dst], cst=e.t+ld[e.p][next];\n\t\t\t\tq.push(Event(next, e.dst, cst, e.ev, e.n));\n\t\t\t}\n\t\t\telse if(lv[e.p]!=0)\n\t\t\t{\n\t\t\t\tq.push(Event(e.p, e.dst, lv[e.p], e.ev, e.n));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint next=nt[e.p][e.dst], cst=e.t+ld[e.p][next];\n\t\t\t\tlv[e.p]=cst+ld[e.p][next];\n\t\t\t\tq.push(Event(next, e.dst, cst, e.ev, e.n));\n\t\t\t\tq.push(Event(e.p, e.p, lv[e.p], BACK, \"\"));\n\t\t\t\t\n\t\t\t\ttc=e.t; tdst=e.dst; tp=e.p;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint N,M;\n\tbool fr=true;\n\twhile(scanf(\"%d%d\", &N, &M), (N||M))\n\t{\n\t\tfor(int i=0; i<32; i++)\n\t\t{\n\t\t\tnode[i].to.clear();\n\t\t\tnode[i].c.clear();\n\t\t}\n\t\twhile(M--)\n\t\t{\n\t\t\tint s,d,c;\n\t\t\tscanf(\"%d%d%d\", &s,&d,&c);\n\t\t\ts--; d--;\n\t\t\t\n\t\t\tnode[s].to.push_back(d);\n\t\t\tnode[d].to.push_back(s);\n\t\t\tnode[s].c.push_back(c);\n\t\t\tnode[d].c.push_back(c);\n\t\t\tld[s][d]=c;\n\t\t\tld[d][s]=c;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\tDijkstra(i,j);\n\t\t\t\n\t\tif(!fr) puts(\"\");\n\t\tfr=false;\n\t\t\n\t\tSim();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstring>\n\nusing namespace std;\nconst int INF=1000000000;\n\nstruct edge{\n    int to;\n    int cost;\n};\n\nstruct Letter{\n    int nxtTo;\n    int goal;\n    int start;\n    int id;\n    int arriveTime;\n    bool operator<(const Letter &lt)const{\n        if(arriveTime>lt.arriveTime)return true;\n        else if(arriveTime<lt.arriveTime)return false;\n        return nxtTo>lt.nxtTo;\n    }\n};\n\nstruct Event{\n    // 0:,1:úÔ,2:èÌÇÁ\n    int kind;\n    int time;\n    int node;\n    int prvNode;\n    vector<Letter> lts;\n    bool operator<(const Event &e)const{\n        if(time>e.time)return true;\n        else if(time<e.time)return false;\n        return kind>e.kind;\n    }\n};\n\nint d[33][33];\n// cur,to\nint nxt[33][33];\nstring letterNames[1001];\nvector<edge>G[101];\nint N,M,L;\n// Çõª¶Ý·é©Ç¤©\nbool isExist[1001];\n// eXÖÇÉÂ¢ÄA»ê¼êÌèª·ÅÉçê½©\nbool isArrivalLet[1001][1001];\n// eXÖÇ²ÆÉAèðÔÉÇ\npriority_queue<Letter> postLets[1001];\n// eXÖÇ²ÆÉAèð Äæ²ÆÉÇ\nvector<Letter> postByNxtTo[101][101];\n\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\nvoid calcNxtPlace(int V){\n    for(int i=0;i<33;i++)for(int j=0;j<33;j++)nxt[i][j]=INF;\n    for(int i=0;i<V;i++){\n        for(int j=0;j<V;j++){\n            if(i!=j){\n                int nxtNum=INF;\n                for(int k=0;k<G[i].size();k++){\n                    edge &e=G[i][k];\n                    if(d[i][e.to]+d[e.to][j]==d[i][j])nxtNum=min(nxtNum,e.to);\n                }\n                nxt[i][j]=nxtNum;\n            }\n        }\n    }\n}\nint main(){\n    bool fst=true;\n    while(cin>>N>>M&&(N|M)){\n        if(fst)fst=false;\n        else cout<<endl;\n        memset(isArrivalLet,0,sizeof(isArrivalLet));\n        for(int i=0;i<N;i++)G[i].clear();\n        for(int i=0;i<1001;i++)isExist[i]=true;\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)postByNxtTo[i][j].clear();\n        for(int i=0;i<N;i++)while(postLets[i].size())postLets[i].pop();\n        for(int i=0;i<N;i++)for(int j=0;j<N;j++){\n            if(i==j)d[i][j]=0;\n            else d[i][j]=INF;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            edge e;\n            cin>>a>>b>>e.cost;\n            a--;b--;\n            e.to=b;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[a][b]=d[b][a]=e.cost;\n        }\n        warshall_floyd(N);\n        calcNxtPlace(N);\n        cin>>L;\n        priority_queue<Event> pq;\n        for(int i=0;i<L;i++){\n            Letter lt;\n            cin>>lt.start>>lt.goal>>lt.arriveTime;\n            lt.start--;lt.goal--;\n            cin>>letterNames[i];\n            lt.id=i;\n            lt.nxtTo=(nxt[lt.start][lt.goal]);\n            // èÇÁCxg\n            Event ev;\n            ev.prvNode=lt.start;\n            ev.node=lt.start;\n            ev.kind=1;\n            ev.time=lt.arriveTime;\n            ev.lts.push_back(lt);\n            pq.push(ev);\n        }\n        vector<pair<int,string> > res;\n        // CxgðÔÉ\n        while(pq.size()){\n            Event e=pq.top();pq.pop();\n            // \n            if(e.kind==0){\n                // èðXÖÇÉÇÁ\n                for(int i=0;i<e.lts.size();i++){\n                    // goal\n                    if(e.lts[i].goal==e.node)\n                        res.push_back(make_pair(e.time,letterNames[e.lts[i].id]));\n                    else{\n                        //  ÄæðÌêÉÏXµÄ¨­\n                        e.lts[i].nxtTo=nxt[e.node][e.lts[i].goal];\n                        e.lts[i].arriveTime=e.time;\n                        postLets[e.node].push(e.lts[i]);\n                        postByNxtTo[e.node][e.lts[i].nxtTo].push_back(e.lts[i]);\n                    }\n                }\n                // AÒCxgðÇÁ\n                {\n                    Event ev;\n                    ev.node=e.prvNode;\n                    ev.kind=2;\n                    ev.prvNode=e.node;\n                    // ÌCxgÔðo^\n                    ev.time=e.time+d[e.node][e.prvNode];\n                    pq.push(ev);\n                }\n                // Ì]æÖéCxgðÇÁ\n                {\n                    // wõª¢éÈçÎAo­CxgðÇÁ\n                    if(isExist[e.node]){\n                        isExist[e.node]=false;\n                        Event ev;\n                        ev.kind=3;\n                        ev.time=e.time;\n                        ev.node=e.node;\n                        pq.push(ev);\n                    }\n                }\n            }\n            // ÇÁ\n            else if(e.kind==1){\n                // èðXÖÇÉÇÁ\n                postLets[e.node].push(e.lts[0]);\n                // èðXÖÇÉ Äæ²ÆÉª¯ÄÇÁ\n                postByNxtTo[e.node][e.lts[0].nxtTo].push_back(e.lts[0]);\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // AÒ\n            else if(e.kind==2){\n                isExist[e.node]=true;\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // o­\n            else if(e.kind==3){\n                // ¡ éèÌÅAàÁÆàÔªÍâ¢àÌðé\n                // ½¾µAÌ Ä³«ª¨È¶àÌÍAÜÆßÄé\n                // ¡±ÌêÉèª¶ÝµÈ¢\n                Letter lt;\n                bool ok=true;\n                while(1){\n                    if(postLets[e.node].empty()){\n                        ok=false;\n                        break;\n                    }\n                    lt=postLets[e.node].top();postLets[e.node].pop();\n                    // ·ÅÉçêÄ¢é\n                    if(isArrivalLet[e.node][lt.id])continue;\n                    else break;\n                }\n                if(!ok){\n                    isExist[e.node]=true;\n                    continue;\n                }\n                Event ev;\n                // éèðZbg\n                ev.lts=postByNxtTo[e.node][lt.nxtTo];\n                // Á½ÌÅgðNA\n                for(int i=0;i<ev.lts.size();i++)isArrivalLet[e.node][ev.lts[i].id]=true;\n                postByNxtTo[e.node][lt.nxtTo].clear();\n                ev.kind=0;\n                ev.node=lt.nxtTo;\n                ev.prvNode=e.node;\n                ev.time=e.time+d[e.node][lt.nxtTo];\n                pq.push(ev);\n            }\n        }\n        sort(res.begin(),res.end());\n        for(int i=0;i<res.size();i++)cout<<res[i].second<<\" \"<<res[i].first<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n,m,co=0;\n\twhile(cin>>n>>m,n){\n\t\tif(co++)cout<<endl;\n\t\tvvi cost(n,vi(n,inf));\n\t\trep(i,n)cost[i][i]=0;\n\t\tvvi G(n);\n\t\trep(i,m){\n\t\t\tint a,b,c;cin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t\tG[a].pb(b);\n\t\t\tG[b].pb(a);\n\t\t}\n\t\trep(i,n)sort(all(G[i]));\n\t\trep(k,n)rep(i,n)rep(j,n)\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n\t\tvvi go(n,vi(n,inf));\n\t\trep(i,n)rep(j,n)if(i!=j)rep(k,G[i].size())if(cost[i][j]==cost[i][G[i][k]]+cost[G[i][k]][j]){\n\t\t\tgo[i][j]=G[i][k];break;\n\t\t}\n\n\t\tint q;\n\t\tcin>>q;\n\t\tvi hu(n),ob(q);\n\t\tvp in(q);\n\t\tvs name(q);\n\t\trep(i,q)cin>>in[i].first>>in[i].second>>ob[i]>>name[i];\n\t\trep(i,q)in[i].first--,in[i].second--;\n\t\twhile(1){\n\t\t\tint mi=inf,mii=-1;\n\t\t\trep(i,q)if(in[i].first!=in[i].second){\n\t\t\t\tif(mi>ob[i])mi=ob[i],mii=i;\n\t\t\t\tif(mi==ob[i]&&go[in[mii].first][in[mii].second]>go[in[i].first][in[i].second])mii=i;\n\t\t\t}\n\t\t\tif(mii==-1)break;\n\t\t\tint from=in[mii].first,to=go[in[mii].first][in[mii].second];\n\t\t\trep(i,q)if(ob[i]==mi&&in[i].first==from&&go[in[i].first][in[i].second]==to){\n\t\t\t\thu[from]=mi+2*cost[from][to];\n\t\t\t\tob[i]=mi+cost[from][to];\n\t\t\t\tin[i].first=to;\n\t\t\t}\n\t\t\trep(i,q)if(in[i].first!=in[i].second&&hu[in[i].first]>ob[i])ob[i]=hu[in[i].first];\n\t\t}\n\t\tvector<pair<int,string> >out(q);\n\t\trep(i,q)out[i]={ob[i],name[i]};\n\t\tsort(all(out));\n\t\trep(i,q)cout<<out[i].second<<\" \"<<out[i].first<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1000000007)\n\ntypedef pair<int,int> Pii;\ntypedef pair<int,string> Pis;\ntypedef pair< Pii , Pis > PP;\n\nint N,M,K;\nint G[32][32];\nint g[32][32];\n\nset< PP > u[32][32];\n\nint mem[32][32];\n\nint search(int from,int to){\n  if(mem[from][to]!=-1)return mem[from][to];\n  int mini=INF, res=-1;\n  for(int i=0;i<N;i++){\n    if(from==i || g[from][i]==INF)continue;\n    if(mini>g[from][i]+G[i][to]){\n      mini=g[from][i]+G[i][to];\n      res=i;\n    }\n  }\n  assert(res!=-1);\n  return mem[from][to]=res;\n}\n\nvoid init(){\n  for(int i=0;i<32;i++){\n    for(int j=0;j<32;j++){\n      g[i][j]=(i==j?0:INF);\n      G[i][j]=(i==j?0:INF);\n      mem[i][j]=-1;\n      u[i][j].clear();\n    }\n  }\n}\n\nint main(){\n  int cnt=0;\n  while(1){\n\n    init();\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    if(cnt)cout<<endl;\n    cnt++;\n    \n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      G[a][b]=G[b][a]=c;\n    }\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n    \n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    cin>>K;\n\n    map<int, vector<PP> > mp;\n    set<int> st;\n    \n    for(int i=0;i<K;i++){\n      int from,to,ti;\n      string name;\n      cin>>from>>to>>ti>>name;\n      from--,to--;\n      mp[ti].push_back( PP( Pii(from,to) , Pis(0,name)) );\n      st.insert(ti);\n    }\n\n    vector< Pis > ans;\n    vector<int> v(N,0);\n    int last=-1;\n    \n    st.insert(0);\n    while(!st.empty()){\n\n      int p=*st.begin();\n      assert( last < p ); last=p;\n      \n      if(mp.count(p)){\n        for(int i=0;i<(int)mp[p].size();i++){\n          PP pp=mp[p][i];\n          int from=pp.first.first;\n          int to=pp.first.second;\n          string name=pp.second.second;\n          int key=search(from,to);\n          PP tmp=PP( Pii(p, key ) , Pis(to,name) );\n          u[from][key].insert(tmp);\n        }\n        //       mp[p].clear();\n      }\n      \n      for(int i=0;i<N;i++){\n        if(v[i]>p)continue;\n        \n        PP target=PP( Pii(INF,0) , Pis(0,\"\") );\n        \n        for(int j=0;j<N;j++){\n          if(u[i][j].empty())continue;\n          PP pp=*u[i][j].begin();\n          target=min(target,pp);\n        }\n        if(target.first.first==INF)continue;\n\n        int nex=target.first.second;\n        \n        set< PP > :: iterator it;\n        for( it=u[i][nex].begin(); it!= u[i][nex].end() ; it++ ){\n          PP pp=*it;\n          int to=pp.second.first;\n          string name=pp.second.second;\n\n          if(to==nex){\n            ans.push_back( Pis( p+g[i][nex] , name ) );\n          }else{\n            mp[ p+g[i][nex] ].push_back( PP(Pii(nex,to),Pis(0,name)) );\n          }\n        }// iterator\n        \n        u[i][nex].clear();\n        v[i]=p+g[i][nex]*2;\n        st.insert(v[i]);\n      }// i\n      \n      st.erase(p);\n    }// while ( st.empty() )\n    \n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      Pis p=ans[i];\n      cout<<p.second<<' '<<p.first<<endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nstruct edge{\n    int to;\n    int cost;\n};\nint d[33][33];\n// cur,to\nint nxt[33][33];\nstring letterNames[1001];\n\nconst int INF=1000000000;\nvector<edge>G[101];\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\nvoid calcNxtPlace(int V){\n    for(int i=0;i<33;i++)for(int j=0;j<33;j++)nxt[i][j]=INF;\n    for(int i=0;i<V;i++){\n        for(int j=0;j<V;j++){\n            if(i!=j){\n                int nxtNum=INF;\n                for(int k=0;k<G[i].size();k++){\n                    edge &e=G[i][k];\n                    if(d[i][e.to]+d[e.to][j]==d[i][j])nxtNum=min(nxtNum,e.to);\n                }\n                nxt[i][j]=nxtNum;\n            }\n        }\n    }\n}\n\nstruct Letter{\n    int nxtTo;\n    int goal;\n    int start;\n    int id;\n    int arriveTime;\n    bool operator<(const Letter &lt)const{\n        return arriveTime>lt.arriveTime;\n    }\n};\n\nstruct Event{\n    // 0:,1:úÔ,2:èÌÇÁ\n    int kind;\n    int time;\n    int node;\n    int prvNode;\n    vector<Letter> lts;\n    bool operator<(const Event &e)const{\n        if(time>e.time)true;\n        else if(time<e.time)false;\n        return kind>e.kind;\n    }\n};\n\nint N,M,L;\n// Çõª¶Ý·é©Ç¤©\nbool isExist[1001];\n// eXÖÇÉÂ¢ÄA»ê¼êÌèª·ÅÉçê½©\nbool isArrivalLet[1001][1001];\n// eXÖÇ²ÆÉAèðÔÉÇ\npriority_queue<Letter> postLets[1001];\n// eXÖÇ²ÆÉAèð Äæ²ÆÉÇ\nvector<Letter> postByNxtTo[101][101];\n\nint main(){\n    bool fst=true;\n    while(cin>>N>>M&&(N|M)){\n        if(fst)fst=false;\n        else cout<<endl;\n        for(int i=0;i<N;i++)G[i].clear();\n        for(int i=0;i<1001;i++)isExist[i]=true;\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)postByNxtTo[i][j].clear();\n        memset(isArrivalLet,0,sizeof(isArrivalLet));\n        //vector<Letter> lts;\n        for(int i=0;i<N;i++)while(postLets[i].size())postLets[i].pop();\n        for(int i=0;i<N;i++)for(int j=0;j<N;j++){\n            if(i==j)d[i][j]=0;\n            else d[i][j]=INF;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            edge e;\n            cin>>a>>b>>e.cost;\n            a--;b--;\n            e.to=b;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[a][b]=d[b][a]=e.cost;\n        }\n        cin>>L;\n        priority_queue<Event> pq;\n        warshall_floyd(N);\n        calcNxtPlace(N);\n        for(int i=0;i<L;i++){\n            Letter lt;\n            cin>>lt.start>>lt.goal>>lt.arriveTime;\n            lt.start--;lt.goal--;\n            cin>>letterNames[i];\n            lt.id=i;\n            lt.nxtTo=(nxt[lt.start][lt.goal]);\n            // èÇÁCxg\n            Event ev;\n            ev.prvNode=lt.start;\n            ev.node=lt.start;\n            ev.kind=1;\n            ev.time=lt.arriveTime;\n            ev.lts.push_back(lt);\n            pq.push(ev);\n        }\n        vector<pair<int,string> > res;\n        // CxgðÔÉ\n        while(pq.size()){\n            Event e=pq.top();pq.pop();\n            // \n            if(e.kind==0){\n                // èðXÖÇÉÇÁ\n                for(int i=0;i<e.lts.size();i++){\n                    // goal\n                    if(e.lts[i].goal==e.node)\n                        res.push_back(make_pair(e.time,letterNames[e.lts[i].id]));\n                    else{\n                        //  ÄæðÌêÉÏXµÄ¨­\n                        e.lts[i].nxtTo=nxt[e.node][e.lts[i].goal];\n                        e.lts[i].arriveTime=e.time;\n                        postLets[e.node].push(e.lts[i]);\n                        postByNxtTo[e.node][e.lts[i].nxtTo].push_back(e.lts[i]);\n                    }\n                }\n                // AÒCxgðÇÁ\n                Event ev;\n                ev.node=e.prvNode;\n                ev.kind=2;\n                ev.prvNode=e.node;\n                // ÌCxgÔðo^\n                ev.time=e.time+d[e.node][e.prvNode];\n                pq.push(ev);\n            }\n            // ÇÁ\n            else if(e.kind==1){\n                // èðXÖÇÉÇÁ\n                postLets[e.node].push(e.lts[0]);\n                // èðXÖÇÉ Äæ²ÆÉª¯ÄÇÁ\n                postByNxtTo[e.node][e.lts[0].nxtTo].push_back(e.lts[0]);\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // AÒ\n            else if(e.kind==2){\n                isExist[e.node]=true;\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // o­\n            else if(e.kind==3){\n                // ¡ éèÌÅAàÁÆàÔªÍâ¢àÌðé\n                // ½¾µAÌ Ä³«ª¨È¶àÌÍAÜÆßÄé\n                // ¡±ÌêÉèª¶ÝµÈ¢\n                if(postLets[e.node].empty()){\n                    // wõð¯ßé\n                    isExist[e.node]=true;\n                    continue;\n                }\n                Letter lt=postLets[e.node].top();postLets[e.node].pop();\n                // ·ÅÉçêÄ¢é\n                if(isArrivalLet[e.node][lt.id])continue;\n                Event ev;\n                // éèðZbg\n                ev.lts=postByNxtTo[e.node][lt.nxtTo];\n                // Á½ÌÅgðNA\n                for(int i=0;i<ev.lts.size();i++)isArrivalLet[e.node][ev.lts[i].id]=true;\n                postByNxtTo[e.node][lt.nxtTo].clear();\n                ev.kind=0;\n                ev.node=lt.nxtTo;\n                ev.prvNode=e.node;\n                ev.time=e.time+d[e.node][lt.nxtTo];\n                pq.push(ev);\n            }\n        }\n        sort(res.begin(),res.end());\n        for(int i=0;i<res.size();i++)cout<<res[i].second<<\" \"<<res[i].first<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n\nstruct Edge{\n\tint a,b,c;\n\tEdge(int a,int b,int c) : a(a),b(b),c(c){}\n};\n\nvector<Edge> v[32];\nint next[1000][32];\nstring name[1000];\n\n\nstruct Info{\n\tint id;\n\tint pos;\n\tint time;\n\tint otodoke;\n\tInfo(){}\n\tInfo(int id,int pos,int time,int otodoke) : id(id),pos(pos),time(time),otodoke(otodoke){}\n};\n\nbool operator < (const Info &a,const Info &b){\n\tif( a.time != b.time ) return a.time > b.time ;\n\tif( a.pos != b.pos ) return a.pos > b.pos;\n\tif( a.otodoke != b.otodoke ) return a.otodoke > b.otodoke;\n\treturn next[a.id][a.pos] > next[b.id][b.pos];\n}\n\n\nint main(){\n\tint blflg=0;\n\tint n,m;\n\twhile(cin >> n >> m && n){\n\t\tfor(int i = 0 ; i < 32 ; i++)\n\t\t\tv[i].clear();\n\t\tif(blflg++)cout << endl;\n\t\tlong long wf[100][100];\n\t\tfor(int i = 0 ; i < 100 ; i++){\n\t\t\tfor(int j = 0 ; j < 100 ; j++){\n\t\t\t\twf[i][j] = i==j?0:1e10;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpriority_queue<Info> Q;\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--,b--;\n\t\t\twf[a][b] = c;\n\t\t\twf[b][a] = c;\n\t\t\tv[a].push_back(Edge(a,b,c));\n\t\t\tv[b].push_back(Edge(b,a,c));\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tfor(int k = 0 ; k < n ; k++){\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l;\n\t\tcin >> l;\n\t\tfor(int i = 0 ; i < l ; i++){\n\t\t\tint a,b,t;\n\t\t\tcin >> a >> b >> t >> name[i];\n\t\t\ta--,b--;\n\t\t\tint cur = a;\n\t\t\twhile( cur != b ){\n\t\t\t\tnext[i][cur] = 1e9;\n\t\t\t\tfor(int j = 0 ; j < v[cur].size() ; j++){\n\t\t\t\t\tif( wf[cur][b] == wf[v[cur][j].b][b]+v[cur][j].c ){\n\t\t\t\t\t\tnext[i][cur] = min(next[i][cur],v[cur][j].b);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = next[i][cur];\n\t\t\t}\n\t\t\tnext[i][cur] = -1;\n\t\t\tQ.push(Info(i,a,t,t));\n\t\t}\n\t\tvector< pair<int,string> > sorted;\n\t\t\n\t\tint waiting[32]={};\n\t\t\n\t\tint prev = 0;\n\t\twhile(Q.size()){\n\t\t\tInfo q = Q.top();\n\t\t\t\n\t\t\t//cout << \"[\" << q.time << \"]\" << name[q.id] << \" \" << q.pos  << \" \" << q.otodoke << endl;\n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\twaiting[i] = max(waiting[i]-(q.time-prev),0);\n\t\t\t}\n\t\t\tprev = q.time;\n\t\t\tvector<Info> chk;\n\t\t\tvector<Info> dummy;\n\t\t\twhile(Q.size() && Q.top().time == q.time && Q.top().pos == q.pos ){\n\t\t\t\tif( next[Q.top().id][Q.top().pos] == next[q.id][q.pos] ){\n\t\t\t\t\tchk.push_back(Q.top());\n\t\t\t\t}else{\n\t\t\t\t\tdummy.push_back(Q.top());\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < dummy.size() ; i++)\n\t\t\t\tQ.push(dummy[i]);\n\t\t\t\n\t\t\tif( next[q.id][q.pos] == -1 ){\n\t\t\t\tfor(int i = 0 ; i < chk.size() ; i++){\n\t\t\t\t\tsorted.push_back(make_pair(chk[i].otodoke,name[chk[i].id]));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( waiting[q.pos] ){\n\t\t\t\tfor(int i = 0 ; i < chk.size() ; i++){\n\t\t\t\t\tQ.push(Info(chk[i].id,chk[i].pos,chk[i].time+waiting[q.pos],chk[i].otodoke));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < chk.size() ; i++){\n\t\t\t\t//cout << chk[i].pos << \" \" << next[chk[i].id][chk[i].pos] << \" < \" << endl;\n\t\t\t\tint cst = wf[chk[i].pos][next[chk[i].id][chk[i].pos]];\n\t\t\t\tQ.push(Info(chk[i].id,next[chk[i].id][chk[i].pos],chk[i].time+cst,chk[i].time+cst));\n\t\t\t\twaiting[q.pos] = 2*cst;\n\t\t\t}\n\t\t}\n\t\tsort(sorted.begin(),sorted.end());\n\t\tfor(int i = 0 ; i < sorted.size() ; i++)\n\t\t\tcout << sorted[i].second << \" \" << sorted[i].first << endl;\n\t}\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cost;\n  Edge() {}\n  Edge(int s, int d, int c) : src(s), dst(d), cost(c) {}\n};\n\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nstruct Event{\n  int type;\n  int time;\n  int latter;\n  int office;\n  Event(int ty, int t, int l, int o) : \n    type(ty), time(t), latter(l), office(o) {}\n  bool operator < (const Event& e) const {\n    if(time != e.time) return time < e.time;\n    if(type != e.type) return type < e.type;\n    return office < e.office;\n  }\n  bool operator > (const Event& e) const {\n    return e < *this;\n  }\n};\nstruct Latter{\n  string name;\n  int src, dst;\n};\ntypedef pair<int, string> P;\nvoid print(Event& e){\n  //printf(\"type %d time %d latter %d office %d\\n\", e.type, e.time, e.latter, e.office);\n}\n\nvoid do_send(Event& e, deque<Event>& lq, priority_queue<Event, vector<Event>, greater<Event> >& que, int dist[36][36], vector<bool>& wait){\n  /*\n  printf(\"do_send : lq is\\n\");\n  REP(i, lq.size()) print(lq[i]);\n  cout << endl;\n  */\n  Event se = lq.front(); lq.pop_front();\n  que.push(Event(0, e.time + dist[e.office][se.office], se.latter, se.office));\n  //printf(\"send : \"); print(se);\n  for(deque<Event>::iterator it = lq.begin(); it != lq.end(); ){\n    if(it->office == se.office){\n      que.push(Event(0, se.time + dist[e.office][se.office], it->latter, se.office));\n      //printf(\"send2 : \"); print(*it);\n      it = lq.erase(it);\n    }else{\n      it++;\n    }\n  }\n  que.push(Event(1, se.time + 2 * dist[e.office][se.office], -1, e.office));\n  wait[e.office] = false;\n}\nint main(){\n  int N, M;\n  bool first = true;\n  while(cin >> N >> M && N){\n\n    if(first) first = false;\n    else cout << endl;\n\n    Graph G(N);\n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      G[a].push_back(Edge(a, b, c));\n      G[b].push_back(Edge(b, a, c));\n    }\n    int dist[36][36] = {};\n    REP(i, N) REP(j, N) dist[i][j] = (i != j) ? INF : 0;\n    REP(i, N) FORIT(e, G[i]) dist[e->src][e->dst] = e->cost;\n    REP(k, N) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    // next[i][j] := 現在地i, 目的地jの郵便物の次の行き先\n    int next[36][36] = {};\n    memset(next, -1, sizeof(next));\n    REP(i, N) REP(j, N) if(i != j && !G[i].empty()){\n      next[i][j] = G[i][0].dst;\n      int n_cost = G[i][0].cost + dist[G[i][0].dst][j];\n      int edge_cost = G[i][0].cost;\n      FORIT(e, G[i]){\n        if(make_pair(n_cost, next[i][j]) > make_pair(e->cost + dist[e->dst][j], e->dst)){\n          n_cost = e->cost + dist[e->dst][j];\n          next[i][j] = e->dst;\n          edge_cost = e->cost;\n        }\n      }\n      assert(edge_cost == dist[i][next[i][j]]);\n    }\n    //REP(i, N) REP(j, N) printf(\"next[%d][%d] = %d\\n\", i, j, next[i][j]);\n\n    int L; cin >> L;\n    vector<Latter> latters(L);\n    priority_queue<Event, vector<Event>, greater<Event> > que;\n    vector< deque<Event> > l_que(N);\n    REP(i, L){\n      int time;\n      cin >> latters[i].src >> latters[i].dst >> time >> latters[i].name;\n      latters[i].src--; latters[i].dst--;\n      que.push(Event(0, time, i, latters[i].src));\n    }\n    vector<P> answer;\n    vector<bool> wait(N, true);\n    while(!que.empty()){\n      Event e = que.top(); que.pop();\n      print(e);\n      deque<Event>& lq = l_que[e.office];\n      if(e.type == 0){\n        Latter& l = latters[e.latter];\n        if(l.dst == e.office){\n          answer.push_back(P(e.time, l.name));\n        }else{\n          int to = next[e.office][l.dst];\n          assert(to != -1);\n          Event send(0, e.time, e.latter, to);\n          lq.insert(lower_bound(lq.begin(), lq.end(), send), send);\n          // send\n          if(wait[e.office] && make_pair(e.time, e.office) != make_pair(que.top().time, que.top().office)){\n            do_send(e, lq, que, dist, wait);\n          }\n        }\n      }else if(e.type == 1){\n        wait[e.office] = true;\n        if(!lq.empty()){\n          do_send(e, lq, que, dist, wait);\n        }\n      }\n    }\n    sort(answer.begin(), answer.end());\n    REP(i, answer.size()){\n      printf(\"%s %d\\n\", answer[i].second.c_str(), answer[i].first);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cost;\n  Edge() {}\n  Edge(int s, int d, int c) : src(s), dst(d), cost(c) {}\n};\n\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nstruct Event{\n  int type;\n  int time;\n  int latter;\n  int office;\n  Event(int ty, int t, int l, int o) : \n    type(ty), time(t), latter(l), office(o) {}\n  bool operator < (const Event& e) const {\n    if(time != e.time) return time < e.time;\n    if(type != e.type) return type < e.type;\n    if(office != e.office) return office < e.office;\n    return latter < e.latter;\n  }\n  bool operator > (const Event& e) const {\n    return e < *this;\n  }\n};\nstruct Latter{\n  string name;\n  int src, dst;\n};\ntypedef pair<int, string> P;\nvoid print(Event& e){\n  //printf(\"type %d time %d latter %d office %d\\n\", e.type, e.time, e.latter, e.office);\n}\n\nvoid do_send(Event& e, deque<Event>& lq, priority_queue<Event, vector<Event>, greater<Event> >& que, int dist[36][36], vector<bool>& wait){\n  /*\n  printf(\"do_send : lq is\\n\");\n  REP(i, lq.size()) print(lq[i]);\n  cout << endl;\n  */\n  Event se = lq.front(); lq.pop_front();\n  que.push(Event(0, e.time + dist[e.office][se.office], se.latter, se.office));\n  //printf(\"send : \"); print(se);\n  for(deque<Event>::iterator it = lq.begin(); it != lq.end(); ){\n    if(it->office == se.office){\n      que.push(Event(0, e.time + dist[e.office][se.office], it->latter, se.office));\n      //printf(\"send2 : \"); print(*it);\n      it = lq.erase(it);\n    }else{\n      it++;\n    }\n  }\n  que.push(Event(1, e.time + 2 * dist[e.office][se.office], -1, e.office));\n  wait[e.office] = false;\n}\nint main(){\n  int N, M;\n  bool first = true;\n  while(cin >> N >> M && N){\n\n    if(first) first = false;\n    else cout << endl;\n\n    Graph G(N);\n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      G[a].push_back(Edge(a, b, c));\n      G[b].push_back(Edge(b, a, c));\n    }\n    int dist[36][36] = {};\n    REP(i, N) REP(j, N) dist[i][j] = (i != j) ? INF : 0;\n    REP(i, N) FORIT(e, G[i]) dist[e->src][e->dst] = e->cost;\n    REP(k, N) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    // next[i][j] := 現在地i, 目的地jの郵便物の次の行き先\n    int next[36][36] = {};\n    memset(next, -1, sizeof(next));\n    REP(i, N) REP(j, N) if(i != j && !G[i].empty()){\n      next[i][j] = G[i][0].dst;\n      int n_cost = G[i][0].cost + dist[G[i][0].dst][j];\n      int edge_cost = G[i][0].cost;\n      FORIT(e, G[i]){\n        if(make_pair(n_cost, next[i][j]) > make_pair(e->cost + dist[e->dst][j], e->dst)){\n          n_cost = e->cost + dist[e->dst][j];\n          next[i][j] = e->dst;\n          edge_cost = e->cost;\n        }\n      }\n      assert(edge_cost == dist[i][next[i][j]]);\n    }\n    //REP(i, N) REP(j, N) printf(\"next[%d][%d] = %d\\n\", i, j, next[i][j]);\n\n    int L; cin >> L;\n    vector<Latter> latters(L);\n    priority_queue<Event, vector<Event>, greater<Event> > que;\n    vector< deque<Event> > l_que(N);\n    REP(i, L){\n      int time;\n      cin >> latters[i].src >> latters[i].dst >> time >> latters[i].name;\n      latters[i].src--; latters[i].dst--;\n      que.push(Event(0, time, i, latters[i].src));\n    }\n    vector<P> answer;\n    vector<bool> wait(N, true);\n    while(!que.empty()){\n      Event e = que.top(); que.pop();\n      print(e);\n      deque<Event>& lq = l_que[e.office];\n      if(e.type == 0){\n        Latter& l = latters[e.latter];\n        if(l.dst == e.office){\n          answer.push_back(P(e.time, l.name));\n        }else{\n          int to = next[e.office][l.dst];\n          assert(to != -1);\n          Event send(0, e.time, e.latter, to);\n          lq.insert(lower_bound(lq.begin(), lq.end(), send), send);\n          // send\n          if(wait[e.office] && (que.empty() || (make_pair(e.time, e.office) != make_pair(que.top().time, que.top().office)))){\n            do_send(e, lq, que, dist, wait);\n          }\n        }\n      }else if(e.type == 1){\n        wait[e.office] = true;\n        if(!lq.empty()){\n          do_send(e, lq, que, dist, wait);\n        }\n      }\n    }\n    REP(i, N) assert(wait[i]);\n    REP(i, N) assert(l_que[i].empty());\n    sort(answer.begin(), answer.end());\n    assert(answer.size() == latters.size());\n    REP(i, answer.size()){\n      printf(\"%s %d\\n\", answer[i].second.c_str(), answer[i].first);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <functional>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<LL,int> pli;\n\nconst LL INF = (LL)1e18;\n\nLL len[33][33];\nint next[33][33];\nchar label[64];\n\nstruct packet{\n\tstring name;\n\tint from, to;\n\tLL tm;\n\n\tpacket(int f, int to, LL tm, const char *s):\n\t\tname(s), from(f), to(to), tm(tm) {}\n\t\n\tbool operator< (const packet &p) const{\n\t\tif(tm != p.tm){ return tm < p.tm; }\n\t\treturn name < p.name;\n\t}\n};\n\nstruct event{\n\tint type;\t//-1: human   other: packet\n\tint pos;\n\tLL tm;\n\n\tbool operator< (const event &e) const{\n\t\tif(tm != e.tm){ return tm > e.tm; }\n\t\treturn type < e.type;\n\t}\n};\n\nvoid solve(int n, int m){\n\tint f, t, d;\n\n\tfor(int i = 0; i <= n; ++i){\n\t\tfor(int j = 0; j <= n; ++j){\n\t\t\tlen[i][j] = INF;\n\t\t\tnext[i][j] = 0;\n\t\t}\n\t\tlen[i][i] = 0;\n\t\tnext[i][i] = i;\n\t}\n\n\tfor(int i = 0; i < m; ++i){\n\t\tscanf(\"%d%d%d\", &f, &t, &d);\n\t\tlen[f][t] = len[t][f] = d;\n\t\tnext[f][t] = t;\n\t\tnext[t][f] = f;\n\t}\n\n\tfor(int k = 1; k <= n; ++k)\n\tfor(int i = 1; i <= n; ++i)\n\tfor(int j = 1; j <= n; ++j){\n\t\tif(i == k || k == j){ continue; }\n\t\tLL &d1 = len[i][j];\n\t\tLL d2 = len[i][k] + len[k][j];\n\t\tif((d1 > d2) || (d1 == d2 && next[i][j] > next[i][k])){\n\t\t\td1 = d2;\n\t\t\tnext[i][j] = next[i][k];\n\t\t}\n\t}\n\n\tvector<vector<int> > wait(n + 1);\n\tscanf(\"%d\", &m);\n\tvector<packet> ps;\n\tpriority_queue<event> pqev;\n\tfor(int i = 0; i < m; ++i){\n\t\tscanf(\"%d%d%d%s\", &f, &t, &d, label);\n\t\tps.push_back(packet(f, t, d, label));\n\t\tpqev.push((event){i, f, d});\n\t}\n\n\tvector<char> standby(n + 1, 1);\n\n\twhile(!pqev.empty()){\n\t\tevent ev = pqev.top();\n\t\tpqev.pop();\n\t\tif(ev.type >= 0){\n\t\t\twait[ev.pos].push_back(ev.type);\n\t\t\tif(standby[ev.pos]){\n\t\t\t\tstandby[ev.pos] = 0;\n\t\t\t\tpqev.push((event){-1, ev.pos, ev.tm});\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tvector<int> &ws = wait[ev.pos];\n\t\t\tif(ws.empty()){\n\t\t\t\tstandby[ev.pos] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tLL mintm = INF;\n\t\t\tfor(int i = 0; i < ws.size(); ++i){\n\t\t\t\tmintm = min(mintm, ps[ws[i]].tm);\n\t\t\t}\n\n\t\t\tint to = 999;\n\t\t\tfor(int i = 0; i < ws.size(); ++i){\n\t\t\t\tpacket &p = ps[ws[i]];\n\t\t\t\tif(p.tm == mintm && to > next[p.from][p.to]){\n\t\t\t\t\tto = next[p.from][p.to];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<int> send;\n\t\t\tfor(int i = 0; i < ws.size(); ++i){\n\t\t\t\tpacket &p = ps[ws[i]];\n\t\t\t\tif(p.tm <= ev.tm && next[ev.pos][p.to] == to){\n\t\t\t\t\tsend.push_back(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLL arvtm = ev.tm + len[ev.pos][to];\n\t\t\tfor(int i = send.size() - 1; i >= 0; --i){\n\t\t\t\tint pn = ws[send[i]];\n\t\t\t\tpacket &p = ps[pn];\n\t\t\t\tp.from = to;\n\t\t\t\tp.tm = arvtm;\n\t\t\t\tif(to != p.to){\n\t\t\t\t\tpqev.push((event){pn, to, arvtm});\n\t\t\t\t}\n\t\t\t\tws.erase(ws.begin() + send[i]);\n\t\t\t}\n\n\t\t\tpqev.push((event){-1, ev.pos, ev.tm + 2 * len[ev.pos][to]});\n\t\t}\n\t}\n\t\n\tsort(ps.begin(), ps.end());\n\tfor(int i = 0; i < ps.size(); ++i){\n\t\tprintf(\"%s %lld\\n\", ps[i].name.c_str(), ps[i].tm);\n\t}\n}\n\nint main(){\n\tbool flg = false;\n\tint n, m;\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\tif(flg){\n\t\t\tputs(\"\");\n\t\t}\n\t\tflg = true;\n\t\tsolve(n, m);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <map>\nusing namespace std;\nconst int INF = 1e9;\n\nstruct mail{\n  int time, to, cur, id;\n};\n\nbool operator < (const mail &a, const mail &b){\n  if(a.time != b.time) return a.time > b.time;\n  return a.cur > b.cur;\n}\n\nint main(){\n  int n, m, c = 0;\n  while(cin >> n >> m, n){\n    if(c) cout << endl;\n    ++c;\n    vector< vector<int> > D(n, vector<int>(n, INF));\n    vector< vector<bool> > E(n, vector<bool>(n, false));\n    for(int i = 0; i < m; ++i){\n      int u, v, d;\n      cin >> u >> v >> d;\n      --u;--v;\n      D[u][v] = d;\n      D[v][u] = d;\n      E[u][v] = true;\n      E[v][u] = true;\n    }\n    for(int i = 0; i < n; ++i) D[i][i] = 0;\n    for(int k = 0; k < n; ++k){\n      for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n          D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n        }\n      }\n    }\n\n    int l;\n    cin >> l;\n    vector<string> name(l);\n    priority_queue<mail> que;\n\n    for(int i = 0; i < l; ++i){\n      int from, to, time;\n      cin >> from >> to >> time >> name[i];\n      que.push((mail){time, to-1, from-1, i});\n    }\n    \n    vector<int> T(n, 0);\n    vector< pair<int, string> > A;\n\n    while(!que.empty()){\n      mail x = que.top();\n      //cout << x.time << \" \" << x.cur << \" \" << x.to << \" \" << name[x.id] << endl;\n      que.pop();\n      int time = x.time, cur = x.cur;\n      T[cur] = max(T[cur], time);\n      vector<mail> V;\n      V.push_back(x);\n      while((!que.empty()) && que.top().time == time && que.top().cur == cur){\n        V.push_back(que.top());\n        que.pop();\n      }\n      vector<bool> used(V.size(), false);\n      for(int i = 0; i < n; ++i){\n        if(i == cur) continue;\n        bool f = false;\n        for(int j = 0; j < V.size(); ++j){\n          if(used[j]) continue;\n          int to = V[j].to;\n          if(D[cur][i] + D[i][to] != D[cur][to] || !E[cur][i]) continue;\n          f = true;\n          used[j] = true;\n          V[j].time = T[cur] + D[cur][i];\n          V[j].cur = i;\n          if(i == to){\n            A.push_back(make_pair(V[j].time, name[V[j].id]));\n            continue;\n          }\n          que.push(V[j]);\n        }\n        if(f){\n          T[cur] += 2*D[cur][i];\n        }\n      }\n    }\n    \n    sort(A.begin(), A.end());\n\n    for(int i = 0; i < A.size(); ++i){\n      cout << A[i].second << \" \" << A[i].first << endl;\n    }\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nconst long long INF = 1e10;\ntypedef vector<vector<long long>> Matrix;\n\nstruct Event {\n  long long time;\n  function<void ()> proc;\n\n  bool operator<(const Event& rhs) const {\n    return time > rhs.time;\n  }\n};\n\nstruct Packet {\n  int src, dst;\n  string name;\n};\n\nenum OfficeState { FREE, BUSY };\n\nstruct Office {\n  OfficeState state;\n  multimap<int, Packet> packets;\n\n  Office(): state(FREE) {}\n};\n\nMatrix shortestPath(const Matrix& g) {\n  int n = g.size();\n  Matrix dist(g);\n  for (int k = 0; k < n; ++k)\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n  return dist;\n}\n\nint nextVertex(const Matrix& dist, int s, int t) {\n  int n = dist.size();\n  for (int v = 0; v < n; ++v)\n    if (v != s && dist[s][v] + dist[v][t] == dist[s][t])\n      return v;\n  assert(false);\n}\n\nint n, m;\nMatrix g, dist;\nvector<Office> offices;\nvector<pair<int, string>> result;\npriority_queue<Event> Q;\n\nvoid onReturn(int time, int office) {\n  offices[office].state = FREE;\n}\n\nvoid onReceive(int time, int office, const vector<Packet>& packets) {\n  Office& o = offices[office];\n  for (auto packet : packets) {\n    if (packet.dst == office) {\n      result.push_back({time, packet.name});\n    } else {\n      int next = nextVertex(dist, office, packet.dst);\n      o.packets.insert({next, packet});\n    }\n  }\n}\n\nvoid deliver(int time, int office) {\n  Office& o = offices[office];\n  if (o.state == BUSY || o.packets.empty()) return;\n  o.state = BUSY;\n  auto range = o.packets.equal_range(o.packets.begin()->first);\n  int next = range.first->first;\n  int t1 = time + g[office][next];\n  int t2 = t1 + g[office][next];\n  vector<Packet> ps;\n  for (auto it = range.first; it != range.second; ++it)\n    ps.push_back(it->second);\n  Q.push({t1, bind(onReceive, t1, next, ps)});\n  Q.push({t2, bind(onReturn, t2, office)});\n  o.packets.erase(range.first, range.second);\n}\n\nint main() {\n  for (int T = 0; cin >> n >> m, n | m; ++T) {\n    if (T > 0) { cout << endl; }\n    result.clear();\n    g.assign(n, vector<long long>(n, INF));\n\n    for (int i = 0; i < m; ++i) {\n      int a, b, c; cin >> a >> b >> c; --a; --b;\n      g[a][b] = g[b][a] = c;\n    }\n    for (int i = 0; i < n; ++i)\n      g[i][i] = 0;\n\n    dist = shortestPath(g);\n    offices.assign(n, Office());\n\n    int l; cin >> l;\n    for (int i = 0; i < l; ++i) {\n      int src, dst;\n      long long time;\n      string name;\n      cin >> src >> dst >> time >> name; --src; --dst;\n      Q.push({time, bind(onReceive, time, src, vector<Packet>{{src, dst, name}})});\n    }\n\n    while (!Q.empty()) {\n      int time = Q.top().time;\n      do {\n        Event e = Q.top(); Q.pop();\n        e.proc();\n      } while (!Q.empty() && Q.top().time == time);\n      for (int i = 0; i < n; ++i)\n        deliver(time, i);\n    }\n\n    sort(result.begin(), result.end());\n    for (auto p : result)\n      cout << p.second << \" \" << p.first << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tint tm,pos,dist;\n\tstring name;\n\tpacket(int t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x], &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(int x,int y){\n\tconst packet &a=pac[x], &b = pac[y];\n\treturn a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tstring name;\n\tfor(;cin>>n>>m,n;){\n\t\tpriority_queue<int,vector<int>,cmp> qu;\n\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=-1;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n/*\n\t\tfor(j=1;j<=n;j++)printf(\"\\t%d\",j);\n\t\tfor(i=1;i<=n;i++,puts){\n\t\t\tprintf(\"\\n%d:\",i);\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tprintf(\"\\t%d(%d)\",len[i][j],to[i][j]);\n\t\t}\n\t\treturn 0;\n*/\n\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n/*\n\t\tfor(;!qu.empty();){\n//printf(\"size: %d\\n\",qu.size());\n\t\t\tint pi = qu.top();\n\t\t\tpacket &p = pac[pi];\n\t\t\tt = p.tm;\n\t\t\tf = p.pos;\n\t\t\tif( f == p.dist ){\n\t\t\t\tqu.pop();\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( t < bac[f] ){\n\t\t\t\tp.tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n//\t\t\t\tprintf(\"wait: %s\\n\",p.name.c_str());\n\t\t\t}else{\n\t\t\t\td = to[f][p.dist];\n//\t\t\t\tprintf(\"%d\\t%d -> %d\\t%s\\n\",p.tm,p.pos,t,p.name.c_str());\n\t\t\t\tbac[f] = p.tm + 2 * len[p.pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket &q = pac[qi];\n\t\t\t\t\tif(t==q.tm && f==q.pos && to[q.pos][q.dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq.tm += len[f][d];\n\t\t\t\t\t\tq.pos = d;\n\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tsort(pac.begin(),pac.end(),cmp2);\n//\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n//\t\tfor(j=0;j<l;j++)tbl[j]=j;\n//\t\tsort(tbl,tbl+l,cmp2);\n//\t\tfor(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),pac[tbl[j]].tm);\n*/\n\t\t**len = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <utility>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std;\nconst int INF = 1e9;\n\nstruct mail{\n  int time, to, cur, next, id;\n};\n\nbool operator < (const mail &a, const mail &b){\n  if(a.time != b.time) return a.time > b.time;\n  if(a.next != b.next) return a.next > b.next;\n  return a.cur > b.cur;\n}\n\nint main(){\n  int n, m, c = 0;\n  while(cin >> n >> m, n){\n    if(c) printf(\"\\n\");\n    else ++c;\n    vector< vector<int> > D(n, vector<int>(n, INF)), E(n, vector<int>(n, -1));\n    for(int i = 0; i < m; ++i){\n      int u, v, d;\n      cin >> u >> v >> d;\n      --u;--v;\n      D[u][v] = d;\n      D[v][u] = d;\n      E[u][v] = d;\n      E[v][u] = d;\n    }\n\n    for(int i = 0; i < n; ++i) D[i][i] = 0;\n    for(int k = 0; k < n; ++k){\n      for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n          D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n        }\n      }\n    }\n\n    vector< vector<int> > next(n, vector<int>(n, -1));\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        for(int k = 0; k < n; ++k){\n          if((D[i][k] + D[k][j] != D[i][j]) || (D[i][k] != E[i][k])) continue;\n          next[i][j] = k;\n          break;\n        }\n      }\n    }\n\n    int l;\n    cin >> l;\n    vector<string> name(l);\n    priority_queue<mail> pque;\n    \n    for(int i = 0; i < l; ++i){\n      int from, to, time;\n      cin >> from >> to >> time >> name[i];\n      pque.push((mail){time, to-1, from-1, next[from-1][to-1], i});\n    }\n    \n    vector<int> T(n, -1);\n    vector< vector<int> > U(n, vector<int>(n, -1));\n    vector< pair<int, string> > A;\n    \n    while(!pque.empty()){\n      mail x = pque.top();\n      pque.pop();\n      \n      if(U[x.cur][x.next] < x.time){\n        T[x.cur] = max(T[x.cur], x.time);\n        U[x.cur][x.next] = T[x.cur];\n        T[x.cur] = max(T[x.cur], U[x.cur][x.next] + 2*D[x.cur][x.next]);\n      }\n      x.time = U[x.cur][x.next] + D[x.cur][x.next];\n      x.cur = x.next;\n      x.next = next[x.cur][x.to];\n\n      if(x.cur == x.to){\n        A.push_back(make_pair(x.time, name[x.id]));\n      }else{\n        pque.push(x);\n      }\n    }\n    \n    sort(A.begin(), A.end());\n    for(int i = 0; i < l; ++i){\n      cout << A[i].second << \" \" << A[i].first << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 10000000\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,string> P2;\n\nstruct edge{\n\tint t,c;\n\tedge(){}\n\tedge(int tt,int cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nstruct data{\n\tint f,id;\n\tint ti,gt,next;\n\tdata(){}\n\tdata(int ff,int ii,int tt,int gg,int nn){\n\t\tf=ff;\n\t\tid=ii;\n\t\tti=tt;\n\t\tgt=gg;\n\t\tnext=nn;\n\t}\n\tbool operator<(const data& d)const{\n\t\tif(ti==d.ti){\n\t\t\tif(gt==d.gt)return next>d.next;\n\t\t\treturn gt>d.gt;\n\t\t}\n\t\treturn ti>d.ti;\n\t}\n};\n\nint n,m,l;\nvector<edge> G[1001];\n\nint dist[33];\nint dijk(int f,int t){\n\tfill(dist,dist+n,INF);\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,t));\n\tint res=n;\n\tdist[t]=0;\n\twhile(que.size()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tif(dist[p.second]<p.first)continue;\n\t\tfor(int j=0;j<G[p.second].size();j++){\n\t\t\tedge e=G[p.second][j];\n\t\t\tif(e.t==f && dist[e.t]==dist[p.second]+e.c)res=min(res,p.second);\n\t\t\tif(dist[e.t]>dist[p.second]+e.c){\n\t\t\t\tif(e.t==f)res=p.second;\n\t\t\t\tdist[e.t]=dist[p.second]+e.c;\n\t\t\t\tque.push(P(dist[e.t],e.t));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\npriority_queue<data> que[35];\nstring str[1001];\nint lf[1001],lt[1001],ltime[1001];\nint next[35];\nint ntime[35];\npriority_queue<P> backer;\nvector<P2> res;\n\nint main(void){\n\tbool space=false;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tif(space)cout << endl;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tspace=true;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint f,t,c;\n\t\t\tscanf(\"%d%d%d\",&f,&t,&c);\n\t\t\tf--;\n\t\t\tt--;\n\t\t\tG[f].push_back(edge(t,c));\n\t\t\tG[t].push_back(edge(f,c));\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\twhile(que[i].size())que[i].pop();\n\t\t}\n\t\twhile(backer.size())backer.pop();\n\t\tscanf(\"%d\",&l);\n\t\tfor(int i=0;i<l;i++){\n\t\t\tcin >> lf[i] >> lt[i] >> ltime[i] >> str[i];\n\t\t\tlf[i]--;\n\t\t\tlt[i]--;\n\t\t\tque[lf[i]].push(data(-1,i,ltime[i],ltime[i],dijk(lf[i],lt[i])));\n\t\t}\n\t\tmemset(next,0,sizeof(next));\n\t\tmemset(ntime,0,sizeof(ntime));\n\t\tres.clear();\n\t\twhile(1){\n\t\t\tbool flag=false;\n\t\t\tint best=0,bt=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(que[i].size()>0){\n\t\t\t\t\tdata p=que[i].top();\n\t\t\t\t\tif(!flag){\n\t\t\t\t\t\tbest=p.ti;\n\t\t\t\t\t\tbt=i;\n\t\t\t\t\t}\n\t\t\t\t\tflag=true;\n\t\t\t\t\tif(best>p.ti){\n\t\t\t\t\t\tbt=i;\n\t\t\t\t\t\tbest=p.ti;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag)break;\n\t\t\tdata v=que[bt].top();\n\t\t\tque[bt].pop();\n\t\t\twhile(backer.size()){\n\t\t\t\tP p=backer.top();\n\t\t\t\tif(p.first<=v.ti){\n\t\t\t\t\tbacker.pop();\n\t\t\t\t\tnext[p.second]=0;\n\t\t\t\t}else break;\n\t\t\t}\n\t\t\tif(bt==lt[v.id]){\n\t\t\t\tres.push_back(P2(v.ti,str[v.id]));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(next[bt]==-1){\n\t\t\t\tv.ti=ntime[bt];\n\t\t\t\tque[bt].push(v);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nex=dijk(bt,lt[v.id]);\n\t\t\tint now=v.ti;\n\t\t\tint plu=0;\n\t\t\tfor(int i=0;i<G[bt].size();i++){\n\t\t\t\tif(nex==G[bt][i].t)plu=G[bt][i].c;\n\t\t\t}\n\t\t\tnext[bt]=-1;\n\t\t\tntime[bt]=v.ti+plu*2;\n\t\t\tbacker.push(P(v.ti+plu*2,bt));\n\t\t\tv.ti+=plu;\n\t\t\tque[nex].push(data(bt,v.id,v.ti,v.ti,(nex==lt[v.id])?-1:dijk(nex,lt[v.id])));\n\t\t\tqueue<data> tmp;\n\t\t\twhile(que[bt].size()){\n\t\t\t\tdata pp=que[bt].top();\n\t\t\t\tif(pp.ti>now)break;\n\t\t\t\tque[bt].pop();\n\t\t\t\tif(pp.next==nex){\n\t\t\t\t\tnext[bt]++;\n\t\t\t\t\tque[nex].push(data(bt,pp.id,v.ti,v.ti,(nex==lt[pp.id])?-1:dijk(nex,lt[v.id])));\n\t\t\t\t}else{\n\t\t\t\t\ttmp.push(pp);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(tmp.size()){\n\t\t\t\tdata pp=tmp.front();\n\t\t\t\tque[bt].push(pp);\n\t\t\t\ttmp.pop();\n\t\t\t}\n\t\t}\n\t\tsort(res.begin(),res.end());\n\t\tfor(int i=0;i<res.size();i++){\n\t\t\tcout << res[i].second << \" \" << res[i].first << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nclass Data\n{\npublic:\n    int time;     // 時刻\n    int position; // 位置\n    int next;     // 次の転送先\n    int postID;   // 郵便物の番号\n    int staffID;  // 転送員の番号\n    Data(int time0, int position0, int next0, int postID0, int staffID0){\n        time = time0;\n        position = position0;\n        next = next0;\n        postID = postID0;\n        staffID = staffID0;\n    }\n    bool operator<(const Data& d) const{\n        return make_pair(time, make_pair(next, postID)) < make_pair(d.time, make_pair(d.next, d.postID));\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Edge> > edges(n);\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            -- a;\n            -- b;\n            edges[a].push_back(Edge(b, c));\n            edges[b].push_back(Edge(a, c));\n        }\n\n        int l;\n        cin >> l;\n        vector<pair<string, vector<int> > > v(l, make_pair(\"\", vector<int>(3)));\n        for(int i=0; i<l; ++i){\n            for(int j=0; j<3; ++j)\n                cin >> v[i].second[j]; // 発送元、宛先、時刻\n            -- v[i].second[0];\n            -- v[i].second[1];\n            cin >> v[i].first;\n        }\n        sort(v.begin(), v.end());\n\n        vector<vector<int> > dist(n, vector<int>(n, INT_MAX)); // dist[i][j] : iからjまでの距離\n        vector<vector<int> > next(n, vector<int>(n, INT_MAX)); // next[i][j] : iからjへ運ぶ郵便物に対する直接の転送先\n        for(int g=0; g<n; ++g){\n            dist[g][g] = 0;\n            multimap<int, int> mm;\n            mm.insert(make_pair(0, g));\n            while(!mm.empty()){\n                int d = mm.begin()->first;\n                int curr = mm.begin()->second;\n                mm.erase(mm.begin());\n                if(d > dist[curr][g])\n                    continue;\n\n                for(unsigned i=0; i<edges[curr].size(); ++i){\n                    int j = edges[curr][i].to;\n                    int d2 = d + edges[curr][i].cost;\n                    if(d2 < dist[j][g]){\n                        dist[j][g] = d2;\n                        mm.insert(make_pair(d2, j));\n                    }\n                    if(d2 <= dist[j][g] && curr < next[j][g])\n                        next[j][g] = curr;\n                }\n            }\n        }\n\n        multiset<Data> ms;\n        for(int i=0; i<l; ++i)\n            ms.insert(Data(v[i].second[2], v[i].second[0], next[v[i].second[0]][v[i].second[1]], i, -1));\n        vector<bool> isStaff(n, true);         // 郵便局に転送員がいるかどうか\n        vector<multiset<Data> > waitedPost(n); // 郵便局に届いている郵便物\n\n        while(!ms.empty()){\n            int t = ms.begin()->time;\n            while(!ms.empty() && t == ms.begin()->time){\n                Data d = *ms.begin();\n                ms.erase(ms.begin());\n\n                if(d.postID != -1){\n                    if(v[d.postID].second[1] == d.position)\n                        cout << v[d.postID].first << ' ' << t << endl;\n                    else\n                        waitedPost[d.position].insert(Data(t, -1, -1, d.postID, -1));\n                    if(d.staffID != -1)\n                        ms.insert(Data(t + dist[d.position][d.staffID], -1, -1, -1, d.staffID));\n                }else{\n                    isStaff[d.staffID] = true;\n                }\n            }\n\n            for(int i=0; i<n; ++i){\n                if(!isStaff[i] || waitedPost[i].size() == 0)\n                    continue;\n\n                int to = next[i][v[waitedPost[i].begin()->postID].second[1]];\n                multiset<Data>::iterator it = waitedPost[i].begin();\n                while(it != waitedPost[i].end()){\n                    if(to == next[i][v[it->postID].second[1]]){\n                        ms.insert(Data(t + dist[i][to], to, next[to][v[it->postID].second[1]], it->postID, i));\n                        multiset<Data>::iterator it2 = it;\n                        ++ it;\n                        waitedPost[i].erase(it2);\n                    }else{\n                        ++ it;\n                    }\n                }\n                isStaff[i] = false;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1000000007)\n\ntypedef pair<int,int> Pii;\ntypedef pair<int,string> Pis;\ntypedef pair< Pii , Pis > PP;\n\nint N,M,K;\nint G[32][32];\nint g[32][32];\n\nset< PP > u[32][32];\n\nint mem[32][32];\n\nint search(int from,int to){\n  if(mem[from][to]!=-1)return mem[from][to];\n  int mini=INF, res=-1;\n  for(int i=0;i<N;i++){\n    if(from==i || g[from][i]==INF)continue;\n    if(mini>g[from][i]+G[i][to]){\n      mini=g[from][i]+G[i][to];\n      res=i;\n    }\n  }\n  assert(res!=-1);\n  return mem[from][to]=res;\n}\n\nvoid init(){\n  for(int i=0;i<32;i++){\n    for(int j=0;j<32;j++){\n      g[i][j]=(i==j?0:INF);\n      G[i][j]=(i==j?0:INF);\n      mem[i][j]=-1;\n      u[i][j].clear();\n    }\n  }\n}\n\nint main(){\n  int cnt=0;\n  while(1){\n\n    init();\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    if(cnt)cout<<endl;\n    cnt++;\n    \n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      G[a][b]=G[b][a]=c;\n    }\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n    \n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    cin>>K;\n\n    map<int, vector<PP> > mp;\n    set<int> st;\n    \n    for(int i=0;i<K;i++){\n      int from,to,ti;\n      string name;\n      cin>>from>>to>>ti>>name;\n      from--,to--;\n      mp[ti].push_back( PP( Pii(from,to) , Pis(0,name)) );\n      st.insert(ti);\n    }\n\n    vector< Pis > ans;\n    vector<int> v(N,0);\n    int last=-1;\n    \n    st.insert(0);\n    while(!st.empty()){\n\n      int p=*st.begin();\n      assert( last < p ); last=p;\n      \n      if(mp.count(p)){\n        for(int i=0;i<(int)mp[p].size();i++){\n          PP pp=mp[p][i];\n          int from=pp.first.first;\n          int to=pp.first.second;\n          string name=pp.second.second;\n          int key=search(from,to);\n          PP tmp=PP( Pii(p, key ) , Pis(to,name) );\n          u[from][key].insert(tmp);\n        }\n        mp[p].clear();\n      }\n      \n      for(int i=0;i<N;i++){\n        if(v[i]>p)continue;\n        PP target=PP( Pii(INF,0) , Pis(0,\"\") );\n        for(int j=0;j<N;j++){\n          if(u[i][j].empty())continue;\n          PP pp=*u[i][j].begin();\n          target=min(target,pp);\n        }\n        if(target.first.first==INF)continue;\n\n        int nex=target.first.second;\n        int to2=target.second.first;\n        \n        set< PP > :: iterator it;\n        for( it=u[i][nex].begin(); it!= u[i][nex].end() ;  ){\n          PP pp=*it;\n          int to=pp.second.first;\n          string name=pp.second.second;\n\n          if(to!=to2){\n            it++;\n          }else if(to==nex){\n            ans.push_back( Pis( p+g[i][nex] , name ) );\n            it=u[i][nex].erase(it);\n          }else{\n            mp[ p+g[i][nex] ].push_back( PP(Pii(nex,to),Pis(0,name)) );\n            it=u[i][nex].erase(it);\n          }\n          \n\n        }// iterator\n        \n        u[i][nex].clear();\n        v[i]=p+g[i][nex]*2;\n        st.insert(v[i]);\n      }// i\n      \n      st.erase(p);\n    }// while ( st.empty() )\n    \n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      Pis p=ans[i];\n      cout<<p.second<<' '<<p.first<<endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst int INF = 1e9;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\n\nstruct query {\n    int type;\n    int pos;\n    string name;\n};\n\nbool operator< (query a, query b) {\n    return a.type < b.type;\n}\n\nint N, M;\nint dist[32][32];\nint Next[32][32];\nint Connected[32][32];\nbool Exist[32];\nvector<vector<string>> QUEUE[32];\nmap<int, vector<query>> mp;\nmap<string, int> ans;\nmap<string, int> destination;\ntypedef pair<int, query> iq;\ntypedef pair<int, string> is;\n\nvoid Add(query q) {\n    //cerr << \"Add: \" << q.pos << \" \" << q.name << endl;\n    int to = Next[q.pos][destination[q.name]];\n    for(int i = 0; i < QUEUE[q.pos].size(); i++) {\n        if(to == Next[q.pos][destination[QUEUE[q.pos][i][0]]]) {\n            QUEUE[q.pos][i].push_back(q.name);\n            return;\n        }\n    }\n    QUEUE[q.pos].push_back({q.name});\n}\n\nvoid Serve(int pos, int timer) {\n    if(!Exist[pos]) return;\n    if(QUEUE[pos].empty()) return;\n    for(string tmp : QUEUE[pos][0]) {\n        int to = Next[pos][destination[tmp]];\n        int newtimer = timer + dist[pos][to];\n        query q;\n        q.type = 1;\n        q.name = tmp;\n        q.pos = to;\n        //cerr << \"Serve: from \" << pos << \" to \" << to << \" \" << tmp << \" when \" << newtimer << endl;\n        mp[newtimer].push_back(q);\n        q.type = 0;\n        q.name = \"\";\n        q.pos = pos;\n        newtimer += dist[pos][to];\n        mp[newtimer].push_back(q);\n    }\n    QUEUE[pos].erase(QUEUE[pos].begin());\n    Exist[pos] = false;\n}\n\nvoid solve() {\n    mp.clear();\n    ans.clear();\n    destination.clear();\n    for(int i = 0; i < N; i++) {\n        Exist[i] = true;\n        QUEUE[i].clear();\n    }\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            dist[i][j] = INF;\n            Connected[i][j] = 1e9;\n        }\n        dist[i][i] = 0;\n        Next[i][i] = -1;\n        Connected[i][i] = 0;\n    }\n    for(int i = 0; i < M; i++) {\n        int a, b, l;\n        cin >> a >> b >> l;\n        a--;\n        b--;\n        dist[a][b] = l;\n        dist[b][a] = l;\n        Connected[a][b] = l;\n        Connected[b][a] = l;\n    }\n    int Q;\n    cin >> Q;\n    while(Q--) {\n        int a, b, t;\n        string S;\n        cin >> a >> b >> t >> S;\n        a--;\n        b--;\n        destination[S] = b;\n        query q;\n        q.pos = a;\n        q.name = S;\n        q.type = 1;\n        mp[t].push_back(q);\n    }\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            for(int k = 0; k < N; k++) {\n                chmin(dist[j][k], dist[j][i] + dist[i][k]);\n            }\n        }\n    }\n    for(int from = 0; from < N; from++) {\n        for(int to = 0; to < N; to++) {\n            if(from == to) continue;\n            int tmp = -1;\n            for(int i = 0; i < N; i++) {\n                if(Connected[from][i] == 1e9) continue;\n                if(i == from) continue;\n                if(tmp == -1 or Connected[from][tmp] + dist[tmp][to] > Connected[from][i] + dist[i][to]) \n                tmp = i;\n            }\n            Next[from][to] = tmp;\n        }\n    }\n    for(auto itr = mp.begin(); itr != mp.end(); itr++) {\n        auto tmp = *itr;\n        //cerr << \"------\" << tmp.first << \"------\" << endl;\n        vector<iq> vec;\n        for(auto q : tmp.second) {\n            //cerr << q.type << \" \" << q.name << \" \" << q.pos << endl;\n            if(q.type == 0) {\n                //cerr << \"clerk of \" << q.pos << \" comes back\" << endl;\n                Exist[q.pos] = true;\n            }\n            if(q.type == 1) {\n                //cerr << q.name << \" \" << destination[q.name] << endl;\n                if(destination[q.name] == q.pos) {\n                    ans[q.name] = tmp.first;\n                    continue;\n                }\n                vec.push_back({Next[q.pos][destination[q.name]], q});\n            }\n        }\n        sort(vec.begin(), vec.end());\n        for(auto tmp : vec) {\n            Add(tmp.second);\n        }\n        for(int i = 0; i < N; i++) {\n            Serve(i, tmp.first);\n        }\n    }\n    vector<is> ANS;\n    for(auto tmp : ans) {\n        ANS.push_back({tmp.second, tmp.first});\n    }\n    sort(ANS.begin(), ANS.end());\n    for(auto tmp : ANS) {\n        cout << tmp.second << \" \" << tmp.first << endl;\n    }\n    /*\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            cerr << Next[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n    */\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int testcase = 0;\n    while(cin >> N >> M) {\n        if(N == 0) break;\n        if(testcase != 0) cout << endl;\n        testcase++;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nsigned main(){\n\tint n,m,co=0;\n\twhile(cin>>n>>m,n){\n\t\tif(co++)cout<<endl;\n\t\tvvi cost(n,vi(n,inf));\n\t\trep(i,n)cost[i][i]=0;\n\t\tvvi G(n);\n\t\trep(i,m){\n\t\t\tint a,b,c;cin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t\tG[a].pb(b);\n\t\t\tG[b].pb(a);\n\t\t}\n\t\trep(i,n)sort(all(G[i]));\n\t\trep(k,n)rep(i,n)rep(j,n)\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n\t\tvvi go(n,vi(n,inf));\n\t\trep(i,n)rep(j,n)if(i!=j)rep(k,G[i].size())if(cost[i][j]==cost[i][G[i][k]]+cost[G[i][k]][j]){\n\t\t\tgo[i][j]=G[i][k];break;\n\t\t}\n\n\t\tint q;\n\t\tcin>>q;\n\t\tvi hu(n),ob(q);\n\t\tvp in(q);\n\t\tvs name(q);\n\t\trep(i,q)cin>>in[i].first>>in[i].second>>ob[i]>>name[i];\n\t\trep(i,q)in[i].first--,in[i].second--;\n\t\twhile(1){\n\t\t\tint mi=inf,mii=-1;\n\t\t\trep(i,q)if(in[i].first!=in[i].second){\n\t\t\t\tint tim=max(ob[i],hu[in[i].first]);\n\t\t\t\tif(mi>tim)mi=tim,mii=in[i].first;\n\t\t\t}\n\t\t\tif(mii==-1)break;\n\t\t\tint mi_t=inf,miti=-1;\n\t\t\trep(i,q)if(in[i].first!=in[i].second&&in[i].first==mii){\n\t\t\t\tif(mi_t>ob[i])mi_t=ob[i],miti=i;\n\t\t\t\telse if(mi_t==ob[i]&&go[in[miti].first][in[miti].second]>go[in[i].first][in[i].second])miti=i;\n\t\t\t}\n\t\t\tint from=in[miti].first,to=go[in[miti].first][in[miti].second];\n\t\t\trep(i,q)if(ob[i]<=mi&&in[i].first==from&&go[in[i].first][in[i].second]==to){\n\t\t\t\thu[from]=mi+2*cost[from][to];\n\t\t\t\tob[i]=mi+cost[from][to];\n\t\t\t\tin[i].first=to;\n\t\t\t}\n\t\t}\n\t\tvector<pair<int,string> >out(q);\n\t\trep(i,q)out[i]={ob[i],name[i]};\n\t\tsort(all(out));\n\t\trep(i,q)cout<<out[i].second<<\" \"<<out[i].first<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tint tm,pos,dist;\n\tstring name;\n\tpacket(int t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x], &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(int x,int y){\n\tconst packet &a=pac[x], &b = pac[y];\n\treturn a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tstring name;\n\tpriority_queue<int,vector<int>,cmp> qu;\n\tfor(;cin>>n>>m,n;){\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=-1;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n\n\t\tfor(;!qu.empty();){\n\t\t\tint pi = qu.top();\n\t\t\tpacket *p = &pac[pi];\n\t\t\tt = p->tm;\n\t\t\tf = p->pos;\n\t\t\tif( f == p->dist ){\n\t\t\t\tqu.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( t < bac[f] ){\n\t\t\t\tp->tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n\t\t\t}else{\n\t\t\t\td = to[f][p->dist];\n\t\t\t\tbac[f] = t + 2 * len[p->pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket*q = &pac[qi];\n\t\t\t\t\tif(t==q->tm && f==q->pos && to[q->pos][q->dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq->tm = max( q->tm + len[f][d], bac[d] );\n\t\t\t\t\t\tq->pos = d;\n\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tsort(pac.begin(),pac.end(),cmp2);\n//\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n\t\tfor(j=0;j<l;j++)tbl[j]=j;\n\t\tsort(tbl,tbl+l,cmp2);\n\t\tfor(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),pac[tbl[j]].tm);\n\n\t\t**len = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nsigned main(){\n\tint n,m,co=0;\n\twhile(cin>>n>>m,n){\n\t\tif(co++)cout<<endl;\n\t\tvvi cost(n,vi(n,inf));\n\t\trep(i,n)cost[i][i]=0;\n\t\tvvi G(n);\n\t\trep(i,m){\n\t\t\tint a,b,c;cin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t\tG[a].pb(b);\n\t\t\tG[b].pb(a);\n\t\t}\n\t\trep(i,n)sort(all(G[i]));\n\t\trep(k,n)rep(i,n)rep(j,n)\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n\t\tvvi go(n,vi(n,inf));\n\t\trep(i,n)rep(j,n)if(i!=j)rep(k,G[i].size())if(cost[i][j]==cost[i][G[i][k]]+cost[G[i][k]][j]){\n\t\t\tgo[i][j]=G[i][k];break;\n\t\t}\n\n\t\tint q;\n\t\tcin>>q;\n\t\tvi hu(n),ob(q);\n\t\tvp in(q);\n\t\tvs name(q);\n\t\trep(i,q)cin>>in[i].first>>in[i].second>>ob[i]>>name[i];\n\t\trep(i,q)in[i].first--,in[i].second--;\n\t\twhile(1){\n\t\t\tint mi=inf,mii=-1;\n\t\t\trep(i,q)if(in[i].first!=in[i].second){\n\t\t\t\tif(mi>ob[i])mi=ob[i],mii=i;\n\t\t\t\tif(mi==ob[i]&&go[in[mii].first][in[mii].second]>go[in[i].first][in[i].second])mii=i;\n\t\t\t}\n\t\t\tif(mii==-1)break;\n\t\t\tint from=in[mii].first,to=go[in[mii].first][in[mii].second];\n\t\t\trep(i,q)if(ob[i]==mi&&in[i].first==from&&go[in[i].first][in[i].second]==to){\n\t\t\t\thu[from]=mi+2*cost[from][to];\n\t\t\t\tob[i]=mi+cost[from][to];\n\t\t\t\tin[i].first=to;\n\t\t\t}\n\t\t\trep(i,q)if(in[i].first!=in[i].second&&hu[in[i].first]>ob[i])ob[i]=hu[in[i].first];\n\t\t}\n\t\tvector<pair<int,string> >out(q);\n\t\trep(i,q)out[i]={ob[i],name[i]};\n\t\tsort(all(out));\n\t\trep(i,q)cout<<out[i].second<<\" \"<<out[i].first<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n\nstruct Edge{\n\tint a,b,c;\n\tEdge(int a,int b,int c) : a(a),b(b),c(c){}\n};\n\nvector<Edge> v[32];\nint next[1000][32];\nstring name[1000];\n\n\nstruct Info{\n\tint id;\n\tint pos;\n\tint time;\n\tint otodoke;\n\tInfo(){}\n\tInfo(int id,int pos,int time,int otodoke) : id(id),pos(pos),time(time),otodoke(otodoke){}\n};\n\nbool operator < (const Info &a,const Info &b){\n\tif( a.time != b.time ) return a.time > b.time ;\n\tif( a.otodoke != b.otodoke ) return a.otodoke > b.otodoke;\n\tif( a.pos != b.pos ) return a.pos > b.pos;\n\treturn next[a.id][a.pos] > next[b.id][b.pos];\n}\n\n\nint main(){\n\tint blflg=0;\n\tint n,m;\n\twhile(cin >> n >> m && n){\n\t\tif(blflg++)cout << endl;\n\t\tlong long wf[100][100];\n\t\tfor(int i = 0 ; i < 100 ; i++){\n\t\t\tfor(int j = 0 ; j < 100 ; j++){\n\t\t\t\twf[i][j] = i==j?0:1e10;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpriority_queue<Info> Q;\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--,b--;\n\t\t\twf[a][b] = c;\n\t\t\twf[b][a] = c;\n\t\t\tv[a].push_back(Edge(a,b,c));\n\t\t\tv[b].push_back(Edge(b,a,c));\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tfor(int k = 0 ; k < n ; k++){\n\t\t\t\t\twf[j][k] = min(wf[j][k],wf[j][i]+wf[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l;\n\t\tcin >> l;\n\t\tfor(int i = 0 ; i < l ; i++){\n\t\t\tint a,b,t;\n\t\t\tcin >> a >> b >> t >> name[i];\n\t\t\ta--,b--;\n\t\t\tint cur = a;\n\t\t\twhile( cur != b ){\n\t\t\t\tnext[i][cur] = 1e9;\n\t\t\t\tfor(int j = 0 ; j < v[cur].size() ; j++){\n\t\t\t\t\tif( wf[cur][b] == wf[v[cur][j].b][b]+v[cur][j].c ){\n\t\t\t\t\t\tnext[i][cur] = min(next[i][cur],v[cur][j].b);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = next[i][cur];\n\t\t\t}\n\t\t\tnext[i][cur] = -1;\n\t\t\tQ.push(Info(i,a,t,t));\n\t\t}\n\t\tvector< pair<int,string> > sorted;\n\t\t\n\t\tint waiting[32]={};\n\t\t\n\t\tint prev = 0;\n\t\twhile(Q.size()){\n\t\t\tInfo q = Q.top();\n\t\t\t\n\t\t\t//cout << \"[\" << q.time << \"]\" << name[q.id] << \" \" << q.pos  << \" \" << q.otodoke << endl;\n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\twaiting[i] = max(waiting[i]-(q.time-prev),0);\n\t\t\t}\n\t\t\tprev = q.time;\n\t\t\tvector<Info> chk;\n\t\t\twhile(Q.size() && Q.top().time == q.time && Q.top().pos == q.pos && next[Q.top().id][Q.top().pos] == next[q.id][q.pos] && Q.top().otodoke == q.otodoke ){\n\t\t\t\tchk.push_back(Q.top()); Q.pop();\n\t\t\t}\n\t\t\tif( next[q.id][q.pos] == -1 ){\n\t\t\t\tfor(int i = 0 ; i < chk.size() ; i++){\n\t\t\t\t\tsorted.push_back(make_pair(chk[i].otodoke,name[chk[i].id]));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( waiting[q.pos] ){\n\t\t\t\tfor(int i = 0 ; i < chk.size() ; i++){\n\t\t\t\t\tQ.push(Info(chk[i].id,chk[i].pos,chk[i].time+waiting[q.pos],chk[i].otodoke));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < chk.size() ; i++){\n\t\t\t\t//cout << chk[i].pos << \" \" << next[chk[i].id][chk[i].pos] << \" < \" << endl;\n\t\t\t\tint cst = wf[chk[i].pos][next[chk[i].id][chk[i].pos]];\n\t\t\t\tQ.push(Info(chk[i].id,next[chk[i].id][chk[i].pos],chk[i].time+cst,chk[i].time+cst));\n\t\t\t\twaiting[q.pos] = 2*cst;\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort(sorted.begin(),sorted.end());\n\t\tfor(int i = 0 ; i < sorted.size() ; i++)\n\t\t\tcout << sorted[i].second << \" \" << sorted[i].first << endl;\n\t}\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nconst long long INF = 1e10;\ntypedef vector<vector<long long>> Matrix;\n\nstruct Event {\n  long long time;\n  function<void ()> proc;\n\n  Event(long long time, function<void ()> proc): time(time), proc(proc) {}\n  bool operator<(const Event& rhs) const { return time > rhs.time; }\n};\n\nstruct Packet {\n  int src, dst;\n  string name;\n\n  Packet(int src, int dst, const string& name): src(src), dst(dst), name(name) {}\n};\n\nenum OfficeState { FREE, BUSY };\n\nstruct Office {\n  OfficeState state;\n  multimap<pair<int, int>, Packet> packets;\n\n  Office(): state(FREE) {}\n};\n\nMatrix shortestPath(const Matrix& g) {\n  int n = g.size();\n  Matrix dist(g);\n  for (int k = 0; k < n; ++k)\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n  return dist;\n}\n\nint nextVertex(const Matrix& g, const Matrix& dist, int s, int t) {\n  int n = dist.size();\n  for (int v = 0; v < n; ++v)\n    if (v != s && g[s][v] + dist[v][t] == dist[s][t])\n      return v;\n  assert(false);\n}\n\nint n, m;\nMatrix g, dist;\nvector<Office> offices;\nvector<pair<int, string>> result;\npriority_queue<Event> Q;\n\nvoid onReturn(int time, int office) {\n  offices[office].state = FREE;\n}\n\nvoid onReceive(int time, int office, const vector<Packet>& packets) {\n  Office& o = offices[office];\n  for (auto packet : packets) {\n    if (packet.dst == office) {\n      result.push_back({time, packet.name});\n    } else {\n      int next = nextVertex(g, dist, office, packet.dst);\n      o.packets.insert({{time, next}, packet});\n    }\n  }\n}\n\nvoid deliver(int time, int office) {\n  Office& o = offices[office];\n  if (o.state == BUSY || o.packets.empty()) return;\n  o.state = BUSY;\n  int next = o.packets.begin()->first.second;\n  int t1 = time + g[office][next];\n  int t2 = t1 + g[office][next];\n  vector<Packet> ps;\n  for (auto it = o.packets.begin(); it != o.packets.end(); ) {\n    if (it->first.second == next) {\n      ps.push_back(it->second);\n      it = o.packets.erase(it);\n    } else {\n      ++it;\n    }\n  }\n  Q.push({t1, bind(onReceive, t1, next, ps)});\n  Q.push({t2, bind(onReturn, t2, office)});\n}\n\nint main() {\n  for (int T = 0; cin >> n >> m, n | m; ++T) {\n    if (T > 0) { cout << endl; }\n    result.clear();\n    g.assign(n, vector<long long>(n, INF));\n\n    for (int i = 0; i < m; ++i) {\n      int a, b, c; cin >> a >> b >> c; --a; --b;\n      g[a][b] = g[b][a] = c;\n    }\n    for (int i = 0; i < n; ++i)\n      g[i][i] = 0;\n\n    dist = shortestPath(g);\n    offices.assign(n, Office());\n\n    int l; cin >> l;\n    for (int i = 0; i < l; ++i) {\n      int src, dst;\n      long long time;\n      string name;\n      cin >> src >> dst >> time >> name; --src; --dst;\n      Q.push({time, bind(onReceive, time, src, vector<Packet>{{src, dst, name}})});\n    }\n\n    while (!Q.empty()) {\n      int time = Q.top().time;\n      do {\n        Event e = Q.top(); Q.pop();\n        e.proc();\n      } while (!Q.empty() && Q.top().time == time);\n      for (int i = 0; i < n; ++i)\n        deliver(time, i);\n    }\n\n    sort(result.begin(), result.end());\n    for (auto p : result)\n      cout << p.second << \" \" << p.first << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct root {\n\tint start;\n\tint goal;\n\tint time;\n\tvector<int>ways;\n\troot():ways() {\n\t\tstart = 0;\n\t\tgoal = 0;\n\t}\n\troot(const int start_, const int goal_, const int time_, const vector<int>ways_)\n\t\t:start(start_), goal(goal_), time(time_), ways(ways_) {\n\n\t}\n};\nstruct edge {\n\tint src;\n\tint dst;\n\tint cost;\n};\n\nstruct query {\n\tint type;\n\tint id;\n\tint num;\n\tint next;\n\tint nextnext;\n\tint time;\n\tquery(int type_, int id_, int num_, const int next_,const int nextnext_, int time_) :type(type_), id(id_), num(num_), next(next_),nextnext(nextnext_), time(time_) {\n\n\t}\n};\nclass Compare {\npublic:\n\tbool operator()(const query&l, const query&r) {\n\t\treturn l.time==r.time?l.type==r.type?l.nextnext>r.nextnext:l.type<r.type:l.time> r.time;\n\t}\n};\t//aa?????????????????¶\nstruct letter {\n\tint id;\n\tstring name;\n\tvector<int>ways;\n};\nint main() {\n\tint aa = 0;\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tif(aa)\tcout << endl;\n\n\t\taa++;\n\t\t\n\t\tvector<vector<root>>roots(N, vector<root>(N));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\n\t\t\t\troots[i][j].start = i;\n\t\t\t\troots[i][j].goal = j;\n\t\t\t\tif (i == j) {\n\t\t\t\t\troots[i][j].time = 0;\n\t\t\t\t\troots[i][j].ways = vector<int>{};\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\troots[i][j].time = 1e9;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\t\troots[a][b] = root( a,b,c,vector<int>{b} );\n\t\t\troots[b][a] = root(b, a, c, vector<int>{a});\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tif (i == k || j == k||i==j)continue;\n\t\t\t\t\tif (roots[i][k].time < 1e8&&roots[k][j].time < 1e8) {\n\t\t\t\t\t\tconst int  nexttime = roots[i][k].time + roots[k][j].time;\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tvector<int>preways(roots[i][j].ways);\n\t\t\t\t\t\tvector<int>nextways(roots[i][k].ways);\n\t\t\t\t\t\tnextways.insert(nextways.end(), roots[k][j].ways.begin(), roots[k][j].ways.end());\n\t\t\t\t\t\tif (nexttime > roots[i][j].time)ok = false;\n\t\t\t\t\t\telse if (nexttime == roots[i][j].time) {\n\n\t\t\t\t\t\t\tfor (int a= 0; a < preways.size(); ++a) {\n\t\t\t\t\t\t\t\tif (preways[a] > nextways[a]) {\n\t\t\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (preways[a] < nextways[a]) {\n\t\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\troots[i][j].time = nexttime;\n\t\t\t\t\t\t\troots[i][j].ways = nextways;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (roots[i][j].time < 1e8) {\n\t\t\t\t\troots[i][j].ways.insert(roots[i][j].ways.begin(), i);\n\t\t\t\t\troots[i][j].ways.emplace_back(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tint L; cin >> L;\n\t\tpriority_queue<query, vector<query>, Compare>que;\n\t\tmap<int,letter>mp;\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint a, b, c; string d; cin >> a >> b >> c >> d; a--; b--;\n\t\t\tmp[i] = letter{ i,d,roots[a][b].ways };\n\t\t\tint nextnext = roots[a][b].ways[1];\n\t\t\tque.push(query(1,i,0,roots[a][b].ways[0],nextnext,c ));\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tque.push(query{ 0,0,0,i,0,0 });\n\t\t}\n\t\tvector<pair< int,string>>anss;\n\t\t//vector<vector<vector<int>>>waits(N,vector<vector<int>>(N,vector<int>()));\n\t\tvector<deque<vector<tuple<int,int,int>>>>nexts(N);\n\t\tvector<int>exists(N);\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tquery q(que.top());\n\t\t\tque.pop();\n\n\t\t\tconst int nowtime = q.time;\n\n\t\t\tconst int nowplace = q.next;\n\t\t\t//??°??£?????????\n\t\t\tif (q.type == 0) {\n\t\t\t\tassert(exists[nowplace] == false);\n\t\t\t\tif (!nexts[nowplace].empty()) {\n\t\t\t\t\tauto carrys(nexts[nowplace].front());\n\t\t\t\t\tconst int nextplace = get<2>(carrys[0]);\n\t\t\t\t\tfor (auto carry : carrys) {\n\t\t\t\t\t\tint aid = get<0>(carry);\n\t\t\t\t\t\tint anum = get<1>(carry);\n\t\t\t\t\t\tconst int needtime = roots[nowplace][nextplace].time;\n\t\t\t\t\t\tconst int nexttime = nowtime + needtime;\n\t\t\t\t\t\tconst int backtime = nexttime + needtime;\n\t\t\t\t\t\tque.push(query(1,aid,anum + 1,nextplace,mp[aid].ways[anum+2],nexttime ));\n\t\t\t\t\t\texists[nowplace] = false;\n\t\t\t\t\t}\n\t\t\t\t\tque.push(query(0, 0, 0, nowplace, 0,nowtime+2*roots[nowplace][nextplace].time));\n\t\t\t\t\tnexts[nowplace].pop_front();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(!exists[nowplace]);\n\t\t\t\t\texists[nowplace] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//???????????\\???\n\t\t\telse {\n\t\t\t\tif (q.nextnext==-1) {\n\t\t\t\t\tanss.push_back(make_pair(q.time, mp[q.id].name));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst int nextplace = mp[q.id].ways[q.num + 1];\n\t\t\t\t\tif (!exists[nowplace]) {\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor (int i = 0; i < nexts[nowplace].size(); ++i) {\n\t\t\t\t\t\t\tif (get<2>(nexts[nowplace][i][0]) == nextplace) {\n\t\t\t\t\t\t\t\tnexts[nowplace][i].push_back(make_tuple(q.id, q.num, nextplace));\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\tnexts[nowplace].push_back(vector<tuple<int,int,int>>(1, make_tuple(q.id, q.num, nextplace)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor (int i = 0; i < nexts[nowplace].size(); ++i) {\n\t\t\t\t\t\t\tif (get<2>(nexts[nowplace][i][0]) == nextplace) {\n\t\t\t\t\t\t\t\tnexts[nowplace][i].push_back(make_tuple(q.id, q.num, nextplace));\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\tnexts[nowplace].push_back(vector<tuple<int, int, int>>(1, make_tuple(q.id, q.num, nextplace)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.push(query(0, 0, 0, nowplace, 0, nowtime));\n\t\t\t\t\t\texists[nowplace] = false;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tsort(anss.begin(), anss.end());\n\t\tfor (auto ans : anss) {\n\t\t\tcout << ans.second << \" \" << ans.first << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nstruct edge{\n    int to;\n    int cost;\n};\nint d[33][33];\n// cur,to\nint nxt[33][33];\nstring letterNames[1001];\n\nconst int INF=1000000000;\nvector<edge>G[101];\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\nvoid calcNxtPlace(int V){\n    for(int i=0;i<33;i++)for(int j=0;j<33;j++)nxt[i][j]=INF;\n    for(int i=0;i<V;i++){\n        for(int j=0;j<V;j++){\n            if(i!=j){\n                int nxtNum=INF;\n                for(int k=0;k<G[i].size();k++){\n                    edge &e=G[i][k];\n                    if(d[i][e.to]+d[e.to][j]==d[i][j])nxtNum=min(nxtNum,e.to);\n                }\n                nxt[i][j]=nxtNum;\n            }\n        }\n    }\n}\n\nstruct Letter{\n    int nxtTo;\n    int goal;\n    int start;\n    int id;\n    int arriveTime;\n    bool operator<(const Letter &lt)const{\n        return arriveTime>lt.arriveTime;\n    }\n};\n\nstruct Event{\n    // 0:,1:úÔ,2:èÌÇÁ\n    int kind;\n    int time;\n    int node;\n    int prvNode;\n    vector<Letter> lts;\n    bool operator<(const Event &e)const{\n        if(time>e.time)true;\n        else if(time<e.time)false;\n        return kind>e.kind;\n    }\n};\n\nint N,M,L;\n// Çõª¶Ý·é©Ç¤©\nbool isExist[1001];\n// eXÖÇÉÂ¢ÄA»ê¼êÌèª·ÅÉçê½©\nbool isArrivalLet[1001][1001];\n// eXÖÇ²ÆÉAèðÔÉÇ\npriority_queue<Letter> postLets[1001];\n// eXÖÇ²ÆÉAèð Äæ²ÆÉÇ\nvector<Letter> postByNxtTo[101][101];\n\nint main(){\n    bool fst=true;\n    while(cin>>N>>M&&(N|M)){\n        if(fst)fst=false;\n        else cout<<endl;\n        for(int i=0;i<N;i++)G[i].clear();\n        for(int i=0;i<1001;i++)isExist[i]=true;\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)postByNxtTo[i][j].clear();\n        memset(isArrivalLet,0,sizeof(isArrivalLet));\n        for(int i=0;i<N;i++)while(postLets[i].size())postLets[i].pop();\n        for(int i=0;i<N;i++)for(int j=0;j<N;j++){\n            if(i==j)d[i][j]=0;\n            else d[i][j]=INF;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            edge e;\n            cin>>a>>b>>e.cost;\n            a--;b--;\n            e.to=b;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[a][b]=d[b][a]=e.cost;\n        }\n        cin>>L;\n        priority_queue<Event> pq;\n        warshall_floyd(N);\n        calcNxtPlace(N);\n        for(int i=0;i<L;i++){\n            Letter lt;\n            cin>>lt.start>>lt.goal>>lt.arriveTime;\n            lt.start--;lt.goal--;\n            cin>>letterNames[i];\n            lt.id=i;\n            lt.nxtTo=(nxt[lt.start][lt.goal]);\n            // èÇÁCxg\n            Event ev;\n            ev.prvNode=lt.start;\n            ev.node=lt.start;\n            ev.kind=1;\n            ev.time=lt.arriveTime;\n            ev.lts.push_back(lt);\n            pq.push(ev);\n        }\n        vector<pair<int,string> > res;\n        // CxgðÔÉ\n        while(pq.size()){\n            Event e=pq.top();pq.pop();\n            // \n            if(e.kind==0){\n                // èðXÖÇÉÇÁ\n                for(int i=0;i<e.lts.size();i++){\n                    // goal\n                    if(e.lts[i].goal==e.node)\n                        res.push_back(make_pair(e.time,letterNames[e.lts[i].id]));\n                    else{\n                        //  ÄæðÌêÉÏXµÄ¨­\n                        e.lts[i].nxtTo=nxt[e.node][e.lts[i].goal];\n                        e.lts[i].arriveTime=e.time;\n                        postLets[e.node].push(e.lts[i]);\n                        postByNxtTo[e.node][e.lts[i].nxtTo].push_back(e.lts[i]);\n                    }\n                }\n                // AÒCxgðÇÁ\n                Event ev;\n                ev.node=e.prvNode;\n                ev.kind=2;\n                ev.prvNode=e.node;\n                // ÌCxgÔðo^\n                ev.time=e.time+d[e.node][e.prvNode];\n                pq.push(ev);\n            }\n            // ÇÁ\n            else if(e.kind==1){\n                // èðXÖÇÉÇÁ\n                postLets[e.node].push(e.lts[0]);\n                // èðXÖÇÉ Äæ²ÆÉª¯ÄÇÁ\n                postByNxtTo[e.node][e.lts[0].nxtTo].push_back(e.lts[0]);\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // AÒ\n            else if(e.kind==2){\n                isExist[e.node]=true;\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // o­\n            else if(e.kind==3){\n                // ¡ éèÌÅAàÁÆàÔªÍâ¢àÌðé\n                // ½¾µAÌ Ä³«ª¨È¶àÌÍAÜÆßÄé\n                // ¡±ÌêÉèª¶ÝµÈ¢\n                Letter lt;\n                bool ok=true;\n                while(1){\n                    if(postLets[e.node].empty()){\n                        //// wõð¯ßé\n                        //isExist[e.node]=true;\n                        ok=false;\n                        break;\n                    }\n                    lt=postLets[e.node].top();postLets[e.node].pop();\n                    // ·ÅÉçêÄ¢é\n                    if(isArrivalLet[e.node][lt.id]){\n                        continue;\n                    }\n                    else{\n                        break;\n                    }\n                }\n                if(!ok){\n                    isExist[e.node]=true;\n                    continue;\n                }\n                Event ev;\n                // éèðZbg\n                ev.lts=postByNxtTo[e.node][lt.nxtTo];\n                // Á½ÌÅgðNA\n                for(int i=0;i<ev.lts.size();i++)isArrivalLet[e.node][ev.lts[i].id]=true;\n                postByNxtTo[e.node][lt.nxtTo].clear();\n                ev.kind=0;\n                ev.node=lt.nxtTo;\n                ev.prvNode=e.node;\n                ev.time=e.time+d[e.node][lt.nxtTo];\n                pq.push(ev);\n            }\n        }\n        sort(res.begin(),res.end());\n        for(int i=0;i<res.size();i++)cout<<res[i].second<<\" \"<<res[i].first<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<26)\n\ntypedef pair<int,int> Pii;\ntypedef pair<int,string> Pis;\ntypedef pair< Pii , Pis > PP;\n\nint N,M,K;\nint G[32][32];\nint g[32][32];\n\nset< PP > t[32];\nset< PP > u[32][32];\n\nint mem[32][32];\n\nint search(int from,int to){\n  if(mem[from][to]!=-1)\n    return mem[from][to];\n  \n  int mini=INF, res=-1;\n  for(int i=0;i<N;i++){\n    if(from!=i&&g[from][i]!=INF&& mini > g[from][i] + G[i][to] ){\n      mini=g[from][i]+G[i][to];\n      res=i;\n    }\n  }\n  \n  return mem[from][to]=res;\n}\n\nvoid init(){\n  for(int i=0;i<32;i++){\n    t[i].clear();\n    for(int j=0;j<32;j++){\n      g[i][j]=(i==j?0:INF);\n      G[i][j]=(i==j?0:INF);\n      mem[i][j]=-1;\n      u[i][j].clear();\n    }\n  }\n}\n\nint main(){\n  int cnt=0;\n  while(1){\n\n    init();\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    if(cnt)cout<<endl;\n    cnt++;\n    \n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      G[a][b]=min(G[a][b],c);\n      G[b][a]=min(G[b][a],c);\n    }\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n    \n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    cin>>K;\n\n    map<int, vector<PP> > mp;\n    set<int> st;\n    \n    for(int i=0;i<K;i++){\n      int from,to,ti;\n      string name;\n      cin>>from>>to>>ti>>name;\n      from--,to--;\n      mp[ti].push_back( PP( Pii(from,to) , Pis(0,name)) );\n      st.insert(ti);\n    }\n\n    vector< Pis > ans;\n    vector<int> v(N,0);\n\n    st.insert(0);\n    while(!st.empty()){\n      int p=*st.begin();\n      if(mp.count(p)){\n        for(int i=0;i<(int)mp[p].size();i++){\n          PP pp=mp[p][i];\n          int from=pp.first.first;\n          int to=pp.first.second;\n          string name=pp.second.second;\n          int key=search(from,to);\n          PP tmp=PP( Pii(p, key ) , Pis(to,name) );\n          t[from].insert(tmp);\n          u[from][key].insert(tmp);\n        }\n        mp[p].clear();\n      }\n      \n      for(int i=0;i<N;i++){\n        if(v[i]>p)continue;\n        if(t[i].empty())continue;\n\n        PP target=*t[i].begin();\n        t[i].erase( t[i].begin() );\n        int nex=target.first.second;\n        set< PP > :: iterator it;\n        for( it=u[i][nex].begin(); it!= u[i][nex].end() ; it++ ){\n          PP pp=*it;\n          int to=pp.second.first;\n          string name=pp.second.second;\n          \n          if(to==nex){\n            ans.push_back( Pis( p+g[i][nex] , name ) );\n            continue;\n          }\n\n          mp[ p+g[i][nex] ].push_back( PP(Pii(nex,to),Pis(0,name)) );\n          \n        }// iterator\n        \n        u[i][nex].clear();\n        v[i]=p+g[i][nex]*2;\n        st.insert(v[i]);\n      }// i\n      \n      st.erase( st.begin() );\n    }// st.empty()\n    \n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      Pis p=ans[i];\n      cout<<p.second<<' '<<p.first<<endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1000000007)\n\ntypedef pair<int,int> Pii;\ntypedef pair<int,string> Pis;\ntypedef pair< Pii , Pis > PP;\n\nint N,M,K;\nint G[32][32];\nint g[32][32];\n\nset< PP > u[32][32];\n\nint mem[32][32];\n\nint search(int from,int to){\n  if(mem[from][to]!=-1)return mem[from][to];\n  int mini=INF, res=-1;\n  for(int i=0;i<N;i++){\n    if(from==i || g[from][i]==INF)continue;\n    if(mini>g[from][i]+G[i][to]){\n      mini=g[from][i]+G[i][to];\n      res=i;\n    }\n  }\n  assert(res!=-1);\n  return mem[from][to]=res;\n}\n\nvoid init(){\n  for(int i=0;i<32;i++){\n    for(int j=0;j<32;j++){\n      g[i][j]=(i==j?0:INF);\n      G[i][j]=(i==j?0:INF);\n      mem[i][j]=-1;\n      u[i][j].clear();\n    }\n  }\n}\n\nint main(){\n  int cnt=0;\n  while(1){\n\n    init();\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    if(cnt)cout<<endl;\n    cnt++;\n    \n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      G[a][b]=G[b][a]=c;\n    }\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n    \n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    cin>>K;\n\n    map<int, vector<PP> > mp;\n    set<int> st;\n    \n    for(int i=0;i<K;i++){\n      int from,to,ti;\n      string name;\n      cin>>from>>to>>ti>>name;\n      from--,to--;\n      mp[ti].push_back( PP( Pii(from,to) , Pis(0,name)) );\n      st.insert(ti);\n    }\n\n    vector< Pis > ans;\n    vector<int> v(N,0);\n    int last=-1;\n    \n    st.insert(0);\n    while(!st.empty()){\n\n      int p=*st.begin();\n      assert( last < p ); last=p;\n      \n      if(mp.count(p)){\n        for(int i=0;i<(int)mp[p].size();i++){\n          PP pp=mp[p][i];\n          int from=pp.first.first;\n          int to=pp.first.second;\n          string name=pp.second.second;\n          int key=search(from,to);\n          PP tmp=PP( Pii(p, key ) , Pis(to,name) );\n          u[from][key].insert(tmp);\n        }\n        mp[p].clear();\n      }\n      \n      for(int i=0;i<N;i++){\n        if(v[i]>p)continue;\n        PP target=PP( Pii(INF,0) , Pis(0,\"\") );\n        for(int j=0;j<N;j++){\n          if(u[i][j].empty())continue;\n          PP pp=*u[i][j].begin();\n          target=min(target,pp);\n        }\n        if(target.first.first==INF)continue;\n\n        int nex=target.first.second;\n        set< PP > :: iterator it;\n        for( it=u[i][nex].begin(); it!= u[i][nex].end() ; it++ ){\n          PP pp=*it;\n          int to=pp.second.first;\n          string name=pp.second.second;\n          \n          if(to==nex){\n            ans.push_back( Pis( p+g[i][nex] , name ) );\n          }else{\n            mp[ p+g[i][nex] ].push_back( PP(Pii(nex,to),Pis(0,name)) );\n          }\n          \n        }// iterator\n        \n        u[i][nex].clear();\n        v[i]=p+g[i][nex]*2;\n        st.insert(v[i]);\n      }// i\n      \n      st.erase(p);\n    }// while ( st.empty() )\n    \n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      Pis p=ans[i];\n      cout<<p.second<<' '<<p.first<<endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 50\n\nbool firstcase = true;\n\nstruct DATA{\n  ll t;\n  int id;\n  int now;\n  int next;\n  int goal;\n\n  const bool operator<(const DATA &B) const{\n    if(t != B.t) return t > B.t;\n    if(next != B.next) return next > B.next;\n    return false;\n  }\n\n  DATA(ll t, int id, int now, int next, int goal):\n    t(t), id(id), now(now), next(next), goal(goal){}\n};\n\nint dist[40][40];\nint connect[40][40];\nint n;\n\nint getNext(int a, int b){\n  if (a == b) return a;\n  for(int i=0;i<n;i++){\n    if(connect[a][i] && connect[a][i] == dist[a][i] && dist[a][i] + dist[i][b] == dist[a][b])\n      return i;\n  }\n\n  assert(false);\n  return -1;\n}\n\nbool solve(){\n  int m, q;\n  string text[1000];\n  \n  priority_queue<DATA> pq;\n\n  scanf(\"%d%d\", &n, &m);\n  \n  if(n == 0) return false;\n  if(firstcase) firstcase = false;\n  else puts(\"\");\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dist[i][j] = INF;\n      connect[i][j] = false;\n    }\n    dist[i][i] = 0;\n  }\n  \n  \n  for(int i=0;i<m;i++){\n    int a, b, c; \n    scanf(\"%d%d%d\", &a, &b, &c);\n    a--; b--;\n\n    dist[a][b] = dist[b][a] = c;\n    connect[a][b] = connect[b][a] = c;\n  }\n\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n  \n  scanf(\"%d\", &q);\n\n  for(int i=0;i<q;i++){\n    int a, b, t;\n    char temp[60];\n    scanf(\"%d%d%d%s\", &a, &b, &t, temp);\n    a--; b--;\n    text[i] = temp;\n    \n    pq.push(DATA(t, i, a, getNext(a,b), b));\n  }\n\n  bool outside[40] = {};\n  ll sent[40][40] = {};\n  priority_queue<pair<ll,int> > que[40];\n  queue<DATA> post[40][40];\n  vector<pair<ll,string> > ans;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      sent[i][j] = -1;\n  \n  while(pq.size()){\n    queue<int> work;\n    ll t = pq.top().t;\n    \n    while(pq.size() && pq.top().t == t){\n      auto p = pq.top(); pq.pop();\n      if(p.id != -1){\n        if(p.now == p.goal){\n          ans.push_back({p.t, text[p.id]});\n          continue;\n        }\n        \n        post[p.now][p.next].push(p);\n        que[p.now].push({-p.t, -p.next});\n        // cerr << \"[post] \" << t << \" : \" << p.now << \" -> \" << p.next << \" -> \" << p.goal << endl;\n      }else{\n        assert(outside[p.now]);\n        outside[p.now] = false;\n        // cerr << \"[back] \" << t << \" : \" << p.now << endl;\n      }\n\n      work.push(p.now);\n    }\n    \n\n    while(work.size()){\n      int now = work.front(); work.pop();\n      if(outside[now]) continue;\n      \n      while(que[now].size() && -que[now].top().first <= t){\n        auto p = que[now].top(); que[now].pop();\n\n        if(-p.first <= sent[now][-p.second]) continue;\n        \n        //cerr << now << \" -> \" << -p.second << endl;\n        \n        while(post[now][-p.second].size()){\n          auto p2 = post[now][-p.second].front(); post[now][-p.second].pop();\n          \n          p2.t = t + dist[now][p2.next];\n          p2.now = p2.next;\n          p2.next = getNext(p2.next, p2.goal);\n          pq.push(p2);\n        }\n        \n        outside[now] = true;\n        pq.push(DATA((ll)t + dist[now][-p.second]*2, -1, now, -1, -1));\n        sent[now][-p.second] = t;\n        break;\n      }\n\n    }\n  }\n\n  sort(ans.begin(), ans.end());\n\n  assert(ans.size() == q);\n  \n  for(int i=0;i<q;i++){\n    cout << ans[i].second << \" \" << ans[i].first << endl;\n  }\n  \n  return true;\n}\n\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstring>\n\nusing namespace std;\nconst int INF=1000000000;\n\nstruct edge{\n    int to;\n    int cost;\n};\n\nstruct Letter{\n    int nxtTo;\n    int goal;\n    int start;\n    int id;\n    int arriveTime;\n    bool operator<(const Letter &lt)const{\n        if(arriveTime>lt.arriveTime)return true;\n        else if(arriveTime<lt.arriveTime)return false;\n        return nxtTo>lt.nxtTo;\n    }\n};\n\nstruct Event{\n    // 0:,1:úÔ,2:èÌÇÁ\n    int kind;\n    int time;\n    int node;\n    int prvNode;\n    vector<Letter> lts;\n    bool operator<(const Event &e)const{\n        if(time>e.time)return true;\n        else if(time<e.time)return false;\n        return kind>e.kind;\n    }\n};\n\nint d[33][33];\n// cur,to\nint nxt[33][33];\nstring letterNames[1001];\nvector<edge>G[101];\nint N,M,L;\n// Çõª¶Ý·é©Ç¤©\nbool isExist[1001];\n// eXÖÇÉÂ¢ÄA»ê¼êÌèª·ÅÉçê½©\nbool isArrivalLet[1001][1001];\n// eXÖÇ²ÆÉAèðÔÉÇ\npriority_queue<Letter> postLets[1001];\n// eXÖÇ²ÆÉAèð Äæ²ÆÉÇ\nvector<Letter> postByNxtTo[101][101];\n\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\nvoid calcNxtPlace(int V){\n    for(int i=0;i<33;i++)for(int j=0;j<33;j++)nxt[i][j]=INF;\n    for(int i=0;i<V;i++){\n        for(int j=0;j<V;j++){\n            if(i!=j){\n                int nxtNum=INF;\n                for(int k=0;k<G[i].size();k++){\n                    edge &e=G[i][k];\n                    if(d[i][e.to]+d[e.to][j]==d[i][j])nxtNum=min(nxtNum,e.to);\n                }\n                nxt[i][j]=nxtNum;\n            }\n        }\n    }\n}\nint main(){\n    bool fst=true;\n    while(cin>>N>>M&&(N|M)){\n        if(fst)fst=false;\n        else cout<<endl;\n        memset(isArrivalLet,0,sizeof(isArrivalLet));\n        for(int i=0;i<N;i++)G[i].clear();\n        for(int i=0;i<1001;i++)isExist[i]=true;\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)postByNxtTo[i][j].clear();\n        for(int i=0;i<N;i++)while(postLets[i].size())postLets[i].pop();\n        for(int i=0;i<N;i++)for(int j=0;j<N;j++){\n            if(i==j)d[i][j]=0;\n            else d[i][j]=INF;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            edge e;\n            cin>>a>>b>>e.cost;\n            a--;b--;\n            e.to=b;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[a][b]=d[b][a]=e.cost;\n        }\n        warshall_floyd(N);\n        calcNxtPlace(N);\n        cin>>L;\n        priority_queue<Event> pq;\n        for(int i=0;i<L;i++){\n            Letter lt;\n            cin>>lt.start>>lt.goal>>lt.arriveTime;\n            lt.start--;lt.goal--;\n            cin>>letterNames[i];\n            lt.id=i;\n            lt.nxtTo=(nxt[lt.start][lt.goal]);\n            // èÇÁCxg\n            Event ev;\n            ev.prvNode=lt.start;\n            ev.node=lt.start;\n            ev.kind=1;\n            ev.time=lt.arriveTime;\n            ev.lts.push_back(lt);\n            pq.push(ev);\n        }\n        vector<pair<int,string> > res;\n        // CxgðÔÉ\n        while(pq.size()){\n            Event e=pq.top();pq.pop();\n            // \n            if(e.kind==0){\n                // èðXÖÇÉÇÁ\n                for(int i=0;i<e.lts.size();i++){\n                    // goal\n                    if(e.lts[i].goal==e.node)\n                        res.push_back(make_pair(e.time,letterNames[e.lts[i].id]));\n                    else{\n                        //  ÄæðÌêÉÏXµÄ¨­\n                        e.lts[i].nxtTo=nxt[e.node][e.lts[i].goal];\n                        e.lts[i].arriveTime=e.time;\n                        postLets[e.node].push(e.lts[i]);\n                        postByNxtTo[e.node][e.lts[i].nxtTo].push_back(e.lts[i]);\n                    }\n                }\n                // AÒCxgðÇÁ\n                {\n                    Event ev;\n                    ev.node=e.prvNode;\n                    ev.kind=2;\n                    ev.prvNode=e.node;\n                    // ÌCxgÔðo^\n                    ev.time=e.time+d[e.node][e.prvNode];\n                    pq.push(ev);\n                }\n                // Ì]æÖéCxgðÇÁ\n                {\n                    // wõª¢éÈçÎAo­CxgðÇÁ\n                    if(isExist[e.node]){\n                        isExist[e.node]=false;\n                        Event ev;\n                        ev.kind=3;\n                        ev.time=e.time;\n                        ev.node=e.node;\n                        pq.push(ev);\n                    }\n                }\n            }\n            // ÇÁ\n            else if(e.kind==1){\n                // èðXÖÇÉÇÁ\n                postLets[e.node].push(e.lts[0]);\n                // èðXÖÇÉ Äæ²ÆÉª¯ÄÇÁ\n                postByNxtTo[e.node][e.lts[0].nxtTo].push_back(e.lts[0]);\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // AÒ\n            else if(e.kind==2){\n                isExist[e.node]=true;\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // o­\n            else if(e.kind==3){\n                // ¡ éèÌÅAàÁÆàÔªÍâ¢àÌðé\n                // ½¾µAÌ Ä³«ª¨È¶àÌÍAÜÆßÄé\n                // ¡±ÌêÉèª¶ÝµÈ¢\n                Letter lt;\n                bool ok=true;\n                while(1){\n                    if(postLets[e.node].empty()){\n                        ok=false;\n                        break;\n                    }\n                    lt=postLets[e.node].top();postLets[e.node].pop();\n                    // ·ÅÉçêÄ¢é\n                    if(isArrivalLet[e.node][lt.id])continue;\n                    else break;\n                }\n                if(!ok){\n                    isExist[e.node]=true;\n                    continue;\n                }\n                Event ev;\n                // éèðZbg\n                ev.lts=postByNxtTo[e.node][lt.nxtTo];\n                // Á½ÌÅgðNA\n                for(int i=0;i<ev.lts.size();i++)isArrivalLet[e.node][ev.lts[i].id]=true;\n                postByNxtTo[e.node][lt.nxtTo].clear();\n                ev.kind=0;\n                ev.node=lt.nxtTo;\n                ev.prvNode=e.node;\n                ev.time=e.time+d[e.node][lt.nxtTo];\n                pq.push(ev);\n            }\n        }\n        sort(res.begin(),res.end());\n        for(int i=0;i<res.size();i++)cout<<res[i].second<<\" \"<<res[i].first<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n#define mp         make_pair\n#define ALL(C)     (C).begin(),(C).end()\n\nconst int N = 32;\nconst int inf = INT_MAX;\nconst int costinf=(1<<21);\n\n\ntypedef struct{string name;int time,tar;}Mail;\n\n\nclass Postman{\npublic:\n  int time,tar;\n  vector<Mail> mail;\n};\n\n\nint cost[N][N];\nint edge[N][N];//costinf\nint next[N][N];\nvoid wf(int n){\n  rep(i,n)rep(j,n)cost[i][j]=edge[i][j];\n  rep(k,n)rep(i,n)rep(j,n)cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n  rep(i,n){\n    rep(j,n){\n      next[i][j]=100;\n      if (i == j)continue;\n      rep(k,n){\n\tif (i == k)continue;\n\tif (edge[i][k] == costinf)continue;\n\tif (cost[i][j] == edge[i][k]+cost[k][j]){\n\t  next[i][j]=k;\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nclass Postoffice{\npublic:\n  vector<Mail> mail;\n  int find_next_time(int node,int now){\n    int mintime=inf,mindex=100;\n    rep(i,mail.size()){\n      if (mintime == inf || next[node][mail[i].tar] < mindex){\n\tif (mail[i].time < now)return 0;\n\tmintime=mail[i].time-now;\n\tmindex =next[node][mail[i].tar];\n      }\n    }\n    return mintime;\n  }\n\n  void set_man(int node,int now,Postman &man){\n    int mintime=inf,mindex=100,mingo=inf;\n    rep(i,mail.size()){\n      if (mail[i].time > now)continue;\n      if (mail[i].time < mintime || \n\t  (mintime == mail[i].time-now && next[node][mail[i].tar] < mindex)){\n\tmintime=mail[i].time-now;\n\tmingo  =edge[node][next[node][mail[i].tar]];\n\tmindex =next[node][mail[i].tar];\n      }\n    }\n    \n    if (mindex == 100)return;\n    \n    rep(i,mail.size()){\n      if (mail[i].time > mintime+now)continue;\n      if (next[node][mail[i].tar] == mindex){\n\tman.mail.pb(mail[i]);\n\tmail.erase(mail.begin()+i);\n\ti--;\n      }\n    }\n    //    cout << \"set_man \" << node <<\" \" << now <<\" \" << mindex <<\" \" << mail.size() << endl;\n    man.time=mingo;\n    man.tar=mindex;\n  }\n};\n\n\nvoid solve(int n,Postman *man,Postoffice *office){\n  vector<pair<string,int> > ans;\n  int t = 0;\n\n  //initialization\n  wf(n);\n\n  while(true){\n    int minevent=inf;\n    \n    // arrive\n    rep(i,n){\n      if (man[i].tar != -1)minevent=min(minevent,man[i].time);\n    }\n\n    rep(i,n){\n      //      cout << \"man \" << i <<\" \" << man[i].tar <<\" \" << man[i].time << endl;\n    }\n    \n    rep(i,n){\n      if (man[i].tar == -1){\n\tminevent=min(office[i].find_next_time(i,t),minevent);\n      }\n    }\n\n    //    cout << t <<\" \" << minevent << endl;\n    if (minevent == inf)break;\n\n    t+=minevent;\n    \n    rep(i,n){\n      if (man[i].tar != -1){\n\tman[i].time-=minevent;\n\tif (man[i].time == 0){\n\t  if (man[i].tar != i){\n\t    rep(j,man[i].mail.size()){\n\t      if (man[i].tar == man[i].mail[j].tar){\n\t\tans.pb(mp(man[i].mail[j].name,t));\n\t      }\n\t      else office[man[i].tar].mail.pb(man[i].mail[j]);\n\t    }\n\t    man[i].mail.clear();\n\t    man[i].time=cost[man[i].tar][i];\n\t    man[i].tar=i;\n\t  }else if (man[i].tar == i){\n\t    man[i].tar=-1;\n\t  }\n\t}\n      }\n    }\n\n    //    cout <<\"check\" <<endl;\n    rep(i,n){\n      if (man[i].tar != -1)continue;\n      office[i].set_man(i,t,man[i]);\n    }\n    //    cout <<\"check 2 \"<<endl;\n  }\n\n\n\n  sort(ALL(ans));\n  rep(i,ans.size()){\n    cout << ans[i].first <<\" \" << ans[i].second << endl;\n  }\n}\n\nmain(){\n  int n,m;\n  int te=0;\n  while(cin>>n>>m && n){\n    if (te)cout<<endl;\n    te++;\n    rep(i,n){\n      rep(j,n)edge[i][j]=costinf;\n      edge[i][i]=0;\n    }\n    Postman    man[n];\n    Postoffice     office[n];\n    rep(i,n)man[i].tar=-1;\n    \n    \n    rep(i,m){\n      int f,t,c;\n      cin>>f>>t>>c;\n      f--;t--;\n      edge[f][t]=edge[t][f]=c;\n    }\n    \n    int l;\n    cin>>l;\n    rep(i,l){\n      int fr,to,ti;\n      string name;\n      cin>>fr>>to>>ti>>name;\n      office[fr-1].mail.pb((Mail){name,ti,to-1});\n    }\n    \n    solve(n,man,office);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nstruct edge{\n    int to;\n    int cost;\n};\nint d[33][33];\n// cur,to\nint nxt[33][33];\nstring letterNames[1001];\n\nconst int INF=1000000000;\nvector<edge>G[101];\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\nvoid calcNxtPlace(int V){\n    for(int i=0;i<33;i++)for(int j=0;j<33;j++)nxt[i][j]=INF;\n    for(int i=0;i<V;i++){\n        for(int j=0;j<V;j++){\n            if(i!=j){\n                int nxtNum=INF;\n                for(int k=0;k<G[i].size();k++){\n                    edge &e=G[i][k];\n                    if(d[i][e.to]+d[e.to][j]==d[i][j])nxtNum=min(nxtNum,e.to);\n                }\n                nxt[i][j]=nxtNum;\n            }\n        }\n    }\n}\n\nstruct Letter{\n    int nxtTo;\n    int goal;\n    int start;\n    int id;\n    int arriveTime;\n    bool operator<(const Letter &lt)const{\n        if(arriveTime>lt.arriveTime)true;\n        else if(arriveTime<lt.arriveTime)false;\n        return nxtTo>lt.nxtTo;\n    }\n};\n\nstruct Event{\n    // 0:,1:úÔ,2:èÌÇÁ\n    int kind;\n    int time;\n    int node;\n    int prvNode;\n    vector<Letter> lts;\n    bool operator<(const Event &e)const{\n        if(time>e.time)true;\n        else if(time<e.time)false;\n        return kind>e.kind;\n    }\n};\n\nint N,M,L;\n// Çõª¶Ý·é©Ç¤©\nbool isExist[1001];\n// eXÖÇÉÂ¢ÄA»ê¼êÌèª·ÅÉçê½©\nbool isArrivalLet[1001][1001];\n// eXÖÇ²ÆÉAèðÔÉÇ\npriority_queue<Letter> postLets[1001];\n// eXÖÇ²ÆÉAèð Äæ²ÆÉÇ\nvector<Letter> postByNxtTo[101][101];\n\nint main(){\n    bool fst=true;\n    while(cin>>N>>M&&(N|M)){\n        if(fst)fst=false;\n        else cout<<endl;\n        for(int i=0;i<N;i++)G[i].clear();\n        for(int i=0;i<1001;i++)isExist[i]=true;\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)postByNxtTo[i][j].clear();\n        memset(isArrivalLet,0,sizeof(isArrivalLet));\n        for(int i=0;i<N;i++)while(postLets[i].size())postLets[i].pop();\n        for(int i=0;i<N;i++)for(int j=0;j<N;j++){\n            if(i==j)d[i][j]=0;\n            else d[i][j]=INF;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            edge e;\n            cin>>a>>b>>e.cost;\n            a--;b--;\n            e.to=b;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[a][b]=d[b][a]=e.cost;\n        }\n        cin>>L;\n        priority_queue<Event> pq;\n        warshall_floyd(N);\n        calcNxtPlace(N);\n        for(int i=0;i<L;i++){\n            Letter lt;\n            cin>>lt.start>>lt.goal>>lt.arriveTime;\n            lt.start--;lt.goal--;\n            cin>>letterNames[i];\n            lt.id=i;\n            lt.nxtTo=(nxt[lt.start][lt.goal]);\n            // èÇÁCxg\n            Event ev;\n            ev.prvNode=lt.start;\n            ev.node=lt.start;\n            ev.kind=1;\n            ev.time=lt.arriveTime;\n            ev.lts.push_back(lt);\n            pq.push(ev);\n        }\n        vector<pair<int,string> > res;\n        // CxgðÔÉ\n        while(pq.size()){\n            Event e=pq.top();pq.pop();\n            // \n            if(e.kind==0){\n                // èðXÖÇÉÇÁ\n                for(int i=0;i<e.lts.size();i++){\n                    // goal\n                    if(e.lts[i].goal==e.node)\n                        res.push_back(make_pair(e.time,letterNames[e.lts[i].id]));\n                    else{\n                        //  ÄæðÌêÉÏXµÄ¨­\n                        e.lts[i].nxtTo=nxt[e.node][e.lts[i].goal];\n                        e.lts[i].arriveTime=e.time;\n                        postLets[e.node].push(e.lts[i]);\n                        postByNxtTo[e.node][e.lts[i].nxtTo].push_back(e.lts[i]);\n                    }\n                }\n                // AÒCxgðÇÁ\n                Event ev;\n                ev.node=e.prvNode;\n                ev.kind=2;\n                ev.prvNode=e.node;\n                // ÌCxgÔðo^\n                ev.time=e.time+d[e.node][e.prvNode];\n                pq.push(ev);\n            }\n            // ÇÁ\n            else if(e.kind==1){\n                // èðXÖÇÉÇÁ\n                postLets[e.node].push(e.lts[0]);\n                // èðXÖÇÉ Äæ²ÆÉª¯ÄÇÁ\n                postByNxtTo[e.node][e.lts[0].nxtTo].push_back(e.lts[0]);\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // AÒ\n            else if(e.kind==2){\n                isExist[e.node]=true;\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // o­\n            else if(e.kind==3){\n                // ¡ éèÌÅAàÁÆàÔªÍâ¢àÌðé\n                // ½¾µAÌ Ä³«ª¨È¶àÌÍAÜÆßÄé\n                // ¡±ÌêÉèª¶ÝµÈ¢\n                Letter lt;\n                bool ok=true;\n                while(1){\n                    if(postLets[e.node].empty()){\n                        ok=false;\n                        break;\n                    }\n                    lt=postLets[e.node].top();postLets[e.node].pop();\n                    // ·ÅÉçêÄ¢é\n                    if(isArrivalLet[e.node][lt.id])continue;\n                    else break;\n                }\n                if(!ok){\n                    isExist[e.node]=true;\n                    continue;\n                }\n                Event ev;\n                // éèðZbg\n                ev.lts=postByNxtTo[e.node][lt.nxtTo];\n                // Á½ÌÅgðNA\n                for(int i=0;i<ev.lts.size();i++)isArrivalLet[e.node][ev.lts[i].id]=true;\n                postByNxtTo[e.node][lt.nxtTo].clear();\n                ev.kind=0;\n                ev.node=lt.nxtTo;\n                ev.prvNode=e.node;\n                ev.time=e.time+d[e.node][lt.nxtTo];\n                pq.push(ev);\n            }\n        }\n        sort(res.begin(),res.end());\n        for(int i=0;i<res.size();i++)cout<<res[i].second<<\" \"<<res[i].first<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nclass Data\n{\npublic:\n    int time;     // 時刻\n    int position; // 位置\n    int next;     // 次の転送先\n    int postID;   // 郵便物の番号\n    int staffID;  // 転送員の番号\n    Data(int time0, int position0, int next0, int postID0, int staffID0){\n        time = time0;\n        position = position0;\n        next = next0;\n        postID = postID0;\n        staffID = staffID0;\n    }\n    bool operator<(const Data& d) const{\n        return make_pair(time, make_pair(next, postID)) < make_pair(d.time, make_pair(d.next, d.postID));\n    }\n};\n\nint main()\n{\n    bool first = true;\n\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        if(first)\n            first = false;\n        else\n            cout << endl;\n\n        vector<vector<Edge> > edges(n);\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            -- a;\n            -- b;\n            edges[a].push_back(Edge(b, c));\n            edges[b].push_back(Edge(a, c));\n        }\n\n        int l;\n        cin >> l;\n        vector<pair<string, vector<int> > > v(l, make_pair(\"\", vector<int>(3)));\n        for(int i=0; i<l; ++i){\n            for(int j=0; j<3; ++j)\n                cin >> v[i].second[j]; // 発送元、宛先、時刻\n            -- v[i].second[0];\n            -- v[i].second[1];\n            cin >> v[i].first;\n        }\n        sort(v.begin(), v.end());\n\n        vector<vector<int> > dist(n, vector<int>(n, INT_MAX)); // dist[i][j] : iからjまでの距離\n        vector<vector<int> > next(n, vector<int>(n, INT_MAX)); // next[i][j] : iからjへ運ぶ郵便物に対する直接の転送先\n        for(int g=0; g<n; ++g){\n            dist[g][g] = 0;\n            multimap<int, int> mm;\n            mm.insert(make_pair(0, g));\n            while(!mm.empty()){\n                int d = mm.begin()->first;\n                int curr = mm.begin()->second;\n                mm.erase(mm.begin());\n                if(d > dist[curr][g])\n                    continue;\n\n                for(unsigned i=0; i<edges[curr].size(); ++i){\n                    int j = edges[curr][i].to;\n                    int d2 = d + edges[curr][i].cost;\n                    if(d2 < dist[j][g]){\n                        dist[j][g] = d2;\n                        mm.insert(make_pair(d2, j));\n                    }\n                    if(d2 <= dist[j][g] && curr < next[j][g])\n                        next[j][g] = curr;\n                }\n            }\n        }\n\n        multiset<Data> ms;\n        for(int i=0; i<l; ++i)\n            ms.insert(Data(v[i].second[2], v[i].second[0], -1, i, -1));\n        vector<bool> isStaff(n, true);         // 郵便局に転送員がいるかどうか\n        vector<multiset<Data> > waitedPost(n); // 郵便局に届いている郵便物\n\n        while(!ms.empty()){\n            int t = ms.begin()->time;\n            while(!ms.empty() && t == ms.begin()->time){\n                Data d = *ms.begin();\n                ms.erase(ms.begin());\n\n                if(d.postID != -1){\n                    if(v[d.postID].second[1] == d.position)\n                        cout << v[d.postID].first << ' ' << t << endl;\n                    else\n                        waitedPost[d.position].insert(Data(t, -1, next[d.position][v[d.postID].second[1]], d.postID, -1));\n                    if(d.staffID != -1)\n                        ms.insert(Data(t + dist[d.position][d.staffID], -1, -1, -1, d.staffID));\n                }else{\n                    isStaff[d.staffID] = true;\n                }\n            }\n\n            for(int i=0; i<n; ++i){\n                if(!isStaff[i] || waitedPost[i].size() == 0)\n                    continue;\n\n                int to = next[i][v[waitedPost[i].begin()->postID].second[1]];\n                multiset<Data>::iterator it = waitedPost[i].begin();\n                while(it != waitedPost[i].end()){\n                    if(to == next[i][v[it->postID].second[1]]){\n                        ms.insert(Data(t + dist[i][to], to, -1, it->postID, i));\n                        multiset<Data>::iterator it2 = it;\n                        ++ it;\n                        waitedPost[i].erase(it2);\n                    }else{\n                        ++ it;\n                    }\n                }\n                isStaff[i] = false;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nsigned main(){\n\tint n,m,co=0;\n\twhile(cin>>n>>m,n){\n\t\tif(co++)cout<<endl;\n\t\tvvi cost(n,vi(n,inf));\n\t\trep(i,n)cost[i][i]=0;\n\t\tvvi G(n);\n\t\trep(i,m){\n\t\t\tint a,b,c;cin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t\tG[a].pb(b);\n\t\t\tG[b].pb(a);\n\t\t}\n\t\trep(i,n)sort(all(G[i]));\n\t\trep(k,n)rep(i,n)rep(j,n)\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n\t\tvvi go(n,vi(n,inf));\n\t\trep(i,n)rep(j,n)if(i!=j)rep(k,G[i].size())if(cost[i][j]==cost[i][G[i][k]]+cost[G[i][k]][j]){\n\t\t\tgo[i][j]=G[i][k];break;\n\t\t}\n\n\t\tint q;\n\t\tcin>>q;\n\t\tvi s(q),t(q),hu(n),ob(q);\n\t\tvs name(q);\n\t\trep(i,q)cin>>s[i]>>t[i]>>ob[i]>>name[i];\n\t\trep(i,q)s[i]--,t[i]--;\n\t\twhile(1){\n\t\t\tint mi=inf,from=-1;\n\t\t\trep(i,q)if(s[i]!=t[i]){\n\t\t\t\tint tim=max(ob[i],hu[s[i]]);\n\t\t\t\tif(mi>tim)mi=tim,from=s[i];\n\t\t\t}\n\t\t\tif(from==-1)break;\n\n\t\t\tint mi_t=inf,to=-1;\n\t\t\trep(i,q)if(s[i]!=t[i]&s[i]==from){\n\t\t\t\tif(mi_t>ob[i])mi_t=ob[i],to=go[s[i]][t[i]];\n\t\t\t\telse if(mi_t==ob[i])to=min(to,go[s[i]][t[i]]);\n\t\t\t}\n\n\t\t\trep(i,q)if(ob[i]<=mi&&s[i]==from&&go[s[i]][t[i]]==to){\n\t\t\t\thu[from]=mi+2*cost[from][to];\n\t\t\t\tob[i]=mi+cost[from][to];\n\t\t\t\ts[i]=to;\n\t\t\t}\n\t\t}\n\t\tvector<pair<int,string> >out(q);\n\t\trep(i,q)out[i]={ob[i],name[i]};\n\t\tsort(all(out));\n\t\trep(i,q)cout<<out[i].second<<\" \"<<out[i].first<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <utility>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std;\nconst int INF = 1e9;\n\nstruct mail{\n  int time, to, cur, next, id;\n};\n\nbool operator < (const mail &a, const mail &b){\n  if(a.time != b.time) return a.time > b.time;\n  if(a.next != b.next) return a.next > b.next;\n  return a.cur > b.cur;\n}\n\nint main(){\n  int n, m, c = 0;\n  while(cin >> n >> m, n){\n    //if(c) printf(\"%d\\n\", c++);\n    if(c) printf(\"\\n\");\n    else ++c;\n    vector< vector<int> > D(n, vector<int>(n, INF));\n    vector< vector<bool> > E(n, vector<bool>(n, false));\n    \n    for(int i = 0; i < m; ++i){\n      int u, v, d;\n      cin >> u >> v >> d;\n\n      --u;--v;\n      D[u][v] = d;\n      D[v][u] = d;\n      E[u][v] = true;\n      E[v][u] = true;\n\n    }\n\n    for(int i = 0; i < n; ++i) D[i][i] = 0;\n    for(int k = 0; k < n; ++k){\n      for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n          D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n        }\n      }\n    }\n\n    vector< vector<int> > next(n, vector<int>(n, -1));\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        for(int k = 0; k < n; ++k){\n          if((D[i][k] + D[k][j] != D[i][j]) || (!E[i][k])) continue;\n          next[i][j] = k;\n          break;\n        }\n      }\n    }\n\n    int l;\n    cin >> l;\n    vector<string> name(l);\n    priority_queue<mail> pque;\n    \n    for(int i = 0; i < l; ++i){\n      int from, to, time;\n      cin >> from >> to >> time >> name[i];\n      pque.push((mail){time, to-1, from-1, next[from-1][to-1], i});\n    }\n\n\n    vector<int> T(n, -1);\n    vector< vector<int> > U(n, vector<int>(n, -1));\n    vector< pair<int, string> > A;\n    \n    while(!pque.empty()){\n      mail x = pque.top();\n      pque.pop();\n      assert(x.cur >= 0);\n      assert(x.next >= 0);\n      assert(x.cur < n);\n      assert(x.next < n);\n      T[x.cur] = max(T[x.cur], x.time);\n      if(U[x.cur][x.next] < x.time){\n        U[x.cur][x.next] = T[x.cur];\n      }\n      T[x.cur] = max(T[x.cur], U[x.cur][x.next] + 2*D[x.cur][x.next]);\n      x.time = U[x.cur][x.next] + D[x.cur][x.next];\n      x.cur = x.next;\n      x.next = next[x.cur][x.to];\n      if(x.cur == x.to){\n        assert(x.id >= 0);\n        assert(x.id < l);\n        A.push_back(make_pair(x.time, name[x.id]));\n      }else{\n        pque.push(x);\n      }\n    }\n    \n    sort(A.begin(), A.end());\n    for(int i = 0; i < l; ++i){\n      cout << A[i].second << \" \" << A[i].first << endl;\n    }\n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define INF (2000000007LL)\n\ntypedef pair<int,int> Pii;\ntypedef pair<int,string> Pis;\ntypedef pair< Pii , Pis > PP;\n\nint N,M,K;\nll G[32][32];\nll g[32][32];\n\nset< PP > u[32][32];\n\nint mem[32][32];\n\nint search(int from,int to){\n  if(mem[from][to]!=-1)return mem[from][to];\n  ll mini=INF, res=-1;\n  for(int i=0;i<N;i++){\n    if(from==i || g[from][i]==INF)continue;\n    if(mini>g[from][i]+G[i][to]){\n      mini=g[from][i]+G[i][to];\n      res=i;\n    }\n  }\n  assert(res!=-1);\n  return mem[from][to]=res;\n}\n\nvoid init(){\n  for(int i=0;i<32;i++){\n    for(int j=0;j<32;j++){\n      g[i][j]=(i==j?0:INF);\n      G[i][j]=(i==j?0:INF);\n      mem[i][j]=-1;\n      u[i][j].clear();\n    }\n  }\n}\n\nint main(){\n  int cnt=0;\n  while(1){\n\n    init();\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    if(cnt)cout<<endl;\n    cnt++;\n    \n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      G[a][b]=G[b][a]=c;\n    }\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n    \n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    cin>>K;\n\n    map<int, vector<PP> > mp;\n    set<int> st;\n    \n    for(int i=0;i<K;i++){\n      int from,to,ti;\n      string name;\n      cin>>from>>to>>ti>>name;\n      from--,to--;\n      mp[ti].push_back( PP( Pii(from,to) , Pis(0,name)) );\n      st.insert(ti);\n    }\n\n    vector< Pis > ans;\n    vector<int> v(N,0);\n    int last=-1;\n    \n    st.insert(0);\n    while(!st.empty()){\n\n      int p=*st.begin();\n      assert( last < p ); last=p;\n      \n      if(mp.count(p)){\n        for(int i=0;i<(int)mp[p].size();i++){\n          PP pp=mp[p][i];\n          int from=pp.first.first;\n          int to=pp.first.second;\n          string name=pp.second.second;\n          int key=search(from,to);\n          PP tmp=PP( Pii(p, key ) , Pis(to,name) );\n          u[from][key].insert(tmp);\n        }\n        //       mp[p].clear();\n      }\n      \n      for(int i=0;i<N;i++){\n        if(v[i]>p)continue;\n        \n        PP target=PP( Pii(INF,0) , Pis(0,\"\") );\n        \n        for(int j=0;j<N;j++){\n          if(u[i][j].empty())continue;\n          PP pp=*u[i][j].begin();\n          target=min(target,pp);\n        }\n        if(target.first.first==INF)continue;\n\n        int nex=target.first.second;\n        \n        set< PP > :: iterator it;\n        for( it=u[i][nex].begin(); it!= u[i][nex].end() ; it++ ){\n          PP pp=*it;\n          int to=pp.second.first;\n          string name=pp.second.second;\n\n          if(to==nex){\n            ans.push_back( Pis( p+g[i][nex] , name ) );\n          }else{\n            mp[ p+g[i][nex] ].push_back( PP(Pii(nex,to),Pis(0,name)) );\n          }\n        }// iterator\n        \n        u[i][nex].clear();\n        v[i]=p+g[i][nex]*2;\n        st.insert(p+g[i][nex]);\n        st.insert(p+g[i][nex]*2);\n      }// i\n      \n      st.erase(p);\n    }// while ( st.empty() )\n    \n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      Pis p=ans[i];\n      cout<<p.second<<' '<<p.first<<endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstring>\n\nusing namespace std;\nconst int INF=1000000000;\n\nstruct edge{\n    int to;\n    int cost;\n};\n\nstruct Letter{\n    int nxtTo;\n    int goal;\n    int start;\n    int id;\n    int arriveTime;\n    bool operator<(const Letter &lt)const{\n        if(arriveTime>lt.arriveTime)return true;\n        else if(arriveTime<lt.arriveTime)return false;\n        return nxtTo>lt.nxtTo;\n    }\n};\n\nstruct Event{\n    // 0:,1:úÔ,2:èÌÇÁ\n    int kind;\n    int time;\n    int node;\n    int prvNode;\n    vector<Letter> lts;\n    bool operator<(const Event &e)const{\n        if(time>e.time)return true;\n        else if(time<e.time)return false;\n        return kind>e.kind;\n    }\n};\n\nint d[33][33];\n// cur,to\nint nxt[33][33];\nstring letterNames[1001];\nvector<edge>G[101];\nint N,M,L;\n// Çõª¶Ý·é©Ç¤©\nbool isExist[1001];\n// eXÖÇÉÂ¢ÄA»ê¼êÌèª·ÅÉçê½©\nbool isArrivalLet[1001][1001];\n// eXÖÇ²ÆÉAèðÔÉÇ\npriority_queue<Letter> postLets[1001];\n// eXÖÇ²ÆÉAèð Äæ²ÆÉÇ\nvector<Letter> postByNxtTo[101][101];\n\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\nvoid calcNxtPlace(int V){\n    for(int i=0;i<33;i++)for(int j=0;j<33;j++)nxt[i][j]=INF;\n    for(int i=0;i<V;i++){\n        for(int j=0;j<V;j++){\n            if(i!=j){\n                int nxtNum=INF;\n                for(int k=0;k<G[i].size();k++){\n                    edge &e=G[i][k];\n                    if(e.cost+d[e.to][j]==d[i][j])nxtNum=min(nxtNum,e.to);\n                }\n                nxt[i][j]=nxtNum;\n            }\n        }\n    }\n}\nint main(){\n    bool fst=true;\n    while(cin>>N>>M&&(N|M)){\n        if(fst)fst=false;\n        else cout<<endl;\n        memset(isArrivalLet,0,sizeof(isArrivalLet));\n        for(int i=0;i<N;i++)G[i].clear();\n        for(int i=0;i<1001;i++)isExist[i]=true;\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)postByNxtTo[i][j].clear();\n        for(int i=0;i<N;i++)while(postLets[i].size())postLets[i].pop();\n        for(int i=0;i<N;i++)for(int j=0;j<N;j++){\n            if(i==j)d[i][j]=0;\n            else d[i][j]=INF;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            edge e;\n            cin>>a>>b>>e.cost;\n            a--;b--;\n            e.to=b;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[a][b]=d[b][a]=e.cost;\n        }\n        warshall_floyd(N);\n        calcNxtPlace(N);\n        cin>>L;\n        priority_queue<Event> pq;\n        for(int i=0;i<L;i++){\n            Letter lt;\n            cin>>lt.start>>lt.goal>>lt.arriveTime;\n            lt.start--;lt.goal--;\n            cin>>letterNames[i];\n            lt.id=i;\n            lt.nxtTo=(nxt[lt.start][lt.goal]);\n            // èÇÁCxg\n            Event ev;\n            ev.prvNode=lt.start;\n            ev.node=lt.start;\n            ev.kind=1;\n            ev.time=lt.arriveTime;\n            ev.lts.push_back(lt);\n            pq.push(ev);\n        }\n        vector<pair<int,string> > res;\n        // CxgðÔÉ\n        while(pq.size()){\n            Event e=pq.top();pq.pop();\n            // \n            if(e.kind==0){\n                // èðXÖÇÉÇÁ\n                for(int i=0;i<e.lts.size();i++){\n                    // goal\n                    if(e.lts[i].goal==e.node)\n                        res.push_back(make_pair(e.time,letterNames[e.lts[i].id]));\n                    else{\n                        //  ÄæðÌêÉÏXµÄ¨­\n                        e.lts[i].nxtTo=nxt[e.node][e.lts[i].goal];\n                        e.lts[i].arriveTime=e.time;\n                        postLets[e.node].push(e.lts[i]);\n                        postByNxtTo[e.node][e.lts[i].nxtTo].push_back(e.lts[i]);\n                    }\n                }\n                // AÒCxgðÇÁ\n                {\n                    Event ev;\n                    ev.node=e.prvNode;\n                    ev.kind=2;\n                    ev.prvNode=e.node;\n                    // ÌCxgÔðo^\n                    ev.time=e.time+d[e.node][e.prvNode];\n                    pq.push(ev);\n                }\n                // Ì]æÖéCxgðÇÁ\n                {\n                    // wõª¢éÈçÎAo­CxgðÇÁ\n                    if(isExist[e.node]){\n                        isExist[e.node]=false;\n                        Event ev;\n                        ev.kind=3;\n                        ev.time=e.time;\n                        ev.node=e.node;\n                        pq.push(ev);\n                    }\n                }\n            }\n            // ÇÁ\n            else if(e.kind==1){\n                // èðXÖÇÉÇÁ\n                postLets[e.node].push(e.lts[0]);\n                // èðXÖÇÉ Äæ²ÆÉª¯ÄÇÁ\n                postByNxtTo[e.node][e.lts[0].nxtTo].push_back(e.lts[0]);\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // AÒ\n            else if(e.kind==2){\n                isExist[e.node]=true;\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // o­\n            else if(e.kind==3){\n                // ¡ éèÌÅAàÁÆàÔªÍâ¢àÌðé\n                // ½¾µAÌ Ä³«ª¨È¶àÌÍAÜÆßÄé\n                // ¡±ÌêÉèª¶ÝµÈ¢\n                Letter lt;\n                bool ok=true;\n                while(1){\n                    if(postLets[e.node].empty()){\n                        ok=false;\n                        break;\n                    }\n                    lt=postLets[e.node].top();postLets[e.node].pop();\n                    // ·ÅÉçêÄ¢é\n                    if(isArrivalLet[e.node][lt.id])continue;\n                    else break;\n                }\n                if(!ok){\n                    isExist[e.node]=true;\n                    continue;\n                }\n                Event ev;\n                // éèðZbg\n                ev.lts=postByNxtTo[e.node][lt.nxtTo];\n                // Á½ÌÅgðNA\n                for(int i=0;i<ev.lts.size();i++)isArrivalLet[e.node][ev.lts[i].id]=true;\n                postByNxtTo[e.node][lt.nxtTo].clear();\n                ev.kind=0;\n                ev.node=lt.nxtTo;\n                ev.prvNode=e.node;\n                ev.time=e.time+d[e.node][lt.nxtTo];\n                pq.push(ev);\n            }\n        }\n        sort(res.begin(),res.end());\n        for(int i=0;i<res.size();i++)cout<<res[i].second<<\" \"<<res[i].first<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<26)\n\ntypedef pair<int,int> Pii;\ntypedef pair<int,string> Pis;\ntypedef pair< Pii , Pis > PP;\n\nint N,M,K;\nint G[32][32];\nint g[32][32];\n\nset< PP > t[32];\nset< PP > u[32][32];\n\nint search(int from,int to){\n  int mini=INF, res=-1;\n  for(int i=0;i<N;i++){\n    if(from!=i && mini > g[from][i] + G[i][to] ){\n      mini=g[from][i]+G[i][to];\n      res=i;\n    }\n  }\n  return res;\n}\n\nvoid init(){\n  for(int i=0;i<32;i++){\n    t[i].clear();\n    for(int j=0;j<32;j++){\n      g[i][j]=(i==j?0:INF);\n      G[i][j]=(i==j?0:INF);\n      u[i][j].clear();\n    }\n  }\n}\n\nint main(){\n  int cnt=0;\n  while(1){\n\n\n    init();\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    if(cnt)cout<<endl;\n    cnt++;\n    \n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      G[a][b]=min(G[a][b],c);\n      G[b][a]=min(G[b][a],c);\n    }\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n    \n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    cin>>K;\n\n    map<int, vector<PP> > mp;\n    set<int> st;\n    \n    for(int i=0;i<K;i++){\n      int from,to,ti;\n      string name;\n      cin>>from>>to>>ti>>name;\n      from--,to--;\n      mp[ti].push_back( PP( Pii(from,to) , Pis(0,name)) );\n      st.insert(ti);\n    }\n\n    vector< Pis > ans;\n    vector<int> v(N,0);\n\n    \n    st.insert(0);\n    while(!st.empty()){\n      int p=*st.begin();\n      if(mp.count(p)){\n        for(int i=0;i<(int)mp[p].size();i++){\n          PP pp=mp[p][i];\n          int from=pp.first.first;\n          int to=pp.first.second;\n          string name=pp.second.second;\n          int key=search(from,to);\n          //          cout<<\"p = \"<<p<<\", from = \"<<from<<\", to = \"<<to<<\", key = \"<<key<<endl;\n          \n          PP tmp=PP( Pii(p, key ) , Pis(to,name) );\n          t[from].insert(tmp);\n          u[from][ key ].insert(tmp);\n        }\n      }\n      \n      for(int i=0;i<N;i++){\n        if(v[i]>p)continue;\n        if(t[i].empty())continue;\n\n        PP target=*t[i].begin();\n        t[i].erase( t[i].begin() );\n        int nex= target.first.second;\n        set< PP > :: iterator it;\n        for( it=u[i][nex].begin(); it!= u[i][nex].end() ; it++ ){\n          PP pp=*it;\n          int to=pp.second.first;\n          string name=pp.second.second;\n          \n          if(to==nex){\n            ans.push_back( Pis( p+g[i][nex] , name ) );\n            continue;\n          }\n\n          mp[ p+g[i][nex] ].push_back( PP(Pii(nex,to),Pis(0,name)) );\n          \n        }// iterator\n        \n        u[i][nex].clear();\n        v[i]=p+g[i][nex]*2;\n        st.insert(v[i]);\n      }// i\n      \n      st.erase( st.begin() );\n    }// st.empty()\n\n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      Pis p=ans[i];\n      cout<<p.second<<' '<<p.first<<endl;\n    }\n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 50\n\nvector<pair<int,int> > way[SIZE];\n\nbool firstcase = true;\n\nstruct DATA{\n  ll t;\n  int id;\n  int now;\n  int next;\n  int goal;\n\n  const bool operator<(const DATA &B) const{\n    if(t != B.t) return t > B.t;\n    if(next != B.next) return next > B.next;\n    return false;\n  }\n\n  DATA(ll t, int id, int now, int next, int goal):\n    t(t), id(id), now(now), next(next), goal(goal){}\n};\n\nint dist[40][40];\nint n;\n\nint getNext(int a, int b){\n  if (a == b) return a;\n  for(int i=0;i<n;i++){\n    if(a != i && dist[a][i] + dist[i][b] == dist[a][b])\n      return i;\n  }\n\n  assert(false);\n  return -1;\n}\n\nbool solve(){\n  int m, q;\n  string text[1000];\n  \n  priority_queue<DATA> pq;\n\n  scanf(\"%d%d\", &n, &m);\n  \n  if(n == 0) return false;\n  if(firstcase) firstcase = false;\n  else puts(\"\");\n  \n  for(int i=0;i<n;i++) way[i] = vector<pair<int,int> > ();\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dist[i][j] = INF;\n    }\n    dist[i][i] = 0;\n  }\n  \n  \n  for(int i=0;i<m;i++){\n    int a, b, c; \n    scanf(\"%d%d%d\", &a, &b, &c);\n    a--; b--;\n\n    dist[a][b] = c;\n    dist[b][a] = c;\n  }\n\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n  \n  scanf(\"%d\", &q);\n\n  for(int i=0;i<q;i++){\n    int a, b, t;\n    char temp[60];\n    scanf(\"%d%d%d%s\", &a, &b, &t, temp);\n    a--; b--;\n    text[i] = temp;\n    \n    pq.push(DATA(t, i, a, getNext(a,b), b));\n  }\n\n  bool outside[40] = {};\n  ll sent[40][40] = {};\n  priority_queue<pair<ll,int> > que[40];\n  queue<DATA> post[40][40];\n  vector<pair<ll,string> > ans;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      sent[i][j] = -1;\n  \n  while(pq.size()){\n    queue<int> work;\n    ll t = pq.top().t;\n\n    while(pq.size() && pq.top().t == t){\n      auto p = pq.top(); pq.pop();\n      if(p.id != -1){\n        if(p.now == p.goal){\n          ans.push_back({p.t, text[p.id]});\n          continue;\n        }\n        \n        post[p.now][p.next].push(p);\n        que[p.now].push({-p.t, -p.next});\n        //cerr << \"[post] \" << t << \" : \" << p.now << \" -> \" << p.next << \" -> \" << p.goal << endl;\n      }else{\n        outside[p.now] = false;\n        //cerr << \"[back] \" << t << \" : \" << p.now << endl;\n      }\n\n      work.push(p.now);\n    }\n    \n\n    while(work.size()){\n      int now = work.front(); work.pop();\n      if(outside[now]) continue;\n      \n      while(que[now].size() && -que[now].top().first <= t){\n        auto p = que[now].top(); que[now].pop();\n\n        if(-p.first <= sent[now][-p.second]) continue;\n        \n        //cerr << now << \" -> \" << -p.second << endl;\n        \n        ll max_t = 0;\n        \n        while(post[now][-p.second].size()){\n          auto p2 = post[now][-p.second].front(); post[now][-p.second].pop();\n          \n          max_t = max(max_t, p2.t);\n\n          p2.t = t + dist[now][-p.second];\n          p2.next = getNext(p2.next, p2.goal);\n          p2.now = -p.second;\n          pq.push(p2);\n        }\n        \n        outside[now] = true;\n        pq.push(DATA((ll)t + dist[now][-p.second]*2, -1, now, -1, -1));\n        sent[now][-p.second] = max(sent[now][-p.second], max_t);\n        break;\n      }\n\n    }\n  }\n\n  sort(ans.begin(), ans.end());\n  \n  for(int i=0;i<ans.size();i++){\n    cout << ans[i].second << \" \" << ans[i].first << endl;\n  }\n  \n  return true;\n}\n\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nint g[40][40];\nint og[40][40];\nconst int MAX = 10000000;\nchar name[1000][52];\nint dist[1000];\n\nenum{\n  RetPeo = 0,\n  SetLet = 1\n};\n\nstruct event{\n  int time;\n  int type;\n  int pos;\n  int id;\n\n  event(int ti, int ty, int po, int i = 0) :\n    time(ti), type(ty), pos(po), id(i){}\n};\n\nbool operator < (const event &lhs, const event &rhs){\n  if(lhs.time != rhs.time) return lhs.time > rhs.time;\n  return lhs.type < rhs.type;\n}\n\nint n, m;\n\nint nextof(int s, int d){\n  if(s == d) return d;\n  REP(i, n) if(i != s && og[s][i] + g[i][d] == g[s][d]) return i;\n  printf(\"error\");\n  return 0;\n}\n\nint main(){\n  bool fst = true;\n  while(scanf(\"%d%d\", &n, &m), n + m){\n    if(!fst) puts(\"\");\n    else fst =false;\n\n\n    REP(i,n) REP(j,n) g[i][j] = MAX;\n    REP(i,n) g[i][i] = 0;\n\n    REP(i,m){\n      int a, b, c;\n      scanf(\"%d%d%d\", &a, &b, &c);\n      g[a - 1][b - 1] = g[b - 1][a - 1] = c;\n    }\n    REP(i,n) REP(j,n) og[i][j] = g[i][j];\n\n    REP(k,n) REP(i,n) REP(j,n)\n      g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\n    int l; scanf(\"%d\", &l);\n    priority_queue<event> pq;\n\n    REP(ll, l){\n      int s, d, t;\n      scanf(\"%d%d%d %s\", &s, &d, &t, name[ll]);\n      dist[ll] = d - 1;\n      pq.push(event(t, SetLet, s - 1, ll));\n    }\n\n    vector<int> last(n, 0);\n    vector<bool> people(n, true);\n    typedef pair<int, pair<int, int> > letter;\n    vector<priority_queue<letter, vector<letter>, greater<letter> > > q(n);\n\n    while(pq.size()){\n      event e = pq.top();\n      int time = e.time;\n      int type = e.type;\n      int pos  = e.pos;\n      int id   = e.id;\n\n      //printf(\"time: %d\\n\", time);\n      //printf(\"type=%d pos=%d id=%d\\n\", type, pos, id);\n\n      vector<string> ans;\n\n      while(pq.size() && pq.top().time == time){\n        event e = pq.top(); pq.pop();\n        int time = e.time;\n        int type = e.type;\n        int pos  = e.pos;\n        int id   = e.id;\n        if(type == RetPeo){\n          people[pos] = true;\n        }else if(type == SetLet){\n          if(dist[id] == pos){\n            ans.push_back(name[id]);\n          }else{\n            //printf(\"%d => %d\\n\", pos, nextof(pos, dist[id]));\n            q[pos].push(letter(time, make_pair(nextof(pos, dist[id]), id)));\n          }\n        }\n      }\n\n      if(ans.size() > 1) sort(ans.begin(), ans.end());\n      REP(i, ans.size()){\n        printf(\"%s %d\\n\", ans[i].c_str(), time);\n      }\n\n      REP(pos, n) if(people[pos]){\n        if(q[pos].size()){\n          int nexttime = q[pos].top().first;\n          int nextpos  = q[pos].top().second.first;\n          while(q[pos].size() && q[pos].top().first == nexttime && q[pos].top().second.first == nextpos){\n            int nt = q[pos].top().first;\n            int np = q[pos].top().second.first;\n            int le = q[pos].top().second.second;\n            q[pos].pop();\n            pq.push(event(time + og[pos][np], SetLet, np, le));\n          }\n          people[pos] = false;\n          last[pos]   = time;\n          pq.push(event(time + 2 * og[pos][nextpos], RetPeo, pos));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\nconst int INF = 1e9;\n\nstruct mail{\n  int time, to, cur, next, id;\n};\n\nbool operator < (const mail &a, const mail &b){\n  if(a.time != b.time) return a.time > b.time;\n  return a.next > b.next;\n}\n\nint main(){\n  int n, m, c = 0;\n  while(cin >> n >> m, n){\n    if(c) cout << endl;\n    ++c;\n    vector< vector<int> > D(n, vector<int>(n, INF));\n    vector< vector<bool> > E(n, vector<bool>(n, false));\n    for(int i = 0; i < m; ++i){\n      int u, v, d;\n      cin >> u >> v >> d;\n      --u;--v;\n      D[u][v] = d;\n      D[v][u] = d;\n      E[u][v] = true;\n      E[v][u] = true;\n    }\n    for(int i = 0; i < n; ++i) D[i][i] = 0;\n    for(int k = 0; k < n; ++k){\n      for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n          D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n        }\n      }\n    }\n\n    vector< vector<int> > next(n, vector<int>(n, -1));\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        for(int k = 0; k < n; ++k){\n          if(D[i][k] + D[k][j] != D[i][j] || !E[i][k]) continue;\n          next[i][j] = k;\n          break;\n        }\n      }\n    }\n\n    int l;\n    cin >> l;\n    vector<string> name(l);\n    priority_queue<mail> que;\n\n    for(int i = 0; i < l; ++i){\n      int from, to, time;\n      cin >> from >> to >> time >> name[i];\n      que.push((mail){time, to-1, from-1, next[from-1][to-1], i});\n    }\n    \n    vector<int> T(n, 0);\n    vector< vector<int> > U(n, vector<int>(n, 0));\n    vector< pair<int, string> > A;\n\n    while(!que.empty()){\n      mail x = que.top();\n      que.pop();\n      if(x.cur == x.to){\n        A.push_back(make_pair(x.time, name[x.id]));\n        continue;\n      }\n      if(U[x.cur][x.next] < x.time){\n        T[x.cur] = max(T[x.cur], x.time);\n        x.time = T[x.cur] + D[x.cur][x.next];\n        U[x.cur][x.next] = T[x.cur];\n        T[x.cur] += 2*D[x.cur][x.next];\n      }else{\n        x.time = U[x.cur][x.next] + D[x.cur][x.next];\n      }\n      x.cur = x.next;\n      x.next = next[x.cur][x.to];\n      que.push(x);\n    }\n    \n    sort(A.begin(), A.end());\n\n    for(int i = 0; i < l; ++i){\n      cout << A[i].second << \" \" << A[i].first << endl;\n    }\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tint tm,pos,dist;\n\tstring name;\n\tpacket(int t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x], &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(int x,int y){\n\tconst packet &a=pac[x], &b = pac[y];\n\treturn a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tstring name;\n\tpriority_queue<int,vector<int>,cmp> qu;\n\tfor(;cin>>n>>m,n;){\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=-1;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n\n\t\tfor(;!qu.empty();){\n\t\t\tint pi = qu.top();\n\t\t\tpacket &p = pac[pi];\n\t\t\tt = p.tm;\n\t\t\tf = p.pos;\n\t\t\tif( f == p.dist ){\n\t\t\t\tqu.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( t < bac[f] ){\n\t\t\t\tp.tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n\t\t\t}else{\n\t\t\t\td = to[f][p.dist];\n\t\t\t\tbac[f] = p.tm + 2 * len[p.pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\tif(qu.empty())return 1;\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket &q = pac[qi];\n\t\t\t\t\tif(t==q.tm && f==q.pos && to[q.pos][q.dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq.tm += len[f][d];\n\t\t\t\t\t\tq.pos = d;\n\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tsort(pac.begin(),pac.end(),cmp2);\n//\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n\t\tfor(j=0;j<l;j++)tbl[j]=j;\n\t\tsort(tbl,tbl+l,cmp2);\n\t\tfor(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),pac[tbl[j]].tm);\n\n\t\t**len = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n#define mp         make_pair\n#define ALL(C)     (C).begin(),(C).end()\n\nconst int N = 32;\nconst int inf = INT_MAX;\nconst int costinf=(1<<21);\n\n\ntypedef struct{string name;int time,tar;}Mail;\n\n\nclass Postman{\npublic:\n  int time,tar;\n  vector<Mail> mail;\n};\n\n\nint cost[N][N];\nint edge[N][N];//costinf\nint next[N][N];\nvoid wf(int n){\n  rep(i,n)rep(j,n)cost[i][j]=edge[i][j];\n  rep(k,n)rep(i,n)rep(j,n)cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n  rep(i,n){\n    rep(j,n){\n      next[i][j]=100;\n      if (i == j)continue;\n      rep(k,n){\n\tif (i == k)continue;\n\tif (edge[i][k] == costinf)continue;\n\tif (cost[i][j] == edge[i][k]+cost[k][j]){\n\t  next[i][j]=k;\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nclass Postoffice{\npublic:\n  vector<Mail> mail;\n  int find_next_time(int node,int now){\n    int mintime=inf;\n    rep(i,mail.size()){\n      if (mail[i].time < now)return 0;\n      else mintime=min(mintime,mail[i].time);\n    }\n    return mintime;\n  }\n\n  void set_man(int node,int now,Postman &man){\n    int mintime=inf,mindex=100;\n    rep(i,mail.size()){\n      if (mail[i].time > now)continue;\n      if (mail[i].time < mintime || \n\t  (mintime == mail[i].time && next[node][mail[i].tar] < mindex)){\n\tmintime=mail[i].time;\n\tmindex =next[node][mail[i].tar];\n      }\n    }\n    \n    if (mindex == 100)return;\n\n    rep(i,mail.size()){\n      if (mail[i].time > now)continue;\n      if (next[node][mail[i].tar] == mindex){\n\tman.mail.pb(mail[i]);\n\tmail.erase(mail.begin()+i);\n\ti--;\n      }\n    }\n\n    man.time=edge[node][mindex];\n    man.tar =mindex;\n  }\n};\n\n\nvoid solve(int n,Postman *man,Postoffice *office){\n  vector<pair<int ,string> > ans;\n  int t = 0;\n\n  //initialization\n  wf(n);\n\n  while(true){\n    int minevent=inf;\n    \n    // arrive\n    rep(i,n){\n      if (man[i].tar != -1)minevent=min(minevent,man[i].time);\n    }\n\n    rep(i,n){\n      if (man[i].tar == -1){\n\tminevent=min(office[i].find_next_time(i,t),minevent);\n      }\n    }\n\n    if (minevent == inf)break;\n\n    t+=minevent;\n    \n    rep(i,n){\n      if (man[i].tar != -1){\n\tman[i].time-=minevent;\n\tif (man[i].time == 0){\n\t  if (man[i].tar != i){\n\t    rep(j,man[i].mail.size()){\n\t      if (man[i].tar == man[i].mail[j].tar){\n\t\tans.pb(mp(t,man[i].mail[j].name));\n\t      }\n\t      else {\n\t\tman[i].mail[j].time=t;\n\t\toffice[man[i].tar].mail.pb(man[i].mail[j]);\n\t      }\n\t    }\n\t    man[i].mail.clear();\n\t    man[i].time=edge[man[i].tar][i];\n\t    man[i].tar=i;\n\t  }else if (man[i].tar == i){\n\t    man[i].tar=-1;\n\t  }\n\t}\n      }\n    }\n\n    rep(i,n){\n      if (man[i].tar != -1)continue;\n      office[i].set_man(i,t,man[i]);\n    }\n  }\n\n  sort(ALL(ans));\n  rep(i,ans.size()){\n    cout << ans[i].second <<\" \" << ans[i].first << endl;\n  }\n}\n\nmain(){\n  int n,m;\n  int te=0;\n  while(cin>>n>>m && n){\n    if (te)cout<<endl;\n    te++;\n    rep(i,n){\n      rep(j,n)edge[i][j]=costinf;\n      edge[i][i]=0;\n    }\n    Postman    man[n];\n    Postoffice     office[n];\n    rep(i,n)man[i].tar=-1;\n    \n    \n    rep(i,m){\n      int f,t,c;\n      cin>>f>>t>>c;\n      f--;t--;\n      edge[f][t]=edge[t][f]=c;\n    }\n    \n    int l;\n    cin>>l;\n    rep(i,l){\n      int fr,to,ti;\n      string name;\n      cin>>fr>>to>>ti>>name;\n      office[fr-1].mail.pb((Mail){name,ti,to-1});\n    }\n    \n    solve(n,man,office);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cost;\n  Edge() {}\n  Edge(int s, int d, int c) : src(s), dst(d), cost(c) {}\n};\n\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nstruct Event{\n  int type;\n  int time;\n  int latter;\n  int office;\n  Event(int ty, int t, int l, int o) : \n    type(ty), time(t), latter(l), office(o) {}\n  bool operator < (const Event& e) const {\n    if(time != e.time) return time < e.time;\n    if(type != e.type) return type < e.type;\n    if(office != e.office) return office < e.office;\n    return latter < e.latter;\n  }\n  bool operator > (const Event& e) const {\n    if(time != e.time) return time > e.time;\n    if(type != e.type) return type > e.type;\n    if(office != e.office) return office > e.office;\n    return latter > e.latter;\n  }\n};\nstruct Latter{\n  string name;\n  int src, dst;\n};\ntypedef pair<int, string> P;\nvoid print(Event& e){\n  //printf(\"type %d time %d latter %d office %d\\n\", e.type, e.time, e.latter, e.office);\n}\n\nvoid do_send(Event& e, deque<Event>& lq, priority_queue<Event, vector<Event>, greater<Event> >& que, int dist[36][36], vector<bool>& wait){\n  /*\n  printf(\"do_send : lq is\\n\");\n  REP(i, lq.size()) print(lq[i]);\n  cout << endl;\n  */\n  Event se = lq.front(); lq.pop_front();\n  assert(se.office != e.office);\n  assert(dist[e.office][se.office] > 0);\n  assert(dist[e.office][se.office] < INF);\n  assert(e.time + dist[e.office][se.office] > 0);\n  assert(e.time + dist[e.office][se.office] < INF);\n  que.push(Event(0, e.time + dist[e.office][se.office], se.latter, se.office));\n  //printf(\"send : \"); print(se);\n  for(deque<Event>::iterator it = lq.begin(); it != lq.end(); ){\n    if(it->office == se.office){\n      que.push(Event(0, e.time + dist[e.office][se.office], it->latter, se.office));\n      //printf(\"send2 : \"); print(*it);\n      it = lq.erase(it);\n    }else{\n      it++;\n    }\n  }\n  que.push(Event(1, e.time + 2 * dist[e.office][se.office], -1, e.office));\n  wait[e.office] = false;\n}\nint main(){\n  int N, M;\n  bool first = true;\n  while(cin >> N >> M && N){\n\n    if(first) first = false;\n    else cout << endl;\n\n    Graph G(N);\n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      G[a].push_back(Edge(a, b, c));\n      G[b].push_back(Edge(b, a, c));\n    }\n    int dist[36][36] = {};\n    REP(i, N) REP(j, N) dist[i][j] = (i != j) ? INF : 0;\n    REP(i, N) FORIT(e, G[i]) dist[e->src][e->dst] = e->cost;\n    REP(k, N) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    // next[i][j] := 現在地i, 目的地jの郵便物の次の行き先\n    int next[36][36] = {};\n    memset(next, -1, sizeof(next));\n    REP(i, N) REP(j, N) if(i != j && !G[i].empty()){\n      next[i][j] = G[i][0].dst;\n      int n_cost = G[i][0].cost + dist[G[i][0].dst][j];\n      int edge_cost = G[i][0].cost;\n      FORIT(e, G[i]){\n        if(make_pair(n_cost, next[i][j]) > make_pair(e->cost + dist[e->dst][j], e->dst)){\n          n_cost = e->cost + dist[e->dst][j];\n          next[i][j] = e->dst;\n          edge_cost = e->cost;\n        }\n      }\n      assert(edge_cost == dist[i][next[i][j]]);\n    }\n    //REP(i, N) REP(j, N) printf(\"next[%d][%d] = %d\\n\", i, j, next[i][j]);\n\n    int L; cin >> L;\n    vector<Latter> latters(L);\n    priority_queue<Event, vector<Event>, greater<Event> > que;\n    vector< deque<Event> > l_que(N);\n    REP(i, L){\n      int time;\n      cin >> latters[i].src >> latters[i].dst >> time >> latters[i].name;\n      latters[i].src--; latters[i].dst--;\n      que.push(Event(0, time, i, latters[i].src));\n    }\n    vector<P> answer;\n    vector<bool> wait(N, true);\n    while(!que.empty()){\n      Event e = que.top(); que.pop();\n      print(e);\n      deque<Event>& lq = l_que[e.office];\n      if(e.type == 0){\n        Latter& l = latters[e.latter];\n        if(l.dst == e.office){\n          answer.push_back(P(e.time, l.name));\n        }else{\n          int to = next[e.office][l.dst];\n          assert(to != -1);\n          Event send(0, e.time, e.latter, to);\n          lq.insert(lower_bound(lq.begin(), lq.end(), send), send);\n          // send\n          if(wait[e.office] && (que.empty() || e.time != que.top().time || e.office != que.top().office)){\n            do_send(e, lq, que, dist, wait);\n          }\n        }\n      }else if(e.type == 1){\n        wait[e.office] = true;\n        if(!lq.empty()){\n          do_send(e, lq, que, dist, wait);\n        }\n      }\n    }\n    REP(i, N) assert(wait[i]);\n    REP(i, N) assert(l_que[i].empty());\n    sort(answer.begin(), answer.end());\n    assert(answer.size() == latters.size());\n    REP(i, answer.size()){\n      printf(\"%s %d\\n\", answer[i].second.c_str(), answer[i].first);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<26)\n \ntypedef pair<int,int> Pii;\ntypedef pair<int,string> Pis;\ntypedef pair< Pii , Pis > PP;\n \nint N,M,K;\nint G[32][32];\nint g[32][32];\nint mem[32][32];\n\nset< PP > t[32];\nset< PP > u[32][32];\n \nint search(int from,int to){\n  int mini=INF, res=-1;\n  if( mem[from][to]!=-1)\n    return mem[from][to];\n  \n  for(int i=0;i<N;i++){\n    if(from!=i && mini > g[from][i] + G[i][to] ){\n      mini=g[from][i]+G[i][to];\n      res=i;\n    }\n  }\n\n  mem[from][to]=res;\n  return res;\n}\n \nvoid init(){\n  for(int i=0;i<32;i++){\n    assert(t[i].empty());\n    t[i].clear();\n    for(int j=0;j<32;j++){\n      g[i][j]=(i==j?0:INF);\n      G[i][j]=(i==j?0:INF);\n      assert(u[i][j].empty());\n      u[i][j].clear();\n      mem[i][j]=-1;\n    }\n  }\n}\n \nint main(){\n  int cnt=0;\n  while(1){\n \n \n    init();\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    if(cnt)cout<<endl;\n    cnt++;\n     \n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      G[a][b]=min(G[a][b],c);\n      G[b][a]=min(G[b][a],c);\n    }\n     \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n     \n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n     \n    cin>>K;\n \n    map<int, vector<PP> > mp;\n    set<int> st;\n     \n    for(int i=0;i<K;i++){\n      int from,to,ti;\n      string name;\n      cin>>from>>to>>ti>>name;\n      from--,to--;\n      mp[ti].push_back( PP( Pii(from,to) , Pis(0,name)) );\n      st.insert(ti);\n    }\n \n    vector< Pis > ans;\n    vector<int> v(N,0);\n \n     \n    st.insert(0);\n    while(!st.empty()){\n      int p=*st.begin();\n      if(mp.count(p)){\n        for(int i=0;i<(int)mp[p].size();i++){\n          PP pp=mp[p][i];\n          int from=pp.first.first;\n          int to=pp.first.second;\n          string name=pp.second.second;\n          int key=search(from,to);\n           \n          PP tmp=PP( Pii(p, key ) , Pis(to,name) );\n          t[from].insert(tmp);\n          u[from][ key ].insert(tmp);\n        }\n      }\n       \n      for(int i=0;i<N;i++){\n        if(v[i]>p)continue;\n        if(t[i].empty())continue;\n \n        PP target=*t[i].begin();\n\n        int nex= target.first.second;\n        set< PP > :: iterator it;\n        for( it=u[i][nex].begin(); it!= u[i][nex].end() ; it++ ){\n          PP pp=*it;\n          int to=pp.second.first;\n          string name=pp.second.second;\n\n          assert( t[i].count(pp) );\n          t[i].erase(pp);\n          \n          if(to==nex){\n            ans.push_back( Pis( p+g[i][nex] , name ) );\n            continue;\n          }\n \n          mp[ p+g[i][nex] ].push_back( PP(Pii(nex,to),Pis(0,name)) );\n           \n        }// iterator\n         \n        u[i][nex].clear();\n        v[i]=p+g[i][nex]*2;\n        st.insert(v[i]);\n      }// i\n       \n      st.erase( st.begin() );\n    }// st.empty()\n \n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      Pis p=ans[i];\n      cout<<p.second<<' '<<p.first<<endl;\n    }\n  }\n \n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<26)\n \ntypedef pair<int,int> Pii;\ntypedef pair<int,string> Pis;\ntypedef pair< Pii , Pis > PP;\n \nint N,M,K;\nint G[32][32];\nint g[32][32];\nint mem[32][32];\n\nset< PP > t[32];\nset< PP > u[32][32];\n \nint search(int from,int to){\n  int mini=INF, res=-1;\n  if( mem[from][to]!=-1)\n    return mem[from][to];\n  \n  for(int i=0;i<N;i++){\n    if(from!=i && mini > g[from][i] + G[i][to] ){\n      mini=g[from][i]+G[i][to];\n      res=i;\n    }\n  }\n\n  mem[from][to]=res;\n  return res;\n}\n \nvoid init(){\n  for(int i=0;i<32;i++){\n    assert(t[i].empty());\n    t[i].clear();\n    for(int j=0;j<32;j++){\n      g[i][j]=(i==j?0:INF);\n      G[i][j]=(i==j?0:INF);\n      assert(u[i][j].empty());\n      u[i][j].clear();\n      mem[i][j]=-1;\n    }\n  }\n}\n \nint main(){\n  int cnt=0;\n  while(1){\n \n \n    init();\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    if(cnt)cout<<endl;\n    cnt++;\n     \n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      G[a][b]=min(G[a][b],c);\n      G[b][a]=min(G[b][a],c);\n    }\n     \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n     \n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n     \n    cin>>K;\n \n    map<int, vector<PP> > mp;\n    set<int> st;\n     \n    for(int i=0;i<K;i++){\n      int from,to,ti;\n      string name;\n      cin>>from>>to>>ti>>name;\n      from--,to--;\n      mp[ti].push_back( PP( Pii(from,to) , Pis(0,name)) );\n      st.insert(ti);\n    }\n \n    vector< Pis > ans;\n    vector<int> v(N,0);\n \n     \n    st.insert(0);\n    while(!st.empty()){\n      int p=*st.begin();\n      if(mp.count(p)){\n        for(int i=0;i<(int)mp[p].size();i++){\n          PP pp=mp[p][i];\n          int from=pp.first.first;\n          int to=pp.first.second;\n          string name=pp.second.second;\n          int key=search(from,to);\n           \n          PP tmp=PP( Pii(p, key ) , Pis(to,name) );\n          t[from].insert(tmp);\n          u[from][ key ].insert(tmp);\n        }\n      }\n      mp[p].clear();\n      \n      for(int i=0;i<N;i++){\n        if(v[i]>p)continue;\n        if(t[i].empty())continue;\n \n        PP target=*t[i].begin();\n\n        int nex= target.first.second;\n        set< PP > :: iterator it;\n        for( it=u[i][nex].begin(); it!= u[i][nex].end() ; it++ ){\n          PP pp=*it;\n          int to=pp.second.first;\n          string name=pp.second.second;\n\n          assert( t[i].count(pp) );\n          t[i].erase(pp);\n          \n          if(to==nex){\n            ans.push_back( Pis( p+g[i][nex] , name ) );\n            continue;\n          }\n \n          mp[ p+g[i][nex] ].push_back( PP(Pii(nex,to),Pis(0,name)) );\n           \n        }// iterator\n         \n        u[i][nex].clear();\n        v[i]=p+g[i][nex]*2;\n        st.insert(v[i]);\n      }// i\n       \n      st.erase( st.begin() );\n    }// st.empty()\n \n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      Pis p=ans[i];\n      cout<<p.second<<' '<<p.first<<endl;\n    }\n  }\n \n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nconstexpr int inf = numeric_limits<int>::max();\n\nstruct edge {\n    int from, to, cost;\n    edge(int f, int t, int c) : from(f), to(t), cost(c) {}\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nvoid add_edge(graph& g, int from, int to, int cost) {\n    g[from].emplace_back(from, to, cost);\n    g[to].emplace_back(to, from, cost);\n}\n\nvector<int> dijkstra(graph const& g, int s) {\n    const int n = g.size();\n    vector<int> dist(n, inf / 2);\n    dist[s] = 0;\n    priority_queue<pii, vector<pii>, greater<>> que;\n    que.emplace(0, s);\n    while(!que.empty()) {\n        int cur_d, v; tie(cur_d, v) = que.top();\n        que.pop();\n        if(cur_d > dist[v]) continue;\n        for(auto const& e : g[v]) {\n            if(dist[e.to] > dist[v] + e.cost) {\n                dist[e.to] = dist[v] + e.cost;\n                que.emplace(dist[e.to], e.to);\n            }\n        }\n    }\n    return dist;\n}\n\nedge calc_next_v(graph const& g, int s, int t) {\n    const auto from_s = dijkstra(g, s);\n    const auto from_t = dijkstra(g, t);\n    edge res{s, inf, -1};\n    for(auto const& e : g[s]) {\n        if(from_s[e.from] + e.cost + from_t[e.to] == from_s[t] && res.to > e.to) {\n            res = e;\n        }\n    }\n    return res;\n}\n\nstruct packet {\n    string name;\n    int to;\n    packet(string n, int t) : name(n), to(t) {}\n};\n\nstruct event {\n    int from, time;\n    packet pkt;\n    event(int f, int t, packet p) : from(f), time(t), pkt(p) {}\n    bool operator>(const event& e) const {\n        return time > e.time;\n    }\n};\n\nstruct postman {\n    int idx, cur, dst, remain, ecost;\n    vector<packet> ps;\n    postman(int i) : idx(i), cur(i), dst(-1), remain(0), ecost(-1) {}\n\n    void move(int cur_t, int t, vector<vector<event>>& tasks, vector<pair<int, string>>& ans) {\n        while(t != 0 && dst != -1) {\n            const int use = min(remain, t);\n            remain -= use, t -= use;\n            cur_t += use;\n            if(remain == 0) {\n                cur = dst;\n                dst = -1;\n                for(auto const& p : ps) {\n                    if(p.to == cur) {\n                        ans.emplace_back(cur_t, p.name);\n                    } else {\n                        tasks[cur].emplace_back(cur, cur_t, p);\n                    }\n                }\n                ps.clear();\n                if(cur != idx) { // return to original\n                    dst = idx;\n                    remain = ecost;\n                }\n            }\n        }\n        assert(t >= 0);\n    }\n};\n\nint main() {\n    int n, m;\n    bool first = true;\n    while(cin >> n >> m, n) {\n        if(!first) cout << '\\n';\n        first = false;\n\n        graph g(n);\n        for(int i = 0; i < m; ++i) {\n            int f, t, cost; cin >> f >> t >> cost;\n            f--, t--;\n            add_edge(g, f, t, cost);\n        }\n        vector<vector<edge>> sg(n);\n        for(int s = 0; s < n; ++s) {\n            for(int t = 0; t < n; ++t) {\n                sg[s].push_back(calc_next_v(g, s, t));\n            }\n        }\n        int l; cin >> l;\n        vector<event> ev;\n        for(int i = 0; i < l; ++i) {\n            int s, t, time; cin >> s >> t >> time;\n            string name; cin >> name;\n            s--, t--;\n            ev.emplace_back(s, time, packet{name, t});\n        }\n        sort(begin(ev), end(ev), greater<>{});\n\n        vector<postman> man;\n        for(int i = 0; i < n; ++i) {\n            man.emplace_back(i);\n        }\n        int cur_t = 0;\n        vector<vector<event>> tasks(n);\n        vector<pair<int, string>> ans;\n        auto is_finished = [&] () {\n            if(!ev.empty()) return false;\n            for(auto const& t : tasks) {\n                if(!t.empty()) return false;\n            }\n            for(auto const& p : man) {\n                if(p.dst != -1) return false;\n            }\n            return true;\n        };\n        while(!is_finished()) {\n            //cout << \"cur_t: \" << cur_t << endl;\n            // determine next time\n            int nxt_t = inf;\n            for(auto const& p : man) {\n                if(p.dst == -1) continue;\n                nxt_t = min(nxt_t, cur_t + p.remain);\n            }\n            if(!ev.empty()) nxt_t = min(nxt_t, ev.back().time);\n            //cout << \"ev.sz: \" << ev.size() << endl;\n            //cout << \"elapsed: \" << nxt_t - cur_t << endl;\n\n            // first, resolve task\n            while(!ev.empty() && ev.back().time == nxt_t) {\n                tasks[ev.back().from].push_back(ev.back());\n                ev.pop_back();\n            }\n\n            // second, resolve postman\n            for(int i = 0; i < n; ++i) {\n                man[i].move(cur_t, nxt_t - cur_t, tasks, ans);\n            }\n            for(int i = 0; i < n; ++i) {\n                // returned to original office\n                if(man[i].dst != -1) continue;\n                if(!tasks[i].empty()) {\n                    vector<event> nxt_ts;\n                    int min_time = inf, min_to = inf, ecost = -1;\n                    for(auto const& t : tasks[i]) {\n                        if(make_pair(min_time, min_to) > make_pair(t.time, sg[i][t.pkt.to].to)) {\n                            min_time = t.time;\n                            min_to = sg[i][t.pkt.to].to;\n                            ecost = sg[i][t.pkt.to].cost;\n                        }\n                    }\n                    assert(ecost >= 1);\n                    man[i].remain = man[i].ecost = ecost;\n                    man[i].dst = min_to;\n                    for(auto const& t : tasks[i]) {\n                        if(sg[i][t.pkt.to].to == min_to) {\n                            man[i].ps.push_back(t.pkt);\n                        } else {\n                            nxt_ts.push_back(t);\n                        }\n                    }\n                    tasks[i] = move(nxt_ts);\n                }\n            }\n            cur_t = nxt_t;\n        }\n\n        //cout << \"finished: \" << endl;\n        sort(begin(ans), end(ans));\n        for(auto const& p : ans) {\n            cout << p.second << \" \" << p.first << '\\n';\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n#define mp         make_pair\n#define ALL(C)     (C).begin(),(C).end()\n\nconst int N = 32;\nconst int inf = INT_MAX;\nconst int costinf=(1<<21);\n\n\ntypedef struct{string name;int time,tar;}Mail;\n\n\nclass Postman{\npublic:\n  int time,tar;\n  vector<Mail> mail;\n};\n\n\nint cost[N][N];\nint edge[N][N];//costinf\nint next[N][N];\nvoid wf(int n){\n  rep(i,n)rep(j,n)cost[i][j]=edge[i][j];\n  rep(k,n)rep(i,n)rep(j,n)cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n  rep(i,n){\n    rep(j,n){\n      next[i][j]=100;\n      if (i == j)continue;\n      rep(k,n){\n\tif (i == k)continue;\n\tif (edge[i][k] == costinf)continue;\n\tif (cost[i][j] == edge[i][k]+cost[k][j]){\n\t  next[i][j]=k;\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nclass Postoffice{\npublic:\n  vector<Mail> mail;\n  int find_next_time(int node,int now){\n    int mintime=inf,mindex=100;\n    rep(i,mail.size()){\n      if (mintime == inf || next[node][mail[i].tar] < mindex){\n\tmintime=mail[i].time-now;\n\tmindex =next[node][mail[i].tar];\n      }\n    }\n    return mintime;\n  }\n\n  void set_man(int node,int now,Postman &man){\n    int mintime=inf,mindex=100,mingo=inf;\n    rep(i,mail.size()){\n      if (mail[i].time > now)continue;\n      if (mintime == inf || next[node][mail[i].tar] < mindex){\n\tmintime=mail[i].time-now;\n\tmingo  =edge[node][next[node][mail[i].tar]];\n\tmindex =next[node][mail[i].tar];\n      }\n    }\n    \n    if (mindex == 100)return;\n    \n    rep(i,mail.size()){\n      if (mail[i].time > mintime+now)continue;\n      if (next[node][mail[i].tar] == mindex){\n\tman.mail.pb(mail[i]);\n\tmail.erase(mail.begin()+i);\n\ti--;\n      }\n    }\n    //    cout << \"set_man \" << node <<\" \" << now <<\" \" << mindex <<\" \" << mail.size() << endl;\n    man.time=mingo;\n    man.tar=mindex;\n  }\n};\n\n\nvoid solve(int n,Postman *man,Postoffice *office){\n  vector<pair<string,int> > ans;\n  int t = 0;\n\n  //initialization\n  wf(n);\n\n  while(true){\n    int minevent=inf;\n    \n    // arrive\n    rep(i,n){\n      if (man[i].tar != -1)minevent=min(minevent,man[i].time);\n    }\n\n    rep(i,n){\n      //      cout << \"man \" << i <<\" \" << man[i].tar <<\" \" << man[i].time << endl;\n    }\n    \n    rep(i,n){\n      if (man[i].tar == -1){\n\tminevent=min(office[i].find_next_time(i,t),minevent);\n      }\n    }\n\n    //    cout << t <<\" \" << minevent << endl;\n    if (minevent == inf)break;\n\n    t+=minevent;\n    \n    rep(i,n){\n      if (man[i].tar != -1){\n\tman[i].time-=minevent;\n\tif (man[i].time == 0){\n\t  if (man[i].tar != i){\n\t    rep(j,man[i].mail.size()){\n\t      if (man[i].tar == man[i].mail[j].tar){\n\t\tans.pb(mp(man[i].mail[j].name,t));\n\t      }\n\t      else office[man[i].tar].mail.pb(man[i].mail[j]);\n\t    }\n\t    man[i].mail.clear();\n\t    man[i].time=cost[man[i].tar][i];\n\t    man[i].tar=i;\n\t  }else if (man[i].tar == i){\n\t    man[i].tar=-1;\n\t  }\n\t}\n      }\n    }\n\n    //    cout <<\"check\" <<endl;\n    rep(i,n){\n      if (man[i].tar != -1)continue;\n      office[i].set_man(i,t,man[i]);\n    }\n    //    cout <<\"check 2 \"<<endl;\n  }\n\n\n\n  sort(ALL(ans));\n  rep(i,ans.size()){\n    cout << ans[i].first <<\" \" << ans[i].second << endl;\n  }\n}\n\nmain(){\n  int n,m;\n  int te=0;\n  while(cin>>n>>m && n){\n    if (te)cout<<endl;\n    te++;\n    rep(i,n){\n      rep(j,n)edge[i][j]=costinf;\n      edge[i][i]=0;\n    }\n    Postman    man[n];\n    Postoffice     office[n];\n    rep(i,n)man[i].tar=-1;\n    \n    \n    rep(i,m){\n      int f,t,c;\n      cin>>f>>t>>c;\n      f--;t--;\n      edge[f][t]=edge[t][f]=c;\n    }\n    \n    int l;\n    cin>>l;\n    rep(i,l){\n      int fr,to,ti;\n      string name;\n      cin>>fr>>to>>ti>>name;\n      office[fr-1].mail.pb((Mail){name,ti,to-1});\n    }\n    \n    solve(n,man,office);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tint tm,pos,dist;\n\tstring name;\n\tpacket(int t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x], &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(int x,int y){\n\tconst packet &a=pac[x], &b = pac[y];\n\treturn a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tstring name;\n\tpriority_queue<int,vector<int>,cmp> qu;\n\tfor(;cin>>n>>m,n;){\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=-1;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n\n\t\tfor(;!qu.empty();){\n\t\t\tint pi = qu.top();\n\t\t\tpacket &p = pac[pi];\n\t\t\tt = p.tm;\n\t\t\tf = p.pos;\n\t\t\tif( f == p.dist ){\n\t\t\t\tqu.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( t < bac[f] ){\n\t\t\t\tp.tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n\t\t\t}else{\n\t\t\t\tint zzz=0;\n\t\t\t\td = to[f][p.dist];\n\t\t\t\tbac[f] = p.tm + 2 * len[p.pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket &q = pac[qi];\n\t\t\t\t\tif(t==q.tm && f==q.pos && to[q.pos][q.dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq.tm += len[f][d];\n\t\t\t\t\t\tq.pos = d;\n\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t\t++zzz;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tif(!zzz||qu.empty())return 1;\n\t\t\t}\n\t\t}\n//\t\tsort(pac.begin(),pac.end(),cmp2);\n//\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n\t\tfor(j=0;j<l;j++)tbl[j]=j;\n\t\tsort(tbl,tbl+l,cmp2);\n\t\tfor(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),pac[tbl[j]].tm);\n\n\t\t**len = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif // !_WIN32\n\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<iomanip>\n#include<map>\n#include<stack>\n#include<queue>\n#include<utility>\nusing namespace std;\ntypedef long long LL;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\ntypedef pair<LL, string> P;\ntypedef vector<int> V;\ntypedef vector<V> VV;\n//input\nint n, m, l;\nint c[32][32];\nstring label[1123];\nint bg_pos[1123];\nint ed_pos[1123];\nLL bg_time[1123];\n\n\nLL d[32][32];\nint nxt[32][32];\n\nconst LL INF = 1e15;\n\nint exist[32];\nvector<VV> post(32,VV(32));\nLL min_time[32][32];\ntypedef pair<LL, int> pli;\ntemplate<typename T>\nbool chmin(T &a, T b) { bool f = a > b; if (f)a = b; return f; }\nmap<LL, vector<pair<int,int>>> sc;\nvoid sync(LL now_time,vector<P>& answer) {\n\tREP(from, n)if(exist[from]) {\n\t\tpli res(INF,-1);\n\t\tREP(j, n)chmin(res, { min_time[from][j],j });\n\t\tint to = res.second;\n\t\tif (to != -1) {\n\t\t\texist[from] = 0;\n\t\t\tLL next_time = now_time + c[from][to];\n\t\t\tV &now_post = post[from][to];\n\t\t\twhile (now_post.size()) {\n\t\t\t\tint now_item = now_post.back();\n\t\t\t\tif (ed_pos[now_item] == to)\n\t\t\t\t\tanswer.push_back({ next_time,label[now_item] });\n\t\t\t\telse {\n\t\t\t\t\tsc[next_time].push_back({ to,now_item });\n\t\t\t\t\t//cout << label[now_item] << \" \" << from << \"->\" << to << endl;\n\t\t\t\t}\n\t\t\t\tnow_post.pop_back();\n\t\t\t}\n\t\t\tmin_time[from][to] = INF;\n\t\t\tnext_time += c[to][from];\n\t\t\tsc[next_time].push_back({ from,-1 });\n\t\t}\n\t}\n}\nLL clean(LL now_time) {\n\tauto it = sc.upper_bound(now_time);\n\tif (it == sc.end())return -1;\n\tnow_time = it->first;\n\twhile (it->second.size()) {\n\t\tint id = it->second.back().second;\n\t\tint pos = it->second.back().first;\n\t\tif (id == -1)exist[pos] = 1;\n\t\telse {\n\t\t\tint to = nxt[pos][ed_pos[id]];\n\t\t\tchmin(min_time[pos][to], now_time);\n\t\t\tpost[pos][to].push_back(id);\n\t\t}\n\t\tit->second.pop_back();\n\t}\n\treturn now_time;\n}\n\nvoid init() {\n\tsc.clear();\n\tREP(i, 32)REP(j, 32)c[i][j] = -1;\n\tREP(i, 32)REP(j, 32) {\n\t\td[i][j] = INF;\n\t\tnxt[i][j] = -1;\n\t}\n\tREP(i, 32) {\n\t\texist[i] = 1;\n\t\tREP(j,32)post[i][j].clear();\n\t\tREP(j,32)min_time[i][j] = INF;\n\t}\n}\n\nvoid set_nxt(){\n\tREP(t, n) {\n\t\tbool update = true;\n\t\td[t][t] = 0;\n\t\twhile (update) {\n\t\t\tupdate = false;\n\t\t\tREP(i, n)REP(j, n) if(c[i][j]!=-1){\n\t\t\t\tLL nxt_cost = d[i][t] + c[i][j];\n\t\t\t\tif (d[j][t] > nxt_cost) {\n\t\t\t\t\tupdate = true;\n\t\t\t\t\td[j][t] = nxt_cost;\n\t\t\t\t\tnxt[j][t] = i;\n\t\t\t\t}\n\t\t\t\tif (d[j][t] == nxt_cost) {\n\t\t\t\t\tnxt[j][t] = min(nxt[j][t], i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> n >> m, n + m) {\n\t\tinit();\n\t\tREP(i, m) {\n\t\t\tint a, b, x;\n\t\t\tcin >> a >> b >> x;\n\t\t\ta--, b--;\n\t\t\tc[a][b] = c[b][a] = x;\n\t\t}\n\t\tvector<P> res;\n\t\tset_nxt();\n\t\tcin >> l;\n\t\tREP(i, l) {\n\t\t\tcin >> bg_pos[i] >> ed_pos[i] >> bg_time[i] >> label[i];\n\t\t\tbg_pos[i]--;\n\t\t\ted_pos[i]--;\n\t\t\tsc[bg_time[i]].push_back({ bg_pos[i],i });\n\t\t}\n\t\tLL nt = 0;\n\t\twhile (true) {\n\t\t\tnt = clean(nt);\n\t\t\tif (nt == -1)break;\n\t\t\tsync(nt, res);\n\t\t}\n\n\t\tsort(ALL(res));\n\t\tfor (auto &it : res)cout << it.second << \" \" << it.first << endl;\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tlong long tm;\n\tint pos,dist;\n\tstring name;\n\tpacket(long long t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x], &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(int x,int y){\n\tconst packet &a=pac[x], &b = pac[y];\n\treturn a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tlong long time;\n\tstring name;\n\tpriority_queue<int,vector<int>,cmp> qu;\n\tfor(;cin>>n>>m,n;){\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=-1;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n\n\t\tfor(;!qu.empty();){\n\t\t\tint pi = qu.top();\n\t\t\tpacket &p = pac[pi];\n\t\t\ttime = p.tm;\n\t\t\tf = p.pos;\n\t\t\tif( f == p.dist ){\n\t\t\t\tqu.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( time < bac[f] ){\n\t\t\t\tp.tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n\t\t\t}else{\n\t\t\t\td = to[f][p.dist];\n\t\t\t\tbac[f] = p.tm + 2 * len[p.pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket &q = pac[qi];\n\t\t\t\t\tif(time==q.tm && f==q.pos && to[q.pos][q.dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq.tm += len[f][d];\n\t\t\t\t\t\tq.pos = d;\n\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tsort(pac.begin(),pac.end(),cmp2);\n//\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n\t\tfor(j=0;j<l;j++)tbl[j]=j;\n\t\tsort(tbl,tbl+l,cmp2);\n\t\tfor(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),(int)pac[tbl[j]].tm);\n\n\t\t**len = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  06:38 - 03:41\n */\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cassert>\n#include<climits>\n#include<cstdio>\n#include<cmath>\n#include<map>\n#include<set>\n#include<deque>\n  \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define LLINF (LLONG_MAX)\n#define MAX_V 33\n#define MAX_E 500\n#define all(n) begin(n),end(n)\n  \nusing namespace std;\n  \nconst bool DEBUG = false;\n  \ntypedef long long ll;\ntypedef pair<int,string> is;\n  \nstruct Data{\n  ll to,cost;\n  Data(ll to=-1,ll cost=-1):to(to),cost(cost){}\n  bool operator < (const Data& data)const { return cost > data.cost; }\n};\n  \nstruct Object{\n  ll from,to,timer;\n  string label;\n  ll priority;\n  Object(ll from=-1,ll to=-1,ll timer=-1,string label=\"\",ll priority=-1):from(from),to(to),timer(timer),label(label),priority(priority){}\n  bool operator < (const Object& obj)const {\n    if(priority != obj.priority)return priority < obj.priority;\n    if( timer != obj.timer )return timer < obj.timer;\n    return to < obj.to;\n  }\n};\n  \nvector<Data> G[MAX_V];\nll mincost[MAX_V][MAX_V];\nll pre[MAX_V][MAX_V];\nll V,E,clist[MAX_V][MAX_V];\n  \nvoid dijkstra(){\n  rep(i,V)REP(j,i,V)mincost[i][j] = mincost[j][i] = pre[i][j] = pre[j][i] = LLINF;\n  rep(goal,V){\n    mincost[goal][goal] = 0;\n    priority_queue<Data> Q;\n    Q.push(Data(goal,0));\n    while(!Q.empty()){\n      Data data = Q.top(); Q.pop();\n      ll cur = data.to;\n      ll cost = data.cost;\n      if( mincost[cur][goal] < cost )continue;\n      rep(i,(int)G[cur].size()){\n    ll next = G[cur][i].to;\n    ll ncost = G[cur][i].cost;\n    if(mincost[next][goal] >= cost + ncost){\n      if(mincost[next][goal] == cost + ncost) pre[next][goal] = min(pre[next][goal],cur);\n      if(mincost[next][goal] > cost + ncost)  pre[next][goal] = cur;\n      mincost[next][goal] = cost + ncost;\n      Q.push(Data(next,mincost[next][goal]));\n    }\n      }\n    }\n  }\n}\n  \n  \nvoid simulation(){\n  int n;\n  cin >> n;\n  ll *schedule = new ll[V]; // coefficient\n  rep(i,V)schedule[i] = 0;\n  deque<Object> *PostOffice = new deque<Object>[V];\n  deque<Object> item;\n  vector<is> ans;\n  rep(i,n){\n    ll sp,gp,tm;\n    string label;\n    cin >> sp >> gp >> tm >> label;\n    --sp,--gp;\n    item.push_back(Object(sp,gp,tm,label,0));\n  }\n  sort(all(item));\n  ll remain = n,event_time = -1,next_pos,phase = 0,pe = -1;\n  while(remain){\n    event_time = LLINF,next_pos = -1;\n    if(!item.empty()){\n      sort(all(item));\n      event_time = item.front().timer;\n    }\n    rep(i,V)if(!PostOffice[i].empty()){\n      sort(all(PostOffice[i]));\n      rep(j,(int)PostOffice[i].size()){\n    if( event_time > PostOffice[i][j].timer+mincost[i][pre[i][PostOffice[i][j].to]]){\n      event_time = PostOffice[i][j].timer+mincost[i][pre[i][PostOffice[i][j].to]];\n      next_pos = i;\n    }\n      }\n    }\n    if( pe != event_time ) phase++;\n \n    pe = event_time;\n    if( !item.empty() && event_time == item.front().timer){\n      while( !item.empty() && item.front().timer == event_time){\n    Object obj = item.front(); item.pop_front();\n    if( obj.from == obj.to ){\n      ans.push_back(is(obj.timer,obj.label));\n      remain--;\n      continue;\n    }\n    obj.timer = max(obj.timer,schedule[obj.from]);\n    obj.priority = phase;\n    PostOffice[obj.from].push_back(obj);\n    sort(all(PostOffice[obj.from]));\n      }\n      continue;\n    }\n    vector<Object> use,tmp;\n    ll dest = PostOffice[next_pos].front().to,current_time = PostOffice[next_pos].front().timer;\n    for(Object& obj : PostOffice[next_pos]){\n      if( current_time >= obj.timer &&  pre[next_pos][dest] == pre[obj.from][obj.to] ) use.push_back(obj);\n      else tmp.push_back(obj);\n    }\n    PostOffice[next_pos].clear();\n    rep(j,(int)tmp.size()){\n      tmp[j].timer = max(tmp[j].timer,use[0].timer+mincost[next_pos][pre[next_pos][dest]]*2);\n      PostOffice[next_pos].push_back(tmp[j]);\n    }\n    schedule[next_pos] = use[0].timer+mincost[next_pos][pre[next_pos][dest]]*2;\n    rep(j,(int)use.size()){\n      use[j].timer +=  mincost[next_pos][pre[next_pos][dest]];\n      use[j].from = pre[next_pos][dest];\n      use[j].priority = -1;\n      item.push_back(use[j]);\n    }\n  }\n  delete [] schedule;\n  delete [] PostOffice;\n  sort(all(ans));\n  rep(i,(int)ans.size()) cout << ans[i].second << \" \" << ans[i].first << endl;\n}\n  \nint main(){\n  bool F = true;\n  while(cin >> V >> E, V|E){\n    if(!F)puts(\"\");\n    F = false;\n    rep(i,V)G[i].clear();\n    rep(i,V)rep(j,V)clist[i][j] = LLINF;\n    rep(i,E){\n      int a,b,cost;\n      cin >> a >> b >> cost;\n      a--,b--;\n      G[a].push_back(Data(b,cost));\n      G[b].push_back(Data(a,cost));\n      clist[a][b] = clist[b][a] = cost;\n    }\n    dijkstra();\n    simulation();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tint tm,pos,dist;\n\tstring name;\n\tpacket(int t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x], &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(int x,int y){\n\tconst packet &a=pac[x], &b = pac[y];\n\treturn a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tstring name;\n\tfor(;cin>>n>>m,n;){\n\t\tpriority_queue<int,vector<int>,cmp> qu;\n\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=-1;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n/*\n\t\tfor(j=1;j<=n;j++)printf(\"\\t%d\",j);\n\t\tfor(i=1;i<=n;i++,puts){\n\t\t\tprintf(\"\\n%d:\",i);\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tprintf(\"\\t%d(%d)\",len[i][j],to[i][j]);\n\t\t}\n\t\treturn 0;\n*/\n\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n\n\t\tfor(;!qu.empty();){\n//printf(\"size: %d\\n\",qu.size());\n\t\t\tint pi = qu.top();\n\t\t\tpacket &p = pac[pi];\n\t\t\tt = p.tm;\n\t\t\tf = p.pos;\n\t\t\tif( f == p.dist ){\n\t\t\t\tqu.pop();\n\t\t\t\t\n\t\t\t\tprintf(\"%s %d\\n\",p.name.c_str(),p.tm);\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( t < bac[f] ){\n\t\t\t\tp.tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n//\t\t\t\tprintf(\"wait: %s\\n\",p.name.c_str());\n\t\t\t}else{\n\t\t\t\td = to[f][p.dist];\n//\t\t\t\tprintf(\"%d\\t%d -> %d\\t%s\\n\",p.tm,p.pos,t,p.name.c_str());\n\t\t\t\tbac[f] = p.tm + 2 * len[p.pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket &q = pac[qi];\n\t\t\t\t\tif(t==q.tm && f==q.pos && to[q.pos][q.dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq.tm += len[f][d];\n\t\t\t\t\t\tq.pos = d;\n\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tsort(pac.begin(),pac.end(),cmp2);\n//\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n//\t\tfor(j=0;j<l;j++)tbl[j]=j;\n//\t\tsort(tbl,tbl+l,cmp2);\n//\t\tfor(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),pac[tbl[j]].tm);\n\n\t\t**len = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <utility>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std;\nconst int INF = 1e9;\n\nstruct mail{\n  int time, to, cur, next, id;\n};\n\nbool operator < (const mail &a, const mail &b){\n  if(a.time != b.time) return a.time > b.time;\n  if(a.next != b.next) return a.next > b.next;\n  return a.cur > b.cur;\n}\n\nint main(){\n  int n, m, c = 0;\n  while(cin >> n >> m, n){\n    if(c) printf(\"\\n\");\n    else ++c;\n    vector< vector<int> > D(n, vector<int>(n, INF)), E(n, vector<int>(n, 0));\n\n    \n    for(int i = 0; i < m; ++i){\n      int u, v, d;\n      cin >> u >> v >> d;\n      --u;--v;\n      D[u][v] = d;\n      D[v][u] = d;\n      E[u][v] = d;\n      E[v][u] = d;\n    }\n\n    for(int i = 0; i < n; ++i) D[i][i] = 0;\n    for(int k = 0; k < n; ++k){\n      for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n          D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\n        }\n      }\n    }\n\n    vector< vector<int> > next(n, vector<int>(n, -1));\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        for(int k = 0; k < n; ++k){\n          if(i == k || (D[i][k] + D[k][j] != D[i][j]) || (D[i][k] != E[i][k])) continue;\n          next[i][j] = k;\n          break;\n        }\n      }\n    }\n\n    int l;\n    cin >> l;\n    vector<string> name(l);\n    priority_queue<mail> pque;\n    \n    for(int i = 0; i < l; ++i){\n      int from, to, time;\n      cin >> from >> to >> time >> name[i];\n      pque.push((mail){time, to-1, from-1, next[from-1][to-1], i});\n    }\n    \n    vector<int> T(n, -1);\n    vector< vector<int> > U(n, vector<int>(n, -1));\n    vector< pair<int, string> > A;\n    \n    while(!pque.empty()){\n      mail x = pque.top();\n      pque.pop();\n      \n      if(U[x.cur][x.next] < x.time){\n        T[x.cur] = max(T[x.cur], x.time);\n        U[x.cur][x.next] = T[x.cur];\n        T[x.cur] = max(T[x.cur], U[x.cur][x.next] + 2*D[x.cur][x.next]);\n      }\n      x.time = U[x.cur][x.next] + D[x.cur][x.next];\n      x.cur = x.next;\n      x.next = next[x.cur][x.to];\n\n      if(x.cur == x.to){\n        A.push_back(make_pair(x.time, name[x.id]));\n      }else{\n        pque.push(x);\n      }\n    }\n    \n    sort(A.begin(), A.end());\n    for(int i = 0; i < l; ++i){\n      cout << A[i].second << \" \" << A[i].first << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nstruct edge{\n    int to;\n    int cost;\n};\nint d[33][33];\n// cur,to\nint nxt[33][33];\nstring letterNames[1001];\n\nconst int INF=1000000000;\nvector<edge>G[101];\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\nvoid calcNxtPlace(int V){\n    for(int i=0;i<33;i++)for(int j=0;j<33;j++)nxt[i][j]=INF;\n    for(int i=0;i<V;i++){\n        for(int j=0;j<V;j++){\n            if(i!=j){\n                int nxtNum=INF;\n                for(int k=0;k<G[i].size();k++){\n                    edge &e=G[i][k];\n                    if(d[i][e.to]+d[e.to][j]==d[i][j])nxtNum=min(nxtNum,e.to);\n                }\n                nxt[i][j]=nxtNum;\n            }\n        }\n    }\n}\n\nstruct Letter{\n    int nxtTo;\n    int goal;\n    int start;\n    int id;\n    int arriveTime;\n    bool operator<(const Letter &lt)const{\n        return arriveTime<lt.arriveTime;\n    }\n};\n\nstruct Event{\n    // 0:,1:úÔ,2:èÌÇÁ\n    int kind;\n    int time;\n    int node;\n    int prvNode;\n    vector<Letter> lts;\n    bool operator<(const Event &e)const{\n        if(time<e.time)true;\n        else if(time>e.time)false;\n        return kind<e.kind;\n    }\n};\n\nint N,M,L;\n// Çõª¶Ý·é©Ç¤©\nbool isExist[1001];\n// eXÖÇÉÂ¢ÄA»ê¼êÌèª·ÅÉçê½©\nbool isArrivalLet[1001][1001];\n// eXÖÇ²ÆÉAèðÔÉÇ\npriority_queue<Letter> postLets[1001];\n// eXÖÇ²ÆÉAèð Äæ²ÆÉÇ\nvector<Letter> postByNxtTo[101][101];\n\nint main(){\n    bool fst=true;\n    while(cin>>N>>M&&(N|M)){\n        if(fst)fst=false;\n        else cout<<endl;\n        for(int i=0;i<N;i++)G[i].clear();\n        for(int i=0;i<1001;i++)isExist[i]=true;\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)postByNxtTo[i][j].clear();\n        memset(isArrivalLet,0,sizeof(isArrivalLet));\n        //vector<Letter> lts;\n        for(int i=0;i<N;i++)while(postLets[i].size())postLets[i].pop();\n        for(int i=0;i<N;i++)for(int j=0;j<N;j++){\n            if(i==j)d[i][j]=0;\n            else d[i][j]=INF;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            edge e;\n            cin>>a>>b>>e.cost;\n            a--;b--;\n            e.to=b;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[a][b]=d[b][a]=e.cost;\n        }\n        cin>>L;\n        priority_queue<Event> pq;\n        warshall_floyd(N);\n        calcNxtPlace(N);\n        for(int i=0;i<L;i++){\n            Letter lt;\n            cin>>lt.start>>lt.goal>>lt.arriveTime;\n            lt.start--;lt.goal--;\n            cin>>letterNames[i];\n            lt.id=i;\n            lt.nxtTo=(nxt[lt.start][lt.goal]);\n            // èÇÁCxg\n            Event ev;\n            ev.prvNode=lt.start;\n            ev.node=lt.start;\n            ev.kind=1;\n            ev.time=lt.arriveTime;\n            ev.lts.push_back(lt);\n            pq.push(ev);\n        }\n        vector<pair<int,string> > res;\n        // CxgðÔÉ\n        while(pq.size()){\n            Event e=pq.top();pq.pop();\n            // \n            if(e.kind==0){\n                // èðXÖÇÉÇÁ\n                for(int i=0;i<e.lts.size();i++){\n                    // goal\n                    if(e.lts[i].goal==e.node)\n                        res.push_back(make_pair(e.time,letterNames[e.lts[i].id]));\n                    else{\n                        //  ÄæðÌêÉÏXµÄ¨­\n                        e.lts[i].nxtTo=nxt[e.node][e.lts[i].goal];\n                        e.lts[i].arriveTime=e.time;\n                        postLets[e.node].push(e.lts[i]);\n                        postByNxtTo[e.node][e.lts[i].nxtTo].push_back(e.lts[i]);\n                    }\n                }\n                // AÒCxgðÇÁ\n                Event ev;\n                ev.node=e.prvNode;\n                ev.kind=2;\n                ev.prvNode=e.node;\n                // ÌCxgÔðo^\n                ev.time=e.time+d[e.node][e.prvNode];\n                pq.push(ev);\n            }\n            // ÇÁ\n            else if(e.kind==1){\n                // èðXÖÇÉÇÁ\n                postLets[e.node].push(e.lts[0]);\n                // èðXÖÇÉ Äæ²ÆÉª¯ÄÇÁ\n                postByNxtTo[e.node][e.lts[0].nxtTo].push_back(e.lts[0]);\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // AÒ\n            else if(e.kind==2){\n                isExist[e.node]=true;\n                // wõª¢éÈçÎAo­CxgðÇÁ\n                if(isExist[e.node]){\n                    isExist[e.node]=false;\n                    Event ev;\n                    ev.kind=3;\n                    ev.time=e.time;\n                    ev.node=e.node;\n                    pq.push(ev);\n                }\n            }\n            // o­\n            else if(e.kind==3){\n                // ¡ éèÌÅAàÁÆàÔªÍâ¢àÌðé\n                // ½¾µAÌ Ä³«ª¨È¶àÌÍAÜÆßÄé\n                // ¡±ÌêÉèª¶ÝµÈ¢\n                if(postLets[e.node].empty()){\n                    // wõð¯ßé\n                    isExist[e.node]=true;\n                    continue;\n                }\n                Letter lt=postLets[e.node].top();postLets[e.node].pop();\n                // ·ÅÉçêÄ¢é\n                if(isArrivalLet[e.node][lt.id])continue;\n                Event ev;\n                // éèðZbg\n                ev.lts=postByNxtTo[e.node][lt.nxtTo];\n                // Á½ÌÅgðNA\n                for(int i=0;i<ev.lts.size();i++)isArrivalLet[e.node][ev.lts[i].id]=true;\n                postByNxtTo[e.node][lt.nxtTo].clear();\n                ev.kind=0;\n                ev.node=lt.nxtTo;\n                ev.prvNode=e.node;\n                ev.time=e.time+d[e.node][lt.nxtTo];\n                pq.push(ev);\n            }\n        }\n        sort(res.begin(),res.end());\n        for(int i=0;i<res.size();i++)cout<<res[i].second<<\" \"<<res[i].first<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cost;\n  Edge() {}\n  Edge(int s, int d, int c) : src(s), dst(d), cost(c) {}\n};\n\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nstruct Event{\n  int type;\n  int time;\n  int latter;\n  int office;\n  Event(int ty, int t, int l, int o) : \n    type(ty), time(t), latter(l), office(o) {}\n  bool operator < (const Event& e) const {\n    if(time != e.time) return time < e.time;\n    if(type != e.type) return type < e.type;\n    if(office != e.office) return office < e.office;\n    return latter < e.latter;\n  }\n  bool operator > (const Event& e) const {\n    if(time != e.time) return time > e.time;\n    if(type != e.type) return type > e.type;\n    if(office != e.office) return office > e.office;\n    return latter > e.latter;\n  }\n};\nstruct Latter{\n  string name;\n  int src, dst;\n};\ntypedef pair<int, string> P;\nvoid print(Event& e){\n  //printf(\"type %d time %d latter %d office %d\\n\", e.type, e.time, e.latter, e.office);\n}\n\nvoid do_send(Event& e, deque<Event>& lq, priority_queue<Event, vector<Event>, greater<Event> >& que, int dist[36][36], vector<bool>& wait){\n  /*\n  printf(\"do_send : lq is\\n\");\n  REP(i, lq.size()) print(lq[i]);\n  cout << endl;\n  */\n  Event se = lq.front(); lq.pop_front();\n  que.push(Event(0, e.time + dist[e.office][se.office], se.latter, se.office));\n  //printf(\"send : \"); print(se);\n  for(deque<Event>::iterator it = lq.begin(); it != lq.end(); ){\n    if(it->office == se.office){\n      que.push(Event(0, e.time + dist[e.office][se.office], it->latter, se.office));\n      //printf(\"send2 : \"); print(*it);\n      it = lq.erase(it);\n    }else{\n      it++;\n    }\n  }\n  que.push(Event(1, e.time + 2 * dist[e.office][se.office], -1, e.office));\n  wait[e.office] = false;\n}\nint main(){\n  int N, M;\n  bool first = true;\n  while(cin >> N >> M && N){\n\n    if(first) first = false;\n    else cout << endl;\n\n    Graph G(N);\n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      G[a].push_back(Edge(a, b, c));\n      G[b].push_back(Edge(b, a, c));\n    }\n    int dist[36][36] = {};\n    REP(i, N) REP(j, N) dist[i][j] = (i != j) ? INF : 0;\n    REP(i, N) FORIT(e, G[i]) dist[e->src][e->dst] = e->cost;\n    REP(k, N) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    // next[i][j] := 現在地i, 目的地jの郵便物の次の行き先\n    int next[36][36] = {};\n    memset(next, -1, sizeof(next));\n    REP(i, N) REP(j, N) if(i != j && !G[i].empty()){\n      next[i][j] = G[i][0].dst;\n      int n_cost = G[i][0].cost + dist[G[i][0].dst][j];\n      int edge_cost = G[i][0].cost;\n      FORIT(e, G[i]){\n        if(make_pair(n_cost, next[i][j]) > make_pair(e->cost + dist[e->dst][j], e->dst)){\n          n_cost = e->cost + dist[e->dst][j];\n          next[i][j] = e->dst;\n          edge_cost = e->cost;\n        }\n      }\n      assert(edge_cost == dist[i][next[i][j]]);\n    }\n    //REP(i, N) REP(j, N) printf(\"next[%d][%d] = %d\\n\", i, j, next[i][j]);\n\n    int L; cin >> L;\n    vector<Latter> latters(L);\n    priority_queue<Event, vector<Event>, greater<Event> > que;\n    vector< deque<Event> > l_que(N);\n    REP(i, L){\n      int time;\n      cin >> latters[i].src >> latters[i].dst >> time >> latters[i].name;\n      latters[i].src--; latters[i].dst--;\n      que.push(Event(0, time, i, latters[i].src));\n    }\n    vector<P> answer;\n    vector<bool> wait(N, true);\n    while(!que.empty()){\n      Event e = que.top(); que.pop();\n      print(e);\n      deque<Event>& lq = l_que[e.office];\n      if(e.type == 0){\n        Latter& l = latters[e.latter];\n        if(l.dst == e.office){\n          answer.push_back(P(e.time, l.name));\n        }else{\n          int to = next[e.office][l.dst];\n          assert(to != -1);\n          Event send(0, e.time, e.latter, to);\n          lq.insert(lower_bound(lq.begin(), lq.end(), send), send);\n          // send\n          if(wait[e.office] && (que.empty() || e.time != que.top().time || e.office != que.top().office)){\n            do_send(e, lq, que, dist, wait);\n          }\n        }\n      }else if(e.type == 1){\n        wait[e.office] = true;\n        if(!lq.empty()){\n          do_send(e, lq, que, dist, wait);\n        }\n      }\n    }\n    REP(i, N) assert(wait[i]);\n    REP(i, N) assert(l_que[i].empty());\n    sort(answer.begin(), answer.end());\n    assert(answer.size() == latters.size());\n    REP(i, answer.size()){\n      printf(\"%s %d\\n\", answer[i].second.c_str(), answer[i].first);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n,m,co=0;\n\twhile(cin>>n>>m,n){\n\t\tif(co++)cout<<endl;\n\t\tvvi cost(n,vi(n,inf));\n\t\trep(i,n)cost[i][i]=0;\n\t\tvvi G(n);\n\t\trep(i,m){\n\t\t\tint a,b,c;cin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t\tG[a].pb(b);\n\t\t\tG[b].pb(a);\n\t\t}\n\t\trep(i,n)sort(all(G[i]));\n\t\trep(k,n)rep(i,n)rep(j,n)\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n\t\tvvi go(n,vi(n,inf));\n\t\trep(i,n)rep(j,n)if(i!=j)rep(k,G[i].size())if(cost[i][j]==cost[i][G[i][k]]+cost[G[i][k]][j]){\n\t\t\tgo[i][j]=G[i][k];break;\n\t\t}\n\n\t\tint q;\n\t\tcin>>q;\n\t\tvi hu(n),ob(q);\n\t\tvp in(q);\n\t\tvs name(q);\n\t\trep(i,q)cin>>in[i].first>>in[i].second>>ob[i]>>name[i];\n\t\trep(i,q)in[i].first--,in[i].second--;\n\t\twhile(1){\n\t\t\tint mi=inf,mii=-1;\n\t\t\trep(i,q)if(in[i].first!=in[i].second){\n\t\t\t\tif(mi>ob[i])mi=ob[i],mii=i;\n\t\t\t\tif(mi==ob[i]&&go[in[mii].first][in[mii].second]>go[in[i].first][in[i].second])mii=i;\n\t\t\t}\n\t\t\tif(mii==-1)break;\n\t\t\tint from=in[mii].first,to=go[in[mii].first][in[mii].second];\n\t\t\trep(i,q)if(ob[i]==mi&&in[i].first==from&&go[in[i].first][in[i].second]==to){\n\t\t\t\thu[from]=mi+2*cost[from][to];\n\t\t\t\tob[i]=mi+cost[from][to];\n\t\t\t\tin[i].first=to;\n\t\t\t}\n\t\t\trep(i,q)if(in[i].first!=in[i].second&&hu[in[i].first]>ob[i])ob[i]=hu[in[i].first];\n\t\t}\n\t\tvector<pair<int,string> >out(q);\n\t\trep(i,q)out[i]={ob[i],name[i]};\n\t\tsort(all(out));\n\t\trep(i,q)cout<<out[i].second<<\" \"<<out[i].first<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <utility>\n#include <cassert>\n\nusing namespace std;\nconst int INF = 1e9;\n\nstruct mail{\n  int time, to, cur, next, id;\n};\n\nbool operator < (const mail &a, const mail &b){\n  if(a.time != b.time) return a.time > b.time;\n  if(a.next != b.next) return a.next > b.next;\n  return a.cur > b.cur;\n}\n\nint main(){\n  int n, m, c = 0;\n  while(cin >> n >> m, n){\n    if(c) cout << endl;\n    else ++c;\n    vector< vector<int> > D(n, vector<int>(n, INF));\n    vector< vector<bool> > E(n, vector<bool>(n, false));\n    \n    for(int i = 0; i < m; ++i){\n      int u, v, d;\n      cin >> u >> v >> d;\n      --u;--v;\n      D[u][v] = d;\n      D[v][u] = d;\n      E[u][v] = true;\n      E[v][u] = true;\n    }\n    \n    for(int i = 0; i < n; ++i) D[i][i] = 0;\n    for(int k = 0; k < n; ++k){\n      for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n          D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n        }\n      }\n    }\n    \n    vector< vector<int> > next(n, vector<int>(n, -1));\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        for(int k = 0; k < n; ++k){\n          if(D[i][k] + D[k][j] != D[i][j] || !E[i][k]) continue;\n          next[i][j] = k;\n          break;\n        }\n      }\n    }\n    \n    int l;\n    cin >> l;\n    vector<string> name(l);\n    priority_queue<mail> pque;\n    \n    for(int i = 0; i < l; ++i){\n      int from, to, time;\n      cin >> from >> to >> time >> name[i];\n      pque.push((mail){time, to-1, from-1, next[from-1][to-1], i});\n    }\n    \n    vector<int> T(n, -1);\n    vector< vector<int> > U(n, vector<int>(n, -1));\n    vector< pair<int, string> > A;\n\n    while(!pque.empty()){\n      mail x = pque.top();\n      pque.pop();\n      T[x.cur] = max(T[x.cur], x.time);\n      if(U[x.cur][x.next] < x.time){\n        U[x.cur][x.next] = T[x.cur];\n      }\n      T[x.cur] = max(T[x.cur], U[x.cur][x.next] + 2*D[x.cur][x.next]);\n      x.time = U[x.cur][x.next] + D[x.cur][x.next];      \n      x.cur = x.next;\n      x.next = next[x.cur][x.to];\n      if(x.cur == x.to){\n        A.push_back(make_pair(x.time, name[x.id]));\n      }else{\n        pque.push(x);\n      }\n    }\n\n    sort(A.begin(), A.end());\n    for(int i = 0; i < l; ++i){\n      cout << A[i].second << \" \" << A[i].first << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tvector<int> to,c;\n};\n\nclass Trl\n{\npublic:\n\tint p,c,pv,sec;\n\tTrl(int p, int c, int pv,int sec)\n\t:p(p),c(c),pv(pv),sec(sec)\n\t{}\n\t\n\tbool operator<(const Trl& t) const\n\t{\n\t\tif(c!=t.c) return c>t.c;\n\t\tif(sec!=t.sec) return sec>t.sec;\n\t\treturn p>t.p;\n\t}\n};\n\nint nt[32][32],ld[32][32];\nNode node[32];\n\nvoid Dijkstra(int src, int dst)\n{\n\tpriority_queue<Trl> q;\n\tq.push(Trl(src,0,src,-1));\n\t\n\tint v[32];\n\tfor(int i=0; i<32; i++) v[i]=-1;\n\t\n\twhile(!q.empty())\n\t{\n\t\tTrl t=q.top(); q.pop();\n\t\tif(v[t.p]!=-1) continue;\n\t\tv[t.p]=t.pv;\n\t\t\n\t\tif(t.p==dst)\n\t\t{\n\t\t\tnt[src][dst]=t.sec;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0; i<node[t.p].to.size(); i++)\n\t\t{\n\t\t\tint next=node[t.p].to[i];\n\t\t\tif(v[next]!=-1) continue;\n\t\t\t\n\t\t\tq.push(Trl(next, t.c+node[t.p].c[i], t.p, (t.sec==-1?next:t.sec)));\n\t\t}\n\t}\n}\n\nenum EV{BACK, GO};\n\nclass Event\n{\npublic:\n\tEV ev;\n\tint p,dst,t,ot;\n\tstring n;\n\t\n\tEvent(int p, int dst, int t, int ot, EV ev, string n)\n\t:p(p),dst(dst),t(t),ot(ot),ev(ev),n(n)\n\t{}\n\t\n\tbool operator<(const Event& e) const\n\t{\n\t\tif(t!=e.t) return t>e.t;\n\t\tif(ev!=e.ev) return ev>e.ev;\n\t\tif(p==dst&&e.p==e.dst) return n>e.n;\n\t\tif(ot!=e.ot) return ot>e.ot;\n\t\treturn nt[p][dst]>nt[e.p][e.dst];\n\t}\n};\n\nvoid Sim()\n{\n\tint K;\n\tscanf(\"%d\", &K);\n\tpriority_queue<Event> q;\n\twhile(K--)\n\t{\n\t\tint s,d,t;\n\t\tchar n[51];\n\t\tscanf(\"%d%d%d%s\",&s,&d,&t,n);\n\t\ts--; d--;\n\t\tq.push(Event(s,d,t,t,GO,string(n)));\n\t}\n\t\n\tint lv[32]={0};\n\twhile(!q.empty())\n\t{\n\t\tEvent e=q.top(); q.pop();\n\t\tif(e.ev==BACK)\n\t\t{\n\t\t\tlv[e.dst]=0;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(e.p==e.dst)\n\t\t{\n\t\t\tprintf(\"%s %d\\n\", e.n.c_str(), e.t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(lv[e.p]!=0)\n\t\t\t{\n\t\t\t\tq.push(Event(e.p, e.dst, lv[e.p], e.ot, e.ev, e.n));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint next=nt[e.p][e.dst], cst=e.t+ld[e.p][next];\n\t\t\t\tlv[e.p]=cst+ld[e.p][next];\n\t\t\t\tq.push(Event(next, e.dst, cst, cst,e.ev, e.n));\n\t\t\t\tq.push(Event(e.p, e.p, lv[e.p],lv[e.p], BACK, \"\"));\n\t\t\t\t\n\t\t\t\tpriority_queue<Event> tmp;\n\t\t\t\twhile(!q.empty())\n\t\t\t\t{\n\t\t\t\t\tEvent te=q.top();\n\t\t\t\t\tif(te.t!=e.t) break;\n\t\t\t\t\tif(next==nt[te.p][te.dst]&&te.p==e.p)\n\t\t\t\t\t{\n\t\t\t\t\t\tq.push(Event(next, te.dst, cst, cst,te.ev, te.n));\n\t\t\t\t\t}\n\t\t\t\t\telse tmp.push(te);\n\t\t\t\t\tq.pop();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile(!tmp.empty())\n\t\t\t\t{\n\t\t\t\t\tq.push(tmp.top()); tmp.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint N,M;\n\tbool fr=true;\n\twhile(scanf(\"%d%d\", &N, &M), (N||M))\n\t{\n\t\tfor(int i=0; i<32; i++)\n\t\t{\n\t\t\tnode[i].to.clear();\n\t\t\tnode[i].c.clear();\n\t\t}\n\t\t\n\t\twhile(M--)\n\t\t{\n\t\t\tint s,d,c;\n\t\t\tscanf(\"%d%d%d\", &s,&d,&c);\n\t\t\ts--; d--;\n\t\t\t\n\t\t\tnode[s].to.push_back(d);\n\t\t\tnode[d].to.push_back(s);\n\t\t\tnode[s].c.push_back(c);\n\t\t\tnode[d].c.push_back(c);\n\t\t\tld[s][d]=c;\n\t\t\tld[d][s]=c;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\tDijkstra(i,j);\n\t\t\t\n\t\tif(!fr) puts(\"\");\n\t\tfr=false;\n\t\t\n\t\tSim();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nvector<pair<int,int> > way[SIZE];\n\nbool firstcase = true;\n\nstruct DATA{\n  int t;\n  int id;\n  int now;\n  int next;\n  int goal;\n\n  const bool operator<(const DATA &B) const{\n    if(t != B.t) return t > B.t;\n    if(next != B.next) return next > B.next;\n    return false;\n  }\n\n  DATA(int t, int id, int now, int next, int goal):\n    t(t), id(id), now(now), next(next), goal(goal){}\n};\n\nint dist[40][40];\nint n;\n\nint getNext(int a, int b){\n  if (a == b) return a;\n  for(int i=0;i<n;i++){\n    if(a != i && dist[a][i] + dist[i][b] == dist[a][b])\n      return i;\n  }\n\n  assert(false);\n  return -1;\n}\n\nbool solve(){\n  int m, q;\n  string text[1000];\n\n  priority_queue<DATA> pq;\n\n  scanf(\"%d%d\", &n, &m);\n\n  if(n == 0) return false;\n  if(firstcase) firstcase = false;\n  else puts(\"\");\n  \n  for(int i=0;i<n;i++) way[i] = vector<pair<int,int> > ();\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      dist[i][j] = INF;\n    }\n    dist[i][i] = 0;\n  }\n  \n  \n  for(int i=0;i<m;i++){\n    int a, b, c; \n    scanf(\"%d%d%d\", &a, &b, &c);\n    a--; b--;\n\n    dist[a][b] = c;\n    dist[b][a] = c;\n  }\n\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n  \n  scanf(\"%d\", &q);\n\n  for(int i=0;i<q;i++){\n    int a, b, t;\n    char temp[60];\n    scanf(\"%d%d%d%s\", &a, &b, &t, temp);\n    a--; b--;\n    text[i] = temp;\n    \n    pq.push(DATA(t, i, a, getNext(a,b), b));\n  }\n\n  bool outside[40] = {};\n  int sent[40][40] = {};\n  priority_queue<pair<int,int> > que[40];\n  queue<DATA> post[40][40];\n  vector<pair<int,string> > ans;\n  \n  while(pq.size()){\n    queue<int> work;\n    int t = pq.top().t;\n\n    while(pq.size() && pq.top().t == t){\n      auto p = pq.top(); pq.pop();\n      if(p.id != -1){\n        if(p.now == p.goal){\n          ans.push_back({p.t, text[p.id]});\n          continue;\n        }\n        \n        post[p.now][p.next].push(p);\n        que[p.now].push({-p.t, -p.next});\n        //cerr << \"[post] \" << t << \" : \" << p.now << \" -> \" << p.next << \" -> \" << p.goal << endl;\n      }else{\n        outside[p.now] = false;\n        //cerr << \"[back] \" << t << \" : \" << p.now << endl;\n      }\n\n      work.push(p.now);\n    }\n    \n\n    while(work.size()){\n      int now = work.front(); work.pop();\n      if(outside[now]) continue;\n\n      while(que[now].size() && -que[now].top().first <= t){\n        auto p = que[now].top(); que[now].pop();\n\n        if(-p.first <= sent[now][-p.second]) continue;\n\n        //cerr << now << \" -> \" << -p.second << endl;\n        \n        int max_t = 0;\n        \n        while(post[now][-p.second].size()){\n          auto p2 = post[now][-p.second].front(); post[now][-p.second].pop();\n          \n          max_t = max(max_t, p2.t);\n\n          p2.t = t + dist[now][-p.second];\n          p2.next = getNext(p2.next, p2.goal);\n          p2.now = -p.second;\n          pq.push(p2);\n        }\n        \n        outside[now] = true;\n        pq.push(DATA(t + dist[now][-p.second]*2, -1, now, -1, -1));\n        sent[now][-p.second] = max(sent[now][-p.second], max_t);\n        break;\n      }\n\n    }\n  }\n\n  sort(ans.begin(), ans.end());\n  \n  for(int i=0;i<q;i++){\n    cout << ans[i].second << \" \" << ans[i].first << endl;\n  }\n  \n  return true;\n}\n\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "tes"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n//#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tint tm,pos,dist;\n\tstring name;\n\tpacket(int t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[1001][1001],to[1001][1001],bac[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x], &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(const packet &p, const packet &q){\n\treturn p.tm==q.tm ? p.name < q.name: p.tm < q.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tstring name;\n\tfor(;cin>>n>>m,n;){\n\t\tpriority_queue<int,vector<int>,cmp> qu;\n\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=-1;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n/*\n\t\tfor(j=1;j<=n;j++)printf(\"\\t%d\",j);\n\t\tfor(i=1;i<=n;i++,puts){\n\t\t\tprintf(\"\\n%d:\",i);\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tprintf(\"\\t%d(%d)\",len[i][j],to[i][j]);\n\t\t}\n\t\treturn 0;\n*/\n\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n\n\t\tfor(;!qu.empty();){\n//printf(\"size: %d\\n\",qu.size());\n\t\t\tint pi = qu.top();\n\t\t\tpacket &p = pac[pi];\n\t\t\tt = p.tm;\n\t\t\tf = p.pos;\n\t\t\tif( f == p.dist ){\n\t\t\t\tqu.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( t < bac[f] ){\n\t\t\t\tp.tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n//\t\t\t\tprintf(\"wait: %s\\n\",p.name.c_str());\n\t\t\t}else{\n\t\t\t\td = to[f][p.dist];\n//\t\t\t\tprintf(\"%d\\t%d -> %d\\t%s\\n\",p.tm,p.pos,t,p.name.c_str());\n\t\t\t\tbac[f] = p.tm + 2 * len[p.pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket &q = pac[qi];\n\t\t\t\t\tif(t==q.tm && f==q.pos && to[q.pos][q.dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq.tm += len[f][d];\n\t\t\t\t\t\tq.pos = d;\n\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(pac.begin(),pac.end(),cmp2);\n\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n\t\t\n\t\t**len = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <functional>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<LL,int> pli;\n\nconst LL INF = (LL)1e18;\n\nLL len[33][33];\nint next[33][33];\nchar label[64];\n\nstruct packet{\n\tstring name;\n\tint from, to;\n\tLL tm;\n\n\tpacket(int f, int to, LL tm, const char *s):\n\t\tname(s), from(f), to(to), tm(tm) {}\n\t\n\tbool operator< (const packet &p) const{\n\t\tif(tm != p.tm){ return tm < p.tm; }\n\t\treturn name < p.name;\n\t}\n};\n\nvoid solve(int n, int m){\n\tint f, t, d;\n\n\tfor(int i = 0; i <= n; ++i){\n\t\tfor(int j = 0; j <= n; ++j){\n\t\t\tlen[i][j] = INF;\n\t\t\tnext[i][j] = 0;\n\t\t}\n\t\tlen[i][i] = 0;\n\t\tnext[i][i] = i;\n\t}\n\n\tfor(int i = 0; i < m; ++i){\n\t\tscanf(\"%d%d%d\", &f, &t, &d);\n\t\tlen[f][t] = len[t][f] = d;\n\t\tnext[f][t] = t;\n\t\tnext[t][f] = f;\n\t}\n\n\tfor(int k = 1; k <= n; ++k)\n\tfor(int i = 1; i <= n; ++i)\n\tfor(int j = 1; j <= n; ++j){\n\t\tif(i == k || k == j){ continue; }\n\t\tLL &d1 = len[i][j];\n\t\tLL d2 = len[i][k] + len[k][j];\n\t\tif((d1 > d2) || (d1 == d2 && next[i][j] > next[i][k])){\n\t\t\td1 = d2;\n\t\t\tnext[i][j] = next[i][k];\n\t\t}\n\t}\n\n\tvector<vector<int> > wait(n + 1);\n\tvector<char> standby(n + 1, 1);\n\tscanf(\"%d\", &m);\n\tvector<packet> ps;\n\tpriority_queue<pli,vector<pli>,greater<pli> > ev;\n\tfor(int i = 0; i < m; ++i){\n\t\tscanf(\"%d%d%d%s\", &f, &t, &d, label);\n\t\tps.push_back(packet(f, t, d, label));\n\t\twait[f].push_back(i);\n\n\t\tif(standby[f]){\n\t\t\tstandby[f] = 0;\n\t\t\tev.push(pli(0, f));\n\t\t}\n\t}\n\n\tint cnt = m;\n\twhile(cnt > 0){\n\t\tpli e = ev.top();\n\t\tev.pop();\n\n\t\tvector<int> &ws = wait[e.second];\n\t\tif(ws.empty()){\n\t\t\tstandby[e.second] = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tLL mintm = INF;\n\t\tfor(int i = 0; i < ws.size(); ++i){\n\t\t\tmintm = min(mintm, ps[ws[i]].tm);\n\t\t}\n\t\tif(mintm > e.first){\n\t\t\tev.push(pli(mintm, e.second));\n\t\t\tcontinue;\n\t\t}\n\n\t\tint to = 999;\n\t\tvector<int> send;\n\t\tfor(int i = 0; i < ws.size(); ++i){\n\t\t\tpacket &p = ps[ws[i]];\n\t\t\tif(p.tm <= e.first){\n\t\t\t\tif(to > next[p.from][p.to]){\n\t\t\t\t\tto = next[p.from][p.to];\n\t\t\t\t\tsend.clear();\n\t\t\t\t}\n\t\t\t\tif(to == next[p.from][p.to]){\n\t\t\t\t\tsend.push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLL arvtm = e.first + len[e.second][to];\n\t\tfor(int i = send.size() - 1; i >= 0; --i){\n\t\t\tpacket &p = ps[ws[send[i]]];\n\t\t\tp.from = to;\n\t\t\tp.tm = arvtm;\n\t\t\tif(to == p.to){\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twait[to].push_back(send[i]);\n\t\t\t}\n\t\t\tws.erase(ws.begin() + send[i]);\n\t\t}\n\t\tif(standby[to]){\n\t\t\tstandby[to] = 0;\n\t\t\tev.push(pli(arvtm, to));\n\t\t}\n\n\t\tev.push(pli(e.first + 2 * len[e.second][to], e.second));\n\t}\n\t\n\tsort(ps.begin(), ps.end());\n\tfor(int i = 0; i < ps.size(); ++i){\n\t\tprintf(\"%s %lld\\n\", ps[i].name.c_str(), ps[i].tm);\n\t}\n}\n\nint main(){\n\tbool flg = false;\n\tint n, m;\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\tif(flg){\n\t\t\tputs(\"\");\n\t\t}\n\t\tflg = true;\n\t\tsolve(n, m);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n \nstruct packet{\n    int tm,pos,dist;\n    string name;\n    packet(int t,int p,int d,const string&n):\n        tm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n    bool operator() (int x,int y) const\n    {\n        const packet &a = pac[x], &b = pac[y];\n        return a.tm == b.tm\n            ? to[a.pos][a.dist] > to[b.pos][b.dist]\n            : a.tm > b.tm;\n    }\n};\nbool cmp2(int x,int y){\n    const packet &a=pac[x], &b = pac[y];\n    return a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n \nint main(){\n    int n,m,f,t,d,i,j,k,l;\n    string name;\n    priority_queue<int,vector<int>,cmp> qu;\n    for(;cin>>n>>m,n;){\n        pac.clear();\n        if(**len==1)cout<<endl;\n \n        for(i=0;i<=n;i++){\n            for(j=0;j<=m;j++){\n                len[i][j]=inf;\n                to[i][j]=inf;\n            }\n            bac[i]=len[i][i]=0;\n//          to[i][i]=i;\n        }\n \n        for(;m--;){\n            cin>>f>>d>>t;\n            len[f][d] = t;\n            len[d][f] = t;\n            to[f][d] = d;\n            to[d][f] = f;\n        }\n \n        for(k=1;k<=n;k++)\n            for(i=1;i<=n;i++)\n                for(j=1;j<=n;j++){\n                    t = len[i][k] + len[k][j];\n                    if( len[i][j] > t ){\n                        len[i][j] = t;\n                        to[i][j] = to[i][k];\n                    }\n                }\n        cin>>l;\n        for(j=0;j<l;j++){\n            cin>>f>>d>>t>>name;\n            pac.push_back( packet(t,f,d,name) );\n            qu.push(j);\n        }\n \n        for(;!qu.empty();){\n            int pi = qu.top();\n            packet &p = pac[pi];\n            t = p.tm;\n            f = p.pos;\n            if( t < bac[f] ){\n                p.tm = bac[f];\n                qu.pop();\n                qu.push(pi);\n            }else{\n                d = to[f][p.dist];\n                bac[f] = p.tm + 2 * len[p.pos][d];\n                for(;;){\n                    int qi = qu.top();\n                    packet &q = pac[qi];\n                    if(t==q.tm && f==q.pos && to[q.pos][q.dist] == d){\n                        qu.pop();\n                        q.tm += len[f][d];\n                        q.pos = d;\n                        if( d != q.dist )\n                            qu.push(qi);\n                    }\n                    else break;\n                }\n            }\n        }\n//      sort(pac.begin(),pac.end(),cmp2);\n//      for(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n        for(j=0;j<l;j++)tbl[j]=j;\n        sort(tbl,tbl+l,cmp2);\n        for(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),pac[tbl[j]].tm);\n \n        **len = 1;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tint tm,pos,dist;\n\tstring name;\n\tpacket(int t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x], &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(int x,int y){\n\tconst packet &a=pac[x], &b = pac[y];\n\treturn a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tstring name;\n\tpriority_queue<int,vector<int>,cmp> qu;\n\tfor(;cin>>n>>m,n;){\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=-1;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n\n\t\tfor(;!qu.empty();){\n\t\t\tint pi = qu.top();\n\t\t\tpacket &p = pac[pi];\n\t\t\tt = p.tm;\n\t\t\tf = p.pos;\n\t\t\tif( f == p.dist ){\n\t\t\t\tqu.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( t < bac[f] ){\n\t\t\t\tp.tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n\t\t\t}else{\n\t\t\t\td = to[f][p.dist];\n\t\t\t\tbac[f] = p.tm + 2 * len[p.pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket &q = pac[qi];\n\t\t\t\t\tif(t==q.tm && f==q.pos && to[q.pos][q.dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq.tm += len[f][d];\n\t\t\t\t\t\tq.pos = d;\n\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tsort(pac.begin(),pac.end(),cmp2);\n//\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n\t\tfor(j=0;j<l;j++)tbl[j]=j;\n\t\tsort(tbl,tbl+l,cmp2);\n\t\tfor(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),pac[tbl[j]].tm);\n\n\t\t**len = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cost;\n  Edge() {}\n  Edge(int s, int d, int c) : src(s), dst(d), cost(c) {}\n};\n\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nstruct Event{\n  int type;\n  int time;\n  int latter;\n  int office;\n  Event(int ty, ll t, int l, int o) : \n    type(ty), time(t), latter(l), office(o) {}\n  bool operator < (const Event& e) const {\n    if(time != e.time) return time < e.time;\n    if(type != e.type) return type < e.type;\n    if(office != e.office) return office < e.office;\n    return latter < e.latter;\n  }\n  bool operator > (const Event& e) const {\n    if(time != e.time) return time > e.time;\n    if(type != e.type) return type > e.type;\n    if(office != e.office) return office > e.office;\n    return latter > e.latter;\n  }\n};\nstruct Latter{\n  string name;\n  int src, dst;\n};\ntypedef pair<int, string> P;\n\nvoid do_send(Event& e, vector<Event>& lq, priority_queue<Event, vector<Event>, greater<Event> >& que, int dist[36][36], vector<bool>& wait){\n  Event se = lq.front();\n  lq.erase(lq.begin());\n  que.push(Event(0, e.time + dist[e.office][se.office], se.latter, se.office));\n  for(vector<Event>::iterator it = lq.begin(); it != lq.end(); ){\n    if(it->office == se.office){\n      que.push(Event(0, e.time + dist[e.office][se.office], it->latter, se.office));\n      it = lq.erase(it);\n    }else{\n      it++;\n    }\n  }\n  que.push(Event(1, e.time + 2 * dist[e.office][se.office], -1, e.office));\n  wait[e.office] = false;\n}\nint main(){\n  int N, M;\n  bool first = true;\n  while(cin >> N >> M && N){\n\n    if(first) first = false;\n    else cout << endl;\n\n    Graph G(N);\n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      G[a].push_back(Edge(a, b, c));\n      G[b].push_back(Edge(b, a, c));\n    }\n    int dist[36][36] = {};\n    REP(i, N) REP(j, N) dist[i][j] = (i != j) ? INF : 0;\n    REP(i, N) FORIT(e, G[i]) dist[e->src][e->dst] = e->cost;\n    REP(k, N) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    // next[i][j] := 現在地i, 目的地jの郵便物の次の行き先\n    int next[36][36] = {};\n    memset(next, -1, sizeof(next));\n    REP(i, N) REP(j, N) if(i != j && !G[i].empty() && dist[i][j] < INF){\n      next[i][j] = INF;\n      int edge_cost = -1;\n      FORIT(e, G[i]){\n        if(e->cost + dist[e->dst][j] == dist[i][j] && next[i][j] > e->dst){\n          next[i][j] = e->dst;\n          edge_cost = e->cost;\n        }\n      }\n    }\n\n    int L; cin >> L;\n    vector<Latter> latters(L);\n    priority_queue<Event, vector<Event>, greater<Event> > que;\n    vector< vector<Event> > l_que(N);\n    REP(i, L){\n      ll time;\n      cin >> latters[i].src >> latters[i].dst >> time >> latters[i].name;\n      latters[i].src--; latters[i].dst--;\n      que.push(Event(0, time, i, latters[i].src));\n    }\n    vector<P> answer;\n    vector<bool> wait(N, true);\n    while(!que.empty()){\n      Event e = que.top(); que.pop();\n      vector<Event>& lq = l_que[e.office];\n      if(e.type == 0){\n        Latter& l = latters[e.latter];\n        if(l.dst == e.office){\n          answer.push_back(P(e.time, l.name));\n        }else{\n          int to = next[e.office][l.dst];\n          assert(to != -1);\n          Event send(0, e.time, e.latter, to);\n          lq.insert(lower_bound(lq.begin(), lq.end(), send), send);\n        }\n      }else if(e.type == 1){\n        wait[e.office] = true;\n      }\n      if(wait[e.office] && !lq.empty() && (que.empty() || e.time != que.top().time || e.office != que.top().office)){\n        do_send(e, lq, que, dist, wait);\n      }\n    }\n    sort(answer.begin(), answer.end());\n    REP(i, answer.size()){\n      printf(\"%s %d\\n\", answer[i].second.c_str(), answer[i].first);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tint tm,pos,dist;\n\tstring name;\n\tpacket(int t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x], &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(int x,int y){\n\tconst packet &a=pac[x], &b = pac[y];\n\treturn a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tstring name;\n\tpriority_queue<int,vector<int>,cmp> qu;\n\tfor(;cin>>n>>m,n;){\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=-1;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n\n\t\tfor(;!qu.empty();){\n\t\t\tint pi = qu.top();\n\t\t\tpacket &p = pac[pi];\n\t\t\tt = p.tm;\n\t\t\tf = p.pos;\n\t\t\tif( f == p.dist ){\n\t\t\t\tqu.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( t < bac[f] ){\n\t\t\t\tp.tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n\t\t\t}else{\n\t\t\t\td = to[f][p.dist];\n\t\t\t\tbac[f] = p.tm + 2 * len[p.pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket &q = pac[qi];\n\t\t\t\t\tif(t==q.tm && f==q.pos && to[q.pos][q.dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq.tm += len[f][d];\n\t\t\t\t\t\tq.pos = d;\n\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tsort(pac.begin(),pac.end(),cmp2);\n//\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n\t\tfor(j=0;j<l;j++)tbl[j]=j;\n\t\tsort(tbl,tbl+l,cmp2);\n\t\tfor(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),pac[tbl[j]].tm);\n\n\t\t**len = 1;\n\t\t\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst ll INF = 1000000000000000LL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Edge{\n  int src, dst, cost;\n  Edge() {}\n  Edge(int s, int d, int c) : src(s), dst(d), cost(c) {}\n};\n\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nstruct Event{\n  int type;\n  ll time;\n  int latter;\n  int office;\n  Event(int ty, ll t, int l, int o) : \n    type(ty), time(t), latter(l), office(o) {}\n  bool operator < (const Event& e) const {\n    if(time != e.time) return time < e.time;\n    if(type != e.type) return type < e.type;\n    if(office != e.office) return office < e.office;\n    return latter < e.latter;\n  }\n  bool operator > (const Event& e) const {\n    if(time != e.time) return time > e.time;\n    if(type != e.type) return type > e.type;\n    if(office != e.office) return office > e.office;\n    return latter > e.latter;\n  }\n};\nstruct Latter{\n  string name;\n  int src, dst;\n};\ntypedef pair<int, string> P;\nvoid print(Event& e){\n  //printf(\"type %d time %d latter %d office %d\\n\", e.type, e.time, e.latter, e.office);\n}\n\nvoid do_send(Event& e, deque<Event>& lq, priority_queue<Event, vector<Event>, greater<Event> >& que, int dist[36][36], vector<bool>& wait){\n  /*\n  printf(\"do_send : lq is\\n\");\n  REP(i, lq.size()) print(lq[i]);\n  cout << endl;\n  */\n  Event se = lq.front(); lq.pop_front();\n  assert(se.office != e.office);\n  assert(e.time + dist[e.office][se.office] > 0);\n  assert(e.time + dist[e.office][se.office] < INF);\n  que.push(Event(0, e.time + dist[e.office][se.office], se.latter, se.office));\n  //printf(\"send : \"); print(se);\n  for(deque<Event>::iterator it = lq.begin(); it != lq.end(); ){\n    if(it->office == se.office){\n      que.push(Event(0, e.time + dist[e.office][se.office], it->latter, se.office));\n      //printf(\"send2 : \"); print(*it);\n      it = lq.erase(it);\n    }else{\n      it++;\n    }\n  }\n  que.push(Event(1, e.time + 2 * dist[e.office][se.office], -1, e.office));\n  wait[e.office] = false;\n}\nint main(){\n  int N, M;\n  bool first = true;\n  while(cin >> N >> M && N){\n\n    if(first) first = false;\n    else cout << endl;\n\n    Graph G(N);\n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      G[a].push_back(Edge(a, b, c));\n      G[b].push_back(Edge(b, a, c));\n    }\n    int dist[36][36] = {};\n    REP(i, N) REP(j, N) dist[i][j] = (i != j) ? 100000000 : 0;\n    REP(i, N) FORIT(e, G[i]) dist[e->src][e->dst] = e->cost;\n    REP(k, N) REP(i, N) REP(j, N) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    // next[i][j] := 現在地i, 目的地jの郵便物の次の行き先\n    int next[36][36] = {};\n    memset(next, -1, sizeof(next));\n    REP(i, N) REP(j, N) if(i != j && !G[i].empty()){\n      next[i][j] = G[i][0].dst;\n      int n_cost = G[i][0].cost + dist[G[i][0].dst][j];\n      int edge_cost = G[i][0].cost;\n      FORIT(e, G[i]){\n        if(make_pair(n_cost, next[i][j]) > make_pair(e->cost + dist[e->dst][j], e->dst)){\n          n_cost = e->cost + dist[e->dst][j];\n          next[i][j] = e->dst;\n          edge_cost = e->cost;\n        }\n      }\n      assert(edge_cost == dist[i][next[i][j]]);\n    }\n    //REP(i, N) REP(j, N) printf(\"next[%d][%d] = %d\\n\", i, j, next[i][j]);\n\n    int L; cin >> L;\n    vector<Latter> latters(L);\n    priority_queue<Event, vector<Event>, greater<Event> > que;\n    vector< deque<Event> > l_que(N);\n    REP(i, L){\n      int time;\n      cin >> latters[i].src >> latters[i].dst >> time >> latters[i].name;\n      latters[i].src--; latters[i].dst--;\n      que.push(Event(0, time, i, latters[i].src));\n    }\n    vector<P> answer;\n    vector<bool> wait(N, true);\n    while(!que.empty()){\n      Event e = que.top(); que.pop();\n      print(e);\n      deque<Event>& lq = l_que[e.office];\n      if(e.type == 0){\n        Latter& l = latters[e.latter];\n        if(l.dst == e.office){\n          answer.push_back(P(e.time, l.name));\n        }else{\n          int to = next[e.office][l.dst];\n          assert(to != -1);\n          Event send(0, e.time, e.latter, to);\n          lq.insert(lower_bound(lq.begin(), lq.end(), send), send);\n          // send\n          if(wait[e.office] && (que.empty() || e.time != que.top().time || e.office != que.top().office)){\n            do_send(e, lq, que, dist, wait);\n          }\n        }\n      }else if(e.type == 1){\n        wait[e.office] = true;\n        if(!lq.empty()){\n          do_send(e, lq, que, dist, wait);\n        }\n      }\n    }\n    REP(i, N) assert(wait[i]);\n    REP(i, N) assert(l_que[i].empty());\n    sort(answer.begin(), answer.end());\n    assert(answer.size() == latters.size());\n    REP(i, answer.size()){\n      printf(\"%s %d\\n\", answer[i].second.c_str(), answer[i].first);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nInt e[40][40],g[40][40];\nsigned main(){\n  Int n,m;\n  Int first=0;\n  while(cin>>n>>m,n||m){\n    if(exchange(first,1)) cout<<endl;\n    memset(e,-1,sizeof(e));\n    for(Int i=0;i<m;i++){\n      Int a,b,c;\n      cin>>a>>b>>c;\n      a--;b--;\n      e[a][b]=e[b][a]=c;\n    }\n    \n    Int l;\n    cin>>l;\n    vector<Int> xs(l),ys(l),ts(l);\n    vector<string> ss(l);\n    for(Int i=0;i<l;i++){\n      cin>>xs[i]>>ys[i]>>ts[i]>>ss[i];\n      xs[i]--;\n      ys[i]--;\n    }\n\n    const Int INF = 1e15;\n    for(Int i=0;i<40;i++)\n      for(Int j=0;j<40;j++)\n        g[i][j]=~e[i][j]?e[i][j]:INF;\n    \n    for(Int i=0;i<40;i++) g[i][i]=0;\n\n    for(Int k=0;k<n;k++)\n      for(Int i=0;i<n;i++)\n        for(Int j=0;j<n;j++)\n          chmin(g[i][j],g[i][k]+g[k][j]);\n\n    using S = pair<Int, string>;    \n    vector<S> ans;\n    \n    using T = tuple<Int, Int, Int, Int>;\n    priority_queue<T, vector<T>, greater<T> > pq;\n    for(Int i=0;i<l;i++) pq.emplace(ts[i],xs[i],ts[i],i);\n\n    vector<Int> ws(n,0);\n    while(!pq.empty()){\n      T pt=pq.top();\n      Int t,v,a,k;\n      tie(t,v,a,k)=pt;\n      if(t<ws[v]){\n        pq.pop();\n        pq.emplace(ws[v],v,a,k);\n        continue;\n      }\n      \n      vector<Int> idxs,arrs;\n      while(!pq.empty()){\n        T qt=pq.top();\n        Int tt,vv,aa,idx;\n        tie(tt,vv,aa,idx)=qt;\n        if(t!=tt||v!=vv) break;\n        pq.pop();\n        idxs.emplace_back(idx);\n        arrs.emplace_back(aa);\n      }\n      ws[v]=t;\n      \n      Int arr=arrs[0];\n      vector<Int> nxts(idxs.size());\n      for(Int i=0;i<(Int)idxs.size();i++){\n        chmin(arr,arrs[i]);\n        Int y=ys[idxs[i]];\n        Int u=-1;\n        for(Int j=0;j<n;j++){\n          if(e[v][j]<0) continue;\n          if(e[v][j]+g[j][y]==g[v][y]){\n            u=j;\n            break;\n          }\n        }\n        nxts[i]=u;\n      }\n      \n      Int nxt=n;\n      for(Int i=0;i<(Int)idxs.size();i++)\n        if(arrs[i]==arr) chmin(nxt,nxts[i]);\n\n      ws[v]+=e[v][nxt]*2;\n      for(Int i=0;i<(Int)idxs.size();i++){\n        if(nxts[i]==nxt){\n          if(ys[idxs[i]]==nxt){\n            ans.emplace_back(t+e[v][nxt],ss[idxs[i]]);\n          }else{\n            pq.emplace(t+e[v][nxt],nxt,t+e[v][nxt],idxs[i]);\n          }\n        }else{\n          pq.emplace(ws[v],v,arrs[i],idxs[i]);\n        }\n      }\n    }\n    \n    sort(ans.begin(),ans.end());\n    for(auto p:ans) cout<<p.second<<\" \"<<p.first<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll INF =(1LL<<31);\n\ntypedef pair<ll,ll> Pii;\ntypedef pair<ll,string> Pis;\ntypedef pair< Pii , Pis > PP;\n\nll N,M,K;\nll G[32][32];\nll g[32][32];\n\nset< PP > u[32][32];\n\nll mem[32][32];\n\nll search(ll from,ll to){\n  if(mem[from][to]!=-1)return mem[from][to];\n  ll mini=INF, res=-1;\n  for(int i=0;i<N;i++){\n    if(from==i || g[from][i]==INF)continue;\n    if(mini>g[from][i]+G[i][to]){\n      mini=g[from][i]+G[i][to];\n      res=i;\n    }\n  }\n  assert(res!=-1);\n  return mem[from][to]=res;\n}\n\nvoid init(){\n  for(int i=0;i<32;i++){\n    for(int j=0;j<32;j++){\n      g[i][j]=(i==j?0:INF);\n      G[i][j]=(i==j?0:INF);\n      mem[i][j]=-1;\n      u[i][j].clear();\n    }\n  }\n}\n\nint main(){\n  ll cnt=0;\n  while(1){\n\n    init();\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    if(cnt)cout<<endl;\n    cnt++;\n    \n    for(int i=0;i<M;i++){\n      ll a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      G[a][b]=G[b][a]=c;\n    }\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        g[i][j]=G[i][j];\n    \n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n    \n    cin>>K;\n\n    map<ll, vector<PP> > mp;\n    set<ll> st;\n    \n    for(int i=0;i<K;i++){\n      ll from,to,ti;\n      string name;\n      cin>>from>>to>>ti>>name;\n      from--,to--;\n      mp[ti].push_back( PP( Pii(from,to) , Pis(0,name)) );\n      st.insert(ti);\n    }\n\n    vector< Pis > ans;\n    vector<ll> v(N,0);\n    ll last=-1;\n    \n    st.insert(0);\n    while(!st.empty()){\n\n      ll p=*st.begin();\n      assert( last < p ); last=p;\n      \n      if(mp.count(p)){\n        for(int i=0;i<(int)mp[p].size();i++){\n          PP pp=mp[p][i];\n          ll from=pp.first.first;\n          ll to=pp.first.second;\n          string name=pp.second.second;\n          ll key=search(from,to);\n          PP tmp=PP( Pii(p, key ) , Pis(to,name) );\n          u[from][key].insert(tmp);\n        }\n        //       mp[p].clear();\n      }\n      \n      for(int i=0;i<N;i++){\n        if(v[i]>p)continue;\n        \n        PP target=PP( Pii(INF,0) , Pis(0,\"\") );\n        \n        for(int j=0;j<N;j++){\n          if(u[i][j].empty())continue;\n          PP pp=*u[i][j].begin();\n          target=min(target,pp);\n        }\n        if(target.first.first==INF)continue;\n\n        ll nex=target.first.second;\n        \n        set< PP > :: iterator it;\n        for( it=u[i][nex].begin(); it!= u[i][nex].end() ; it++ ){\n          PP pp=*it;\n          ll to=pp.second.first;\n          string name=pp.second.second;\n\n          if(to==nex){\n            ans.push_back( Pis( p+g[i][nex] , name ) );\n          }else{\n            mp[ p+g[i][nex] ].push_back( PP(Pii(nex,to),Pis(0,name)) );\n          }\n        }// iterator\n        \n        u[i][nex].clear();\n        v[i]=p+g[i][nex]*2;\n        st.insert(p+g[i][nex]);\n        st.insert(p+g[i][nex]*2);\n      }// i\n      \n      st.erase(p);\n    }// while ( st.empty() )\n    \n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      Pis p=ans[i];\n      cout<<p.second<<' '<<p.first<<endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  06:38 - \n */\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cassert>\n#include<climits>\n#include<cstdio>\n#include<cmath>\n#include<map>\n#include<set>\n#include<deque>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define LLINF (LLONG_MAX)\n#define MAX_V 33\n#define MAX_E 500\n#define all(n) begin(n),end(n)\n\nusing namespace std;\n\nconst bool DEBUG = false;\n\ntypedef long long ll;\ntypedef pair<int,string> is;\n\nstruct Data{\n  ll to,cost;\n  Data(ll to=-1,ll cost=-1):to(to),cost(cost){}\n  bool operator < (const Data& data)const { return cost > data.cost; }\n};\n\nstruct Object{\n  ll from,to,timer;\n  string label;\n  ll priority;\n  Object(ll from=-1,ll to=-1,ll timer=-1,string label=\"\",ll priority=-1):from(from),to(to),timer(timer),label(label),priority(priority){}\n  bool operator < (const Object& obj)const {\n    if(priority != obj.priority)return priority < obj.priority;\n    if( timer != obj.timer )return timer < obj.timer;\n    return to < obj.to;\n  }\n};\n\nvector<Data> G[MAX_V];\nll mincost[MAX_V][MAX_V];\nll pre[MAX_V][MAX_V];\nll V,E,clist[MAX_V][MAX_V];\n\nvoid dijkstra(){\n  rep(i,V)REP(j,i,V)mincost[i][j] = mincost[j][i] = pre[i][j] = pre[j][i] = LLINF;\n  rep(goal,V){\n    mincost[goal][goal] = 0;\n    priority_queue<Data> Q;\n    Q.push(Data(goal,0));\n    while(!Q.empty()){\n      Data data = Q.top(); Q.pop();\n      ll cur = data.to;\n      ll cost = data.cost;\n      if( mincost[cur][goal] < cost )continue;\n      rep(i,(int)G[cur].size()){\n\tll next = G[cur][i].to;\n\tll ncost = G[cur][i].cost;\n\tif(mincost[next][goal] >= cost + ncost){\n\t  if(mincost[next][goal] == cost + ncost) pre[next][goal] = min(pre[next][goal],cur);\n\t  if(mincost[next][goal] > cost + ncost)  pre[next][goal] = cur;\n\t  mincost[next][goal] = cost + ncost;\n\t  Q.push(Data(next,mincost[next][goal]));\n\t}\n      }\n    }\n  }\n  if(DEBUG){\n  rep(i,V){\n    cout << \"from = \" << i << endl;\n    rep(j,V){\n      if( mincost[i][j] == LLINF )continue;\n      cout << \"to = \" << j << \" pre[\" << i << \"][\" << j << \"] = \" << pre[i][j] << \" cost = \" << mincost[i][j] << endl;\n    }\n    cout << endl;\n  }\n  }\n}\n\n\nvoid simulation(){\n  int n;\n  cin >> n;\n  ll *schedule = new ll[V]; // coefficient\n  rep(i,V)schedule[i] = 0;\n  deque<Object> *PostOffice = new deque<Object>[V];\n  deque<Object> item;\n  vector<is> ans;\n  rep(i,n){\n    ll sp,gp,tm;\n    string label;\n    cin >> sp >> gp >> tm >> label;\n    --sp,--gp;\n    item.push_back(Object(sp,gp,tm,label,0));\n  }\n  sort(all(item));\n\n  ll remain = n;\n  ll event_time = -1;\n  ll next_pos;\n  ll phase = 0;\n  ll pe = -1;\n  while(remain){\n    if(DEBUG)cout << \"remain = \"  << remain << \" let's start--------------------------\" << endl;\n    event_time = LLINF;\n    next_pos = -1;\n\n    if(!item.empty()){\n      sort(all(item));\n      event_time = item.front().timer;\n      if(DEBUG)cout << \"event_time first = > \" << event_time << endl;\n    }\n\n    rep(i,V)if(!PostOffice[i].empty()){\n      sort(all(PostOffice[i]));\n      rep(j,(int)PostOffice[i].size()){\n\tif(DEBUG)cout << \"check \" << event_time << \" > \" << PostOffice[i][j].timer + mincost[i][pre[i][PostOffice[i][j].to]] << \" ? \" << endl;\n\tif( event_time > PostOffice[i][j].timer+mincost[i][pre[i][PostOffice[i][j].to]]){\n\t    event_time = PostOffice[i][j].timer+mincost[i][pre[i][PostOffice[i][j].to]];\n\t    if(DEBUG)cout << \" new time : \" << event_time << endl;\n\t    next_pos = i;\n\t}\n      }\n    }\n    if( pe != event_time ){\n      phase++;\n    }\n    pe = event_time;\n    if(DEBUG)cout << \"event_time = \" << event_time << endl;\n    if( !item.empty() && event_time == item.front().timer){\n\n      while( !item.empty() && item.front().timer == event_time){\n\tObject obj = item.front(); item.pop_front();\n\tif( obj.from == obj.to ){\n\t  ans.push_back(is(obj.timer,obj.label));\n\t  remain--;\n\t  if(DEBUG)cout << \"finish! \" << obj.label << \" : \" << obj.timer << endl;\n\t  continue;\n\t}\n\n\tif(DEBUG)cout << \"push | from : \" << obj.from << \", to : \" << obj.to << \" \" << obj.label  << \" (\" << obj.timer << \",\" << obj.priority << \")\" << endl;\n\t//if(obj.timer > schedule[obj.from])schedule[obj.from] = obj.timer;\n\n\n\tobj.timer = max(obj.timer,schedule[obj.from]);\n\tobj.priority = phase;\n\tPostOffice[obj.from].push_back(obj);\n\tif(DEBUG)cout << \"QUEUE \" << obj.from << endl;\n\tsort(all(PostOffice[obj.from]));\n\tif(DEBUG){\n\t  rep(j,PostOffice[obj.from].size()){\n\t    cout << PostOffice[obj.from][j].label << \"(\" << PostOffice[obj.from][j].timer << \",\" << PostOffice[obj.from][j].priority << \") \" ;\n\t  } cout << endl;\n\t}\n\t//sort(PostOffice[obj.from].begin(),PostOffice[obj.from].end());\n      }\n      continue;\n    }\n    if(DEBUG)cout << \" ----------- \" << remain << endl;\n\n    assert(next_pos != -1);\n\n    vector<Object> use,tmp;\n    ll dest = PostOffice[next_pos].front().to;\n    if(DEBUG)cout << \"THE TOP : \" << PostOffice[next_pos].front().label << endl;\n    //int cur  = PostOffice[next_pos].front().from;\n    ll current_time = PostOffice[next_pos].front().timer;\n    for(Object& obj : PostOffice[next_pos]){\n      if( current_time >= obj.timer &&  pre[next_pos][dest] == pre[obj.from][obj.to] ){\n\tuse.push_back(obj);\n      } else {\n\ttmp.push_back(obj);\n      }\n    }\n    PostOffice[next_pos].clear();\n    rep(j,(int)tmp.size()){\n      tmp[j].timer = max(tmp[j].timer,use[0].timer+mincost[next_pos][pre[next_pos][dest]]*2);\n      if(DEBUG)cout << \"again,push  \" << tmp[j].label << \" time : \" << tmp[j].timer << \" again to \" << next_pos << endl;\n      //item.push_back(tmp[j]);\n      PostOffice[next_pos].push_back(tmp[j]);\n    }\n    //sort(all(item));\n    schedule[next_pos] = use[0].timer+mincost[next_pos][pre[next_pos][dest]]*2;\n    //if(DEBUG)cout << \"Aschedule[\" << next_pos << \"] = \" << schedule[next_pos] << endl;\n    rep(j,(int)use.size()){\n      if(DEBUG)cout << \"transport from \" << next_pos << \" to \" << pre[next_pos][dest] <<  \" : \"  << use[j].label << \" cost = \"; \n      use[j].timer += /*schedule[next_pos] +*/ mincost[next_pos][pre[next_pos][dest]];\n      if(DEBUG)cout << use[j].timer << endl;\n      use[j].from = pre[next_pos][dest];\n      use[j].priority = -1;\n      item.push_back(use[j]);\n    }\n\n    /*\n    rep(i,V){\n      //cout << \"schedule[\" << i << \"] \" << schedule[i] << endl;\n      if( schedule[i] > event_time ) continue;\n      //cout << \"post -> \" << i << endl;\n      vector<Object> use,tmp;\n      int next = IINF;\n      for(Object& obj : PostOffice[i]){\n\tif( next == IINF ){\n\t  next = obj.to;\n\t  use.push_back(obj);\n\t  continue;\n\t}\n\tif( obj.to == next ) use.push_back(obj);\n\telse                 tmp.push_back(obj);\n      }\n      //rep(j,(int)use.size())cout << \" --> \" << use[j].from << \",\" << use[j].to << \" \" << use[j].timer << \" \" << use[j].label << endl;\n      PostOffice[i].clear();\n      rep(j,(int)tmp.size())PostOffice[i].push_back(tmp[j]);\n      if( next == IINF )continue;\n      if( schedule[i] < use[0].timer ) schedule[i] = use[0].timer;\n      schedule[i] += clist[i][pre[i][next]];\n      rep(j,(int)use.size()){\n\tuse[j].timer = schedule[i];\n\tuse[j].from = pre[i][next];\n\titem.push_back(use[j]);\n      }\n\n    }\n    */\n  }\n  delete [] schedule;\n  delete [] PostOffice;\n  sort(all(ans));\n  rep(i,(int)ans.size()){\n    cout << ans[i].second << \" \" << ans[i].first << endl;\n  }\n}\n\n\nint main(){\n  bool F = true;\n  while(cin >> V >> E, V|E){\n    if(!F)puts(\"\");\n    F = false;\n    rep(i,V)G[i].clear();\n    rep(i,V)rep(j,V)clist[i][j] = LLINF;\n    rep(i,E){\n      int a,b,cost;\n      cin >> a >> b >> cost;\n      a--,b--;\n      G[a].push_back(Data(b,cost));\n      G[b].push_back(Data(a,cost));\n      clist[a][b] = clist[b][a] = cost;\n    }\n\n    dijkstra();\n\n    simulation();\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tint tm,pos,dist;\n\tstring name;\n\tpacket(int t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x], &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(int x,int y){\n\tconst packet &a=pac[x], &b = pac[y];\n\treturn a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tstring name;\n\tfor(;cin>>n>>m,n;){\n\t\tpriority_queue<int,vector<int>,cmp> qu;\n\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=-1;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n/*\n\t\tfor(j=1;j<=n;j++)printf(\"\\t%d\",j);\n\t\tfor(i=1;i<=n;i++,puts){\n\t\t\tprintf(\"\\n%d:\",i);\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tprintf(\"\\t%d(%d)\",len[i][j],to[i][j]);\n\t\t}\n\t\treturn 0;\n*/\n\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n\n\t\tfor(;!qu.empty();){\n//printf(\"size: %d\\n\",qu.size());\n\t\t\tint pi = qu.top();\n\t\t\tpacket &p = pac[pi];\n\t\t\tt = p.tm;\n\t\t\tf = p.pos;\n\t\t\tif( f == p.dist ){\n\t\t\t\tqu.pop();\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( t < bac[f] ){\n\t\t\t\tp.tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n//\t\t\t\tprintf(\"wait: %s\\n\",p.name.c_str());\n\t\t\t}else{\n\t\t\t\td = to[f][p.dist];\n//\t\t\t\tprintf(\"%d\\t%d -> %d\\t%s\\n\",p.tm,p.pos,t,p.name.c_str());\n\t\t\t\tbac[f] = p.tm + 2 * len[p.pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket &q = pac[qi];\n\t\t\t\t\tif(t==q.tm && f==q.pos && to[q.pos][q.dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq.tm += len[f][d];\n\t\t\t\t\t\tq.pos = d;\n\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tsort(pac.begin(),pac.end(),cmp2);\n//\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n//\t\tfor(j=0;j<l;j++)tbl[j]=j;\n//\t\tsort(tbl,tbl+l,cmp2);\n//\t\tfor(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),pac[tbl[j]].tm);\n\n\t\t**len = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tvector<int> to,c;\n};\n\nclass Trl\n{\npublic:\n\tint p,c,pv;\n\tTrl(int p, int c, int pv)\n\t:p(p),c(c),pv(pv)\n\t{}\n\t\n\tbool operator<(const Trl& t) const\n\t{\n\t\tif(c!=t.c) return c>t.c;\n\t\treturn p>t.p;\n\t}\n};\n\nint nt[32][32],ld[32][32];\nNode node[32];\n\nvoid Dijkstra(int src, int dst)\n{\n\tpriority_queue<Trl> q;\n\tq.push(Trl(src,0,src));\n\t\n\tint v[32];\n\tfor(int i=0; i<32; i++) v[i]=-1;\n\t\n\twhile(1)\n\t{\n\t\tTrl t=q.top(); q.pop();\n\t\tif(v[t.p]!=-1) continue;\n\t\tv[t.p]=t.pv;\n\t\t\n\t\tif(t.p==dst)\n\t\t{\n\t\t\tfor(int i=dst; v[i]!=i; i=v[i])\n\t\t\t\tnt[v[i]][dst]=i;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<node[t.p].to.size(); i++)\n\t\t{\n\t\t\tint next=node[t.p].to[i];\n\t\t\tif(v[next]!=-1) continue;\n\t\t\t\n\t\t\tq.push(Trl(next, t.c+node[t.p].c[i], t.p));\n\t\t}\n\t}\n}\n\nenum EV{BACK, GO};\n\nclass Event\n{\npublic:\n\tEV ev;\n\tint p, dst,t;\n\tstring n;\n\t\n\tEvent(int p, int dst, int t,EV ev, string n)\n\t:p(p),dst(dst),t(t),ev(ev),n(n)\n\t{}\n\t\n\tbool operator<(const Event& e) const\n\t{\n\t\tif(t!=e.t) return t>e.t;\n\t\tif(ev!=e.ev) return ev>e.ev;\n\t\treturn n>e.n;\n\t}\n};\n\nvoid Sim()\n{\n\tint K;\n\tscanf(\"%d\", &K);\n\tpriority_queue<Event> q;\n\twhile(K--)\n\t{\n\t\tint s,d,t;\n\t\tchar n[51];\n\t\tscanf(\"%d%d%d%s\",&s,&d,&t,n);\n\t\ts--; d--;\n\t\tq.push(Event(s,d,t,GO,string(n)));\n\t}\n\t\n\tint lv[32]={0};\n\twhile(!q.empty())\n\t{\n\t\tEvent e=q.top(); q.pop();\n\t\tif(e.ev==BACK)\n\t\t{\n\t\t\tlv[e.dst]=0;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif(e.dst==e.p)\n\t\t{\n\t\t\tprintf(\"%s %d\\n\", e.n.c_str(), e.t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(lv[e.p]!=0)\n\t\t\t{\n\t\t\t\tq.push(Event(e.p, e.dst, lv[e.p], e.ev, e.n));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint next=nt[e.p][e.dst], cst=e.t+ld[e.p][next];\n\t\t\t\tlv[e.p]=cst+ld[e.p][next];\n\t\t\t\tq.push(Event(next, e.dst, cst, e.ev, e.n));\n\t\t\t\tq.push(Event(e.p,e.p, lv[e.p], BACK, \"\"));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint N,M;\n\tbool fr=true;\n\twhile(scanf(\"%d%d\", &N, &M), (N||M))\n\t{\n\t\tfor(int i=0; i<32; i++)\n\t\t{\n\t\t\tnode[i].to.clear();\n\t\t\tnode[i].c.clear();\n\t\t}\n\t\twhile(M--)\n\t\t{\n\t\t\tint s,d,c;\n\t\t\tscanf(\"%d%d%d\", &s,&d,&c);\n\t\t\ts--; d--;\n\t\t\t\n\t\t\tnode[s].to.push_back(d);\n\t\t\tnode[d].to.push_back(s);\n\t\t\tnode[s].c.push_back(c);\n\t\t\tnode[d].c.push_back(c);\n\t\t\tld[s][d]=c;\n\t\t\tld[d][s]=c;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\tDijkstra(i,j);\n\t\t\t\n\t\tif(!fr) puts(\"\");\n\t\tfr=false;\n\t\t\n\t\tSim();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n\nint n, m, l;\nvector<vi> dist, nx;\ntypedef pair<int, string> Item;\n\nstruct Event\n{\n\tint time, office;\n\tint eve; //  0 -> ??°??£?????????, 1 -> ???????????????????????????\n\tItem item;\n\n\tbool operator < (const Event& e) const \n\t{ \n\t\tif (time != e.time) return time > e.time;\n\t\telse return eve > e.eve;\n\t}\n};\n\nvector<Item> getItem(int office, set<pair<Item, int>> &que)\n{\n\tll time = LLONG_MAX / 100; int to = 10000;\n\tfor (auto i : que)\n\t{\n\t\tif (i.second < time)\n\t\t{\n\t\t\ttime = i.second;\n\t\t\tto = nx[office][i.first.first];\n\t\t}\n\t\telse if (i.second == time)\n\t\t{\n\t\t\tchmin(to, nx[office][i.first.first]);\n\t\t}\n\t}\n\tvector<Item> res;\n\tvector<pair<Item, int>> er;\n\tfor (auto i : que)\n\t{\n\t\tif (nx[office][i.first.first] == to)\n\t\t{\n\t\t\ter.push_back(i);\n\t\t\tres.push_back(i.first);\n\t\t}\n\t}\n\tfor (auto i : er) que.erase(i);\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tbool start = true;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tif (!start) cout << endl;\n\t\tstart = false;\n\t\tdist.clear(), nx.clear();\n\t\tdist.resize(n, vi(n, INF));\n\t\tnx.resize(n, vi(n));\n\t\tREP(i, n)REP(j, n)\n\t\t{\n\t\t\tif (i == j) dist[i][j] = 0;\n\t\t\tnx[i][j] = j;\n\t\t}\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdist[a][b] = c;\n\t\t\tdist[b][a] = c;\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n)\n\t\t{\n\t\t\tif (dist[i][j] > dist[i][k] + dist[k][j])\n\t\t\t{\n\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];\n\t\t\t\tnx[i][j] = nx[i][k];\n\t\t\t}\n\t\t\telse if (k != i && dist[i][j] == dist[i][k] + dist[k][j])\n\t\t\t{\n\t\t\t\tnx[i][j] = min(nx[i][j], nx[i][k]);\n\t\t\t}\n\t\t}\n\t\n\t\tpriority_queue<Event> events;\n\t\tcin >> l;\n\t\tREP(i, l)\n\t\t{\n\t\t\tint a, b, t; string s;\n\t\t\tcin >> a >> b >> t >> s;\n\t\t\ta--; b--;\n\t\t\tevents.push(Event{ t,a,1,Item(b, s) });\n\t\t}\n\t\tvector<bool> officer(n, true);\n\t\tvector<set<pair<Item, int>>> que(n); //????????¨??????\n\n\t\tint now = -1;\n\t\tvs reach;\n\t\twhile (1)\n\t\t{\n\t\t\tif (events.empty())\n\t\t\t{\n\t\t\t\tbool f = true;\n\t\t\t\tREP(i, que.size()) if (!que.empty()) f = false;\n\t\t\t\tif(f) break;\n\t\t\t}\n\t\t\tif (events.empty() || events.top().time != now)\n\t\t\t{\n\t\t\t\tbool f = true;\n\t\t\t\tsort(ALL(reach));\n\t\t\t\tfor(auto i: reach)\n\t\t\t\t{ \n\t\t\t\t\tcout << i << \" \" << now << endl;\n\t\t\t\t}\n\t\t\t\treach.clear();\n\t\t\t\tREP(i, n)\n\t\t\t\t{\n\t\t\t\t\tif (!officer[i] || que[i].empty()) continue;\n\t\t\t\t\tf = false;\n\t\t\t\t\tvector<Item> send = getItem(i, que[i]);\n\t\t\t\t\tint next_office = nx[i][get<0>(send[0])];\n\t\t\t\t\tint d = dist[i][next_office];\n\t\t\t\t\tofficer[i] = false;\n\t\t\t\t\tevents.push(Event{ now + d * 2 ,i, 0 });\n\t\t\t\t\tfor (auto item : send)\n\t\t\t\t\t{\n\t\t\t\t\t\tevents.push(Event{ now + d, next_office,  1, item });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f)\n\t\t\t\t{\n\t\t\t\t\tif (events.empty()) break;\n\t\t\t\t\telse now = events.top().time;\n\t\t\t\t}\n\t\t\t\telse continue;\n\t\t\t}\n\n\t\t\tEvent tmp = events.top();\n\t\t\tevents.pop();\n\t\t\tif (tmp.eve == 0)\n\t\t\t{\n\t\t\t\tofficer[tmp.office] = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (tmp.item.first == tmp.office)\n\t\t\t\t{\n\t\t\t\t\treach.push_back(tmp.item.second);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tque[tmp.office].emplace(tmp.item, tmp.time);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nconst long long INF = 1e10;\ntypedef vector<vector<long long>> Matrix;\n\nstruct Event {\n  long long time;\n  function<void ()> proc;\n\n  Event(long long time, function<void ()> proc): time(time), proc(proc) {}\n  bool operator<(const Event& rhs) const { return time > rhs.time; }\n};\n\nstruct Packet {\n  int src, dst;\n  string name;\n\n  Packet(int src, int dst, const string& name): src(src), dst(dst), name(name) {}\n};\n\nenum OfficeState { FREE, BUSY };\n\nstruct Office {\n  OfficeState state;\n  multimap<pair<int, int>, Packet> packets;\n\n  Office(): state(FREE) {}\n};\n\nMatrix shortestPath(const Matrix& g) {\n  int n = g.size();\n  Matrix dist(g);\n  for (int k = 0; k < n; ++k)\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n  return dist;\n}\n\nint nextVertex(const Matrix& g, const Matrix& dist, int s, int t) {\n  int n = dist.size();\n  for (int v = 0; v < n; ++v)\n    if (v != s && g[s][v] + dist[v][t] == dist[s][t])\n      return v;\n  assert(false);\n}\n\nint n, m;\nMatrix g, dist;\nvector<Office> offices;\nvector<pair<int, string>> result;\npriority_queue<Event> Q;\n\nvoid onReturn(int time, int office) {\n  offices[office].state = FREE;\n}\n\nvoid onReceive(int time, int office, const vector<Packet>& packets) {\n  Office& o = offices[office];\n  for (auto packet : packets) {\n    if (packet.dst == office) {\n      result.push_back({time, packet.name});\n    } else {\n      int next = nextVertex(g, dist, office, packet.dst);\n      o.packets.insert({{time, next}, packet});\n    }\n  }\n}\n\nvoid deliver(int time, int office) {\n  Office& o = offices[office];\n  if (o.state == BUSY || o.packets.empty()) return;\n  o.state = BUSY;\n  auto range = o.packets.equal_range(o.packets.begin()->first);\n  int next = range.first->first.second;\n  int t1 = time + g[office][next];\n  int t2 = t1 + g[office][next];\n  vector<Packet> ps;\n  for (auto it = range.first; it != range.second; ++it)\n    ps.push_back(it->second);\n  Q.push({t1, bind(onReceive, t1, next, ps)});\n  Q.push({t2, bind(onReturn, t2, office)});\n  o.packets.erase(range.first, range.second);\n}\n\nint main() {\n  for (int T = 0; cin >> n >> m, n | m; ++T) {\n    if (T > 0) { cout << endl; }\n    result.clear();\n    g.assign(n, vector<long long>(n, INF));\n\n    for (int i = 0; i < m; ++i) {\n      int a, b, c; cin >> a >> b >> c; --a; --b;\n      g[a][b] = g[b][a] = c;\n    }\n    for (int i = 0; i < n; ++i)\n      g[i][i] = 0;\n\n    dist = shortestPath(g);\n    offices.assign(n, Office());\n\n    int l; cin >> l;\n    for (int i = 0; i < l; ++i) {\n      int src, dst;\n      long long time;\n      string name;\n      cin >> src >> dst >> time >> name; --src; --dst;\n      Q.push({time, bind(onReceive, time, src, vector<Packet>{{src, dst, name}})});\n    }\n\n    while (!Q.empty()) {\n      int time = Q.top().time;\n      do {\n        Event e = Q.top(); Q.pop();\n        e.proc();\n      } while (!Q.empty() && Q.top().time == time);\n      for (int i = 0; i < n; ++i)\n        deliver(time, i);\n    }\n\n    sort(result.begin(), result.end());\n    for (auto p : result)\n      cout << p.second << \" \" << p.first << endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\n\n#ifdef PROFILE\n#include <time.h>\n#define time _time\n#endif\n\n#define MAX_LEN 64\n\n#define MAX_NODE 32\n#define MAX_MAIL 1000\n#define MAX_LABEL 50+1\n\n#define MAX_TIME (1<<31)\n#define MAX_DIST 10000\n#define MAX_DISTSUM 320000\n\n#define TRUE 1\n#define FALSE 0\n\ntypedef enum {\n\tNONE, /* Í¯çêÄ¢È¢ */\n\tPOST, /* XÖÇÉ é */\n\tDELI, /* zB */\n\tDONE  /* zB®¹ */\n} MailState;\n\ntypedef enum {\n\tHERE, /* zBõª¢é */\n\tGO,   /* zBõªÚInÉü©ÁÄ¢é */\n\tBACK  /* zBõªÚIn©çAÁÄ«Ä¢é */\n} NodeState;\n\ntypedef struct _Mail{\n\tMailState state;    /* [ÌóÔ */\n\tunsigned long timer;          /* XÖÇÉÍ­Ô */\n\tstruct _Mail *next; /* ÉÍ¢½[ */\n\tint src;            /* a©èê */\n\tint dst;            /* ÅIÍ¯æ */\n\tchar label[MAX_LABEL]; /* x */\n} Mail;\n\ntypedef struct {\n\tNodeState state;    /* zBõÌóÔ */\n\tunsigned long timer;          /* zBõªÚ®µIíéÔ */\n\tint dst;            /* zBõÌÚIn */\n\tshort dist[MAX_NODE]; /* ]oHÌ£ */\n\tchar distf[MAX_NODE]; /* ÅZ£vZÏÝtO*/\n\tint distnext[MAX_NODE]; /* ÅZ£ÌÆ«É^Ôm[h*/\n\tMail *post_queue;        /* Í¢Ä¢é[ */\n\tMail *deli_queue;        /* zBÌ[ */\n} Node;\n\n/* nÂÌXÖÇim[hjÌú» */\nvoid init_nodes(int n);\n\n/* Í¯çêÄ¢È¢[Ì */\nint check_mail(int l);\n/* XÖÇÔÌÅZ£vZ */\nint calc_dist(int a, int b);\n/* èzBJn */\nvoid take_mail(int n);\n/* [Ì */\nvoid post_mail(Mail *m);\n/* zB®¹ */\nvoid arrive_mail(int n);\n/* zBõÌAÒõ */\nvoid go_back(int n);\n/* zB®¹[Ì\\¦ */\nvoid print_arrive(void);\n\n\nvoid del_mail(Mail **q,Mail *mail);\nvoid add_mail(Mail **q,Mail *mail);\n\nint compare_mail(const void* a, const void* b);\n\nNode node[MAX_NODE]; /* XÖÇXg */\nint node_num; /* XÖÇgp */\nMail mail[MAX_MAIL]; /* [Xg */\nint mail_num; /* [gp */\nint posted; /* ÏÝ[Ô */\nMail *arrive[MAX_MAIL];/* zB®¹[Xg */\nint arrive_cnt;/* zB®¹[ */\n\nunsigned long time = 0; /* V~[VÔ */\n\nint main(){\n\tchar buf[MAX_LEN];\n\tint i;\n\tint n,m;\n\tint a,b,d;\n\tint l;\n\tunsigned long min; /* ñ­Î·é^C}l */\n#ifdef PROFILE\n\tclock_t c_input=0, c_init=0, c_all=0, c_sim=0, c_take=0, c_arrive=0, c_mail=0, c_print=0;\n\n\tc_all-=clock();\n#endif\n\t\n\twhile(fgets(buf,MAX_LEN,stdin)!=NULL){\n\t\tif(sscanf(buf,\"%d %d\",&n,&m)<2){\n\t\t\tfprintf(stderr,\"error:invalid input\\n\");\n\t\t}else{\n\t\t\t/* 0 0 ¾Á½çI¹ */\n\t\t\tif(n<2||m<1)break;\n\t\t\t/* KvÈª¾¯ú» */\n#ifdef PROFILE\n\t\t\tc_init-=clock();\n#endif\n\t\t\tinit_nodes(n);\n#ifdef PROFILE\n\t\t\tc_init+=clock();\n\t\t\tc_input-=clock();\n#endif\n\t\t\t/* ]oHÇÝæè */\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 0;\n\t\t\t\tif(sscanf(buf,\"%d %d %d\",&a,&b,&d)<3)return 0;\n\t\t\t\t/* 0IWÉ·é½ß-1 */\n\t\t\t\tnode[a-1].dist[b-1] = d;\n\t\t\t\tnode[b-1].dist[a-1] = d;\n\t\t\t\tnode[a-1].distnext[b-1] = b-1;\n\t\t\t\tnode[b-1].distnext[a-1] = a-1;\n\t\t\t}\n\t\t\t/* [ÇÝæè */\n\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 0;\n\t\t\tif(sscanf(buf,\"%d\",&l)<1)return 0;\n\t\t\t/* [îñÇÝæè */\n\t\t\tmin = MAX_TIME;/* ÅÉ­Î·é^C}Í[ */\n\t\t\tfor(i=0;i<l;i++){\n\t\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 0;\n\t\t\t\tif(sscanf(buf,\"%d %d %d %[a-zA-Z0-9-_]\",\n\t\t\t\t\t&(mail[i].src),&(mail[i].dst),&(mail[i].timer),mail[i].label)<4)return 0;\n\t\t\t\t/* 0IWÉ·é½ß-1 */\n\t\t\t\tmail[i].src--;\n\t\t\t\tmail[i].dst--;\n\t\t\t\tmail[i].state = NONE;\n\t\t\t\tmail[i].next = NULL;\n\t\t\t\tif(min>mail[i].timer)min = mail[i].timer;\n\t\t\t}\n\t\t\tnode_num = n;\n\t\t\tmail_num = l;\n#ifdef PROFILE\n\t\t\tc_input+=clock();\n\t\t\tc_sim-=clock();\n#endif\n\n\t\t\t/* V~[VJn */\n\t\t\ttime = min;\n\t\t\tarrive_cnt = 0;\n\t\t\tposted = 0;\n\t\t\twhile(check_mail(l)!=0){/* S[ªzBI¹·éÜÅ */\n\t\t\t\tmin = MAX_TIME;\n#ifdef PROFILE\n\t\t\t\tc_mail-=clock();\n#endif\n\t\t\t\t/* èªÍ­ */\n\t\t\t\tfor(i=posted;mail[i].timer==time;i++){\n\t\t\t\t\tpost_mail(&mail[i]);\n\t\t\t\t\tposted++;\n\t\t\t\t}\n\t\t\t\tif(posted<mail_num)\tmin = mail[posted].timer;\n#ifdef PROFILE\n\t\t\t\tc_mail+=clock();\n#endif\n\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\t/* zBõª·é */\n\t\t\t\t\tif(node[i].timer == time){\n\t\t\t\t\t\tif(node[i].state == GO){\n#ifdef PROFILE\n\t\t\t\tc_arrive-=clock();\n#endif\n\t\t\t\t\t\t\tarrive_mail(i);\n#ifdef PROFILE\n\t\t\t\tc_arrive+=clock();\n#endif\n\t\t\t\t\t\t\tgo_back(i);\n\t\t\t\t\t\t}else if(node[i].state == BACK){\n\t\t\t\t\t\t\tnode[i].timer = 0;\n\t\t\t\t\t\t\tnode[i].state = HERE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* zBõªo­·é */\n\t\t\t\t\tif(node[i].state == HERE){\n#ifdef PROFILE\n\t\t\t\tc_take-=clock();\n#endif\n\t\t\t\t\t\ttake_mail(i);\n#ifdef PROFILE\n\t\t\t\tc_take+=clock();\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tif(node[i].timer && min>node[i].timer)min=node[i].timer;\n\t\t\t\t}\n#ifdef PROFILE\n\t\t\t\tc_print-=clock();\n#endif\n\t\t\t\tprint_arrive();\n#ifdef PROFILE\n\t\t\t\tc_print+=clock();\n#endif\n\t\t\t\ttime=min;\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n#ifdef PROFILE\n\t\t\tc_sim+=clock();\n#endif\n\t\t}\n\t}\n#ifdef PROFILE\n\tc_all+=clock();\n\tprintf(\n\t\t\"init:  %d\\n\"\n\t\t\"input: %d\\n\"\n\t\t\"sim:   %d\\n\"\n\t\t\" mail: %d\\n\"\n\t\t\" arriv:%d\\n\"\n\t\t\" take: %d\\n\"\n\t\t\" print:%d\\n\"\n\t\t\"all:   %d\\n\"\n\t\t,c_init, c_input, c_sim, c_mail, c_arrive, c_take, c_print, c_all);\n#endif\n\treturn 0;\n}\n\nvoid init_nodes(int n){\n\tint i,j;\n\tfor(i=0;i<n;i++){\n\t\tnode[i].state = HERE;\n\t\tnode[i].timer = 0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tnode[i].dist[j] = MAX_DIST;\n\t\t\tnode[i].distf[j] = FALSE;\n\t\t\tnode[i].distnext[j] = -1;\n\t\t}\n\t\tnode[i].dist[i] = 0;\n\t\tnode[i].distf[i] = TRUE;\n\t\tnode[i].distnext[i] = i;\n\t\tnode[i].dst = -1;\n\t\tnode[i].post_queue = NULL;\n\t\tnode[i].deli_queue = NULL;\n\t}\n}\n\nint check_mail(int l){\n\tint i,cnt;\n\tcnt=0;\n\tfor(i=0;i<l;i++){\n\t\tif(mail[i].state != DONE)cnt++;\n\t}\n\treturn cnt;\n}\n\nvoid post_mail(Mail *m){\n\tadd_mail(&(node[m->src].post_queue),m);\n\tm->state = POST;\n}\n\nvoid take_mail(int n){\n\tMail *que,**q,*tmp;\n\n\t/* zB·é[ª é©H */\n\tif(node[n].post_queue!=NULL){\n\n\t\t/* ÅÌ[ðzBXgÖÚ® */\n\t\tque = node[n].post_queue;\n\t\tdel_mail(&(node[n].post_queue),que);\n\t\tadd_mail(&(node[n].deli_queue),que);\n\n\t\tque->state = DELI;\n\t\tnode[n].state = GO;\n\t\tnode[n].timer = time+calc_dist(n,que->dst);/* »Ý{ÚWnÜÅÌ£ */\n\t\tnode[n].dst = node[n].distnext[que->dst];\n\n\t\t/* ¯¶Í¯æÌ[ðzBXgÖÚ® */\n\t\tq = &(node[n].post_queue);\n\t\twhile(*q != NULL){\n\t\t\tif((*q)->dst == que->dst){\n\t\t\t\ttmp = *q;\n\t\t\t\ttmp->state = DELI;\n\t\t\t\tdel_mail(q,tmp);\n\t\t\t\tadd_mail(&(node[n].deli_queue),tmp);\n\t\t\t}else{\n\t\t\t\tq = &((*q)->next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid arrive_mail(int n){\n\tMail *tmp;\n\n\twhile(node[n].deli_queue != NULL){\n\t\ttmp = node[n].deli_queue;\n\t\tdel_mail(&(node[n].deli_queue),tmp);\n\t\tif(tmp->dst==node[n].dst){\n\t\t\t/* ÅIÍ¯æÉ */\n\t\t\tarrive[arrive_cnt] = tmp;\n\t\t\tarrive_cnt++;\n\t\t\ttmp->state = DONE;\n\t\t}else{\n\t\t\t/* ³çÉ] */\n\t\t\tadd_mail(&(node[node[n].distnext[tmp->dst]].post_queue),tmp);\n\t\t\ttmp->state = POST;\n\t\t}\n\t}\n\n}\n\nvoid go_back(int n){\n\tnode[n].state = BACK;\n\tnode[n].timer = time + node[n].dist[node[n].dst];\n}\n\nvoid del_mail(Mail **q,Mail *mail){\n\twhile((*q)!=NULL && (*q)!=mail)q = &((*q)->next);\n\tif((*q)==mail){\n\t\t*q = mail->next;\n\t\tmail->next = NULL;\n\t}\n}\n\nvoid add_mail(Mail **q,Mail *mail){\n\twhile((*q)!=NULL)q = &((*q)->next);\n\tmail->next = NULL;\n\t*q = mail;\n}\n\n\n\nint calc_dist(int a, int b){\n\tstatic char past[MAX_NODE];/* ßÉÊÁ½m[h */\n\tstatic char best[MAX_NODE];/* ÅZÌm[h */\n\tstatic int past_n = 0; /* ßÉÊÁ½m[h */\n\tstatic int dist = 0;  /* ßÉÊÁÄ«½£ */\n\tstatic int bestd = MAX_DISTSUM;  /* ÅZÌ£ */\n\tint i,j;\n\n\tif(past_n==0) bestd = MAX_DISTSUM;/* TõJnú» */\n\n\tpast[past_n++] = a;\n\n\t/* ½Çè¢½Æ« */\n\tif(a==b){\n\t\t/* ¡ñÌoHªÅZÅ êÎÅZoHðXV */\n\t\tif(bestd>dist){\n\t\t\tbestd = dist;\n\t\t\tfor(i=0;i<past_n;i++)best[i]=past[i];\n\t\t}\n\t}else{\n\t\tif(dist<bestd){\n\t\t\t/* êxvZ³êÄ¢é */\n\t\t\tif(node[a].distf[b]==TRUE){\n\t\t\t\ti = node[a].distnext[b];\n\t\t\t\tfor(j=0;j<past_n;j++)if(past[j]==i)return -1;\n\t\t\t\tdist += node[a].dist[i];\n\t\t\t\tcalc_dist(i,b);\n\t\t\t\tdist -= node[a].dist[i];\n\t\t\t}else{\n\t\t\t\tfor(i=0;i<node_num;i++){\n\t\t\t\t\tfor(j=0;j<past_n;j++)if(past[j]==i)break;\n\t\t\t\t\tif(j!=past_n)continue;\n\t\t\t\t\tif(MAX_DIST>node[a].dist[i]){\n\t\t\t\t\t\tdist += node[a].dist[i];\n\t\t\t\t\t\tcalc_dist(i,b);\n\t\t\t\t\t\tdist -= node[a].dist[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpast_n--;\n\n\t/* TõI¹Ê½f */\n\tif(past_n==0){\n\t\tfor(i=0;best[i]!=b;i++){\n\t\t\tnode[best[i]].distnext[b] = best[i+1];\n\t\t\tnode[best[i+1]].distnext[a] = best[i];\n\t\t\tnode[best[i]].distf[b] = TRUE;\n\t\t\tnode[best[i+1]].distf[a] = TRUE;\n\t\t}\n\t\treturn  node[a].dist[node[a].distnext[b]];\n\t}\n\treturn  0;\n}\n\nvoid print_arrive(void){\n\tint i;\n\tif(arrive_cnt > 0){\n\t\tqsort(arrive,arrive_cnt,sizeof(Mail*),compare_mail);\n\t\tfor(i=0;i<arrive_cnt;i++){\n\t\t\tprintf(\"%s %d\\n\",arrive[i]->label,time);\n\t\t}\n\t}\n\tarrive_cnt = 0;\n}\n\t\n\nint compare_mail(const void* a, const void* b){\n\treturn strcmp((*(Mail**)a)->label,(*(Mail**)b)->label);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LEN 64\n\n#define MAX_NODE 32\n#define MAX_MAIL 1000\n#define MAX_LABEL 50+1\n\n#define TRUE 1\n#define FALSE 0\n\ntypedef enum {\n\tNONE, /* Í¯çêÄ¢È¢ */\n\tPOST, /* XÖÇÉ é */\n\tDELI, /* zB */\n\tDONE  /* zB®¹ */\n} MailState;\n\ntypedef enum {\n\tHERE, /* zBõª¢é */\n\tGO,   /* zBõªÚInÉü©ÁÄ¢é */\n\tBACK  /* zBõªÚIn©çAÁÄ«Ä¢é */\n} NodeState;\n\ntypedef struct _Mail{\n\tMailState state;    /* [ÌóÔ */\n\tint src;            /* a©èê */\n\tint dst;            /* ÅIÍ¯æ */\n\tlong timer;          /* XÖÇÉÍ­Ô */\n\tchar label[MAX_LABEL]; /* x */\n\tstruct _Mail *next; /* ÉÍ¢½[ */\n} Mail;\n\ntypedef struct {\n\tNodeState state;    /* zBõÌóÔ */\n\tlong timer;          /* zBõªÚ®µIíéÔ */\n\tint dst;            /* zBõÌÚIn */\n\tshort dist[MAX_NODE]; /* ]oHÌ£ */\n\tchar distf[MAX_NODE]; /* ÅZ£vZÏÝtO*/\n\tint distnext[MAX_NODE]; /* ÅZ£ÌÆ«É^Ôm[h*/\n\tMail *post_queue;        /* Í¢Ä¢é[ */\n\tMail *deli_queue;        /* zBÌ[ */\n} Node;\n\n/* nÂÌXÖÇim[hjÌú» */\nvoid init_nodes(int n);\n\n/* Í¯çêÄ¢È¢[Ì */\nint check_mail(int l);\n/* XÖÇÔÌÅZ£vZ */\nint calc_dist(int a, int b);\n/* èzBJn */\nvoid take_mail(int n);\n/* [Ì */\nvoid post_mail(int i);\n/* zB®¹ */\nvoid arrive_mail(int n);\n/* zBõÌAÒõ */\nvoid go_back(int n);\n/* zB®¹[Ì\\¦ */\nvoid print_arrive(void);\n\n\nvoid del_mail(Mail **q,Mail *mail);\nvoid add_mail(Mail **q,Mail *mail);\n\nint compare_mail(const void* a, const void* b);\n\nNode node[MAX_NODE]; /* XÖÇXg */\nint node_num; /* XÖÇgp */\nMail mail[MAX_MAIL]; /* [Xg */\nint mail_num; /* [gp */\nMail *arrive[MAX_MAIL];/* zB®¹[Xg */\nint arrive_cnt;/* zB®¹[ */\n\nlong time = 0; /* V~[VÔ */\n\nint main(){\n\tchar buf[MAX_LEN];\n\tint i;\n\tint n,m;\n\tint a,b,d;\n\tint l;\n\t\n\twhile(fgets(buf,MAX_LEN,stdin)!=NULL){\n\t\tif(sscanf(buf,\"%d %d\",&n,&m)<2){\n\t\t\tfprintf(stderr,\"error:invalid input\\n\");\n\t\t}else{\n\t\t\t/* 0 0 ¾Á½çI¹ */\n\t\t\tif(n<2||m<1)break;\n\t\t\t/* KvÈª¾¯ú» */\n\t\t\tinit_nodes(n);\n\t\t\t/* ]oHÇÝæè */\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 1;\n\t\t\t\tif(sscanf(buf,\"%d %d %d\",&a,&b,&d)<3)return 1;\n\t\t\t\t/* 0IWÉ·é½ß-1 */\n\t\t\t\tnode[a-1].dist[b-1] = d;\n\t\t\t\tnode[b-1].dist[a-1] = d;\n\t\t\t\tnode[a-1].distnext[b-1] = b-1;\n\t\t\t\tnode[b-1].distnext[a-1] = a-1;\n\t\t\t}\n\t\t\t/* [ÇÝæè */\n\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 1;\n\t\t\tif(sscanf(buf,\"%d\",&l)<1)return 1;\n\t\t\t/* [îñÇÝæè */\n\t\t\tfor(i=0;i<l;i++){\n\t\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 1;\n\t\t\t\tif(sscanf(buf,\"%d %d %d %[a-zA-Z0-9-_]\",\n\t\t\t\t\t&(mail[i].src),&(mail[i].dst),&(mail[i].timer),mail[i].label)<4)return 1;\n\t\t\t\t/* 0IWÉ·é½ß-1 */\n\t\t\t\tmail[i].src--;\n\t\t\t\tmail[i].dst--;\n\t\t\t\tmail[i].state = NONE;\n\t\t\t\tmail[i].next = NULL;\n\t\t\t}\n\t\t\tnode_num = n;\n\t\t\tmail_num = l;\n\n\t\t\t/* V~[VJn */\n\t\t\ttime = 0;\n\t\t\tarrive_cnt = 0;\n\t\t\twhile(check_mail(l)!=0){/* S[ªzBI¹·éÜÅ */\n\t\t\t\t/* èªÍ­ */\n\t\t\t\tfor(i=0;i<l;i++){\n\t\t\t\t\tif( (mail[i].state == NONE)\n\t\t\t\t\t  &&(mail[i].timer <= time) ){\n\t\t\t\t\t\tpost_mail(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\t/* zBõª·é */\n\t\t\t\t\tif(node[i].timer == time){\n\t\t\t\t\t\tif(node[i].state == GO){\n\t\t\t\t\t\t\tarrive_mail(i);\n\t\t\t\t\t\t\tgo_back(i);\n\t\t\t\t\t\t}else if(node[i].state == BACK){\n\t\t\t\t\t\t\tnode[i].state = HERE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* zBõªo­·é */\n\t\t\t\t\tif(node[i].state == HERE){\n\t\t\t\t\t\ttake_mail(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprint_arrive();\n\t\t\t\ttime++;\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid init_nodes(int n){\n\tint i,j;\n\tfor(i=0;i<n;i++){\n\t\tnode[i].state = HERE;\n\t\tnode[i].timer = 0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tnode[i].dist[j] = 10000;\n\t\t\tnode[i].distf[j] = FALSE;\n\t\t\tnode[i].distnext[j] = 10000;\n\t\t}\n\t\tnode[i].dist[i] = 0;\n\t\tnode[i].distf[i] = TRUE;\n\t\tnode[i].distnext[i] = i;\n\t\tnode[i].dst = -1;\n\t\tnode[i].post_queue = NULL;\n\t\tnode[i].deli_queue = NULL;\n\t}\n}\n\nint check_mail(int l){\n\tint i,cnt;\n\tcnt=0;\n\tfor(i=0;i<l;i++){\n\t\tif(mail[i].state != DONE)cnt++;\n\t}\n\treturn cnt;\n}\n\nvoid post_mail(int i){\n\tadd_mail(&(node[mail[i].src].post_queue),&mail[i]);\n\tmail[i].state = POST;\n}\n\nvoid take_mail(int n){\n\tMail *que,**q,*tmp;\n\n\t/* zB·é[ª é©H */\n\tif(node[n].post_queue!=NULL){\n\n\t\t/* ÅÌ[ðzBXgÖÚ® */\n\t\tque = node[n].post_queue;\n\t\tdel_mail(&(node[n].post_queue),que);\n\t\tadd_mail(&(node[n].deli_queue),que);\n\n\t\tque->state = DELI;\n\t\tnode[n].state = GO;\n\t\tnode[n].timer = time+calc_dist(n,que->dst);/* »Ý{ÚWnÜÅÌ£ */\n\t\tnode[n].dst = node[n].distnext[que->dst];\n\n\t\t/* ¯¶Í¯æÌ[ðzBXgÖÚ® */\n\t\tq = &(node[n].post_queue);\n\t\twhile(*q != NULL){\n\t\t\tif((*q)->dst == que->dst){\n\t\t\t\ttmp = *q;\n\t\t\t\ttmp->state = DELI;\n\t\t\t\tdel_mail(q,tmp);\n\t\t\t\tadd_mail(&(node[n].deli_queue),tmp);\n\t\t\t}else{\n\t\t\t\tq = &((*q)->next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid arrive_mail(int n){\n\tMail *tmp;\n\n\twhile(node[n].deli_queue != NULL){\n\t\ttmp = node[n].deli_queue;\n\t\tdel_mail(&(node[n].deli_queue),tmp);\n\t\tif(tmp->dst==node[n].dst){\n\t\t\t/* ÅIÍ¯æÉ */\n\t\t\tarrive[arrive_cnt] = tmp;\n\t\t\tarrive_cnt++;\n\t\t\ttmp->state = DONE;\n\t\t}else{\n\t\t\t/* ³çÉ] */\n\t\t\tadd_mail(&(node[node[n].distnext[tmp->dst]].post_queue),tmp);\n\t\t\ttmp->state = POST;\n\t\t}\n\t}\n\n}\n\nvoid go_back(int n){\n\tnode[n].state = BACK;\n\tnode[n].timer = time + node[n].dist[node[n].dst];\n}\n\nvoid del_mail(Mail **q,Mail *mail){\n\twhile((*q)!=NULL && (*q)!=mail)q = &((*q)->next);\n\tif((*q)==mail){\n\t\t*q = mail->next;\n\t\tmail->next = NULL;\n\t}\n}\n\nvoid add_mail(Mail **q,Mail *mail){\n\twhile((*q)!=NULL)q = &((*q)->next);\n\tmail->next = NULL;\n\t*q = mail;\n}\n\n\n\nint calc_dist(int a, int b){\n\tint min,min_i;\n\tint i;\n\t/* êxvZ³êÄ¢é */\n\tif(node[a].distf[b]==TRUE)return node[a].dist[node[a].distnext[b]];\n\n\tdo{\n\t\tmin = 10000;\n\t\tmin_i = 10000;\n\t\tfor(i=0;i<node_num;i++){\n\t\t\tif(a!=i && node[a].distf[i] == FALSE && node[a].dist[i] != 10000){\n\t\t\t\tif(min>node[a].dist[i]){\n\t\t\t\t\tmin = node[a].dist[i];\n\t\t\t\t\tmin_i = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnode[a].distf[min_i] = TRUE;\n\t\tnode[min_i].distf[a] = TRUE;\n\t\tfor(i=0;i<node_num;i++){\n\t\t\tif(min_i!=i && node[min_i].dist[i] != 10000){\n\t\t\t\tif(node[a].dist[i]>node[a].dist[min_i]+node[min_i].dist[i]){\n\t\t\t\t\tnode[a].dist[i] = node[a].dist[min_i]+node[min_i].dist[i];\n\t\t\t\t\tnode[a].distnext[i] = node[a].distnext[min_i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while(min_i!=b);\n\n\n\t//min = node[a].dist[b];\n\t//for(i=0;i<node_num;i++){\n\t//\tif(a!=i && node[a].dist[i] != 10000){\n\t//\t\ttmp = node[a].dist[i]+calc_dist(i,b);\n\t//\t\tif(min>tmp)min = tmp;\n\t//\t}\n\t//}\n\tnode[a].distf[b] = TRUE;\n\tnode[b].distf[a] = TRUE;\n\tnode[a].dist[b] = min;\n\tnode[b].dist[a] = min;\n\treturn node[a].dist[node[a].distnext[b]];\n}\n\nvoid print_arrive(void){\n\tint i;\n\tif(arrive_cnt > 0){\n\t\tqsort(arrive,arrive_cnt,sizeof(Mail*),compare_mail);\n\t\tfor(i=0;i<arrive_cnt;i++){\n\t\t\tprintf(\"%s %d\\n\",arrive[i]->label,time);\n\t\t}\n\t}\n\tarrive_cnt = 0;\n}\n\t\n\nint compare_mail(const void* a, const void* b){\n\treturn strcmp((*(Mail**)a)->label,(*(Mail**)b)->label);\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\n\n#ifdef PROFILE\n#include <time.h>\n#define time _time\n#endif\n\n#define MAX_LEN 64\n\n#define MAX_NODE 32\n#define MAX_MAIL 1000\n#define MAX_LABEL 50+1\n\n#define MAX_TIME (1<<31)\n#define MAX_DIST 10000\n#define MAX_DISTSUM 320000\n\n#define TRUE 1\n#define FALSE 0\n\ntypedef enum {\n\tNONE, /* Í¯çêÄ¢È¢ */\n\tPOST, /* XÖÇÉ é */\n\tDELI, /* zB */\n\tDONE  /* zB®¹ */\n} MailState;\n\ntypedef enum {\n\tHERE, /* zBõª¢é */\n\tGO,   /* zBõªÚInÉü©ÁÄ¢é */\n\tBACK  /* zBõªÚIn©çAÁÄ«Ä¢é */\n} NodeState;\n\ntypedef struct _Mail{\n\tMailState state;    /* [ÌóÔ */\n\tunsigned long timer;          /* XÖÇÉÍ­Ô */\n\tstruct _Mail *next; /* ÉÍ¢½[ */\n\tint src;            /* a©èê */\n\tint dst;            /* ÅIÍ¯æ */\n\tchar label[MAX_LABEL]; /* x */\n} Mail;\n\ntypedef struct {\n\tNodeState state;    /* zBõÌóÔ */\n\tunsigned long timer;          /* zBõªÚ®µIíéÔ */\n\tint dst;            /* zBõÌÚIn */\n\tshort dist[MAX_NODE]; /* ]oHÌ£ */\n\tchar distf[MAX_NODE]; /* ÅZ£vZÏÝtO*/\n\tint distnext[MAX_NODE]; /* ÅZ£ÌÆ«É^Ôm[h*/\n\tMail *post_queue;        /* Í¢Ä¢é[ */\n\tMail *deli_queue;        /* zBÌ[ */\n} Node;\n\n/* nÂÌXÖÇim[hjÌú» */\nvoid init_nodes(int n);\n\n/* Í¯çêÄ¢È¢[Ì */\nint check_mail(int l);\n/* XÖÇÔÌÅZ£vZ */\nint calc_dist(int a, int b);\n/* èzBJn */\nvoid take_mail(int n);\n/* [Ì */\nvoid post_mail(Mail *m);\n/* zB®¹ */\nvoid arrive_mail(int n);\n/* zBõÌAÒõ */\nvoid go_back(int n);\n/* zB®¹[Ì\\¦ */\nvoid print_arrive(void);\n\n\nvoid del_mail(Mail **q,Mail *mail);\nvoid add_mail(Mail **q,Mail *mail);\n\nint compare_mail(const void* a, const void* b);\n\nNode node[MAX_NODE]; /* XÖÇXg */\nint node_num; /* XÖÇgp */\nMail mail[MAX_MAIL]; /* [Xg */\nint mail_num; /* [gp */\nint posted; /* ÏÝ[Ô */\nMail *arrive[MAX_MAIL];/* zB®¹[Xg */\nint arrive_cnt;/* zB®¹[ */\n\nunsigned long time = 0; /* V~[VÔ */\n\nint main(){\n\tchar buf[MAX_LEN];\n\tint i;\n\tint n,m;\n\tint a,b,d;\n\tint l;\n\tunsigned long min; /* ñ­Î·é^C}l */\n#ifdef PROFILE\n\tclock_t c_input=0, c_init=0, c_all=0, c_sim=0, c_take=0, c_arrive=0, c_mail=0, c_print=0;\n\n\tc_all-=clock();\n#endif\n\t\n\twhile(fgets(buf,MAX_LEN,stdin)!=NULL){\n\t\tif(sscanf(buf,\"%d %d\",&n,&m)<2){\n\t\t\tfprintf(stderr,\"error:invalid input\\n\");\n\t\t}else{\n\t\t\t/* 0 0 ¾Á½çI¹ */\n\t\t\tif(n<2||m<1)break;\n\t\t\t/* KvÈª¾¯ú» */\n#ifdef PROFILE\n\t\t\tc_init-=clock();\n#endif\n\t\t\tinit_nodes(n);\n#ifdef PROFILE\n\t\t\tc_init+=clock();\n\t\t\tc_input-=clock();\n#endif\n\t\t\t/* ]oHÇÝæè */\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 1;\n\t\t\t\tif(sscanf(buf,\"%d %d %d\",&a,&b,&d)<3)return 2;\n\t\t\t\t/* 0IWÉ·é½ß-1 */\n\t\t\t\tnode[a-1].dist[b-1] = d;\n\t\t\t\tnode[b-1].dist[a-1] = d;\n\t\t\t\tnode[a-1].distnext[b-1] = b-1;\n\t\t\t\tnode[b-1].distnext[a-1] = a-1;\n\t\t\t}\n\t\t\t/* [ÇÝæè */\n\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 3;\n\t\t\tif(sscanf(buf,\"%d\",&l)<1)return 4;\n\t\t\t/* [îñÇÝæè */\n\t\t\tmin = MAX_TIME;/* ÅÉ­Î·é^C}Í[ */\n\t\t\tfor(i=0;i<l;i++){\n\t\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 5;\n\t\t\t\tif(sscanf(buf,\"%d %d %ld %[a-zA-Z0-9-_]\",\n\t\t\t\t\t&(mail[i].src),&(mail[i].dst),&(mail[i].timer),mail[i].label)<4)return 6;\n\t\t\t\t/* 0IWÉ·é½ß-1 */\n\t\t\t\tmail[i].src--;\n\t\t\t\tmail[i].dst--;\n\t\t\t\tmail[i].state = NONE;\n\t\t\t\tmail[i].next = NULL;\n\t\t\t\tif(min>mail[i].timer)min = mail[i].timer;\n\t\t\t}\n\t\t\tnode_num = n;\n\t\t\tmail_num = l;\n#ifdef PROFILE\n\t\t\tc_input+=clock();\n\t\t\tc_sim-=clock();\n#endif\n\n\t\t\t/* V~[VJn */\n\t\t\ttime = min;\n\t\t\tarrive_cnt = 0;\n\t\t\tposted = 0;\n\t\t\twhile(check_mail(l)!=0){/* S[ªzBI¹·éÜÅ */\n\t\t\t\tmin = MAX_TIME;\n#ifdef PROFILE\n\t\t\t\tc_mail-=clock();\n#endif\n\t\t\t\t/* èªÍ­ */\n\t\t\t\tfor(i=posted;mail[i].timer==time;i++){\n\t\t\t\t\tpost_mail(&mail[i]);\n\t\t\t\t\tposted++;\n\t\t\t\t}\n\t\t\t\tif(posted<mail_num)\tmin = mail[posted].timer;\n#ifdef PROFILE\n\t\t\t\tc_mail+=clock();\n#endif\n\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\t/* zBõª·é */\n\t\t\t\t\tif(node[i].timer == time){\n\t\t\t\t\t\tif(node[i].state == GO){\n#ifdef PROFILE\n\t\t\t\tc_arrive-=clock();\n#endif\n\t\t\t\t\t\t\tarrive_mail(i);\n#ifdef PROFILE\n\t\t\t\tc_arrive+=clock();\n#endif\n\t\t\t\t\t\t\tgo_back(i);\n\t\t\t\t\t\t}else if(node[i].state == BACK){\n\t\t\t\t\t\t\tnode[i].timer = 0;\n\t\t\t\t\t\t\tnode[i].state = HERE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* zBõªo­·é */\n\t\t\t\t\tif(node[i].state == HERE){\n#ifdef PROFILE\n\t\t\t\tc_take-=clock();\n#endif\n\t\t\t\t\t\ttake_mail(i);\n#ifdef PROFILE\n\t\t\t\tc_take+=clock();\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tif(node[i].timer && min>node[i].timer)min=node[i].timer;\n\t\t\t\t}\n#ifdef PROFILE\n\t\t\t\tc_print-=clock();\n#endif\n\t\t\t\tprint_arrive();\n#ifdef PROFILE\n\t\t\t\tc_print+=clock();\n#endif\n\t\t\t\ttime=min;\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n#ifdef PROFILE\n\t\t\tc_sim+=clock();\n#endif\n\t\t}\n\t}\n#ifdef PROFILE\n\tc_all+=clock();\n\tprintf(\n\t\t\"init:  %ld\\n\"\n\t\t\"input: %ld\\n\"\n\t\t\"sim:   %ld\\n\"\n\t\t\" mail: %ld\\n\"\n\t\t\" arriv:%ld\\n\"\n\t\t\" take: %ld\\n\"\n\t\t\" print:%ld\\n\"\n\t\t\"all:   %ld\\n\"\n\t\t,c_init, c_input, c_sim, c_mail, c_arrive, c_take, c_print, c_all);\n#endif\n\treturn 0;\n}\n\nvoid init_nodes(int n){\n\tint i,j;\n\tfor(i=0;i<n;i++){\n\t\tnode[i].state = HERE;\n\t\tnode[i].timer = 0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tnode[i].dist[j] = MAX_DIST;\n\t\t\tnode[i].distf[j] = FALSE;\n\t\t\tnode[i].distnext[j] = -1;\n\t\t}\n\t\tnode[i].dist[i] = 0;\n\t\tnode[i].distf[i] = TRUE;\n\t\tnode[i].distnext[i] = i;\n\t\tnode[i].dst = -1;\n\t\tnode[i].post_queue = NULL;\n\t\tnode[i].deli_queue = NULL;\n\t}\n}\n\nint check_mail(int l){\n\tint i,cnt;\n\tcnt=0;\n\tfor(i=0;i<l;i++){\n\t\tif(mail[i].state != DONE)cnt++;\n\t}\n\treturn cnt;\n}\n\nvoid post_mail(Mail *m){\n\tadd_mail(&(node[m->src].post_queue),m);\n\tm->state = POST;\n}\n\nvoid take_mail(int n){\n\tMail *que,**q,*tmp;\n\n\t/* zB·é[ª é©H */\n\tif(node[n].post_queue!=NULL){\n\n\t\t/* ÅÌ[ðzBXgÖÚ® */\n\t\tque = node[n].post_queue;\n\t\tdel_mail(&(node[n].post_queue),que);\n\t\tadd_mail(&(node[n].deli_queue),que);\n\n\t\tque->state = DELI;\n\t\tnode[n].state = GO;\n\t\tnode[n].timer = time+calc_dist(n,que->dst);/* »Ý{ÚWnÜÅÌ£ */\n\t\tnode[n].dst = node[n].distnext[que->dst];\n\n\t\t/* ¯¶Í¯æÌ[ðzBXgÖÚ® */\n\t\tq = &(node[n].post_queue);\n\t\twhile(*q != NULL){\n\t\t\tif((*q)->dst == que->dst){\n\t\t\t\ttmp = *q;\n\t\t\t\ttmp->state = DELI;\n\t\t\t\tdel_mail(q,tmp);\n\t\t\t\tadd_mail(&(node[n].deli_queue),tmp);\n\t\t\t}else{\n\t\t\t\tq = &((*q)->next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid arrive_mail(int n){\n\tMail *tmp;\n\n\twhile(node[n].deli_queue != NULL){\n\t\ttmp = node[n].deli_queue;\n\t\tdel_mail(&(node[n].deli_queue),tmp);\n\t\tif(tmp->dst==node[n].dst){\n\t\t\t/* ÅIÍ¯æÉ */\n\t\t\tarrive[arrive_cnt] = tmp;\n\t\t\tarrive_cnt++;\n\t\t\ttmp->state = DONE;\n\t\t}else{\n\t\t\t/* ³çÉ] */\n\t\t\tadd_mail(&(node[node[n].distnext[tmp->dst]].post_queue),tmp);\n\t\t\ttmp->state = POST;\n\t\t}\n\t}\n\n}\n\nvoid go_back(int n){\n\tnode[n].state = BACK;\n\tnode[n].timer = time + node[n].dist[node[n].dst];\n}\n\nvoid del_mail(Mail **q,Mail *mail){\n\twhile((*q)!=NULL && (*q)!=mail)q = &((*q)->next);\n\tif((*q)==mail){\n\t\t*q = mail->next;\n\t\tmail->next = NULL;\n\t}\n}\n\nvoid add_mail(Mail **q,Mail *mail){\n\twhile((*q)!=NULL)q = &((*q)->next);\n\tmail->next = NULL;\n\t*q = mail;\n}\n\n\n\nint calc_dist(int a, int b){\n\tstatic int past[MAX_NODE];/* ßÉÊÁ½m[h */\n\tstatic int best[MAX_NODE];/* ÅZÌm[h */\n\tstatic int past_n = 0; /* ßÉÊÁ½m[h */\n\tstatic int dist = 0;  /* ßÉÊÁÄ«½£ */\n\tstatic int bestd = MAX_DISTSUM;  /* ÅZÌ£ */\n\tint i,j;\n\n\tif(past_n==0) bestd = MAX_DISTSUM;/* TõJnú» */\n\n\tpast[past_n++] = a;\n\n\t/* ½Çè¢½Æ« */\n\tif(a==b){\n\t\t/* ¡ñÌoHªÅZÅ êÎÅZoHðXV */\n\t\tif(bestd>dist){\n\t\t\tbestd = dist;\n\t\t\tfor(i=0;i<past_n;i++)best[i]=past[i];\n\t\t}\n\t}else{\n\t\tif(dist<bestd){\n\t\t\t/* êxvZ³êÄ¢é */\n\t\t\tif(node[a].distf[b]==TRUE){\n\t\t\t\ti = node[a].distnext[b];\n\t\t\t\tfor(j=0;j<past_n;j++)if(past[j]==i)return -1;\n\t\t\t\tdist += node[a].dist[i];\n\t\t\t\tcalc_dist(i,b);\n\t\t\t\tdist -= node[a].dist[i];\n\t\t\t}else{\n\t\t\t\tfor(i=0;i<node_num;i++){\n\t\t\t\t\tfor(j=0;j<past_n;j++)if(past[j]==i)break;\n\t\t\t\t\tif(j!=past_n)continue;\n\t\t\t\t\tif(MAX_DIST>node[a].dist[i]){\n\t\t\t\t\t\tdist += node[a].dist[i];\n\t\t\t\t\t\tcalc_dist(i,b);\n\t\t\t\t\t\tdist -= node[a].dist[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpast_n--;\n\n\t/* TõI¹Ê½f */\n\tif(past_n==0){\n\t\tfor(i=0;best[i]!=b;i++){\n\t\t\tnode[best[i]].distnext[b] = best[i+1];\n\t\t\tnode[best[i+1]].distnext[a] = best[i];\n\t\t\tnode[best[i]].distf[b] = TRUE;\n\t\t\tnode[best[i+1]].distf[a] = TRUE;\n\t\t}\n\t\treturn  node[a].dist[node[a].distnext[b]];\n\t}\n\treturn  0;\n}\n\nvoid print_arrive(void){\n\tint i;\n\tif(arrive_cnt > 0){\n\t\tqsort(arrive,arrive_cnt,sizeof(Mail*),compare_mail);\n\t\tfor(i=0;i<arrive_cnt;i++){\n\t\t\tprintf(\"%s %ld\\n\",arrive[i]->label,time);\n\t\t}\n\t}\n\tarrive_cnt = 0;\n}\n\t\n\nint compare_mail(const void* a, const void* b){\n\treturn strcmp((*(Mail**)a)->label,(*(Mail**)b)->label);\n}"
  },
  {
    "language": "C",
    "code": "//TLE\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nstruct packet{\n\tint tm,pos,dist;\n\tstring name;\n\tpacket(int t,int p,int d,const string&n):\n\t\ttm(t),pos(p),dist(d),name(n){}\n};\nvector<packet> pac;\nint len[33][33],to[33][33],bac[33];\nint tbl[1001];\nconst int inf = 1e9;\nstruct cmp{\n\tbool operator()\t(int x,int y) const\n\t{\n\t\tconst packet &a = pac[x], &b = pac[y];\n\t\treturn a.tm == b.tm\n\t\t\t? to[a.pos][a.dist] > to[b.pos][b.dist]\n\t\t\t: a.tm > b.tm;\n\t}\n};\nbool cmp2(int x,int y){\n\tconst packet &a=pac[x], &b = pac[y];\n\treturn a.tm==b.tm ? a.name < b.name: a.tm < b.tm;\n}\n\nint main(){\n\tint n,m,f,t,d,i,j,k,l;\n\tstring name;\n\tpriority_queue<int,vector<int>,cmp> qu;\n\tfor(;cin>>n>>m,n;){\n\t\tpac.clear();\n\t\tif(**len==1)cout<<endl;\n\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tlen[i][j]=inf;\n\t\t\t\tto[i][j]=-1;\n\t\t\t}\n\t\t\tbac[i]=len[i][i]=0;\n\t\t\tto[i][i]=i;\n\t\t}\n\n\t\tfor(;m--;){\n\t\t\tcin>>f>>d>>t;\n\t\t\tlen[f][d] = t;\n\t\t\tlen[d][f] = t;\n\t\t\tto[f][d] = d;\n\t\t\tto[d][f] = f;\n\t\t}\n\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tt = len[i][k] + len[k][j];\n\t\t\t\t\tif( len[i][j] > t ){\n\t\t\t\t\t\tlen[i][j] = t;\n\t\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tcin>>l;\n\t\tfor(j=0;j<l;j++){\n\t\t\tcin>>f>>d>>t>>name;\n\t\t\tpac.push_back( packet(t,f,d,name) );\n\t\t\tqu.push(j);\n\t\t}\n\n\t\tfor(;!qu.empty();){\n\t\t\tint pi = qu.top();\n\t\t\tpacket *p = &pac[pi];\n\t\t\tt = p->tm;\n\t\t\tf = p->pos;\n\t\t\tif( f == p->dist ){\n\t\t\t\tqu.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( t < bac[f] ){\n\t\t\t\tp->tm = bac[f];\n\t\t\t\tqu.pop();\n\t\t\t\tqu.push(pi);\n\t\t\t}else{\n\t\t\t\td = to[f][p->dist];\n\t\t\t\tbac[f] = t + 2 * len[p->pos][d];\n\t\t\t\tfor(;;){\n\t\t\t\t\tint qi = qu.top();\n\t\t\t\t\tpacket*q = &pac[qi];\n\t\t\t\t\tif(t==q->tm && f==q->pos && to[q->pos][q->dist] == d){\n\t\t\t\t\t\tqu.pop();\n\t\t\t\t\t\tq->tm = max( q->tm + len[f][d], bac[d] );\n\t\t\t\t\t\tq->pos = d;\n\t\t\t\t\t\tqu.push(qi);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tsort(pac.begin(),pac.end(),cmp2);\n//\t\tfor(j=0;j<l;j++)cout<<pac[j].name<<' '<<pac[j].tm<<endl;\n\t\tfor(j=0;j<l;j++)tbl[j]=j;\n\t\tsort(tbl,tbl+l,cmp2);\n\t\tfor(j=0;j<l;j++)printf(\"%s %d\\n\",pac[tbl[j]].name.c_str(),pac[tbl[j]].tm);\n\n\t\t**len = 1;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_DEPRECATE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n//#define PROFILE\n\n#ifdef PROFILE\n#include <time.h>\n#define time _time\n#endif\n\n#define MAX_LEN 64\n\n#define MAX_NODE 32\n#define MAX_MAIL 1000\n#define MAX_LABEL 50+1\n\n#define MAX_TIME (1<<31)\n#define MAX_DIST 10000\n#define MAX_DISTSUM 320000\n\n#define TRUE 1\n#define FALSE 0\n\ntypedef enum {\n\tNONE, /* Í¯çêÄ¢È¢ */\n\tPOST, /* XÖÇÉ é */\n\tDELI, /* zB */\n\tDONE  /* zB®¹ */\n} MailState;\n\ntypedef enum {\n\tHERE, /* zBõª¢é */\n\tGO,   /* zBõªÚInÉü©ÁÄ¢é */\n\tBACK  /* zBõªÚIn©çAÁÄ«Ä¢é */\n} NodeState;\n\ntypedef struct _Mail{\n\tMailState state;    /* [ÌóÔ */\n\tunsigned long timer;          /* XÖÇÉÍ­Ô */\n\tstruct _Mail *next; /* ÉÍ¢½[ */\n\tint src;            /* a©èê */\n\tint dst;            /* ÅIÍ¯æ */\n\tchar label[MAX_LABEL]; /* x */\n} Mail;\n\ntypedef struct {\n\tNodeState state;    /* zBõÌóÔ */\n\tunsigned long timer;          /* zBõªÚ®µIíéÔ */\n\tint dst;            /* zBõÌÚIn */\n\tshort dist[MAX_NODE]; /* ]oHÌ£ */\n\tchar distf[MAX_NODE]; /* ÅZ£vZÏÝtO*/\n\tint distnext[MAX_NODE]; /* ÅZ£ÌÆ«É^Ôm[h*/\n\tMail *post_queue;        /* Í¢Ä¢é[ */\n\tMail *deli_queue;        /* zBÌ[ */\n} Node;\n\n/* nÂÌXÖÇim[hjÌú» */\nvoid init_nodes(int n);\n\n/* Í¯çêÄ¢È¢[Ì */\nint check_mail(int l);\n/* XÖÇÔÌÅZ£vZ */\nint calc_dist(int a, int b);\n/* èzBJn */\nvoid take_mail(int n);\n/* [Ì */\nvoid post_mail(Mail *m);\n/* zB®¹ */\nvoid arrive_mail(int n);\n/* zBõÌAÒõ */\nvoid go_back(int n);\n/* zB®¹[Ì\\¦ */\nvoid print_arrive(void);\n\n\nvoid del_mail(Mail **q,Mail *mail);\nvoid add_mail(Mail **q,Mail *mail);\n\nint compare_mail(const void* a, const void* b);\n\nNode node[MAX_NODE]; /* XÖÇXg */\nint node_num; /* XÖÇgp */\nMail mail[MAX_MAIL]; /* [Xg */\nMail mmail; /* ¢[Xg(æªÍ_~[) */\nint mail_num; /* [gp */\nMail *arrive[MAX_MAIL];/* zB®¹[Xg */\nint arrive_cnt;/* zB®¹[ */\n\nunsigned long time = 0; /* V~[VÔ */\n\nint main(){\n\tchar buf[MAX_LEN];\n\tint i;\n\tint n,m;\n\tint a,b,d;\n\tint l;\n\tMail *lmail,*nmail;\n\tunsigned long min; /* ñ­Î·é^C}l */\n#ifdef PROFILE\n\tclock_t c_input=0, c_init=0, c_all=0, c_sim=0;\n\n\tc_all-=clock();\n#endif\n\t\n\twhile(fgets(buf,MAX_LEN,stdin)!=NULL){\n\t\tif(sscanf(buf,\"%d %d\",&n,&m)<2){\n\t\t\tfprintf(stderr,\"error:invalid input\\n\");\n\t\t}else{\n\t\t\t/* 0 0 ¾Á½çI¹ */\n\t\t\tif(n<2||m<1)break;\n\t\t\t/* KvÈª¾¯ú» */\n#ifdef PROFILE\n\t\t\tc_init-=clock();\n#endif\n\t\t\tinit_nodes(n);\n#ifdef PROFILE\n\t\t\tc_init+=clock();\n\t\t\tc_input-=clock();\n#endif\n\t\t\t/* ]oHÇÝæè */\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 1;\n\t\t\t\tif(sscanf(buf,\"%d %d %d\",&a,&b,&d)<3)return 2;\n\t\t\t\t/* 0IWÉ·é½ß-1 */\n\t\t\t\tnode[a-1].dist[b-1] = d;\n\t\t\t\tnode[b-1].dist[a-1] = d;\n\t\t\t\tnode[a-1].distnext[b-1] = b-1;\n\t\t\t\tnode[b-1].distnext[a-1] = a-1;\n\t\t\t}\n\t\t\t/* [ÇÝæè */\n\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 3;\n\t\t\tif(sscanf(buf,\"%d\",&l)<1)return 4;\n\t\t\t/* [îñÇÝæè */\n\t\t\tmin = MAX_TIME;/* ÅÉ­Î·é^C}Í[ */\n\t\t\tmmail.next = NULL;\n\t\t\tfor(i=0;i<l;i++){\n\t\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 5;\n\t\t\t\tif(sscanf(buf,\"%d %d %d %[a-zA-Z0-9-_]\",\n\t\t\t\t\t&(mail[i].src),&(mail[i].dst),&(mail[i].timer),mail[i].label)<4)return 6;\n\t\t\t\t/* 0IWÉ·é½ß-1 */\n\t\t\t\tmail[i].src--;\n\t\t\t\tmail[i].dst--;\n\t\t\t\tmail[i].state = NONE;\n\t\t\t\tmail[i].next = mmail.next;\n\t\t\t\tmmail.next = &mail[i];\n\t\t\t\tif(min>mail[i].timer)min = mail[i].timer;\n\t\t\t}\n\t\t\tnode_num = n;\n\t\t\tmail_num = l;\n#ifdef PROFILE\n\t\t\tc_input+=clock();\n\t\t\tc_sim-=clock();\n#endif\n\n\t\t\t/* V~[VJn */\n\t\t\ttime = min;\n\t\t\tarrive_cnt = 0;\n\t\t\twhile(check_mail(l)!=0){/* S[ªzBI¹·éÜÅ */\n\t\t\t\tmin = MAX_TIME;\n\t\t\t\t/* èªÍ­ */\n\t\t\t\tlmail = &mmail;\n\t\t\t\tnmail = lmail->next;\n\t\t\t\twhile(nmail!=NULL){\n\t\t\t\t\tif(nmail->timer <= time){\n\t\t\t\t\t\tlmail->next = nmail->next;\n\t\t\t\t\t\tpost_mail(nmail);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(min>nmail->timer)min=nmail->timer;\n\t\t\t\t\t\tlmail = lmail->next;\n\t\t\t\t\t}\n\t\t\t\t\tnmail = lmail->next;\n\t\t\t\t}\n\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\t/* zBõª·é */\n\t\t\t\t\tif(node[i].timer == time){\n\t\t\t\t\t\tif(node[i].state == GO){\n\t\t\t\t\t\t\tarrive_mail(i);\n\t\t\t\t\t\t\tgo_back(i);\n\t\t\t\t\t\t}else if(node[i].state == BACK){\n\t\t\t\t\t\t\tnode[i].timer = 0;\n\t\t\t\t\t\t\tnode[i].state = HERE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* zBõªo­·é */\n\t\t\t\t\tif(node[i].state == HERE){\n\t\t\t\t\t\ttake_mail(i);\n\t\t\t\t\t}\n\t\t\t\t\tif(node[i].timer && min>node[i].timer)min=node[i].timer;\n\t\t\t\t}\n\t\t\t\tprint_arrive();\n\t\t\t\ttime=min;\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n#ifdef PROFILE\n\t\t\tc_sim+=clock();\n#endif\n\t\t}\n\t}\n#ifdef PROFILE\n\tc_all+=clock();\n\tprintf(\"init:  %d\\n\" \"input: %d\\n\" \"sim:   %d\\n\" \"all:   %d\\n\",c_init,c_input,c_sim,c_all);\n#endif\n\treturn 0;\n}\n\nvoid init_nodes(int n){\n\tint i,j;\n\tfor(i=0;i<n;i++){\n\t\tnode[i].state = HERE;\n\t\tnode[i].timer = 0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tnode[i].dist[j] = MAX_DIST;\n\t\t\tnode[i].distf[j] = FALSE;\n\t\t\tnode[i].distnext[j] = -1;\n\t\t}\n\t\tnode[i].dist[i] = 0;\n\t\tnode[i].distf[i] = TRUE;\n\t\tnode[i].distnext[i] = i;\n\t\tnode[i].dst = -1;\n\t\tnode[i].post_queue = NULL;\n\t\tnode[i].deli_queue = NULL;\n\t}\n}\n\nint check_mail(int l){\n\tint i,cnt;\n\tcnt=0;\n\tfor(i=0;i<l;i++){\n\t\tif(mail[i].state != DONE)cnt++;\n\t}\n\treturn cnt;\n}\n\nvoid post_mail(Mail *m){\n\tadd_mail(&(node[m->src].post_queue),m);\n\tm->state = POST;\n}\n\nvoid take_mail(int n){\n\tMail *que,**q,*tmp;\n\n\t/* zB·é[ª é©H */\n\tif(node[n].post_queue!=NULL){\n\n\t\t/* ÅÌ[ðzBXgÖÚ® */\n\t\tque = node[n].post_queue;\n\t\tdel_mail(&(node[n].post_queue),que);\n\t\tadd_mail(&(node[n].deli_queue),que);\n\n\t\tque->state = DELI;\n\t\tnode[n].state = GO;\n\t\tnode[n].timer = time+calc_dist(n,que->dst);/* »Ý{ÚWnÜÅÌ£ */\n\t\tnode[n].dst = node[n].distnext[que->dst];\n\n\t\t/* ¯¶Í¯æÌ[ðzBXgÖÚ® */\n\t\tq = &(node[n].post_queue);\n\t\twhile(*q != NULL){\n\t\t\tif((*q)->dst == que->dst){\n\t\t\t\ttmp = *q;\n\t\t\t\ttmp->state = DELI;\n\t\t\t\tdel_mail(q,tmp);\n\t\t\t\tadd_mail(&(node[n].deli_queue),tmp);\n\t\t\t}else{\n\t\t\t\tq = &((*q)->next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid arrive_mail(int n){\n\tMail *tmp;\n\n\twhile(node[n].deli_queue != NULL){\n\t\ttmp = node[n].deli_queue;\n\t\tdel_mail(&(node[n].deli_queue),tmp);\n\t\tif(tmp->dst==node[n].dst){\n\t\t\t/* ÅIÍ¯æÉ */\n\t\t\tarrive[arrive_cnt] = tmp;\n\t\t\tarrive_cnt++;\n\t\t\ttmp->state = DONE;\n\t\t}else{\n\t\t\t/* ³çÉ] */\n\t\t\tadd_mail(&(node[node[n].distnext[tmp->dst]].post_queue),tmp);\n\t\t\ttmp->state = POST;\n\t\t}\n\t}\n\n}\n\nvoid go_back(int n){\n\tnode[n].state = BACK;\n\tnode[n].timer = time + node[n].dist[node[n].dst];\n}\n\nvoid del_mail(Mail **q,Mail *mail){\n\twhile((*q)!=NULL && (*q)!=mail)q = &((*q)->next);\n\tif((*q)==mail){\n\t\t*q = mail->next;\n\t\tmail->next = NULL;\n\t}\n}\n\nvoid add_mail(Mail **q,Mail *mail){\n\twhile((*q)!=NULL)q = &((*q)->next);\n\tmail->next = NULL;\n\t*q = mail;\n}\n\n\n\nint calc_dist(int a, int b){\n\tstatic int past[MAX_NODE];/* ßÉÊÁ½m[h */\n\tstatic int best[MAX_NODE];/* ÅZÌm[h */\n\tstatic int past_n = 0; /* ßÉÊÁ½m[h */\n\tstatic int dist = 0;  /* ßÉÊÁÄ«½£ */\n\tstatic int bestd = MAX_DISTSUM;  /* ÅZÌ£ */\n\tint i,j;\n\n\tif(past_n==0) bestd = MAX_DISTSUM;/* TõJnú» */\n\n\tpast[past_n++] = a;\n\n\t/* ½Çè¢½Æ« */\n\tif(a==b){\n\t\t/* ¡ñÌoHªÅZÅ êÎÅZoHðXV */\n\t\tif(bestd>dist){\n\t\t\tbestd = dist;\n\t\t\tfor(i=0;i<past_n;i++)best[i]=past[i];\n\t\t}\n\t}else{\n\t\tif(dist<bestd){\n\t\t\t/* êxvZ³êÄ¢é */\n\t\t\tif(node[a].distf[b]==TRUE){\n\t\t\t\ti = node[a].distnext[b];\n\t\t\t\tfor(j=0;j<past_n;j++)if(past[j]==i)return -1;\n\t\t\t\tdist += node[a].dist[i];\n\t\t\t\tcalc_dist(i,b);\n\t\t\t\tdist -= node[a].dist[i];\n\t\t\t}else{\n\t\t\t\tfor(i=0;i<node_num;i++){\n\t\t\t\t\tfor(j=0;j<past_n;j++)if(past[j]==i)break;\n\t\t\t\t\tif(j!=past_n)continue;\n\t\t\t\t\tif(MAX_DIST>node[a].dist[i]){\n\t\t\t\t\t\tdist += node[a].dist[i];\n\t\t\t\t\t\tcalc_dist(i,b);\n\t\t\t\t\t\tdist -= node[a].dist[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpast_n--;\n\n\t/* TõI¹Ê½f */\n\tif(past_n==0){\n\t\tfor(i=0;best[i]!=b;i++){\n\t\t\tnode[best[i]].distnext[b] = best[i+1];\n\t\t\tnode[best[i+1]].distnext[a] = best[i];\n\t\t\tnode[best[i]].distf[b] = TRUE;\n\t\t\tnode[best[i+1]].distf[a] = TRUE;\n\t\t}\n\t}\n\treturn  node[a].dist[node[a].distnext[b]];\n}\n\nvoid print_arrive(void){\n\tint i;\n\tif(arrive_cnt > 0){\n\t\tqsort(arrive,arrive_cnt,sizeof(Mail*),compare_mail);\n\t\tfor(i=0;i<arrive_cnt;i++){\n\t\t\tprintf(\"%s %d\\n\",arrive[i]->label,time);\n\t\t}\n\t}\n\tarrive_cnt = 0;\n}\n\t\n\nint compare_mail(const void* a, const void* b){\n\treturn strcmp((*(Mail**)a)->label,(*(Mail**)b)->label);\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\n\n#ifdef PROFILE\n#include <time.h>\n#define time _time\n#endif\n\n#define MAX_LEN 64\n\n#define MAX_NODE 32\n#define MAX_MAIL 1000\n#define MAX_LABEL 50+1\n\n#define MAX_TIME (1<<31)\n#define MAX_DIST 10000\n#define MAX_DISTSUM 320000\n\n#define TRUE 1\n#define FALSE 0\n\ntypedef enum {\n\tNONE, /* Í¯çêÄ¢È¢ */\n\tPOST, /* XÖÇÉ é */\n\tDELI, /* zB */\n\tDONE  /* zB®¹ */\n} MailState;\n\ntypedef enum {\n\tHERE, /* zBõª¢é */\n\tGO,   /* zBõªÚInÉü©ÁÄ¢é */\n\tBACK  /* zBõªÚIn©çAÁÄ«Ä¢é */\n} NodeState;\n\ntypedef struct _Mail{\n\tMailState state;    /* [ÌóÔ */\n\tunsigned long timer;          /* XÖÇÉÍ­Ô */\n\tstruct _Mail *next; /* ÉÍ¢½[ */\n\tint src;            /* a©èê */\n\tint dst;            /* ÅIÍ¯æ */\n\tchar label[MAX_LABEL]; /* x */\n} Mail;\n\ntypedef struct {\n\tNodeState state;    /* zBõÌóÔ */\n\tunsigned long timer;          /* zBõªÚ®µIíéÔ */\n\tint dst;            /* zBõÌÚIn */\n\tshort dist[MAX_NODE]; /* ]oHÌ£ */\n\tchar distf[MAX_NODE]; /* ÅZ£vZÏÝtO*/\n\tint distnext[MAX_NODE]; /* ÅZ£ÌÆ«É^Ôm[h*/\n\tMail *post_queue;        /* Í¢Ä¢é[ */\n\tMail *deli_queue;        /* zBÌ[ */\n} Node;\n\n/* nÂÌXÖÇim[hjÌú» */\nvoid init_nodes(int n);\n\n/* Í¯çêÄ¢È¢[Ì */\nint check_mail(int l);\n/* XÖÇÔÌÅZ£vZ */\nint calc_dist(int a, int b);\n/* èzBJn */\nvoid take_mail(int n);\n/* [Ì */\nvoid post_mail(Mail *m);\n/* zB®¹ */\nvoid arrive_mail(int n);\n/* zBõÌAÒõ */\nvoid go_back(int n);\n/* zB®¹[Ì\\¦ */\nvoid print_arrive(void);\n\n\nvoid del_mail(Mail **q,Mail *mail);\nvoid add_mail(Mail **q,Mail *mail);\n\nint compare_mail(const void* a, const void* b);\n\nNode node[MAX_NODE]; /* XÖÇXg */\nint node_num; /* XÖÇgp */\nMail mail[MAX_MAIL]; /* [Xg */\nint mail_num; /* [gp */\nint posted; /* ÏÝ[Ô */\nMail *arrive[MAX_MAIL];/* zB®¹[Xg */\nint arrive_cnt;/* zB®¹[ */\n\nunsigned long time = 0; /* V~[VÔ */\n\nint main(){\n\tchar buf[MAX_LEN];\n\tint i;\n\tint n,m;\n\tint a,b,d;\n\tint l;\n\tunsigned long min; /* ñ­Î·é^C}l */\n#ifdef PROFILE\n\tclock_t c_input=0, c_init=0, c_all=0, c_sim=0, c_take=0, c_arrive=0, c_mail=0, c_print=0;\n\n\tc_all-=clock();\n#endif\n\t\n\twhile(fgets(buf,MAX_LEN,stdin)!=NULL){\n\t\tif(sscanf(buf,\"%d %d\",&n,&m)<2){\n\t\t\tfprintf(stderr,\"error:invalid input\\n\");\n\t\t}else{\n\t\t\t/* 0 0 ¾Á½çI¹ */\n\t\t\tif(n<2||m<1)break;\n\t\t\t/* KvÈª¾¯ú» */\n#ifdef PROFILE\n\t\t\tc_init-=clock();\n#endif\n\t\t\tinit_nodes(n);\n#ifdef PROFILE\n\t\t\tc_init+=clock();\n\t\t\tc_input-=clock();\n#endif\n\t\t\t/* ]oHÇÝæè */\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 1;\n\t\t\t\tif(sscanf(buf,\"%d %d %d\",&a,&b,&d)<3)return 2;\n\t\t\t\t/* 0IWÉ·é½ß-1 */\n\t\t\t\tnode[a-1].dist[b-1] = d;\n\t\t\t\tnode[b-1].dist[a-1] = d;\n\t\t\t\tnode[a-1].distnext[b-1] = b-1;\n\t\t\t\tnode[b-1].distnext[a-1] = a-1;\n\t\t\t}\n\t\t\t/* [ÇÝæè */\n\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 3;\n\t\t\tif(sscanf(buf,\"%d\",&l)<1)return 4;\n\t\t\t/* [îñÇÝæè */\n\t\t\tmin = MAX_TIME;/* ÅÉ­Î·é^C}Í[ */\n\t\t\tfor(i=0;i<l;i++){\n\t\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 5;\n\t\t\t\tif(sscanf(buf,\"%d %d %d %[a-zA-Z0-9-_]\",\n\t\t\t\t\t&(mail[i].src),&(mail[i].dst),&(mail[i].timer),mail[i].label)<4)return 6;\n\t\t\t\t/* 0IWÉ·é½ß-1 */\n\t\t\t\tmail[i].src--;\n\t\t\t\tmail[i].dst--;\n\t\t\t\tmail[i].state = NONE;\n\t\t\t\tmail[i].next = NULL;\n\t\t\t\tif(min>mail[i].timer)min = mail[i].timer;\n\t\t\t}\n\t\t\tnode_num = n;\n\t\t\tmail_num = l;\n#ifdef PROFILE\n\t\t\tc_input+=clock();\n\t\t\tc_sim-=clock();\n#endif\n\n\t\t\t/* V~[VJn */\n\t\t\ttime = min;\n\t\t\tarrive_cnt = 0;\n\t\t\tposted = 0;\n\t\t\twhile(check_mail(l)!=0){/* S[ªzBI¹·éÜÅ */\n\t\t\t\tmin = MAX_TIME;\n#ifdef PROFILE\n\t\t\t\tc_mail-=clock();\n#endif\n\t\t\t\t/* èªÍ­ */\n\t\t\t\tfor(i=posted;mail[i].timer==time;i++){\n\t\t\t\t\tpost_mail(&mail[i]);\n\t\t\t\t\tposted++;\n\t\t\t\t}\n\t\t\t\tif(posted<mail_num)\tmin = mail[posted].timer;\n#ifdef PROFILE\n\t\t\t\tc_mail+=clock();\n#endif\n\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\t/* zBõª·é */\n\t\t\t\t\tif(node[i].timer == time){\n\t\t\t\t\t\tif(node[i].state == GO){\n#ifdef PROFILE\n\t\t\t\tc_arrive-=clock();\n#endif\n\t\t\t\t\t\t\tarrive_mail(i);\n#ifdef PROFILE\n\t\t\t\tc_arrive+=clock();\n#endif\n\t\t\t\t\t\t\tgo_back(i);\n\t\t\t\t\t\t}else if(node[i].state == BACK){\n\t\t\t\t\t\t\tnode[i].timer = 0;\n\t\t\t\t\t\t\tnode[i].state = HERE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* zBõªo­·é */\n\t\t\t\t\tif(node[i].state == HERE){\n#ifdef PROFILE\n\t\t\t\tc_take-=clock();\n#endif\n\t\t\t\t\t\ttake_mail(i);\n#ifdef PROFILE\n\t\t\t\tc_take+=clock();\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tif(node[i].timer && min>node[i].timer)min=node[i].timer;\n\t\t\t\t}\n#ifdef PROFILE\n\t\t\t\tc_print-=clock();\n#endif\n\t\t\t\tprint_arrive();\n#ifdef PROFILE\n\t\t\t\tc_print+=clock();\n#endif\n\t\t\t\ttime=min;\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n#ifdef PROFILE\n\t\t\tc_sim+=clock();\n#endif\n\t\t}\n\t}\n#ifdef PROFILE\n\tc_all+=clock();\n\tprintf(\n\t\t\"init:  %d\\n\"\n\t\t\"input: %d\\n\"\n\t\t\"sim:   %d\\n\"\n\t\t\" mail: %d\\n\"\n\t\t\" arriv:%d\\n\"\n\t\t\" take: %d\\n\"\n\t\t\" print:%d\\n\"\n\t\t\"all:   %d\\n\"\n\t\t,c_init, c_input, c_sim, c_mail, c_arrive, c_take, c_print, c_all);\n#endif\n\treturn 0;\n}\n\nvoid init_nodes(int n){\n\tint i,j;\n\tfor(i=0;i<n;i++){\n\t\tnode[i].state = HERE;\n\t\tnode[i].timer = 0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tnode[i].dist[j] = MAX_DIST;\n\t\t\tnode[i].distf[j] = FALSE;\n\t\t\tnode[i].distnext[j] = -1;\n\t\t}\n\t\tnode[i].dist[i] = 0;\n\t\tnode[i].distf[i] = TRUE;\n\t\tnode[i].distnext[i] = i;\n\t\tnode[i].dst = -1;\n\t\tnode[i].post_queue = NULL;\n\t\tnode[i].deli_queue = NULL;\n\t}\n}\n\nint check_mail(int l){\n\tint i,cnt;\n\tcnt=0;\n\tfor(i=0;i<l;i++){\n\t\tif(mail[i].state != DONE)cnt++;\n\t}\n\treturn cnt;\n}\n\nvoid post_mail(Mail *m){\n\tadd_mail(&(node[m->src].post_queue),m);\n\tm->state = POST;\n}\n\nvoid take_mail(int n){\n\tMail *que,**q,*tmp;\n\n\t/* zB·é[ª é©H */\n\tif(node[n].post_queue!=NULL){\n\n\t\t/* ÅÌ[ðzBXgÖÚ® */\n\t\tque = node[n].post_queue;\n\t\tdel_mail(&(node[n].post_queue),que);\n\t\tadd_mail(&(node[n].deli_queue),que);\n\n\t\tque->state = DELI;\n\t\tnode[n].state = GO;\n\t\tnode[n].timer = time+calc_dist(n,que->dst);/* »Ý{ÚWnÜÅÌ£ */\n\t\tnode[n].dst = node[n].distnext[que->dst];\n\n\t\t/* ¯¶Í¯æÌ[ðzBXgÖÚ® */\n\t\tq = &(node[n].post_queue);\n\t\twhile(*q != NULL){\n\t\t\tif((*q)->dst == que->dst){\n\t\t\t\ttmp = *q;\n\t\t\t\ttmp->state = DELI;\n\t\t\t\tdel_mail(q,tmp);\n\t\t\t\tadd_mail(&(node[n].deli_queue),tmp);\n\t\t\t}else{\n\t\t\t\tq = &((*q)->next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid arrive_mail(int n){\n\tMail *tmp;\n\n\twhile(node[n].deli_queue != NULL){\n\t\ttmp = node[n].deli_queue;\n\t\tdel_mail(&(node[n].deli_queue),tmp);\n\t\tif(tmp->dst==node[n].dst){\n\t\t\t/* ÅIÍ¯æÉ */\n\t\t\tarrive[arrive_cnt] = tmp;\n\t\t\tarrive_cnt++;\n\t\t\ttmp->state = DONE;\n\t\t}else{\n\t\t\t/* ³çÉ] */\n\t\t\tadd_mail(&(node[node[n].distnext[tmp->dst]].post_queue),tmp);\n\t\t\ttmp->state = POST;\n\t\t}\n\t}\n\n}\n\nvoid go_back(int n){\n\tnode[n].state = BACK;\n\tnode[n].timer = time + node[n].dist[node[n].dst];\n}\n\nvoid del_mail(Mail **q,Mail *mail){\n\twhile((*q)!=NULL && (*q)!=mail)q = &((*q)->next);\n\tif((*q)==mail){\n\t\t*q = mail->next;\n\t\tmail->next = NULL;\n\t}\n}\n\nvoid add_mail(Mail **q,Mail *mail){\n\twhile((*q)!=NULL)q = &((*q)->next);\n\tmail->next = NULL;\n\t*q = mail;\n}\n\n\n\nint calc_dist(int a, int b){\n\tstatic char past[MAX_NODE];/* ßÉÊÁ½m[h */\n\tstatic char best[MAX_NODE];/* ÅZÌm[h */\n\tstatic int past_n = 0; /* ßÉÊÁ½m[h */\n\tstatic int dist = 0;  /* ßÉÊÁÄ«½£ */\n\tstatic int bestd = MAX_DISTSUM;  /* ÅZÌ£ */\n\tint i,j;\n\n\tif(past_n==0) bestd = MAX_DISTSUM;/* TõJnú» */\n\n\tpast[past_n++] = a;\n\n\t/* ½Çè¢½Æ« */\n\tif(a==b){\n\t\t/* ¡ñÌoHªÅZÅ êÎÅZoHðXV */\n\t\tif(bestd>dist){\n\t\t\tbestd = dist;\n\t\t\tfor(i=0;i<past_n;i++)best[i]=past[i];\n\t\t}\n\t}else{\n\t\tif(dist<bestd){\n\t\t\t/* êxvZ³êÄ¢é */\n\t\t\tif(node[a].distf[b]==TRUE){\n\t\t\t\ti = node[a].distnext[b];\n\t\t\t\tfor(j=0;j<past_n;j++)if(past[j]==i)return -1;\n\t\t\t\tdist += node[a].dist[i];\n\t\t\t\tcalc_dist(i,b);\n\t\t\t\tdist -= node[a].dist[i];\n\t\t\t}else{\n\t\t\t\tfor(i=0;i<node_num;i++){\n\t\t\t\t\tfor(j=0;j<past_n;j++)if(past[j]==i)break;\n\t\t\t\t\tif(j!=past_n)continue;\n\t\t\t\t\tif(MAX_DIST>node[a].dist[i]){\n\t\t\t\t\t\tdist += node[a].dist[i];\n\t\t\t\t\t\tcalc_dist(i,b);\n\t\t\t\t\t\tdist -= node[a].dist[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpast_n--;\n\n\t/* TõI¹Ê½f */\n\tif(past_n==0){\n\t\tfor(i=0;best[i]!=b;i++){\n\t\t\tnode[best[i]].distnext[b] = best[i+1];\n\t\t\tnode[best[i+1]].distnext[a] = best[i];\n\t\t\tnode[best[i]].distf[b] = TRUE;\n\t\t\tnode[best[i+1]].distf[a] = TRUE;\n\t\t}\n\t\treturn  node[a].dist[node[a].distnext[b]];\n\t}\n\treturn  0;\n}\n\nvoid print_arrive(void){\n\tint i;\n\tif(arrive_cnt > 0){\n\t\tqsort(arrive,arrive_cnt,sizeof(Mail*),compare_mail);\n\t\tfor(i=0;i<arrive_cnt;i++){\n\t\t\tprintf(\"%s %d\\n\",arrive[i]->label,time);\n\t\t}\n\t}\n\tarrive_cnt = 0;\n}\n\t\n\nint compare_mail(const void* a, const void* b){\n\treturn strcmp((*(Mail**)a)->label,(*(Mail**)b)->label);\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_DEPRECATE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LEN 64\n\n#define MAX_NODE 32\n#define MAX_MAIL 1000\n#define MAX_LABEL 50+1\n\n#define MAX_TIME (1<<31)\n#define MAX_DIST 10000\n#define MAX_DISTSUM 320000\n\n#define TRUE 1\n#define FALSE 0\n\ntypedef enum {\n\tNONE, /* Í¯çêÄ¢È¢ */\n\tPOST, /* XÖÇÉ é */\n\tDELI, /* zB */\n\tDONE  /* zB®¹ */\n} MailState;\n\ntypedef enum {\n\tHERE, /* zBõª¢é */\n\tGO,   /* zBõªÚInÉü©ÁÄ¢é */\n\tBACK  /* zBõªÚIn©çAÁÄ«Ä¢é */\n} NodeState;\n\ntypedef struct _Mail{\n\tMailState state;    /* [ÌóÔ */\n\tunsigned long timer;          /* XÖÇÉÍ­Ô */\n\tstruct _Mail *next; /* ÉÍ¢½[ */\n\tint src;            /* a©èê */\n\tint dst;            /* ÅIÍ¯æ */\n\tchar label[MAX_LABEL]; /* x */\n} Mail;\n\ntypedef struct {\n\tNodeState state;    /* zBõÌóÔ */\n\tunsigned long timer;          /* zBõªÚ®µIíéÔ */\n\tint dst;            /* zBõÌÚIn */\n\tshort dist[MAX_NODE]; /* ]oHÌ£ */\n\tchar distf[MAX_NODE]; /* ÅZ£vZÏÝtO*/\n\tint distnext[MAX_NODE]; /* ÅZ£ÌÆ«É^Ôm[h*/\n\tMail *post_queue;        /* Í¢Ä¢é[ */\n\tMail *deli_queue;        /* zBÌ[ */\n} Node;\n\n/* nÂÌXÖÇim[hjÌú» */\nvoid init_nodes(int n);\n\n/* Í¯çêÄ¢È¢[Ì */\nint check_mail(int l);\n/* XÖÇÔÌÅZ£vZ */\nint calc_dist(int a, int b);\n/* èzBJn */\nvoid take_mail(int n);\n/* [Ì */\nvoid post_mail(Mail *m);\n/* zB®¹ */\nvoid arrive_mail(int n);\n/* zBõÌAÒõ */\nvoid go_back(int n);\n/* zB®¹[Ì\\¦ */\nvoid print_arrive(void);\n\n\nvoid del_mail(Mail **q,Mail *mail);\nvoid add_mail(Mail **q,Mail *mail);\n\nint compare_mail(const void* a, const void* b);\n\nNode node[MAX_NODE]; /* XÖÇXg */\nint node_num; /* XÖÇgp */\nMail mail[MAX_MAIL]; /* [Xg */\nMail mmail; /* ¢[Xg(æªÍ_~[) */\nint mail_num; /* [gp */\nMail *arrive[MAX_MAIL];/* zB®¹[Xg */\nint arrive_cnt;/* zB®¹[ */\n\nunsigned long time = 0; /* V~[VÔ */\n\nint main(){\n\tchar buf[MAX_LEN];\n\tint i;\n\tint n,m;\n\tint a,b,d;\n\tint l;\n\tMail *lmail,*nmail;\n\tunsigned long min; /* ñ­Î·é^C}l */\n\t\n\twhile(fgets(buf,MAX_LEN,stdin)!=NULL){\n\t\tif(sscanf(buf,\"%d %d\",&n,&m)<2){\n\t\t\tfprintf(stderr,\"error:invalid input\\n\");\n\t\t}else{\n\t\t\t/* 0 0 ¾Á½çI¹ */\n\t\t\tif(n<2||m<1)break;\n\t\t\t/* KvÈª¾¯ú» */\n\t\t\tinit_nodes(n);\n\t\t\t/* ]oHÇÝæè */\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 1;\n\t\t\t\tif(sscanf(buf,\"%d %d %d\",&a,&b,&d)<3)return 1;\n\t\t\t\t/* 0IWÉ·é½ß-1 */\n\t\t\t\tnode[a-1].dist[b-1] = d;\n\t\t\t\tnode[b-1].dist[a-1] = d;\n\t\t\t\tnode[a-1].distnext[b-1] = b-1;\n\t\t\t\tnode[b-1].distnext[a-1] = a-1;\n\t\t\t}\n\t\t\t/* [ÇÝæè */\n\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 1;\n\t\t\tif(sscanf(buf,\"%d\",&l)<1)return 1;\n\t\t\t/* [îñÇÝæè */\n\t\t\tmin = MAX_TIME;/* ÅÉ­Î·é^C}Í[ */\n\t\t\tmmail.next = NULL;\n\t\t\tfor(i=0;i<l;i++){\n\t\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 1;\n\t\t\t\tif(sscanf(buf,\"%d %d %d %[a-zA-Z0-9-_]\",\n\t\t\t\t\t&(mail[i].src),&(mail[i].dst),&(mail[i].timer),mail[i].label)<4)return 1;\n\t\t\t\t/* 0IWÉ·é½ß-1 */\n\t\t\t\tmail[i].src--;\n\t\t\t\tmail[i].dst--;\n\t\t\t\tmail[i].state = NONE;\n\t\t\t\tmail[i].next = mmail.next;\n\t\t\t\tmmail.next = &mail[i];\n\t\t\t\tif(min>mail[i].timer)min = mail[i].timer;\n\t\t\t}\n\t\t\tnode_num = n;\n\t\t\tmail_num = l;\n\n\t\t\t/* V~[VJn */\n\t\t\ttime = min;\n\t\t\tarrive_cnt = 0;\n\t\t\twhile(check_mail(l)!=0){/* S[ªzBI¹·éÜÅ */\n\t\t\t\tmin = MAX_TIME;\n\t\t\t\t/* èªÍ­ */\n\t\t\t\tlmail = &mmail;\n\t\t\t\tnmail = lmail->next;\n\t\t\t\twhile(nmail!=NULL){\n\t\t\t\t\tif(nmail->timer <= time){\n\t\t\t\t\t\tlmail->next = nmail->next;\n\t\t\t\t\t\tpost_mail(nmail);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(min>nmail->timer)min=nmail->timer;\n\t\t\t\t\t\tlmail = lmail->next;\n\t\t\t\t\t}\n\t\t\t\t\tnmail = lmail->next;\n\t\t\t\t}\n\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\t/* zBõª·é */\n\t\t\t\t\tif(node[i].timer == time){\n\t\t\t\t\t\tif(node[i].state == GO){\n\t\t\t\t\t\t\tarrive_mail(i);\n\t\t\t\t\t\t\tgo_back(i);\n\t\t\t\t\t\t}else if(node[i].state == BACK){\n\t\t\t\t\t\t\tnode[i].timer = 0;\n\t\t\t\t\t\t\tnode[i].state = HERE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* zBõªo­·é */\n\t\t\t\t\tif(node[i].state == HERE){\n\t\t\t\t\t\ttake_mail(i);\n\t\t\t\t\t}\n\t\t\t\t\tif(node[i].timer && min>node[i].timer)min=node[i].timer;\n\t\t\t\t}\n\t\t\t\tprint_arrive();\n\t\t\t\ttime=min;\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid init_nodes(int n){\n\tint i,j;\n\tfor(i=0;i<n;i++){\n\t\tnode[i].state = HERE;\n\t\tnode[i].timer = 0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tnode[i].dist[j] = MAX_DIST;\n\t\t\tnode[i].distf[j] = FALSE;\n\t\t\tnode[i].distnext[j] = -1;\n\t\t}\n\t\tnode[i].dist[i] = 0;\n\t\tnode[i].distf[i] = TRUE;\n\t\tnode[i].distnext[i] = i;\n\t\tnode[i].dst = -1;\n\t\tnode[i].post_queue = NULL;\n\t\tnode[i].deli_queue = NULL;\n\t}\n}\n\nint check_mail(int l){\n\tint i,cnt;\n\tcnt=0;\n\tfor(i=0;i<l;i++){\n\t\tif(mail[i].state != DONE)cnt++;\n\t}\n\treturn cnt;\n}\n\nvoid post_mail(Mail *m){\n\tadd_mail(&(node[m->src].post_queue),m);\n\tm->state = POST;\n}\n\nvoid take_mail(int n){\n\tMail *que,**q,*tmp;\n\n\t/* zB·é[ª é©H */\n\tif(node[n].post_queue!=NULL){\n\n\t\t/* ÅÌ[ðzBXgÖÚ® */\n\t\tque = node[n].post_queue;\n\t\tdel_mail(&(node[n].post_queue),que);\n\t\tadd_mail(&(node[n].deli_queue),que);\n\n\t\tque->state = DELI;\n\t\tnode[n].state = GO;\n\t\tnode[n].timer = time+calc_dist(n,que->dst);/* »Ý{ÚWnÜÅÌ£ */\n\t\tnode[n].dst = node[n].distnext[que->dst];\n\n\t\t/* ¯¶Í¯æÌ[ðzBXgÖÚ® */\n\t\tq = &(node[n].post_queue);\n\t\twhile(*q != NULL){\n\t\t\tif((*q)->dst == que->dst){\n\t\t\t\ttmp = *q;\n\t\t\t\ttmp->state = DELI;\n\t\t\t\tdel_mail(q,tmp);\n\t\t\t\tadd_mail(&(node[n].deli_queue),tmp);\n\t\t\t}else{\n\t\t\t\tq = &((*q)->next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid arrive_mail(int n){\n\tMail *tmp;\n\n\twhile(node[n].deli_queue != NULL){\n\t\ttmp = node[n].deli_queue;\n\t\tdel_mail(&(node[n].deli_queue),tmp);\n\t\tif(tmp->dst==node[n].dst){\n\t\t\t/* ÅIÍ¯æÉ */\n\t\t\tarrive[arrive_cnt] = tmp;\n\t\t\tarrive_cnt++;\n\t\t\ttmp->state = DONE;\n\t\t}else{\n\t\t\t/* ³çÉ] */\n\t\t\tadd_mail(&(node[node[n].distnext[tmp->dst]].post_queue),tmp);\n\t\t\ttmp->state = POST;\n\t\t}\n\t}\n\n}\n\nvoid go_back(int n){\n\tnode[n].state = BACK;\n\tnode[n].timer = time + node[n].dist[node[n].dst];\n}\n\nvoid del_mail(Mail **q,Mail *mail){\n\twhile((*q)!=NULL && (*q)!=mail)q = &((*q)->next);\n\tif((*q)==mail){\n\t\t*q = mail->next;\n\t\tmail->next = NULL;\n\t}\n}\n\nvoid add_mail(Mail **q,Mail *mail){\n\twhile((*q)!=NULL)q = &((*q)->next);\n\tmail->next = NULL;\n\t*q = mail;\n}\n\n\n\nint calc_dist(int a, int b){\n\tstatic int past[MAX_NODE];/* ßÉÊÁ½m[h */\n\tstatic int best[MAX_NODE];/* ÅZÌm[h */\n\tstatic int past_n = 0; /* ßÉÊÁ½m[h */\n\tstatic int dist = 0;  /* ßÉÊÁÄ«½£ */\n\tstatic int bestd = MAX_DISTSUM;  /* ÅZÌ£ */\n\tint i,j;\n\n\tif(past_n==0) bestd = MAX_DISTSUM;/* TõJnú» */\n\n\tpast[past_n++] = a;\n\n\t/* ½Çè¢½Æ« */\n\tif(a==b){\n\t\t/* ¡ñÌoHªÅZÅ êÎÅZoHðXV */\n\t\tif(bestd>dist){\n\t\t\tbestd = dist;\n\t\t\tfor(i=0;i<past_n;i++)best[i]=past[i];\n\t\t}\n\t}else{\n\t\t/* êxvZ³êÄ¢é */\n\t\tif(node[a].distf[b]==TRUE){\n\t\t\ti = node[a].distnext[b];\n\t\t\tfor(j=0;j<past_n;j++)if(past[j]==i)return -1;\n\t\t\tdist += node[a].dist[i];\n\t\t\tcalc_dist(i,b);\n\t\t\tdist -= node[a].dist[i];\n\t\t}else{\n\t\t\tfor(i=0;i<node_num;i++){\n\t\t\t\tfor(j=0;j<past_n;j++)if(past[j]==i)break;\n\t\t\t\tif(j!=past_n)continue;\n\t\t\t\tif(MAX_DIST>node[a].dist[i]){\n\t\t\t\t\tdist += node[a].dist[i];\n\t\t\t\t\tcalc_dist(i,b);\n\t\t\t\t\tdist -= node[a].dist[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpast_n--;\n\n\t/* TõI¹Ê½f */\n\tif(past_n==0){\n\t\tfor(i=0;best[i]!=b;i++){\n\t\t\tnode[best[i]].distnext[b] = best[i+1];\n\t\t\tnode[best[i+1]].distnext[a] = best[i];\n\t\t\tnode[best[i]].distf[b] = TRUE;\n\t\t\tnode[best[i+1]].distf[a] = TRUE;\n\t\t}\n\t}\n\treturn  node[a].dist[node[a].distnext[b]];\n}\n\n\n\n#if 0\n\tdo{\n\t\tmin = 10000;\n\t\tmin_i = 10000;\n\t\tfor(i=0;i<node_num;i++){\n\t\t\tif(a!=i && node[a].distf[i] == FALSE){\n\t\t\t\tif(min>node[a].dist[i]){\n\t\t\t\t\tmin = node[a].dist[i];\n\t\t\t\t\tmin_i = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnode[a].distf[min_i] = TRUE;\n\t\tnode[min_i].distf[a] = TRUE;\n\t\tfor(i=0;i<node_num;i++){\n\t\t\tif(min_i!=i && node[min_i].dist[i] != 10000){\n\t\t\t\tif(node[a].dist[i]>node[a].dist[min_i]+node[min_i].dist[i]){\n\t\t\t\t\tnode[a].dist[i] = node[a].dist[min_i]+node[min_i].dist[i];\n\t\t\t\t\tnode[a].distnext[i] = node[a].distnext[min_i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while(min_i!=b);\n\n\n\t//min = node[a].dist[b];\n\t//for(i=0;i<node_num;i++){\n\t//\tif(a!=i && node[a].dist[i] != 10000){\n\t//\t\ttmp = node[a].dist[i]+calc_dist(i,b);\n\t//\t\tif(min>tmp)min = tmp;\n\t//\t}\n\t//}\n\tnode[a].distf[b] = TRUE;\n\tnode[b].distf[a] = TRUE;\n\tnode[a].dist[b] = min;\n\tnode[b].dist[a] = min;\n\treturn node[a].dist[node[a].distnext[b]];\n}\n#endif\n\nvoid print_arrive(void){\n\tint i;\n\tif(arrive_cnt > 0){\n\t\tqsort(arrive,arrive_cnt,sizeof(Mail*),compare_mail);\n\t\tfor(i=0;i<arrive_cnt;i++){\n\t\t\tprintf(\"%s %d\\n\",arrive[i]->label,time);\n\t\t}\n\t}\n\tarrive_cnt = 0;\n}\n\t\n\nint compare_mail(const void* a, const void* b){\n\treturn strcmp((*(Mail**)a)->label,(*(Mail**)b)->label);\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_DEPRECATE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n//#define PROFILE\n\n#ifdef PROFILE\n#include <time.h>\n#define time _time\n#endif\n\n#define MAX_LEN 64\n\n#define MAX_NODE 32\n#define MAX_MAIL 1000\n#define MAX_LABEL 50+1\n\n#define MAX_TIME (1UL<<31)\n#define MAX_DIST 10000\n#define MAX_DISTSUM 320000\n\n#define TRUE (char)0x01\n#define FALSE (char)0x00\n\ntypedef enum {\n\tNONE, /* Í¯çêÄ¢È¢ */\n\tPOST, /* XÖÇÉ é */\n\tDELI, /* zB */\n\tDONE  /* zB®¹ */\n} MailState;\n\ntypedef enum {\n\tHERE, /* zBõª¢é */\n\tGO,   /* zBõªÚInÉü©ÁÄ¢é */\n\tBACK  /* zBõªÚIn©çAÁÄ«Ä¢é */\n} NodeState;\n\ntypedef struct _Mail{\n\tMailState state;    /* [ÌóÔ */\n\tunsigned long timer;          /* XÖÇÉÍ­Ô */\n\tstruct _Mail *next; /* ÉÍ¢½[ */\n\tint src;            /* a©èê */\n\tint dst;            /* ÅIÍ¯æ */\n\tchar label[MAX_LABEL]; /* x */\n} Mail;\n\ntypedef struct {\n\tNodeState state;    /* zBõÌóÔ */\n\tunsigned long timer;          /* zBõªÚ®µIíéÔ */\n\tint dst;            /* zBõÌÚIn */\n\tint dist[MAX_NODE]; /* ]oHÌ£ */\n\tchar distf[MAX_NODE]; /* ÅZ£vZÏÝtO*/\n\tint distnext[MAX_NODE]; /* ÅZ£ÌÆ«É^Ôm[h*/\n\tMail *post_queue;        /* Í¢Ä¢é[ */\n\tMail *deli_queue;        /* zBÌ[ */\n} Node;\n\n/* nÂÌXÖÇim[hjÌú» */\nstatic void init_nodes(int n);\n\n/* Í¯çêÄ¢È¢[Ì */\nstatic int check_mail(int l);\n/* XÖÇÔÌÅZ£vZ */\nstatic int calc_dist(int a, int b);\n/* èzBJn */\nstatic void take_mail(int n);\n/* [Ì */\nstatic void post_mail(Mail *m);\n/* zB®¹ */\nstatic void arrive_mail(int n);\n/* zBõÌAÒõ */\nstatic void go_back(int n);\n/* zB®¹[Ì\\¦ */\nstatic void print_arrive(void);\n\n\nstatic void del_mail(Mail **q,Mail *mail);\nstatic void add_mail(Mail **q,Mail *mail);\n\nstatic int compare_mail(const void* a, const void* b);\n\nstatic Node node[MAX_NODE]; /* XÖÇXg */\nstatic int node_num; /* XÖÇgp */\nstatic Mail mail[MAX_MAIL]; /* [Xg */\nstatic int mail_num; /* [gp */\nstatic int posted; /* ÏÝ[Ô */\nstatic Mail *arrive[MAX_MAIL];/* zB®¹[Xg */\nstatic int arrive_cnt;/* zB®¹[ */\n\nstatic unsigned long time = 0; /* V~[VÔ */\n\nint main(){\n\tchar buf[MAX_LEN];\n\tint i;\n\tint n,m;\n\tint a,b,d;\n\tint l;\n\tunsigned long min; /* ñ­Î·é^C}l */\n#ifdef PROFILE\n\tclock_t c_input=0, c_init=0, c_all=0, c_sim=0, c_take=0, c_arrive=0, c_mail=0, c_print=0;\n\n\tc_all-=clock();\n#endif\n\t\n\twhile(fgets(buf,MAX_LEN,stdin)!=NULL){\n\t\tif(sscanf(buf,\"%d %d\",&n,&m)<2){\n\t\t\tfprintf(stderr,\"error:invalid input\\n\");\n\t\t}else{\n\t\t\t/* 0 0 ¾Á½çI¹ */\n\t\t\tif(n<2||m<1)break;\n\t\t\t/* KvÈª¾¯ú» */\n#ifdef PROFILE\n\t\t\tc_init-=clock();\n#endif\n\t\t\tinit_nodes(n);\n#ifdef PROFILE\n\t\t\tc_init+=clock();\n\t\t\tc_input-=clock();\n#endif\n\t\t\t/* ]oHÇÝæè */\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 1;\n\t\t\t\tif(sscanf(buf,\"%d %d %d\",&a,&b,&d)<3)return 2;\n\t\t\t\t/* 0IWÉ·é½ß-1 */\n\t\t\t\tnode[a-1].dist[b-1] = d;\n\t\t\t\tnode[b-1].dist[a-1] = d;\n\t\t\t\tnode[a-1].distnext[b-1] = b-1;\n\t\t\t\tnode[b-1].distnext[a-1] = a-1;\n\t\t\t}\n\t\t\t/* [ÇÝæè */\n\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 3;\n\t\t\tif(sscanf(buf,\"%d\",&l)<1)return 4;\n\t\t\t/* [îñÇÝæè */\n\t\t\tmin = MAX_TIME;/* ÅÉ­Î·é^C}Í[ */\n\t\t\tfor(i=0;i<l;i++){\n\t\t\t\tif(fgets(buf,MAX_LEN,stdin)==NULL)return 5;\n\t\t\t\tif(sscanf(buf,\"%d %d %ld %[a-zA-Z0-9-_]\",\n\t\t\t\t\t&(mail[i].src),&(mail[i].dst),&(mail[i].timer),mail[i].label)<4)return 6;\n\t\t\t\t/* 0IWÉ·é½ß-1 */\n\t\t\t\tmail[i].src--;\n\t\t\t\tmail[i].dst--;\n\t\t\t\tmail[i].state = NONE;\n\t\t\t\tmail[i].next = NULL;\n\t\t\t\tif(min>mail[i].timer)min = mail[i].timer;\n\t\t\t}\n\t\t\tnode_num = n;\n\t\t\tmail_num = l;\n#ifdef PROFILE\n\t\t\tc_input+=clock();\n\t\t\tc_sim-=clock();\n#endif\n\n\t\t\t/* V~[VJn */\n\t\t\ttime = min;\n\t\t\tarrive_cnt = 0;\n\t\t\tposted = 0;\n\t\t\twhile(check_mail(l)!=0){/* S[ªzBI¹·éÜÅ */\n\t\t\t\tmin = MAX_TIME;\n#ifdef PROFILE\n\t\t\t\tc_mail-=clock();\n#endif\n\t\t\t\t/* èªÍ­ */\n\t\t\t\tfor(i=posted;mail[i].timer==time;i++){\n\t\t\t\t\tpost_mail(&mail[i]);\n\t\t\t\t\tposted++;\n\t\t\t\t}\n\t\t\t\tif(posted<mail_num)\tmin = mail[posted].timer;\n#ifdef PROFILE\n\t\t\t\tc_mail+=clock();\n#endif\n\t\t\t\tfor(i=0;i<n;i++){\n\t\t\t\t\t/* zBõª·é */\n\t\t\t\t\tif(node[i].timer == time){\n\t\t\t\t\t\tif(node[i].state == GO){\n#ifdef PROFILE\n\t\t\t\tc_arrive-=clock();\n#endif\n\t\t\t\t\t\t\tarrive_mail(i);\n#ifdef PROFILE\n\t\t\t\tc_arrive+=clock();\n#endif\n\t\t\t\t\t\t\tgo_back(i);\n\t\t\t\t\t\t}else if(node[i].state == BACK){\n\t\t\t\t\t\t\tnode[i].timer = 0;\n\t\t\t\t\t\t\tnode[i].state = HERE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* zBõªo­·é */\n\t\t\t\t\tif(node[i].state == HERE){\n#ifdef PROFILE\n\t\t\t\tc_take-=clock();\n#endif\n\t\t\t\t\t\ttake_mail(i);\n#ifdef PROFILE\n\t\t\t\tc_take+=clock();\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tif(node[i].timer!=0 && min>node[i].timer)min=node[i].timer;\n\t\t\t\t}\n#ifdef PROFILE\n\t\t\t\tc_print-=clock();\n#endif\n\t\t\t\tprint_arrive();\n#ifdef PROFILE\n\t\t\t\tc_print+=clock();\n#endif\n\t\t\t\ttime=min;\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n#ifdef PROFILE\n\t\t\tc_sim+=clock();\n#endif\n\t\t}\n\t}\n#ifdef PROFILE\n\tc_all+=clock();\n\tprintf(\n\t\t\"init:  %ld\\n\"\n\t\t\"input: %ld\\n\"\n\t\t\"sim:   %ld\\n\"\n\t\t\" mail: %ld\\n\"\n\t\t\" arriv:%ld\\n\"\n\t\t\" take: %ld\\n\"\n\t\t\" print:%ld\\n\"\n\t\t\"all:   %ld\\n\"\n\t\t,c_init, c_input, c_sim, c_mail, c_arrive, c_take, c_print, c_all);\n#endif\n\treturn 0;\n}\n\nstatic void init_nodes(int n){\n\tint i,j;\n\tfor(i=0;i<n;i++){\n\t\tnode[i].state = HERE;\n\t\tnode[i].timer = 0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tnode[i].dist[j] = MAX_DIST;\n\t\t\tnode[i].distf[j] = FALSE;\n\t\t\tnode[i].distnext[j] = -1;\n\t\t}\n\t\tnode[i].dist[i] = 0;\n\t\tnode[i].distf[i] = TRUE;\n\t\tnode[i].distnext[i] = i;\n\t\tnode[i].dst = -1;\n\t\tnode[i].post_queue = NULL;\n\t\tnode[i].deli_queue = NULL;\n\t}\n}\n\nstatic int check_mail(int l){\n\tint i,cnt;\n\tcnt=0;\n\tfor(i=0;i<l;i++){\n\t\tif(mail[i].state != DONE)cnt++;\n\t}\n\treturn cnt;\n}\n\nstatic void post_mail(Mail *m){\n\tadd_mail(&(node[m->src].post_queue),m);\n\tm->state = POST;\n}\n\nstatic void take_mail(int n){\n\tMail *que,**q,*tmp;\n\n\t/* zB·é[ª é©H */\n\tif(node[n].post_queue!=NULL){\n\n\t\t/* ÅÌ[ðzBXgÖÚ® */\n\t\tque = node[n].post_queue;\n\t\tdel_mail(&(node[n].post_queue),que);\n\t\tadd_mail(&(node[n].deli_queue),que);\n\n\t\tque->state = DELI;\n\t\tnode[n].state = GO;\n\t\tnode[n].timer = time+calc_dist(n,que->dst);/* »Ý{ÚWnÜÅÌ£ */\n\t\tnode[n].dst = node[n].distnext[que->dst];\n\n\t\t/* ¯¶Í¯æÌ[ðzBXgÖÚ® */\n\t\tq = &(node[n].post_queue);\n\t\twhile(*q != NULL){\n\t\t\tif((*q)->dst == que->dst){\n\t\t\t\ttmp = *q;\n\t\t\t\ttmp->state = DELI;\n\t\t\t\tdel_mail(q,tmp);\n\t\t\t\tadd_mail(&(node[n].deli_queue),tmp);\n\t\t\t}else{\n\t\t\t\tq = &((*q)->next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void arrive_mail(int n){\n\tMail *tmp;\n\n\twhile(node[n].deli_queue != NULL){\n\t\ttmp = node[n].deli_queue;\n\t\tdel_mail(&(node[n].deli_queue),tmp);\n\t\tif(tmp->dst==node[n].dst){\n\t\t\t/* ÅIÍ¯æÉ */\n\t\t\tarrive[arrive_cnt] = tmp;\n\t\t\tarrive_cnt++;\n\t\t\ttmp->state = DONE;\n\t\t}else{\n\t\t\t/* ³çÉ] */\n\t\t\tadd_mail(&(node[node[n].distnext[tmp->dst]].post_queue),tmp);\n\t\t\ttmp->state = POST;\n\t\t}\n\t}\n\n}\n\nstatic void go_back(int n){\n\tnode[n].state = BACK;\n\tnode[n].timer = time + node[n].dist[node[n].dst];\n}\n\nstatic void del_mail(Mail **q,Mail *m){\n\twhile((*q)!=NULL && (*q)!=m)q = &((*q)->next);\n\tif((*q)==m){\n\t\t*q = m->next;\n\t\tm->next = NULL; /* @null@ */\n\t}\n}\n\nstatic void add_mail(Mail **q,Mail *m){\n\twhile((*q)!=NULL)q = &((*q)->next);\n\tm->next = NULL;\n\t*q = m;\n}\n\n\n\nstatic int calc_dist(int a, int b){\n\tstatic int past[MAX_NODE];/* ßÉÊÁ½m[h */\n\tstatic int best[MAX_NODE];/* ÅZÌm[h */\n\tstatic int past_n = 0; /* ßÉÊÁ½m[h */\n\tstatic int dist = 0;  /* ßÉÊÁÄ«½£ */\n\tstatic int bestd = MAX_DISTSUM;  /* ÅZÌ£ */\n\tint i,j;\n\n\tif(past_n==0) bestd = MAX_DISTSUM;/* TõJnú» */\n\n\tpast[past_n++] = a;\n\n\t/* ½Çè¢½Æ« */\n\tif(a==b){\n\t\t/* ¡ñÌoHªÅZÅ êÎÅZoHðXV */\n\t\tif(bestd>dist){\n\t\t\tbestd = dist;\n\t\t\tfor(i=0;i<past_n;i++)best[i]=past[i];\n\t\t}\n\t}else{\n\t\tif(dist<bestd){\n\t\t\t/* êxvZ³êÄ¢é */\n\t\t\tif(node[a].distf[b]==TRUE){\n\t\t\t\ti = node[a].distnext[b];\n\t\t\t\tfor(j=0;j<past_n;j++)if(past[j]==i)return -1;\n\t\t\t\tdist += node[a].dist[i];\n\t\t\t\t(void)calc_dist(i,b);\n\t\t\t\tdist -= node[a].dist[i];\n\t\t\t}else{\n\t\t\t\tfor(i=0;i<node_num;i++){\n\t\t\t\t\tfor(j=0;j<past_n;j++)if(past[j]==i)break;\n\t\t\t\t\tif(j!=past_n)continue;\n\t\t\t\t\tif(MAX_DIST>node[a].dist[i]){\n\t\t\t\t\t\tdist += node[a].dist[i];\n\t\t\t\t\t\t(void)calc_dist(i,b);\n\t\t\t\t\t\tdist -= node[a].dist[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpast_n--;\n\n\t/* TõI¹Ê½f */\n\tif(past_n==0){\n\t\tfor(i=0;best[i]!=b;i++){\n\t\t\tnode[best[i]].distnext[b] = best[i+1];\n\t\t\tnode[best[i+1]].distnext[a] = best[i];\n\t\t\tnode[best[i]].distf[b] = TRUE;\n\t\t\tnode[best[i+1]].distf[a] = TRUE;\n\t\t}\n\t\treturn  node[a].dist[node[a].distnext[b]];\n\t}\n\treturn  0;\n}\n\nstatic void print_arrive(void){\n\tint i;\n\tif(arrive_cnt > 0){\n\t\tqsort(arrive,(size_t)arrive_cnt,sizeof(Mail*),compare_mail);\n\t\tfor(i=0;i<arrive_cnt;i++){\n\t\t\tprintf(\"%s %ld\\n\",arrive[i]->label,(long)time);\n\t\t}\n\t}\n\tarrive_cnt = 0;\n}\n\t\n\nstatic int compare_mail(const void* a, const void* b){\n\treturn strcmp((*(Mail**)a)->label,(*(Mail**)b)->label);\n}"
  },
  {
    "language": "Kotlin",
    "code": "\nimport java.util.*\n\nfun setRoute(officeCount:Int, routeInfo:Array<Triple<Int, Int, Int>>):Array<PostOffice> {\n    val routes = Array(officeCount){Array(officeCount){\n        Route(Int.MAX_VALUE)\n    }}\n    val office = Array(officeCount){PostOffice(it, routes[it])}\n    routeInfo.forEach {(from, to, distance) ->\n        routes[from - 1][to - 1] = Route(distance, office[to - 1])\n        routes[to - 1][from - 1] = Route(distance, office[from - 1])\n    }\n    for (mid in 0 until officeCount) for (from in 0 until officeCount) for (to in 0 until officeCount){\n        if (routes[from][mid].minCost < routes[from][to].minCost - routes[mid][to].minCost){\n            routes[from][to] = Route(routes[from][mid].minCost + routes[mid][to].minCost, routes[from][mid].next)\n            routes[to][from] = Route(routes[from][mid].minCost + routes[mid][to].minCost, routes[to][mid].next)\n        }else if (routes[from][mid].minCost == routes[from][to].minCost - routes[mid][to].minCost){\n            if (routes[from][to].next.id > routes[from][mid].next.id)\n                routes[from][to].next = routes[from][mid].next\n            if (routes[to][from].next.id > routes[to][mid].next.id)\n                routes[to][from].next = routes[to][mid].next\n        }\n    }\n    return office\n}\nfun main(args:Array<String>):Unit{\n    var isNotFirst = false\n    while(true){\n        val (n, m) = readLine()!!.split(' ').map(String::toInt)\n        if (n == 0 && m == 0) return\n        val offices = setRoute(n, Array(m){\n            val (f, t, d) = readLine()!!.split(' ').map(String::toInt)\n            Triple(f, t, d)\n        })\n        val civilian:Civilian = Civilian()\n        repeat(readLine()!!.toInt()){\n            val arg = readLine()!!.split(' ')\n            val (from, to, time) = arg.take(3).map(String::toInt)\n            civilian.addPostSchedule(time, Mail(offices[to - 1], arg.last()), offices[from - 1])\n        }\n        if (isNotFirst) println()\n        isNotFirst = true\n        loopEvent(offices.map{it.officer} + civilian)\n    }\n}\ntypealias Mails = Collection<Mail>\ninterface Person{\n    val nextSchedule:Event\n}\nclass Officer(private val mOffice: PostOffice):Person{\n    val id:Int = mOffice.id\n    override var nextSchedule: Event = Event.NoEvent\n        private set\n    private var currentRelationalPosition:Int = 0\n    fun addJobToReturn(currentTime:Int):Unit {\n        nextSchedule = Event.SomeEvent.ReturnToOffice(currentTime + currentRelationalPosition, this)\n        currentRelationalPosition = 0\n    }\n    fun findNewJob(currentTime:Int):Unit {\n        nextSchedule = Event.NoEvent\n        mOffice.returnOfficer(currentTime)\n    }\n    fun addJobToDeliverMails(currentTime:Int, distance:Int, mails: Mails, deliverAt:PostOffice):Unit {\n        nextSchedule = Event.SomeEvent.DeliverMails(currentTime + distance, this, mails, deliverAt)\n        currentRelationalPosition = distance\n    }\n}\nclass Civilian:Person{\n    private val mSchedules:Deque<Event.SomeEvent.PostMail> = LinkedList()\n    override val nextSchedule: Event\n        get() = mSchedules.firstOrNull() ?: Event.NoEvent\n    fun addPostSchedule(time:Int, mail:Mail, postAt:PostOffice):Unit {\n        mSchedules.addLast(Event.SomeEvent.PostMail(time, mail, postAt, this))\n    }\n    fun receivedMail():Unit {\n        mSchedules.removeFirst()\n    }\n}\nclass MailBox(val id:Int){\n    var timeStamp:Int = Int.MAX_VALUE\n        private set\n    private val mMails:Stack<Mail> = Stack()\n    val mails:Mails\n        get() = mMails\n    fun clear():Unit {\n        timeStamp = Int.MAX_VALUE\n        mMails.clear()\n    }\n    fun addMail(currentTime:Int, mail:Mail):Unit {\n        if (timeStamp > currentTime){\n            timeStamp = currentTime\n        }\n        mMails.push(mail)\n    }\n    fun isEmpty():Boolean = mMails.isEmpty()\n}\nclass PostOffice(val id:Int, private val route:Array<Route>){\n    val officer:Officer = Officer(this)\n    private val mMail:Array<MailBox> = Array(route.size){MailBox(it)}\n    fun postMail(currentTime:Int, mail:Mail):Unit {\n        mMail[route[mail.destination.id].next.id].addMail(currentTime, mail)\n        instructNewJob(currentTime)\n    }\n    fun addMails(currentTime:Int, mails:Mails):Unit {\n        mails.forEach {\n            mMail[route[it.destination.id].next.id].addMail(currentTime,it)\n        }\n        instructNewJob(currentTime)\n    }\n    fun returnOfficer(currentTime:Int):Unit {\n        when(officer.nextSchedule){\n            is Event.NoEvent -> {\n                val mailBox = mMail.filterNot{it.isEmpty()}.minBy { it.timeStamp }\n                when(mailBox){\n                    null -> return\n                    else -> {\n                        officer.addJobToDeliverMails(currentTime, route[mailBox.id].minCost, mailBox.mails, route[mailBox.id].next)\n                        mailBox.clear()\n                    }\n                }\n            }\n            else -> return\n        }\n    }\n    private fun instructNewJob(currentTime:Int):Unit {\n        when(officer.nextSchedule){\n            is Event.NoEvent -> officer.addJobToReturn(currentTime)\n            else -> return\n        }\n    }\n}\n\nclass Route(val minCost:Int, private var mNext:PostOffice? = null){\n    var next:PostOffice\n        get() = mNext!!\n        set(value){\n            mNext = value\n        }\n}\nclass Mail(val destination:PostOffice, val label:String)\nsealed class Event {\n    object NoEvent : Event()\n    sealed class SomeEvent(val time: Int) : Event(), Comparable<SomeEvent> {\n        protected abstract fun compareToWithType(other: SomeEvent): Int\n        override fun compareTo(other: SomeEvent): Int {\n            return when (time) {\n                other.time -> compareToWithType(other)\n                else -> time.compareTo(other.time)\n            }\n        }\n\n        class PostMail(time: Int, val mail: Mail, val office: PostOffice, val poster: Civilian) : SomeEvent(time) {\n            override fun compareToWithType(other: SomeEvent): Int {\n                return when (other) {\n                    is PostMail -> 0\n                    else -> -1\n                }\n            }\n        }\n\n        class DeliverMails(time: Int, val officer: Officer, mails: Mails, val next: PostOffice) : SomeEvent(time) {\n            override fun compareToWithType(other: SomeEvent): Int {\n                return when (other) {\n                    is PostMail -> 1\n                    else -> 0\n                }\n            }\n\n            val mailsToDestination: Mails = mails.filter { it.destination == next }\n            val mailsToRelay: Mails = mails.filterNot { it.destination == next }\n        }\n\n        class ReturnToOffice(time: Int, val officer: Officer) : SomeEvent(time) {\n            override fun compareToWithType(other: SomeEvent): Int {\n                return when (other) {\n                    is ReturnToOffice -> 0\n                    else -> 1\n                }\n            }\n        }\n    }\n}\nfun loopEvent(persons:Collection<Person>):Unit {\n    val result: Stack<Pair<String, Int>> = Stack()\n    loop@while (true){\n        val event = persons.mapNotNull { it.nextSchedule as? Event.SomeEvent }.min()\n        when (event) {\n            is Event.SomeEvent.PostMail -> {\n                //println(\"time = ${event.time}, post = ${event.mail.label}, at = ${event.office.id}\")\n                event.office.postMail(event.time, event.mail)\n                event.poster.receivedMail()\n            }\n            is Event.SomeEvent.DeliverMails -> {\n                //println(\"time = ${event.time}, officer = ${event.officer.id}, deliver = ${event.mailsToDestination.joinToString(\",\") { it.label }}, ${event.mailsToRelay.joinToString(\",\") { it.label }}, office = ${event.next.id}\")\n                result.addAll(event.mailsToDestination.map { Pair(it.label, event.time) })\n                event.next.addMails(event.time, event.mailsToRelay)\n                event.officer.addJobToReturn(event.time)\n            }\n            is Event.SomeEvent.ReturnToOffice -> {\n                //println(\"time = ${event.time}, officer = ${event.officer.id} return\")\n                event.officer.findNewJob(event.time)\n            }\n            null -> break@loop\n        }\n    }\n    println(\n            result.sortedWith(compareBy(Pair<String, Int>::second, Pair<String,Int>::first)).joinToString(\"\\n\") { \"${it.first} ${it.second}\" }\n    )\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "\nimport java.util.*\n\nfun setRoute(officeCount:Int, routeInfo:Array<Triple<Int, Int, Int>>):Array<PostOffice> {\n    val routes = Array(officeCount){Array(officeCount){\n        Route(Int.MAX_VALUE)\n    }}\n    val office = Array(officeCount){PostOffice(it, routes[it])}\n    routeInfo.forEach {(from, to, distance) ->\n        routes[from - 1][to - 1] = Route(distance, office[to - 1])\n        routes[to - 1][from - 1] = Route(distance, office[from - 1])\n    }\n    for (mid in 0 until officeCount) for (from in 0 until officeCount) for (to in 0 until officeCount){\n        if (routes[from][mid].minCost < routes[from][to].minCost - routes[mid][to].minCost){\n            routes[from][to] = Route(routes[from][mid].minCost + routes[mid][to].minCost, routes[from][mid].next)\n            routes[to][from] = Route(routes[from][mid].minCost + routes[mid][to].minCost, routes[to][mid].next)\n        }\n    }\n    return office\n}\nfun main(args:Array<String>):Unit{\n    var isNotFirst = false\n    while(true){\n        val (n, m) = readLine()!!.split(' ').map(String::toInt)\n        if (n == 0 && m == 0) return\n        val offices = setRoute(n, Array(m){\n            val (f, t, d) = readLine()!!.split(' ').map(String::toInt)\n            Triple(f, t, d)\n        })\n        val civilian:Civilian = Civilian()\n        repeat(readLine()!!.toInt()){\n            val arg = readLine()!!.split(' ')\n            val (from, to, time) = arg.take(3).map(String::toInt)\n            civilian.addPostSchedule(time, Mail(offices[to - 1], arg.last()), offices[from - 1])\n        }\n        if (isNotFirst) println()\n        isNotFirst = true\n        loopEvent(offices.map{it.officer} + civilian)\n    }\n}\ntypealias Mails = Collection<Mail>\ninterface Person{\n    val nextSchedule:Event\n}\nclass Officer(private val mOffice: PostOffice):Person{\n    val id:Int = mOffice.id\n    override var nextSchedule: Event = Event.NoEvent\n        private set\n    private var currentRelationalPosition:Int = 0\n    fun addJobToReturn(currentTime:Int):Unit {\n        nextSchedule = Event.SomeEvent.ReturnToOffice(currentTime + currentRelationalPosition, this)\n        currentRelationalPosition = 0\n    }\n    fun findNewJob(currentTime:Int):Unit {\n        nextSchedule = Event.NoEvent\n        mOffice.returnOfficer(currentTime)\n    }\n    fun addJobToDeliverMails(currentTime:Int, distance:Int, mails: Mails, deliverAt:PostOffice):Unit {\n        nextSchedule = Event.SomeEvent.DeliverMails(currentTime + distance, this, mails, deliverAt)\n        currentRelationalPosition = distance\n    }\n}\nclass Civilian:Person{\n    private val mSchedules:Deque<Event.SomeEvent.PostMail> = LinkedList()\n    override val nextSchedule: Event\n        get() = mSchedules.firstOrNull() ?: Event.NoEvent\n    fun addPostSchedule(time:Int, mail:Mail, postAt:PostOffice):Unit {\n        mSchedules.addLast(Event.SomeEvent.PostMail(time, mail, postAt, this))\n    }\n    fun receivedMail():Unit {\n        mSchedules.removeFirst()\n    }\n}\nclass PostOffice(val id:Int, private val route:Array<Route>){\n    val officer:Officer = Officer(this)\n    private val mMail:Array<Stack<Mail>> = Array(route.size){Stack<Mail>()}\n    fun postMail(currentTime:Int, mail:Mail):Unit {\n        mMail[route[mail.destination.id].next.id].push(mail)\n        instructNewJob(currentTime)\n    }\n    fun addMails(currentTime:Int, mails:Mails):Unit {\n        mails.forEach {\n            mMail[route[it.destination.id].next.id].push(it)\n        }\n        instructNewJob(currentTime)\n    }\n    fun returnOfficer(currentTime:Int):Unit {\n        when(officer.nextSchedule){\n            is Event.NoEvent -> {\n                val mails = mMail.indexOfFirst{it.isNotEmpty()}\n                when(mails){\n                    -1 -> return\n                    else -> {\n                        officer.addJobToDeliverMails(currentTime, route[mails].minCost, mMail[mails], route[mails].next)\n                        mMail[mails].clear()\n                    }\n                }\n            }\n            else -> return\n        }\n    }\n    private fun instructNewJob(currentTime:Int):Unit {\n        when(officer.nextSchedule){\n            is Event.NoEvent -> officer.addJobToReturn(currentTime)\n            else -> return\n        }\n    }\n}\n\nclass Route(val minCost:Int, private var mNext:PostOffice? = null){\n    var next:PostOffice\n        get() = mNext!!\n        set(value){\n            mNext = value\n        }\n}\nclass Mail(val destination:PostOffice, val label:String)\nsealed class Event {\n    object NoEvent : Event()\n    sealed class SomeEvent(val time: Int) : Event(), Comparable<SomeEvent> {\n        protected abstract fun compareToWithType(other: SomeEvent): Int\n        override fun compareTo(other: SomeEvent): Int {\n            return when (time) {\n                other.time -> compareToWithType(other)\n                else -> time.compareTo(other.time)\n            }\n        }\n\n        class PostMail(time: Int, val mail: Mail, val office: PostOffice, val poster: Civilian) : SomeEvent(time) {\n            override fun compareToWithType(other: SomeEvent): Int {\n                return when (other) {\n                    is PostMail -> 0\n                    else -> -1\n                }\n            }\n        }\n\n        class DeliverMails(time: Int, val officer: Officer, mails: Mails, val next: PostOffice) : SomeEvent(time) {\n            override fun compareToWithType(other: SomeEvent): Int {\n                return when (other) {\n                    is PostMail -> 1\n                    else -> 0\n                }\n            }\n\n            val mailsToDestination: Mails = mails.filter { it.destination == next }\n            val mailsToRelay: Mails = mails.filterNot { it.destination == next }\n        }\n\n        class ReturnToOffice(time: Int, val officer: Officer) : SomeEvent(time) {\n            override fun compareToWithType(other: SomeEvent): Int {\n                return when (other) {\n                    is ReturnToOffice -> 0\n                    else -> 1\n                }\n            }\n        }\n    }\n}\nfun loopEvent(persons:Collection<Person>):Unit {\n    val result: Stack<Pair<String, Int>> = Stack()\n    loop@while (true){\n        val event = persons.mapNotNull { it.nextSchedule as? Event.SomeEvent }.min()\n        when (event) {\n            is Event.SomeEvent.PostMail -> {\n                //println(\"time = ${event.time}, posted = ${event.mail.label}\")\n                event.office.postMail(event.time, event.mail)\n                event.poster.receivedMail()\n            }\n            is Event.SomeEvent.DeliverMails -> {\n                //println(\"time = ${event.time}, officer = ${event.officer.id}, deliver = ${event.mailsToDestination.joinToString(\",\") { it.label }}, ${event.mailsToRelay.joinToString(\",\") { it.label }}, office = ${event.next.id}\")\n                result.addAll(event.mailsToDestination.map { Pair(it.label, event.time) })\n                event.next.addMails(event.time, event.mailsToRelay)\n                event.officer.addJobToReturn(event.time)\n            }\n            is Event.SomeEvent.ReturnToOffice -> {\n                //println(\"time = ${event.time}, officer = ${event.officer.id} return\")\n                event.officer.findNewJob(event.time)\n            }\n            null -> break@loop\n        }\n    }\n    println(\n            result.sortedWith(compareBy(Pair<String, Int>::second, Pair<String,Int>::first)).joinToString(\"\\n\") { \"${it.first} ${it.second}\" }\n    )\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import javafx.geometry.Pos\nimport java.util.*\nimport javax.lang.model.type.NoType\n\nfun setRoute(officeCount:Int, routeInfo:Array<Triple<Int, Int, Int>>):Array<PostOffice> {\n    val routes = Array(officeCount){Array(officeCount){\n        Route(Int.MAX_VALUE)\n    }}\n    val office = Array(officeCount){PostOffice(it, routes[it])}\n    routeInfo.forEach {(from, to, distance) ->\n        routes[from - 1][to - 1] = Route(distance, office[to - 1])\n        routes[to - 1][from - 1] = Route(distance, office[from - 1])\n    }\n    for (mid in 0 until officeCount) for (from in 0 until officeCount) for (to in 0 until officeCount){\n        if (routes[from][mid].minCost < routes[from][to].minCost - routes[mid][to].minCost){\n            routes[from][to] = Route(routes[from][mid].minCost + routes[mid][to].minCost, routes[from][mid].next)\n            routes[to][from] = Route(routes[from][mid].minCost + routes[mid][to].minCost, routes[to][mid].next)\n        }\n    }\n    return office\n}\nfun main(args:Array<String>):Unit{\n    var isNotFirst = false\n    while(true){\n        val (n, m) = readLine()!!.split(' ').map(String::toInt)\n        if (n == 0 && m == 0) return\n        val offices = setRoute(n, Array(m){\n            val (f, t, d) = readLine()!!.split(' ').map(String::toInt)\n            Triple(f, t, d)\n        })\n        val civilian:Civilian = Civilian()\n        repeat(readLine()!!.toInt()){\n            val arg = readLine()!!.split(' ')\n            val (from, to, time) = arg.take(3).map(String::toInt)\n            civilian.addPostSchedule(time, Mail(offices[to - 1], arg.last()), offices[from - 1])\n        }\n        if (isNotFirst) println()\n        isNotFirst = true\n        loopEvent(offices.map{it.officer} + civilian)\n    }\n}\ntypealias Mails = Collection<Mail>\ninterface Person{\n    val nextSchedule:Event\n}\nclass Officer(private val mOffice: PostOffice):Person{\n    val id:Int = mOffice.id\n    override var nextSchedule: Event = Event.NoEvent\n        private set\n    private var currentRelationalPosition:Int = 0\n    fun addJobToReturn(currentTime:Int):Unit {\n        nextSchedule = Event.SomeEvent.ReturnToOffice(currentTime + currentRelationalPosition, this)\n    }\n    fun findNewJob(currentTime:Int):Unit {\n        nextSchedule = Event.NoEvent\n        mOffice.returnOfficer(currentTime)\n    }\n    fun addJobToDeliverMails(currentTime:Int, distance:Int, mails: Mails, deliverAt:PostOffice):Unit {\n        nextSchedule = Event.SomeEvent.DeliverMails(currentTime + distance, this, mails, deliverAt)\n        currentRelationalPosition = distance\n    }\n}\nclass Civilian:Person{\n    private val mSchedules:Deque<Event.SomeEvent.PostMail> = LinkedList()\n    override val nextSchedule: Event\n        get() = mSchedules.firstOrNull() ?: Event.NoEvent\n    fun addPostSchedule(time:Int, mail:Mail, postAt:PostOffice):Unit {\n        mSchedules.addLast(Event.SomeEvent.PostMail(time, mail, postAt, this))\n    }\n    fun receivedMail():Unit {\n        mSchedules.removeFirst()\n    }\n}\nclass PostOffice(val id:Int, private val route:Array<Route>){\n    val officer:Officer = Officer(this)\n    private val mMail:Array<Stack<Mail>> = Array(route.size){Stack<Mail>()}\n    fun postMail(currentTime:Int, mail:Mail):Unit {\n        mMail[route[mail.destination.id].next.id].push(mail)\n        instructNewJob(currentTime)\n    }\n    fun addMails(currentTime:Int, mails:Mails):Unit {\n        mails.forEach {\n            mMail[route[it.destination.id].next.id].push(it)\n        }\n        instructNewJob(currentTime)\n    }\n    fun returnOfficer(currentTime:Int):Unit {\n        instructNewJob(currentTime)\n    }\n    private fun instructNewJob(currentTime:Int):Unit {\n        when(officer.nextSchedule){\n            is Event.NoEvent -> {\n                val mails = mMail.indexOfFirst{it.isNotEmpty()}\n                when(mails){\n                    -1 -> return\n                    else -> {\n                        officer.addJobToDeliverMails(currentTime, route[mails].minCost, mMail[mails], route[mails].next)\n                        mMail[mails].clear()\n                    }\n                }\n            }\n            else -> return\n        }\n    }\n}\n\nclass Route(val minCost:Int, private var mNext:PostOffice? = null){\n    var next:PostOffice\n        get() = mNext!!\n        set(value){\n            mNext = value\n        }\n}\nclass Mail(val destination:PostOffice, val label:String)\nsealed class Event {\n    object NoEvent : Event()\n    sealed class SomeEvent(val time: Int) : Event(), Comparable<SomeEvent> {\n        protected abstract fun compareToWithType(other: SomeEvent): Int\n        override fun compareTo(other: SomeEvent): Int {\n            return when (time) {\n                other.time -> compareToWithType(other)\n                else -> time.compareTo(other.time)\n            }\n        }\n\n        class PostMail(time: Int, val mail: Mail, val office: PostOffice, val poster: Civilian) : SomeEvent(time) {\n            override fun compareToWithType(other: SomeEvent): Int {\n                return when (other) {\n                    is PostMail -> 0\n                    else -> -1\n                }\n            }\n        }\n\n        class DeliverMails(time: Int, val officer: Officer, mails: Mails, val next: PostOffice) : SomeEvent(time) {\n            override fun compareToWithType(other: SomeEvent): Int {\n                return when (other) {\n                    is PostMail -> 1\n                    else -> 0\n                }\n            }\n\n            val mailsToDestination: Mails = mails.filter { it.destination == next }\n            val mailsToRelay: Mails = mails.filterNot { it.destination == next }\n        }\n\n        class ReturnToOffice(time: Int, val officer: Officer) : SomeEvent(time) {\n            override fun compareToWithType(other: SomeEvent): Int {\n                return when (other) {\n                    is PostMail -> 1\n                    else -> 0\n                }\n            }\n        }\n    }\n}\nfun loopEvent(persons:Collection<Person>):Unit {\n    val result: Stack<Pair<String, Int>> = Stack()\n    loop@while (true){\n        val event = persons.mapNotNull { it.nextSchedule as? Event.SomeEvent }.min()\n        when (event) {\n            is Event.SomeEvent.PostMail -> {\n                //println(\"time = ${event.time}, posted = ${event.mail.label}\")\n                event.office.postMail(event.time, event.mail)\n                event.poster.receivedMail()\n            }\n            is Event.SomeEvent.DeliverMails -> {\n                //println(\"time = ${event.time}, officer = ${event.officer.id}, deliver = ${event.mailsToDestination.joinToString(\",\") { it.label }}, ${event.mailsToRelay.joinToString(\",\") { it.label }}, office = ${event.next.id}\")\n                result.addAll(event.mailsToDestination.map { Pair(it.label, event.time) })\n                event.next.addMails(event.time, event.mailsToRelay)\n                event.officer.addJobToReturn(event.time)\n            }\n            is Event.SomeEvent.ReturnToOffice -> {\n                //println(\"time = ${event.time}, officer = ${event.officer.id} return\")\n                event.officer.findNewJob(event.time)\n            }\n            null -> break@loop\n        }\n    }\n    println(\n            result.sortedWith(compareBy(Pair<String, Int>::second, Pair<String,Int>::first)).joinToString(\"\\n\") { \"${it.first} ${it.second}\" }\n    )\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "\nimport java.util.*\n\nfun setRoute(officeCount:Int, routeInfo:Array<Triple<Int, Int, Int>>):Array<PostOffice> {\n    val routes = Array(officeCount){Array(officeCount){\n        Route(Int.MAX_VALUE)\n    }}\n    val office = Array(officeCount){PostOffice(it, routes[it])}\n    routeInfo.forEach {(from, to, distance) ->\n        routes[from - 1][to - 1] = Route(distance, office[to - 1])\n        routes[to - 1][from - 1] = Route(distance, office[from - 1])\n    }\n    for (mid in 0 until officeCount) for (from in 0 until officeCount) for (to in 0 until officeCount){\n        if (routes[from][mid].minCost < routes[from][to].minCost - routes[mid][to].minCost){\n            routes[from][to] = Route(routes[from][mid].minCost + routes[mid][to].minCost, routes[from][mid].next)\n            routes[to][from] = Route(routes[from][mid].minCost + routes[mid][to].minCost, routes[to][mid].next)\n        }\n    }\n    return office\n}\nfun main(args:Array<String>):Unit{\n    var isNotFirst = false\n    while(true){\n        val (n, m) = readLine()!!.split(' ').map(String::toInt)\n        if (n == 0 && m == 0) return\n        val offices = setRoute(n, Array(m){\n            val (f, t, d) = readLine()!!.split(' ').map(String::toInt)\n            Triple(f, t, d)\n        })\n        val civilian:Civilian = Civilian()\n        repeat(readLine()!!.toInt()){\n            val arg = readLine()!!.split(' ')\n            val (from, to, time) = arg.take(3).map(String::toInt)\n            civilian.addPostSchedule(time, Mail(offices[to - 1], arg.last()), offices[from - 1])\n        }\n        if (isNotFirst) println()\n        isNotFirst = true\n        loopEvent(offices.map{it.officer} + civilian)\n    }\n}\ntypealias Mails = Collection<Mail>\ninterface Person{\n    val nextSchedule:Event\n}\nclass Officer(private val mOffice: PostOffice):Person{\n    val id:Int = mOffice.id\n    override var nextSchedule: Event = Event.NoEvent\n        private set\n    private var currentRelationalPosition:Int = 0\n    fun addJobToReturn(currentTime:Int):Unit {\n        nextSchedule = Event.SomeEvent.ReturnToOffice(currentTime + currentRelationalPosition, this)\n    }\n    fun findNewJob(currentTime:Int):Unit {\n        nextSchedule = Event.NoEvent\n        mOffice.returnOfficer(currentTime)\n    }\n    fun addJobToDeliverMails(currentTime:Int, distance:Int, mails: Mails, deliverAt:PostOffice):Unit {\n        nextSchedule = Event.SomeEvent.DeliverMails(currentTime + distance, this, mails, deliverAt)\n        currentRelationalPosition = distance\n    }\n}\nclass Civilian:Person{\n    private val mSchedules:Deque<Event.SomeEvent.PostMail> = LinkedList()\n    override val nextSchedule: Event\n        get() = mSchedules.firstOrNull() ?: Event.NoEvent\n    fun addPostSchedule(time:Int, mail:Mail, postAt:PostOffice):Unit {\n        mSchedules.addLast(Event.SomeEvent.PostMail(time, mail, postAt, this))\n    }\n    fun receivedMail():Unit {\n        mSchedules.removeFirst()\n    }\n}\nclass PostOffice(val id:Int, private val route:Array<Route>){\n    val officer:Officer = Officer(this)\n    private val mMail:Array<Stack<Mail>> = Array(route.size){Stack<Mail>()}\n    fun postMail(currentTime:Int, mail:Mail):Unit {\n        mMail[route[mail.destination.id].next.id].push(mail)\n        instructNewJob(currentTime)\n    }\n    fun addMails(currentTime:Int, mails:Mails):Unit {\n        mails.forEach {\n            mMail[route[it.destination.id].next.id].push(it)\n        }\n        instructNewJob(currentTime)\n    }\n    fun returnOfficer(currentTime:Int):Unit {\n        instructNewJob(currentTime)\n    }\n    private fun instructNewJob(currentTime:Int):Unit {\n        when(officer.nextSchedule){\n            is Event.NoEvent -> {\n                val mails = mMail.indexOfFirst{it.isNotEmpty()}\n                when(mails){\n                    -1 -> return\n                    else -> {\n                        officer.addJobToDeliverMails(currentTime, route[mails].minCost, mMail[mails], route[mails].next)\n                        mMail[mails].clear()\n                    }\n                }\n            }\n            else -> return\n        }\n    }\n}\n\nclass Route(val minCost:Int, private var mNext:PostOffice? = null){\n    var next:PostOffice\n        get() = mNext!!\n        set(value){\n            mNext = value\n        }\n}\nclass Mail(val destination:PostOffice, val label:String)\nsealed class Event {\n    object NoEvent : Event()\n    sealed class SomeEvent(val time: Int) : Event(), Comparable<SomeEvent> {\n        protected abstract fun compareToWithType(other: SomeEvent): Int\n        override fun compareTo(other: SomeEvent): Int {\n            return when (time) {\n                other.time -> compareToWithType(other)\n                else -> time.compareTo(other.time)\n            }\n        }\n\n        class PostMail(time: Int, val mail: Mail, val office: PostOffice, val poster: Civilian) : SomeEvent(time) {\n            override fun compareToWithType(other: SomeEvent): Int {\n                return when (other) {\n                    is PostMail -> 0\n                    else -> -1\n                }\n            }\n        }\n\n        class DeliverMails(time: Int, val officer: Officer, mails: Mails, val next: PostOffice) : SomeEvent(time) {\n            override fun compareToWithType(other: SomeEvent): Int {\n                return when (other) {\n                    is PostMail -> 1\n                    else -> 0\n                }\n            }\n\n            val mailsToDestination: Mails = mails.filter { it.destination == next }\n            val mailsToRelay: Mails = mails.filterNot { it.destination == next }\n        }\n\n        class ReturnToOffice(time: Int, val officer: Officer) : SomeEvent(time) {\n            override fun compareToWithType(other: SomeEvent): Int {\n                return when (other) {\n                    is PostMail -> 1\n                    else -> 0\n                }\n            }\n        }\n    }\n}\nfun loopEvent(persons:Collection<Person>):Unit {\n    val result: Stack<Pair<String, Int>> = Stack()\n    loop@while (true){\n        val event = persons.mapNotNull { it.nextSchedule as? Event.SomeEvent }.min()\n        when (event) {\n            is Event.SomeEvent.PostMail -> {\n                //println(\"time = ${event.time}, posted = ${event.mail.label}\")\n                event.office.postMail(event.time, event.mail)\n                event.poster.receivedMail()\n            }\n            is Event.SomeEvent.DeliverMails -> {\n                //println(\"time = ${event.time}, officer = ${event.officer.id}, deliver = ${event.mailsToDestination.joinToString(\",\") { it.label }}, ${event.mailsToRelay.joinToString(\",\") { it.label }}, office = ${event.next.id}\")\n                result.addAll(event.mailsToDestination.map { Pair(it.label, event.time) })\n                event.next.addMails(event.time, event.mailsToRelay)\n                event.officer.addJobToReturn(event.time)\n            }\n            is Event.SomeEvent.ReturnToOffice -> {\n                //println(\"time = ${event.time}, officer = ${event.officer.id} return\")\n                event.officer.findNewJob(event.time)\n            }\n            null -> break@loop\n        }\n    }\n    println(\n            result.sortedWith(compareBy(Pair<String, Int>::second, Pair<String,Int>::first)).joinToString(\"\\n\") { \"${it.first} ${it.second}\" }\n    )\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Poor Mail Forwarding\npublic class Main{\n\n\tfinal int SEND = 0, BACK = 1, INFORM = 2;\n\tint INF = 1<<29;\n\tint[][] e, next;\n\tboolean[] exist;\n\tint[] from, to;\n\tString[] letter;\n\tLinkedList<P>[] post;\n\t\n\tclass T{\n\t\tint from;\n\t\tList<Integer> list;\n\t\tpublic T(int from) {\n\t\t\tthis.from = from;\n\t\t\tlist = new ArrayList<Integer>();\n\t\t}\n\t}\n\tclass P implements Comparable<P>{\n\t\tint at, id, t;\n\t\tpublic P(int at, int id, int t) {\n\t\t\tthis.at = at;\n\t\t\tthis.id = id;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\treturn t!=o.t?t-o.t:next[at][to[id]]-next[at][to[o.id]];\n\t\t}\n\t}\n\tclass E implements Comparable<E>{\n\t\tint type, data, t;\n\t\tT con;\n\t\tpublic E(int type, int data, int t, T c) {\n\t\t\tthis.type = type;\n\t\t\tthis.data = data;\n\t\t\tthis.t = t;\n\t\t\tcon = c;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn t!=o.t?t-o.t:type-o.type;\n\t\t}\n\t}\n\tclass R implements Comparable<R>{\n\t\tString s;\n\t\tint t;\n\t\tpublic R(String s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn t!=o.t?t-o.t:s.compareTo(o.s);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tboolean head = true;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tif(!head)System.out.println();\n\t\t\thead = false;\n\t\t\te = new int[n][n];\n\t\t\tint[][] adj = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:adj)Arrays.fill(a, INF);\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, d = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = d;\n\t\t\t\tadj[s][t] = adj[t][s] = d;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)e[i][i]=0;\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)e[i][j]=Math.min(e[i][j], e[i][k]+e[k][j]);\n\t\t\tnext = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\tif(i==j||e[i][j]==INF)continue;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(i==k||adj[i][k]==INF)continue;\n\t\t\t\t\tif(e[i][j]==adj[i][k]+e[k][j]){\n\t\t\t\t\t\tnext[i][j] = k; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<R> res = new PriorityQueue<R>();\n\t\t\texist = new boolean[n];\n\t\t\tArrays.fill(exist, true);\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\t\t\tint L = sc.nextInt();\n\t\t\tfrom = new int[L]; to = new int[L]; letter = new String[L];\n\t\t\tpost = new LinkedList[n];\n\t\t\tfor(int i=0;i<n;i++)post[i] = new LinkedList<P>();\n\t\t\tfor(int i=0;i<L;i++){\n\t\t\t\tfrom[i] = sc.nextInt()-1; to[i] = sc.nextInt()-1;\n\t\t\t\tint time = sc.nextInt();\n\t\t\t\tletter[i] = sc.next();\n\t\t\t\tpost[from[i]].add(new P(from[i], i, time));\n\t\t\t\tq.add(new E(INFORM, from[i], time, null));\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tE event = q.poll();\n\t\t\t\tint pos = event.data;\n\t\t\t\tif(event.type==BACK){\n\t\t\t\t\tif(post[pos].isEmpty()){\n\t\t\t\t\t\texist[pos] = true; continue;\n\t\t\t\t\t}\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tif(event.t<post[pos].peek().t){\n\t\t\t\t\t\texist[pos] = true; continue;\n\t\t\t\t\t}\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(event.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==INFORM){\n\t\t\t\t\tif(!exist[pos])continue;\n\t\t\t\t\tif(post[pos].isEmpty())continue;\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tif(event.t<post[pos].peek().t)continue;\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(event.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==SEND){\n\t\t\t\t\tT t = event.con;\n\t\t\t\t\tq.add(new E(BACK, t.from, event.t+e[pos][t.from], null));\n\t\t\t\t\tboolean offer = false;\n\t\t\t\t\tfor(int id:t.list){\n\t\t\t\t\t\tif(pos==to[id]){\n\t\t\t\t\t\t\tres.add(new R(letter[id], event.t)); continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!offer)q.add(new E(INFORM, pos, event.t, null));\n\t\t\t\t\t\toffer = true;\n\t\t\t\t\t\tpost[pos].add(new P(pos, id, event.t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!res.isEmpty()){\n\t\t\t\tR r = res.poll();\n\t\t\t\tSystem.out.println(r.s+\" \"+r.t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Poor Mail Forwarding\npublic class Main{\n\n\tfinal int SEND = 0, BACK = 1, INFORM = 2;\n\tint INF = 1<<29;\n\tint[][] e, next;\n\tboolean[] exist;\n\tint[] from, to;\n\tString[] letter;\n\tLinkedList<P>[] post;\n\t\n\tclass T{\n\t\tint from;\n\t\tList<Integer> list;\n\t\tpublic T(int from) {\n\t\t\tthis.from = from;\n\t\t\tlist = new ArrayList<Integer>();\n\t\t}\n\t}\n\tclass P implements Comparable<P>{\n\t\tint at, id, t;\n\t\tpublic P(int at, int id, int t) {\n\t\t\tthis.at = at;\n\t\t\tthis.id = id;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\treturn t!=o.t?t-o.t:next[at][to[id]]-next[at][to[o.id]];\n\t\t}\n\t}\n\tclass E implements Comparable<E>{\n\t\tint type, data, t;\n\t\tT con;\n\t\tpublic E(int type, int data, int t, T c) {\n\t\t\tthis.type = type;\n\t\t\tthis.data = data;\n\t\t\tthis.t = t;\n\t\t\tcon = c;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn t!=o.t?t-o.t:type-o.type;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tr+=type==BACK?\"BACK\":type==SEND?\"SEND\":\"INFORM\";\n\t\t\tr+=\" at:\"+data+\" time:\"+t;\n\t\t\treturn r;\n\t\t}\n\t}\n\tclass R implements Comparable<R>{\n\t\tString s;\n\t\tint t;\n\t\tpublic R(String s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn t!=o.t?t-o.t:s.compareTo(o.s);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tboolean head = true;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tif(!head)System.out.println();\n\t\t\thead = false;\n\t\t\te = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, d = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = d;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)e[i][i]=0;\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)e[i][j]=Math.min(e[i][j], e[i][k]+e[k][j]);\n\t\t\tnext = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\tif(i==j||e[i][j]==INF)continue;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(i==k)continue;\n\t\t\t\t\tif(e[i][j]==e[i][k]+e[k][j]){\n\t\t\t\t\t\tnext[i][j] = k; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<R> res = new PriorityQueue<R>();\n\t\t\texist = new boolean[n];\n\t\t\tArrays.fill(exist, true);\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\t\t\tint L = sc.nextInt();\n\t\t\tfrom = new int[L]; to = new int[L]; letter = new String[L];\n\t\t\tpost = new LinkedList[n];\n\t\t\tfor(int i=0;i<n;i++)post[i] = new LinkedList<P>();\n\t\t\tfor(int i=0;i<L;i++){\n\t\t\t\tfrom[i] = sc.nextInt()-1; to[i] = sc.nextInt()-1;\n\t\t\t\tint time = sc.nextInt();\n\t\t\t\tletter[i] = sc.next();\n\t\t\t\tpost[from[i]].add(new P(from[i], i, time));\n\t\t\t\tq.add(new E(INFORM, from[i], time, null));\n\t\t\t}\n//\t\t\tdebug(from); debug(to);\n//\t\t\tdebug(e); debug(next);\n//\t\t\twhile(!q.isEmpty()){\n//\t\t\t\tSystem.out.println(q.poll());\n//\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tE event = q.poll();\n//\t\t\t\tSystem.out.println(event);\n\t\t\t\tint pos = event.data;\n\t\t\t\tif(event.type==BACK){\n\t\t\t\t\tif(post[pos].isEmpty()){\n\t\t\t\t\t\texist[pos] = true; continue;\n\t\t\t\t\t}\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(p.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==INFORM){\n\t\t\t\t\tif(!exist[pos])continue;\n\t\t\t\t\tif(post[pos].isEmpty())continue;\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(p.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==SEND){\n\t\t\t\t\tT t = event.con;\n\t\t\t\t\tq.add(new E(BACK, t.from, event.t+e[pos][t.from], null));\n\t\t\t\t\tboolean offer = false;\n\t\t\t\t\tfor(int id:t.list){\n\t\t\t\t\t\tif(pos==to[id]){\n\t\t\t\t\t\t\tres.add(new R(letter[id], event.t)); continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!offer)q.add(new E(INFORM, pos, event.t, null));\n\t\t\t\t\t\toffer = true;\n\t\t\t\t\t\tpost[pos].add(new P(pos, id, event.t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!res.isEmpty()){\n\t\t\t\tR r = res.poll();\n\t\t\t\tSystem.out.println(r.s+\" \"+r.t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t//Scanner scan = new Scanner(new File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\2010-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\tMap mp = new Map(n, m);\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t\tmp.addRoot(scan.nextInt(), scan.nextInt(), scan.nextInt());\n\t\t\tint l = scan.nextInt();\n\t\t\tmp.ml(l);\n\t\t\tfor (int i = 0; i < l; i++)\n\t\t\t\tmp.addMail(i, scan.nextInt(), scan.nextInt(), scan.nextInt(), scan.next());\n\t\t\tmp.process();\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Map {\n\tclass Evt {\n\t\tpublic Evt(int tm, int fr) {\n\t\t\ttime = tm;\n\t\t\tpof = fr;\n\t\t}\n\n\t\tint time;\n\t\tint pof;\n\t}\n\n\tclass EvTime implements Comparator<Evt> {\n\n\t\t@Override\n\t\tpublic int compare(Evt o1, Evt o2) {\n\t\t\tif (o1.time > o2.time)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.time == o2.time)\n\t\t\t\tif (o1.pof > o2.pof)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (o1.pof == o2.pof)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tPriorityQueue<Evt> evt = new PriorityQueue<Evt>(100, new EvTime());\n\n\tint N;\n\tint[] delv;\n\tint[][] dist;\n\tint[][] next;\n\n\tclass Mail {\n\t\tpublic Mail(int tm, String lb) {\n\t\t\tarrive = tm;\n\t\t\tlab=new String(lb);\n\t\t}\n\n\t\tint arrive;\n\t\tString lab;\n\t}\n\n\tList<Mail> mail = new ArrayList<Mail>();\n\tint[] p_fr;\n\tint[] p_to;\n\tint[] p_nx;\n\tint[] time;\n\tString[] label;\n\n\tpublic Map(int n, int m) {\n\t\tN = n;\n\t\tdelv = new int[n + 1];\n\t\tdist = new int[n + 1][n + 1];\n\t\tnext = new int[n + 1][n + 1];\n\n\t}\n\n\tpublic void ml(int l) {\n\t\tp_fr = new int[l];\n\t\tp_to = new int[l];\n\t\tp_nx = new int[l];\n\t\ttime = new int[l];\n\t\tlabel = new String[l];\t\t\n\t}\n\n\tpublic void process() {\n\t\tEvt e;\n\t\twhile ((e = evt.poll()) != null) {\n\t\t\tif (delv[e.pof] > e.time)\n\t\t\t\tcontinue;\n\t\t\tint minTo = Integer.MAX_VALUE;\n\t\t\tint minTm = Integer.MAX_VALUE;\n\t\t\tint mail = 0;\n\t\t\tfor (int i = 0; i < p_fr.length; i++)\n\t\t\t\tif (p_fr[i] == e.pof && (time[i] < minTm || (time[i] == minTm) && p_nx[i] < minTo)) {\n\t\t\t\t\tminTo = p_nx[i];\n\t\t\t\t\tminTm = time[i];\n\t\t\t\t\tmail = i;\n\t\t\t\t}\n\n\t\t\tif (minTm != Integer.MAX_VALUE)\n\t\t\t\tthis.deriver(mail, e.time);\n\n\t\t\tfor (int i = 0; i < p_fr.length; i++)\n\t\t\t\tif (i != mail && p_fr[i] == e.pof && p_nx[i] == minTo && time[i] <= e.time)\n\t\t\t\t\tthis.deriver(i, e.time);\n\t\t}\n\n\t\tthis.printMail();\n\n\t}\n\n\tclass mailSort implements Comparator<Mail> {\n\n\t\t@Override\n\t\tpublic int compare(Mail o1, Mail o2) {\n\t\t\tif (o1.arrive > o2.arrive)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.arrive == o2.arrive)\n\t\t\t\tif (o1.lab.compareTo(o2.lab) > 0)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (o1.lab.compareTo(o2.lab) == 0)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t}\n\n\tprivate void printMail() {\n\t\t// for (int i = 0; i < p_fr.length; i++) {\n\t\tfor (int i = 0; i < p_fr.length; i++) {\n\t\t\tmail.add(new Mail(time[i], label[i]));\n\t\t}\n\t\tCollections.sort(mail, new mailSort());\n\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\tSystem.out.println(mail.get(i).lab + \" \" + mail.get(i).arrive);\n\n\t}\n\n\tprivate void deriver(int m, int tm) {\n\t\tif (p_nx[m] == p_fr[m]) {\n\t\t\t// System.out.println(label[m] + \" \" + time[m]);\n\t\t\tp_fr[m] = -1;\n\t\t\treturn;\n\t\t}\n\t\tdelv[p_fr[m]] = tm + (dist[p_fr[m]][p_nx[m]] * 2);\n\t\tevt.add(new Evt(delv[p_fr[m]], p_fr[m]));\n\n\t\ttime[m] = tm + dist[p_fr[m]][p_nx[m]];\n\t\tp_fr[m] = p_nx[m];\n\t\tp_nx[m] = this.getNext(p_fr[m], p_to[m]);\n\t\tevt.add(new Evt(time[m], p_fr[m]));\n\n\t}\n\n\tpublic void addMail(int id, int fr, int to, int tm, String lab) {\n\t\tp_fr[id] = fr;\n\t\tp_to[id] = to;\n\t\ttime[id] = tm;\n\t\tlabel[id] = lab.substring(0);\n\n\t\tp_nx[id] = this.getNext(fr, to);\n\t\t// System.out.println(\"send to - \" + p_nx[id]);\n\t\tevt.add(new Evt(tm, fr));\n\t}\n\n\tprivate int getNext(int fr, int to) {\n\t\tif (fr == to)\n\t\t\treturn to;\n\t\tif (next[fr][to] > 0)\n\t\t\treturn next[fr][to];\n\n\t\tint min = Integer.MAX_VALUE;\n\t\tint nx = 0;\n\t\tfor (int i = 1; i < next.length; i++) {\n\t\t\tint[] r = new int[dist.length];\n\t\t\tif (dist[fr][i] > 0) {\n\t\t\t\tint d = this.leastDist(fr, to, i, r);\n\t\t\t\tif (d < min) {\n\t\t\t\t\tmin = d;\n\t\t\t\t\tnx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnext[fr][to] = nx;\n\t\treturn nx;\n\t}\n\n\tprivate int leastDist(int fr, int to, int nx, int[] r) {\n\t\tif (fr == to)\n\t\t\treturn 0;\n\t\tif (nx == to)\n\t\t\treturn dist[fr][nx];\n\t\tr[fr] = -1;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 1; i < dist.length; i++)\n\t\t\tif (dist[nx][i] > 0 && r[i] == 0) {\n\t\t\t\tint d = leastDist(nx, to, i, r);\n\t\t\t\tif (d > 0 && d + dist[fr][nx] < min)\n\t\t\t\t\tmin = d + dist[fr][nx];\n\t\t\t}\n\t\tr[fr] = 0;\n\t\tif (min == Integer.MAX_VALUE)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn min;\n\t}\n\n\tpublic void addRoot(int fr, int to, int ds) {\n\t\tdist[fr][to] = ds;\n\t\tdist[to][fr] = ds;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Poor Mail Forwarding\npublic class Main{\n\n\tfinal int SEND = 0, BACK = 1, INFORM = 2;\n\tint INF = 1<<29;\n\tint[][] e, next;\n\tboolean[] exist;\n\tint[] from, to;\n\tString[] letter;\n\tLinkedList<P>[] post;\n\t\n\tclass T{\n\t\tint from;\n\t\tList<Integer> list;\n\t\tpublic T(int from) {\n\t\t\tthis.from = from;\n\t\t\tlist = new ArrayList<Integer>();\n\t\t}\n\t}\n\tclass P implements Comparable<P>{\n\t\tint at, id, t;\n\t\tpublic P(int at, int id, int t) {\n\t\t\tthis.at = at;\n\t\t\tthis.id = id;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\treturn t!=o.t?t-o.t:next[at][to[id]]-next[at][to[o.id]];\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tr+=\"Pos:\"+at+\" Letter id:\"+id+\" Time:\"+t;\n\t\t\treturn r;\n\t\t}\n\t}\n\tclass E implements Comparable<E>{\n\t\tint type, data, t;\n\t\tT con;\n\t\tpublic E(int type, int data, int t, T c) {\n\t\t\tthis.type = type;\n\t\t\tthis.data = data;\n\t\t\tthis.t = t;\n\t\t\tcon = c;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn t!=o.t?t-o.t:type-o.type;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tr+=type==BACK?\"BACK\":type==SEND?\"SEND\":\"INFORM\";\n\t\t\tr+=\" at:\"+data+\" time:\"+t;\n\t\t\treturn r;\n\t\t}\n\t}\n\tclass R implements Comparable<R>{\n\t\tString s;\n\t\tint t;\n\t\tpublic R(String s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn t!=o.t?t-o.t:s.compareTo(o.s);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tboolean head = true;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tif(!head)System.out.println();\n\t\t\thead = false;\n\t\t\te = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, d = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = d;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)e[i][i]=0;\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)e[i][j]=Math.min(e[i][j], e[i][k]+e[k][j]);\n\t\t\tnext = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\tif(i==j||e[i][j]==INF)continue;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(i==k)continue;\n\t\t\t\t\tif(e[i][j]==e[i][k]+e[k][j]){\n\t\t\t\t\t\tnext[i][j] = k; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<R> res = new PriorityQueue<R>();\n\t\t\texist = new boolean[n];\n\t\t\tArrays.fill(exist, true);\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\t\t\tint L = sc.nextInt();\n\t\t\tfrom = new int[L]; to = new int[L]; letter = new String[L];\n\t\t\tpost = new LinkedList[n];\n\t\t\tfor(int i=0;i<n;i++)post[i] = new LinkedList<P>();\n\t\t\tfor(int i=0;i<L;i++){\n\t\t\t\tfrom[i] = sc.nextInt()-1; to[i] = sc.nextInt()-1;\n\t\t\t\tint time = sc.nextInt();\n\t\t\t\tletter[i] = sc.next();\n\t\t\t\tpost[from[i]].add(new P(from[i], i, time));\n\t\t\t\tq.add(new E(INFORM, from[i], time, null));\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tE event = q.poll();\n//\t\t\t\tSystem.out.println(event);\n//\t\t\t\tSystem.out.println(post[1]);\n\t\t\t\tint pos = event.data;\n\t\t\t\tif(event.type==BACK){\n\t\t\t\t\tif(post[pos].isEmpty()){\n\t\t\t\t\t\texist[pos] = true; continue;\n\t\t\t\t\t}\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tif(event.t<post[pos].peek().t){\n\t\t\t\t\t\texist[pos] = true; continue;\n\t\t\t\t\t}\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(event.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==INFORM){\n\t\t\t\t\tif(!exist[pos])continue;\n\t\t\t\t\tif(post[pos].isEmpty())continue;\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tif(event.t<post[pos].peek().t)continue;\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(event.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==SEND){\n\t\t\t\t\tT t = event.con;\n\t\t\t\t\tq.add(new E(BACK, t.from, event.t+e[pos][t.from], null));\n\t\t\t\t\tboolean offer = false;\n\t\t\t\t\tfor(int id:t.list){\n\t\t\t\t\t\tif(pos==to[id]){\n\t\t\t\t\t\t\tres.add(new R(letter[id], event.t)); continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!offer)q.add(new E(INFORM, pos, event.t, null));\n\t\t\t\t\t\toffer = true;\n\t\t\t\t\t\tpost[pos].add(new P(pos, id, event.t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!res.isEmpty()){\n\t\t\t\tR r = res.poll();\n\t\t\t\tSystem.out.println(r.s+\" \"+r.t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Poor Mail Forwarding\npublic class Main{\n\n\tfinal int SEND = 0, BACK = 1, INFORM = 2;\n\tint INF = 1<<29;\n\tint[][] e, next;\n\tboolean[] exist;\n\tint[] from, to;\n\tString[] letter;\n\tLinkedList<P>[] post;\n\t\n\tclass T{\n\t\tint from;\n\t\tList<Integer> list;\n\t\tpublic T(int from) {\n\t\t\tthis.from = from;\n\t\t\tlist = new ArrayList<Integer>();\n\t\t}\n\t}\n\tclass P implements Comparable<P>{\n\t\tint at, id, t;\n\t\tpublic P(int at, int id, int t) {\n\t\t\tthis.at = at;\n\t\t\tthis.id = id;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\treturn t!=o.t?t-o.t:next[at][to[id]]-next[at][to[o.id]];\n\t\t}\n\t}\n\tclass E implements Comparable<E>{\n\t\tint type, data, t;\n\t\tT con;\n\t\tpublic E(int type, int data, int t, T c) {\n\t\t\tthis.type = type;\n\t\t\tthis.data = data;\n\t\t\tthis.t = t;\n\t\t\tcon = c;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn t!=o.t?t-o.t:type-o.type;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tr+=type==BACK?\"BACK\":type==SEND?\"SEND\":\"INFORM\";\n\t\t\tr+=\" at:\"+data+\" time:\"+t;\n\t\t\treturn r;\n\t\t}\n\t}\n\tclass R implements Comparable<R>{\n\t\tString s;\n\t\tint t;\n\t\tpublic R(String s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn t!=o.t?t-o.t:s.compareTo(o.s);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tboolean head = true;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tif(!head)System.out.println();\n\t\t\thead = false;\n\t\t\te = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, d = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = d;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)e[i][i]=0;\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)e[i][j]=Math.min(e[i][j], e[i][k]+e[k][j]);\n\t\t\tnext = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\tif(i==j||e[i][j]==INF)continue;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(i==k)continue;\n\t\t\t\t\tif(e[i][j]==e[i][k]+e[k][j]){\n\t\t\t\t\t\tnext[i][j] = k; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<R> res = new PriorityQueue<R>();\n\t\t\texist = new boolean[n];\n\t\t\tArrays.fill(exist, true);\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\t\t\tint L = sc.nextInt();\n\t\t\tfrom = new int[L]; to = new int[L]; letter = new String[L];\n\t\t\tpost = new LinkedList[n];\n\t\t\tfor(int i=0;i<n;i++)post[i] = new LinkedList<P>();\n\t\t\tfor(int i=0;i<L;i++){\n\t\t\t\tfrom[i] = sc.nextInt()-1; to[i] = sc.nextInt()-1;\n\t\t\t\tint time = sc.nextInt();\n\t\t\t\tletter[i] = sc.next();\n\t\t\t\tpost[from[i]].add(new P(from[i], i, time));\n\t\t\t\tq.add(new E(INFORM, from[i], time, null));\n\t\t\t}\n//\t\t\tdebug(from); debug(to);\n//\t\t\tdebug(e); debug(next);\n//\t\t\twhile(!q.isEmpty()){\n//\t\t\t\tSystem.out.println(q.poll());\n//\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tE event = q.poll();\n//\t\t\t\tSystem.out.println(event);\n\t\t\t\tint pos = event.data;\n\t\t\t\tif(event.type==BACK){\n\t\t\t\t\tif(post[pos].isEmpty()){\n\t\t\t\t\t\texist[pos] = true; continue;\n\t\t\t\t\t}\n\t\t\t\t\tif(event.t<post[pos].peek().t)continue;\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(p.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==INFORM){\n\t\t\t\t\tif(!exist[pos])continue;\n\t\t\t\t\tif(post[pos].isEmpty())continue;\n\t\t\t\t\tif(event.t<post[pos].peek().t)continue;\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(p.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==SEND){\n\t\t\t\t\tT t = event.con;\n\t\t\t\t\tq.add(new E(BACK, t.from, event.t+e[pos][t.from], null));\n\t\t\t\t\tboolean offer = false;\n\t\t\t\t\tfor(int id:t.list){\n\t\t\t\t\t\tif(pos==to[id]){\n\t\t\t\t\t\t\tres.add(new R(letter[id], event.t)); continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!offer)q.add(new E(INFORM, pos, event.t, null));\n\t\t\t\t\t\toffer = true;\n\t\t\t\t\t\tpost[pos].add(new P(pos, id, event.t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!res.isEmpty()){\n\t\t\t\tR r = res.poll();\n\t\t\t\tSystem.out.println(r.s+\" \"+r.t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\t// Scanner scan = new Scanner(System.in);\n\t\tScanner scan = new Scanner(new File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\2010-input.txt\"));\n\n\t\tboolean first = true;\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\tMap mp = new Map(n, m);\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t\tmp.addRoot(scan.nextInt(), scan.nextInt(), scan.nextInt());\n\t\t\tint l = scan.nextInt();\n\t\t\tfor (int i = 0; i < l; i++)\n\t\t\t\tmp.addMail(i, scan.nextInt(), scan.nextInt(), scan.nextInt(), scan.next());\n\t\t\tif (!first)\n\t\t\t\tSystem.out.println();\n\t\t\tfirst = false;\n\t\t\tmp.process();\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Map {\n\tclass Evt {\n\t\tpublic Evt(int tm, int fr, char r) {\n\t\t\ttime = tm;\n\t\t\tpof = fr;\n\t\t\tcd = r;\n\t\t}\n\n\t\tint time;\n\t\tint pof;\n\t\tchar cd;\n\t}\n\n\tclass EvTime implements Comparator<Evt> {\n\n\t\t@Override\n\t\tpublic int compare(Evt o1, Evt o2) {\n\t\t\tif (o1.time > o2.time)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.time == o2.time)\n\t\t\t\tif (o1.pof > o2.pof)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (o1.pof == o2.pof)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tPriorityQueue<Evt> evt = new PriorityQueue<Evt>(100, new EvTime());\n\n\tint N;\n\tint[] delv;\n\tint[][] dist;\n\tint[][] next;\n\n\tclass Mail {\n\t\tint cur;\n\t\tint next;\n\t\tint to;\n\t\tint arrive;\n\t\tString lab;\n\n\t\tpublic Mail(int _cur, int _next, int _to, int _arrive, String lb) {\n\t\t\tcur = _cur;\n\t\t\tnext = _next;\n\t\t\tto = _to;\n\t\t\tarrive = _arrive;\n\t\t\tlab = new String(lb);\n\t\t}\n\n\t\tpublic void deliver(int time) {\n\t\t\tarrive = time + dist[cur][next];\n\t\t\tdelv[cur] = time + dist[cur][next] * 2;\n\t\t\tevt.add(new Evt(delv[cur], cur, 'o'));\n\t\t\tif (next == to) {\n\t\t\t\tcur = -1;\n\t\t\t\tnext = -1;\n\t\t\t} else {\n\t\t\t\tcur = next;\n\t\t\t\tnext = getNext(next, to);\n\t\t\t\tevt.add(new Evt(arrive, cur, 'M'));\n\t\t\t}\n\t\t\t// @@@@@@@@@@@@@@@@\n\t\t\t// System.out.println(cur + \" \" + next + \" \" + to + \" \" + arrive + \"\n\t\t\t// will_arrive \" + lab);\n\t\t}\n\t}\n\n\tList<Mail> mail = new ArrayList<Mail>();\n\n\tpublic void addMail(int id, int fr, int to, int tm, String lab) {\n\t\tmail.add(new Mail(fr, this.getNext(fr, to), to, tm, lab));\n\t\tevt.add(new Evt(tm, fr, 'I'));\n\t}\n\n\tpublic Map(int n, int m) {\n\t\tN = n;\n\t\tdelv = new int[n + 1];\n\t\tdist = new int[n + 1][n + 1];\n\t\tnext = new int[n + 1][n + 1];\n\n\t}\n\n\tpublic void process() {\n\t\tEvt e;\n\t\twhile ((e = evt.poll()) != null) {\n\t\t\t// @@@@@@@@@@@@@@@@\n\t\t\t// System.out.println(\"event \" + e.time + \" \" + e.pof + \" \" + e.cd);\n\t\t\tif (delv[e.pof] > e.time)\n\t\t\t\tcontinue;\n\t\t\tint minNext = Integer.MAX_VALUE;\n\t\t\tint minTime = Integer.MAX_VALUE;\n\t\t\tint mail_ID = 0;\n\t\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\t\tif (mail.get(i).cur == e.pof && mail.get(i).arrive <= e.time && (mail.get(i).arrive < minTime\n\t\t\t\t\t\t|| (mail.get(i).arrive == minTime && mail.get(i).next < minNext))) {\n\t\t\t\t\tminNext = mail.get(i).next;\n\t\t\t\t\tminTime = mail.get(i).arrive;\n\t\t\t\t\tmail_ID = i;\n\t\t\t\t}\n\n\t\t\tif (minTime != Integer.MAX_VALUE) {\n\t\t\t\tmail.get(mail_ID).deliver(e.time);\n\n\t\t\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\t\t\tif (i != mail_ID && mail.get(i).cur == e.pof && mail.get(i).arrive <= e.time\n\t\t\t\t\t\t\t&& mail.get(i).next == minNext)\n\t\t\t\t\t\tmail.get(i).deliver(e.time);\n\t\t\t}\n\t\t}\n\n\t\tthis.printMail();\n\t}\n\n\tclass mailSort implements Comparator<Mail> {\n\n\t\t@Override\n\t\tpublic int compare(Mail o1, Mail o2) {\n\t\t\tif (o1.arrive > o2.arrive)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.arrive == o2.arrive)\n\t\t\t\tif (o1.lab.compareTo(o2.lab) > 0)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (o1.lab.compareTo(o2.lab) == 0)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tprivate void printMail() {\n\t\tCollections.sort(mail, new mailSort());\n\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\tSystem.out.println(mail.get(i).lab + \" \" + mail.get(i).arrive);\n\t}\n\n\tpublic int getNext(int fr, int to) {\n\t\tif (fr == to)\n\t\t\treturn to;\n\t\tif (next[fr][to] > 0)\n\t\t\treturn next[fr][to];\n\n\t\tint min = Integer.MAX_VALUE;\n\t\ttempdist = Integer.MAX_VALUE;\n\t\tint nx = 0;\n\t\tfor (int i = 1; i < next.length; i++) {\n\t\t\tint[] r = new int[dist.length];\n\t\t\tr[fr] = -1;\n\t\t\tif (dist[fr][i] > 0) {\n\t\t\t\tint d = this.leastDist(i, to, r, dist[fr][i]);\n\t\t\t\tif (d > 0 && d < min) {\n\t\t\t\t\tmin = d;\n\t\t\t\t\tnx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnext[fr][to] = nx;\n\t\t// @@@@@@@@@@@@@@@@@@@@@@@\n\t\t// System.out.println(fr + \" \" + to + \" by \" + nx);\n\t\treturn nx;\n\t}\n\n\tint tempdist;\n\n\tprivate int leastDist(int fr, int to, int[] r, int ps) {\n\t\tif (fr == to) {\n\t\t\tif (tempdist > ps)\n\t\t\t\ttempdist = ps;\n\t\t\treturn ps;\n\t\t}\n\t\tif (ps > tempdist)\n\t\t\treturn -1;\n\t\tr[fr] = -1;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 1; i < dist[fr].length; i++)\n\t\t\tif (dist[fr][i] > 0 && r[i] != -1) {\n\t\t\t\tint d = leastDist(i, to, r, ps + dist[fr][i]);\n\t\t\t\tif (d > 0 && d < min)\n\t\t\t\t\tmin = d;\n\t\t\t}\n\t\tr[fr] = 0;\n\t\tif (min == Integer.MAX_VALUE)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn min;\n\t}\n\n\tpublic void addRoot(int fr, int to, int ds) {\n\t\tdist[fr][to] = ds;\n\t\tdist[to][fr] = ds;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t//Scanner scan = new Scanner(new File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\2010-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\tMap mp = new Map(n, m);\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t\tmp.addRoot(scan.nextInt(), scan.nextInt(), scan.nextInt());\n\t\t\tint l = scan.nextInt();\n\t\t\tfor (int i = 0; i < l; i++)\n\t\t\t\tmp.addMail(i, scan.nextInt(), scan.nextInt(), scan.nextInt(), scan.next());\n\t\t\tmp.process();\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Map {\n\tclass Evt {\n\t\tpublic Evt(int tm, int fr, char r) {\n\t\t\ttime = tm;\n\t\t\tpof = fr;\n\t\t\tcd = r;\n\t\t}\n\n\t\tint time;\n\t\tint pof;\n\t\tchar cd;\n\t}\n\n\tclass EvTime implements Comparator<Evt> {\n\n\t\t@Override\n\t\tpublic int compare(Evt o1, Evt o2) {\n\t\t\tif (o1.time > o2.time)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.time == o2.time)\n\t\t\t\tif (o1.pof > o2.pof)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (o1.pof == o2.pof)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tPriorityQueue<Evt> evt = new PriorityQueue<Evt>(100, new EvTime());\n\n\tint N;\n\tint[] delv;\n\tint[][] dist;\n\tint[][] next;\n\n\tclass Mail {\n\t\tint cur;\n\t\tint next;\n\t\tint to;\n\t\tint arrive;\n\t\tString lab;\n\n\t\tpublic Mail(int _cur, int _next, int _to, int _arrive, String lb) {\n\t\t\tcur = _cur;\n\t\t\tnext = _next;\n\t\t\tto = _to;\n\t\t\tarrive = _arrive;\n\t\t\tlab = new String(lb);\n\t\t}\n\n\t\tpublic void deliver(int time) {\n\t\t\tarrive = time + dist[cur][next];\n\t\t\tdelv[cur] = time + dist[cur][next] * 2;\n\t\t\tevt.add(new Evt(delv[cur], cur, 'o'));\n\t\t\tif (next == to) {\n\t\t\t\tcur = -1;\n\t\t\t\tnext = -1;\n\t\t\t} else {\n\t\t\t\tcur = next;\n\t\t\t\tnext = getNext(next, to);\n\t\t\t\tevt.add(new Evt(arrive, next, 'M'));\n\t\t\t}\n\t\t}\n\t}\n\n\tList<Mail> mail = new ArrayList<Mail>();\n\n\tpublic void addMail(int id, int fr, int to, int tm, String lab) {\n\t\tmail.add(new Mail(fr, this.getNext(fr, to), to, tm, lab));\n\t\tevt.add(new Evt(tm, fr, 'M'));\n\t}\n\n\tpublic Map(int n, int m) {\n\t\tN = n;\n\t\tdelv = new int[n + 1];\n\t\tdist = new int[n + 1][n + 1];\n\t\tnext = new int[n + 1][n + 1];\n\n\t}\n\n\tpublic void process() {\n\t\tEvt e;\n\t\twhile ((e = evt.poll()) != null) {\n\t\t\t// System.out.println(\"event \" + e.time + \" \" + e.pof + \" \" + e.cd);\n\t\t\tif (delv[e.pof] > e.time)\n\t\t\t\tcontinue;\n\t\t\tint minNext = Integer.MAX_VALUE;\n\t\t\tint minTime = Integer.MAX_VALUE;\n\t\t\tint mail_ID = 0;\n\t\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\t\tif (mail.get(i).cur == e.pof && mail.get(i).arrive <= e.time && (mail.get(i).arrive < minTime\n\t\t\t\t\t\t|| (mail.get(i).arrive == minTime && mail.get(i).next < minNext))) {\n\t\t\t\t\tminNext = mail.get(i).next;\n\t\t\t\t\tminTime = mail.get(i).arrive;\n\t\t\t\t\tmail_ID = i;\n\t\t\t\t}\n\n\t\t\tif (minTime != Integer.MAX_VALUE) {\n\t\t\t\tmail.get(mail_ID).deliver(e.time);\n\n\t\t\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\t\t\tif (i != mail_ID && mail.get(i).cur == e.pof && mail.get(i).arrive <= e.time\n\t\t\t\t\t\t\t&& mail.get(i).next == minNext)\n\t\t\t\t\t\tmail.get(i).deliver(e.time);\n\t\t\t}\n\t\t}\n\n\t\tthis.printMail();\n\t}\n\n\tclass mailSort implements Comparator<Mail> {\n\n\t\t@Override\n\t\tpublic int compare(Mail o1, Mail o2) {\n\t\t\tif (o1.arrive > o2.arrive)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.arrive == o2.arrive)\n\t\t\t\tif (o1.lab.compareTo(o2.lab) > 0)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (o1.lab.compareTo(o2.lab) == 0)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tprivate void printMail() {\n\t\tCollections.sort(mail, new mailSort());\n\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\tSystem.out.println(mail.get(i).lab + \" \" + mail.get(i).arrive);\n\t\tSystem.out.println();\n\t}\n\n\tpublic int getNext(int fr, int to) {\n\t\tif (fr == to)\n\t\t\treturn to;\n\t\tif (next[fr][to] > 0)\n\t\t\treturn next[fr][to];\n\n\t\tint min = Integer.MAX_VALUE;\n\t\ttempdist = Integer.MAX_VALUE;\n\t\tint nx = 0;\n\t\tfor (int i = 1; i < next.length; i++) {\n\t\t\tint[] r = new int[dist.length];\n\t\t\tr[fr] = -1;\n\t\t\tif (dist[fr][i] > 0) {\n\t\t\t\tint d = this.leastDist(i, to, r, dist[fr][i]);\n\t\t\t\tif (d > 0 && d < min) {\n\t\t\t\t\tmin = d;\n\t\t\t\t\tnx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnext[fr][to] = nx;\n\t\treturn nx;\n\t}\n\n\tint tempdist;\n\n\tprivate int leastDist(int fr, int to, int[] r, int ps) {\n\t\tif (fr == to) {\n\t\t\ttempdist = ps;\n\t\t\treturn ps;\n\t\t}\n\t\tif (ps > tempdist)\n\t\t\treturn -1;\n\t\tr[fr] = -1;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 1; i < dist.length; i++)\n\t\t\tif (dist[fr][i] > 0 && r[i] == 0) {\n\t\t\t\tint d = leastDist(i, to, r, ps + dist[fr][i]);\n\t\t\t\tif (d > 0 && d < min)\n\t\t\t\t\tmin = d;\n\t\t\t}\n\t\tif (min == Integer.MAX_VALUE)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn min;\n\t}\n\n\tpublic void addRoot(int fr, int to, int ds) {\n\t\tdist[fr][to] = ds;\n\t\tdist[to][fr] = ds;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\2010-input.txt\"));\n\t\tboolean first = true;\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\tMap mp = new Map(n, m);\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t\tmp.addRoot(scan.nextInt(), scan.nextInt(), scan.nextInt());\n\t\t\tint l = scan.nextInt();\n\t\t\tfor (int i = 0; i < l; i++)\n\t\t\t\tmp.addMail(i, scan.nextInt(), scan.nextInt(), scan.nextInt(), scan.next());\n\t\t\tif (!first) {\n\t\t\t\tSystem.out.println();\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\tmp.process();\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Map {\n\tclass Evt {\n\t\tpublic Evt(int tm, int fr, char r) {\n\t\t\ttime = tm;\n\t\t\tpof = fr;\n\t\t\tcd = r;\n\t\t}\n\n\t\tint time;\n\t\tint pof;\n\t\tchar cd;\n\t}\n\n\tclass EvTime implements Comparator<Evt> {\n\n\t\t@Override\n\t\tpublic int compare(Evt o1, Evt o2) {\n\t\t\tif (o1.time > o2.time)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.time == o2.time)\n\t\t\t\tif (o1.pof > o2.pof)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (o1.pof == o2.pof)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tPriorityQueue<Evt> evt = new PriorityQueue<Evt>(100, new EvTime());\n\n\tint N;\n\tint[] delv;\n\tint[][] dist;\n\tint[][] next;\n\n\tclass Mail {\n\t\tint cur;\n\t\tint next;\n\t\tint to;\n\t\tint arrive;\n\t\tString lab;\n\n\t\tpublic Mail(int _cur, int _next, int _to, int _arrive, String lb) {\n\t\t\tcur = _cur;\n\t\t\tnext = _next;\n\t\t\tto = _to;\n\t\t\tarrive = _arrive;\n\t\t\tlab = new String(lb);\n\t\t}\n\n\t\tpublic void deliver(int time) {\n\t\t\tarrive = time + dist[cur][next];\n\t\t\tdelv[cur] = time + dist[cur][next] * 2;\n\t\t\tevt.add(new Evt(delv[cur], cur, 'o'));\n\t\t\tif (next == to) {\n\t\t\t\tcur = -1;\n\t\t\t\tnext = -1;\n\t\t\t} else {\n\t\t\t\tcur = next;\n\t\t\t\tnext = getNext(next, to);\n\t\t\t\tevt.add(new Evt(arrive, cur, 'M'));\n\t\t\t}\n\t\t\t// @@@@@@@@@@@@@@@@\n\t\t\t// System.out.println(cur + \" \" + next + \" \" + to + \" \" + arrive + \"\n\t\t\t// will_arrive \" + lab);\n\t\t}\n\t}\n\n\tList<Mail> mail = new ArrayList<Mail>();\n\n\tpublic void addMail(int id, int fr, int to, int tm, String lab) {\n\t\tmail.add(new Mail(fr, this.getNext(fr, to), to, tm, lab));\n\t\tevt.add(new Evt(tm, fr, 'I'));\n\t}\n\n\tpublic Map(int n, int m) {\n\t\tN = n;\n\t\tdelv = new int[n + 1];\n\t\tdist = new int[n + 1][n + 1];\n\t\tnext = new int[n + 1][n + 1];\n\n\t}\n\n\tpublic void process() {\n\t\tEvt e;\n\t\twhile ((e = evt.poll()) != null) {\n\t\t\t// @@@@@@@@@@@@@@@@\n\t\t\t// System.out.println(\"event \" + e.time + \" \" + e.pof + \" \" + e.cd);\n\t\t\tif (delv[e.pof] > e.time)\n\t\t\t\tcontinue;\n\t\t\tint minNext = Integer.MAX_VALUE;\n\t\t\tint minTime = Integer.MAX_VALUE;\n\t\t\tint mail_ID = 0;\n\t\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\t\tif (mail.get(i).cur == e.pof && mail.get(i).arrive <= e.time && (mail.get(i).arrive < minTime\n\t\t\t\t\t\t|| (mail.get(i).arrive == minTime && mail.get(i).next < minNext))) {\n\t\t\t\t\tminNext = mail.get(i).next;\n\t\t\t\t\tminTime = mail.get(i).arrive;\n\t\t\t\t\tmail_ID = i;\n\t\t\t\t}\n\n\t\t\tif (minTime != Integer.MAX_VALUE) {\n\t\t\t\tmail.get(mail_ID).deliver(e.time);\n\n\t\t\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\t\t\tif (i != mail_ID && mail.get(i).cur == e.pof && mail.get(i).arrive <= e.time\n\t\t\t\t\t\t\t&& mail.get(i).next == minNext)\n\t\t\t\t\t\tmail.get(i).deliver(e.time);\n\t\t\t}\n\t\t}\n\n\t\tthis.printMail();\n\t}\n\n\tclass mailSort implements Comparator<Mail> {\n\n\t\t@Override\n\t\tpublic int compare(Mail o1, Mail o2) {\n\t\t\tif (o1.arrive > o2.arrive)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.arrive == o2.arrive)\n\t\t\t\tif (o1.lab.compareTo(o2.lab) > 0)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (o1.lab.compareTo(o2.lab) == 0)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tprivate void printMail() {\n\t\tCollections.sort(mail, new mailSort());\n\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\tSystem.out.println(mail.get(i).lab + \" \" + mail.get(i).arrive);\n\t}\n\n\tpublic int getNext(int fr, int to) {\n\t\tif (fr == to)\n\t\t\treturn to;\n\t\tif (next[fr][to] > 0)\n\t\t\treturn next[fr][to];\n\n\t\tint min = Integer.MAX_VALUE;\n\t\ttempdist = Integer.MAX_VALUE;\n\t\tint nx = 0;\n\t\tfor (int i = 1; i < next.length; i++) {\n\t\t\tint[] r = new int[dist.length];\n\t\t\tr[fr] = -1;\n\t\t\tif (dist[fr][i] > 0) {\n\t\t\t\tint d = this.leastDist(i, to, r, dist[fr][i]);\n\t\t\t\tif (d > 0 && d < min) {\n\t\t\t\t\tmin = d;\n\t\t\t\t\tnx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnext[fr][to] = nx;\n\t\t// @@@@@@@@@@@@@@@@@@@@@@@\n\t\t// System.out.println(fr + \" \" + to + \" by \" + nx);\n\t\treturn nx;\n\t}\n\n\tint tempdist;\n\n\tprivate int leastDist(int fr, int to, int[] r, int ps) {\n\t\tif (fr == to) {\n\t\t\tif (tempdist > ps)\n\t\t\t\ttempdist = ps;\n\t\t\treturn ps;\n\t\t}\n\t\tif (ps > tempdist)\n\t\t\treturn -1;\n\t\tr[fr] = -1;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 1; i < dist[fr].length; i++)\n\t\t\tif (dist[fr][i] > 0 && r[i] != -1) {\n\t\t\t\tint d = leastDist(i, to, r, ps + dist[fr][i]);\n\t\t\t\tif (d > 0 && d < min)\n\t\t\t\t\tmin = d;\n\t\t\t}\n\t\tr[fr] = 0;\n\t\tif (min == Integer.MAX_VALUE)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn min;\n\t}\n\n\tpublic void addRoot(int fr, int to, int ds) {\n\t\tdist[fr][to] = ds;\n\t\tdist[to][fr] = ds;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Poor Mail Forwarding\npublic class Main{\n\n\tfinal int SEND = 0, BACK = 1, INFORM = 2;\n\tint INF = 1<<29;\n\tint[][] e, next;\n\tboolean[] exist;\n\tint[] from, to;\n\tString[] letter;\n\tLinkedList<P>[] post;\n\t\n\tclass T{\n\t\tint from;\n\t\tList<Integer> list;\n\t\tpublic T(int from) {\n\t\t\tthis.from = from;\n\t\t\tlist = new ArrayList<Integer>();\n\t\t}\n\t}\n\tclass P implements Comparable<P>{\n\t\tint at, id, t;\n\t\tpublic P(int at, int id, int t) {\n\t\t\tthis.at = at;\n\t\t\tthis.id = id;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\treturn t!=o.t?t-o.t:next[at][to[id]]-next[at][to[o.id]];\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tr+=\"Pos:\"+at+\" Letter id:\"+id+\" Time:\"+t;\n\t\t\treturn r;\n\t\t}\n\t}\n\tclass E implements Comparable<E>{\n\t\tint type, data, t;\n\t\tT con;\n\t\tpublic E(int type, int data, int t, T c) {\n\t\t\tthis.type = type;\n\t\t\tthis.data = data;\n\t\t\tthis.t = t;\n\t\t\tcon = c;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn t!=o.t?t-o.t:type-o.type;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tr+=type==BACK?\"BACK\":type==SEND?\"SEND\":\"INFORM\";\n\t\t\tr+=\" at:\"+data+\" time:\"+t;\n\t\t\treturn r;\n\t\t}\n\t}\n\tclass R implements Comparable<R>{\n\t\tString s;\n\t\tint t;\n\t\tpublic R(String s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn t!=o.t?t-o.t:s.compareTo(o.s);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tboolean head = true;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tif(!head)System.out.println();\n\t\t\thead = false;\n\t\t\te = new int[n][n];\n\t\t\tboolean[][] adj = new boolean[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, d = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = d;\n\t\t\t\tadj[s][t] = adj[t][s] = true;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)e[i][i]=0;\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)e[i][j]=Math.min(e[i][j], e[i][k]+e[k][j]);\n\t\t\tnext = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\tif(i==j||e[i][j]==INF)continue;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(i==k||!adj[i][k])continue;\n\t\t\t\t\tif(e[i][j]==e[i][k]+e[k][j]){\n\t\t\t\t\t\tnext[i][j] = k; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<R> res = new PriorityQueue<R>();\n\t\t\texist = new boolean[n];\n\t\t\tArrays.fill(exist, true);\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\t\t\tint L = sc.nextInt();\n\t\t\tfrom = new int[L]; to = new int[L]; letter = new String[L];\n\t\t\tpost = new LinkedList[n];\n\t\t\tfor(int i=0;i<n;i++)post[i] = new LinkedList<P>();\n\t\t\tfor(int i=0;i<L;i++){\n\t\t\t\tfrom[i] = sc.nextInt()-1; to[i] = sc.nextInt()-1;\n\t\t\t\tint time = sc.nextInt();\n\t\t\t\tletter[i] = sc.next();\n\t\t\t\tpost[from[i]].add(new P(from[i], i, time));\n\t\t\t\tq.add(new E(INFORM, from[i], time, null));\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tE event = q.poll();\n//\t\t\t\tSystem.out.println(event);\n//\t\t\t\tSystem.out.println(post[1]);\n\t\t\t\tint pos = event.data;\n\t\t\t\tif(event.type==BACK){\n\t\t\t\t\tif(post[pos].isEmpty()){\n\t\t\t\t\t\texist[pos] = true; continue;\n\t\t\t\t\t}\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tif(event.t<post[pos].peek().t){\n\t\t\t\t\t\texist[pos] = true; continue;\n\t\t\t\t\t}\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(event.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==INFORM){\n\t\t\t\t\tif(!exist[pos])continue;\n\t\t\t\t\tif(post[pos].isEmpty())continue;\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tif(event.t<post[pos].peek().t)continue;\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(event.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==SEND){\n\t\t\t\t\tT t = event.con;\n\t\t\t\t\tq.add(new E(BACK, t.from, event.t+e[pos][t.from], null));\n\t\t\t\t\tboolean offer = false;\n\t\t\t\t\tfor(int id:t.list){\n\t\t\t\t\t\tif(pos==to[id]){\n\t\t\t\t\t\t\tres.add(new R(letter[id], event.t)); continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!offer)q.add(new E(INFORM, pos, event.t, null));\n\t\t\t\t\t\toffer = true;\n\t\t\t\t\t\tpost[pos].add(new P(pos, id, event.t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!res.isEmpty()){\n\t\t\t\tR r = res.poll();\n\t\t\t\tSystem.out.println(r.s+\" \"+r.t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Poor Mail Forwarding\npublic class Main{\n\n\tfinal int SEND = 0, BACK = 1, INFORM = 2;\n\tint INF = 1<<29;\n\tint[][] e, next;\n\tboolean[] exist;\n\tint[] from, to;\n\tString[] letter;\n\tLinkedList<P>[] post;\n\t\n\tclass T{\n\t\tint from;\n\t\tList<Integer> list;\n\t\tpublic T(int from) {\n\t\t\tthis.from = from;\n\t\t\tlist = new ArrayList<Integer>();\n\t\t}\n\t}\n\tclass P implements Comparable<P>{\n\t\tint at, id, t;\n\t\tpublic P(int at, int id, int t) {\n\t\t\tthis.at = at;\n\t\t\tthis.id = id;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\treturn t!=o.t?t-o.t:next[at][to[id]]-next[at][to[o.id]];\n\t\t}\n\t}\n\tclass E implements Comparable<E>{\n\t\tint type, data, t;\n\t\tT con;\n\t\tpublic E(int type, int data, int t, T c) {\n\t\t\tthis.type = type;\n\t\t\tthis.data = data;\n\t\t\tthis.t = t;\n\t\t\tcon = c;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn t!=o.t?t-o.t:type-o.type;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tr+=type==BACK?\"BACK\":type==SEND?\"SEND\":\"INFORM\";\n\t\t\tr+=\" at:\"+data+\" time:\"+t;\n\t\t\treturn r;\n\t\t}\n\t}\n\tclass R implements Comparable<R>{\n\t\tString s;\n\t\tint t;\n\t\tpublic R(String s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn t!=o.t?t-o.t:s.compareTo(o.s);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tboolean head = true;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tif(!head)System.out.println();\n\t\t\thead = false;\n\t\t\te = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, d = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = d;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)e[i][i]=0;\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)e[i][j]=Math.min(e[i][j], e[i][k]+e[k][j]);\n\t\t\tnext = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\tif(i==j||e[i][j]==INF)continue;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(i==k)continue;\n\t\t\t\t\tif(e[i][j]==e[i][k]+e[k][j]){\n\t\t\t\t\t\tnext[i][j] = k; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<R> res = new PriorityQueue<R>();\n\t\t\texist = new boolean[n];\n\t\t\tArrays.fill(exist, true);\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\t\t\tint L = sc.nextInt();\n\t\t\tfrom = new int[L]; to = new int[L]; letter = new String[L];\n\t\t\tpost = new LinkedList[n];\n\t\t\tfor(int i=0;i<n;i++)post[i] = new LinkedList<P>();\n\t\t\tfor(int i=0;i<L;i++){\n\t\t\t\tfrom[i] = sc.nextInt()-1; to[i] = sc.nextInt()-1;\n\t\t\t\tint time = sc.nextInt();\n\t\t\t\tletter[i] = sc.next();\n\t\t\t\tpost[from[i]].add(new P(from[i], i, time));\n\t\t\t\tq.add(new E(INFORM, from[i], time, null));\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tE event = q.poll();\n//\t\t\t\tSystem.out.println(event);\n\t\t\t\tint pos = event.data;\n\t\t\t\tif(event.type==BACK){\n\t\t\t\t\tif(post[pos].isEmpty()){\n\t\t\t\t\t\texist[pos] = true; continue;\n\t\t\t\t\t}\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tif(event.t<post[pos].peek().t){\n\t\t\t\t\t\texist[pos] = true; continue;\n\t\t\t\t\t}\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(p.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==INFORM){\n\t\t\t\t\tif(!exist[pos])continue;\n\t\t\t\t\tif(post[pos].isEmpty())continue;\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tif(event.t<post[pos].peek().t)continue;\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(p.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==SEND){\n\t\t\t\t\tT t = event.con;\n\t\t\t\t\tq.add(new E(BACK, t.from, event.t+e[pos][t.from], null));\n\t\t\t\t\tboolean offer = false;\n\t\t\t\t\tfor(int id:t.list){\n\t\t\t\t\t\tif(pos==to[id]){\n\t\t\t\t\t\t\tres.add(new R(letter[id], event.t)); continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!offer)q.add(new E(INFORM, pos, event.t, null));\n\t\t\t\t\t\toffer = true;\n\t\t\t\t\t\tpost[pos].add(new P(pos, id, event.t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!res.isEmpty()){\n\t\t\t\tR r = res.poll();\n\t\t\t\tSystem.out.println(r.s+\" \"+r.t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Poor Mail Forwarding\npublic class Main{\n\n\tfinal int SEND = 0, BACK = 1, INFORM = 2;\n\tint INF = 1<<29;\n\tint[][] e, next;\n\tboolean[] exist;\n\tint[] from, to;\n\tString[] letter;\n\tLinkedList<P>[] post;\n\t\n\tclass T{\n\t\tint from;\n\t\tList<Integer> list;\n\t\tpublic T(int from) {\n\t\t\tthis.from = from;\n\t\t\tlist = new ArrayList<Integer>();\n\t\t}\n\t}\n\tclass P implements Comparable<P>{\n\t\tint at, id, t;\n\t\tpublic P(int at, int id, int t) {\n\t\t\tthis.at = at;\n\t\t\tthis.id = id;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\treturn t!=o.t?t-o.t:next[at][to[id]]-next[at][to[o.id]];\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tr+=\"Pos:\"+at+\" Letter id:\"+id+\" Time:\"+t;\n\t\t\treturn r;\n\t\t}\n\t}\n\tclass E implements Comparable<E>{\n\t\tint type, data, t;\n\t\tT con;\n\t\tpublic E(int type, int data, int t, T c) {\n\t\t\tthis.type = type;\n\t\t\tthis.data = data;\n\t\t\tthis.t = t;\n\t\t\tcon = c;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn t!=o.t?t-o.t:type-o.type;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tr+=type==BACK?\"BACK\":type==SEND?\"SEND\":\"INFORM\";\n\t\t\tr+=\" at:\"+data+\" time:\"+t;\n\t\t\treturn r;\n\t\t}\n\t}\n\tclass R implements Comparable<R>{\n\t\tString s;\n\t\tint t;\n\t\tpublic R(String s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn t!=o.t?t-o.t:s.compareTo(o.s);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tboolean head = true;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tif(!head)System.out.println();\n\t\t\thead = false;\n\t\t\te = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, d = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = d;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)e[i][i]=0;\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)e[i][j]=Math.min(e[i][j], e[i][k]+e[k][j]);\n\t\t\tnext = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\tif(i==j||e[i][j]==INF)continue;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(i==k||e[i][k]==INF)continue;\n\t\t\t\t\tif(e[i][j]==e[i][k]+e[k][j]){\n\t\t\t\t\t\tnext[i][j] = k; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<R> res = new PriorityQueue<R>();\n\t\t\texist = new boolean[n];\n\t\t\tArrays.fill(exist, true);\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\t\t\tint L = sc.nextInt();\n\t\t\tfrom = new int[L]; to = new int[L]; letter = new String[L];\n\t\t\tpost = new LinkedList[n];\n\t\t\tfor(int i=0;i<n;i++)post[i] = new LinkedList<P>();\n\t\t\tfor(int i=0;i<L;i++){\n\t\t\t\tfrom[i] = sc.nextInt()-1; to[i] = sc.nextInt()-1;\n\t\t\t\tint time = sc.nextInt();\n\t\t\t\tletter[i] = sc.next();\n\t\t\t\tpost[from[i]].add(new P(from[i], i, time));\n\t\t\t\tq.add(new E(INFORM, from[i], time, null));\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tE event = q.poll();\n//\t\t\t\tSystem.out.println(event);\n//\t\t\t\tSystem.out.println(post[1]);\n\t\t\t\tint pos = event.data;\n\t\t\t\tif(event.type==BACK){\n\t\t\t\t\tif(post[pos].isEmpty()){\n\t\t\t\t\t\texist[pos] = true; continue;\n\t\t\t\t\t}\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tif(event.t<post[pos].peek().t){\n\t\t\t\t\t\texist[pos] = true; continue;\n\t\t\t\t\t}\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(event.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==INFORM){\n\t\t\t\t\tif(!exist[pos])continue;\n\t\t\t\t\tif(post[pos].isEmpty())continue;\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tif(event.t<post[pos].peek().t)continue;\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(event.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==SEND){\n\t\t\t\t\tT t = event.con;\n\t\t\t\t\tq.add(new E(BACK, t.from, event.t+e[pos][t.from], null));\n\t\t\t\t\tboolean offer = false;\n\t\t\t\t\tfor(int id:t.list){\n\t\t\t\t\t\tif(pos==to[id]){\n\t\t\t\t\t\t\tres.add(new R(letter[id], event.t)); continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!offer)q.add(new E(INFORM, pos, event.t, null));\n\t\t\t\t\t\toffer = true;\n\t\t\t\t\t\tpost[pos].add(new P(pos, id, event.t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!res.isEmpty()){\n\t\t\t\tR r = res.poll();\n\t\t\t\tSystem.out.println(r.s+\" \"+r.t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\2010-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\t// if (n == 23 && m == 37)\n\t\t\t// break;\n\t\t\tMap mp = new Map(n, m);\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t\tmp.addRoot(scan.nextInt(), scan.nextInt(), scan.nextInt());\n\t\t\tint l = scan.nextInt();\n\t\t\tfor (int i = 0; i < l; i++)\n\t\t\t\tmp.addMail(i, scan.nextInt(), scan.nextInt(), scan.nextInt(), scan.next());\n\t\t\tmp.process();\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Map {\n\tclass Evt {\n\t\tpublic Evt(int tm, int fr, char r) {\n\t\t\ttime = tm;\n\t\t\tpof = fr;\n\t\t\tcd = r;\n\t\t}\n\n\t\tint time;\n\t\tint pof;\n\t\tchar cd;\n\t}\n\n\tclass EvTime implements Comparator<Evt> {\n\n\t\t@Override\n\t\tpublic int compare(Evt o1, Evt o2) {\n\t\t\tif (o1.time > o2.time)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.time == o2.time)\n\t\t\t\tif (o1.pof > o2.pof)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (o1.pof == o2.pof)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tPriorityQueue<Evt> evt = new PriorityQueue<Evt>(100, new EvTime());\n\n\tint N;\n\tint[] delv;\n\tint[][] dist;\n\tint[][] next;\n\n\tclass Mail {\n\t\tint cur;\n\t\tint next;\n\t\tint to;\n\t\tint arrive;\n\t\tString lab;\n\n\t\tpublic Mail(int _cur, int _next, int _to, int _arrive, String lb) {\n\t\t\tcur = _cur;\n\t\t\tnext = _next;\n\t\t\tto = _to;\n\t\t\tarrive = _arrive;\n\t\t\tlab = new String(lb);\n\t\t}\n\n\t\tpublic void deliver(int time) {\n\t\t\tarrive = time + dist[cur][next];\n\t\t\tdelv[cur] = time + dist[cur][next] * 2;\n\t\t\tevt.add(new Evt(delv[cur], cur, 'o'));\n\t\t\tif (next == to) {\n\t\t\t\tcur = -1;\n\t\t\t\tnext = -1;\n\t\t\t} else {\n\t\t\t\tcur = next;\n\t\t\t\tnext = getNext(next, to);\n\t\t\t\tevt.add(new Evt(arrive, cur, 'M'));\n\t\t\t}\n\t\t\t// @@@@@@@@@@@@@@@@\n\t\t\t// System.out.println(cur + \" \" + next + \" \" + to + \" \" + arrive + \"\n\t\t\t// will_arrive \" + lab);\n\t\t}\n\t}\n\n\tList<Mail> mail = new ArrayList<Mail>();\n\n\tpublic void addMail(int id, int fr, int to, int tm, String lab) {\n\t\tmail.add(new Mail(fr, this.getNext(fr, to), to, tm, lab));\n\t\tevt.add(new Evt(tm, fr, 'I'));\n\t}\n\n\tpublic Map(int n, int m) {\n\t\tN = n;\n\t\tdelv = new int[n + 1];\n\t\tdist = new int[n + 1][n + 1];\n\t\tnext = new int[n + 1][n + 1];\n\n\t}\n\n\tpublic void process() {\n\t\tEvt e;\n\t\twhile ((e = evt.poll()) != null) {\n\t\t\t// @@@@@@@@@@@@@@@@\n\t\t\t// System.out.println(\"event \" + e.time + \" \" + e.pof + \" \" + e.cd);\n\t\t\tif (delv[e.pof] > e.time)\n\t\t\t\tcontinue;\n\t\t\tint minNext = Integer.MAX_VALUE;\n\t\t\tint minTime = Integer.MAX_VALUE;\n\t\t\tint mail_ID = 0;\n\t\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\t\tif (mail.get(i).cur == e.pof && mail.get(i).arrive <= e.time && (mail.get(i).arrive < minTime\n\t\t\t\t\t\t|| (mail.get(i).arrive == minTime && mail.get(i).next < minNext))) {\n\t\t\t\t\tminNext = mail.get(i).next;\n\t\t\t\t\tminTime = mail.get(i).arrive;\n\t\t\t\t\tmail_ID = i;\n\t\t\t\t}\n\n\t\t\tif (minTime != Integer.MAX_VALUE) {\n\t\t\t\tmail.get(mail_ID).deliver(e.time);\n\n\t\t\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\t\t\tif (i != mail_ID && mail.get(i).cur == e.pof && mail.get(i).arrive <= e.time\n\t\t\t\t\t\t\t&& mail.get(i).next == minNext)\n\t\t\t\t\t\tmail.get(i).deliver(e.time);\n\t\t\t}\n\t\t}\n\n\t\tthis.printMail();\n\t}\n\n\tclass mailSort implements Comparator<Mail> {\n\n\t\t@Override\n\t\tpublic int compare(Mail o1, Mail o2) {\n\t\t\tif (o1.arrive > o2.arrive)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.arrive == o2.arrive)\n\t\t\t\tif (o1.lab.compareTo(o2.lab) > 0)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (o1.lab.compareTo(o2.lab) == 0)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tprivate void printMail() {\n\t\tCollections.sort(mail, new mailSort());\n\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\tSystem.out.println(mail.get(i).lab + \" \" + mail.get(i).arrive);\n\t\tSystem.out.println();\n\t}\n\n\tpublic int getNext(int fr, int to) {\n\t\tif (fr == to)\n\t\t\treturn to;\n\t\tif (next[fr][to] > 0)\n\t\t\treturn next[fr][to];\n\n\t\tint min = Integer.MAX_VALUE;\n\t\ttempdist = Integer.MAX_VALUE;\n\t\tint nx = 0;\n\t\tfor (int i = 1; i < next.length; i++) {\n\t\t\tint[] r = new int[dist.length];\n\t\t\tr[fr] = -1;\n\t\t\tif (dist[fr][i] > 0) {\n\t\t\t\tint d = this.leastDist(i, to, r, dist[fr][i]);\n\t\t\t\tif (d > 0 && d < min) {\n\t\t\t\t\tmin = d;\n\t\t\t\t\tnx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnext[fr][to] = nx;\n\t\t// @@@@@@@@@@@@@@@@@@@@@@@\n\t\t// System.out.println(fr + \" \" + to + \" by \" + nx);\n\t\treturn nx;\n\t}\n\n\tint tempdist;\n\n\tprivate int leastDist(int fr, int to, int[] r, int ps) {\n\t\tif (fr == to) {\n\t\t\tif (tempdist > ps)\n\t\t\t\ttempdist = ps;\n\t\t\treturn ps;\n\t\t}\n\t\tif (ps > tempdist)\n\t\t\treturn -1;\n\t\tr[fr] = -1;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 1; i < dist[fr].length; i++)\n\t\t\tif (dist[fr][i] > 0 && r[i] != -1) {\n\t\t\t\tint d = leastDist(i, to, r, ps + dist[fr][i]);\n\t\t\t\tif (d > 0 && d < min)\n\t\t\t\t\tmin = d;\n\t\t\t}\n\t\tr[fr] = 0;\n\t\tif (min == Integer.MAX_VALUE)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn min;\n\t}\n\n\tpublic void addRoot(int fr, int to, int ds) {\n\t\tdist[fr][to] = ds;\n\t\tdist[to][fr] = ds;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\2010-input.txt\"));\n\n\t\tboolean first = true;\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\tMap mp = new Map(n, m);\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t\tmp.addRoot(scan.nextInt(), scan.nextInt(), scan.nextInt());\n\t\t\tint l = scan.nextInt();\n\t\t\tfor (int i = 0; i < l; i++)\n\t\t\t\tmp.addMail(i, scan.nextInt(), scan.nextInt(), scan.nextInt(), scan.next());\n\t\t\tif (!first)\n\t\t\t\tSystem.out.println();\n\t\t\tfirst = false;\n\t\t\tmp.process();\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Map {\n\tclass Evt {\n\t\tpublic Evt(int tm, int fr, char r) {\n\t\t\ttime = tm;\n\t\t\tpof = fr;\n\t\t\tcd = r;\n\t\t}\n\n\t\tint time;\n\t\tint pof;\n\t\tchar cd;\n\t}\n\n\tclass EvTime implements Comparator<Evt> {\n\n\t\t@Override\n\t\tpublic int compare(Evt o1, Evt o2) {\n\t\t\tif (o1.time > o2.time)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.time == o2.time)\n\t\t\t\tif (o1.pof > o2.pof)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (o1.pof == o2.pof)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tPriorityQueue<Evt> evt = new PriorityQueue<Evt>(100, new EvTime());\n\n\tint N;\n\tint[] delv;\n\tint[][] dist;\n\tint[][] next;\n\n\tclass Mail {\n\t\tint cur;\n\t\tint next;\n\t\tint to;\n\t\tint arrive;\n\t\tString lab;\n\n\t\tpublic Mail(int _cur, int _next, int _to, int _arrive, String lb) {\n\t\t\tcur = _cur;\n\t\t\tnext = _next;\n\t\t\tto = _to;\n\t\t\tarrive = _arrive;\n\t\t\tlab = new String(lb);\n\t\t}\n\n\t\tpublic void deliver(int time) {\n\t\t\tarrive = time + dist[cur][next];\n\t\t\tdelv[cur] = time + dist[cur][next] * 2;\n\t\t\tevt.add(new Evt(delv[cur], cur, 'o'));\n\t\t\tif (next == to) {\n\t\t\t\tcur = -1;\n\t\t\t\tnext = -1;\n\t\t\t} else {\n\t\t\t\tcur = next;\n\t\t\t\tnext = getNext(next, to);\n\t\t\t\tevt.add(new Evt(arrive, cur, 'M'));\n\t\t\t}\n\t\t\t// @@@@@@@@@@@@@@@@\n\t\t\t// System.out.println(cur + \" \" + next + \" \" + to + \" \" + arrive + \"\n\t\t\t// will_arrive \" + lab);\n\t\t}\n\t}\n\n\tList<Mail> mail = new ArrayList<Mail>();\n\n\tpublic void addMail(int id, int fr, int to, int tm, String lab) {\n\t\tmail.add(new Mail(fr, this.getNext(fr, to), to, tm, lab));\n\t\tevt.add(new Evt(tm, fr, 'I'));\n\t}\n\n\tpublic Map(int n, int m) {\n\t\tN = n;\n\t\tdelv = new int[n + 1];\n\t\tdist = new int[n + 1][n + 1];\n\t\tnext = new int[n + 1][n + 1];\n\n\t}\n\n\tpublic void process() {\n\t\tEvt e;\n\t\twhile ((e = evt.poll()) != null) {\n\t\t\t// @@@@@@@@@@@@@@@@\n\t\t\t// System.out.println(\"event \" + e.time + \" \" + e.pof + \" \" + e.cd);\n\t\t\tif (delv[e.pof] > e.time)\n\t\t\t\tcontinue;\n\t\t\tint minNext = Integer.MAX_VALUE;\n\t\t\tint minTime = Integer.MAX_VALUE;\n\t\t\tint mail_ID = 0;\n\t\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\t\tif (mail.get(i).cur == e.pof && mail.get(i).arrive <= e.time && (mail.get(i).arrive < minTime\n\t\t\t\t\t\t|| (mail.get(i).arrive == minTime && mail.get(i).next < minNext))) {\n\t\t\t\t\tminNext = mail.get(i).next;\n\t\t\t\t\tminTime = mail.get(i).arrive;\n\t\t\t\t\tmail_ID = i;\n\t\t\t\t}\n\n\t\t\tif (minTime != Integer.MAX_VALUE) {\n\t\t\t\tmail.get(mail_ID).deliver(e.time);\n\n\t\t\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\t\t\tif (i != mail_ID && mail.get(i).cur == e.pof && mail.get(i).arrive <= e.time\n\t\t\t\t\t\t\t&& mail.get(i).next == minNext)\n\t\t\t\t\t\tmail.get(i).deliver(e.time);\n\t\t\t}\n\t\t}\n\n\t\tthis.printMail();\n\t}\n\n\tclass mailSort implements Comparator<Mail> {\n\n\t\t@Override\n\t\tpublic int compare(Mail o1, Mail o2) {\n\t\t\tif (o1.arrive > o2.arrive)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.arrive == o2.arrive)\n\t\t\t\tif (o1.lab.compareTo(o2.lab) > 0)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (o1.lab.compareTo(o2.lab) == 0)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tprivate void printMail() {\n\t\tCollections.sort(mail, new mailSort());\n\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\tSystem.out.println(mail.get(i).lab + \" \" + mail.get(i).arrive);\n\t}\n\n\tpublic int getNext(int fr, int to) {\n\t\tif (fr == to)\n\t\t\treturn to;\n\t\tif (next[fr][to] > 0)\n\t\t\treturn next[fr][to];\n\n\t\tint min = Integer.MAX_VALUE;\n\t\ttempdist = Integer.MAX_VALUE;\n\t\tint nx = 0;\n\t\tfor (int i = 1; i < next.length; i++) {\n\t\t\tint[] r = new int[dist.length];\n\t\t\tr[fr] = -1;\n\t\t\tif (dist[fr][i] > 0) {\n\t\t\t\tint d = this.leastDist(i, to, r, dist[fr][i]);\n\t\t\t\tif (d > 0 && d < min) {\n\t\t\t\t\tmin = d;\n\t\t\t\t\tnx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnext[fr][to] = nx;\n\t\t// @@@@@@@@@@@@@@@@@@@@@@@\n\t\t// System.out.println(fr + \" \" + to + \" by \" + nx);\n\t\treturn nx;\n\t}\n\n\tint tempdist;\n\n\tprivate int leastDist(int fr, int to, int[] r, int ps) {\n\t\tif (fr == to) {\n\t\t\tif (tempdist > ps)\n\t\t\t\ttempdist = ps;\n\t\t\treturn ps;\n\t\t}\n\t\tif (ps > tempdist)\n\t\t\treturn -1;\n\t\tr[fr] = -1;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 1; i < dist[fr].length; i++)\n\t\t\tif (dist[fr][i] > 0 && r[i] != -1) {\n\t\t\t\tint d = leastDist(i, to, r, ps + dist[fr][i]);\n\t\t\t\tif (d > 0 && d < min)\n\t\t\t\t\tmin = d;\n\t\t\t}\n\t\tr[fr] = 0;\n\t\tif (min == Integer.MAX_VALUE)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn min;\n\t}\n\n\tpublic void addRoot(int fr, int to, int ds) {\n\t\tdist[fr][to] = ds;\n\t\tdist[to][fr] = ds;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Poor Mail Forwarding\npublic class Main{\n\n\tfinal int SEND = 0, BACK = 1, INFORM = 2;\n\tint INF = 1<<29;\n\tint[][] e, next;\n\tboolean[] exist;\n\tint[] from, to;\n\tString[] letter;\n\tLinkedList<P>[] post;\n\t\n\tclass T{\n\t\tint from;\n\t\tList<Integer> list;\n\t\tpublic T(int from) {\n\t\t\tthis.from = from;\n\t\t\tlist = new ArrayList<Integer>();\n\t\t}\n\t}\n\tclass P implements Comparable<P>{\n\t\tint at, id, t;\n\t\tpublic P(int at, int id, int t) {\n\t\t\tthis.at = at;\n\t\t\tthis.id = id;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\treturn t!=o.t?t-o.t:next[at][to[id]]-next[at][to[o.id]];\n\t\t}\n\t}\n\tclass E implements Comparable<E>{\n\t\tint type, data, t;\n\t\tT con;\n\t\tpublic E(int type, int data, int t, T c) {\n\t\t\tthis.type = type;\n\t\t\tthis.data = data;\n\t\t\tthis.t = t;\n\t\t\tcon = c;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn t!=o.t?t-o.t:type-o.type;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tr+=type==BACK?\"BACK\":type==SEND?\"SEND\":\"INFORM\";\n\t\t\tr+=\" at:\"+data+\" time:\"+t;\n\t\t\treturn r;\n\t\t}\n\t}\n\tclass R implements Comparable<R>{\n\t\tString s;\n\t\tint t;\n\t\tpublic R(String s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn t!=o.t?t-o.t:s.compareTo(o.s);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tboolean head = true;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tif(!head)System.out.println();\n\t\t\thead = false;\n\t\t\te = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, d = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = d;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)e[i][i]=0;\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)e[i][j]=Math.min(e[i][j], e[i][k]+e[k][j]);\n\t\t\tnext = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\tif(i==j||e[i][j]==INF)continue;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(i==k)continue;\n\t\t\t\t\tif(e[i][j]==e[i][k]+e[k][j]){\n\t\t\t\t\t\tnext[i][j] = k; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<R> res = new PriorityQueue<R>();\n\t\t\texist = new boolean[n];\n\t\t\tArrays.fill(exist, true);\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\t\t\tint L = sc.nextInt();\n\t\t\tfrom = new int[L]; to = new int[L]; letter = new String[L];\n\t\t\tpost = new LinkedList[n];\n\t\t\tfor(int i=0;i<n;i++)post[i] = new LinkedList<P>();\n\t\t\tfor(int i=0;i<L;i++){\n\t\t\t\tfrom[i] = sc.nextInt()-1; to[i] = sc.nextInt()-1;\n\t\t\t\tint time = sc.nextInt();\n\t\t\t\tletter[i] = sc.next();\n\t\t\t\tpost[from[i]].add(new P(from[i], i, time));\n\t\t\t\tq.add(new E(INFORM, from[i], time, null));\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tE event = q.poll();\n//\t\t\t\tSystem.out.println(event);\n\t\t\t\tint pos = event.data;\n\t\t\t\tif(event.type==BACK){\n\t\t\t\t\tif(post[pos].isEmpty()){\n\t\t\t\t\t\texist[pos] = true; continue;\n\t\t\t\t\t}\n\t\t\t\t\tif(event.t<post[pos].peek().t){\n\t\t\t\t\t\texist[pos] = true; continue;\n\t\t\t\t\t}\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(p.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==INFORM){\n\t\t\t\t\tif(!exist[pos])continue;\n\t\t\t\t\tif(post[pos].isEmpty())continue;\n\t\t\t\t\tif(event.t<post[pos].peek().t)continue;\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(p.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==SEND){\n\t\t\t\t\tT t = event.con;\n\t\t\t\t\tq.add(new E(BACK, t.from, event.t+e[pos][t.from], null));\n\t\t\t\t\tboolean offer = false;\n\t\t\t\t\tfor(int id:t.list){\n\t\t\t\t\t\tif(pos==to[id]){\n\t\t\t\t\t\t\tres.add(new R(letter[id], event.t)); continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!offer)q.add(new E(INFORM, pos, event.t, null));\n\t\t\t\t\t\toffer = true;\n\t\t\t\t\t\tpost[pos].add(new P(pos, id, event.t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!res.isEmpty()){\n\t\t\t\tR r = res.poll();\n\t\t\t\tSystem.out.println(r.s+\" \"+r.t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Poor Mail Forwarding\npublic class Main{\n\n\tfinal int SEND = 0, BACK = 1, INFORM = 2;\n\tint INF = 1<<29;\n\tint[][] e, next;\n\tboolean[] exist;\n\tint[] from, to;\n\tString[] letter;\n\tLinkedList<P>[] post;\n\t\n\tclass T{\n\t\tint from;\n\t\tList<Integer> list;\n\t\tpublic T(int from) {\n\t\t\tthis.from = from;\n\t\t\tlist = new ArrayList<Integer>();\n\t\t}\n\t}\n\tclass P implements Comparable<P>{\n\t\tint at, id, t;\n\t\tpublic P(int at, int id, int t) {\n\t\t\tthis.at = at;\n\t\t\tthis.id = id;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\treturn t!=o.t?t-o.t:next[at][to[id]]-next[at][to[o.id]];\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tr+=\"Pos:\"+at+\" Letter id:\"+id+\" Time:\"+t;\n\t\t\treturn r;\n\t\t}\n\t}\n\tclass E implements Comparable<E>{\n\t\tint type, data, t;\n\t\tT con;\n\t\tpublic E(int type, int data, int t, T c) {\n\t\t\tthis.type = type;\n\t\t\tthis.data = data;\n\t\t\tthis.t = t;\n\t\t\tcon = c;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn t!=o.t?t-o.t:type-o.type;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString r = \"\";\n\t\t\tr+=type==BACK?\"BACK\":type==SEND?\"SEND\":\"INFORM\";\n\t\t\tr+=\" at:\"+data+\" time:\"+t;\n\t\t\treturn r;\n\t\t}\n\t}\n\tclass R implements Comparable<R>{\n\t\tString s;\n\t\tint t;\n\t\tpublic R(String s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn t!=o.t?t-o.t:s.compareTo(o.s);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tboolean head = true;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tif(!head)System.out.println();\n\t\t\thead = false;\n\t\t\te = new int[n][n];\n\t\t\tint[][] adj = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:adj)Arrays.fill(a, INF);\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, d = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = d;\n\t\t\t\tadj[s][t] = adj[t][s] = d;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)e[i][i]=0;\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)e[i][j]=Math.min(e[i][j], e[i][k]+e[k][j]);\n\t\t\tnext = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\tif(i==j||e[i][j]==INF)continue;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(i==k||adj[i][k]==INF)continue;\n\t\t\t\t\tif(e[i][j]==adj[i][k]+e[k][j]){\n\t\t\t\t\t\tnext[i][j] = k; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<R> res = new PriorityQueue<R>();\n\t\t\texist = new boolean[n];\n\t\t\tArrays.fill(exist, true);\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\t\t\tint L = sc.nextInt();\n\t\t\tfrom = new int[L]; to = new int[L]; letter = new String[L];\n\t\t\tpost = new LinkedList[n];\n\t\t\tfor(int i=0;i<n;i++)post[i] = new LinkedList<P>();\n\t\t\tfor(int i=0;i<L;i++){\n\t\t\t\tfrom[i] = sc.nextInt()-1; to[i] = sc.nextInt()-1;\n\t\t\t\tint time = sc.nextInt();\n\t\t\t\tletter[i] = sc.next();\n\t\t\t\tpost[from[i]].add(new P(from[i], i, time));\n\t\t\t\tq.add(new E(INFORM, from[i], time, null));\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tE event = q.poll();\n//\t\t\t\tSystem.out.println(event);\n//\t\t\t\tSystem.out.println(post[1]);\n\t\t\t\tint pos = event.data;\n\t\t\t\tif(event.type==BACK){\n\t\t\t\t\tif(post[pos].isEmpty()){\n\t\t\t\t\t\texist[pos] = true; continue;\n\t\t\t\t\t}\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tif(event.t<post[pos].peek().t){\n\t\t\t\t\t\texist[pos] = true; continue;\n\t\t\t\t\t}\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(event.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==INFORM){\n\t\t\t\t\tif(!exist[pos])continue;\n\t\t\t\t\tif(post[pos].isEmpty())continue;\n\t\t\t\t\tCollections.sort(post[pos]);\n\t\t\t\t\tif(event.t<post[pos].peek().t)continue;\n\t\t\t\t\texist[pos] = false;\n\t\t\t\t\tT t = new T(pos);\n\t\t\t\t\tP p = post[pos].remove(0);\n\t\t\t\t\tt.list.add(p.id);\n\t\t\t\t\tint nx = next[pos][to[p.id]];\n\t\t\t\t\tfor(int i=0;i<post[pos].size();i++){\n\t\t\t\t\t\tP tmp = post[pos].get(i);\n\t\t\t\t\t\tif(event.t<tmp.t)break;\n\t\t\t\t\t\tif(nx==next[pos][to[tmp.id]]){\n\t\t\t\t\t\t\tpost[pos].remove(i);\n\t\t\t\t\t\t\tt.list.add(tmp.id);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nt = event.t+e[pos][nx];\n\t\t\t\t\tq.add(new E(SEND, nx, nt, t));\n\t\t\t\t\tq.add(new E(INFORM, nx, nt, null));\n\t\t\t\t}\n\t\t\t\telse if(event.type==SEND){\n\t\t\t\t\tT t = event.con;\n\t\t\t\t\tq.add(new E(BACK, t.from, event.t+e[pos][t.from], null));\n\t\t\t\t\tboolean offer = false;\n\t\t\t\t\tfor(int id:t.list){\n\t\t\t\t\t\tif(pos==to[id]){\n\t\t\t\t\t\t\tres.add(new R(letter[id], event.t)); continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!offer)q.add(new E(INFORM, pos, event.t, null));\n\t\t\t\t\t\toffer = true;\n\t\t\t\t\t\tpost[pos].add(new P(pos, id, event.t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!res.isEmpty()){\n\t\t\t\tR r = res.poll();\n\t\t\t\tSystem.out.println(r.s+\" \"+r.t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\2010-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\tMap mp = new Map(n, m);\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t\tmp.addRoot(scan.nextInt(), scan.nextInt(), scan.nextInt());\n\t\t\tint l = scan.nextInt();\n\t\t\tfor (int i = 0; i < l; i++)\n\t\t\t\tmp.addMail(i, scan.nextInt(), scan.nextInt(), scan.nextInt(), scan.next());\n\t\t\tmp.process();\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Map {\n\tclass Evt {\n\t\tpublic Evt(int tm, int fr, char r) {\n\t\t\ttime = tm;\n\t\t\tpof = fr;\n\t\t\tcd = r;\n\t\t}\n\n\t\tint time;\n\t\tint pof;\n\t\tchar cd;\n\t}\n\n\tclass EvTime implements Comparator<Evt> {\n\n\t\t@Override\n\t\tpublic int compare(Evt o1, Evt o2) {\n\t\t\tif (o1.time > o2.time)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.time == o2.time)\n\t\t\t\tif (o1.pof > o2.pof)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (o1.pof == o2.pof)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tPriorityQueue<Evt> evt = new PriorityQueue<Evt>(100, new EvTime());\n\n\tint N;\n\tint[] delv;\n\tint[][] dist;\n\tint[][] next;\n\n\tclass Mail {\n\t\tint cur;\n\t\tint next;\n\t\tint to;\n\t\tint arrive;\n\t\tString lab;\n\n\t\tpublic Mail(int _cur, int _next, int _to, int _arrive, String lb) {\n\t\t\tcur = _cur;\n\t\t\tnext = _next;\n\t\t\tto = _to;\n\t\t\tarrive = _arrive;\n\t\t\tlab = new String(lb);\n\t\t}\n\n\t\tpublic void deliver(int time) {\n\t\t\tarrive = time + dist[cur][next];\n\t\t\tdelv[cur] = time + dist[cur][next] * 2;\n\t\t\tevt.add(new Evt(delv[cur], cur, 'o'));\n\t\t\tif (next == to) {\n\t\t\t\tcur = -1;\n\t\t\t\tnext = -1;\n\t\t\t} else {\n\t\t\t\tcur = next;\n\t\t\t\tnext = getNext(next, to);\n\t\t\t\tevt.add(new Evt(arrive, cur, 'M'));\n\t\t\t}\n\t\t}\n\t}\n\n\tList<Mail> mail = new ArrayList<Mail>();\n\n\tpublic void addMail(int id, int fr, int to, int tm, String lab) {\n\t\tmail.add(new Mail(fr, this.getNext(fr, to), to, tm, lab));\n\t\tevt.add(new Evt(tm, fr, 'M'));\n\t}\n\n\tpublic Map(int n, int m) {\n\t\tN = n;\n\t\tdelv = new int[n + 1];\n\t\tdist = new int[n + 1][n + 1];\n\t\tnext = new int[n + 1][n + 1];\n\n\t}\n\n\tpublic void process() {\n\t\tEvt e;\n\t\twhile ((e = evt.poll()) != null) {\n\t\t\t// @@@@@@@@@@@@@@@@\n\t\t\t// System.out.println(\"event \" + e.time + \" \" + e.pof + \" \" + e.cd);\n\t\t\tif (delv[e.pof] > e.time)\n\t\t\t\tcontinue;\n\t\t\tint minNext = Integer.MAX_VALUE;\n\t\t\tint minTime = Integer.MAX_VALUE;\n\t\t\tint mail_ID = 0;\n\t\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\t\tif (mail.get(i).cur == e.pof && mail.get(i).arrive <= e.time && (mail.get(i).arrive < minTime\n\t\t\t\t\t\t|| (mail.get(i).arrive == minTime && mail.get(i).next < minNext))) {\n\t\t\t\t\tminNext = mail.get(i).next;\n\t\t\t\t\tminTime = mail.get(i).arrive;\n\t\t\t\t\tmail_ID = i;\n\t\t\t\t}\n\n\t\t\tif (minTime != Integer.MAX_VALUE) {\n\t\t\t\tmail.get(mail_ID).deliver(e.time);\n\n\t\t\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\t\t\tif (i != mail_ID && mail.get(i).cur == e.pof && mail.get(i).arrive <= e.time\n\t\t\t\t\t\t\t&& mail.get(i).next == minNext)\n\t\t\t\t\t\tmail.get(i).deliver(e.time);\n\t\t\t}\n\t\t}\n\n\t\tthis.printMail();\n\t}\n\n\tclass mailSort implements Comparator<Mail> {\n\n\t\t@Override\n\t\tpublic int compare(Mail o1, Mail o2) {\n\t\t\tif (o1.arrive > o2.arrive)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.arrive == o2.arrive)\n\t\t\t\tif (o1.lab.compareTo(o2.lab) > 0)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (o1.lab.compareTo(o2.lab) == 0)\n\t\t\t\t\treturn 0;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tprivate void printMail() {\n\t\tCollections.sort(mail, new mailSort());\n\t\tfor (int i = 0; i < mail.size(); i++)\n\t\t\tSystem.out.println(mail.get(i).lab + \" \" + mail.get(i).arrive);\n\t\tSystem.out.println();\n\t}\n\n\tpublic int getNext(int fr, int to) {\n\t\tif (fr == to)\n\t\t\treturn to;\n\t\tif (next[fr][to] > 0)\n\t\t\treturn next[fr][to];\n\n\t\tint min = Integer.MAX_VALUE;\n\t\ttempdist = Integer.MAX_VALUE;\n\t\tint nx = 0;\n\t\tfor (int i = 1; i < next.length; i++) {\n\t\t\tint[] r = new int[dist.length];\n\t\t\tr[fr] = -1;\n\t\t\tif (dist[fr][i] > 0) {\n\t\t\t\tint d = this.leastDist(i, to, r, dist[fr][i]);\n\t\t\t\tif (d > 0 && d < min) {\n\t\t\t\t\tmin = d;\n\t\t\t\t\tnx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnext[fr][to] = nx;\n\t\t// @@@@@@@@@@@@@@@@@@@@@@@\n\t\t// System.out.println(fr + \" \" + to + \" by \" + nx);\n\t\treturn nx;\n\t}\n\n\tint tempdist;\n\n\tprivate int leastDist(int fr, int to, int[] r, int ps) {\n\t\tif (fr == to) {\n\t\t\ttempdist = ps;\n\t\t\treturn ps;\n\t\t}\n\t\tif (ps > tempdist)\n\t\t\treturn -1;\n\t\tr[fr] = -1;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 1; i < dist.length; i++)\n\t\t\tif (dist[fr][i] > 0 && r[i] == 0) {\n\t\t\t\tint d = leastDist(i, to, r, ps + dist[fr][i]);\n\t\t\t\tif (d > 0 && d < min)\n\t\t\t\t\tmin = d;\n\t\t\t}\n\t\tif (min == Integer.MAX_VALUE)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn min;\n\t}\n\n\tpublic void addRoot(int fr, int to, int ds) {\n\t\tdist[fr][to] = ds;\n\t\tdist[to][fr] = ds;\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\ndef warshall_floyd(dist_matrix)\n\tdist = dist_matrix\n\tn = dist.size\n\traise \"dist_matrix is not square\" if dist.any?{|row| row.size != n}\n\n\tnext_dist = (1..n).map{ Array.new(n) }\n\t(0..n-1).each{|k|\n\t\tdist_k = dist[k]\n\t\t(0..n-1).each{|i|\n\t\t\tdist_i = dist[i]\n\t\t\tnext_dist_i = next_dist[i]\n\t\t\t(0..n-1).each{|j|\n\t\t\t\tx = dist_i[j]\n\t\t\t\ty = dist_i[k] + dist_k[j]\n\t\t\t\tnext_dist_i[j] = (x < y ? x : y)\n\t\t\t}\n\t\t}\n\t\tdist = next_dist\n\t}\n\tdist\nend\n\nans = []\nloop do\n    n, m = gets.split.map(&:to_i)\n    break if n == 0\n    ans << []\n\n    d_mat = (0..n).map {(0..n).map {Float::INFINITY}}\n    (1..n).map {|i| d_mat[i][i] = 0}\n    m.times do\n        i, j, d = gets.split.map(&:to_i)\n        d_mat[i][j] = d_mat[j][i] = d\n    end\n    dist = warshall_floyd(d_mat)\n\n    routing = (0..n).map {[nil] * (n+1)}\n    (1..n).each do |u|\n        (1..n).each do |v|\n            if u == v\n                routing[u][v] = u\n            else\n                routing[u][v] = (1..n).min_by do |w|\n                    if w == u || d_mat[u][w] == Float::INFINITY\n                        [Float::INFINITY, -1]\n                    else\n                        [d_mat[u][w] + dist[w][v], w]\n                    end\n                end\n            end\n        end\n    end\n\n    event_queue = Heap.new\n    at_home = Hash.new(true)\n\n    hash = (0..n).map { {} }\n    queue = (0..n).map { [] }\n\n    l = gets.to_i\n    l.times do\n        u, v, t, name = gets.chomp.split\n        event_queue.add([:new, name, u.to_i, v.to_i], t.to_i)\n    end\n\n    until event_queue.empty?\n        t0 = event_queue.min_key\n        while ! event_queue.empty? && event_queue.min_key == t0\n            event, _ = event_queue.del_min\n            case event[0]\n            when :new\n                _, name, from, orig_to = event\n                to = routing[from][orig_to]\n                if hash[from][to]\n                    hash[from][to] << [orig_to, name]\n                else\n                    queue[from] << to\n                    hash[from][to] = [[orig_to, name]]\n                end\n            when :return\n                _, u = event\n                at_home[u] = true\n            when :arrival\n                _, name, to, orig_to = event\n                if to == orig_to\n                    ans[-1] << [name, t0]\n                else\n                    next_to = routing[to][orig_to]\n                    if hash[to][next_to]\n                        hash[to][next_to] << [orig_to, name]\n                    else\n                        queue[to] << next_to\n                        hash[to][next_to] = [[orig_to, name]]\n                    end\n                end\n            end\n        end\n\n        (1..n).map do |from|\n            next if ! at_home[from]\n            next if queue[from].empty?\n            to = queue[from].shift\n            hash[from][to].each do |orig_to, name|\n                event = [:arrival, name, to, orig_to]\n                t = t0 + d_mat[from][to]\n                event_queue.add(event, t)\n            end\n            hash[from].delete(to)\n\n            at_home[from] = false\n            event = [:return, from]\n            t = t0 + 2 * d_mat[from][to]\n            event_queue.add(event, t)\n        end\n    end\nend\n\nputs ans.map {|a| a.sort_by {|name, t| [t, name]}.map{|name, t| \"#{name} #{t}\"}.join(\"\\n\")}.join(\"\\n\\n\")"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\ndef warshall_floyd(dist_matrix)\n\tdist = dist_matrix\n\tn = dist.size\n\traise \"dist_matrix is not square\" if dist.any?{|row| row.size != n}\n\n\tnext_dist = (1..n).map{ Array.new(n) }\n\t(0..n-1).each{|k|\n\t\tdist_k = dist[k]\n\t\t(0..n-1).each{|i|\n\t\t\tdist_i = dist[i]\n\t\t\tnext_dist_i = next_dist[i]\n\t\t\t(0..n-1).each{|j|\n\t\t\t\tx = dist_i[j]\n\t\t\t\ty = dist_i[k] + dist_k[j]\n\t\t\t\tnext_dist_i[j] = (x < y ? x : y)\n\t\t\t}\n\t\t}\n\t\tdist = next_dist\n\t}\n\tdist\nend\n\nans = []\nloop do\n    n, m = gets.split.map(&:to_i)\n    break if n == 0\n    ans << []\n\n    d_mat = (0..n).map {(0..n).map {Float::INFINITY}}\n    (1..n).map {|i| d_mat[i][i] = 0}\n    m.times do\n        i, j, d = gets.split.map(&:to_i)\n        d_mat[i][j] = d_mat[j][i] = d\n    end\n    dist = warshall_floyd(d_mat)\n\n    routing = (0..n).map {[nil] * (n+1)}\n    (1..n).each do |u|\n        (1..n).each do |v|\n            if u == v\n                routing[u][v] = u\n            else\n                routing[u][v] = (1..n).min_by do |w|\n                    if w == u || d_mat[u][w] == Float::INFINITY\n                        [Float::INFINITY, -1]\n                    else\n                        [d_mat[u][w] + dist[w][v], w]\n                    end\n                end\n            end\n        end\n    end\n\n    event_queue = Heap.new\n    at_home = Hash.new(true)\n\n    hash = (0..n).map { {} }\n    queue = (0..n).map { Heap.new }\n\n    l = gets.to_i\n    l.times do\n        u, v, t, name = gets.chomp.split\n        event_queue.add([:new, name, u.to_i, v.to_i], t.to_i)\n    end\n\n    until event_queue.empty?\n        t0 = event_queue.min_key\n        while ! event_queue.empty? && event_queue.min_key == t0\n            event, _ = event_queue.del_min\n            case event[0]\n            when :new\n                _, name, from, orig_to = event\n                to = routing[from][orig_to]\n                if hash[from][to]\n                    hash[from][to] << [orig_to, name]\n                else\n                    queue[from].add(to, [t0, to])\n                    hash[from][to] = [[orig_to, name]]\n                end\n            when :return\n                _, u = event\n                at_home[u] = true\n            when :arrival\n                _, name, to, orig_to = event\n                if to == orig_to\n                    ans[-1] << [name, t0]\n                else\n                    next_to = routing[to][orig_to]\n                    if hash[to][next_to]\n                        hash[to][next_to] << [orig_to, name]\n                    else\n                        queue[to].add(next_to, [t0, next_to])\n                        hash[to][next_to] = [[orig_to, name]]\n                    end\n                end\n            end\n        end\n\n        (1..n).map do |from|\n            next if ! at_home[from]\n            next if queue[from].empty?\n            to, _ = queue[from].del_min\n            hash[from][to].each do |orig_to, name|\n                event = [:arrival, name, to, orig_to]\n                t = t0 + d_mat[from][to]\n                event_queue.add(event, t)\n            end\n            hash[from].delete(to)\n\n            at_home[from] = false\n            event = [:return, from]\n            t = t0 + 2 * d_mat[from][to]\n            event_queue.add(event, t)\n        end\n    end\nend\n\nputs ans.map {|a| a.sort_by {|name, t| [t, name]}.map{|name, t| \"#{name} #{t}\"}.join(\"\\n\")}.join(\"\\n\\n\")"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from sys import stdin\n    f_i = stdin\n    \n    ans = ''\n    \n    while True:\n        n, m = map(int, f_i.readline().split())\n        if n == 0:\n            break\n        \n        # prep for warshall-floyd algorithm\n        inf = 10000 * 31 + 1\n        dist = [[inf] * n for i in range(n)]\n        for i in range(n):\n            dist[i][i] = 0\n        \n        for i in range(m):\n            s, t, d = map(int, f_i.readline().split())\n            s -= 1\n            t -= 1\n            dist[s][t] = d\n            dist[t][s] = d\n        \n        # table for path reconstruction\n        next_p = [list(range(n)) for i in range(n)]\n        \n        # Warshall-Floyd algorithm\n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    d_ikj = dist[i][k] + dist[k][j]\n                    d_ij = dist[i][j]\n                    if d_ikj < d_ij:\n                        dist[i][j] = d_ikj\n                        next_p[i][j] = next_p[i][k]\n                    # for restore the smallest path in lexicographic order\n                    elif k != i and d_ikj == d_ij:\n                        if next_p[i][k] < next_p[i][j]:\n                            next_p[i][j] = next_p[i][k]\n        \n        l = int(f_i.readline())\n        paths = []\n        mails = set()\n        messages = []\n        goals = []\n        for i in range(l):\n            start, goal, at, msg = f_i.readline().split()\n            start = int(start) - 1\n            goal = int(goal) - 1\n            at = int(at)\n            messages.append(msg)\n            goals.append(goal)\n            \n            # path reconstruction\n            path = []\n            cur = start\n            while cur != goal:\n                path.append(cur)\n                cur = next_p[cur][goal]\n            path.append(goal)\n            \n            paths.append(path)\n            # mail: (time, arrivalTime, next, cur, number)\n            mails.add((at, at, path[1], start, i))\n        \n        step = [1] * l\n        deliv_time = [0] * n\n        \n        # mail forwarding\n        tmp_ans = []\n        while mails:\n            t, at, nxt, cur, num = min(mails)\n            \n            to_forward = set(filter(lambda x: x[0] == t and x[2] == nxt and x[3] == cur, mails))\n            mails = mails.difference(to_forward)\n            \n            dt = deliv_time[cur]\n            # transferable\n            if t >= dt:\n                cost = dist[cur][nxt]\n                new_t = t + cost\n                for t, at, nxt, cur, num in to_forward:\n                    if nxt == goals[num]:\n                        tmp_ans.append((new_t, messages[num]))\n                    else:\n                        step[num] += 1\n                        new_nxt = paths[num][step[num]]\n                        mails.add((new_t, new_t, new_nxt, nxt, num))\n                deliv_time[cur] = t + cost * 2\n            # non-transferable\n            else:\n                for t, at, nxt, cur, num in to_forward:\n                    mails.add((dt, at, nxt, cur, num))\n        \n        tmp_ans.sort()\n        tmp_ans = (f\"{label} {time}\" for time, label in tmp_ans)\n        ans += '\\n'.join(tmp_ans) + '\\n\\n'\n    \n    print(ans.rstrip())\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop, heapify\nfrom collections import defaultdict\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve(q):\n    N, M = map(int, readline().split())\n    if N == M == 0:\n        return False\n    if q:\n        write(\"\\n\")\n    INF = 10**18\n    G = [[] for i in range(N)]\n    E = [[INF]*N for i in range(N)]\n    for i in range(M):\n        a, b, c = map(int, readline().split())\n        G[a-1].append((b-1, c))\n        G[b-1].append((a-1, c))\n        E[a-1][b-1] = E[b-1][a-1] = c\n    prv = [-1]*N\n    L = int(readline())\n    P = []; R = []; I = [0]*L\n    B = [0]*L\n    que = []\n    for i in range(L):\n        a, b, c, s = readline().strip().split()\n        P.append(s)\n        a = int(a)-1; b = int(b)-1; c = int(c)\n        dist = [INF] * N\n        dist[b] = 0\n        que1 = [(0, b)]\n        while que1:\n            cost, v = heappop(que1)\n            if dist[v] < cost:\n                continue\n            for w, d in G[v]:\n                r = cost + d\n                if r < dist[w]:\n                    dist[w] = r\n                    prv[w] = v\n                    heappush(que1, (r, w))\n                elif r == dist[w]:\n                    prv[w] = min(prv[w], v)\n        rt = []\n        B[i] = b\n        v = a\n        while v != b:\n            rt.append(v)\n            v = prv[v]\n        rt.append(b)\n        R.append(rt)\n        que.append((c, 1, i))\n    heapify(que)\n    res = [0]*L\n    QS = [[] for i in range(N)]; rest = L\n    D = [defaultdict(list) for i in range(N)]\n    F = [{} for i in range(N)]\n    U = [1]*N\n    while rest:\n        t = que[0][0]\n        while que and que[0][0] == t:\n            _, p, i = heappop(que)\n            if p:\n                v = R[i][I[i]]\n                I[i] += 1\n                if B[i] == v:\n                    rest -= 1\n                    res[i] = t\n                else:\n                    w = R[i][I[i]]\n                    heappush(QS[v], (t, w, i))\n                    D[v][w].append(i)\n                    F[v][i] = 0\n            else:\n                U[i] = 1\n        for v in range(N):\n            if QS[v]:\n                qv = QS[v]\n                while qv and F[v][qv[0][2]]:\n                    heappop(qv)\n            if not U[v] or not QS[v]:\n                continue\n            _, w, k = heappop(QS[v])\n            d = E[v][w]\n            for k0 in D[v][w]:\n                F[v][k0] = 1\n                heappush(que, (t+d, 1, k0))\n            D[v][w] = []\n            heappush(que, (t+d+d, 0, v))\n            U[v] = 0\n    ans = []\n    for i in range(L):\n        ans.append((res[i], P[i]))\n    ans.sort()\n    for e, s in ans:\n        write(\"%s %d\\n\" % (s, e))\n    return True\nq = 0\nwhile solve(q):\n    q += 1\n"
  }
]