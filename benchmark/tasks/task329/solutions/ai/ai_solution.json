[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_OFFICES 1000\n#define MAX_MAIL 10000\n\ntypedef struct {\n    int dest;\n    int time;\n} Edge;\n\ntypedef struct {\n    Edge edges[MAX_OFFICES];\n    int edge_count;\n} Office;\n\ntypedef struct {\n    int src;\n    int dest;\n    int arrival_time;\n    int id;\n} MailItem;\n\ntypedef struct {\n    MailItem items[MAX_MAIL];\n    int count;\n} MailQueue;\n\nOffice offices[MAX_OFFICES];\nMailQueue office_queues[MAX_OFFICES];\nint delivery_time[MAX_MAIL];\nint carrier_busy_until[MAX_OFFICES];\nint dist[MAX_OFFICES];\nint prev[MAX_OFFICES];\nint visited[MAX_OFFICES];\n\nvoid init() {\n    for (int i = 0; i < MAX_OFFICES; i++) {\n        offices[i].edge_count = 0;\n        office_queues[i].count = 0;\n        carrier_busy_until[i] = 0;\n    }\n    memset(delivery_time, -1, sizeof(delivery_time));\n}\n\nvoid add_edge(int src, int dest, int time) {\n    offices[src].edges[offices[src].edge_count].dest = dest;\n    offices[src].edges[offices[src].edge_count].time = time;\n    offices[src].edge_count++;\n}\n\nvoid dijkstra(int start, int n) {\n    for (int i = 0; i < n; i++) {\n        dist[i] = INT_MAX;\n        prev[i] = -1;\n        visited[i] = 0;\n    }\n    dist[start] = 0;\n\n    for (int i = 0; i < n; i++) {\n        int u = -1;\n        for (int j = 0; j < n; j++) {\n            if (!visited[j] && (u == -1 || dist[j] < dist[u])) {\n                u = j;\n            }\n        }\n        if (u == -1 || dist[u] == INT_MAX) break;\n        visited[u] = 1;\n\n        for (int k = 0; k < offices[u].edge_count; k++) {\n            int v = offices[u].edges[k].dest;\n            int time = offices[u].edges[k].time;\n            if (dist[v] > dist[u] + time || (dist[v] == dist[u] + time && u < prev[v])) {\n                dist[v] = dist[u] + time;\n                prev[v] = u;\n            }\n        }\n    }\n}\n\nvoid get_path(int dest, int *path, int *path_len) {\n    int temp_path[MAX_OFFICES];\n    int len = 0;\n    int current = dest;\n    while (current != -1) {\n        temp_path[len++] = current;\n        current = prev[current];\n    }\n    *path_len = len;\n    for (int i = 0; i < len; i++) {\n        path[i] = temp_path[len - 1 - i];\n    }\n}\n\nvoid simulate(int n, int m) {\n    int time = 0;\n    int delivered = 0;\n    while (delivered < m) {\n        int processed = 0;\n        for (int i = 0; i < n; i++) {\n            if (office_queues[i].count > 0 && carrier_busy_until[i] <= time) {\n                MailItem item = office_queues[i].items[0];\n                if (item.dest == i) {\n                    delivery_time[item.id] = time;\n                    delivered++;\n                } else {\n                    dijkstra(i, n);\n                    int path[MAX_OFFICES], path_len;\n                    get_path(item.dest, path, &path_len);\n                    if (path_len > 1) {\n                        int next_office = path[1];\n                        int travel_time = 0;\n                        for (int k = 0; k < offices[i].edge_count; k++) {\n                            if (offices[i].edges[k].dest == next_office) {\n                                travel_time = offices[i].edges[k].time;\n                                break;\n                            }\n                        }\n                        carrier_busy_until[i] = time + 2 * travel_time;\n                        for (int j = 0; j < office_queues[next_office].count; j++) {\n                            if (office_queues[next_office].items[j].id == item.id) {\n                                office_queues[next_office].items[j].arrival_time = time + travel_time;\n                                break;\n                            }\n                        }\n                    }\n                }\n                for (int j = 0; j < office_queues[i].count - 1; j++) {\n                    office_queues[i].items[j] = office_queues[i].items[j + 1];\n                }\n                office_queues[i].count--;\n                processed = 1;\n                break;\n            }\n        }\n        if (!processed) time++;\n    }\n}\n\nint main() {\n    init();\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        int u, v, t;\n        scanf(\"%d %d %d\", &u, &v, &t);\n        add_edge(u, v, t);\n        add_edge(v, u, t);\n    }\n    int k;\n    scanf(\"%d\", &k);\n    for (int i = 0; i < k; i++) {\n        int src, dest, arrival;\n        scanf(\"%d %d %d\", &src, &dest, &arrival);\n        MailItem item;\n        item.src = src;\n        item.dest = dest;\n        item.arrival_time = arrival;\n        item.id = i;\n        office_queues[src].items[office_queues[src].count++] = item;\n    }\n    simulate(n, k);\n    for (int i = 0; i < k; i++) {\n        printf(\"%d\\n\", delivery_time[i]);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:06:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Mail {\n    int id;\n    int source;\n    int destination;\n    int arrival_time;\n    int departure_time;\n    int delivery_time;\n    \n    bool operator<(const Mail& other) const {\n        return arrival_time > other.arrival_time;\n    }\n};\n\nstruct PostOffice {\n    int id;\n    priority_queue<Mail> mail_queue;\n    int carrier_available_time;\n    vector<pair<int, int>> neighbors; // neighbor and distance\n};\n\nvector<int> dijkstra(int start, const vector<PostOffice>& offices) {\n    int n = offices.size();\n    vector<int> dist(n, INT_MAX);\n    vector<int> prev(n, -1);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    \n    dist[start] = 0;\n    pq.push({0, start});\n    \n    while (!pq.empty()) {\n        int current_dist = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n        \n        if (current_dist > dist[u]) continue;\n        \n        for (const auto& neighbor : offices[u].neighbors) {\n            int v = neighbor.first;\n            int weight = neighbor.second;\n            if (dist[v] > dist[u] + weight) {\n                dist[v] = dist[u] + weight;\n                prev[v] = u;\n                pq.push({dist[v], v});\n            }\n            else if (dist[v] == dist[u] + weight && u < prev[v]) {\n                prev[v] = u;\n            }\n        }\n    }\n    \n    return prev;\n}\n\nvector<int> get_path(int source, int destination, const vector<int>& prev) {\n    vector<int> path;\n    for (int v = destination; v != -1; v = prev[v]) {\n        path.push_back(v);\n    }\n    reverse(path.begin(), path.end());\n    if (path.empty() || path[0] != source) return {};\n    return path;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<PostOffice> offices(N);\n    for (int i = 0; i < N; ++i) {\n        offices[i].id = i;\n        offices[i].carrier_available_time = 0;\n    }\n    \n    for (int i = 0; i < M; ++i) {\n        int u, v, d;\n        cin >> u >> v >> d;\n        offices[u].neighbors.push_back({v, d});\n        offices[v].neighbors.push_back({u, d});\n    }\n    \n    int K;\n    cin >> K;\n    vector<Mail> mails(K);\n    for (int i = 0; i < K; ++i) {\n        cin >> mails[i].source >> mails[i].destination >> mails[i].arrival_time;\n        mails[i].id = i;\n        mails[i].departure_time = -1;\n        mails[i].delivery_time = -1;\n    }\n    \n    for (auto& mail : mails) {\n        vector<int> prev = dijkstra(mail.source, offices);\n        vector<int> path = get_path(mail.source, mail.destination, prev);\n        \n        if (path.empty()) {\n            mail.delivery_time = -1;\n            continue;\n        }\n        \n        int current_office = mail.source;\n        int current_time = mail.arrival_time;\n        \n        for (size_t i = 1; i < path.size(); ++i) {\n            int next_office = path[i];\n            int distance = 0;\n            for (const auto& neighbor : offices[current_office].neighbors) {\n                if (neighbor.first == next_office) {\n                    distance = neighbor.second;\n                    break;\n                }\n            }\n            \n            PostOffice& office = offices[current_office];\n            if (current_time >= office.carrier_available_time) {\n                office.carrier_available_time = current_time + distance;\n                current_time += distance;\n                current_office = next_office;\n            } else {\n                mail.delivery_time = -1;\n                break;\n            }\n        }\n        \n        if (current_office == mail.destination && mail.delivery_time == -1) {\n            mail.delivery_time = current_time;\n        }\n    }\n    \n    for (const auto& mail : mails) {\n        cout << mail.delivery_time << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:07:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass PostOffice {\n    int id;\n    PriorityQueue<Mail> mailQueue;\n    boolean isCarrierPresent;\n\n    PostOffice(int id) {\n        this.id = id;\n        this.mailQueue = new PriorityQueue<>((a, b) -> {\n            if (a.arrivalTime != b.arrivalTime) {\n                return a.arrivalTime - b.arrivalTime;\n            } else {\n                return a.id - b.id;\n            }\n        });\n        this.isCarrierPresent = true;\n    }\n}\n\nclass Mail {\n    int id;\n    int arrivalTime;\n    int source;\n    int destination;\n    int deliveryTime;\n\n    Mail(int id, int arrivalTime, int source, int destination) {\n        this.id = id;\n        this.arrivalTime = arrivalTime;\n        this.source = source;\n        this.destination = destination;\n        this.deliveryTime = -1;\n    }\n}\n\npublic class PostalSystem {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int K = scanner.nextInt();\n\n        Map<Integer, PostOffice> offices = new HashMap<>();\n        for (int i = 1; i <= N; i++) {\n            offices.put(i, new PostOffice(i));\n        }\n\n        Map<Integer, List<int[]>> graph = new HashMap<>();\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int w = scanner.nextInt();\n            graph.computeIfAbsent(u, k -> new ArrayList<>()).add(new int[]{v, w});\n            graph.computeIfAbsent(v, k -> new ArrayList<>()).add(new int[]{u, w});\n        }\n\n        List<Mail> mails = new ArrayList<>();\n        for (int i = 0; i < K; i++) {\n            int arrivalTime = scanner.nextInt();\n            int source = scanner.nextInt();\n            int destination = scanner.nextInt();\n            Mail mail = new Mail(i + 1, arrivalTime, source, destination);\n            mails.add(mail);\n            offices.get(source).mailQueue.add(mail);\n        }\n\n        PriorityQueue<int[]> eventQueue = new PriorityQueue<>((a, b) -> {\n            if (a[0] != b[0]) {\n                return a[0] - b[0];\n            } else {\n                return a[1] - b[1];\n            }\n        });\n\n        for (Mail mail : mails) {\n            eventQueue.add(new int[]{mail.arrivalTime, 0, mail.source});\n        }\n\n        while (!eventQueue.isEmpty()) {\n            int[] event = eventQueue.poll();\n            int currentTime = event[0];\n            int eventType = event[1];\n            int officeId = event[2];\n            PostOffice office = offices.get(officeId);\n\n            if (eventType == 0) {\n                if (office.isCarrierPresent) {\n                    eventQueue.add(new int[]{currentTime, 1, officeId});\n                }\n            } else if (eventType == 1) {\n                if (!office.mailQueue.isEmpty()) {\n                    Mail mail = office.mailQueue.poll();\n                    if (mail.destination == officeId) {\n                        mail.deliveryTime = currentTime;\n                    } else {\n                        office.isCarrierPresent = false;\n                        int nextOffice = findNextOffice(graph, officeId, mail.destination);\n                        int travelTime = getTravelTime(graph, officeId, nextOffice);\n                        eventQueue.add(new int[]{currentTime + travelTime, 2, nextOffice, officeId, mail.id});\n                    }\n                    eventQueue.add(new int[]{currentTime, 1, officeId});\n                }\n            } else if (eventType == 2) {\n                int prevOfficeId = event[3];\n                int mailId = event[4];\n                Mail mail = mails.get(mailId - 1);\n                PostOffice prevOffice = offices.get(prevOfficeId);\n                PostOffice currentOffice = offices.get(officeId);\n\n                currentOffice.mailQueue.add(mail);\n                prevOffice.isCarrierPresent = true;\n                eventQueue.add(new int[]{currentTime, 1, officeId});\n                eventQueue.add(new int[]{currentTime, 0, prevOfficeId});\n            }\n        }\n\n        for (Mail mail : mails) {\n            System.out.println(mail.deliveryTime);\n        }\n    }\n\n    private static int findNextOffice(Map<Integer, List<int[]>> graph, int source, int destination) {\n        Map<Integer, Integer> distances = new HashMap<>();\n        Map<Integer, Integer> previous = new HashMap<>();\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n\n        for (int node : graph.keySet()) {\n            distances.put(node, Integer.MAX_VALUE);\n        }\n        distances.put(source, 0);\n        pq.add(new int[]{source, 0});\n\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int u = current[0];\n            int dist = current[1];\n\n            if (u == destination) {\n                break;\n            }\n\n            if (dist > distances.get(u)) {\n                continue;\n            }\n\n            for (int[] edge : graph.get(u)) {\n                int v = edge[0];\n                int w = edge[1];\n                if (dist + w < distances.get(v)) {\n                    distances.put(v, dist + w);\n                    previous.put(v, u);\n                    pq.add(new int[]{v, distances.get(v)});\n                } else if (dist + w == distances.get(v) && u < previous.get(v)) {\n                    previous.put(v, u);\n                }\n            }\n        }\n\n        int current = destination;\n        while (previous.get(current) != source) {\n            current = previous.get(current);\n        }\n        return current;\n    }\n\n    private static int getTravelTime(Map<Integer, List<int[]>> graph, int u, int v) {\n        for (int[] edge : graph.get(u)) {\n            if (edge[0] == v) {\n                return edge[1];\n            }\n        }\n        return 0;\n    }\n}",
    "timestamp": "2025-08-05 21:08:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass PostOffice {\n    int number;\n    Queue<Mail> mailQueue;\n    boolean isCarrierAvailable;\n\n    public PostOffice(int number) {\n        this.number = number;\n        this.mailQueue = new PriorityQueue<>((a, b) -> {\n            if (a.arrivalTime == b.arrivalTime) {\n                return Integer.compare(a.id, b.id);\n            }\n            return Long.compare(a.arrivalTime, b.arrivalTime);\n        });\n        this.isCarrierAvailable = true;\n    }\n}\n\nclass Mail {\n    int id;\n    int source;\n    int destination;\n    long arrivalTime;\n\n    public Mail(int id, int source, int destination, long arrivalTime) {\n        this.id = id;\n        this.source = source;\n        this.destination = destination;\n        this.arrivalTime = arrivalTime;\n    }\n}\n\npublic class PostalSystemSimulation {\n    private Map<Integer, PostOffice> postOffices;\n    private Map<Integer, List<int[]>> forwardingPaths;\n    private List<Long> deliveryTimes;\n\n    public PostalSystemSimulation(int numOffices) {\n        postOffices = new HashMap<>();\n        forwardingPaths = new HashMap<>();\n        deliveryTimes = new ArrayList<>();\n\n        for (int i = 1; i <= numOffices; i++) {\n            postOffices.put(i, new PostOffice(i));\n            forwardingPaths.put(i, new ArrayList<>());\n        }\n    }\n\n    public void addForwardingPath(int source, int destination, int intermediate) {\n        forwardingPaths.get(source).add(new int[]{destination, intermediate});\n    }\n\n    public void sendMail(int id, int source, int destination, long arrivalTime) {\n        Mail mail = new Mail(id, source, destination, arrivalTime);\n        postOffices.get(source).mailQueue.offer(mail);\n    }\n\n    public void processMailRouting() {\n        while (true) {\n            boolean anyMailProcessed = false;\n\n            for (PostOffice office : postOffices.values()) {\n                if (!office.mailQueue.isEmpty() && office.isCarrierAvailable) {\n                    Mail currentMail = office.mailQueue.poll();\n                    office.isCarrierAvailable = false;\n\n                    if (currentMail.destination == office.number) {\n                        deliveryTimes.add(currentMail.arrivalTime);\n                        office.isCarrierAvailable = true;\n                        anyMailProcessed = true;\n                        continue;\n                    }\n\n                    List<int[]> possibleRoutes = forwardingPaths.get(office.number);\n                    int bestNextOffice = -1;\n                    int bestDistance = Integer.MAX_VALUE;\n\n                    for (int[] route : possibleRoutes) {\n                        if (route[0] == currentMail.destination) {\n                            if (bestNextOffice == -1 || route[1] < bestNextOffice) {\n                                bestNextOffice = route[1];\n                                bestDistance = 1;\n                            }\n                        }\n                    }\n\n                    if (bestNextOffice != -1) {\n                        currentMail.source = office.number;\n                        currentMail.arrivalTime++;\n                        postOffices.get(bestNextOffice).mailQueue.offer(currentMail);\n                        office.isCarrierAvailable = true;\n                        anyMailProcessed = true;\n                    }\n                }\n            }\n\n            if (!anyMailProcessed) break;\n        }\n    }\n\n    public List<Long> getDeliveryTimes() {\n        return deliveryTimes;\n    }\n}",
    "timestamp": "2025-08-05 21:08:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_OFFICES 100\n#define MAX_PATHS 10000\n#define MAX_MAIL 10000\n\ntypedef struct {\n    int source;\n    int dest;\n    int time;\n    int id;\n} Mail;\n\ntypedef struct {\n    int dest;\n    int next;\n} Path;\n\nPath paths[MAX_OFFICES][MAX_OFFICES];\nint n_offices, n_paths, n_mail;\nint carrier_time[MAX_OFFICES];\nMail mail_queue[MAX_MAIL];\nint delivered[MAX_MAIL];\n\nvoid initialize_paths() {\n    for (int i = 0; i < MAX_OFFICES; i++) {\n        for (int j = 0; j < MAX_OFFICES; j++) {\n            paths[i][j].dest = -1;\n            paths[i][j].next = -1;\n        }\n    }\n}\n\nvoid add_path(int src, int dest, int next) {\n    for (int i = 0; i < MAX_OFFICES; i++) {\n        if (paths[src][i].dest == -1) {\n            paths[src][i].dest = dest;\n            paths[src][i].next = next;\n            return;\n        }\n    }\n}\n\nint find_shortest_path(int src, int dest) {\n    if (src == dest) return src;\n    \n    for (int i = 0; i < MAX_OFFICES; i++) {\n        if (paths[src][i].dest == -1) break;\n        \n        if (paths[src][i].dest == dest) \n            return paths[src][i].next;\n    }\n    \n    return -1;\n}\n\nint compare_mail(const void* a, const void* b) {\n    Mail* mail_a = (Mail*)a;\n    Mail* mail_b = (Mail*)b;\n    \n    if (mail_a->time != mail_b->time)\n        return mail_a->time - mail_b->time;\n    \n    return mail_a->id - mail_b->id;\n}\n\nvoid simulate_mail_delivery() {\n    qsort(mail_queue, n_mail, sizeof(Mail), compare_mail);\n    \n    for (int i = 0; i < n_mail; i++) {\n        if (delivered[i]) continue;\n        \n        Mail* current_mail = &mail_queue[i];\n        int current_loc = current_mail->source;\n        \n        while (current_loc != current_mail->dest) {\n            if (carrier_time[current_loc] > current_mail->time) {\n                current_mail->time = carrier_time[current_loc];\n            }\n            \n            int next_office = find_shortest_path(current_loc, current_mail->dest);\n            \n            if (next_office == -1) break;\n            \n            carrier_time[current_loc] = current_mail->time + 1;\n            current_loc = next_office;\n        }\n        \n        if (current_loc == current_mail->dest) {\n            delivered[i] = 1;\n            carrier_time[current_loc] = current_mail->time + 1;\n            printf(\"%d %d %d\\n\", current_mail->id, current_mail->source, current_mail->time + 1);\n        }\n    }\n}\n\nint main() {\n    initialize_paths();\n    \n    scanf(\"%d %d %d\", &n_offices, &n_paths, &n_mail);\n    \n    for (int i = 0; i < n_paths; i++) {\n        int src, dest, next;\n        scanf(\"%d %d %d\", &src, &dest, &next);\n        add_path(src, dest, next);\n    }\n    \n    for (int i = 0; i < n_mail; i++) {\n        scanf(\"%d %d %d\", &mail_queue[i].id, &mail_queue[i].source, &mail_queue[i].time);\n        mail_queue[i].dest = mail_queue[i].source + 1;\n        delivered[i] = 0;\n    }\n    \n    simulate_mail_delivery();\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:08:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Mail {\n    int id, source, dest, time;\n    bool operator>(const Mail& other) const {\n        return time > other.time;\n    }\n};\n\nstruct PostOffice {\n    int carrierLocation = 0;\n    bool carrierAvailable = true;\n    priority_queue<Mail, vector<Mail>, greater<Mail>> pendingMail;\n};\n\nclass PostalSystem {\nprivate:\n    int offices;\n    vector<vector<pair<int, int>>> paths;\n    vector<PostOffice> postOffices;\n    vector<int> deliveryTimes;\n\n    int findShortestPath(int start, int end) {\n        vector<int> dist(offices, INT_MAX);\n        vector<int> prev(offices, -1);\n        dist[start] = 0;\n\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        pq.push({0, start});\n\n        while (!pq.empty()) {\n            int curr = pq.top().second;\n            pq.pop();\n\n            if (curr == end) break;\n\n            for (auto& [next, weight] : paths[curr]) {\n                int newDist = dist[curr] + weight;\n                if (newDist < dist[next] || (newDist == dist[next] && curr < prev[next])) {\n                    dist[next] = newDist;\n                    prev[next] = curr;\n                    pq.push({dist[next], next});\n                }\n            }\n        }\n\n        return dist[end];\n    }\n\npublic:\n    PostalSystem(int n) : offices(n), paths(n), postOffices(n), deliveryTimes(n, -1) {}\n\n    void addPath(int from, int to, int weight) {\n        paths[from].push_back({to, weight});\n        paths[to].push_back({from, weight});\n    }\n\n    void processMail(int mailId, int source, int dest, int time) {\n        int shortestPathLength = findShortestPath(source, dest);\n        \n        Mail mail = {mailId, source, dest, time};\n        PostOffice& sourceOffice = postOffices[source];\n\n        if (sourceOffice.carrierAvailable) {\n            sourceOffice.carrierAvailable = false;\n            sourceOffice.carrierLocation = dest;\n            deliveryTimes[mailId] = time + 2 * shortestPathLength;\n        } else {\n            sourceOffice.pendingMail.push(mail);\n        }\n    }\n\n    void checkMailDelivery(int currentTime) {\n        for (int i = 0; i < offices; i++) {\n            PostOffice& office = postOffices[i];\n            \n            if (!office.carrierAvailable && office.carrierLocation == i) {\n                office.carrierAvailable = true;\n            }\n\n            while (!office.pendingMail.empty() && office.carrierAvailable) {\n                Mail mail = office.pendingMail.top();\n                office.pendingMail.pop();\n\n                int shortestPathLength = findShortestPath(mail.source, mail.dest);\n                \n                office.carrierAvailable = false;\n                office.carrierLocation = mail.dest;\n                deliveryTimes[mail.id] = currentTime + 2 * shortestPathLength;\n            }\n        }\n    }\n\n    int getDeliveryTime(int mailId) {\n        return deliveryTimes[mailId];\n    }\n};\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    PostalSystem postalSystem(n);\n\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        postalSystem.addPath(u-1, v-1, w);\n    }\n\n    for (int i = 0; i < q; i++) {\n        int type;\n        cin >> type;\n\n        if (type == 1) {\n            int mailId, source, dest, time;\n            cin >> mailId >> source >> dest >> time;\n            postalSystem.processMail(mailId-1, source-1, dest-1, time);\n        } else {\n            int currentTime;\n            cin >> currentTime;\n            postalSystem.checkMailDelivery(currentTime);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:08:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\nfrom collections import defaultdict, deque\n\nclass PostOfficeSimulator:\n    def __init__(self, forwarding_paths, carriers_availability):\n        self.graph = defaultdict(list)\n        self.carriers_availability = carriers_availability\n        self.mail_queue = defaultdict(deque)\n        self.arrival_log = []\n        \n        for office1, office2 in forwarding_paths:\n            self.graph[office1].append(office2)\n            self.graph[office2].append(office1)\n            \n        for adj in self.graph.values():\n            adj.sort()\n\n    def add_mail_item(self, source, destination, arrival_time):\n        heapq.heappush(self.arrival_log, (arrival_time, source, destination))\n\n    def simulate_delivery(self):\n        timestamp = 0\n        deliveries = []\n\n        while self.arrival_log or any(self.mail_queue.values()):\n            timestamp += 1\n\n            # Process arrivals\n            while self.arrival_log and self.arrival_log[0][0] <= timestamp:\n                _, source, destination = heapq.heappop(self.arrival_log)\n                self.mail_queue[source].append((timestamp, destination))\n\n            # Process mail at each post office\n            for office in sorted(self.graph.keys()):\n                if self.carriers_availability[office] <= timestamp and self.mail_queue[office]:\n                    mail_time, destination = self.mail_queue[office].popleft()\n                    path = self.find_shortest_path(office, destination)\n                    deliveries.append((mail_time, destination, timestamp + len(path) - 1))\n                    self.mail_queue[destination].append((timestamp + len(path) - 1, destination))\n\n        return sorted(deliveries)\n\n    def find_shortest_path(self, start, end):\n        visited = set()\n        pq = [(0, start, [start])]\n        while pq:\n            cost, current, path = heapq.heappop(pq)\n            if current == end:\n                return path\n            if current in visited:\n                continue\n            visited.add(current)\n            for neighbor in self.graph[current]:\n                if neighbor not in visited:\n                    heapq.heappush(pq, (cost + 1, neighbor, path + [neighbor]))\n        return []\n\ndef simulate_post_offices(forwarding_paths, carriers_availability, mail_items):\n    simulator = PostOfficeSimulator(forwarding_paths, carriers_availability)\n    for arrival_time, source, destination in mail_items:\n        simulator.add_mail_item(source, destination, arrival_time)\n    return simulator.simulate_delivery()\n\n# Example usage:\nforwarding_paths = [(1, 2), (2, 3), (3, 4), (4, 5)]\ncarriers_availability = {1: 1, 2: 1, 3: 1, 4: 1, 5: 1}\nmail_items = [(1, 1, 5), (2, 1, 3), (3, 3, 5)]\ndeliveries = simulate_post_offices(forwarding_paths, carriers_availability, mail_items)\nprint(deliveries)",
    "timestamp": "2025-08-13 05:00:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class PostOfficeSimulation {\n    static class Mail {\n        int id;\n        int deliveryTime;\n        int destination;\n        \n        Mail(int id, int deliveryTime, int destination) {\n            this.id = id;\n            this.deliveryTime = deliveryTime;\n            this.destination = destination;\n        }\n    }\n    \n    static class PostOffice {\n        int number;\n        PriorityQueue<Mail> mailQueue;\n        \n        PostOffice(int number) {\n            this.number = number;\n            this.mailQueue = new PriorityQueue<>(Comparator.comparingInt(m -> m.deliveryTime));\n        }\n    }\n    \n    static class Edge {\n        int to, time;\n        \n        Edge(int to, int time) {\n            this.to = to;\n            this.time = time;\n        }\n    }\n    \n    static void simulateMailDelivery(int postOfficeCount, Map<Integer, List<Edge>> routes, List<Mail> mails) {\n        Map<Integer, PostOffice> postOffices = new HashMap<>();\n        for (int i = 0; i < postOfficeCount; i++) {\n            postOffices.put(i, new PostOffice(i));\n        }\n        \n        for (Mail mail : mails) {\n            postOffices.get(0).mailQueue.add(mail);\n        }\n\n        PriorityQueue<Mail> deliverySchedule = new PriorityQueue<>(Comparator.comparingInt(m -> m.deliveryTime));\n        \n        while (!postOffices.isEmpty()) {\n            for (int i = 0; i < postOfficeCount; i++) {\n                PostOffice postOffice = postOffices.get(i);\n                if (postOffice == null || postOffice.mailQueue.isEmpty()) continue;\n\n                Mail currentMail = postOffice.mailQueue.poll();\n                \n                if (i == currentMail.destination) {\n                    System.out.println(\"Mail ID \" + currentMail.id + \" delivered at time \" + currentMail.deliveryTime + \" to Post Office \" + i);\n                    deliverySchedule.add(currentMail);\n                } else {\n                    List<Edge> connections = routes.get(i);\n                    if (connections == null || connections.isEmpty()) continue;\n\n                    int minTime = Integer.MAX_VALUE;\n                    int nextOffice = -1;\n                    \n                    for (Edge edge : connections) {\n                        if (edge.time < minTime || (edge.time == minTime && edge.to < nextOffice)) {\n                            minTime = edge.time;\n                            nextOffice = edge.to;\n                        }\n                    }\n\n                    if (nextOffice >= 0) {\n                        currentMail.deliveryTime += minTime;\n                        postOffices.get(nextOffice).mailQueue.add(currentMail);\n                    }\n                }\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        int postOfficeCount = 3;\n        \n        Map<Integer, List<Edge>> routes = new HashMap<>();\n        routes.put(0, Arrays.asList(new Edge(1, 2), new Edge(2, 4)));\n        routes.put(1, Arrays.asList(new Edge(2, 2)));\n        \n        List<Mail> mails = Arrays.asList(\n            new Mail(1, 0, 2),\n            new Mail(2, 1, 1)\n        );\n        \n        simulateMailDelivery(postOfficeCount, routes, mails);\n    }\n}",
    "timestamp": "2025-08-13 05:00:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_OFFICES 100\n#define MAX_MAILS 1000\n\ntypedef struct {\n    int arrivalTime;\n    int source;\n    int destination;\n    int index; \n} Mail;\n\ntypedef struct {\n    int time;\n    int office;\n} Event;\n\ntypedef struct {\n    int from;\n    int to;\n    int time;\n} Path;\n\nint numOffices, numPaths, numMails;\nint officePaths[MAX_OFFICES][MAX_OFFICES];\nMail mails[MAX_MAILS];\nEvent events[MAX_MAILS];\nint eventCount = 0;\nbool isCarrierPresent[MAX_OFFICES];\n\nvoid addEvent(int time, int office) {\n    events[eventCount].time = time;\n    events[eventCount].office = office;\n    eventCount++;\n}\n\nint compareEvents(const void *a, const void *b) {\n    Event *eventA = (Event *)a;\n    Event *eventB = (Event *)b;\n    \n    if (eventA->time != eventB->time)\n        return eventA->time - eventB->time;\n    return eventA->office - eventB->office;\n}\n\nint compareMails(const void *a, const void *b) {\n    Mail *mailA = (Mail *)a;\n    Mail *mailB = (Mail *)b;\n    \n    if (mailA->arrivalTime != mailB->arrivalTime)\n        return mailA->arrivalTime - mailB->arrivalTime;\n    return mailA->index - mailB->index;\n}\n\nvoid dijkstra(int src, int dist[], int prev[]) {\n    bool visited[MAX_OFFICES] = { false };\n    for (int i = 0; i < MAX_OFFICES; i++) {\n        dist[i] = INT_MAX;\n        prev[i] = -1;\n    }\n    dist[src] = 0;\n\n    for (int i = 0; i < numOffices; i++) {\n        int u = -1;\n        for (int j = 0; j < numOffices; j++) {\n            if (!visited[j] && (u == -1 || dist[j] < dist[u])) {\n                u = j;\n            }\n        }\n\n        if (dist[u] == INT_MAX) break;\n        \n        visited[u] = true;\n        for (int v = 0; v < numOffices; v++) {\n            int weight = officePaths[u][v];\n            if (weight && dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                prev[v] = u;\n            }\n        }\n    }\n}\n\nvoid simulate() {\n    qsort(mails, numMails, sizeof(Mail), compareMails);\n\n    for (int i = 0; i < numOffices; i++) {\n        isCarrierPresent[i] = true;\n    }\n\n    for (int i = 0; i < numMails; i++) {\n        mails[i].arrivalTime = INT_MAX;\n    }\n    \n    for (int i = 0; i < numMails; i++) {\n        int dist[MAX_OFFICES], prev[MAX_OFFICES];\n        int source = mails[i].source;\n        int destination = mails[i].destination;\n        int arrivalTime = mails[i].arrivalTime;\n\n        dijkstra(source, dist, prev);\n\n        if (dist[destination] == INT_MAX) continue;\n\n        for(int current = destination; current != source; current = prev[current]) {\n            int next = prev[current];\n            if (isCarrierPresent[next] && arrivalTime <= mails[i].arrivalTime) {\n                isCarrierPresent[next] = false;\n                arrivalTime += officePaths[next][current];\n                addEvent(arrivalTime, next);\n            } else {\n                break;\n            }\n        }\n        \n        if (dist[destination] != INT_MAX) {\n            printf(\"Mail %d delivered at time %d\\n\", mails[i].index, arrivalTime);\n        }\n    }\n\n    qsort(events, eventCount, sizeof(Event), compareEvents);\n\n    for (int i = 0; i < eventCount; i++) {\n        isCarrierPresent[events[i].office] = true;\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &numOffices, &numPaths, &numMails);\n    \n    for (int i = 0; i < numOffices; i++) {\n        for (int j = 0; j < numOffices; j++) {\n            officePaths[i][j] = (i == j) ? 0 : INT_MAX;\n        }\n    }\n    \n    for (int i = 0; i < numPaths; i++) {\n        int from, to, time;\n        scanf(\"%d %d %d\", &from, &to, &time);\n        officePaths[from][to] = time;\n        officePaths[to][from] = time;\n    }\n    \n    for (int i = 0; i < numMails; i++) {\n        int arrivalTime, source, destination;\n        scanf(\"%d %d %d\", &arrivalTime, &source, &destination);\n        mails[i].arrivalTime = arrivalTime;\n        mails[i].source = source;\n        mails[i].destination = destination;\n        mails[i].index = i;\n    }\n    \n    simulate();\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 05:01:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappush, heappop\nfrom collections import defaultdict\n\nclass PostOffice:\n    def __init__(self, num_offices):\n        self.graph = defaultdict(list)\n        self.carrier_available = [True] * (num_offices + 1)\n        self.mail_queue = defaultdict(list)\n        self.delivered_mail = []\n\n    def add_path(self, source, dest, distance):\n        self.graph[source].append((dest, distance))\n        self.graph[dest].append((source, distance))\n\n    def dijkstra(self, start, end):\n        distances = [float('inf')] * (len(self.graph) + 1)\n        predecessors = [None] * (len(self.graph) + 1)\n        distances[start] = 0\n        pq = [(0, start)]\n\n        while pq:\n            current_dist, current_node = heappop(pq)\n            \n            if current_node == end:\n                break\n            \n            if current_dist > distances[current_node]:\n                continue\n            \n            for neighbor, weight in self.graph[current_node]:\n                distance = current_dist + weight\n                \n                if distance < distances[neighbor] or (distance == distances[neighbor] and current_node < predecessors[neighbor]):\n                    distances[neighbor] = distance\n                    predecessors[neighbor] = current_node\n                    heappush(pq, (distance, neighbor))\n        \n        path = []\n        current = end\n        while current is not None:\n            path.append(current)\n            current = predecessors[current]\n        \n        return list(reversed(path)), distances[end]\n\n    def send_mail(self, source, dest, timestamp):\n        self.mail_queue[source].append((timestamp, dest))\n\n    def process_mail(self):\n        for source in sorted(self.mail_queue.keys()):\n            self.mail_queue[source].sort()\n            while self.mail_queue[source]:\n                timestamp, dest = self.mail_queue[source][0]\n                \n                if source == dest:\n                    self.delivered_mail.append((timestamp, source, dest))\n                    heappop(self.mail_queue[source])\n                    continue\n                \n                if not self.carrier_available[source]:\n                    break\n                \n                path, distance = self.dijkstra(source, dest)\n                \n                if len(path) > 1:\n                    next_office = path[1]\n                    self.carrier_available[source] = False\n                    delivery_time = timestamp + distance\n                    \n                    self.delivered_mail.append((delivery_time, source, dest))\n                    heappop(self.mail_queue[source])\n                    \n                    self.send_mail(next_office, dest, delivery_time)\n                    self.carrier_available[source] = True\n                else:\n                    break\n\ndef main():\n    num_offices, num_paths, num_mails = map(int, input().split())\n    \n    post_system = PostOffice(num_offices)\n    \n    for _ in range(num_paths):\n        x, y, z = map(int, input().split())\n        post_system.add_path(x, y, z)\n    \n    for _ in range(num_mails):\n        s, d, t = map(int, input().split())\n        post_system.send_mail(s, d, t)\n    \n    post_system.process_mail()\n    \n    post_system.delivered_mail.sort()\n    \n    for delivery in post_system.delivered_mail:\n        print(*delivery)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:01:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef simulate_mail_delivery(post_offices, mail_items):\n    # Build adjacency list for the post offices\n    adjacency = {}\n    for src, dest, time in post_offices:\n        if src not in adjacency:\n            adjacency[src] = []\n        adjacency[src].append((dest, time))\n    \n    # Dijkstra's algorithm to find shortest paths\n    def dijkstra(start):\n        heap = []\n        heapq.heappush(heap, (0, start))\n        distances = {start: (0, start)}\n        while heap:\n            current_dist, current_po = heapq.heappop(heap)\n            if current_po not in adjacency:\n                continue\n            for neighbor, time in adjacency[current_po]:\n                distance = current_dist + time\n                if neighbor not in distances or (distance, neighbor) < distances[neighbor]:\n                    distances[neighbor] = (distance, neighbor)\n                    heapq.heappush(heap, (distance, neighbor))\n        return distances\n    \n    # Precompute all shortest paths\n    shortest_paths = {}\n    for po in adjacency.keys():\n        shortest_paths[po] = dijkstra(po)\n    \n    # Initialize carrier availability and mail queues\n    carrier_available = {}\n    mail_queues = {}\n    for po in adjacency.keys():\n        carrier_available[po] = 0\n        mail_queues[po] = []\n    \n    # Process mail items in order of arrival\n    mail_items.sort(key=lambda x: x[1])\n    delivery_times = {}\n    \n    for src, dest, arrival_time in mail_items:\n        if src not in shortest_paths or dest not in shortest_paths[src]:\n            delivery_times[(src, dest, arrival_time)] = -1\n            continue\n        \n        distance, _ = shortest_paths[src][dest]\n        heapq.heappush(mail_queues[src], (arrival_time, distance, dest))\n    \n    # Simulate the mail delivery process\n    current_time = 0\n    while True:\n        # Find the next event (carrier becoming available)\n        next_time = None\n        for po in carrier_available:\n            if carrier_available[po] > current_time:\n                if next_time is None or carrier_available[po] < next_time:\n                    next_time = carrier_available[po]\n        \n        if next_time is None:\n            break\n        \n        current_time = next_time\n        \n        # Process all offices where carriers become available at current_time\n        for po in carrier_available:\n            if carrier_available[po] == current_time and mail_queues[po]:\n                # Get the oldest mail item\n                arrival_time, distance, dest = heapq.heappop(mail_queues[po])\n                delivery_time = current_time + distance\n                delivery_times[(po, dest, arrival_time)] = delivery_time\n                carrier_available[po] = delivery_time\n    \n    # Prepare the output in the order of input mail items\n    output = []\n    for item in mail_items:\n        src, dest, arrival_time = item\n        output.append(delivery_times.get((src, dest, arrival_time), -1))\n    \n    return output",
    "timestamp": "2025-08-13 05:01:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <tuple>\n#include <set>\n\nusing namespace std;\n\nstruct MailItem {\n    int arrivalTime;\n    int source;\n    int destination;\n    int index;\n    bool operator<(const MailItem &m) const {\n        return arrivalTime > m.arrivalTime || (arrivalTime == m.arrivalTime && index > m.index);\n    }\n};\n\nusing Graph = vector<vector<pair<int, int>>>; // (destination, travelTime)\n\nvector<int> dijkstra(int start, const Graph &graph, int n) {\n    vector<int> dist(n, INT_MAX);\n    dist[start] = 0;\n    set<pair<int, int>> pq; // (distance, node)\n    pq.insert({0, start});\n\n    while (!pq.empty()) {\n        auto [d, u] = *pq.begin();\n        pq.erase(pq.begin());\n\n        if (dist[u] < d) continue;\n\n        for (auto &[v, w] : graph[u]) {\n            if (dist[u] + w < dist[v] || (dist[u] + w == dist[v] && u < v)) {\n                pq.erase({dist[v], v});\n                dist[v] = dist[u] + w;\n                pq.insert({dist[v], v});\n            }\n        }\n    }\n\n    return dist;\n}\n\nint main() {\n    int numPostOffices, numForwardPaths, numMailItems;\n    cin >> numPostOffices >> numForwardPaths >> numMailItems;\n\n    Graph graph(numPostOffices);\n\n    for (int i = 0; i < numForwardPaths; ++i) {\n        int u, v, t;\n        cin >> u >> v >> t;\n        graph[u].emplace_back(v, t);\n        graph[v].emplace_back(u, t);\n    }\n\n    priority_queue<MailItem> mailQueue;\n    for (int i = 0; i < numMailItems; ++i) {\n        int arrivalTime, source, destination;\n        cin >> arrivalTime >> source >> destination;\n        mailQueue.push({arrivalTime, source, destination, i});\n    }\n\n    vector<int> carriersReturnTime(numPostOffices, 0);\n    vector<int> result(numMailItems, -1);\n\n    while (!mailQueue.empty()) {\n        auto mail = mailQueue.top();\n        mailQueue.pop();\n\n        int currentTime = mail.arrivalTime;\n        int source = mail.source;\n\n        if (carriersReturnTime[source] > currentTime) {\n            mailQueue.push({carriersReturnTime[source], source, mail.destination, mail.index});\n            continue;\n        }\n\n        vector<int> distances = dijkstra(source, graph, numPostOffices);\n        int deliveryTime = currentTime + distances[mail.destination];\n        result[mail.index] = deliveryTime;\n\n        carriersReturnTime[source] = deliveryTime;\n    }\n\n    for (int i = 0; i < numMailItems; ++i) {\n        cout << result[i] << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:22:35"
  }
]