[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross_product(Point p1, Point p2, Point p3) {\n    return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\n\nbool do_intersect(Point p1, Point p2, Point p3, Point p4) {\n    double cp1 = cross_product(p1, p2, p3);\n    double cp2 = cross_product(p1, p2, p4);\n    double cp3 = cross_product(p3, p4, p1);\n    double cp4 = cross_product(p3, p4, p2);\n\n    if (cp1 * cp2 < 0 && cp3 * cp4 < 0) return true;\n    return false;\n}\n\nPoint get_intersection(Point p1, Point p2, Point p3, Point p4) {\n    Point intersection;\n    double x1 = p1.x, y1 = p1.y;\n    double x2 = p2.x, y2 = p2.y;\n    double x3 = p3.x, y3 = p3.y;\n    double x4 = p4.x, y4 = p4.y;\n\n    double denom = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n    double ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;\n\n    intersection.x = x1 + ua * (x2 - x1);\n    intersection.y = y1 + ua * (y2 - y1);\n\n    return intersection;\n}\n\nint main() {\n    Point p0, p1, p2, p3;\n    \n    scanf(\"%lf %lf\", &p0.x, &p0.y);\n    scanf(\"%lf %lf\", &p1.x, &p1.y);\n    scanf(\"%lf %lf\", &p2.x, &p2.y);\n    scanf(\"%lf %lf\", &p3.x, &p3.y);\n\n    if (do_intersect(p0, p1, p2, p3)) {\n        Point intersection = get_intersection(p0, p1, p2, p3);\n        printf(\"Intersection point: (%.2f, %.2f)\\n\", intersection.x, intersection.y);\n    } else {\n        printf(\"No intersection\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:14:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\nint ccw(Point a, Point b, Point c) {\n    double area = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    if (area > 0) return 1;\n    if (area < 0) return -1;\n    return 0;\n}\n\nint intersect(Point p0, Point p1, Point p2, Point p3) {\n    int ccw1 = ccw(p0, p1, p2);\n    int ccw2 = ccw(p0, p1, p3);\n    int ccw3 = ccw(p2, p3, p0);\n    int ccw4 = ccw(p2, p3, p1);\n\n    if ((ccw1 * ccw2 < 0) && (ccw3 * ccw4 < 0)) return 1;\n\n    if (ccw1 == 0 && ccw2 == 0 && ccw3 == 0 && ccw4 == 0) {\n        if (p0.x == p1.x) {\n            if (p0.y > p1.y) { Point temp = p0; p0 = p1; p1 = temp; }\n            if (p2.y > p3.y) { Point temp = p2; p2 = p3; p3 = temp; }\n            return !(p1.y < p2.y || p3.y < p0.y);\n        } else {\n            if (p0.x > p1.x) { Point temp = p0; p0 = p1; p1 = temp; }\n            if (p2.x > p3.x) { Point temp = p2; p2 = p3; p3 = temp; }\n            return !(p1.x < p2.x || p3.x < p0.x);\n        }\n    }\n\n    if (ccw1 == 0 && (p2.x >= fmin(p0.x, p1.x) && p2.x <= fmax(p0.x, p1.x)) && (p2.y >= fmin(p0.y, p1.y) && p2.y <= fmax(p0.y, p1.y))) return 1;\n    if (ccw2 == 0 && (p3.x >= fmin(p0.x, p1.x) && p3.x <= fmax(p0.x, p1.x)) && (p3.y >= fmin(p0.y, p1.y) && p3.y <= fmax(p0.y, p1.y))) return 1;\n    if (ccw3 == 0 && (p0.x >= fmin(p2.x, p3.x) && p0.x <= fmax(p2.x, p3.x)) && (p0.y >= fmin(p2.y, p3.y) && p0.y <= fmax(p2.y, p3.y))) return 1;\n    if (ccw4 == 0 && (p1.x >= fmin(p2.x, p3.x) && p1.x <= fmax(p2.x, p3.x)) && (p1.y >= fmin(p2.y, p3.y) && p1.y <= fmax(p2.y, p3.y))) return 1;\n\n    return 0;\n}\n\nvoid findIntersection(Point p0, Point p1, Point p2, Point p3) {\n    double a1 = p1.y - p0.y;\n    double b1 = p0.x - p1.x;\n    double c1 = a1 * p0.x + b1 * p0.y;\n\n    double a2 = p3.y - p2.y;\n    double b2 = p2.x - p3.x;\n    double c2 = a2 * p2.x + b2 * p2.y;\n\n    double det = a1 * b2 - a2 * b1;\n\n    if (det == 0) {\n        printf(\"The line segments are parallel or coincident.\\n\");\n    } else {\n        double x = (b2 * c1 - b1 * c2) / det;\n        double y = (a1 * c2 - a2 * c1) / det;\n\n        printf(\"%.6f %.6f\\n\", x, y);\n    }\n}\n\nint main() {\n    Point p0, p1, p2, p3;\n    scanf(\"%lf %lf %lf %lf\", &p0.x, &p0.y, &p1.x, &p1.y);\n    scanf(\"%lf %lf %lf %lf\", &p2.x, &p2.y, &p3.x, &p3.y);\n\n    if (intersect(p0, p1, p2, p3)) {\n        findIntersection(p0, p1, p2, p3);\n    } else {\n        printf(\"The line segments do not intersect.\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:15:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\nbool onSegment(Point p, Point q, Point r) {\n    if (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&\n        q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y))\n        return true;\n    return false;\n}\n\nint orientation(Point p, Point q, Point r) {\n    double val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0;\n    return (val > 0) ? 1 : 2;\n}\n\nbool doIntersect(Point p1, Point q1, Point p2, Point q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    if (o1 != o2 && o3 != o4)\n        return true;\n\n    if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n    if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n    if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n    if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false;\n}\n\nvoid findIntersection(Point p1, Point p2, Point p3, Point p4) {\n    double a1 = p2.y - p1.y;\n    double b1 = p1.x - p2.x;\n    double c1 = a1 * p1.x + b1 * p1.y;\n\n    double a2 = p4.y - p3.y;\n    double b2 = p3.x - p4.x;\n    double c2 = a2 * p3.x + b2 * p3.y;\n\n    double determinant = a1 * b2 - a2 * b1;\n\n    if (determinant == 0) {\n        cout << \"The segments are parallel or collinear.\" << endl;\n    } else {\n        double x = (b2 * c1 - b1 * c2) / determinant;\n        double y = (a1 * c2 - a2 * c1) / determinant;\n\n        if (onSegment(p1, {x, y}, p2) && onSegment(p3, {x, y}, p4)) {\n            cout << x << \" \" << y << endl;\n        } else {\n            cout << \"The segments do not intersect.\" << endl;\n        }\n    }\n}\n\nint main() {\n    double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n    cin >> xp0 >> yp0 >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3;\n\n    Point p0 = {xp0, yp0};\n    Point p1 = {xp1, yp1};\n    Point p2 = {xp2, yp2};\n    Point p3 = {xp3, yp3};\n\n    if (doIntersect(p0, p1, p2, p3)) {\n        findIntersection(p0, p1, p2, p3);\n    } else {\n        cout << \"The segments do not intersect.\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:16:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class LineSegmentIntersection {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static Point findIntersection(Point p0, Point p1, Point p2, Point p3) {\n        double a1 = p1.y - p0.y;\n        double b1 = p0.x - p1.x;\n        double c1 = a1 * p0.x + b1 * p0.y;\n\n        double a2 = p3.y - p2.y;\n        double b2 = p2.x - p3.x;\n        double c2 = a2 * p2.x + b2 * p2.y;\n\n        double determinant = a1 * b2 - a2 * b1;\n\n        if (determinant == 0) {\n            return null;\n        } else {\n            double x = (b2 * c1 - b1 * c2) / determinant;\n            double y = (a1 * c2 - a2 * c1) / determinant;\n\n            if (isOnSegment(p0, p1, x, y) && isOnSegment(p2, p3, x, y)) {\n                return new Point(x, y);\n            } else {\n                return null;\n            }\n        }\n    }\n\n    static boolean isOnSegment(Point p, Point q, double x, double y) {\n        double minX = Math.min(p.x, q.x);\n        double maxX = Math.max(p.x, q.x);\n        double minY = Math.min(p.y, q.y);\n        double maxY = Math.max(p.y, q.y);\n        return (x >= minX - 1e-10 && x <= maxX + 1e-10) && (y >= minY - 1e-10 && y <= maxY + 1e-10);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        double xp0 = scanner.nextDouble();\n        double yp0 = scanner.nextDouble();\n        double xp1 = scanner.nextDouble();\n        double yp1 = scanner.nextDouble();\n        double xp2 = scanner.nextDouble();\n        double yp2 = scanner.nextDouble();\n        double xp3 = scanner.nextDouble();\n        double yp3 = scanner.nextDouble();\n\n        Point p0 = new Point(xp0, yp0);\n        Point p1 = new Point(xp1, yp1);\n        Point p2 = new Point(xp2, yp2);\n        Point p3 = new Point(xp3, yp3);\n\n        Point intersection = findIntersection(p0, p1, p2, p3);\n        if (intersection != null) {\n            System.out.printf(\"%.2f %.2f\\n\", intersection.x, intersection.y);\n        } else {\n            System.out.println(\"No intersection\");\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:16:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class LineIntersection {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        double xp0 = scanner.nextDouble();\n        double yp0 = scanner.nextDouble();\n        double xp1 = scanner.nextDouble();\n        double yp1 = scanner.nextDouble();\n        double xp2 = scanner.nextDouble();\n        double yp2 = scanner.nextDouble();\n        double xp3 = scanner.nextDouble();\n        double yp3 = scanner.nextDouble();\n        \n        double[] intersection = findIntersection(xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3);\n        \n        if (intersection == null) {\n            System.out.println(\"No intersection\");\n        } else {\n            System.out.printf(\"%.6f %.6f%n\", intersection[0], intersection[1]);\n        }\n        \n        scanner.close();\n    }\n    \n    public static double[] findIntersection(double x1, double y1, double x2, double y2, \n                                             double x3, double y3, double x4, double y4) {\n        double det = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        \n        if (Math.abs(det) < 1e-9) {\n            return null;\n        }\n        \n        double t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / det;\n        double u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / det;\n        \n        if (t < 0 || t > 1 || u < 0 || u > 1) {\n            return null;\n        }\n        \n        double x = x1 + t * (x2 - x1);\n        double y = y1 + t * (y2 - y1);\n        \n        return new double[]{x, y};\n    }\n}",
    "timestamp": "2025-08-05 22:16:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\nPoint findIntersection(double xp0, double yp0, double xp1, double yp1, \n                       double xp2, double yp2, double xp3, double yp3) {\n    double x1 = xp0, y1 = yp0, x2 = xp1, y2 = yp1;\n    double x3 = xp2, y3 = yp2, x4 = xp3, y4 = yp3;\n    \n    double denom = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n    \n    if (abs(denom) < 1e-9) {\n        return {-1, -1}; // No intersection\n    }\n    \n    double ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;\n    double ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;\n    \n    if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n        return {-1, -1}; // Intersection outside line segments\n    }\n    \n    double x = x1 + ua * (x2 - x1);\n    double y = y1 + ua * (y2 - y1);\n    \n    return {x, y};\n}\n\nint main() {\n    double xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3;\n    \n    cin >> xp0 >> yp0 >> xp1 >> yp1;\n    cin >> xp2 >> yp2 >> xp3 >> yp3;\n    \n    Point intersection = findIntersection(xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3);\n    \n    if (intersection.x == -1 && intersection.y == -1) {\n        cout << \"No intersection\" << endl;\n    } else {\n        cout << fixed << setprecision(2) \n             << intersection.x << \" \" \n             << intersection.y << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:16:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def line_segment_intersection(p0, p1, p2, p3):\n    # Helper function to calculate the cross product\n    def cross(v1, v2):\n        return v1[0] * v2[1] - v1[1] * v2[0]\n\n    # Convert points to vectors\n    d1 = (p1[0] - p0[0], p1[1] - p0[1])  # Direction vector of s1\n    d2 = (p3[0] - p2[0], p3[1] - p2[1])  # Direction vector of s2\n    delta = (p2[0] - p0[0], p2[1] - p0[1])\n\n    cross_d1_d2 = cross(d1, d2)\n    cross_delta_d1 = cross(delta, d1)\n    cross_delta_d2 = cross(delta, d2)\n\n    if cross_d1_d2 == 0:\n        return None\n\n    t = cross_delta_d2 / cross_d1_d2\n    u = cross_delta_d1 / cross_d1_d2\n\n    if 0 <= t <= 1 and 0 <= u <= 1:\n        intersection_x = p0[0] + t * d1[0]\n        intersection_y = p0[1] + t * d1[1]\n        return (intersection_x, intersection_y)\n    else:\n        return None\n\n# Example usage:\np0 = (0, 0)\np1 = (4, 4)\np2 = (0, 4)\np3 = (4, 0)\nintersection_point = line_segment_intersection(p0, p1, p2, p3)\nprint(intersection_point)",
    "timestamp": "2025-08-13 09:38:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class LineSegmentIntersection {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        double xp0 = scanner.nextDouble();\n        double yp0 = scanner.nextDouble();\n        double xp1 = scanner.nextDouble();\n        double yp1 = scanner.nextDouble();\n        double xp2 = scanner.nextDouble();\n        double yp2 = scanner.nextDouble();\n        double xp3 = scanner.nextDouble();\n        double yp3 = scanner.nextDouble();\n        \n        double denominator = (xp0 - xp1) * (yp2 - yp3) - (yp0 - yp1) * (xp2 - xp3);\n        \n        if (denominator == 0) {\n            System.out.println(\"No intersection point\");\n        } else {\n            double x = ((xp0 * yp1 - yp0 * xp1) * (xp2 - xp3) - (xp0 - xp1) * (xp2 * yp3 - yp2 * xp3)) / denominator;\n            double y = ((xp0 * yp1 - yp0 * xp1) * (yp2 - yp3) - (yp0 - yp1) * (xp2 * yp3 - yp2 * xp3)) / denominator;\n            \n            if (isBetween(x, y, xp0, yp0, xp1, yp1) && isBetween(x, y, xp2, yp2, xp3, yp3)) {\n                System.out.println(\"Intersection point: (\" + x + \", \" + y + \")\");\n            } else {\n                System.out.println(\"No intersection point within the segments\");\n            }\n        }\n\n        scanner.close();\n    }\n\n    private static boolean isBetween(double x, double y, double x1, double y1, double x2, double y2) {\n        return x >= Math.min(x1, x2) && x <= Math.max(x1, x2) && \n               y >= Math.min(y1, y2) && y <= Math.max(y1, y2);\n    }\n}",
    "timestamp": "2025-08-13 09:39:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\nint onSegment(Point p, Point q, Point r) {\n    if (q.x <= fmax(p.x, r.x) && q.x >= fmin(p.x, r.x) && \n        q.y <= fmax(p.y, r.y) && q.y >= fmin(p.y, r.y)) {\n        return 1;\n    }\n    return 0;\n}\n\nint orientation(Point p, Point q, Point r) {\n    double val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0;\n    return (val > 0) ? 1 : 2;\n}\n\nint doIntersect(Point p1, Point q1, Point p2, Point q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    return (o1 != o2 && o3 != o4) ||\n          (o1 == 0 && onSegment(p1, p2, q1)) ||\n          (o2 == 0 && onSegment(p1, q2, q1)) ||\n          (o3 == 0 && onSegment(p2, p1, q2)) ||\n          (o4 == 0 && onSegment(p2, q1, q2));\n}\n\nPoint getIntersection(Point p1, Point q1, Point p2, Point q2) {\n    double A1 = q1.y - p1.y;\n    double B1 = p1.x - q1.x;\n    double C1 = A1 * p1.x + B1 * p1.y;\n\n    double A2 = q2.y - p2.y;\n    double B2 = p2.x - q2.x;\n    double C2 = A2 * p2.x + B2 * p2.y;\n\n    double determinant = A1 * B2 - A2 * B1;\n\n    Point intersection;\n    intersection.x = (B2 * C1 - B1 * C2) / determinant;\n    intersection.y = (A1 * C2 - A2 * C1) / determinant;\n    return intersection;\n}\n\nint main() {\n    Point p0, p1, p2, p3;\n    \n    // Input: values for endpoints p0, p1, p2, p3 must be set here\n    // Example assignment:\n    // p0.x = 1; p0.y = 1;\n    // p1.x = 4; p1.y = 4;\n    // p2.x = 1; p2.y = 8;\n    // p3.x = 2; p3.y = 4;\n\n    if (doIntersect(p0, p1, p2, p3)) {\n        Point intersection = getIntersection(p0, p1, p2, p3);\n        printf(\"Intersection Point: (%lf, %lf)\\n\", intersection.x, intersection.y);\n    } else {\n        printf(\"No Intersection\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 09:39:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def line_intersection(xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3):\n    # Calculate the direction vectors for the line segments\n    dx1 = xp1 - xp0\n    dy1 = yp1 - yp0\n    dx2 = xp3 - xp2\n    dy2 = yp3 - yp2\n\n    # Calculate the cross product denominator\n    denominator = dx1 * dy2 - dy1 * dx2\n\n    # Check if lines are parallel\n    if denominator == 0:\n        return None\n\n    # Calculate t and u parameters\n    t = ((xp2 - xp0) * dy2 - (yp2 - yp0) * dx2) / denominator\n    u = ((xp2 - xp0) * dy1 - (yp2 - yp0) * dx1) / denominator\n\n    # Check if intersection point is within both line segments\n    if 0 <= t <= 1 and 0 <= u <= 1:\n        x = xp0 + t * dx1\n        y = yp0 + t * dy1\n        return x, y\n\n    return None\n\n# Example usage\nxp0, yp0 = map(float, input().split())\nxp1, yp1 = map(float, input().split())\nxp2, yp2 = map(float, input().split())\nxp3, yp3 = map(float, input().split())\n\nresult = line_intersection(xp0, yp0, xp1, yp1, xp2, yp2, xp3, yp3)\nif result:\n    print(f\"{result[0]:.6f} {result[1]:.6f}\")\nelse:\n    print(\"No intersection\")",
    "timestamp": "2025-08-13 09:39:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_intersection(p0, p1, p2, p3):\n    xp0, yp0 = p0\n    xp1, yp1 = p1\n    xp2, yp2 = p2\n    xp3, yp3 = p3\n\n    def ccw(A, B, C):\n        return (C[1]-A[1])*(B[0]-A[0]) - (B[1]-A[1])*(C[0]-A[0])\n\n    A1 = yp1 - yp0\n    B1 = xp0 - xp1\n    C1 = A1 * xp0 + B1 * yp0\n\n    A2 = yp3 - yp2\n    B2 = xp2 - xp3\n    C2 = A2 * xp2 + B2 * yp2\n\n    determinant = A1 * B2 - A2 * B1\n\n    if determinant == 0:\n        return None\n    else:\n        x = (B2 * C1 - B1 * C2) / determinant\n        y = (A1 * C2 - A2 * C1) / determinant\n\n        if (min(xp0, xp1) <= x <= max(xp0, xp1) and min(yp0, yp1) <= y <= max(yp0, yp1) and\n            min(xp2, xp3) <= x <= max(xp2, xp3) and min(yp2, yp3) <= y <= max(yp2, yp3)):\n            return (x, y)\n        else:\n            return None\n\np0 = tuple(map(float, input().split()))\np1 = tuple(map(float, input().split()))\np2 = tuple(map(float, input().split()))\np3 = tuple(map(float, input().split()))\n\nresult = find_intersection(p0, p1, p2, p3)\nif result:\n    print(' '.join(map(str, result)))\nelse:\n    print(\"none\")",
    "timestamp": "2025-08-13 09:39:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <iomanip>\n\nstruct Point {\n    double x, y;\n};\n\nbool onSegment(Point p, Point q, Point r) {\n    return q.x <= std::max(p.x, r.x) && q.x >= std::min(p.x, r.x) &&\n           q.y <= std::max(p.y, r.y) && q.y >= std::min(p.y, r.y);\n}\n\nint orientation(Point p, Point q, Point r) {\n    double val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0)\n        return 0; // collinear\n    return (val > 0) ? 1 : 2; // clock or counterclock wise\n}\n\nbool doIntersect(Point p1, Point q1, Point p2, Point q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    return (o1 != o2 && o3 != o4) ||\n           (o1 == 0 && onSegment(p1, p2, q1)) ||\n           (o2 == 0 && onSegment(p1, q2, q1)) ||\n           (o3 == 0 && onSegment(p2, p1, q2)) ||\n           (o4 == 0 && onSegment(p2, q1, q2));\n}\n\nPoint intersectionPoint(Point p1, Point q1, Point p2, Point q2) {\n    double A1 = q1.y - p1.y;\n    double B1 = p1.x - q1.x;\n    double C1 = A1 * (p1.x) + B1 * (p1.y);\n\n    double A2 = q2.y - p2.y;\n    double B2 = p2.x - q2.x;\n    double C2 = A2 * (p2.x) + B2 * (p2.y);\n\n    double determinant = A1 * B2 - A2 * B1;\n\n    double x = (B2 * C1 - B1 * C2) / determinant;\n    double y = (A1 * C2 - A2 * C1) / determinant;\n\n    return {x, y};\n}\n\nint main() {\n    Point p0, p1, p2, p3;\n    std::cin >> p0.x >> p0.y >> p1.x >> p1.y;\n    std::cin >> p2.x >> p2.y >> p3.x >> p3.y;\n\n    if (doIntersect(p0, p1, p2, p3)) {\n        Point intersection = intersectionPoint(p0, p1, p2, p3);\n        std::cout << std::fixed << std::setprecision(6) \n                  << intersection.x << \" \" << intersection.y << std::endl;\n    } else {\n        std::cout << \"No Intersection\" << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:53:22"
  }
]