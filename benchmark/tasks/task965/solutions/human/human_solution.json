[
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint power(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxn = (int) 1e5 + 10;\npair<int, int> tosort[maxn];\n\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    tosort[i] = mp(x, y);\n  }\n  return 1;\n}\n\nvoid solve() {\n  if (tosort[0].first || tosort[1].second) {\n    printf(\"-1\\n\");\n    return;\n  }\n  map<pair<int, int>, int> cnt;\n  for (int i = 0; i < n; ++i) {\n    int x = tosort[i].first;\n    int y = tosort[i].second;\n    if (i != 0 && !x) {\n      printf(\"-1\\n\");\n      return;\n    }\n    if (i != 1 && !y) {\n      printf(\"-1\\n\");\n      return;\n    }\n    cnt[{x, y}] += 1;\n    tosort[i] = {x + y, x};\n  }\n  sort(tosort, tosort + n);\n\n  int res = 2 * n - 2;\n  for (int i = 0; i < n;) {\n    int i0 = i;\n    while (i < n && tosort[i].first == tosort[i0].first) {\n      int x = tosort[i].first, y = tosort[i].second;\n      x -= y;\n\n      for (int iter = 0; iter < 2; ++iter) {\n        auto &cur = (!iter ? x : y);\n        if (!cur) {\n          continue;\n        }\n        auto &cury = (iter ? x : y);\n        --cur;\n        bool ok = 0;\n        for (int dx = -1; dx <= 1; ++dx) {\n          cury += dx;\n          if (cnt.count({x, y})) {\n            ok = 1;\n          }\n          cury -= dx;\n        }\n        ++cur;\n        if (!ok) {\n          printf(\"-1\\n\");\n          return;\n        }\n      }\n      ++i;\n    }\n\n    int last = 0, left = 0;\n    for (int j = i0; j < i;) {\n      int j0 = j;\n      while (j < i && tosort[j].second == tosort[j0].second) {\n        ++j;\n      }\n      int now = j - j0;\n\n      int del = 0;\n      if (last + 1 == tosort[j0].second) {\n        del = min(now, left);\n        res -= del;\n      }\n      if (cnt.count({tosort[j0].first - tosort[j0].second - 1, tosort[j0].second - 1})) {\n        res -= now - del;\n        now = del;\n      }\n      left = now;\n      last = tosort[j0].second;\n    }\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <set>\nusing namespace std;\n\nint N, A[101010], B[101010];\n\nvoid fail()\n{\n\tputs(\"-1\");\n\texit(0);\n}\n\nint bas[101010];\nset<pair<int, int> > P;\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i) scanf(\"%d%d\", A + i, B + i);\n\n\tif (A[0] != 0) fail();\n\tif (B[1] != 0) fail();\n\tif (A[1] != B[0]) fail();\n\tint D = A[1];\n//\tputs(\"x\");\n\tfor (int i = 2; i < N; ++i) {\n\t\tif (A[i] == 0 || B[i] == 0 || A[i] + B[i] < D) fail();\n\t}\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (A[i] + B[i] == D) {\n\t\t\tbas[A[i]] += 1;\n\t\t}\n\t}\n//\tputs(\"y\");\n\n\tint ret = 0;\n\tfor (int i = 0; i < D; ++i) {\n\t\tif (bas[i] == 0) fail();\n\t\tret += max(bas[i], bas[i + 1]);\n\t}\n//\tputs(\"z\");\n\n\tfor (int i = 0; i < N; ++i) P.insert(make_pair(A[i], B[i]));\n\tfor (int i = 2; i < N; ++i) if (A[i] + B[i] != D) {\n\t\tint x = A[i], y = B[i];\n\t\tif (P.count(make_pair(x - 1, y - 1))) {\n\t\t\t++ret;\n\t\t} else if (P.count(make_pair(x, y - 1)) || P.count(make_pair(x - 1, y))) {\n\t\t\tret += 2;\n\t\t} else fail();\n\t}\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#define pii pair<int,int>\nint n, chk[101000], cnt, m;\nusing namespace std;\nstruct point {\n\tint x, y, num;\n\tbool operator<(const point &p)const {\n\t\treturn x + y != p.x + p.y ? x+y < p.x+p.y : x<p.x;\n\t}\n}P[101000], U[101000];\nint A[101000], B[101000], res, D[101000][2], first = 1;\nvector<int>G[101000];\nmap<pii, int>Map;\nint Get(int x, int y) {\n\tif (Map.count({ x,y }))return Map[{x, y}];\n\treturn 0;\n}\nbool Go() {\n\tint i;\n\tif (first) {\n\t\tfirst = 0;\n\t\tfor (i = 1; i < m; i++) {\n\t\t\tint x = U[i].x, y = U[i].y;\n\t\t\tres += max(Get(x, y), Get(x + 1, y - 1));\n\t\t}\n\t\treturn true;\n\t}\n\tfor (i = 0; i <= m + 1; i++) {\n\t\tD[i][0] = D[i][1] = 1e9;\n\t}\n\tD[0][0] = 0;\n\tfor (i = 1; i <= m; i++) {\n\t\tint x = U[i].x, y = U[i].y;\n\t\tint ck1 = 0, ck2 = 0, ck3 = 0;\n\t\tif (Get(x-1,y-1)) ck1 = 1;\n\t\tif (Get(x-1,y)) ck2 = 1;\n\t\tif (Get(x,y-1)) ck3 = 1;\n\t\tif (ck1) {\n\t\t\tD[i][0] = min(D[i][0], D[i - 1][0] + Get(x, y));\n\t\t}\n\t\tif (ck2) {\n\t\t\tD[i][1] = min(D[i][1], D[i - 1][0] + Get(x, y));\n\t\t}\n\t\tif (ck2 &&ck3) {\n\t\t\tD[i][0] = min(D[i][0], D[i - 1][0] + Get(x, y) * 2);\n\t\t}\n\t\tif (i != 1) {\n\t\t\tD[i][1] = min(D[i][1], min(D[i - 1][0], D[i - 1][1]) + max(Get(x - 1, y + 1), Get(x, y)));\n\t\t}\n\t\tif (ck1 || ck3) {\n\t\t\tD[i][0] = min(D[i][0], D[i][1] + Get(x, y));\n\t\t}\n\t}\n\tif (D[m][0] > 1e8)return false;\n\tres += D[m][0];\n\treturn true;\n}\nint main() {\n\tint i, j;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\t\tP[i] = { A[i],B[i],i };\n\t\tMap[{A[i], B[i]}]++;\n\t}\n\tsort(P + 1, P + n + 1);\n\tif (A[1] != 0 || B[2] != 0 || A[2]!=B[1] || Get(A[1],B[1])!=1 || Get(A[2],B[2])!=1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tif (abs(A[i] - B[i]) > A[2]) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tG[Get(A[i], B[i])].push_back(i);\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tm = 0;\n\t\tU[++m] = P[i];\n\t\tfor (j = i+1; j <= n; j++) {\n\t\t\tif (abs(P[j].x - P[j - 1].x) > 1 || P[j].x + P[j].y != P[j - 1].x + P[j - 1].y)break;\n\t\t\tif (P[j].x != P[j - 1].x)U[++m] = P[j];\n\t\t}\n\t\tif (i == 1) {\n\t\t\tif (U[1].num != 1 || U[m].num != 2) {\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif (!Go()) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\ti = j - 1;\n\t}\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nvoid ng() {\n        printf(\"-1\\n\");\n        exit(0);\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<set<int>> ab(n), ba(n);\n        vector<pair<int, int>> p;\n        for (int i = 0; i < n; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                p.emplace_back(a, b);\n                ab[a].insert(b);\n                ba[b].insert(a);\n        }\n        if (p[0].first != 0 || p[1].second != 0) ng();\n        if (p[0].second != p[1].first) ng();\n        for (int i = 2; i < n; i ++) {\n                int a, b;\n                tie(a, b) = p[i];\n                cerr << a << ' ' << b << endl;\n                if (a == 0 || b == 0) ng();\n                if (ab[a - 1].count(b + 1) == 0 && ab[a - 1].count(b) == 0 && ab[a - 1].count(b - 1) == 0) ng();\n                if (ba[b - 1].count(a + 1) == 0 && ba[b - 1].count(a) == 0 && ba[b - 1].count(a - 1) == 0) ng();\n        }\n        ng();\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].two==shit[2].one&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    mp.clear();\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one&&shit[tk].two==shit[k].two){\n                tk++;\n            }\n            int now=tk-k;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                last=shit[k].one;\n                left=min(now,left);\n                continue;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n            bool one=0,two=0;\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n            if(shit[k].one==0)one=1;\n            if(shit[k].two==0) two=1;\n            if(one==0||two==0){\n                puts(\"-1\");\n                return 0;\n            }\n            if(last+1==shit[k].one){\n                ans-=min(now,left);\n            }\n            last=shit[k].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nvoid ng() {\n        printf(\"-1\\n\");\n        exit(0);\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        set<pair<int, int>> ps;\n        vector<pair<int, int>> p;\n        for (int i = 0; i < n; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                p.emplace_back(a, b);\n                ps.insert({a, b});\n        }\n        if (p[0].first != 0 || p[1].second != 0) ng();\n        if (p[0].second != p[1].first) ng();\n        if (p[0].second == 0) ng();\n        for (int i = 2; i < n; i ++) {\n                int a, b;\n                tie(a, b) = p[i];\n                if (a == 0 || b == 0) ng();\n                if (!ps.count({a - 1, b + 1}) && !ps.count({a - 1, b}) && !ps.count({a - 1, b - 1})) ng();\n                if (!ps.count({a + 1, b - 1}) && !ps.count({a, b - 1}) && !ps.count({a - 1, b - 1})) ng();\n        }\n        map<int, vector<pair<int, int>>> s;\n        for (int i = 0; i < n; i ++) {\n                s[p[i].first + p[i].second].emplace_back(p[i].first, p[i].second);\n        }\n        int matching = 0;\n        for (auto mp : s) {\n                vector<pair<int, int>> v = mp.second;\n                sort(v.begin(), v.end());\n                int cur = v[0].first;\n                vector<pair<bool, pair<int, int>>> t; //(bottom left exists, number of the same position)\n                for (int i = 0; i < (int) v.size(); i ++) {\n                        int cnt = 0;\n                        bool ex = ps.count({v[i].first - 1, v[i].second - 1});\n                        while (i < (int) v.size() && cur == v[i].first) {\n                                i ++;\n                                cnt ++;\n                        }\n                        i --;\n                        t.push_back({ex, {cnt, cnt}});\n                        cur ++;\n                }\n                for (int i = 0; i < (int) t.size(); i ++) {\n                        if (t[i].first) {\n                                int d = min(t[i].second.first, t[i].second.second);\n                                matching += d;\n                                t[i].second.first -= d;\n                                t[i].second.second -= d;\n                        }\n                        if (t[i].second.second > 0 && i + 1 < (int) t.size()) {\n                                int d = min(t[i].second.second, t[i + 1].second.first);\n                                matching += d;\n                                t[i + 1].second.first -= d;\n                        }\n                }\n        }\n        printf(\"%d\\n\", 2 * n - 2 - matching);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint nr, N, a[100009], b[100009], A[100009], B[100009], id[100009], sz[100009], may[100009], both1[100009], dp[100009][2];\nconst int INF = 1e8;\n\nbool cmp (int i, int j)\n{\n    if (A[i] + B[i] == A[j] + B[j]) return (A[i] < A[j]);\n    return (A[i] + B[i] < A[j] + B[j]);\n}\n\nint findPair (int x, int y)\n{\n    int p = 1, u = nr, mij;\n    while (p <= u)\n    {\n        mij = (p + u) >> 1;\n        if (a[mij] == x && b[mij] == y) return mij;\n        if (a[mij] + b[mij] < x + y || (a[mij] + b[mij] == x + y && a[mij] < x)) p = mij + 1;\n        else u = mij - 1;\n    }\n    return 0;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d\", &A[i], &B[i]), id[i] = i;\nsort (id + 1, id + N + 1, cmp);\nif (A[2] != B[1] || A[id[1]] + B[id[1]] < A[2] || A[1] != 0 || B[2] != 0)\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=N; i++)\n    if ((A[i] == 0 && i != 1) || (B[i] == 0 && i != 2))\n    {\n        printf (\"-1\\n\");\n        return 0;\n    }\nfor (int i=1; i<=N; i++)\n{\n    int j = i;\n    while (j + 1 <= N && A[id[j]] == A[id[j + 1]] && B[id[j]] == B[id[j + 1]])\n        j ++;\n    a[++nr] = A[id[i]], b[nr] = B[id[i]], sz[nr] = j - i + 1;\n    i = j;\n}\nfor (int i=1; i<=nr; i++)\n    may[i] = (findPair (a[i] + 1, b[i] - 1) != 0),\n    both1[i] = (findPair (a[i] - 1, b[i] - 1) != 0);\nif (!may[1])\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=nr; i++)\n    if ((a[i] > 0 && findPair (a[i] - 1, b[i]) == 0 && findPair (a[i] - 1, b[i] + 1) == 0 && both1[i] == 0) ||\n        (b[i] > 0 && findPair (a[i], b[i] - 1) == 0 && findPair (a[i] + 1, b[i] - 1) == 0 && both1[i] == 0))\n        {\n            printf (\"-1\\n\");\n            return 0;\n        }\nfor (int i=1; i<=nr; i++)\n    for (int j=0; j<2; j++)\n        dp[i][j] = INF;\ndp[1][1] = max (1, sz[2]);\nfor (int i=1; i<nr; i++)\n    for (int j=0; j<=may[i]; j++)\n        for (int k=0; k<=may[i + 1]; k++)\n        {\n            if (k == 0 && both1[i + 1] == 1)\n                dp[i + 1][k] = min (dp[i + 1][k], dp[i][j] + sz[i + 1]);\n            int curr = dp[i][j];\n            if (j == 0)\n            {\n                if (findPair (a[i + 1] - 1, b[i + 1]) == 0 && both1[i + 1] == 0) continue;\n                curr += sz[i + 1];\n            }\n            if (k == 0 && b[i + 1] > 0)\n                curr += sz[i + 1];\n            else\n            if (k == 1)\n            {\n                if (sz[i + 1] <= sz[i + 2] || both1[i + 1] == 0) curr += max (sz[i + 1], sz[i + 2]);\n                else curr += sz[i + 2] + sz[i + 1] * j;\n            }\n            if (curr < dp[i + 1][k])\n                dp[i + 1][k] = curr;\n        }\nprintf (\"%d\\n\", dp[nr][0]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    return a.one+a.two<b.one+b.two;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=0;\n    if(mn==1) ans++;\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+3,shit+n+1,cmp);\n    mp.clear();\n    mp[shit[1]]=1;\n    mp[shit[2]]=1;\n    for(int i=3;i<=n;i++)\n    {\n        int j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        if(shit[i].one+shit[i].two==mn){\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n                if(mp.count(tmp1)&&mp.count(tmp2)){\n                    ans+=2;\n                }\n                else{\n                    puts(\"-1\");\n                    return 0;\n                }\n            }\n        }\n        else{\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two-1;\n                if(mp.count(tmp1)){\n                    ans++;continue;\n                }\n                bool one=0,two=0;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                one=one|mp.count(tmp1);\n                tmp1.two--;\n                one=one|mp.count(tmp1);\n\n\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n                two=two|mp.count(tmp2);\n                tmp2.one--;\n                two=two|mp.count(tmp2);\n                if(one&&two){\n                    ans+=2;continue;\n                }\n                puts(\"-1\");\n                return 0;\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].two==shit[2].one&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    mp.clear();\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one){\n                tk++;\n            }\n            int now=tk-k;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                last=shit[k].one;\n                left=min(now,left);\n                continue;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n            bool one=0,two=0;\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n            if(shit[k].one==0)one=1;\n            if(shit[k].two==0) two=1;\n            if(one==0||two==0){\n                while(1);\n                puts(\"-1\");\n                return 0;\n            }\n            if(last+1==shit[k].one){\n                ans-=min(now,left);\n            }\n            last=shit[k].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 26.11.2019 22:59:30       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n  }\n  if (a[0] != 0 || b[1] != 0 || a[1] == 0 || a[1] != b[0]) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  int d = a[1];\n  vector<int> was(d + 1, 0);\n  for (int i = 0; i < n; i++) {\n    if ((i >= 2 && min(a[i], b[i]) == 0) || a[i] + b[i] < d) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    if (a[i] + b[i] == d) {\n      was[a[i]] = 1;\n    }\n  }\n  if (*min_element(was.begin(), was.end()) == 0) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  set<pair<int, int>> s;\n  for (int i = 0; i < n; i++) {\n    s.emplace(a[i], b[i]);\n  }\n  map<pair<int, int>, pair<int, int>> mp;\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (s.find({a[i] - 1, b[i] - 1}) != s.end()) {\n      ans += 1;\n      mp[make_pair(a[i], b[i])].second += 1;\n    } else {\n      ans += (a[i] > 0) + (b[i] > 0);\n      mp[make_pair(a[i], b[i])].first += 1;\n      if (a[i] > 0 && s.find({a[i] - 1, b[i]}) == s.end() && s.find({a[i] - 1, b[i] + 1}) == s.end()) {\n        cout << -1 << '\\n';\n        return 0;\n      }\n      if (b[i] > 0 && s.find({a[i], b[i] - 1}) == s.end() && s.find({a[i] + 1, b[i] - 1}) == s.end()) {\n        cout << -1 << '\\n';\n        return 0;\n      }\n    }\n  }\n  for (auto& p : mp) {\n    auto it = mp.find(make_pair(p.first.first + 1, p.first.second - 1));\n    if (it != mp.end()) {\n      ans -= min(p.second.first, it->second.first);\n      auto it2 = mp.find(make_pair(p.first.first - 1, p.first.second + 1));\n      if (it2 != mp.end()) {\n        int me = p.second.first;\n        int they = min(it->second.first, it2->second.first);\n        if (me < they) {\n          ans -= min(they - me, p.second.second);\n        }\n      }\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#define ll long long\n#define inf 1000000007\n#define inf16 0x3f3f3f3f\n#define INF 1000000000000000007LL\n#define VI vector<int>\n#define VPII vector<pair<int, int> >\n#define VLL vector<ll>\n#define PII pair<int, int>\n#define st first\n#define nd second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define endl '\\n'\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\nconst int N = 1e5+7;\n\nint n, ans;\n\nint A[N];\nint B[N];\n\nPII mB[N]; //maksymalne B dla danego A\nPII mA[N]; //maksymalne A dla danego B\n\nmap<PII, int> takie;\n\nVI G[N];\n\nqueue<int> Q;\n\nint dist[3][N];\n\nbool check()\n{\n\tfor(int i = 1; i <= 2; ++i)\n\t{\n\t\tfor(int v = 1; v <= n; ++v)\n\t\t{\n\t\t\tdist[i][v] = inf;\n\t\t}\n\n\t\tdist[i][i] = 0;\n\t\tQ.push(i);\n\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tint v = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tfor(auto it:G[v])\n\t\t\t{\n\t\t\t\tif(dist[i][it]>dist[i][v]+1)\n\t\t\t\t{\n\t\t\t\t\tdist[i][it] = dist[i][v]+1;\n\t\t\t\t\tQ.push(it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tif(A[i]!=dist[1][i])\n\t\t\treturn 0;\n\n\t\tif(B[i]!=dist[2][i])\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tcin >> n;\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> A[i] >> B[i];\n\t\ttakie[{A[i], B[i]}] = i;\n\t\tmB[A[i]] = max(mB[A[i]], mp(B[i], i));\n\t\tmA[B[i]] = max(mA[B[i]], mp(A[i], i));\n\t}\n\n\tif(A[2]!=B[1] || A[1] || B[2])\n\t{\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tif(A[2]==1)\n\t{\n\t\tG[1].pb(2);\n\t\tG[2].pb(1);\n\t\t++ans;\n\t}\n\n\tfor(int i = 3; i <= n; ++i)\n\t{\n\t\tif(takie.find({A[i]-1, B[i]-1})!=takie.end())\n\t\t{\n\t\t\tG[i].pb(takie[{A[i]-1, B[i]-1}]);\n\t\t\tG[takie[{A[i]-1, B[i]-1}]].pb(i);\n\t\t\t++ans;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(mB[A[i]-1].st>B[i]-1 && mA[B[i]-1].st>A[i]-1)\n\t\t\t{\n\t\t\t\tG[i].pb(mB[A[i]-1].nd);\n\t\t\t\tG[i].pb(mA[B[i]-1].nd);\n\t\t\t\tG[mB[A[i]-1].nd].pb(i);\n\t\t\t\tG[mA[B[i]-1].nd].pb(i);\n\t\t\t\tans += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!check())\n\t{\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nint N, A[101010], B[101010];\n\nvoid fail()\n{\n\tputs(\"-1\");\n\texit(0);\n}\n\nint bas[101010];\nmap<pair<int, int>, int> P;\n\nbool is_good(int y, int x)\n{\n\treturn P.count(make_pair(y - 1, x - 1)) > 0;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i) scanf(\"%d%d\", A + i, B + i);\n\n\tif (A[0] != 0) fail();\n\tif (B[1] != 0) fail();\n\tif (A[1] != B[0]) fail();\n\tint D = A[1];\n\n\tfor (int i = 2; i < N; ++i) {\n\t\tif (A[i] == 0 || B[i] == 0 || A[i] + B[i] < D) fail();\n\t}\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (A[i] + B[i] == D) {\n\t\t\tbas[A[i]] += 1;\n\t\t}\n\t}\n\n\tint ret = 0;\n\tfor (int i = 0; i < D; ++i) {\n\t\tif (bas[i] == 0) fail();\n\t\tret += max(bas[i], bas[i + 1]);\n\t}\n\n\tfor (int i = 0; i < N; ++i) P[make_pair(A[i], B[i])] += 1;\n\n\tfor (int i = 2; i < N; ++i) if (A[i] + B[i] != D) {\n\t\tint x = A[i], y = B[i];\n\t\tif (P.count(make_pair(x - 1, y - 1))) {\n\t\t\t++ret;\n\t\t} else if (P.count(make_pair(x, y - 1)) && P.count(make_pair(x - 1, y))) {\n\t\t\tret += 2;\n\t\t} else fail();\n\t}\n\tfor (map<pair<int, int>, int>::iterator p = P.begin(); p != P.end(); ++p) {\n\t\tint y = p->first.first, x = p->first.second;\n\t\tif (y + x == D) continue;\n\t\tif (P.count(make_pair(y, x)) && P.count(make_pair(y - 1, x + 1)) && !is_good(y, x) && !is_good(y - 1, x + 1)) {\n\t\t\tret -= min(P[make_pair(y, x)], P[make_pair(y - 1, x + 1)]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nvoid ng() {\n        printf(\"-1\\n\");\n        exit(0);\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        set<pair<int, int>> ps;\n        vector<pair<int, int>> p;\n        for (int i = 0; i < n; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                p.emplace_back(a, b);\n                ps.insert({a, b});\n        }\n        if (p[0].first != 0 || p[1].second != 0) ng();\n        if (p[0].second != p[1].first) ng();\n        if (p[0].second == 0) ng();\n        for (int i = 2; i < n; i ++) {\n                int a, b;\n                tie(a, b) = p[i];\n                if (a == 0 || b == 0) ng();\n                if (!ps.count({a - 1, b + 1}) && !ps.count({a - 1, b}) && !ps.count({a - 1, b - 1})) ng();\n                if (!ps.count({a + 1, b - 1}) && !ps.count({a, b - 1}) && !ps.count({a - 1, b - 1})) ng();\n        }\n        map<int, vector<pair<int, int>>> s;\n        for (int i = 0; i < n; i ++) {\n                s[p[i].first + p[i].second].emplace_back(p[i].first, p[i].second);\n        }\n        int matching = 0;\n        for (auto mp : s) {\n                vector<pair<int, int>> v = mp.second;\n                sort(v.begin(), v.end());\n                vector<pair<bool, pair<int, int>>> t; //(bottom left exists, number of the same position)\n                int cur = v[0].first;\n                int curi = 0;\n                while (curi < (int) v.size()) {\n                        int cnt = 0;\n                        bool ex = ps.count({v[curi].first - 1, v[curi].second - 1});\n                        while (curi < (int) v.size() && cur == v[curi].first) {\n                                curi ++;\n                                cnt ++;\n                        }\n                        t.push_back({ex, {cnt, cnt}});\n                        cur ++;\n                }\n                for (int i = 0; i < (int) t.size(); i ++) {\n                        if (t[i].first) {\n                                int d = min(t[i].second.first, t[i].second.second);\n                                matching += d;\n                                t[i].second.first -= d;\n                                t[i].second.second -= d;\n                        }\n                        if (t[i].second.second > 0 && i + 1 < (int) t.size()) {\n                                int d = min(t[i].second.second, t[i + 1].second.first);\n                                matching += d;\n                                t[i + 1].second.first -= d;\n                        }\n                }\n        }\n        printf(\"%d\\n\", 2 * n - 2 - matching);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\nusing namespace std;\nmap<int,map<int,int> >mp,vis;\nint a[100010],b[100010];\nbool ex(int x,int y){\n\treturn mp.count(x)&&mp[x].count(y);\n}\nint main(){\n\tint n,i,j,s,las,now;\n\tscanf(\"%d\",&n);\n\t#define wa {puts(\"-1\");return 0;}\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",a+i,b+i);\n\t\tif(i!=1&&a[i]==0)wa\n\t\tif(i!=2&&b[i]==0)wa\n\t\tmp[a[i]][b[i]]++;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tif(i!=2){\n\t\t\tif(!(ex(a[i]-1,b[i]-1)||ex(a[i],b[i]-1)||ex(a[i]+1,b[i]-1)))wa\n\t\t}\n\t\tif(i!=1){\n\t\t\tif(!(ex(a[i]-1,b[i]+1)||ex(a[i]-1,b[i])||ex(a[i]-1,b[i]-1)))wa\n\t\t}\n\t}\n\ts=0;\n\tfor(i=1;i<=n;i++){\n\t\tif(!ex(a[i]-1,b[i]+1)&&!vis[a[i]][b[i]]){\n\t\t\tif(a[i]==3&&b[i]==5){\n\t\t\t\ti++;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tvis[a[i]][b[i]]=1;\n\t\t\tlas=0;\n\t\t\tfor(j=0;ex(a[i]+j,b[i]-j);j++){\n\t\t\t\tnow=mp[a[i]+j][b[i]-j];\n\t\t\t\ts+=min(las,now);\n\t\t\t\tnow-=min(las,now);\n\t\t\t\tif(ex(a[i]+j-1,b[i]-j-1)){\n\t\t\t\t\ts+=now;\n\t\t\t\t\tnow=min(las,mp[a[i]+j][b[i]-j]);\n\t\t\t\t}else\n\t\t\t\t\tnow=mp[a[i]+j][b[i]-j];\n\t\t\t\tlas=now;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",2*n-2-s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint n;\nvvi a;\n\nint f(int i,int x){\n\treturn upper_bound(a[i].begin(),a[i].end(),x)-lower_bound(a[i].begin(),a[i].end(),x);\n}\n\nint main(){\n\tcin>>n;\n\ta=vvi(n+1);\n\tint res=n-1,d;\n\tfor(int i=0;i<n;i++){\n\t\tint A,B;\n\t\tcin>>A>>B;\n\t\ta[A].push_back(B);\n\t\tif(i==1) d=A;\n\t}\n\tfor(int i=0;i<n;i++) sort(a[i].begin(),a[i].end());\n\tif(a[0].size()!=1||a[0][0]!=d) res=-inf;\n\tfor(int i=1;i<n;i++) for(int j=0;j<a[i].size();j++){\n\t\tint x=a[i][j];\n\t\tif(x<abs(i-d)||i+d<x) res=-inf;\n\t\tif(x==0&&j==0&&i==d) continue;\n\t\tif(f(i-1,x-1));\n\t\telse if(f(i+1,x-1)){\n\t\t\tint t=f(i+1,x-1),I=upper_bound(a[i].begin(),a[i].end(),x)-a[i].begin();\n\t\t\tres+=abs(I-j-t);\n\t\t\tj=I-1;\n\t\t}\n\t\telse if(f(i,x-1)) res++;\n\t\telse res=-inf;\n\t}\n\tcout<<max(res,-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nvoid ng() {\n        printf(\"-1\\n\");\n        exit(0);\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<set<int>> ab(n), ba(n);\n        vector<pair<int, int>> p;\n        for (int i = 0; i < n; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                p.emplace_back(a, b);\n                ab[a].insert(b);\n                ba[b].insert(a);\n        }\n        if (p[0].first != 0 || p[1].second != 0) ng();\n        if (p[0].second != p[1].first) ng();\n        for (int i = 2; i < n; i ++) {\n                int a, b;\n                tie(a, b) = p[i];\n                cerr << a << ' ' << b << endl;\n                if (a == 0 || b == 0) ng();\n                if (ab[a - 1].count(b + 1) == 0 && ab[a - 1].count(b) == 0 && ab[a - 1].count(b - 1) == 0) ng();\n                if (ba[b - 1].count(a + 1) == 0 && ba[b - 1].count(a) == 0 && ba[b - 1].count(a - 1) == 0) ng();\n        }\n        assert(false);\n\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=0;\n    if(mn==1)\n        ans++;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+3,shit+n+1,cmp);\n    mp.clear();\n    mp[shit[1]]=1;\n    mp[shit[2]]=1;\n    for(int i=3;i<=n;)\n    {\n        int j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        if(shit[i].one+shit[i].two==mn){\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n                //printf(\"%d %d\\n\",mp.count(tmp1),mp.count(tmp2));\n                if(mp.count(tmp1)&&mp.count(tmp2)){\n                    continue;\n                }\n                else{\n                    puts(\"-1\");\n                    return 0;\n                }\n            }\n            ans=ans+(j-i-mn+1)*2+mn;\n        }\n        else{\n            int flag=0;\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two-1;\n                if(mp.count(tmp1)){\n                    ans++;continue;\n                }\n                if(shit[k].one==shit[k-1].one&&shit[k].two==shit[k-1].two){\n                    ans+=2;\n                    continue;\n                }\n                bool one=0,two=0;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n\n                if(mp.count(tmp1)&&mp.count(tmp2)){\n                    ans=ans+2-flag;\n                    flag=1;\n                    continue;\n                }\n                else{\n                    flag=0;\n                }\n                one=one|mp.count(tmp1);\n                tmp1.two--;\n                one=one|mp.count(tmp1);\n\n                two=two|mp.count(tmp2);\n                tmp2.one--;\n                two=two|mp.count(tmp2);\n                if(one&&two){\n                    ans+=2;continue;\n                }\n                puts(\"-1\");\n                return 0;\n            }\n        }\n        i=j;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n        return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    mp.clear();\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n        mp[shit[i]]=1;\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].two==shit[2].one&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one){\n                tk++;\n            }\n            int now=tk-k;\n            bool one=0,two=0;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                int del=min(now,left);\n                ans-=del;\n                ans-=now-left;\n                now=min(now,left);\n                last=shit[k].one;\n                left=now;\n                continue;\n                one=1;two=1;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            if(shit[k].one==0)one=1;\n            if(shit[k].two==0) two=1;\n            if(one==0||two==0){\n                puts(\"-1\");\n                return 0;\n            }\n            int del=0;\n            if(last+1==shit[k].one){\n                del=min(now,left);\n                ans-=del;\n            }\n            tmp1.two--;\n\n            last=shit[k].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint n;\nvvi a;\n\nint f(int i,int x){\n\treturn upper_bound(a[i].begin(),a[i].end(),x)-lower_bound(a[i].begin(),a[i].end(),x);\n}\n\nint main(){\n\tcin>>n;\n\ta=vvi(n+1);\n\tint res=n-1,d;\n\tfor(int i=0;i<n;i++){\n\t\tint A,B;\n\t\tcin>>A>>B;\n\t\ta[A].push_back(B);\n\t\tif(i==1) d=A;\n\t}\n\tfor(int i=0;i<n;i++) sort(a[i].begin(),a[i].end());\n\tif(a[0].size()!=1||a[0][0]!=d) res=-inf;\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=0;j<a[i].size();j++){\n\t\t\tint x=a[i][j];\n\t\t\tif(x<abs(i-d)||i+d<x) res=-inf;\n\t\t\tif(x==0) continue;\n\t\t\tif(f(i-1,x-1));\n\t\t\telse if(f(i+1,x-1)){\n\t\t\t\tint t=f(i+1,x-1),I=upper_bound(a[i].begin(),a[i].end(),x)-a[i].begin();\n\t\t\t\tres+=max(I-j-t,0);\n\t\t\t\tj=I-1;\n\t\t\t}\n\t\t\telse if(f(i,x-1)) res++;\n\t\t\telse res=-inf;\n\t\t}\n\t}\n\tcout<<max(res,-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n        return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    mp.clear();\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n        mp[shit[i]]=1;\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].two==shit[2].one&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one){\n                tk++;\n            }\n            int now=tk-k;\n            bool one=0,two=0;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                int del=min(now,left);\n                ans-=del;\n                ans-=now-left;\n                now=del;\n                if(last+1!=shit[k].one)\n                    now=0;\n                last=shit[k].one;\n                left=now;\n\n                continue;\n                one=1;two=1;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            if(shit[k].one==0)one=1;\n            if(shit[k].two==0) two=1;\n            if(one==0||two==0){\n                puts(\"-1\");\n                return 0;\n            }\n            int del=0;\n            if(last+1==shit[k].one){\n                del=min(now,left);\n                ans-=del;\n            }\n            tmp1.two--;\n\n            last=shit[k].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#define pii pair<int,int>\nint n, chk[101000], cnt, m;\nusing namespace std;\nstruct point {\n\tint x, y, num;\n\tbool operator<(const point &p)const {\n\t\treturn x + y != p.x + p.y ? x+y < p.x+p.y : x<p.x;\n\t}\n}P[101000], U[101000];\nint A[101000], B[101000], res, D[101000][2], first = 1;\nmap<pii, int>Map;\nint Get(int x, int y) {\n\tif (Map.count({ x,y }))return Map[{x, y}];\n\treturn 0;\n}\nbool Go() {\n\tint i;\n\tif (first) {\n\t\tfirst = 0;\n\t\tfor (i = 1; i < m; i++) {\n\t\t\tint x = U[i].x, y = U[i].y;\n\t\t\tres += max(Get(x, y), Get(x + 1, y - 1));\n\t\t}\n\t\treturn true;\n\t}\n\tfor (i = 0; i <= m + 1; i++) {\n\t\tD[i][0] = D[i][1] = 1e9;\n\t}\n\tD[0][0] = 0;\n\tfor (i = 1; i <= m; i++) {\n\t\tint x = U[i].x, y = U[i].y;\n\t\tint ck1 = 0, ck2 = 0, ck3 = 0;\n\t\tif (Get(x-1,y-1)) ck1 = 1;\n\t\tif (Get(x-1,y)) ck2 = 1;\n\t\tif (Get(x,y-1)) ck3 = 1;\n\t\tif (ck1) {\n\t\t\tD[i][0] = min(D[i][0], D[i - 1][0] + Get(x, y));\n\t\t}\n\t\tif (ck2) {\n\t\t\tD[i][1] = min(D[i][1], D[i - 1][0] + Get(x, y));\n\t\t}\n\t\tif (ck2 &&ck3) {\n\t\t\tD[i][0] = min(D[i][0], D[i - 1][0] + Get(x, y) * 2);\n\t\t}\n\t\tif (i != 1) {\n\t\t\tD[i][1] = min(D[i][1], min(D[i - 1][0], D[i - 1][1]) + max(Get(x - 1, y + 1), Get(x, y)));\n\t\t}\n\t\tif (ck1 || ck3) {\n\t\t\tD[i][0] = min(D[i][0], D[i][1] + Get(x, y));\n\t\t}\n\t\tD[i][1] = min(D[i][1], D[i][0]);\n\t}\n\tif (D[m][0] > 1e8)return false;\n\tres += D[m][0];\n\treturn true;\n}\nint main() {\n\tint i, j;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\t\tP[i] = { A[i],B[i],i };\n\t\tMap[{A[i], B[i]}]++;\n\t}\n\tsort(P + 1, P + n + 1);\n\tif (A[1] != 0 || B[2] != 0 || A[2]!=B[1] || Get(A[1],B[1])!=1 || Get(A[2],B[2])!=1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tif (abs(A[i] - B[i]) > A[2]) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tm = 0;\n\t\tU[++m] = P[i];\n\t\tfor (j = i+1; j <= n; j++) {\n\t\t\tif (abs(P[j].x - P[j - 1].x) > 1 || P[j].x + P[j].y != P[j - 1].x + P[j - 1].y)break;\n\t\t\tif (P[j].x != P[j - 1].x)U[++m] = P[j];\n\t\t}\n\t\tif (i == 1) {\n\t\t\tif (U[1].num != 1 || U[m].num != 2) {\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif (!Go()) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\ti = j - 1;\n\t}\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n        return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    mp.clear();\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n        mp[shit[i]]=1;\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].two==shit[2].one&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one){\n                tk++;\n            }\n            int now=tk-k;\n            bool one=0,two=0;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                int del=min(now,left);\n                ans-=del;\n                ans-=now-left;\n                now=del;\n                last=shit[k].one;\n                left=now;\n                continue;\n                one=1;two=1;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            if(shit[k].one==0)one=1;\n            if(shit[k].two==0) two=1;\n            if(one==0||two==0){\n                puts(\"-1\");\n                return 0;\n            }\n            int del=0;\n            if(last+1==shit[k].one){\n                del=min(now,left);\n                ans-=del;\n            }\n            tmp1.two--;\n\n            last=shit[k].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define N 100010\nint n;\nint a[N], b[N];\nmap<PII, set<int> > A;\n\nvoid end() {\n\tputs (\"-1\");\n\texit(0);\n}\n\nint path[N], L;\nbool v[N];\n\n//vector<int> c[N];\n// c[i] = connect with path[i] and path[i+1]\n//int sc[N];\nmap<PII, set<int> > B;\n\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i ++) {\n  \tcin >> a[i] >> b[i];\n  \tA[mp(a[i], b[i])].insert(i);\n  }\n  if (a[0] != 0 || b[1] != 0 || a[1] != b[0]) end();\n  L = a[1];\n  path[0] = 0;\n  path[L] = 1;\n  for (int i = 1; i < L; i++)\n  \tpath[i] = -1;\n  for (int i = 2; i < n; i++)\n  \tif (a[i] + b[i] == L) {\n  \t\tif (path[a[i]] == -1) {\n  \t\t   path[a[i]] = i;\n  \t\t   v[i] = true;\n  \t\t}\n  \t}\n  for (int i = 1; i < L; i ++)\n  \tif (path[i] == -1) end();\n  for (int i = 2; i < n; i ++) {\n    if (a[i] == 0 || b[i] == 0) end();\n    if (a[i] + b[i] < L) end();\n  }\n  int S = 0;\n  S += L; // path\n  for (int i = 2; i < n; i ++) if (!v[i]) {\n    if (a[i] + b[i] == L) {\n      S += 2;\n    } else {\n      if (A.find(mp(a[i]-1, b[i]-1)) != A.end()) {\n        S ++;\n      } else \n      if (A.find(mp(a[i]-1, b[i])) != A.end() && A.find(mp(a[i], b[i]-1)) != A.end()) {\n        S += 2;\n        B[mp(a[i], b[i])].insert(i);\n      } else {\n        end();\n      }\n    }\n  }\n  /*\n  for (int i = 0; i < L; i ++) {\n    sc[i] = (int) c[i].size();\n  }\n  for (int i = 0; i < L-1; i ++) {\n    int T = min(sc[i], sc[i+1]);\n    S -= T;\n  }\n  */\n  for (map<PII, set<int> >::iterator i = B.begin(); i != B.end(); i++) {\n    int l = i->fi.fi;\n    int r = i->fi.se;\n    if (B.find(mp(l+1,r-1)) != B.end()) {\n      S -= min( (int) i->se.size(), (int) B[mp(l+1,r-1)].size());\n    }\n  }\n  cout << S << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\n#define mp make_pair\n#define pb push_back\n#define N 100010\nint n;\nint a[N], b[N];\nmap<PII, set<int> > A;\n\nvoid end() {\n\tputs (\"-1\");\n\texit(0);\n}\n\nint path[N], L;\nbool v[N];\n\nvector<int> c[N];\n// c[i] = connect with path[i] and path[i+1]\nint sc[N];\n\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i ++) {\n  \tcin >> a[i] >> b[i];\n  \tA[mp(a[i], b[i])].insert(i);\n  }\n  if (a[0] != 0 || b[1] != 0 || a[1] != b[0]) end();\n  L = a[1];\n  path[0] = 0;\n  path[L] = 1;\n  for (int i = 1; i < L; i++)\n  \tpath[i] = -1;\n  for (int i = 2; i < n; i++)\n  \tif (a[i] + b[i] == L) {\n  \t\tif (path[a[i]] == -1) {\n  \t\t   path[a[i]] = i;\n  \t\t   v[i] = true;\n  \t\t}\n  \t}\n  for (int i = 2; i < n; i ++) {\n    if (a[i] == 0 || b[i] == 0) end();\n    if (a[i] + b[i] < L) end();\n  }\n  int S = 0;\n  S += L; // path\n  for (int i = 2; i < n; i ++) {\n    if (a[i] + b[i] == L) {\n      S += 2;\n    } else\n    if (a[i] + b[i] == L+1) {\n      S += 2;\n      c[i].pb(a[i]);\n    } else {\n      if (A.find(mp(a[i]-1, b[i]-1)) != A.end()) {\n        S ++;\n      } else {\n        end();\n      }\n    }\n  }\n  for (int i = 0; i < L; i ++) {\n    sc[i] = (int) c[i].size();\n  }\n  for (int i = 0; i < L-1; i ++) {\n    int T = min(sc[i], sc[i+1]);\n    S -= T;\n  }\n  cout << S << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nvoid ng() {\n        printf(\"-1\\n\");\n        exit(0);\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        set<pair<int, int>> ps;\n        vector<pair<int, int>> p;\n        for (int i = 0; i < n; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                p.emplace_back(a, b);\n                ps.insert({a, b});\n        }\n        if (p[0].first != 0 || p[1].second != 0) ng();\n        if (p[0].second != p[1].first) ng();\n        if (p[0].second == 0) ng();\n        for (int i = 2; i < n; i ++) {\n                int a, b;\n                tie(a, b) = p[i];\n                if (a == 0 || b == 0) ng();\n                if (!ps.count({a - 1, b + 1}) && !ps.count({a - 1, b}) && !ps.count({a - 1, b - 1})) ng();\n                if (!ps.count({a + 1, b - 1}) && !ps.count({a, b - 1}) && !ps.count({a - 1, b - 1})) ng();\n        }\n        map<int, vector<pair<int, int>>> s;\n        for (int i = 0; i < n; i ++) {\n                s[p[i].first + p[i].second].emplace_back(p[i].first, p[i].second);\n        }\n        int matching = 0;\n        for (auto mp : s) {\n                vector<pair<int, int>> v = mp.second;\n                sort(v.begin(), v.end());\n                vector<pair<bool, pair<int, int>>> t; //(bottom left exists, number of the same position)\n                int cur = v[0].first;\n                int curi = 0;\n                if ((int) v.size() == 0) continue;\n                while (curi < (int) v.size()) {\n                        int cnt = 0;\n                        bool ex = ps.count({v[curi].first - 1, v[curi].second - 1});\n                        while (curi < (int) v.size() && cur == v[curi].first) {\n                                curi ++;\n                                cnt ++;\n                        }\n                        t.push_back({ex, {cnt, cnt}});\n                        cur ++;\n                }\n                for (int i = 0; i < (int) t.size(); i ++) {\n                        if (t[i].first) {\n                                int d = min(t[i].second.first, t[i].second.second);\n                                matching += d;\n                                t[i].second.first -= d;\n                                t[i].second.second -= d;\n                        }\n                        if (t[i].second.second > 0 && i + 1 < (int) t.size()) {\n                                int d = min(t[i].second.second, t[i + 1].second.first);\n                                matching += d;\n                                t[i + 1].second.first -= d;\n                        }\n                }\n        }\n        printf(\"%d\\n\", 2 * n - 2 - matching);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=0;\n    if(mn==1)\n        ans++;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+3,shit+n+1,cmp);\n    mp.clear();\n    mp[shit[1]]=1;\n    mp[shit[2]]=1;\n    for(int i=3;i<=n;)\n    {\n        int j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        if(shit[i].one+shit[i].two==mn){\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n                //printf(\"%d %d\\n\",mp.count(tmp1),mp.count(tmp2));\n                if(mp.count(tmp1)&&mp.count(tmp2)){\n                    continue;\n                }\n                else{\n                    puts(\"-1\");\n                    return 0;\n                }\n            }\n            ans=ans+(j-i-mn+1)*2+mn;\n        }\n        else{\n            int flag=0;\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two-1;\n                if(mp.count(tmp1)){\n                    flag=0;\n                    ans++;continue;\n                }\n                if(shit[k].one==shit[k-1].one&&shit[k].two==shit[k-1].two){\n                    ans+=2;\n                    continue;\n                }\n                bool one=0,two=0;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n\n                if(mp.count(tmp1)&&mp.count(tmp2)){\n                    ans=ans+2-flag;\n                    flag=1;\n                    continue;\n                }\n                else{\n                    flag=0;\n                }\n                one=one|mp.count(tmp1);\n                tmp1.two--;\n                one=one|mp.count(tmp1);\n\n                two=two|mp.count(tmp2);\n                tmp2.one--;\n                two=two|mp.count(tmp2);\n                if(one&&two){\n                    ans+=2;continue;\n                }\n                puts(\"-1\");\n                return 0;\n            }\n        }\n        i=j;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nint N, A[101010], B[101010];\n\nvoid fail()\n{\n\tputs(\"-1\");\n\texit(0);\n}\n\nint bas[101010];\nmap<pair<int, int>, int> P;\n\nbool is_good(int y, int x)\n{\n\treturn P.count(make_pair(y - 1, x - 1)) > 0;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i) scanf(\"%d%d\", A + i, B + i);\n\n\tif (A[0] != 0) fail();\n\tif (B[1] != 0) fail();\n\tif (A[1] != B[0]) fail();\n\tint D = A[1];\n\n\tfor (int i = 2; i < N; ++i) {\n\t\tif (A[i] == 0 || B[i] == 0 || A[i] + B[i] < D) fail();\n\t}\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (A[i] + B[i] == D) {\n\t\t\tbas[A[i]] += 1;\n\t\t}\n\t}\n\n\tint ret = 0;\n\tfor (int i = 0; i < D; ++i) {\n\t\tif (bas[i] == 0) fail();\n\t\tret += max(bas[i], bas[i + 1]);\n\t}\n\n\tfor (int i = 0; i < N; ++i) P[make_pair(A[i], B[i])] += 1;\n\n\t/*\n\tfor (int i = 2; i < N; ++i) if (A[i] + B[i] != D) {\n\t\tint x = A[i], y = B[i];\n\t\tif (P.count(make_pair(x - 1, y - 1))) {\n\t\t\t++ret;\n\t\t} else if (P.count(make_pair(x, y - 1)) && P.count(make_pair(x - 1, y))) {\n\t\t\tret += 2;\n\t\t} else fail();\n\t}\n\t*/\n\tfor (map<pair<int, int>, int>::iterator p = P.begin(); p != P.end(); ++p) {\n\t\tint y = p->first.first, x = p->first.second;\n\t\tif (y + x == D) continue;\n\n\t\tif (P.count(make_pair(y - 1, x + 1)) == 0) {\n\t\t\tvector<pair<pair<int, int>, int> > V;\n\t\t\tfor (;;) {\n\t\t\t\tint cnt = P[make_pair(y, x)];\n\t\t\t\tif (cnt == 0) break;\n\t\t\t\tV.push_back(make_pair(make_pair(y, x), cnt));\n\t\t\t\ty += 1;\n\t\t\t\tx -= 1;\n\t\t\t}\n\n\t\t\tif (V.size() == 1) {\n\t\t\t\ty = V[0].first.first, x = V[0].first.second;\n\t\t\t\tif (P.count(make_pair(y - 1, x - 1))) {\n\t\t\t\t\tret += V[0].second;\n\t\t\t\t} else if (P.count(make_pair(y - 1, x)) && P.count(make_pair(y, x - 1))) {\n\t\t\t\t\tret += 2 * V[0].second;\n\t\t\t\t} else fail();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t{\n\t\t\t\ty = V[0].first.first, x = V[0].first.second;\n\t\t\t\tif (P.count(make_pair(y - 1, x)) || P.count(make_pair(y - 1, x - 1))) {\n\t\t\t\t\tret += V[0].second;\n\t\t\t\t} else fail();\n\t\t\t}\n\t\t\t{\n\t\t\t\ty = V[V.size()-1].first.first, x = V[V.size()-1].first.second;\n\t\t\t\tif (P.count(make_pair(y, x - 1)) || P.count(make_pair(y - 1, x - 1))) {\n\t\t\t\t\tret += V[V.size()-1].second;\n\t\t\t\t} else fail();\n\t\t\t}\n\t\t\tV[0].second = V[V.size()-1].second = 0;\n\t\t\tfor (int i = 1; i < V.size() - 1; ++i) {\n\t\t\t\ty = V[i].first.first, x = V[i].first.second;\n\t\t\t\tif (P.count(make_pair(y - 1, x - 1))) {\n\t\t\t\t\tret += V[i].second;\n\t\t\t\t\tV[i].second = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i < V.size(); ++i) {\n\t\t\t\tret += max(V[i].second, V[i - 1].second);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    mp.clear();\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one&&shit[tk].two==shit[k].two){\n                tk++;\n            }\n            int now=tk-k;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                last=shit[i].one;\n                left=now;\n                continue;\n            }\n\n            if(last+1==shit[k].one){\n                ans-=min(now,left);\n            }\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n            bool one=0,two=0;\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            if(one==0||two==0){\n                puts(\"-1\");\n                return 0;\n            }\n            if(last+1==shit[k].one){\n                ans+=max(now,left);\n            }\n            else{\n                ans+=now*2;\n            }\n            last=shit[i].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint nr, N, a[100009], b[100009], A[100009], B[100009], id[100009], sz[100009], may[100009], both1[100009], dp[100009][2];\nconst int INF = 1e8;\n\nbool cmp (int i, int j)\n{\n    if (A[i] + B[i] == A[j] + B[j]) return (A[i] < A[j]);\n    return (A[i] + B[i] < A[j] + B[j]);\n}\n\nint findPair (int x, int y)\n{\n    int p = 1, u = nr, mij;\n    while (p <= u)\n    {\n        mij = (p + u) >> 1;\n        if (a[mij] == x && b[mij] == y) return mij;\n        if (a[mij] + b[mij] < x + y || (a[mij] + b[mij] == x + y && a[mij] < x)) p = mij + 1;\n        else u = mij - 1;\n    }\n    return 0;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nprintf (\"-1\\n\");\nreturn 0;\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d\", &A[i], &B[i]), id[i] = i;\nsort (id + 1, id + N + 1, cmp);\nif (A[2] != B[1] || A[id[1]] + B[id[1]] < A[2] || A[1] != 0 || B[2] != 0)\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=N; i++)\n    if ((A[i] == 0 && i != 1) || (B[i] == 0 && i != 2))\n    {\n        printf (\"-1\\n\");\n        return 0;\n    }\nfor (int i=1; i<=N; i++)\n{\n    int j = i;\n    while (j + 1 <= N && A[id[j]] == A[id[j + 1]] && B[id[j]] == B[id[j + 1]])\n        j ++;\n    a[++nr] = A[id[i]], b[nr] = B[id[i]], sz[nr] = j - i + 1;\n    i = j;\n}\nfor (int i=1; i<=nr; i++)\n    may[i] = (findPair (a[i] + 1, b[i] - 1) != 0),\n    both1[i] = (findPair (a[i] - 1, b[i] - 1) != 0);\nif (!may[1])\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=nr; i++)\n    if ((a[i] > 0 && findPair (a[i] - 1, b[i]) == 0 && findPair (a[i] - 1, b[i] + 1) == 0 && both1[i] == 0) ||\n        (b[i] > 0 && findPair (a[i], b[i] - 1) == 0 && findPair (a[i] + 1, b[i] - 1) == 0 && both1[i] == 0))\n        {\n            printf (\"-1\\n\");\n            return 0;\n        }\nfor (int i=1; i<=nr; i++)\n    for (int j=0; j<2; j++)\n        dp[i][j] = INF;\ndp[1][1] = 1;\nfor (int i=1; i<nr; i++)\n    for (int j=0; j<=may[i]; j++)\n        for (int k=0; k<=may[i + 1]; k++)\n        {\n            if (k == 0 && both1[i + 1] == 1)\n                dp[i + 1][k] = min (dp[i + 1][k], dp[i][j] + sz[i + 1]);\n            int curr = dp[i][j];\n            if (j == 0)\n            {\n                if (findPair (a[i + 1] - 1, b[i + 1]) == 0 && both1[i + 1] == 0) continue;\n                curr += sz[i + 1];\n            }\n            if (k == 0 && b[i + 1] > 0)\n            {\n                if (findPair (a[i + 1], b[i + 1] - 1) == 0 && both1[i + 1] == 0) continue;\n                curr += sz[i + 1];\n            }\n            if (curr < dp[i + 1][k])\n                dp[i + 1][k] = curr;\n        }\nprintf (\"%d\\n\", min (dp[nr][0], dp[nr][1]));\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 26.11.2019 22:59:30       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n  }\n  if (a[0] != 0 || b[1] != 0 || a[1] == 0 || a[1] != b[0]) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  int d = a[1];\n  vector<int> was(d + 1, 0);\n  for (int i = 0; i < n; i++) {\n    if ((i >= 2 && min(a[i], b[i]) == 0) || a[i] + b[i] < d) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    if (a[i] + b[i] == d) {\n      was[a[i]] = 1;\n    }\n  }\n  if (*min_element(was.begin(), was.end()) == 0) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  set<pair<int, int>> s;\n  for (int i = 0; i < n; i++) {\n    s.emplace(a[i], b[i]);\n  }\n  map<pair<int, int>, tuple<int, int, int>> mp;\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    get<0>(mp[make_pair(a[i], b[i])]) += 1;\n    get<2>(mp[make_pair(a[i], b[i])]) += 1;\n    ans += (a[i] > 0) + (b[i] > 0);\n    if (s.find({a[i] - 1, b[i] - 1}) != s.end()) {\n      get<1>(mp[make_pair(a[i], b[i])]) += 1;\n    } else {\n      if (a[i] > 0 && s.find({a[i] - 1, b[i]}) == s.end() && s.find({a[i] - 1, b[i] + 1}) == s.end()) {\n        cout << -1 << '\\n';\n        return 0;\n      }\n      if (b[i] > 0 && s.find({a[i], b[i] - 1}) == s.end() && s.find({a[i] + 1, b[i] - 1}) == s.end()) {\n        cout << -1 << '\\n';\n        return 0;\n      }\n    }\n  }\n  for (auto& p : mp) {\n    int t = min(get<0>(p.second), get<1>(p.second));\n    get<2>(p.second) -= t;\n    ans -= t;\n    auto it = mp.find(make_pair(p.first.first + 1, p.first.second - 1));\n    if (it != mp.end()) {\n      t = min(get<2>(p.second), get<0>(it->second));\n      get<0>(it->second) -= t;\n      ans -= t;\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nint A[100000], B[100000];\nmap<P, bool> exist;\nmap<P, int> CA, CB;\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) cin >> A[i] >> B[i];\n  int zero_a = 0, zero_b = 0;\n  rep(i, N) zero_a += A[i]==0, zero_b += B[i]==0;\n  if (A[0] != 0 || B[1] != 0 || zero_a != 1 || zero_b != 1) {\n    cout << -1 << \"\\n\";\n    return 0;\n  }\n  rep(i, N) exist[P(A[i], B[i])] = true;\n  rep(i, N) {\n    int a = A[i], b = B[i];\n    if (a > 0 && !exist[P(a-1, b-1)] && !exist[P(a-1, b)] && !exist[P(a-1, b+1)]) {\n      cout << -1 << \"\\n\";\n      return 0;\n    }\n    if (b > 0 && !exist[P(a-1, b-1)] && !exist[P(a, b-1)] && !exist[P(a+1, b-1)]) {\n      cout << -1 << \"\\n\";\n      return 0;\n    }\n  }\n  int sum = 0;\n  rep(i, N) {\n    int a = A[i], b = B[i];\n    if (exist[P(a-1, b-1)]) sum++;\n    else {\n      //cout<<\"(\"<<a<<\",\"<<b<<\")\\n\";\n      if (a > 0) CA[P(a, b)]++;\n      if (b > 0) CB[P(a, b)]++;\n    }\n  }\n  for (auto &p : CA) {\n    int a = p._1._1, b = p._1._2;\n    int num = min(p._2, CB[P(a-1, b+1)]);\n    p._2 -= num;\n    CB[P(a-1, b+1)] -= num;\n    //cout<<\"(\"<<a<<\",\"<<b<<\")<->(\"<<a-1<<\",\"<<b+1<<\") * \"<<num<<\"\\n\";\n    sum += num;\n  }\n  for (auto p : CA) sum += p._2;\n  for (auto p : CB) sum += p._2;\n  cout << sum << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define fill( x, y ) memset( x, y, sizeof x )\n#define copy( x, y ) memcpy( x, y, sizeof x )\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pa;\n\ninline int read()\n{\n\tint sc = 0, f = 1; char ch = getchar();\n\twhile( ch < '0' || ch > '9' ) { if( ch == '-' ) f = -1; ch = getchar(); }\n\twhile( ch >= '0' && ch <= '9' ) sc = sc * 10 + ch - '0', ch = getchar();\n\treturn sc * f;\n}\n\nconst int MAXN = 100005;\n\nint n, a[MAXN], b[MAXN];\nmap < pa, bool > cnt;\npa c[MAXN];\n\ninline void GG() { puts( \"-1\" ); exit( 0 ); }\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen( \"data.in\", \"r\", stdin );\n#endif\n\tn = read();\n\tfor( int i = 1 ; i <= n ; i++ )\n\t{\n\t\ta[ i ] = read(), b[ i ] = read(), c[ i ] = mp( a[ i ] + b[ i ], b[ i ] );\n\t\tif( !a[ i ] && i != 1 ) GG();\n\t\tif( !b[ i ] && i != 2 ) GG();\n\t\tcnt[ mp( a[ i ], b[ i ] ) ] = 1;\n\t}\n\tif( a[ 1 ] || b[ 2 ] ) GG();\n\tsort( c + 1, c + n + 1 );\n\tint ret = n - 1 << 1;\n\tfor( int l = 1, r = 1 ; l <= n ; l = r )\n\t{\n\t\twhile( r <= n && c[ r ].xx == c[ l ].xx )\n\t\t{\n\t\t\tint x = c[ r ].xx - c[ r ].yy, y = c[ r ].yy;\n\t\t\tif( x )\n\t\t\t{\n\t\t\t\tbool flag = false;\n\t\t\t\tfor( int d = -1 ; d <= 1 ; d++ ) if( cnt.find( mp( x - 1, y + d ) ) != cnt.end() ) flag = true;\n\t\t\t\tif( !flag ) GG();\n\t\t\t}\n\t\t\tif( y )\n\t\t\t{\n\t\t\t\tbool flag = true;\n\t\t\t\tfor( int d = -1 ; d <= 1 ; d++ ) if( cnt.find( mp( x + d, y - 1 ) ) != cnt.end() ) flag = true;\n\t\t\t\tif( !flag ) GG();\n\t\t\t}\n\t\t\tr++;\n\t\t}\n\t\tfor( int i = l, j = l, last = 0, left = 0 ; i <= r ; i = j )\n\t\t{\n\t\t\twhile( j <= r && c[ j ].yy == c[ i ].yy ) j++;\n\t\t\tint now = j - i, del = 0;\n\t\t\tif( c[ j ].yy == last + 1 ) del = min( now, left ), ret -= del;\n\t\t\tif( cnt.find( mp( c[ j ].xx - c[ j ].yy - 1, c[ j ].yy - 1 ) ) != cnt.end() ) ret -= now - del, now = del;\n\t\t\tlast = c[ j ].yy; last = now;\n\t\t}\n\t}\n\treturn printf( \"%d\\n\", ret ), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#define ll long long\n#define inf 1000000007\n#define inf16 0x3f3f3f3f\n#define INF 1000000000000000007LL\n#define VI vector<int>\n#define VPII vector<pair<int, int> >\n#define VLL vector<ll>\n#define PII pair<int, int>\n#define st first\n#define nd second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define endl '\\n'\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\nconst int N = 1e5+7;\n\nint n, ans;\n\nint A[N];\nint B[N];\n\nPII mB[N]; //maksymalne B dla danego A\nPII mA[N]; //maksymalne A dla danego B\n\nmap<PII, int> takie;\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tcin >> n;\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> A[i] >> B[i];\n\t\ttakie[{A[i], B[i]}] = i;\n\t\tmB[A[i]] = max(mB[A[i]], mp(B[i], i));\n\t\tmA[B[i]] = max(mA[B[i]], mp(A[i], i));\n\t}\n\n\tif(A[2]!=B[1] || A[1] || B[2])\n\t{\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tif(A[2]==1)\n\t\t++ans;\n\n\tfor(int i = 3; i <= n; ++i)\n\t{\n\t\tif(takie.find({A[i]-1, B[i]-1})!=takie.end())\n\t\t\t++ans;\n\t\telse\n\t\t{\n\t\t\tif(mB[A[i]-1].st>B[i]-1 && mA[B[i]-1].st>A[i]-1)\n\t\t\t\tans += 2;\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    mp.clear();\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one&&shit[tk].two==shit[k].two){\n                tk++;\n            }\n            int now=tk-k;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                last=shit[i].one;\n                left=now;\n                continue;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n            bool one=0,two=0;\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            if((one==0||two==0)&&shit[k].one!=0&&shit[k].two!=0){\n                //printf(\"%d k %d\\n\",shit[k].one,shit[k].two);\n                puts(\"-1\");\n                return 0;\n            }\n            if(last+1==shit[k].one){\n                ans-=max(now,left);\n            }\n            last=shit[i].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint nr, N, a[100009], b[100009], A[100009], B[100009], id[100009], sz[100009], may[100009], both1[100009], dp[100009][2];\nconst int INF = 1e8;\n\nbool cmp (int i, int j)\n{\n    if (A[i] + B[i] == A[j] + B[j]) return (A[i] < A[j]);\n    return (A[i] + B[i] < A[j] + B[j]);\n}\n\nint findPair (int x, int y)\n{\n    int p = 1, u = nr, mij;\n    while (p <= u)\n    {\n        mij = (p + u) >> 1;\n        if (a[mij] == x && b[mij] == y) return mij;\n        if (a[mij] + b[mij] < x + y || (a[mij] + b[mij] == x + y && a[mij] < x)) p = mij + 1;\n        else u = mij - 1;\n    }\n    return 0;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d\", &A[i], &B[i]), id[i] = i;\nsort (id + 1, id + N + 1, cmp);\nif (A[2] != B[1] || A[id[1]] + B[id[1]] < A[2] || A[1] != 0 || B[2] != 0)\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=N; i++)\n    if ((A[i] == 0 && i != 1) || (B[i] == 0 && i != 2))\n    {\n        printf (\"-1\\n\");\n        return 0;\n    }\nfor (int i=1; i<=N; i++)\n{\n    int j = i;\n    while (j + 1 <= N && A[id[j]] == A[id[j + 1]] && B[id[j]] == B[id[j + 1]])\n        j ++;\n    a[++nr] = A[id[i]], b[nr] = B[id[i]], sz[nr] = j - i + 1;\n    i = j;\n}\nfor (int i=1; i<=nr; i++)\n    may[i] = (findPair (a[i] + 1, b[i] - 1) != 0),\n    both1[i] = (findPair (a[i] - 1, b[i] - 1) != 0);\nif (!may[1])\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=nr; i++)\n    if ((a[i] > 0 && findPair (a[i] - 1, b[i]) == 0 && findPair (a[i] - 1, b[i] + 1) == 0 && both1[i] == 0) ||\n        (b[i] > 0 && findPair (a[i], b[i] - 1) == 0 && findPair (a[i] + 1, b[i] - 1) == 0 && both1[i] == 0))\n        {\n            printf (\"-1\\n\");\n            return 0;\n        }\nfor (int i=1; i<=nr; i++)\n    for (int j=0; j<2; j++)\n        dp[i][j] = INF;\ndp[1][1] = max (1, sz[2]);\nfor (int i=1; i<nr; i++)\n    for (int j=0; j<=may[i]; j++)\n        for (int k=0; k<=may[i + 1]; k++)\n        {\n            if (k == 0 && both1[i + 1] == 1)\n                dp[i + 1][k] = min (dp[i + 1][k], dp[i][j] + sz[i + 1]);\n            int curr = dp[i][j];\n            if (j == 0)\n            {\n                if (findPair (a[i + 1] - 1, b[i + 1]) == 0 && both1[i + 1] == 0) continue;\n                curr += sz[i + 1];\n            }\n            if (k == 0 && b[i + 1] > 0)\n            {\n                if (findPair (a[i + 1], b[i + 1] - 1) == 0 && both1[i + 1] == 0) continue;\n                curr += sz[i + 1];\n            }\n            else\n            if (k == 1) curr += max (sz[i + 1], sz[i + 2]);\n            if (curr < dp[i + 1][k])\n                dp[i + 1][k] = curr;\n        }\nprintf (\"%d\\n\", min (dp[nr][0], dp[nr][1]));\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint n;\nvvi a;\n\nint f(int i,int x){\n\treturn upper_bound(a[i].begin(),a[i].end(),x)-lower_bound(a[i].begin(),a[i].end(),x);\n}\n\nint main(){\n\tcin>>n;\n\ta=vvi(n+1);\n\tint res=n-1,d;\n\tfor(int i=0;i<n;i++){\n\t\tint A,B;\n\t\tcin>>A>>B;\n\t\ta[A].push_back(B);\n\t\tif(i==1) d=A;\n\t}\n\tfor(int i=0;i<n;i++) sort(a[i].begin(),a[i].end());\n\tif(a[0].size()!=1||a[0][0]!=d) res=-inf;\n\tfor(int i=1;i<n;i++) for(int j=0;j<a[i].size();j++){\n\t\tint x=a[i][j];\n\t\tif(x<abs(i-d)||i+d<x) res=-inf;\n\t\tif(!x&&!j||f(i-1,x-1)) continue;\n\t\tif(f(i+1,x-1)){\n\t\t\tint t=f(i+1,x-1),I=upper_bound(a[i].begin(),a[i].end(),x)-a[i].begin();\n\t\t\tres+=max(I-j-t,0);\n\t\t\tj=I-1;\n\t\t}\n\t\telse if(f(i,x-1)) res++;\n\t\telse res=-inf;\n\t\tif(f(i-1,x-1)+f(i-1,x)+f(i-1,x+1)==0) res=-inf;\n\t}\n\tassert(res>-1);\n\tcout<<max(res,-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n        return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    mp.clear();\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n        mp[shit[i]]=1;\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].two==shit[2].one&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one){\n                tk++;\n            }\n            int now=tk-k;\n            bool one=0,two=0;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                if(last+1!=shit[k].one)\n                    now=0;\n                else now=min(now,left);\n                last=shit[k].one;\n                left=now;\n \n                continue;\n                one=1;two=1;\n            }\n \n \n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n \n \n \n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n \n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n \n            if(shit[k].one==0)one=1;\n            if(shit[k].two==0) two=1;\n            if(one==0||two==0){\n                puts(\"-1\");\n                return 0;\n            }\n            int del=0;\n            if(last+1==shit[k].one){\n                del=min(now,left);\n                ans-=del;\n            }\n            tmp1.two--;\n \n            last=shit[k].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    mp.clear();\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one&&shit[tk].two==shit[k].two){\n                tk++;\n            }\n            int now=tk-k;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                last=shit[i].one;\n                left=now;\n                continue;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n            bool one=0,two=0;\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            if((one==0||two==0)&&shit[k].one!=0&&shit[k].two!=0){\n                //printf(\"%d k %d\\n\",shit[k].one,shit[k].two);\n                puts(\"-1\");\n                return 0;\n            }\n            if(last+1==shit[k].one){\n                ans-=min(now,left);\n            }\n            last=shit[i].one;\n            left=now;\n        }\n        //printf(\"%d %d\\n\",shit[i].one+shit[i].two,ans);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n        return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    mp.clear();\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n        mp[shit[i]]=1;\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].two==shit[2].one&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one){\n                tk++;\n            }\n            int now=tk-k;\n            bool one=0,two=0;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                int del=min(now,left);\n                ans-=del;\n                ans-=now-left;\n                now=del;\n                if(last+1!=shit[i].one)\n                    now=0;\n                last=shit[k].one;\n                left=now;\n\n                continue;\n                one=1;two=1;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            if(shit[k].one==0)one=1;\n            if(shit[k].two==0) two=1;\n            if(one==0||two==0){\n                puts(\"-1\");\n                return 0;\n            }\n            int del=0;\n            if(last+1==shit[k].one){\n                del=min(now,left);\n                ans-=del;\n            }\n            tmp1.two--;\n\n            last=shit[k].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=0;\n    ans++;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+3,shit+n+1,cmp);\n    mp.clear();\n    mp[shit[1]]=1;\n    mp[shit[2]]=1;\n    for(int i=3;i<=n;)\n    {\n        int j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        if(shit[i].one+shit[i].two==mn){\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n                //printf(\"%d %d\\n\",mp.count(tmp1),mp.count(tmp2));\n                if(mp.count(tmp1)&&mp.count(tmp2)){\n                    continue;\n                }\n                else{\n                    puts(\"-1\");\n                    return 0;\n                }\n            }\n            ans=ans+(j-mn+1)*2+mn;\n        }\n        else{\n            int flag=0;\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two-1;\n                if(mp.count(tmp1)){\n                    ans++;continue;\n                }\n                if(shit[k].one==shit[k-1].one&&shit[k].two==shit[k-1].two){\n                    ans+=2;\n                    continue;\n                }\n                bool one=0,two=0;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n\n                if(mp.count(tmp1)&&mp.count(tmp2)){\n                    ans=ans+2-flag;\n                    flag=1;\n                    continue;\n                }\n                else{\n                    flag=0;\n                }\n                one=one|mp.count(tmp1);\n                tmp1.two--;\n                one=one|mp.count(tmp1);\n\n                two=two|mp.count(tmp2);\n                tmp2.one--;\n                two=two|mp.count(tmp2);\n                if(one&&two){\n                    ans+=2;continue;\n                }\n                puts(\"-1\");\n                return 0;\n            }\n        }\n        i=j;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define fill( x, y ) memset( x, y, sizeof x )\n#define copy( x, y ) memcpy( x, y, sizeof x )\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pa;\n\ninline int read()\n{\n\tint sc = 0, f = 1; char ch = getchar();\n\twhile( ch < '0' || ch > '9' ) { if( ch == '-' ) f = -1; ch = getchar(); }\n\twhile( ch >= '0' && ch <= '9' ) sc = sc * 10 + ch - '0', ch = getchar();\n\treturn sc * f;\n}\n\nconst int MAXN = 100005;\n\nint n, a[MAXN], b[MAXN];\nmap < pa, bool > cnt;\npa c[MAXN];\n\ninline void GG() { puts( \"-1\" ); exit( 0 ); }\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen( \"data.in\", \"r\", stdin );\n#endif\n\tn = read();\n\tfor( int i = 1 ; i <= n ; i++ )\n\t{\n\t\ta[ i ] = read(), b[ i ] = read(), c[ i ] = mp( a[ i ] + b[ i ], b[ i ] );\n\t\tif( !a[ i ] && i != 1 ) GG();\n\t\tif( !b[ i ] && i != 2 ) GG();\n\t\tcnt[ mp( a[ i ], b[ i ] ) ] = 1;\n\t}\n\tif( a[ 1 ] || b[ 2 ] ) GG();\n\tsort( c + 1, c + n + 1 );\n\tint ret = n - 1 << 1;\n\tfor( int l = 1, r = 1 ; l <= n ; l = r )\n\t{\n\t\twhile( r <= n && c[ r ].xx == c[ l ].xx )\n\t\t{\n\t\t\tint x = c[ r ].xx - c[ r ].yy, y = c[ r ].yy;\n\t\t\tif( x )\n\t\t\t{\n\t\t\t\tbool flag = false;\n\t\t\t\tfor( int d = -1 ; d <= 1 ; d++ ) if( cnt.find( mp( x - 1, y + d ) ) != cnt.end() ) flag = true;\n\t\t\t\tif( !flag ) GG();\n\t\t\t}\n\t\t\tif( y )\n\t\t\t{\n\t\t\t\tbool flag = false;\n\t\t\t\tfor( int d = -1 ; d <= 1 ; d++ ) if( cnt.find( mp( x + d, y - 1 ) ) != cnt.end() ) flag = true;\n\t\t\t\tif( !flag ) GG();\n\t\t\t}\n\t\t\tr++;\n\t\t}\n\t\tfor( int i = l, j = l, last = 0, left = 0 ; i < r ; i = j )\n\t\t{\n\t\t\twhile( j < r && c[ j ].yy == c[ i ].yy ) j++;\n\t\t\tint now = j - i, del = 0;\n\n\t\t\tif( cnt.find( mp( c[ i ].xx - c[ i ].yy - 1, c[ i ].yy - 1 ) ) != cnt.end() ) {ret -= now, last=c[i].yy,left=min(now,left);continue;}\n            if( c[ i ].yy == last + 1 ) del = min( now, left ), ret -= del;\n\t\t\tlast = c[ i ].yy; left = now;\n\t\t}\n\t}\n\treturn printf( \"%d\\n\", ret ), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nint N, A[101010], B[101010];\n\nvoid fail()\n{\n\tputs(\"-1\");\n\texit(0);\n}\n\nint bas[101010];\nmap<pair<int, int>, int> P;\n\nbool is_good(int y, int x)\n{\n\treturn P.count(make_pair(y - 1, x - 1)) > 0;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i) scanf(\"%d%d\", A + i, B + i);\n\n\tif (A[0] != 0) fail();\n\tif (B[1] != 0) fail();\n\tif (A[1] != B[0]) fail();\n\tint D = A[1];\n\n\tfor (int i = 2; i < N; ++i) {\n\t\tif (A[i] == 0 || B[i] == 0 || A[i] + B[i] < D) fail();\n\t}\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (A[i] + B[i] == D) {\n\t\t\tbas[A[i]] += 1;\n\t\t}\n\t}\n\n\tint ret = 0;\n\tfor (int i = 0; i < D; ++i) {\n\t\tif (bas[i] == 0) fail();\n\t\tret += max(bas[i], bas[i + 1]);\n\t}\n\n\tfor (int i = 0; i < N; ++i) P[make_pair(A[i], B[i])] += 1;\n\n\t/*\n\tfor (int i = 2; i < N; ++i) if (A[i] + B[i] != D) {\n\t\tint x = A[i], y = B[i];\n\t\tif (P.count(make_pair(x - 1, y - 1))) {\n\t\t\t++ret;\n\t\t} else if (P.count(make_pair(x, y - 1)) && P.count(make_pair(x - 1, y))) {\n\t\t\tret += 2;\n\t\t} else fail();\n\t}\n\t*/\n\tfor (map<pair<int, int>, int>::iterator p = P.begin(); p != P.end(); ++p) {\n\t\tint y = p->first.first, x = p->first.second;\n\t\tif (y + x == D) continue;\n\n\t\tif (P.count(make_pair(y - 1, x + 1)) == 0) {\n\t\t\tvector<pair<pair<int, int>, int> > V;\n\t\t\tfor (;;) {\n\t\t\t\tint cnt = P[make_pair(y, x)];\n\t\t\t\tif (cnt == 0) break;\n\t\t\t\tV.push_back(make_pair(make_pair(y, x), cnt));\n\t\t\t\ty += 1;\n\t\t\t\tx -= 1;\n\t\t\t}\n\n\t\t\tif (V.size() == 1) {\n\t\t\t\ty = V[0].first.first, x = V[0].first.second;\n\t\t\t\tif (P.count(make_pair(y - 1, x - 1))) {\n\t\t\t\t\tret += V[0].second;\n\t\t\t\t} else if (P.count(make_pair(y - 1, x)) && P.count(make_pair(y, x - 1))) {\n\t\t\t\t\tret += 2 * V[0].second;\n\t\t\t\t} else fail();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t//\tprintf(\"%d\\n\", ret);\n\t\t\tbool waf = false;\n\t\t\t{\n\t\t\t\ty = V[0].first.first, x = V[0].first.second;\n\t\t\t\tif (P.count(make_pair(y - 1, x)) || P.count(make_pair(y - 1, x - 1))) {\n\t\t\t\t\tif (!P.count(make_pair(y - 1, x - 1))) waf = true;\n\t\t\t\t\tret += V[0].second;\n\t\t\t\t} else fail();\n\t\t\t}\n\t\t\t{\n\t\t\t\ty = V[V.size()-1].first.first, x = V[V.size()-1].first.second;\n\t\t\t\tif (P.count(make_pair(y, x - 1)) || P.count(make_pair(y - 1, x - 1))) {\n\t\t\t\t\tif (!P.count(make_pair(y - 1, x - 1))) waf = true;\n\t\t\t\t\tret += V[V.size()-1].second;\n\t\t\t\t} else fail();\n\t\t\t}\n\t\t//\tprintf(\"%d\\n\", ret);\n\t\t\tif (!waf) V[0].second = V[V.size()-1].second = 0;\n\t\t\tfor (int i = 1; i < V.size(); ++i) {\n\t\t\t\ty = V[i].first.first, x = V[i].first.second;\n\t\t\t\tif (P.count(make_pair(y - 1, x - 1))) {\n\t\t\t\t\tret += V[i].second;\n\t\t\t\t\tV[i].second = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i < V.size(); ++i) {\n\t\t\t\tret += max(V[i].second, V[i - 1].second);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ());\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint power(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxn = (int) 1e5 + 10;\npair<int, int> tosort[maxn];\n\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    tosort[i] = mp(x, y);\n  }\n  return 1;\n}\n\nvoid solve() {\n  if (tosort[0].first || tosort[1].second) {\n    printf(\"-1\\n\");while(1);\n    return;\n  }\n  map<pair<int, int>, int> cnt;\n  for (int i = 0; i < n; ++i) {\n    int x = tosort[i].first;\n    int y = tosort[i].second;\n    if (i != 0 && !x) {\n        while(1);\n      printf(\"-1\\n\");\n      return;\n    }\n    if (i != 1 && !y) {\n        while(1);\n      printf(\"-1\\n\");\n      return;\n    }\n    cnt[{x, y}] += 1;\n    tosort[i] = {x + y, y};\n  }\n  sort(tosort, tosort + n);\n\n  int res = 2 * n - 2;\n  for (int i = 0; i < n;) {\n    int i0 = i;\n    while (i < n && tosort[i].first == tosort[i0].first) {\n      int x = tosort[i].first, y = tosort[i].second;\n      x -= y;\n\n      for (int iter = 0; iter < 2; ++iter) {\n        auto &cur = (!iter ? x : y);\n        if (!cur) {\n          continue;\n        }\n        auto &cury = (iter ? x : y);\n        --cur;\n        bool ok = 0;\n        for (int dx = -1; dx <= 1; ++dx) {\n          cury += dx;\n          if (cnt.count({x, y})) {\n            ok = 1;\n          }\n          cury -= dx;\n        }\n        ++cur;\n        if (!ok) {\n            while(1);\n          printf(\"-1\\n\");\n          return;\n        }\n      }\n      ++i;\n    }\n\n    int last = 0, left = 0;\n    for (int j = i0; j < i;) {\n      int j0 = j;\n      while (j < i && tosort[j].second == tosort[j0].second) {\n        ++j;\n      }\n      int now = j - j0;\n\n      int del = 0;\n      if (last + 1 == tosort[j0].second) {\n        del = min(now, left);\n        res -= del;\n      }\n      if (cnt.count({tosort[j0].first - tosort[j0].second - 1, tosort[j0].second - 1})) {\n        res -= now - del;\n        now = del;\n      }\n      left = now;\n      last = tosort[j0].second;\n    }\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint nr, N, a[100009], b[100009], A[100009], B[100009], id[100009], sz[100009], may[100009], both1[100009], dp[100009][2];\nconst int INF = 1e8;\n\nbool cmp (int i, int j)\n{\n    if (A[i] + B[i] == A[j] + B[j]) return (A[i] < A[j]);\n    return (A[i] + B[i] < A[j] + B[j]);\n}\n\nint findPair (int x, int y)\n{\n    int p = 1, u = nr, mij;\n    while (p <= u)\n    {\n        mij = (p + u) >> 1;\n        if (a[mij] == x && b[mij] == y) return mij;\n        if (a[mij] + b[mij] < x + y || (a[mij] + b[mij] == x + y && a[mij] < x)) p = mij + 1;\n        else u = mij - 1;\n    }\n    return 0;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d\", &A[i], &B[i]), id[i] = i;\nsort (id + 1, id + N + 1, cmp);\nif (A[2] != B[1] || A[id[1]] + B[id[1]] < A[2] || A[1] != 0 || B[2] != 0)\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=N; i++)\n    if ((A[i] == 0 && i != 1) || (B[i] == 0 && i != 2))\n    {\n        printf (\"-1\\n\");\n        return 0;\n    }\nfor (int i=1; i<=N; i++)\n{\n    int j = i;\n    while (j + 1 <= N && A[id[j]] == A[id[j + 1]] && B[id[j]] == B[id[j + 1]])\n        j ++;\n    a[++nr] = A[id[i]], b[nr] = B[id[i]], sz[nr] = j - i + 1;\n    i = j;\n}\nfor (int i=1; i<=nr; i++)\n    may[i] = (findPair (a[i] + 1, b[i] - 1) != 0),\n    both1[i] = (findPair (a[i] - 1, b[i] - 1) != 0);\nif (!may[1])\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=nr; i++)\n    if ((a[i] > 0 && findPair (a[i] - 1, b[i]) == 0 && findPair (a[i] - 1, b[i] + 1) == 0 && both1[i] == 0) ||\n        (b[i] > 0 && findPair (a[i], b[i] - 1) == 0 && findPair (a[i] + 1, b[i] - 1) == 0 && both1[i] == 0))\n        {\n            printf (\"-1\\n\");\n            return 0;\n        }\nfor (int i=1; i<=nr; i++)\n    for (int j=0; j<2; j++)\n        dp[i][j] = INF;\ndp[1][1] = max (1, sz[2]);\nfor (int i=1; i<nr; i++)\n    for (int j=0; j<=may[i]; j++)\n        for (int k=0; k<=may[i + 1]; k++)\n        {\n            if (k == 0 && both1[i + 1] == 1)\n                dp[i + 1][k] = min (dp[i + 1][k], dp[i][j] + sz[i + 1]);\n            int curr = dp[i][j];\n            if (j == 0)\n            {\n                if (findPair (a[i + 1] - 1, b[i + 1]) == 0 && both1[i + 1] == 0) continue;\n                curr += sz[i + 1];\n            }\n            if (k == 0 && b[i + 1] > 0)\n                curr += sz[i + 1];\n            else\n            if (k == 1) curr += max (sz[i + 1], sz[i + 2]);\n            if (curr < dp[i + 1][k])\n                dp[i + 1][k] = curr;\n        }\nprintf (\"%d\\n\", dp[nr][0]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nvoid ng() {\n        printf(\"-1\\n\");\n        exit(0);\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        set<pair<int, int>> ps;\n        vector<pair<int, int>> p;\n        for (int i = 0; i < n; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                p.emplace_back(a, b);\n                ps.insert({a, b});\n        }\n        if (p[0].first != 0 || p[1].second != 0) ng();\n        if (p[0].second != p[1].first) ng();\n        if (p[0].second == 0) ng();\n        for (int i = 2; i < n; i ++) {\n                int a, b;\n                tie(a, b) = p[i];\n                if (a == 0 || b == 0) ng();\n                if (!ps.count({a - 1, b + 1}) && !ps.count({a - 1, b}) && !ps.count({a - 1, b - 1})) ng();\n                if (!ps.count({a + 1, b - 1}) && !ps.count({a, b - 1}) && !ps.count({a - 1, b - 1})) ng();\n        }\n        map<int, map<int, int>> s;\n        for (int i = 0; i < n; i ++) {\n                s[p[i].first + p[i].second][p[i].first] ++;\n        }\n        int matching = 0;\n        for (auto mpmp : s) {\n                auto sum = mpmp.first;\n                auto mp = mpmp.second;\n                vector<pair<int, int>> v;\n                for (auto it : mp) {\n                        v.emplace_back(it.first, it.second);\n                }\n                sort(v.begin(), v.end());\n                vector<pair<bool, pair<int, int>>> t; //(bottom left exists, number of the same position)\n                for (auto u : v) {\n                        int a = u.first;\n                        int b = sum - a;\n                        bool ex = ps.count({a - 1, b - 1});\n                        t.push_back({ex, {u.second, u.second}});\n                }\n                for (int i = 0; i < (int) t.size(); i ++) {\n                        if (t[i].first) {\n                                int d = min(t[i].second.first, t[i].second.second);\n                                matching += d;\n                                t[i].second.first -= d;\n                                t[i].second.second -= d;\n                        }\n                        if (t[i].second.second > 0 && i + 1 < (int) t.size()) {\n                                int d = min(t[i].second.second, t[i + 1].second.first);\n                                matching += d;\n                                t[i + 1].second.first -= d;\n                        }\n                }\n        }\n        printf(\"%d\\n\", 2 * n - 2 - matching);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 10;\nint ds[2][maxn];\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &ds[0][i], &ds[1][i]);\n  }\n  return 1;\n}\n\nint res;\n\nvoid solve() {\n  if (ds[0][0] || ds[1][1]) {\n    printf(\"-1\\n\");\n    return;\n  }\n  int d = ds[0][1];\n  if (ds[1][0] != d) {\n    printf(\"-1\\n\");\n    return;\n  }\n  vector<int> big(d + 1, 0);\n\n  vector<int> vs[2][d + 1];\n  for (int v = 0; v < n; ++v) {\n    int left = ds[0][v] + ds[1][v] - d;\n    if (left < 0 || abs(ds[0][v] - ds[1][v]) > d) {\n      printf(\"-1\\n\");\n      return;\n    }\n    if (left > 0) {\n      vs[left & 1][(ds[0][v] - ds[1][v] + d) / 2].pb((left + 1) / 2);\n    } else {\n      big[ds[0][v]] += 1;\n    }\n  }\n  res = 0;\n  for (int odd = 0; odd < 2; ++odd) {\n    vector<int> cool;\n    for (int i = 0; i <= d - odd; ++i) {\n      auto &cur = vs[odd][i];\n      sort(cur.begin(), cur.end());\n      int last = 0;\n      for (int i = 0; i < sz(cur);) {\n        int i0 = i;\n        while (i < sz(cur) && cur[i] == cur[i0]) {\n          ++i;\n        }\n        //eprintf(\"%dx  %d\\n\", i - i0, cur[i0]);\n        if (cur[i0] != last + 1) {\n          printf(\"-1\\n\");\n          return;\n        }\n        res += i - i0;\n        if (odd && cur[i0] == 1) {\n          cool.pb(i - i0);\n        }\n        ++last;\n      }\n      if (sz(cool) == i) {\n        cool.pb(0);\n      }\n    }\n    if (odd) {\n      for (int i = 0; i < sz(cool); ++i) {\n        while (cool[i]) {\n          int j = i;\n          while (j < sz(cool) && cool[j]) {\n            --cool[j];\n            ++j;\n          }\n          ++res;\n        }\n      }\n    }\n  }\n  if (big[0] != 1 || big[d] != 1) {\n    printf(\"-1\\n\");\n    return;\n  }\n  for (int i = 1; i < d; ++i) {\n    if (big[i] == 0) {\n      printf(\"-1\\n\");\n      return;\n    }\n  }\n  for (int i = 0; i < d; ++i) {\n    res += max(big[i], big[i + 1]);\n  }\n  if (0) {\n  printf(\"%d\\n\", res);\n  }\n}\n\nvoid gen() {\n  vector<vector<int> > es;\n  vector<pair<int, int> > edges;\n\n  int m;\n  while (1) {\n    beg:;\n  n = rnd(20) + 2;\n  es = vector<vector<int> >(n);\n  edges.clear();\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      edges.pb(mp(i, j));\n    }\n  }\n  random_shuffle(edges.begin(), edges.end(), rnd);\n  m = rnd(sz(edges) + 1);\n  edges.resize(m);\n  for (auto cur : edges) {\n    int i = cur.first, j = cur.second;\n    es[i].pb(j), es[j].pb(i);\n  }\n\n  for (int i = 0; i < 2; ++i) {\n    auto &dist = ds[i];\n    for (int v = 0; v < n; ++v) {\n      dist[v] = inf;\n    }\n    vector<int> st;\n    st.pb(i);\n    dist[i] = 0;\n    for (int l = 0; l < sz(st); ++l) {\n      int v = st[l];\n      for (int u : es[v]) {\n        if (dist[u] > dist[v] + 1) {\n          st.pb(u);\n          dist[u] = dist[v] + 1;\n        }\n      }\n    }\n    if (sz(st) < n) {\n      goto beg;\n    }\n  }\n  break;\n  }\n  solve();\n  if (res == -1 || res > m) {\n    eprintf(\"n = %d\\n\", n);\n    for (int i = 0; i < sz(edges); ++i) {\n      eprintf(\"%d %d\\n\", edges[i].first + 1, edges[i].second + 1);\n    }\n    eprintf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n      eprintf(\"%d %d\\n\", ds[0][i], ds[1][i]);\n    }\n    exit(1);\n  }\n}\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  if (1) {\n    int cnt = 0;\n  while (1) {\n    if (++cnt % 1000 == 0) {\n      eprintf(\"Ok %d\\n\", cnt);\n    }\n    gen();\n  }\n  }\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\n//const int mod=(int)1e9+7;\n\nconst llint big=(llint)(2.19e15+1)*18;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\n#define dme cout<<\"-1\\n\";return 0\nint main(void){\n\tint n,i;cin>>n;\n\tmap<pair<int,int>,int>ban;\n\tfor(i=0;i<n;i++){\n\t\tint a,b;cin>>a>>b;\n\t\tif((i==0)^(a==0)){dme;}\n\t\tif((i==1)^(b==0)){dme;}\n\t\tban[mp(a+b,a)]++;\n\t}\n\t//dp\n\tint ans=-2,sen=0;\n\tpair<int,int>maebas=mp(-1,-1);\n\tfor(auto it:ban){\n\t\tint a=it.fir.sec;\n\t\tint b=it.fir.fir-a;\n\t\tint kaz=it.sec;\n\t\tif(kaz==0){continue;}\n\t\tif(!(maebas.fir==it.fir.fir&&maebas.sec+1==it.fir.sec)){sen=0;}//\n\t\tif(ban[mp(a-1+b-1,a-1)]>0){ans+=kaz;mineq(sen,kaz);}//\n\t\telse{\n\t\t\tans+=kaz;ans+=max(0,kaz-sen);sen=kaz;\n\t\t\tif(ban[mp(a-1+b,a-1)]+ban[mp(a+b,a-1)]==0&&a>0&&b>0){dme;}\n\t\t\tif(ban[mp(a+b-1,a)]+ban[mp(a+b,a+1)]==0&&a>0&&b>0){dme;}\n\t\t}\n\t\tmaebas=it.fir;\n\t\t\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#define ll long long\n#define inf 1000000007\n#define inf16 0x3f3f3f3f\n#define INF 1000000000000000007LL\n#define VI vector<int>\n#define VPII vector<pair<int, int> >\n#define VLL vector<ll>\n#define PII pair<int, int>\n#define st first\n#define nd second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define endl '\\n'\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\nconst int N = 1e5+7;\n\nint n, ans;\n\nint A[N];\nint B[N];\n\nPII mB[N]; //maksymalne B dla danego A\nPII mA[N]; //maksymalne A dla danego B\n\nmap<PII, int> takie;\n\nVI G[N];\n\nqueue<int> Q;\n\nint dist[3][N];\n\nbool check()\n{\n\tfor(int i = 1; i <= 2; ++i)\n\t{\n\t\tfor(int v = 1; v <= n; ++v)\n\t\t{\n\t\t\tdist[i][v] = inf;\n\t\t}\n\n\t\tdist[i][i] = 0;\n\t\tQ.push(i);\n\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tint v = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tfor(auto it:G[v])\n\t\t\t{\n\t\t\t\tif(dist[i][it]>dist[i][v]+1)\n\t\t\t\t{\n\t\t\t\t\tdist[i][it] = dist[i][v]+1;\n\t\t\t\t\tQ.push(it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tif(A[i]!=dist[1][i])\n\t\t\treturn 0;\n\n\t\tif(B[i]!=dist[2][i])\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tcin >> n;\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> A[i] >> B[i];\n\t\ttakie[{A[i], B[i]}] = i;\n\t\tmB[A[i]] = max(mB[A[i]], mp(B[i], i));\n\t\tmA[B[i]] = max(mA[B[i]], mp(A[i], i));\n\t}\n\n\tif(A[2]!=B[1] || A[1] || B[2])\n\t{\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tif(A[2]==1)\n\t{\n\t\tG[1].pb(2);\n\t\tG[2].pb(1);\n\t}\n\n\tfor(int i = 3; i <= n; ++i)\n\t{\n\t\tif(takie.find({A[i]-1, B[i]-1})!=takie.end())\n\t\t{\n\t\t\tG[i].pb(takie[{A[i]-1, B[i]-1}]);\n\t\t\tG[takie[{A[i]-1, B[i]-1}]].pb(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(mB[A[i]-1].st>B[i]-1 && mA[B[i]-1].st>A[i]-1)\n\t\t\t{\n\t\t\t\tG[i].pb(mB[A[i]-1].nd);\n\t\t\t\tG[i].pb(mA[B[i]-1].nd);\n\t\t\t\tG[mB[A[i]-1].nd].pb(i);\n\t\t\t\tG[mA[B[i]-1].nd].pb(i);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!check())\n\t{\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tsort(ALL(G[i]));\n\t\tG[i].erase(unique(ALL(G[i])), G[i].end());\n\t\tans += G[i].size();\n\t}\n\n\tans /= 2;\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define N 100010\nint n;\nint a[N], b[N];\nmap<PII, set<int> > A;\n\nvoid end() {\n\tputs (\"-1\");\n\texit(0);\n}\n\nint path[N], L;\nbool v[N];\n\n//vector<int> c[N];\n// c[i] = connect with path[i] and path[i+1]\n//int sc[N];\nmap<PII, set<int> > B;\n\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i ++) {\n  \tcin >> a[i] >> b[i];\n  \tA[mp(a[i], b[i])].insert(i);\n  }\n  if (a[0] != 0 || b[1] != 0 || a[1] != b[0]) end();\n  L = a[1];\n  path[0] = 0;\n  path[L] = 1;\n  for (int i = 1; i < L; i++)\n  \tpath[i] = -1;\n  for (int i = 2; i < n; i++)\n  \tif (a[i] + b[i] == L) {\n  \t\tif (path[a[i]] == -1) {\n  \t\t   path[a[i]] = i;\n  \t\t   v[i] = true;\n  \t\t}\n  \t}\n  for (int i = 1; i < L; i ++)\n  \tif (path[i] == -1) end();\n  for (int i = 2; i < n; i ++) {\n    if (a[i] == 0 || b[i] == 0) end();\n    if (a[i] + b[i] < L) end();\n  }\n  int S = 0;\n  S += L; // path\n  for (int i = 2; i < n; i ++) if (!v[i]) {\n    if (a[i] + b[i] == L) {\n      S += 2;\n      B[mp(a[i], b[i])].insert(i);\n    } else {\n      if (A.find(mp(a[i]-1, b[i]-1)) != A.end()) {\n        S ++;\n      } else \n      if (A.find(mp(a[i]-1, b[i])) != A.end() && A.find(mp(a[i], b[i]-1)) != A.end()) {\n        S += 2;\n        B[mp(a[i], b[i])].insert(i);\n      } else {\n        end();\n      }\n    }\n  }\n  /*\n  for (int i = 0; i < L; i ++) {\n    sc[i] = (int) c[i].size();\n  }\n  for (int i = 0; i < L-1; i ++) {\n    int T = min(sc[i], sc[i+1]);\n    S -= T;\n  }\n  */\n  for (map<PII, set<int> >::iterator i = B.begin(); i != B.end(); i++) {\n    int l = i->fi.fi;\n    int r = i->fi.se;\n    if (B.find(mp(l+1,r-1)) != B.end()) {\n      S -= min( (int) i->se.size(), (int) B[mp(l+1,r-1)].size());\n    }\n  }\n  cout << S << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    mp.clear();\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one&&shit[tk].two==shit[k].two){\n                tk++;\n            }\n            int now=tk-k;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                last=shit[i].one;\n                left=now;\n                continue;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n            bool one=0,two=0;\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            if((one==0||two==0)&&shit[k].one!=0&&shit[k].two!=0){\n                //printf(\"%d k %d\\n\",shit[k].one,shit[k].two);\n                puts(\"-1\");\n                return 0;\n            }\n            if(last+1==shit[k].one){\n                ans-=min(now,left);\n            }\n            last=shit[k].one;\n            left=now;\n        }\n        //printf(\"%d %d\\n\",shit[i].one+shit[i].two,ans);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    mp.clear();\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one&&shit[tk].two==shit[k].two){\n                tk++;\n            }\n            int now=tk-k;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                last=shit[k].one;\n                left=now;\n                continue;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n            bool one=0,two=0;\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            if((one==0||two==0)&&k!=1&&k!=2){\n                //printf(\"%d k %d\\n\",shit[k].one,shit[k].two);\n                puts(\"-1\");\n                return 0;\n            }\n            if(last+1==shit[k].one){\n                ans-=min(now,left);\n            }\n            last=shit[k].one;\n            left=now;\n        }\n        //printf(\"%d %d\\n\",shit[i].one+shit[i].two,ans);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define fill( x, y ) memset( x, y, sizeof x )\n#define copy( x, y ) memcpy( x, y, sizeof x )\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pa;\n\ninline int read()\n{\n\tint sc = 0, f = 1; char ch = getchar();\n\twhile( ch < '0' || ch > '9' ) { if( ch == '-' ) f = -1; ch = getchar(); }\n\twhile( ch >= '0' && ch <= '9' ) sc = sc * 10 + ch - '0', ch = getchar();\n\treturn sc * f;\n}\n\nconst int MAXN = 100005;\n\nint n, a[MAXN], b[MAXN];\nmap < pa, bool > cnt;\npa c[MAXN];\n\ninline void GG() { puts( \"-1\" ); exit( 0 ); }\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen( \"data.in\", \"r\", stdin );\n#endif\n\tn = read();\n\tfor( int i = 1 ; i <= n ; i++ )\n\t{\n\t\ta[ i ] = read(), b[ i ] = read(), c[ i ] = mp( a[ i ] + b[ i ], b[ i ] );\n\t\tif( !a[ i ] && i != 1 ) GG();\n\t\tif( !b[ i ] && i != 2 ) GG();\n\t\tcnt[ mp( a[ i ], b[ i ] ) ] = 1;\n\t}\n\tif( a[ 1 ] || b[ 2 ] ) GG();\n\tsort( c + 1, c + n + 1 );\n\tint ret = n - 1 << 1;\n\tfor( int l = 1, r = 1 ; l <= n ; l = r )\n\t{\n\t\twhile( r <= n && c[ r ].xx == c[ l ].xx )\n\t\t{\n\t\t\tint x = c[ r ].xx - c[ r ].yy, y = c[ r ].yy;\n\t\t\tif( x )\n\t\t\t{\n\t\t\t\tbool flag = false;\n\t\t\t\tfor( int d = -1 ; d <= 1 ; d++ ) if( cnt.find( mp( x - 1, y + d ) ) != cnt.end() ) flag = true;\n\t\t\t\tif( !flag ) GG();\n\t\t\t}\n\t\t\tif( y )\n\t\t\t{\n\t\t\t\tbool flag = true;\n\t\t\t\tfor( int d = -1 ; d <= 1 ; d++ ) if( cnt.find( mp( x + d, y - 1 ) ) != cnt.end() ) flag = true;\n\t\t\t\tif( !flag ) GG();\n\t\t\t}\n\t\t\tr++;\n\t\t}\n\t\tfor( int i = l, j = l, last = 0, left = 0 ; i < r ; i = j )\n\t\t{\n\t\t\twhile( j < r && c[ j ].yy == c[ i ].yy ) j++;\n\t\t\tint now = j - i, del = 0;\n\t\t\tif( c[ i ].yy == last + 1 ) del = min( now, left ), ret -= del;\n\t\t\tif( cnt.find( mp( c[ i ].xx - c[ i ].yy - 1, c[ i ].yy - 1 ) ) != cnt.end() ) ret -= now - del, now = del;\n\t\t\tlast = c[ i ].yy; left = now;\n\t\t}\n\t}\n\treturn printf( \"%d\\n\", ret ), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define fill( x, y ) memset( x, y, sizeof x )\n#define copy( x, y ) memcpy( x, y, sizeof x )\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pa;\n\ninline int read()\n{\n\tint sc = 0, f = 1; char ch = getchar();\n\twhile( ch < '0' || ch > '9' ) { if( ch == '-' ) f = -1; ch = getchar(); }\n\twhile( ch >= '0' && ch <= '9' ) sc = sc * 10 + ch - '0', ch = getchar();\n\treturn sc * f;\n}\n\nconst int MAXN = 100005;\n\nint n, a[MAXN], b[MAXN];\nmap < pa, bool > cnt;\npa c[MAXN];\n\ninline void GG() { puts( \"-1\" ); exit( 0 ); }\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen( \"data.in\", \"r\", stdin );\n#endif\n\tn = read();\n\tfor( int i = 1 ; i <= n ; i++ )\n\t{\n\t\ta[ i ] = read(), b[ i ] = read(), c[ i ] = mp( a[ i ] + b[ i ], b[ i ] );\n\t\tif( !a[ i ] && i != 1 ) GG();\n\t\tif( !b[ i ] && i != 2 ) GG();\n\t\tcnt[ mp( a[ i ], b[ i ] ) ] = 1;\n\t}\n\tif( a[ 1 ] || b[ 2 ] ) GG();\n\tsort( c + 1, c + n + 1 );\n\tint ret = n - 1 << 1;\n\tfor( int l = 1, r = 1 ; l <= n ; l = r )\n\t{\n\t\twhile( r <= n && c[ r ].xx == c[ l ].xx )\n\t\t{\n\t\t\tint x = c[ r ].xx - c[ r ].yy, y = c[ r ].yy;\n\t\t\tif( x )\n\t\t\t{\n\t\t\t\tbool flag = false;\n\t\t\t\tfor( int d = -1 ; d <= 1 ; d++ ) if( cnt.find( mp( x - 1, y + d ) ) != cnt.end() ) flag = true;\n\t\t\t\tif( !flag ) GG();\n\t\t\t}\n\t\t\tif( y )\n\t\t\t{\n\t\t\t\tbool flag = true;\n\t\t\t\tfor( int d = -1 ; d <= 1 ; d++ ) if( cnt.find( mp( x + d, y - 1 ) ) != cnt.end() ) flag = true;\n\t\t\t\tif( !flag ) GG();\n\t\t\t}\n\t\t\tr++;\n\t\t}\n\t\tfor( int i = l, j = l, last = 0, left = 0 ; i <= r ; i = j )\n\t\t{\n\t\t\twhile( j <= r && c[ j ].yy == c[ i ].yy ) j++;\n\t\t\tint now = j - i, del = 0;\n\t\t\tif( c[ i ].yy == last + 1 ) del = min( now, left ), ret -= del;\n\t\t\tif( cnt.find( mp( c[ i ].xx - c[ i ].yy - 1, c[ i ].yy - 1 ) ) != cnt.end() ) ret -= now - del, now = del;\n\t\t\tlast = c[ i ].yy; left = now;\n\t\t}\n\t}\n\treturn printf( \"%d\\n\", ret ), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n        return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    mp.clear();\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n        mp[shit[i]]=1;\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].two==shit[2].one&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one){\n                tk++;\n            }\n            int now=tk-k;\n            bool one=0,two=0;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                one=1;two=1;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            if(shit[k].one==0)one=1;\n            if(shit[k].two==0) two=1;\n            if(one==0||two==0){\n                puts(\"-1\");\n                return 0;\n            }\n            int del=0;\n            if(last+1==shit[k].one){\n                del=min(now,left);\n                ans-=del;\n            }\n            tmp1.two--;\n            if(mp.count(tmp1)){\n                ans-=now-del;\n                now=del;\n            }\n            last=shit[k].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n        return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    mp.clear();\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n        mp[shit[i]]=1;\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].two==shit[2].one&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one){\n                tk++;\n            }\n            int now=tk-k;\n            bool one=0,two=0;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                now=min(now,left);\n                last=shit[k].one;\n                left=now;\n                continue;\n                one=1;two=1;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            if(shit[k].one==0)one=1;\n            if(shit[k].two==0) two=1;\n            if(one==0||two==0){\n                puts(\"-1\");\n                return 0;\n            }\n            int del=0;\n            if(last+1==shit[k].one){\n                del=min(now,left);\n                ans-=del;\n            }\n            tmp1.two--;\n\n            last=shit[k].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n        return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    mp.clear();\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n        mp[shit[i]]=1;\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].two==shit[2].one&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one){\n                tk++;\n            }\n            int now=tk-k;\n            bool one=0,two=0;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                now=min(now,left);\n                ast=shit[k].one;\n                left=now;\n                continue;\n                one=1;two=1;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            if(shit[k].one==0)one=1;\n            if(shit[k].two==0) two=1;\n            if(one==0||two==0){\n                puts(\"-1\");\n                return 0;\n            }\n            int del=0;\n            if(last+1==shit[k].one){\n                del=min(now,left);\n                ans-=del;\n            }\n            tmp1.two--;\n\n            last=shit[k].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define N 100010\nint n;\nint a[N], b[N];\nmap<PII, set<int> > A;\n\nvoid end() {\n\tputs (\"-1\");\n\texit(0);\n}\n\nint path[N], L;\nbool v[N];\n\n//vector<int> c[N];\n// c[i] = connect with path[i] and path[i+1]\n//int sc[N];\nmap<PII, set<int> > B;\n\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i ++) {\n  \tcin >> a[i] >> b[i];\n  \tA[mp(a[i], b[i])].insert(i);\n  }\n  if (a[0] != 0 || b[1] != 0 || a[1] != b[0]) end();\n  L = a[1];\n  path[0] = 0;\n  path[L] = 1;\n  for (int i = 1; i < L; i++)\n  \tpath[i] = -1;\n  for (int i = 2; i < n; i++)\n  \tif (a[i] + b[i] == L) {\n  \t\tif (path[a[i]] == -1) {\n  \t\t   path[a[i]] = i;\n  \t\t   v[i] = true;\n  \t\t}\n  \t}\n  for (int i = 1; i < L; i ++)\n  \tif (path[i] == -1) end();\n  for (int i = 2; i < n; i ++) {\n    if (a[i] == 0 || b[i] == 0) end();\n    if (a[i] + b[i] < L) end();\n  }\n  int S = 0;\n  S += L; // path\n  for (int i = 2; i < n; i ++) {\n    if (a[i] + b[i] == L) {\n      S += 2;\n    } else {\n      if (A.find(mp(a[i]-1, b[i]-1)) != A.end()) {\n        S ++;\n      } else \n      if (A.find(mp(a[i]-1, b[i])) != A.end() && A.find(mp(a[i], b[i]-1)) != A.end()) {\n        S += 2;\n        B[mp(a[i], b[i])].insert(i);\n      } else {\n        end();\n      }\n    }\n  }\n  /*\n  for (int i = 0; i < L; i ++) {\n    sc[i] = (int) c[i].size();\n  }\n  for (int i = 0; i < L-1; i ++) {\n    int T = min(sc[i], sc[i+1]);\n    S -= T;\n  }\n  */\n  for (map<PII, set<int> >::iterator i = B.begin(); i != B.end(); i++) {\n    int l = i->fi.fi;\n    int r = i->fi.se;\n    if (B.find(mp(l+1,r-1)) != B.end()) {\n      S -= min( (int) i->se.size(), (int) B[mp(l+1,r-1)].size());\n    }\n  }\n  cout << S << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=0;\n    ans++;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+3,shit+n+1,cmp);\n    mp.clear();\n    mp[shit[1]]=1;\n    mp[shit[2]]=1;\n    for(int i=3;i<=n;)\n    {\n        int j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        if(shit[i].one+shit[i].two==mn){\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n                //printf(\"%d %d\\n\",mp.count(tmp1),mp.count(tmp2));\n                if(mp.count(tmp1)&&mp.count(tmp2)){\n                    continue;\n                }\n                else{\n                    puts(\"-1\");\n                    return 0;\n                }\n            }\n            ans=ans+(j-i-mn+1)*2+mn;\n        }\n        else{\n            int flag=0;\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two-1;\n                if(mp.count(tmp1)){\n                    ans++;continue;\n                }\n                if(shit[k].one==shit[k-1].one&&shit[k].two==shit[k-1].two){\n                    ans+=2;\n                    continue;\n                }\n                bool one=0,two=0;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n\n                if(mp.count(tmp1)&&mp.count(tmp2)){\n                    ans=ans+2-flag;\n                    flag=1;\n                    continue;\n                }\n                else{\n                    flag=0;\n                }\n                one=one|mp.count(tmp1);\n                tmp1.two--;\n                one=one|mp.count(tmp1);\n\n                two=two|mp.count(tmp2);\n                tmp2.one--;\n                two=two|mp.count(tmp2);\n                if(one&&two){\n                    ans+=2;continue;\n                }\n                puts(\"-1\");\n                return 0;\n            }\n        }\n        i=j;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 26.11.2019 22:59:30       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n  }\n  if (a[0] != 0 || b[1] != 0 || a[1] == 0 || a[1] != b[0]) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  int d = a[1];\n  vector<int> was(d + 1, 0);\n  for (int i = 0; i < n; i++) {\n    if (a[i] + b[i] < d) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    if (a[i] + b[i] == d) {\n      was[a[i]] = 1;\n    }\n  }\n  if (*min_element(was.begin(), was.end()) == 0) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  set<pair<int, int>> s;\n  for (int i = 0; i < n; i++) {\n    s.emplace(a[i], b[i]);\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (s.find({a[i] - 1, b[i] - 1}) != s.end()) {\n      ans += 1;\n    } else {\n      ans += 2;\n      if (a[i] > 0 && s.find({a[i] - 1, b[i]}) == s.end() && s.find({a[i] - 1, b[i] + 1}) == s.end()) {\n        cout << -1 << '\\n';\n        return 0;\n      }\n      if (b[i] > 0 && s.find({a[i], b[i] - 1}) == s.end() && s.find({a[i] + 1, b[i] - 1}) == s.end()) {\n        cout << -1 << '\\n';\n        return 0;\n      }\n    }\n  }\n  cout << ans - d - 2 << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint n;\nvvi a;\n\nint f(int i,int x){\n\treturn upper_bound(a[i].begin(),a[i].end(),x)-lower_bound(a[i].begin(),a[i].end(),x);\n}\n\nint main(){\n\tcin>>n;\n\ta=vvi(n+1);\n\tint res=n-1,d;\n\tfor(int i=0;i<n;i++){\n\t\tint A,B;\n\t\tcin>>A>>B;\n\t\ta[A].push_back(B);\n\t\tif(i==1) d=A;\n\t}\n\tfor(int i=0;i<n;i++) sort(a[i].begin(),a[i].end());\n\tif(a[0].size()!=1||a[0][0]!=d) res=-inf;\n\tfor(int i=1;i<n;i++) for(int j=0;j<a[i].size();j++){\n\t\tint x=a[i][j];\n\t\tif(x<abs(i-d)||i+d<x) res=-inf;\n\t\tif(!x&&!j||f(i-1,x-1)) continue;\n\t\tif(f(i+1,x-1)){\n\t\t\tint t=f(i+1,x-1),I=upper_bound(a[i].begin(),a[i].end(),x)-a[i].begin();\n\t\t\tres+=max(I-j-t,0);\n\t\t\tj=I-1;\n\t\t}\n\t\telse if(f(i,x-1)) res++;\n\t\telse res=-inf;\n\t\tif(f(i-1,x-1)+f(i-1,x)+f(i-1,x+1)==0) res=-inf;\n\t}\n\tcout<<max(res,-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nint A[100000], B[100000];\nmap<P, bool> exist;\nmap<P, int> CA, CB;\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) cin >> A[i] >> B[i];\n  int zero_a = 0, zero_b = 0;\n  rep(i, N) zero_a += A[i]==0, zero_b += B[i]==0;\n  if (A[0] != 0 || B[1] != 0 || zero_a != 1 || zero_b != 1) {\n    cout << -1 << \"\\n\";\n    return 0;\n  }\n  rep(i, N) exist[P(A[i], B[i])] = true;\n  rep(i, N) {\n    int a = A[i], b = B[i];\n    if (a > 0 && !exist[P(a-1, b-1)] && !exist[P(a-1, b)] && !exist[P(a-1, b+1)]) {\n      cout << -1 << \"\\n\";\n      return 0;\n    }\n    if (b > 0 && !exist[P(a-1, b-1)] && !exist[P(a, b-1)] && !exist[P(a+1, b-1)]) {\n      cout << -1 << \"\\n\";\n      return 0;\n    }\n  }\n  cout << -1 << \"\\n\";\n  return 0;\n  int sum = 0;\n  rep(i, N) {\n    int a = A[i], b = B[i];\n    if (exist[P(a-1, b-1)]) sum++;\n    else {\n      //cout<<\"(\"<<a<<\",\"<<b<<\")\\n\";\n      if (a > 0) CA[P(a, b)]++;\n      if (b > 0) CB[P(a, b)]++;\n    }\n  }\n  for (auto &p : CA) {\n    int a = p._1._1, b = p._1._2;\n    int num = min(p._2, CB[P(a-1, b+1)]);\n    p._2 -= num;\n    CB[P(a-1, b+1)] -= num;\n    //cout<<\"(\"<<a<<\",\"<<b<<\")<->(\"<<a-1<<\",\"<<b+1<<\") * \"<<num<<\"\\n\";\n    sum += num;\n  }\n  for (auto p : CA) sum += p._2;\n  for (auto p : CB) sum += p._2;\n  cout << sum << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 10;\nint ds[2][maxn];\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &ds[0][i], &ds[1][i]);\n  }\n  return 1;\n}\n\nint res;\n\nvoid solve() {\n  if (ds[0][0] || ds[1][1]) {\n    printf(\"-1\\n\");\n    return;\n  }\n  int d = ds[0][1];\n  if (ds[1][0] != d) {\n    printf(\"-1\\n\");\n    return;\n  }\n  vector<int> big(d + 1, 0);\n\n  vector<int> vs[2][d + 1];\n  for (int v = 0; v < n; ++v) {\n    int left = ds[0][v] + ds[1][v] - d;\n    if (left < 0 || abs(ds[0][v] - ds[1][v]) > d) {\n      printf(\"-1\\n\");\n      return;\n    }\n    if (left > 0) {\n      vs[left & 1][(ds[0][v] - ds[1][v] + d) / 2].pb((left + 1) / 2);\n    } else {\n      big[ds[0][v]] += 1;\n    }\n  }\n  res = 0;\n  for (int odd = 0; odd < 2; ++odd) {\n    vector<int> cool;\n    for (int i = 0; i <= d - odd; ++i) {\n      auto &cur = vs[odd][i];\n      sort(cur.begin(), cur.end());\n      int last = 0;\n      for (int i = 0; i < sz(cur);) {\n        int i0 = i;\n        while (i < sz(cur) && cur[i] == cur[i0]) {\n          ++i;\n        }\n        //eprintf(\"%dx  %d\\n\", i - i0, cur[i0]);\n        if (cur[i0] != last + 1) {\n          printf(\"-1\\n\");\n          return;\n        }\n        res += i - i0;\n        if (odd && cur[i0] == 1) {\n          cool.pb(i - i0);\n        }\n        ++last;\n      }\n      if (sz(cool) == i) {\n        cool.pb(0);\n      }\n    }\n    if (odd) {\n      for (int i = 0; i < sz(cool); ++i) {\n        while (cool[i]) {\n          int j = i;\n          while (j < sz(cool) && cool[j]) {\n            --cool[j];\n            ++j;\n          }\n          ++res;\n        }\n      }\n    }\n  }\n  if (big[0] != 1 || big[d] != 1) {\n    printf(\"-1\\n\");\n    return;\n  }\n  for (int i = 1; i < d; ++i) {\n    if (big[i] == 0) {\n      printf(\"-1\\n\");\n      return;\n    }\n  }\n  for (int i = 0; i < d; ++i) {\n    res += max(big[i], big[i + 1]);\n  }\n  if (0) {\n  printf(\"%d\\n\", res);\n  }\n}\n\nvoid gen() {\n  vector<vector<int> > es;\n  vector<pair<int, int> > edges;\n\n  int m;\n  while (1) {\n    beg:;\n  n = rnd(20) + 2;\n  es = vector<vector<int> >(n);\n  edges.clear();\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      edges.pb(mp(i, j));\n    }\n  }\n  random_shuffle(edges.begin(), edges.end(), rnd);\n  m = rnd(sz(edges) + 1);\n  edges.resize(m);\n  for (auto cur : edges) {\n    int i = cur.first, j = cur.second;\n    es[i].pb(j), es[j].pb(i);\n  }\n\n  for (int i = 0; i < 2; ++i) {\n    auto &dist = ds[i];\n    for (int v = 0; v < n; ++v) {\n      dist[v] = inf;\n    }\n    vector<int> st;\n    st.pb(i);\n    dist[i] = 0;\n    for (int l = 0; l < sz(st); ++l) {\n      int v = st[l];\n      for (int u : es[v]) {\n        if (dist[u] > dist[v] + 1) {\n          st.pb(u);\n          dist[u] = dist[v] + 1;\n        }\n      }\n    }\n    if (sz(st) < n) {\n      goto beg;\n    }\n  }\n  break;\n  }\n  solve();\n  if (res == -1 || res > m) {\n    eprintf(\"n = %d\\n\", n);\n    for (int i = 0; i < sz(edges); ++i) {\n      eprintf(\"%d %d\\n\", edges[i].first + 1, edges[i].second + 1);\n    }\n    eprintf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n      eprintf(\"%d %d\\n\", ds[0][i], ds[1][i]);\n    }\n    exit(1);\n  }\n}\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  if (0) {\n    int cnt = 0;\n  while (1) {\n    if (++cnt % 1000 == 0) {\n      eprintf(\"Ok %d\\n\", cnt);\n    }\n    gen();\n  }\n  }\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 26.11.2019 22:59:30       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n  }\n  if (a[0] != 0 || b[1] != 0 || a[1] == 0 || a[1] != b[0]) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  int d = a[1];\n  vector<int> was(d + 1, 0);\n  for (int i = 0; i < n; i++) {\n    if ((i >= 2 && min(a[i], b[i]) == 0) || a[i] + b[i] < d) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    if (a[i] + b[i] == d) {\n      was[a[i]] = 1;\n    }\n  }\n  if (*min_element(was.begin(), was.end()) == 0) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  set<pair<int, int>> s;\n  for (int i = 0; i < n; i++) {\n    s.emplace(a[i], b[i]);\n  }\n  map<pair<int, int>, int> mp;\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (s.find({a[i] - 1, b[i] - 1}) != s.end()) {\n      ans += 1;\n    } else {\n      ans += (a[i] > 0) + (b[i] > 0);\n      mp[make_pair(a[i], b[i])] += 1;\n      if (a[i] > 0 && s.find({a[i] - 1, b[i]}) == s.end() && s.find({a[i] - 1, b[i] + 1}) == s.end()) {\n        cout << -1 << '\\n';\n        return 0;\n      }\n      if (b[i] > 0 && s.find({a[i], b[i] - 1}) == s.end() && s.find({a[i] + 1, b[i] - 1}) == s.end()) {\n        cout << -1 << '\\n';\n        return 0;\n      }\n    }\n  }\n  for (auto& p : mp) {\n    auto it = mp.find(make_pair(p.first.first + 1, p.first.second - 1));\n    if (it != mp.end()) {\n      ans -= min(p.second, it->second);\n    }\n  }\n  assert(false);\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    mp.clear();\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one&&shit[tk].two==shit[k].two){\n                tk++;\n            }\n            int now=tk-k;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                last=shit[i].one;\n                left=now;\n                continue;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n            bool one=0,two=0;\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            if((one==0||two==0)&&shit[k].one!=0&&shit[k].two!=0){\n                //printf(\"%d k %d\\n\",shit[k].one,shit[k].two);\n                puts(\"-1\");\n                return 0;\n            }\n            if(last+1==shit[k].one){\n                ans-=min(now,left);\n            }\n            last=shit[k].one;\n            left=now;\n        }\n        //printf(\"%d %d\\n\",shit[i].one+shit[i].two,ans);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint nr, N, a[100009], b[100009], A[100009], B[100009], id[100009], sz[100009], may[100009], both1[100009], dp[100009][2];\nconst int INF = 1e8;\n\nbool cmp (int i, int j)\n{\n    if (A[i] + B[i] == A[j] + B[j]) return (A[i] < A[j]);\n    return (A[i] + B[i] < A[j] + B[j]);\n}\n\nint findPair (int x, int y)\n{\n    int p = 1, u = nr, mij;\n    while (p <= u)\n    {\n        mij = (p + u) >> 1;\n        if (a[mij] == x && b[mij] == y) return mij;\n        if (a[mij] + b[mij] < x + y || (a[mij] + b[mij] == x + y && a[mij] < x)) p = mij + 1;\n        else u = mij - 1;\n    }\n    return 0;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d\", &A[i], &B[i]), id[i] = i;\nsort (id + 1, id + N + 1, cmp);\nif (A[2] != B[1] || A[id[1]] + B[id[1]] < A[2] || A[1] != 0 || B[2] != 0)\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=N; i++)\n    if ((A[i] == 0 && i != 1) || (B[i] == 0 && i != 2))\n    {\n        printf (\"-1\\n\");\n        return 0;\n    }\nfor (int i=1; i<=N; i++)\n{\n    int j = i;\n    while (j + 1 <= N && A[id[j]] == A[id[j + 1]] && B[id[j]] == B[id[j + 1]])\n        j ++;\n    a[++nr] = A[id[i]], b[nr] = B[id[i]], sz[nr] = j - i + 1;\n    i = j;\n}\nfor (int i=1; i<=nr; i++)\n    may[i] = (findPair (a[i] + 1, b[i] - 1) != 0),\n    both1[i] = (findPair (a[i] - 1, b[i] - 1) != 0);\nif (!may[1])\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=nr; i++)\n    if ((a[i] > 0 && findPair (a[i] - 1, b[i]) == 0 && findPair (a[i] - 1, b[i] + 1) == 0 && both1[i] == 0) ||\n        (b[i] > 0 && findPair (a[i], b[i] - 1) == 0 && findPair (a[i] + 1, b[i] - 1) == 0 && both1[i] == 0))\n        {\n            printf (\"-1\\n\");\n            return 0;\n        }\nfor (int i=1; i<=nr; i++)\n    for (int j=0; j<2; j++)\n        dp[i][j] = INF;\ndp[1][1] = max (1, sz[2]);\nfor (int i=1; i<nr; i++)\n    for (int j=0; j<=may[i]; j++)\n        for (int k=0; k<=may[i + 1]; k++)\n        {\n            if (k == 0 && both1[i + 1] == 1)\n                dp[i + 1][k] = min (dp[i + 1][k], dp[i][j] + sz[i + 1]);\n            int curr = dp[i][j];\n            if (j == 0)\n            {\n                if (findPair (a[i + 1] - 1, b[i + 1]) == 0 && both1[i + 1] == 0) continue;\n                curr += sz[i + 1];\n            }\n            if (k == 0 && b[i + 1] > 0)\n                curr += sz[i + 1];\n            else\n            if (k == 1)\n            {\n                if (sz[i + 1] <= sz[i + 2] || both1[i + 1] == 0) curr += max (sz[i + 1], sz[i + 2]);\n                else curr += sz[i + 2];\n            }\n            if (curr < dp[i + 1][k])\n                dp[i + 1][k] = curr;\n        }\nprintf (\"%d\\n\", dp[nr][0]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nvoid ng() {\n        printf(\"-1\\n\");\n        exit(0);\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<set<int>> ab(n), ba(n);\n        vector<pair<int, int>> p;\n        for (int i = 0; i < n; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                p.emplace_back(a, b);\n                ab[a].insert(b);\n                ba[b].insert(a);\n        }\n        if (p[0].first != 0 || p[1].second != 0) ng();\n        if (p[0].second != p[1].first) ng();\n        if (p[0].second == 0) ng();\n        for (int i = 2; i < n; i ++) {\n                int a, b;\n                tie(a, b) = p[i];\n                cerr << a << ' ' << b << endl;\n                if (a == 0 || b == 0) ng();\n                if (ab[a - 1].count(b + 1) == 0 && ab[a - 1].count(b) == 0 && ab[a - 1].count(b - 1) == 0) ng();\n                if (ba[b - 1].count(a + 1) == 0 && ba[b - 1].count(a) == 0 && ba[b - 1].count(a - 1) == 0) ng();\n        }\n        ng();\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint power(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxn = (int) 1e5 + 10;\npair<int, int> tosort[maxn];\n\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    tosort[i] = mp(x, y);\n  }\n  return 1;\n}\n\nvoid solve() {\n  if (tosort[0].first || tosort[1].second) {\n    printf(\"-1\\n\");\n    return;\n  }\n  map<pair<int, int>, int> cnt;\n  for (int i = 0; i < n; ++i) {\n    int x = tosort[i].first;\n    int y = tosort[i].second;\n    if (i != 0 && !x) {\n      printf(\"-1\\n\");\n      return;\n    }\n    if (i != 1 && !y) {\n      printf(\"-1\\n\");\n      return;\n    }\n    cnt[{x, y}] += 1;\n    tosort[i] = {x + y, y};\n  }\n  sort(tosort, tosort + n);\n\n  int res = 2 * n - 2;\n  for (int i = 0; i < n;) {\n    int i0 = i;\n    while (i < n && tosort[i].first == tosort[i0].first) {\n      int x = tosort[i].first, y = tosort[i].second;\n      x -= y;\n\n      for (int iter = 0; iter < 2; ++iter) {\n        auto &cur = (!iter ? x : y);\n        if (!cur) {\n          continue;\n        }\n        auto &cury = (iter ? x : y);\n        --cur;\n        bool ok = 0;\n        for (int dx = -1; dx <= 1; ++dx) {\n          cury += dx;\n          if (cnt.count({x, y})) {\n            ok = 1;\n          }\n          cury -= dx;\n        }\n        ++cur;\n        if (!ok) {\n          printf(\"-1\\n\");\n          return;\n        }\n      }\n      ++i;\n    }\n\n    int last = 0, left = 0;\n    for (int j = i0; j < i;) {\n      int j0 = j;\n      while (j < i && tosort[j].second == tosort[j0].second) {\n        ++j;\n      }\n      int now = j - j0;\n\n      int del = 0;\n      if (last + 1 == tosort[j0].second) {\n        del = min(now, left);\n        res -= del;\n      }\n      if (cnt.count({tosort[j0].first - tosort[j0].second - 1, tosort[j0].second - 1})) {\n        res -= now - del;\n        now = del;\n      }\n      left = now;\n      last = tosort[j0].second;\n    }\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint nr, N, a[100009], b[100009], A[100009], B[100009], id[100009], sz[100009], may[100009], both1[100009];\nconst int INF = 1e8;\n\nbool cmp (int i, int j)\n{\n    if (A[i] + B[i] == A[j] + B[j]) return (A[i] < A[j]);\n    return (A[i] + B[i] < A[j] + B[j]);\n}\n\nint findPair (int x, int y)\n{\n    int p = 1, u = nr, mij;\n    while (p <= u)\n    {\n        mij = (p + u) >> 1;\n        if (a[mij] == x && b[mij] == y) return mij;\n        if (a[mij] + b[mij] < x + y || (a[mij] + b[mij] == x + y && a[mij] < x)) p = mij + 1;\n        else u = mij - 1;\n    }\n    return 0;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d\", &A[i], &B[i]), id[i] = i;\nsort (id + 1, id + N + 1, cmp);\nif (A[2] != B[1] || A[id[1]] + B[id[1]] < A[2] || A[1] != 0 || B[2] != 0)\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=N; i++)\n    if ((A[i] == 0 && i != 1) || (B[i] == 0 && i != 2))\n    {\n        printf (\"-1\\n\");\n        return 0;\n    }\nfor (int i=1; i<=N; i++)\n{\n    int j = i;\n    while (j + 1 <= N && A[id[j]] == A[id[j + 1]] && B[id[j]] == B[id[j + 1]])\n        j ++;\n    a[++nr] = A[id[i]], b[nr] = B[id[i]], sz[nr] = j - i + 1;\n    i = j;\n}\nfor (int i=1; i<=nr; i++)\n    may[i] = (findPair (a[i] + 1, b[i] - 1) != 0),\n    both1[i] = (findPair (a[i] - 1, b[i] - 1) != 0);\nif (!may[1])\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=nr; i++)\n    if ((a[i] > 0 && findPair (a[i] - 1, b[i]) == 0 && findPair (a[i] - 1, b[i] + 1) == 0 && both1[i] == 0) ||\n        (b[i] > 0 && findPair (a[i], b[i] - 1) == 0 && findPair (a[i] + 1, b[i] - 1) == 0 && both1[i] == 0))\n        {\n            printf (\"-1\\n\");\n            return 0;\n        }\nint ans = 0;\nfor (int i=1; i<=nr; i++)\n{\n    int j = i;\n    while (j < nr && a[j] + b[j] == a[j + 1] + b[j + 1])\n        j ++;\n    ///\n    if (i == 1)\n    {\n        for (int k=1; k<j; k++)\n            ans += max (sz[k], sz[k + 1]);\n    }\n    else\n    {\n        int cm = 0;\n        for (int k=i; k<=j; k++)\n        {\n            if (both1[k])\n            {\n                ans += sz[k];\n                if (may[k]) cm = min (cm, sz[k]);\n                else cm = 0;\n                continue;\n            }\n            if (sz[k] > cm) ans += sz[k] - cm;\n            ans += sz[k];\n            if (may[k]) cm = sz[k];\n            else cm = 0;\n        }\n    }\n    ///\n    i = j;\n}\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=0;\n    if(mn==1)\n        ans++;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+3,shit+n+1,cmp);\n    mp.clear();\n    mp[shit[1]]=1;\n    mp[shit[2]]=1;\n    for(int i=3;i<=n;)\n    {\n        int j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        if(shit[i].one+shit[i].two==mn){\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n                //printf(\"%d %d\\n\",mp.count(tmp1),mp.count(tmp2));\n                if(mp.count(tmp1)&&mp.count(tmp2)){\n                    continue;\n                }\n                else{\n                    puts(\"-1\");\n                    return 0;\n                }\n            }\n            ans=ans+(j-i-mn+1)*2+mn;\n        }\n        else{\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two-1;\n                if(mp.count(tmp1)){\n                    ans++;\n                    continue;\n                }\n                if(shit[k].one==shit[k-1].one&&shit[k].two==shit[k-1].two){\n                    ans+=2;\n                    continue;\n                }\n                bool one=0,two=0;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n\n                if(mp.count(tmp1)&&mp.count(tmp2)&&tmp1.one==shit[k-1].one&&tmp1.two==shit[k-1].two){\n                    ans=ans+1;\n                    continue;\n                }\n                one=one|mp.count(tmp1);\n                tmp1.two--;\n                one=one|mp.count(tmp1);\n\n                two=two|mp.count(tmp2);\n                tmp2.one--;\n                two=two|mp.count(tmp2);\n                if(one&&two){\n                    ans+=2;continue;\n                }\n                puts(\"-1\");\n                return 0;\n            }\n        }\n        i=j;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nint N, A[101010], B[101010];\n\nvoid fail()\n{\n\tputs(\"-1\");\n\texit(0);\n}\n\nint bas[101010];\nmap<pair<int, int>, int> P;\n\nbool is_good(int y, int x)\n{\n\treturn P.count(make_pair(y - 1, x - 1)) > 0;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i) scanf(\"%d%d\", A + i, B + i);\n\n\tif (A[0] != 0) fail();\n\tif (B[1] != 0) fail();\n\tif (A[1] != B[0]) fail();\n\tint D = A[1];\n\n\tfor (int i = 2; i < N; ++i) {\n\t\tif (A[i] == 0 || B[i] == 0 || A[i] + B[i] < D) fail();\n\t}\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (A[i] + B[i] == D) {\n\t\t\tbas[A[i]] += 1;\n\t\t}\n\t}\n\n\tint ret = 0;\n\tfor (int i = 0; i < D; ++i) {\n\t\tif (bas[i] == 0) fail();\n\t\tret += max(bas[i], bas[i + 1]);\n\t}\n\n\tfor (int i = 0; i < N; ++i) P[make_pair(A[i], B[i])] += 1;\n\n\t/*\n\tfor (int i = 2; i < N; ++i) if (A[i] + B[i] != D) {\n\t\tint x = A[i], y = B[i];\n\t\tif (P.count(make_pair(x - 1, y - 1))) {\n\t\t\t++ret;\n\t\t} else if (P.count(make_pair(x, y - 1)) && P.count(make_pair(x - 1, y))) {\n\t\t\tret += 2;\n\t\t} else fail();\n\t}\n\t*/\n\tfor (map<pair<int, int>, int>::iterator p = P.begin(); p != P.end(); ++p) {\n\t\tint y = p->first.first, x = p->first.second;\n\t\tif (y + x== D) continue;\n\n\t\tif (P.count(make_pair(y - 1, x + 1)) == 0) {\n\t\t\tvector<pair<pair<int, int>, int> > V;\n\t\t\tfor (;;) {\n\t\t\t\tint cnt = P[make_pair(y, x)];\n\t\t\t\tif (cnt == 0) break;\n\t\t\t\tV.push_back(make_pair(make_pair(y, x), cnt));\n\t\t\t\ty += 1;\n\t\t\t\tx -= 1;\n\t\t\t}\n\n\t\t\tif (V.size() == 1) {\n\t\t\t\ty = V[0].first.first, x = V[0].first.second;\n\t\t\t\tif (P.count(make_pair(y - 1, x - 1))) {\n\t\t\t\t\tret += V[0].second;\n\t\t\t\t} else if (P.count(make_pair(y - 1, x)) && P.count(make_pair(y, x - 1))) {\n\t\t\t\t\tret += 2 * V[0].second;\n\t\t\t\t} else fail();\n\t\t\t}\n\t\t\t{\n\t\t\t\ty = V[0].first.first, x = V[0].first.second;\n\t\t\t\tif (P.count(make_pair(y - 1, x)) || P.count(make_pair(y - 1, x - 1))) {\n\t\t\t\t\tret += V[0].second;\n\t\t\t\t} else fail();\n\t\t\t}\n\t\t\t{\n\t\t\t\ty = V[V.size()-1].first.first, x = V[V.size()-1].first.second;\n\t\t\t\tif (P.count(make_pair(y, x - 1)) || P.count(make_pair(y - 1, x - 1))) {\n\t\t\t\t\tret += V[V.size()-1].second;\n\t\t\t\t} else fail();\n\t\t\t}\n\t\t\tV[0].second = V[V.size()-1].second = 0;\n\t\t\tfor (int i = 1; i < V.size() - 1; ++i) {\n\t\t\t\ty = V[i].first.first, x = V[i].first.second;\n\t\t\t\tif (P.count(make_pair(y - 1, x - 1))) {\n\t\t\t\t\tret += V[i].second;\n\t\t\t\t\tV[i].second = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i < V.size(); ++i) {\n\t\t\t\tret += max(V[i].second, V[i - 1].second);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nvoid ng() {\n        printf(\"-1\\n\");\n        exit(0);\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        set<pair<int, int>> ps;\n        vector<pair<int, int>> p;\n        for (int i = 0; i < n; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                p.emplace_back(a, b);\n                ps.insert({a, b});\n        }\n        if (p[0].first != 0 || p[1].second != 0) ng();\n        if (p[0].second != p[1].first) ng();\n        if (p[0].second == 0) ng();\n        for (int i = 2; i < n; i ++) {\n                int a, b;\n                tie(a, b) = p[i];\n                if (a == 0 || b == 0) ng();\n                if (!ps.count({a - 1, b + 1}) && !ps.count({a - 1, b}) && !ps.count({a - 1, b - 1})) ng();\n                if (!ps.count({a + 1, b - 1}) && !ps.count({a, b - 1}) && !ps.count({a - 1, b - 1})) ng();\n        }\n        map<int, vector<pair<int, int>>> s;\n        for (int i = 0; i < n; i ++) {\n                s[p[i].first + p[i].second].emplace_back(p[i].first, p[i].second);\n        }\n        int matching = 0;\n        for (auto mp : s) {\n                vector<pair<int, int>> v = mp.second;\n                sort(v.begin(), v.end());\n                vector<pair<bool, pair<int, int>>> t; //(bottom left exists, number of the same position)\n                int cur = v[0].first;\n                int curi = 0;\n                while (curi < (int) v.size()) {\n                        int cnt = 0;\n                        bool ex = ps.count({v[curi].first - 1, v[curi].second - 1});\n                        while (curi < (int) v.size() && cur == v[curi].first) {\n                                curi ++;\n                                cnt ++;\n                        }\n                        t.push_back({ex, {cnt, cnt}});\n                        cur = v[curi].first;\n                }\n                for (int i = 0; i < (int) t.size(); i ++) {\n                        if (t[i].first) {\n                                int d = min(t[i].second.first, t[i].second.second);\n                                matching += d;\n                                t[i].second.first -= d;\n                                t[i].second.second -= d;\n                        }\n                        if (t[i].second.second > 0 && i + 1 < (int) t.size()) {\n                                int d = min(t[i].second.second, t[i + 1].second.first);\n                                matching += d;\n                                t[i + 1].second.first -= d;\n                        }\n                }\n        }\n        printf(\"%d\\n\", 2 * n - 2 - matching);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define fill( x, y ) memset( x, y, sizeof x )\n#define copy( x, y ) memcpy( x, y, sizeof x )\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pa;\n\ninline int read()\n{\n\tint sc = 0, f = 1; char ch = getchar();\n\twhile( ch < '0' || ch > '9' ) { if( ch == '-' ) f = -1; ch = getchar(); }\n\twhile( ch >= '0' && ch <= '9' ) sc = sc * 10 + ch - '0', ch = getchar();\n\treturn sc * f;\n}\n\nconst int MAXN = 100005;\n\nint n, a[MAXN], b[MAXN];\nmap < pa, bool > cnt;\npa c[MAXN];\n\ninline void GG() { puts( \"-1\" ); exit( 0 ); }\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen( \"data.in\", \"r\", stdin );\n#endif\n\tn = read();\n\tfor( int i = 1 ; i <= n ; i++ )\n\t{\n\t\ta[ i ] = read(), b[ i ] = read(), c[ i ] = mp( a[ i ] + b[ i ], b[ i ] );\n\t\tif( !a[ i ] && i != 1 ) GG();\n\t\tif( !b[ i ] && i != 2 ) GG();\n\t\tcnt[ mp( a[ i ], b[ i ] ) ] = 1;\n\t}\n\tif( a[ 1 ] || b[ 2 ] ) GG();\n\tsort( c + 1, c + n + 1 );\n\tint ret = n - 1 << 1;\n\tfor( int l = 1, r = 1 ; l <= n ; l = r )\n\t{\n\t\twhile( r <= n && c[ r ].xx == c[ l ].xx )\n\t\t{\n\t\t\tint x = c[ r ].xx - c[ r ].yy, y = c[ r ].yy;\n\t\t\tif( x )\n\t\t\t{\n\t\t\t\tbool flag = false;\n\t\t\t\tfor( int d = -1 ; d <= 1 ; d++ ) if( cnt.find( mp( x - 1, y + d ) ) != cnt.end() ) flag = true;\n\t\t\t\tif( !flag ) GG();\n\t\t\t}\n\t\t\tif( y )\n\t\t\t{\n\t\t\t\tbool flag = false;\n\t\t\t\tfor( int d = -1 ; d <= 1 ; d++ ) if( cnt.find( mp( x + d, y - 1 ) ) != cnt.end() ) flag = true;\n\t\t\t\tif( !flag ) GG();\n\t\t\t}\n\t\t\tr++;\n\t\t}\n\t\tfor( int i = l, j = l, last = 0, left = 0 ; i < r ; i = j )\n\t\t{\n\t\t\twhile( j < r && c[ j ].yy == c[ i ].yy ) j++;\n\t\t\tint now = j - i, del = 0;\n\n\t\t\tif( cnt.find( mp( c[ i ].xx - c[ i ].yy - 1, c[ i ].yy - 1 ) ) != cnt.end() ) ret -= now, last=c[i].yy,left=min(now,left),continue;;\n            if( c[ i ].yy == last + 1 ) del = min( now, left ), ret -= del;\n\t\t\tlast = c[ i ].yy; left = now;\n\t\t}\n\t}\n\treturn printf( \"%d\\n\", ret ), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#define pii pair<int,int>\nint n, chk[101000], cnt, m;\nusing namespace std;\nstruct point {\n\tint x, y, num;\n\tbool operator<(const point &p)const {\n\t\treturn x + y != p.x + p.y ? x+y < p.x+p.y : x<p.x;\n\t}\n}P[101000], U[101000];\nint A[101000], B[101000], res, D[101000][2], first = 1;\nvector<int>G[101000];\nmap<pii, int>Map;\nint Get(int x, int y) {\n\tif (Map.count({ x,y }))return Map[{x, y}];\n\treturn 0;\n}\nbool Go() {\n\tint i;\n\tif (first) {\n\t\tfirst = 0;\n\t\tfor (i = 1; i < m; i++) {\n\t\t\tint x = U[i].x, y = U[i].y;\n\t\t\tres += max(Get(x, y), Get(x + 1, y - 1));\n\t\t}\n\t\treturn true;\n\t}\n\tfor (i = 0; i <= m + 1; i++) {\n\t\tD[i][0] = D[i][1] = 1e9;\n\t}\n\tD[0][0] = 0;\n\tfor (i = 1; i <= m; i++) {\n\t\tint x = U[i].x, y = U[i].y;\n\t\tint ck1 = 0, ck2 = 0, ck3 = 0;\n\t\tif (Get(x-1,y-1)) ck1 = 1;\n\t\tif (Get(x-1,y)) ck2 = 1;\n\t\tif (Get(x,y-1)) ck3 = 1;\n\t\tif (ck1) {\n\t\t\tD[i][0] = min(D[i][0], D[i - 1][0] + Get(x, y));\n\t\t}\n\t\tif (ck2) {\n\t\t\tD[i][1] = min(D[i][1], D[i - 1][0] + Get(x, y));\n\t\t}\n\t\tif (ck2 &&ck3) {\n\t\t\tD[i][0] = min(D[i][0], D[i - 1][0] + Get(x, y) * 2);\n\t\t}\n\t\tif (i != 1) {\n\t\t\tD[i][1] = min(D[i][1], min(D[i - 1][0], D[i - 1][1]) + max(Get(x - 1, y + 1), Get(x, y)));\n\t\t}\n\t\tif (ck1 || ck3) {\n\t\t\tD[i][0] = min(D[i][0], D[i][1] + Get(x, y));\n\t\t}\n\t}\n\tif (D[m][0] > 1e8)return false;\n\tres += D[m][0];\n\treturn true;\n}\nint main() {\n\tint i, j;\n\tputs(\"-1\");\n\treturn 0;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\t\tP[i] = { A[i],B[i],i };\n\t\tMap[{A[i], B[i]}]++;\n\t}\n\tsort(P + 1, P + n + 1);\n\tif (A[1] != 0 || B[2] != 0 || A[2]!=B[1] || Get(A[1],B[1])!=1 || Get(A[2],B[2])!=1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tif (abs(A[i] - B[i]) > A[2]) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tG[Get(A[i], B[i])].push_back(i);\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tm = 0;\n\t\tU[++m] = P[i];\n\t\tfor (j = i+1; j <= n; j++) {\n\t\t\tif (abs(P[j].x - P[j - 1].x) > 1 || P[j].x + P[j].y != P[j - 1].x + P[j - 1].y)break;\n\t\t\tif (P[j].x != P[j - 1].x)U[++m] = P[j];\n\t\t}\n\t\tif (i == 1) {\n\t\t\tif (U[1].num != 1 || U[m].num != 2) {\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif (!Go()) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\ti = j - 1;\n\t}\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].two==shit[2].one&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    mp.clear();\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one){\n                tk++;\n            }\n            int now=tk-k;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                last=shit[k].one;\n                left=min(now,left);\n                continue;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n            bool one=0,two=0;\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n            if(shit[k].one==0)one=1;\n            if(shit[k].two==0) two=1;\n            if(one==0||two==0){\n                puts(\"-1\");\n                return 0;\n            }\n            if(last+1==shit[k].one){\n                ans-=min(now,left);\n            }\n            last=shit[k].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nint A[100000], B[100000];\nmap<P, bool> exist;\nmap<P, int> CA, CB;\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) cin >> A[i] >> B[i];\n  int zero_a = 0, zero_b = 0;\n  rep(i, N) zero_a += A[i]==0, zero_b += B[i]==0;\n  if (A[0] != 0 || B[1] != 0 || zero_a != 1 || zero_b != 1) {\n    cout << -1 << \"\\n\";\n    return 0;\n  }\n  rep(i, N) exist[P(A[i], B[i])] = true;\n  rep(i, N) {\n    int a = A[i], b = B[i];\n    if (a > 0 && !exist[P(a-1, b-1)] && !exist[P(a-1, b)] && !exist[P(a-1, b+1)]) {\n      cout << -1 << \"\\n\";\n      return 0;\n    }\n    if (b > 0 && !exist[P(a-1, b-1)] && !exist[P(a, b-1)] && !exist[P(a+1, b-1)]) {\n      cout << -1 << \"\\n\";\n      return 0;\n    }\n  }\n  int sum = 0;\n  rep(i, N) {\n    int a = A[i], b = B[i];\n    if (exist[P(a-1, b-1)]) sum++;\n    else {\n      //cout<<\"(\"<<a<<\",\"<<b<<\")\\n\";\n      if (a > 0) CA[P(a, b)]++;\n      if (b > 0) CB[P(a, b)]++;\n    }\n  }\n  for (auto &p : CA) {\n    int a = p._1._1, b = p._1._2;\n    int num = min(p._2, CB[P(a-1, b+1)]);\n    p._2 -= num;\n    CB[P(a-1, b+1)] -= num;\n    //cout<<\"(\"<<a<<\",\"<<b<<\")<->(\"<<a-1<<\",\"<<b+1<<\") * \"<<num<<\"\\n\";\n    sum += num;\n  }\n  for (auto p : CA) sum += p._2;\n  for (auto p : CB) sum += p._2;\n  sum--;\n  cout << sum << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint nr, N, a[100009], b[100009], A[100009], B[100009], id[100009], sz[100009], may[100009], both1[100009];\nconst int INF = 1e8;\n\nbool cmp (int i, int j)\n{\n    if (A[i] + B[i] == A[j] + B[j]) return (A[i] < A[j]);\n    return (A[i] + B[i] < A[j] + B[j]);\n}\n\nint findPair (int x, int y)\n{\n    int p = 1, u = nr, mij;\n    while (p <= u)\n    {\n        mij = (p + u) >> 1;\n        if (a[mij] == x && b[mij] == y) return mij;\n        if (a[mij] + b[mij] < x + y || (a[mij] + b[mij] == x + y && a[mij] < x)) p = mij + 1;\n        else u = mij - 1;\n    }\n    return 0;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d\", &A[i], &B[i]), id[i] = i;\nsort (id + 1, id + N + 1, cmp);\nif (A[2] != B[1] || A[id[1]] + B[id[1]] < A[2] || A[1] != 0 || B[2] != 0)\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=N; i++)\n    if ((A[i] == 0 && i != 1) || (B[i] == 0 && i != 2))\n    {\n        printf (\"-1\\n\");\n        return 0;\n    }\nfor (int i=1; i<=N; i++)\n{\n    int j = i;\n    while (j + 1 <= N && A[id[j]] == A[id[j + 1]] && B[id[j]] == B[id[j + 1]])\n        j ++;\n    a[++nr] = A[id[i]], b[nr] = B[id[i]], sz[nr] = j - i + 1;\n    i = j;\n}\nfor (int i=1; i<=nr; i++)\n    may[i] = (findPair (a[i] + 1, b[i] - 1) != 0),\n    both1[i] = (findPair (a[i] - 1, b[i] - 1) != 0);\nif (!may[1])\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=nr; i++)\n    if ((a[i] > 0 && findPair (a[i] - 1, b[i]) == 0 && findPair (a[i] - 1, b[i] + 1) == 0 && both1[i] == 0) ||\n        (b[i] > 0 && findPair (a[i], b[i] - 1) == 0 && findPair (a[i] + 1, b[i] - 1) == 0 && both1[i] == 0))\n        {\n            printf (\"-1\\n\");\n            return 0;\n        }\nint ans = 0;\nfor (int i=1; i<=nr; i++)\n{\n    int j = i;\n    while (j < nr && a[j] + b[j] == a[i] + b[i])\n        j ++;\n    ///\n    if (i == 1)\n    {\n        for (int k=1; k<j; k++)\n            ans += max (sz[k], sz[k + 1]);\n    }\n    else\n    {\n        int cm = 0;\n        for (int k=i; k<=j; k++)\n        {\n            if (both1[k])\n            {\n                ans += sz[k];\n                if (may[k]) cm = min (cm, sz[k]);\n                else cm = 0;\n                continue;\n            }\n            if (sz[k] > cm) ans += sz[k] - cm;\n            ans += sz[k];\n            if (may[k]) cm = sz[k];\n            else cm = 0;\n        }\n    }\n    ///\n    i = j;\n}\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\n#define mp make_pair\n#define pb push_back\n#define N 100010\nint n;\nint a[N], b[N];\nmap<PII, set<int> > A;\n\nvoid end() {\n\tputs (\"-1\");\n\texit(0);\n}\n\nint path[N], L;\nbool v[N];\n\nvector<int> c[N];\n// c[i] = connect with path[i] and path[i+1]\nint sc[N];\n\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i ++) {\n  \tcin >> a[i] >> b[i];\n  \tA[mp(a[i], b[i])].insert(i);\n  }\n  if (a[0] != 0 || b[1] != 0 || a[1] != b[0]) end();\n  L = a[1];\n  path[0] = 0;\n  path[L] = 1;\n  for (int i = 1; i < L; i++)\n  \tpath[i] = -1;\n  for (int i = 2; i < n; i++)\n  \tif (a[i] + b[i] == L) {\n  \t\tif (path[a[i]] == -1) {\n  \t\t   path[a[i]] = i;\n  \t\t   v[i] = true;\n  \t\t}\n  \t}\n  for (int i = 1; i < L; i ++)\n  \tif (path[i] == -1) end();\n  for (int i = 2; i < n; i ++) {\n    if (a[i] == 0 || b[i] == 0) end();\n    if (a[i] + b[i] < L) end();\n  }\n  int S = 0;\n  S += L; // path\n  for (int i = 2; i < n; i ++) {\n    if (a[i] + b[i] == L) {\n      S += 2;\n    } else\n    if (a[i] + b[i] == L+1) {\n      S += 2;\n      c[a[i]-1].pb(i);\n    } else {\n      if (A.find(mp(a[i]-1, b[i]-1)) != A.end()) {\n        S ++;\n      } else {\n        end();\n      }\n    }\n  }\n  for (int i = 0; i < L; i ++) {\n    sc[i] = (int) c[i].size();\n  }\n  for (int i = 0; i < L-1; i ++) {\n    int T = min(sc[i], sc[i+1]);\n    S -= T;\n  }\n  cout << S << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 26.11.2019 22:59:30       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n  }\n  if (a[0] != 0 || b[1] != 0 || a[1] == 0 || a[1] != b[0]) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  int d = a[1];\n  vector<int> was(d + 1, 0);\n  for (int i = 0; i < n; i++) {\n    if ((i >= 2 && min(a[i], b[i]) == 0) || a[i] + b[i] < d) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    if (a[i] + b[i] == d) {\n      was[a[i]] = 1;\n    }\n  }\n  if (*min_element(was.begin(), was.end()) == 0) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  set<pair<int, int>> s;\n  for (int i = 0; i < n; i++) {\n    s.emplace(a[i], b[i]);\n  }\n  map<pair<int, int>, int> mp;\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (s.find({a[i] - 1, b[i] - 1}) != s.end()) {\n      ans += 1;\n    } else {\n      ans += (a[i] > 0) + (b[i] > 0);\n      mp[make_pair(a[i], b[i])] += 1;\n      if (a[i] > 0 && s.find({a[i] - 1, b[i]}) == s.end() && s.find({a[i] - 1, b[i] + 1}) == s.end()) {\n        cout << -1 << '\\n';\n        return 0;\n      }\n      if (b[i] > 0 && s.find({a[i], b[i] - 1}) == s.end() && s.find({a[i] + 1, b[i] - 1}) == s.end()) {\n        cout << -1 << '\\n';\n        return 0;\n      }\n    }\n  }\n  for (auto& p : mp) {\n    auto it = mp.find(make_pair(p.first.first + 1, p.first.second - 1));\n    if (it != mp.end()) {\n      ans -= min(p.second, it->second);\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#define ll long long\n#define inf 1000000007\n#define inf16 0x3f3f3f3f\n#define INF 1000000000000000007LL\n#define VI vector<int>\n#define VPII vector<pair<int, int> >\n#define VLL vector<ll>\n#define PII pair<int, int>\n#define st first\n#define nd second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define endl '\\n'\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\nconst int N = 1e5+7;\n\nint n, ans;\n\nint A[N];\nint B[N];\n\nPII mB[N]; //maksymalne B dla danego A\nPII mA[N]; //maksymalne A dla danego B\n\nmap<PII, int> takie;\n\nVI G[N];\n\nqueue<int> Q;\n\nint dist[3][N];\n\nbool check()\n{\n\tfor(int i = 1; i <= 2; ++i)\n\t{\n\t\tfor(int v = 1; v <= n; ++v)\n\t\t{\n\t\t\tdist[i][v] = inf;\n\t\t}\n\n\t\tdist[i][i] = 0;\n\t\tQ.push(i);\n\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tint v = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tfor(auto it:G[v])\n\t\t\t{\n\t\t\t\tif(dist[i][it]>dist[i][v]+1)\n\t\t\t\t{\n\t\t\t\t\tdist[i][it] = dist[i][v]+1;\n\t\t\t\t\tQ.push(it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tif(A[i]!=dist[1][i])\n\t\t\treturn 0;\n\n\t\tif(B[i]!=dist[2][i])\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tcin >> n;\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> A[i] >> B[i];\n\t\ttakie[{A[i], B[i]}] = i;\n\t\tmB[A[i]] = max(mB[A[i]], mp(B[i], i));\n\t\tmA[B[i]] = max(mA[B[i]], mp(A[i], i));\n\t}\n\n\tif(A[2]!=B[1] || A[1] || B[2])\n\t{\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tif(A[2]==1)\n\t{\n\t\tG[1].pb(2);\n\t\tG[2].pb(1);\n\t\t++ans;\n\t}\n\n\tfor(int i = 3; i <= n; ++i)\n\t{\n\t\tif(takie.find({A[i]-1, B[i]-1})!=takie.end())\n\t\t{\n\t\t\tG[i].pb(takie[{A[i]-1, B[i]-1}]);\n\t\t\tG[takie[{A[i]-1, B[i]-1}]].pb(i);\n\t\t\t++ans;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(mB[A[i]-1].st>B[i]-1 && mA[B[i]-1].st>A[i]-1)\n\t\t\t{\n\t\t\t\tG[i].pb(mB[A[i]-1].nd);\n\t\t\t\tG[i].pb(mA[B[i]-1].nd);\n\t\t\t\tG[mB[A[i]-1].nd].pb(i);\n\t\t\t\tG[mA[B[i]-1].nd].pb(i);\n\t\t\t\tans += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!check())\n\t{\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define N 100010\nint n;\nint a[N], b[N];\nmap<PII, set<int> > A;\n\nvoid end() {\n\tputs (\"-1\");\n\texit(0);\n}\n\nint path[N], L;\nbool v[N];\n\n//vector<int> c[N];\n// c[i] = connect with path[i] and path[i+1]\n//int sc[N];\nmap<PII, set<int> > B;\n\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i ++) {\n  \tcin >> a[i] >> b[i];\n  \tA[mp(a[i], b[i])].insert(i);\n  }\n  if (a[0] != 0 || b[1] != 0 || a[1] != b[0]) end();\n  L = a[1];\n  path[0] = 0;\n  path[L] = 1;\n  for (int i = 1; i < L; i++)\n  \tpath[i] = -1;\n  for (int i = 2; i < n; i++)\n  \tif (a[i] + b[i] == L) {\n  \t\tif (path[a[i]] == -1) {\n  \t\t   path[a[i]] = i;\n  \t\t   v[i] = true;\n  \t\t}\n  \t}\n  for (int i = 1; i < L; i ++)\n  \tif (path[i] == -1) end();\n  for (int i = 2; i < n; i ++) {\n    if (a[i] == 0 || b[i] == 0) end();\n    if (a[i] + b[i] < L) end();\n  }\n  int S = 0;\n  S += L; // path\n  for (int i = 2; i < n; i ++) if (!v[i]) {\n    if (a[i] + b[i] == L) {\n      S += 2;\n      B[mp(a[i], b[i])].insert(i);\n    } else {\n      if (A.find(mp(a[i]-1, b[i]-1)) != A.end()) {\n        S ++;\n      B[mp(a[i], b[i])].insert(i);\n      } else \n      if (A.find(mp(a[i]-1, b[i])) != A.end() && A.find(mp(a[i], b[i]-1)) != A.end()) {\n        S += 2;\n        B[mp(a[i], b[i])].insert(i);\n      } else {\n        end();\n      }\n    }\n  }\n  /*\n  for (int i = 0; i < L; i ++) {\n    sc[i] = (int) c[i].size();\n  }\n  for (int i = 0; i < L-1; i ++) {\n    int T = min(sc[i], sc[i+1]);\n    S -= T;\n  }\n  */\n  for (map<PII, set<int> >::iterator i = B.begin(); i != B.end(); i++) {\n    int l = i->fi.fi;\n    int r = i->fi.se;\n    if (B.find(mp(l+1,r-1)) != B.end()) {\n      S -= min( (int) i->se.size(), (int) B[mp(l+1,r-1)].size());\n    }\n  }\n  cout << S << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].two==shit[2].one&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            while(1);\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    mp.clear();\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one){\n                tk++;\n            }\n            int now=tk-k;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                last=shit[k].one;\n                left=min(now,left);\n                continue;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n            bool one=0,two=0;\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n            if(shit[k].one==0)one=1;\n            if(shit[k].two==0) two=1;\n            if(one==0||two==0){\n                puts(\"-1\");\n                return 0;\n            }\n            if(last+1==shit[k].one){\n                ans-=min(now,left);\n            }\n            last=shit[k].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define fill( x, y ) memset( x, y, sizeof x )\n#define copy( x, y ) memcpy( x, y, sizeof x )\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pa;\n\ninline int read()\n{\n\tint sc = 0, f = 1; char ch = getchar();\n\twhile( ch < '0' || ch > '9' ) { if( ch == '-' ) f = -1; ch = getchar(); }\n\twhile( ch >= '0' && ch <= '9' ) sc = sc * 10 + ch - '0', ch = getchar();\n\treturn sc * f;\n}\n\nconst int MAXN = 100005;\n\nint n, a[MAXN], b[MAXN];\nmap < pa, bool > cnt;\npa c[MAXN];\n\ninline void GG() { puts( \"-1\" ); exit( 0 ); }\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen( \"data.in\", \"r\", stdin );\n#endif\n\tn = read();\n\tfor( int i = 1 ; i <= n ; i++ )\n\t{\n\t\ta[ i ] = read(), b[ i ] = read(), c[ i ] = mp( a[ i ] + b[ i ], b[ i ] );\n\t\tif( !a[ i ] && i != 1 ) GG();\n\t\tif( !b[ i ] && i != 2 ) GG();\n\t\tcnt[ mp( a[ i ], b[ i ] ) ] = 1;\n\t}\n\tif( a[ 1 ] || b[ 2 ] ) GG();\n\tsort( c + 1, c + n + 1 );\n\tint ret = n - 1 << 1;\n\tfor( int l = 1, r = 1 ; l <= n ; l = r )\n\t{\n\t\twhile( r <= n && c[ r ].xx == c[ l ].xx )\n\t\t{\n\t\t\tint x = c[ r ].xx - c[ r ].yy, y = c[ r ].yy;\n\t\t\tif( x )\n\t\t\t{\n\t\t\t\tbool flag = false;\n\t\t\t\tfor( int d = -1 ; d <= 1 ; d++ ) if( cnt.find( mp( x - 1, y + d ) ) != cnt.end() ) flag = true;\n\t\t\t\tif( !flag ) GG();\n\t\t\t}\n\t\t\tif( y )\n\t\t\t{\n\t\t\t\tbool flag = false;\n\t\t\t\tfor( int d = -1 ; d <= 1 ; d++ ) if( cnt.find( mp( x + d, y - 1 ) ) != cnt.end() ) flag = true;\n\t\t\t\tif( !flag ) GG();\n\t\t\t}\n\t\t\tr++;\n\t\t}\n\t\tfor( int i = l, j = l, last = 0, left = 0 ; i < r ; i = j )\n\t\t{\n\t\t\twhile( j < r && c[ j ].yy == c[ i ].yy ) j++;\n\t\t\tint now = j - i, del = 0;\n\t\t\tif( c[ i ].yy == last + 1 ) del = min( now, left ), ret -= del;\n\t\t\tif( cnt.find( mp( c[ i ].xx - c[ i ].yy - 1, c[ i ].yy - 1 ) ) != cnt.end() ) ret -= now - del, now = del;\n\t\t\tlast = c[ i ].yy; left = now;\n\t\t}\n\t}\n\treturn printf( \"%d\\n\", ret ), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    mp.clear();\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n        mp[shit[i]]=1;\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].two==shit[2].one&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        while(1);\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one){\n                tk++;\n            }\n            int now=tk-k;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                last=shit[k].one;\n                left=min(now,left);\n                continue;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n            bool one=0,two=0;\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n            if(shit[k].one==0)one=1;\n            if(shit[k].two==0) two=1;\n            if(one==0||two==0){\n                puts(\"-1\");\n                return 0;\n            }\n            if(last+1==shit[k].one){\n                ans-=min(now,left);\n            }\n            last=shit[k].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define fill( x, y ) memset( x, y, sizeof x )\n#define copy( x, y ) memcpy( x, y, sizeof x )\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pa;\n\ninline int read()\n{\n\tint sc = 0, f = 1; char ch = getchar();\n\twhile( ch < '0' || ch > '9' ) { if( ch == '-' ) f = -1; ch = getchar(); }\n\twhile( ch >= '0' && ch <= '9' ) sc = sc * 10 + ch - '0', ch = getchar();\n\treturn sc * f;\n}\n\nconst int MAXN = 100005;\n\nint n, a[MAXN], b[MAXN];\nmap < pa, bool > cnt;\npa c[MAXN];\n\ninline void GG() { puts( \"-1\" ); exit( 0 ); }\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen( \"data.in\", \"r\", stdin );\n#endif\n\tn = read();\n\tfor( int i = 1 ; i <= n ; i++ )\n\t{\n\t\ta[ i ] = read(), b[ i ] = read(), c[ i ] = mp( a[ i ] + b[ i ], b[ i ] );\n\t\tif( !a[ i ] && i != 1 ) GG();\n\t\tif( !b[ i ] && i != 2 ) GG();\n\t\tcnt[ mp( a[ i ], b[ i ] ) ] = 1;\n\t}\n\tif( a[ 1 ] || b[ 2 ] ) GG();\n\tsort( c + 1, c + n + 1 );\n\tint ret = n - 1 << 1;\n\tfor( int l = 1, r = 1 ; l <= n ; l = r )\n\t{\n\t\twhile( r <= n && c[ r ].xx == c[ l ].xx )\n\t\t{\n\t\t\tint x = c[ r ].xx - c[ r ].yy, y = c[ r ].yy;\n\t\t\tif( x )\n\t\t\t{\n\t\t\t\tbool flag = false;\n\t\t\t\tfor( int d = -1 ; d <= 1 ; d++ ) if( cnt.find( mp( x - 1, y + d ) ) != cnt.end() ) flag = true;\n\t\t\t\tif( !flag ) GG();\n\t\t\t}\n\t\t\tif( y )\n\t\t\t{\n\t\t\t\tbool flag = true;\n\t\t\t\tfor( int d = -1 ; d <= 1 ; d++ ) if( cnt.find( mp( x + d, y - 1 ) ) != cnt.end() ) flag = true;\n\t\t\t\tif( !flag ) GG();\n\t\t\t}\n\t\t\tr++;\n\t\t}\n\t\tfor( int i = l, j = l, last = 0, left = 0 ; i <= r ; i = j )\n\t\t{\n\t\t\twhile( j <= r && c[ j ].yy == c[ i ].yy ) j++;\n\t\t\tint now = j - i, del = 0;\n\t\t\tif( c[ j ].yy == last + 1 ) del = min( now, left ), ret -= del;\n\t\t\tif( cnt.find( mp( c[ j ].xx - c[ j ].yy - 1, c[ j ].yy - 1 ) ) != cnt.end() ) ret -= now - del, now = del;\n\t\t\tlast = c[ j ].yy; left = now;\n\t\t}\n\t}\n\treturn printf( \"%d\\n\", ret ), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint n;\nvvi a;\n\nint f(int i,int x){\n\treturn upper_bound(a[i].begin(),a[i].end(),x)-lower_bound(a[i].begin(),a[i].end(),x);\n}\n\nint main(){\n\tcin>>n;\n\ta=vvi(n+1);\n\tint res=n-1,d;\n\tfor(int i=0;i<n;i++){\n\t\tint A,B;\n\t\tcin>>A>>B;\n\t\ta[A].push_back(B);\n\t\tif(i==1) d=A;\n\t}\n\tfor(int i=0;i<n;i++) sort(a[i].begin(),a[i].end());\n\tif(a[0].size()!=1||a[0][0]!=d) res=-inf;\n\tfor(int i=1;i<n;i++) for(int j=0;j<a[i].size();j++){\n\t\tint x=a[i][j];\n\t\tif(x<abs(i-d)||i+d<x) res=-inf;\n\t\tif(x==0) continue;\n\t\tif(f(i-1,x-1));\n\t\telse if(f(i+1,x-1)){\n\t\t\tint t=f(i+1,x-1),I=upper_bound(a[i].begin(),a[i].end(),x)-a[i].begin();\n\t\t\tres+=abs(I-j-t);\n\t\t\tj=I-1;\n\t\t}\n\t\telse if(f(i,x-1)) res++;\n\t\telse res=-inf;\n\t}\n\tcout<<max(res,-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    mp.clear();\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one&&shit[tk].two==shit[k].two){\n                tk++;\n            }\n            int now=tk-k;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                last=shit[k].one;\n                left=min(now,left);\n                continue;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n            bool one=0,two=0;\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n            if(shit[k].one==0)one=1;\n            if(shit[k].two==0) two=1;\n            if(one==0||two==0){\n                //printf(\"%d k %d\\n\",shit[k].one,shit[k].two);\n                puts(\"-1\");\n                return 0;\n            }\n            if(last+1==shit[k].one){\n                ans-=min(now,left);\n            }\n            last=shit[k].one;\n            left=now;\n        }\n        //printf(\"%d %d\\n\",shit[i].one+shit[i].two,ans);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].two==shit[2].one&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        while(1);\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    mp.clear();\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one){\n                tk++;\n            }\n            int now=tk-k;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                last=shit[k].one;\n                left=min(now,left);\n                continue;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n            bool one=0,two=0;\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n            if(shit[k].one==0)one=1;\n            if(shit[k].two==0) two=1;\n            if(one==0||two==0){\n                puts(\"-1\");\n                return 0;\n            }\n            if(last+1==shit[k].one){\n                ans-=min(now,left);\n            }\n            last=shit[k].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<endl;\n\t#else\n\tcout<<\"Possible\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<endl;\n\t#else\n\tcout<<\"Impossible\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvoid imp(){\n\tcout<<-1<<endl;\n\texit(0);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tmap<pi,int> a;\n\tint n;cin>>n;\n\t\n\tint d12;\n\t\n\trep(i,n){\n\t\tint x,y;cin>>x>>y;\n\t\tif(i==0){\n\t\t\tif(x)imp();\n\t\t\td12=y;\n\t\t}else{\n\t\t\tif(x==0)imp();\n\t\t}\n\t\tif(i==1){\n\t\t\tif(y)imp();\n\t\t\tif(d12!=x)imp();\n\t\t}else{\n\t\t\tif(y==0)imp();\n\t\t}\n\t\t\n\t\ta[pi(x,y)]++;\n\t}\n\t\n\tint ans=2*n-2;\n\tfor(auto kv:a){\n\t\tint x,y;tie(x,y)=kv.a;\n\t\t\n\t\tif(x>0){\n\t\t\tint c=0;\n\t\t\trng(j,-1,2)\n\t\t\t\tc+=a.count(pi(x-1,y+j));\n\t\t\tif(c==0)imp();\n\t\t}\n\t\tif(y>0){\n\t\t\tint c=0;\n\t\t\trng(j,-1,2)\n\t\t\t\tc+=a.count(pi(x+j,y-1));\n\t\t\tif(c==0)imp();\n\t\t}\n\t\t\n\t\tif(a.count(pi(x+1,y-1)))continue;\n\t\t\n\t\tint p=x,q=y;\n\t\t\n\t\tint pre=0;\n\t\tint w=0;\n\t\t\n\t\twhile(a.count(pi(p,q))){\n\t\t\tint cnt=a[pi(p,q)];\n\t\t\tbool mid=a.count(pi(p-1,q-1));\n\t\t\tint u=min(pre,cnt);\n\t\t\tw+=u;\n\t\t\tif(mid){\n\t\t\t\tw+=cnt-u;\n\t\t\t\tcnt=u;\n\t\t\t}\n\t\t\tpre=cnt;\n\t\t\tp--;\n\t\t\tq++;\n\t\t}\n\t\t\n\t\tans-=w;\n\t}\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint nr, N, a[100009], b[100009], A[100009], B[100009], id[100009], sz[100009], may[100009], both1[100009], dp[100009][2];\nconst int INF = 1e8;\n\nbool cmp (int i, int j)\n{\n    if (A[i] + B[i] == A[j] + B[j]) return (A[i] < A[j]);\n    return (A[i] + B[i] < A[j] + B[j]);\n}\n\nint findPair (int x, int y)\n{\n    int p = 1, u = nr, mij;\n    while (p <= u)\n    {\n        mij = (p + u) >> 1;\n        if (a[mij] == x && b[mij] == y) return mij;\n        if (a[mij] + b[mij] < x + y || (a[mij] + b[mij] == x + y && a[mij] < x)) p = mij + 1;\n        else u = mij - 1;\n    }\n    return 0;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d\", &A[i], &B[i]), id[i] = i;\nsort (id + 1, id + N + 1, cmp);\nif (A[2] != B[1] || A[id[1]] + B[id[1]] < A[2] || A[1] != 0 || B[2] != 0)\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=N; i++)\n    if ((A[i] == 0 && i != 1) || (B[i] == 0 && i != 2))\n    {\n        printf (\"-1\\n\");\n        return 0;\n    }\nfor (int i=1; i<=N; i++)\n{\n    int j = i;\n    while (j + 1 <= N && A[id[j]] == A[id[j + 1]] && B[id[j]] == B[id[j + 1]])\n        j ++;\n    a[++nr] = A[id[i]], b[nr] = B[id[i]], sz[nr] = j - i + 1;\n    i = j;\n}\nfor (int i=1; i<=nr; i++)\n    may[i] = (findPair (a[i] + 1, b[i] - 1) != 0),\n    both1[i] = (findPair (a[i] - 1, b[i] - 1) != 0);\nif (!may[1])\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=nr; i++)\n    if ((a[i] > 0 && findPair (a[i] - 1, b[i]) == 0 && findPair (a[i] - 1, b[i] + 1) == 0 && both1[i] == 0) ||\n        (b[i] > 0 && findPair (a[i], b[i] - 1) == 0 && findPair (a[i] + 1, b[i] - 1) == 0 && both1[i] == 0))\n        {\n            printf (\"-1\\n\");\n            return 0;\n        }\nfor (int i=1; i<=nr; i++)\n    for (int j=0; j<2; j++)\n        dp[i][j] = INF;\ndp[1][1] = max (1, sz[2]);\nfor (int i=1; i<nr; i++)\n    for (int j=0; j<=may[i]; j++)\n        for (int k=0; k<=may[i + 1]; k++)\n        {\n            if (k == 0 && both1[i + 1] == 1)\n                dp[i + 1][k] = min (dp[i + 1][k], dp[i][j] + sz[i + 1]);\n            int curr = dp[i][j];\n            if (j == 0)\n            {\n                if (findPair (a[i + 1] - 1, b[i + 1]) == 0 && both1[i + 1] == 0) continue;\n                curr += sz[i + 1];\n            }\n            if (k == 0 && b[i + 1] > 0)\n            {\n                if (findPair (a[i + 1], b[i + 1] - 1) == 0 && both1[i + 1] == 0) continue;\n                curr += sz[i + 1];\n            }\n            else\n            if (k == 1) curr += max (sz[i + 1], sz[i]);\n            if (curr < dp[i + 1][k])\n                dp[i + 1][k] = curr;\n        }\nprintf (\"%d\\n\", min (dp[nr][0], dp[nr][1]));\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint n;\nvvi a;\n\nint f(int i,int x){\n\treturn upper_bound(a[i].begin(),a[i].end(),x)-lower_bound(a[i].begin(),a[i].end(),x);\n}\n\nint main(){\n\tcin>>n;\n\ta=vvi(n+1);\n\tint res=n-1,d;\n\tfor(int i=0;i<n;i++){\n\t\tint A,B;\n\t\tcin>>A>>B;\n\t\ta[A].push_back(B);\n\t\tif(i==1) d=A;\n\t}\n\tfor(int i=0;i<n;i++) sort(a[i].begin(),a[i].end());\n\tif(a[0].size()!=1||a[0][0]!=d) res=-inf;\n\tfor(int i=1;i<n;i++) for(int j=0;j<a[i].size();j++){\n\t\tint x=a[i][j];\n\t\tif(x<abs(i-d)||i+d<x) res=-inf;\n\t\tif(x==0&&j==0&&i==d||f(i-1,x-1)) continue;\n\t\tif(f(i+1,x-1)){\n\t\t\tint t=f(i+1,x-1),I=upper_bound(a[i].begin(),a[i].end(),x)-a[i].begin();\n\t\t\tres+=max(I-j-t,0);\n\t\t\tj=I-1;\n\t\t}\n\t\telse if(f(i,x-1)) res++;\n\t\telse res=-inf;\n\t}\n\tcout<<max(res,-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nvoid ng() {\n        printf(\"-1\\n\");\n        exit(0);\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<set<int>> ab(n), ba(n);\n        vector<pair<int, int>> p;\n        for (int i = 0; i < n; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                p.emplace_back(a, b);\n                ab[a].insert(b);\n                ba[b].insert(a);\n        }\n        if (p[0].first != 0 || p[1].second != 0) ng();\n        if (p[0].second != p[1].first) ng();\n        for (int i = 2; i < n; i ++) {\n                int a, b;\n                tie(a, b) = p[i];\n                if (a == 0 || b == 0) ng();\n                if (ab[a - 1].count(b + 1) == 0 && ab[a - 1].count(b) == 0 && ab[a - 1].count(b - 1)) ng();\n                if (ba[b - 1].count(a + 1) == 0 && ba[b - 1].count(a) == 0 && ba[b - 1].count(a - 1)) ng();\n        }\n        assert(false);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 26.11.2019 22:59:30       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n  }\n  if (a[0] != 0 || b[1] != 0 || a[1] == 0 || a[1] != b[0]) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  int d = a[1];\n  vector<int> was(d + 1, 0);\n  for (int i = 0; i < n; i++) {\n    if (a[i] + b[i] < d) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    if (a[i] + b[i] == d) {\n      was[a[i]] = 1;\n    }\n  }\n  if (*min_element(was.begin(), was.end()) == 0) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  set<pair<int, int>> s;\n  for (int i = 0; i < n; i++) {\n    s.emplace(a[i], b[i]);\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (s.find({a[i] - 1, b[i] - 1}) != s.end()) {\n      ans += 2;\n    } else {\n      if (a[i] > 0) {\n        if (s.find({a[i] - 1, b[i] + 1}) != s.end()) ans += 1; else\n        if (s.find({a[i] - 1, b[i]}) != s.end()) ans += 2;\n        else {\n          cout << -1 << '\\n';\n          return 0;\n        }\n      }\n      if (b[i] > 0) {\n        if (s.find({a[i] + 1, b[i] - 1}) != s.end()) ans += 1; else\n        if (s.find({a[i], b[i] - 1}) != s.end()) ans += 2;\n        else {\n          cout << -1 << '\\n';\n          return 0;\n        }\n      }\n    }\n  }\n  assert(ans % 2 == 0);\n  cout << ans / 2 << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    return a.one+a.two<b.one+b.two;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=0;\n    if(mn==1) ans++;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+3,shit+n+1,cmp);\n    mp.clear();\n    mp[shit[1]]=1;\n    mp[shit[2]]=1;\n    for(int i=3;i<=n;)\n    {\n        int j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        if(shit[i].one+shit[i].two==mn){\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n                //printf(\"%d %d\\n\",mp.count(tmp1),mp.count(tmp2));\n                if(mp.count(tmp1)&&mp.count(tmp2)){\n                    ans+=2;\n                }\n                else{\n                    puts(\"-1\");\n                    return 0;\n                }\n            }\n        }\n        else{\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two-1;\n                if(mp.count(tmp1)){\n                    ans++;continue;\n                }\n                bool one=0,two=0;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                one=one|mp.count(tmp1);\n                tmp1.two--;\n                one=one|mp.count(tmp1);\n\n\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n                two=two|mp.count(tmp2);\n                tmp2.one--;\n                two=two|mp.count(tmp2);\n                if(one&&two){\n                    ans+=2;continue;\n                }\n                puts(\"-1\");\n                return 0;\n            }\n        }\n        i=j;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=0;\n    if(mn==1)\n        ans++;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+3,shit+n+1,cmp);\n    mp.clear();\n    mp[shit[1]]=1;\n    mp[shit[2]]=1;\n    for(int i=3;i<=n;)\n    {\n        int j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        if(shit[i].one+shit[i].two==mn){\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n                //printf(\"%d %d\\n\",mp.count(tmp1),mp.count(tmp2));\n                if(mp.count(tmp1)&&mp.count(tmp2)){\n                    continue;\n                }\n                else{\n                    puts(\"-1\");\n                    return 0;\n                }\n            }\n            ans=ans+(j-i-mn+1)*2+mn;\n        }\n        else{\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two-1;\n                if(mp.count(tmp1)){\n                    ans++;\n                    continue;\n                }\n                if(shit[k].one==shit[k-1].one&&shit[k].two==shit[k-1].two){\n                    ans+=2;\n                    continue;\n                }\n                bool one=0,two=0;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n\n                if(mp.count(tmp1)&&mp.count(tmp2)&&tmp1.one==shit[k-1].one&&tmp1.two=shit[k-1].two){\n                    ans=ans+1;\n                    continue;\n                }\n                one=one|mp.count(tmp1);\n                tmp1.two--;\n                one=one|mp.count(tmp1);\n\n                two=two|mp.count(tmp2);\n                tmp2.one--;\n                two=two|mp.count(tmp2);\n                if(one&&two){\n                    ans+=2;continue;\n                }\n                puts(\"-1\");\n                return 0;\n            }\n        }\n        i=j;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nvoid ng() {\n        printf(\"-1\\n\");\n        exit(0);\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        set<pair<int, int>> ps;\n        vector<pair<int, int>> p;\n        for (int i = 0; i < n; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                p.emplace_back(a, b);\n                ps.insert({a, b});\n        }\n        if (p[0].first != 0 || p[1].second != 0) ng();\n        if (p[0].second != p[1].first) ng();\n        if (p[0].second == 0) ng();\n        for (int i = 2; i < n; i ++) {\n                int a, b;\n                tie(a, b) = p[i];\n                if (a == 0 || b == 0) ng();\n                if (!ps.count({a - 1, b + 1}) && !ps.count({a - 1, b}) && !ps.count({a - 1, b - 1})) ng();\n                if (!ps.count({a + 1, b - 1}) && !ps.count({a, b - 1}) && !ps.count({a - 1, b - 1})) ng();\n        }\n        map<int, map<int, int>> s;\n        for (int i = 0; i < n; i ++) {\n                s[p[i].first + p[i].second][p[i].first] ++;\n        }\n        int matching = 0;\n        for (auto mpmp : s) {\n                auto sum = mpmp.first;\n                auto mp = mpmp.second;\n                vector<pair<int, int>> v;\n                for (auto it : mp) {\n                        v.emplace_back(it.first, it.second);\n                }\n                sort(v.begin(), v.end());\n                vector<vector<pair<bool, pair<int, int>>>> t; //(bottom left exists, number of the same position)\n                vector<pair<bool, pair<int, int>>> tmp; //(bottom left exists, number of the same position)\n                int preva = -1;\n                for (auto u : v) {\n                        int a = u.first;\n                        if (preva != -1 && preva + 1 != a) {\n                                t.push_back(tmp);\n                                tmp.clear();\n                        }\n                        int b = sum - a;\n                        bool ex = ps.count({a - 1, b - 1});\n                        tmp.push_back({ex, {u.second, u.second}});\n                        preva = a;\n                }\n                if (tmp.size() > 0) t.push_back(tmp);\n                for (auto it : t) {\n                        for (int i = 0; i < (int) it.size(); i ++) {\n                                if (it[i].first) {\n                                        int d = min(it[i].second.first, it[i].second.second);\n                                        matching += d;\n                                        it[i].second.first -= d;\n                                        it[i].second.second -= d;\n                                }\n                                if (it[i].second.second > 0 && i + 1 < (int) it.size()) {\n                                        int d = min(it[i].second.second, it[i + 1].second.first);\n                                        matching += d;\n                                        it[i + 1].second.first -= d;\n                                }\n                        }\n                }\n        }\n        printf(\"%d\\n\", 2 * n - 2 - matching);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=0;\n    ans++;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+3,shit+n+1,cmp);\n    mp.clear();\n    mp[shit[1]]=1;\n    mp[shit[2]]=1;\n    for(int i=3;i<=n;)\n    {\n        int j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        if(shit[i].one+shit[i].two==mn){\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n                //printf(\"%d %d\\n\",mp.count(tmp1),mp.count(tmp2));\n                if(mp.count(tmp1)&&mp.count(tmp2)){\n                    continue;\n                }\n                else{\n                    puts(\"-1\");\n                    return 0;\n                }\n            }\n            ans=ans+(j-mn+1)*2+mn;\n        }\n        else{\n            bool flag;\n            for(int k=i;k<j;k++)\n            {\n                SHIT tmp1,tmp2;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two-1;\n                if(mp.count(tmp1)){\n                    ans++;continue;\n                }\n                if(shit[k].one==shit[k-1].one&&shit[k].two==shit[k-1].two){\n                    ans+=2;\n                    continue;\n                }\n                bool one=0,two=0;\n                tmp1.one=shit[k].one-1;\n                tmp1.two=shit[k].two+1;\n                tmp2.one=shit[k].one+1;\n                tmp2.two=shit[k].two-1;\n\n                if(mp.count(tmp1)&&mp.count(tmp2)){\n                    ans+=2-flag;\n                    flag=1;\n                    continue;\n                }\n                one=one|mp.count(tmp1);\n                tmp1.two--;\n                one=one|mp.count(tmp1);\n\n                two=two|mp.count(tmp2);\n                tmp2.one--;\n                two=two|mp.count(tmp2);\n                if(one&&two){\n                    ans+=2;continue;\n                }\n                puts(\"-1\");\n                return 0;\n            }\n        }\n        i=j;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n        return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    mp.clear();\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n        mp[shit[i]]=1;\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].two==shit[2].one&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one){\n                tk++;\n            }\n            int now=tk-k;\n            bool one=0,two=0;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                if(last+1!=shit[k].one)\n                    now=0;\n                else now=min(now,left);\n                last=shit[k].one;\n                left=now;\n\n                continue;\n                one=1;two=1;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            if(shit[k].one==0)one=1;\n            if(shit[k].two==0) two=1;\n            if(one==0||two==0){\n                puts(\"-1\");\n                return 0;\n            }\n            int del=0;\n            if(last+1==shit[k].one){\n                del=min(now,left);\n                ans-=del;\n            }\n            tmp1.two--;\n\n            last=shit[k].one;\n            left=now;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nstruct SHIT\n{\n    int one,two;\n    bool operator<(const SHIT  &b)const {\n        if(this->one!=b.one) return (this->one<b.one);\n        return (this->two<b.two);\n    }\n}shit[maxn];\nbool cmp(SHIT a,SHIT b)\n{\n    if(a.one+a.two!=b.one+b.two)\n    return a.one+a.two<b.one+b.two;\n    return a.one<b.one;\n}\nmap<SHIT,bool>mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&shit[i].one,&shit[i].two);\n    }\n    if(!(shit[1].one==shit[2].two&&shit[1].one==0&&shit[1].two!=0)){\n        puts(\"-1\");\n        return 0;\n    }\n    int mn=shit[1].two;\n    int ans=2*n-2;\n    if(n==2){\n        if(mn==1){\n            puts(\"1\");\n        }\n        else{\n            puts(\"-1\");\n        }\n        return 0;\n    }\n    for(int i=3;i<=n;i++)\n    {\n        if(shit[i].one==0||shit[i].two==0||shit[i].one+shit[i].two<mn){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    sort(shit+1,shit+n+1,cmp);\n    mp.clear();\n    for(int i=1,j;i<=n;i=j)\n    {\n        j=i+1;\n        while(j<=n&&shit[j].one+shit[j].two==shit[i].one+shit[i].two)\n            j++;\n        for(int k=i;k<j;k++)\n            mp[shit[k]]=1;\n        int last=0,left=0;\n        for(int k=i,tk;k<j;k=tk)\n        {\n            tk=k+1;\n            while(tk<j&&shit[tk].one==shit[k].one&&shit[tk].two==shit[k].two){\n                tk++;\n            }\n            int now=tk-k;\n            SHIT tmp1,tmp2;\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two-1;\n            if(mp.count(tmp1)){\n                ans-=now;\n                last=shit[k].one;\n                left=min(now,left);\n                continue;\n            }\n\n\n            tmp1.one=shit[k].one-1;\n            tmp1.two=shit[k].two+1;\n            tmp2.one=shit[k].one+1;\n            tmp2.two=shit[k].two-1;\n\n            bool one=0,two=0;\n\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            tmp1.two--;\n            tmp2.one--;\n            one=one|mp.count(tmp1);\n            two=two|mp.count(tmp2);\n\n            if((one==0||two==0)&&shit[k].one!=0&&shit[k].two!=0){\n                //printf(\"%d k %d\\n\",shit[k].one,shit[k].two);\n                puts(\"-1\");\n                return 0;\n            }\n            if(last+1==shit[k].one){\n                ans-=min(now,left);\n            }\n            last=shit[k].one;\n            left=now;\n        }\n        //printf(\"%d %d\\n\",shit[i].one+shit[i].two,ans);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint nr, N, a[100009], b[100009], A[100009], B[100009], id[100009], sz[100009], may[100009], both1[100009], dp[100009][2];\nconst int INF = 1e8;\n\nbool cmp (int i, int j)\n{\n    if (A[i] + B[i] == A[j] + B[j]) return (A[i] < A[j]);\n    return (A[i] + B[i] < A[j] + B[j]);\n}\n\nint findPair (int x, int y)\n{\n    int p = 1, u = nr, mij;\n    while (p <= u)\n    {\n        mij = (p + u) >> 1;\n        if (a[mij] == x && b[mij] == y) return mij;\n        if (a[mij] + b[mij] < x + y || (a[mij] + b[mij] == x + y && a[mij] < x)) p = mij + 1;\n        else u = mij - 1;\n    }\n    return 0;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d %d\", &A[i], &B[i]), id[i] = i;\nsort (id + 1, id + N + 1, cmp);\nif (A[2] != B[1] || A[id[1]] + B[id[1]] < A[2] || A[1] != 0 || B[2] != 0)\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=N; i++)\n    if ((A[i] == 0 && i != 1) || (B[i] == 0 && i != 2))\n    {\n        printf (\"-1\\n\");\n        return 0;\n    }\nfor (int i=1; i<=N; i++)\n{\n    int j = i;\n    while (j + 1 <= N && A[id[j]] == A[id[j + 1]] && B[id[j]] == B[id[j + 1]])\n        j ++;\n    a[++nr] = A[id[i]], b[nr] = B[id[i]], sz[nr] = j - i + 1;\n    i = j;\n}\nfor (int i=1; i<=nr; i++)\n    may[i] = (findPair (a[i] + 1, b[i] - 1) != 0),\n    both1[i] = (findPair (a[i] - 1, b[i] - 1) != 0);\nif (!may[1])\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=nr; i++)\n    if ((a[i] > 0 && findPair (a[i] - 1, b[i]) == 0 && findPair (a[i] - 1, b[i] + 1) == 0 && both1[i] == 0) ||\n        (b[i] > 0 && findPair (a[i], b[i] - 1) == 0 && findPair (a[i] + 1, b[i] - 1) == 0 && both1[i] == 0))\n        {\n            printf (\"-1\\n\");\n            return 0;\n        }\nfor (int i=1; i<=nr; i++)\n    for (int j=0; j<2; j++)\n        dp[i][j] = INF;\ndp[1][1] = 1;\nfor (int i=1; i<nr; i++)\n    for (int j=0; j<=may[i]; j++)\n        for (int k=0; k<=may[i + 1]; k++)\n        {\n            if (k == 0 && both1[i + 1] == 1)\n                dp[i + 1][k] = min (dp[i + 1][k], dp[i][j] + sz[i + 1]);\n            int curr = dp[i][j];\n            if (j == 0)\n            {\n                if (findPair (a[i + 1] - 1, b[i + 1]) == 0 && both1[i + 1] == 0) continue;\n                curr += sz[i + 1];\n            }\n            if (k == 0 && b[i + 1] > 0)\n            {\n                if (findPair (a[i + 1], b[i + 1] - 1) == 0 && both1[i + 1] == 0) continue;\n                curr += sz[i + 1];\n            }\n            if (curr < dp[i + 1][k])\n                dp[i + 1][k] = curr;\n        }\nprintf (\"%d\\n\", min (dp[nr][0], dp[nr][1]));\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\n#define mp make_pair\n#define pb push_back\n#define N 100010\nint n;\nint a[N], b[N];\nmap<PII, set<int> > A;\n\nvoid end() {\n\tputs (\"-1\");\n\texit(0);\n}\n\nint path[N], L;\nbool v[N];\n\nvector<int> c[N];\n// c[i] = connect with path[i] and path[i+1]\nint sc[N];\n\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i ++) {\n  \tcin >> a[i] >> b[i];\n  \tA[mp(a[i], b[i])].insert(i);\n  }\n  if (a[0] != 0 || b[1] != 0 || a[1] != b[0]) end();\n  L = a[1];\n  path[0] = 0;\n  path[L] = 1;\n  for (int i = 1; i < L; i++)\n  \tpath[i] = -1;\n  for (int i = 2; i < n; i++)\n  \tif (a[i] + b[i] == L) {\n  \t\tif (path[a[i]] == -1) {\n  \t\t   path[a[i]] = i;\n  \t\t   v[i] = true;\n  \t\t}\n  \t}\n  for (int i = 2; i < n; i ++) {\n    if (a[i] == 0 || b[i] == 0) end();\n    if (a[i] + b[i] < L) end();\n  }\n  int S = 0;\n  S += L; // path\n  for (int i = 2; i < n; i ++) {\n    if (a[i] + b[i] == L) {\n      S += 2;\n    } else\n    if (a[i] + b[i] == L+1) {\n      S += 2;\n      c[a[i]-1].pb(i);\n    } else {\n      if (A.find(mp(a[i]-1, b[i]-1)) != A.end()) {\n        S ++;\n      } else {\n        end();\n      }\n    }\n  }\n  for (int i = 0; i < L; i ++) {\n    sc[i] = (int) c[i].size();\n  }\n  for (int i = 0; i < L-1; i ++) {\n    int T = min(sc[i], sc[i+1]);\n    S -= T;\n  }\n  cout << S << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nvoid ng() {\n        printf(\"-1\\n\");\n        exit(0);\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<set<int>> ab(n), ba(n);\n        vector<pair<int, int>> p;\n        for (int i = 0; i < n; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                p.emplace_back(a, b);\n                ab[a].insert(b);\n                ba[b].insert(a);\n        }\n        if (p[0].first != 0 || p[1].second != 0) ng();\n        if (p[0].second != p[1].first) ng();\n        if (p[0].second == 0) ng();\n        for (int i = 2; i < n; i ++) {\n                int a, b;\n                tie(a, b) = p[i];\n                cerr << a << ' ' << b << endl;\n                if (a == 0 || b == 0) ng();\n                if (ab[a - 1].count(b + 1) == 0 && ab[a - 1].count(b) == 0 && ab[a - 1].count(b - 1) == 0) ng();\n                if (ba[b - 1].count(a + 1) == 0 && ba[b - 1].count(a) == 0 && ba[b - 1].count(a - 1) == 0) ng();\n        }\n        assert(false);\n        return 0;\n}\n\n"
  },
  {
    "language": "Text",
    "code": "-1\n"
  },
  {
    "language": "Text",
    "code": "-1"
  },
  {
    "language": "Text",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint n;\nvvi a;\n\nint f(int i,int x){\n\treturn upper_bound(a[i].begin(),a[i].end(),x)-lower_bound(a[i].begin(),a[i].end(),x);\n}\n\nint main(){\n\tcin>>n;\n\ta=vvi(n+1);\n\tint res=n-1,d;\n\tfor(int i=0;i<n;i++){\n\t\tint A,B;\n\t\tcin>>A>>B;\n\t\ta[A].push_back(B);\n\t\tif(i==1) d=A;\n\t}\n\tfor(int i=0;i<n;i++) sort(a[i].begin(),a[i].end());\n\tif(a[0].size()!=1||a[0][0]!=d) res=-inf;\n\tfor(int i=1;i<n;i++) for(int j=0;j<a[i].size();j++){\n\t\tint x=a[i][j];\n\t\tif(x<abs(i-d)||i+d<x) res=-inf;\n\t\tif(x==0) continue;\n\t\tif(f(i-1,x-1));\n\t\telse if(f(i+1,x-1)){\n\t\t\tint t=f(i+1,x-1),I=upper_bound(a[i].begin(),a[i].end(),x)-a[i].begin();\n\t\t\tres+=abs(I-j-t);\n\t\t\tj=I-1;\n\t\t}\n\t\telse if(f(i,x-1)) res++;\n\t\telse res=-inf;\n\t}\n\tcout<<max(res,-1)<<endl;\n}"
  },
  {
    "language": "Python",
    "code": "n = input()\nD = [tuple(map(int, raw_input().split())) for i in xrange(n)]\nif (not D[0][0] == D[1][1] == 0 or not D[0][1] == D[1][0] > 0\n        or any(i>1 and (d[0] == 0 or d[1] == 0) for i, d in enumerate(D))):\n    print -1\n    exit(0)\nm = {}\nfor i, d in enumerate(D):\n    m[d] = m.get(d, 0) + 1 if i>0 else 0\nP = D[:2]\nD.sort()\n\ncnt = 0\nfor x, y in D:\n    if (x+1, y+1) in m:\n        cnt += m[x+1, y+1]\n        m[x+1, y+1] = 0\n    if (x+1, y-1) in m:\n        cnt += m[x+1, y-1]\n        m[x+1, y-1] = 0\n\ndef dfs(x, y, dd, used):\n    used.add((x, y))\n    for dx, dy in dd:\n        nx = x + dx; ny = y + dy\n        if (nx, ny) in m and (nx, ny) not in used:\n            dfs(nx, ny, dd, used)\nusedA = set(); usedB = set()\ndfs(P[0][0], P[0][1], [(1, 1), (1, 0), (1, -1)], usedA)\ndfs(P[1][0], P[1][1], [(1, 1), (0, 1), (-1, 1)], usedB)\nif len(m) == len(usedA) == len(usedB):\n    print 2*n - 2 - cnt\nelse:\n    print -1\n"
  },
  {
    "language": "Python",
    "code": "n = input()\nD = [tuple(map(int, raw_input().split())) for i in xrange(n)]\nif (not D[0][0] == D[1][1] == 0 or not D[0][1] == D[1][0] > 0\n        or any(i>1 and (d[0] == 0 or d[1] == 0) for i, d in enumerate(D))):\n    print -1\n    exit(0)\nm = {}\nfor i, d in enumerate(D):\n    m[d] = m.get(d, 0) + 1 if i>0 else 0\nD.sort()\nused = [0]*n\n\ncnt = 0\nfor x, y in D:\n    if (x+1, y+1) in m:\n        cnt += m[x+1, y+1]\n        m[x+1, y+1] = 0\n    if (x+1, y-1) in m:\n        cnt += m[x+1, y-1]\n        m[x+1, y-1] = 0\nok = 1\nfor x, y in D:\n    if m[x, y] > 0:\n        if (x-1, y) not in m or (x, y-1) not in m:\n            ok = 0\nif ok:\n    print 2*n - 2 - cnt\nelse:\n    print -1"
  }
]