[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n#define MAX_M 100005\n\nint propellers[MAX_M];\nint N, M, Q;\n\nint check(int arrow_length, int max_losses) {\n    int losses = 0;\n    int last_covered = 0;\n\n    for (int target = 1; target <= N; target++) {\n        if (target > last_covered) {\n            losses++;\n            if (losses > max_losses) return 0;\n            \n            int propeller_found = 0;\n            for (int j = 0; j < M; j++) {\n                if (propellers[j] >= target - arrow_length + 1 && propellers[j] <= target) {\n                    last_covered = target + arrow_length - 1;\n                    propeller_found = 1;\n                    break;\n                }\n            }\n            \n            if (!propeller_found) {\n                return 0;\n            }\n        }\n    }\n    \n    return 1;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    \n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &propellers[i]);\n    }\n    \n    for (int q = 0; q < Q; q++) {\n        int max_losses;\n        scanf(\"%d\", &max_losses);\n        \n        int left = 1, right = N + 1;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            \n            if (check(mid, max_losses)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        printf(\"%d\\n\", left > N ? -1 : left);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:04:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, M, Q;\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    \n    int *P = (int *)malloc(M * sizeof(int));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &P[i]);\n    }\n    \n    // Sort propellers\n    for (int i = 0; i < M; i++) {\n        for (int j = i + 1; j < M; j++) {\n            if (P[i] > P[j]) {\n                int temp = P[i];\n                P[i] = P[j];\n                P[j] = temp;\n            }\n        }\n    }\n    \n    // Precompute prefix sums\n    int *prefix = (int *)malloc((M + 1) * sizeof(int));\n    prefix[0] = 0;\n    for (int i = 1; i <= M; i++) {\n        prefix[i] = prefix[i - 1] + P[i - 1];\n    }\n    \n    // Process queries\n    while (Q--) {\n        int l_i;\n        scanf(\"%d\", &l_i);\n        \n        int left = 1, right = N, ans = N;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            int losses = 0;\n            \n            // Find the first propeller >= mid\n            int low = 0, high = M - 1, pos = M;\n            while (low <= high) {\n                int m = (low + high) / 2;\n                if (P[m] >= mid) {\n                    pos = m;\n                    high = m - 1;\n                } else {\n                    low = m + 1;\n                }\n            }\n            \n            // Calculate losses in [1, mid - 1]\n            losses += (mid - 1) - pos;\n            \n            // Check if mid is a propeller\n            if (pos < M && P[pos] == mid) {\n                losses = 0;\n            } else {\n                // Calculate losses in [mid + 1, N]\n                int next_pos = pos;\n                losses += (N - mid) - (M - next_pos);\n            }\n            \n            if (losses <= l_i) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    \n    free(P);\n    free(prefix);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:04:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vector<int> P(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> P[i];\n    }\n    sort(P.begin(), P.end());\n\n    vector<int> gaps;\n    int prev = 0;\n    for (int p : P) {\n        if (p > prev) {\n            gaps.push_back(p - prev - 1);\n        }\n        prev = p;\n    }\n    if (N > prev) {\n        gaps.push_back(N - prev);\n    }\n    sort(gaps.begin(), gaps.end());\n\n    vector<int> prefix(gaps.size() + 1, 0);\n    for (int i = 0; i < gaps.size(); ++i) {\n        prefix[i + 1] = prefix[i] + gaps[i];\n    }\n\n    while (Q--) {\n        int l;\n        cin >> l;\n        int k = upper_bound(gaps.begin(), gaps.end(), l) - gaps.begin();\n        int sum = prefix[k] + (gaps.size() - k) * l;\n        cout << sum + 1 << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:04:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        int Q = Integer.parseInt(st.nextToken());\n        \n        int[] propellers = new int[M];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < M; i++) {\n            propellers[i] = Integer.parseInt(st.nextToken());\n        }\n        Arrays.sort(propellers);\n        \n        int[] prefix = new int[M + 1];\n        for (int i = 0; i < M; i++) {\n            prefix[i + 1] = prefix[i] + propellers[i];\n        }\n        \n        int[] queries = new int[Q];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < Q; i++) {\n            queries[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        int[] res = new int[Q];\n        for (int q = 0; q < Q; q++) {\n            int l_i = queries[q];\n            int low = 1;\n            int high = N;\n            int answer = N;\n            \n            while (low <= high) {\n                int mid = (low + high) / 2;\n                int count = 0;\n                int prev = 0;\n                \n                for (int p : propellers) {\n                    if (p > prev) {\n                        int start = prev;\n                        int end = Math.min(p, prev + mid);\n                        count += end - start - 1;\n                        prev = p;\n                    }\n                }\n                if (propellers.length > 0) {\n                    int start = propellers[M - 1];\n                    int end = Math.min(N, start + mid);\n                    count += end - start;\n                } else {\n                    count += Math.min(N, mid);\n                }\n                \n                if (count <= l_i) {\n                    answer = mid;\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n            res[q] = answer;\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        for (int num : res) {\n            sb.append(num).append(\" \");\n        }\n        System.out.println(sb.toString().trim());\n    }\n}",
    "timestamp": "2025-08-05 22:05:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void solve(int N, int M, int Q, int[] queries) {\n        int[] result = new int[Q];\n        \n        for (int q = 0; q < Q; q++) {\n            int maxLosses = queries[q];\n            int low = 1, high = N + 1;\n            \n            while (low < high) {\n                int mid = (low + high) / 2;\n                \n                if (canDeliver(N, M, mid, maxLosses)) {\n                    high = mid;\n                } else {\n                    low = mid + 1;\n                }\n            }\n            \n            result[q] = low;\n        }\n        \n        for (int r : result) {\n            System.out.println(r);\n        }\n    }\n    \n    private static boolean canDeliver(int N, int M, int arrowLength, int maxLosses) {\n        int[] propellers = new int[M];\n        \n        for (int i = 0; i < (1 << M); i++) {\n            int losses = 0;\n            boolean[] placedPropellers = new boolean[N + 1];\n            \n            for (int j = 0; j < M; j++) {\n                if ((i & (1 << j)) > 0) {\n                    placedPropellers[propellers[j]] = true;\n                }\n            }\n            \n            for (int x = 1; x <= N; x++) {\n                boolean covered = false;\n                for (int j = Math.max(0, x - arrowLength + 1); j <= x; j++) {\n                    if (placedPropellers[j]) {\n                        covered = true;\n                        break;\n                    }\n                }\n                \n                if (!covered) {\n                    losses++;\n                }\n                \n                if (losses > maxLosses) {\n                    break;\n                }\n            }\n            \n            if (losses <= maxLosses) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        int Q = Integer.parseInt(st.nextToken());\n        \n        st = new StringTokenizer(br.readLine());\n        int[] propellers = new int[M];\n        for (int i = 0; i < M; i++) {\n            propellers[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        st = new StringTokenizer(br.readLine());\n        int[] queries = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            queries[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        solve(N, M, Q, queries);\n    }\n}",
    "timestamp": "2025-08-05 22:05:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool is_possible(int arrow_length, int num_propellers, int target, int max_losses) {\n    vector<bool> propeller(target + 1, false);\n    \n    // Place propellers\n    for (int i = 0; i < num_propellers; i++) {\n        int pos;\n        cin >> pos;\n        propeller[pos] = true;\n    }\n    \n    int losses = 0;\n    for (int tip = 1; tip <= target; tip++) {\n        bool has_propeller = false;\n        \n        // Check if there's a propeller between base and tip\n        for (int base = max(0, tip - arrow_length); base < tip; base++) {\n            if (propeller[base]) {\n                has_propeller = true;\n                break;\n            }\n        }\n        \n        if (!has_propeller) {\n            losses++;\n        }\n        \n        if (losses > max_losses) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int Q;\n    cin >> Q;\n    \n    while (Q--) {\n        int N, M, l;\n        cin >> N >> M >> l;\n        \n        int left = 1, right = N;\n        int result = -1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (is_possible(mid, M, N, l)) {\n                result = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        cout << result << \"\\n\";\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:05:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_arrow_length(N, M, propeller_positions, Q, loss_queries):\n    propeller_set = set(propeller_positions)\n    result = []\n\n    for l_i in loss_queries:\n        left, right = 1, N\n        while left < right:\n            mid = (left + right) // 2\n            losses = sum(1 for i in range(mid) if i not in propeller_set)\n            if losses <= l_i:\n                right = mid\n            else:\n                left = mid + 1\n        result.append(right)\n    \n    return result\n\n# Example Usage:\nN = 10\nM = 2\npropeller_positions = [3, 7]\nQ = 3\nloss_queries = [2, 5, 10]\n\nprint(min_arrow_length(N, M, propeller_positions, Q, loss_queries))",
    "timestamp": "2025-08-13 08:51:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class RodeaArrows {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int Q = sc.nextInt();\n\n        TreeSet<Integer> propellers = new TreeSet<>();\n        for (int i = 0; i < M; i++) {\n            propellers.add(sc.nextInt());\n        }\n\n        int[] queries = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            queries[i] = sc.nextInt();\n        }\n\n        for (int i = 0; i < Q; i++) {\n            int l_i = queries[i];\n            int low = 1, high = N, answer = N;\n\n            while (low <= high) {\n                int mid = (low + high) / 2;\n                if (canDeliver(mid, N, propellers, l_i)) {\n                    answer = mid;\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n\n            System.out.println(answer);\n        }\n\n        sc.close();\n    }\n\n    private static boolean canDeliver(int arrowLength, int N, TreeSet<Integer> propellers, int maxLosses) {\n        int losses = 0;\n\n        for (int i = 1; i <= N; i++) {\n            int tip = i;\n            int base = i - arrowLength + 1;\n\n            if (base > 0 && !hasPropellerInRange(base, tip, propellers)) {\n                losses++;\n                if (losses > maxLosses) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    private static boolean hasPropellerInRange(int start, int end, TreeSet<Integer> propellers) {\n        Integer propeller = propellers.ceiling(start);\n        return propeller != null && propeller <= end;\n    }\n}",
    "timestamp": "2025-08-13 08:51:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint minArrowLength(int N, int M, int propellers[], int max_loss) {\n    int minLength = N;\n    int i, lossCount, j;\n    for (i = 1; i <= N; i++) {\n        lossCount = 0;\n        for (j = 1; j <= N; j++) {\n            int covered = 0;\n            for (int k = 0; k < M; k++) {\n                if (propellers[k] >= j - i + 1 && propellers[k] <= j) {\n                    covered = 1;\n                    break;\n                }\n            }\n            if (!covered) lossCount++;\n        }\n        if (lossCount <= max_loss) {\n            minLength = i;\n            break;\n        }\n    }\n    return minLength;\n}\n\nint main() {\n    int N, M, Q;\n    scanf(\"%d %d %d\", &N, &M, &Q);\n\n    int *propellers = (int *)malloc(M * sizeof(int));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &propellers[i]);\n    }\n\n    for (int q = 0; q < Q; q++) {\n        int l_i;\n        scanf(\"%d\", &l_i);\n        printf(\"%d\\n\", minArrowLength(N, M, propellers, l_i));\n    }\n\n    free(propellers);\n    return 0;\n}",
    "timestamp": "2025-08-13 08:51:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_arrow_problem(N, M, Q, queries):\n    def check(arrow_length):\n        propellers = [0] * (N + 1)\n        for i in range(M):\n            propellers[i] = 1\n        \n        losses = 0\n        for i in range(1, N + 1):\n            if all(propellers[max(0, i - arrow_length):i] == [0] * min(arrow_length, i)):\n                losses += 1\n        \n        return losses\n    \n    results = []\n    for l in queries:\n        left, right = 1, N + 1\n        while left < right:\n            mid = (left + right) // 2\n            if check(mid) <= l:\n                right = mid\n            else:\n                left = mid + 1\n        results.append(left)\n    \n    return results\n\n# Input processing\nN, M, Q = map(int, input().split())\npropeller_positions = list(map(int, input().split()))\nqueries = [int(input()) for _ in range(Q)]\n\n# Solve and output results\nresults = solve_arrow_problem(N, M, Q, propeller_positions)\nfor result in results:\n    print(result)",
    "timestamp": "2025-08-13 08:52:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N, M, Q = map(int, input[ptr:ptr+3])\n    ptr +=3\n    \n    propellers = list(map(int, input[ptr:ptr+M]))\n    ptr +=M\n    propellers.sort()\n    \n    # Precompute the gaps between consecutive propellers and boundaries\n    gaps = []\n    prev = 0\n    for p in propellers:\n        gap = p - prev -1\n        if gap >0:\n            gaps.append(gap)\n        prev = p\n    gap = N - prev\n    if gap >0:\n        gaps.append(gap)\n    \n    gaps.sort()\n    \n    # Precompute prefix sum of gaps\n    prefix = [0]*(len(gaps)+1)\n    for i in range(len(gaps)):\n        prefix[i+1] = prefix[i] + gaps[i]\n    \n    # Process queries\n    res = []\n    for _ in range(Q):\n        l_i = int(input[ptr])\n        ptr +=1\n        \n        # Binary search for the minimal k such that sum_{gap >=k} (gap -k +1) <= l_i\n        left = 1\n        right = N\n        answer = N\n        \n        while left <= right:\n            mid = (left + right) //2\n            # Find the first gap >= mid\n            low = 0\n            high = len(gaps)\n            pos = len(gaps)\n            while low < high:\n                m = (low + high) //2\n                if gaps[m] >= mid:\n                    high = m\n                else:\n                    low = m +1\n            pos = low\n            total = prefix[len(gaps)] - prefix[pos] - mid * (len(gaps) - pos) + (len(gaps) - pos)\n            \n            if total <= l_i:\n                answer = mid\n                right = mid -1\n            else:\n                left = mid +1\n        res.append(answer)\n    \n    print('\\n'.join(map(str, res)))\n\nsolve()",
    "timestamp": "2025-08-13 08:52:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    \n    set<int> propeller_positions;\n    for (int i = 0; i < M; i++) {\n        int pos;\n        cin >> pos;\n        propeller_positions.insert(pos);\n    }\n    \n    vector<int> queries(Q);\n    for (int i = 0; i < Q; i++) {\n        cin >> queries[i];\n    }\n    \n    for (int qi = 0; qi < Q; qi++) {\n        int l_i = queries[qi];\n        int left = 1, right = N, ans = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            int losses = 0;\n            for (int j = 1; j <= N; j++) {\n                if (!propeller_positions.count(j) && j - mid + 1 > 0) {\n                    losses++;\n                }\n            }\n            if (losses <= l_i) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:48:05"
  }
]