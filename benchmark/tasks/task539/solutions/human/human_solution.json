[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\nimport scala.collection.mutable.ArrayBuffer\nobject Main extends App {\n  import scala.io.StdIn._\n\n\n  val Array(n, m) = readLine.trim.split(' ').map(_.toInt)\n  val fan = readLine.trim.split(' ').map(_.toInt) :+ n + 1\n  val q = readInt\n  val defaultLoss = fan.head - 1\n  val loss = fan.indices.tail.map(i ⇒ fan(i).toLong - fan(i - 1)).sorted.toArray\n  val sumLoss = (0L +: loss).also(a ⇒ a.indices.tail.foreach(i ⇒ a(i) += a(i - 1)))\n  for (l ← readLine.trim.split(' ').map(_.toInt)){\n    if (defaultLoss <= l) {\n      var min = 1\n      var max = n\n      while (min < max) {\n        val mid = (min + max) / 2\n        val count = upperBound(loss, mid)//lossが起きない送風機の数\n        if (l < sumLoss.last - sumLoss(count) - (m - count) * mid + defaultLoss) {\n          min = mid + 1\n        } else {\n          max = mid\n        }\n      }\n      println(max)\n    }else println(-1)\n  }\n\n\n  def upperBound(array: Array[Long], target: Int): Int = {\n    var left = 0\n    var right = array.length\n    while(left < right){\n      val mid = (left + right) / 2\n      if (array(mid) <= target){\n        left = mid + 1\n      }else {\n        right = mid\n      }\n    }\n    right\n  }\n  implicit class Scope[T](val value: T) extends AnyVal {\n    @inline\n    def let[A](func: T ⇒ A): A = func(value)\n    @inline\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ld INF = (ld)10000000000000;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nint n, m;\nint x[1 << 17];\n\nint ans[1 << 17];\n\npriority_queue<int, vector<int>, greater<int>>q;\nvector<P> vr;\n\nint main() {\n\tcin >> n >> m;\n\trep(i, m) {\n\t\tcin >> x[i];\n\t}\n\tans[1] = n - m;\n\trep(i, m - 1) {\n\t\tif (x[i + 1] - x[i]-1 > 0)q.push(x[i + 1] - x[i] - 1);\n\t}\n\t//if (x[0] > 1)q.push(x[0] - 1);\n\tif (n - x[m - 1] > 0)q.push(n - x[m - 1]);\n\tRep1(i, 2, n) {\n\t\tans[i] = ans[i - 1] - q.size();\n\t\twhile (!q.empty() && q.top() < i)q.pop();\n\t\t//cout << i << \" \" << ans[i] << endl;\n\t}\n\trep1(i, n) {\n\t\tvr.push_back({ ans[i],i });\n\t}\n\tsort(vr.begin(), vr.end());\n\tint q; cin >> q;\n\trep(aa, q) {\n\t\tint l; cin >> l;\n\t\tint id = lower_bound(vr.begin(), vr.end(), P{ l+1,-1 }) - vr.begin();\n\t\tif (id == 0)cout << -1 << endl;\n\t\telse {\n\t\t\tid--;\n\t\t\tint out = n - id;\n\t\t\tcout << out << endl;\n\t\t}\n\t}\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M;\nint m[100050];\nint length[100050];\nint main() {\n    cin >> N >> M;\n    for(int i = 1; i <= M; i++) {\n        cin >> m[i];\n    }\n    m[M + 1] = N + 1;\n    //length[1] = m[1] - 1;\n    for(int i = 2; i <= M + 1; i++) {\n        int delta = m[i] - m[i - 1];\n        length[delta-1]++;\n        //cout << delta << endl;\n        //length[1] += 1;\n        //length[delta+1] -= delta;\n        //length[delta+2] += delta;\n    }\n    for(int i = 1; i <= N; i++) {\n        //cout << i << \" \" << length[i] << endl;\n    }\n    for(int i = N-1; i >= 1; i--) {\n        length[i] += length[i+1];\n    }\n    for(int i = 1; i <= N; i++) {\n        //cout << i << \" \" << length[i] << endl;\n    }\n    for(int i = N-1; i >= 1; i--) {\n        length[i] += length[i+1];\n    }\n    for(int i = 1; i <= N; i++) {\n        //cout << i << \" \" << length[i] << endl;\n    }\n    for(int i = 1; i <= N; i++) {\n        length[i] += m[1] - 1;\n        //cout << i << \" \" << length[i] << endl;\n    }\n    int Q;\n    cin >> Q;\n    while(Q--) {\n        int l;\n        cin >> l;\n        if(length[N] > l) {\n            cout << -1 << endl;\n            continue;\n        }\n        int ok = N;\n        int ng = 0;\n        while(ok - ng > 1) {\n            int mid = (ok + ng) / 2;\n            if(length[mid] <= l) ok = mid;\n            else ng = mid;\n        }\n        cout << ok << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  vector<int> p(m);\n  for(int i=0;i<m;i++) cin>>p[i];\n  \n  vector<int> cnt(n+1,0);\n  for(int i=0;i+1<m;i++) cnt[p[i+1]-p[i]-1]++;\n\n  vector<int> v(n+2,0);\n  int sum=0;\n  for(int i=n;i>=1;i--){\n    sum+=cnt[i];\n    v[i]=v[i+1]+sum;\n    //cout<<i<<\":\"<<v[i]<<endl;\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int x;\n    cin>>x;\n    x-=p[0]-1;\n    if(x<0){\n      cout<<-1<<\"\\n\";\n      continue;\n    }\n    int l=0,r=n;\n    while(l+1<r){\n      int mid=(l+r)>>1;\n      if(max(0,n-p[m-1]-(mid-1))+v[mid]<=x) r=mid;\n      else l=mid;\n    }\n    cout<<r<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n#include <iostream>\n#include <vector>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\n#include <complex>\n#include <bitset>\n#include <functional>\n#include <stack>\n#include <regex>\n#include <tuple>\n#include <iomanip>\n\n#define int long long\n#define REP(i, l, r) REPEAT(i,l,r,true) // [l, r)\n#define rep(i, n) REP(i,0,n)           // [0, n)\n#define REPEAT(i, l, r, condition) for(int i=(condition)?l:r-1;(condition)?i<r:i>=l;(condition)?++i:--i) // false<-[l, r)->true\n#define all(e) e.begin(),e.end()\n#define rall(e) e.rbegin(),e.rend()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(...) cerr<<#__VA_ARGS__<<\" = \";_DEBUG(__VA_ARGS__)\n#define showlr(n, l, r) cerr<<#n<<\" = \";for(int i=l;i<r;i++){cerr<<n[i]<<\", \";}cerr<<endl // [l, r)\n\n#define YN(condition) puts((condition)?\"YES\":\"NO\")\n#define Yn(condition) puts((condition)?\"Yes\":\"No\")\n#define yn(condition) puts((condition)?\"yes\":\"no\")\n#define YES puts(\"YES\")\n#define Yes puts(\"Yes\")\n#define yes puts(\"yes\")\n#define NO  puts(\"NO\")\n#define No  puts(\"No\")\n#define no  puts(\"no\")\n\n#define case(i) printf(\"Case #%lld: \",i)\n\nusing namespace std;\n\nusing vi=vector< int >;\nusing pint=pair< int, int >;\n\nstruct io {\n  io() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout.tie(0);\n    cout << fixed << setprecision(20);\n  }\n} io;\n\ntemplate< class T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &e:v)is >> e;\n  return is;\n}\n\ntemplate< class T >\nostream &operator<<(ostream &os, vector< T > v) {\n  os << \"{\";\n  for(T &e:v)os << e << (v.size() - (int) (&e - &v[0]) > 1 ? \", \" : \"\");\n  os << \"}\";\n  return os;\n}\n\nvoid _DEBUG() {}\n\ntemplate< typename H, typename... T >\nvoid _DEBUG(H a, T...b) {\n  cerr << a << (sizeof...(b) ? \",\" : \"\\n\");\n  _DEBUG(b...);\n}\n\ninline void in() {}\n\ntemplate< typename H, typename... T >\nvoid in(H &a, T &... b) {\n  cin >> a;\n  in(b...);\n}\n\ninline void out() {}\n\ntemplate< typename H, typename... T >\nvoid out(H a, T... b) {\n  cout << a << (sizeof...(b) ? \" \" : \"\\n\");\n  out(b...);\n}\n\ntemplate< class T >\nvoid resz(int n, T &v) { v.resize(n); }\n\ntemplate< class H, class... T >\nvoid resz(int n, H &a, T &... b) {\n  a.resize(n);\n  resz(n, b...);\n}\n\ntemplate< typename V, typename H >\nvoid resize(vector< V > &v, const H a) { v.resize(a); }\n\ntemplate< typename V, typename H, typename... T >\nvoid resize(vector< V > &v, const H &a, const T... b) {\n  v.resize(a);\n  for(auto &v:v) resize(v, b...);\n}\n\nconst int INF = 1LL << 55;\nconst int MOD = 1000000007;\nconst double EPS = 1e-8;\n\nint N, M;\nvi m;\nvi cumsum_arrow(1e5 + 1);\nvi cumsum_dist(1e5 + 1);\nint Q;\n\nsigned main() {\n\n  in(N, M);\n  m.resize(M);\n  in(m);\n  m.push_back(N + 1);\n  sort(begin(m), end(m));\n  m.erase(unique(begin(m), end(m)), end(m));\n  for(int i = 1; i < m.size(); i++) {\n    int sa = m[i] - m[i - 1] - 1;\n    cumsum_arrow[sa]++;\n    cumsum_dist[sa] += sa;\n  }\n\n  REP(i, 1, 1e5 + 1) {\n    cumsum_arrow[i] += cumsum_arrow[i - 1];\n    cumsum_dist[i] += cumsum_dist[i - 1];\n  }\n\n  //showlr(cumsum_arrow, 0, 11);\n  //showlr(cumsum_dist, 0, 11);\n  in(Q);\n\n  while(Q--) {\n    int l;\n    in(l);\n    int lo = 0, hi = 1e5 + 1;\n\n    while(hi - lo > 1) {\n      int med = (hi + lo) / 2;\n      // 矢の長さがmedのときのコスト\n      int cost = (cumsum_dist[1e5] - cumsum_dist[med - 1]) - (cumsum_arrow[1e5] - cumsum_arrow[med - 1]) * (med - 1) + m[0] - 1;\n\n      // show(hi, lo, cost, cost <= l);\n\n      // costが2 lが1\n      if(cost <= l) {\n        hi = med;\n      } else {\n        lo = med;\n      }\n    }\n    if(hi == 1e5 + 1) {\n      out(-1);\n      continue;\n    }\n    out(hi);\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100005\n\nint N,M;\nint input[NUM],table[NUM],dp[NUM];\n\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&M);\n\n\tfor(int i = 0; i <= N; i++){\n\n\t\ttable[i] = 0;\n\t\tdp[i] = 0;\n\t}\n\n\t//区間数の計上\n\tscanf(\"%d\",&input[0]);\n\tint pre = input[0];\n\n\tfor(int i = 1; i < M; i++){\n\n\t\tscanf(\"%d\",&input[i]);\n\t\ttable[(input[i]-pre)-1]++;\n\t\tpre = input[i];\n\t}\n\ttable[N-pre]++;\n\n\tdp[N] = table[N];\n\n\t//累積和\n\tfor(int i = 1; i <= N; i++){\n\n\t\ttable[i] += table[i-1];\n\t}\n\n\tfor(int len = N-1; len >= 1; len--){\n\n\t\tdp[len] = dp[len+1] + (table[N]-table[len-1]);\n\t}\n\n\tint Q,count;\n\tscanf(\"%d\",&Q);\n\n\tint L,R,mid,ans;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\n\t\tscanf(\"%d\",&count);\n\n\t\tcount -= input[0]-1; //必ずinput[0]-1回の損失発生\n\n\t\tL = 1,R = N,mid = (L+R)/2,ans = -1;\n\n\t\twhile(L <= R){\n\n\t\t\tif(dp[mid] <= count){\n\n\t\t\t\tans = mid;\n\t\t\t\tR = mid-1;\n\n\t\t\t}else{\n\n\t\t\t\tL = mid+1;\n\t\t\t}\n\n\t\t\tmid = (L+R)/2;\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n#define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl\n#define STOP assert(false)\n#else\n#define dump(x) ;\n#define LINE     ;\n#define dumpV(v);\n#define STOP     ;\n#endif\n#define mp make_pair\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\nusing ull = unsigned long long;\n\n\nconstexpr ll initVal = 0LL;     //TODO: fix type and value\nconstexpr ll initLazy = 0LL;    //TODO: fix type and value\ntemplate <typename T>\nstruct Node {\n    T val;\n    T lazy;\n    ull l, r;\n    Node<T>* l_node = nullptr;\n    Node<T>* r_node = nullptr;\n    Node(ull l, ull r, const T& val = initVal) : l(l), r(r), val(val), lazy(initLazy) {}\n    T getVal() {\n        return val + lazy * (r - l); //TODO: fix\n    }\n    T f1(const T& a, const T& b) {\n        return a+b;               //TODO: fix\n    }\n    T f2(const T& a, const T& b) {\n        return a+b;                       //TODO: fix\n    }\n    void push() {\n        if(r - l > 1) {\n            auto m = (l+r)/2;\n            {\n                if(l_node == nullptr) l_node = new Node(l, m);\n                if(lazy != initLazy) l_node->lazy = f2(l_node->lazy, this->lazy);\n            }\n            {\n                if(r_node == nullptr) r_node = new Node(m, r);\n                if(lazy != initLazy) r_node->lazy = f2(r_node->lazy, this->lazy); \n            }\n        }\n        val = getVal();\n        lazy = initLazy;\n    }\n    void fix() {\n        if(r - l == 1) return;\n        val = f1(l_node->getVal(), r_node->getVal());\n    }\n    T query(ull qL, ull qR) {\n        if(qR <= l || r <= qL) return initVal;\n        if(qL <= l && r <= qR) return getVal();\n        if(r - l == 1)  return getVal();\n\n        push();\n        T l_val = l_node->query(qL, qR), r_val = r_node->query(qL, qR);\n        return f1(l_val, r_val);\n    }\n    void update(ull uL, ull uR, const T& uVal) {\n        if(uR <= l || r <= uL) return;\n        if(uL <= l && r <= uR) lazy = f2(lazy, uVal);\n        else {\n            push();\n            l_node->update(uL, uR, uVal);\n            r_node->update(uL, uR, uVal);\n            fix();\n        }\n    }\n};\n\ntemplate <typename T>\nstruct DynamicLazySegTree {\n    Node<T> root;\n    DynamicLazySegTree(ull l, ull r, const T& val) : root(l, r, val) {}\n    T query(ull l, ull r) {\n        return root.query(l, r);\n    }\n    void update(ull l, ull r, const T& val) {\n        root.update(l, r, val);\n    }\n};\n\n\n\nint main(){\n    ll n, m;\n    cin >> n >> m;\n    vl a(m+1);\n    rep(i, m) cin >> a[i];\n    a[m] = n+1;\n    vl d(m);\n    rep(i, m) d[i] = a[i+1] - a[i]-1;\n    sort(all(d));\n\n    DynamicLazySegTree<ll> seg(0, d.size(), 0);\n    rep(i, d.size()) seg.update(i, i+1, d[i]);\n\n    vi x(n);\n    const int r = d.size();\n    rep(i, n) {\n        int l = lower_bound(all(d), i+1) - d.begin();\n        x[i] = seg.query(l, r) - i * (r - l);\n    }\n    reverse(all(x));\n\n    // dumpV(d);\n    // dumpV(x);\n\n\n    int Q;\n    cin >> Q;\n    rep(i, Q) {\n        int l;\n        cin >> l;\n\n        auto it = upper_bound(all(x), l - a[0]+1);\n\n        if(it == x.begin()) cout << -1 << endl;\n        else {\n            int id = it - x.begin() - 1;\n            cout << n - id << endl;\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma GCC optimize(\"Ofast\")\n//for CodeForces\n#pragma GCC target(\"avx,avx2\")\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\nmap<long long int, int>soinnsuu(long long int a) {\n\tmap<long long int, int>ans;\n\tfor (long long i = 2; i*i <= a; ++i) {\n\t\twhile (a%i == 0) {\n\t\t\tans[i]++;\n\t\t\ta /= i;\n\t\t}\n\t}\n\tif (a != 1)ans[a]++;\n\n\n\treturn ans;\n}\nstruct query {\n\tint id;\n\tint num;\n};\nint main() {\n\tint N,M;cin>>N>>M;\n\tvector<int>v(M);\n\tfor (int i = 0; i < M; ++i) { cin >> v[i]; };\n\tvector<int>nums;\n\tint need=v[0];\n\tfor (int i = 0; i < M - 1; ++i) {\n\t\tnums.push_back(v[i+1]-v[i]);\n\t}\n\tnums.push_back(N-v.back()+1);\n\tmap<int,int>mp;\n\tfor (auto n : nums) {\n\t\tmp[n]++;\n\t}\n\tvector<int>anss(100005);\n\tanss[1]=N-M;\n\tint minus=M;\n\tfor (int i = 2; i < 100005; ++i) {\n\t\tminus-=mp[i-1];\n\t\tanss[i]=anss[i-1]-minus;\n\t}\n\tanss.erase(anss.begin());\n\treverse(anss.begin(),anss.end());\n\tint Q;cin>>Q;\n\tvector<pair<int,int>>qs;\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint a;cin>>a;\n\t\tqs.push_back(make_pair(a,i));\n\t\tauto it=lower_bound(anss.begin(),anss.end(),a+1);\n\n\t\tint nans=(anss.end()-it);\n\t\tif(it==anss.begin())nans=-2;\n\t\tcout<<nans+1<<endl;\n\t}\n\n\n\n\tvector<int>real_anss(Q);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_SEG_SIZE = 100010;\n\nint N, M, Q;\nvector<int> m;\nint sum = 0;\nint dp[MAX_SEG_SIZE];\nint dp2[MAX_SEG_SIZE];\n\nint solve(int length){\n  int loss = sum;\n  // loss += m[0] - 1;\n  loss -= dp[length-1];\n  loss -= (length-1) * dp2[length];\n  return loss;\n}\n\nint main(void){\n  cin >> N >> M;\n  m = vector<int>(M);\n  for(auto& _m: m){\n    cin >> _m;\n    _m--;\n  }\n\n\n  sum = N - M;\n  int num_of_seg = M+1;\n  vector<int> seg_len(num_of_seg);\n  for(int i = 0; i < (int)seg_len.size(); i++){\n    int next = (i == num_of_seg-1 ? N : m[i]);\n    int prev = (i == 0 ? 0 : m[i - 1]);\n    seg_len[i] = next - prev - 1;\n  }\n  // dp[i] := 長さi以上の区間の数\n  memset(dp, 0, sizeof(int) * MAX_SEG_SIZE);\n  memset(dp2, 0, sizeof(int) * MAX_SEG_SIZE);\n  for(int i = 1; i < num_of_seg; i++){\n    dp[seg_len[i]] += seg_len[i];\n    dp2[seg_len[i]] += 1;\n    // dp[seg_len[i]] += seg_len[i];\n  }\n  for(int i = 1; i < MAX_SEG_SIZE; i++){\n    dp[i] += dp[i-1];\n  }\n  for(int i = MAX_SEG_SIZE-2; i >= 0; i--){\n    dp2[i] += dp2[i+1];\n  }\n\n  ////////////\n  // for(int i = 0;  i< N; i++){\n  //   cout << dp[i] << \" \";\n  // }\n  // cout << endl;\n  // cout << \"-----\" << endl;\n  // for(int i = 0; i < N; i++){\n  //   cout << dp2[i] << endl;\n  // }\n  // cout << endl;\n  ////////////\n\n  cin >> Q;\n  const int RMAX = 100001;\n  for(int loop = 0; loop < Q; loop++){\n    int loss; cin >> loss;\n    int l = 0, r = RMAX;\n    while(l+1 < r){\n      int med = (l + r) / 2;\n      int v = solve(med);\n      // cout << v << \" \" << med << endl;\n      if(v <= loss){\n        // shorter\n        r = med;\n      }else{\n        // longer\n        l = med;\n      }\n    }\n    if(r == RMAX) cout << -1 << endl;\n    else cout << r << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<vector>\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<assert.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<stack>\n#include<complex>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\t\n#define WHATS(var)cout<<__LINE__<<' '<<#var<<\"=\"<<var<<endl;\n\t\ntemplate<class S, class T> ostream& operator <<(ostream &os, const pair<S, T> v){\n\tos << \"( \" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<T> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<vector<T>> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<set<T>> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const set<T> &v){\n\tint i=0;\n\tfor(auto it:v){\n\t\tif(i > 0){os << ' ';}\n\t\tos << it;\n\t\ti++;\n\t} \n\treturn os;\n}\n\nmap<long long int, int>soinnsuu(long long int a) {\n\tmap<long long int, int>ans;\n\tfor (long long i = 2; i*i <= a; ++i) {\n\t\twhile (a%i == 0) {\n\t\t\tans[i]++;\n\t\t\ta /= i;\n\t\t}\n\t}\n\tif (a != 1)ans[a]++;\n\n\n\treturn ans;\n}\n\t\nint main() {\n\tios::sync_with_stdio(false);\n\tint N,M;cin>>N>>M;\n\tvector<int>ms(M);\n\tfor(int i=0;i<M;++i){\n\t\tcin>>ms[i];\n\t\tms[i]--;\n\t}\n\tms.push_back(N);\n\tsort(ms.begin(),ms.end());\n\tvector<int>ds;\n\tfor(int i=0;i<M;++i){\n\t\tint d=ms[i+1]-ms[i];\n\t\tif(d)ds.push_back(d);\n\t}\n\t//WHATS(ds)\n\tsort(ds.begin(),ds.end());\n\tint answer=N;\n\tvector<int>answers(N+1);\n\tint x=0;\n\tanswers[0]=answer;\n\tfor(int len=1;len<=N;++len){\n\t\tanswer-=(ds.size()-x);\n\t\twhile(x!=ds.size()&&ds[x]==len){\n\t\t\tx++;\n\t\t}\n\t\tanswers[len]=answer;\n\t}\n\t//WHATS(answers);\n\tint Q;cin>>Q;\n\twhile(Q--){\n\t\tint t;cin>>t;\n\t\tauto it=lower_bound(answers.begin(),answers.end(),t,greater<int>());\n\t\t//auto it=lower_bound(answers.begin(),answers.end(),greater<int>(),t);\n\t\tint num=it-answers.begin();\n\t\tif(!num)num++;\n\t\tif(num==N+1)num=-1;\n\t\tcout<<num<<endl;\n\t}\n\treturn 0;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tVEC(int, a, m);\n\tVAR(int, Q);\n\n\ta.emplace_back(n + 1);\n\tstd::sort(ALL(a));\n\n\tV<int> d(m);\n\tREP(i, m) d[i] = a[i + 1] - 1 - a[i];\n\tstd::sort(ALL(d));\n\n\tV<int> ans(100005, INFINT);\n\tint sum = 0;\n\tREP(i, m) sum += d[i];\n\n\tint p = 0;\n\tFOR(i, 1, n + 1) {\n\t\tCHMIN(ans[sum + a[0] - 1], i);\n\t\twhile (p < d.size() && d[p] < i) ++p;\n\t\tsum -= m - p;\n\t}\n\tREP(i, 100003) CHMIN(ans[i + 1], ans[i]);\n\tREP(i, 100005) if (ans[i] == INFINT) ans[i] = -1;\n\n\tREP(_, Q) {\n\t\tVAR(int, l);\n\t\tOUT(ans[l])BR;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define endl '\\n'\nint mod=1e9+7;\nint mod2=998244353;\nconst int INF=1e9;\n\nsigned main(){\n  int N,M;\n  cin>>N>>M;\n  vector<int> m(M);\n  for(int i=0;i<M;i++)cin>>m[i];\n  int Q;\n  cin>>Q;\n\n  vector<int> sou(1e5+1,0);\n  sou[abs(N-m[M-1])]++;\n  for(int i=0;i<M-1;i++){\n    sou[abs(m[i]-m[i+1])-1]++;\n  }\n  vector<int> sourui(1e5+3,0);\n  for(int i=1;i<1e5+3;i++){\n    sourui[i]=sourui[i-1]+sou[i];\n  }\n\n  vector<int> sekirui(1e5+3,0);\n  for(int i=1;i<1e5+3;i++)sekirui[i]=(sou[i]*i)+sekirui[i-1];\n\n  for(int i=0;i<Q;i++){\n    int L;\n    cin>>L;\n    L-=(m[0]-1);\n\n    int l=0;\n    int r=1e5+1;\n    int mid;\n    while(abs(l-r)>1){\n      mid=(l+r)/2;\n      int tmp=sekirui[1e5+2]-sekirui[mid-1];\n      tmp-=(sourui[1e5+2]-sourui[mid-1])*(mid-1);\n      if(tmp<=L)r=mid;\n      else l=mid;\n    }\n    if(r==1e5+1)cout<<-1<<endl;\n    else cout<<r<<endl;\n  }\n}\n\n// `.`..`(WNNNNNNMNWWWH9rttwgHM8OtttwwVtttrrtrttrw0rtrtwrrrtrZUAOOrrrXWppHMHyZHpWHMHMkWWVHMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n// `.`.`..`(WMNMHfWH9ZtrtAdNM8ttttOwVtrrtrrtrrrrrdrrttrZkOrrrrrrXWyrtrrZWWWWMmwXWppWHHMmWHkWMMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n// .`.```_..(HMfWH9OtttwXWHBrttrOw0rttrOvrrrtrZrrRrtrrrtZHwrrrrrwwZHyrrrrZWWpWMmwWppkWHHMkHNkVWMNNNNN#NN#NN#NN#NN#NN#NN#NN#NN#NN#NNNN\n// .``.. ..HNfWW9wtrrOdWHM0trttOdSrtrtwwrtrtrw0twSrtOrrrrZHwtrrrrrXwdWwrrrrXHppWNkXWpkvWH@MkHMHkWMMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n// `.`. -jMWWXXwtrttO0d@BrtrttwXVrtrrwVrrrtrtXrrd0rrXrrrrrZWyrrrrrrZXwWyZOrrvWWpWMkZHbkwrdHMMKMMNHkHMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n// `.`. v8Xdk9ttttrOwXM0tttrtwXwwrtrw0rrtrrtwKrrd0rrXrtrrrrZHkwrrrrrrXkVkrrrvrZHWpHHkWkwrwvVHHNWMMMMkWMNNNNNNN#NN#NN#NN#NN#NN#NN#NNNN\n// .. JHZdbKOrrrtrtwWWOOttrOwSzVrOrw0rrttrrrdRrrdZrrdOrtrtrrZHkXwrrrrrZWXHwwrrrvWWWWNkWkvrrrwWM@RMMMNNmWMNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n// . .JGXHStttttrtwW9OrtrrrdSX0rtrdStrtrtrrwHVrrdkrrtSrrrrrrrdMyXrrrrrvXWXWmwvrrvdHWWNkWyvvvvvT@MNWM#N#MNWMMNNNNNNNNNNNNNNNNNNNNNNNNN\n// (.zqHXZtrttrrOwU0trttrOdWX0OtOdRrrtrrrrrdNrrrdkrrrXOwrrrrrrdNySrrrrrwXXkUmvvwvrZHWfNkUkvwvvvdMMMRM#MMNNNkMMNNNNNN#NN#NN#NN#NN#NNNN\n// (wdS0OttrtOOrwSrtttrrtwKukrrrwKrrrrrtrrwW@rrrXKrrrZkr0OrrrrrWNwkrvvrrvzXkXHwvvrvwWVVHkUyrvvvvZHMMNWMMNNNNNkWMNNNNNNNNNNNNNNNNNNNNN\n// wWtrrttrrOwrwStrttrtrwWZXOrtwX0rrrttrrrXMSrrrXWrrrrXrwvrrrrvZHHXkrrrrvrzWkXNyvrvvvWWWHHWwvvvvvwHNMHRM#NNNNNMmWMMNNNNNNNNNNNNNNNNNN\n// 8OtttrwZwwtwSrrttrrrwdyXwtrrdWrrtrrrrrdWH0rrrXWOrrrwRz0rrvrrrdMHWwvvrrvvXWkWHyrvvvrWWWHkHvvvvvvwWMMMNWMMNNNNNMHWMMNMNNNN#NN#NNNNNN\n// wttrrdVrZrwWwtOrrrrwdWX0rrtdH0rrrtrrtwWHHrrrrXWRrrvrXXXrrvrrrvXHkSwvvrvrrXWkVHyvvvvwHVWHWRvvvvvvdHdMMMKMNNNNNNNMNkWMNNNNNNNNNNNNNM\n// ttrrd0rwrOX0rrtrrtwXHXSrwrwHKrtrtrrtrdWH#rrrrdpkrrrrvHwkwvrrvrZWHXkzzvvvvwUWkpNwvrvvZHfVNHwvvvvvzXHWMNMNMNNNNNNNN#NkWMNNNNNNNNNM3>\n// rrrdSrwwtXSrrtrrrwXWWKwrrrdHXrrrrrrrwWWH#vrrrvWpvrrvrdRXwvrvrvvXHWWwkvvrvvwWWKWHzwvvvXHVWWHvzzzzvzWRHMMMNHMNNNNNNNNMNkMMNNNNNN@<<>\n// OOd9rw0rdKOtrtrrruXHW0rrrdH#rrrrrrrrdpWp#rrrrrXWkvrvvrWwkrvrrvwwWHpKdvvrrvvXHHfWmdwvzwWHVHWkzzzzzzwWXHMHHNWMNNNNNNNNNMNkMNNNN#z>>>\n// OdSOwSwwW0rrrrtrwXNW8rrtrWWSrtrrrrrrXpHWHvrrrrXpHrrrvwZHdyvvvvvvXHpHwkvvvvvrXHHfNwXvzzwWWWKHzzzzzzzWSWHHHMMKMNNNNNNNNNNMNKMNN#>>;>\n// wWwOXrwX8rtrrrrwWWpHrrrrdNNrrrrrrrrwppNWHrvrvrypWwvvrrvXKWvrvrvvZXHHkXzvvvvvwWWWWNdkvvzXHfHWkXzzzzzwWXHHHHNMHMNNNNNNNNNNNNNWMN+>>>\n// R0rd0rdKrrtrtrrdWHWSrrrwWWDrrrrrrrrXpWHqWvrrrvdWbRvvrvvwWZkvvvrvvXHbHzRvvvvvvdHHpHkWwvzXWHWHHzuzzzzzXXWHHHMHMNHMNNNNNNNNNNNMNWh<>>\n// wOwSrwXSrtrtrrwHWWMwrrrdNWSrrrrrrrvppWpHprrvrvddWHwvvrrvXHXwvvvrvzXWHkXzvvvvvzWWKWNdRvzzXWWHHXzzzzzzzudWHbH@HNNWMNNNNNNNNNNNNNkHe>\n// rOXwwwKrrrrrrrXWHHDrrwrdHHXwrrrrrrwpWWbHWvvvrvwHHpHrvvvrXWHWwvvrwwXHkHdkvzvvvvZHHpHKWzzzwWHWHRzzzzuzzzzWHHkHHMMNWMNNNNNNNNNNNNNNKm\n// rdX0OXSrrtrrrdHHWMXrrrwHWHrrrrrrrrXppqWHWkrrvvwWMHHXwwvvvZWKRvvvvrWHWHwWvzvzzzzXWKWNXRzzwXWWNHzzzzzzzzzXUHkHWMMHNWMNNNNNNNNNNNNNNN\n// wSwww#rrrrrrwWWHM#vrrrd#WKvrrrrrvvXppmWMWkvvvvwXNNpNvSXzzvdHkkvvzvdWWWRXwzzzzzzdNNpMkHzzzWVHHpXzzzzzzzzdkHkHHHNMHNkMNNNNNNNNNNNNNN\n// XwSwWwrrrrrrdHWWMKrvrvWHWSrvrvvvvwpppHW#HRwUUUWWMMMMMHHHHmmXHWwvvzwWHbNwRzzzzzzzWWWWHWkzzdXWWWRzzzzzzzuzWWbHHWMNMMNkMNNNNNNNNNNNNN\n// 8drd#rrrrrrwWWkHMmXmywMfWXrvrrrvrwppWNWMNWvrvvwvW#MNHmdkrvvXHMMmmwzdWpM0WzzzzzzzdHHWNUHzzzWWmHHzzuzzuzuzWXbbNkHMqMHNkHNNNNNNNNNNNN\n// dSwWSrrrrrrdHHHMHrrrwWMfWvvvrvrrrdppWNW#WWRvvrvvdM?WNHkXkzvvdWMHXHNmHHHkfwzzzzzzXHHpMWHkzuXWHNWXzzuzzuzzXXkkHbHMHMMMMkMNNNNNNNNNNN\n// Xrd#wrrrrrrXpHWH#rrrvdMWWvrrvrvvrdppWHW#(NWwvvvvwMr~TNHmdkvzvXWMKzzzWMHKXXzzzzzzuWHbHkWKuzdWWHWkzzzuzzuuXXHkHkgHk@H@HHkMNNNNNNNNNN\n// RvWDrrrrrrwHWkMW#rvvrMMfWwrvrrvvrdppWHW@~?HHuvvrvdb_~?NWkdkzzzUWMkzuuWWHWXuzwzzuzXHHHKWHuzzWW@WRuzuzzzzzduWbHHgMH@HHHMMHMNNNNNNNNN\n// rdHwrrrrrrXHHWNW#vvvdMMHWkvrvrrvrdppWbWD~~?XKkrrrwMc~~~THHZHwzzWHNkvzwMRdHHzuzzzzXHHWHXNkuzdWHkWuzzuzuzzXzWkHHHMHHHkH@MMNWMNNNNNNN\n// rdHvrrrrrrWkHHHW#rrrd#dNWKrvrvvrvwbpWWW$...vVkkOrtXb~~~~(WHkWkvwWWMkzzWRXkSWXzzzuwmNWHXHRuuwHMKWzzuzzzuzXzWHWHHMHHHkkMMMHHWNNNNNNN\n// wW#rrvrrrwHWHMpWNrvrd@(NWWvrrrrrvvWpWXH$..._?dkkttOWl~~~~~?HHdHXXbWMkzUHXWkzzzzzzuHNk#XHHzzukHHXzuzzzuzuXuXqkMHMHMbbkHHH@HNWMNNNNN\n// dH#rrrvrrdNWWNpHHwrrd@_WHWkrvvrrrrZpWXWr...__?WkWyOvN~~~~~__7HkWkbbkNkzXHZkzzzuzzzWHW#ugbXuzWWHXXuzzuzuuuzXkkHHH@MbkHMHMHMMNWMNNNN\n// X@KrrvrvrXNHWHpHHHrrdb~(NWHrrrrrrrrXWXWr..`...-7HZkzvn~~~~~~~_TNyHHkHMyzXkXuzzzzuuWHW#uHkkzzWHHXuzzzzuzzuuXHkHHHMNbkHHHHHHMMNWMNNN\n// WHKvvrvrvXHNMbpHmHkOwb..?HWRrwOrtrtrWKWr`.`.`..._?6dkJn~~~~~~-_~7NHMHbNkuUkzzuzzzuWHW#uHbRzuXHHXzzuuuuzuuzXHkHHMMbkkHkMkkkMMMNUMMN\n// WHKrrvrrvXqHMpfHHHWkrb...vkHyOrtttttdNXr.`.J>~-((J+ggQkHXHHHmaJz7&JWHMMWkuHXzuuuzzWgHHwHkKuzXMKXuzuuzuzzuzdkHHHHHkHWMHHbkWHMMMNXM#\n// Wg#rvrvrrXmHNpfHHHMMRd-.._4kfyttttllOHWr`` <udT\"\"\"7\"\"\"\"\"TMHHMNHHMNgv4HMRXHXHwuzzzuWHHKXHkHzzXMSWzuzzuzuuzudbkHHHHkkHqHuWkWHHMMMNWM\n// WHNrvrvvvXHmNppgg@MMMHr..` UkWOlllllldW$..?!     `     ` ?@MMHHMM#NMMmMkXXWkHuzuzuWNHSXHHHuuXNSWuzuuzuzuzuWkHNgMkkkMHSuWkqmqHHMNNK\n// WHMkvvrvrXHHMppHHHMNMTN_``` 4kWOz====vXP` `   `        ``.HggmgM@MH###NKkkuXWHzzuXHHMzdMHHuzWNXKzuuzuzuzuuHkHHNMkkHHBuzWkHHHHuHMMM\n// WHHNzvvrvwHMMppHMMMM>.#L`````?kyy====?0S``  `     ` ``...dmqqqmmHHHMMM#WRSzuzWHuzXHq#uWHHHzuWHXKzuzzuzuzuXHkHWMNkWM#uzuWHHHHSuuWM#\n// WM@MkwvvrzXMMHpgHMMM[.MN.`````(HXy1???zd.``  `  `   ` dHkkqkkqkHHHHHHMMWWXzzuzwWwXHHKXMkHHuXMRXSuuuzuuzuzXHkHdHHWHHXuuwWHqHHuXzXWM\n// XHHMNyrvvwdW@HpHWMHML MM[`  ` `.4kGz<<>Or```  `      `dWpbbbbbHMMbbbHHMXXuzzuzuzXWHHSXMkHHuXMSXuzzuzzuzuzWkkHWMHMSwuzzXHkHHXuzuWd#\n// dHHH@NyzwwwWHMHHWMMMR dW]`` ` ```(HZx<<<4.```` `` ``  OZppfppppWfpWpK9NKXuuzuuzuXWHHudMqNHXWNuHuzzuzuzuzuHkHXMMBuuuzuuWkHHUuuuXSMS\n// wWHMMMMkwwvdNpHHHM#MH-jWP``` `` ```7kI<:<h.``````` `` ,2OWVVyVVyWWWWIdMKWzuuuzzuXHHSwHHHHKXHHXSuuzuuzuzuXHHHXMXuuuuuuXHHHuzuuXSX#X\n// wdWHMMMMmwXwHbpMNHMM@b.hb``````````` 7x1_(>_```````````(x7UUUV0XwvCI1dMWKXuzzuzuWHHudMkgkWbMSXuzzzuzzuzuWkHSW#zXwXuXXWHHuuXXuWXWSX\n// vvXWHMMHWNkvWHbbMWMMMN_JF.```` `` `````?1_(_.`.`........(<777=<<<><<+dMXUuzuuuuWWMRwMHWMkWHHXSuuzuzuzzuXqHHXMHUXuXXHHHSuuwuXWud8uH\n// mzzXWH#zHbHkXNbbWMMMMD~(_``````````````` .~_`.``.`.`.....___(<~(<<(<<dHkkuuuuuXkHHuWMkHkkkHSXXzuuzuuuuzXHHSd#uuXXWHHXuuuZuXSuqHudS\n// UHzzXWSXXWbbHHHbWHMH#<~...```` ``````````````.```.` -_____<~~_<_<~~(jMWSuzuzuXWHMHXMHHHkkH#XSuzzuzuzuzuKkHXMQkWHHWUXuXXUuXUuXHuXBu\n// .(Smd8wSvXbbbbHHHWHW3___.``````` `` ``````.```.```.`...._.._~~..~_~~(#WuzuuzXXkHMqMMHMkkkMUXuXzuuwuuzuXkHSWMWUUuuuXXUUuXHXXWSuXHXu\n// .. JKwSvwzWkkkkHHHH5~~..```````````````````.```.````````.` .........dWSuuzzzdkHMW@MHMkkkHHXXuzuuXSuzuuWWHd#uuuXXkWSuXXWUXXHUXWHuuu\n// .`(HXSzzzzwWbkWHNHr_...``````````````````.```````.```````.`.`..`.-.(HKuzzuuwHHMNMHHMkkkHHuZuuzuuXuuuuXkHWMHHHUUuXXXWHXXHHUuXW8uuuu\n// .-MXWwzzzuzXkHHMHHN-.`````````` ````````````.`.````.``.```.`.`....-dXUXuzuXHWHMMHHBWHMMMSZuzuuzXXzuuXHHMHMHkHHHHHHHWHHSuXkHWSuuuuX\n// (#XKzzzzzuzuWHHkWHHp ``.````````````````````````.````````.....-((-(NSXuzzXHW@D:~`(/1- .kXuzuuzXSuuzXXkHWMHHHHHHHHMWuuuQXUXWuuuXuXH\n// MXWzuzzzzzuXHHbHNMMMt`.```````````````````````````.`.` ..-J7\"!``  XKuzzuXHHM9;/<-.J-u!JXXuuzuXWuuuuXHHH#WMNHmkkkuXXkWUXXWXXuuuXqHH\n// XWzzzzuzzwXHHHH#\"````<.````````````````````.``.`...-c\"7``` ` `  `(BzuuuXmHH8<!(- ?_!`jWUuzuuuWuuuzXWHNH> ..7WHHqHmQkWWXXuuuuuXWqHH\n// SwuzzzXuwXHNHY``  ``  <,`.`````````````` `` ..J7=``` ` ` `` ````.#zuzXXHHH$~`` ```(_(HSuuuzuXSuzuuXHHWCi(` ._ ?WggHHHHWkkkkWHHHHMH\n// zzzuzuzwWHMY!`  `   ` `(&.```````````` ..J7^ `` `  `  `   ` `. .HXuuXWHW#!` ` ```` (WUuzzuXXSzuuudHHXY$. : (..``.THHkqkHHHgHHMHkkk\n// zzzzzzXHWK``  ` `` ` ` ` TJ.``````..J7=````    ` `  ` ` `` ` `.8zuXXHHW=`   ``  ..(XSuuuuuXWuuuuXHWH5~~` .`_?_,-``.TMMMMMMHkkqqHHH\n// zzuuzdHHkN ` ` `  ``  ` ``(Wm,.(J7!```  `  ``` `` `` ` ` ``` .SzuXWHHY `` .._~<~~(dSuuuzzXHuuuuXHWHD::?C._.( -`(!_1 ,WHqHHHmqHHHHN\n// zuzXXHHkHM;`  ` ` ` ``  ` .;jY= ` .``_``  `  `  `  ` `` ` `.dXuXWm@^ .._~_.~~~~~(d0uuzuuXHUuuuXHWH5:::::::_.<&._4r?_.;WMMM@MMY\"<!`\n// zzXHHHHMHMb`` `` ` `` `` .J!  ` ..`_~  ` ` ` `` `   `  ``.JXXXHY! .__.....~.~~~-d0wuzuXXHSuuuXWWH$::::;:::;:+- ~`(.i +HqHHkkHL..`.\n// XWHHHMMHMHM; `  ` `   ` ._`` ...(:.=_` `  ` `  ` ```` .-dVT7^``````......~~~~~_jWuuuuuXHSuzuXHHH3<;:::::;;j<+z ``` -dHNkkMqkkN..``\n// HHHMMHHHHNMN.``  ` `  `!`z(. ~..~ ! . ` ``  ` ` ` ..gHr``````````........~~~~_jWuuuuuXkSuuuXHWHC:;::;;:::+v>:((J<!(WHHMkkHNqkM;`..\n// HMMkkHHHHM9?b ``  ` `  ``     .``. `  ` ` `  ``` 4HkkkH,  ``````.`......~~~~_+KuuuzuXHSuuuXHHK<(::::::<;<J+g9>::;<  .4NkkqMHqH]..`\n// MHkHHHMM$<<:?L` `` ` `  ` ``.` `  !``  ` ` ` `  ` ?HbkkHx``````.`..`...~~~~_jKuuuuuXHSuuuqMHD<:<;:<++ddNMB3:;::;:<` `,HkkqH@HH].``\n// kkHHkHY``` (;?h`` ` ` ``  ````  ` ` ` ` ` ` ` ` ```.4XWbHx```..`......~~~~_gKuuuuXWH0uuuXHH3:;++1z<jgMB3<::::::::~` `jMkqkHMHHF.`.\n// kHHHH=` . ` _<?L  ` `  ` `    `  ` ` ` ` ` ` `  ` `  ?kwWHp .`.......~_~~(dKuuuuXWHUuuXWH9++z1<;+jWB3::::;;;::;:;_`` MNkqkqMNMF..`\n// HHk@!.  ` ` ` ~?L  ` ` `` ` `` `` ` ` ` `  ` ` `   `  -WuXHh..`.....~~~~(dWuuuXXkHUuuXHH9>:<:++YY<:;::::;:::::;:::+.``?HHkHHHM>`.`\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M;\n  cin >> N >> M;\n\n  vector<int> m(M);\n  vector<int> c(100001, 0);  \n  vector<int> A(100001, 0);\n  vector<int> all;  \n  for ( int i = 0; i < M; i++ ) {\n    cin >> m[i];\n    m[i]--;    \n    c[m[i]]++;    \n  }\n\n  int add = 0;\n  {\n    int cnt = 0;\n    bool f = false;    \n    for ( int i = 0; i < N; i++ ) {\n      if ( !f ) {\n\tif ( c[i] ) {\n\t  f = true;\t  \n\t} else {\n\t  add++;\n\t}\n      } else {\n\tif ( c[i] ) {\n\t  A[cnt]++;\n\t  all.push_back(cnt);\t  \n\t  cnt = 0;\t  \n\t} else {\n\t  cnt++;\t  \n\t}\n      }\n    }\n\n    if ( cnt ) all.push_back(cnt);    \n  }\n\n  int sum = 0;  \n  for ( int i : all ) sum += i;\n  sort(all.begin(), all.end());\n  vector<int> B(N, 0);\n  int idx = 0;  \n  for ( int i = 0; i < N; i++ ) {\n    B[i] = sum + add;    \n    while ( idx < all.size() && all[idx]-i <= 0 ) idx++;    \n    sum -= (all.size()-idx);    \n  }\n\n  reverse(B.begin(), B.end());\n\n  // for ( int i : B ) cout << i << endl;\n   \n  int Q;\n  cin >> Q;\n  vector<int> l(Q);  \n  for ( int i = 0; i < Q; i++ ) {\n    cin >> l[i];    \n    int it = upper_bound(B.begin(), B.end(), l[i]) - B.begin();\n    if ( N-it+1 <= 0 || N-it+1 > N ) cout << -1 << endl;    \n    else cout << N-it+1 << endl;          \n  }    \n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\n\nconst int inf =  1 << 21;\nconst int limit = 100010;\nint ary[limit];\nbool reset[limit];\n\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\t\n\trep(i,m){\n\t\tint p;\n\t\tcin >> p;\n\t\treset[p - 1] = true;\n\t}\n\n\tint val = inf;\n\t\n\trep(i, n) {\n\t\tif(reset[i]) val = 1;\n\t\tary[i] = val;\n\t\tval++; \n\t}\n\n\tsort(ary, ary + n);\n\n\tint q;\n\tcin >> q;\n\trep(loop, q){\n\t\tint l;\n\t\tcin >> l;\n\n\t\tint ng = 0, ok = 2 * inf;\n\t\twhile(ok - ng > 1){\n\t\t\tconst int mid = (ok + ng) / 2;\n\t\t\tconst int val = n - (upper_bound(ary, ary + n, mid) - ary);\n\t\t\tif(val <= l) \n\t\t\t\tok = mid;\n\t\t\telse \n\t\t\t\tng = mid;\n\t\t}\n\n\t\tif(n < ok)\n\t\t\tcout << -1 << endl;\n\t\telse \n\t\t\tcout << ok << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\n#define int long long\n\nint N,M;\n\n\nbool sou[101010];\n\nint cnt[202020];\n\nint fff = 0;\n\nint ss[202020];\nint sum[202020];\n\nint func(int x) {\n  int res = ss[101010 - 1] - ss[x - 1] - (sum[101010 -1] - sum[x - 1]) * (x - 1) + fff;\n  return res;\n}\n\n\n\nsigned main() {\n  cin >> N >> M;\n  for(int i = 0;i < M;i++) {\n    int m;\n    cin >> m;\n    m--;\n    sou[m] = true;\n  }\n\n  sou[N] = true;\n\n  int fi = 0;\n  while(!sou[fi]) fi++;\n\n  fff = fi;\n  {\n    int c = 0;\n    for(int i = fi;i <= N;i++) {\n      if(sou[i]) {\n        cnt[c]++;\n        c = 0;\n      }\n      else {\n        c++;\n      }\n    }\n  }\n\n  cnt[0] = 0;\n\n  for(int i = 1;i < 101010;i++) {\n    sum[i] += sum[i - 1] + cnt[i];\n  }\n\n  for(int i = 1;i < 101010;i++) {\n    ss[i] += ss[i - 1] + cnt[i] * i;\n  }\n\n  int Q;\n  cin >> Q;\n  vector<int> ans;\n  for(int qq = 0;qq < Q;qq++) {\n    int l;\n    cin >> l;\n    int ok = 101010;\n    int ng = 0;\n    while(ok - ng > 1) {\n      int mid = (ok + ng) / 2;\n      if(func(mid) <= l) ok = mid;\n      else ng = mid;\n    }\n    ans.push_back(ok);\n  }\n\n  for(auto x : ans) {\n    if(x == 101010) { cout << -1 << endl; }\n    else { cout << x << endl;}\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ld INF = (ld)10000000000000;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\nint n, m;\nint x[1 << 17];\n\nint ans[1 << 17];\n\npriority_queue<int, vector<int>, greater<int>>q;\nvector<P> vr;\n\nint main() {\n\tcin >> n >> m;\n\trep(i, m) {\n\t\tcin >> x[i];\n\t}\n\tans[1] = n - m;\n\trep(i, m - 1) {\n\t\tif (x[i + 1] - x[i]-1 > 0)q.push(x[i + 1] - x[i] - 1);\n\t}\n\t//if (x[0] > 1)q.push(x[0] - 1);\n\tif (n - x[m - 1] > 0)q.push(n - x[m - 1]);\n\tRep1(i, 2, n) {\n\t\tans[i] = ans[i - 1] - q.size();\n\t\twhile (!q.empty() && q.top() < i)q.pop();\n\t\t//cout << i << \" \" << ans[i] << endl;\n\t}\n\trep1(i, n) {\n\t\tvr.push_back({ ans[i],i });\n\t}\n\tsort(vr.begin(), vr.end());\n\tint q; cin >> q;\n\trep(aa, q) {\n\t\tint l; cin >> l;\n\t\tint id = lower_bound(vr.begin(), vr.end(), P{ l+1,-1 }) - vr.begin();\n\t\tif (id == 0)cout << -1 << endl;\n\t\telse {\n\t\t\tid--;\n\t\t\tint out = n - id;\n\t\t\tcout << out << endl;\n\t\t}\n\t}\n\t//stop\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define rep(i, a, b) for (auto (i) = (a); (i) < (b); (i)++)\n#define rrep(i, a, b) for (auto (i) = (a); (i) > (b); (i)--)\n#define UNIQUE(v) (v).erase(unique((v).begin(), (v).end()), (v).end());\n\n#ifdef LOCAL_DEFINE\nstruct InitInput{\n  InitInput() {\n    FILE *stream1;\n    stream1 = freopen(\"/Users/aim_cpo/CLionProjects/competitive/in.txt\", \"r\", stdin);\n    assert(stream1 != nullptr);\n    cerr << \"This problem is not interactive\" << endl;\n  }\n}LOCAL_INPUT;\nstruct LOCAL_OUTPUT{\n  LOCAL_OUTPUT() {\n    FILE *stream2;\n    const char *outputfile = \"out.txt\";\n    stream2 = freopen(outputfile, \"w\", stdout);\n    assert(stream2 != nullptr);\n    cerr << \"output [ \" << outputfile << \" ]\" << endl;\n  }\n}/*LOCAL_OUTPUT*/;\n#define show(x) cerr << #x << \" = \" << (x) << \" (line \" << __LINE__ << \")\" << endl\n#define showV(v, n) do{\\\nfor(int _i_t_e_=0; _i_t_e_<(n);_i_t_e_++)\\\ncerr<<\"(\"<<_i_t_e_<<\" = \"<<(v)[_i_t_e_]<<\") \";\\\ncerr<<endl;}while(0)\n#define showA(a, n) do{\\\nfor(int _i_t_e_=0;_i_t_e_<(n);_i_t_e_++)\\\ncerr<<\"(\"<<_i_t_e_<<\" = \"<<(a)[_i_t_e_]<<\") \";\\\ncerr<<endl;}while(0)\n#define showA2(a, n, m) do{\\\nfor(int _i_t_e_=0;_i_t_e_<(n);_i_t_e_++){\\\nfor(int _i_t_e_2=0;_i_t_e_2<(m);_i_t_e_2++){\\\ncerr<<\"(\"<<_i_t_e_<<\", \"<<_i_t_e_2<<\" = \"<<(a)[_i_t_e_][_i_t_e_2]<<\") \";\\\n}cerr<<endl;}cerr<<endl;}while(0)\n#else\n#define show(x)\n#define showV(v, n)\n#define showA(a, n)\n#define showA2(a, n, m)\n#endif\n\nstruct InitAim{\n  InitAim() {\n    ios::sync_with_stdio(false);cin.tie(nullptr);\n    cout.precision(12);cout<<fixed;\n#ifdef LOCAL_DEFINE\n    cerr << \"This problem is not interactive\" << endl;\n#endif\n  }\n}aim_cpo;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconstexpr const int INT_INF=0x3f3f3f3f; //1061109567\nconstexpr const ll LL_INF=0x3f3f3f3f3f3f3f3f; //4557430888798830399\n\ntemplate <typename T> bool chmin(T &a, T b){return a>b?(a=b,true):false;}\ntemplate <typename T> bool chmax(T &a, T b){return a<b?(a=b,true):false;}\ntemplate <typename T> void ln(T i, T n){cout<<(i==n-1?\"\\n\":\" \");}\ntemplate<typename T, typename S>\nostream &operator<<(ostream &out, const pair<T, S> &pair1) {\n  out << '(' << pair1.fi << \", \" << pair1.se << ')';\n  return out;\n}\ntemplate<typename T>\nostream &operator<<(ostream &out, const vector<T> &vector1) {\n  out << '[';\n  for (unsigned int i = 0; i < vector1.size(); i++) {\n    out << vector1[i];\n    if (i == vector1.size() - 1)out << \"]\"; else out << \", \";\n  }\n  return out;\n}\n\n// INT\n#define GCD(a, b) __gcd(a, b)\ntemplate <typename T> T LCM(T a, T b) {return a / GCD(a, b) * b;}\ntemplate <typename T> T EXTGCD(T a, T b, T& x, T& y) {\n  T d = a;\n  if (b != 0) {d=EXTGCD(b,a%b,y,x);y-=(a/b)*x;}\n  else x=1,y=0;\n  return d;\n}\ntemplate <typename T> bool is_prime(T a) {\n  for(int i=2;i*i<=a;i++)if(a%i==0)return true;\n  return false;\n}\ntemplate <typename T, typename S> T Pow(T a, S b) {\n  T res = 1, now = a;\n  while(b){if(b&1)res*=now;b>>=1;now*=now;}return res;\n}\n\n// MOD\nll MOD = 1000000000L + 7L;\n#define add(a, b) ((a % MOD + MOD) + (b % MOD + MOD)) % MOD\n#define mul(a, b) ((a % MOD + MOD) * (b % MOD + MOD)) % MOD\n#define sub(a, b) ((a % MOD + MOD) + MOD - (b % MOD + MOD)) % MOD\ntemplate <typename T, typename S> T ModPow(T a, S b) {\n  T res = 1, now = a;\n  while(b){if(b&1)res=mul(res,now);b>>=1;now=mul(now,now);}return res;\n}\ntemplate <typename T> T mod_inverse(T a, T mod, bool prime){ // if mod is prime, \"prime\" is true.\n  if(prime)return ModPow(a, mod - 2);\n  else{T x,y;EXTGCD(a,mod,x,y);return (mod+x%mod)%mod;}\n}\n#define divide(a, b) ((a % MOD + MOD) * (mod_inverse(b, MOD, true))) % MOD\n\n//LLの数値をつかう時は最後にLLをつける癖をつけよう\n///////////////////////////////////////////////////////////////////////////////////\n// VARIABLE\n///////////////////////////////////////////////////////////////////////////////////\n\nint n, m, q;\nint start;\nll a[200001];\nll sum[200001];\nvector <int> space;\n\n///////////////////////////////////////////////////////////////////////////////////\n// TEMPLATE(data structure)\n///////////////////////////////////////////////////////////////////////////////////\n\n\n\n///////////////////////////////////////////////////////////////////////////////////\n// MAIN\n///////////////////////////////////////////////////////////////////////////////////\n\nint query(int l) {\n  if (start > l) {\n    return -1;\n  }\n  int ng = 0, ok = n;\n  while (ok - ng > 1) {\n    int mid = (ok + ng) / 2;\n    auto check = [&](int mid) {\n      auto ite = lower_bound(all(space), mid);\n      if (ite == space.end()) {\n        return 0LL;\n      }\n      int idx = (int) (ite - space.begin());\n      ll res = sum[idx];\n      res -= ((int) space.size() - idx) * (ll) (mid - 1);\n      res += start;\n      return res;\n    };\n    if (check(mid) > l) ng = mid;\n    else ok = mid;\n  }\n  return ok;\n}\n\nint main() {\n  cin >> n >> m;\n  start = n;\n  rep(i, 0, m) {\n    cin >> a[i];\n    if (i == 0) {\n      start = a[i] - 1;\n    } else {\n      if (a[i] - 1 != a[i - 1]) space.push_back(a[i] - a[i - 1] - 1);\n    }\n  }\n  if (m > 0 && a[m - 1] != n) space.push_back(n - a[m - 1]);\n  sort(all(space));\n  showV(space, (int) space.size());\n  show(start);\n  if (space.size() > 0) sum[space.size() - 1] = space.back();\n  rrep(i, (int) space.size() - 2, -1) {\n    sum[i] = sum[i + 1] + space[i];\n  }\n  cin >> q;\n  rep(i, 0, q) {\n    int l; cin >> l;\n    cout << query(l) << endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s.\" << endl;\n  show(MOD);\n#endif\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// NOTE\n///////////////////////////////////////////////////////////////////////////////////\n// テキトー考察\n//\n// 連続して何個扇風機がないのかを意識してそこから考えれば、できるはず.\n// \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\nusing ld = long double;\nusing ll = long long;\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename F>\nconstexpr F PI() { return 3.1415926535897932385; }\ntemplate <typename T, std::size_t N>\nstd::ostream& operator<<(std::ostream& os, const std::array<T, N>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::deque<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename K, typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::multimap<K, T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::multiset<T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename K, typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::map<K, T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, const std::pair<T1, T2>& v) { return (os << \"<\" << v.first << \",\" << v.second << \">\"); }\ntemplate <typename T1, typename T2, typename T3>\nstd::ostream& operator<<(std::ostream& os, const std::priority_queue<T1, T2, T3>& v)\n{\n    auto q = v;\n    os << \"[\";\n    while (not q.empty()) { os << q.top() << \",\", q.pop(); }\n    return os << \"]\\n\";\n}\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, const std::queue<T1>& v)\n{\n    auto q = v;\n    os << \"[\";\n    while (not q.empty()) { os << q.front() << \",\", q.pop(); }\n    return os << \"]\\n\";\n}\ntemplate <typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::set<T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, const std::stack<T1>& v)\n{\n    auto q = v;\n    os << \"[\";\n    while (not q.empty()) { os << q.top() << \",\", q.pop(); }\n    return os << \"]\\n\";\n}\ntemplate <typename K, typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_multimap<K, T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_multiset<T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename K, typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_map<K, T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_set<T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\n#define SHOW(...) (std::cerr << \"(\" << #__VA_ARGS__ << \") = (\"), HogeHogeSansuu(__VA_ARGS__), std::cerr << \")\" << std::endl;\nvoid HogeHogeSansuu() { ; }\ntemplate <typename T>\nvoid HogeHogeSansuu(const T x) { std::cerr << x; }\ntemplate <typename T, typename... Args>\nvoid HogeHogeSansuu(const T x, Args... args) { (std::cerr << x << \", \"), HogeHogeSansuu(args...); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T PopCount(T v) { return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f); }\ntemplate <typename T>\nconstexpr T log2p1(T v) { return v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), PopCount(v); }\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return (v << 1) == (T(1) << (log2p1(v))); }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return ispow2(v) ? v : T(1) << log2p1(v); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : ispow2(v) ? v : T(1) << (log2p1(v) - 1); }\ntemplate <typename T>\nconstexpr T INF() { return std::numeric_limits<T>::max() / 4; }\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    int N, M;\n    std::cin >> N >> M;\n    std::vector<int> m(M);\n    for (int i = 0; i < M; i++) { std::cin >> m[i]; }\n    std::vector<int> loss(N + 1);\n    std::vector<int> d(M, N - m.back());\n    for (int i = 0; i < M - 1; i++) { d[i] = m[i + 1] - 1 - m[i]; }\n    std::sort(d.begin(), d.end());\n    auto sum = d;\n    for (int i = 0; i < M - 1; i++) { sum[i + 1] += sum[i]; }\n    auto get = [&](const int i, const int j) { return sum[j - 1] - (i == 0 ? 0 : sum[i - 1]); };\n    for (int l = 1; l <= N; l++) {\n        const int L = std::upper_bound(d.begin(), d.end(), l - 1) - d.begin();\n        if (L != M) {\n            const int SN = M - L;\n            const int sum = get(L, M) - SN * (l - 1);\n            loss[l] = sum + m[0] - 1;\n        } else {\n            loss[l] = m[0] - 1;\n        }\n    }\n    int Q;\n    std::cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int L;\n        std::cin >> L;\n        int inf = 0, sup = N + 1;\n        while (sup - inf > 1) {\n            const int mid = (sup + inf) / 2;\n            (loss[mid] <= L ? sup : inf) = mid;\n        }\n        std::cout << (sup == N + 1 ? -1 : sup) << std::endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  int n,m;\n  cin >> n >> m;\n  vector<LL> v(m+1);\n  v[m]=n+1;\n  for(int i=0;i<m;i++){\n    cin >> v[i];\n  }\n  int h=v[0]-1;\n  vector<LL> d(m),rui(m+1);\n  for(int i=0;i<m;i++){\n    d[i]=v[i+1]-v[i];\n  }\n  sort(all(d));\n  rui[m]=0;\n  for(int i=m-1;i>=0;i--){\n    rui[i]=rui[i+1]+d[i];\n  }\n  // for(int i=0;i<m;i++){\n  //   cout << d[i] << \" \";\n  // }\n  // cout << endl;\n  // for(int i=0;i<m;i++){\n  //   cout << rui[i] << \" \";\n  // }\n  // cout << endl;\n  int q;\n  cin >> q;\n  LL k;\n  for(int t=0;t<q;t++){\n    cin >> k;\n    LL l=0,r=IINF,mid;\n    while(r-l>1){\n      mid=(l+r)/2;\n      int idx=distance(d.begin(),lower_bound(all(d),mid));\n      // cout << mid SP idx SP rui[idx]-mid*(m-idx)+h << endl;\n      if(rui[idx]-mid*(m-idx)+h<=k){\n        r=mid;\n      }else{\n        l=mid;\n      }\n    }\n    if(r==IINF){\n      cout << -1 << endl;\n    }else{\n      cout << r << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n#include <stack>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(ll i = 0; i < n; i++)\n\n\n\n\n\n\nint main() {\n    ll n, m;\n    cin >> n >> m;\n    queue<pair<ll, ll>> que;\n    ll mn;\n    REP(i, m){\n        ll t;\n        cin >> t;\n        que.push({t, 0});\n        if(i == 0) mn = t;\n    }\n    vector<bool> used(n + 1);\n    vector<ll> res(n + 1, n);\n    ll cnt = 0, len = 1;\n    while(!que.empty()){\n        auto tmp = que.front(); que.pop();\n        ll x = tmp.first, loop = tmp.second;\n        if(loop >= len){\n            res[len] = n - cnt;\n            len++;\n        }\n        if(x > n || used[x]) continue;\n        used[x] = true;\n        cnt++;\n        que.push({x + 1, loop + 1});\n    }\n    ll mn2 = n;\n    for(ll i = 1; i <= n; i++){\n        mn2 = min(mn2, res[i]);\n        res[i] = mn2;\n    }\n    ll q;\n    cin >> q;\n    REP(i, q){\n        ll l;\n        cin >> l;\n        if(l < mn - 1){\n            cout << -1 << endl;\n            continue;\n        }\n        ll ng = 0, ok = n;\n        while(ok - ng > 1){\n            ll m = (ok + ng) / 2;\n            if(res[m] <= l){\n                ok = m;\n            }\n            else{\n                ng = m;\n            }\n        }\n        cout << ok << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define DEBUG_MODE\n#define endl '\\n'\n#ifdef DEBUG_MODE\n#define DEBUG(X) debug_func(X, #X)\n#define DEBUG_ENDL endl\n#define DEBUG_SEPARATOR_LINE cout<<\"=================\\n\"\n#else\n#define DEBUG(X) 0\n#define DEBUG_ENDL 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n#define DEBUG_ENDL_S(S) ((S).size() ? \"\\n\" : \"\")\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T, typename U> using P = pair<T, U>;\nusing ll = int64_t;\nusing PLL = P<ll, ll>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename Head, typename... Tail> const Head& var_min(const Head &head, const Tail&... tail) { return min(head, var_min(tail...)); }\ntemplate <typename Head, typename... Tail> const Head& var_max(const Head &head, const Tail&... tail) { return max(head, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\nvoid debug_func_preffix(const string &s) { if(s.size()) cout << s << \" = \"; }\ntemplate <typename T>\nvoid debug_func(const T &t, const string &s = \"\") {\n    debug_func_preffix(s);\n    cout << t << DEBUG_ENDL_S(s);\n}\ntemplate <typename T, typename U>\nvoid debug_func(const P<T, U> &p, const string &s = \"\") {\n    debug_func_preffix(s);\n    cout << \"(\";\n    debug_func(p.first);\n    cout << \", \";\n    debug_func(p.second);\n    cout << \")\" << DEBUG_ENDL_S(s);\n}\ntemplate <typename T>\nvoid debug_func(const V<T> &v, const string &s = \"\") {\n    for(ll i = 0; i < v.size(); i++) {\n        string t = s + \"[\" + to_string(i) + \"]\";\n        debug_func(v[i], t);\n    }\n}\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n    V<ll> mv(M);\n    for(ll &e : mv) cin >> e;\n    ll initl = mv[0] - 1;\n    mv.push_back(N + 1);\n    V<ll> dist;\n    for(ll i = 0; i + 1 < mv.size(); i++) dist.push_back(mv[i + 1] - mv[i] - 1);\n    sort(ALL(dist));\n    DEBUG(dist);\n    V<ll> dsum(M + 1);\n    for(ll i = 0; i + 1 < dsum.size(); i++) dsum[i + 1] = dsum[i] + dist[i];\n    DEBUG(dsum);\n    ll Q;\n    cin >> Q;\n    for(ll QQ = 0; QQ < Q; QQ++) {\n        ll L;\n        cin >> L;\n        ll ok = 1e9, ng = 0;\n        bool suc = 0;\n        while(ok - ng > 1) {\n            ll mid = (ok + ng) / 2;\n            auto ite = lower_bound(ALL(dist), mid);\n            ll idx = distance(dist.begin(), ite);\n            ll cnt = distance(ite, dist.end());\n            ll rdsum = dsum[M] - dsum[idx];\n            ll loss = rdsum - cnt * (mid - 1);\n            DEBUG(mid);\n            DEBUG(idx);\n            DEBUG(cnt);\n            DEBUG(rdsum);\n            DEBUG(loss);\n            loss += initl;\n            if(loss <= L) {\n                ok = mid;\n                suc = true;\n            } else {\n                ng = mid;\n            }\n        }\n        cout << (suc ? ok : -1) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include <map>\n#include <fstream>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <assert.h>\n#include <complex>\nusing namespace std;\n#define LONG_INF 10000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353LL\n#define seg_size 65536*4\n#define REP(i,n) for(long long i = 0;i < n;++i)\nlong long cnt[300000] = {};\nlong long adding[300000] = {};\nint main() {\n#define int long long\n\tint n, m;\n\tcin >> n >> m;\n\tvector<long long> input;\n\tREP(i, m) {\n\t\tlong long tmp;\n\t\tcin >> tmp;\n\t\tinput.push_back(tmp);\n\t}\n\tinput.push_back(n+1);\n\tsort(input.begin(), input.end());\n\tREP(i, input.size()-1) {\n\t\tcnt[input[i + 1] - input[i]-1]++;\n\t}\n\tlong long tools = 0;\n\tfor (int i = 200000; i >= 0; --i) {\n\t\tcnt[i] += cnt[i + 1];\n\t\tadding[i] += adding[i + 1];\n\t\tadding[i] += cnt[i];\n\t}\n\tint query;\n\tcin >> query;\n\tREP(test, query) {\n\t\tlong long geko = 0;\n\t\tcin >> geko;\n\t\tgeko -= input[0] - 1;\n\t\tif (geko < 0) {\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tlong long top = n-1;\n\t\tlong long bot = 1;\n\t\twhile (top - bot > 1) {\n\t\t\tlong long mid = (top + bot) / 2;\n\t\t\tif (adding[mid] > geko) {\n\t\t\t\tbot = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttop = mid;\n\t\t\t}\n\t\t}\n\t\tfor (int i = max(1LL, (long long)bot - 3);; ++i) {\n\t\t\tif (adding[i] <= geko) {\n\t\t\t\tcout << i << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nint N, M;\nint imos[123456];\n\nint main(void)\n{\n\tcin >> N >> M;\n\tvector<int>m;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint tmp; cin >> tmp;\n\t\tm.push_back(tmp - 1);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tauto itr = upper_bound(m.begin(), m.end(), i);\n\t\tif (itr != m.begin()) {\n\t\t\t--itr;\n\t\t\timos[i - *itr + 1]--;\n\t\t}\n\t}\n\timos[0] = N;\n\tfor (int i = 1; i <= N + 100; ++i) {\n\t\timos[i] += imos[i - 1];\n\t}\n\tfor (int i = 0; i <= N + 100; ++i) {\n\t\timos[i] = -imos[i];\n\t}\n\tint Q;\n\tcin >> Q;\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint l;\n\t\tcin >> l;\n\t\tauto itr = lower_bound(imos, imos + N + 100, -l);\n\t\tint ans = itr - imos;\n\t\tif (ans > N) {\n\t\t\tans = -1;\n\t\t}\n\t\tif (ans == 0)ans = 1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    vector<ll> a(m);\n    for(auto &I:a){cin>>I; I--;}\n    ll l=0;\n    vector<ll> L(n,0);\n    for(int i=1;i<=n;i++){\n        while(l<m && a[l]<i){l++;}\n        if(l==0){L[i-1]=E;}\n        else{L[i-1]=i-a[l-1];}\n    }\n    sort(L.begin(),L.end(),greater<ll>());\n    ll q;\n    cin>>q;\n    while(q--){\n        ll l;\n        cin>>l;\n        if(l>=n){cout<<1<<endl;}\n        else if(L[l]==E){cout<<-1<<endl;}\n        else{cout<<L[l]<<endl;}\n    }\n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}}star;\n#define DEBUG if(0)\n#endif\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\nclass reverse_range {private:struct I {int x;int operator*() {return x-1;}bool operator!=(I& lhs) {return x>lhs.x;}void operator++() {--x;}};I i, n;public:reverse_range(int n) :i({ 0 }), n({ n }){}reverse_range(int i, int n) :i({ i }), n({ n }){}I& begin() {return n;}I& end() {return i;}};\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }reverse_range operator!(){return reverse_range(*i,*n);}};\nint N,M,Q;\nint m[112345];\nint l[112345];\n\nint need[112345];\nint pos[112345];\n\nint main(){\n    int N,M;\n    cin>>N>>M;\n    for(int i:range(M)){\n        cin>>m[i];\n        m[i]--;\n    }\n    cin>>Q;\n    for(int i:range(Q)){\n        cin>>l[i];\n    }\n    for(int i:range(N)){\n        pos[i]=-1e7;\n    }\n\n    for(int i:range(M)){\n        pos[m[i]]=m[i];\n    }\n    need[0]=0-pos[0]+1;\n    for(int i:range(1,N)){\n        pos[i]=max(pos[i],pos[i-1]);\n        need[i]=i-pos[i]+1;\n    }\n\n    sort(need,need+N);\n/*\n    for(int i:range(N))cerr<<pos[i]<<\",\";\n    cerr << endl;\n\n    for(int i:range(N))cerr<<need[i]<<\",\";\n    cerr << endl;\n*/\n\n    for(int i:range(Q)){\n        const int query = l[i];\n        int ok=1e6;\n        int ng=0;\n        if(query<m[0]){\n            ok=-1;\n        }\n        else{\n            while(abs(ok-ng)>1){\n                const int mid = (ok+ng)/2;\n                int sonsitu = need+N-upper_bound(need,need+N,mid);\n                if(sonsitu<=query){\n                    ok=mid;\n                }\n                else{\n                    ng=mid;\n                }\n            }\n        }\n        assert(ok<=112345);\n        cout<<ok<<endl;\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M;\nint m[100050];\nint length[100050];\nint main() {\n    cin >> N >> M;\n    for(int i = 1; i <= M; i++) {\n        cin >> m[i];\n    }\n    m[M + 1] = N + 1;\n    //length[1] = m[1] - 1;\n    for(int i = 2; i <= M + 1; i++) {\n        int delta = m[i] - m[i - 1];\n        length[delta-1]++;\n        //cout << delta << endl;\n        //length[1] += 1;\n        //length[delta+1] -= delta;\n        //length[delta+2] += delta;\n    }\n    for(int i = 1; i <= N; i++) {\n        //cout << i << \" \" << length[i] << endl;\n    }\n    for(int i = N-1; i >= 1; i--) {\n        length[i] += length[i+1];\n    }\n    for(int i = 1; i <= N; i++) {\n        //cout << i << \" \" << length[i] << endl;\n    }\n    for(int i = N-1; i >= 1; i--) {\n        length[i] += length[i+1];\n    }\n    for(int i = 1; i <= N; i++) {\n        //cout << i << \" \" << length[i] << endl;\n    }\n    for(int i = 1; i <= N; i++) {\n        length[i] += m[1] - 1;\n        //cout << i << \" \" << length[i] << endl;\n    }\n    int Q;\n    cin >> Q;\n    while(Q--) {\n        int l;\n        cin >> l;\n        if(length[N] > l) {\n            cout << -1 << endl;\n            continue;\n        }\n        int ok = N;\n        int ng = 0;\n        while(ok - ng > 1) {\n            int mid = (ok + ng) / 2;\n            if(length[mid] <= l) ok = mid;\n            else ng = mid;\n        }\n        cout << ok << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// template version 1.14\nusing namespace std;\n#include <bits/stdc++.h>\n\n// varibable settings\n#define int long long\nconst int INF=1e18;\nconst int MOD=1e9+7;\n\n// define basic macro {{{\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define _rrep(i,n) rrepi(i,0,n)\n#define rrepi(i,a,b) for(int i=(int)((b)-1);i>=(int)(a);--i)\n#define rrep(...) _overload3(__VA_ARGS__,rrepi,_rrep,)(__VA_ARGS__)\n#define each(i,a) for (auto&& i : a)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define pb(a) push_back(a)\n#define mp(a, b) make_pair(a, b)\n#define mt(a, b, c) make_tuple(a, b, c)\n#define ceil(a,b) ((a)+(b)-1)/(b)\n#define is_in(x, a, b) ((a)<=(x) && (x)<(b))\n#define uni(x) sort(all(x));x.erase(unique(all(x)),x.end())\n#define ub upper_bound\n#define lb lower_bound\n#define posl(A, x) (lower_bound(all(A), x)-A.begin())\n#define posu(A, x) (upper_bound(all(A),x)-A.begin())\ntemplate<class T> inline void chmax(T &a, const T &b) { if((a) < (b)) (a) = (b); }\ntemplate<class T> inline void chmin(T &a, const T &b) { if((a) > (b)) (a) = (b); }\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef tuple<int,int,int> iii;\n\ntemplate<typename T> using PQ = priority_queue<T, vector<T>, greater<T>>;\nstruct Fast { Fast(){ std::cin.tie(0); ios::sync_with_stdio(false); } } fast;\n\n#if defined(PCM) || defined(LOCAL)\n  #include \"lib/dump.hpp\"\n#else\n  #define dump(...) 42\n  #define dump_1d(...) 42\n  #define dump_2d(...) 42\n#endif\n//}}}\n\nint n,m;\nvector<int> x;\n\nsigned main() {\n  cin>>n>>m;\n\n  x.resize(m);\n  vi d;\n  rep(i, m) { cin>>x[i]; }\n  x.pb(n+1);\n  rep(i, 1, m+1){\n    d.pb(x[i]-x[i-1]);\n  }\n  sort(all(d));\n  dump(d);\n\n  vi dp(n+1);\n  dp[1] = n-m;\n  rep(y, 2, n+1){\n    int x = posl(d, y);\n    int v = (sz(d)) - x;\n    dump(y, x);\n    dp[y] = dp[y-1]-v;\n  }\n  dump(dp);\n\n  vi ans(100001, -1);\n  rrep(i, 1, n+1){\n    ans[dp[i]] = i;\n  }\n  rep(i, 1, 100001){\n    if (ans[i]==-1) ans[i]=ans[i-1];\n  }\n\n  int Q;cin>>Q;\n  rep(i, Q) {\n    int s;cin>>s;\n    cout << ans[s] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long n, m, q;\nlong long s[100005] = {0};\nlong long l[100005] = {0};\nlong long ans[100005] = {0};\nlong long cnt[100005] = {0};\nvector<long long> dis;\n\nvoid solve();\n\nint main() {\n  cin >> n >> m;\n  for(long long i = 0; i < m; ++i) cin >> s[i];\n  cin >> q;\n  for(long long i = 0; i < q; ++i) cin >> l[i];\n  solve();\n  for(long long i = 0; i < q; ++i) {\n    int nowans =\n        lower_bound(ans + 1, ans + n + 1, l[i] - s[0] + 1,\n                    greater<long long>()) -\n        ans;\n    if(ans[nowans] + s[0] - 1 > l[i]) nowans = -1;\n    cout << nowans << endl;\n  }\n  return 0;\n}\n\nvoid solve() {\n  for(int i = 1; i < m; ++i) {\n    dis.push_back(s[i] - s[i - 1] - 1);\n    ans[1] += dis[i - 1];\n  }\n  dis.push_back(n - s[m - 1]);\n  ans[1] += n - s[m - 1];\n  sort(dis.begin(), dis.end());\n  for(int i = 1; i <= n; ++i) {\n    auto it = lower_bound(dis.begin(), dis.end(), i - 1);\n    cnt[i] = dis.end() - it;\n  }\n  for(int i = 2; i <= n; ++i) ans[i] = ans[i - 1] - cnt[i];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define trace1(x)                cout<<#x<<\": \"<<x<<endl\n#define trace2(x, y)             cout<<#x<<\": \"<<x<<\" | \"<<#y<<\": \"<<y<<endl\n#define trace3(x, y, z)          cout<<#x<<\":\" <<x<<\" | \"<<#y<<\": \"<<y<<\" | \"<<#z<<\": \"<<z<<endl\n#define trace4(a, b, c, d)       cout<<#a<<\": \"<<a<<\" | \"<<#b<<\": \"<<b<<\" | \"<<#c<<\": \"<<c<<\" | \"<<#d<<\": \"<<d<<endl\n#define trace5(a, b, c, d, e)    cout<<#a<<\": \"<<a<<\" | \"<<#b<<\": \"<<b<<\" | \"<<#c<<\": \"<<c<<\" | \"<<#d<<\": \"<<d<<\" | \"<<#e<< \": \"<<e<<endl\n#define trace6(a, b, c, d, e, f) cout<<#a<<\": \"<<a<<\" | \"<<#b<<\": \"<<b<<\" | \"<<#c<<\": \"<<c<<\" | \"<<#d<<\": \"<<d<<\" | \"<<#e<< \": \"<<e<<\" | \"<<#f<<\": \"<<f<<endl\n#define trace7(a, b, c, d, e, f , g) cout<<#a<<\": \"<<a<<\" | \"<<#b<<\": \"<<b<<\" | \"<<#c<<\": \"<<c<<\" | \"<<#d<<\": \"<<d<<\" | \"<<#e<< \": \"<<e<<\" | \"<<#f<<\": \"<< f << \" | \"<< #g <<\": \"<<g<<endl\n#define trace8(a, b, c, d, e, f , g , h) cout<<#a<<\": \"<<a<<\" | \"<<#b<<\": \"<<b<<\" | \"<<#c<<\": \"<<c<<\" | \"<<#d<<\": \"<<d<<\" | \"<<#e<< \": \"<<e<<\" | \"<<#f<<\": \"<< f << \" | \" << #g <<\": \"<< g <<\" | \"<<#h<< \": \" << h << endl\n#define rep(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rrep(i,a,b) for(int i=(int)(a);i>=(int)(b);--i)\n#define fore(x,a) for(auto &x:a)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define isin(i,a,b) ((a) <= (i) && (i) <= (b))\n#define uni(a) (a).erase(unique(all(a)),(a).end())\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define sz(a) ((long long)(a).size())\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\nusing ll  = long long;          using vi  = vector<int>;\nusing unit= unsigned;           using vl  = vector<ll>;\nusing ull = unsigned long long; using vvi = vector<vi>;\nusing P   = pair<int,int>;      using vvl = vector<vl>;\n                                using vp  = vector<P>;\nvoid _main(); int main(){ cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntemplate<class T>string join(const v(T)&v){ stringstream s; rep(i,0,sz(v))s<<' '<<v[i]; return s.str().substr(1); }\ntemplate<class T>istream &operator>>(istream&i, v(T)&v){ fore(x,v){ i >> v; } return i; }\ntemplate<class T>ostream &operator<<(ostream&o, const v(T)&v){ o<<\"[\"; fore(x,v)o<<x<<\",\"; o<<\"]\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const deque<T>&v){ o<<\"deq[\"; fore(x,v)o<<x<<\",\"; o<<\"]\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const set<T>&v){ o<<\"{\"; fore(x,v)o<<x<<\",\"; o<<\"}\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const unordered_set<T>&v){ o<<\"{\"; fore(x,v)o<<x<<\",\"; o<<\"}\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const multiset<T>&v){ o<<\"{\"; fore(x,v)o<<x<<\",\"; o<<\"}\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const unordered_multiset<T>&v){ o<<\"{\"; fore(x,v)o<<x<<\",\"; o<<\"}\"; return o; }\ntemplate<class T1,class T2>ostream &operator<<(ostream &o, const pair<T1,T2>&p){ o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\"; return o; }\ntemplate<class TK,class TV>ostream &operator<<(ostream &o, const map<TK,TV>&m){ o<<\"{\"; fore(x,m)o<<x.fi<<\"=>\"<<x.se<<\",\"; o<<\"}\"; return o; }\ntemplate<class TK,class TV>ostream &operator<<(ostream &o, const unordered_map<TK,TV>&m){ o<<\"{\"; fore(x,m)o<<x.fi<<\"=>\"<<x.se<<\",\"; o<<\"}\"; return o; }\ntemplate<class T>void YES(T c){ if(c) cout<<\"YES\"<<endl; else cout<<\"NO\"<<endl; }\ntemplate<class T>void Yes(T c){ if(c) cout<<\"Yes\"<< endl; else cout<<\"No\"<<endl; }\ntemplate<class T>void POSS(T c){ if(c) cout<<\"POSSIBLE\"<<endl; else cout<<\"IMPOSSIBLE\"<<endl; }\ntemplate<class T>void Poss(T c){ if(c) cout<<\"Possible\"<<endl; else cout<<\"Impossible\"<<endl; }\ntemplate<class T>void chmax(T &a, const T &b){ if(a<b) a=b; }\ntemplate<class T>void chmin(T &a, const T &b){ if(b<a) a=b; }\ntemplate<class T>T gcd(T a, T b){ return (b==0) ? a : gcd(b,a%b); }\ntemplate<class T>T lcm(T a, T b){ return a * (b / gcd(a,b)); }\nconst double  EPS = 1e-10;\nconst double  PI  = acos(-1.0);\nconst int     INF = 1001002003;\nconst ll      LINF= 1001002003004005006LL;\nconst int dx[] = { -1, 0, 1, 0 , -1,-1, 1, 1 };\nconst int dy[] = {  0, 1, 0,-1 , -1, 1,-1, 1 };\n\nvoid _main() {\n  int N, M;   cin >> N >> M;\n  vi m(M);\n  vi exists(N+1);\n  rep(i, 0, M) {\n    cin >> m[i];\n    --m[i];\n    ++exists[m[i]];\n  }\n\n  const int M1 = find(all(exists), 1) - exists.begin();\n  vi d;\n  {\n    d.pb(0);\n    int cnt = 0;\n    rep(i, M1+1, N) {\n      if (exists[i]) {\n        d.pb(cnt);\n        cnt = 0;\n      } else {\n        ++cnt;\n      }\n    }\n    if (cnt) d.pb(cnt);\n    sort(all(d));\n  }\n\n  vi B(N);\n  {\n    int sum = accumulate(all(d), 0);\n    int di = 0;\n    rep(i, 0, N) {\n      // trace3(i, di, sum);\n      B[i] = sum + M1;\n      while (di < sz(d) && d[di]-i <= 0) ++di;\n      sum -= (sz(d)-di);\n    }\n    reverse(all(B));\n  }\n  // cout << endl;\n  // trace2(N, M);\n  // trace1(m);\n  // trace1(exists);\n  // trace1(d);\n  // trace1(B);\n\n  int Q;    cin >> Q;\n  vi l(Q);  fore(x, l) cin >> x;\n  vi ans(Q);\n  rep(i, 0, Q) {\n    int tmp = N + 1 - (upper_bound(all(B), l[i]) - B.begin());\n    ans[i] = (0 < tmp &&  tmp <= N) ? tmp : -1;\n  }\n  fore(x, ans) cout << x << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long n, m, q;\nlong long s[100005] = {0};\nlong long l[100005] = {0};\nlong long ans[100005] = {0};\nlong long cnt[100005] = {0};\nvector<long long> dis;\n\nvoid solve();\n\nint main() {\n  cin >> n >> m;\n  for(long long i = 0; i < m; ++i) cin >> s[i];\n  cin >> q;\n  for(long long i = 0; i < q; ++i) cin >> l[i];\n  solve();\n  for(long long i = 0; i < q; ++i) {\n    int nowans =\n        lower_bound(ans + 1, ans + n + 1, l[i] - s[0] + 1,\n                    greater<long long>()) -\n        ans;\n    if(ans[nowans] + s[0] - 1 > l[i]) nowans = -1;\n    cout << nowans << endl;\n  }\n  return 0;\n}\n\nvoid solve() {\n  for(int i = 1; i < m; ++i) {\n    dis.push_back(s[i] - s[i - 1] - 1);\n    ans[1] += dis[i - 1];\n  }\n  dis.push_back(n - s[m - 1]);\n  ans[1] += n - s[m - 1];\n  sort(dis.begin(), dis.end());\n  for(int i = 1; i <= n; ++i) {\n    auto it = lower_bound(dis.begin(), dis.end(), i - 1);\n    cnt[i] = dis.end() - it;\n  }\n  for(int i = 2; i <= n; ++i) ans[i] = ans[i - 1] - cnt[i];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n \n#define int long long\n \nint N,M;\n \n \nbool sou[101010];\n \nint cnt[202020];\n \nint fff = 0;\n \nint ss[202020];\nint sum[202020];\n \nint func(int x) {\n  int res = ss[101010 - 1] - ss[x - 1] - (sum[101010 -1] - sum[x - 1]) * (x - 1) + fff;\n  return res;\n}\n \n \n \nsigned main() {\n  cin >> N >> M;\n  for(int i = 0;i < M;i++) {\n    int m;\n    cin >> m;\n    m--;\n    sou[m] = true;\n  }\n \n  sou[N] = true;\n \n  int fi = 0;\n  while(!sou[fi]) fi++;\n \n  fff = fi;\n  {\n    int c = 0;\n    for(int i = fi;i <= N;i++) {\n      if(sou[i]) {\n        cnt[c]++;\n        c = 0;\n      }\n      else {\n        c++;\n      }\n    }\n  }\n \n  cnt[0] = 0;\n \n  for(int i = 1;i < 101010;i++) {\n    sum[i] += sum[i - 1] + cnt[i];\n  }\n \n  for(int i = 1;i < 101010;i++) {\n    ss[i] += ss[i - 1] + cnt[i] * i;\n  }\n \n  int Q;\n  cin >> Q;\n  vector<int> ans;\n  for(int qq = 0;qq < Q;qq++) {\n    int l;\n    cin >> l;\n    int ok = 101010;\n    int ng = 0;\n    while(ok - ng > 1) {\n      int mid = (ok + ng) / 2;\n      if(func(mid) <= l) ok = mid;\n      else ng = mid;\n    }\n    ans.push_back(ok);\n  }\n \n  for(auto x : ans) {\n    if(x == 101010) { cout << -1 << endl; }\n    else { cout << x << endl;}\n  }\n \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n    int N, M, m[100001];\n    cin >> N >> M;\n    for(int i=0; i<M; i++) cin >> m[i];\n    m[M] = N+1;\n\n    vector<int> intervals;\n    for(int i=0; i<M; i++) intervals.push_back(m[i+1] - m[i] - 1);\n    sort(intervals.begin(), intervals.end());\n\n    int loss[100001];\n    int now = m[0] - 1;\n    int num = 0;\n    for(int l=N; l>0; l--){\n        while(intervals.size() > 0 && intervals.back() >= l){\n            intervals.pop_back();\n            num++;\n        }\n        now += num;\n        loss[l] = -now;\n    }\n    int Q;\n    cin >> Q;\n    while(Q--){\n        int l;\n        cin >> l;\n        int ans = lower_bound(loss, loss+N+1, -l) - loss;\n        if(ans == 0) ans = 1;\n        if(ans == N+1) ans = -1;\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll mp[111111];\nll ans[111111];\n\nint main(){\n\n\tll n, m;cin >> n >> m;\n\tvector<ll> v(m+1);\n\tv[m] = n+1;\n\tREP(i,m)cin >> v[i];\n\n\tvector<ll> seica;\n\tREP(i, v.size() - 1){\n\t\tif(i == 0){\n\t\t\tREP(j,111111)mp[j] += v[i] - 1;\n\t\t}\n\t\tint now = v[i+1] - v[i];\n\t\tfor(int j = 1;j <= now;j++){\n\t\t\tmp[j] += now - j;\n\t\t}\n\t}\n\n\t//SHOW1d(mp, 20);\n\n\tint q;cin >> q;\n\tvector<P> que(q);\n\tREP(i, q){\n\t\tcin >> que[i].FI;\n\t\tque[i].SE = i;\n\t}\n\n\tsort(ALL(que), greater<P>());\n\n\tint nagasa = 1;\n\tREP(i,que.size()){\n\t\tint id = que[i].SE;\n\t\tint d = que[i].FI;\n\t\twhile(nagasa < 111111 && mp[nagasa] > d)nagasa++;\n\t\tif(nagasa != 111111)ans[id] = nagasa;\n\t\telse ans[id] = -1;\n\t}\n\n\tREP(i,q){\n\t\tcout << ans[i] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(long long i=(long long)(m) ; i < (long long) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\n\nconst long long inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nsigned main(){\n\tlong long n;\n\tcin>>n;\n\tlong long m;\n\tcin>>m;\n\tlong long a[m];\n\trep(i,m)cin>>a[i];\n\tlong long sum[m+1];\n\tsum[m]=0;\n\trep(i,m-1)sum[i]=a[i+1]-a[i]-1;\n\tsum[m-1]=n-a[m-1];\n\tsort(sum,sum+m);\n\tlong long b[m];\n\trep(i,m)b[i]=sum[i];\n\trep(i,m-1)sum[m-i-2]+=sum[m-i-1];\n\tlong long ans[n+1];\n\tans[0]=longinf;\n\tREP(i,1,n+1){\n\t\tlong long idx=lower_bound(b,b+m,i)-b;\n\t\tans[i]=sum[idx]-(m-idx)*(i-1);\n\t}\n\trep(i,n+1)ans[i]=-ans[i];\n\tlong long q;\n\tcin>>q;\n\twhile(q--){\n\t\tlong long x;\n\t\tcin>>x;\n\t\tx-=a[0]-1;\n\t\tif(x<0){\n\t\t\tcout<<-1<<endl;\n\t\t}\n\t\telse {\n\t\t\tlong long ret=lower_bound(ans,ans+n+1,-x)-ans;\n\t\t\tcout<<ret<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n#include \"bits/stdc++.h\"\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b-1,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB emplace_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int long long\n#define zero 0LL\n#define pb PB\nusing namespace std;\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ppr, Vppr ,greater<ppr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nint dx[] = { 0,1,0,-1,1,1,-1,-1,0 }, dy[] = { 1,0,-1,0,1,-1,1,-1,0 };\nconst int SIZE1 =3e5 + 1000;\nconst int SIZE2 = 2010;\nconst int SIZE3 = 22;\nconst int SIZE = SIZE1;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\nut N, M, K, X, L, Y,H,W,Q,D;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\nLL A[SIZE], B[SIZE];\nbool nable[SIZE2][SIZE2];\nLL cost[SIZE2][SIZE2];\n\nLL solve() {\n\tcin >> N >> M ;\n\tREP(i, M) {\n\t\tLL x;\n\t\tcin >> x;\n\t\tA[x] = 1;\n\t}\n\tLL now = INF;\n\tEFOR(i, 1, N) {\n\n\t\tif (A[i] == 1) {\n\t\t\tnow = 0;\n\t\t}\n\t\telse {\n\t\t\tnow++;\n\t\t}\n\t\tif (now < INF) {\n\t\t\tB[now] += 1;\n\n\t\t}\n\t}\n\tVI sum(N+1);\n\tsum[0] = B[0];\n\tLL maxim = 0;\n\tEFOR(i, 1, N) {\n\t\tsum[i] = B[i] + sum[i-1];\n\t\tMX(maxim, sum[i]);\n\t\t//\tcout << i << \" \" << sum[i] << endl;\n\t}\n\tcin >> Q;\n\tREP(i, Q) {\n\t\tLL x;\n\t\tcin >> x;\n\t\tif (maxim < N - x) {\n\t\t\tcout << -1 << endl;\n\t\t}else\n\t\t\tcout << distance(sum.begin(),lower_bound(ALL(sum),N-x))+1 << endl;\n\t}\n\treturn 0;\n}\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(10);\n\tsolve();\n\t//\tcin >> N;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\nint accumFailTime[100001];\nint ac_k[100001];\nint ac[100001];\nint failTime[100001];\nint firstZeroLen = -1;\nint main() {\n    int N, M;\n    int m[100001];\n    int Q;\n    int l[100001];\n    cin >> N >> M;\n    for (int i=0; i<M; i++) cin >> m[i];\n    cin >> Q;\n    for (int i=0; i<Q; i++) cin >> l[i];\n\n    int m_head = 0;\n    int zero_len = 0;\n    for (int i=1; i<=N; i++) {\n        if (m_head < M && m[m_head] == i) {\n            if (zero_len > 0) {\n                accumFailTime[zero_len]++;\n            }\n            if (firstZeroLen == -1) firstZeroLen = zero_len;\n            zero_len = 0;\n            m_head++;\n        }\n        else {\n            zero_len++;\n        }\n    }\n    if (zero_len > 0) {\n        accumFailTime[zero_len]++;\n    }\n    if (firstZeroLen == -1) firstZeroLen = zero_len;\n\n    int ak = 0;\n    int a = 0;\n    for (int i=N; i>=1; i--) {\n        ak += i * accumFailTime[i];\n        a += accumFailTime[i];\n        ac_k[i] = ak;\n        ac[i] = a;\n    }\n    for (int i=1; i<=N; i++) {\n        failTime[i] = ac_k[i] - ac[i] * (i-1);\n        if (firstZeroLen > 0) {\n            if (i == 2) failTime[2] += 1;\n            if (i > 2 && firstZeroLen >= i) failTime[i] += i-1;\n            if (i > 2 && firstZeroLen < i) failTime[i] += firstZeroLen;\n        } \n        failTime[i] *= -1;\n\n        //cerr << \"failtime:\" << i << \":\" << failTime[i] << endl;\n    }\n    //cerr << endl;\n\n    for (int i=0; i<Q; i++) {\n        int* index = lower_bound(failTime+1, failTime+N+1, -l[i]);\n        int answer = index - failTime;\n        if (answer > N) answer = -1;\n        cout << answer << endl;\n    }   \n        \n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ALL(x) (x).begin(), (x).end()\n#define AND(x,y,z) \n#define DUMP(xs) for (auto x:xs) cout<<x<<' ';cout<<endl\n#define DUMPP(xs) for (auto x:xs) cout<<'('<<x.first<<','<<x.second<<')';cout<<endl\n#define FOR(i,a,b) for (ll i=(ll)(a);i<(ll)(b);++i)\n#define OUT(x) cout<<x<<endl\n#define REP(i,n) FOR(i,0,n)\n#define YES(cond) cond ? OUT(\"YES\") : OUT(\"NO\")\n#define Yes(cond) cond ? OUT(\"Yes\") : OUT(\"No\")\n\ntemplate<class T> T gcd(const T x,const T y){if(!y){return x;}return gcd(y,x%y);}\ntemplate<class T> T lcm(const T x,const T y){return x/gcd(x,y)*y;};\ntemplate<class T> T modpow(const T x,const T n,const T mod) {\n  T res=1;while(n>0){if(n%2)res=res*x%mod;x=x*x%mod;n/=2;};return res;\n}\ntemplate<class T> bool alltrue(const T &a){return all_of(ALL(a),[](bool x){return x;});}\ntemplate<class T> bool anytrue(const T &a){return any_of(ALL(a),[](bool x){return x;});}\ntemplate<class T> bool contain(const T &a,const T &b){for(auto x:b){if (a.find(x)==a.end()){return false;}}return true;}\ntemplate<class T> bool mmax(T &m,const T q){ if (m < q) {m = q; return true;} else return false; }\ntemplate<class T> bool mmin(T &m,const T q){ if (m > q) {m = q; return true;} else return false; }\ntemplate<class T> int siz(const T &a) {return (int)a.size();}\ntemplate<class T> set<T> devisers(T n) {\n  set<T> res;for(T i=1;i<(T)sqrt(n)+1;i++){if(n%i==0){res.insert(i);res.insert(n/i);}}return res;\n}\ntemplate<class T> void concat(T &a, const T &b){a.insert(a.end(),b.begin(),b.end());}\ntemplate<class T> void getand(const T &a,const T &b,T &c) {\n  set_intersection(a.begin(),a.end(),b.begin(),b.end(),inserter(c,c.end()));\n}\ntemplate<class T> void getor(const T &a,const T &b,T &c) {\n  set_union(a.begin(),a.end(),b.begin(),b.end(),inserter(c,c.end()));\n}\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst ll MOD=1e9+7;\nconst int MAX=1e5+100;\n\nint main() {\n  // 最短の矢の長さ（or-1）\n  // 矢の長さをxとすると\n  // l>=N-(x*M)を満たす最低のxが答え\n  // N*l/M<=x\n  // しかし当然ながら扇風機の範囲がかぶるところが存在する\n  // xを順に伸ばして言ってDPに損失を保存していく\n  int N,M;cin>>N>>M;\n  vector<int> ms(M);\n  REP(i,M) cin>>ms[i];\n\n  // 損失にならない場はtrue\n  bitset<100000> bs;\n  REP(i,M) bs.set(N-1-(ms[i]-1));\n\n  // 長さがiの時の損失の数をdp[i-1]とする\n  vector<ll> dp(N,0);\n  dp[0] = N-M;\n\n  // 余計なzeroの数\n  int red = 100000 - N;\n\n  FOR(n,1,N) {\n    bs |= bs>>1;\n    dp[n] = 100000 - bs.count()-red;\n  }\n  // DUMP(dp);\n\n  int Q;cin>>Q;\n\n  // 逆順にして、l+1のlower_bound-begin-1=idxとしたとき、N-idxが答え\n  reverse(ALL(dp));\n\n  REP(i,Q) {\n    int l;cin>>l;\n    if (dp[0]>l) {\n      OUT(-1);\n    } else {\n      ll idx = lower_bound(ALL(dp),l+1)-dp.begin()-1;\n      OUT(N-idx);\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nconst int INF=1e9,MOD=1e9+7;\nconst ll LINF=1e18;\nusing namespace std;\n#define int long long\n\nsigned main(){\n  int N,M;cin>>N>>M;\n  std::vector<int> v(M);\n  for(int i=0;i<M;i++)cin>>v[i];\n  map<int,int> m;\n  for(int i=1;i<M;i++)m[v[i]-v[i-1]]++;\n  m[N-v[M-1]+1]++;\n  map<int,int> memo;\n  int Q;cin>>Q;\n  std::vector<int> iiii(Q);\n  for(int i=0;i<Q;i++)cin>>iiii[i];\n  for(int i=0;i<Q;i++){\n    int L=iiii[i];\n    L-=v[0]-1;\n    if(L<0){cout<<-1<<endl;continue;}\n    if(memo[L]){cout<<memo[L]<<endl;continue;}\n    int l=0;int r=N+1;\n    while(r-l>1){\n      int me=(l+r)/2;\n      int t=0;\n      for(auto p:m){\n        t+=max(p.first-me,0LL)*p.second;\n      }\n      if(t<=L)r=me;\n      else l=me;\n    }\n    memo[L]=r;cout<<r<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n//INSERT ABOVE HERE\n\ntemplate<typename T>\nclass CumulativeSum{\npublic:\n  int n;\n  vector<T> sum;\n  vector<T> A;\n  int added;\n  CumulativeSum():n(-1),added(0){}\n  CumulativeSum(int n):n(n), sum(n+1), A(n+1),added(0){}\n  CumulativeSum(const vector<T> &B):n(B.size()), sum(n+1), A(n+1),added(0){\n    for(int i=1;i<=n;i++) sum[i] = sum[i-1] + B[i-1];\n  }\n\n  void apply(){\n    for(int i=1;i<=n;i++) A[i] = A[i] + A[i-1];\n    for(int i=1;i<=n;i++) A[i] = A[i] + A[i-1];\n    for(int i=1;i<=n;i++) sum[i] = sum[i] + A[i-1];\n    added = 0; A.clear(); A.resize(n+1);\n  }\n\n  //[l, r)にxを加算\n  void add(int l, int r, T x){\n    added = 1;\n    assert(l <= r && 0 <= l && r <= n);\n    A[l] = A[l] + x;\n    A[r] = A[r] - x;\n  }\n\n  //[l, r)の和を得る\n  T get(int l,int r){\n    assert(l<=r && 0<=l && r<=n);\n    if(added) apply();\n    return sum[r] - sum[l];\n  }\n};\n\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M;\n  cin>>N>>M;\n  vector<int> A(M);\n  cin>>A;\n  A.push_back(N+1);\n\n  vector<Int> len;\n  for(int i=0;i<(int)A.size() - 1;i++){\n    len.push_back(A[i+1] - A[i]);\n  }\n\n  sort(len.begin(), len.end());\n  CumulativeSum<Int> Sum(len);\n  //pr(len);\n  int Q;\n  cin>>Q;\n  while(Q--){\n    int l;\n    cin>>l;\n    \n    auto check = [&](int x){\n      int idx = upper_bound(len.begin(), len.end(), x) - len.begin() ;\n      int cost = Sum.get(idx, Sum.n) - x * (Sum.n - idx ) + A[0] - 1;// + (Sum.n - idx);\n      //pr(l, x, idx, cost);\n      return cost <= l;\n    };\n\n    int L = 0, R = N+1;\n    while(L + 1 < R){\n      int M = (L + R) / 2;\n      // pr(M);\n      check(M)? R = M:L = M;\n    }\n    cout<<(R==N+1?-1:R)<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<int> w(m+1);\n\tfor(int i=0; i<m; i++){\n\t\tcin >> w[i];\n\t}\n\tw[m] = n+1;\n\tint q;\n\tcin >> q;\n\tvector<int> query(q);\n\tfor(int i=0; i<q; i++){\n\t\tcin >> query[i];\n\t}\n\n\tvector<int> loss(n+2,0),num(n+2,0);\n\tloss[0] += w[0]-1;\n\tnum[0] += m;\n\tfor(int i=0; i<m; i++){\n\t\tint len = w[i+1] -w[i];\n\t\tloss[0] += len;\n\t\tloss[len+1] -= len;\n\t\tnum[len+1] -= 1;\n\t}\n\tfor(int i=0; i<n+2; i++){\n\t\tloss[i+1] += loss[i];\n\t\tnum[i+1] += num[i];\n\t}\n\tfor(int i=0; i<n+2; i++){\n\t\tloss[i] -= num[i]*i;\n\t\tloss[i] = -loss[i];\n\t}\n\n\tfor(int i=0; i<q; i++){\n\t\tif(-loss[n+1] > query[i]){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tauto itr = lower_bound(loss.begin(), loss.end(), -query[i]);\n\t\t\tint ans = itr -loss.begin();\n\t\t\tcout << max(1, ans) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nint n, m;\nint x[112345];\nint ch[112345];\nint lost[112345];\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> m;\n  vector<int> v;\n  int now = n - m;\n  for(int i = 0; i < m; i++) cin >> x[i], ch[x[i]] = 1, v.emplace_back(x[i]);\n\n  lost[1] = now;\n  for(int i = 2; i <= n; i++) {\n    vector<int> nv;\n    for(auto e : v) {\n      if(e == n || ch[e+1]) {\n      } else {\n        ch[e+1] = 1;\n        now--;\n        nv.emplace_back(e + 1);\n      }\n    }\n    v = nv;\n    lost[i] = now;\n  }\n\n  int q;\n  cin >> q;\n  vector<int> ans(int(1e5) + 1, -1);\n  int head = n;\n  for(int i = 0; i <= int(1e5); i++) {\n    while(head >= 1 && lost[head] <= i) head--;\n    ans[i] = head == n ? -1 : head + 1;\n  }\n\n  for(int i = 0; i < q; i++) {\n    int x;\n    cin >> x;\n    cout << ans[x] << \"\\n\";\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\nint n,m;\nint p[125252];\nint q;\nint l[125252];\nint ans[125252];  // ans[i] := length i arrow -> sonsitu\n\nint main(){\n  scanf(\"%d%d\",&n,&m);\n  REP(i,m)scanf(\"%d\",p+i),p[i]--;\n  scanf(\"%d\",&q);\n  REP(i,q)scanf(\"%d\",l+i);\n  // calc ans\n  REP(i,n+2)ans[i] += p[0];\n  REP(i,m){\n    int x = p[i];\n    int y = i==m-1 ? n : p[i+1];\n    int sp = y-x-1;\n    int len = 1;\n    while(sp>0){\n      ans[len] += sp;\n      len++; sp--;\n    }\n  }\n  REP(i,n+2)ans[i] = n - ans[i];\n  // query\n  REP(i,q){\n    int id = lower_bound(ans+1,ans+n+2,n-l[i]) - ans;\n    if(id == n+2){\n      puts(\"-1\");\n    }else{\n      printf(\"%d\\n\",id);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define ll long long\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\n\nll a[100010];\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\ta[t]=-1;\n\t}\n\ta[0]=1e9;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]==-1)a[i]=0;\n\t\telse a[i]=a[i-1]+1;\n\t}\n\tsortdown(a+1,n);\n\t\n\tint q;\n\tscanf(\"%d\",&q);\n\twhile(q--){\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tt++;\n\t\tprintf(\"%d\\n\",a[t]>=1e9?-1:a[t]+1);\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint R=1,C=1,H[2000010],N[2000010];\n//評価関数（いまはMIN）\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]>N[H[b]]?1:0;\n}\n//挿入関数\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\n//取り出す関数\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint main(){\n  int n,m,a,b,d[200010],i,c;\n  scanf(\"%d %d %d\",&n,&m,&c);\n  for(i=0;i<100010;i++)d[i]=-1;\n  b=a=c;\n  for(i=1;i<m;i++){\n    scanf(\"%d\",&a);\n    hin(a-b);\n    b=a;\n  }\n  hin(n-a+1);\n  for(i=c-1;i<n;i++){\n    d[i]=N[hout()];\n    hin(d[i]-1);//printf(\"%d\\n\",d[i]);\n  }//printf(\"\\n\");\n  for(;i<100010;i++)d[i]=1;\n  scanf(\"%d\",&m);\n  while(m--){\n    scanf(\"%d\",&a);\n    printf(\"%d\\n\",d[a]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int mm = sc.nextInt();\n        TreeMap<Integer, Integer> counts = new TreeMap<>();\n        int start = sc.nextInt();\n        int prev = start;\n        for (int i = 1; i < mm; i++) {\n            int x = sc.nextInt();\n            if (counts.containsKey(x - prev)) {\n                counts.put(x - prev, counts.get(x - prev) + 1);\n            } else {\n                counts.put(x - prev, 1);\n            }\n            prev = x;\n        }\n        if (counts.containsKey(n + 1 - prev)) {\n            counts.put(n + 1 - prev, counts.get(n + 1 - prev) + 1);\n        } else {\n            counts.put(n + 1 - prev, 1);\n        }\n        int[] sums = new int[n + 1];\n        for (Map.Entry<Integer, Integer> entry : counts.entrySet()) {\n            for (int i = 0; i < entry.getKey(); i++) {\n                sums[i] += (entry.getKey() - i) * entry.getValue();\n            }\n        }\n        int q = sc.nextInt();\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < q; i++) {\n            int x = sc.nextInt();\n            if (x < start - 1) {\n                sb.append(-1).append(\"\\n\");\n                continue;\n            }\n            x -= start - 1;\n            int left = 0;\n            int right = n;\n            while (right - left > 1) {\n                int m = (left + right) / 2;\n                if (sums[m] > x) {\n                    left = m;\n                } else {\n                    right = m;\n                }\n            }\n            sb.append(right).append(\"\\n\");\n        }\n        System.out.print(sb);\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "n, m = gets.chomp.split.map(&:to_i)\n\nbase, prev = nil, nil\nh = Hash.new(0)\ngets.chomp.split.map(&:to_i).each{|x|\n    base = x - 1 if base.nil?\n    h[x - prev] += 1 if prev\n    prev = x\n}\nh[n + 1 - prev] += 1\n\narr = Array.new(h.keys.max, base)\narr.length.times{|i| h.each{|k, v| arr[i] += [(k - i - 1), 0].max * v}}\n\nq = gets.to_i\ngets.chomp.split.map(&:to_i).each{|query|\n    i = arr.bsearch_index{|x| x <= query}\n    puts i.nil? ? -1 : i + 1\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\n// I/O\ntype Scanner struct {\n\tsc *bufio.Scanner\n}\n\nfunc NewScanner() *Scanner {\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\tsc.Buffer(make([]byte, 1024), int(1e+9))\n\treturn &Scanner{sc}\n}\n\nfunc (s *Scanner) nextStr() string {\n\ts.sc.Scan()\n\treturn s.sc.Text()\n}\n\nfunc (s *Scanner) nextInt() int {\n\ti, e := strconv.Atoi(s.nextStr())\n\tif e != nil {\n\t\tpanic(e)\n\t}\n\treturn i\n}\n\nfunc (s *Scanner) nextFloat() float64 {\n\tf, e := strconv.ParseFloat(s.nextStr(), 64)\n\tif e != nil {\n\t\tpanic(e)\n\t}\n\treturn f\n}\n\nfunc (s *Scanner) nextRuneSlice() []rune {\n\treturn []rune(s.nextStr())\n}\n\nfunc (s *Scanner) nextIntSlice(n int) []int {\n\tres := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tres[i] = s.nextInt()\n\t}\n\treturn res\n}\n\nfunc (s *Scanner) nextFloatSlice(n int) []float64 {\n\tres := make([]float64, n)\n\tfor i := 0; i < n; i++ {\n\t\tres[i] = s.nextFloat()\n\t}\n\treturn res\n}\n\n// Arithmetic\nfunc max(nums ...int) int {\n\tm := nums[0]\n\tfor _, i := range nums {\n\t\tif m < i {\n\t\t\tm = i\n\t\t}\n\t}\n\treturn m\n}\n\nfunc min(nums ...int) int {\n\tm := nums[0]\n\tfor _, i := range nums {\n\t\tif m > i {\n\t\t\tm = i\n\t\t}\n\t}\n\treturn m\n}\n\nfunc abs(x int) int {\n\tif x > 0 {\n\t\treturn x\n\t}\n\treturn -x\n}\n\nfunc pow(x, y int) int {\n\tres := 1\n\tfor i := 0; i < y; i++ {\n\t\tres *= x\n\t}\n\treturn res\n}\n\n// Sort\ntype Val struct {\n\tid, num int\n}\ntype ByNum []Val\n\nfunc (a ByNum) Len() int           { return len(a) }\nfunc (a ByNum) Less(i, j int) bool { return a[i].num < a[j].num }\nfunc (a ByNum) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\n\nfunc main() {\n\tsc := NewScanner()\n\twtr := bufio.NewWriter(os.Stdout)\n\tN, M := sc.nextInt(), sc.nextInt()\n\tm := sc.nextIntSlice(M)\n\tm = append(m, N)\n\tQ := sc.nextInt()\n\tl := sc.nextIntSlice(Q)\n\tbase := m[0] - 1\n\tsums := make([]int, N+1)\n\tfor i := 1; i <= M; i++ {\n\t\tvar diff int\n\t\tif i != M {\n\t\t\tdiff = m[i] - m[i-1] - 1\n\t\t} else {\n\t\t\tdiff = m[i] - m[i-1]\n\t\t}\n\t\tfor j := 0; j < diff; j++ {\n\t\t\tsums[j+1] += diff - j\n\t\t}\n\t}\n\tfor _, allow := range l {\n\t\tok := N + 1\n\t\tng := 0\n\t\tfor abs(ok-ng) > 1 {\n\t\t\tmid := (ok + ng) / 2\n\t\t\tif base+sums[mid] <= allow {\n\t\t\t\tok = mid\n\t\t\t} else {\n\t\t\t\tng = mid\n\t\t\t}\n\t\t}\n\t\tif ok == N+1 {\n\t\t\tfmt.Fprintln(wtr, -1)\n\t\t} else {\n\t\t\tfmt.Fprintln(wtr, ok)\n\t\t}\n\t}\n\n\twtr.Flush()\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import bisect\n\nn,m = map(int,input().split())\npos = list(map(int,input().split()))\nq = int(input())\nl = list(map(int,input().split()))\n\npos.append(n+1)\nd = [pos[i+1]-pos[i]-1 for i in range(m)]\nd.sort()\ns = [0]*(m+1)\nfor i in range(len(d)):\n    s[i+1] = s[i]+d[i]\n\nfor lim in l:\n    ok = n+1\n    ng = 0\n    while abs(ok-ng)>1:\n        mid = (ok+ng)//2\n        idx = bisect.bisect_left(d,mid)\n        cost = (s[-1]-s[idx]) - (m-idx)*(mid-1) + (pos[0]-1)\n        if cost <= lim:\n            ok = mid\n        else:\n            ng = mid\n    if ok <= n:\n        print(ok)\n    else:\n        print(-1)\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left\ndef inpl(): return list(map(int, input().split()))\n\nN, M = inpl()\nX = inpl()\nQ = int(input())\nL = inpl()\n\nX += [N+1]\ninitcost = X[0] - 1\ncosts = [X[i+1] - X[i] - 1 for i in range(M) if X[i+1] - X[i] > 1]\nC = [0]*(N+1)\nC[0] = - 10**9\n\nfor i in range(1, N+1):\n    cost = 0\n    costs2 = []\n    for c in costs:\n        cost += c\n        if c > 1:\n            costs2.append(c-1)\n    C[i] = - (initcost + cost)\n    costs = costs2\n\nfor l in L:\n    if l < - C[-1]:\n        print(-1)\n    else:\n        print(bisect_left(C, -l))\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = SR()\n    return l\nmod = 1000000007\n\n#A\n\"\"\"\nn,m = LI()\na = LI()\nb = LI()\nli = list(set(a)|set(b))\nli2 = list(set(a)&set(b))\nli.sort()\nli2.sort()\nprint(len(li2),len(li))\nfor i in li2:\n    print(i)\nfor i in li:\n    print(i)\n\"\"\"\n\n#B\n\"\"\"\nn = I()\np = LI()\nans = [None for i in range(2*n)]\nind = [i for i in range(n)]\nfor i in range(n):\n    ind[p[i]-1] = i\nl = 0\nprint(ind)\nfor i in range(n):\n    while ans[l] != None:l += 1\n    ans[l] = \"(\"\n    r = n+ind[i]\n    while ans[r] != None:r += 1\n    ans[r] = \")\"\n    print(ans)\nk = []\nq = []\na = 1\nprint(ans)\nfor i in range(2*n):\n    if ans[i] == \"(\":\n        q.append(a)\n        a += 1\n    else:\n        k.append(q.pop(-1))\nif k != p:\n    print(\":(\")\nelse:\n    for i in range(2*n-1):\n        print(ans[i],end = \"\")\n    print(ans[-1])\n\"\"\"\n\n#C\n\"\"\"\ndef fact(n):\n    i = 2\n    a = n\n    if n < 4:\n        return [1,n],[n]\n    li = [1,n]\n    while i**2 <= a:\n        if n%i == 0:\n            li.append(i)\n            if i != n//i:\n                li.append(n//i)\n        i += 1\n    li.sort()\n    i = 2\n    if len(li) == 2:\n        return li,[a]\n    k = []\n    b = a\n    while i**2 <= b:\n        if a%i == 0:\n            k.append(i)\n            while a%i == 0:\n                a//= i\n        i += 1\n    if a!=1:\n        k.append(a)\n    return li,k\nn = I()\nl,k = fact(n)\nif len(l) == 2:\n    print(1,1)\nelse:\n    print(len(k),len(l)-1)\n\"\"\"\n\n#D\nn,m = LI()\na = LI()\nf = [0 for i in range(n+1)]\nfor i in range(1,m):\n    f[a[i]-a[i-1]-1] += 1\nf[n-a[-1]] += 1\ns = 0\nk = [0 for i in range(n+1)]\nfor i in range(n)[::-1]:\n    s += f[i]\n    k[i] += s+k[i+1]\nfor i in range(n+1):\n    k[i] += a[0]-1\nq = I()\np = LI()\nfor i in p:\n    l = 0\n    r = n\n    while r-l>1:\n        m = (l+r)//2\n        if k[m] > i:\n            l = m\n        else:\n            r = m\n    if k[r] > i:\n        print(-1)\n    else:\n        print(r)\n#E\n\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n\n"
  },
  {
    "language": "Python",
    "code": "import itertools as ite\nimport math\n\nINF = 10 ** 18\nN, M = map(int, raw_input().split())\nm = map(int, raw_input().split()) + [N + 1]\nQ = input()\nl = map(int, raw_input().split())\ncost = [0] * (N + 1)\nfor i in range(M):\n    cost[m[i + 1] - m[i] - 1] += 1\ncost[N] += m[0] - 1\ngrad = 0\nfor i in range(N)[::-1]:\n    grad += cost[i]\n    cost[i] = cost[i + 1] + grad\ndic = {}\nS = 10 ** 5 + 1\nfor i in range(1, N + 1):\n    if S != cost[i]:\n        for j in range(cost[i], S):\n            dic[j] = i\n        S = cost[i]\nfor num in l:\n    if not num in dic:\n        print -1\n    else:\n        print dic[num]\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::VecDeque;\n\nconst INF: usize = 1e9 as usize;\n\nfn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n\n    let distance: usize = sc.read();\n    let n: usize = sc.read();\n    let mut m = vec![];\n    for _ in 0..n {\n        let x: usize = sc.read();\n        m.push(x);\n    }\n    m.push(distance + 1);\n\n    let first = m[0];\n\n    let mut ds = vec![];\n    for i in 1..m.len() {\n        let d = m[i] - m[i - 1] - 1;\n        ds.push(d);\n    }\n\n    ds.sort();\n\n    let mut costs = vec![0; distance + 1];\n    let mut seg = 0;\n    for i in (0..distance).rev() {\n        while let Some(d) = ds.pop() {\n            if d < i {\n                ds.push(d);\n                break;\n            } else {\n                seg += 1;\n            }\n        }\n        costs[i] = costs[i + 1] + seg;\n    }\n\n    let q: usize = sc.read();\n    let mut l = vec![];\n    for i in 0..q {\n        let x = sc.read::<usize>();\n        l.push((x, i));\n    }\n    l.sort();\n\n    let mut ans: Vec<i64> = vec![0; q];\n    let mut cur = distance;\n    for (l, i) in l.into_iter() {\n        if l < first - 1 {\n            ans[i] = -1;\n            continue;\n        }\n        let l = l - (first - 1);\n        while cur > 1 && costs[cur - 1] <= l {\n            cur -= 1;\n        }\n        if cur == 1 && costs[1] > l {\n            ans[i] = -1;\n            continue;\n        }\n        ans[i] = cur as i64;\n    }\n\n    for ans in ans.into_iter() {\n        sc.write(format!(\"{}\\n\", ans));\n    }\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> IO<R, W> {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: std::ops::Deref<Target = str>>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n\n"
  }
]