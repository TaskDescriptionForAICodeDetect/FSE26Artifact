[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntemplate<class T> inline bool Cmax(T &x,T y) {return x<y?x=y,1:0;} \ntypedef long long ll;\nint T,A,X,B,Y,C,D;\nvector<int> pos,cnt;\nint gcd(int a,int b) {return b==0?a:gcd(b,a%b);}\nint exgcd(int a,int b,int &x,int &y) {\n\tif(b==0) {x=1,y=0; return a;}\n\tint d=exgcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\ninline int inver(int a,int mod) {\n\tint x,y,d=exgcd(a,mod,x,y);\n\tif(x<0) x+=mod;\n\treturn x;\n}\ninline ll lowdiv(ll a,ll b) {return a/b-(a%b&&(a^b)<0);}\nvoid init() {\n\tint d=gcd(A,B);\n\tA/=d,B/=d,C/=gcd(d,C);\n\tfor(int _=0;_<2;++_) {\n\t\td=gcd(A,C);\n\t\tC/=d,A/=d;\n\t\tint t=gcd(B,d);\n\t\tB/=t,Y/=d/t;\n\t\tswap(A,B),swap(X,Y);\n\t}\n}\nvoid getpos() {\n\tpos.clear(),cnt.clear();\n\tint W=C,H=D,now=0,r=inver(D,C);\n\twhile(W) {\n\t\tint d=W/H;\n\t\tpos.push_back((ll)now*r%C),cnt.push_back(d); \n\t\tnow+=d*H;\n\t\tW%=H; if(W==0) break;\n\t\tH%=W; if(H==0) H=W;\n\t}\n\tpos.push_back(C);\n}\ninline int gety(int x) {return C-(ll)x*D%C;}\nint main() {\n\trd(T);\n\tfor(int kase=1;kase<=T;++kase) {\n\t\trd(A),rd(X),rd(B),rd(Y),rd(C);\n\t\tinit();\n\t\tif(C==1) {printf(\"%d\\n\",X+Y); continue;}\n\t\tD=(ll)A*inver(B,C)%C;\n\t\tgetpos();\n\t\tint an=0;\n\t\tfor(int i=0;i<cnt.size();++i) {\n\t\t\tint xl=pos[i],xr=pos[i+1],yl=gety(xl),yr=gety(xr);\n\t\t\tint dx=(xr-xl)/cnt[i],dy=(yl-yr)/cnt[i];\n\t\t\tint l=0,r=X+Y,re=-1;\n\t\t\twhile(l<=r) {\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tll p=lowdiv(X-(ll)xl*mid,dx),q=lowdiv(Y-(ll)yr*mid,dy);\n\t\t\t\tif(p>=0&&q>=0&&p+q>=cnt[i]*mid) re=mid,l=mid+1;\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tCmax(an,re);\n\t\t}\n\t\tprintf(\"%d\\n\",an);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint a,b,c,lim1,lim2,tp;\n\nvoid exgcd(int a,int b,int &x,int &y) {\n\tif(!b) { x=1;y=0;return; }\n\texgcd(b,a%b,y,x);y-=a/b*x;\n}\n\nint inv(int a,int p) {\n\tint x,y;exgcd(a,p,x,y);\n\treturn (x+p)%p;\n}\n\nstruct dat {\n\tint x,y,cnt;\n} st[110];\n\nvoid get(int c,int d) {\n\ttp=0;int a=1,b=0;\n\twhile(d) {\n\t\t++tp;st[tp]=(dat){st[tp-1].x+c/d*a,st[tp-1].y+c/d*d,c/d};\n\t\tfor(int t=0;t<2&&d;t++) {\n\t\t\tif(!t) b+=c/d*a; else a+=c/d*b;\n\t\t\tswap(c,d);d%=c;\n\t\t}\n\t}\n}\n\nll Div(ll a,ll b) {\n\tif(a<0) return -1;\n\treturn a/b;\n}\n\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tint T;cin>>T;\n\twhile(T--) {\n\t\tcin>>a>>lim1>>b>>lim2>>c;\n\t\tint g=__gcd(a,b);a/=g;b/=g;c/=__gcd(c,g);\n\t\tg=__gcd(a,c);lim1/=g/__gcd(g,b);a/=g;b/=__gcd(g,b);c/=g;\n\t\tg=__gcd(b,c);lim2/=g/__gcd(g,a);a/=__gcd(g,a);b/=g;c/=g;\n\t\ta%=c;b%=c;\n\t\tif(c==1) { cout<<lim1+lim2<<'\\n';continue; }\n\t\tint d=1ll*a*inv(b,c)%c;get(c,d);int ans=0;\n\t\tif(st[tp].x!=c) st[++tp]=(dat){c,c,1};\n\t\tfor(int i=1;i<=tp;i++) {\n\t\t\tint lx=st[i-1].x,ly=c-st[i-1].y,rx=st[i].x,ry=c-st[i].y;\n\t\t\tint dx=(rx-lx)/st[i].cnt,dy=(ly-ry)/st[i].cnt;\n\t\t\t//cerr<<lx<<' '<<ly<<' '<<rx<<' '<<ry<<' '<<dx<<' '<<dy<<' '<<st[i].cnt<<'\\n';\n\t\t\tint l=ans,r=lim1+lim2;\n\t\t\twhile(l<r) {\n\t\t\t\tint mid=(l+r+1)>>1;\n\t\t\t\tif(max(0ll,Div(1ll*mid*ly-lim2+dy-1,dy))<=min(1ll*st[i].cnt*mid,Div(lim1-1ll*mid*lx,dx))) l=mid;\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tans=max(ans,l);\n\t\t}\n\t\tcout<<ans<<'\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nint a,b,x,y,c;\n\ninline int gcd(int a,int b){\n\treturn b==0?a:gcd(b,a%b);\n}\n\ninline void exgcd(int a,int b,int &x,int &y){\n\tif(b)exgcd(b,a%b,y,x),y-=a/b*x;\n\telse x=1,y=0;\n}\n\ninline int inv(int x,int p){//gcd(a,b)=0;\n\tint a,b;exgcd(x,p,a,b);\n\tif(a<0)a+=p;\n\treturn a;\n}\n\nvector<int> s, t;\n\ninline int gety(int x,int step){\n\tif(x==0)return c;\n\treturn (c-1ll*x*step%c)%c;\n}\n\ninline int lowdiv(int x,int y){\n\treturn x/y-(x%y&&(x^y)<0);\n}\n\nvoid Main(){\n\tint ans=0;\n\tcin >> a >> x >> b >> y >> c;\n\tint g=gcd(a,b);a/=g,b/=g;\n\tc/=gcd(c,g);\n\tfor(int _=1;_<=2;_++){\n\t\tg=gcd(a,c);\n\t\tc/=g,a/=g;int h=gcd(b,g);\n\t\tb/=h,y/=g/h;\n\n\t\tswap(a,b),swap(x,y);\n\t}\n\t// cerr << a << \" \" << x << \" \" << b << \" \" << y << \" \" << c << endl;\n\tif(c==1){\n\t\tprintf(\"%lld\\n\",x+y);return ;\n\t}\n\tint step=1ll*inv(b,c)*a%c;\n\tvector<int> pos, cnt;\n\t\tint z=inv(step, c), h=step, w=c, cur=0;\n\t\twhile(w){\n\t\t\tint p=w/h;\n\t\t\tpos.push_back(1ll*cur*z%c);\n\t\t\tcnt.push_back(p);\n\t\t\tcur+=p*h;\n\t\t\tw%=h;\n\t\t\tif(w==0)break;\n\t\t\th%=w;\n\t\t\tif(h==0)h=w;\n\t\t}\n\t\tpos.push_back(c);\n\t// for(size_t i=0;i<pos.size();i++)cout << pos[i] << \" \" ;puts(\"\");\n\t// for(size_t i=0;i<cnt.size();i++)cout << cnt[i] << \" \";puts(\"\");\n\t// cerr << \"????\" << endl;\n\tfor(size_t i=0;i<cnt.size();i++){\n\t\tint lx=pos[i], ly=gety(lx, step);\n\t\tint rx=pos[i+1], ry=gety(rx, step);\n\t\t\n\t\t// cerr << lx << \" \" << ly << \" \" << rx << \" \" << ry << endl;\n\t\t// cerr << cnt[i] << \"??\" << endl;\n\t\tint dx=(rx-lx)/cnt[i];\n\t\tint dy=(ly-ry)/cnt[i];\n\t\t// cerr << dx << \" \" << dy << endl;\n\t\tint lw=0,up=x+y+1;\n\t\t// cerr << \"st\" << endl;\n\t\twhile(up-lw>1){\n\t\t\tint mid=(lw+up)>>1;\n\t\t\tint p=lowdiv(x-lx*mid,dx);\n\t\t\tint q=lowdiv(y-ry*mid,dy);\n\t\t\tif(p>=0&&q>=0&&p+q>=cnt[i]*mid)\n\t\t\t\tlw=mid;\n\t\t\telse\n\t\t\t\tup=mid;\n\t\t}\n\t\t// cerr << \"ed\" << endl;\n\t\tans=max(ans, lw);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n#undef int\n\nint main(){int T;cin >> T;while(T--)Main();}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint T;\nll A,X,B,Y,C,TC;\n\nll totient(ll v) {\n\tll ret=v;\n\tfor(ll i=2;i*i<=v;i++) if(v%i==0) {\n\t\tret=ret/i*(i-1);\n\t\twhile(v%i==0) v/=i;\n\t}\n\tif(v>1) ret=ret/v*(v-1);\n\treturn ret;\n}\n\nll modpow(ll a, ll n,ll mo) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>T;\n\twhile(T--) {\n\t\tcin>>A>>X>>B>>Y>>C;\n\t\tll g=__gcd(A,B),g2;\n\t\t\n\t\tA/=g;\tB/=g;\tC/=__gcd(g,C);\n\t\tg=__gcd(A,C);\tA/=g;\tC/=g;\tg2=gcd(B,g);\tB/=g2;\tY/=g/g2;\n\t\tg=__gcd(B,C);\tB/=g;\tC/=g;\tg2=gcd(A,g);\tA/=g2;\tX/=g/g2;\n\t\tif(C==1) {\n\t\t\tcout<<X+Y<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tA%=C;\n\t\tB%=C;\n\t\t\n\t\tTC=totient(C);\n\t\t\n\t\tvector<pair<ll,ll>> cand;\n\t\tll D=A*modpow(B,TC-1,C)%C;\n\t\tcand.push_back({0,C});\n\t\tll H=D,W=0;\n\t\twhile(1) {\n\t\t\tH%=(C-W);\n\t\t\tif(H==0) break;\n\t\t\tll dif=(C-W)%H;\n\t\t\tif(dif==0) break;\n\t\t\tW=C-dif;\n\t\t\tll X=W*modpow(D,TC-1,C)%C;\n\t\t\tll Y=(C-D*X%C)%C;\n\t\t\tcand.push_back({X,Y});\n\t\t}\n\t\tcand.push_back({C,0});\n\t\t\n\t\tll ret=0;\n\t\t//cout<<A<<\" \"<<X<<\" \"<<B<<\" \"<<Y<<\" \"<<C<<endl;\n\t\tFORR(c,cand) {\n\t\t\t//cout<<c.first<<\" \"<<c.second<<endl;\n\t\t\tif(c.first==0) ret=max(ret,Y/c.second);\n\t\t\telse if(c.second==0) ret=max(ret,X/c.first);\n\t\t\telse ret=max(ret,min(X/c.first,Y/c.second));\n\t\t}\n\t\tFOR(i,cand.size()-1) {\n\t\t\tll AX=cand[i].first,AY=cand[i].second;\n\t\t\tll BX=cand[i+1].first,BY=cand[i+1].second;\n\t\t\tif(AY*X<=AX*Y || BY*X>=BX*Y) continue;\n\t\t\tll step=__gcd(BX-AX,AY-BY);\n\t\t\tll dx=(BX-AX)/step;\n\t\t\tll dy=(BY-AY)/step;\n\t\t\t\n\t\t\tint cur=0;\n\t\t\tfor(j=29;j>=0;j--) if(cur+(1<<j)<step) {\n\t\t\t\tll CX=AX+(cur+(1<<j))*dx;\n\t\t\t\tll CY=AY+(cur+(1<<j))*dy;\n\t\t\t\tif(CY*X>CX*Y) cur+=1<<j;\n\t\t\t}\n\t\t\tll TX=AX+cur*dx;\n\t\t\tll TY=AY+cur*dy;\n\t\t\tll SX=TX+dx;\n\t\t\tll SY=TY+dy;\n\t\t\tll mx=0;\n\t\t\tfor(j=29;j>=0;j--) {\n\t\t\t\tll lef=(-TX*(mx+(1<<j))+X)*SY;\n\t\t\t\tll ri=(-TY*(mx+(1<<j))+Y)*SX;\n\t\t\t\tif(lef<ri) mx+=1<<j;\n\t\t\t}\n\t\t\tret=max(ret,min(TX?X/TX:1<<30,TY?Y/TY:1<<30));\n\t\t\tret=max(ret,min(SX?X/SX:1<<30,SY?Y/SY:1<<30));\n\t\t\t//cout<<i<<\":: \"<<SX<<\" \"<<SY<<\" \"<<TX<<\" \"<<TY<<\" \"<<X<<\" \"<<Y<<\" \"<<mx<<\" \"<<ret<<endl;\n\t\t\tfor(x=mx-1;x<=mx+1;x++) if(x>=0) {\n\t\t\t\tll LX=X-SX*x;\n\t\t\t\tll LY=Y-SY*x;\n\t\t\t\tif(LX>=0&LY>=0) ret=max(ret,x+min(TX?LX/TX:1<<30,TY?LY/TY:1<<30));\n\t\t\t}\n\t\t\tcout<<ret<<endl;\n\t\t\t/*\n\t\t\tFOR(x,1000000) {\n\t\t\t\tll LX=X-SX*x;\n\t\t\t\tll LY=Y-SY*x;\n\t\t\t\tif(LX<0 || LY<0) break;\n\t\t\t\tret=max(ret,x+min(TX?LX/TX:1<<30,TY?LY/TY:1<<30));\n\t\t\t}\n\t\t\tcout<<ret<<endl;\n\t\t\t*/\n\t\t\t\n\t\t}\n\t\t\n\t\tcout<<ret<<endl;\n\t\t\n\t\t\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint T;\nll A,X,B,Y,C,TC;\n\nconst int prime_max = 1000000;\nvector<int> prime;\nint NP,divp[prime_max];\n\nvoid cprime() {\n\tif(NP) return;\n\tfor(int i=2;i<prime_max;i++) if(divp[i]==0) {\n\t\tprime.push_back(i); NP++;\n\t\tfor(ll j=1LL*i*i;j>=i&&j<prime_max;j+=i) if(divp[j]==0) divp[j]=i;\n\t}\n}\n\nll totient(ll v) {\n\tcprime();\n\tll ret=v;\n\tFORR(p,prime) {\n\t\tif(1LL*p*p>v) break;\n\t\tif(v%p==0) {\n\t\t\tret=ret/p*(p-1);\n\t\t\twhile(v%p==0) v/=p;\n\t\t}\n\t}\n\tif(v>1) ret=ret/v*(v-1);\n\treturn ret;\n}\n\nll modpow(ll a, ll n,ll mo) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>T;\n\twhile(T--) {\n\t\tcin>>A>>X>>B>>Y>>C;\n\t\tll g=__gcd(A,B),g2;\n\t\t\n\t\tA/=g;\tB/=g;\tC/=__gcd(g,C);\n\t\tg=__gcd(A,C);\tA/=g;\tC/=g;\tg2=gcd(B,g);\tB/=g2;\tY/=g/g2;\n\t\tg=__gcd(B,C);\tB/=g;\tC/=g;\tg2=gcd(A,g);\tA/=g2;\tX/=g/g2;\n\t\tif(C==1) {\n\t\t\tcout<<X+Y<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tA%=C;\n\t\tB%=C;\n\t\t\n\t\tTC=totient(C);\n\t\t\n\t\tvector<pair<ll,ll>> cand;\n\t\tll D=A*modpow(B,TC-1,C)%C;\n\t\tcand.push_back({0,C});\n\t\tll H=D,W=0;\n\t\twhile(1) {\n\t\t\tH%=(C-W);\n\t\t\tif(H==0) break;\n\t\t\tll dif=(C-W)%H;\n\t\t\tif(dif==0) break;\n\t\t\tW=C-dif;\n\t\t\tll X=W*modpow(D,TC-1,C)%C;\n\t\t\tll Y=(C-D*X%C)%C;\n\t\t\tcand.push_back({X,Y});\n\t\t}\n\t\tcand.push_back({C,0});\n\t\t\n\t\tll ret=0;\n\t\t//cout<<A<<\" \"<<X<<\" \"<<B<<\" \"<<Y<<\" \"<<C<<endl;\n\t\tFORR(c,cand) {\n\t\t\t//cout<<c.first<<\" \"<<c.second<<endl;\n\t\t\tif(c.first==0) ret=max(ret,Y/c.second);\n\t\t\telse if(c.second==0) ret=max(ret,X/c.first);\n\t\t\telse ret=max(ret,min(X/c.first,Y/c.second));\n\t\t}\n\t\tFOR(i,cand.size()-1) {\n\t\t\tll AX=cand[i].first,AY=cand[i].second;\n\t\t\tll BX=cand[i+1].first,BY=cand[i+1].second;\n\t\t\tif(AY*X<=AX*Y || BY*X>=BX*Y) continue;\n\t\t\tll step=__gcd(BX-AX,AY-BY);\n\t\t\tll dx=(BX-AX)/step;\n\t\t\tll dy=(BY-AY)/step;\n\t\t\t\n\t\t\tint cur=0;\n\t\t\tfor(j=29;j>=0;j--) if(cur+(1<<j)<step) {\n\t\t\t\tll CX=AX+(cur+(1<<j))*dx;\n\t\t\t\tll CY=AY+(cur+(1<<j))*dy;\n\t\t\t\tif(CY*X>CX*Y) cur+=1<<j;\n\t\t\t}\n\t\t\tll TX=AX+cur*dx;\n\t\t\tll TY=AY+cur*dy;\n\t\t\tll SX=TX+dx;\n\t\t\tll SY=TY+dy;\n\t\t\tint mx=0;\n\t\t\tfor(j=29;j>=0;j--) {\n\t\t\t\tll lef=(-TX*(mx+(1<<j))+X)*SY;\n\t\t\t\tll ri=(-TY*(mx+(1<<j))+Y)*SX;\n\t\t\t\tif(lef<ri) mx+=1<<j;\n\t\t\t}\n\t\t\tret=max(ret,min(TX?(X/TX):(1<<30),TY?(Y/TY):(1<<30)));\n\t\t\tret=max(ret,min(SX?(X/SX):(1<<30),SY?(Y/SY):(1<<30)));\n\t\t\t//cout<<i<<\":: \"<<SX<<\" \"<<SY<<\" \"<<TX<<\" \"<<TY<<\" \"<<X<<\" \"<<Y<<\" \"<<mx<<\" \"<<ret<<endl;\n\t\t\tfor(x=max(0,mx-2);x<=mx+2;x++) if(x>=0) {\n\t\t\t\tll LX=X-TX*x;\n\t\t\t\tll LY=Y-TY*x;\n\t\t\t\tif(LX>=0&LY>=0) {\n\t\t\t\t\tret=max(ret,x+min(SX?(LX/SX):(1<<30),SY?(LY/SY):(1<<30)));\n\t\t\t\t\t//cout<<x<<\" \"<<x+min(SX?(LX/SX):(1<<30),SY?(LY/SY):(1<<30))<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout<<ret<<endl;\n\t\t\t\n\t\t}\n\t\t\n\t\tcout<<ret<<endl;\n\t\t\n\t\t\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntemplate<class T> inline bool Cmax(T &x,T y) {return x<y?x=y,1:0;} \ntypedef long long ll;\nint T,A,X,B,Y,C,D;\nint gcd(int a,int b) {return b==0?a:gcd(b,a%b);}\nint exgcd(int a,int b,int &x,int &y) {\n\tif(b==0) {x=1,y=0; return a;}\n\telse exgcd(b,a%b,y,x),y-=a/b*x;\n}\ninline int inver(int a,int mod) {\n\tint x,y,exgcd(a,mod,x,y);\n\tif(x<0) x+=mod;\n\treturn x;\n}\ninline ll lowdiv(ll a,ll b) {return a/b-(a%b&&(a^b)<0);}\ninline int gety(int x) {return x==0?C:(C-(ll)x*D%C)%C;}\nint main() {\n\trd(T);\n\tfor(int kase=1;kase<=T;++kase) {\n\t\trd(A),rd(X),rd(B),rd(Y),rd(C);\n\t\t{\n\t\t\tint d=gcd(A,B);\n\t\t\tA/=d,B/=d,C/=gcd(d,C);\n\t\t\tfor(int _=0;_<2;++_) {\n\t\t\t\td=gcd(A,C);\n\t\t\t\tC/=d,A/=d;\n\t\t\t\tint t=gcd(B,d);\n\t\t\t\tB/=t,Y/=d/t;\n\t\t\t\tswap(A,B),swap(X,Y);\n\t\t\t}\n\t\t}\n\t\tif(C==1) {printf(\"%d\\n\",X+Y); continue;}\n\t\tD=(ll)A*inver(B,C)%C;\n\t\tvector<int> pos,cnt;\n\t\t{\n\t\t\tint W=C,H=D,now=0,r=inver(D,C);\n\t\t\twhile(W) {\n\t\t\t\tint d=W/H;\n\t\t\t\tpos.push_back((ll)now*r%C),cnt.push_back(d); \n\t\t\t\tnow+=d*H;\n\t\t\t\tW%=H; if(W==0) break;\n\t\t\t\tH%=W; if(H==0) H=W;\n\t\t\t}\n\t\t\tpos.push_back(C);\n\t\t} \n\t\tint an=0;\n\t\tfor(int i=0;i<cnt.size();++i) {\n\t\t\tint xl=pos[i],xr=pos[i+1],yl=gety(xl),yr=gety(xr);\n\t\t\tint dx=(xr-xl)/cnt[i],dy=(yl-yr)/cnt[i];\n\t\t\tint l=0,r=X+Y,re=-1;\n\t\t\twhile(l<=r) {\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tll p=lowdiv(X-(ll)xl*mid,dx),q=lowdiv(Y-(ll)yr*mid,dy);\n\t\t\t\tif(p>=0&&q>=0&&p+q>=(ll)cnt[i]*mid) re=mid,l=mid+1;\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tCmax(an,re);\n\t\t}\n\t\tprintf(\"%d\\n\",an);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\ninline int exgcd(int a,int b,int &x,int &y){\n\tif (!b) return x=1,y=0,a;\n\tint g=exgcd(b,a%b,y,x);\n\treturn y-=a/b*x,g;\n}\ninline int inv(int A,int mod){\n\tint x,y;\n\texgcd(A,mod,x,y);\n\treturn x<0?x+mod:x;\n}\n\nint A,B,C,D,X,Y;\n\ninline void init(){\n\tint g=__gcd(__gcd(A,B),C);\n\tA/=g,B/=g,C/=g;\n\tg=__gcd(A,C),Y/=g,C/=g;\n\tg=__gcd(B,C),X/=g,C/=g;\n}\nvector<int>x,cnt;\ninline void Get(){\n\tD=1ll*A*inv(B,C)%C,x.clear(),cnt.clear();\n\tint W=C,H=D,now=0,invD=inv(D,C);\n\twhile (W){\n\t\tint tmp=W/H;\n\t\tcnt.pb(tmp),x.pb(1ll*now*invD%C),now+=tmp*H;\n\t\tW%=H;\n\t\tif (!W) break;\n\t\tH%=W;\n\t\tif (H==0) H=W;\n\t}\n\tx.pb(C),cnt.pb(0);\n}\ninline int Get(int x){\n\treturn x==0?C:(C-1ll*x*D%C)%C;\n}\ninline void solve(){\n\tA=read(),X=read(),B=read(),Y=read(),C=read();\n\tinit(),Get();\n\tll ans=0;\n\tFOR(i,0,siz(x)-2){\n\t\tint lx=x[i],ly=Get(lx),rx=x[i+1],ry=Get(rx),dx=(rx-lx)/cnt[i],dy=(ly-ry)/cnt[i];\n\t\tll l=0,r=X+Y,ret=0;\n\t\twhile (l<=r){\n\t\t\tll mid=l+r>>1;\n\t\t\tif (X>=mid*lx&&Y>=mid*ry){\n\t\t\t\tll a=(X-mid*lx)/dx,b=(Y-mid*ry)/dy;\n\t\t\t\tif (a>=0&&b>=0&&a+b>=mid*cnt[i]) l=mid+1,ans=mid;\n\t\t\t\t\telse r=mid-1;\n\t\t\t} else r=mid-1;\n\t\t}\n\t\tans=max(ans,ret);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\tint T=read();\n\twhile (T--) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntemplate<class T> inline bool Cmax(T &x,T y) {return x<y?x=y,1:0;} \ntypedef long long ll;\nint T,A,X,B,Y,C,D;\nvector<int> pos,cnt;\nint gcd(int a,int b) {return b==0?a:gcd(b,a%b);}\nint exgcd(int a,int b,int &x,int &y) {\n\tif(b==0) {x=1,y=0; return a;}\n\tint d=exgcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\ninline int inver(int a,int mod) {\n\tint x,y,d=exgcd(a,mod,x,y);\n\tif(x<0) x+=mod;\n\treturn x;\n}\ninline ll lowdiv(ll a,ll b) {return a/b-(a%b&&(a^b)<0);}\nvoid init() {\n\tint d=gcd(A,B);\n\tA/=d,B/=d,C/=gcd(d,C);\n\tfor(int _=0;_<2;++_) {\n\t\td=gcd(A,C);\n\t\tC/=d,A/=d;\n\t\tint t=gcd(B,d);\n\t\tB/=t,Y/=d/t;\n\t\tswap(A,B),swap(X,Y);\n\t}\n}\nvoid getpos() {\n\tpos.clear(),cnt.clear();\n\tint W=C,H=D,now=0,r=inver(D,C);\n\twhile(W) {\n\t\tint d=W/H;\n\t\tpos.push_back((ll)now*r%C),cnt.push_back(d); \n\t\tnow+=d*H;\n\t\tW%=H; if(W==0) break;\n\t\tH%=W; if(H==0) H=W;\n\t}\n\tpos.push_back(C);\n}\ninline int gety(int x) {return x==0?C:(C-(ll)x*D%C)%C;}\nint main() {\n\trd(T);\n\tfor(int kase=1;kase<=T;++kase) {\n\t\trd(A),rd(X),rd(B),rd(Y),rd(C);\n\t\tinit();\n\t\tif(C==1) {printf(\"%d\\n\",X+Y); continue;}\n\t\tD=(ll)A*inver(B,C)%C;\n\t\tgetpos();\n\t\tint an=0;\n\t\tfor(int i=0;i<cnt.size();++i) {\n\t\t\tint xl=pos[i],xr=pos[i+1],yl=gety(xl),yr=gety(xr);\n\t\t\tint dx=(xr-xl)/cnt[i],dy=(yl-yr)/cnt[i];\n\t\t\tint l=0,r=X+Y,re=-1;\n\t\t\twhile(l<=r) {\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tll p=lowdiv(X-(ll)xl*mid,dx),q=lowdiv(Y-(ll)yr*mid,dy);\n\t\t\t\tif(p>=0&&q>=0&&p+q>=(ll)cnt[i]*mid) re=mid,l=mid+1;\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tCmax(an,re);\n\t\t}\n\t\tprintf(\"%d\\n\",an);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nint T;\nint ex_gcd(int a,int b,int &x,int &y)\n{\n\tif(b==0)\n\t{\n\t\tx=1,y=0;\n\t\treturn a;\n\t}\n\tint d=ex_gcd(b,a%b,x,y);\n\tint tmp=x;\n\tx=y,y=tmp-a/b*y;\n\treturn d;\n}\nint getinv(int A,int MOD)\n{\n\tint x,y;\n\tint d=ex_gcd(A,MOD,x,y);\n\tif(d!=1) return -1;\n\treturn (x+MOD)%MOD;\n}\nint a,x,b,y,c;\nint d;\nint gcd(int a,int b)\n{\n\treturn b==0?a:gcd(b,a%b);\n}\nvector<pair<int,int> >pos;\nvector<int>cnt;\nvoid getpos()\n{\n\tpos.clear(),cnt.clear();\n\tint W=c,H=d;\n\tint now=0;\n\twhile(true)\n\t{\n\t\tint r=W/H;\n\t\tpos.push_back(make_pair(1LL*now*getinv(d,c)%c,now%c==0?c:(c-now+c)%c)),cnt.push_back(r); \n\t\tnow+=r*H;\n\t\tW%=H;\n\t\tif(W==0) break;\n\t\tH%=W;\n\t\tif(H==0) H=W;\n\t}\n\tpos.push_back(make_pair(c,0));\n\treturn;\n}\nvoid solve()\n{\n\tscanf(\"%d%d%d%d%d\",&a,&x,&b,&y,&c);\n\tint G;\n\tG=gcd(a,b),a/=G,b/=G,c/=gcd(G,c);\n\tG=gcd(a,c),a/=G,c/=G,y/=G;\n\tG=gcd(b,c),b/=G,c/=G,x/=G;\n\ta%=c,b%=c;\n\tif(c==1)\n\t{\n\t\tprintf(\"%d\\n\",x+y);\n\t\treturn;\n\t}\n\td=1LL*a*getinv(b,c)%c;\n\tgetpos();\n\tint ans=0;\n\tfor(size_t i=0;i<cnt.size();i++)\n\t{\n\t\tint xl=pos[i].first,yl=pos[i].second,xr=pos[i+1].first,yr=pos[i+1].second;\n\t\tint dx=(xr-xl)/cnt[i],dy=(yl-yr)/cnt[i];\n\t\tint l=0,r=x+y,res=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint mid=((long long)l+r)/2;\n\t\t\tauto check=[=](int mid)\n\t\t\t{\n\t\t\t\tlong long p=(x-1LL*xl*mid)/dx,q=(y-1LL*yr*mid)/dy;\n\t\t\t\treturn (x-1LL*xl*mid)>=0&&(y-1LL*yr*mid)>=0&&p+q>=1LL*cnt[i]*mid;\n\t\t\t};\n\t\t\tif(check(mid)) res=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tans=max(ans,res);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn;\n}\nint main()\n{\n\tscanf(\"%d\",&T);\n\twhile(T--)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define eb(x,y) emplace_back(x,y)\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint a,b,c,x,y,top;\ninline void exgcd(int a,int b,int&x,int&y){\n\tif(b==0){x=1,y=0;return;}\n\texgcd(b,a%b,y,x),y-=a/b*x;\n}\ninline int inv(int x,int p){int a=0,b=0;exgcd(x,p,a,b);return (a%p+p)%p;}\nstruct Node{int x,y,c;}q[MAXN];\ninline void work(int c,int d){\n\tq[top=0]=(Node){0,0,0};\n\tfor(int x,a=1,b=0;d;){\n\t\tNode tmp=q[top];q[++top]=(Node){tmp.x+c/d*a,tmp.y+c/d*d,c/d};\n\t\tfor(int t=1;t<=2&&d!=0;t++){if(t==1)b+=c/d*a;else a+=c/d*b;x=c%d,c=d,d=x;}\n\t}\n}\ninline ll F(ll x,ll y){return x<0?-1:x/y;}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tfor(int t=read();t--;){\n\t\ta=read(),x=read(),b=read(),y=read(),c=read();\n\t\tint g=__gcd(a,b);a/=g,b/=g,c/=__gcd(c,g);\n\t\tg=__gcd(a,c),a/=g,c/=g,y/=g,g=__gcd(b,c),b/=g,c/=g,x/=g;\n\t\ta%=c,b%=c;if(c==1){cout<<x+y<<'\\n';continue;}int d=1ll*a*inv(b,c)%c;work(c,d);\n\t\tif(q[top].x!=c)q[++top]=(Node){c,c,1};int ans=0;\n\t\tRep(i,1,top){\n\t\t\tint lx=q[i-1].x,rx=q[i].x,ly=c-q[i-1].y,ry=c-q[i].y,dx=(rx-lx)/q[i].c,dy=(ly-ry)/q[i].c,l=ans+1,r=x+y;\n\t\t\twhile(l<=r){\n\t\t\t\tint mid=0ll+l+r>>1;ll s=F(x-1ll*mid*lx,dx),t=F(y-1ll*mid*ry,dy);\n\t\t\t\tif(s>=0&&t>=0&&s+t>=1ll*mid*q[i].c)ans=mid,l=mid+1;else r=mid-1;\n\t\t\t}\n\t\t}cout<<ans<<'\\n';\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nll minv(ll a, ll m) {\n\ta %= m;\n\tassert(a);\n\treturn a == 1 ? 1 : ll(m - ll(minv(m, a)) * ll(m) / a);\n}\nvoid solve(){\n\tll a, x, b, y, c;\n\tcin >> a >> x >> b >> y >> c;\n\ta %= c; b %= c;\n\t{\n\t\tll gabc = __gcd(c, __gcd(a, b));\n\t\ta /= gabc; b /= gabc; c /= gabc;\n\t}\n\t{\n\t\tll ga = __gcd(c, a);\n\t\ty /= ga;\n\t\tb = (b * ga) % c;\n\t\ta /= ga; b /= ga; c /= ga;\n\t}\n\t{\n\t\tll gb = __gcd(c, b);\n\t\ty /= gb;\n\t\ta = (a * gb) % c;\n\t\ta /= gb; b /= gb; c /= gb;\n\t}\n\tif(c == 1){\n\t\tcout << x + y << '\\n';\n\t\treturn;\n\t}\n\tassert(a > 0 && b > 0);\n\tll r = (a * minv(b, c)) % c;\n\tassert(r > 0);\n\tif(r == 1){\n\t\tcout << (x + y) / c << '\\n';\n\t\treturn;\n\t}\n\tll ir = minv(r, c);\n\tll f = c - r * (c / r);\n\tll g = c - ir * (c / ir);\n\tll s = 0; // yes\n\tll e = int(2e9) + 1;\n\tll fx = c / r;\n\tll fy = f;\n\tll gx = g;\n\tll gy = c / ir;\n\tassert(fx <= gx && fy >= gy);\n\twhile(s + 1 < e){\n\t\tll m = (s + e) / 2;\n\t\tll na = m * (c / r);\n\t\tll nb = m;\n\t\tll nc = m * (c / ir);\n\t\tll dx = gx - fx;\n\t\tll dy = fy - gy;\n\n\t\tll curx = 0;\n\t\tll cury = c;\n\t\tvector<pair<pair<ll,ll>, ll> > z = {{{r, 1}, na}, {{dx, dy}, nb}, {{1, ir}, nc}};\n\t\tfor(auto q : z){\n\t\t\tif(cury > y){\n\t\t\t\tll gg = (cury - y - 1) / q.first.second + 1;\n\t\t\t\tgg = min(g, q.second);\n\t\t\t\tcurx += gg * q.first.second;\n\t\t\t\tcury -= gg * q.second;\n\t\t\t}\n\t\t}\n\t\tif(c <= x){\n\t\t\ts = m;\n\t\t} else {\n\t\t\te = m;\n\t\t}\n\t}\n\tcout << s << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nll gcd(ll a, ll b) {\n  return b ? gcd(b, a % b) : a;\n}\nvoid exgcd(ll a, ll b, ll& x, ll& y) {\n  if (!b) {\n    x = 1, y = 0;\n  } else {\n    exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n}\nll inv(ll a, ll Mod) {\n  ll x, y;\n  exgcd(a, Mod, x, y);\n  return x < 0 ? x + Mod : x;\n} \n\ntypedef class vec {\n  public:\n    ll dx, dy;\n    int c;\n\n    vec(ll dx, ll dy, int c) : dx(dx), dy(dy), c(c) { }\n} vec;\n\nint T;\nll A, X, B, Y, C;\nvector<vec> conv;\n\nvoid solve() {\n  scanf(\"%lld%lld%lld%lld%lld\", &A, &X, &B, &Y, &C);\n  ll g = gcd(A, B), ga, gb;\n  A /= g, B /= g, C /= gcd(g, C);\n  ga = gcd(A, C);\n  A /= ga, Y /= ga, C /= ga;\n  gb = gcd(B, C);\n  B /= gb, X /= gb, C /= gb;\n  if (C == 1) {\n    printf(\"%lld\\n\", X + Y);\n    return;\n  }\n\n  conv.clear();\n  ll W = C, H = A * inv(B, C) % C, x0 = 0, ia = inv(A, C), p = 0, np;\n  while (W && H) {\n    if (W >= H) {\n      ll t = W / H;\n      W -= t * H;\n      x0 += t * H;\n      np = x0 * B % C * ia % C;\n      np += !np * C;\n      conv.emplace_back((np - p) / t, H, t);\n      p = np;\n    } else {\n      if (!(H % W)) { \n        conv.emplace_back(C - p, W, 1);\n        break;\n      } else {\n        H %= W;\n      }\n    }\n  }\n\n  ll l = 1, r = X + Y, mid;\n  while (l <= r) {\n    mid = (l + r) >> 1;\n    ll ca = 0, cb = mid * C;\n    for (auto v : conv) {\n      ll ub = min((cb - Y - 1) / v.dy + 1, 1ll * v.c * mid);\n      ub = min(ub, 1000000001ll);\n      ca += v.dx * ub;\n      cb -= v.dy * ub;\n      if (ca > X || cb <= Y) {\n        break;\n      }\n    }\n    if (ca <= X && cb <= Y) {\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  printf(\"%d\\n\", l - 1);\n}\n\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nstruct node{\n\tLL t,k,i;\n\tnode(LL t=0,LL k=0,LL i=0):t(t),k(k),i(i){}\n\tLL calc(LL x){return t+k*x;}\n};\nvector<node> f;\n\nLL gcd(LL x,LL y){\n\treturn y==0?x:gcd(y,x%y);\n}\n\nvoid exgcd(LL a,LL b,LL &x,LL &y){\n\tif (b==0){\n\t\tx=1; y=0;\n\t\treturn;\n\t}\n\texgcd(b,a%b,x,y);\n\tx-=a/b*y;\n\tswap(x,y);\n}\n\nvoid calc(LL n,LL m,LL p,LL q,LL now){\n\tif (!n||!m){\n\t\treturn;\n\t}\n\tif (n<=m){\n\t\tLL t=(m-1)/n;\n\t\tf.push_back(node(now+p,n+q,t)); \n\t\tcalc(n,m%n,p+(q+n)*t,q,now);\n\t}\n\telse{\n\t\tLL t=n/m;\n\t\tcalc(n%m,m,p,q+(p+m)*t,now);\n\t}\n}\n\nLL up(LL x,LL y){return (x+y-1)/y;}\n\nLL down(LL x,LL y){return x/y;}\n\nbool pd(LL u1,LL v1,LL u2,LL v2){\n\treturn u1*v2>=u2*v1;\n}\n\nLL calc(LL u1,LL v1,LL u2,LL v2,LL u,LL v){\n\tLL ret=0,l=0,r=u+v;\n\twhile (l<=r){\n\t\tLL mid=(l+r)>>1,t1=0,t2=mid;\n\t\tif (u2*mid-u>=0){\n\t\t\tt1=max(t1,up(u2*mid-u,u2-u1));\n\t\t}\n\t\tif (v-v2*mid<0){\n\t\t\tt2=-1;\n\t\t}\n\t\telse{\n\t\t\tt2=min(t2,down(v-v2*mid,v1-v2));\n\t\t}\n\t\tif (t1<=t2){ret=mid; l=mid+1;}\n\t\telse r=mid-1;\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\tLL a,b,c,x,y;\n\tscanf(\"%lld%lld%lld%lld%lld\",&a,&x,&b,&y,&c);\n\tLL g=gcd(a,b);\n\ta/=g; b/=g; c/=gcd(c,g);\n\tg=gcd(a,c);\n\ta/=g; c/=g; y/=g;\n\tg=gcd(b,c);\n\tb/=g; c/=g; x/=g;\n\ta%=c; b%=c;\n\tif (c==1){\n\t\tprintf(\"%lld\\n\",x+y);\n\t\treturn;\n\t}\n\tLL x0=0,y0=0;\n\texgcd(b,c,x0,y0);\n\ta=(a*x0%c+c)%c;\n\tf.clear();\n\tf.push_back(node(0,0,1));\n\tcalc(a,c,0,0,0);\n\tf.push_back(node(c*a,0,1));\n\tLL ans=0;\n\tfor (size_t i=0;i<f.size();++i){\n\t\tif (f[i].i>=2){\n\t\t\tLL u1=f[i].calc(1)/a,v1=c-(a*u1)%c;\n\t\t\tLL u2=f[i].calc(f[i].i)/a,v2=c-(a*u2)%c;\n\t\t\tif (pd(v1,u1,y,x)&&pd(y,x,v2,u2)){\n\t\t\t\tLL l=1,r=f[i].i-1;\n\t\t\t\twhile (l<=r){\n\t\t\t\t\tLL mid=(l+r)>>1;\n\t\t\t\t\tLL u1=f[i].calc(mid)/a,v1=c-(a*u1)%c;\n\t\t\t\t\tLL u2=f[i].calc(mid+1)/a,v2=c-(a*u2)%c;\n\t\t\t\t\tif (!pd(v1,u1,y,x)){\n\t\t\t\t\t\tr=mid-1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!pd(y,x,v2,u2)){\n\t\t\t\t\t\tl=mid+1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans=calc(u1,v1,u2,v2,x,y);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i+1<f.size()){\n\t\t\tLL u1=f[i].calc(f[i].i)/a,v1=c-(a*u1)%c;\n\t\t\tLL u2=f[i+1].calc(1)/a,v2=(c-(a*u2)%c)%c;\n\t\t\tif (pd(v1,u1,y,x)&&pd(y,x,v2,u2)){\n\t\t\t\tans=calc(u1,v1,u2,v2,x,y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\tLL T; scanf(\"%lld\",&T);\n\twhile (T--) solve();\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nint A, X, B, Y, C, G, D;\n\nvoid exgcd(int a, int b, int &x, int &y) {\n\tif (!b) {\n\t\tx = 1, y = 0;\n\t\treturn;\n\t}\n\texgcd(b, a % b, y, x);\n\ty -= a / b * x;\n}\n\nint inv(int a, int p) {\n\tint x, y;\n\texgcd(a, p, x, y);\n\treturn (x % p + p) % p;\n}\n\nint gety(int x) {\n\tif (x == 0) {\n\t\treturn C;\n\t}\n\treturn (C - 1ll * D * x % C) % C;\n}\n\nvoid solve() {\n\tread(A), read(X), read(B), read(Y), read(C);\n\tG = std::__gcd(A, B), A /= G, B /= G, C /= std::__gcd(C, G);\n\tG = std::__gcd(A, C), A /= G, C /= G, Y /= G;\n\tG = std::__gcd(B, C), B /= G, C /= G, X /= G;\n\tA %= C, B %= C;\n\tif (C == 1) {\n\t\tprint(X + Y);\n\t\treturn;\n\t}\n\tD = 1ll * A * inv(B, C) % C;\n\n\tstd::vector<int> pos, cnt;\n\tint W = C, H = D, now = 0, invD = inv(D, C);\n\twhile (W) {\n\t\tH = (H - 1) % W + 1;\n\t\tint t = W / H;\n\t\tpos.push_back(1ll * now * invD % C);\n\t\tcnt.push_back(t);\n\t\tnow += t * H;\n\t\tW -= t * H;\n\t}\n\tpos.push_back(C);\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < (int)cnt.size(); ++i) {\n\t\tint lx = pos[i], ly = gety(lx);\n\t\tint rx = pos[i + 1], ry = gety(rx);\n\t\tint dx = (rx - lx) / cnt[i];\n\t\tint dy = (ly - ry) / cnt[i];\n\t\t// debug(\"%d %d %d %d %d %d\\n\", lx, ly, rx, ry, dx, dy);\n\n\t\tlong long l = 0, r = X + Y, s = 0;\n\t\twhile (l <= r) {\n\t\t\tint md = (l + r) >> 1;\n\t\t\tlong long p = X - lx * md, q = Y - ry * md;\n\t\t\tif (p >= 0 && q >= 0 && p / dx + q / dy >= cnt[i] * md) {\n\t\t\t\ts = md, l = md + 1;\n\t\t\t} else {\n\t\t\t\tr = md - 1;\n\t\t\t}\n\t\t}\n\t\tans = std::max(ans, s);\n\t}\n\tprint(ans);\n}\n\nint main() {\n\tint T = 1;\n\tread(T);\n\twhile (T--) {\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <tuple>\nusing namespace std;\n#define endl '\\n'\n#define ll long long\n#define pi pair<int, int>\n#define pii pair<int, pi>\n#define f first\n#define s second\n\nll inv(ll a, ll mod){\n\tll b = mod, x = 0, y = 1, u = 1, v = 0;\n\twhile(a){\n\t\tll q = b / a, r = b % a;\n\t\ttie(x, y, u, v) = make_tuple(u, v, x - u * q, y - v * q);\n\t\tb = a, a = r;\n\t}\n\treturn x + (x < 0) * mod;\n}\n\nll a, x, b, y, c;\nll g, w, h, ia;\nvector<pii> v;\n\nbool works(ll f){\n\tll l = 0, r = v.size();\n\twhile(r - l > 1){\n\t\tll mid = (l + r) / 2;\n\t\tif(f * (c - v[mid].s.s) >= y) l = mid;\n\t\telse r = mid;\n\t}\n\tif(l == v.size() - 1) return 0;\n\t\n\tll dx = v[r].s.f - v[l].s.f, dy = v[r].s.s - v[l].s.s;\n\tdx /= v[r].f, dy /= v[r].f;\n\t\n\treturn l < v.size() - 1 && f * v[l].s.f + \n\t\t(f * (c - v[l].s.s) + dy - y - 1) / dy * dx <= x; \n}\n\nvoid answer(){\n\tcin >> a >> x >> b >> y >> c;\t\n\t\n\tg = __gcd(a, b);\n\ta /= g, b /= g, c /= __gcd(g, c);\n\tg = __gcd(a, c);\n\ta /= g, y /= g, c /= g;\n\tg = __gcd(b, c);\n\tb /= g, x /= g, c /= g;\n\t\n\tif(c == 1){\n\t\tcout << x + y << endl;\n\t\treturn;\n\t}\n\t\n\tw = c, h = a * inv(b, c) % c, ia = inv(a, c);\n\tv.assign(1, {1, {0, 0}});\n\twhile(w && h){\n\t\tif(w > h){\n\t\t\tll t = w / h;\n\t\t\tw -= t * h;\n\t\t\tv.push_back({t, {(c - w) * b % c * ia % c, c - w}});\n\t\t\tv.back().s.f += !v.back().s.f * c;\n\t\t}else if(h % w){\n\t\t\th %= w;\n\t\t}else{\n\t\t\tv.push_back({1, {c, c}});\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tll l = y / c, r = x + y + 1;\n\twhile(r - l > 1){\n\t\tll mid = (l + r) / 2;\n\t\tif(works(mid)) l = mid;\n\t\telse r = mid;\n\t}\n\t\n\tcout << l << endl;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor(int i = 0; i < t; i++) answer();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nint T, A, B, X, Y, C;\nint x, y;\nvoid exgcd(int a, int b, int &x, int &y){\n\tif(!b) return x=1,y=0,void();\n\texgcd(b,a%b,x,y); int _x=y, _y=x-a/b*y; x=_x; y=_y;\n}\nint inv(int a, int b){\n\texgcd(a,b,x,y);\n\tx = (x % b + b) % b; return x;\n}\nstruct dat{ int x, y, ct; };\nvector<dat> pt;\nvoid cope(int c, int d){\n\tpt.pb((dat){0,0,0}); int a=1, b=0;\n\twhile(d){\n\t\tdat t = pt.back();\n\t\tpt.pb((dat){t.x+c/d*a,t.y+c/d*d,c/d});\n\t\tfor(int _=1,x;_<=2;_++){\n\t\t\tif(_==1)b+=c/d*a;\n\t\t\tif(_==2)a+=c/d*b;\n\t\t\tx=c%d,c=d,d=x;\n\t\t}\n\t}\n} int clc(ll x, ll y){ return x<0?-1:x/y; }\nvoid Main(){\n\tscanf(\"%d%d%d%d%d\",&A,&X,&B,&Y,&C);\n\tint t = __gcd(A,B); A/=t; B/=t; C/=__gcd(t,C);\n\tt = __gcd(A,C); A/=t, C/=t, Y/=t;\n\tt = __gcd(B,C); B/=t, C/=t, X/=t;\n\tif(C==1)return cout<<X+Y<<'\\n',void();\n\tint D = (ll)A * inv(B,C) % C;\n\tcope(C,D); int ans = 0;\n\tif(pt.back().x!=C)pt.pb((dat){C,C,1});\n\tfor(int i=1; i<pt.size(); i++){\n\t\tint lx=pt[i-1].x,rx=pt[i].x;\n\t\tint ly=C-pt[i-1].y,ry=C-pt[i].y;\n\t\tint dx=(rx-lx)/pt[i].ct, dy=(ly-ry)/pt[i].ct;\n\t\tint l=ans+1,r=X+Y;\n\t\twhile(l<=r){\n\t\t\tint mid=(ll)(l+r)>>1;\n\t\t\tll S=clc(X-(ll)mid*lx,dx);\n\t\t\tll T=clc(Y-(ll)mid*ry,dy);\n\t\t\tif(~S&&~T&&S+T>=(ll)mid*pt[i].ct)ans=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t} \n\t} cout<<ans<<'\\n'; pt.clear();\n}\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d\",&T);\n\twhile(T--)Main();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nint mod;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\n\nvoid Ex_gcd(int a,int b,int &x,int &y){\n  if (!b) {x=1;y=0;return;}\n  Ex_gcd(b,a%b,y,x);\n  y-=a/b*x;\n}\n\nint Get_inv(int a,int p=mod){int x,y;Ex_gcd(a,p,x,y);return (x%p+p)%p;}\n\nint a,x,b,y;\n\nvoid into(){\n  scanf(\"%d%d%d%d%d\",&a,&x,&b,&y,&mod);\n}\n\nvoid Get_abc(){\n  int g=gcd(a,b);\n  a/=g;b/=g;mod/=gcd(g,mod);\n  g=gcd(a,mod);\n  a/=g;y/=g;mod/=g;\n  g=gcd(b,mod);\n  x/=g;b/=g;mod/=g;\n  a%=mod;b%=mod;\n}\n\nint d;\nvector<int>p,cnt;\n\nvoid Get_p(){\n  if (mod==1) return;\n  p.clear();\n  cnt.clear();\n  d=mul(a,Get_inv(b));\n  int invd=Get_inv(d),now=0;\n  for (int n=mod,m=d;n;){\n\tm=(m-1)%n+1;\n\tint t=n/m;\n\tp.push_back(mul(now,invd));\n\tcnt.push_back(t);\n\tnow+=t*m;n-=t*m;\n  }\n  p.push_back(mod);\n}\n\nLL ans;\n\nint Get_y(int x){return x?sub(0,mul(d,x)):mod;}\n\nvoid Get_ans(){\n  if (mod==1) {ans=x+y;return;}\n  ans=0;\n  for (int vs=cnt.size(),i=0;i<vs;++i){\n\tint lx=p[i],ly=Get_y(lx),rx=p[i+1],ry=Get_y(rx);\n\tint dx=(rx-lx)/cnt[i],dy=(ly-ry)/cnt[i];\n\t//printf(\"%d %d %d %d %d %d\\n\",lx,ly,rx,ry,dx,dy);\n\tLL l=0,r=x+y,s=0;\n\tfor (;l<=r;){\n\t  LL mid=l+r>>1,p=x-lx*mid,q=y-ry*mid;\n\t  p>=0&&q>=0&&p/dx+q/dy>=mid*cnt[i]?(s=mid,l=mid+1):r=mid-1;\n\t}\n\tans=max(ans,s);\n  }\n}\n\nvoid work(){\n  Get_abc();\n  Get_p();\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%lld\\n\",ans);\n}\n\nint main(){\n  int T;\n  scanf(\"%d\",&T);\n  for (;T--;){\n    into();\n    work();\n    outo();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntemplate<class T> inline bool Cmax(T &x,T y) {return x<y?x=y,1:0;} \ntypedef long long ll;\nint T,A,X,B,Y,C,D;\nint gcd(int a,int b) {return b==0?a:gcd(b,a%b);}\nint exgcd(int a,int b,int &x,int &y) {\n\tif(b==0) {x=1,y=0; return a;}\n\tint d=exgcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\ninline int inver(int a,int mod) {\n\tint x,y,d=exgcd(a,mod,x,y);\n\tif(x<0) x+=mod;\n\treturn x;\n}\ninline ll lowdiv(ll a,ll b) {return a/b-(a%b&&(a^b)<0);}\ninline int gety(int x) {return x==0?C:(C-(ll)x*D%C)%C;}\nint main() {\n\trd(T);\n\tfor(int kase=1;kase<=T;++kase) {\n\t\trd(A),rd(X),rd(B),rd(Y),rd(C);\n\t\t{\n\t\t\tint d=gcd(A,B);\n\t\t\tA/=d,B/=d,C/=gcd(d,C);\n\t\t\tfor(int _=0;_<2;++_) {\n\t\t\t\td=gcd(A,C);\n\t\t\t\tC/=d,A/=d;\n\t\t\t\tint t=gcd(B,d);\n\t\t\t\tB/=t,Y/=d/t;\n\t\t\t\tswap(A,B),swap(X,Y);\n\t\t\t}\n\t\t}\n\t\tif(C==1) {printf(\"%d\\n\",X+Y); continue;}\n\t\tvector<int> cnt,pos;\n\t\tD=(ll)A*inver(B,C)%C;\n\t\t{\n\t\t\tint W=C,H=D,now=0,r=inver(D,C);\n\t\t\twhile(W) {\n\t\t\t\tint d=W/H;\n\t\t\t\tpos.push_back((ll)now*r%C),cnt.push_back(d); \n\t\t\t\tnow+=d*H;\n\t\t\t\tW%=H; if(W==0) break;\n\t\t\t\tH%=W; if(H==0) H=W;\n\t\t\t}\n\t\t\tpos.push_back(C);\n\t\t} \n\t\tint an=0;\n\t\tfor(int i=0;i<cnt.size();++i) {\n\t\t\tint xl=pos[i],xr=pos[i+1],yl=gety(xl),yr=gety(xr);\n\t\t\tint dx=(xr-xl)/cnt[i],dy=(yl-yr)/cnt[i];\n\t\t\tint l=0,r=X+Y,re=-1;\n\t\t\twhile(l<=r) {\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tll p=lowdiv(X-(ll)xl*mid,dx),q=lowdiv(Y-(ll)yr*mid,dy);\n\t\t\t\tif(p>=0&&q>=0&&p+q>=(ll)cnt[i]*mid) re=mid,l=mid+1;\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tCmax(an,re);\n\t\t}\n\t\tprintf(\"%d\\n\",an);\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <tuple>\nusing namespace std;\n#define endl '\\n'\n#define ll long long\n#define pi pair<int, int>\n#define pii pair<int, pi>\n#define f first\n#define s second\n\nll inv(ll a, ll mod){\n\tll b = mod, x = 0, y = 1, u = 1, v = 0;\n\twhile(a){\n\t\tll q = b / a, r = b % a;\n\t\ttie(x, y, u, v) = make_tuple(u, v, x - u * q, y - v * q);\n\t\tb = a, a = r;\n\t}\n\treturn (x + (x < 0) * mod) % mod;\n}\n\nll a, x, b, y, c;\nll g, w, h, ia;\nvector<pii> v;\n\nbool works(ll f){\n\tll l = 0, r = v.size();\n\twhile(r - l > 1){\n\t\tll mid = (l + r) / 2;\n\t\tif(f * (c - v[mid].s.s) >= y) l = mid;\n\t\telse r = mid;\n\t}\n\tif(l == v.size() - 1) return 0;\n\t\n\tll dx = v[r].s.f - v[l].s.f, dy = v[r].s.s - v[l].s.s;\n\tdx /= v[r].f, dy /= v[r].f;\n\t\n\treturn l < v.size() - 1 && f * v[l].s.f + \n\t\t(f * (c - v[l].s.s) + dy - y - 1) / dy * dx <= x; \n}\n\nvoid answer(){\n\tcin >> a >> x >> b >> y >> c;\t\n\t\n\tg = __gcd(a, b);\n\ta /= g, b /= g, c /= __gcd(g, c);\n\tg = __gcd(a, c);\n\ta /= g, y /= g, c /= g;\n\tg = __gcd(b, c);\n\tb /= g, x /= g, c /= g;\n\t\n\tw = c, h = a * inv(b, c) % c, ia = inv(a, c);\n\tv.assign(1, {1, {0, 0}});\n\twhile(w && h){\n\t\tif(w > h){\n\t\t\tll t = w / h;\n\t\t\tw -= t * h;\n\t\t\tv.push_back({t, {(c - w) * b % c * ia % c, c - w}});\n\t\t\tv.back().s.f += !v.back().s.f * c;\n\t\t}else if(h % w){\n\t\t\th %= w;\n\t\t}else{\n\t\t\tv.push_back({1, {c, c}});\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tll l = y / c, r = x + y + 1;\n\twhile(r - l > 1){\n\t\tll mid = (l + r) / 2;\n\t\tif(works(mid)) l = mid;\n\t\telse r = mid;\n\t}\n\t\n\tcout << l << endl;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor(int i = 0; i < t; i++) answer();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nint T;\nint ex_gcd(int a,int b,int &x,int &y)\n{\n\tif(b==0)\n\t{\n\t\tx=1,y=0;\n\t\treturn a;\n\t}\n\tint d=ex_gcd(b,a%b,x,y);\n\tint tmp=x;\n\tx=y,y=tmp-a/b*y;\n\treturn d;\n}\nint getinv(int A,int MOD)\n{\n\tint x,y;\n\tint d=ex_gcd(A,MOD,x,y);\n\tif(d!=1) return -1;\n\treturn (x+MOD)%MOD;\n}\nint a,x,b,y,c;\nint d;\nint gcd(int a,int b)\n{\n\treturn b==0?a:gcd(b,a%b);\n}\nvector<pair<int,int> >pos;\nvector<int>cnt;\nvoid getpos()\n{\n\tpos.clear(),cnt.clear();\n\tint W=c,H=d;\n\tint now=0;\n\twhile(true)\n\t{\n\t\tint r=W/H;\n\t\tpos.push_back(make_pair(1LL*now*getinv(d,c)%c,now%c==0?c:(c-now+c)%c)),cnt.push_back(r); \n\t\tnow+=r*H;\n\t\tW%=H;\n\t\tif(W==0) break;\n\t\tH%=W;\n\t\tif(H==0) H=W;\n\t}\n\tpos.push_back(make_pair(c,0));\n\treturn;\n}\nvoid solve()\n{\n\tscanf(\"%d%d%d%d%d\",&a,&x,&b,&y,&c);\n\tint G;\n\tG=gcd(a,b),a/=G,b/=G,c/=gcd(G,c);\n\tG=gcd(a,c),a/=G,c/=G,y/=G;\n\tG=gcd(b,c),b/=G,c/=G,x/=G;\n\ta%=c,b%=c;\n\tif(c==1)\n\t{\n\t\tprintf(\"%d\\n\",x+y);\n\t\treturn;\n\t}\n\td=1LL*a*getinv(b,c)%c;\n\tgetpos();\n\tint ans=0;\n\tfor(size_t i=0;i<cnt.size();i++)\n\t{\n\t\tint xl=pos[i].first,yl=pos[i].second,xr=pos[i+1].first,yr=pos[i+1].second;\n\t\tint dx=(xr-xl)/cnt[i],dy=(yl-yr)/cnt[i];\n\t\tint l=0,r=x+y,res=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint mid=((long long)l+r)/2;\n\t\t\tlong long p=(x-1LL*xl*mid)/dx,q=(y-1LL*yr*mid)/dy;\n\t\t\tif((x-1LL*xl*mid)>=0&&(y-1LL*yr*mid)>=0&&p+q>=1LL*cnt[i]*mid) res=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tans=max(ans,res);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn;\n}\nint main()\n{\n\tscanf(\"%d\",&T);\n\twhile(T--)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb pushback\n#define fr(i,n) for(int i=0;i<n;i++)\n#define fro(i,j,n) for(int i=j;i<n;i++)\n#define ifr(i,n) for(int i=n-1;i>=0;i--)\n\nint main() {\n    int t;\n    int a,x,b,y,c\n    int ans=0;\n\tcin >> t;\n  \tfr(i,t){\n      cin >> a>>x>>b>>y>>c;\n      a%=c;\n      b%=c;\n      int g=gcd(a,b);\n      g=gcd(g,c);\n      a/=g;\n      b/=g;\n      c/=g;\n      if(b>a){\n        int ko=a;\n        a=b;\n        b=lo;\n      }\n      ans+=x/c;\n      ans+=y/c;\n      x%=c;\n      y%=c;\n      int dp[c][c];\n      fr(j,2*c-1){\n        fr(k,c){\n          dp[j][k-j]=j*x+(k-j)*y;\n        }\n      }\n      cout << ans<< endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nstruct node{\n\tLL t,k,i;\n\tnode(LL t=0,LL k=0,LL i=0):t(t),k(k),i(i){}\n\tLL calc(LL x){return t+k*x;}\n};\nvector<node> f;\n\nLL gcd(LL x,LL y){\n\treturn y==0?x:gcd(y,x%y);\n}\n\nvoid exgcd(LL a,LL b,LL &x,LL &y){\n\tif (b==0){\n\t\tx=1; y=0;\n\t\treturn;\n\t}\n\texgcd(b,a%b,x,y);\n\tx-=a/b*y;\n\tswap(x,y);\n}\n\nvoid calc(LL n,LL m,LL p,LL now){\n\tif (!n||!m){\n\t\treturn;\n\t}\n\tif (n<=m){\n\t\tLL t=(m-1)/n;\n\t\tf.push_back(node(now,n+p,t)); \n//\t\tfor (LL i=1;i<=t;++i) printf(\"%lld \",now+(n+p)*i);\n\t\tcalc(n,m%n,(n+p)*t,now+p);\n\t}\n\telse{\n\t\tLL t=n/m;\n\t\tcalc(n%m,m,(m+p)*t,now+p);\n\t}\n}\n\nLL up(LL x,LL y){return (x+y-1)/y;}\n\nLL down(LL x,LL y){return x/y;}\n\nbool pd(LL u1,LL v1,LL u2,LL v2){\n\treturn u1*v2>=u2*v1;\n}\n\nLL calc(LL u1,LL v1,LL u2,LL v2,LL u,LL v){\n\tLL ret=0,l=0,r=u+v;\n\twhile (l<=r){\n\t\tLL mid=(l+r)>>1,t1=0,t2=mid;\n\t\tif (u2*mid-u>=0){\n\t\t\tt1=max(t1,up(u2*mid-u,u2-u1));\n\t\t}\n\t\tif (v-v2*mid<0){\n\t\t\tt2=-1;\n\t\t}\n\t\telse{\n\t\t\tt2=min(t2,down(v-v2*mid,v1-v2));\n\t\t}\n\t\tif (t1<=t2){ret=mid; l=mid+1;}\n\t\telse r=mid-1;\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\tLL a,b,c,x,y;\n\tscanf(\"%lld%lld%lld%lld%lld\",&a,&x,&b,&y,&c);\n\tLL g=gcd(a,b);\n\ta/=g; b/=g; c/=gcd(c,g);\n\tg=gcd(a,c);\n\ta/=g; c/=g; y/=g;\n\tg=gcd(b,c);\n\tb/=g; c/=g; x/=g;\n\ta%=c; b%=c;\n\tLL x0=0,y0=0;\n\texgcd(b,c,x0,y0);\n\ta=(a*x0%c+c)%c;\n\tfor (LL i=a,mx=0;i<=10000;i+=a){\n\t\tif (i%c>mx){\n//\t\t\tprintf(\"%d %d\\n\",i/a,c-i%c);\n//\t\t\tprintf(\"%d \",i);\n\t\t\tmx=i%c;\n\t\t}\n\t}\n//\tputs(\"\");\n\tf.clear();\n\tf.push_back(node(0,0,1));\n\tcalc(a,c,0,0);\n\tf.push_back(node(c*a,0,1));\n//\tputs(\"\");\n\tLL ans=0;\n\tfor (size_t i=0;i<f.size();++i){\n\t\tif (f[i].i>=2){\n\t\t\tLL u1=f[i].calc(1)/a,v1=c-(a*u1)%c;\n\t\t\tLL u2=f[i].calc(f[i].i)/a,v2=c-(a*u2)%c;\n\t\t\tif (pd(v1,u1,y,x)&&pd(y,x,v2,u2)){\n\t\t\t\tLL l=1,r=f[i].i-1;\n\t\t\t\twhile (l<=r){\n\t\t\t\t\tLL mid=(l+r)>>1;\n\t\t\t\t\tLL u1=f[i].calc(mid)/a,v1=c-(a*u1)%c;\n\t\t\t\t\tLL u2=f[i].calc(mid+1)/a,v2=c-(a*u2)%c;\n\t\t\t\t\tif (!pd(v1,u1,y,x)){\n\t\t\t\t\t\tr=mid-1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!pd(y,x,v2,u2)){\n\t\t\t\t\t\tl=mid+1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans=calc(u1,v1,u2,v2,x,y);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i+1<f.size()){\n\t\t\tLL u1=f[i].calc(f[i].i)/a,v1=c-(a*u1)%c;\n\t\t\tLL u2=f[i+1].calc(1)/a,v2=(c-(a*u2)%c)%c;\n\t\t\tif (pd(v1,u1,y,x)&&pd(y,x,v2,u2)){\n\t\t\t\tans=calc(u1,v1,u2,v2,x,y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\tLL T; scanf(\"%lld\",&T);\n\twhile (T--) solve();\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint a,b,c,lim1,lim2,tp;\n\nvoid exgcd(int a,int b,int &x,int &y) {\n\tif(!b) { x=1;y=0;return; }\n\texgcd(b,a%b,y,x);y-=a/b*x;\n}\n\nint inv(int a,int p) {\n\tint x,y;exgcd(a,p,x,y);\n\treturn (x+p)%p;\n}\n\nstruct dat {\n\tint x,y,cnt;\n} st[110];\n\nvoid get(int c,int d) {\n\ttp=0;int a=1,b=0;\n\twhile(d) {\n\t\t++tp;st[tp]=(dat){st[tp-1].x+c/d*a,st[tp-1].y+c/d*d,c/d};\n\t\tfor(int t=0;t<2&&d;t++) {\n\t\t\tif(!t) b+=c/d*a; else a+=c/d*b;\n\t\t\tswap(c,d);d%=c;\n\t\t}\n\t}\n}\n\nll Div(ll a,ll b) {\n\tif(a<0) return -1;\n\treturn a/b;\n}\n\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tint T;cin>>T;\n\twhile(T--) {\n\t\tcin>>a>>lim1>>b>>lim2>>c;\n\t\tint g=__gcd(a,b);a/=g;b/=g;c/=__gcd(c,g);\n\t\tg=__gcd(a,c);lim2/=g/__gcd(g,b);a/=g;b/=__gcd(g,b);c/=g;\n\t\tg=__gcd(b,c);lim1/=g/__gcd(g,a);a/=__gcd(g,a);b/=g;c/=g;\n\t\ta%=c;b%=c;\n\t\tif(c==1) { cout<<lim1+lim2<<'\\n';continue; }\n\t\tint d=1ll*a*inv(b,c)%c;get(c,d);int ans=0;\n\t\tif(st[tp].x!=c) st[++tp]=(dat){c,c,1};\n\t\tfor(int i=1;i<=tp;i++) {\n\t\t\tint lx=st[i-1].x,ly=c-st[i-1].y,rx=st[i].x,ry=c-st[i].y;\n\t\t\tint dx=(rx-lx)/st[i].cnt,dy=(ly-ry)/st[i].cnt;\n\t\t\t//cerr<<lx<<' '<<ly<<' '<<rx<<' '<<ry<<' '<<dx<<' '<<dy<<' '<<st[i].cnt<<'\\n';\n\t\t\tint l=ans,r=lim1+lim2;\n\t\t\twhile(l<r) {\n\t\t\t\tint mid=(1ll+l+r)>>1;\n\t\t\t\tif(max(0ll,Div(1ll*mid*ly-lim2+dy-1,dy))<=min(1ll*st[i].cnt*mid,Div(lim1-1ll*mid*lx,dx))) l=mid;\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tans=max(ans,l);\n\t\t}\n\t\tcout<<ans<<'\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint T;\nll A,X,B,Y,C,TC;\n\nll totient(ll v) {\n\tll ret=v;\n\tfor(ll i=2;i*i<=v;i++) if(v%i==0) {\n\t\tret=ret/i*(i-1);\n\t\twhile(v%i==0) v/=i;\n\t}\n\tif(v>1) ret=ret/v*(v-1);\n\treturn ret;\n}\n\nll modpow(ll a, ll n,ll mo) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>T;\n\twhile(T--) {\n\t\tcin>>A>>X>>B>>Y>>C;\n\t\tll g=__gcd(A,B),g2;\n\t\t\n\t\tA/=g;\tB/=g;\tC/=__gcd(g,C);\n\t\tg=__gcd(A,C);\tA/=g;\tC/=g;\tg2=gcd(B,g);\tB/=g2;\tY/=g/g2;\n\t\tg=__gcd(B,C);\tB/=g;\tC/=g;\tg2=gcd(A,g);\tA/=g2;\tX/=g/g2;\n\t\tif(C==1) {\n\t\t\tcout<<X+Y<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tA%=C;\n\t\tB%=C;\n\t\t\n\t\tTC=totient(C);\n\t\t\n\t\tvector<pair<ll,ll>> cand;\n\t\tll D=A*modpow(B,TC-1,C)%C;\n\t\tcand.push_back({0,C});\n\t\tll H=D,W=0;\n\t\twhile(1) {\n\t\t\tH%=(C-W);\n\t\t\tif(H==0) break;\n\t\t\tll dif=(C-W)%H;\n\t\t\tif(dif==0) break;\n\t\t\tW=C-dif;\n\t\t\tll X=W*modpow(D,TC-1,C)%C;\n\t\t\tll Y=(C-D*X%C)%C;\n\t\t\tcand.push_back({X,Y});\n\t\t}\n\t\tcand.push_back({C,0});\n\t\t\n\t\tll ret=0;\n\t\t//cout<<A<<\" \"<<X<<\" \"<<B<<\" \"<<Y<<\" \"<<C<<endl;\n\t\tFORR(c,cand) {\n\t\t\t//cout<<c.first<<\" \"<<c.second<<endl;\n\t\t\tif(c.first==0) ret=max(ret,Y/c.second);\n\t\t\telse if(c.second==0) ret=max(ret,X/c.first);\n\t\t\telse ret=max(ret,min(X/c.first,Y/c.second));\n\t\t}\n\t\tFOR(i,cand.size()-1) {\n\t\t\tll AX=cand[i].first,AY=cand[i].second;\n\t\t\tll BX=cand[i+1].first,BY=cand[i+1].second;\n\t\t\tif(AY*X<=AX*Y || BY*X>=BX*Y) continue;\n\t\t\tll step=__gcd(BX-AX,AY-BY);\n\t\t\tll dx=(BX-AX)/step;\n\t\t\tll dy=(BY-AY)/step;\n\t\t\t\n\t\t\tint cur=0;\n\t\t\tfor(j=29;j>=0;j--) if(cur+(1<<j)<step) {\n\t\t\t\tll CX=AX+(cur+(1<<j))*dx;\n\t\t\t\tll CY=AY+(cur+(1<<j))*dy;\n\t\t\t\tif(CY*X>CX*Y) cur+=1<<j;\n\t\t\t}\n\t\t\tll TX=AX+cur*dx;\n\t\t\tll TY=AY+cur*dy;\n\t\t\tll SX=TX+dx;\n\t\t\tll SY=TY+dy;\n\t\t\tll mx=0;\n\t\t\tfor(j=29;j>=0;j--) {\n\t\t\t\tll lef=(-SX*(mx+(1<<j))+X)*TY;\n\t\t\t\tll ri=(-TX*(mx+(1<<j))+Y)*SY;\n\t\t\t\tif(lef>ri) mx+=1<<j;\n\t\t\t}\n\t\t\tret=max(ret,min(TX?X/TX:1<<30,TY?Y/TY:1<<30));\n\t\t\tret=max(ret,min(SX?X/SX:1<<30,SY?Y/SY:1<<30));\n\t\t\t//cout<<i<<\":: \"<<SX<<\" \"<<SY<<\" \"<<TX<<\" \"<<TY<<\" \"<<X<<\" \"<<Y<<\" \"<<mx<<\" \"<<ret<<endl;\n\t\t\tfor(x=mx-1;x<=mx+1;x++) if(x>=0) {\n\t\t\t\tll LX=X-SX*x;\n\t\t\t\tll LY=Y-SY*x;\n\t\t\t\tif(LX>=0&LY>=0) ret=max(ret,x+min(LX/TX,LY/TY));\n\t\t\t}\n\t\t\t//cout<<ret<<endl;\n\t\t\tFOR(x,1000000) {\n\t\t\t\tll LX=X-SX*x;\n\t\t\t\tll LY=Y-SY*x;\n\t\t\t\tif(LX<0 || LY<0) break;\n\t\t\t\tret=max(ret,x+min(TX?LX/TX:1<<30,TY?LY/TY:1<<30));\n\t\t\t}\n\t\t\t//cout<<ret<<endl;\n\t\t\t\n\t\t}\n\t\t\n\t\tcout<<ret<<endl;\n\t\t\n\t\t\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint T,A,X,B,Y,C,D;\nvector<pair<int,int> > s;\nint _gcd(int a,int b){\n\tif(b==0)return a;\n\treturn _gcd(b,a%b);\n}\nvoid init(){\n\tint g=_gcd(A,B);\n\tA/=g,B/=g,C/=_gcd(g,C);\n\tg=_gcd(A,C),A/=g,C/=g,Y/=g;\n\tg=_gcd(B,C),B/=g,C/=g,X/=g;\n}\nvoid exgcd(int a,int b,int &x,int &y){\n\tif(b==0){\n\t\tx=1,y=0;\n\t\treturn;\n\t}\n\texgcd(b,a%b,x,y);\n\tint t=x;\n\tx=y;\n\ty=t-a/b*y;\n}\nint Inv(int a,int mod){\n\tint x,y;\n\texgcd(a,mod,x,y);\n\treturn (x+mod)%mod;\n}\nint Get(int x){\n\treturn !x?C:(C-1LL*x*D%C)%C;\n}\nvoid Get_seg(){\n\tD=1LL*A*Inv(B,C)%C;\n\ts.clear();\n\tint W=C,H=D,now=0,invD=Inv(D,C);\n\twhile(\"MAK AK IOI!\"){\n\t\ts.emplace_back(W/H,(int)(1LL*now*invD%C));\n\t\tnow+=W/H*H;\n\t\tif(!(W%=H))break;\n\t\tif(!(H%=W))H=W;\n\t}\n\ts.emplace_back(0,C);\n}\nint main(){\n\tT=read();\n\twhile(T--){\n\t\tA=read(),X=read(),B=read(),Y=read(),C=read();\n\t\tinit();\n\t\tif(C==1){\n\t\t\tprintf(\"%d\\n\",X+Y);\n\t\t\tcontinue;\n\t\t}\n\t\tGet_seg();\n\t\tll mx=0;\n\t\tfor(int i=0;i<(int)s.size()-1;++i){\n\t\t\tint lx=s[i].second,rx=s[i+1].second;\n\t\t\tint ly=Get(lx),ry=Get(rx);\n\t\t\tint dx=(rx-lx)/s[i].first,dy=(ly-ry)/s[i].first;\n\t\t\tauto check=[=](ll k) -> bool{\n\t\t\t\tif(X-k*lx<0||Y-k*ry<0)return false;\n\t\t\t\tint a=(X-k*lx)/dx,b=(Y-k*ry)/dy;\n\t\t\t\treturn a+b>=k*s[i].first;\n\t\t\t};\n\t\t\tll l=0,r=X+Y+1,ans=0;\n\t\t\twhile(l<r){\n\t\t\t\tll mid=(l+r)>>1;\n\t\t\t\tif(check(mid)){\n\t\t\t\t\tans=mid;\n\t\t\t\t\tl=mid+1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tr=mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmx=max(mx,ans);\n\t\t}\n\t\tprintf(\"%lld\\n\",mx);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nvoid exgcd(int a, int b, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\treturn;\n\t}\n\tint q = a / b, r = a % b;\n\texgcd(b, r, y, x);\n\ty -= q * x;\n}\nint inv(int x, int p) {\n\tint a = 0, b = 0;\n\texgcd(x, p, a, b);\n\treturn (a % p + p) % p;\n}\nstruct info {int x, y, c; } q[MAXN];\nint top, a, b, c, x, y;\nvoid work(int c, int d){\n\tq[top = 0] = (info) {0, 0, 0};\n\tint len = 1, x, a = 1, b = 0;\n\twhile (d != 0) {\n\t\tinfo tmp = q[top];\n\t\tq[++top] = (info) {tmp.x + c / d * a, tmp.y + c / d * d, c / d};\n\t\tfor (int t = 1; t <= 2 && d != 0; t++){\n\t\t\tif (t == 1) b += c / d * a;\n\t\t\telse a += c / d * b;\n\t\t\tx = c % d, c = d, d = x;\n\t\t}\n\t}\n}\nll func(ll x, ll y) {\n\tif (x < 0) return -1;\n\telse return x / y;\n}\nint main() {\n\tint T; read(T);\n\twhile (T--) {\n\t\tread(a), read(x), read(b), read(y), read(c);\n\t\tint g = __gcd(a, b); a /= g, b /= g, c /= __gcd(c, g);\n\t\tg = __gcd(a, c), a /= g, c /= g, y /= g;\n\t\tg = __gcd(b, c), b /= g, c /= g, x /= g;\n\t\ta %= c, b %= c;\n\t\tif (c == 1) {\n\t\t\tprintf(\"%d\\n\", x + y);\n\t\t\tcontinue;\n\t\t}\n\t\tint d = 1ll * a * inv(b, c) % c; work(c, d);\n\t\tif (q[top].x != c) q[++top] = (info) {c, c, 1};\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= top; i++) {\n\t\t\tint lx = q[i - 1].x, rx = q[i].x;\n\t\t\tint ly = c - q[i - 1].y, ry = c - q[i].y;\n\t\t\tint dx = (rx - lx) / q[i].c, dy = (ly - ry) / q[i].c;\n\t\t\tint l = ans + 1, r = x + y;\n\t\t\twhile (l <= r) {\n\t\t\t\tint mid = (l + r) / 2;\n\t\t\t\tll s = func(x - 1ll * mid * lx, dx);\n\t\t\t\tll t = func(y - 1ll * mid * ry, dy);\n\t\t\t\tif (s >= 0 && t >= 0 && s + t >= 1ll * q[i].c * mid) ans = mid, l = mid + 1;\n\t\t\t\telse r = mid - 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint T;\nll A,X,B,Y,C,TC;\n\nll totient(ll v) {\n\tll ret=v;\n\tfor(ll i=2;i*i<=v;i++) if(v%i==0) {\n\t\tret=ret/i*(i-1);\n\t\twhile(v%i==0) v/=i;\n\t}\n\tif(v>1) ret=ret/v*(v-1);\n\treturn ret;\n}\n\nll modpow(ll a, ll n,ll mo) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>T;\n\twhile(T--) {\n\t\tcin>>A>>X>>B>>Y>>C;\n\t\tll g=__gcd(A,B),g2;\n\t\t\n\t\tA/=g;\tB/=g;\tC/=__gcd(g,C);\n\t\tg=__gcd(A,C);\tA/=g;\tC/=g;\tg2=gcd(B,g);\tB/=g2;\tY/=g/g2;\n\t\tg=__gcd(B,C);\tB/=g;\tC/=g;\tg2=gcd(A,g);\tA/=g2;\tX/=g/g2;\n\t\tif(C==1) {\n\t\t\tcout<<X+Y<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tA%=C;\n\t\tB%=C;\n\t\t\n\t\tTC=totient(C);\n\t\t\n\t\tvector<pair<ll,ll>> cand;\n\t\tll D=A*modpow(B,TC-1,C)%C;\n\t\tcand.push_back({0,C});\n\t\tll H=D,W=0;\n\t\twhile(1) {\n\t\t\tH%=(C-W);\n\t\t\tif(H==0) break;\n\t\t\tll dif=(C-W)%H;\n\t\t\tif(dif==0) break;\n\t\t\tW=C-dif;\n\t\t\tll X=W*modpow(D,TC-1,C)%C;\n\t\t\tll Y=(C-D*X%C)%C;\n\t\t\tcand.push_back({X,Y});\n\t\t}\n\t\tcand.push_back({C,0});\n\t\t\n\t\tll ret=0;\n\t\t//cout<<A<<\" \"<<X<<\" \"<<B<<\" \"<<Y<<\" \"<<C<<endl;\n\t\tFORR(c,cand) {\n\t\t\t//cout<<c.first<<\" \"<<c.second<<endl;\n\t\t\tif(c.first==0) ret=max(ret,Y/c.second);\n\t\t\telse if(c.second==0) ret=max(ret,X/c.first);\n\t\t\telse ret=max(ret,min(X/c.first,Y/c.second));\n\t\t}\n\t\tFOR(i,cand.size()-1) {\n\t\t\tll AX=cand[i].first,AY=cand[i].second;\n\t\t\tll BX=cand[i+1].first,BY=cand[i+1].second;\n\t\t\tif(AY*X<=AX*Y || BY*X>=BX*Y) continue;\n\t\t\tll step=__gcd(BX-AX,AY-BY);\n\t\t\tll dx=(BX-AX)/step;\n\t\t\tll dy=(BY-AY)/step;\n\t\t\t\n\t\t\tint cur=0;\n\t\t\tfor(j=29;j>=0;j--) if(cur+(1<<j)<step) {\n\t\t\t\tll CX=AX+(cur+(1<<j))*dx;\n\t\t\t\tll CY=AY+(cur+(1<<j))*dy;\n\t\t\t\tif(CY*X>CX*Y) cur+=1<<j;\n\t\t\t}\n\t\t\tll TX=AX+cur*dx;\n\t\t\tll TY=AY+cur*dy;\n\t\t\tll SX=TX+dx;\n\t\t\tll SY=TY+dy;\n\t\t\tll mx=0;\n\t\t\tfor(j=29;j>=0;j--) {\n\t\t\t\tll lef=(-SX*(mx+(1<<j))+X)*TY;\n\t\t\t\tll ri=(-TX*(mx+(1<<j))+Y)*SY;\n\t\t\t\tif(lef>ri) mx+=1<<j;\n\t\t\t}\n\t\t\tret=max(ret,min(X/TX,Y/TY));\n\t\t\tret=max(ret,min(X/SX,Y/SY));\n\t\t\t//cout<<i<<\":: \"<<SX<<\" \"<<SY<<\" \"<<TX<<\" \"<<TY<<\" \"<<X<<\" \"<<Y<<\" \"<<mx<<\" \"<<ret<<endl;\n\t\t\tfor(x=mx-1;x<=mx+1;x++) if(x>=0) {\n\t\t\t\tll LX=X-SX*x;\n\t\t\t\tll LY=Y-SY*x;\n\t\t\t\tif(LX>=0&LY>=0) ret=max(ret,x+min(LX/TX,LY/TY));\n\t\t\t}\n\t\t\t//cout<<ret<<endl;\n\t\t\tFOR(x,1000000) {\n\t\t\t\tll LX=X-SX*x;\n\t\t\t\tll LY=Y-SY*x;\n\t\t\t\tif(LX<0 || LY<0) break;\n\t\t\t\tret=max(ret,x+min(LX/TX,LY/TY));\n\t\t\t}\n\t\t\t//cout<<ret<<endl;\n\t\t\t\n\t\t}\n\t\t\n\t\tcout<<ret<<endl;\n\t\t\n\t\t\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nstruct node{\n\tLL t,k,i;\n\tnode(LL t=0,LL k=0,LL i=0):t(t),k(k),i(i){}\n\tLL calc(LL x){return t+k*x;}\n};\nvector<node> f;\n\nLL gcd(LL x,LL y){\n\treturn y==0?x:gcd(y,x%y);\n}\n\nvoid exgcd(LL a,LL b,LL &x,LL &y){\n\tif (b==0){\n\t\tx=1; y=0;\n\t\treturn;\n\t}\n\texgcd(b,a%b,x,y);\n\tx-=a/b*y;\n\tswap(x,y);\n}\n\nvoid calc(LL n,LL m,LL p,LL now){\n\tif (!n||!m){\n\t\treturn;\n\t}\n\tif (n<=m){\n\t\tLL t=(m-1)/n;\n\t\tf.push_back(node(now,n+p,t)); \n\t\tcalc(n,m%n,(n+p)*t,now+p);\n\t}\n\telse{\n\t\tLL t=n/m;\n\t\tcalc(n%m,m,(m+p)*t,now+p);\n\t}\n}\n\nLL up(LL x,LL y){return (x+y-1)/y;}\n\nLL down(LL x,LL y){return x/y;}\n\nbool pd(LL u1,LL v1,LL u2,LL v2){\n\treturn u1*v2>=u2*v1;\n}\n\nLL calc(LL u1,LL v1,LL u2,LL v2,LL u,LL v){\n\tLL ret=0,l=0,r=u+v;\n\twhile (l<=r){\n\t\tLL mid=(l+r)>>1,t1=0,t2=mid;\n\t\tif (u2*mid-u>=0){\n\t\t\tt1=max(t1,up(u2*mid-u,u2-u1));\n\t\t}\n\t\tif (v-v2*mid<0){\n\t\t\tt2=-1;\n\t\t}\n\t\telse{\n\t\t\tt2=min(t2,down(v-v2*mid,v1-v2));\n\t\t}\n\t\tif (t1<=t2){ret=mid; l=mid+1;}\n\t\telse r=mid-1;\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\tLL a,b,c,x,y;\n\tscanf(\"%lld%lld%lld%lld%lld\",&a,&x,&b,&y,&c);\n\tLL g=gcd(a,b);\n\ta/=g; b/=g; c/=gcd(c,g);\n\tg=gcd(a,c);\n\ta/=g; c/=g; y/=g;\n\tg=gcd(b,c);\n\tb/=g; c/=g; x/=g;\n\ta%=c; b%=c;\n\tLL x0=0,y0=0;\n\texgcd(b,c,x0,y0);\n\ta=(a*x0%c+c)%c;\n\tfor (LL i=a,mx=0;i<=10000;i+=a){\n\t\tif (i%c>mx){\n\t\t\tmx=i%c;\n\t\t}\n\t}\n\tf.clear();\n\tf.push_back(node(0,0,1));\n\tcalc(a,c,0,0);\n\tf.push_back(node(c*a,0,1));\n\tLL ans=0;\n\tfor (size_t i=0;i<f.size();++i){\n\t\tif (f[i].i>=2){\n\t\t\tLL u1=f[i].calc(1)/a,v1=c-(a*u1)%c;\n\t\t\tLL u2=f[i].calc(f[i].i)/a,v2=c-(a*u2)%c;\n\t\t\tif (pd(v1,u1,y,x)&&pd(y,x,v2,u2)){\n\t\t\t\tLL l=1,r=f[i].i-1;\n\t\t\t\twhile (l<=r){\n\t\t\t\t\tLL mid=(l+r)>>1;\n\t\t\t\t\tLL u1=f[i].calc(mid)/a,v1=c-(a*u1)%c;\n\t\t\t\t\tLL u2=f[i].calc(mid+1)/a,v2=c-(a*u2)%c;\n\t\t\t\t\tif (!pd(v1,u1,y,x)){\n\t\t\t\t\t\tr=mid-1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!pd(y,x,v2,u2)){\n\t\t\t\t\t\tl=mid+1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans=calc(u1,v1,u2,v2,x,y);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i+1<f.size()){\n\t\t\tLL u1=f[i].calc(f[i].i)/a,v1=c-(a*u1)%c;\n\t\t\tLL u2=f[i+1].calc(1)/a,v2=c-(a*u2)%c;\n\t\t\tif (pd(v1,u1,y,x)&&pd(y,x,v2,u2)){\n\t\t\t\tans=calc(u1,v1,u2,v2,x,y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\tLL T; scanf(\"%lld\",&T);\n\twhile (T--) solve();\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint T;\nll A,X,B,Y,C,TC;\n\nconst int prime_max = 1000000;\nvector<int> prime;\nint NP,divp[prime_max];\n\nvoid cprime() {\n\tif(NP) return;\n\tfor(int i=2;i<prime_max;i++) if(divp[i]==0) {\n\t\tprime.push_back(i); NP++;\n\t\tfor(ll j=1LL*i*i;j>=i&&j<prime_max;j+=i) if(divp[j]==0) divp[j]=i;\n\t}\n}\n\nll totient(ll v) {\n\tcprime();\n\tll ret=v;\n\tFORR(p,prime) {\n\t\tif(1LL*p*p>v) break;\n\t\tif(v%p==0) {\n\t\t\tret=ret/p*(p-1);\n\t\t\twhile(v%p==0) v/=p;\n\t\t}\n\t}\n\tif(v>1) ret=ret/v*(v-1);\n\treturn ret;\n}\n\nll modpow(ll a, ll n,ll mo) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>T;\n\twhile(T--) {\n\t\tcin>>A>>X>>B>>Y>>C;\n\t\tll g=__gcd(A,B),g2;\n\t\t\n\t\tA/=g;\tB/=g;\tC/=__gcd(g,C);\n\t\tg=__gcd(A,C);\tA/=g;\tC/=g;\tg2=gcd(B,g);\tB/=g2;\tY/=g/g2;\n\t\tg=__gcd(B,C);\tB/=g;\tC/=g;\tg2=gcd(A,g);\tA/=g2;\tX/=g/g2;\n\t\tif(C==1) {\n\t\t\tcout<<X+Y<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tA%=C;\n\t\tB%=C;\n\t\t\n\t\tTC=totient(C);\n\t\t\n\t\tvector<pair<ll,ll>> cand;\n\t\tll D=A*modpow(B,TC-1,C)%C;\n\t\tcand.push_back({0,C});\n\t\tll H=D,W=0;\n\t\twhile(1) {\n\t\t\tH%=(C-W);\n\t\t\tif(H==0) break;\n\t\t\tll dif=(C-W)%H;\n\t\t\tif(dif==0) break;\n\t\t\tW=C-dif;\n\t\t\tll X=W*modpow(D,TC-1,C)%C;\n\t\t\tll Y=(C-D*X%C)%C;\n\t\t\tcand.push_back({X,Y});\n\t\t}\n\t\tcand.push_back({C,0});\n\t\t\n\t\tll ret=0;\n\t\t//cout<<A<<\" \"<<X<<\" \"<<B<<\" \"<<Y<<\" \"<<C<<endl;\n\t\tFORR(c,cand) {\n\t\t\t//cout<<c.first<<\" \"<<c.second<<endl;\n\t\t\tif(c.first==0) ret=max(ret,Y/c.second);\n\t\t\telse if(c.second==0) ret=max(ret,X/c.first);\n\t\t\telse ret=max(ret,min(X/c.first,Y/c.second));\n\t\t}\n\t\tFOR(i,cand.size()-1) {\n\t\t\tll AX=cand[i].first,AY=cand[i].second;\n\t\t\tll BX=cand[i+1].first,BY=cand[i+1].second;\n\t\t\tif(AY*X<=AX*Y || BY*X>=BX*Y) continue;\n\t\t\tll step=__gcd(BX-AX,AY-BY);\n\t\t\tll dx=(BX-AX)/step;\n\t\t\tll dy=(BY-AY)/step;\n\t\t\t\n\t\t\tint cur=0;\n\t\t\tfor(j=29;j>=0;j--) if(cur+(1<<j)<step) {\n\t\t\t\tll CX=AX+(cur+(1<<j))*dx;\n\t\t\t\tll CY=AY+(cur+(1<<j))*dy;\n\t\t\t\tif(CY*X>CX*Y) cur+=1<<j;\n\t\t\t}\n\t\t\tll TX=AX+cur*dx;\n\t\t\tll TY=AY+cur*dy;\n\t\t\tll SX=TX+dx;\n\t\t\tll SY=TY+dy;\n\t\t\tret=max(ret,min(TX?(X/TX):(1<<30),TY?(Y/TY):(1<<30)));\n\t\t\tret=max(ret,min(SX?(X/SX):(1<<30),SY?(Y/SY):(1<<30)));\n\t\t\tFOR(r,2) {\n\t\t\t\tll mx=0;\n\t\t\t\tfor(j=29;j>=0;j--) {\n\t\t\t\t\t__int128_t lef=(-TX*(mx+(1<<j))+X)*(__int128_t)SY;\n\t\t\t\t\t__int128_t ri=(-TY*(mx+(1<<j))+Y)*(__int128_t)SX;\n\t\t\t\t\tif(lef<ri) mx+=1<<j;\n\t\t\t\t}\n\t\t\t\t//cout<<i<<\":: \"<<SX<<\" \"<<SY<<\" \"<<TX<<\" \"<<TY<<\" \"<<X<<\" \"<<Y<<\" \"<<mx<<\" \"<<ret<<endl;\n\t\t\t\tfor(ll x=max(0LL,mx-2);x<=mx+2;x++) if(x>=0) {\n\t\t\t\t\tll LX=X-TX*x;\n\t\t\t\t\tll LY=Y-TY*x;\n\t\t\t\t\tif(LX>=0&LY>=0) {\n\t\t\t\t\t\tret=max(ret,x+min(SX?(LX/SX):(1<<30),SY?(LY/SY):(1<<30)));\n\t\t\t\t\t\t//cout<<x<<\" \"<<x+min(SX?(LX/SX):(1<<30),SY?(LY/SY):(1<<30))<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout<<i<<\":: \"<<SX<<\" \"<<SY<<\" \"<<TX<<\" \"<<TY<<\" \"<<X<<\" \"<<Y<<\" \"<<mx<<\" \"<<ret<<endl;\n\t\t\t\tswap(TX,SY);\n\t\t\t\tswap(SX,TY);\n\t\t\t\tswap(X,Y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<ret<<endl;\n\t\t\n\t\t\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T, class S> void Dump(map<T, S> &m){\n\tfor(auto e: m) cout << e.first << \" : \" << e.second << '\\n';\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nll div(ll a, ll b, ll mod){ ///////////////////ライブラリにする\n\tll c=b, d=mod, u=1, v=0;\n\twhile (d){\n\t\tll t = c / d;\n\t\tc -= t * d; swap(c, d);\n\t\tu -= t * v; swap(u, v);\n\t}\n\ta = a * u % mod;\n\tif (a < 0) a += mod;\n\treturn a;\n}\n\nvoid solve()\n{\n\tll A, X, B, Y, C;  cin >> A >> X >> B >> Y >> C;\n\n\t{\n\t\tll g=Gcd(Gcd(A, B), C);\n\t\tA/=g;\n\t\tB/=g;\n\t\tC/=g;\n\t}\n\tll a=gcd(A, C);\n\tll b=gcd(B, C);\n\tll x1=b;\n\tll p=C/b-A;\n\tll BB=B/b;\n\tll CC=C/b;\n\tll y1=div(p, BB, CC);\n\n\tll x0=0;\n\tll y0=CC;\n\n\tll t;\n\twhile (true){\n\t\t//(xe,ye)を求める\n\t\tt=y0/(y0-y1);\n\t\tll xe=x0+t*(x1-x0);\n\t\tll ye=y0-t*(y0-y1);\n\n\t\t//(X,Y)を下回ったらbreak\n\t\tif (Y*xe>=X*ye) break;\n\n\t\t//次の(x0,y0),(x1,y1)を求める\n\t\tll xm=x0+(t-1)*(x1-x0);\n\t\tll ym=y0-(t-1)*(y0-y1);\n\t\tx0=xe;\n\t\ty0=ye;\n\t\tll k=CEIL(ym, y0);\n\t\tx1=x0*k-xm;\n\t\ty1=y0*k-ym;\n\t}\n\n\t//出力 (x0,y0), (x1,y1), t\n\n\t//(X,Y)の両脇を求める\n\tll xp, yp, xq, yq;\n\t{\n#if 0\n\t\tll ng=0;\n\t\tll ok=t;\n\t\twhile (abs(ng-ok)>1){\n\t\t\tll m=(ng+ok)/2;\n\t\t\tll xm=x0+m*(x1-x0);\n\t\t\tll ym=y0-m*(y0-y1);\n\t\t\tif (Y*xm>=X*ym) ok=m; else ng=m;\n\t\t}\n#endif\n\t\tll u=x1-x0;\n\t\tll v=y1-y0;\n\t\tll ng=(y0*X-x0*Y-1)/(u*Y-v*X);\n\t\tll ok=ng+1;\n\t\txp=x0+ng*(x1-x0);\n\t\typ=y0-ng*(y0-y1);\n\t\txq=x0+ok*(x1-x0);\n\t\tyq=y0-ok*(y0-y1);\n\t}\n\n\t//両脇(xp,yp),(xq,yq)が何個ずつ取れるか\n\tll ans=0;\n\t{\n#if 0\n\t\tll ng=Y/yp+10;\n\t\tll ok=0;\n\t\twhile (abs(ng-ok)>1){\n\t\t\tll m=(ng+ok)/2;\n\t\t\tll xx=X-xp*m;\n\t\t\tll yy=Y-yp*m;\n\t\t\tif (yy>=0 and xq*yy>=xx*yq) ok=m; else ng=m;\n\t\t}\n#endif\n\t\tll ok = (xq*Y-yq*X)/(xq*yp-xp*yq);\n\t\tll ng=ok+1;\n\t\t{\n\t\t\tll xxx=X-xp*ok;\n\t\t\t//ll yyy=Y-yp*ok;\n\t\t\tll qnm=xxx/xq;\n\t\t\tchmax(ans, ok+qnm);\n\t\t}\n\t\t{\n\t\t\t//ll xxx=X-xp*ng;\n\t\t\tll yyy=Y-yp*ng;\n\t\t\tif (yyy>=0){\n\t\t\t\tll qnm=yyy/yq;\n\t\t\t\tchmax(ans, ng+qnm);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n#if 0\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T, class S> void Dump(map<T, S> &m){\n\tfor(auto e: m) cout << e.first << \" : \" << e.second << '\\n';\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nll div(ll a, ll b, ll mod){ ///////////////////ライブラリにする\n\tll c=b, d=mod, u=1, v=0;\n\twhile (d){\n\t\tll t = c / d;\n\t\tc -= t * d; swap(c, d);\n\t\tu -= t * v; swap(u, v);\n\t}\n\ta = a * u % mod;\n\tif (a < 0) a += mod;\n\treturn a;\n}\n\nvoid solve()\n{\n\tll A, X, B, Y, C;  cin >> A >> X >> B >> Y >> C;\n\n\tif (X>Y){\n\t\tswap(A, B);\n\t\tswap(X, Y);\n\t}\n\t{\n\t\tll g=Gcd(Gcd(A, B), C);\n\t\tA/=g;\n\t\tB/=g;\n\t\tC/=g;\n\t}\n\tll a=gcd(A, C);\n\tll b=gcd(B, C);\n\tll x1=b;\n\tll p=C/b-A;\n\tll BB=B/b;\n\tll CC=C/b;\n\tll y1=div(p, BB, CC);\n\n\tll x0=0;\n\tll y0=CC;\n\n\tll t;\n\twhile (true){\n\t\t//(xe,ye)を求める\n\t\tt=y0/(y0-y1);\n\t\tll xe=x0+t*(x1-x0);\n\t\tll ye=y0-t*(y0-y1);\n\n\t\t//(X,Y)を下回ったらbreak\n\t\tif (Y*xe>=X*ye) break;\n\n\t\t//次の(x0,y0),(x1,y1)を求める\n\t\tll xm=x0+(t-1)*(x1-x0);\n\t\tll ym=y0-(t-1)*(y0-y1);\n\t\tx0=xe;\n\t\ty0=ye;\n\t\tll k=CEIL(ym, y0);\n\t\tx1=x0*k-xm;\n\t\ty1=y0*k-ym;\n\t}\n\n\t//出力 (x0,y0), (x1,y1), t\n\n\t//(X,Y)の両脇を求める\n\tll xp, yp, xq, yq;\n\t{\n\t\tll ng=0;\n\t\tll ok=t;\n\t\twhile (abs(ng-ok)>1){\n\t\t\tll m=(ng+ok)/2;\n\t\t\tll xm=x0+m*(x1-x0);\n\t\t\tll ym=y0-m*(y0-y1);\n\t\t\tif (Y*xm>=X*ym) ok=m; else ng=m;\n\t\t}\n\t\txp=x0+ng*(x1-x0);\n\t\typ=y0-ng*(y0-y1);\n\t\txq=x0+ok*(x1-x0);\n\t\tyq=y0-ok*(y0-y1);\n\t}\n\n\t//両脇(xp,yp),(xq,yq)が何個ずつ取れるか\n\tll ans=0;\n\t{\n\t\tll ng=Y/yp+10;\n\t\tll ok=0;\n\t\twhile (abs(ng-ok)>1){\n\t\t\tll m=(ng+ok)/2;\n\t\t\tll xx=X-xp*m;\n\t\t\tll yy=Y-yp*m;\n\t\t\tif (yy>=0 and xq*yy>=xx*yq) ok=m; else ng=m;\n\t\t}\n\t\t{\n\t\t\tll xxx=X-xp*ok;\n\t\t\t//ll yyy=Y-yp*ok;\n\t\t\tll qnm=xxx/xq;\n\t\t\tchmax(ans, ok+qnm);\n\t\t}\n\t\t{\n\t\t\t//ll xxx=X-xp*ng;\n\t\t\tll yyy=Y-yp*ng;\n\t\t\tif (yyy>=0){\n\t\t\t\tll qnm=yyy/yq;\n\t\t\t\tchmax(ans, ng+qnm);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n#if 0\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\ninline int exgcd(int a,int b,int &x,int &y){\n\tif (!b) return x=1,y=0,a;\n\tint g=exgcd(b,a%b,y,x);\n\treturn y-=a/b*x,g;\n}\ninline int inv(int A,int mod){\n\tint x,y;\n\texgcd(A,mod,x,y);\n\treturn x<0?x+mod:x;\n}\n\nint A,B,C,D,X,Y;\n\ninline void init(){\n\tint g=__gcd(__gcd(A,B),C);\n\tA/=g,B/=g,C/=g;\n\tg=__gcd(A,C),Y/=g,C/=g,A/=g;\n\tg=__gcd(B,C),X/=g,C/=g,B/=g;\n}\nvector<int>x,cnt;\ninline void Get(){\n\tD=1ll*A*inv(B,C)%C,x.clear(),cnt.clear();\n\tint W=C,H=D,now=0,invD=inv(D,C);\n\twhile (W){\n\t\tint tmp=W/H;\n\t\tcnt.pb(tmp),x.pb(1ll*now*invD%C),now+=tmp*H;\n\t\tW%=H;\n\t\tif (!W) break;\n\t\tH%=W;\n\t\tif (H==0) H=W;\n\t}\n\tx.pb(C),cnt.pb(0);\n}\ninline ll Div(ll x,ll y){\n\treturn x/y-(x%y&&(x^y)<0);\n}\ninline int Get(int x){\n\treturn x==0?C:(C-1ll*x*D%C)%C;\n}\ninline void solve(){\n\tA=read(),X=read(),B=read(),Y=read(),C=read();\n\tinit(),Get();\n\tll ans=0;\n\tFOR(i,0,siz(x)-2){\n\t\tint lx=x[i],ly=Get(lx),rx=x[i+1],ry=Get(rx),dx=(rx-lx)/cnt[i],dy=(ly-ry)/cnt[i];\n\t\tll l=0,r=X+Y,ret=0;\n\t\twhile (l<=r){\n\t\t\tll mid=l+r>>1;\n\t\t\tif (X-mid*lx>=0&&Y-mid*ry>=0){\n\t\t\t\tll a=(X-mid*lx)/dx,b=(Y-mid*ry)/dy;\n\t\t\t\tif (a>=0&&b>=0&&a+b>=mid*cnt[i]) l=mid+1,ret=mid;\n\t\t\t\t\telse r=mid-1;\n\t\t\t} else r=mid-1;\n\t\t}\n\t\tans=max(ans,ret);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\tint T=read();\n\twhile (T--) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprlong longf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; long long f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntemplate<class T> inline bool Cmax(T &x,T y) {return x<y?x=y,1:0;} \ntypedef long long ll;\nlong long T,A,X,B,Y,C,D;\nvector<long long> pos,cnt;\nlong long gcd(long long a,long long b) {return b==0?a:gcd(b,a%b);}\nlong long exgcd(long long a,long long b,long long &x,long long &y) {\n\tif(b==0) {x=1,y=0; return a;}\n\tlong long d=exgcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\ninline long long inver(long long a,long long mod) {\n\tlong long x,y,d=exgcd(a,mod,x,y);\n\tif(x<0) x+=mod;\n\treturn x;\n}\ninline ll lowdiv(ll a,ll b) {return a/b-(a%b&&(a^b)<0);}\nvoid init() {\n\tlong long d=gcd(A,B);\n\tA/=d,B/=d,C/=gcd(d,C);\n\tfor(long long _=0;_<2;++_) {\n\t\td=gcd(A,C);\n\t\tC/=d,A/=d;\n\t\tlong long t=gcd(B,d);\n\t\tB/=t,Y/=d/t;\n\t\tswap(A,B),swap(X,Y);\n\t}\n}\nvoid getpos() {\n\tpos.clear(),cnt.clear();\n\tlong long W=C,H=D,now=0,r=inver(D,C);\n\twhile(W) {\n\t\tlong long d=W/H;\n\t\tpos.push_back((ll)now*r%C),cnt.push_back(d); \n\t\tnow+=d*H;\n\t\tW%=H; if(W==0) break;\n\t\tH%=W; if(H==0) H=W;\n\t}\n\tpos.push_back(C);\n}\ninline long long gety(long long x) {return C-(ll)x*D%C;}\nint main() {\n\trd(T);\n\tfor(long long kase=1;kase<=T;++kase) {\n\t\trd(A),rd(X),rd(B),rd(Y),rd(C);\n\t\tinit();\n\t\tif(C==1) {printf(\"%d\\n\",X+Y); continue;}\n\t\tD=(ll)A*inver(B,C)%C;\n\t\tgetpos();\n\t\tlong long an=0;\n\t\tfor(long long i=0;i<cnt.size();++i) {\n\t\t\tlong long xl=pos[i],xr=pos[i+1],yl=gety(xl),yr=gety(xr);\n\t\t\tlong long dx=(xr-xl)/cnt[i],dy=(yl-yr)/cnt[i];\n\t\t\tlong long l=0,r=X+Y,re=-1;\n\t\t\twhile(l<=r) {\n\t\t\t\tlong long mid=(l+r)>>1;\n\t\t\t\tll p=lowdiv(X-(ll)xl*mid,dx),q=lowdiv(Y-(ll)yr*mid,dy);\n\t\t\t\tif(p>=0&&q>=0&&p+q>=cnt[i]*mid) re=mid,l=mid+1;\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tCmax(an,re);\n\t\t}\n\t\tprintf(\"%d\\n\",an);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntemplate<class T> inline bool Cmax(T &x,T y) {return x<y?x=y,1:0;} \ntypedef long long ll;\nint T,A,X,B,Y,C,D;\nint gcd(int a,int b) {return b==0?a:gcd(b,a%b);}\nint exgcd(int a,int b,int &x,int &y) {\n\tif(b==0) {x=1,y=0; return a;}\n\telse exgcd(b,a%b,y,x),y-=a/b*x;\n}\ninline int inver(int a,int mod) {\n\tint x,y; exgcd(a,mod,x,y);\n\tif(x<0) x+=mod;\n\treturn x;\n}\ninline ll lowdiv(ll a,ll b) {return a/b-(a%b&&(a^b)<0);}\ninline int gety(int x) {return x==0?C:(C-(ll)x*D%C)%C;}\nint main() {\n\trd(T);\n\tfor(int kase=1;kase<=T;++kase) {\n\t\trd(A),rd(X),rd(B),rd(Y),rd(C);\n\t\t{\n\t\t\tint d=gcd(A,B);\n\t\t\tA/=d,B/=d,C/=gcd(d,C);\n\t\t\tfor(int _=0;_<2;++_) {\n\t\t\t\td=gcd(A,C);\n\t\t\t\tC/=d,A/=d;\n\t\t\t\tint t=gcd(B,d);\n\t\t\t\tB/=t,Y/=d/t;\n\t\t\t\tswap(A,B),swap(X,Y);\n\t\t\t}\n\t\t}\n\t\tif(C==1) {printf(\"%d\\n\",X+Y); continue;}\n\t\tD=(ll)A*inver(B,C)%C;\n\t\tvector<int> pos,cnt;\n\t\t{\n\t\t\tint W=C,H=D,now=0,r=inver(D,C);\n\t\t\twhile(W) {\n\t\t\t\tint d=W/H;\n\t\t\t\tpos.push_back((ll)now*r%C),cnt.push_back(d); \n\t\t\t\tnow+=d*H;\n\t\t\t\tW%=H; if(W==0) break;\n\t\t\t\tH%=W; if(H==0) H=W;\n\t\t\t}\n\t\t\tpos.push_back(C);\n\t\t} \n\t\tint an=0;\n\t\tfor(int i=0;i<cnt.size();++i) {\n\t\t\tint xl=pos[i],xr=pos[i+1],yl=gety(xl),yr=gety(xr);\n\t\t\tint dx=(xr-xl)/cnt[i],dy=(yl-yr)/cnt[i];\n\t\t\tint l=0,r=X+Y,re=-1;\n\t\t\twhile(l<=r) {\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tll p=lowdiv(X-(ll)xl*mid,dx),q=lowdiv(Y-(ll)yr*mid,dy);\n\t\t\t\tif(p>=0&&q>=0&&p+q>=(ll)cnt[i]*mid) re=mid,l=mid+1;\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tCmax(an,re);\n\t\t}\n\t\tprintf(\"%d\\n\",an);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint T;\nll A,X,B,Y,C,TC;\n\nll totient(ll v) {\n\tll ret=v;\n\tfor(ll i=2;i*i<=v;i++) if(v%i==0) {\n\t\tret=ret/i*(i-1);\n\t\twhile(v%i==0) v/=i;\n\t}\n\tif(v>1) ret=ret/v*(v-1);\n\treturn ret;\n}\n\nll modpow(ll a, ll n,ll mo) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>T;\n\twhile(T--) {\n\t\tcin>>A>>X>>B>>Y>>C;\n\t\tll g=__gcd(A,B),g2;\n\t\t\n\t\tA/=g;\tB/=g;\tC/=__gcd(g,C);\n\t\tg=__gcd(A,C);\tA/=g;\tC/=g;\tg2=gcd(B,g);\tB/=g2;\tY/=g/g2;\n\t\tg=__gcd(B,C);\tB/=g;\tC/=g;\tg2=gcd(A,g);\tA/=g2;\tX/=g/g2;\n\t\tif(C==1) {\n\t\t\tcout<<X+Y<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tA%=C;\n\t\tB%=C;\n\t\t\n\t\tTC=totient(C);\n\t\t\n\t\tvector<pair<ll,ll>> cand;\n\t\tll D=A*modpow(B,TC-1,C)%C;\n\t\tcand.push_back({0,C});\n\t\tll H=D,W=0;\n\t\twhile(1) {\n\t\t\tH%=(C-W);\n\t\t\tif(H==0) break;\n\t\t\tll dif=(C-W)%H;\n\t\t\tif(dif==0) break;\n\t\t\tW=C-dif;\n\t\t\tll X=W*modpow(D,TC-1,C)%C;\n\t\t\tll Y=(C-D*X%C)%C;\n\t\t\tcand.push_back({X,Y});\n\t\t}\n\t\tcand.push_back({C,0});\n\t\t\n\t\tll ret=0;\n\t\t//cout<<A<<\" \"<<X<<\" \"<<B<<\" \"<<Y<<\" \"<<C<<endl;\n\t\tFORR(c,cand) {\n\t\t\t//cout<<c.first<<\" \"<<c.second<<endl;\n\t\t\tif(c.first==0) ret=max(ret,Y/c.second);\n\t\t\telse if(c.second==0) ret=max(ret,X/c.first);\n\t\t\telse ret=max(ret,min(X/c.first,Y/c.second));\n\t\t}\n\t\tFOR(i,cand.size()-1) {\n\t\t\tll AX=cand[i].first,AY=cand[i].second;\n\t\t\tll BX=cand[i+1].first,BY=cand[i+1].second;\n\t\t\tif(AY*X<=AX*Y || BY*X>=BX*Y) continue;\n\t\t\tll step=__gcd(BX-AX,AY-BY);\n\t\t\tll dx=(BX-AX)/step;\n\t\t\tll dy=(BY-AY)/step;\n\t\t\t\n\t\t\tint cur=0;\n\t\t\tfor(j=29;j>=0;j--) if(cur+(1<<j)<step) {\n\t\t\t\tll CX=AX+(cur+(1<<j))*dx;\n\t\t\t\tll CY=AY+(cur+(1<<j))*dy;\n\t\t\t\tif(CY*X>CX*Y) cur+=1<<j;\n\t\t\t}\n\t\t\tll TX=AX+cur*dx;\n\t\t\tll TY=AY+cur*dy;\n\t\t\tll SX=TX+dx;\n\t\t\tll SY=TY+dy;\n\t\t\tll mx=0;\n\t\t\tfor(j=29;j>=0;j--) {\n\t\t\t\tll lef=(-TX*(mx+(1<<j))+X)*SY;\n\t\t\t\tll ri=(-TY*(mx+(1<<j))+Y)*SX;\n\t\t\t\tif(lef<ri) mx+=1<<j;\n\t\t\t}\n\t\t\tret=max(ret,min(TX?(X/TX):(1<<30),TY?(Y/TY):(1<<30)));\n\t\t\tret=max(ret,min(SX?(X/SX):(1<<30),SY?(Y/SY):(1<<30)));\n\t\t\t//cout<<i<<\":: \"<<SX<<\" \"<<SY<<\" \"<<TX<<\" \"<<TY<<\" \"<<X<<\" \"<<Y<<\" \"<<mx<<\" \"<<ret<<endl;\n\t\t\tfor(x=mx-1;x<=mx+1;x++) if(x>=0) {\n\t\t\t\tll LX=X-TX*x;\n\t\t\t\tll LY=Y-TY*x;\n\t\t\t\tif(LX>=0&LY>=0) ret=max(ret,x+min(SX?(LX/SX):(1<<30),SY?(LY/SY):(1<<30)));\n\t\t\t}\n\t\t\t//cout<<ret<<endl;\n\t\t\t\n\t\t}\n\t\t\n\t\tcout<<ret<<endl;\n\t\t\n\t\t\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nint A, X, B, Y, C, G, D;\n\nvoid exgcd(int a, int b, int &x, int &y) {\n\tif (!b) {\n\t\tx = 1, y = 0;\n\t\treturn;\n\t}\n\texgcd(b, a % b, y, x);\n\ty -= a / b * x;\n}\n\nint inv(int a, int p) {\n\tint x, y;\n\texgcd(a, p, x, y);\n\treturn (x % p + p) % p;\n}\n\nint gety(int x) {\n\tif (x == 0) {\n\t\treturn C;\n\t}\n\treturn (C - 1ll * D * x % C) % C;\n}\n\nvoid solve() {\n\tread(A), read(X), read(B), read(Y), read(C);\n\tG = std::__gcd(A, B), A /= G, B /= G, C /= std::__gcd(C, G);\n\tG = std::__gcd(A, C), A /= G, C /= G, Y /= G;\n\tG = std::__gcd(B, C), B /= G, C /= G, X /= G;\n\tA %= C, B %= C;\n\tif (C == 1) {\n\t\tprint(X + Y);\n\t\treturn;\n\t}\n\tD = 1ll * A * inv(B, C) % C;\n\n\tstd::vector<int> pos, cnt;\n\tint W = C, H = D, now = 0, invD = inv(D, C);\n\twhile (W) {\n\t\tH = (H - 1) % W + 1;\n\t\tint t = W / H;\n\t\tpos.push_back(1ll * now * invD % C);\n\t\tcnt.push_back(t);\n\t\tnow += t * H;\n\t\tW -= t * H;\n\t}\n\tpos.push_back(C);\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < (int)cnt.size(); ++i) {\n\t\tint lx = pos[i], ly = gety(lx);\n\t\tint rx = pos[i + 1], ry = gety(rx);\n\t\tint dx = (rx - lx) / cnt[i];\n\t\tint dy = (ly - ry) / cnt[i];\n\t\t// debug(\"%d %d %d %d %d %d\\n\", lx, ly, rx, ry, dx, dy);\n\n\t\tlong long l = 0, r = X + Y, s = 0;\n\t\twhile (l <= r) {\n\t\t\tlong long md = (l + r) >> 1;\n\t\t\tlong long p = X - lx * md, q = Y - ry * md;\n\t\t\tif (p >= 0 && q >= 0 && p / dx + q / dy >= cnt[i] * md) {\n\t\t\t\ts = md, l = md + 1;\n\t\t\t} else {\n\t\t\t\tr = md - 1;\n\t\t\t}\n\t\t}\n\t\tans = std::max(ans, s);\n\t}\n\tprint(ans);\n}\n\nint main() {\n\tint T = 1;\n\tread(T);\n\twhile (T--) {\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \n//int cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n/**\n * Description: euclid finds ${x,y}$ such that $ax+by=\\gcd(a,b)$ \n \t* and $|ax|,|by|\\le \\frac{ab}{\\gcd(a,b)}.$ Should work for $a,b<2^{62}$\n * Source: KACTL\n * Time: O(\\log ab)\n */\n\npl euclid(ll a, ll b) { \n\tif (!b) return {1,0};\n\tpl p = euclid(b,a%b); return {p.s,p.f-a/b*p.s}; }\nll invGen(ll a, ll b) { \n\tpl p = euclid(a,b); assert(p.f*a+p.s*b == 1); // gcd is 1\n\treturn p.f+(p.f<0)*b; }\n\n/**\n * Description: finds smallest $x\\ge 0$ such that $L\\le Ax\\pmod{P}\\le R$\n * Source: https://codeforces.com/gym/102411/submission/64315879\n * Verification: https://codeforces.com/gym/102411/problem/G\n */\n\nll cdiv(ll x, ll y) { return (x+y-1)/y; }\nll bet(ll P, ll A, ll L, ll R) { \n\tif (A == 0) return L == 0 ? 0 : -1;\n\tll c = cdiv(L,A); if (A*c <= R) return c;\n\tll B = P%A; // P = k*A+B, L <= A(x-Ky)-By <= R \n\t// => -R <= By % A <= -L\n\tauto y = bet(A,B,A-R%A,A-L%A); \n\treturn y == -1 ? y : cdiv(L+B*y,A)+P/A*y;\n}\n\n\nint solve(ll A, ll X, ll B, ll Y, ll C) {\n\tll g = __gcd(A,B);\n\tA /= g, B /= g; C /= __gcd(g,C);\n\tF0R(i,2) {\n\t\tint t = __gcd(A,C);\n\t\tY /= t; A /= t, C /= t;\n\t\tswap(A,B); swap(X,Y);\n\t}\n\tassert(__gcd(A,B) == 1 && __gcd(B,C) == 1 && __gcd(C,A) == 1);\n\t//dbg(\"OK\",A,B,C,X,Y);\n\tif (C == 1) return X+Y;\n\tvpi posi; posi.pb({0,C});\n\tvi step;\n\tint con = -1LL*A*invGen(B,C)%C; con = (con+C)%C;\n\twhile (posi.bk.s) {\n\t\tpi a = posi.bk;\n\t\tint L = 1, R = a.s-1; if (L > R) break;\n\t\tll x = bet(C,con,L,R); if (x == -1) break;\n\t\tpi b = {x,con*x%C};\n\t\tint ti = a.s/(a.s-b.s); if (a.s%(a.s-b.s) == 0) ti --;\n\t\tpi c = {a.f+ti*(b.f-a.f),a.s+ti*(b.s-a.s)}; assert(c.s > 0 && c.s <= a.s-b.s);\n\t\tposi.pb(c); step.pb(ti);\n\t\t//dbg(\"OOPS\",a,b,ti);\n\t\t// int rem = con*x%C; \n\t\t// int dem = C-con;\n\t\t// int times = rem/dem-(rem%dem == 0);\n\t\t// posi.pb({{x,}});\n\t\t// dbg(\"HAHA\",posi.bk);\n\t\t// 0 < (-A*x)*B^{-1} < posi.bk.s mod C\n\t}\n\tassert(posi.bk.s < C);\n\tstep.pb(1);\n\tposi.pb({C,0});\n\t//dbg(\"HA\",posi);\n\tll ans = 0;\n\tF0R(i,sz(posi)-1) {\n\t\tpi a = posi[i], b = posi[i+1];\n\t\tint g = step[i]; // dbg(\"G\",g);\n\t\tpi d = {(b.f-a.f)/g,(a.s-b.s)/g}; assert(d.f > 0 && d.s > 0);\n\t\tauto ok = [&](ll mid) -> bool {\n\t\t\tif (a.f*mid > X || b.s*mid > Y) return 0;\n\t\t\tll L = 0, R = g*mid;\n\t\t\tif (b.f*mid > X) ckmin(R,(X-a.f*mid)/d.f);\n\t\t\tif (a.s*mid > Y) ckmax(L,cdiv(a.s*mid-Y,d.s));\n\t\t\treturn L <= R;\n\t\t};\n\t\tll lo = 0, hi = X+Y;\n\t\twhile (lo < hi) {\n\t\t\tll mid = (lo+hi+1)/2;\n\t\t\tif (ok(mid)) lo = mid;\n\t\t\telse hi = mid-1;\n\t\t}\n\t\t//dbg(\"AH\",a,b,lo,g);\n\t\tckmax(ans,lo);\n\t}\n\treturn ans;\n}\n\n\nint good(ll A, ll X, ll B, ll Y, ll C) {\n\tll g = __gcd(A,B);\n\tA /= g, B /= g; C /= __gcd(g,C);\n\tF0R(i,2) {\n\t\tint t = __gcd(A,C);\n\t\tY /= t; A /= t, C /= t;\n\t\tswap(A,B); swap(X,Y);\n\t}\n\tassert(__gcd(A,B) == 1 && __gcd(B,C) == 1 && __gcd(C,A) == 1);\n\t//dbg(\"OK\",A,B,C,X,Y);\n\tif (C == 1) return X+Y;\n\tvpi posi; posi.pb({0,C});\n\tint con = -1LL*A*invGen(B,C)%C; con = (con+C)%C;\n\t//dbg(\"START LOOP\");\n\twhile (1) {\n\t\tint L = 1, R = posi.bk.s-1; if (L > R) break;\n\t\tll x = bet(C,con,L,R); if (x == -1) break;\n\t\tposi.pb({x,con*x%C});\n\t\t//dbg(\"HAHA\",posi.bk);\n\t\t// 0 < (-A*x)*B^{-1} < posi.bk.s mod C\n\t}\n\t//dbg(\"END LOOP\");\n\tposi.pb({C,0});\n\t//dbg(posi);\n\tll ans = 0;\n\ttrav(t,posi) {\n\t\tll mul = INF;\n\t\tif (t.f) ckmin(mul,X/t.f);\n\t\tif (t.s) ckmin(mul,Y/t.s);\n\t\tckmax(ans,mul);\n\t}\n\tdbg(\"HAHA\",posi);\n\tF0R(i,sz(posi)-1) {\n\t\tpi a = posi[i], b = posi[i+1];\n\t\tauto ok = [&](ll mid) -> bool {\n\t\t\tif (a.f*mid > X || b.s*mid > Y) return 0;\n\t\t\tll L = 0, R = mid;\n\t\t\tif (b.f*mid > X) {\n\t\t\t\t// a.f*x+b.f*(mid-x) <= X\n\t\t\t\t// (a.f-b.f)*x+b.f*mid <= X\n\t\t\t\t// x*(b.f-a.f) >= b.f*mid-X\n\t\t\t\tL = cdiv(b.f*mid-X,b.f-a.f);\n\t\t\t}\n\t\t\tif (a.s*mid > Y) {\n\t\t\t\t// a.s*x+b.s*(mid-x) <= Y\n\t\t\t\t// (a.s-b.s)*x <= Y-b.s*mid\n\t\t\t\tR = (Y-b.s*mid)/(a.s-b.s);\n\t\t\t}\n\t\t\treturn L <= R;\n\t\t};\n\t\tll lo = 0, hi = X+Y;\n\t\twhile (lo < hi) {\n\t\t\tll mid = (lo+hi+1)/2;\n\t\t\tif (ok(mid)) lo = mid;\n\t\t\telse hi = mid-1;\n\t\t}\n\t\tdbg(a,b,lo);\n\t\tckmax(ans,lo);\n\t}\n\t// dbg(\"HA\",posi);\n\treturn ans;\n\t// Ax+By is divisible by C\n\t// what if gcd(A,C) > 1?\n\t// gcd(B,C) > 1?\n}\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) {\n\t\tll A,X,B,Y,C; re(A,X,B,Y,C);\n\t\tll x = solve(A,X,B,Y,C);\n\t\tps(x);\n\t\t//dbg(x);\n\t\t/*ll y = good(A,X,B,Y,C);\n\t\tif (x != y) {\n\t\t\tdbg(\"OOPS\",A,X,B,Y,C);\n\t\t\tdbg(x,y);\n\t\t\texit(0);\n\t\t}*/\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\ninline int exgcd(int a,int b,int &x,int &y){\n\tif (!b) return x=1,y=0,a;\n\tint g=exgcd(b,a%b,y,x);\n\treturn y-=a/b*x,g;\n}\ninline int inv(int A,int mod){\n\tint x,y;\n\texgcd(A,mod,x,y);\n\treturn x<0?x+mod:x;\n}\n\nint A,B,C,D,X,Y;\n\ninline void init(){\n\tint g=__gcd(__gcd(A,B),C);\n\tA/=g,B/=g,C/=g;\n\tg=__gcd(A,C),Y/=g,C/=g,A/=g;\n\tg=__gcd(B,C),X/=g,C/=g,B/=g;\n}\nvector<int>x,cnt;\ninline void Get(){\n\tD=1ll*A*inv(B,C)%C,x.clear(),cnt.clear();\n\tint W=C,H=D,now=0,invD=inv(D,C);\n\twhile (W){\n\t\tint tmp=W/H;\n\t\tcnt.pb(tmp),x.pb(1ll*now*invD%C),now+=tmp*H;\n\t\tW%=H;\n\t\tif (!W) break;\n\t\tH%=W;\n\t\tif (H==0) H=W;\n\t}\n\tx.pb(C),cnt.pb(0);\n}\ninline ll Div(ll x,ll y){\n\treturn x/y-(x%y&&(x^y)<0);\n}\ninline int Get(int x){\n\treturn x==0?C:(C-1ll*x*D%C)%C;\n}\ninline void solve(){\n\tA=read(),X=read(),B=read(),Y=read(),C=read();\n\tinit(),Get();\n\tll ans=0;\n\tFOR(i,0,siz(x)-1){\n\t\tint lx=x[i],ly=Get(lx),rx=x[i+1],ry=Get(rx),dx=(rx-lx)/cnt[i],dy=(ly-ry)/cnt[i];\n\t\tll l=0,r=X+Y,ret=0;\n\t\twhile (l<=r){\n\t\t\tll mid=l+r>>1;\n\t\t\tif (X-mid*lx>=0&&Y-mid*ry>=0){\n\t\t\t\tll a=(X-mid*lx)/dx,b=(Y-mid*ry)/dy;\n\t\t\t\tif (a>=0&&b>=0&&a+b>=mid*cnt[i]) l=mid+1,ret=mid;\n\t\t\t\t\telse r=mid-1;\n\t\t\t} else r=mid-1;\n\t\t}\n\t\tans=max(ans,ret);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\tint T=read();\n\twhile (T--) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint T;\nll A,X,B,Y,C,TC;\n\nll totient(ll v) {\n\tll ret=v;\n\tfor(ll i=2;i*i<=v;i++) if(v%i==0) {\n\t\tret=ret/i*(i-1);\n\t\twhile(v%i==0) v/=i;\n\t}\n\tif(v>1) ret=ret/v*(v-1);\n\treturn ret;\n}\n\nll modpow(ll a, ll n,ll mo) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>T;\n\twhile(T--) {\n\t\tcin>>A>>X>>B>>Y>>C;\n\t\tll g=__gcd(A,B),g2;\n\t\t\n\t\tA/=g;\tB/=g;\tC/=__gcd(g,C);\n\t\tg=__gcd(A,C);\tA/=g;\tC/=g;\tg2=gcd(B,g);\tB/=g2;\tY/=g/g2;\n\t\tg=__gcd(B,C);\tB/=g;\tC/=g;\tg2=gcd(A,g);\tA/=g2;\tX/=g/g2;\n\t\tif(C==1) {\n\t\t\tcout<<X+Y<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tA%=C;\n\t\tB%=C;\n\t\t\n\t\tTC=totient(C);\n\t\t\n\t\tvector<pair<ll,ll>> cand;\n\t\tll D=A*modpow(B,TC-1,C)%C;\n\t\tcand.push_back({0,C});\n\t\tll H=D,W=0;\n\t\twhile(1) {\n\t\t\tH%=(C-W);\n\t\t\tif(H==0) break;\n\t\t\tll dif=(C-W)%H;\n\t\t\tif(dif==0) break;\n\t\t\tW=C-dif;\n\t\t\tll X=W*modpow(D,TC-1,C)%C;\n\t\t\tll Y=(C-D*X%C)%C;\n\t\t\tcand.push_back({X,Y});\n\t\t}\n\t\tcand.push_back({C,0});\n\t\t\n\t\tll ret=0;\n\t\t//cout<<A<<\" \"<<X<<\" \"<<B<<\" \"<<Y<<\" \"<<C<<endl;\n\t\tFORR(c,cand) {\n\t\t\t//cout<<c.first<<\" \"<<c.second<<endl;\n\t\t\tif(c.first==0) ret=max(ret,Y/c.second);\n\t\t\telse if(c.second==0) ret=max(ret,X/c.first);\n\t\t\telse ret=max(ret,min(X/c.first,Y/c.second));\n\t\t}\n\t\tFOR(i,cand.size()-1) {\n\t\t\tll AX=cand[i].first,AY=cand[i].second;\n\t\t\tll BX=cand[i+1].first,BY=cand[i+1].second;\n\t\t\tif(AY*X<=AX*Y || BY*X>=BX*Y) continue;\n\t\t\tll step=__gcd(BX-AX,AY-BY);\n\t\t\tll dx=(BX-AX)/step;\n\t\t\tll dy=(BY-AY)/step;\n\t\t\t\n\t\t\tint cur=0;\n\t\t\tfor(j=29;j>=0;j--) if(cur+(1<<j)<step) {\n\t\t\t\tll CX=AX+(cur+(1<<j))*dx;\n\t\t\t\tll CY=AY+(cur+(1<<j))*dy;\n\t\t\t\tif(CY*X>CX*Y) cur+=1<<j;\n\t\t\t}\n\t\t\tll TX=AX+cur*dx;\n\t\t\tll TY=AY+cur*dy;\n\t\t\tll SX=TX+dx;\n\t\t\tll SY=TY+dy;\n\t\t\tll mx=0;\n\t\t\tfor(j=29;j>=0;j--) {\n\t\t\t\tll lef=(-TX*(mx+(1<<j))+X)*SY;\n\t\t\t\tll ri=(-TY*(mx+(1<<j))+Y)*SX;\n\t\t\t\tif(lef<ri) mx+=1<<j;\n\t\t\t}\n\t\t\tret=max(ret,min(TX?X/TX:1<<30,TY?Y/TY:1<<30));\n\t\t\tret=max(ret,min(SX?X/SX:1<<30,SY?Y/SY:1<<30));\n\t\t\t//cout<<i<<\":: \"<<SX<<\" \"<<SY<<\" \"<<TX<<\" \"<<TY<<\" \"<<X<<\" \"<<Y<<\" \"<<mx<<\" \"<<ret<<endl;\n\t\t\tfor(x=mx-1;x<=mx+1;x++) if(x>=0) {\n\t\t\t\tll LX=X-SX*x;\n\t\t\t\tll LY=Y-SY*x;\n\t\t\t\tif(LX>=0&LY>=0) ret=max(ret,x+min(TX?LX/TX:1<<30,TY?LY/TY:1<<30));\n\t\t\t}\n\t\t\t//cout<<ret<<endl;\n\t\t\t\n\t\t}\n\t\t\n\t\tcout<<ret<<endl;\n\t\t\n\t\t\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \n//int cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n/**\n * Description: euclid finds ${x,y}$ such that $ax+by=\\gcd(a,b)$ \n \t* and $|ax|,|by|\\le \\frac{ab}{\\gcd(a,b)}.$ Should work for $a,b<2^{62}$\n * Source: KACTL\n * Time: O(\\log ab)\n */\n\npl euclid(ll a, ll b) { \n\tif (!b) return {1,0};\n\tpl p = euclid(b,a%b); return {p.s,p.f-a/b*p.s}; }\nll invGen(ll a, ll b) { \n\tpl p = euclid(a,b); assert(p.f*a+p.s*b == 1); // gcd is 1\n\treturn p.f+(p.f<0)*b; }\n\n/**\n * Description: finds smallest $x\\ge 0$ such that $L\\le Ax\\pmod{P}\\le R$\n * Source: https://codeforces.com/gym/102411/submission/64315879\n * Verification: https://codeforces.com/gym/102411/problem/G\n */\n\nll cdiv(ll x, ll y) { return (x+y-1)/y; }\nll bet(ll P, ll A, ll L, ll R) { \n\tif (A == 0) return L == 0 ? 0 : -1;\n\tll c = cdiv(L,A); if (A*c <= R) return c;\n\tll B = P%A; // P = k*A+B, L <= A(x-Ky)-By <= R \n\t// => -R <= By % A <= -L\n\tauto y = bet(A,B,A-R%A,A-L%A); \n\treturn y == -1 ? y : cdiv(L+B*y,A)+P/A*y;\n}\n\n\nll A,X,B,Y,C;\nint solve() {\n\tre(A,X,B,Y,C);\n\tll g = __gcd(A,B);\n\tA /= g, B /= g; C /= __gcd(g,C);\n\tF0R(i,2) {\n\t\tint t = __gcd(A,C);\n\t\tY /= t; A /= t, C /= t;\n\t\tswap(A,B); swap(X,Y);\n\t}\n\tassert(__gcd(A,B) == 1 && __gcd(B,C) == 1 && __gcd(C,A) == 1);\n\tdbg(\"OK\",A,B,C,X,Y);\n\tif (C == 1) return X+Y;\n\tvpi posi; posi.pb({0,C});\n\tint con = -1LL*A*invGen(B,C)%C; con = (con+C)%C;\n\twhile (posi.bk.s) {\n\t\tpi a = posi.bk;\n\t\tint L = 1, R = a.s-1; if (L > R) break;\n\t\tll x = bet(C,con,L,R); if (x == -1) break;\n\t\tpi b = {x,con*x%C};\n\t\tint ti = a.s/(a.s-b.s); if (a.s%(a.s-b.s) == 0) ti --;\n\t\tpi c = {a.f+ti*(b.f-a.f),a.s+ti*(b.s-a.s)}; assert(c.s > 0 && c.s <= a.s-b.s);\n\t\tposi.pb(c);\n\t\t// int rem = con*x%C;\n\t\t// int dem = C-con;\n\t\t// int times = rem/dem-(rem%dem == 0);\n\t\t// posi.pb({{x,}});\n\t\t// dbg(\"HAHA\",posi.bk);\n\t\t// 0 < (-A*x)*B^{-1} < posi.bk.s mod C\n\t}\n\tassert(posi.bk.s < C);\n\tposi.pb({C,0});\n\tll ans = 0;\n\tF0R(i,sz(posi)-1) {\n\t\tpi a = posi[i], b = posi[i+1];\n\t\tint g = __gcd(b.f-a.f,a.s-b.s);\n\t\tpi d = {(b.f-a.f)/g,(a.s-b.s)/g}; assert(d.f > 0 && d.s > 0);\n\t\tauto ok = [&](ll mid) -> bool {\n\t\t\tif (a.f*mid > X || b.s*mid > Y) return 0;\n\t\t\tll L = 0, R = g*mid;\n\t\t\tif (b.f*mid > X) ckmin(R,(X-a.f*mid)/d.f);\n\t\t\tif (a.s*mid > Y) ckmax(L,cdiv(a.s*mid-Y,d.s));\n\t\t\treturn L <= R;\n\t\t};\n\t\tll lo = 0, hi = X+Y;\n\t\twhile (lo < hi) {\n\t\t\tll mid = (lo+hi+1)/2;\n\t\t\tif (ok(mid)) lo = mid;\n\t\t\telse hi = mid-1;\n\t\t}\n\t\tckmax(ans,lo);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) ps(solve());\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\n#define int long long\nusing namespace std;\nint A,B,C,X,Y,H,G,D;\nint top,q1[555],q2[555],q3[555];\nint gcd(int x,int y){\n\treturn y?gcd(y,x%y):x;\n}\nvoid exgcd(int x,int y,int &a,int &b){\n\tif (!y){\n\t\ta=1; b=0;\n\t\treturn;\n\t}\n\texgcd(y,x%y,b,a);\n\tb-=x/y*a;\n}\nint getinv(int x,int y){\n\tint a,b;\n\texgcd(x,y,a,b);\n\treturn (a%y+y)%y;\n}\nvoid get_seq(int C,int D){\n\ttop=q1[0]=q2[0]=0;\n\tint len=1,x,a=1,b=0;\n\tfor (;D;){\n\t\t//cout<<\"debug \"<<C<<' '<<D<<' '<<a<<endl;\n\t\t++top;\n\t\tq1[top]=q1[top-1]+C/D*a;\n\t\tq2[top]=q2[top-1]+C/D*D;\n\t\tq3[top]=C/D;\n\t\tFor(T,1,2){\n\t\t\tif (T==1) b+=C/D*a;\n\t\t\telse a+=C/D*b;\n\t\t\tx=C%D; C=D; D=x;\n\t\t\tif (!D) break;\n\t\t}\n\t}\n}\nll Mydiv(ll x,ll y){\n\treturn x<0?-1:x/y;\n}\nvoid solve(){\n\tscanf(\"%lld%lld%lld%lld%lld\",&A,&X,&B,&Y,&C);\n\tG=gcd(A,B); A/=G; B/=G; C/=gcd(C,G);\n\tG=gcd(A,C); A/=G; C/=G;\n\tH=gcd(G,B); B/=H; Y/=G/H;\n\tG=gcd(B,C); B/=G; C/=G;\n\tH=gcd(G,A); A/=H; X/=G/H;\n\tA%=C; B%=C;\n\tif (C==1) return cout<<X+Y<<endl,void(0);\n\tD=1ll*A*getinv(B,C)%C; get_seq(C,D);\n\tif (q1[top]!=C) q1[++top]=C,q2[top]=C,q3[top]=1;\n\t//For(i,1,top) cout<<q1[i]<<' '<<q2[i]<<' '<<q3[i]<<endl;\n\tint ans=0;\n\tFor(i,1,top){\n\t\tint lx=q1[i-1],rx=q1[i];\n\t\tint ly=C-q2[i-1],ry=C-q2[i];\n\t\tint dx=(rx-lx)/q3[i],dy=(ly-ry)/q3[i];\n\t\tint l=ans+1,r=X+Y+1;\n\t\t//cout<<lx<<' '<<ry<<' '<<dx<<' '<<dy<<' '<<ans<<endl;\n\t\twhile (l<=r){\n\t\t\tint mid=(l+r)/2;\n\t\t\tll p=Mydiv(X-1ll*mid*lx,dx);\n\t\t\tll q=Mydiv(Y-1ll*mid*ry,dy);\n\t\t\tif (p>=0&&q>=0&&p+q>=1ll*q3[i]*mid)\n\t\t\t\tans=max(ans,mid),l=mid+1;\n\t\t\telse r=mid-1;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\nsigned main(){\n\tint T;\n\tscanf(\"%lld\",&T);\n\twhile (T--) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nint gcd(re int a,re int b)\n{\n\tif(!b)return a;\n\treturn gcd(b,a%b);\n}\nvoid exgcd(re int a,re int b,re int&x,re int &y)\n{\n\tif(!b){x=1;y=0;return;}\n\texgcd(b,a%b,y,x);\n\ty-=a/b*x;\n}\nint a,b,c,d,x,y,x1,yk1,x2,y2,c1,d1,c2,d2,rd;\nlong long sol()\n{\n\tre int l=0,r=(yk1-y2)/d2-1,xx,yy,xx1,yy1;\n\tfor(re int mid=(l+r+1)/2;l<r;mid=(l+r+1)/2)\n\t{\n\t\tyy=yk1-mid*d2,xx=1ll*rd*yy%c;\n\t\tif(1ll*x*yy>=1ll*xx*y)l=mid;\n\t\telse r=mid-1;\n\t}\n\tyy=yk1-l*d2;xx=1ll*rd*yy%c;yy1=yy-d2;xx1=1ll*rd*yy1%c;\n\tre long long xl1=xx-xx1,yl1=yy-yy1,xxl,yyl;\n\tl=0,r=1e9;\n\tfor(re int mid=(l+r+1)/2;l<r;mid=(l+r+1)/2)\n\t{\n\t\txxl=x+1ll*mid*xl1,yyl=y+1ll*mid*yl1;\n\t\tif((long double)xxl*yy>=(long double)xx*yyl)l=mid;\n\t\telse r=mid-1;\n\t}\n\txxl=x+l*xl1,yyl=y+l*yl1;//printf(\"****%lld %lld %d %d %d %d %d\\n\",xxl,yyl,xx,yy,xx1,yy1,l);\n\tre long long ans=std::min(xx?xxl/xx:(1ll<<60),yy?yyl/yy:(1ll<<60));\n\txxl+=xl1;yyl+=yl1;\n\tif(xxl>=0&&yyl>=0)ans=std::max(ans,std::min(xx?xxl/xx:(1ll<<60),yy?yyl/yy:(1ll<<60)));\n\treturn ans;\n}\nint main()\n{\n\tre int T;\n\tscanf(\"%d\",&T);\n\tfor(;T--;)\n\t{\n\t\tscanf(\"%d%d%d%d%d\",&a,&x,&b,&y,&c);\n\t\tre int g=gcd(a,b);a/=g,b/=g,c/=gcd(c,g);\n\t\tg=gcd(a,c);a/=g;c/=g;y/=g;\n\t\tg=gcd(b,c);b/=g;c/=g;x/=g;\n\t\texgcd(b,c,x1,yk1);\n\t\td=1ll*a*(x1+c)%c;//printf(\"**%d %d %d c:%d d:%d %lld\\n\",a,b,gcd(a,b),c,d,1ll*(x1+c)*b%c);\n\t\texgcd(d,c,x1,yk1);\n\t\trd=(c-x1)%c;\n\t\tc1=c,d1=d;\n\t\twhile(c1!=0)\n\t\t{\n\t\t\tx1=1ll*rd*c1%c;yk1=c1;\n\t\t\tc2=c1,d2=d1;\n\t\t\tif(d1)c1%=d1;\n\t\t\telse c1=0;\n\t\t\tif(c1)d1%=c1;\n\t\t\telse d1=0;\n\t\t\tif(d1==0)d1=c1;\n\t\t\tre int x2=1ll*rd*c1%c,y2=c1;\n\t\t//printf(\"****%d %d %d %d %d %d\\n\",x1,y1,x2,y2,d,d2);\n\t\t\tif(1ll*x*yk1>=1ll*x1*y&&1ll*x2*y>=1ll*x*y2)\n\t\t\t{\n\t\t\t\tprintf(\"%lld\\n\",sol());break;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\nstruct Seq { ll lx, dx, cnt; Seq() {} Seq(ll lx, ll dx, ll cnt) :lx(lx), dx(dx), cnt(cnt) {} };\n\nll egcd(ll a, ll b, ll &x, ll &y) {\n\tif (b == 0) { x = 1, y = 0; return a; }\n\tll g = egcd(b, a%b, y, x); y -= x*(a / b); return g;\n}\n\nll inv(ll a, ll mod) {\n\tll x, y, g = egcd(a, mod, x, y);\n\tif (g != 1) return -1;\n\tassert(x >= -mod && x <= mod);\n\tif (x < 0) x += mod;\n\tif (x >= mod) x -= mod;\n\treturn x;\n}\n\nvector<Seq> calcIncreasingModularMultiples(ll k, ll mod) {\n\tll h = k, w = mod;\n\tvector<Seq> ret;\n\tll num = 0, den = inv(k, mod);\n\twhile (h > 0 && w > 0) {\n\t\tif (w >= h) {\n\t\t\tll t = w / h;\n\t\t\tret.PB(Seq(num*den%mod, h*den%mod, t));\n\t\t\tnum = (num + t*h) % mod;\n\t\t\tw -= t*h;\n\t\t} else {\n\t\t\th %= w;\n\t\t\tif (h == 0) h = w;\n\t\t}\n\t}\n\t//printf(\"%lld %lld:\", k, mod); REPSZ(i, ret) printf(\" [%lld,%lld,%lld]\", ret[i].lx, ret[i].dx, ret[i].cnt); puts(\"\");\n\treturn ret;\n}\n\nll divup(ll num, ll den) { return num >= 0 ? (num + den - 1) / den : num / den; }\nll divdn(ll num, ll den) { return num >= 0 ? num / den : (num - den + 1) / den; }\n\nll a, na, b, nb, c;\n\nll solve() {\n\tll all_groups_are_multiple_of = gcd(a, b);\n\tll min_possible_multiple_of_c = lcm(c, all_groups_are_multiple_of);\n\ta /= all_groups_are_multiple_of, b /= all_groups_are_multiple_of, c = min_possible_multiple_of_c / all_groups_are_multiple_of;\n\tassert(gcd(a, b) == 1);\n\n\tll contribution_of_a_in_good_group_is_multiple_of = lcm(a, gcd(b, c));\n\tll contribution_of_b_in_good_group_is_multiple_of = lcm(b, gcd(a, c));\n\tll count_of_a_in_good_group_is_multiple_of = contribution_of_a_in_good_group_is_multiple_of / a; // = gcd(b,c) because gcd(a,b)=1\n\tll count_of_b_in_good_group_is_multiple_of = contribution_of_b_in_good_group_is_multiple_of / b; // = gcd(a,c) because gcd(a,b)=1\n\ta *= count_of_a_in_good_group_is_multiple_of, na /= count_of_a_in_good_group_is_multiple_of;\n\tb *= count_of_b_in_good_group_is_multiple_of, nb /= count_of_b_in_good_group_is_multiple_of;\n\ta /= count_of_a_in_good_group_is_multiple_of, b /= count_of_a_in_good_group_is_multiple_of, c /= count_of_a_in_good_group_is_multiple_of;\n\ta /= count_of_b_in_good_group_is_multiple_of, b /= count_of_b_in_good_group_is_multiple_of, c /= count_of_b_in_good_group_is_multiple_of;\n\tassert(gcd(a, b) == 1 && gcd(a, c) == 1 && gcd(b, c) == 1);\n\n\tif (c == 1) return na + nb;\n\t// we want a*x+b*y=0 mod c -> y=-(a/b)*x mod c and we only need solutions x1<x2<...<xk with y1>y2>...>yk or equivalently (a/b)*x1<(a/b)*x2<...<(a/b)*xk\n\tll binv = inv(b, c);\n\tassert(binv != -1);\n\tll z = (ll)a*binv%c;\n\tvector<Seq> seq = calcIncreasingModularMultiples(z, c);\n\n\t// x1=lx+i*dx, x2=x1+dx, y1=-z*x1, y2=-z*x2 [x1<x2, y1>y2], let dy=y1-y2\n\t// s*(lx+i*dx)+(mi-s)*(lx+(i+1)*dx)<=na -> i*mi+(mi-s)<=(na-mi*lx)/dx\n\t// s*(ly-i*dy)+(mi-s)*(ly-(i+1)*dy)<=nb -> i*mi+(mi-s)>=(mi*ly-nb)/dy\n\tll ret = 0;\n\tREPSZ(i, seq) {\n\t\tll lx = seq[i].lx, dx = seq[i].dx;\n\t\tll ly = c - z*lx%c, dy = z*dx%c;\n\t\tll lo = 0, hi = na + nb + 1;\n\t\twhile (lo + 1 < hi) {\n\t\t\tll mi = lo + (hi - lo) / 2;\n\t\t\tll lbound = divup(mi*ly - nb, dy), ubound = divdn(na - mi*lx, dx);\n\t\t\tbool ok = lbound <= ubound && ubound >= 0 && lbound <= seq[i].cnt*mi;\n\t\t\tif (ok) lo = mi; else hi = mi;\n\t\t}\n\t\tret = max(ret, lo);\n\t}\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%lld%lld%lld%lld%lld\", &a, &na, &b, &nb, &c);\n\tprintf(\"%lld\\n\", solve());\n}\n\nvoid stress() {\n\tREP(rep, 100000) {\n\t\tll mod, k; while (true) { mod = rnd() % 1000 + 1, k = rnd() % mod; if (k == 0 || gcd(k, mod) != 1) continue; else break; }\n\t\tvector<Seq> seq = calcIncreasingModularMultiples(k, mod);\n\t\tvector<ll> have; REPSZ(i, seq) FORE(j, i == 0 ? 0 : 1, seq[i].cnt) have.PB(seq[i].lx + j*seq[i].dx);\n\t\tvector<ll> want; REPE(i, mod) { ll cur = (ll)i*k%mod; if (i != 0 && cur == 0) cur = mod; if (SZ(want) == 0 || cur > (ll)want.back()*k%mod) want.PB(i); }\n\t\tbool ok = SZ(have) == SZ(want); if (ok) REPSZ(i, have) if (have[i] != want[i]) ok = false;\n\t\tif (ok) { if (rep % 1000 == 999) printf(\".\"); continue; }\n\t\tprintf(\"err\\n\");\n\t\tprintf(\"have:\"); REPSZ(i, have) printf(\" %lld\", have[i]); puts(\"\");\n\t\tprintf(\"want:\"); REPSZ(i, want) printf(\" %lld\", want[i]); puts(\"\");\n\t}\n}\n\nint main() {\n\tint ncase; scanf(\"%d\", &ncase); FORE(i, 1, ncase) run();\n\t//stress();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nll gcd(ll a, ll b) {\n  return b ? gcd(b, a % b) : a;\n}\nvoid exgcd(ll a, ll b, ll& x, ll& y) {\n  if (!b) {\n    x = 1, y = 0;\n  } else {\n    exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n}\nll inv(ll a, ll Mod) {\n  ll x, y;\n  exgcd(a, Mod, x, y);\n  return x < 0 ? x + Mod : x;\n} \n\ntypedef class vec {\n  public:\n    ll dx, dy;\n    int c;\n\n    vec(ll dx, ll dy, int c) : dx(dx), dy(dy), c(c) { }\n} vec;\n\nint T;\nll A, X, B, Y, C;\nvector<vec> conv;\n\nvoid solve() {\n  scanf(\"%lld%lld%lld%lld%lld\", &A, &X, &B, &Y, &C);\n  ll g = gcd(A, B), ga, gb;\n  A /= g, B /= g, C /= gcd(g, C);\n  ga = gcd(A, C);\n  A /= ga, Y /= ga, C /= ga;\n  gb = gcd(B, C);\n  B /= gb, X /= gb, C /= gb;\n  if (C == 1) {\n    printf(\"%lld\\n\", X + Y);\n    return;\n  }\n\n  conv.clear();\n  ll W = C, H = A * inv(B, C) % C, x0 = 0, ia = inv(A, C), p = 0, np;\n  while (W && H) {\n    if (W >= H) {\n      ll t = W / H;\n      W -= t * H;\n      x0 += t * H;\n      np = x0 * B % C * ia % C;\n      np += !np * C;\n      conv.emplace_back((np - p) / t, H, t);\n      p = np;\n    } else {\n      if (!(H % W)) { \n        conv.emplace_back(C - p, W, 1);\n        break;\n      } else {\n        H %= W;\n      }\n    }\n  }\n\n  int l = 1, r = X + Y, mid;\n  while (l <= r) {\n    mid = (l + r) >> 1;\n    ll ca = 0, cb = mid * C;\n    for (auto v : conv) {\n      ll ub = min((cb - Y - 1) / v.dy + 1, 1ll * v.c * mid);\n      ca += v.dx * ub;\n      cb -= v.dy * ub;\n      if (cb <= Y) {\n        break;\n      }\n    }\n    if (ca <= X && cb <= Y) {\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  printf(\"%d\\n\", l - 1);\n}\n\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nlong long inv(int a,int p){return p==1?0:(1+p*(a-inv(p%a,a)))/a%p;}\nbool find(long long a1,long long b1,long long c1,long long a2,long long b2,long long c2,long long&x,long long&y){\n\tlong long t1=a1/c1,t2=a2/c2,y1=b1/c1,y2=(b2-1)/c2;\n\ta1-c1*t1<0?t1--:1;\n\ta2-c2*t2<0?t2--:1;\n\tb1-c1*y1<0?y1--:1;\n\tb2-1-c2*y2<0?y2--:1;\n\tif(y1<y2){\n\t\tx=0;y=y2;\n\t\treturn 1;\n\t}\n\tif(y1>y2||t1>t2||!a2)return 0;\n\tif(t1){\n\t\tbool res=find(a1-c1*t1,b1,c1,a2-c2*t2,b2,c2,x,y);y+=x*t1;\n\t\treturn res;\n\t}\n\tbool res=find(c2,c2*(y2+1)-b2,a2,c1,c1*(y1+1)-b1,a1,x,y);\n\tt1=x;x=y;y=t1+y1+1;\n\treturn res;\n}\nint calc(int A,int X,int B,int Y,int C){\n\tint G=gcd(B,C),z=C/G,x=G/gcd(A,G),y=1ll*A*x/G*inv(B/G,z)%z;\n\tif(!y)return X/x+Y/z;\n\tlong long x0,y0,l=0,r=1ll*Y*x+1ll*X*y+1,m;\n\twhile(r-l>1){\n\t\tm=(l+r)/2;\n\t\tif(find(-y,-y,z,-1ll*Y*x-1ll*X*y,m-1ll*Y*x-1ll*X*y,1ll*X*z,x0,y0))r=m;\n\t\telse l=m;\n\t}\n\tfind(-y,-y,z,-1ll*Y*x-1ll*X*y,r-1ll*Y*x-1ll*X*y,1ll*X*z,x0,y0);\n\ty0=(x0+1)*y%z;x0=(x0+1)*x;\n\tint t=(x0*Y+y0*X)/z/x,x1=inv(x0/x*y/z,x0/x)*x*t%x0;\n\tx1=X-(X+x1)%x0;\n\tif(y0*x1+x0*Y<1ll*t*z*x)t--;\n\treturn t;\n}\nint main(){\n\tint T;scanf(\"%d\",&T);\n\twhile(T--){\n\t\tint A,X,B,Y,C;\n\t\tscanf(\"%d%d%d%d%d\",&A,&X,&B,&Y,&C);\n\t\tprintf(\"%d\\n\",calc(A,X,B,Y,C));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint T;\nll A,X,B,Y,C,TC;\n\nconst int prime_max = 1000000;\nvector<int> prime;\nint NP,divp[prime_max];\n\nvoid cprime() {\n\tif(NP) return;\n\tfor(int i=2;i<prime_max;i++) if(divp[i]==0) {\n\t\tprime.push_back(i); NP++;\n\t\tfor(ll j=1LL*i*i;j>=i&&j<prime_max;j+=i) if(divp[j]==0) divp[j]=i;\n\t}\n}\n\nll totient(ll v) {\n\tcprime();\n\tll ret=v;\n\tFORR(p,prime) {\n\t\tif(1LL*p*p>v) break;\n\t\tif(v%p==0) {\n\t\t\tret=ret/p*(p-1);\n\t\t\twhile(v%p==0) v/=p;\n\t\t}\n\t}\n\tif(v>1) ret=ret/v*(v-1);\n\treturn ret;\n}\n\nll modpow(ll a, ll n,ll mo) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>T;\n\twhile(T--) {\n\t\tcin>>A>>X>>B>>Y>>C;\n\t\tll g=__gcd(A,B),g2;\n\t\t\n\t\tA/=g;\tB/=g;\tC/=__gcd(g,C);\n\t\tg=__gcd(A,C);\tA/=g;\tC/=g;\tg2=gcd(B,g);\tB/=g2;\tY/=g/g2;\n\t\tg=__gcd(B,C);\tB/=g;\tC/=g;\tg2=gcd(A,g);\tA/=g2;\tX/=g/g2;\n\t\tif(C==1) {\n\t\t\tcout<<X+Y<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tA%=C;\n\t\tB%=C;\n\t\t\n\t\tTC=totient(C);\n\t\t\n\t\tvector<vector<ll>> cand;\n\t\tll D=A*modpow(B,TC-1,C)%C;\n\t\tcand.push_back({0,C,0});\n\t\tll H=D,W=0;\n\t\twhile(1) {\n\t\t\tH%=(C-W);\n\t\t\tif(H==0) {\n\t\t\t\tH=C-W;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tll dif=(C-W)%H;\n\t\t\tif(dif==0) break;\n\t\t\tll step=(C-W)/H;\n\t\t\tW=C-dif;\n\t\t\tll X=W*modpow(D,TC-1,C)%C;\n\t\t\tll Y=(C-D*X%C)%C;\n\t\t\tcand.push_back({X,Y,step});\n\t\t}\n\t\tcand.push_back({C,0,(C-W)/H});\n\t\t\n\t\tll ret=0;\n\t\tFORR(c,cand) {\n\t\t\tif(c[0]==0) ret=max(ret,Y/c[1]);\n\t\t\telse if(c[1]==0) ret=max(ret,X/c[0]);\n\t\t\telse ret=max(ret,min(X/c[0],Y/c[1]));\n\t\t}\n\t\tFOR(i,cand.size()-1) {\n\t\t\tll AX=cand[i][0],AY=cand[i][1];\n\t\t\tll BX=cand[i+1][0],BY=cand[i+1][1];\n\t\t\tif(AY*X<=AX*Y || BY*X>=BX*Y) continue;\n\t\t\tll step=cand[i+1][2];\n\t\t\tll g=__gcd(BX-AX,AY-BY);\n\t\t\tassert(g%step==0);\n\t\t\tll dx=(BX-AX)/step;\n\t\t\tll dy=(BY-AY)/step;\n\t\t\t\n\t\t\tint cur=0;\n\t\t\tfor(j=29;j>=0;j--) if(cur+(1<<j)<step) {\n\t\t\t\tll CX=AX+(cur+(1<<j))*dx;\n\t\t\t\tll CY=AY+(cur+(1<<j))*dy;\n\t\t\t\tif(CY*X>CX*Y) cur+=1<<j;\n\t\t\t}\n\t\t\tll TX=AX+cur*dx;\n\t\t\tll TY=AY+cur*dy;\n\t\t\tll SX=TX+dx;\n\t\t\tll SY=TY+dy;\n\t\t\tret=max(ret,min(TX?(X/TX):(1<<30),TY?(Y/TY):(1<<30)));\n\t\t\tret=max(ret,min(SX?(X/SX):(1<<30),SY?(Y/SY):(1<<30)));\n\t\t\tFOR(r,2) {\n\t\t\t\tll mx=0;\n\t\t\t\tfor(j=29;j>=0;j--) {\n\t\t\t\t\t__int128_t lef=(-TX*(mx+(1<<j))+X)*(__int128_t)SY;\n\t\t\t\t\t__int128_t ri=(-TY*(mx+(1<<j))+Y)*(__int128_t)SX;\n\t\t\t\t\tif(lef<ri) mx+=1<<j;\n\t\t\t\t}\n\t\t\t\tfor(ll x=max(0LL,mx-2);x<=mx+2;x++) if(x>=0) {\n\t\t\t\t\tll LX=X-TX*x;\n\t\t\t\t\tll LY=Y-TY*x;\n\t\t\t\t\tif(LX>=0&LY>=0) {\n\t\t\t\t\t\tret=max(ret,x+min(SX?(LX/SX):(1<<30),SY?(LY/SY):(1<<30)));\n\t\t\t\t\t\tll y=min(SX?(LX/SX):(1<<30),SY?(LY/SY):(1<<30));\n\t\t\t\t\t\tll XX=TX*x+SX*y;\n\t\t\t\t\t\tll YY=TY*x+SY*y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tswap(TX,SY);\n\t\t\t\tswap(SX,TY);\n\t\t\t\tswap(X,Y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<ret<<endl;\n\t\t\n\t\t\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tscanf(\"%d\",&x); return;\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntemplate<class T> inline bool Cmax(T &x,T y) {return x<y?x=y,1:0;} \ntypedef long long ll;\nint T,A,X,B,Y,C,D;\nvector<int> pos,cnt;\nint gcd(int a,int b) {return b==0?a:gcd(b,a%b);}\nint exgcd(int a,int b,int &x,int &y) {\n\tif(b==0) {x=1,y=0; return a;}\n\tint d=exgcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\ninline int inver(int a,int mod) {\n\tint x,y,d=exgcd(a,mod,x,y);\n\tif(x<0) x+=mod;\n\treturn x;\n}\ninline ll lowdiv(ll a,ll b) {return a/b-(a%b&&(a^b)<0);}\nvoid init() {\n\tint d=gcd(A,B);\n\tA/=d,B/=d,C/=gcd(d,C);\n\tfor(int _=0;_<2;++_) {\n\t\td=gcd(A,C);\n\t\tC/=d,A/=d;\n\t\tint t=gcd(B,d);\n\t\tB/=t,Y/=d/t;\n\t\tswap(A,B),swap(X,Y);\n\t}\n}\nvoid getpos() {\n\tpos.clear(),cnt.clear();\n\tint W=C,H=D,now=0,r=inver(D,C);\n\twhile(W) {\n\t\tint d=W/H;\n\t\tpos.push_back((ll)now*r%C),cnt.push_back(d); \n\t\tnow+=d*H;\n\t\tW%=H; if(W==0) break;\n\t\tH%=W; if(H==0) H=W;\n\t}\n\tpos.push_back(C);\n}\ninline int gety(int x) {return x==0?C:(C-(ll)x*D%C)%C;}\nint main() {\n//\tfreopen(\"1.in\",\"r\",stdin);\n//\tfreopen(\"1.out\",\"w\",stdout);\n\trd(T);\n\tfor(int kase=1;kase<=T;++kase) {\n\t\trd(A),rd(X),rd(B),rd(Y),rd(C);\n\t\tinit();\n\t\tif(C==1) {printf(\"%d\\n\",X+Y); continue;}\n\t\tD=(ll)A*inver(B,C)%C;\n\t\tgetpos();\n\t\tint an=0;\n\t\tfor(int i=0;i<cnt.size();++i) {\n\t\t\tint xl=pos[i],xr=pos[i+1],yl=gety(xl),yr=gety(xr);\n\t\t\tint dx=(xr-xl)/cnt[i],dy=(yl-yr)/cnt[i];\n\t\t\tint l=0,r=X+Y,re=-1;\n\t\t\twhile(l<=r) {\n\t\t\t\tint mid=((ll)l+r)>>1;\n\t\t\t\tll p=lowdiv(X-(ll)xl*mid,dx),q=lowdiv(Y-(ll)yr*mid,dy);\n\t\t\t\tif(p>=0&&q>=0&&p+q>=(ll)cnt[i]*mid) re=mid,l=mid+1;\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tCmax(an,re);\n\t\t}\n\t\tprintf(\"%d\\n\",an);\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nint A, X, B, Y, C, G, D;\n\nvoid exgcd(int a, int b, int &x, int &y) {\n\tif (!b) {\n\t\tx = 1, y = 0;\n\t\treturn;\n\t}\n\texgcd(b, a % b, y, x);\n\ty -= a / b * x;\n}\n\nint inv(int a, int p) {\n\tint x, y;\n\texgcd(a, p, x, y);\n\treturn (x % p + p) % p;\n}\n\nint gety(int x) {\n\tif (x == 0) {\n\t\treturn C;\n\t}\n\treturn (C - 1ll * D * x % C) % C;\n}\n\nvoid solve() {\n\tread(A), read(X), read(B), read(Y), read(C);\n\tG = std::__gcd(A, B), A /= G, B /= G, C /= std::__gcd(C, G);\n\tG = std::__gcd(A, C), A /= G, C /= G, Y /= G;\n\tG = std::__gcd(B, C), B /= G, C /= G, X /= G;\n\tD = 1ll * A * inv(B, C) % C;\n\n\tstd::vector<int> pos, cnt;\n\tint W = C, H = D, now = 0, invD = inv(D, C);\n\twhile (W) {\n\t\tH = (H - 1) % W + 1;\n\t\tint t = W / H;\n\t\tpos.push_back(1ll * now * invD % C);\n\t\tcnt.push_back(t);\n\t\tnow += t * H;\n\t\tW -= t * H;\n\t}\n\tpos.push_back(C);\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < (int)cnt.size(); ++i) {\n\t\tint lx = pos[i], ly = gety(lx);\n\t\tint rx = pos[i + 1], ry = gety(rx);\n\t\tint dx = (rx - lx) / cnt[i];\n\t\tint dy = (ly - ry) / cnt[i];\n\t\t// debug(\"%d %d %d %d %d %d\\n\", lx, ly, rx, ry, dx, dy);\n\n\t\tlong long l = 0, r = X + Y, s = 0;\n\t\twhile (l <= r) {\n\t\t\tint md = (l + r) >> 1;\n\t\t\tlong long p = X - lx * md, q = Y - ry * md;\n\t\t\tif (p >= 0 && q >= 0 && p / dx + q / dy >= cnt[i] * md) {\n\t\t\t\ts = md, l = md + 1;\n\t\t\t} else {\n\t\t\t\tr = md - 1;\n\t\t\t}\n\t\t}\n\t\tans = std::max(ans, s);\n\t}\n\tprint(ans);\n}\n\nint main() {\n\tint T = 1;\n\tread(T);\n\twhile (T--) {\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint a,b,c,lim1,lim2,tp;\n\nvoid exgcd(int a,int b,int &x,int &y) {\n\tif(!b) { x=1;y=0;return; }\n\texgcd(b,a%b,y,x);y-=a/b*x;\n}\n\nint inv(int a,int p) {\n\tint x,y;exgcd(a,p,x,y);\n\treturn (x+p)%p;\n}\n\nstruct dat {\n\tint x,y,cnt;\n} st[110];\n\nvoid get(int c,int d) {\n\ttp=0;int a=1,b=0;\n\twhile(d) {\n\t\t++tp;st[tp]=(dat){st[tp-1].x+c/d*a,st[tp-1].y+c/d*d,c/d};\n\t\tfor(int t=0;t<2&&d;t++) {\n\t\t\tif(!t) b+=c/d*a; else a+=c/d*b;\n\t\t\tswap(c,d);d%=c;\n\t\t}\n\t}\n}\n\nll Div(ll a,ll b) {\n\tif(a<0) return -1;\n\treturn a/b;\n}\n\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tint T;cin>>T;\n\twhile(T--) {\n\t\tcin>>a>>lim1>>b>>lim2>>c;\n\t\tint g=__gcd(a,b);a/=g,b/=g,c/=__gcd(c,g);\n\t\tg=__gcd(a,c),a/=g,c/=g,lim2/=g;\n\t\tg=__gcd(b,c),b/=g,c/=g,lim1/=g;\n\t\ta%=c;b%=c;\n\t\tif(c==1) { cout<<lim1+lim2<<'\\n';continue; }\n\t\tint d=1ll*a*inv(b,c)%c;get(c,d);int ans=0;\n\t\tif(st[tp].x!=c) st[++tp]=(dat){c,c,1};\n\t\tfor(int i=1;i<=tp;i++) {\n\t\t\tint lx=st[i-1].x,ly=c-st[i-1].y,rx=st[i].x,ry=c-st[i].y;\n\t\t\tint dx=(rx-lx)/st[i].cnt,dy=(ly-ry)/st[i].cnt;\n\t\t\t//cerr<<lx<<' '<<ly<<' '<<rx<<' '<<ry<<' '<<dx<<' '<<dy<<' '<<st[i].cnt<<'\\n';\n\t\t\tint l=ans,r=lim1+lim2;\n\t\t\twhile(l<r) {\n\t\t\t\tint mid=(l+r+1)>>1;\n\t\t\t\tif(max(0ll,Div(1ll*mid*ly-lim2+dy-1,dy))<=min(1ll*st[i].cnt*mid,Div(lim1-1ll*mid*lx,dx))) l=mid;\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tans=max(ans,l);\n\t\t}\n\t\tcout<<ans<<'\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nll gcd(ll a, ll b) {\n  return b ? gcd(b, a % b) : a;\n}\nvoid exgcd(ll a, ll b, ll& x, ll& y) {\n  if (!b) {\n    x = 1, y = 0;\n  } else {\n    exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n}\nll inv(ll a, ll Mod) {\n  ll x, y;\n  exgcd(a, Mod, x, y);\n  return x < 0 ? x + Mod : x;\n} \n\ntypedef class vec {\n  public:\n    ll dx, dy;\n    int c;\n\n    vec(ll dx, ll dy, int c) : dx(dx), dy(dy), c(c) { }\n} vec;\n\nint T;\nll A, X, B, Y, C;\nvector<vec> conv;\n\nvoid solve() {\n  scanf(\"%lld%lld%lld%lld%lld\", &A, &X, &B, &Y, &C);\n  ll g = gcd(A, B), ga, gb;\n  A /= g, B /= g, C /= gcd(g, C);\n  while ((ga = gcd(A, C)) > 1) {\n    A /= ga;\n    Y /= ga;\n  }\n  while ((gb = gcd(B, C)) > 1) {\n    B /= gb;\n    X /= gb;\n  }\n\n  conv.clear();\n  ll W = C, H = A * inv(B, C) % C, x0 = 0, ia = inv(A, C), p = 0, np;\n  while (W && H) {\n    if (W >= H) {\n      ll t = W / H;\n      W -= t * H;\n      x0 += t * H;\n      np = x0 * B % C * ia % C;\n      conv.emplace_back((np - p) / t, H, t);\n      p = np;\n    } else {\n      if (!(H % W)) { \n        conv.emplace_back(C - p, W, 1);\n        break;\n      } else {\n        H %= W;\n      }\n    }\n  }\n\n  int l = 1, r = X + Y, mid;\n  while (l <= r) {\n    mid = (l + r) >> 1;\n    ll ca = 0, cb = mid * C;\n    for (auto v : conv) {\n      ll ub = min((cb - Y - 1) / v.dy + 1, 1ll * v.c * mid);\n      ca += v.dx * ub;\n      cb -= v.dy * ub;\n      if (cb <= Y) {\n        break;\n      }\n    }\n    if (ca <= X && cb <= Y) {\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  printf(\"%d\\n\", l - 1);\n}\n\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1007*1007;\n\nll a, b, c, x, y;\n\nvoid eukl(ll &x, ll &y, ll a, ll b) {\n\tif (!a) { x = 0; y = 1; return; }\n\teukl(y, x, b % a, a);\n\tx -= y * (b / a);\n}\n\nll odw(ll v)\n{\n\tll x, y;\n\teukl(x, y, v, c);\n\tx%=c;\n\tx+=c;\n\tx%=c;\n\treturn x;\n}\n\nvoid relax()\n{\n\tll g=__gcd(a, b);\n\tg=__gcd(g, c);\n\ta/=g;\n\tb/=g;\n\tc/=g;\n\t\n\tg=__gcd(a, b);\n\ta/=g;\n\tb/=g;\n\t\t\n\tg=__gcd(a, c);\n\ta/=g;\n\tc/=g;\n\ty/=g;\n\t\n\tg=__gcd(b, c);\n\tb/=g;\n\tc/=g;\n\tx/=g;\n}\n\nvector<pll> sta;\nvector<pll> dod;\nvll razy;\nll jest;\n\npll dajkt(int v, ll x)\n{\n\treturn {sta[v].first+x*dod[v].first, sta[v].second+x*dod[v].second};\n}\n\npll daj(ll x)\n{\n\tint v=0;\n\twhile(razy[v]<=x)\n\t{\n\t\tx-=razy[v];\n\t\tv++;\n\t}\n\treturn dajkt(v, x);\n}\n\nvoid euklides()\n{\n\tll mno=odw(b)*a;\n\tmno%=c;\n\tmno=c-mno;\n\tmno%=c;\n\t\n\tsta.clear();\n\tdod.clear();\n\trazy.clear();\n\tll mini=1;\n\tll maxi=1;\n\tll wmi=mno;\n\tll wma=mno;\n\tsta.push_back({0, c});\n\tdod.push_back({0, 0});\n\trazy.push_back(1);\n\tsta.push_back({1, mno});\n\tdod.push_back({0, 0});\n\trazy.push_back(1);\n\twhile(mini+maxi<=c)\n\t{\n\t\tif ((wmi+wma)%c<wmi)\n\t\t{\n\t\t\tll ile=wmi/(c-wma);\n\t\t\tsta.push_back({mini+maxi, (wmi+wma)%c});\n\t\t\tdod.push_back({maxi, wma-c});\n\t\t\trazy.push_back(ile);\n\t\t\tmini+=ile*maxi;\n\t\t\twmi+=ile*wma;\n\t\t\twmi%=c;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll ile=(c-wma-1)/wmi;\n\t\t\tmaxi+=ile*mini;\n\t\t\twma+=ile*wmi;\n\t\t\twma%=c;\n\t\t}\n\t}\n\tjest=0;\n\tfor (ll i : razy)\n\t\tjest+=i;\n}\n\nint check(ll v)\n{\n\tll bsa=0;\n\tll bsb=jest-1;\n\twhile(bsa<bsb)\n\t{\n\t\tll bss=(bsa+bsb+2)>>1;\n\t\tif (daj(bss).first*v<=x)\n\t\t\tbsa=bss;\n\t\telse\n\t\t\tbsb=bss-1;\n\t}\n\tll g=bsa;\n\tif (g==jest-1)\n\t\treturn 1;\n\tpll lew=daj(g);\n\tpll pra=daj(g+1);\n\tbsa=0;\n\tbsb=v;\n\twhile(bsa<bsb)\n\t{\n\t\tll bss=(bsa+bsb+2)>>1;\n\t\tif (bss*pra.first+(v-bss)*lew.first<=x)\n\t\t\tbsa=bss;\n\t\telse\n\t\t\tbsb=bss-1;\n\t}\n\treturn (bsa*pra.second+(v-bsa)*lew.second<=y);\n}\n\nvoid test()\n{\n\tscanf(\"%lld%lld%lld%lld%lld\", &a, &x, &b, &y, &c);\n\ta%=c;\n\tb%=c;\n\tif (!a || !b)\n\t{\n\t\tll jed=c/__gcd(c, a);\n\t\tll dwa=c/__gcd(c, b);\n\t\tprintf(\"%lld\\n\", x/jed+y/dwa);\n\t\treturn;\n\t}\n\trelax();\n\teuklides();\n\tll bsa=0;\n\tll bsb=x+y;\n\twhile(bsa<bsb)\n\t{\n\t\tll bss=(bsa+bsb+2)>>1;\n\t\tif (check(bss))\n\t\t\tbsa=bss;\n\t\telse\n\t\t\tbsb=bss-1;\n\t}\n\tprintf(\"%lld\\n\", bsa);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n#define int ll\ninline char gc() {\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntemplate<class T> inline bool Cmax(T &x,T y) {return x<y?x=y,1:0;} \ntypedef long long ll;\nint T,A,X,B,Y,C,D;\nvector<int> pos,cnt;\nint gcd(int a,int b) {return b==0?a:gcd(b,a%b);}\nint exgcd(int a,int b,int &x,int &y) {\n\tif(b==0) {x=1,y=0; return a;}\n\tint d=exgcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\ninline int inver(int a,int mod) {\n\tint x,y,d=exgcd(a,mod,x,y);\n\tif(x<0) x+=mod;\n\treturn x;\n}\ninline ll lowdiv(ll a,ll b) {return a/b-(a%b&&(a^b)<0);}\nvoid init() {\n\tint d=gcd(A,B);\n\tA/=d,B/=d,C/=gcd(d,C);\n\tfor(int _=0;_<2;++_) {\n\t\td=gcd(A,C);\n\t\tC/=d,A/=d;\n\t\tint t=gcd(B,d);\n\t\tB/=t,Y/=d/t;\n\t\tswap(A,B),swap(X,Y);\n\t}\n}\nvoid getpos() {\n\tpos.clear(),cnt.clear();\n\tint W=C,H=D,now=0,r=inver(D,C);\n\twhile(W) {\n\t\tint d=W/H;\n\t\tpos.push_back((ll)now*r%C),cnt.push_back(d); \n\t\tnow+=d*H;\n\t\tW%=H; if(W==0) break;\n\t\tH%=W; if(H==0) H=W;\n\t}\n\tpos.push_back(C);\n}\ninline int gety(int x) {return C-(ll)x*D%C;}\nint main() {\n\trd(T);\n\tfor(int kase=1;kase<=T;++kase) {\n\t\trd(A),rd(X),rd(B),rd(Y),rd(C);\n\t\tinit();\n\t\tif(C==1) {printf(\"%d\\n\",X+Y); continue;}\n\t\tD=(ll)A*inver(B,C)%C;\n\t\tgetpos();\n\t\tint an=0;\n\t\tfor(int i=0;i<cnt.size();++i) {\n\t\t\tint xl=pos[i],xr=pos[i+1],yl=gety(xl),yr=gety(xr);\n\t\t\tint dx=(xr-xl)/cnt[i],dy=(yl-yr)/cnt[i];\n\t\t\tint l=0,r=X+Y,re=-1;\n\t\t\twhile(l<=r) {\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tll p=lowdiv(X-(ll)xl*mid,dx),q=lowdiv(Y-(ll)yr*mid,dy);\n\t\t\t\tif(p>=0&&q>=0&&p+q>=cnt[i]*mid) re=mid,l=mid+1;\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tCmax(an,re);\n\t\t}\n\t\tprintf(\"%d\\n\",an);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ncs int N = 1e3;\nint T, A, B, X, Y, C;\nint x, y;\nvoid exgcd(int a, int b, int &x, int &y){\n\tif(!b) return x=1,y=0,void();\n\texgcd(b,a%b,x,y); int _x=y, _y=x-a/b*y; x=_x; y=_y;\n}\nint inv(int a, int b){\n\texgcd(a,b,x,y);\n\tx = (x % b + b) % b; return x;\n}\nstruct dat{ int x, y, ct; };\ndat pt[N]; int top;\nvoid cope(int c, int d){\n\tpt[top=0]=(dat){0,0,0}; int a=1, b=0;\n\twhile(d>0){\n\t\tdat t = pt[top];\n\t\tpt[++top]=(dat){t.x+c/d*a,t.y+c/d*d,c/d};\n\t\tfor(int _=1,x;_<=2&&d;_++){\n\t\t\tif(_==1)b+=c/d*a;\n\t\t\tif(_==2)a+=c/d*b;\n\t\t\tx=c%d,c=d,d=x;\n\t\t} \n\t} \n} int clc(ll x, ll y){ return x<0?-1:x/y; }\nvoid Main(){\n\tscanf(\"%d%d%d%d%d\",&A,&X,&B,&Y,&C);\n\tint t = __gcd(A,B); A/=t; B/=t; C/=__gcd(t,C);\n\tt = __gcd(A,C); A/=t, C/=t, Y/=t;\n\tt = __gcd(B,C); B/=t, C/=t, X/=t;\n\tif(C==1)return cout<<X+Y<<'\\n',void();\n\tint D = (ll)A * inv(B,C) % C;\n\tcope(C,D); int ans = 0;\n\tif(pt[top].x!=C)pt[++top]=(dat){C,C,1};\n\tfor(int i=1; i<=top; i++){\n\t\tint lx=pt[i-1].x,rx=pt[i].x;\n\t\tint ly=C-pt[i-1].y,ry=C-pt[i].y;\n\t\tint dx=(rx-lx)/pt[i].ct, dy=(ly-ry)/pt[i].ct;\n\t\tint l=ans+1,r=X+Y;\n\t\twhile(l<=r){\n\t\t\tint mid=(ll)(l+r)>>1;\n\t\t\tll S=clc(X-(ll)mid*lx,dx);\n\t\t\tll T=clc(Y-(ll)mid*ry,dy);\n\t\t\tif(~S&&~T&&S+T>=(ll)mid*pt[i].ct)ans=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t} \n\t} cout<<ans<<'\\n';\n}\nsigned main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d\",&T);\n\twhile(T--)Main();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\n\ntemplate<class t=ll>\nt extgcd(t a,t b,t&x,t&y){\n\tif(b==0){\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}else{\n\t\tt g=extgcd(b,a%b,y,x);\n\t\ty-=a/b*x;\n\t\treturn g;\n\t}\n}\n\n//x*y=g mod m\n//returns (g,y)\ntemplate<class t=ll>\npair<t,t> modinv(t x,t m){\n\tt a,b;\n\tt g=extgcd(x,m,a,b);\n\tif(a<0)a+=m/g;\n\treturn {g,a};\n}\n\nint fdiv(int a,int b){\n\treturn a/b-(a%b&&(a^b)<0);\n}\n\nvoid slv(){\n\tint a,x,b,y,c;\n\tcin>>a>>x>>b>>y>>c;\n\t{\n\t\tint g=gcd(a,b);\n\t\ta/=g;\n\t\tb/=g;\n\t\tc/=gcd(g,c);\n\t}\n\trep(_,2){\n\t\tint g=gcd(a,c);\n\t\ta/=g;\n\t\tc/=g;\n\t\tint h=gcd(b,g);\n\t\tb/=h;\n\t\ty/=g/h;\n\t\t\n\t\tswap(a,b);\n\t\tswap(x,y);\n\t}\n\tif(c==1){\n\t\tprint(x+y);\n\t\treturn;\n\t}\n\tint step=modinv(b,c).b*a%c;\n\tvi pos,cnt;\n\t{\n\t\tint z=modinv(step,c).b;\n\t\tint h=step;\n\t\tint w=c;\n\t\tint cur=0;\n\t\twhile(w){\n\t\t\tint p=w/h;\n\t\t\tpos.pb(cur*z%c);\n\t\t\tcnt.pb(p);\n\t\t\tcur+=p*h;\n\t\t\tw%=h;\n\t\t\tif(w==0)break;\n\t\t\th%=w;\n\t\t\tif(h==0)h=w;\n\t\t}\n\t\tassert(cur==c);\n\t\tpos.pb(c);\n\t}\n\tauto gety=[&](int v){\n\t\tif(v==0)return c;\n\t\treturn (c-step*v%c)%c;\n\t};\n\tint ans=0;\n\trep(i,si(cnt)){\n\t\tint lx=pos[i],ly=gety(lx);\n\t\tint rx=pos[i+1],ry=gety(rx);\n\t\tint dx=(rx-lx)/cnt[i];\n\t\tint dy=(ly-ry)/cnt[i];\n\t\tint lw=0,up=x+y+1;\n\t\twhile(up-lw>1){\n\t\t\tconst int mid=(lw+up)/2;\n\t\t\tint p=fdiv(x-lx*mid,dx);\n\t\t\tint q=fdiv(y-ry*mid,dy);\n\t\t\tif(p>=0&&q>=0&&p+q>=cnt[i]*mid)\n\t\t\t\tlw=mid;\n\t\t\telse\n\t\t\t\tup=mid;\n\t\t}\n\t\tchmax(ans,lw);\n\t}\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;\n\trep(_,t)slv();\n}\n"
  },
  {
    "language": "C++",
    "code": "poyo~"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint T, A, X, B, Y, C, ans;\n\nint gcd(int a, int b) {\n\treturn b ? gcd(b, a%b) : a;\n}\n\nvoid exgcd(int a, int b, int &x, int &y) {\n\tif (!b) {\n\t\tx = 1, y = 0;\n\t\treturn;\n\t}\n\t// ax + by = gcd(a,b)\n\t// bx + (a-b[a/b])y = gcd(a,b)\n\t// ya + (x-[a/b]y)b = gcd(a,b)\n\tint x_ = 0, y_ = 0;\n\texgcd(b, a%b, x_, y_);\n\tx = y_, y = x_ - (a / b) * y_;\n}\n\nint inverse(int a, int mod) {\n\tint x = 0, y = 0;\n\t// ax - mod k = 1\n\texgcd(a, mod, x, y);\n\treturn (x % mod + mod) % mod;\n}\n\nint solve(int k, int p, int l, int r) {\n    if (r >= l + p) r = l + p - 1;\n    if (r >= p) {\n        int x = (l + k - 1) / k;\n        int res = solve(k, p, l - k * x, r - k * x);\n        if (res == -1) return -1;\n        return x + res;\n    }\n    k %= p;\n    if (l <= -p) {\n        int x = ((- p - l) / p) + 1;\n        l += p * x, r += p * x;\n    }\n    if (!k) {\n        if (l <= 0 && r >= 0)\n            return 0;\n        else \n            return -1;\n    }\n    int q = solve(p, k, -r, -l);\n    if (q == -1) return -1;\n    // ki >= l + qp\n    return max(0, (l + q * p + k - 1) / k);\n}\n\nint solve(int k, int p, int l, int r, int a) {\n\tl -= k * a, r -= k * a;\n\treturn solve(k, p, l, r) + a;\n}\n\nint main() {\n\tscanf(\"%d\", &T);\n\twhile (T --) {\n\t\tscanf(\"%d%d%d%d%d\", &A, &X, &B, &Y, &C);\n\t\tint d = gcd(gcd(A, B), C);\n\t\tA /= d, B /= d, C /= d;\n\t\tint dA = gcd(A, C), dB = gcd(B, C);\n\t\tX /= dB, Y /= dA, C /= (dA * dB);\n\t\tA /= dA, B /= dB;\n\t\tans = 0;\n\t\tA %= C, B %= C;\n\t\tif (!A || !B) {\n\t\t\tif (!A && !B) {\n\t\t\t\tprintf(\"%d\\n\", X+Y);\n\t\t\t} else if (!A) {\n\t\t\t\tprintf(\"%d\\n\", X+Y/C);\n\t\t\t} else {\n\t\t\t\tprintf(\"%d\\n\", X/C+Y);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tint k = 1LL * inverse(B, C) * A % C;\n\t\tint cur_x = 0, cur_y = C;\n\t\twhile (cur_x != C) {\n\t\t\tint nxt_x = solve(C - k, C, 0, cur_y-1, cur_x+1);\n\t\t\tint nxt_y = 1LL * (C - k) * nxt_x % C;\n\t\t\tint delta_x = nxt_x - cur_x, delta_y = cur_y - nxt_y;\n\t\t\tint c = cur_y / delta_y;\n\t\t\tnxt_x = cur_x + delta_x * c;\n\t\t\tnxt_y = cur_y - delta_y * c;\n\t\t\tint L = 0, R = min(cur_x ? (X / cur_x) : 0x3f3f3f3f, nxt_y ? (Y / nxt_y) : (0x3f3f3f3f)), res = 0;\n\t\t\twhile (L <= R) {\n\t\t\t\tint mid = (L + R) >> 1;\n\t\t\t\tll lb = max(0LL, (1LL * mid * cur_y - Y + delta_y - 1) / delta_y), rb = min(1LL*mid*c, (X - 1LL * mid * cur_x) / delta_x);\n\t\t\t\tif (lb <= rb) {\n\t\t\t\t\tres = mid;\n\t\t\t\t\tL = mid + 1;\n\t\t\t\t} else R = mid - 1;\n\t\t\t}\n\t\t\tans = max(ans, res);\n\t\t\tcur_x = nxt_x, cur_y = nxt_y;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nll gcd(ll a, ll b) {\n  return b ? gcd(b, a % b) : a;\n}\nvoid exgcd(ll a, ll b, ll& x, ll& y) {\n  if (!b) {\n    x = 1, y = 0;\n  } else {\n    exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n}\nll inv(ll a, ll Mod) {\n  ll x, y;\n  exgcd(a, Mod, x, y);\n  return x < 0 ? x + Mod : x;\n} \n\ntypedef class vec {\n  public:\n    ll dx, dy;\n    int c;\n\n    vec(ll dx, ll dy, int c) : dx(dx), dy(dy), c(c) { }\n} vec;\n\nint T;\nll A, X, B, Y, C;\nvector<vec> conv;\n\nvoid solve() {\n  scanf(\"%lld%lld%lld%lld%lld\", &A, &X, &B, &Y, &C);\n  ll g = gcd(A, B), ga, gb;\n  A /= g, B /= g, C /= gcd(g, C);\n  ga = gcd(A, C);\n  A /= ga, Y /= ga, C /= ga;\n  gb = gcd(B, C);\n  B /= gb, X /= gb, C /= gb;\n  if (C == 1) {\n    printf(\"%lld\\n\", X + Y);\n    return;\n  }\n\n  conv.clear();\n  ll W = C, H = A * inv(B, C) % C, x0 = 0, ia = inv(A, C), p = 0, np;\n  while (W && H) {\n    if (W >= H) {\n      ll t = W / H;\n      W -= t * H;\n      x0 += t * H;\n      np = x0 * B % C * ia % C;\n      np += !np * C;\n      conv.emplace_back((np - p) / t, H, t);\n      p = np;\n    } else {\n      if (!(H % W)) { \n        conv.emplace_back(C - p, W, 1);\n        break;\n      } else {\n        H %= W;\n      }\n    }\n  }\n\n  ll l = Y / C + 1, r = X + Y, mid;\n  while (l <= r) {\n    mid = (l + r) >> 1;\n    ll ca = 0, cb = mid * C;\n    for (auto v : conv) {\n      ll ub = min((cb - Y - 1) / v.dy + 1, 1ll * v.c * mid);\n      ub = min(ub, 1000000001ll);\n      ca += v.dx * ub;\n      cb -= v.dy * ub;\n      if (ca > X || cb <= Y) {\n        break;\n      }\n    }\n    if (ca <= X && cb <= Y) {\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  printf(\"%d\\n\", l - 1);\n}\n\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nll minv(ll a, ll m) {\n\ta %= m;\n\tassert(a);\n\treturn a == 1 ? 1 : ll(m - ll(minv(m, a)) * ll(m) / a);\n}\nvoid solve(){\n\tll a, x, b, y, c;\n\tcin >> a >> x >> b >> y >> c;\n\ta %= c; b %= c;\n\t{\n\t\tll gabc = __gcd(c, __gcd(a, b));\n\t\ta /= gabc; b /= gabc; c /= gabc;\n\t}\n\t{\n\t\tll ga = __gcd(c, a);\n\t\ty /= ga;\n\t\tb = (b * ga) % c;\n\t\ta /= ga; b /= ga; c /= ga;\n\t}\n\t{\n\t\tll gb = __gcd(c, b);\n\t\ty /= gb;\n\t\ta = (a * gb) % c;\n\t\ta /= gb; b /= gb; c /= gb;\n\t}\n\tif(c == 1){\n\t\tcout << x + y << '\\n';\n\t\treturn;\n\t}\n\tassert(a > 0 && b > 0);\n\tll r = (a * minv(b, c)) % c;\n\tassert(r > 0);\n\tif(r == 1){\n\t\tcout << (x + y) / c << '\\n';\n\t\treturn;\n\t}\n\tll ir = minv(r, c);\n\tll f = c - r * (c / r);\n\tll g = c - ir * (c / ir);\n\tll s = 0; // yes\n\tll e = int(2e9) + 1;\n\tll fx = c / r;\n\tll fy = f;\n\tll gx = g;\n\tll gy = c / ir;\n\tassert(fx <= gx && fy >= gy);\n\twhile(s + 1 < e){\n\t\tll m = (s + e) / 2;\n\t\tll na = m * fx;\n\t\tll nb = m;\n\t\tll nc = m * gy;\n\t\tll dx = gx - fx;\n\t\tll dy = gy - fy;\n\n\t\tll curx = 0;\n\t\tll cury = c;\n\t\tvector<pair<pair<ll,ll>, ll> > z = {{{r, 1}, na}, {{dx, dy}, nb}, {{1, ir}, nc}};\n\t\tfor(auto q : z){\n\t\t\tif(cury > y){\n\t\t\t\tll gg = (cury - y - 1) / q.first.second + 1;\n\t\t\t\tgg = min(g, q.second);\n\t\t\t\tcurx += gg * q.first.second;\n\t\t\t\tcury -= gg * q.second;\n\t\t\t}\n\t\t}\n\t\tif(c <= x){\n\t\t\ts = m;\n\t\t} else {\n\t\t\te = m;\n\t\t}\n\t}\n\tcout << s << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint T, A, X, B, Y, C, ans;\n\nint gcd(int a, int b) {\n\treturn b ? gcd(b, a%b) : a;\n}\n\nvoid exgcd(int a, int b, int &x, int &y) {\n\tif (!b) {\n\t\tx = 1, y = 0;\n\t\treturn;\n\t}\n\t// ax + by = gcd(a,b)\n\t// bx + (a-b[a/b])y = gcd(a,b)\n\t// ya + (x-[a/b]y)b = gcd(a,b)\n\tint x_ = 0, y_ = 0;\n\texgcd(b, a%b, x_, y_);\n\tx = y_, y = x_ - (a / b) * y_;\n}\n\nint inverse(int a, int mod) {\n\tint x = 0, y = 0;\n\t// ax - mod k = 1\n\texgcd(a, mod, x, y);\n\treturn (x % mod + mod) % mod;\n}\n\nint solve(int k, int p, int l, int r) {\n    if (r >= l + p) r = l + p - 1;\n    if (r >= p) {\n        int x = (l + k - 1) / k;\n        int res = solve(k, p, l - k * x, r - k * x);\n        if (res == -1) return -1;\n        return x + res;\n    }\n    k %= p;\n    if (l <= -p) {\n        int x = ((- p - l) / p) + 1;\n        l += p * x, r += p * x;\n    }\n    if (!k) {\n        if (l <= 0 && r >= 0)\n            return 0;\n        else \n            return -1;\n    }\n    int q = solve(p, k, -r, -l);\n    if (q == -1) return -1;\n    // ki >= l + qp\n    int ret = max(0ll, (l + 1LL * q * p + k - 1) / k);\n\tif (k * ret > r + 1LL * q*p) {\n\t\tputs(\"???\");\n\t}\n\treturn ret;\n}\n\nint solve(int k, int p, int l, int r, int a) {\n\tint v = 1LL * k * a % p;\n\tl -= v, r -= v;\n\treturn solve(k, p, l, r) + a;\n}\n\nint main() {\n\tscanf(\"%d\", &T);\n\twhile (T --) {\n\t\tscanf(\"%d%d%d%d%d\", &A, &X, &B, &Y, &C);\n\t\tint d = gcd(gcd(A, B), C);\n\t\tA /= d, B /= d, C /= d;\n\t\tint dA = gcd(A, C), dB = gcd(B, C);\n\t\tX /= dB, Y /= dA, C /= (dA * dB);\n\t\tA /= dA, B /= dB;\n\t\tans = 0;\n\t\tA %= C, B %= C;\n\t\tif (!A || !B) {\n\t\t\tif (!A && !B) {\n\t\t\t\tprintf(\"%d\\n\", X+Y);\n\t\t\t} else if (!A) {\n\t\t\t\tprintf(\"%d\\n\", X+Y/C);\n\t\t\t} else {\n\t\t\t\tprintf(\"%d\\n\", X/C+Y);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tint k = 1LL * inverse(B, C) * A % C;\n\t\tint cur_x = 0, cur_y = C;\n\t\twhile (cur_x != C) {\n\t\t\tint nxt_x = solve(C - k, C, 0, cur_y-1, cur_x+1);\n\t\t\tint nxt_y = 1LL * (C - k) * nxt_x % C;\n\t\t\tint delta_x = nxt_x - cur_x, delta_y = cur_y - nxt_y;\n\t\t\tint c = cur_y / delta_y;\n\t\t\tnxt_x = cur_x + delta_x * c;\n\t\t\tnxt_y = cur_y - delta_y * c;\n\t\t\tint L = 0, R = min(cur_x ? (X / cur_x) : 0x3f3f3f3f, nxt_y ? (Y / nxt_y) : (0x3f3f3f3f)), res = 0;\n\t\t\twhile (L <= R) {\n\t\t\t\tint mid = (L + R) >> 1;\n\t\t\t\tll lb = max(0LL, (1LL * mid * cur_y - Y + delta_y - 1) / delta_y), rb = min(1LL*mid*c, (X - 1LL * mid * cur_x) / delta_x);\n\t\t\t\tif (lb <= rb) {\n\t\t\t\t\tres = mid;\n\t\t\t\t\tL = mid + 1;\n\t\t\t\t} else R = mid - 1;\n\t\t\t}\n\t\t\tans = max(ans, res);\n\t\t\tcur_x = nxt_x, cur_y = nxt_y;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nint gcd(re int a,re int b)\n{\n\tif(!b)return a;\n\treturn gcd(b,a%b);\n}\nvoid exgcd(re int a,re int b,re int&x,re int &y)\n{\n\tif(!b){x=1;y=0;return;}\n\texgcd(b,a%b,y,x);\n\ty-=a/b*x;\n}\nint a,b,c,d,x,y,x1,y1,x2,y2,c1,d1,c2,d2,rd;\nlong long sol()\n{\n\tre int l=0,r=(y1-y2)/d2-1,xx,yy,xx1,yy1;\n\tfor(re int mid=(l+r+1)/2;l<r;mid=(l+r+1)/2)\n\t{\n\t\tyy=y1-mid*d2,xx=1ll*rd*yy%c;\n\t\tif(1ll*x*yy>=1ll*xx*y)l=mid;\n\t\telse r=mid-1;\n\t}\n\tyy=y1-l*d2;xx=1ll*rd*yy%c;yy1=yy-d2;xx1=1ll*rd*yy1%c;\n\tre long long xl1=xx-xx1,yl1=yy-yy1,xxl,yyl;\n\tl=0,r=1e9;\n\tfor(re int mid=(l+r+1)/2;l<r;mid=(l+r+1)/2)\n\t{\n\t\txxl=x+1ll*mid*xl1,yyl=y+1ll*mid*yl1;\n\t\tif((long double)xxl*yy>=(long double)xx*yyl)l=mid;\n\t\telse r=mid-1;\n\t}\n\txxl=x+l*xl1,yyl=y+l*yl1;//printf(\"****%lld %lld %d %d %d %d %d\\n\",xxl,yyl,xx,yy,xx1,yy1,l);\n\tre long long ans=std::min(xx?xxl/xx:(1ll<<60),yy?yyl/yy:(1ll<<60));\n\txxl+=xl1;yyl+=yl1;\n\tif(xxl>=0&&yyl>=0)ans=std::max(ans,std::min(xx?xxl/xx:(1ll<<60),yy?yyl/yy:(1ll<<60)));\n\treturn ans;\n}\nint main()\n{\n\tre int T;\n\tscanf(\"%d\",&T);\n\tfor(;T--;)\n\t{\n\t\tscanf(\"%d%d%d%d%d\",&a,&x,&b,&y,&c);\n\t\tre int g=gcd(a,b);a/=g,b/=g,c/=gcd(c,g);\n\t\tg=gcd(a,c);a/=g;c/=g;y/=g;\n\t\tg=gcd(b,c);b/=g;c/=g;x/=g;\n\t\texgcd(b,c,x1,y1);\n\t\td=1ll*a*(x1+c)%c;//printf(\"**%d %d %d c:%d d:%d %lld\\n\",a,b,gcd(a,b),c,d,1ll*(x1+c)*b%c);\n\t\texgcd(d,c,x1,y1);\n\t\trd=(c-x1)%c;\n\t\tc1=c,d1=d;\n\t\twhile(c1!=0)\n\t\t{\n\t\t\tx1=1ll*rd*c1%c;y1=c1;\n\t\t\tc2=c1,d2=d1;\n\t\t\tif(d1)c1%=d1;\n\t\t\telse c1=0;\n\t\t\tif(c1)d1%=c1;\n\t\t\telse d1=0;\n\t\t\tif(d1==0)d1=c1;\n\t\t\tre int x2=1ll*rd*c1%c,y2=c1;\n\t\t//printf(\"****%d %d %d %d %d %d\\n\",x1,y1,x2,y2,d,d2);\n\t\t\tif(1ll*x*y1>=1ll*x1*y&&1ll*x2*y>=1ll*x*y2)\n\t\t\t{\n\t\t\t\tprintf(\"%lld\\n\",sol());break;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\ninline int exgcd(int a,int b,int &x,int &y){\n\tif (!b) return x=1,y=0,a;\n\tint g=exgcd(b,a%b,y,x);\n\treturn y-=a/b*x,g;\n}\ninline int inv(int A,int mod){\n\tint x,y;\n\texgcd(A,mod,x,y);\n\treturn x<0?x+mod:x;\n}\n\nint A,B,C,D,X,Y;\n\ninline void init(){\n\tint g=__gcd(__gcd(A,B),C);\n\tA/=g,B/=g,C/=g;\n\tg=__gcd(A,C),Y/=g,C/=g;\n\tg=__gcd(B,C),X/=g,C/=g;\n}\nvector<int>x,cnt;\ninline void Get(){\n\tD=1ll*A*inv(B,C)%C,x.clear(),cnt.clear();\n\tint W=C,H=D,now=0,invD=inv(D,C);\n\twhile (W){\n\t\tint tmp=W/H;\n\t\tcnt.pb(tmp),x.pb(1ll*now*invD%C),now+=tmp*H;\n\t\tW%=H;\n\t\tif (!W) break;\n\t\tH%=W;\n\t\tif (H==0) H=W;\n\t}\n\tx.pb(C),cnt.pb(0);\n}\ninline int Get(int x){\n\treturn x==0?C:(C-1ll*x*D%C)%C;\n}\ninline void solve(){\n\tA=read(),X=read(),B=read(),Y=read(),C=read();\n\tinit(),Get();\n\tll ans=0;\n\tFOR(i,0,siz(x)-2){\n\t\tint lx=x[i],ly=Get(lx),rx=x[i+1],ry=Get(rx),dx=(rx-lx)/cnt[i],dy=(ly-ry)/cnt[i];\n\t\tll l=0,r=X+Y,ret=0;\n\t\twhile (l<=r){\n\t\t\tll mid=l+r>>1;\n\t\t\tif (X-mid*lx>=0&&Y-mid*ry>=0){\n\t\t\t\tll a=(X-mid*lx)/dx,b=(Y-mid*ry)/dy;\n\t\t\t\tif (a>=0&&b>=0&&a+b>=mid*cnt[i]) l=mid+1,ret=mid;\n\t\t\t\t\telse r=mid-1;\n\t\t\t} else r=mid-1;\n\t\t}\n\t\tans=max(ans,ret);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\tint T=read();\n\twhile (T--) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \n//int cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n/**\n * Description: euclid finds ${x,y}$ such that $ax+by=\\gcd(a,b)$ \n \t* and $|ax|,|by|\\le \\frac{ab}{\\gcd(a,b)}.$ Should work for $a,b<2^{62}$\n * Source: KACTL\n * Time: O(\\log ab)\n */\n\npl euclid(ll a, ll b) { \n\tif (!b) return {1,0};\n\tpl p = euclid(b,a%b); return {p.s,p.f-a/b*p.s}; }\nll invGen(ll a, ll b) { \n\tpl p = euclid(a,b); assert(p.f*a+p.s*b == 1); // gcd is 1\n\treturn p.f+(p.f<0)*b; }\n\n/**\n * Description: finds smallest $x\\ge 0$ such that $L\\le Ax\\pmod{P}\\le R$\n * Source: https://codeforces.com/gym/102411/submission/64315879\n * Verification: https://codeforces.com/gym/102411/problem/G\n */\n\nll cdiv(ll x, ll y) { return (x+y-1)/y; }\nll bet(ll P, ll A, ll L, ll R) { \n\tif (A == 0) return L == 0 ? 0 : -1;\n\tll c = cdiv(L,A); if (A*c <= R) return c;\n\tll B = P%A; // P = k*A+B, L <= A(x-Ky)-By <= R \n\t// => -R <= By % A <= -L\n\tauto y = bet(A,B,A-R%A,A-L%A); \n\treturn y == -1 ? y : cdiv(L+B*y,A)+P/A*y;\n}\n\n\nll A,X,B,Y,C;\nint solve() {\n\tre(A,X,B,Y,C);\n\tll g = __gcd(A,B);\n\tA /= g, B /= g; C /= __gcd(g,C);\n\tF0R(i,2) {\n\t\tint t = __gcd(A,C);\n\t\tY /= t; A /= t, C /= t;\n\t\tswap(A,B); swap(X,Y);\n\t}\n\tassert(__gcd(A,B) == 1 && __gcd(B,C) == 1 && __gcd(C,A) == 1);\n\tdbg(\"OK\",A,B,C,X,Y);\n\tif (C == 1) return X+Y;\n\tvpi posi; posi.pb({0,C});\n\tint con = -1LL*A*invGen(B,C)%C; con = (con+C)%C;\n\twhile (1) {\n\t\tint L = 1, R = posi.bk.s-1;\n\t\tll x = bet(C,con,L,R); if (x == -1) break;\n\t\tposi.pb({x,con*x%C});\n\t\t// 0 < (-A*x)*B^{-1} < posi.bk.s mod C\n\t}\n\tposi.pb({C,0});\n\tdbg(posi);\n\tll ans = 0;\n\ttrav(t,posi) {\n\t\tll mul = INF;\n\t\tif (t.f) ckmin(mul,X/t.f);\n\t\tif (t.s) ckmin(mul,Y/t.s);\n\t\tckmax(ans,mul);\n\t}\n\tF0R(i,sz(posi)-1) {\n\t\tpi a = posi[i], b = posi[i+1];\n\t\tauto ok = [&](ll mid) -> bool {\n\t\t\tif (a.f*mid > X || b.s*mid > Y) return 0;\n\t\t\tll L = 0, R = mid;\n\t\t\tif (b.f*mid > X) {\n\t\t\t\t// a.f*x+b.f*(mid-x) <= X\n\t\t\t\t// (a.f-b.f)*x+b.f*mid <= X\n\t\t\t\t// x*(b.f-a.f) >= b.f*mid-X\n\t\t\t\tL = cdiv(b.f*mid-X,b.f-a.f);\n\t\t\t}\n\t\t\tif (a.s*mid > Y) {\n\t\t\t\t// a.s*x+b.s*(mid-x) <= Y\n\t\t\t\t// (a.s-b.s)*x <= Y-b.s*mid\n\t\t\t\tR = (Y-b.s*mid)/(a.s-b.s);\n\t\t\t}\n\t\t\treturn L <= R;\n\t\t};\n\t\tll lo = 0, hi = X+Y;\n\t\twhile (lo < hi) {\n\t\t\tll mid = (lo+hi+1)/2;\n\t\t\tif (ok(mid)) lo = mid;\n\t\t\telse hi = mid-1;\n\t\t}\n\t\tckmax(ans,lo);\n\t}\n\t// dbg(\"HA\",posi);\n\treturn ans;\n\t// Ax+By is divisible by C\n\t// what if gcd(A,C) > 1?\n\t// gcd(B,C) > 1?\n}\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) ps(solve());\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\n#define int long long\nusing namespace std;\ntypedef long long ll;\nint T, A, B, X, Y, C;\nint x, y;\nvoid exgcd(int a, int b, int &x, int &y){\n\tif(!b) return x=1,y=0,void();\n\texgcd(b,a%b,x,y); int _x=y, _y=x-a/b*y; x=_x; y=_y;\n}\nint inv(int a, int b){\n\texgcd(a,b,x,y);\n\tx = (x % b + b) % b; return x;\n}\nstruct dat{ int x, y, ct; };\nvector<dat> pt;\nvoid cope(int c, int d){\n\tpt.pb((dat){0,0,0}); int a=1, b=0;\n\twhile(d){\n\t\tdat t = pt.back();\n\t\tpt.pb((dat){t.x+c/d*a,t.y+c/d*d,c/d});\n\t\tfor(int _=1,x;_<=2;_++){\n\t\t\tif(_==1)b+=c/d*a;\n\t\t\tif(_==2)a+=c/d*b;\n\t\t\tx=c%d,c=d,d=x;\n\t\t}\n\t}\n} int clc(ll x, ll y){ return x<0?-1:x/y; }\nvoid Main(){\n\tscanf(\"%lld%lld%lld%lld%lld\",&A,&X,&B,&Y,&C);\n\tint t = __gcd(A,B); A/=t; B/=t; C/=__gcd(t,C);\n\tt = __gcd(A,C); A/=t, C/=t, Y/=t;\n\tt = __gcd(B,C); B/=t, C/=t, X/=t;\n\tif(C==1)return cout<<X+Y<<'\\n',void();\n\tint D = (ll)A * inv(B,C) % C;\n\tcope(C,D); int ans = 0;\n\tif(pt.back().x!=C)pt.pb((dat){C,C,1});\n\tfor(int i=1; i<pt.size(); i++){\n\t\tint lx=pt[i-1].x,rx=pt[i].x;\n\t\tint ly=C-pt[i-1].y,ry=C-pt[i].y;\n\t\tint dx=(rx-lx)/pt[i].ct, dy=(ly-ry)/pt[i].ct;\n\t\tint l=ans+1,r=X+Y;\n\t\twhile(l<=r){\n\t\t\tint mid=(ll)(l+r)>>1;\n\t\t\tll S=clc(X-(ll)mid*lx,dx);\n\t\t\tll T=clc(Y-(ll)mid*ry,dy);\n\t\t\tif(~S&&~T&&S+T>=(ll)mid*pt[i].ct)ans=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t} \n\t} cout<<ans<<'\\n'; pt.clear();\n}\nsigned main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d\",&T);\n\twhile(T--)Main();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1007*1007;\n\nll a, b, c, x, y;\n\nll wyn;\n\nvoid eukl(ll &x, ll &y, ll a, ll b) {\n\tif (!a) { x = 0; y = 1; return; }\n\teukl(y, x, b % a, a);\n\tx -= y * (b / a);\n}\n\nll odw(ll v)\n{\n\tll x, y;\n\teukl(x, y, v, c);\n\tx%=c;\n\tx+=c;\n\tx%=c;\n\treturn x;\n}\n\nvoid relax()\n{\n\tll g=__gcd(a, b);\n\tg=__gcd(g, c);\n\ta/=g;\n\tb/=g;\n\tc/=g;\n\t\n\tg=__gcd(a, b);\n\ta/=g;\n\tb/=g;\n\t\t\n\tg=__gcd(a, c);\n\ta/=g;\n\tc/=g;\n\ty/=g;\n\t\n\tg=__gcd(b, c);\n\tb/=g;\n\tc/=g;\n\tx/=g;\n}\n\nvector<pll> sta;\nvector<pll> dod;\nvll razy;\nll jest;\n\npll dajkt(int v, ll x)\n{\n\treturn {sta[v].first+x*dod[v].first, sta[v].second+x*dod[v].second};\n}\n\npll daj(ll x)\n{\n\tint v=0;\n\twhile(razy[v]<=x)\n\t{\n\t\tx-=razy[v];\n\t\tv++;\n\t}\n\treturn dajkt(v, x);\n}\n\nvoid euklides()\n{\n\tll mno=odw(b)*a;\n\tmno%=c;\n\tmno=c-mno;\n\tmno%=c;\n\t\n\tsta.clear();\n\tdod.clear();\n\trazy.clear();\n\tll mini=1;\n\tll maxi=1;\n\tll wmi=mno;\n\tll wma=mno;\n\tsta.push_back({0, c});\n\tdod.push_back({0, 0});\n\trazy.push_back(1);\n\tsta.push_back({1, mno});\n\tdod.push_back({0, 0});\n\trazy.push_back(1);\n\twhile(mini+maxi<=c)\n\t{\n\t\tif ((wmi+wma)%c<wmi)\n\t\t{\n\t\t\tll ile=wmi/(c-wma);\n\t\t\tsta.push_back({mini+maxi, (wmi+wma)%c});\n\t\t\tdod.push_back({maxi, wma-c});\n\t\t\trazy.push_back(ile);\n\t\t\tmini+=ile*maxi;\n\t\t\twmi+=ile*wma;\n\t\t\twmi%=c;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll ile=(c-wma-1)/wmi;\n\t\t\tmaxi+=ile*mini;\n\t\t\twma+=ile*wmi;\n\t\t\twma%=c;\n\t\t}\n\t}\n\tjest=0;\n\tfor (ll i : razy)\n\t\tjest+=i;\n}\n\nint check(ll v)\n{\n\tll bsa=0;\n\tll bsb=jest;\n\twhile(bsa<bsb)\n\t{\n\t\tll bss=(bsa+bsb+2)>>1;\n\t\tif (daj(bss).first*v<=x)\n\t\t\tbsa=bss;\n\t\telse\n\t\t\tbsb=bss-1;\n\t}\n\tll g=bsa;\n\tif (g==jest-1)\n\t\treturn 1;\n\tpll lew=daj(g);\n\tpll pra=daj(g+1);\n\tbsa=0;\n\tbsb=v;\n\twhile(bsa<bsb)\n\t{\n\t\tll bss=(bsa+bsb+2)>>1;\n\t\tif (bss*pra.first+(v-bss)*lew.first<=x)\n\t\t\tbsa=bss;\n\t\telse\n\t\t\tbsb=bss-1;\n\t}\n\treturn (bsa*pra.second+(v-bsa)*lew.second<=y);\n}\n\nvoid test()\n{\n\tscanf(\"%lld%lld%lld%lld%lld\", &a, &x, &b, &y, &c);\n\ta%=c;\n\tb%=c;\n\twyn=0;\n\tif (!a || !b)\n\t{\n\t\tll jed=c/__gcd(c, a);\n\t\tll dwa=c/__gcd(c, b);\n\t\tprintf(\"%lld\\n\", x/jed+y/dwa);\n\t\treturn;\n\t}\n\trelax();\n\teuklides();\n\tll bsa=0;\n\tll bsb=x+y;\n\twhile(bsa<bsb)\n\t{\n\t\tll bss=(bsa+bsb+2)>>1;\n\t\tif (check(bss))\n\t\t\tbsa=bss;\n\t\telse\n\t\t\tbsb=bss-1;\n\t}\n\tprintf(\"%lld\\n\", bsa);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <tuple>\nusing namespace std;\n#define endl '\\n'\n#define ll long long\n#define pi pair<int, int>\n#define pii pair<int, pi>\n#define f first\n#define s second\n\nll inv(ll a, ll mod){\n\tll b = mod, x = 0, y = 1, u = 1, v = 0;\n\twhile(a){\n\t\tll q = b / a, r = b % a;\n\t\ttie(x, y, u, v) = make_tuple(u, v, x - u * q, y - v * q);\n\t\tb = a, a = r;\n\t}\n\treturn x + (x < 0) * mod;\n}\n\nll a, x, b, y, c;\nll g, w, h, ia;\nvector<pii> v;\n\nbool works(ll f){\n\tint l = 0, r = v.size();\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(f * (c - v[mid].s.s) >= y) l = mid;\n\t\telse r = mid;\n\t}\n\tif(l == v.size() - 1) return 0;\n\t\n\tll dx = v[r].s.f - v[l].s.f, dy = v[r].s.s - v[l].s.s;\n\tdx /= v[r].f, dy /= v[r].f;\n\t\n\treturn l < v.size() - 1 && f * v[l].s.f + \n\t\tmin(0x3f3f3f3fll, (f * (c - v[l].s.s) + dy - y - 1)) / dy * dx <= x; \n}\n\nvoid answer(){\n\tcin >> a >> x >> b >> y >> c;\t\n\t\n\tg = __gcd(a, b);\n\ta /= g, b /= g, c /= __gcd(g, c);\n\tg = __gcd(a, c);\n\ta /= g, y /= g, c /= g;\n\tg = __gcd(b, c);\n\tb /= g, x /= g, c /= g;\n\t\n\tif(c == 1){\n\t\tcout << x + y << endl;\n\t\treturn;\n\t}\n\t\n\tw = c, h = a * inv(b, c) % c, ia = inv(a, c);\n\tv.assign(1, {1, {0, 0}});\n\twhile(w && h){\n\t\tif(w > h){\n\t\t\tll t = w / h;\n\t\t\tw -= t * h;\n\t\t\tv.push_back({t, {(c - w) * b % c * ia % c, c - w}});\n\t\t\tv.back().s.f += !v.back().s.f * c;\n\t\t}else if(h % w){\n\t\t\th %= w;\n\t\t}else{\n\t\t\tv.push_back({1, {c, c}});\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tll l = y / c, r = x + y + 1;\n\twhile(r - l > 1){\n\t\tll mid = (l + r) / 2;\n\t\tif(works(mid)) l = mid;\n\t\telse r = mid;\n\t}\n\t\n\tcout << l << endl;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor(int i = 0; i < t; i++) answer();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lol;\nconst int N = 1e3 + 5;\nint _w;\n\nint A , B , X , Y , C;\n\nvoid exgcd( int a , int b , lol & x , lol & y ) {\n  if( !b ) {\n    x = 1, y = 0;\n    return;\n  } exgcd( b , a % b , y , x );\n  y -= a / b * x;\n}\n\nint inv( int a , int m ) {\n  lol x , y;\n  exgcd( a , m , x , y );\n  x = ( x % m + m ) % m;\n  return x;\n}\n\ninline void solve( void ) {\n  _w = scanf(\"%d%d%d%d%d\",&A,&X,&B,&Y,&C);\n  int g = __gcd( A , B );\n  A /= g , B /= g , C /= __gcd( g , C );\n  for( int _ = 0 , t ; _ < 2 ; ++_ ) {\n    g = __gcd( A , C );\n    A /= g , C /= g;\n    t = __gcd( g , B );\n    B /= t , Y /= g / t;\n    swap( A , B ) , swap( X , Y );\n  }\n  if( C == 1 ) {\n    printf(\"%d\\n\",X+Y);\n    return;\n  }\n  int D = (lol)A * inv( B , C ) % C , ID = inv( D , C );\n  vector<int> x , y , n;\n  int W = C , H = D;\n  lol now = 0;\n  while( W ) {\n    int d = W / H;\n    x.push_back( (now%C) * ID % C );\n    if( now == 0 ) y.push_back( C );\n    else y.push_back( ( C - now ) % C );\n    n.push_back( d );\n    now += d * H;\n    W %= H;\n    if( !W ) break;\n    H %= W;\n    if( !H ) H = W;\n  }\n  x.push_back( C ) , y.push_back( 0 );\n  int ans = 0;\n  function<lol(lol,lol)> Div = []( lol a , lol b ) {\n    return a / b - ( a % b && (a^b) < 0 );\n  };\n  for( int i = 1 , lx , ly , rx , ry , ct , l , r , mid , res , dx , dy ; i < int(x.size()) ; ++i ) {\n    lx = x[i - 1] , rx = x[i] , ly = y[i - 1] , ry = y[i] , ct = n[i - 1];\n    l = 0 , r = X + Y + 1 , res = -1 , dx = ( rx - lx ) / ct , dy = ( ly - ry ) / ct;\n    while( l <= r ) {\n      mid = ( l + r ) >> 1;\n      lol p = Div( X - (lol)mid * lx , dx );\n      lol q = Div( Y - (lol)mid * ry , dy );\n      if( p >= 0 && q >= 0 && p + q >= (lol)ct * mid ) \n        res = mid , l = mid + 1;\n      else r = mid - 1;\n    }\n    ans = max( ans , res );\n  }\n  printf(\"%d\\n\",ans);\n}\n\nint main( void ) {\n  int T;\n  _w = scanf(\"%d\",&T);\n  while( T-- ) solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() { cout << \"˚‧º·(˚ ˃̣̣̥ ⌓ ˂̣̣̥ )‧º·˚\" << endl; }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint T;\nll A,X,B,Y,C,TC;\n\nconst int prime_max = 1000000;\nvector<int> prime;\nint NP,divp[prime_max];\n\nvoid cprime() {\n\tif(NP) return;\n\tfor(int i=2;i<prime_max;i++) if(divp[i]==0) {\n\t\tprime.push_back(i); NP++;\n\t\tfor(ll j=1LL*i*i;j>=i&&j<prime_max;j+=i) if(divp[j]==0) divp[j]=i;\n\t}\n}\n\nll totient(ll v) {\n\tcprime();\n\tll ret=v;\n\tFORR(p,prime) {\n\t\tif(1LL*p*p>v) break;\n\t\tif(v%p==0) {\n\t\t\tret=ret/p*(p-1);\n\t\t\twhile(v%p==0) v/=p;\n\t\t}\n\t}\n\tif(v>1) ret=ret/v*(v-1);\n\treturn ret;\n}\n\nll modpow(ll a, ll n,ll mo) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>T;\n\twhile(T--) {\n\t\tcin>>A>>X>>B>>Y>>C;\n\t\tll g=__gcd(A,B),g2;\n\t\t\n\t\tA/=g;\tB/=g;\tC/=__gcd(g,C);\n\t\tg=__gcd(A,C);\tA/=g;\tC/=g;\tg2=gcd(B,g);\tB/=g2;\tY/=g/g2;\n\t\tg=__gcd(B,C);\tB/=g;\tC/=g;\tg2=gcd(A,g);\tA/=g2;\tX/=g/g2;\n\t\tif(C==1) {\n\t\t\tcout<<X+Y<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tA%=C;\n\t\tB%=C;\n\t\t\n\t\tTC=totient(C);\n\t\t\n\t\tvector<vector<ll>> cand;\n\t\tll D=A*modpow(B,TC-1,C)%C;\n\t\tcand.push_back({0,C,0});\n\t\tll H=D,W=0;\n\t\twhile(1) {\n\t\t\tH%=(C-W);\n\t\t\tif(H==0) {\n\t\t\t\tH=C-W;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tll dif=(C-W)%H;\n\t\t\tif(dif==0) break;\n\t\t\tW=C-dif;\n\t\t\tll X=W*modpow(D,TC-1,C)%C;\n\t\t\tll Y=(C-D*X%C)%C;\n\t\t\tcand.push_back({X,Y,dif/H+1});\n\t\t}\n\t\tcand.push_back({C,0,(C-W)/H});\n\t\t\n\t\tll ret=0;\n\t\t//cout<<A<<\" \"<<X<<\" \"<<B<<\" \"<<Y<<\" \"<<C<<endl;\n\t\tFORR(c,cand) {\n\t\t\t//cout<<c.first<<\" \"<<c.second<<endl;\n\t\t\tif(c[0]==0) ret=max(ret,Y/c[1]);\n\t\t\telse if(c[1]==0) ret=max(ret,X/c[0]);\n\t\t\telse ret=max(ret,min(X/c[0],Y/c[1]));\n\t\t}\n\t\t//cout<<ret<<endl;\n\t\tFOR(i,cand.size()-1) {\n\t\t\tll AX=cand[i][0],AY=cand[i][1];\n\t\t\tll BX=cand[i+1][0],BY=cand[i+1][1];\n\t\t\tif(AY*X<=AX*Y || BY*X>=BX*Y) continue;\n\t\t\tll step=cand[i+1][2];\n\t\t\tll g=__gcd(BX-AX,AY-BY);\n\t\t\tassert(g%step==0);\n\t\t\tll dx=(BX-AX)/step;\n\t\t\tll dy=(BY-AY)/step;\n\t\t\t\n\t\t\tint cur=0;\n\t\t\tfor(j=29;j>=0;j--) if(cur+(1<<j)<step) {\n\t\t\t\tll CX=AX+(cur+(1<<j))*dx;\n\t\t\t\tll CY=AY+(cur+(1<<j))*dy;\n\t\t\t\tif(CY*X>CX*Y) cur+=1<<j;\n\t\t\t}\n\t\t\tll TX=AX+cur*dx;\n\t\t\tll TY=AY+cur*dy;\n\t\t\tll SX=TX+dx;\n\t\t\tll SY=TY+dy;\n\t\t\t//cout<<step<<endl;\n\t\t\t//cout<<\"!\"<<(TX*A+TY*B)%C<<endl;\n\t\t\t//cout<<\"!\"<<(SX*A+SY*B)%C<<endl;\n\t\t\tret=max(ret,min(TX?(X/TX):(1<<30),TY?(Y/TY):(1<<30)));\n\t\t\tret=max(ret,min(SX?(X/SX):(1<<30),SY?(Y/SY):(1<<30)));\n\t\t\tFOR(r,2) {\n\t\t\t\tll mx=0;\n\t\t\t\tfor(j=29;j>=0;j--) {\n\t\t\t\t\t__int128_t lef=(-TX*(mx+(1<<j))+X)*(__int128_t)SY;\n\t\t\t\t\t__int128_t ri=(-TY*(mx+(1<<j))+Y)*(__int128_t)SX;\n\t\t\t\t\tif(lef<ri) mx+=1<<j;\n\t\t\t\t}\n\t\t\t\t//cout<<i<<\":: \"<<SX<<\" \"<<SY<<\" \"<<TX<<\" \"<<TY<<\" \"<<X<<\" \"<<Y<<\" \"<<mx<<\" \"<<ret<<endl;\n\t\t\t\tfor(ll x=max(0LL,mx-2);x<=mx+2;x++) if(x>=0) {\n\t\t\t\t\tll LX=X-TX*x;\n\t\t\t\t\tll LY=Y-TY*x;\n\t\t\t\t\tif(LX>=0&LY>=0) {\n\t\t\t\t\t\tret=max(ret,x+min(SX?(LX/SX):(1<<30),SY?(LY/SY):(1<<30)));\n\t\t\t\t\t\t//cout<<x<<\" \"<<x+min(SX?(LX/SX):(1<<30),SY?(LY/SY):(1<<30))<<endl;\n\t\t\t\t\t\tll y=min(SX?(LX/SX):(1<<30),SY?(LY/SY):(1<<30));\n\t\t\t\t\t\tll XX=TX*x+SX*y;\n\t\t\t\t\t\tll YY=TY*x+SY*y;\n\t\t\t\t\t\t//cout<<(X>=XX)<<\" \"<<(Y>=YY)<<\" \"<<x+y<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout<<i<<\":: \"<<SX<<\" \"<<SY<<\" \"<<TX<<\" \"<<TY<<\" \"<<X<<\" \"<<Y<<\" \"<<mx<<\" \"<<ret<<endl;\n\t\t\t\tswap(TX,SY);\n\t\t\t\tswap(SX,TY);\n\t\t\t\tswap(X,Y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<ret<<endl;\n\t\t\n\t\t\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <tuple>\nusing namespace std;\n#define endl '\\n'\n#define ll long long\n#define pi pair<int, int>\n#define pii pair<int, pi>\n#define f first\n#define s second\n\nll inv(ll a, ll mod){\n\tll b = mod, x = 0, y = 1, u = 1, v = 0;\n\twhile(a){\n\t\tll q = b / a, r = b % a;\n\t\ttie(x, y, u, v) = make_tuple(u, v, x - u * q, y - v * q);\n\t\tb = a, a = r;\n\t}\n\treturn x + (x < 0) * mod;\n}\n\nll a, x, b, y, c;\nll g, w, h, ia;\nvector<pii> v;\n\nbool works(ll f){\n\tll l = 0, r = v.size();\n\twhile(r - l > 1){\n\t\tll mid = (l + r) / 2;\n\t\tif(f * (c - v[mid].s.s) >= y) l = mid;\n\t\telse r = mid;\n\t}\n\tif(l == v.size() - 1) return 0;\n\t\n\tll dx = v[r].s.f - v[l].s.f, dy = v[r].s.s - v[l].s.s;\n\tdx /= v[r].f, dy /= v[r].f;\n\t\n\treturn l < v.size() - 1 && f * v[l].s.f + \n\t\tmin(0x3f3f3f3fll, (f * (c - v[l].s.s) + dy - y - 1) / dy) * dx <= x; \n}\n\nvoid answer(){\n\tcin >> a >> x >> b >> y >> c;\t\n\t\n\tg = __gcd(a, b);\n\ta /= g, b /= g, c /= __gcd(g, c);\n\tg = __gcd(a, c);\n\ta /= g, y /= g, c /= g;\n\tg = __gcd(b, c);\n\tb /= g, x /= g, c /= g;\n\t\n\tw = c, h = a * inv(b, c) % c, ia = inv(a, c);\n\tv.assign(1, {1, {0, 0}});\n\twhile(w && h){\n\t\tif(w > h){\n\t\t\tll t = w / h;\n\t\t\tw -= t * h;\n\t\t\tv.push_back({t, {(c - w) * b % c * ia % c, c - w}});\n\t\t\tv.back().s.f += !v.back().s.f * c;\n\t\t}else if(h % w){\n\t\t\th %= w;\n\t\t}else{\n\t\t\tv.push_back({1, {c, c}});\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tll l = y / c, r = x + y + 1;\n\twhile(r - l > 1){\n\t\tll mid = (l + r) / 2;\n\t\tif(works(mid)) l = mid;\n\t\telse r = mid;\n\t}\n\t\n\tcout << l << endl;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor(int i = 0; i < t; i++) answer();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "非常に難しい問題楽しみ〜"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\nint great(vector<int> v,int a,int b,int c,int x,int y){\n  int ans;\n  int n;\n  n=0;\n  for(int i=1;i<=x;i++){\n    n+=a;\n    if(n%c==0){\n      ++ans;\n    }\n  }\n  n=0;\n  for(int i=1;i<=y;i++){\n    n+=b;\n    if(n%c==0){\n      ++ans;\n    }\n  }\n  return ans;\n}\nint main(void){\n  int t,a,b,c,x,y;\n  cin>>t;\n  for(int i=0;i<t;i++){\n    cin>>a>>x>>b>>y>>c;\n    vector<int> vec(x+y);\n    rep(j,x){\n      vec.pb(a);\n    }\n    rep(k,y){\n      vec.pb(b);\n    }\n    cout<<great(vec,a,b,c,x,y)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T, class S> void Dump(map<T, S> &m){\n\tfor(auto e: m) cout << e.first << \" : \" << e.second << '\\n';\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nll div(ll a, ll b, ll mod){ ///////////////////ライブラリにする\n\tll c=b, d=mod, u=1, v=0;\n\twhile (d){\n\t\tll t = c / d;\n\t\tc -= t * d; swap(c, d);\n\t\tu -= t * v; swap(u, v);\n\t}\n\ta = a * u % mod;\n\tif (a < 0) a += mod;\n\treturn a;\n}\n\nvoid solve()\n{\n\tll A, X, B, Y, C;  cin >> A >> X >> B >> Y >> C;\n\n\t{\n\t\tll g=Gcd(Gcd(A, B), C);\n\t\tA/=g;\n\t\tB/=g;\n\t\tC/=g;\n\t}\n\tll a=gcd(A, C);\n\tll b=gcd(B, C);\n\tll x1=b;\n\tll p=C/b-A;\n\tll BB=B/b;\n\tll CC=C/b;\n\tll y1=div(p, BB, CC);\n\n\tll x0=0;\n\tll y0=CC;\n\n\tll t;\n\twhile (true){\n\t\t//(xe,ye)を求める\n\t\tt=y0/(y0-y1);\n\t\tll xe=x0+t*(x1-x0);\n\t\tll ye=y0-t*(y0-y1);\n\n\t\t//(X,Y)を下回ったらbreak\n\t\tif (Y*xe>=X*ye) break;\n\n\t\t//次の(x0,y0),(x1,y1)を求める\n\t\tll xm=x0+(t-1)*(x1-x0);\n\t\tll ym=y0-(t-1)*(y0-y1);\n\t\tx0=xe;\n\t\ty0=ye;\n\t\tll k=CEIL(ym, y0);\n\t\tx1=x0*k-xm;\n\t\ty1=y0*k-ym;\n\t}\n\n\t//出力 (x0,y0), (x1,y1), t\n\n\t//(X,Y)の両脇を求める\n\tll xp, yp, xq, yq;\n\t{\n\t\tll ng=0;\n\t\tll ok=t;\n\t\twhile (abs(ng-ok)>1){\n\t\t\tll m=(ng+ok)/2;\n\t\t\tll xm=x0+m*(x1-x0);\n\t\t\tll ym=y0-m*(y0-y1);\n\t\t\tif (Y*xm>=X*ym) ok=m; else ng=m;\n\t\t}\n\t\txp=x0+ng*(x1-x0);\n\t\typ=y0-ng*(y0-y1);\n\t\txq=x0+ok*(x1-x0);\n\t\tyq=y0-ok*(y0-y1);\n\t}\n\n\t//両脇(xp,yp),(xq,yq)が何個ずつ取れるか\n\tll ans=0;\n\t{\n\t\tll ng=Y/yp+10;\n\t\tll ok=0;\n\t\twhile (abs(ng-ok)>1){\n\t\t\tll m=(ng+ok)/2;\n\t\t\tll xx=X-xp*m;\n\t\t\tll yy=Y-yp*m;\n\t\t\tif (yy>=0 and xq*yy>=xx*yq) ok=m; else ng=m;\n\t\t}\n\t\t{\n\t\t\tll xxx=X-xp*ok;\n\t\t\t//ll yyy=Y-yp*ok;\n\t\t\tll qnm=xxx/xq;\n\t\t\tchmax(ans, ok+qnm);\n\t\t}\n\t\t{\n\t\t\t//ll xxx=X-xp*ng;\n\t\t\tll yyy=Y-yp*ng;\n\t\t\tif (yyy>=0){\n\t\t\t\tll qnm=yyy/yq;\n\t\t\t\tchmax(ans, ng+qnm);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n#if 0\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint T,A,X,B,Y,C,D;\nvector<pair<int,int> > s;\nint _gcd(int a,int b){\n\tif(b==0)return a;\n\treturn _gcd(b,a%b);\n}\nvoid init(){\n\tint g=_gcd(A,B);\n\tA/=g,B/=g,C/=_gcd(g,C);\n\tg=_gcd(A,C),A/=g,C/=g,Y/=g;\n\tg=_gcd(B,C),B/=g,C/=g,X/=g;\n}\nvoid exgcd(int a,int b,int &x,int &y){\n\tif(b==0){\n\t\tx=1,y=0;\n\t\treturn;\n\t}\n\texgcd(b,a%b,x,y);\n\tint t=x;\n\tx=y;\n\ty=t-a/b*y;\n}\nint Inv(int a,int mod){\n\tint x,y;\n\texgcd(a,mod,x,y);\n\treturn (x+mod)%mod;\n}\nint Get(int x){\n\treturn !x?C:(C-1LL*x*D%C)%C;\n}\nvoid Get_seg(){\n\tD=1LL*A*Inv(B,C)%C;\n\ts.clear();\n\tint W=C,H=D,now=0,invD=Inv(D,C);\n\twhile(\"MAK AK IOI!\"){\n\t\ts.emplace_back(W/H,(int)(1LL*now*invD%C));\n\t\tnow+=W/H*H;\n\t\tif(!(W%=H))break;\n\t\tif(!(H%=W))H=W;\n\t}\n\ts.emplace_back(0,C);\n}\nint main(){\n\tT=read();\n\twhile(T--){\n\t\tA=read(),X=read(),B=read(),Y=read(),C=read();\n\t\tinit();\n\t\tif(C==1){\n\t\t\tprintf(\"%d\\n\",X+Y);\n\t\t\tcontinue;\n\t\t}\n\t\tGet_seg();\n\t\tint mx=0;\n\t\tfor(int i=0;i<(int)s.size()-1;++i){\n\t\t\tint lx=s[i].second,rx=s[i+1].second;\n\t\t\tint ly=Get(lx),ry=Get(rx);\n\t\t\tint dx=(rx-lx)/s[i].first,dy=(ly-ry)/s[i].first;\n\t\t\tauto check=[=](int k) -> bool{\n\t\t\t\tif(X-k*lx<0||Y-k*ry<0)return false;\n\t\t\t\tint a=(X-k*lx)/dx,b=(Y-k*ry)/dy;\n\t\t\t\treturn a+b>=k*s[i].first;\n\t\t\t};\n\t\t\tint l=0,r=X+Y+1,ans=0;\n\t\t\twhile(l<r){\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tif(check(mid)){\n\t\t\t\t\tans=mid;\n\t\t\t\t\tl=mid+1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tr=mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmx=max(mx,ans);\n\t\t}\n\t\tprintf(\"%d\\n\",mx);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <tuple>\nusing namespace std;\n#define endl '\\n'\n#define ll long long\n#define pi pair<int, int>\n#define pii pair<int, pi>\n#define f first\n#define s second\n\nll inv(ll a, ll mod){\n\tll b = mod, x = 0, y = 1, u = 1, v = 0;\n\twhile(a){\n\t\tll q = b / a, r = b % a;\n\t\ttie(x, y, u, v) = make_tuple(u, v, x - u * q, y - v * q);\n\t\tb = a, a = r;\n\t}\n\treturn x + (x < 0) * mod;\n}\n\nll a, x, b, y, c;\nll g, w, h, ia;\nvector<pii> v;\n\nbool works(ll f){\n\tint l = 0, r = v.size() - 1;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(f * (c - v[mid].s.s) >= y) l = mid;\n\t\telse r = mid;\n\t}\n\t\n\tll dx = v[r].s.f - v[l].s.f, dy = v[r].s.s - v[l].s.s;\n\tdx /= v[r].f, dy /= v[r].f;\n\t\n\treturn f * v[l].s.f + (f * (c - v[l].s.s) + dy - y - 1) / dy * dx <= x; \n}\n\nvoid answer(){\n\tcin >> a >> x >> b >> y >> c;\t\n\t\n\tg = __gcd(a, b);\n\ta /= g, b /= g, c /= __gcd(g, c);\n\tg = __gcd(a, c);\n\ta /= g, y /= g, c /= g;\n\tg = __gcd(b, c);\n\tb /= g, x /= g, c /= g;\n\t\n\tif(c == 1){\n\t\tcout << x + y << endl;\n\t\treturn;\n\t}\n\t\n\tw = c, h = a * inv(b, c) % c, ia = inv(a, c);\n\tv.assign(1, {1, {0, 0}});\n\twhile(w && h){\n\t\tif(w > h){\n\t\t\tll t = w / h;\n\t\t\tw -= t * h;\n\t\t\tv.push_back({t, {(c - w) * b % c * ia % c, c - w}});\n\t\t}else if(h % w){\n\t\t\th %= w;\n\t\t}else{\n\t\t\tv.push_back({1, {c, c}});\n\t\t\tbreak;\n\t\t}\n\t}\n\tv.back().s.f += !v.back().s.f * c;\n\tv.push_back({1, {c, c + 1}});\n\t\n\tll l = y / c, r = x + y + 1;\n\twhile(r - l > 1){\n\t\tll mid = (l + r) / 2;\n\t\tif(works(mid)) l = mid;\n\t\telse r = mid;\n\t}\n\t\n\tcout << l << endl;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor(int i = 0; i < t; i++) answer();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nint gcd(re int a,re int b)\n{\n\tif(!b)return a;\n\treturn gcd(b,a%b);\n}\nvoid exgcd(re int a,re int b,re int&x,re int &y)\n{\n\tif(!b){x=1;y=0;return;}\n\texgcd(b,a%b,y,x);\n\ty-=a/b*x;\n}\nint a,b,c,d,x,y,x1,yk1,x2,y2,c1,d1,c2,d2,rd;\nlong long sol()\n{\n\tre int l=0,r=(yk1-y2)/d2-1,xx,yy,xx1,yy1;\n\tfor(re int mid=(l+r+1)/2;l<r;mid=(l+r+1)/2)\n\t{\n\t\tyy=yk1-mid*d2,xx=1ll*rd*yy%c;\n\t\tif(xx==0&&yy==0)xx=c;\n\t\tif(1ll*x*yy>=1ll*xx*y)l=mid;\n\t\telse r=mid-1;\n\t}\n\tyy=yk1-l*d2;xx=1ll*rd*yy%c;yy1=yy-d2;xx1=1ll*rd*yy1%c;\n\tif(xx==0&&yy==0)xx=c;if(xx1==0&&yy1==0)xx1=c;\n\tre long long xl1=xx-xx1,yl1=yy-yy1,xxl,yyl;\n\tl=0,r=1e9;\n\tfor(re int mid=(l+r+1)/2;l<r;mid=(l+r+1)/2)\n\t{\n\t\txxl=x+1ll*mid*xl1,yyl=y+1ll*mid*yl1;\n\t\tif((long double)xxl*yy>=(long double)xx*yyl)l=mid;\n\t\telse r=mid-1;\n\t}\n\txxl=x+l*xl1,yyl=y+l*yl1;//printf(\"****%lld %lld %d %d %d %d %d\\n\",xxl,yyl,xx,yy,xx1,yy1,l);\n\tre long long ans=std::min(xx?xxl/xx:(1ll<<60),yy?yyl/yy:(1ll<<60));\n\txxl+=xl1;yyl+=yl1;\n\tif(xxl>=0&&yyl>=0)ans=std::max(ans,std::min(xx?xxl/xx:(1ll<<60),yy?yyl/yy:(1ll<<60)));\n\treturn ans;\n}\nint main()\n{\n\tre int T;\n\tscanf(\"%d\",&T);\n\tfor(;T--;)\n\t{\n\t\tscanf(\"%d%d%d%d%d\",&a,&x,&b,&y,&c);\n\t\tre int g=gcd(a,b);a/=g,b/=g,c/=gcd(c,g);\n\t\tg=gcd(a,c);a/=g;c/=g;y/=g;\n\t\tg=gcd(b,c);b/=g;c/=g;x/=g;\n\t\texgcd(b,c,x1,yk1);\n\t\tif(c==1){printf(\"%d\\n\",x+y);continue;}\n\t\td=1ll*a*(x1+c)%c;//printf(\"**%d %d %d\\n\",a,b,c);\n\t\texgcd(d,c,x1,yk1);\n\t\trd=(c-x1)%c;\n\t\tc1=c,d1=d;\n\t\twhile(c1!=0)\n\t\t{\n\t\t\tx1=1ll*rd*c1%c;yk1=c1;\n\t\t\tc2=c1,d2=d1;\n\t\t\tif(d1)c1%=d1;\n\t\t\telse c1=0;\n\t\t\tif(c1)d1%=c1;\n\t\t\telse d1=0;\n\t\t\tif(d1==0)d1=c1;\n\t\t\tre int x2=1ll*rd*c1%c,y2=c1;\n\t\t\tif(x2==0&&y2==0)x2=c;\n\t\t//printf(\"****%d %d %d %d %d %d\\n\",x1,yk1,x2,y2,d,d2);\n\t\t\tif(1ll*x*yk1>=1ll*x1*y&&1ll*x2*y>=1ll*x*y2)\n\t\t\t{\n\t\t\t\tprintf(\"%lld\\n\",sol());break;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\nint great(vector<int> v,int a,int b,int c,int x,int y){\n  int ans=0;\n  int n;\n  n=0;\n  for(int i=1;i<=x;i++){\n    n+=a;\n    if(n%c==0){\n      ++ans;\n    }\n  }\n  n=0;\n  for(int i=1;i<=y;i++){\n    n+=b;\n    if(n%c==0){\n      ++ans;\n    }\n  }\n  return ans;\n}\nint main(void){\n  int t,a,b,c,x,y;\n  cin>>t;\n  for(int i=0;i<t;i++){\n    cin>>a>>x>>b>>y>>c;\n    vector<int> vec(x+y);\n    rep(j,x){\n      vec.pb(a);\n    }\n    rep(k,y){\n      vec.pb(b);\n    }\n    cout<<great(vec,a,b,c,x,y)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nll inv(ll q,ll m) {\n\tq%=m;if (q<0) q+=m;\n\tif (q==0) return 0;\n\tll a1=m,b1=0,a2=q,b2=1,a3=0,b3=0,t=0;\n\twhile (a2!=1) {\tt=a1/a2,a3=a1-t*a2,b3=b1-t*b2%m,\n\t\ta1=a2,a2=a3,b1=b2,b2=b3;if (b2<0) b2+=m;}\n\treturn b2;\n}\n\nll ceil(ll n, ll m) { return (n+m-1)/m; }\n\nll calc(ll A, ll M, ll L, ll R) // minimum nonnegative integer x s.t. L <= Ax mod M <= R\n{\n\tif (R==0) return M;\n\tif(L==0) return 0;\n\tif(2*A>M) { swap(L,R); A=M-A; L=M-L; R=M-R; }\n\tll cc_1=ceil(L,A);\n\tif(A*cc_1<=R) return cc_1;\n\tll cc_2=calc(A-M%A,A,L%A,R%A);\n\treturn ceil(L+M*cc_2,A);\n}\n\nbool sol_ex(ll A, ll M, ll L, ll R) // Existence of x s.t. L <= Ax mod M <= R\n{\n\tif(L==0) return true;\n\tll g=gcd(A,M);\n\tif((L-1)/g==R/g) return false;\n\treturn true;\n}\n\nvoid solve() {\n\tll a,x,b,y,c;\n\tscanf(\"%lld%lld%lld%lld%lld\",&a,&x,&b,&y,&c);\n\ta%=c; b%=c;\n\twhile (gcd(a,c)>1||gcd(b,c)>1) {\n\t\tll d=gcd(gcd(a,b),c);\n\t\ta/=d; b/=d; c/=d;\n\t\tif (gcd(a,c)==1) swap(a,b),swap(x,y);\n\t\td=gcd(a,c);\n\t\tll dd=d/gcd(d,b);\n\t\tb=b*dd%c; y=y/dd;\n\t\ta/=d; b/=d; c/=d;\n\t\tif (a==0&&b==0) {\n\t\t\tprintf(\"%lld\\n\",x+y);\n\t\t\treturn;\n\t\t}\n\t}\n\tb=a*inv(c-b,c)%c;\n\tPII px(0,c);\n\tvector<VI> g;\n\twhile (px.se>0) {\n\t\tint p=calc(b,c,1,px.se-1);\n\t\tint q=(ll)p*b%c;\n\t\tint dx=p-px.fi,dy=px.se-q;\n\t\tint cnt=px.se/dy;\n\t\tPII py(px.fi+cnt*dx,px.se-cnt*dy);\n\t\tg.pb({px.fi,px.se,py.fi,py.se,dx,-dy});\n\t\tpx=py;\n\t}\n\tll l=0,r=1ll<<33;\n\twhile (l+1<r) {\n\t\tll md=(l+r)>>1;\n\t\tbool valid=0;\n\t\tfor (auto p:g) {\n\t\t\tll x1=p[0]*md,x2=p[2]*md;\n\t\t\tif (x1<=x&&x<=x2) {\n\t\t\t\tll cc=p[1]*md+((x-x1)/p[4])*p[5];\n\t\t\t\tif (y>=cc) valid=1;\n\t\t\t}\n\t\t}\n\t\tif (g.back()[2]*md<=x) valid=1;\n\t\tif (valid) l=md; else r=md;\n\t}\n\tprintf(\"%lld\\n\",l);\n}\n\nint main() {\n\tint _;\n\tfor (scanf(\"%d\",&_);_;_--) {\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1007*1007;\n\nll a, b, c, x, y;\n\nll wyn;\n\nvoid eukl(ll &x, ll &y, ll a, ll b) {\n\tif (!a) { x = 0; y = 1; return; }\n\teukl(y, x, b % a, a);\n\tx -= y * (b / a);\n}\n\nll odw(ll v)\n{\n\tll x, y;\n\teukl(x, y, v, c);\n\tx%=c;\n\tx+=c;\n\tx%=c;\n\treturn x;\n}\n\nvoid relax()\n{\n\tll g=__gcd(a, b);\n\tg=__gcd(g, c);\n\ta/=g;\n\tb/=g;\n\tc/=g;\n\t\n\tg=__gcd(a, b);\n\tif (g)\n\t{\n\t\ta/=g;\n\t\tb/=g;\n\t}\n\t\t\n\tg=__gcd(a, c);\n\ta/=g;\n\tc/=g;\n\ty/=g;\n\t\n\tg=__gcd(b, c);\n\tb/=g;\n\tc/=g;\n\tx/=g;\n}\n\nvector<pll> sta;\nvector<pll> dod;\nvll razy;\nll jest;\n\npll dajkt(int v, ll x)\n{\n\treturn {sta[v].first+x*dod[v].first, sta[v].second+x*dod[v].second};\n}\n\npll daj(ll x)\n{\n\tint v=0;\n\twhile(razy[v]<=x)\n\t{\n\t\tx-=razy[v];\n\t\tv++;\n\t}\n\treturn dajkt(v, x);\n}\n\nvoid euklides()\n{\n\tll mno=odw(b)*a;\n\tmno%=c;\n\tmno=c-mno;\n\tmno%=c;\n\t\n\tsta.clear();\n\tdod.clear();\n\trazy.clear();\n\tll mini=1;\n\tll maxi=1;\n\tll wmi=mno;\n\tll wma=mno;\n\tsta.push_back({0, c});\n\tdod.push_back({0, 0});\n\trazy.push_back(1);\n\tsta.push_back({1, mno});\n\tdod.push_back({0, 0});\n\trazy.push_back(1);\n\twhile(mini+maxi<=c)\n\t{\n\t\tif ((wmi+wma)%c<wmi)\n\t\t{\n\t\t\tll ile=wmi/(c-wma);\n\t\t\tsta.push_back({mini+maxi, (wmi+wma)%c});\n\t\t\tdod.push_back({maxi, wma-c});\n\t\t\trazy.push_back(ile);\n\t\t\tmini+=ile*maxi;\n\t\t\twmi+=ile*wma;\n\t\t\twmi%=c;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll ile=(c-wma-1)/wmi;\n\t\t\tmaxi+=ile*mini;\n\t\t\twma+=ile*wmi;\n\t\t\twma%=c;\n\t\t}\n\t}\n\tjest=0;\n\tfor (ll i : razy)\n\t\tjest+=i;\n}\n\nint check(ll v)\n{\n\tll bsa=0;\n\tll bsb=jest;\n\twhile(bsa<bsb)\n\t{\n\t\tll bss=(bsa+bsb+2)>>1;\n\t\tif (daj(bss).first*v<=x)\n\t\t\tbsa=bss;\n\t\telse\n\t\t\tbsb=bss-1;\n\t}\n\tll g=bsa;\n\tif (g==jest-1)\n\t\treturn 1;\n\tpll lew=daj(g);\n\tpll pra=daj(g+1);\n\tbsa=0;\n\tbsb=v;\n\twhile(bsa<bsb)\n\t{\n\t\tll bss=(bsa+bsb+2)>>1;\n\t\tif (bss*pra.first+(v-bss)*lew.first<=x)\n\t\t\tbsa=bss;\n\t\telse\n\t\t\tbsb=bss-1;\n\t}\n\treturn (bsa*pra.second+(v-bsa)*lew.second<=y);\n}\n\nvoid test()\n{\n\tscanf(\"%lld%lld%lld%lld%lld\", &a, &x, &b, &y, &c);\n\ta%=c;\n\tb%=c;\n\twyn=0;\n\trelax();\n\tif (!a || !b)\n\t{\n\t\tll jed=c/__gcd(c, a);\n\t\tll dwa=c/__gcd(c, b);\n\t\tprintf(\"%lld\\n\", x/jed+y/dwa);\n\t\treturn;\n\t}\n\teuklides();\n\tll bsa=0;\n\tll bsb=x+y;\n\twhile(bsa<bsb)\n\t{\n\t\tll bss=(bsa+bsb+2)>>1;\n\t\tif (check(bss))\n\t\t\tbsa=bss;\n\t\telse\n\t\t\tbsb=bss-1;\n\t}\n\tprintf(\"%lld\\n\", bsa);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nint gcd(re int a,re int b)\n{\n\tif(!b)return a;\n\treturn gcd(b,a%b);\n}\nvoid exgcd(re int a,re int b,re int&x,re int &y)\n{\n\tif(!b){x=1;y=0;return;}\n\texgcd(b,a%b,y,x);\n\ty-=a/b*x;\n}\nint a,b,c,d,x,y,x1,yk1,x2,y2,c1,d1,c2,d2,rd;\nlong long sol()\n{\n\tre int l=0,r=(yk1-y2)/d2-1,xx,yy,xx1,yy1;\n\tfor(re int mid=(l+r+1)/2;l<r;mid=(l+r+1)/2)\n\t{\n\t\tyy=yk1-mid*d2,xx=1ll*rd*yy%c;\n\t\tif(1ll*x*yy>=1ll*xx*y)l=mid;\n\t\telse r=mid-1;\n\t}\n\tyy=yk1-l*d2;xx=1ll*rd*yy%c;yy1=yy-d2;xx1=1ll*rd*yy1%c;\n\tre long long xl1=xx-xx1,yl1=yy-yy1,xxl,yyl;\n\tl=0,r=1e9;\n\tfor(re int mid=(l+r+1)/2;l<r;mid=(l+r+1)/2)\n\t{\n\t\txxl=x+1ll*mid*xl1,yyl=y+1ll*mid*yl1;\n\t\tif((long double)xxl*yy>=(long double)xx*yyl)l=mid;\n\t\telse r=mid-1;\n\t}\n\txxl=x+l*xl1,yyl=y+l*yl1;//printf(\"****%lld %lld %d %d %d %d %d\\n\",xxl,yyl,xx,yy,xx1,yy1,l);\n\tre long long ans=std::min(xx?xxl/xx:(1ll<<60),yy?yyl/yy:(1ll<<60));\n\txxl+=xl1;yyl+=yl1;\n\tif(xxl>=0&&yyl>=0)ans=std::max(ans,std::min(xx?xxl/xx:(1ll<<60),yy?yyl/yy:(1ll<<60)));\n\treturn ans;\n}\nint main()\n{\n\t//freopen(\"01-05.txt\",\"r\",stdin);\n\tre int T;\n\tscanf(\"%d\",&T);\n\tfor(;T--;)\n\t{\n\t\tscanf(\"%d%d%d%d%d\",&a,&x,&b,&y,&c);\n\t\tre int g=gcd(a,b);a/=g,b/=g,c/=gcd(c,g);\n\t\tg=gcd(a,c);a/=g;c/=g;y/=g;\n\t\tg=gcd(b,c);b/=g;c/=g;x/=g;\n\t\texgcd(b,c,x1,yk1);\n\t\tif(c==1){printf(\"%d\\n\",x+y);continue;}\n\t\td=1ll*a*(x1+c)%c;//printf(\"**%d %d %d\\n\",a,b,c);\n\t\texgcd(d,c,x1,yk1);\n\t\trd=(c-x1)%c;\n\t\tc1=c,d1=d;\n\t\twhile(c1!=0)\n\t\t{\n\t\t\tx1=1ll*rd*c1%c;yk1=c1;\n\t\t\tc2=c1,d2=d1;\n\t\t\tif(d1)c1%=d1;\n\t\t\telse c1=0;\n\t\t\tif(c1)d1%=c1;\n\t\t\telse d1=0;\n\t\t\tif(d1==0)d1=c1;\n\t\t\tre int x2=1ll*rd*c1%c,y2=c1;\n\t\t//printf(\"****%d %d %d %d %d %d\\n\",x1,yk1,x2,y2,d,d2);\n\t\t\tif(1ll*x*yk1>=1ll*x1*y&&1ll*x2*y>=1ll*x*y2)\n\t\t\t{\n\t\t\t\tprintf(\"%lld\\n\",sol());break;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define lol long long \n\nusing namespace std;\n\n// typedef long long lol;\nconst int N = 1e3 + 5;\nint _w;\n\nint A , B , X , Y , C;\n\nvoid exgcd( int a , int b , lol & x , lol & y ) {\n  if( !b ) {\n    x = 1, y = 0;\n    return;\n  } exgcd( b , a % b , y , x );\n  y -= a / b * x;\n}\n\nint inv( int a , int m ) {\n  lol x , y;\n  exgcd( a , m , x , y );\n  x = ( x % m + m ) % m;\n  return x;\n}\n\ninline void solve( void ) {\n  _w = scanf(\"%lld%lld%lld%lld%lld\",&A,&X,&B,&Y,&C);\n  int g = __gcd( A , B );\n  A /= g , B /= g , C /= __gcd( g , C );\n  for( int _ = 0 , t ; _ < 2 ; ++_ ) {\n    g = __gcd( A , C );\n    A /= g , C /= g;\n    t = __gcd( g , B );\n    B /= t , Y /= g / t;\n    swap( A , B ) , swap( X , Y );\n  }\n  if( C == 1 ) {\n    printf(\"%lld\\n\",X+Y);\n    return;\n  }\n  int D = (lol)A * inv( B , C ) % C , ID = inv( D , C );\n  vector<int> x , y , n;\n  int W = C , H = D;\n  lol now = 0;\n  while( W ) {\n    int d = W / H;\n    x.push_back( (now%C) * ID % C );\n    if( now == 0 ) y.push_back( C );\n    else y.push_back( ( C - now ) % C );\n    n.push_back( d );\n    now += d * H;\n    W %= H;\n    if( !W ) break;\n    H %= W;\n    if( !H ) H = W;\n  }\n  x.push_back( C ) , y.push_back( 0 );\n  int ans = 0;\n  function<lol(lol,lol)> Div = []( lol a , lol b ) {\n    return a / b - ( a % b && (a^b) < 0 );\n  };\n  for( int i = 1 , lx , ly , rx , ry , ct , l , r , mid , res , dx , dy ; i < (int)(x.size()) ; ++i ) {\n    lx = x[i - 1] , rx = x[i] , ly = y[i - 1] , ry = y[i] , ct = n[i - 1];\n    l = 0 , r = X + Y + 1 , res = -1 , dx = ( rx - lx ) / ct , dy = ( ly - ry ) / ct;\n    while( l <= r ) {\n      mid = ( l + r ) >> 1;\n      lol p = Div( X - (lol)mid * lx , dx );\n      lol q = Div( Y - (lol)mid * ry , dy );\n      if( p >= 0 && q >= 0 && p + q >= (lol)ct * mid ) \n        res = mid , l = mid + 1;\n      else r = mid - 1;\n    }\n    ans = max( ans , res );\n  }\n  printf(\"%lld\\n\",ans);\n}\n\nsigned main( void ) {\n  int T;\n  _w = scanf(\"%lld\",&T);\n  while( T-- ) solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nstruct node{\n\tLL t,k,i;\n\tnode(LL t=0,LL k=0,LL i=0):t(t),k(k),i(i){}\n\tLL calc(LL x){return t+k*x;}\n};\nvector<node> f;\n\nLL gcd(LL x,LL y){\n\treturn y==0?x:gcd(y,x%y);\n}\n\nvoid exgcd(LL a,LL b,LL &x,LL &y){\n\tif (b==0){\n\t\tx=1; y=0;\n\t\treturn;\n\t}\n\texgcd(b,a%b,x,y);\n\tx-=a/b*y;\n\tswap(x,y);\n}\n\nvoid calc(LL n,LL m,LL p,LL now){\n\tif (!n||!m){\n\t\treturn;\n\t}\n\tif (n<=m){\n\t\tLL t=(m-1)/n;\n\t\tf.push_back(node(now,n+p,t)); \n//\t\tfor (LL i=1;i<=t;++i) printf(\"%lld \",now+(n+p)*i);\n\t\tcalc(n,m%n,(n+p)*t,now+p);\n\t}\n\telse{\n\t\tLL t=n/m;\n\t\tcalc(n%m,m,(m+p)*t,now+p);\n\t}\n}\n\nLL up(LL x,LL y){return (x+y-1)/y;}\n\nLL down(LL x,LL y){return x/y;}\n\nbool pd(LL u1,LL v1,LL u2,LL v2){\n\treturn u1*v2>=u2*v1;\n}\n\nLL calc(LL u1,LL v1,LL u2,LL v2,LL u,LL v){\n\tLL ret=0,l=0,r=u+v;\n\twhile (l<=r){\n\t\tLL mid=(l+r)>>1,t1=0,t2=mid;\n\t\tif (u2*mid-u>=0){\n\t\t\tt1=max(t1,up(u2*mid-u,u2-u1));\n\t\t}\n\t\tif (v-v2*mid<0){\n\t\t\tt2=-1;\n\t\t}\n\t\telse{\n\t\t\tt2=min(t2,down(v-v2*mid,v1-v2));\n\t\t}\n\t\tif (t1<=t2){ret=mid; l=mid+1;}\n\t\telse r=mid-1;\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\tLL a,b,c,x,y;\n\tscanf(\"%lld%lld%lld%lld%lld\",&a,&x,&b,&y,&c);\n\tLL g=gcd(a,b);\n\ta/=g; b/=g; c/=gcd(c,g);\n\tg=gcd(a,c);\n\ta/=g; c/=g; y/=g;\n\tg=gcd(b,c);\n\tb/=g; c/=g; x/=g;\n\ta%=c; b%=c;\n\tif (c==1){\n\t\tprintf(\"%lld\\n\",x+y);\n\t\treturn;\n\t}\n\tLL x0=0,y0=0;\n\texgcd(b,c,x0,y0);\n\ta=(a*x0%c+c)%c;\n//\tfor (LL i=a,mx=0;i<=10000;i+=a){\n//\t\tif (i%c>mx){\n//\t\t\tprintf(\"%d %d\\n\",i/a,c-i%c);\n//\t\t\tprintf(\"%d \",i);\n//\t\t\tmx=i%c;\n//\t\t}\n//\t}\n//\tputs(\"\");\n\tf.clear();\n\tf.push_back(node(0,0,1));\n\tcalc(a,c,0,0);\n\tf.push_back(node(c*a,0,1));\n//\tputs(\"\");\n\tLL ans=0;\n\tfor (size_t i=0;i<f.size();++i){\n\t\tif (f[i].i>=2){\n\t\t\tLL u1=f[i].calc(1)/a,v1=c-(a*u1)%c;\n\t\t\tLL u2=f[i].calc(f[i].i)/a,v2=c-(a*u2)%c;\n\t\t\tif (pd(v1,u1,y,x)&&pd(y,x,v2,u2)){\n\t\t\t\tLL l=1,r=f[i].i-1;\n\t\t\t\twhile (l<=r){\n\t\t\t\t\tLL mid=(l+r)>>1;\n\t\t\t\t\tLL u1=f[i].calc(mid)/a,v1=c-(a*u1)%c;\n\t\t\t\t\tLL u2=f[i].calc(mid+1)/a,v2=c-(a*u2)%c;\n\t\t\t\t\tif (!pd(v1,u1,y,x)){\n\t\t\t\t\t\tr=mid-1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!pd(y,x,v2,u2)){\n\t\t\t\t\t\tl=mid+1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans=calc(u1,v1,u2,v2,x,y);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i+1<f.size()){\n\t\t\tLL u1=f[i].calc(f[i].i)/a,v1=c-(a*u1)%c;\n\t\t\tLL u2=f[i+1].calc(1)/a,v2=(c-(a*u2)%c)%c;\n\t\t\tif (pd(v1,u1,y,x)&&pd(y,x,v2,u2)){\n\t\t\t\tans=calc(u1,v1,u2,v2,x,y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\tLL T; scanf(\"%lld\",&T);\n\twhile (T--) solve();\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntemplate<class T> inline bool Cmax(T &x,T y) {return x<y?x=y,1:0;} \ntypedef long long ll;\nint T,A,X,B,Y,C,D;\nvector<int> pos,cnt;\nint gcd(int a,int b) {return b==0?a:gcd(b,a%b);}\nint exgcd(int a,int b,int &x,int &y) {\n\tif(b==0) {x=1,y=0; return a;}\n\tint d=exgcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\ninline int inver(int a,int mod) {\n\tint x,y,d=exgcd(a,mod,x,y);\n\tif(x<0) x+=mod;\n\treturn x;\n}\ninline ll lowdiv(ll a,ll b) {return a/b-(a%b&&(a^b)<0);}\nvoid init() {\n\tint d=gcd(A,B);\n\tA/=d,B/=d,C/=gcd(d,C);\n\tfor(int _=0;_<2;++_) {\n\t\td=gcd(A,C);\n\t\tC/=d,A/=d;\n\t\tint t=gcd(B,d);\n\t\tB/=t,Y/=d/t;\n\t\tswap(A,B),swap(X,Y);\n\t}\n}\nvoid getpos() {\n\tpos.clear(),cnt.clear();\n\tint W=C,H=D,now=0,r=inver(D,C);\n\twhile(W) {\n\t\tint d=W/H;\n\t\tpos.push_back((ll)now*r%C),cnt.push_back(d); \n\t\tnow+=d*H;\n\t\tW%=H; if(W==0) break;\n\t\tH%=W; if(H==0) H=W;\n\t}\n\tpos.push_back(C);\n}\ninline int gety(int x) {return C-(ll)x*D%C;}\nint main() {\n\trd(T);\n\tfor(int kase=1;kase<=T;++kase) {\n\t\trd(A),rd(X),rd(B),rd(Y),rd(C);\n\t\tinit();\n\t\tif(C==1) {printf(\"%d\\n\",X+Y); continue;}\n\t\tD=(ll)A*inver(B,C)%C;\n\t\tgetpos();\n\t\tint an=0;\n\t\tfor(int i=0;i<cnt.size();++i) {\n\t\t\tint xl=pos[i],xr=pos[i+1],yl=gety(xl),yr=gety(xr);\n\t\t\tint dx=(xr-xl)/cnt[i],dy=(yl-yr)/cnt[i];\n\t\t\tint l=0,r=X+Y,re=-1;\n\t\t\twhile(l<=r) {\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tll p=lowdiv(X-(ll)xl*mid,dx),q=lowdiv(Y-(ll)yr*mid,dy);\n\t\t\t\tif(p>=0&&q>=0&&p+q>=(ll)cnt[i]*mid) re=mid,l=mid+1;\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tCmax(an,re);\n\t\t}\n\t\tprintf(\"%d\\n\",an);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntemplate<class T> inline bool Cmax(T &x,T y) {return x<y?x=y,1:0;} \ntypedef long long ll;\nint T,A,X,B,Y,C,D;\nvector<int> pos,cnt;\nint gcd(int a,int b) {return b==0?a:gcd(b,a%b);}\nint exgcd(int a,int b,int &x,int &y) {\n\tif(b==0) {x=1,y=0; return a;}\n\tint d=exgcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\ninline int inver(int a,int mod) {\n\tint x,y,d=exgcd(a,mod,x,y);\n\tif(x<0) x+=mod;\n\treturn x;\n}\ninline int lowdiv(int a,int b) {return a/b-(a%b&&(a^b)<0);}\nvoid init() {\n\tint d=gcd(A,B);\n\tA/=d,B/=d,C/=gcd(d,C);\n\tfor(int _=0;_<2;++_) {\n\t\td=gcd(A,C);\n\t\tC/=d,A/=d;\n\t\tint t=gcd(B,d);\n\t\tB/=t,Y/=d/t;\n\t\tswap(A,B),swap(X,Y);\n\t}\n}\nvoid getpos() {\n\tpos.clear(),cnt.clear();\n\tint W=C,H=D,now=0,r=inver(D,C);\n\twhile(W) {\n\t\tint d=W/H;\n\t\tpos.push_back((ll)now*r%C),cnt.push_back(d); \n\t\tnow+=d*H;\n\t\tW%=H; if(W==0) break;\n\t\tH%=W; if(H==0) H=W;\n\t}\n\tpos.push_back(C);\n}\ninline int gety(int x) {return C-(ll)x*D%C;}\nint main() {\n\trd(T);\n\tfor(int kase=1;kase<=T;++kase) {\n\t\trd(A),rd(X),rd(B),rd(Y),rd(C);\n\t\tinit();\n\t\tif(C==1) {printf(\"%d\\n\",X+Y); continue;}\n\t\tD=(ll)A*inver(B,C)%C;\n\t\tgetpos();\n\t\tint an=0;\n\t\tfor(int i=0;i<cnt.size();++i) {\n\t\t\tint xl=pos[i],xr=pos[i+1],yl=gety(xl),yr=gety(xr);\n\t\t\tint dx=(xr-xl)/cnt[i],dy=(yl-yr)/cnt[i];\n\t\t\tint l=0,r=X+Y,re=-1;\n\t\t\twhile(l<=r) {\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tint p=lowdiv(X-xl*mid,dx),q=lowdiv(Y-yr*mid,dy);\n\t\t\t\tif(p>=0&&q>=0&&p+q>=cnt[i]*mid) re=mid,l=mid+1;\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tCmax(an,re);\n\t\t}\n\t\tprintf(\"%d\\n\",an);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T, class S> void Dump(map<T, S> &m){\n\tfor(auto e: m) cout << e.first << \" : \" << e.second << '\\n';\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nll div(ll a, ll b, ll mod){ ///////////////////ライブラリにする\n\tll c=b, d=mod, u=1, v=0;\n\twhile (d){\n\t\tll t = c / d;\n\t\tc -= t * d; swap(c, d);\n\t\tu -= t * v; swap(u, v);\n\t}\n\ta = a * u % mod;\n\tif (a < 0) a += mod;\n\treturn a;\n}\n\nvoid solve()\n{\n\tll A, X, B, Y, C;  cin >> A >> X >> B >> Y >> C;\n\n\t{\n\t\tll g=Gcd(Gcd(A, B), C);\n\t\tA/=g;\n\t\tB/=g;\n\t\tC/=g;\n\t}\n\tll a=gcd(A, C);\n\tll b=gcd(B, C);\n\tll x1=b;\n\tll p=C/b-A;\n\tll BB=B/b;\n\tll CC=C/b;\n\tll y1=div(p, BB, CC);\n\n\tll x0=0;\n\tll y0=CC;\n\n\tll t;\n\twhile (true){\n\t\t//(xe,ye)を求める\n\t\tt=y0/(y0-y1);\n\t\tll xe=x0+t*(x1-x0);\n\t\tll ye=y0-t*(y0-y1);\n\n\t\t//(X,Y)を下回ったらbreak\n\t\tif (Y*xe>=X*ye) break;\n\n\t\t//次の(x0,y0),(x1,y1)を求める\n\t\tll xm=x0+(t-1)*(x1-x0);\n\t\tll ym=y0-(t-1)*(y0-y1);\n\t\tx0=xe;\n\t\ty0=ye;\n\t\tll k=CEIL(ym, y0);\n\t\tx1=x0*k-xm;\n\t\ty1=y0*k-ym;\n\t}\n\n\t//出力 (x0,y0), (x1,y1), t\n\n\t//(X,Y)の両脇を求める\n\tll xp, yp, xq, yq;\n\t{\n\t\tll ng=0;\n\t\tll ok=t;\n\t\twhile (abs(ng-ok)>1){\n\t\t\tll m=(ng+ok)/2;\n\t\t\tll xm=x0+m*(x1-x0);\n\t\t\tll ym=y0-m*(y0-y1);\n\t\t\tif (Y*xm>=X*ym) ok=m; else ng=m;\n\t\t}\n\t\txp=x0+ng*(x1-x0);\n\t\typ=y0-ng*(y0-y1);\n\t\txq=x0+ok*(x1-x0);\n\t\tyq=y0-ok*(y0-y1);\n\t}\n\n\t//両脇(xp,yp),(xq,yq)が何個ずつ取れるか\n\tll ans=0;\n\t{\n\t\tll ng=Y/yp+10;\n\t\tll ok=0;\n\t\twhile (abs(ng-ok)>1){\n\t\t\tll m=(ng+ok)/2;\n\t\t\tll xx=X-xp*m;\n\t\t\tll yy=Y-yp*m;\n\t\t\tif (yy>=0 and xq*yy>=xx*yq) ok=m; else ng=m;\n\t\t}\n\t\t{\n\t\t\tll xxx=X-xp*ok;\n\t\t\t//ll yyy=Y-yp*ok;\n\t\t\tll qnm=xxx/xq;\n\t\t\tchmax(ans, ok+qnm);\n\t\t}\n\t\t{\n\t\t\t//ll xxx=X-xp*ng;\n\t\t\tll yyy=Y-yp*ng;\n\t\t\tif (yyy>0){\n\t\t\t\tll qnm=yyy/yq;\n\t\t\t\tchmax(ans, ng+qnm);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n#if 0\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint mini(int x,int y)\n{\n    if (x<=y) return x;\n    return y;\n}\nint main()\n{\n    int t;\n    cin>>t;\n    while (t--)\n    {\n        int a,x,b,y,c,k=0,p=1,q=1;\n        cin>>a>>x>>b>>y>>c;\n        a%=c;\n        b%=c;\n        int x1=x,y1=y;\n        if (a==0)\n        {\n            k+=x;\n            x=0;\n        }\n        if (b==0)\n        {\n            k+=y;\n            y=0;\n        }\n        while ((x>0 || y>0) && (p<=x1) && (q<=y1))\n        {\n            if (((p*a)%c+(q*b)%c)%c==0) \n            {\n                int z1=x/p;\n                int z2=y/q;\n                int z=mini(z2,z1);\n                x-=p*z;\n                y-=q*z;\n                k+=z;\n            }\n            p+=1;\n            if (((p*a)%c+(q*b)%c)%c==0) \n            {\n                int z1=x/p;\n                int z2=y/q;\n                int z=mini(z2,z1);\n                x-=p*z;\n                y-=q*z;\n                k+=z;\n            }\n            q+=1;\n            p-=1;\n            if (((p*a)%c+(q*b)%c)%c==0) \n            {\n                int z1= x/p;\n                int z2=y/q;\n                int z=mini(z2,z1);\n                x-=p*z;\n                y-=q*z;\n                k+=z;\n            }\n            p+=1;\n        }\n        while (x>0 && p<=x1)\n        {\n            if ((a*p)%c==0) k+=x/p;\n            p++;\n            x-=p;\n        }\n        while (y>0 && q<=y1)\n        {\n            if ((b*q)%c==0) k+=y/q;\n            q++;\n            y-=q;\n        }\n        cout<<k<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nstruct node{\n\tLL t,k,i;\n\tnode(LL t=0,LL k=0,LL i=0):t(t),k(k),i(i){}\n\tLL calc(LL x){return t+k*x;}\n};\nvector<node> f;\n\nLL gcd(LL x,LL y){\n\treturn y==0?x:gcd(y,x%y);\n}\n\nvoid exgcd(LL a,LL b,LL &x,LL &y){\n\tif (b==0){\n\t\tx=1; y=0;\n\t\treturn;\n\t}\n\texgcd(b,a%b,x,y);\n\tx-=a/b*y;\n\tswap(x,y);\n}\n\nvoid calc(LL n,LL m,LL p,LL now){\n\tif (!n||!m){\n\t\treturn;\n\t}\n\tif (n<=m){\n\t\tLL t=(m-1)/n;\n\t\tf.push_back(node(now,n+p,t)); \n\t\tcalc(n,m%n,(n+p)*t,now+p);\n\t}\n\telse{\n\t\tLL t=n/m;\n\t\tcalc(n%m,m,(m+p)*t,now+p);\n\t}\n}\n\nLL up(LL x,LL y){return (x+y-1)/y;}\n\nLL down(LL x,LL y){return x/y;}\n\nbool pd(LL u1,LL v1,LL u2,LL v2){\n\treturn u1*v2>=u2*v1;\n}\n\nLL calc(LL u1,LL v1,LL u2,LL v2,LL u,LL v){\n\tLL ret=0,l=0,r=u+v;\n\twhile (l<=r){\n\t\tLL mid=(l+r)>>1,t1=0,t2=mid;\n\t\tif (u2*mid-u>=0){\n\t\t\tt1=max(t1,up(u2*mid-u,u2-u1));\n\t\t}\n\t\tif (v-v2*mid<0){\n\t\t\tt2=-1;\n\t\t}\n\t\telse{\n\t\t\tt2=min(t2,down(v-v2*mid,v1-v2));\n\t\t}\n\t\tif (t1<=t2){ret=mid; l=mid+1;}\n\t\telse r=mid-1;\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\tLL a,b,c,x,y;\n\tscanf(\"%lld%lld%lld%lld%lld\",&a,&x,&b,&y,&c);\n\tLL g=gcd(a,b);\n\ta/=g; b/=g; c/=gcd(c,g);\n\tg=gcd(a,c);\n\ta/=g; c/=g; y/=g;\n\tg=gcd(b,c);\n\tb/=g; c/=g; x/=g;\n\ta%=c; b%=c;\n\tLL x0=0,y0=0;\n\texgcd(b,c,x0,y0);\n\ta=(a*x0%c+c)%c;\n\tfor (LL i=a,mx=0;i<=10000;i+=a){\n\t\tif (i%c>mx){\n\t\t\tmx=i%c;\n\t\t}\n\t}\n\tf.push_back(node(0,0,1));\n\tcalc(a,c,0,0);\n\tf.push_back(node(c*a,0,1));\n\tLL ans=0;\n\tfor (size_t i=0;i<f.size();++i){\n\t\tif (f[i].i>=2){\n\t\t\tLL u1=f[i].calc(1)/a,v1=c-(a*u1)%c;\n\t\t\tLL u2=f[i].calc(f[i].i)/a,v2=c-(a*u2)%c;\n\t\t\tif (pd(v1,u1,y,x)&&pd(y,x,v2,u2)){\n\t\t\t\tLL l=1,r=f[i].i-1;\n\t\t\t\twhile (l<=r){\n\t\t\t\t\tLL mid=(l+r)>>1;\n\t\t\t\t\tLL u1=f[i].calc(mid)/a,v1=c-(a*u1)%c;\n\t\t\t\t\tLL u2=f[i].calc(mid+1)/a,v2=c-(a*u2)%c;\n\t\t\t\t\tif (!pd(v1,u1,y,x)){\n\t\t\t\t\t\tr=mid-1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!pd(y,x,v2,u2)){\n\t\t\t\t\t\tl=mid+1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans=calc(u1,v1,u2,v2,x,y);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i+1<f.size()){\n\t\t\tLL u1=f[i].calc(f[i].i)/a,v1=c-(a*u1)%c;\n\t\t\tLL u2=f[i+1].calc(1)/a,v2=c-(a*u2)%c;\n\t\t\tif (pd(v1,u1,y,x)&&pd(y,x,v2,u2)){\n\t\t\t\tans=calc(u1,v1,u2,v2,x,y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\tLL T; scanf(\"%lld\",&T);\n\twhile (T--) solve();\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntemplate<class T> inline bool Cmax(T &x,T y) {return x<y?x=y,1:0;} \ntypedef long long ll;\nint T,A,X,B,Y,C,D;\nvector<int> pos,cnt;\nint gcd(int a,int b) {return b==0?a:gcd(b,a%b);}\nint exgcd(int a,int b,int &x,int &y) {\n\tif(b==0) {x=1,y=0; return a;}\n\tint d=exgcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\ninline int inver(int a,int mod) {\n\tint x,y,d=exgcd(a,mod,x,y);\n\tif(x<0) x+=mod;\n\treturn x;\n}\ninline ll lowdiv(ll a,ll b) {return a/b-(a%b&&(a^b)<0);}\ninline int gety(int x) {return x==0?C:(C-(ll)x*D%C)%C;}\nint main() {\n\trd(T);\n\tfor(int kase=1;kase<=T;++kase) {\n\t\trd(A),rd(X),rd(B),rd(Y),rd(C);\n\t\t{\n\t\t\tint d=gcd(A,B);\n\t\t\tA/=d,B/=d,C/=gcd(d,C);\n\t\t\tfor(int _=0;_<2;++_) {\n\t\t\t\td=gcd(A,C);\n\t\t\t\tC/=d,A/=d;\n\t\t\t\tint t=gcd(B,d);\n\t\t\t\tB/=t,Y/=d/t;\n\t\t\t\tswap(A,B),swap(X,Y);\n\t\t\t}\n\t\t}\n\t\tif(C==1) {printf(\"%d\\n\",X+Y); continue;}\n\t\tD=(ll)A*inver(B,C)%C;\n\t\t{\n\t\t\tpos.clear(),cnt.clear();\n\t\t\tint W=C,H=D,now=0,r=inver(D,C);\n\t\t\twhile(W) {\n\t\t\t\tint d=W/H;\n\t\t\t\tpos.push_back((ll)now*r%C),cnt.push_back(d); \n\t\t\t\tnow+=d*H;\n\t\t\t\tW%=H; if(W==0) break;\n\t\t\t\tH%=W; if(H==0) H=W;\n\t\t\t}\n\t\t\tpos.push_back(C);\n\t\t} \n\t\tint an=0;\n\t\tfor(int i=0;i<cnt.size();++i) {\n\t\t\tint xl=pos[i],xr=pos[i+1],yl=gety(xl),yr=gety(xr);\n\t\t\tint dx=(xr-xl)/cnt[i],dy=(yl-yr)/cnt[i];\n\t\t\tint l=0,r=X+Y,re=-1;\n\t\t\twhile(l<=r) {\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tll p=lowdiv(X-(ll)xl*mid,dx),q=lowdiv(Y-(ll)yr*mid,dy);\n\t\t\t\tif(p>=0&&q>=0&&p+q>=(ll)cnt[i]*mid) re=mid,l=mid+1;\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tCmax(an,re);\n\t\t}\n\t\tprintf(\"%d\\n\",an);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "ぞい"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T, class S> void Dump(map<T, S> &m){\n\tfor(auto e: m) cout << e.first << \" : \" << e.second << '\\n';\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nll div(ll a, ll b, ll mod){ ///////////////////ライブラリにする\n\tll c=b, d=mod, u=1, v=0;\n\twhile (d){\n\t\tll t = c / d;\n\t\tc -= t * d; swap(c, d);\n\t\tu -= t * v; swap(u, v);\n\t}\n\ta = a * u % mod;\n\tif (a < 0) a += mod;\n\treturn a;\n}\n\nvoid solve()\n{\n\tll A, X, B, Y, C;  cin >> A >> X >> B >> Y >> C;\n\n\t{\n\t\tll g=Gcd(Gcd(A, B), C);\n\t\tA/=g;\n\t\tB/=g;\n\t\tC/=g;\n\t}\n\tll a=gcd(A, C);\n\tll b=gcd(B, C);\n\tll x1=b;\n\tll p=C/b-A;\n\tll BB=B/b;\n\tll CC=C/b;\n\tll y1=div(p, BB, CC);\n\n\tll x0=0;\n\tll y0=CC;\n\n\tll t;\n\twhile (true){\n\t\t//(xe,ye)を求める\n\t\tt=y0/(y0-y1);\n\t\tll xe=x0+t*(x1-x0);\n\t\tll ye=y0-t*(y0-y1);\n\n\t\t//(X,Y)を下回ったらbreak\n\t\tif (Y*xe>=X*ye) break;\n\n\t\t//次の(x0,y0),(x1,y1)を求める\n\t\tll xm=x0+(t-1)*(x1-x0);\n\t\tll ym=y0-(t-1)*(y0-y1);\n\t\tx0=xe;\n\t\ty0=ye;\n\t\tll k=CEIL(ym, y0);\n\t\tx1=x0*k-xm;\n\t\ty1=y0*k-ym;\n\t}\n\n\t//出力 (x0,y0), (x1,y1), t\n\n\t//(X,Y)の両脇を求める\n\tll xp, yp, xq, yq;\n\t{\n\t\tll ng=0;\n\t\tll ok=t;\n\t\twhile (abs(ng-ok)>1){\n\t\t\tll m=(ng+ok)/2;\n\t\t\tll xm=x0+m*(x1-x0);\n\t\t\tll ym=y0-m*(y0-y1);\n\t\t\tif (Y*xm>=X*ym) ok=m; else ng=m;\n\t\t}\n\t\txp=x0+ng*(x1-x0);\n\t\typ=y0-ng*(y0-y1);\n\t\txq=x0+ok*(x1-x0);\n\t\tyq=y0-ok*(y0-y1);\n\t}\n\n\t//両脇(xp,yp),(xq,yq)が何個ずつ取れるか\n\tll ans=0;\n\t{\n#if 0\n\t\tll ng=Y/yp+10;\n\t\tll ok=0;\n\t\twhile (abs(ng-ok)>1){\n\t\t\tll m=(ng+ok)/2;\n\t\t\tll xx=X-xp*m;\n\t\t\tll yy=Y-yp*m;\n\t\t\tif (yy>=0 and xq*yy>=xx*yq) ok=m; else ng=m;\n\t\t}\n#endif\n\t\tll ok = (xq*Y-yq*X)/(xq*yp-xp*yq);\n\t\tll ng=ok+1;\n\t\t{\n\t\t\tll xxx=X-xp*ok;\n\t\t\t//ll yyy=Y-yp*ok;\n\t\t\tll qnm=xxx/xq;\n\t\t\tchmax(ans, ok+qnm);\n\t\t}\n\t\t{\n\t\t\t//ll xxx=X-xp*ng;\n\t\t\tll yyy=Y-yp*ng;\n\t\t\tif (yyy>=0){\n\t\t\t\tll qnm=yyy/yq;\n\t\t\t\tchmax(ans, ng+qnm);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n#if 0\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \n//int cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n/**\n * Description: euclid finds ${x,y}$ such that $ax+by=\\gcd(a,b)$ \n \t* and $|ax|,|by|\\le \\frac{ab}{\\gcd(a,b)}.$ Should work for $a,b<2^{62}$\n * Source: KACTL\n * Time: O(\\log ab)\n */\n\npl euclid(ll a, ll b) { \n\tif (!b) return {1,0};\n\tpl p = euclid(b,a%b); return {p.s,p.f-a/b*p.s}; }\nll invGen(ll a, ll b) { \n\tpl p = euclid(a,b); assert(p.f*a+p.s*b == 1); // gcd is 1\n\treturn p.f+(p.f<0)*b; }\n\n/**\n * Description: finds smallest $x\\ge 0$ such that $L\\le Ax\\pmod{P}\\le R$\n * Source: https://codeforces.com/gym/102411/submission/64315879\n * Verification: https://codeforces.com/gym/102411/problem/G\n */\n\nll cdiv(ll x, ll y) { return (x+y-1)/y; }\nll bet(ll P, ll A, ll L, ll R) { \n\tif (A == 0) return L == 0 ? 0 : -1;\n\tll c = cdiv(L,A); if (A*c <= R) return c;\n\tll B = P%A; // P = k*A+B, L <= A(x-Ky)-By <= R \n\t// => -R <= By % A <= -L\n\tauto y = bet(A,B,A-R%A,A-L%A); \n\treturn y == -1 ? y : cdiv(L+B*y,A)+P/A*y;\n}\n\n\nint solve(ll A, ll X, ll B, ll Y, ll C) {\n\tll g = __gcd(A,B);\n\tA /= g, B /= g; C /= __gcd(g,C);\n\tF0R(i,2) {\n\t\tint t = __gcd(A,C);\n\t\tY /= t; A /= t, C /= t;\n\t\tswap(A,B); swap(X,Y);\n\t}\n\tassert(__gcd(A,B) == 1 && __gcd(B,C) == 1 && __gcd(C,A) == 1);\n\t//dbg(\"OK\",A,B,C,X,Y);\n\tif (C == 1) return X+Y;\n\tvpi posi; posi.pb({0,C});\n\tvi step;\n\tint con = -1LL*A*invGen(B,C)%C; con = (con+C)%C;\n\twhile (posi.bk.s) {\n\t\tpi a = posi.bk;\n\t\tint L = 1, R = a.s-1; if (L > R) break;\n\t\tll x = bet(C,con,L,R); if (x == -1) break;\n\t\tpi b = {x,con*x%C};\n\t\tint ti = a.s/(a.s-b.s); if (a.s%(a.s-b.s) == 0) ti --;\n\t\tpi c = {a.f+ti*(b.f-a.f),a.s+ti*(b.s-a.s)}; assert(c.s > 0 && c.s <= a.s-b.s);\n\t\tposi.pb(c); step.pb(ti);\n\t\t//dbg(\"OOPS\",a,b,ti);\n\t\t// int rem = con*x%C; \n\t\t// int dem = C-con;\n\t\t// int times = rem/dem-(rem%dem == 0);\n\t\t// posi.pb({{x,}});\n\t\t// dbg(\"HAHA\",posi.bk);\n\t\t// 0 < (-A*x)*B^{-1} < posi.bk.s mod C\n\t}\n\tassert(posi.bk.s < C);\n\tstep.pb(1);\n\tposi.pb({C,0});\n\t//dbg(\"HA\",posi);\n\tll ans = 0;\n\tF0R(i,sz(posi)-1) {\n\t\tpi a = posi[i], b = posi[i+1];\n\t\tint g = step[i]; // dbg(\"G\",g);\n\t\tpi d = {(b.f-a.f)/g,(a.s-b.s)/g}; assert(d.f > 0 && d.s > 0);\n\t\tauto ok = [&](ll mid) -> bool {\n\t\t\tif (a.f*mid > X || b.s*mid > Y) return 0;\n\t\t\tll L = 0, R = g*mid;\n\t\t\tif (b.f*mid > X) ckmin(R,(X-a.f*mid)/d.f);\n\t\t\tif (a.s*mid > Y) ckmax(L,cdiv(a.s*mid-Y,d.s));\n\t\t\treturn L <= R;\n\t\t};\n\t\tll lo = 0, hi = X+Y;\n\t\twhile (lo < hi) {\n\t\t\tll mid = (lo+hi+1)/2;\n\t\t\tif (ok(mid)) lo = mid;\n\t\t\telse hi = mid-1;\n\t\t}\n\t\t//dbg(\"AH\",a,b,lo,g);\n\t\tckmax(ans,lo);\n\t}\n\treturn ans;\n}\n\n\nint good(ll A, ll X, ll B, ll Y, ll C) {\n\tll g = __gcd(A,B);\n\tA /= g, B /= g; C /= __gcd(g,C);\n\tF0R(i,2) {\n\t\tint t = __gcd(A,C);\n\t\tY /= t; A /= t, C /= t;\n\t\tswap(A,B); swap(X,Y);\n\t}\n\tassert(__gcd(A,B) == 1 && __gcd(B,C) == 1 && __gcd(C,A) == 1);\n\t//dbg(\"OK\",A,B,C,X,Y);\n\tif (C == 1) return X+Y;\n\tvpi posi; posi.pb({0,C});\n\tint con = -1LL*A*invGen(B,C)%C; con = (con+C)%C;\n\t//dbg(\"START LOOP\");\n\twhile (1) {\n\t\tint L = 1, R = posi.bk.s-1; if (L > R) break;\n\t\tll x = bet(C,con,L,R); if (x == -1) break;\n\t\tposi.pb({x,con*x%C});\n\t\t//dbg(\"HAHA\",posi.bk);\n\t\t// 0 < (-A*x)*B^{-1} < posi.bk.s mod C\n\t}\n\t//dbg(\"END LOOP\");\n\tposi.pb({C,0});\n\t//dbg(posi);\n\tll ans = 0;\n\ttrav(t,posi) {\n\t\tll mul = INF;\n\t\tif (t.f) ckmin(mul,X/t.f);\n\t\tif (t.s) ckmin(mul,Y/t.s);\n\t\tckmax(ans,mul);\n\t}\n\tdbg(\"HAHA\",posi);\n\tF0R(i,sz(posi)-1) {\n\t\tpi a = posi[i], b = posi[i+1];\n\t\tauto ok = [&](ll mid) -> bool {\n\t\t\tif (a.f*mid > X || b.s*mid > Y) return 0;\n\t\t\tll L = 0, R = mid;\n\t\t\tif (b.f*mid > X) {\n\t\t\t\t// a.f*x+b.f*(mid-x) <= X\n\t\t\t\t// (a.f-b.f)*x+b.f*mid <= X\n\t\t\t\t// x*(b.f-a.f) >= b.f*mid-X\n\t\t\t\tL = cdiv(b.f*mid-X,b.f-a.f);\n\t\t\t}\n\t\t\tif (a.s*mid > Y) {\n\t\t\t\t// a.s*x+b.s*(mid-x) <= Y\n\t\t\t\t// (a.s-b.s)*x <= Y-b.s*mid\n\t\t\t\tR = (Y-b.s*mid)/(a.s-b.s);\n\t\t\t}\n\t\t\treturn L <= R;\n\t\t};\n\t\tll lo = 0, hi = X+Y;\n\t\twhile (lo < hi) {\n\t\t\tll mid = (lo+hi+1)/2;\n\t\t\tif (ok(mid)) lo = mid;\n\t\t\telse hi = mid-1;\n\t\t}\n\t\tdbg(a,b,lo);\n\t\tckmax(ans,lo);\n\t}\n\t// dbg(\"HA\",posi);\n\treturn ans;\n\t// Ax+By is divisible by C\n\t// what if gcd(A,C) > 1?\n\t// gcd(B,C) > 1?\n}\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) {\n\t\tll A,X,B,Y,C; re(A,X,B,Y,C);\n\t\tll x = solve(A,X,B,Y,C);\n\t\t//dbg(x);\n\t\t/*ll y = good(A,X,B,Y,C);\n\t\tif (x != y) {\n\t\t\tdbg(\"OOPS\",A,X,B,Y,C);\n\t\t\tdbg(x,y);\n\t\t\texit(0);\n\t\t}*/\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <tuple>\nusing namespace std;\n#define endl '\\n'\n#define ll long long\n#define pi pair<int, int>\n#define pii pair<int, pi>\n#define f first\n#define s second\n\nll inv(ll a, ll mod){\n\tll b = mod, x = 0, y = 1, u = 1, v = 0;\n\twhile(a){\n\t\tll q = b / a, r = b % a;\n\t\ttie(x, y, u, v) = make_tuple(u, v, x - u * q, y - v * q);\n\t\tb = a, a = r;\n\t}\n\treturn x + (x < 0) * mod;\n}\n\nll a, x, b, y, c;\nll g, w, h, ia;\nvector<pii> v;\n\nbool works(ll f){\n\tll l = 0, r = v.size();\n\twhile(r - l > 1){\n\t\tll mid = (l + r) / 2;\n\t\tif(f * (c - v[mid].s.s) >= y) l = mid;\n\t\telse r = mid;\n\t}\n\tif(l == v.size() - 1) return 0;\n\t\n\tll dx = v[r].s.f - v[l].s.f, dy = v[r].s.s - v[l].s.s;\n\tdx /= v[r].f, dy /= v[r].f;\n\t\n\treturn l < v.size() - 1 && f * v[l].s.f + \n\t\t(f * (c - v[l].s.s) + dy - y - 1) / dy * dx <= x; \n}\n\nvoid answer(){\n\tcin >> a >> x >> b >> y >> c;\t\n\t\n\tg = __gcd(a, b);\n\ta /= g, b /= g, c /= __gcd(g, c);\n\tg = __gcd(a, c);\n\ta /= g, y /= g, c /= g;\n\tg = __gcd(b, c);\n\tb /= g, x /= g, c /= g;\n\t\n\tw = c, h = a * inv(b, c) % c, ia = inv(a, c);\n\tv.assign(1, {1, {0, 0}});\n\twhile(w && h){\n\t\tif(w > h){\n\t\t\tll t = w / h;\n\t\t\tw -= t * h;\n\t\t\tv.push_back({t, {(c - w) * b % c * ia % c, c - w}});\n\t\t\tv.back().s.f += !v.back().s.f * c;\n\t\t}else if(h % w){\n\t\t\th %= w;\n\t\t}else{\n\t\t\tv.push_back({1, {c, c}});\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tll l = y / c, r = x + y + 1;\n\twhile(r - l > 1){\n\t\tll mid = (l + r) / 2;\n\t\tif(works(mid)) l = mid;\n\t\telse r = mid;\n\t}\n\t\n\tcout << l << endl;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor(int i = 0; i < t; i++) answer();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint T,A,X,B,Y,C,D;\nvector<pair<int,int> > s;\nint _gcd(int a,int b){\n\tif(b==0)return a;\n\treturn _gcd(b,a%b);\n}\nvoid init(){\n\tint g=_gcd(A,B);\n\tA/=g,B/=g,C/=_gcd(g,C);\n\tg=_gcd(A,C),A/=g,C/=g,Y/=g;\n\tg=_gcd(B,C),B/=g,C/=g,X/=g;\n}\nvoid exgcd(int a,int b,int &x,int &y){\n\tif(b==0){\n\t\tx=1,y=0;\n\t\treturn;\n\t}\n\texgcd(b,a%b,x,y);\n\tint t=x;\n\tx=y;\n\ty=t-a/b*y;\n}\ninline int Inv(int a,int mod){\n\tint x,y;\n\texgcd(a,mod,x,y);\n\treturn (x+mod)%mod;\n}\ninline int Get(int x){\n\treturn !x?C:(C-1LL*x*D%C)%C;\n}\nvoid Get_seg(){\n\tD=1LL*A*Inv(B,C)%C;\n\ts.clear();\n\tint W=C,H=D,now=0,invD=Inv(D,C);\n\twhile(\"MAK AK IOI!\"){\n\t\ts.emplace_back(W/H,(int)(1LL*now*invD%C));\n\t\tnow+=W/H*H;\n\t\tif(!(W%=H))break;\n\t\tif(!(H%=W))H=W;\n\t}\n\ts.emplace_back(0,C);\n}\nint main(){\n\tT=read();\n\twhile(T--){\n\t\tA=read(),X=read(),B=read(),Y=read(),C=read();\n\t\tinit();\n\t\tif(C==1){\n\t\t\tprintf(\"%d\\n\",X+Y);\n\t\t\tcontinue;\n\t\t}\n\t\tGet_seg();\n\t\tll mx=0;\n\t\tfor(int i=0;i<(int)s.size()-1;++i){\n\t\t\tint lx=s[i].second,rx=s[i+1].second;\n\t\t\tint ly=Get(lx),ry=Get(rx);\n\t\t\tint dx=(rx-lx)/s[i].first,dy=(ly-ry)/s[i].first;\n\t\t\t\n\t\t\tauto check=[=](ll k) -> bool{\n\t\t\t\tif(X-k*lx<0||Y-k*ry<0)return false;\n\t\t\t\tint a=(X-k*lx)/dx,b=(Y-k*ry)/dy;\n\t\t\t\treturn a+b>=k*s[i].first;\n\t\t\t};\n\t\t\t\n\t\t\tll l=0,r=X+Y+1,ans=0;\n\t\t\twhile(l<r){\n\t\t\t\tll mid=(l+r)>>1;\n\t\t\t\tif(check(mid)){\n\t\t\t\t\tans=mid,l=mid+1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tr=mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmx=max(mx,ans);\n\t\t}\n\t\tprintf(\"%lld\\n\",mx);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nint A,B,C,X,Y,H,G,D;\nint top,q1[55],q2[55],q3[55];\nint gcd(int x,int y){\n\treturn y?gcd(y,x%y):x;\n}\nvoid exgcd(int x,int y,int &a,int &b){\n\tif (!y){\n\t\ta=1; b=0;\n\t\treturn;\n\t}\n\texgcd(y,x%y,b,a);\n\tb-=x/y*a;\n}\nint getinv(int x,int y){\n\tint a,b;\n\texgcd(x,y,a,b);\n\treturn (a%y+y)%y;\n}\nvoid get_seq(int C,int D){\n\ttop=q1[0]=q2[0]=0;\n\tint len=1,x,a=1,b=0;\n\tfor (;D;){\n\t\t//cout<<\"debug \"<<C<<' '<<D<<' '<<a<<endl;\n\t\t++top;\n\t\tq1[top]=q1[top-1]+C/D*a;\n\t\tq2[top]=q2[top-1]+C/D*D;\n\t\tq3[top]=C/D;\n\t\tFor(T,1,2){\n\t\t\tif (T==1) b+=C/D*a;\n\t\t\telse a+=C/D*b;\n\t\t\tx=C%D; C=D; D=x;\n\t\t\tif (!D) break;\n\t\t}\n\t}\n}\nll Mydiv(ll x,ll y){\n\treturn x<0?-1:x/y;\n}\nvoid solve(){\n\tscanf(\"%d%d%d%d%d\",&A,&X,&B,&Y,&C);\n\tG=gcd(A,B); A/=G; B/=G; C/=gcd(C,G);\n\tG=gcd(A,C); A/=G; C/=G;\n\tH=gcd(G,B); B/=H; Y/=G/H;\n\tG=gcd(B,C); B/=G; C/=G;\n\tH=gcd(G,A); A/=H; X/=G/H;\n\tA%=C; B%=C;\n\tif (C==1) return cout<<X+Y<<endl,void(0);\n\tD=1ll*A*getinv(B,C)%C; get_seq(C,D);\n\tif (q1[top]!=C) q1[++top]=C,q2[top]=C,q3[top]=1;\n\t//For(i,1,top) cout<<q1[i]<<' '<<q2[i]<<' '<<q3[i]<<endl;\n\tint ans=0;\n\tFor(i,1,top){\n\t\tint lx=q1[i-1],rx=q1[i];\n\t\tint ly=C-q2[i-1],ry=C-q2[i];\n\t\tint dx=(rx-lx)/q3[i],dy=(ly-ry)/q3[i];\n\t\tint l=ans+1,r=X+Y+1;\n\t\t//cout<<lx<<' '<<ry<<' '<<dx<<' '<<dy<<' '<<ans<<endl;\n\t\twhile (l<=r){\n\t\t\tint mid=(l+r)/2;\n\t\t\tll p=Mydiv(X-1ll*mid*lx,dx);\n\t\t\tll q=Mydiv(Y-1ll*mid*ry,dy);\n\t\t\tif (p>=0&&q>=0&&p+q>=1ll*q3[i]*mid)\n\t\t\t\tans=max(ans,mid),l=mid+1;\n\t\t\telse r=mid-1;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile (T--) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb pushback\n#define fr(i,n) for(int i=0;i<n;i++)\n#define fro(i,j,n) for(int i=j;i<n;i++)\n#define ifr(i,n) for(int i=n-1;i>=0;i--)\n\nint main() {\n    int t;\n    ll a,x,b,y,c\n    int ans=0;\n\tcin >> t;\n  \tfr(i,t){\n      cin >> a>>x>>b>>y>>c;\n      a%=c;\n      b%=c;\n      int g=gcd(a,b);\n      g=gcd(g,c);\n      a/=g;\n      b/=g;\n      c/=g;\n      if(b>a){\n        int ko=a;\n        a=b;\n        b=lo;\n      }\n      ans+=x/c;\n      ans+=y/c;\n      x%=c;\n      y%=c;\n      cout << ans+rand()%((x*a+b*y)/c)<< endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvoid exgcd(int a,int b,int &x,int &y){\n\tif(b==0) return (void)(x=1,y=0);\n\texgcd(b,a%b,y,x);\n\ty-=(a/b)*x;\n}\nint inv(int a,int mod){\n\tint x,y;\n\texgcd(a,mod,x,y);\n\treturn (x%mod+mod)%mod;\n}\nint getY(int x,int C,int D){\n\treturn x==0?C:(C-1ll*x*D%C)%C;\n}\nvoid solve(){\n\tint A,X,B,Y,C,g;\n\tcin>>A>>X>>B>>Y>>C;\n\tg=__gcd(A,B); A/=g; B/=g; C/=__gcd(g,C);\n\tg=__gcd(A,C); A/=g; C/=g; Y/=g;\n\tg=__gcd(B,C); B/=g; C/=g; X/=g;\n\tA%=C;B%=C;if(C==1) return (void)(cout<<X+Y<<endl);\n\tint D=1ll*A*inv(B,C)%C;\n\tint W=C,H=D,now=0,invD=inv(D,C),tmp;\n\tvector<int> pos,cnt; //等差数列的起始值与点的数量 \n\twhile(W){\n\t\tH=(H-1)%W+1;tmp=W/H;\n\t\tpos.push_back(1ll*now*invD%C);\n\t\tcnt.push_back(tmp);\n\t\tnow+=tmp*H;W-=tmp*H;\n\t}\n\tpos.push_back(C);\n\tlong long ans=0;\n\tfor(int i=0;i<cnt.size();++i){\n\t\tint lx=pos[i],ly=getY(lx,C,D);\n\t\tint rx=pos[i+1],ry=getY(rx,C,D);\n\t\tint del_x=(rx-lx)/cnt[i],del_y=(ly-ry)/cnt[i];\n\t\tlong long mid,l=0,r=X+Y,res=0;\n\t\twhile(l<=r){\n\t\t\tmid=(l+r)>>1;\n\t\t\tlong long p=(X-mid*lx),q=(Y-mid*ry);\n\t\t\tif(p>=0 && q>=0 && p/del_x+q/del_y>=mid*(cnt[i])) res=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tans=max(ans,res);\n\t}\n\tcout<<ans<<endl;\n}\nsigned main(){\n\tint T;cin>>T;\n\twhile(T--) solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\ninline int exgcd(int a,int b,int &x,int &y){\n\tif (!b) return x=1,y=0,a;\n\tint g=exgcd(b,a%b,y,x);\n\treturn y-=a/b*x,g;\n}\ninline int inv(int A,int mod){\n\tint x,y;\n\texgcd(A,mod,x,y);\n\treturn x<0?x+mod:x;\n}\n\nint A,B,C,D,X,Y;\n\ninline void init(){\n\tint g=__gcd(__gcd(A,B),C);\n\tA/=g,B/=g,C/=g;\n\tg=__gcd(A,C),Y/=g,C/=g,A/=g;\n\tg=__gcd(B,C),X/=g,C/=g,B/=g;\n}\nvector<int>x,cnt;\ninline void Get(){\n\tD=1ll*A*inv(B,C)%C,x.clear(),cnt.clear();\n\tint W=C,H=D,now=0,invD=inv(D,C);\n\twhile (W){\n\t\tint tmp=W/H;\n\t\tcnt.pb(tmp),x.pb(1ll*now*invD%C),now+=tmp*H;\n\t\tW%=H;\n\t\tif (!W) break;\n\t\tH%=W;\n\t\tif (H==0) H=W;\n\t}\n\tx.pb(C),cnt.pb(0);\n}\ninline ll Div(ll x,ll y){\n\treturn x/y-(x%y&&(x^y)<0);\n}\ninline int Get(int x){\n\treturn x==0?C:(C-1ll*x*D%C)%C;\n}\ninline void solve(){\n\tA=read(),X=read(),B=read(),Y=read(),C=read();\n\tinit();\n\tif (C==1) return printf(\"%d\\n\",X+Y),void(0);\n\tGet();\n\tll ans=0;\n\tFOR(i,0,siz(x)-1){\n\t\tint lx=x[i],ly=Get(lx),rx=x[i+1],ry=Get(rx),dx=(rx-lx)/cnt[i],dy=(ly-ry)/cnt[i];\n\t\tll l=0,r=X+Y,ret=0;\n\t\twhile (l<=r){\n\t\t\tll mid=l+r>>1;\n\t\t\tif (X-mid*lx>=0&&Y-mid*ry>=0){\n\t\t\t\tll a=(X-mid*lx)/dx,b=(Y-mid*ry)/dy;\n\t\t\t\tif (a>=0&&b>=0&&a+b>=mid*cnt[i]) l=mid+1,ret=mid;\n\t\t\t\t\telse r=mid-1;\n\t\t\t} else r=mid-1;\n\t\t}\n\t\tans=max(ans,ret);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\tint T=read();\n\twhile (T--) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nll inv(ll q,ll m) {\n\tq%=m;if (q<0) q+=m;\n\tif (q==0) return 0;\n\tll a1=m,b1=0,a2=q,b2=1,a3=0,b3=0,t=0;\n\twhile (a2!=1) {\tt=a1/a2,a3=a1-t*a2,b3=b1-t*b2%m,\n\t\ta1=a2,a2=a3,b1=b2,b2=b3;if (b2<0) b2+=m;}\n\treturn b2;\n}\n\nll ceil(ll n, ll m) { return (n+m-1)/m; }\n\nll calc(ll A, ll M, ll L, ll R) // minimum nonnegative integer x s.t. L <= Ax mod M <= R\n{\n\tif (R==0) return M;\n\tif(L==0) return 0;\n\tif(2*A>M) { swap(L,R); A=M-A; L=M-L; R=M-R; }\n\tll cc_1=ceil(L,A);\n\tif(A*cc_1<=R) return cc_1;\n\tll cc_2=calc(A-M%A,A,L%A,R%A);\n\treturn ceil(L+M*cc_2,A);\n}\n\nbool sol_ex(ll A, ll M, ll L, ll R) // Existence of x s.t. L <= Ax mod M <= R\n{\n\tif(L==0) return true;\n\tll g=gcd(A,M);\n\tif((L-1)/g==R/g) return false;\n\treturn true;\n}\n\nvoid solve() {\n\tint a,x,b,y,c;\n\tscanf(\"%d%d%d%d%d\",&a,&x,&b,&y,&c);\n\ta%=c; b%=c;\n\twhile (gcd(a,c)>1||gcd(b,c)>1) {\n\t\tint d=gcd(gcd(a,b),c);\n\t\ta/=d; b/=d; c/=d;\n\t\tif (gcd(a,c)==1) swap(a,b),swap(x,y);\n\t\td=gcd(a,c);\n\t\tint dd=d/gcd(d,b);\n\t\tb=b*dd%c; y=y/dd;\n\t\ta/=d; b/=d; c/=d;\n\t\tif (a==0&&b==0) {\n\t\t\tprintf(\"%d\\n\",x+y);\n\t\t\treturn;\n\t\t}\n\t}\n\t//printf(\"%lld %lld %lld %lld %lld\\n\",a,x,b,y,c);\n\tb=a*inv(c-b,c)%c;\n\tPII px(0,c);\n\tvector<VI> g;\n\twhile (px.se>0) {\n\t\tint p=calc(b,c,1,px.se-1);\n\t\tint q=(ll)p*b%c;\n\t\tint dx=p-px.fi,dy=px.se-q;\n\t\tint cnt=px.se/dy;\n\t\tPII py(px.fi+cnt*dx,px.se-cnt*dy);\n\t\tg.pb({px.fi,px.se,py.fi,py.se,dx,-dy});\n\t\tpx=py;\n\t}\n\tll l=0,r=1ll<<33;\n\twhile (l+1<r) {\n\t\tll md=(l+r)>>1;\n\t\tbool valid=0;\n\t\tfor (auto p:g) {\n\t\t\tll x1=p[0]*md,x2=p[2]*md;\n\t\t\tif (x1<=x&&x<=x2) {\n\t\t\t\tll cc=p[1]*md+((x-x1)/p[4])*p[5];\n\t\t\t\tif (y>=cc) valid=1;\n\t\t\t}\n\t\t}\n\t\tif (g.back()[2]*md<=x) valid=1;\n\t\tif (valid) l=md; else r=md;\n\t}\n\tprintf(\"%lld\\n\",l);\n}\n\nint main() {\n\tint _;\n\tfor (scanf(\"%d\",&_);_;_--) {\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "a"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \n//int cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n/**\n * Description: euclid finds ${x,y}$ such that $ax+by=\\gcd(a,b)$ \n \t* and $|ax|,|by|\\le \\frac{ab}{\\gcd(a,b)}.$ Should work for $a,b<2^{62}$\n * Source: KACTL\n * Time: O(\\log ab)\n */\n\npl euclid(ll a, ll b) { \n\tif (!b) return {1,0};\n\tpl p = euclid(b,a%b); return {p.s,p.f-a/b*p.s}; }\nll invGen(ll a, ll b) { \n\tpl p = euclid(a,b); assert(p.f*a+p.s*b == 1); // gcd is 1\n\treturn p.f+(p.f<0)*b; }\n\n/**\n * Description: finds smallest $x\\ge 0$ such that $L\\le Ax\\pmod{P}\\le R$\n * Source: https://codeforces.com/gym/102411/submission/64315879\n * Verification: https://codeforces.com/gym/102411/problem/G\n */\n\nll cdiv(ll x, ll y) { return (x+y-1)/y; }\nll bet(ll P, ll A, ll L, ll R) { \n\tif (A == 0) return L == 0 ? 0 : -1;\n\tll c = cdiv(L,A); if (A*c <= R) return c;\n\tll B = P%A; // P = k*A+B, L <= A(x-Ky)-By <= R \n\t// => -R <= By % A <= -L\n\tauto y = bet(A,B,A-R%A,A-L%A); \n\treturn y == -1 ? y : cdiv(L+B*y,A)+P/A*y;\n}\n\n\nll A,X,B,Y,C;\nint solve() {\n\tre(A,X,B,Y,C);\n\tll g = __gcd(A,B);\n\tA /= g, B /= g; C /= __gcd(g,C);\n\tF0R(i,2) {\n\t\tint t = __gcd(A,C);\n\t\tY /= t; A /= t, C /= t;\n\t\tswap(A,B); swap(X,Y);\n\t}\n\tassert(__gcd(A,B) == 1 && __gcd(B,C) == 1 && __gcd(C,A) == 1);\n\t//dbg(\"OK\",A,B,C,X,Y);\n\tif (C == 1) return X+Y;\n\tvpi posi; posi.pb({0,C});\n\tint con = -1LL*A*invGen(B,C)%C; con = (con+C)%C;\n\t//dbg(\"START LOOP\");\n\twhile (1) {\n\t\tint L = 1, R = posi.bk.s-1; if (L > R) break;\n\t\tll x = bet(C,con,L,R); if (x == -1) break;\n\t\tposi.pb({x,con*x%C});\n\t\t//dbg(\"HAHA\",posi.bk);\n\t\t// 0 < (-A*x)*B^{-1} < posi.bk.s mod C\n\t}\n\t//dbg(\"END LOOP\");\n\tposi.pb({C,0});\n\t//dbg(posi);\n\tll ans = 0;\n\ttrav(t,posi) {\n\t\tll mul = INF;\n\t\tif (t.f) ckmin(mul,X/t.f);\n\t\tif (t.s) ckmin(mul,Y/t.s);\n\t\tckmax(ans,mul);\n\t}\n\tF0R(i,sz(posi)-1) {\n\t\tpi a = posi[i], b = posi[i+1];\n\t\tauto ok = [&](ll mid) -> bool {\n\t\t\tif (a.f*mid > X || b.s*mid > Y) return 0;\n\t\t\tll L = 0, R = mid;\n\t\t\tif (b.f*mid > X) {\n\t\t\t\t// a.f*x+b.f*(mid-x) <= X\n\t\t\t\t// (a.f-b.f)*x+b.f*mid <= X\n\t\t\t\t// x*(b.f-a.f) >= b.f*mid-X\n\t\t\t\tL = cdiv(b.f*mid-X,b.f-a.f);\n\t\t\t}\n\t\t\tif (a.s*mid > Y) {\n\t\t\t\t// a.s*x+b.s*(mid-x) <= Y\n\t\t\t\t// (a.s-b.s)*x <= Y-b.s*mid\n\t\t\t\tR = (Y-b.s*mid)/(a.s-b.s);\n\t\t\t}\n\t\t\treturn L <= R;\n\t\t};\n\t\tll lo = 0, hi = X+Y;\n\t\twhile (lo < hi) {\n\t\t\tll mid = (lo+hi+1)/2;\n\t\t\tif (ok(mid)) lo = mid;\n\t\t\telse hi = mid-1;\n\t\t}\n\t\tckmax(ans,lo);\n\t}\n\t// dbg(\"HA\",posi);\n\treturn ans;\n\t// Ax+By is divisible by C\n\t// what if gcd(A,C) > 1?\n\t// gcd(B,C) > 1?\n}\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) ps(solve());\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nvoid exgcd(int a, int b, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\treturn;\n\t}\n\tint q = a / b, r = a % b;\n\texgcd(b, r, y, x);\n\ty -= q * x;\n}\nint inv(int x, int p) {\n\tint a = 0, b = 0;\n\texgcd(x, p, a, b);\n\treturn (a % p + p) % p;\n}\nstruct info {int x, y, c; } q[MAXN];\nint top, a, b, c, x, y;\nvoid work(int c, int d){\n\tq[top = 0] = (info) {0, 0, 0};\n\tint x, a = 1, b = 0;\n\twhile (d != 0) {\n\t\tinfo tmp = q[top];\n\t\tq[++top] = (info) {tmp.x + c / d * a, tmp.y + c / d * d, c / d};\n\t\tfor (int t = 1; t <= 2 && d != 0; t++){\n\t\t\tif (t == 1) b += c / d * a;\n\t\t\telse a += c / d * b;\n\t\t\tx = c % d, c = d, d = x;\n\t\t}\n\t}\n}\nll func(ll x, ll y) {\n\tif (x < 0) return -1;\n\telse return x / y;\n}\nint main() {\n\tint T; read(T);\n\twhile (T--) {\n\t\tread(a), read(x), read(b), read(y), read(c);\n\t\tint g = __gcd(a, b); a /= g, b /= g, c /= __gcd(c, g);\n\t\tg = __gcd(a, c), a /= g, c /= g, y /= g;\n\t\tg = __gcd(b, c), b /= g, c /= g, x /= g;\n\t\ta %= c, b %= c;\n\t\tif (c == 1) {\n\t\t\tprintf(\"%d\\n\", x + y);\n\t\t\tcontinue;\n\t\t}\n\t\tint d = 1ll * a * inv(b, c) % c; work(c, d);\n\t\tif (q[top].x != c) q[++top] = (info) {c, c, 1};\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= top; i++) {\n\t\t\tint lx = q[i - 1].x, rx = q[i].x;\n\t\t\tint ly = c - q[i - 1].y, ry = c - q[i].y;\n\t\t\tint dx = (rx - lx) / q[i].c, dy = (ly - ry) / q[i].c;\n\t\t\tint l = ans + 1, r = x + y;\n\t\t\twhile (l <= r) {\n\t\t\t\tint mid = (0ll + l + r) / 2;\n\t\t\t\tll s = func(x - 1ll * mid * lx, dx);\n\t\t\t\tll t = func(y - 1ll * mid * ry, dy);\n\t\t\t\tif (s >= 0 && t >= 0 && s + t >= 1ll * q[i].c * mid) ans = mid, l = mid + 1;\n\t\t\t\telse r = mid - 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint a,b,c,lim1,lim2,tp;\n\nvoid exgcd(int a,int b,int &x,int &y) {\n\tif(!b) { x=1;y=0;return; }\n\texgcd(b,a%b,y,x);y-=a/b*x;\n}\n\nint inv(int a,int p) {\n\tint x,y;exgcd(a,p,x,y);\n\treturn (x+p)%p;\n}\n\nstruct dat {\n\tint x,y,cnt;\n} st[110];\n\nvoid get(int c,int d) {\n\ttp=0;int a=1,b=0;\n\twhile(d) {\n\t\t++tp;st[tp]=(dat){st[tp-1].x+c/d*a,st[tp-1].y+c/d*d,c/d};\n\t\tfor(int t=0;t<2&&d;t++) {\n\t\t\tif(!t) b+=c/d*a; else a+=c/d*b;\n\t\t\tswap(c,d);d%=c;\n\t\t}\n\t}\n}\n\nll Div(ll a,ll b) {\n\tif(a<0) return -1;\n\treturn a/b;\n}\n\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tint T;cin>>T;\n\twhile(T--) {\n\t\tcin>>a>>lim1>>b>>lim2>>c;\n\t\tint g=__gcd(a,b);a/=g,b/=g,c/=__gcd(c,g);\n\t\tg=__gcd(a,c),a/=g,c/=g,lim2/=g;\n\t\tg=__gcd(b,c),b/=g,c/=g,lim1/=g;\n\t\ta%=c;b%=c;\n\t\tif(c==1) { cout<<lim1+lim2<<'\\n';continue; }\n\t\tint d=1ll*a*inv(b,c)%c;get(c,d);int ans=0;\n\t\tif(st[tp].x!=c) st[++tp]=(dat){c,c,1};\n\t\tfor(int i=1;i<=tp;i++) {\n\t\t\tint lx=st[i-1].x,ly=c-st[i-1].y,rx=st[i].x,ry=c-st[i].y;\n\t\t\tint dx=(rx-lx)/st[i].cnt,dy=(ly-ry)/st[i].cnt;\n\t\t\t//cerr<<lx<<' '<<ly<<' '<<rx<<' '<<ry<<' '<<dx<<' '<<dy<<' '<<st[i].cnt<<'\\n';\n\t\t\tint l=ans,r=lim1+lim2;\n\t\t\twhile(l<r) {\n\t\t\t\tint mid=(1ll+l+r)>>1;\n\t\t\t\tif(max(0ll,Div(1ll*mid*ly-lim2+dy-1,dy))<=min(1ll*st[i].cnt*mid,Div(lim1-1ll*mid*lx,dx))) l=mid;\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tans=max(ans,l);\n\t\t}\n\t\tcout<<ans<<'\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "逃げないよ"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint T;\nll A,X,B,Y,C,TC;\n\nconst int prime_max = 1000000;\nvector<int> prime;\nint NP,divp[prime_max];\n\nvoid cprime() {\n\tif(NP) return;\n\tfor(int i=2;i<prime_max;i++) if(divp[i]==0) {\n\t\tprime.push_back(i); NP++;\n\t\tfor(ll j=1LL*i*i;j>=i&&j<prime_max;j+=i) if(divp[j]==0) divp[j]=i;\n\t}\n}\n\nll totient(ll v) {\n\tcprime();\n\tll ret=v;\n\tFORR(p,prime) {\n\t\tif(1LL*p*p>v) break;\n\t\tif(v%p==0) {\n\t\t\tret=ret/p*(p-1);\n\t\t\twhile(v%p==0) v/=p;\n\t\t}\n\t}\n\tif(v>1) ret=ret/v*(v-1);\n\treturn ret;\n}\n\nll modpow(ll a, ll n,ll mo) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>T;\n\twhile(T--) {\n\t\tcin>>A>>X>>B>>Y>>C;\n\t\tll g=__gcd(A,B),g2;\n\t\t\n\t\tA/=g;\tB/=g;\tC/=__gcd(g,C);\n\t\tg=__gcd(A,C);\tA/=g;\tC/=g;\tg2=gcd(B,g);\tB/=g2;\tY/=g/g2;\n\t\tg=__gcd(B,C);\tB/=g;\tC/=g;\tg2=gcd(A,g);\tA/=g2;\tX/=g/g2;\n\t\tif(C==1) {\n\t\t\tcout<<X+Y<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tA%=C;\n\t\tB%=C;\n\t\t\n\t\tTC=totient(C);\n\t\t\n\t\tvector<vector<ll>> cand;\n\t\tll D=A*modpow(B,TC-1,C)%C;\n\t\tcand.push_back({0,C,0});\n\t\tll H=D,W=0;\n\t\twhile(1) {\n\t\t\tH%=(C-W);\n\t\t\tif(H==0) {\n\t\t\t\tH=C-W;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tll dif=(C-W)%H;\n\t\t\tif(dif==0) break;\n\t\t\tll step=(C-W)/H;\n\t\t\tW=C-dif;\n\t\t\tll X=W*modpow(D,TC-1,C)%C;\n\t\t\tll Y=(C-D*X%C)%C;\n\t\t\tcand.push_back({X,Y,step});\n\t\t}\n\t\tcand.push_back({C,0,(C-W)/H});\n\t\t\n\t\tll ret=0;\n\t\t//cout<<A<<\" \"<<X<<\" \"<<B<<\" \"<<Y<<\" \"<<C<<endl;\n\t\tFORR(c,cand) {\n\t\t\t//cout<<c[0]<<\" \"<<c[1]<<\" \"<<c[2]<<endl;\n\t\t\tif(c[0]==0) ret=max(ret,Y/c[1]);\n\t\t\telse if(c[1]==0) ret=max(ret,X/c[0]);\n\t\t\telse ret=max(ret,min(X/c[0],Y/c[1]));\n\t\t}\n\t\t//cout<<ret<<endl;\n\t\tFOR(i,cand.size()-1) {\n\t\t\tll AX=cand[i][0],AY=cand[i][1];\n\t\t\tll BX=cand[i+1][0],BY=cand[i+1][1];\n\t\t\tif(AY*X<=AX*Y || BY*X>=BX*Y) continue;\n\t\t\tll step=cand[i+1][2];\n\t\t\tll g=__gcd(BX-AX,AY-BY);\n\t\t\tassert(g%step==0);\n\t\t\tll dx=(BX-AX)/step;\n\t\t\tll dy=(BY-AY)/step;\n\t\t\t\n\t\t\tint cur=0;\n\t\t\tfor(j=29;j>=0;j--) if(cur+(1<<j)<step) {\n\t\t\t\tll CX=AX+(cur+(1<<j))*dx;\n\t\t\t\tll CY=AY+(cur+(1<<j))*dy;\n\t\t\t\tif(CY*X>CX*Y) cur+=1<<j;\n\t\t\t}\n\t\t\tll TX=AX+cur*dx;\n\t\t\tll TY=AY+cur*dy;\n\t\t\tll SX=TX+dx;\n\t\t\tll SY=TY+dy;\n\t\t\tassert((TX*A+TY*B)%C==0);\n\t\t\tassert((SX*A+SY*B)%C==0);\n\t\t\tret=max(ret,min(TX?(X/TX):(1<<30),TY?(Y/TY):(1<<30)));\n\t\t\tret=max(ret,min(SX?(X/SX):(1<<30),SY?(Y/SY):(1<<30)));\n\t\t\tFOR(r,2) {\n\t\t\t\tll mx=0;\n\t\t\t\tfor(j=29;j>=0;j--) {\n\t\t\t\t\t__int128_t lef=(-TX*(mx+(1<<j))+X)*(__int128_t)SY;\n\t\t\t\t\t__int128_t ri=(-TY*(mx+(1<<j))+Y)*(__int128_t)SX;\n\t\t\t\t\tif(lef<ri) mx+=1<<j;\n\t\t\t\t}\n\t\t\t\t//cout<<i<<\":: \"<<SX<<\" \"<<SY<<\" \"<<TX<<\" \"<<TY<<\" \"<<X<<\" \"<<Y<<\" \"<<mx<<\" \"<<ret<<endl;\n\t\t\t\tfor(ll x=max(0LL,mx-2);x<=mx+2;x++) if(x>=0) {\n\t\t\t\t\tll LX=X-TX*x;\n\t\t\t\t\tll LY=Y-TY*x;\n\t\t\t\t\tif(LX>=0&LY>=0) {\n\t\t\t\t\t\tret=max(ret,x+min(SX?(LX/SX):(1<<30),SY?(LY/SY):(1<<30)));\n\t\t\t\t\t\t//cout<<x<<\" \"<<x+min(SX?(LX/SX):(1<<30),SY?(LY/SY):(1<<30))<<endl;\n\t\t\t\t\t\tll y=min(SX?(LX/SX):(1<<30),SY?(LY/SY):(1<<30));\n\t\t\t\t\t\tll XX=TX*x+SX*y;\n\t\t\t\t\t\tll YY=TY*x+SY*y;\n\t\t\t\t\t\t//cout<<(X>=XX)<<\" \"<<(Y>=YY)<<\" \"<<x+y<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout<<i<<\":: \"<<SX<<\" \"<<SY<<\" \"<<TX<<\" \"<<TY<<\" \"<<X<<\" \"<<Y<<\" \"<<mx<<\" \"<<ret<<endl;\n\t\t\t\tswap(TX,SY);\n\t\t\t\tswap(SX,TY);\n\t\t\t\tswap(X,Y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<ret<<endl;\n\t\t\n\t\t\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n cout<<\"うしたぷにきあ君笑\"<<endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint T,A,X,B,Y,C,D;\nvector<pair<int,int> > s;\nint _gcd(int a,int b){\n\tif(b==0)return a;\n\treturn _gcd(b,a%b);\n}\nvoid init(){\n\tint g=_gcd(A,B);\n\tA/=g,B/=g,C/=_gcd(g,C);\n\tg=_gcd(A,C),A/=g,C/=g,Y/=g;\n\tg=_gcd(B,C),B/=g,C/=g,X/=g;\n}\nvoid exgcd(int a,int b,int &x,int &y){\n\tif(b==0){\n\t\tx=1,y=0;\n\t\treturn;\n\t}\n\texgcd(b,a%b,x,y);\n\tint t=x;\n\tx=y;\n\ty=t-a/b*y;\n}\nint Inv(int a,int mod){\n\tint x,y;\n\texgcd(a,mod,x,y);\n\treturn (x+mod)%mod;\n}\nint Get(int x){\n\treturn !x?C:(C-1LL*x*D%C)%C;\n}\nvoid Get_seg(){\n\tD=1LL*A*Inv(B,C)%C;\n\ts.clear();\n\tint W=C,H=D,now=0,invD=Inv(D,C);\n\twhile(\"MAK AK IOI!\"){\n\t\ts.emplace_back(W/H,(int)(1LL*now*invD%C));\n\t\tnow+=W/H*H;\n\t\tif(!(W%=H))break;\n\t\tif(!(H%=W))H=W;\n\t}\n\ts.emplace_back(0,C);\n}\nint main(){\n\tT=read();\n\twhile(T--){\n\t\tA=read(),X=read(),B=read(),Y=read(),C=read();\n\t\tif(C==1){\n\t\t\tprintf(\"%d\\n\",X+Y);\n\t\t\tcontinue;\n\t\t}\n\t\tinit();\n\t\tGet_seg();\n\t\tint mx=0;\n\t\tfor(int i=0;i<(int)s.size()-1;++i){\n\t\t\tint lx=s[i].second,rx=s[i+1].second;\n\t\t\tint ly=Get(lx),ry=Get(rx);\n\t\t\tint dx=(rx-lx)/s[i].first,dy=(ly-ry)/s[i].first;\n\t\t\tauto check=[=](int k) -> bool{\n\t\t\t\tif(X-k*lx<0||Y-k*ry<0)return false;\n\t\t\t\tint a=(X-k*lx)/dx,b=(Y-k*ry)/dy;\n\t\t\t\treturn a+b>=k*s[i].first;\n\t\t\t};\n\t\t\tint l=0,r=X+Y+1,ans=0;\n\t\t\twhile(l<r){\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tif(check(mid)){\n\t\t\t\t\tans=mid;\n\t\t\t\t\tl=mid+1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tr=mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmx=max(mx,ans);\n\t\t}\n\t\tprintf(\"%d\\n\",mx);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint T;\nll A,X,B,Y,C,TC;\n\nll totient(ll v) {\n\tll ret=v;\n\tfor(ll i=2;i*i<=v;i++) if(v%i==0) {\n\t\tret=ret/i*(i-1);\n\t\twhile(v%i==0) v/=i;\n\t}\n\tif(v>1) ret=ret/v*(v-1);\n\treturn ret;\n}\n\nll modpow(ll a, ll n,ll mo) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>T;\n\twhile(T--) {\n\t\tcin>>A>>X>>B>>Y>>C;\n\t\tll g=__gcd(A,B),g2;\n\t\t\n\t\tA/=g;\tB/=g;\tC/=__gcd(g,C);\n\t\tg=__gcd(A,C);\tA/=g;\tC/=g;\tg2=gcd(B,g);\tB/=g2;\tY/=g/g2;\n\t\tg=__gcd(B,C);\tB/=g;\tC/=g;\tg2=gcd(A,g);\tA/=g2;\tX/=g/g2;\n\t\tif(C==1) {\n\t\t\tcout<<X+Y<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tA%=C;\n\t\tB%=C;\n\t\t\n\t\tTC=totient(C);\n\t\t\n\t\tvector<pair<ll,ll>> cand;\n\t\tll D=A*modpow(B,TC-1,C)%C;\n\t\tcand.push_back({0,C});\n\t\tll H=D,W=0;\n\t\twhile(1) {\n\t\t\tH%=(C-W);\n\t\t\tif(H==0) break;\n\t\t\tll dif=(C-W)%H;\n\t\t\tif(dif==0) break;\n\t\t\tW=C-dif;\n\t\t\tll X=W*modpow(D,TC-1,C)%C;\n\t\t\tll Y=(C-D*X%C)%C;\n\t\t\tcand.push_back({X,Y});\n\t\t}\n\t\tcand.push_back({C,0});\n\t\t\n\t\tll ret=0;\n\t\t//cout<<A<<\" \"<<X<<\" \"<<B<<\" \"<<Y<<\" \"<<C<<endl;\n\t\tFORR(c,cand) {\n\t\t\t//cout<<c.first<<\" \"<<c.second<<endl;\n\t\t\tif(c.first==0) ret=max(ret,Y/c.second);\n\t\t\telse if(c.second==0) ret=max(ret,X/c.first);\n\t\t\telse ret=max(ret,min(X/c.first,Y/c.second));\n\t\t}\n\t\tFOR(i,cand.size()-1) {\n\t\t\tll AX=cand[i].first,AY=cand[i].second;\n\t\t\tll BX=cand[i+1].first,BY=cand[i+1].second;\n\t\t\tif(AY*X<=AX*Y || BY*X>=BX*Y) continue;\n\t\t\tll step=__gcd(BX-AX,AY-BY);\n\t\t\tll dx=(BX-AX)/step;\n\t\t\tll dy=(BY-AY)/step;\n\t\t\t\n\t\t\tint cur=0;\n\t\t\tfor(j=29;j>=0;j--) if(cur+(1<<j)<step) {\n\t\t\t\tll CX=AX+(cur+(1<<j))*dx;\n\t\t\t\tll CY=AY+(cur+(1<<j))*dy;\n\t\t\t\tif(CY*X>CX*Y) cur+=1<<j;\n\t\t\t}\n\t\t\tll TX=AX+cur*dx;\n\t\t\tll TY=AY+cur*dy;\n\t\t\tll SX=TX+dx;\n\t\t\tll SY=TY+dy;\n\t\t\tll mx=0;\n\t\t\tfor(j=29;j>=0;j--) {\n\t\t\t\tll lef=(-SX*(mx+(1<<j))+X)*TY;\n\t\t\t\tll ri=(-TX*(mx+(1<<j))+Y)*SY;\n\t\t\t\tif(lef>ri) mx+=1<<j;\n\t\t\t}\n\t\t\tret=max(ret,min(TX?X/TX:1<<30,TY?Y/TY:1<<30));\n\t\t\tret=max(ret,min(SX?X/SX:1<<30,SY?Y/SY:1<<30));\n\t\t\t//cout<<i<<\":: \"<<SX<<\" \"<<SY<<\" \"<<TX<<\" \"<<TY<<\" \"<<X<<\" \"<<Y<<\" \"<<mx<<\" \"<<ret<<endl;\n\t\t\tfor(x=mx-1;x<=mx+1;x++) if(x>=0) {\n\t\t\t\tll LX=X-SX*x;\n\t\t\t\tll LY=Y-SY*x;\n\t\t\t\tif(LX>=0&LY>=0) ret=max(ret,x+min(TX?LX/TX:1<<30,TY?LY/TY:1<<30));\n\t\t\t}\n\t\t\t//cout<<ret<<endl;\n\t\t\tFOR(x,1000000) {\n\t\t\t\tll LX=X-SX*x;\n\t\t\t\tll LY=Y-SY*x;\n\t\t\t\tif(LX<0 || LY<0) break;\n\t\t\t\tret=max(ret,x+min(TX?LX/TX:1<<30,TY?LY/TY:1<<30));\n\t\t\t}\n\t\t\t//cout<<ret<<endl;\n\t\t\t\n\t\t}\n\t\t\n\t\tcout<<ret<<endl;\n\t\t\n\t\t\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint T;\nll A,X,B,Y,C;\n\nll modpow(ll a, ll n,ll mo) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>T;\n\twhile(T--) {\n\t\tcin>>A>>X>>B>>Y>>C;\n\t\tll g=__gcd(A,B),g2;\n\t\t\n\t\tA/=g;\tB/=g;\tC/=__gcd(g,C);\n\t\tg=__gcd(A,C);\tA/=g;\tC/=g;\tg2=gcd(B,g);\tB/=g2;\tY/=g/g2;\n\t\tg=__gcd(B,C);\tB/=g;\tC/=g;\tg2=gcd(A,g);\tA/=g2;\tX/=g/g2;\n\t\tif(C==1) {\n\t\t\tcout<<X+Y<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tA%=C;\n\t\tB%=C;\n\t\t\n\t\tvector<pair<ll,ll>> cand;\n\t\tll D=A*modpow(B,C-2,C)%C;\n\t\tcand.push_back({0,C});\n\t\tll H=D,W=0;\n\t\twhile(1) {\n\t\t\tH%=(C-W);\n\t\t\tif(H==0) break;\n\t\t\tll dif=(C-W)%H;\n\t\t\tif(dif==0) break;\n\t\t\tW=C-dif;\n\t\t\tll X=B*(C-W)%C*modpow(A,C-2,C)%C;\n\t\t\tX=((C-X)%C+C)%C;\n\t\t\tif(X==0) X=C;\n\t\t\tcand.push_back({X,C-W});\n\t\t}\n\t\tcand.push_back({C,0});\n\t\t\n\t\tll ret=0;\n\t\t//cout<<A<<\" \"<<X<<\" \"<<B<<\" \"<<Y<<\" \"<<C<<endl;\n\t\tFORR(c,cand) {\n\t\t\t//cout<<c.first<<\" \"<<c.second<<endl;\n\t\t\tif(c.first==0) ret=max(ret,Y/c.second);\n\t\t\telse if(c.second==0) ret=max(ret,X/c.first);\n\t\t\telse ret=max(ret,min(X/c.first,Y/c.second));\n\t\t}\n\t\t\n\t\tcout<<ret<<endl;\n\t\t\n\t\t\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nll gcd(ll a, ll b) {\n  return b ? gcd(b, a % b) : a;\n}\nvoid exgcd(ll a, ll b, ll& x, ll& y) {\n  if (!b) {\n    x = 1, y = 0;\n  } else {\n    exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n}\nll inv(ll a, ll Mod) {\n  ll x, y;\n  exgcd(a, Mod, x, y);\n  return x < 0 ? x + Mod : x;\n} \n\ntypedef class vec {\n  public:\n    ll dx, dy;\n    int c;\n\n    vec(ll dx, ll dy, int c) : dx(dx), dy(dy), c(c) { }\n} vec;\n\nint T;\nll A, X, B, Y, C;\nvector<vec> conv;\n\nvoid solve() {\n  scanf(\"%lld%lld%lld%lld%lld\", &A, &X, &B, &Y, &C);\n  ll g = gcd(A, B), ga, gb;\n  A /= g, B /= g, C /= gcd(g, C);\n  ga = gcd(A, C);\n  A /= ga, Y /= ga, C /= ga;\n  gb = gcd(B, C);\n  B /= gb, X /= gb, C /= gb;\n  if (C == 1) {\n    printf(\"%lld\\n\", X + Y);\n    return;\n  }\n\n  conv.clear();\n  ll W = C, H = A * inv(B, C) % C, x0 = 0, ia = inv(A, C), p = 0, np;\n  while (W && H) {\n    if (W >= H) {\n      ll t = W / H;\n      W -= t * H;\n      x0 += t * H;\n      np = x0 * B % C * ia % C;\n      np += !np * C;\n      conv.emplace_back((np - p) / t, H, t);\n      p = np;\n    } else {\n      if (!(H % W)) { \n        conv.emplace_back(C - p, W, 1);\n        break;\n      } else {\n        H %= W;\n      }\n    }\n  }\n\n  int l = 1, r = X + Y, mid;\n  while (l <= r) {\n    mid = (l + r) >> 1;\n    ll ca = 0, cb = mid * C;\n    for (auto v : conv) {\n      ll ub = min((cb - Y - 1) / v.dy + 1, 1ll * v.c * mid);\n      ub = min(ub, 1000000001ll);\n      ca += v.dx * ub;\n      cb -= v.dy * ub;\n      if (ca > X || cb <= Y) {\n        break;\n      }\n    }\n    if (ca <= X && cb <= Y) {\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  printf(\"%d\\n\", l - 1);\n}\n\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nint T, A, B, X, Y, C;\nint x, y;\nvoid exgcd(int a, int b, int &x, int &y){\n\tif(!b) return x=1,y=0,void();\n\texgcd(b,a%b,x,y); int _x=y, _y=x-a/b*y; x=_x; y=_y;\n}\nint inv(int a, int b){\n\texgcd(a,b,x,y);\n\tx = (x % b + b) % b; return x;\n}\nstruct dat{ int x, y, ct; };\nvector<dat> pt;\nvoid cope(int c, int d){\n\tpt.pb((dat){0,0,0}); int a=1, b=0;\n\twhile(d>0){\n\t\tdat t = pt.back();\n\t\tpt.pb((dat){t.x+c/d*a,t.y+c/d*d,c/d});\n\t\tfor(int _=1,x;_<=2&&d;_++){\n\t\t\tif(_==1)b+=c/d*a;\n\t\t\tif(_==2)a+=c/d*b;\n\t\t\tx=c%d,c=d,d=x;\n\t\t} \n\t} \n} int clc(ll x, ll y){ return x<0?-1:x/y; }\nvoid Main(){\n\tscanf(\"%d%d%d%d%d\",&A,&X,&B,&Y,&C);\n\tint t = __gcd(A,B); A/=t; B/=t; C/=__gcd(t,C);\n\tt = __gcd(A,C); A/=t, C/=t, Y/=t;\n\tt = __gcd(B,C); B/=t, C/=t, X/=t;\n\tif(C==1)return cout<<X+Y<<'\\n',void();\n\tint D = (ll)A * inv(B,C) % C;\n\tcope(C,D); int ans = 0;\n\tif(pt.back().x!=C)pt.pb((dat){C,C,1});\n\tfor(int i=1; i<(int)pt.size(); i++){\n\t\tint lx=pt[i-1].x,rx=pt[i].x;\n\t\tint ly=C-pt[i-1].y,ry=C-pt[i].y;\n\t\tint dx=(rx-lx)/pt[i].ct, dy=(ly-ry)/pt[i].ct;\n\t\tint l=ans+1,r=X+Y;\n\t\twhile(l<=r){\n\t\t\tint mid=(ll)(l+r)>>1;\n\t\t\tll S=clc(X-(ll)mid*lx,dx);\n\t\t\tll T=clc(Y-(ll)mid*ry,dy);\n\t\t\tif(~S&&~T&&S+T>=(ll)mid*pt[i].ct)ans=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t} \n\t} cout<<ans<<'\\n'; pt.clear();\n}\nsigned main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d\",&T);\n\twhile(T--)Main();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nint gcd(re int a,re int b)\n{\n\tif(!b)return a;\n\treturn gcd(b,a%b);\n}\nvoid exgcd(re int a,re int b,re int&x,re int &y)\n{\n\tif(!b){x=1;y=0;return;}\n\texgcd(b,a%b,y,x);\n\ty-=a/b*x;\n}\nint a,b,c,d,x,y,x1,y1,x2,y2,c1,d1,c2,d2,rd;\nlong long sol()\n{\n\tre int l=0,r=(y1-y2)/d2-1,xx,yy,xx1,yy1;\n\tfor(re int mid=(l+r+1)/2;l<r;mid=(l+r+1)/2)\n\t{\n\t\tyy=y1-mid*d2,xx=1ll*rd*yy%c;\n\t\tif(1ll*x*yy>=1ll*xx*y)l=mid;\n\t\telse r=mid-1;\n\t}\n\tyy=y1-l*d2;xx=1ll*rd*yy%c;yy1=yy-d2;xx1=1ll*rd*yy1%c;\n\tre long long xl1=xx-xx1,yl1=yy-yy1,xxl,yyl;\n\tl=0,r=1e9;\n\tfor(re int mid=(l+r+1)/2;l<r;mid=(l+r+1)/2)\n\t{\n\t\txxl=x+1ll*mid*xl1,yyl=y+1ll*mid*yl1;\n\t\tif((long double)xxl*yy>=(long double)xx*yyl)l=mid;\n\t\telse r=mid-1;\n\t}\n\txxl=x+l*xl1,yyl=y+l*yl1;//printf(\"****%lld %lld %d %d %d %d %d\\n\",xxl,yyl,xx,yy,xx1,yy1,l);\n\tre long long ans=std::min(xx?xxl/xx:(1ll<<60),yy?yyl/yy:(1ll<<60));\n\txxl+=xl1;yyl+=yl1;\n\tif(xxl>=0&&yyl>=0)ans=std::max(ans,std::min(xx?xxl/xx:(1ll<<60),yy?yyl/yy:(1ll<<60)));\n\treturn ans;\n}\nint main()\n{\n\tfreopen(\"01-01.txt\",\"r\",stdin);\n\tre int T;\n\tscanf(\"%d\",&T);\n\tfor(;T--;)\n\t{\n\t\tscanf(\"%d%d%d%d%d\",&a,&x,&b,&y,&c);\n\t\tre int g=gcd(a,b);a/=g,b/=g,c/=gcd(c,g);\n\t\tg=gcd(a,c);a/=g;c/=g;y/=g;\n\t\tg=gcd(b,c);b/=g;c/=g;x/=g;\n\t\texgcd(b,c,x1,y1);\n\t\td=1ll*a*(x1+c)%c;//printf(\"**%d %d %d c:%d d:%d %lld\\n\",a,b,gcd(a,b),c,d,1ll*(x1+c)*b%c);\n\t\texgcd(d,c,x1,y1);\n\t\trd=(c-x1)%c;\n\t\tc1=c,d1=d;\n\t\twhile(c1!=0)\n\t\t{\n\t\t\tx1=1ll*rd*c1%c;y1=c1;\n\t\t\tc2=c1,d2=d1;\n\t\t\tif(d1)c1%=d1;\n\t\t\telse c1=0;\n\t\t\tif(c1)d1%=c1;\n\t\t\telse d1=0;\n\t\t\tif(d1==0)d1=c1;\n\t\t\tre int x2=1ll*rd*c1%c,y2=c1;\n\t\t//printf(\"****%d %d %d %d %d %d\\n\",x1,y1,x2,y2,d,d2);\n\t\t\tif(1ll*x*y1>=1ll*x1*y&&1ll*x2*y>=1ll*x*y2)\n\t\t\t{\n\t\t\t\tprintf(\"%lld\\n\",sol());break;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define eb(x,y) emplace_back(x,y)\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint a,b,c,x,y,top;\ninline void exgcd(int a,int b,int&x,int&y){\n\tif(b==0){x=1,y=0;return;}\n\texgcd(b,a%b,y,x),y-=a/b*x;\n}\ninline int inv(int x,int p){int a=0,b=0;exgcd(x,p,a,b);return (a%p+p)%p;}\nstruct Node{int x,y,c;}q[MAXN];\ninline void work(int c,int d){\n\tq[top=0]=(Node){0,0,0};\n\tfor(int x,a=1,b=0;d;){\n\t\tNode tmp=q[top];q[++top]=(Node){tmp.x+c/d*a,tmp.y+c/d*d,c/d};\n\t\tRep(t,1,2){if(t==1)b+=c/d*a;else a+=c/d*b;x=c%d,c=d,d=x;}\n\t}\n}\ninline ll F(ll x,ll y){return x<0?-1:x/y;}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tfor(int t=read();t--;){\n\t\ta=read(),x=read(),b=read(),y=read(),c=read();\n\t\tint g=__gcd(a,b);a/=g,b/=g,c/=__gcd(c,g);\n\t\tg=__gcd(a,c),a/=g,c/=g,y/=g,g=__gcd(b,c),b/=g,c/=g,x/=g;\n\t\ta%=c,b%=c;if(c==1){cout<<x+y<<'\\n';continue;}int d=1ll*a*inv(b,c)%c;work(c,d);\n\t\tif(q[top].x!=c)q[++top]=(Node){c,c,1};int ans=0;\n\t\tRep(i,1,top){\n\t\t\tint lx=q[i-1].x,rx=q[i].x,ly=c-q[i-1].y,ry=c-q[i].y,dx=(rx-lx)/q[i].c,dy=(ly-ry)/q[i].c,l=ans+1,r=x+y;\n\t\t\twhile(l<=r){\n\t\t\t\tint mid=0ll+l+r>>1;ll s=F(x-1ll*mid*lx,dx),t=F(y-1ll*mid*ry,dy);\n\t\t\t\tif(s>=0&&t>=0&&s+t>=1ll*mid*q[i].c)ans=mid,l=mid+1;else r=mid-1;\n\t\t\t}\n\t\t}cout<<ans<<'\\n';\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <tuple>\nusing namespace std;\n#define endl '\\n'\n#define ll long long\n#define pi pair<int, int>\n#define pii pair<int, pi>\n#define f first\n#define s second\n\nll inv(ll a, ll mod){\n\tll b = mod, x = 0, y = 1, u = 1, v = 0;\n\twhile(a){\n\t\tll q = b / a, r = b % a;\n\t\ttie(x, y, u, v) = make_tuple(u, v, x - u * q, y - v * q);\n\t\tb = a, a = r;\n\t}\n\treturn x + (x < 0) * mod;\n}\n\nll a, x, b, y, c;\nll g, w, h, ia;\nvector<pii> v;\n\nbool works(ll f){\n\tint l = 0, r = v.size();\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(f * (c - v[mid].s.s) >= y) l = mid;\n\t\telse r = mid;\n\t}\n\tif(l == v.size() - 1) return 0;\n\t\n\tll dx = v[r].s.f - v[l].s.f, dy = v[r].s.s - v[l].s.s;\n\tdx /= v[r].f, dy /= v[r].f;\n\t\n\treturn l < v.size() - 1 && f * v[l].s.f + \n\t\tmin(x / dx + 1, (f * (c - v[l].s.s) + dy - y - 1) / dy) * dx <= x; \n}\n\nvoid answer(){\n\tcin >> a >> x >> b >> y >> c;\t\n\t\n\tg = __gcd(a, b);\n\ta /= g, b /= g, c /= __gcd(g, c);\n\tg = __gcd(a, c);\n\ta /= g, y /= g, c /= g;\n\tg = __gcd(b, c);\n\tb /= g, x /= g, c /= g;\n\t\n\tif(c == 1){\n\t\tcout << x + y << endl;\n\t\treturn;\n\t}\n\t\n\tw = c, h = a * inv(b, c) % c, ia = inv(a, c);\n\tv.assign(1, {1, {0, 0}});\n\twhile(w && h){\n\t\tif(w > h){\n\t\t\tll t = w / h;\n\t\t\tw -= t * h;\n\t\t\tv.push_back({t, {(c - w) * b % c * ia % c, c - w}});\n\t\t\tv.back().s.f += !v.back().s.f * c;\n\t\t}else if(h % w){\n\t\t\th %= w;\n\t\t}else{\n\t\t\tv.push_back({1, {c, c}});\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tll l = y / c, r = x + y + 1;\n\twhile(r - l > 1){\n\t\tll mid = (l + r) / 2;\n\t\tif(works(mid)) l = mid;\n\t\telse r = mid;\n\t}\n\t\n\tcout << l << endl;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor(int i = 0; i < t; i++) answer();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\ninline int exgcd(int a,int b,int &x,int &y){\n\tif (!b) return x=1,y=0,a;\n\tint g=exgcd(b,a%b,y,x);\n\treturn y-=a/b*x,g;\n}\ninline int inv(int A,int mod){\n\tint x,y;\n\texgcd(A,mod,x,y);\n\treturn x<0?x+mod:x;\n}\n\nint A,B,C,D,X,Y;\n\ninline void init(){\n\tint g=__gcd(__gcd(A,B),C);\n\tA/=g,B/=g,C/=g;\n\tg=__gcd(A,C),Y/=g,C/=g,A/=g;\n\tg=__gcd(B,C),X/=g,C/=g,B/=g;\n}\nvector<int>x,cnt;\ninline void Get(){\n\tD=1ll*A*inv(B,C)%C,x.clear(),cnt.clear();\n\tint W=C,H=D,now=0,invD=inv(D,C);\n\twhile (W){\n\t\tint tmp=W/H;\n\t\tcnt.pb(tmp),x.pb(1ll*now*invD%C),now+=tmp*H;\n\t\tW%=H;\n\t\tif (!W) break;\n\t\tH%=W;\n\t\tif (H==0) H=W;\n\t}\n\tx.pb(C),cnt.pb(0);\n}\ninline ll Div(ll x,ll y){\n\treturn x/y-(x%y&&(x^y)<0);\n}\ninline int Get(int x){\n\treturn x==0?C:(C-1ll*x*D%C)%C;\n}\ninline void solve(){\n\tA=read(),X=read(),B=read(),Y=read(),C=read();\n\tinit();\n\tif (C==1) return printf(\"%d\\n\",A+B),void(0);\n\tGet();\n\tll ans=0;\n\tFOR(i,0,siz(x)-1){\n\t\tint lx=x[i],ly=Get(lx),rx=x[i+1],ry=Get(rx),dx=(rx-lx)/cnt[i],dy=(ly-ry)/cnt[i];\n\t\tll l=0,r=X+Y,ret=0;\n\t\twhile (l<=r){\n\t\t\tll mid=l+r>>1;\n\t\t\tif (X-mid*lx>=0&&Y-mid*ry>=0){\n\t\t\t\tll a=(X-mid*lx)/dx,b=(Y-mid*ry)/dy;\n\t\t\t\tif (a>=0&&b>=0&&a+b>=mid*cnt[i]) l=mid+1,ret=mid;\n\t\t\t\t\telse r=mid-1;\n\t\t\t} else r=mid-1;\n\t\t}\n\t\tans=max(ans,ret);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\tint T=read();\n\twhile (T--) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tscanf(\"%d\",&x); return;\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntemplate<class T> inline bool Cmax(T &x,T y) {return x<y?x=y,1:0;} \ntypedef long long ll;\nint T,A,X,B,Y,C,D;\nvector<int> pos,cnt;\nint gcd(int a,int b) {return b==0?a:gcd(b,a%b);}\nint exgcd(int a,int b,int &x,int &y) {\n\tif(b==0) {x=1,y=0; return a;}\n\tint d=exgcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\ninline int inver(int a,int mod) {\n\tint x,y,d=exgcd(a,mod,x,y);\n\tif(x<0) x+=mod;\n\treturn x;\n}\ninline ll lowdiv(ll a,ll b) {return a/b-(a%b&&(a^b)<0);}\nvoid init() {\n\tint d=gcd(A,B);\n\tA/=d,B/=d,C/=gcd(d,C);\n\tfor(int _=0;_<2;++_) {\n\t\td=gcd(A,C);\n\t\tC/=d,A/=d;\n\t\tint t=gcd(B,d);\n\t\tB/=t,Y/=d/t;\n\t\tswap(A,B),swap(X,Y);\n\t}\n}\nvoid getpos() {\n\tpos.clear(),cnt.clear();\n\tint W=C,H=D,now=0,r=inver(D,C);\n\twhile(W) {\n\t\tint d=W/H;\n\t\tpos.push_back((ll)now*r%C),cnt.push_back(d); \n\t\tnow+=d*H;\n\t\tW%=H; if(W==0) break;\n\t\tH%=W; if(H==0) H=W;\n\t}\n\tpos.push_back(C);\n}\ninline int gety(int x) {return x==0?C:(C-(ll)x*D%C)%C;}\nint main() {\n//\tfreopen(\"1.in\",\"r\",stdin);\n//\tfreopen(\"1.out\",\"w\",stdout);\n\trd(T);\n\tfor(int kase=1;kase<=T;++kase) {\n\t\trd(A),rd(X),rd(B),rd(Y),rd(C);\n\t\tinit();\n\t\tif(C==1) {printf(\"%d\\n\",X+Y); continue;}\n\t\tD=(ll)A*inver(B,C)%C;\n\t\tgetpos();\n\t\tint an=0;\n\t\tfor(int i=0;i<cnt.size();++i) {\n\t\t\tint xl=pos[i],xr=pos[i+1],yl=gety(xl),yr=gety(xr);\n\t\t\tint dx=(xr-xl)/cnt[i],dy=(yl-yr)/cnt[i];\n\t\t\tint l=0,r=X+Y,re=-1;\n\t\t\twhile(l<=r) {\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tll p=lowdiv(X-(ll)xl*mid,dx),q=lowdiv(Y-(ll)yr*mid,dy);\n\t\t\t\tif(p>=0&&q>=0&&p+q>=(ll)cnt[i]*mid) re=mid,l=mid+1;\n\t\t\t\telse r=mid-1;\n\t\t\t}\n\t\t\tCmax(an,re);\n\t\t}\n\t\tprintf(\"%d\\n\",an);\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nll gcd(ll a, ll b) {\n  return b ? gcd(b, a % b) : a;\n}\nvoid exgcd(ll a, ll b, ll& x, ll& y) {\n  if (!b) {\n    x = 1, y = 0;\n  } else {\n    exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n}\nll inv(ll a, ll Mod) {\n  ll x, y;\n  exgcd(a, Mod, x, y);\n  return x < 0 ? x + Mod : x;\n} \n\ntypedef class vec {\n  public:\n    ll dx, dy;\n    int c;\n\n    vec(ll dx, ll dy, int c) : dx(dx), dy(dy), c(c) { }\n} vec;\n\nint T;\nll A, X, B, Y, C;\nvector<vec> conv;\n\nvoid solve() {\n  scanf(\"%lld%lld%lld%lld%lld\", &A, &X, &B, &Y, &C);\n  ll g = gcd(A, B), ga, gb;\n  A /= g, B /= g, C /= gcd(g, C);\n  ga = gcd(A, C);\n  A /= ga, Y /= ga, C /= ga;\n  gb = gcd(B, C);\n  B /= gb, X /= gb, C /= gb;\n  if (C == 1) {\n    printf(\"%lld\\n\", X + Y);\n    return;\n  }\n\n  conv.clear();\n  ll W = C, H = A * inv(B, C) % C, x0 = 0, ia = inv(A, C), p = 0, np;\n  while (W && H) {\n    if (W >= H) {\n      ll t = W / H;\n      W -= t * H;\n      x0 += t * H;\n      np = x0 * B % C * ia % C;\n      np += !np * C;\n      conv.emplace_back((np - p) / t, H, t);\n      p = np;\n    } else {\n      if (!(H % W)) { \n        conv.emplace_back(C - p, W, 1);\n        break;\n      } else {\n        H %= W;\n      }\n    }\n  }\n\n  int l = 1, r = X + Y, mid;\n  while (l <= r) {\n    mid = (l + r) >> 1;\n    ll ca = 0, cb = mid * C;\n    for (auto v : conv) {\n      ll ub = min(ub, 1000000001);\n      ca += v.dx * ub;\n      cb -= v.dy * ub;\n      if (ca > X || cb <= Y) {\n        break;\n      }\n    }\n    if (ca <= X && cb <= Y) {\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  printf(\"%d\\n\", l - 1);\n}\n\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lol;\nconst int N = 1e3 + 5;\nint _w;\n\nint A , B , X , Y , C;\n\nvoid exgcd( int a , int b , int & x , int & y ) {\n  if( !b ) {\n    x = 1, y = 0;\n    return;\n  } exgcd( b , a % b , y , x );\n  y -= a / b * x;\n}\n\nint inv( int a , int m ) {\n  int x , y;\n  exgcd( a , m , x , y );\n  x = ( x % m + m ) % m;\n  return x;\n}\n\ninline void solve( void ) {\n  _w = scanf(\"%d%d%d%d%d\",&A,&X,&B,&Y,&C);\n  int g = __gcd( A , B );\n  A /= g , B /= g , C /= __gcd( g , C );\n  for( int _ = 0 , t ; _ < 2 ; ++_ ) {\n    g = __gcd( A , C );\n    A /= g , C /= g;\n    t = __gcd( g , B );\n    B /= t , Y /= g / t;\n    swap( A , B ) , swap( X , Y );\n  }\n  if( C == 1 ) {\n    printf(\"%d\\n\",X+Y);\n    return;\n  }\n  int D = (lol)A * inv( B , C ) % C , ID = inv( D , C );\n  vector<int> x , y , n;\n  int W = C , H = D , now = 0;\n  while( W ) {\n    int d = W / H;\n    x.push_back( (lol)now * ID % C );\n    if( now == 0 ) y.push_back( C );\n    else y.push_back( ( C - now ) % C );\n    n.push_back( d );\n    now = ( now + (lol)d * H) % C;\n    W %= H;\n    if( !W ) break;\n    H %= W;\n    if( !H ) H = W;\n  }\n  x.push_back( C ) , y.push_back( 0 );\n  int ans = 0;\n  function<lol(lol,lol)> Div = []( lol a , lol b ) {\n    return a / b - ( a % b && (a^b) < 0 );\n  };\n  for( int i = 1 , lx , ly , rx , ry , ct , l , r , mid , res , dx , dy ; i < int(x.size()) ; ++i ) {\n    lx = x[i - 1] , rx = x[i] , ly = y[i - 1] , ry = y[i] , ct = n[i - 1];\n    l = 0 , r = X + Y + 1 , res = -1 , dx = ( rx - lx ) / ct , dy = ( ly - ry ) / ct;\n    while( l <= r ) {\n      mid = ( l + r ) >> 1;\n      lol p = Div( X - (lol)mid * lx , dx );\n      lol q = Div( Y - (lol)mid * ry , dy );\n      if( p >= 0 && q >= 0 && p + q >= (lol)ct * mid ) \n        res = mid , l = mid + 1;\n      else r = mid - 1;\n    }\n    ans = max( ans , res );\n  }\n  printf(\"%d\\n\",ans);\n}\n\nint main( void ) {\n  int T;\n  _w = scanf(\"%d\",&T);\n  while( T-- ) solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <tuple>\nusing namespace std;\n#define endl '\\n'\n#define ll long long\n#define pi pair<int, int>\n#define pii pair<int, pi>\n#define f first\n#define s second\n\nll inv(ll a, ll mod){\n\tll b = mod, x = 0, y = 1, u = 1, v = 0;\n\twhile(a){\n\t\tll q = b / a, r = b % a;\n\t\ttie(x, y, u, v) = make_tuple(u, v, x - u * q, y - v * q);\n\t\tb = a, a = r;\n\t}\n\treturn x + (x < 0) * mod;\n}\n\nll a, x, b, y, c;\nll g, w, h, ia;\nvector<pii> v;\n\nbool works(ll f){\n\tll l = 0, r = v.size();\n\twhile(r - l > 1){\n\t\tll mid = (l + r) / 2;\n\t\tif(f * (c - v[mid].s.s) >= y) l = mid;\n\t\telse r = mid;\n\t}\n\tif(l == v.size() - 1) return 0;\n\t\n\tll dx = v[r].s.f - v[l].s.f, dy = v[r].s.s - v[l].s.s;\n\tdx /= v[r].f, dy /= v[r].f;\n\t\n\treturn l < v.size() - 1 && f * v[l].s.f + \n\t\t(f * (c - v[l].s.s) + dy - y - 1) / dy * dx <= x; \n}\n\nvoid answer(){\n\tcin >> a >> x >> b >> y >> c;\t\n\t\n\tg = __gcd(a, b);\n\ta /= g, b /= g, c /= __gcd(g, c);\n\tg = __gcd(a, c);\n\ta /= g, y /= g, c /= g;\n\tg = __gcd(b, c);\n\tb /= g, x /= g, c /= g;\n\t\n\tw = c, h = a * inv(b, c), ia = inv(a, c);\n\tv.assign(1, {1, {0, 0}});\n\twhile(w && h){\n\t\tif(w > h){\n\t\t\tll t = w / h;\n\t\t\tw -= t * h;\n\t\t\tv.push_back({t, {(c - w) * b % c * ia % c, c - w}});\n\t\t\tv.back().s.f += !v.back().s.f * c;\n\t\t}else if(h % w){\n\t\t\th %= w;\n\t\t}else{\n\t\t\tv.push_back({1, {c, c}});\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tll l = y / c, r = x + y + 1;\n\twhile(r - l > 1){\n\t\tll mid = (l + r) / 2;\n\t\tif(works(mid)) l = mid;\n\t\telse r = mid;\n\t}\n\t\n\tcout << l << endl;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor(int i = 0; i < t; i++) answer();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define eb(x,y) emplace_back(x,y)\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=1e5+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint a,b,c,x,y,top;\ninline void exgcd(int a,int b,int&x,int&y){\n\tif(b==0){x=1,y=0;return;}int q=a/b,r=a%b;\n\texgcd(b,r,y,x),y-=q*x;\n}\ninline int inv(int x,int p){int a=0,b=0;exgcd(x,p,a,b);return (a%p+p)%p;}\nstruct Node{int x,y,c;}q[MAXN];\ninline void work(int c,int d){\n\tq[top=0]=(Node){0,0,0};\n\tfor(int x,a=1,b=0;d;){\n\t\tNode tmp=q[top];q[++top]=(Node){tmp.x+c/d*a,tmp.y+c/d*d,c/d};\n\t\tRep(t,1,2){if(t==1)b+=c/d*a;else a+=c/d*b;x=c%d,c=d,d=x;}\n\t}\n}\ninline ll F(ll x,ll y){return x<0?-1:x/y;}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tfor(int t=read();t--;){\n\t\ta=read(),x=read(),b=read(),y=read(),c=read();\n\t\tint g=__gcd(a,b);a/=g,b/=g,c/=__gcd(c,g);\n\t\tg=__gcd(a,c),a/=g,c/=g,y/=g,g=__gcd(b,c),b/=g,c/=g,x/=g;\n\t\ta%=c,b%=c;if(c==1){cout<<x+y<<'\\n';continue;}int d=1ll*a*inv(b,c)%c;work(c,d);\n\t\tif(q[top].x!=c)q[++top]=(Node){c,c,1};int ans=0;\n\t\tRep(i,1,top){\n\t\t\tint lx=q[i-1].x,rx=q[i].x,ly=c-q[i-1].y,ry=c-q[i].y,dx=(rx-lx)/q[i].c,dy=(ly-ry)/q[i].c,l=ans+1,r=x+y;\n\t\t\twhile(l<=r){\n\t\t\t\tint mid=l+r>>1;ll s=F(x-1ll*mid*lx,dx),t=F(y-1ll*mid*ry,dy);\n\t\t\t\tif(s>=0&&t>=0&&s+t>=1ll*mid*q[i].c)ans=mid,l=mid+1;else r=mid-1;\n\t\t\t}\n\t\t}cout<<ans<<'\\n';\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nint gcd(re int a,re int b)\n{\n\tif(!b)return a;\n\treturn gcd(b,a%b);\n}\nvoid exgcd(re int a,re int b,re int&x,re int &y)\n{\n\tif(!b){x=1;y=0;return;}\n\texgcd(b,a%b,y,x);\n\ty-=a/b*x;\n}\nint a,b,c,d,x,y,x1,y1,x2,y2,c1,d1,c2,d2,rd;\nlong long sol()\n{\n\tre int l=0,r=(y1-y2)/d2-1,xx,yy,xx1,yy1;\n\tfor(re int mid=(l+r+1)/2;l<r;mid=(l+r+1)/2)\n\t{\n\t\tyy=y1-mid*d2,xx=1ll*rd*yy%c;\n\t\tif(1ll*x*yy>=1ll*xx*y)l=mid;\n\t\telse r=mid-1;\n\t}\n\tyy=y1-l*d2;xx=1ll*rd*yy%c;yy1=yy-d2;xx1=1ll*rd*yy1%c;\n\tre long long xl1=xx-xx1,yl1=yy-yy1,xxl,yyl;\n\tl=0,r=1e9;\n\tfor(re int mid=(l+r+1)/2;l<r;mid=(l+r+1)/2)\n\t{\n\t\txxl=x+1ll*mid*xl1,yyl=y+1ll*mid*yl1;\n\t\tif((long double)xxl*yy>=(long double)xx*yyl)l=mid;\n\t\telse r=mid-1;\n\t}\n\txxl=x+l*xl1,yyl=y+l*yl1;//printf(\"****%lld %lld %d %d %d %d %d\\n\",xxl,yyl,xx,yy,xx1,yy1,l);\n\tre long long ans=std::min(xx?xxl/xx:(1ll<<60),yy?yyl/yy:(1ll<<60));\n\txxl+=xl1;yyl+=yl1;\n\tif(xxl>=0&&yyl>=0)ans=std::max(ans,std::min(xx?xxl/xx:(1ll<<60),yy?yyl/yy:(1ll<<60)));\n\treturn ans;\n}\nint main()\n{\n\tre int T;\n\tscanf(\"%d\",&T);\n\tfor(;T--;)\n\t{\n\t\tscanf(\"%d%d%d%d%d\",&a,&x,&b,&y,&c);\n\t\tre int g=gcd(a,b);a/=g,b/=g,c/=gcd(c,g);\n\t\tg=gcd(a,c);a/=g;c/=g;y/=g;\n\t\tg=gcd(b,c);b/=g;c/=g;x/=g;\n\t\texgcd(b,c,x1,y1);\n\t\td=1ll*a*(x1+c)%c;//printf(\"**%d %d %d c:%d d:%d %lld\\n\",a,b,gcd(a,b),c,d,1ll*(x1+c)*b%c);\n\t\texgcd(d,c,x1,y1);\n\t\trd=(c-x1)%c;\n\t\tc1=c,d1=d;\n\t\twhile(c1!=0)\n\t\t{\n\t\t\tx1=1ll*rd*c1%c;y1=c1;\n\t\t\tc2=c1,d2=d1;\n\t\t\tif(d1)c1%=d1;\n\t\t\telse c1=0;\n\t\t\tif(c1)d1%=c1;\n\t\t\telse d1=0;\n\t\t\tif(d1==0)d1=c1;\n\t\t\tre int x2=1ll*rd*c1%c,y2=c1;\n\t\t//printf(\"****%d %d %d %d %d %d\\n\",x1,y1,x2,y2,d,d2);\n\t\t\tif(1ll*x*y1>=1ll*x1*y&&1ll*x2*y>=1ll*x*y2)\n\t\t\t{\n\t\t\t\tprintf(\"%lld\\n\",sol());break;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\ninline int topbit(unsigned long long x){\n\treturn x?63-__builtin_clzll(x):-1;\n}\n\ninline int popcount(unsigned long long x){\n\treturn __builtin_popcountll(x);\n}\n\ninline int parity(unsigned long long x){\n\treturn __builtin_parity(x);\n}\n\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\n\nint extgcd(int a,int b,int &x,int &y){\n\tint g=a;\n\tx=1;\n\ty=0;\n\tif(b!=0){\n\t\tg=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}\n\treturn g;\n}\nint inv(int a,int m){\n\tint x,k;\n\textgcd(a,m,x,k);\n\treturn (x%m+m)%m;\n}\n\nvoid solve(){\n\tint A,X,B,Y,C;\n\tcin>>A>>X>>B>>Y>>C;\n\n\n\n\t//gcd(A,B,C)=1\n\tint tmp=gcd(gcd(A,B),C);\n\tA/=tmp;B/=tmp;C/=tmp;\n\n\n\t/*\n\tBy=-Ax mod C\n\tgcd(B,C) | (Ax)\n\tgcd(B,C) | x   (<=  gcd(gcd(B,C),A)=1)\n\tA *=gcd(B,C)\n\tX/=gcd(B,C)\n\tA/=gcd(B,C);B/=gcd(B,C);C/=gcd(B,C);\n\t*/\n\t\n\t//gcd(B,C)=1\n\ttmp=gcd(B,C);\n\tX/=tmp;\n\tB/=tmp;C/=tmp;\n\n\t/*\n\tBy=-Ax mod C\n\ty=-inv(B)Ax mod C\n\th:=(-inv(B)A mod C)\n\n\t(x,hx mod C) (x=0,1,2,...)\n\t*/\n\n\t//gcd(A,C)=1\n\ttmp=gcd(A,C);\n\tY/=tmp;\n\tA/=tmp;C/=tmp;\n\n\tif(C==1){\n\t\tcout<<X+Y<<endl;\n\t\treturn;\n\t}\n\n\t/*\n\tgcd(h,C)=1\n\t*/\n\n\tint H=(C-inv(B,C))*A%C;\n\n\tint h=H,c=C;\n\tvint dx,dy,num;\n\tdy.pb(C-h);\n\tnum.pb(1);\n\n\t/*\n\t(h,c)->(h-d,h)  (d=C%h)\n\t\t ->(h-2d,h-d)->...->(g,g+d)  (g=h%d)\n\n\t\tgcd(g,g+d)=gcd(g,d)=gcd(h%d,d)=gcd(h,d)=gcd(h,c%h)=gcd(h,c)=1\n\t*/\n\n\twhile(h){\n\t\tif(h==1){\n\t\t\tdy.pb(1);\n\t\t\tnum.pb(1);\n\t\t\tbreak;\n\t\t}\n\t\tint d=c%h;\n\t\tint g=h%d;\n\t\tdy.pb(d);\n\t\tnum.pb(h/d);\n\t\th=g;\n\t\tc=g+d;\n\t}\n\n\t/*\n\tdx=-H^{-1} dy\n\t*/\n\tint coef=C-inv(H,C);\n\trep(i,dy.size()){\n\t\tdx.pb(coef*dy[i]%C);\n\t}\n\n\t\n\tint lb=0,ub=X+Y+1;\n\twhile(ub-lb>1){\n\t\tint mid=(ub+lb)/2;\n\n\t\tint x=0,y=C*mid;\n\t\trep(i,dx.size()){\n\t\t\tif(x+dx[i]*num[i]*mid<=X){\n\t\t\t\tx+=dx[i]*num[i]*mid;\n\t\t\t\ty-=dy[i]*num[i]*mid;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint k=(X-x)/dx[i];\n\t\t\tx+=dx[i]*k;\n\t\t\ty-=dy[i]*k;\n\t\t\tbreak;\n\t\t}\n\t\tif(y<=Y)lb=mid;\n\t\telse ub=mid;\n\t}\n\tcout<<lb<<endl;\n}\n\nsigned main(){\n\tint T;cin>>T;\n\twhile(T--)solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <tuple>\nusing namespace std;\n#define endl '\\n'\n#define ll long long\n#define pi pair<int, int>\n#define pii pair<int, pi>\n#define f first\n#define s second\n\nll inv(ll a, ll mod){\n\tll b = mod, x = 0, y = 1, u = 1, v = 0;\n\twhile(a){\n\t\tll q = b / a, r = b % a;\n\t\ttie(x, y, u, v) = make_tuple(u, v, x - u * q, y - v * q);\n\t\tb = a, a = r;\n\t}\n\treturn x + (x < 0) * mod;\n}\n\nll a, x, b, y, c;\nll g, w, h, ia;\nvector<pii> v;\n\nbool works(ll f){\n\tll l = 0, r = v.size();\n\twhile(r - l > 1){\n\t\tll mid = (l + r) / 2;\n\t\tif(f * (c - v[mid].s.s) >= y) l = mid;\n\t\telse r = mid;\n\t}\n\tif(l == v.size() - 1) return 0;\n\t\n\tll dx = v[l + 1].s.f - v[l].s.f, dy = v[l + 1].s.s - v[l].s.s;\n\tdx /= v[l + 1].f, dy /= v[l + 1].f;\n\t\n\treturn l < v.size() - 1 && f * v[l].s.f + \n\t\t(f * (c - v[l].s.s) + dy - y - 1) / dy * dx <= x; \n}\n\nvoid answer(){\n\tcin >> a >> x >> b >> y >> c;\t\n\t\n\tg = __gcd(a, b);\n\ta /= g, b /= g, c /= __gcd(g, c);\n\tg = __gcd(a, c);\n\ta /= g, y /= g, c /= g;\n\tg = __gcd(b, c);\n\tb /= g, x /= g, c /= g;\n\t\n\tw = c, h = a * inv(b, c), ia = inv(a, c);\n\tv.assign(1, {1, {0, 0}});\n\twhile(w && h){\n\t\tif(w >= h){\n\t\t\tll t = w / h;\n\t\t\tw -= t * h;\n\t\t\tv.push_back({t, {(c - w) * b % c * ia % c, c - w}});\n\t\t}else if(h % w){\n\t\t\th %= w;\n\t\t}else{\n\t\t\tv.push_back({1, {c, c}});\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tll l = y / c, r = x + y + 1;\n\twhile(r - l > 1){\n\t\tll mid = (l + r) / 2;\n\t\tif(works(mid)) l = mid;\n\t\telse r = mid;\n\t}\n\t\n\tcout << l << endl;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor(int i = 0; i < t; i++) answer();\n\n\treturn 0;\n}"
  },
  {
    "language": "Text",
    "code": "ごめんなさい"
  },
  {
    "language": "Text",
    "code": "2\n2\n0\n"
  },
  {
    "language": "C",
    "code": "あ"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\n\npublic class Main {\n\tpublic static void main (String[] args) throws IOException{\n\t    InputStreamReader reader = new InputStreamReader(System.in, StandardCharsets.UTF_8);\n\t    BufferedReader in = new BufferedReader(reader);\n\t\tint num = Integer.parseInt(in.readLine());\n\t\tint cnt = 0;\n\t\tString[][] strs = new String[num][];\n\t\tString[] str = new String[5];\n\t\tint n = 0;\n\n\t\tfor(int i = 0; i<num; i++) {\n\t\t\tstr = in.readLine().split(\" \");\n\t\t\tstrs[i] = str;\n\t\t}\n\t\tfor(int i = 0; i<num; i++) {\n\t\t\tint A = Integer.parseInt(strs[i][0]);\n\t\t\tint X = Integer.parseInt(strs[i][1]);\n\t\t\tint B = Integer.parseInt(strs[i][2]);\n\t\t\tint Y = Integer.parseInt(strs[i][3]);\n\t\t\tint C = Integer.parseInt(strs[i][4]);\n\n\t\t\tint Anum = 0;\n\t\t\tint Bnum = 0;\n\n\t\t\tfor(int j=0; j<X; j++) {\n\t\t\t\tAnum += A;\n\t\t\t\tSystem.out.println(Anum);\n\t\t\t\tif(Anum % C == 0) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tfor(int k=n; k<Y; k++) {\n\t\t\t\t\tBnum += B;\n\t\t\t\t\tSystem.out.println(Bnum);\n\t\t\t\t\tif(j==0 && Bnum % C == 0) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tBnum = 0;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(Anum+Bnum);\n\t\t\t\t\tif((Anum+Bnum) % C == 0) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tBnum = 0;\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\n\npublic class Main {\n\tpublic static void main (String[] args) throws IOException{\n\t    InputStreamReader reader = new InputStreamReader(System.in, StandardCharsets.UTF_8);\n\t    BufferedReader in = new BufferedReader(reader);\n\t\tint num = Integer.parseInt(in.readLine());\n\t\tString[][] strs = new String[num][];\n\t\tString[] str = new String[5];\n\n\t\tfor(int i = 0; i<num; i++) {\n\t\t\tstr = in.readLine().split(\" \");\n\t\t\tstrs[i] = str;\n\t\t}\n\t\tfor(int i = 0; i<num; i++) {\n\t\t\tint n = 0;\n\t\t\tint cnt = 0;\n\t\t\tint A = Integer.parseInt(strs[i][0]);\n\t\t\tint X = Integer.parseInt(strs[i][1]);\n\t\t\tint B = Integer.parseInt(strs[i][2]);\n\t\t\tint Y = Integer.parseInt(strs[i][3]);\n\t\t\tint C = Integer.parseInt(strs[i][4]);\n\n\t\t\tint Anum = 0;\n\t\t\tint Bnum = 0;\n\n\t\t\tfor(int j=0; j<X; j++) {\n\t\t\t\tAnum += A;\n\t\t\t\tif(Anum % C == 0) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int k=n; k<Y; k++) {\n\t\t\t\t\tBnum += B;\n\t\t\t\t\tif((Anum+Bnum) % C == 0) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tn=k+1;\n\t\t\t\t\t}else if(j==0 && Bnum % C == 0) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tn=k+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tBnum = 0;\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution{\n  public static void main(String [] args){\n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    for(int  j= 1;j <= t;j++){\n     \tint a = sc.nextInt();\n    \tint x = sc.nextInt();\n    \tint b = sc.nextInt();\n    \tint y = sc.nextInt();\n    \tint c = sc.nextInt();\n    \tStack<Integer> sta = new Stack<>();\n    \tStack<Integer> stb = new Stack<>();\n    \tfor(int i = 0;i < x;i++){\n      \t\tsta.push(a);\n    \t}\n    \tfor(int i = 0;i < y;i++){\n      \t\tstb.push(b);\n    \t}\n    \tint rem = 0,count = 0;\n    \twhile(!sta.isEmpty() && !stb.isEmpty()){\n      \t\trem = (rem+sta.pop())%c;\n      \t\tif(rem == 0) count++;\n      \t\telse {\n        \t\tif( (rem + stb.peek())%c < rem) {\n        \t\t\trem = (rem + stb.pop())%c;\n        \t\t\tif(rem == 0)  count++;\n        \t\t}\n      \t\t}\n    \t}\n    \twhile(!sta.isEmpty()) {\n    \t\trem = (rem + sta.pop())%c;\n    \t\tif(rem == 0) count++;\n    \t}\n    \twhile(!stb.isEmpty()) {\n    \t\trem = (rem + stb.pop())%c;\n    \t\tif(rem == 0) count++;\n    \t}\n    \tSystem.out.println(count);\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution{\n  public static void main(String [] args){\n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    for(int  j= 1;j <= t;j++){\n     \tint a = sc.nextInt();\n    \tint x = sc.nextInt();\n    \tint b = sc.nextInt();\n    \tint y = sc.nextInt();\n    \tint c = sc.nextInt();\n    \tStack<Integer> sta = new Stack<>();\n    \tStack<Integer> stb = new Stack<>();\n    \tfor(int i = 0;i < x;i++){\n      \t\tsta.push(a);\n    \t}\n    \tfor(int i = 0;i < y;i++){\n      \t\tstb.push(b);\n    \t}\n    \tint rem = 0,count = 0;\n    \twhile(!sta.isEmpty() && !stb.isEmpty()){\n      \t\trem = (rem+sta.pop())%c;\n      \t\tif(rem == 0) count++;\n      \t\telse {\n        \t\tif( (rem + stb.peek())%c < rem) {\n        \t\t\trem = (rem + stb.pop())%c;\n        \t\t\tif(rem == 0)  count++;\n        \t\t}\n      \t\t}\n    \t}\n    \twhile(!sta.isEmpty()) {\n    \t\trem = (rem + sta.pop())%c;\n    \t\tif(rem == 0) count++;\n    \t}\n    \twhile(!stb.isEmpty()) {\n    \t\trem = (rem + stb.pop())%c;\n    \t\tif(rem == 0) count++;\n    \t}\n    \tSystem.out.println(count);\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution{\n  public static void main(String [] args){\n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    for(int  j= 1;j <= t;j++){\n     \tint a = sc.nextInt();\n    \tint x = sc.nextInt();\n    \tint b = sc.nextInt();\n    \tint y = sc.nextInt();\n    \tint c = sc.nextInt();\n    \tStack<Integer> sta = new Stack<>();\n    \tStack<Integer> stb = new Stack<>();\n    \tfor(int i = 0;i < x;i++){\n      \t\tsta.push(a);\n    \t}\n    \tfor(int i = 0;i < y;i++){\n      \t\tstb.push(b);\n    \t}\n    \tint rem = 0,count = 0;\n    \twhile(!sta.isEmpty() && !stb.isEmpty()){\n      \t\trem = (rem+sta.pop())%c;\n      \t\tif(rem == 0) count++;\n      \t\telse {\n        \t\tif( (rem + stb.peek())%c < rem) {\n        \t\t\trem = (rem + stb.pop())%c;\n        \t\t\tif(rem == 0)  count++;\n        \t\t}\n      \t\t}\n    \t}\n    \twhile(!sta.isEmpty()) {\n    \t\trem = (rem + sta.pop())%c;\n    \t\tif(rem == 0) count++;\n    \t}\n    \twhile(!stb.isEmpty()) {\n    \t\trem = (rem + stb.pop())%c;\n    \t\tif(rem == 0) count++;\n    \t}\n    \tSystem.out.println(count);\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution{\n  public static void main(String [] args){\n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    for(int i = 1;i <= t;i++){\n     \tint a = sc.nextInt();\n    \tint x = sc.nextInt();\n    \tint b = sc.nextInt();\n    \tint y = sc.nextInt();\n    \tint c = sc.nextInt();\n    \tStack<Integer> sta = new Stack<>();\n    \tStack<Integer> stb = new Stack<>();\n    \tfor(int i = 0;i < a;i++){\n      \t\tsta.push(x);\n    \t}\n    \tfor(int i = 0;i < b;i++){\n      \t\tstb.push(y);\n    \t}\n    \tint rem = -1,count = 0;\n    \twhile(!sta.isEmpty() && !stb.isEmpty()){\n      \t\trem = (rem+sta.pop())%c;\n      \t\tif(rem == 0) count++;\n      \t\telse {\n        \t\tif( (rem + stb.peek())%c < rem)\n        \t\t\trem = (rem + stb.pop())%c;\n      \t\t}\n    \t}\n    System.out.println(count);\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution{\n  public static void main(String [] args){\n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    for(int  j= 1;j <= t;j++){\n     \tint a = sc.nextInt();\n    \tint x = sc.nextInt();\n    \tint b = sc.nextInt();\n    \tint y = sc.nextInt();\n    \tint c = sc.nextInt();\n    \tStack<Integer> sta = new Stack<>();\n    \tStack<Integer> stb = new Stack<>();\n    \tfor(int i = 0;i < x;i++){\n      \t\tsta.push(a);\n    \t}\n    \tfor(int i = 0;i < y;i++){\n      \t\tstb.push(b);\n    \t}\n    \tint rem = 0,count = 0;\n    \twhile(!sta.isEmpty() && !stb.isEmpty()){\n      \t\trem = (rem+sta.pop())%c;\n      \t\tif(rem == 0) count++;\n      \t\telse {\n        \t\tif( (rem + stb.peek())%c < rem) {\n        \t\t\trem = (rem + stb.pop())%c;\n        \t\t\tif(rem == 0)  count++;\n        \t\t}\n      \t\t}\n    \t}\n    \twhile(!sta.isEmpty()) {\n    \t\trem = (rem + sta.pop())%c;\n    \t\tif(rem == 0) count++;\n    \t}\n    \twhile(!stb.isEmpty()) {\n    \t\trem = (rem + stb.pop())%c;\n    \t\tif(rem == 0) count++;\n    \t}\n    \tSystem.out.println(count);\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \nclass Solution{\n  public static void main(String [] args){\n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    for(int j = 1;j <= t;j++){\n     \tint a = sc.nextInt();\n    \tint x = sc.nextInt();\n    \tint b = sc.nextInt();\n    \tint y = sc.nextInt();\n    \tint c = sc.nextInt();\n    \tStack<Integer> sta = new Stack<>();\n    \tStack<Integer> stb = new Stack<>();\n    \tfor(int i = 0;i < a;i++){\n      \t\tsta.push(x);\n    \t}\n    \tfor(int i = 0;i < b;i++){\n      \t\tstb.push(y);\n    \t}\n    \tint rem = -1,count = 0;\n    \twhile(!sta.isEmpty() && !stb.isEmpty()){\n      \t\trem = (rem+sta.pop())%c;\n      \t\tif(rem == 0) count++;\n      \t\telse {\n        \t\tif( (rem + stb.peek())%c < rem)\n        \t\t\trem = (rem + stb.pop())%c;\n      \t\t}\n    \t}\n    \tSystem.out.println(count);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\n\npublic class Main {\n\tpublic static void main (String[] args) throws IOException{\n\t    InputStreamReader reader = new InputStreamReader(System.in, StandardCharsets.UTF_8);\n\t    BufferedReader in = new BufferedReader(reader);\n\t\tint num = Integer.parseInt(in.readLine());\n\t\tint cnt = 0;\n\t\tString[][] strs = new String[num][];\n\t\tString[] str = new String[5];\n\t\tint n = 0;\n\n\t\tfor(int i = 0; i<num; i++) {\n\t\t\tstr = in.readLine().split(\" \");\n\t\t\tstrs[i] = str;\n\t\t}\n\t\tfor(int i = 0; i<num; i++) {\n\t\t\tint A = Integer.parseInt(strs[i][0]);\n\t\t\tint X = Integer.parseInt(strs[i][1]);\n\t\t\tint B = Integer.parseInt(strs[i][2]);\n\t\t\tint Y = Integer.parseInt(strs[i][3]);\n\t\t\tint C = Integer.parseInt(strs[i][4]);\n\n\t\t\tint Anum = 0;\n\t\t\tint Bnum = 0;\n\n\t\t\tfor(int j=0; j<X; j++) {\n\t\t\t\tAnum += A;\n\t\t\t\tSystem.out.println(Anum);\n\t\t\t\tif(Anum % C == 0) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tfor(int k=n; k<Y; k++) {\n\t\t\t\t\tBnum += B;\n\t\t\t\t\tSystem.out.println(Bnum);\n\t\t\t\t\tif(j==0 && Bnum % C == 0) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tBnum = 0;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(Anum+Bnum);\n\t\t\t\t\tif((Anum+Bnum) % C == 0) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tn=k+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tBnum = 0;\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\n\npublic class Main {\n\tpublic static void main (String[] args) throws IOException{\n\t    InputStreamReader reader = new InputStreamReader(System.in, StandardCharsets.UTF_8);\n\t    BufferedReader in = new BufferedReader(reader);\n\t\tint num = Integer.parseInt(in.readLine());\n\t\tint cnt = 0;\n\t\tString[][] strs = new String[num][];\n\t\tString[] str = new String[5];\n\t\tint n = 0;\n\n\t\tfor(int i = 0; i<num; i++) {\n\t\t\tstr = in.readLine().split(\" \");\n\t\t\tstrs[i] = str;\n\t\t}\n\t\tfor(int i = 0; i<num; i++) {\n\t\t\tint A = Integer.parseInt(strs[i][0]);\n\t\t\tint X = Integer.parseInt(strs[i][1]);\n\t\t\tint B = Integer.parseInt(strs[i][2]);\n\t\t\tint Y = Integer.parseInt(strs[i][3]);\n\t\t\tint C = Integer.parseInt(strs[i][4]);\n\n\t\t\tint Anum = 0;\n\t\t\tint Bnum = 0;\n\n\t\t\tfor(int j=0; j<X; j++) {\n\t\t\t\tAnum += A;\n\t\t\t\tif(Anum % C == 0) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tfor(int k=n; k<Y; k++) {\n\t\t\t\t\tBnum += B;\n\t\t\t\t\tif(j==0 && Bnum % C == 0) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tBnum = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif((Anum+Bnum) % C == 0) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tn=k+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tBnum = 0;\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution{\n  public static void main(String [] args){\n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    for(int  j= 1;j <= t;j++){\n     \tint a = sc.nextInt();\n    \tint x = sc.nextInt();\n    \tint b = sc.nextInt();\n    \tint y = sc.nextInt();\n    \tint c = sc.nextInt();\n    \tStack<Integer> sta = new Stack<>();\n    \tStack<Integer> stb = new Stack<>();\n    \tfor(int i = 0;i < x;i++){\n      \t\tsta.push(a);\n    \t}\n    \tfor(int i = 0;i < y;i++){\n      \t\tstb.push(b);\n    \t}\n    \tint rem = 0,count = 0;\n    \twhile(!sta.isEmpty() && !stb.isEmpty()){\n      \t\trem = (rem+sta.pop())%c;\n      \t\tif(rem == 0) count++;\n      \t\telse {\n        \t\tif( (rem + stb.peek())%c < rem) {\n        \t\t\trem = (rem + stb.pop())%c;\n        \t\t\tif(rem == 0)  count++;\n        \t\t}\n      \t\t}\n    \t}\n    \twhile(!sta.isEmpty()) {\n    \t\trem = (rem + sta.pop())%c;\n    \t\tif(rem == 0) count++;\n    \t}\n    \twhile(!stb.isEmpty()) {\n    \t\trem = (rem + stb.pop())%c;\n    \t\tif(rem == 0) count++;\n    \t}\n    \tSystem.out.println(count);\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution{\n  public static void main(String [] args){\n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    for(int  j= 1;j <= t;j++){\n     \tint a = sc.nextInt();\n    \tint x = sc.nextInt();\n    \tint b = sc.nextInt();\n    \tint y = sc.nextInt();\n    \tint c = sc.nextInt();\n    \tStack<Integer> sta = new Stack<>();\n    \tStack<Integer> stb = new Stack<>();\n    \tfor(int i = 0;i < x;i++){\n      \t\tsta.push(a);\n    \t}\n    \tfor(int i = 0;i < y;i++){\n      \t\tstb.push(b);\n    \t}\n    \tint rem = 0,count = 0;\n    \twhile(!sta.isEmpty() && !stb.isEmpty()){\n      \t\trem = (rem+sta.pop())%c;\n      \t\tif(rem == 0) count++;\n      \t\telse {\n        \t\tif( (rem + stb.peek())%c < rem) {\n        \t\t\trem = (rem + stb.pop())%c;\n        \t\t\tif(rem == 0)  count++;\n        \t\t}\n      \t\t}\n    \t}\n    \twhile(!sta.isEmpty()) {\n    \t\trem = (rem + sta.pop())%c;\n    \t\tif(rem == 0) count++;\n    \t}\n    \twhile(!stb.isEmpty()) {\n    \t\trem = (rem + stb.pop())%c;\n    \t\tif(rem == 0) count++;\n    \t}\n    \tSystem.out.println(count);\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(\"test\");\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\n\npublic class Main {\n\tpublic static void main (String[] args) throws IOException{\n\t    InputStreamReader reader = new InputStreamReader(System.in, StandardCharsets.UTF_8);\n\t    BufferedReader in = new BufferedReader(reader);\n\t\tint num = Integer.parseInt(in.readLine());\n\t\tString[][] strs = new String[num][];\n\t\tString[] str = new String[5];\n\n\t\tfor(int i = 0; i<num; i++) {\n\t\t\tstr = in.readLine().split(\" \");\n\t\t\tstrs[i] = str;\n\t\t}\n\t\tfor(int i = 0; i<num; i++) {\n\t\t\tint n = 0;\n\t\t\tint cnt = 0;\n\t\t\tint A = Integer.parseInt(strs[i][0]);\n\t\t\tint X = Integer.parseInt(strs[i][1]);\n\t\t\tint B = Integer.parseInt(strs[i][2]);\n\t\t\tint Y = Integer.parseInt(strs[i][3]);\n\t\t\tint C = Integer.parseInt(strs[i][4]);\n\n\t\t\tint Anum = 0;\n\t\t\tint Bnum = 0;\n\n\t\t\tfor(int j=0; j<X; j++) {\n\t\t\t\tAnum += A;\n\t\t\t\tif(Anum % C == 0) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tfor(int k=n; k<Y; k++) {\n\t\t\t\t\tBnum += B;\n\t\t\t\t\tif(j==0 && Bnum % C == 0) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tBnum = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif((Anum+Bnum) % C == 0) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tn=k+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tBnum = 0;\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n}"
  },
  {
    "language": "PHP",
    "code": "2\n2\n0\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport itertools\n\ndef I(): return int(sys.stdin.readline().rstrip())\ndef LI():return list(map(int,sys.stdin.readline().rstrip().split()))\ndef LS():return list(sys.stdin.readline().rstrip().split())\n\ndef a(target, a, b, x, y):\n    # print(\"target=\",target,\"a=\",a,\"b=\",b,\"x=\",x,\"y=\",y)\n    a_n = min(x, target // a)\n    b_n = min(y, target // b)\n    # print(\"a_n=\",a_n, \"target//a=\",target//a, \"b_n=\",b_n,\"target//b=\",target//b)\n\n    comb = []\n    for a_i in range(a_n+1):\n        for b_i in range(b_n+1):\n            s = a * a_i + b * b_i\n            # print(\"target=\",target,\"a=\",a_i,\"b=\",b_i,\"s=\",s)\n            if s == target:\n                comb.append((a_i,b_i))\n    return comb\n\ndef solver():\n    A,X,B,Y,C = LI()\n    # print(\"A=\",A)\n    # print(\"X=\",X)\n    # print(\"B=\",B)\n    # print(\"Y=\",Y)\n    # print(\"C=\",C)\n\n    Total = A*X+B*Y\n    C_loop = Total//C\n    a_lmt = X\n    b_lmt = Y\n    ans = 0\n    for c_i in range(C_loop):\n        C_target = C * (c_i+1)\n\n        pattern = a(C_target, A, B, a_lmt, b_lmt)\n        # print(\"target=\",C_target, \"pattern_num=\",len(pattern))\n        ans += len(pattern)\n        for p in pattern:\n            # print(\"p=\",p)\n            a_lmt -= p[0]\n            b_lmt -= p[1]\n    return ans\n\ndef main():\n    T = I()\n    # print(\"T=\",T)\n\n    for _ in range(T):\n        # print(\"ANS=\",solver())\n        print(solver())\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "T = int(input())\n#NumList=[3, 3, 4, 4, 5]\nNumList=[2, 1, 1, 5, 3]\n\nP = [input().split() for i in range(T)]\n\ndef ReturnGoodGroup(AXBYC):\n    NumList=AXBYC\n    A, X, B, Y, C = int(NumList[0]),int(NumList[1]),int(NumList[2]),int(NumList[3]),int(NumList[4])\n\n    RemainingBall=X+Y\n    GroupNum=0\n\n    BallList=[]\n\n    for A_times in range(X+1):\n        for B_times in range(Y+1):\n            if A_times+B_times>0 and (A*A_times+B*B_times)%C==0:\n                BallList.append([A_times,B_times])\n\n    OmomiBallList=[[x[0]/A,x[0]/B] for x in BallList]\n    #print(OmomiBallList)\n    BallNumSumList=[sum(x) for x in OmomiBallList]\n\n    OmomiSortedBallList = [x for _,x in sorted(zip(BallNumSumList,BallList))]\n    #print(OmomiSortedBallList) \n\n\n    A_Remain=X\n    B_Remain=Y\n\n\n    for ls in OmomiSortedBallList:\n        #print(ls)\n        A_Remain-=ls[0]\n        B_Remain-=ls[1]\n\n    #     print(\"A_Remain:\")\n    #     print(A_Remain)\n    #     print(\"B_Remain:\")\n    #     print(B_Remain)\n\n        if A_Remain>-1 and B_Remain>-1:\n            GroupNum+=1\n        elif A_Remain<0 or B_Remain<0:\n            break\n\n\n    return(GroupNum)\n\nfor AXBYC in P:\n    print(ReturnGoodGroup(AXBYC))"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport itertools\n\ndef I(): return int(sys.stdin.readline().rstrip())\ndef LI():return list(map(int,sys.stdin.readline().rstrip().split()))\ndef LS():return list(sys.stdin.readline().rstrip().split())\n\ndef a(target, a, b, x, y):\n    # print(\"target=\",target,\"a=\",a,\"b=\",b,\"x=\",x,\"y=\",y)\n    a_n = min(x, target // a)\n    b_n = min(y, target // b)\n    # print(\"a_n=\",a_n, \"target//a=\",target//a, \"b_n=\",b_n,\"target//b=\",target//b)\n\n    comb = []\n    for a_i in range(a_n+1):\n        for b_i in range(b_n+1):\n            s = a * a_i + b * b_i\n            # print(\"target=\",target,\"a=\",a_i,\"b=\",b_i,\"s=\",s)\n            if s == target:\n                comb.append((a_i,b_i))\n    return comb\n\ndef solver():\n    A,X,B,Y,C = LI()\n    # print(\"A=\",A)\n    # print(\"X=\",X)\n    # print(\"B=\",B)\n    # print(\"Y=\",Y)\n    # print(\"C=\",C)\n\n    Total = A*X+B*Y\n    C_loop = Total//C\n    a_lmt = X\n    b_lmt = Y\n    ans = 0\n    for c_i in range(C_loop):\n        C_target = C * (c_i+1)\n\n        pattern = a(C_target, A, B, a_lmt, b_lmt)\n        print(\"target=\",C_target, \"pattern_num=\",len(pattern))\n        ans += len(pattern)\n        for p in pattern:\n            # print(\"p=\",p)\n            a_lmt -= p[0]\n            b_lmt -= p[1]\n    return ans\n    \ndef main():\n    T = I()\n    # print(\"T=\",T)\n\n    for _ in range(T):\n        # print(\"ANS=\",solver())\n        print(solver())\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport itertools\n\ndef I(): return int(sys.stdin.readline().rstrip())\ndef LI():return list(map(int,sys.stdin.readline().rstrip().split()))\ndef LS():return list(sys.stdin.readline().rstrip().split())\n\ndef a(target, a, b, x, y):\n    # print(\"target=\",target,\"a=\",a,\"b=\",b,\"x=\",x,\"y=\",y)\n    a_n = min(x, target // a)\n    b_n = min(y, target // b)\n    # print(\"a_n=\",a_n, \"target//a=\",target//a, \"b_n=\",b_n,\"target//b=\",target//b)\n\n    comb = []\n    for a_i in range(a_n+1):\n        for b_i in range(b_n+1):\n            s = a * a_i + b * b_i\n            # print(\"target=\",target,\"a=\",a_i,\"b=\",b_i,\"s=\",s)\n            if s == target:\n                comb.append((a_i,b_i))\n    return comb\n\ndef solver():\n    A,X,B,Y,C = LI()\n    # print(\"A=\",A)\n    # print(\"X=\",X)\n    # print(\"B=\",B)\n    # print(\"Y=\",Y)\n    # print(\"C=\",C)\n\n    Total = A*X+B*Y\n    C_loop = Total//C\n    a_lmt = X\n    b_lmt = Y\n    ans = 0\n    for c_i in range(C_loop):\n        C_target = C * (c_i+1)\n\n        pattern = a(C_target, A, B, a_lmt, b_lmt)\n        # print(\"target=\",C_target, \"pattern_num=\",len(pattern))\n        ans += len(pattern)\n        for p in pattern:\n            # print(\"p=\",p)\n            a_lmt -= p[0]\n            b_lmt -= p[1]\n    return ans\n\ndef main():\n    T = I()\n    # print(\"T=\",T)\n\n    for _ in range(T):\n        # print(\"ANS=\",solver())\n        print(solver())\n\n\nif __name__ == '__main__':\n    main()\n"
  }
]