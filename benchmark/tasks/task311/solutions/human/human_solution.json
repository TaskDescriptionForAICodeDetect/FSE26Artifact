[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  const int CMAX = 2000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 1000... really?\n    // # of 500 got so far : at most 100\n    // value : minimum payment\n    vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(CMAX+1, vector<int>(101, BIG)));\n    dp[0][0][0] = 0;\n    for(int i = 0; i < n; i++) {\n      const int ii = i + 1;\n      for(int j = 0; j <= CMAX; j++) { // not buying\n        for(int k = 0; k <= 100; k++) {\n          dp[ii][j][k] = dp[i][j][k];\n        }\n      }\n      // buying\n      const int p = ps[i] % 1000;\n      if(p != 0 && p <= 500) { // got 500!\n        for(int j = 0; j <= CMAX; j++) {\n          const int jj = min(j + 500 - p, 999);\n          for(int k = 0; k < 100; k++) {\n            const int kk = k + 1;\n            dp[ii][jj][kk] = min(dp[ii][jj][kk], dp[i][j][k] + ps[i]);\n          }\n        }\n      } else {\n        // get 500 if possible!\n        const int q = (p == 0 ? 1000 : p) - 500;\n        for(int j = 0; j <= CMAX; j++) {\n          if(j >= q) {\n            const int jj = j - q;\n            for(int k = 0; k < 100; k++) {\n              const int kk = k + 1;\n              dp[ii][jj][kk] = min(dp[ii][jj][kk], dp[i][j][k] + ps[i]);\n            }\n          } else { // get change\n            const int jj = j + 1000 - p;\n            if( jj < 1000) {\n              for(int k = 0; k <= 100; k++) {\n                const int kk = k;\n                dp[ii][jj][kk] = min(dp[ii][jj][kk], dp[i][j][k] + ps[i]);\n              }\n            }\n          }\n        }\n      }\n    }\n    for(int k = 100; k >= 0; k--) {\n      int p = BIG;\n      for(int j = 0; j <= CMAX; j++) {\n        p = min(p, dp[n][j][k]);\n      }\n      if(p != BIG) {\n        cout << k << \" \" << p << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nconst int INF = 5000*100*3;\nconst int max_x = 102;\nconst int max_y = 12000;\n\nint dp[max_x+10][max_y+10];\n\nvoid solve(int n){\n    // init\n    for(int j=0;j<max_x+10;j++) for(int k=0;k<max_y+10;k++) dp[j][k] = INF;\n    vector<int> p(n);\n    for(int i=0;i<n;i++) cin >> p[i];\n\n    dp[0][0] = 0;\n    for(int i=0;i<n;i++){\n        const int &pi = p[i];\n        for(int x=n;x>=0;x--){\n            for(int y=max_y;y>=0;y--){\n                if(pi%1000<=500){\n                    if(pi%1000>0 && y-(500-pi%1000)>=0 && x-1>=0)\n                        dp[x][y] = min(dp[x][y],dp[x-1][y-(500-pi%1000)]+pi);\n                    if(y+(pi%1000+500)<=max_y && x-1>=0)\n                        dp[x][y] = min(dp[x][y],dp[x-1][y+(pi%1000+500)]+pi);\n                }else{\n                    if(y+(pi%1000-500) <= max_y && x-1>=0) dp[x][y] = min(dp[x][y], dp[x-1][y + (pi%1000-500)] + pi);\n                    if(y-(1000-pi%1000)>=0) dp[x][y] = min(dp[x][y], dp[x][y-(1000-pi%1000)] + pi);\n                }\n            }\n        }\n    }\n\n    for(int i=100;i>=0;i--){\n        int mn = INF;\n        for(int j=0;j<=max_y;j++){\n            if(dp[i][j] < INF){\n                mn = min(mn,dp[i][j]);\n            }\n        }\n        if(mn != INF){\n            cout << i << \" \" << mn << endl;\n            return;\n        }\n    }\n}\n\nint main(){\n    while(1){\n        int n; cin >> n;\n        if(n==0) break;\n        solve(n);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\nconst ll INF = (1ll << 50);\n\nll dp[101][502][101];\nll n;\nll p[101];\n\n\nint main(){\n  while(cin >> n){\n    if(n == 0) return 0;\n    for(ll i = 0;i < n;i++) cin >> p[i];\n    for(ll i = 0;i <= 100;i++){\n      for(ll j = 0;j <= 501;j++){\n        for(ll k = 0;k <= 100;k++){\n          dp[i][j][k] = INF;\n        }\n      }\n    }\n    dp[0][0][0] = 0;\n    for(ll i = 0;i < n;i++){\n      for(ll j = 0;j <= 500;j++){\n        for(ll k = 0;k <= 100;k++){\n          dp[i+1][j][k] = min(dp[i+1][j][k],dp[i][j][k]);\n          if(p[i]%1000 <= 500 && p[i]%1000 > 0){\n            dp[i+1][j+(p[i]/1000)+1][k+1] = min(dp[i+1][j+(p[i]/1000)+1][k+1], dp[i][j][k]+p[i]);\n          }else if(p[i]%1000 > 500){\n            ll nokori = (p[i]%1000) - 500;\n            ll kozeni = j*1000-dp[i][j][k]-500*k;\n            if(kozeni >= nokori){\n              dp[i+1][j+(p[i]/1000)+1][k+1] = min(dp[i+1][j+(p[i]/1000)+1][k+1], dp[i][j][k]+p[i]);\n            }else{\n              dp[i+1][j+(p[i]/1000)+1][k] = min(dp[i+1][j+(p[i]/1000)+1][k], dp[i][j][k]+p[i]);\n            }\n          }else{\n            ll kozeni = j*1000-dp[i][j][k]-500*k;\n            if(kozeni >= 500){\n              dp[i+1][j+(p[i]/1000)][k+1] = min(dp[i+1][j+(p[i]/1000)][k+1], dp[i][j][k]+p[i]);\n\n            }else{\n              // dp[i+1][j+(p[i]/1000)][k] = min(dp[i+1][j+(p[i]/1000)][k], dp[i][j][k]);\n\n            }\n          }\n        }\n      }\n    }\n    // for(ll i = 0;i <= n;i++){\n    //   for(ll j = 0;j <= 5;j++){\n    //     for(ll k = 0;k <= 5;k++){\n    //       cerr << dp[i][j][k] << \" \";\n    //     }\n    //     cerr << endl;\n    //   }\n    //   cerr << endl;\n    // }\n    ll ans = 0;\n    ll cost = INF;\n    ll i = n;\n\n    for(ll j = 0;j <= 500;j++){\n      for(ll k = 0;k <= 100;k++){\n        if(dp[i][j][k] != INF){\n          if(ans < k){\n            ans = k;\n            cost = dp[i][j][k];\n            // cerr << j << \" \" << k << endl;\n          }else if(ans == k){\n            cost = min(cost, dp[i][j][k]);\n          }\n        }\n      }\n    }\n    cout << ans  << \" \" << cost << endl;\n\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n,i,j,k;\n  while(1){\n  cin>>n;\n  if(n==0) break;\n  int p[n+1],w[n+1];\n  int pri=0;\n  for(i=1;i<=n;i++) {\n    cin>>p[i];\n    pri+=p[i];\n    w[i]=(1000*(p[i]/1000))+1000-p[i];\n    if(w[i]==1000) w[i]=0;\n  }\n  int sum=0;\n  for(i=1;i<=n;i++) sum+=w[i];\n  int ans=sum/500;\n  int R=sum-500*ans;\n\n  int dp[R+1][n+1];\n  for(i=0;i<R+1;i++) dp[i][0]=0;\n  for(i=1;i<n+1;i++){\n    for(j=0;j<R+1;j++){\n      if(j-w[i]>=0) dp[j][i]=max(dp[j-w[i]][i-1]+p[i],dp[j][i-1]);\n      else dp[j][i]=dp[j][i-1];\n    }\n  }\n\n  cout<<ans<<\" \"<<pri - dp[R][n]<<endl;\n}\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvoid chmax(int&a,int b)\n{\n\ta=max(a,b);\n}\nmain()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tvector<vector<int> >dp(n+2,vector<int>(5e2+1,-1));\n\t\tdp[0][0]=0;\n\t\tfor(int count=0;count<n;count++)\n\t\t{\n\t\t\tint p;cin>>p;\n\t\t\tint oturi=p%1000?1000-p%1000:0;\n\t\t\tfor(int k=n;k>=0;k--)\n\t\t\t{\n\t\t\t\tfor(int j=5e2;j>=0;j--)\n\t\t\t\t{\n\t\t\t\t\tif(dp[k][j]<0)continue;\n\t\t\t\t\tchmax(dp[k+(dp[k][j]+oturi>=500)][j+(p+999)/1000],\n\t\t\t\t\t\t\tdp[k][j]+oturi-(dp[k][j]+oturi>=500?500:0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint f=0;\n\t\tfor(int k=n;!f&&k>=0;k--)\n\t\t{\n\t\t\tfor(int i=0;!f&&i<=5e2;i++)\n\t\t\t{\n\t\t\t\tif(dp[k][i]>=0)\n\t\t\t\t{\n\t\t\t\t\tcout<<k<<\" \"<<i*1000-dp[k][i]-k*500<<endl;\n\t\t\t\t\tf=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_MONEY = 5000;\nint n;\nvector<int> p;\nvector<vector<pair<int, int>>> memo;\n\ninline void Change(pair<int, int> &a, pair<int, int> &b) {\n    if ((a.first < b.first) || (a.first == b.first && a.second > b.second))\n        a = b;\n}\n\npair<int, int> Solve(int idx, int money) {\n    if (idx == n)\n        return pair<int, int>(0, 0);\n\n    auto &opt = memo[idx][money];\n    if (opt.first != -1)\n        return opt;\n\n    // idx?????????????????§????????????\n    opt = Solve(idx + 1, money);\n\n    // idx?????????????????§??????\n    if (0 < (p[idx] % 1000) && (p[idx] % 1000) <= 500) {\n        // 1000????????§?????????\n        int res = 1000 - (p[idx] % 1000) - 500 + money;\n        auto tmp = Solve(idx + 1, res);\n        tmp.first += 1;\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n    else if (p[idx] % 1000 == 0) {\n        if (500 <= money) {\n            int res = 500 - money;\n            auto tmp = Solve(idx + 1, res);\n            tmp.first += 1;\n            tmp.second += p[idx];\n            Change(opt, tmp);\n        }\n    }\n    else if (500 <= money + 1000 - (p[idx] % 1000)) {\n        // 1000????????¨?°????money??§?????????\n        int res = money + 1000 - (p[idx] % 1000) - 500;\n        auto tmp = Solve(idx + 1, res);\n        tmp.first += 1;\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n    else {\n        // 1000??????????????§?????????\n        int res = 1000 - (p[idx] % 1000) + money;\n        auto tmp = Solve(idx + 1, res);\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n\n    return opt;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n, n) {\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            cin >> p[i];\n\n        memo.clear();\n        memo.resize(n, vector<pair<int, int>>(n * 5000,\n                                              pair<int, int>(-1, 0)));\n\n        auto res = Solve(0, 0);\n        cout << res.first << ' ' << res.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vii;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip> vip;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 :1e9;\n#define MAX 50010\nint dp[110][MAX];\nint mo[110][MAX];\nvoid f(int a,int b,int c,int d){\n\tif(dp[a][b]<c){\n\t\tdp[a][b]=c;\n\t\tmo[a][b]=d;\n\t}else if(dp[a][b]==c)\n\t\tmo[a][b]=min(mo[a][b],d);\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi in(n);\n\t\trep(i,n)cin>>in[i];\n\t\trep(j,110)rep(k,MAX)dp[j][k]=-inf;\n\t\tdp[0][0]=mo[0][0]=0;\n\t\trep(i,n)rep(j,MAX)if(dp[i][j]!=-inf){\n\t\t\tf(i+1,j,dp[i][j],mo[i][j]);\n\t\t\tint a=in[i]%1000;\n\t\t\tint t=1000-a;\n\t\t\tif(a)f(i+1,j+t%500,dp[i][j]+(t>=500),mo[i][j]+in[i]);\n\t\t\telse if(j>=500)f(i+1,j-500,dp[i][j]+1,mo[i][j]+in[i]);\n\t\t\tt=500+j-a;\n\t\t\tif(t>=0&&a>=500)f(i+1,t,dp[i][j]+1,mo[i][j]+in[i]);\n\t\t}\n\n\t\tint outc=0,out=inf;\n\t\trep(i,MAX)if(dp[n][i]!=-inf){\n\t\t\tif(outc<dp[n][i]){\n\t\t\t\toutc=dp[n][i];\n\t\t\t\tout=mo[n][i];\n\t\t\t}else if(outc==dp[n][i])\n\t\t\t\tout=min(out,mo[n][i]);\n\t\t}\n\t\tcout<<outc<<\" \"<<out<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\nstruct State {\n\tbool reached;\n\tint num_coins;\n\tint paid;\n};\n\nbool is_better(State& x, State& y) {\n\tif (!y.reached) return true;\n\tif (x.num_coins > y.num_coins) return true;\n\tif (x.num_coins < y.num_coins) return false;\n\treturn x.paid < y.paid;\n}\n\nconst int MAX_POCKET = 1000;\n\nint stores[100];\nState dp[100][MAX_POCKET];\n\nvoid buy(int store_index, State state, int pocket, int pay_from_pocket) {\n\tint price = stores[store_index];\n\tstate.paid += price;\n\n\tint p = price - pay_from_pocket;\n\twhile (p > 0) p -= 1000;\n\tint change = (-p) % 1000;\n\tif (change >= 500) {\n\t\tstate.num_coins++;\n\t\tchange -= 500;\n\t}\n\n\tint new_pocket = (pocket - (pay_from_pocket % 1000) + change) % 1000;\n\tif (is_better(state, dp[store_index][new_pocket]))\n\t\tdp[store_index][new_pocket] = state;\n}\n\nint main()\n{\n\twhile (true) {\n\t\tint n;\n\t\tstd::cin >> n;\n\n\t\tif (n == 0) return 0;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint p;\n\t\t\tstd::cin >> p;\n\t\t\tstores[i] = p;\n\t\t}\n\n\t\tstd::memset(dp, 0, sizeof(dp));\n\n\t\t{\n\t\t\tdp[0][0].reached = true;\n\n\t\t\tState state = { true, 0, stores[0] };\n\t\t\tint change = stores[0] % 1000;\n\t\t\tif (change != 0) {\n\t\t\t\tchange = 1000 - change;\n\t\t\t\tif (change >= 500) {\n\t\t\t\t\tstate.num_coins++;\n\t\t\t\t\tchange -= 500;\n\t\t\t\t}\n\t\t\t\tdp[0][change] = state;\n\t\t\t}\n\t\t}\n\n\t\tfor (int store_index = 1; store_index < n; store_index++) {\n\t\t\tfor (int pocket = 0; pocket < MAX_POCKET; pocket++) {\n\t\t\t\tState& prev_state = dp[store_index - 1][pocket];\n\t\t\t\tif (!prev_state.reached) continue;\n\n\t\t\t\t// ????????????\n\t\t\t\tif (is_better(prev_state, dp[store_index][pocket]))\n\t\t\t\t\tdp[store_index][pocket] = prev_state;\n\n\t\t\t\t// ??????\n\t\t\t\tfor (int pay_from_pocket = 0; pay_from_pocket <= pocket; pay_from_pocket++) {\n\t\t\t\t\tbuy(store_index, prev_state, pocket, pay_from_pocket);\n\t\t\t\t\tbuy(store_index, prev_state, pocket, pay_from_pocket + 1000);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tState& best = dp[n - 1][0];\n\t\tfor (int i = 1; i < MAX_POCKET; i++) {\n\t\t\tState& current = dp[n - 1][i];\n\t\t\tif (current.reached && is_better(current, best))\n\t\t\t\tbest = dp[n - 1][i];\n\t\t}\n\n\t\tstd::cout << best.num_coins << \" \" << best.paid << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\nll dp[105][105][505];\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll n;\n\twhile (cin >> n, n) {\n\t\tvector<ll> p(n);\n\t\tfor (int i = 0; i < n;i++) cin >> p[i];\n\t\t/* dp[N][500yen cnt][1000yen cnt] := cost */\n\t\tfor (int i = 0; i < 105;i++)for (int j = 0; j < 105;j++)for (int k = 0; k < 505;k++)dp[i][j][k] = INF;\n\t\tdp[0][0][0] = 0;\n\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tfor (int j = 0; j < 105;j++) {\n\t\t\t\tfor (int k = 0; k < 505;k++) {\n\t\t\t\t\tif (dp[i][j][k] == INF)continue;\n\n\t\t\t\t\tint coin = 1000 * k - dp[i][j][k] - 500 * j;\n\t\t\t\t\tdp[i + 1][j][k] = min(dp[i + 1][j][k], dp[i][j][k]);\n\n\t\t\t\t\t/*cout << i << \" \" << j << \" \" << k << endl;\n\t\t\t\t\tcout << dp[i][j][k] << \" \" << p[i] << endl;\n\t\t\t\t\tcout << coin << endl;\n\t\t\t\t\tcout << \"---------------------------------\" << endl;*/\n\n\t\t\t\t\tint x = p[i] + 500;\n\t\t\t\t\tint th = x / 1000;\n\t\t\t\t\tint c = x % 1000;\n\t\t\t\t\tif (coin >= c) {\n\t\t\t\t\t\tdp[i + 1][j + 1][k + th] = min(dp[i + 1][j + 1][k + th], dp[i][j][k] + p[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tth = p[i] / 1000;\n\t\t\t\t\tif (p[i] % 1000 != 0)th++;\n\t\t\t\t\tc = 1000 * th - p[i];\n\t\t\t\t\tif (c >= 500) {\n\t\t\t\t\t\tdp[i + 1][j + 1][k +th] = min(dp[i + 1][j + 1][k + th], dp[i][j][k] + p[i]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i + 1][j][k + th] = min(dp[i + 1][j][k + th], dp[i][j][k] + p[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans1, ans2 = INF;\n\t\tfor (int i = 104; i >= 0;i--) {\n\t\t\tbool f = false;\n\t\t\tfor (int j = 504; j >= 0; j--) {\n\t\t\t\tif (dp[n][i][j] == INF)continue;\n\t\t\t\tif (!f) { ans1 = i; f = true; }\n\t\t\t\tans2 = min(ans2, dp[n][i][j]);\n\t\t\t}\n\t\t\tif (f)break;\n\t\t}\n\t\tcout << ans1 << \" \" << ans2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nvector<pair<int,int> >dp(50001);\nvector<pair<int,int> >dp2(50001);\nint n;\n\nint main(){\n\twhile(cin>>n&&n!=0){\n\t\tfor(int i=0;i<50001;i++){\n\t\t\tdp[i] = make_pair(0,0);\n\t\t}\n\t\tvector<int> val(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> val[i];\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint v = val[i]%1000;\n\t\t\tif(v==0){\n\t\t\t\tfor(int j=0;j<50001;j++){\n\t\t\t\t\tif(j+500>50000)break;\n\t\t\t\t\tif(dp[j+500]!=make_pair(0,0)){\n\t\t\t\t\t\tif(dp[j].first < dp[j+500].first+1){\n\t\t\t\t\t\t\tdp[j] = dp[j+500];\n\t\t\t\t\t\t\tdp[j].first += 1;\n\t\t\t\t\t\t\tdp[j].second += val[i];\n\t\t\t\t\t\t}else if(dp[j].first == dp[j+500].first+1){\n\t\t\t\t\t\t\tif(dp[j+500].second+val[i] < dp[j].second){\n\t\t\t\t\t\t\t\tdp[j].second = dp[j+500].second + val[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(v<=500){\n\t\t\t\tdp2 = dp;\n\t\t\t\tfor(int j=0;j<50001;j++){\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tif(dp2[j+500-v]==make_pair(0,0)){\n\t\t\t\t\t\t\tdp2[j+500-v]= make_pair(1,val[i]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(dp2[j+500-v].first < dp[j].first+1){\n\t\t\t\t\t\t\t\tdp2[j+500-v] = dp[j];\n\t\t\t\t\t\t\t\tdp2[j+500-v].first += 1;\n\t\t\t\t\t\t\t\tdp2[j+500-v].second += val[i];\n\t\t\t\t\t\t\t}else if(dp2[j+500-v].first == dp[j].first+1){\n\t\t\t\t\t\t\t\tif(dp2[j+500-v].second > dp[j].second + val[i]){\n\t\t\t\t\t\t\t\tdp2[j+500-v] = dp[j];\n\t\t\t\t\t\t\t\tdp2[j+500-v].first += 1;\n\t\t\t\t\t\t\t\tdp2[j+500-v].second += val[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j+500-v>50000)break;\n\t\t\t\t\tif(dp[j]!=make_pair(0,0)){\n\t\t\t\t\t\tif(dp2[j+500-v].first < dp[j].first+1){\n\t\t\t\t\t\t\tdp2[j+500-v] = dp[j];\n\t\t\t\t\t\t\tdp2[j+500-v].first += 1;\n\t\t\t\t\t\t\tdp2[j+500-v].second += val[i];\n\t\t\t\t\t\t}else if(dp2[j+500-v].first == dp[j].first+1){\n\t\t\t\t\t\t\tif(dp2[j+500-v].second > dp[j].second + val[i]){\n\t\t\t\t\t\t\t\tdp2[j+500-v] = dp[j];\n\t\t\t\t\t\t\t\tdp2[j+500-v].first += 1;\n\t\t\t\t\t\t\t\tdp2[j+500-v].second += val[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp = dp2;\n\t\t\t}else{\n\t\t\t\tdp2 = dp;\n\t\t\t\tfor(int j=0;j<50001;j++){\n\t\t\t\t\tif(j+1000-v>50000)break;\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tif(dp2[j+1000-v]==make_pair(0,0)){\n\t\t\t\t\t\t\tdp2[j+1000-v] = make_pair(0,val[i]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(dp2[j+1000-v].first < dp[j].first){\n\t\t\t\t\t\t\t\tdp2[j+1000-v] = dp[j];\n\t\t\t\t\t\t\t\tdp2[j+1000-v].second += val[i];\n\t\t\t\t\t\t\t}else if(dp2[j+1000-v].first == dp[j].first){\n\t\t\t\t\t\t\t\tif(dp2[j+1000-v].second > dp[j].second + val[i]){\n\t\t\t\t\t\t\t\t\tdp2[j+1000-v] = dp[j];\n\t\t\t\t\t\t\t\t\tdp2[j+1000-v].second += val[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[j]!=make_pair(0,0)){\n\t\t\t\t\t\tif(dp2[j+1000-v].first < dp[j].first){\n\t\t\t\t\t\t\tdp2[j+1000-v] = dp[j];\n\t\t\t\t\t\t\tdp2[j+1000-v].second += val[i];\n\t\t\t\t\t\t}else if(dp2[j+1000-v].first == dp[j].first){\n\t\t\t\t\t\t\tif(dp2[j+1000-v].second > dp[j].second + val[i]){\n\t\t\t\t\t\t\t\tdp2[j+1000-v] = dp[j];\n\t\t\t\t\t\t\t\tdp2[j+1000-v].second += val[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<50001;j++){\n\t\t\t\t\tif(j-v+500<0)continue;\n\t\t\t\t\tif(dp[j]!=make_pair(0,0)){\n\t\t\t\t\t\tif(dp2[j-v+500].first < dp[j].first+1){\n\t\t\t\t\t\t\tdp2[j-v+500] = dp[j];\n\t\t\t\t\t\t\tdp2[j-v+500].first += 1;\n\t\t\t\t\t\t\tdp2[j-v+500].second += val[i];\n\t\t\t\t\t\t}else if(dp2[j-v+500].first == dp[j].first+1){\n\t\t\t\t\t\t\tif(dp2[j-v+500].second > dp[j].second + val[i]){\n\t\t\t\t\t\t\t\tdp2[j-v+500] = dp[j];\n\t\t\t\t\t\t\t\tdp2[j-v+500].first +=1;\n\t\t\t\t\t\t\t\tdp2[j-v+500].second += val[i]; \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp = dp2;\n\t\t\t}\n\t\t}\n\t\tint mx = -1;\n\t\tpair<int,int> p=make_pair(0,0);\n\t\tfor(int i=0;i<50001;i++){\n\t\t\tif(mx < dp[i].first){\n\t\t\t\tp = dp[i];\n\t\t\t\tmx = dp[i].first;\n\t\t\t}else if(mx == dp[i].first){\n\t\t\t\tif(p.second > dp[i].second){\n\t\t\t\t\tp = dp[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << p.first << \" \" << p.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nconst int INF = 500002;\nint p[102];\nP dp[102][102][502];\nbool visited[102][102][502];\nint n;\n\nP dfs(int pos, int r, int ex){\n    if(pos == n) return P(0, 0);\n    if(visited[pos][r][ex]) return dp[pos][r][ex];\n    int pay = 1000;\n    while(pay < p[pos]) pay += 1000;\n    int nex = ex + pay - p[pos];\n    int nr = r + nex / 500;\n    nex %= 500;\n    P ret = dfs(pos+1, r, ex);\n    if(nr > 0){\n        P res = dfs(pos+1, nr-1, nex);\n        ret = max(ret, P(res.first + 1, res.second - p[pos]));\n    }else{\n        P res = dfs(pos+1, nr, nex);\n        ret = max(ret, P(res.first, res.second - p[pos]));\n    }\n    dp[pos][r][ex] = ret;\n    visited[pos][r][ex] = true;\n    return ret;\n}\n\nint main(){\n    while(true){\n        cin >> n;\n        if(n == 0) break;\n\n        for(int i=0;i<n;i++){\n            cin >> p[i];\n        }\n\n        memset(visited, 0, sizeof(visited));\n        P ans = dfs(0, 0, 0);\n        cout << ans.first << \" \" << -ans.second << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\npair<int,int> dp[101][50501];\n\nbool ge(pair<int,int>p1,pair<int,int>p2){\n\tif(p1.first==0&&p1.second==0)return 1;\n\tif(p2.first==0&&p2.second==0)return 0;\n\tif(p1.first > p2.first)return 0;\n\tif(p1.first < p2.first)return 1;\n\tif(p1.second < p2.second)return 0;\n\treturn 1;\n}\n\n\nint main(){\n\tint n;\n\tint x;\n\tpair<int,int> p1,p2;\t\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int j=0;j<50001;j++){\n\t\t\t\tdp[i][j]=make_pair(0,0);\n\t\t\t}\n\t\t}\n\t\tvector<int> v(n+1,0);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tx = (v[i]-1)%1000+1;\n\t\t\tif(x<=500){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<50000;j++){\n\t\t\t\t\tif(j==0&&dp[i-1][j]==make_pair(0,0)){\n\t\t\t\t\t\tdp[i][j+500-x] = make_pair(1,v[i]);\n\t\t\t\t\t\tdp[i][j+500-x] = max(dp[i][j+500-x],dp[i-1][j+500-x],ge);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(dp[i-1][j]!=make_pair(0,0)){\n\t\t\t\t\t\t\tdp[i][j+500-x] = dp[i-1][j];\n\t\t\t\t\t\t\tdp[i][j+500-x].first +=1;\n\t\t\t\t\t\t\tdp[i][j+500-x].second +=v[i];\n\t\t\t\t\t\t\tdp[i][j+500-x] = max(dp[i][j+500-x],dp[i-1][j+500-x],ge);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i][j+500-x] = dp[i-1][j+500-x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<50000;j++){\n\t\t\t\t\tp1 = make_pair(0,0);\n\t\t\t\t\tp2 = make_pair(0,0);\n\t\t\t\t\tif(j-(1000-x)>=0){\n\t\t\t\t\t\tif(dp[i-1][j-(1000-x)]!=make_pair(0,0)){\n\t\t\t\t\t\t\tp1 = dp[i-1][j-(1000-x)];\n\t\t\t\t\t\t\tp1.second += v[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i-1][j+x-500]!=make_pair(0,0)){\n\t\t\t\t\t\tp2 = dp[i-1][j+x-500];\n\t\t\t\t\t\tp2.first +=1;\n\t\t\t\t\t\tp2.second +=v[i];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\tif(j-(1000-x)==0){\n\t\t\t\t\t\tif(dp[i-1][j]==make_pair(0,0)){\n\t\t\t\t\t\t\tdp[i][j]=make_pair(0,v[i]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i][j]=max(dp[i-1][j],make_pair(0,v[i]),ge);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = max(dp[i][j],p1,ge);\n\t\t\t\t\tdp[i][j] = max(dp[i][j],p2,ge);\n\t\t\t\t\tif(j==0&&dp[i][j].first==0){\n\t\t\t\t\t\tdp[i][j] = make_pair(0,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int,int> mx = make_pair(0,0);\n\t\tfor(int j=0;j<50000;j++){\n\t\t\tmx = max(mx,dp[n][j],ge);\n\t\t}\n\t\tif(mx.first==0){\n\t\t\tcout << 0 << \" \" << 0 << endl;\n\t\t}else{\n\t\t\tcout << mx.first << \" \" << mx.second << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\n#define IINF INT_MAX\nint n,p[110],dp[110][100010];\n\nint main() {\n  while( cin >> n, n ) {\n    rep(i,n) cin >> p[i];\n    int limit = (n * 999) + 1;\n    rep(i,n+1) rep(j,limit) dp[i][j] = IINF;\n    dp[0][0] = 0;\n    int maxi = -IINF, mini = IINF;\n    rep(i,n) {\n      for(int j=n;j>=0;--j) {\n\tfor(int k=min((i+1)*999+1,limit)-1;k>=0;--k) {\n\t  if( dp[j][k] == IINF ) continue;\n\t  int rem = ( 1000 - p[i] % 1000 ) + k;\n\t  if( p[i] % 1000 == 0 ) rem = k;\n\t  \n\t  if( rem >= 500 ) {\n\t    assert( rem - 500 >= 0 && rem - 500 < limit);\n\t    dp[j+1][rem-500] = min(dp[j+1][rem-500],\n\t\t\t\t\tdp[j][k]+p[i]);\n\t    if( maxi < j + 1 ) maxi = j + 1, mini = dp[j+1][rem-500];\n\t    else if( maxi == j + 1 ) mini = min(mini,dp[j+1][rem-500]);\n\t  } else {\n\t    assert( 0 <= rem && rem < limit );\n\t    dp[j][rem] = min(dp[j][rem],dp[j][k]+p[i]);\n\t  }\n\t  dp[j][k] = min(dp[j][k],dp[j][k]);\n\t}\n      }\n    }\n    if( maxi == -IINF ) maxi = mini = 0;\n    cout << maxi << \" \" << mini << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint dp[110][110][2010]={0};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\trep(i,110)rep(j,110)rep(k,2010)dp[i][j][k]=inf;\n\t\tdp[0][0][0]=0;\n\t\tvi a(n);\n\t\trep(i,n)cin>>a[i];\n\t\trep(i,n)rep(j,n)rep(k,2010)if(dp[i][j][k]!=inf){\n\t\t\tint I=i+1,J=j,K=k;\n\t\t\tdp[I][J][K]=min(dp[I][J][K],dp[i][j][k]);\n\t\t\tint t=1000-a[i]%1000;\n\t\t\tif(t==1000)t=0;\n\t\t\tif(a[i]%500<=K&&K&&(a[i]-1)%1000+1>500)dp[I][J+1][K-a[i]%500]=min(dp[I][J+1][K-a[i]%500],dp[i][j][k]+a[i]);\n\t\t\tif(t>=500){\n\t\t\t\tif(t<=K)dp[I][J+1][K-t]=min(dp[I][J+1][K-t],dp[i][j][k]+a[i]);\n\t\t\t\tif(K+t-500<2010)dp[I][J+1][K+t-500]=min(dp[I][J+1][K+t-500],dp[i][j][k]+a[i]);\n\t\t\t}else if(K+t<2010)dp[I][J][K+t]=min(dp[I][J][K+t],dp[i][j][k]+a[i]);\n\t\t}\n\t\tint out=0,ne=inf;\n\t\trep(i,n+1)rep(j,2010)if(out<=i&&dp[n][i][j]!=inf){\n\t\t\tif(out==i)ne=min(ne,dp[n][i][j]);\n\t\t\telse ne=dp[n][i][j];\n\t\t\tout=max(out,i);\n\t\t}\n\t\tcout<<out<<\" \"<<ne<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_MONEY = 500;\nint n;\nvector<int> p;\nvector<vector<pair<int, int>>> memo;\n\ninline void Change(pair<int, int> &a, pair<int, int> &b) {\n    if ((a.first < b.first) || (a.first == b.first && a.second > b.second))\n        a = b;\n}\n\npair<int, int> Solve(int idx, int money) {\n    if (idx == n)\n        return pair<int, int>(0, 0);\n\n    auto &opt = memo[idx][money];\n    if (opt.first != -1)\n        return opt;\n\n    // idx?????????????????§????????????\n    opt = Solve(idx + 1, money);\n\n    // idx?????????????????§??????\n    if (0 < (p[idx] % 1000) && (p[idx] % 1000) <= 500) {\n        // 1000????????§?????????\n        int res = 1000 - (p[idx] % 1000) - 500 + money;\n        auto tmp = Solve(idx + 1, res);\n        tmp.first += 1;\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n    else if (p[idx] % 1000 == 0) {\n        if (500 <= money) {\n            int res = money - 500;\n            auto tmp = Solve(idx + 1, res);\n            tmp.first += 1;\n            tmp.second += p[idx];\n            Change(opt, tmp);\n        }\n    }\n    else if (500 <= money + 1000 - (p[idx] % 1000)) {\n        // 1000????????¨?°????money??§?????????\n        int res = money + 1000 - (p[idx] % 1000) - 500;\n        auto tmp = Solve(idx + 1, res);\n        tmp.first += 1;\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n    else {\n        // 1000??????????????§?????????\n        int res = 1000 - (p[idx] % 1000) + money;\n        auto tmp = Solve(idx + 1, res);\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n\n    return opt;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n, n) {\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            cin >> p[i];\n\n        memo.clear();\n        memo.resize(n, vector<pair<int, int>>(5000 * n,\n                                              pair<int, int>(-1, 0)));\n\n        auto res = Solve(0, 0);\n        cout << res.first << ' ' << res.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// dp[i][j]: i番目の店までで100円以下の小銭の総額がjとなるような買い方の{500円玉の枚数,-購入金額}の最大値\n// 遷移は a)500円玉を得られるように買う b)1000円札のみで買って小銭を稼ぐ c)買わない\n// bでも500円玉を得られる場合がある\nint n, p[100];\npii dp[100][50050];\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\trep(i,n) cin >> p[i];\n\t\trept(i,n) rept(j,50000) dp[i][j] = {-1,0};\n\t\tdp[0][0] = {0,0};\n\t\trep(i,n) rept(j,50000) if (dp[i][j].fi!=-1) {\n\t\t\tint g = dp[i][j].fi, u = -dp[i][j].se;\n\t\t\t// 500円玉を得る\n\t\t\tif (j>=(p[i]+500)%1000) chmax(dp[i+1][j-(p[i]+500)%1000], mp(g+1, -(u+p[i])));\n\t\t\t// 1000円札のみ\n\t\t\tif (1<=p[i]%1000 && p[i]%1000<=500) chmax(dp[i+1][j+(500-p[i]%1000)], mp(g+1, -(u+p[i])));\n\t\t\tif (500<p[i]%1000) chmax(dp[i+1][j+(1000-p[i]%1000)], mp(g, -(u+p[i])));\n\t\t\t// 買わない\n\t\t\tchmax(dp[i+1][j], mp(g, -u));\n\t\t}\n\t\tpii res = {0,0};\n\t\trept(i,50000) chmax(res, dp[n][i]);\n\t\tcout << res.fi << ' ' << -res.se << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <Math.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\nusing namespace std;\n\nint ans_coin, ans_money;\nint const gohyaku = 0, hyaku = 1, goju = 2, ju = 3, go = 4, ichi = 5;\nint const val[6] = {500, 100, 50, 10, 5, 1};\nint n;\nvector<int> storeVal;\nint Tririri[6];\n\n// ?????£????????§?????¬??????\nvoid Turi(int oturi) {\n    //if(oturi > 999) return;\n    oturi %= 1000;\n    for(int i = 0; i < 6; i++) {\n        Tririri[i] = oturi / val[i];\n        oturi %= val[i];\n    }\n}\n\n// ??§????????????1000????????????????????????????????????????????????\nint NumCoin(int miyageVal, int use, int coinVal, int num) {\n    use -= 1000;\n    int i;\n    for(i = num ; i > 0; i--) {\n        //if((use + coinVal * i) - miyageVal < 1000)\n        if(miyageVal > use + coinVal * i) break;\n    }\n    return i;\n}\n\n// ????????£?????????\nvoid Store(int storeID, int *coinb, int pay) {\n    int coin[6];\n    for(int i=0;i<6;i++) {\n        coin[i] = coinb[i];\n    }\n    if(storeID >= n) {\n        //cout << \"AAAA\" << endl;\n        if(ans_coin == coin[0] && ans_money > pay) {\n            ans_money = pay;\n        }\n        \n        // ?±????\n        \n        return;\n    }\n    if(coin[0] + (n - storeID)  <  ans_coin){\n        //cout << storeID << \" \" << coin[0] << \" \" << ans_coin << endl;\n        if(ans_coin == coin[0] && ans_money > pay) {\n            ans_money = pay;\n        }\n        return;\n    }\n    \n    // ????????????????????????\n    Store(storeID+1, coin, pay);\n\n    // ??????????????????\n    int use = 1000 * ((storeVal[storeID] / 1000) + 1);\n\n    if(storeVal[storeID] % 1000 == 0) {\n        int size = 0;\n        for(int i = 0; i < 6; i++)\n            if(size += val[i] * coin[i] > 500) {\n                use += 500;\n                cout << use << endl;\n                break;\n            }\n    }\n    else {\n        for(int i = 1; i < 6; i++) {\n            use += NumCoin(storeVal[storeID], use, val[i], coin[i]) * val[i];\n        }\n    }\n    \n    Turi(use);\n    for(int i = 1; i < 6; i++) {\n        coin[i] -= Tririri[i];\n    }\n    \n    Turi(use - storeVal[storeID]);\n    for(int i = 0; i < 6; i++) {\n        coin[i] += Tririri[i];\n    }\n    \n    pay += storeVal[storeID];\n\n    \n    // 500????????´??°??????????????????\n    if(ans_coin < coin[0]) {\n        ans_coin = coin[0];\n        ans_money = pay;\n    }\n\n    \n\n    \n    Store(storeID+1, coin, pay);\n}\n\n\nint main() {\n\t\n\twhile(true) {\n        n = 0;\n        cin >> n;\n        if(n == 0) break;\n        \n        storeVal.clear();\n        for(int i = 0; i < n; i++) {\n            int a;\n            cin >> a;\n            storeVal.push_back(a);\n        }\n        ans_coin = 0;\n        ans_money = 10000000;\n        int coin[6] = {0};\n        \n        Store(0, coin, 0);\n        \n        cout << ans_coin << \" \" << ans_money << endl;\n    }\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\nusing namespace std;\nostream& operator<<(ostream &os, const pair<int,int> &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  const int CMAX = 50000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 49900... too much? to get 50, max = 25000\n    // value : (# 500 yen so far, minimum payment) \n    vector<pair<int,int>> dp(CMAX+1, pair<int,int>(BIG, BIG));\n    vector<pair<int,int>> dpnew(CMAX+1, pair<int,int>(BIG, BIG));\n    dpnew[0] = make_pair(0, 0);\n    int cmax = 0;\n    for(int i = 0; i < n; i++) {\n      // not buying\n      for(int j = 0; j <= cmax; j++) {\n        dp[j] = dpnew[j];\n      }\n      // buying\n      for(int j = 0; j <= cmax; j++) {\n        if(dp[j].first > 0) continue;\n        const int p = ps[i] % 1000;\n        if(p != 0 && p <= 500) { // got 500!\n          const int jj = min(j + 500 - p, CMAX);\n          cmax = min(max(cmax, jj), CMAX);\n          pair<int,int> dd(dp[j].first - 1, dp[j].second + ps[i]);\n          if(dd < dpnew[jj]) {\n            dpnew[jj] = dd;\n          }\n        } else {\n          // get 500 if possible!\n          const int q = (p == 0 ? 1000 : p) - 500;\n          if(j >= q) {\n            const int jj = j - q;\n            pair<int,int> dd(dp[j].first - 1, dp[j].second + ps[i]);\n            if(dd < dpnew[jj]) {\n              dpnew[jj] = dd;\n            }\n          } else { // get change\n            const int jj = (j + 1000 - p) % 1000;\n            cmax = min(max(cmax, jj), CMAX);\n            if( jj <= CMAX) {\n              pair<int,int> dd(dp[j].first, dp[j].second + ps[i]);\n              if(dd < dpnew[jj]) {\n                dpnew[jj] = dd;\n              }\n            }\n          }\n        }\n      }\n    }\n    pair<int,int> dd(BIG, BIG);\n    for(int j = 0; j <= cmax; j++) {\n      if(dpnew[j] < dd) {\n        dd = dpnew[j];\n      }\n    }\n    cout << -dd.first << \" \" << dd.second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<17;\n\nP dp[101][50501];\nP pmax(P p,P q){\n    if(p.fs>q.fs) return p;\n    else if(p.fs==q.fs) return (p.sc<q.sc?p:q);\n    else return q;\n}\n\n\nint main(){\n    int N;\n    while(cin >> N){\n        if(!N) return 0;\n        int p[N];\n        for(int i=0;i<N;i++){\n            cin >> p[i];\n        }\n        for(int i=0;i<=N;i++){\n            for(int j=0;j<50001;j++){\n                if(j==0) dp[i][j]=mp(0,0);\n                else dp[i][j]=mp(-1,INF);\n            }\n        }\n        for(int i=0;i<N;i++){\n            for(int j=0;j<50001;j++){\n                if(dp[i][j].fs==-1){\n                    continue;\n                }\n                P d=dp[i][j];\n                dp[i+1][j]=pmax(dp[i+1][j],d);\n                d.sc+=p[i];\n                int res=(1000-p[i]%1000)%1000;\n                dp[i+1][j+res]=pmax(dp[i+1][j+res],d);\n                if(res>=500){\n                    d.fs++;\n                    res-=500;\n                    dp[i+1][j+res]=pmax(dp[i+1][j+res],d);\n                }\n                else{\n                    d.fs++;\n                    res=500-res;\n                    if(res<=j) dp[i+1][j-res]=pmax(dp[i+1][j-res],d);\n                }\n            }\n        }\n        P ans=mp(0,LINF);\n        for(int i=0;i<=50000;i++){\n            ans=pmax(ans,dp[N][i]);\n        }\n        cout << ans.fs << \" \" << ans.sc << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nint p[111];\nint dp[101][50100];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    rep(i,n)cin>>p[i];\n    rep(j,101)rep(k,50100)dp[j][k]=INF;\n    dp[0][0]=0;\n    rep(i,n)for(int j=100;j>=0;j--)for(int k=50000;k>=0;k--){\n      if(dp[j][k]==INF)continue;\n      if(p[i]%1000>500&&k>=(p[i]%1000-500)){\n        minch(dp[j+1][k-(p[i]%1000-500)],dp[j][k]+p[i]);\n      }else if(p[i]%1000==0&&k>=500){\n        minch(dp[j+1][k-500],dp[j][k]+p[i]);\n      }\n      int rest=(1000000-p[i])%1000;\n      minch(dp[j+rest/500][rest%500+k],dp[j][k]+p[i]);\n    }\n    int resa=0,resb=INF;\n    rep(j,101)rep(k,50100){\n      if(dp[j][k]!=INF&&resa<j){\n        resa=j;\n        resb=dp[j][k];\n      }else if(resa==j)minch(resb,dp[j][k]);\n    }\n    printf(\"%d %d\\n\", resa,resb);\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nP dp[105][50005];\nint p[100];\nint main(){\n  int n;\n  while(cin>>n && n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++)cin>>p[i];\n    dp[0][0] = P(0,0);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<50000;j++){\n        if(dp[i][j]==P(-1,-1)) continue;\n        int nf=dp[i][j].first,ns=dp[i][j].second;\n        dp[i+1][j] = P(nf,ns);\n        if(p[i]%1000==0)\n          {if(j>=500) dp[i+1][j-500]=P(nf+1,ns-p[i]);}\n        else if(p[i]%1000<500) dp[i+1][j+500-p[i]%500]=P(nf+1,ns-p[i]);\n        else if(p[i]%500<=j) dp[i+1][j-p[i]%500] = P(nf+1,ns-p[i]);\n        else dp[i+1][j+1000-p[i]%1000] = P(nf,ns-p[i]); \n      }\n    }\n    P ans(0,0);\n    for(int i=0;i<50000;i++) ans=max(ans,dp[n][i]);\n    cout<<ans.first<<\" \"<<-ans.second<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint dp[128][128][1024];\nint n;\nint P[128];\n\nvoid init() {\n  for(int i = 0; i < 128; ++i) {\n    for(int j = 0; j < 128; ++j) {\n      for(int k = 0; k < 1024; ++k) {\n        dp[i][j][k] = -1;\n      }\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d\", &P[i]);\n    }\n    dp[0][0][0] = 0;\n    for(int i = 0; i < n; ++i) {\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < 1024; ++k) {\n          if( dp[i][j][k] == -1 ) continue;\n          // step 1\n          dp[i+1][j][k] = std::max(dp[i+1][j][k], dp[i][j][k]);\n          // step 2\n          int n1kyen = (P[i] + 999) / 1000;\n          int rem = dp[i][j][k] + n1kyen * 1000 - P[i];\n          int next_num500yen = j + (rem >= 500 ? 1 : 0);\n          int next_num1kyen  = k + n1kyen;\n          int next_rem       = rem >= 500 ? rem - 500 : rem;\n          int& next = dp[i+1][next_num500yen][next_num1kyen];\n          next = std::max(next, next_rem);\n        }\n      }\n    }    \n    int res = (1 << 28);\n    int max = -1;\n    for(int j = n; j >= 0; --j) {\n      for(int k = 0; k < 1024; ++k) {\n        if( dp[n][j][k] == -1 ) continue;\n        int cost = k * 1000 - 500 * j - dp[n][j][k];\n        res = std::min(res, cost);\n      }\n      if( res != (1 << 28) ) {\n        max = j;\n        break;\n      }\n    }\n    printf(\"%d %d\\n\", max, res);\n  }\n         \n        \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100000000\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n;\nint p[101];\nP dp[101][50001];\n\nP max_get(P a,P b){\n\tif(a.first>b.first){\n\t\treturn a;\n\t}\n\tif(a.first<b.first){\n\t\treturn b;\n\t}\n\treturn (a.second<=b.second)?a:b;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&p[i]);\n\t\t}\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=50000;j++){\n\t\t\t\tdp[i][j]=P(0,INF);\n\t\t\t}\n\t\t}\n\t\tdp[0][0]=P(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint need=(p[i]%1000)-500;\n\t\t\tif(need<0)need+=1000;\n\t\t\tint oturi=1000-(p[i]%1000);\n\t\t\tif(oturi==1000)oturi=0;\n\t\t\tfor(int j=0;j<=50000;j++){\n\t\t\t\tif(dp[i][j].second!=INF){\n\t\t\t\t\tdp[i+1][j]=max_get(dp[i+1][j],dp[i][j]);\n\t\t\t\t\tif(p[i]%1000<500 && ((p[i]%1000)!=0)){\n\t\t\t\t\t\tP np=dp[i][j];\n\t\t\t\t\t\tnp.first++;\n\t\t\t\t\t\tnp.second+=p[i];\n\t\t\t\t\t\tdp[i+1][j+oturi-500]=max_get(dp[i+1][j+oturi-500],np);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(j>=need){\n\t\t\t\t\t\t\tP np=dp[i][j];\n\t\t\t\t\t\t\tnp.first++;\n\t\t\t\t\t\t\tnp.second+=p[i];\n\t\t\t\t\t\t\tdp[i+1][j-need]=max_get(dp[i+1][j-need],np);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tP np=dp[i][j];\n\t\t\t\t\t\t\tnp.second+=p[i];\n\t\t\t\t\t\t\tdp[i+1][j+oturi]=max_get(dp[i+1][j+oturi],np);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r1=0,r2=0;\n\t\tfor(int i=0;i<=50000;i++){\n\t\t\tif(dp[n][i].second!=INF){\n\t\t\t\tif(r1==dp[n][i].first && r2>dp[n][i].second){\n\t\t\t\t\tr1=dp[n][i].first;\n\t\t\t\t\tr2=dp[n][i].second;\n\t\t\t\t}\n\t\t\t\tif(r1<dp[n][i].first){\n\t\t\t\t\tr1=dp[n][i].first;\n\t\t\t\t\tr2=dp[n][i].second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",r1,r2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int INF = (int)1e9 + 7;\n\nbool cmp(pair<int, int> a, pair<int, int> b) {\n    if (a.first != b.first) return a.first > b.first;\n    return a.second < b.second;\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<int> p(n);\n        for (int &pi: p) cin >> pi;\n        vector<pair<int, int>> cur(50001, {-INF, INF}), nxt(cur);\n        cur[0] = {0, 0};\n        int rest_ma = 0;\n        for (int pi: p) {\n            int mod = pi % 1000;\n            if (1 <= mod && mod <= 500) {\n                int rev = 1000 - mod - 500;\n                rest_ma += rev;\n                for (int rest = rest_ma; rest >= rev; rest--) {\n                    nxt[rest] = min(nxt[rest], {\n                        cur[rest - rev].first + 1, cur[rest - rev].second + pi\n                    }, cmp);\n                }\n            } else {\n                int rev = (1000 - mod) % 1000;\n                int need = (mod + 500) % 1000;\n                rest_ma += max(rev, need);\n                for (int rest = 0; rest <= rest_ma; rest++) {\n                    nxt[rest] = cur[rest];\n                }\n                for (int rest = rest_ma; rest >= rev; rest--) {\n                    nxt[rest] = min(nxt[rest], {\n                        cur[rest - rev].first, cur[rest - rev].second + pi\n                    }, cmp);\n                }\n                for (int rest = need; rest <= rest_ma; rest++) {\n                    nxt[rest - need] = min(nxt[rest - need], {\n                        cur[rest].first + 1, cur[rest].second + pi\n                    }, cmp);\n                }\n            }\n            swap(cur, nxt);\n        }\n        auto res_p = *min_element(cur.begin(), cur.end(), cmp);\n        cout << res_p.first << \" \" << res_p.second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nPi dp[2][100001];\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  while(cin >> n, n) {\n    vint p(n);\n    rep(i, n) cin >> p[i];\n    fill(dp[0], dp[2], Pi(inf, inf));\n    Pi* curr = dp[0];\n    Pi* next = dp[1];\n\n    curr[0] = Pi(0, 0);\n    rep(i, n) {\n      rep(j, 100001) next[j] = Pi(inf, inf);\n      rep(j, 100001) {\n\tchmin(next[j], curr[j]);\n\tPi d = curr[j];\n\tint q = p[i]%1000;\n\tint x = (1000-q)%1000;\n\tif(j+x >= 500) { // ????????????500?????\\???????????????????????°??????????????????????????????\n\t  if(j+x-500 <= 100000) {\n\t    d.first--;\n\t    d.second += p[i];\n\t    chmin(next[j+x-500], d);\n\t  }\n\t} else {\n\t  if(j+x <= 100000) {\n\t    d.second += p[i];\n\t    chmin(next[j+x], d);\n\t  }\n\t}\n      }\n      swap(curr, next);\n    }\n\n    Pi ans = Pi(inf, inf);\n    rep(i, 100001) chmin(ans, curr[i]);\n    cout << -ans.first << \" \" << ans.second << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\nll n, p, dp[101][50001], sum[101][50001];\n\nint main() {\n  while (scanf(\"%lld\", &n), n) {\n    for (ll j = 1; j <= n*500; j++) dp[0][j] = -10000, sum[0][j] = 100000000000LL;\n    for (ll i = 1; i <= n; i++) {\n      scanf(\"%lld\", &p);\n      ll temp = (1000 - p % 1000);\n      if (temp == 1000) temp = 0;\n      if (temp >= 500) {\n        for (ll j = 0; j < temp-500; j++) dp[i][j] = -10000, sum[i][j] = 100000000000LL;\n        for (ll j = temp-500; j <= n*500; j++) {\n          dp[i][j] = dp[i-1][j-(temp-500)]+1, sum[i][j] = sum[i-1][j-(temp-500)] + p;\n        }\n      } else {\n        for (ll j = 0; j <= n*500; j++) {\n          dp[i][j] = dp[i-1][j], sum[i][j] = sum[i-1][j];\n        }\n        for (ll j = temp; j <= n*500; j++) {\n          if (dp[i][j] < dp[i-1][j-temp]) {\n            dp[i][j] = dp[i-1][j-temp];\n            sum[i][j] = sum[i-1][j-temp] + p;\n          } else if (dp[i][j] == dp[i-1][j-temp]) {\n            sum[i][j] = min(sum[i][j], sum[i-1][j-temp] + p);\n          }\n        }\n        for (ll j = 0; j <= n*500+temp-500; j++) {\n          if (dp[i][j] < dp[i-1][j-temp+500]+1) {\n            dp[i][j] = dp[i-1][j-temp+500]+1;\n            sum[i][j] = sum[i-1][j-temp+500] + p;\n          } else if (dp[i][j] == dp[i-1][j-temp]+1) {\n            sum[i][j] = min(sum[i][j], sum[i-1][j-temp+500] + p);\n          }\n        }\n      }\n    }\n    ll ans1 = 0, ans2 = 100000000000LL;\n    for (ll j = 0; j <= n*500; j++) {\n      if (ans1 < dp[n][j]) {\n        ans1 = dp[n][j];\n        ans2 = sum[n][j];\n      } else if (ans1 == dp[n][j]) {\n        ans2 = min(ans2, sum[n][j]);\n      }\n    }\n    printf(\"%lld %lld\\n\", ans1, ans2);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\n#define chmax(a, b) a = max(a, b)\n//#define chmin(a, b) a = min(a, b)\n#define chmin(a, b, c) a = min(a, b, c)\n#define inf (int)(1e9+7)\n#define mod (ll)(1e9+7)\n#define eb emplace_back\n\n/*\n dp[i番目の店][お釣り] = {500円玉の数、払った金額}\n 500円玉の数 -> 大きくしたい\n 払った金額 -> 小さくしたい\n そういう比較関数作る\n \n 1. i番目の店では買わない\n chmin(dp[i + 1][j], dp[i][j], comp);\n \n 2. i番目の店で買う\n \n 2-1. 1000円の倍数払って500円もらえる\n i番目の店の商品の金額piを1000で割った余りqi\n 1 <= qi <= 500\n 1000円の倍数払って500円もらえる\n 1001 -> 2000払う\n \n このとき小銭払わなくていいことをいう\n 商品の値段250円とする\n 小銭120円持ってる\n 1120円払う\n 1120 - 250 = 870円帰ってくる\n 870 = 500 + 250 + 120\n 結局払った小銭返ってくる\n \n 2-2. 小銭払って500円もらえるか\n pi = 750\n 小銭250円いる\n \n\n \n \n */\nbool comp(pii a, pii b) {\n    if (a.first != b.first) return a.first > b.first;\n    return a.second < b.second;\n}\npii dp[107][501 * 101];\n//各お店500未満のお釣り\nvoid out(int a, int b) {cout << dp[a][b].first << \" \" << dp[a][b].second << endl;}\nint main() {\n    int n;\n    while (cin >> n && n) {\n        int pi[n]; rep(i, n) cin >> pi[i];\n        rep(i, 107) rep(j, 501 * 101) dp[i][j] = {-1, inf}; //-1 for ただ小銭もらうとき\n        dp[0][0] = {0, 0};\n        rep(i, n) {\n            rep(j, 501 * 101) {\n                if (dp[i][j].second == inf) continue;\n                //not buy\n                chmin(dp[i + 1][j], dp[i][j], comp);\n                //1000円の倍数払って500円もらえるか\n                int qi = pi[i] % 1000;\n                int df = dp[i][j].first;\n                int ds = dp[i][j].second;\n                pii tmp = {df + 1, ds + pi[i]};\n                if (1 <= qi && qi <= 500) chmin(dp[i + 1][j + (1000 - 500 - qi)], tmp, comp);\n                //小銭使って500円もらえるか\n                tmp = {df + 1, ds + pi[i]};\n                int need = (pi[i] + 500) % 1000;\n                if (need <= j) chmin(dp[i + 1][j - need], tmp, comp);\n                //ただ小銭もらう\n                tmp = {df, ds + pi[i]};\n                chmin(dp[i + 1][j + (1000 - pi[i]%1000) % 1000], tmp, comp);\n            }\n        }\n        pii ans = {0, inf};\n        rep(j, 501 * 101) {\n            chmin(ans, dp[n][j], comp);\n        }\n        cout << ans.first << \" \" << ans.second << endl;\n        \n    }\n}\n\n/*\n corner case\n 1\n 1000\n */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e8;\n\nconst int MX = 50010;\nint dp[2][128][MX];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N, N){\n\tVI ps(N);\n\tREP(i,N) cin >> ps[i];\n\n\tfill((int*)dp, (int*)dp+2*128*MX, INF);\n\tint crt = 0, nxt = 1;\n\tdp[crt][0][0] = 0;\n\tREP(i,N){\n\t  REP(c,128) REP(x,MX)\n\t\tdp[nxt][c][x] = dp[crt][c][x];\n\n\t  int p = ps[i] % 1000;\n\t  int p_ = ps[i] % 500;\n\n\t  if(p == 0){\n\t\tfor(int c=0;c<=N;++c){\n\t\t  for(int x=500;x<MX;++x){\n\t\t\tmini(dp[nxt][c+1][x-500], dp[crt][c][x] + ps[i]);\n\t\t  }\n\t\t}\n\t  }\n\t  else if(p <= 500){\n\t\tfor(int c=0;c<=N;++c){\n\t\t  for(int x=0;x+500-p_<MX;++x){\n\t\t\tmini(dp[nxt][c+1][x+500-p_], dp[crt][c][x] + ps[i]);\n\t\t  }\n\t\t}\n\t  }\n\t  else{\n\t\tfor(int c=0;c<=N;++c){\n\t\t  for(int x=0;x+500-p_ < MX;++x)\n\t\t\tmini(dp[nxt][c][x+500-p_], dp[crt][c][x] + ps[i]);\n\t\t  for(int x=p_;x<MX;++x)\n\t\t\tmini(dp[nxt][c+1][x-p_], dp[crt][c][x] + ps[i]);\n\t\t}\n\t  }\n\t  swap(crt, nxt);\n\t}\n\n\tPII ans(0,-0);\n\tREP(c,128) REP(x,1024){\n\t  if(dp[crt][c][x] < INF)\n\t\tmaxi(ans, MP(c, -dp[crt][c][x]));\n\t}\n\tcout << ans.FF << \" \" << -ans.SS << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <climits>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RFOR(i,a,b) for (int i=(a)-1;i>=(b);i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nusing namespace std;\n\nconst int MAXN = 500003;\n\npair<int,int> maxa(pair<int,int> a, int f,int s,pair<int,int> b){\n\tif(f)a.first++;\n\ta.second+=s;\n\tif(a.first > b.first)return a;\n\telse if(a.first == b.first){\n\t\tif(a.second < b.second)return a;\n\t\telse return b;\n\t}else return b;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<int> p(n);\n\t\tREP(i,n)cin>>p[i];\n\t\tpair<int,int> dp[2][MAXN + 503];\n\t\tfill(dp[0],dp[2],make_pair(0,INF));// num of 500 and imamade ni tukatta okane\n\t\tdp[1][0] = make_pair(0,0);\n\t\tREP(i,n){\n\t\t\tfill(dp[i&1],dp[i&1] + MAXN,make_pair(0,INF));// num of 500 and imamade ni tukatta okane\n\t\t\tfor(int j = MAXN;j >= 0;j--){\n\t\t\t\tif(p[i] % 1000 <= 500 && p[i] % 1000 > 0 && (dp[(i+1)&1][j].second != INF || j==0) ){\n\t\t\t\t\tdp[i&1][j + (5000-p[i])%500] = maxa(dp[(i+1)&1][j],1,p[i],dp[i&1][j + (5000-p[i])%500]);\n\t\t\t\t\t//toriaezu 1000(+500)\n\t\t\t\t}else{\n\t\t\t\t\tif(p[i] %1000 > 0 &&  dp[(i+1)&1][j + p[i]%500].second != INF){\n\t\t\t\t\t\tdp[i&1][j] = maxa(dp[(i+1)&1][j + p[i]%500],1,p[i],dp[i&1][j]);\n\t\t\t\t\t}//1000n + iikanjino\n\t\t\t\t\tif(p[i] %1000 == 0 &&  dp[(i+1)&1][j + 500].second != INF){\n\t\t\t\t\t\tdp[i&1][j] = maxa(dp[(i+1)&1][j + 500],1,p[i],dp[i&1][j]);\n\t\t\t\t\t}// 1000n + 500\n\t\t\t\t\tif(dp[(i+1)&1][j].second != INF || j==0)//toriaezu 1000(not +500)\n\t\t\t\t\t\tdp[i&1][j + (5000-p[i])%500] = maxa(dp[(i+1)&1][j],0,p[i],dp[i&1][j + (5000-p[i])%500]);\n\t\t\t\t}\n\t\t\t\tdp[i&1][j] = maxa(dp[i&1][j],0,0,dp[(i+1)&1][j]);\n\t\t\t}\n\t\t}\n\t\tpair<int,int> ans = make_pair(0,0);\n\t\tfor(int j = MAXN + 500;j >= 0;j--){\n\t\t\tans = maxa(dp[(n-1)&1][j],0,0,ans);\n\t\t}\n\t\tcout << ans.first << ' ' << ans.second << endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPEQ(i, n) FOREQ(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n\ntemplate <typename T> inline int size(const T& x) { return x.size(); }\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int n;\n    while (cin >> n, n) {\n\n        vector<int> prices(n);\n        REP(i, n) cin >> prices[i];\n\n        vector<pair<int, int>> dp[2];\n        REP(i, 2) dp[i].resize(1000);\n\n        dp[0][0] = make_pair(0, 0);\n        FOR(i, 1, 1000) dp[0][i] = make_pair(-10000000, 0);\n\n        REP(i, n) {\n            int curr = i % 2;\n            int next = (i+1) % 2;\n\n            REP(coin, 1000) {\n                dp[next][coin] = make_pair(-10000000, 0);\n            }\n\n            REP(coin, 1000) {\n                auto c = dp[curr][coin];\n\n                // ??????????????´???\n                dp[next][coin] = max(dp[next][coin], c);\n\n                // ????????´???\n                int change = (1000 - prices[i]%1000) % 1000;\n                int next_coin = coin + change;\n                if (next_coin < 500) {\n                    dp[next][next_coin] = max(dp[next][next_coin], make_pair(c.first, c.second-prices[i]));\n                } else {\n                    next_coin = (next_coin - 500) % 1000;\n                    dp[next][next_coin] = max(dp[next][next_coin], make_pair(c.first+1, c.second-prices[i]));\n                }\n            }\n        }\n\n        auto ans = make_pair(-10000000, 0);\n        REP(coin, 500) ans = max(ans, dp[n%2][coin]);\n\n        cout << ans.first << ' ' << -ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint dp[128][128][1024];\nint n;\nint P[128];\n\nvoid init() {\n  for(int i = 0; i < 128; ++i) {\n    for(int j = 0; j < 128; ++j) {\n      for(int k = 0; k < 1024; ++k) {\n        dp[i][j][k] = -1;\n      }\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d\", &P[i]);\n    }\n    dp[0][0][0] = 0;\n    for(int i = 0; i < n; ++i) {\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < 1024; ++k) {\n          if( dp[i][j][k] == -1 ) continue;\n          dp[i+1][j][k] = std::max(dp[i+1][j][k], dp[i][j][k]);\n          // 1000\n          int count_1000_2 = (P[i] + 999) / 1000;\n          int rem0 = count_1000_2 * 1000 - P[i];\n          int& next0 = dp[i+1][j + (rem0%1000>=500 ? 1 : 0)][k + count_1000_2];\n          next0 = std::max(next0, dp[i][j][k] + (rem0%1000>=500 ? rem0 - 500 : rem0));\n          //\n          int count_1000 = (P[i] + 999) / 1000;\n          int rem1 = dp[i][j][k] + count_1000 * 1000 - P[i];\n          int& next = dp[i+1][j + (rem1%1000>=500 ? 1 : 0)][k + count_1000];\n          next = std::max(next, rem1%1000>=500 ? rem1 - 500 : rem1);\n          // rem\n          if( dp[i][j][k] > P[i] ) {\n            int rem2 = dp[i][j][k] - P[i];\n            int& next = dp[i+1][j + (rem2%1000>=500 ? 1 : 0)][k];\n            next = std::max(next, (rem2%1000>=500 ? rem2 - 500 : rem2));\n          }\n        }\n      }\n    }\n    // for(int i = 0; i <= 4; ++i) {\n    //   for(int j = 0; j <= 4; ++j) {\n    //     for(int k = 0; k < 6; ++k) {\n    //       printf(\"(i, j, k) = (%d, %d, %d) : %d\\n\", i, j, k, dp[i][j][k]);\n    //     }\n    //   }\n    // }\n    int res = (1 << 28);\n    int max = -1;\n    for(int j = n; j >= 0; --j) {\n      for(int k = 0; k < 1024; ++k) {\n        if( dp[n][j][k] == -1 ) continue;\n        int cost = k * 1000 - 500 * j - dp[n][j][k];\n        res = std::min(res, cost);\n      }\n      if( res != (1 << 28) ) {\n        max = j;\n        break;\n      }\n    }\n    printf(\"%d %d\\n\", max, res);\n  }\n         \n        \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> ans_t;\n\nans_t dp[105][50005];\nint N;\nint shops[105];\n\nconst ans_t& chmax(const ans_t& src,ans_t& target){\n    if (src.first>target.first||(src.first==target.first&&src.second<target.second))\n        return target=src;\n    else \n        return target;\n}\n\nint main(){\n\n    while(scanf(\"%d\",&N)&&N){\n        for(int i=1;i<=N;i++) scanf(\"%d\",shops+i);\n\n        for(int i=0;i<=N;i++)\n            for(int change=0;change<=50003;change++) \n                dp[i][change]=ans_t(-1,0);\n\n        dp[0][0]=ans_t(0,0);\n\n        ans_t ans(0,0);\n\n        for(int i=0;i<N;i++){\n            for(int change=0;change<=50000;change++){\n                const auto &cost=dp[i][change];\n                if (cost.first==-1) continue;\n\n                chmax(cost,dp[i+1][change]);\n                chmax(dp[i+1][change],ans);\n\n                auto cur_price=shops[i+1];\n\n                auto remain=(1000-cur_price%1000)%1000;\n                auto new_change=remain%500,new_500=remain/500;\n                chmax(ans_t(cost.first+new_500,cost.second+cur_price),\n                    dp[i+1][min(change+new_change,50000)]);\n                chmax(dp[i+1][min(change+new_change,50000)],ans);\n\n                remain=(cur_price+500)%1000;\n                if (change>=remain){\n                    chmax(ans_t(cost.first+1,cost.second+cur_price),\n                        dp[i+1][change-remain]\n                    );\n                    chmax(dp[i+1][change-remain],ans);\n                }\n\n            }\n            // printf(\"%d %d\\n\",ans.first,ans.second);\n        }\n\n        printf(\"%d %d\\n\",ans.first,ans.second);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nvoid change( int kingaku, int a[] )\n{\n\ta[0] = kingaku / 1000;\n\tkingaku -= a[0] * 1000;\n\ta[1] = kingaku / 500;\n\tkingaku -= a[1] * 500;\n\ta[2] = kingaku;\n}\n\nint main(void)\n{\n\twhile ( true ) {\n\t\tint n;\n\t\tstd::cin >> n;\n\t\tif ( n == 0 ) break;\n\n\t\tstd::vector<int> omiyage(n);\n\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tstd::cin >> omiyage[i];\n\t\t}\n\n\t\tconst int NC = 5000;\n\t\tint now = 0;\n\t\tstatic int kingaku[2][NC];\n\t\tstatic unsigned char m[2][NC];\n\t\tfor ( int j = 0; j < NC; ++j ) {\n\t\t\tm[1-now][j] = 0;\n\t\t\tkingaku[1-now][j] = 0;\n\t\t}\n\n\t\tfor ( int i = 1; i <= n; ++i ) {\n\t\t\tfor ( int j = 0; j < NC; ++j ) {\n\t\t\t\tint a[3];\n\t\t\t\tm[now][j] = m[1-now][j];\n\t\t\t\tkingaku[now][j] = kingaku[1-now][j];\n\t\t\t\tfor ( int v = j%100 - 100; v <= j; v += 100 ) {\n\t\t\t\t\tint u = v;\n\t\t\t\t\tif ( u < 0 ) u = 0;\n\t\t\t\t\tint l = ((omiyage[n-i] - u) + 999) / 1000;\n\t\t\t\t\tif ( l < 0 ) continue;\n\t\t\t\t\tchange( l * 1000 + u - omiyage[n-i], a);\n\t\t\t\t\tif ( a[2] + j - u >= NC ) continue;\n\t\t\t\t\tif ( m[now][j] == a[1] + m[1-now][a[2] + j - u] && kingaku[now][j] > omiyage[n-i] + kingaku[1-now][a[2] + j - u] ) {\n\t\t\t\t\t\tm[now][j] = a[1] + m[1-now][a[2] + j - u];\n\t\t\t\t\t\tkingaku[now][j] = omiyage[n-i] + kingaku[1-now][a[2] + j - u];\n\t\t\t\t\t} else if ( m[now][j] < a[1] + m[1-now][a[2] + j - u]) {\n\t\t\t\t\t\tm[now][j] = a[1] + m[1-now][a[2] + j - u];\n\t\t\t\t\t\tkingaku[now][j] = omiyage[n-i] + kingaku[1-now][a[2] + j - u];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow = 1 - now;\n\t\t}\n\t\tnow = 1 - now;\n\t\tstd::cout << (int)m[now][0] << \" \" << kingaku[now][0] << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\ntypedef long long ll;\nusing namespace std;\n\npair<int,int> dp[2][200001];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n;\n\twhile(cin>>n,n){\n\t\tint a[201];\n\t\tfill(a,a+201,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a[i];\n\t\t}\n\t\tfor(int i=0;i<=200000;i++)dp[0][i]=make_pair(-1,0);\n\t\tdp[0][0]=make_pair(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<=200000;j++)dp[(i+1)&1][j]=make_pair(-1,0);\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tif(dp[i&1][j].fi==-1)continue;\n\t\t\t\tdp[(i+1)&1][j]=make_pair(dp[i&1][j].fi,dp[i&1][j].se);\n\t\t\t\tint tmp=a[i]%1000;\n\t\t\t\tif(tmp<=500 && tmp>=1){\n\t\t\t\t\tif(dp[(i+1)&1][j+500-tmp]<make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i])){\n\t\t\t\t\t\tdp[(i+1)&1][j+500-tmp]=make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i]);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tint pay=(tmp+500)%1000;\n\t\t\t\t\tif(pay<=j){\n\t\t\t\t\t\tif(dp[(i+1)&1][j-pay]<make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i])){\n\t\t\t\t\t\t\tdp[(i+1)&1][j-pay]=make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint pay2=(1000-tmp)%1000;\n\t\t\t\t\tif(dp[(i+1)&1][j+pay2]<make_pair(dp[i&1][j].fi,dp[i&1][j].se-a[i])){\n\t\t\t\t\t\tdp[(i+1)&1][j+pay2]=make_pair(dp[i&1][j].fi,dp[i&1][j].se-a[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int,int> ans=make_pair(0,0);\n\t\tfor(int i=0;i<=200000;i++){\n\t\t\tif(dp[n&1][i]>ans){\n\t\t\t\tans=make_pair(dp[n&1][i].fi,dp[n&1][i].se);\n\t\t\t}\n\t\t}\n\t\tcout<<ans.fi<<\" \"<<-ans.se<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e8;\n\nconst int MX = 500*100+10;\nPII dp[2][MX];\n\nint main(){\n  int N;\n  while(scanf(\"%d\",&N), N){\n\tVI ps(N);\n\tREP(i,N) scanf(\"%d\", &ps[i]);\n\n\tfill((PII*)dp, (PII*)dp+2*MX, MP(0,-INF));\n\tint crt = 0, nxt = 1;\n\tdp[crt][0] = MP(0, -0);\n\tREP(i,N){\n\t  REP(x,MX)\n\t\tdp[nxt][x] = dp[crt][x];\n\n\t  int p = ps[i] % 1000;\n\t  if(p == 0){\n\t\tfor(int x=500;x<MX;++x){\n\t\t  PII tmp = dp[crt][x];\n\t\t  if(tmp.SS <= -INF) continue;\n\t\t  tmp.FF++;\n\t\t  tmp.SS -= ps[i];\n\t\t  maxi(dp[nxt][x-500], tmp);\n\t\t}\n\t  }\n\t  else if(p <= 500){\n\t\tfor(int x=0;x<MX;++x){\n\t\t  PII tmp = dp[crt][x];\n\t\t  if(tmp.SS <= -INF) continue;\n\t\t  tmp.FF++;\n\t\t  tmp.SS -= ps[i];\n\t\t  maxi(dp[nxt][x+500-p], tmp);\n\t\t}\n\t  }\n\t  else{\n\t\tint p_ = p - 500;\n\t\tfor(int x=0;x<MX;++x){\n\t\t  if(x >= p_){\n\t\t\tPII tmp = dp[crt][x];\n\t\t\tif(tmp.SS > -INF){\n\t\t\t  tmp.FF++;\n\t\t\t  tmp.SS -= ps[i];\n\t\t\t  maxi(dp[nxt][x-p_], tmp);\n\t\t\t}\n\t\t  }\n\t\t  PII tmp = dp[crt][x];\n\t\t  if(tmp.SS <= -INF) continue;\n\t\t  tmp.SS -= ps[i];\n\t\t  maxi(dp[nxt][x+1000-p], tmp);\n\t\t}\n\t  }\n\t  swap(crt, nxt);\n\t}\n\n\tPII ans(0,-0);\n\tREP(x,MX){\n\t  maxi(ans, dp[crt][x]);\n\t}\n\tprintf(\"%d %d\\n\", ans.FF, -ans.SS);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\npair<int,int> dp[101][50501];\n\nbool ge(pair<int,int>p1,pair<int,int>p2){\n\tif(p1.first > p2.first)return 0;\n\tif(p1.first < p2.first)return 1;\n\tif(p1.second < p2.second)return 0;\n\treturn 1;\n}\n\n\nint main(){\n\tint n;\n\tint x;\n\tpair<int,int> p1,p2;\t\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int j=0;j<50001;j++){\n\t\t\t\tdp[i][j]=make_pair(0,0);\n\t\t\t}\n\t\t}\n\t\tvector<int> v(n+1,0);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tx = (v[i]-1)%1000+1;\n\t\t\tif(x<=500){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<50000;j++){\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tdp[i][j+500-x] = make_pair(1,v[i]);\n\t\t\t\t\t\tdp[i][j+500-x] = max(dp[i][j+500-x],dp[i-1][j+500-x],ge);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(dp[i-1][j]!=make_pair(0,0)){\n\t\t\t\t\t\t\tdp[i][j+500-x] = dp[i-1][j];\n\t\t\t\t\t\t\tdp[i][j+500-x].first +=1;\n\t\t\t\t\t\t\tdp[i][j+500-x].second +=v[i];\n\t\t\t\t\t\t\tdp[i][j+500-x] = max(dp[i][j+500-x],dp[i-1][j+500-x],ge);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i][j+500-x] = dp[i-1][j+x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<50000;j++){\n\t\t\t\t\tp1 = make_pair(0,0);\n\t\t\t\t\tp2 = make_pair(0,0);\n\t\t\t\t\tif(j-(1000-x)>=0){\n\t\t\t\t\t\tif(dp[i-1][j-(1000-x)]!=make_pair(0,0)){\n\t\t\t\t\t\t\tp1 = dp[i-1][j-(1000-x)];\n\t\t\t\t\t\t\tp1.second += v[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i-1][j+x-500]!=make_pair(0,0)){\n\t\t\t\t\t\tp2 = dp[i-1][j+x-500];\n\t\t\t\t\t\tp2.first +=1;\n\t\t\t\t\t\tp2.second +=v[i];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\tif(j-(1000-x)==0){\n\t\t\t\t\t\tif(dp[i-1][j]==make_pair(0,0)){\n\t\t\t\t\t\t\tdp[i][j]=make_pair(0,v[i]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i][j]=max(dp[i-1][j],make_pair(0,v[i]),ge);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p1!=make_pair(0,0)){\n\t\t\t\t\t\tdp[i][j] = max(dp[i][j],p1,ge);\n\t\t\t\t\t}\n\t\t\t\t\tif(p2!=make_pair(0,0)){\n\t\t\t\t\t\tdp[i][j] = max(dp[i][j],p2,ge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int,int> mx = make_pair(0,0);\n\t\tfor(int j=0;j<50000;j++){\n\t\t\tmx = max(mx,dp[n][j],ge);\n\t\t}\n\t\tcout << mx.first << \" \" << mx.second << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define M 100000\n\nint dp[2][101][M];\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int p[100],pp[100];\n    for(int i=0;i<n;i++)cin>>p[i],pp[i]=(1000-p[i]%1000)%1000;\n\n    for(int i=0;i<2;i++)\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<M;k++)dp[i][j][k]=1e9;\n    \n    dp[0][0][0]=0;\n\n    for(int i=0;i<n;i++){\n      int ni=(i+1)%2,I=i%2;\n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<M*(i+1)/n;k++)dp[ni][j][k]=1e9;\n      \n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<M*(i+1)/n;k++){\n\t  int np=k+pp[i];\n\t  int nj=j;\n\t  if(np>=500)nj++,np-=500;\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t  dp[ni][j][k]=min(dp[ni][j][k],dp[I][j][k]);\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t}\n    }\n    \n    int c=0,s=0;\n    for(int i=1;i<=n;i++)\n      for(int j=0;j<M;j++)\n\tif(dp[n%2][i][j]!=1e9&&i>=c){\n\t  if(c==i&&dp[n%2][i][j]<s)s=dp[n%2][i][j];\n\t  else if(c<i)c=i,s=dp[n%2][i][j];\n\t}\n    cout<<c<<\" \"<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<int> p(n);\n        for(int i=0;i<n;i++) cin>>p[i];\n        const int INF=1e8;\n        vector<vector<pair<int,int>>> dp(n+1,vector<pair<int,int>>(499*n+1,make_pair(-INF,INF)));\n        dp[0][0]=make_pair(0,0);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<499*n+1;j++){\n                //distribute dp[i][j]\n                \n                if(p[i]>500&&(p[i]+500)%1000<=j){\n                    pair<int,int> x=make_pair(dp[i][j].first+1,dp[i][j].second-p[i]);\n                    dp[i+1][j-(p[i]+500)%1000]=max(dp[i+1][j-(p[i]+500)%1000],x);\n                }\n                else if(p[i]!=0 && p[i]%1000<=500){\n                    int to=j+1000-(p[i]%1000)-500;\n                    if(to<dp[i].size()) dp[i+1][to]=max(dp[i+1][to],make_pair(dp[i][j].first+1,dp[i][j].second-p[i]));\n                }\n                int to=(1000-p[i]%1000)*(p[i]%1000!=0)+j;\n                if(to<dp[i+1].size()){\n                    pair<int,int> x=make_pair(dp[i][j].first,dp[i][j].second-p[i]);\n                    dp[i+1][to]=max(dp[i+1][to],x);\n                }\n                dp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n            }\n            \n        }\n\n        pair<int,int> res=make_pair(-INF,INF);\n        for(int i=0;i<dp[n].size();i++){\n            res=max(res,dp[n][i]);\n        }\n        cout<<res.first<<\" \"<<-res.second<<endl;\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * D.cpp\n *\n *  Created on: 2017/07/01\n *      Author: LitMc\n */\n\n#define MYDEBUG\n#include <bits/stdc++.h>\n\n#ifdef MYDEBUG\n#define dbp(x) cout<<#x<<\": \"<<x<<endl\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define dbp4(w,x,y,z) cout<<#w<<\",\"<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<w<<\",\"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define ifcin(x) std::ifstream cin(x)\n#else\n#define dbp(x)\n#define dbp2(x,y)\n#define dbp3(x,y,z)\n#define dbp4(w,x,y,z)\n#define ifcin(x)\n#endif\n#define ll long long\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define rep(i, from, to) for(int i=from; i<to; ++i)\n#define REP(i, from, to) for(int i=from; i<=to; ++i)\n#define EPS = 1e-14;\nusing std::vector;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::max;\nusing std::min;\nusing std::swap;\nusing std::string;\nusing std::fill;\nusing std::pair;\nusing std::sort;\nusing std::reverse;\nusing std::pair;\nusing std::greater;\nusing std::priority_queue;\nusing std::ostream;\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n  for (size_t i = 0; i < v.size(); ++i) {\n    out << v[i] << endl;\n  }\n  return out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n  out << \"[\";\n  size_t last = v.size() - 1;\n  for (size_t i = 0; i < v.size(); ++i) {\n    out << v[i];\n    if (i != last) {\n      out << \",\";\n    }\n  }\n  out << \"]\";\n  return out;\n}\ntypedef pair<int, int> P;\nbool cmp(const P &p1, const P &p2) {\n  if (p1.first == p2.first) {\n    return p1.second > p2.second;\n  } else {\n    return p1.first < p2.first;\n  }\n}\nstatic const int MAX_N = 102;\nstatic const int MAX_E = 1000 * MAX_N; //10^5\nint n;\nint p[MAX_N];\nP dp[MAX_N][MAX_E];\n//P ch[MAX_N][MAX_E]; //??????????????¨\n//dp[i][k]: k????°?????????????????????¶?????§???i????????\\????????????????????£?????????????????????????????§???\n//dp[1][0]: ?¬??????????\n//dp[n+1][*]: ?????????(0???, 0???)\n\nvoid init() {\n  rep(i,0,MAX_N)\n  {\n    p[i] = 0;\n    rep(j,0,MAX_E)\n    {\n      dp[i][j] = P(0, 0);\n    }\n  }\n}\n\n//ex: 900\n//p: 400\n//1900?????????\n//1000 = (400+1000-1)/1000\n//900: ex\n//1900 - 400 = 1500\n//%1000????????¨500, 1???get\n//??????\n//base: (p + 1000 - 1) / 1000 : 1000???????????§??????????????????\n//?????????????????£????????¨?????????: ex\n//????????????: base + ex\n//????????????: ret = (base+ex) - p\n//????????????500??????????????°: ret%1000\n//?????????????????????: p\n//500????????????????????????????????£???: ret - ((ret%1000) / 500) * 500\n//100?????????????????????, ?°????700???\n//1000 + 700 - 100 = 1600\n//1600%1000 = 600\n//600/500 = 1\n//?????£???: 1600 - 1*500 = 1100\n//1700????????£???+1100???(600???????????????)\n//????±???????????????£????????????p???????????????????????????????????£????????????????????£?????????\n\n//??????price??????1000???????????§???????????????????????????\nint only1000(int &price) {\n  return ((price + 1000 - 1) / 1000) * 1000;\n}\n\nvoid doDP() {\n  rep(k,0,MAX_E)\n  {\n    dp[n + 1][k] = P(0, 0);\n  }\n  for (int i = n; i >= 1; --i) {\n    int base = only1000(p[i]);\n    int pay, ret, get; //get: 500??????????????????????????°(0???1)\n    rep(ex,0, MAX_E)\n    {\n      P nobuy, buy1000, try500; //???????????§??????????????¢????????§??????3???(????????????, ?°??????????, 500????????????)w\n      //????????????\n      nobuy = dp[i + 1][ex];\n      //??????\n      //    ?°?????????£???????????????\n      pay = base;\n      ret = pay - p[i];\n      get = ret / 500;\n      ret -= get * 500;      //500??????????????????????????????????¶??????????\n      buy1000 = dp[i + 1][ret + ex];      //?°?????????????????????£????????§???????¶????\n      buy1000.first += get;\n      buy1000.second += p[i];\n//      int ret1000 = ret;\n      //    500?????????????????????\n      int usedEx = 0;\n      pay = base;\n      ret = pay - p[i];\n      if (ret >= 500) {      //500??????????°?????????¢???????????????\n        usedEx = 0;\n        get = ret / 500;\n        ret -= get * 500;\n      } else if (ret + ex >= 500) {      //?°???????????????°500?????????????????§??????\n        usedEx = 500 - ret;\n        pay += usedEx;\n        ret = pay - p[i];      //??????500??????????????????\n        get = ret / 500;\n        ret -= get * 500;\n      } else {\n        //1000???????????§?????£???????°????????????£??????500??????????????§?????????\n        usedEx = 0;\n      }\n      try500 = dp[i + 1][ret + ex - usedEx];\n      try500.first += get;\n      try500.second += p[i];\n      P best = max(buy1000, try500, cmp);\n      best = max(best, nobuy, cmp);\n//      if (best == nobuy) {\n//        ch[i][ex] = P(i + 1, ex);\n//      } else if (best == buy1000) {\n//        ch[i][ex] = P(i + 1, ret1000);\n//      } else if (best == try500) {\n//        ch[i][ex] = P(i + 1, ret);\n//      }\n      dp[i][ex] = best;\n    }\n  }\n}\n\n//void trace() {      //????????????\n//  int i = 1;\n//  int ex = 0;\n//  REP(t,1,4)\n//  {\n//    dbp4(i, ex, dp[i][ex].first, dp[i][ex].second);\n//    P next = ch[i][ex];\n//    i = next.first;\n//    ex = next.second;\n//  }\n//}\n\nvoid solve() {\n  while (cin >> n, n) {\n    init();\n    REP(i,1,n)\n    {\n      cin >> p[i];\n    }\n    doDP();\n    cout << dp[1][0].first << \" \" << dp[1][0].second << endl;\n  }\n}\n\nint main() {\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\npair<int, int> memo[50][50 * 5000];\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *) array, (T *) (array + N), val);\n}\n\nstd::pair<int, int> f(const int n, int nokori, int n_, const int *p) {\n    if (n <= n_)return std::make_pair(0, 0);\n    if (memo[n_][nokori].second > -1)return memo[n_][nokori];\n    int s = p[n_] % 1000;\n    int c = 0;\n    int nokori_ = nokori;\n    pair<int, int> ans = make_pair(0, INF);\n    if (s > 500 || s == 0) {\n        ans = f(n, nokori, n_ + 1, p);\n    }\n\n    if (s != 0) {\n        if (s <= 500) {\n            c++;\n            nokori += (500 - s);\n        } else {\n            if (s > 500)s -= 500;\n            if (s <= nokori) {\n                c++;\n                nokori -= s;\n            } else {\n                nokori += (500 - s);\n            }\n        }\n    } else if (nokori >= 500) {\n        c++;\n    } else {\n        return ans;\n    }\n    pair<int, int> hoge = f(n, nokori, n_ + 1, p);\n    pair<int, int> hoge_ = make_pair(hoge.first + c, hoge.second + p[n_]);\n    if (ans.first < hoge_.first) {\n        ans = hoge_;\n    } else if (ans.first == hoge_.first && ans.first > hoge_.first) {\n        ans = hoge_;\n    }\n    return memo[n_][nokori_] = ans;\n}\n\nint main() {\n    int n;\n    int p[50];\n    while (cin >> n, n) {\n        Fill(p, 0);\n        Fill(memo, make_pair(0, -1));\n        for (int i = 0; i < n; i++) {\n            cin >> p[i];\n        }\n        pair<int, int> ans = f(n, 0, 0, p);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 2\n#define MAX 100\n#define MAX_C 100001\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nint m[MAX];\npii dp[MAX_N][MAX_C];\n\nvoid set_m(vector<int> &p)\n{\n    for (int i = 0; i < (int)p.size(); i++) {    \n        m[i] = ((p[i] - 1) / 1000 + 1) * 1000;\n    }\n}\n\nvoid update(pii &a, pii &b)\n{\n    if (a.first < b.first) {\n        a = b;\n    } else if (a.first == b.first) {\n        if (a.second > b.second) {\n            a = b;\n        }\n    }\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<int> p(N);\n        for (int i = 0; i < N; i++) {\n            cin >> p[i];\n        }\n        \n        set_m(p);\n        \n        memset(dp, -1, sizeof(dp));\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < MAX_C; j++) {\n                dp[i][j] = pii(-1, INF);\n            }\n        }\n        \n        dp[0][0] = pii(0, 0);\n        for (int i = 0; i < N; i++) {\n            int curr = (i & 1), next = !(i & 1);\n            for (int j = 0; j < MAX_C; j++) {\n                if (dp[curr][j].first == -1) continue;\n                \n                update(dp[next][j], dp[curr][j]);\n\n                for (int k = 0; k <= min(j, 999); k++) {\n                    int pay = m[i] + k;\n                    int change = pay - p[i];                    \n                    if (change >= 1000) continue;\n                    \n                    int _500 = (change >= 500);\n                    int nc = j - k + change - _500 * 500;                    \n\n                    if (nc >= MAX_C) continue;\n                    \n                    pii ncost = pii(dp[curr][j].first + _500,\n                                    dp[curr][j].second + p[i]);                    \n                    \n                    update(dp[next][nc], ncost);\n                }\n            }\n            \n            for (int j = 0; j < MAX_C; j++) {\n                dp[curr][j] = pii(-1, INF);\n            }\n        }\n        \n        pii res = pii(-1, INF);\n        for (int i = 0; i < MAX_C; i++) {\n            update(res, dp[N&1][i]);\n        }\n        cout << res.first << \" \" << res.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF (1<<30)\n#define INFLL (1ll<<60)\ntypedef pair<int, int> P;\ntypedef pair<int, P> E;\n#define MOD (1000000007ll)\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\tb += MOD;\n\ta += b;\n\ta %= MOD;\n}\n\nint coin[2][55555],cost[2][55555];\n\nvoid update(int i, int j, int c, int v){\n\tif(coin[i][j] < c){\n\t\tcoin[i][j] = c;\n\t\tcost[i][j] = v;\n\t}else if(coin[i][j] == c){\n\t\tcost[i][j] = min(cost[i][j], v);\n\t}\n}\n\nint main(void){\n\tint n,p[111],i,j,r,c,a,b;\n\tbool flag;\n\twhile(true){\n\t\tcin >> n;\n\t\tif(!n){\n\t\t\tbreak;\n\t\t}\n\t\tfill(coin[0],coin[2],0);\n\t\tfill(cost[0],cost[2],INF);\n\t\tcost[0][0] = 0;\n\t\tfor(i=0; i<n; ++i){\n\t\t\ta = i%2;\n\t\t\tb = (i+1)%2;\n\t\t\tcin >> p[i];\n\t\t\tfor(j=0; j<50000; ++j){\n\t\t\t\tupdate(b,j,coin[a][j],cost[a][j]);\n\t\t\t\tif(cost[a][j]>=INF){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr = (p[i]+500)%1000;\n\t\t\t\tif(j>=r){\n\t\t\t\t\tupdate(b,j-r,coin[a][j]+1,cost[a][j]+p[i]);\n\t\t\t\t}\n\t\t\t\tr = (5000-p[i])%1000;\n\t\t\t\tif(r<500){\n\t\t\t\t\tupdate(b,j+r,coin[a][j],cost[a][j]+p[i]);\n\t\t\t\t}else{\n\t\t\t\t\tupdate(b,j+r-500,coin[a][j]+1,cost[a][j]+p[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta = n%2; b = (n+1)%2;\n\t\tcoin[b][0] = 0; cost[b][0] = INF;\n\t\tfor(j=0; j<50000; ++j){\n\t\t\tif(cost[a][j]<INF){\n\t\t\t\tupdate(b,0,coin[a][j],cost[a][j]);\n\t\t\t}\n\t\t}\n\t\tcout << coin[b][0] << \" \" << cost[b][0] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nPII f(PII a, PII b) {\n    if(a.first>b.first || (a.first==b.first && a.second<b.second)) return a;\n    return b;\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(1) {\n        ll n;\n        cin >> n;\n        if(!n) break;\n        vector<ll> p(n);\n        REP(i, n) cin >> p[i];\n\n        ll cur = 0, nxt = 1;\n        vector<vector<PII>> dp(2, vector<PII>(50000, {-LLINF, LLINF}));\n        dp[0][0] = {0, 0};\n        REP(i, n) {\n            dp[nxt] = vector<PII>(50000, {-LLINF, LLINF});\n            REP(j, 50000) {\n                if(dp[cur][j].first == LLINF) continue;\n                // 小銭を出すことで500円玉をもらう\n                ll use = (p[i]+500)%1000;\n                if(use <= j) {\n                    PII now(dp[cur][j]);\n                    now.first++;\n                    now.second += p[i];\n                    dp[nxt][j-use] = f(dp[nxt][j-use], now);\n                }\n                // 何もしない\n                dp[nxt][j] = f(dp[nxt][j], dp[cur][j]);\n                // 1000円だけ出す\n                PII now(dp[cur][j]);\n                ll get = 1000-p[i]%1000;\n                if(get == 1000) get = 0;\n                if(get >= 500) {\n                    now.first++;\n                    get -= 500;\n                }\n                now.second += p[i];\n                if(j+get < 50000) dp[nxt][j+get] = f(dp[nxt][j+get], now);\n            }\n            swap(cur, nxt);\n        }\n\n        // REP(i, 10) cout << dp[cur][i] << \" \";\n        // cout << endl;\n\n        PII ret(0, 0);\n        REP(i, 50000) ret = f(ret, dp[cur][i]);\n        cout << ret.first << \" \" << ret.second << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// finish date: 2018/06/21\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <map>\n#include <climits>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i, a, b) for(int (i)=a;(i)<(b);(i)++)\n#define rep(i, n)  FOR(i,0,n)\n#define ll long long\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vvvi vector<vector<vector<int>>>\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vd vector<double>\n#define vvd vector<vector<double>>\n#define vb vector<bool>\n#define vvb vector<vector<bool>>\n#define vs vector<string>\n#define vc vector<char>\n#define vvc vector<vector<char>>\n#define pii pair<int,int>\nconst int bigmod = 1000000007;\n#define INF 1050000000\n\n\nint main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        vi p(n);\n        rep(i, n) {\n            cin >> p[i];\n        }\n        int maxDP = n * 500;\n        vector<pii > DP(maxDP, pii(-1, -1));\n        DP[0] = pii(0, 0);\n        vector<pii > newDP;\n        rep(i, n) {\n            newDP = vector<pii >(maxDP, pii(-1, -1));\n            int otsuri = 1000 - p[i] % 1000;\n            if (otsuri == 1000) otsuri = 0;\n            for (int j = maxDP - 1; j >= 0; j--) {\n                if (DP[j] == pii(-1, -1)) continue;\n                bool con1 = newDP[j + otsuri].first < DP[j].first;\n                bool con2 = newDP[j + otsuri].first == DP[j].first;\n                bool con3 = newDP[j + otsuri].second > DP[j].second + p[i];\n                if (con1 || (con2 && con3)) {\n                    newDP[j + otsuri] = DP[j];\n                    newDP[j + otsuri].second += p[i];\n                }\n            }\n            rep(j, maxDP) {\n                if (newDP[j] == pii(-1, -1)) continue;\n                if (j >= 500) {\n                    bool con1 = newDP[j - 500].first < newDP[j].first + 1;\n                    bool con2 = newDP[j - 500].first == newDP[j].first + 1;\n                    bool con3 = newDP[j - 500].second > newDP[j].second;\n                    if (con1 || (con2 && con3)) {\n                        newDP[j - 500] = newDP[j];\n                        newDP[j - 500].first++;\n                    }\n                }\n            }\n            rep(j, maxDP) {\n                if (DP[j].first > newDP[j].first || (DP[j].first == newDP[j].first && DP[j].second < newDP[j].second)) {\n                    newDP[j] = DP[j];\n                }\n            }\n            DP = newDP;\n        }\n        int ma = -1;\n        int ansMoney = 0;\n        rep(i, maxDP) {\n            if (DP[i].first > ma || (DP[i].first == ma && DP[i].second < ansMoney)) {\n                ma = DP[i].first;\n                ansMoney = DP[i].second;\n            }\n        }\n        cout << ma << \" \" << ansMoney << endl;\n\n    }\n\n\n    return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> P;\n\nP comp(P lhs,P rhs)\n{\n\tif(lhs.first>rhs.first)\n\t\treturn lhs;\n\telse if(lhs.first==rhs.first && lhs.second<rhs.second)\n\t\treturn lhs;\n\telse\n\t\treturn rhs;\t\n}\n\nP dp[101][50001]; //i番目まで端数でj円持っているときの500の数と金額\nint m[100]; //価格\nP pay1000[100]; //1000円オンリーで払ったときにもらえる500ともらえる端数\nP adjust[100]; //端数を調整したときに500を1もらうために必要な端数\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>m[i];\n\t\t\tint p=(7000-m[i])%1000;\n\t\t\tif(p>=500)\n\t\t\t\tpay1000[i]=P(1,p-500);\n\t\t\telse\n\t\t\t\tpay1000[i]=P(0,p);\n\t\t\tp=(m[i]+1000)%1000;\n\t\t\tif(p!=0)\n\t\t\t\tadjust[i]=P(1,(p+500)%1000);\n\t\t\telse\n\t\t\t\tadjust[i]=P(1,500);\n\t\t}\n\t\t\n\t\t//ここからdp\n\t\tfill(dp[0],dp[101],P(-1,-1));\n\t\tdp[0][0]=P(0,0);\n\t\tfor(int i=1;i<n+1;i++)\n\t\t{\n\t\t\t//cerr<<pay1000[i-1].first<<\" \"<<pay1000[i-1].second<<endl;\n\t\t\t//cerr<<adjust[i-1].first<<\" \"<<adjust[i-1].second<<endl;\n\t\t\tfor(int j=0;j<50001;j++)\n\t\t\t{\n\t\t\t\tif(dp[i-1][j]!=P(-1,-1))\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=comp(dp[i][j],dp[i-1][j]);\n\t\t\t\t\t//端数調整して買う場合\t\n\t\t\t\t\tif(j>=adjust[i-1].second)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j-adjust[i-1].second]=comp(dp[i][j-adjust[i-1].second], \n\t\t\t\t\t\t\tP(dp[i-1][j].first+adjust[i-1].first, dp[i-1][j].second+m[i-1]));\n\t\t\t\t\t}\n\t\t\t\t\t//1000円だけで買う場合\n\t\t\t\t\tdp[i][j+pay1000[i-1].second]=comp(dp[i][j+pay1000[i-1].second],\n\t\t\t\t\t\tP(dp[i-1][j].first+pay1000[i-1].first, dp[i-1][j].second+m[i-1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tP ans=P(0,0);\n\t\tfor(int i=0;i<50001;i++)\n\t\t\tans=comp(dp[n][i],ans);\n\t\tcout<<ans.first<<\" \"<<ans.second<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<17;\n\nP dp[102][50501];\nP pmax(P p,P q){\n    if(p.fs>q.fs) return p;\n    else if(p.fs==q.fs) return (p.sc<q.sc?p:q);\n    else return q;\n}\n\n\nint main(){\n    int N;\n    while(cin >> N){\n        if(!N) return 0;\n        int p[N];\n        for(int i=0;i<N;i++){\n            cin >> p[i];\n        }\n        for(int i=0;i<=N;i++){\n            for(int j=0;j<50001;j++){\n                if(j==0) dp[i][j]=mp(0,0);\n                else dp[i][j]=mp(-1,INF);\n            }\n        }\n        for(int i=0;i<N;i++){\n            for(int j=0;j<50001;j++){\n                if(dp[i][j].fs==-1){\n                    continue;\n                }\n                P d=dp[i][j];\n                dp[i+1][j]=pmax(dp[i+1][j],d);\n                d.sc+=p[i];\n                int res=(1000-p[i]%1000)%1000;\n                dp[i+1][j+res]=pmax(dp[i+1][j+res],d);\n                if(res>=500){\n                    d.fs++;\n                    res-=500;\n                    dp[i+1][j+res]=pmax(dp[i+1][j+res],d);\n                }\n                else{\n                    d.fs++;\n                    res=500-res;\n                    if(res<=j) dp[i+1][j-res]=pmax(dp[i+1][j-res],d);\n                }\n            }\n        }\n        P ans=mp(0,LINF);\n        for(int i=0;i<=50000;i++){\n            ans=pmax(ans,dp[N][i]);\n        }\n        cout << ans.fs << \" \" << ans.sc << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\n\npii max(pii a, pii b){\n  if(a.first > b.first){\n    return a;\n  }else if(a.first < b.first){\n    return b;\n  }else{\n    if(a.second > b.second){\n      return b;\n    }else{\n      return a;\n    }\n  }\n}\npii dp[111][50000];\n\nint main(){\n  int n;\n  while(std::cin >> n, n){\n    vector<int> shop(n);\n    for (int i = 0; i < n; i++) std::cin >> shop[i];\n    \n    for (int i = 0; i <= n; i++) {\n      for (int j = 0; j < 50000; j++) {\n        dp[i][j] = pii(-1e9, 0);\n      }\n    }\n\n    dp[0][0] = pii(0, 0);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 50000; j++) {\n        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);\n        \n        int tf = dp[i][j].first;\n        int tc = dp[i][j].second;\n        int five_hundred;\n        int diff = (5000 - shop[i])%1000;\n        if(j + diff >= 500)\n          dp[i + 1][j + diff - 500] = max(dp[i + 1][j + diff - 500], pii(tf + 1, tc + shop[i]));\n        else\n          dp[i + 1][j + diff] = max(dp[i + 1][j + diff],\n                                    pii(tf, tc + shop[i]));\n      }\n    }\n    pii ans = pii(0, 0);\n    for (int i = 0; i < 50000; i++) {\n      ans = max(ans, dp[n][i]);\n    }\n    std::cout << ans.first << \" \" << ans.second << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\nconst int M = 1000000007;\n\nint main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n\n        vector<vector<int>> dp(n * 500, vector<int>(n + 1, M));\n        dp[0][0] = 0;\n        for (int i = 0; i < n; ++i) {\n            int p;\n            cin >> p;\n            vector<vector<int>> nex = dp;\n            if (p % 1000 > 0 && p % 1000 <= 500) {\n                int q = (500 - p % 500) % 500;\n                for (int j = q; j < (i + 1) * 500; ++j) {\n                    for (int k = 1; k <= i + 1; ++k) {\n                        nex[j][k] = min(nex[j][k], dp[j - q][k - 1] + p);\n                    }\n                }\n            }\n            else {\n                int q = p % 500;\n                int r = 1000 - p % 1000;\n                if (q == 0) {\n                    q = 500;\n                    r = 0;\n                }\n                for (int j = 0; j + q < (i + 1) * 500; ++j) {\n                    for (int k = 1; k <= i + 1; ++k) {\n                        nex[j][k] = min(nex[j][k], dp[j + q][k - 1] + p);\n                    }\n                }\n                for (int j = r; j + q < (i + 1) * 500; ++j) {\n                    for (int k = 0; k <= i + 1; ++k) {\n                        nex[j][k] = min(nex[j][k], dp[j - r][k] + p);\n                    }\n                }\n            }\n            dp = nex;\n        }\n        for (int i = n; i >= 0; --i) {\n            int mi = M;\n            for (int j = 0; j < n * 500; ++j) {\n                mi = min(mi, dp[j][i]);\n            }\n            if (mi < M) {\n                cout << i << \" \" << mi << \"\\n\";\n                break;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\n#define INF 10000000\nusing namespace std;\n\nint N, P[100];\nint dp[2][101][501];\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> P[i];\n\n    REP(i, 0, 2) REP(j, 0, N + 1) REP(k, 0, 501) dp[i][j][k] = INF;\n    dp[0][0][0] = 0;\n\n    int current = 0, next = 1;\n    REP(i, 0, N) {\n      REP(j, 0, N) REP(k, 0, 501) dp[next][j][k] = dp[current][j][k];\n      REP(j, 0, N) REP(k, 0, 501) {\n        if(dp[current][j][k] >= INF) continue;\n        if((P[i] + 500) % 1000 <= k) {\n          int nj = j + 1;\n          int nk = k - (P[i] + 500) % 1000;\n          dp[next][nj][nk] = min(dp[current][nj][nk], dp[current][j][k] + P[i]);\n        } else {\n          int r = 1000;\n          while(r < P[i]) r += 1000;\n          int o = r - P[i];\n          int nj = j + o / 500;\n          int nk = k + o % 500;\n          dp[next][nj][nk] = min(dp[current][nj][nk], dp[current][j][k] + P[i]);\n        }\n      }\n\n      swap(current, next);\n    }\n\n    // REP(j, 0, N) REP(k, 0, 501) {\n    //   if(dp[next][j][k] < INF) cout << j << \", \" << k << \": \" << dp[next][j][k] << endl;\n    // }\n    // cout << endl;\n\n    int n = 0, p = INF;\n    REP(i, 0, N + 1) REP(j, 0, 501) if(dp[current][i][j] != INF) n = max(n, i);\n    REP(i, 0, 501) p = min(p, dp[current][n][i]);\n    cout << n << \" \" << p << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<n; ++i)\n#define rep(i,n) reps(i,0,n)\n#define maxl(a,b) a = max(a, b)\n\npair<int, int> dp[101][210 * 500];\nconst int MAX = 1001001001;\n\nvoid solve(int n)\n{\n    vector<int> p(n);\n    \n    rep(i, n){\n        cin >> p[i];\n    }\n    \n    rep(i, n+1){\n        rep(c, 20*500){\n            dp[i][c] = {-MAX, 0};\n        }\n    }\n    dp[0][0] = {0, 0};\n    \n    rep(i, n){\n        rep(c, 210*500){\n            auto r = dp[i][c];\n            maxl(dp[i+1][c], r);\n            \n            int pr = p[i] % 1000;\n            if(pr == 0){\n                if(c >= 500) maxl(dp[i+1][c - 500], make_pair(r.first+1, r.second - p[i]));\n            }\n            else if(pr <= 500){\n                maxl(dp[i+1][c + 500 - pr], make_pair(r.first+1, r.second - p[i]));\n            }\n            else{\n                maxl(dp[i+1][c - pr + 1000], make_pair(r.first, r.second - p[i]));\n                if(c >= pr - 500) maxl(dp[i+1][c - pr + 500], make_pair(r.first+1, r.second - p[i]));\n            }\n        }\n    }\n    \n    auto ans = *max_element(dp[n], dp[n] + 210*500);\n    cout << ans.first << ' ' << -ans.second << endl;\n}\n\nint main()\n{\n    int n;\n    \n    while(cin >> n, n){\n        solve(n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\npint INF(INT_MAX,INT_MAX);\n\npint dp[55555];\npint nex[55555];\n\nint N;\nint P[111];\n\n\n\nvoid solve(){\n    rep(i,N)cin>>P[i];\n\n    fill_n(dp,55555,INF);\n    dp[0]=pint(0,0);\n\n    for(int i=0;i<N;i++){\n        fill_n(nex,55555,INF);\n        for(int j=0;j<50000;j++){\n            chmin(nex[j],dp[j]);\n\n            int p=P[i]%1000;\n            if(p==0){\n                pint w=dp[j];\n                w.fi--;w.se+=P[i];\n                if(j>=500)chmin(nex[j-500],w);\n            }\n            else if(p<=500){\n                pint w=dp[j];\n                w.fi--;\n                w.se+=P[i];\n                chmin(nex[j+500-p],w);\n            }\n            else{\n                pint w=dp[j];\n                w.se+=P[i];\n                chmin(nex[j+1000-p],w);\n                w.fi--;\n                if(j-(p-500)>=0)chmin(nex[j-(p-500)],w);\n            }\n        }\n        rep(j,55555)dp[j]=nex[j];\n    }\n\n    pint ans=INF;\n    rep(i,55555)chmin(ans,dp[i]);\n    cout<<-ans.fi<<\" \"<<ans.se<<endl;\n}\n\nsigned main(){\n    while(cin>>N,N)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\npair<int, int> dp[109][50009]; int n, x[109], g[109];\n\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0) break;\n\t\tfor (int i = 1; i <= n; i++) { cin >> x[i]; g[i] = x[i]; x[i] %= 1000; }\n\n\t\tfor (int i = 1; i <= n + 1; i++) { for (int j = 0; j <= n * 500; j++) dp[i][j] = make_pair(-1, -1); }\n\n\t\tdp[1][0] = make_pair(0, 0);\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= n * 500; j++) {\n\t\t\t\tif (dp[i][j] == make_pair(-1, -1)) continue;\n\n\t\t\t\tdp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);\n\n\t\t\t\tif (x[i] == 0) {\n\t\t\t\t\t// 何もできない\n\t\t\t\t}\n\t\t\t\telse if (x[i] >= 1 && x[i] <= 500) {\n\t\t\t\t\t// 1000 円支払う\n\t\t\t\t\tdp[i + 1][j + (1000 - x[i]) % 500] = max(dp[i + 1][j + (1000 - x[i]) % 500], make_pair(dp[i][j].first + 1, dp[i][j].second - g[i]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// 1000 円支払う\n\t\t\t\t\tif (j - (x[i] - 500) >= 0) {\n\t\t\t\t\t\tdp[i + 1][j - (x[i] - 500)] = max(dp[i + 1][j - (x[i] - 500)], make_pair(dp[i][j].first + 1, dp[i][j].second - g[i]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i + 1][j + (1000 - x[i]) % 500] = max(dp[i + 1][j + (1000 - x[i]) % 500], make_pair(dp[i][j].first, dp[i][j].second - g[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int, int>maxn = make_pair(-1, -1);\n\t\tfor (int i = 0; i <= 50000; i++) maxn = max(maxn, dp[n + 1][i]);\n\t\tcout << maxn.first << \" \" << -maxn.second << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint n,p;\npair<int,int> dp[101][50001];\n\nint main() {\n    while (cin>>n && n != 0) {\n        memset(dp,-1,sizeof(dp));\n        dp[0][0] = pair<int,int>(0,0);\n        for (int i = 0; i < n; i++) {\n            cin>>p;\n            for (int t = 0; t < 500*n; t++) {\n                if (dp[i][t] == pair<int,int>(-1,-1)) continue;\n                dp[i+1][t] = max(dp[i][t],dp[i+1][t]);\n                if (p%1000<500 && p%1000) dp[i+1][t+(500-p%500)] = max(dp[i+1][t+(500-p%500)], pair<int,int>(dp[i][t].first+1,dp[i][t].second-p));\n                if (p%1000==0 && t>=500) dp[i+1][t-500] = max(dp[i+1][t-500],pair<int,int>(dp[i][t].first+1,dp[i][t].second-p));\n\n                if (p%1000>=500) {\n                    if (t>=p%500) dp[i+1][t-p%500] = max(dp[i+1][t-p%500], pair<int,int>(dp[i][t].first+1,dp[i][t].second-p));\n                    else dp[i+1][t+(500-p%500)] = max(dp[i+1][t+(500-p%500)], pair<int,int>(dp[i][t].first, dp[i][t].second-p));\n                }\n            }\n        }\n        pair<int,int> ans = pair<int,int>(0,0);\n        for (int i = 0; i < 50000; i++) ans = max(ans, dp[n][i]);\n        cout<<ans.first<<\" \"<<-ans.second<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nP dp[101][50001];\n \nvoid Max(P &a,P b){a=max(a,b);}\n \nint main(){\n  int n,p[101];\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>p[i];\n     \n    memset(dp,-1,sizeof(dp));\n    dp[0][0]=P(0,0);\n   \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n*500;j++){\n    if(dp[i][j]==P(-1,-1))continue;\n    int coin=dp[i][j].first, ncost=dp[i][j].second-p[i];\n    Max(dp[i+1][j],dp[i][j]);\n    if(p[i]%1000<500&&p[i]%1000)Max(dp[i+1][j+(500-p[i]%500)],P(coin+1,ncost));\n    if(p[i]%1000==0&&j>=500) Max(dp[i+1][j-500],P(coin+1,ncost));\n     \n    if(p[i]%1000>=500) {\n      if(j>=p[i]%500)Max(dp[i+1][j-p[i]%500],P(coin+1,ncost));\n      else Max(dp[i+1][j+(500-p[i]%500)],P(coin,ncost));\n    }\n      }\n     \n    P ans=P(0,0);\n    for(int i=0;i<50000;i++)Max(ans,dp[n][i]);\n    cout <<ans.first<<\" \"<<-ans.second<<endl;\n     \n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\nint main() {\n\tint n;\n\twhile (cin>>n,n) {\n\t\tvi va(n);\n\t\tREP(i, n)\n\t\t\tcin >> va[i];\n\t\tvector<pii> state(500 * n, {-1,9999999});\n\t\tstate[0] = { 0,0 };\n\t\tREP(i, n) {\n\t\t\tvector<pii> state2 = state;\n\t\t\tREP(j, 500 * n) {\n\t\t\t\tif (state[j].first != -1) {\n\t\t\t\t\tif (va[i] % 1000 != 0 && va[i] % 1000 <= 500) {\n\t\t\t\t\t\tif (state2[j + (500 - va[i] % 500) % 500].first < state[j].first + 1) {\n\t\t\t\t\t\t\tstate2[j + (500 - va[i] % 500) % 500].first = state[j].first + 1;\n\t\t\t\t\t\t\tstate2[j + (500 - va[i] % 500) % 500].second = state[j].second + va[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(state2[j + (500 - va[i] % 500) % 500].first == state[j].first + 1){\n\t\t\t\t\t\t\tif (state2[j + (500 - va[i] % 500) % 500].second > state[j].second + va[i]) {\n\t\t\t\t\t\t\t\tstate2[j + (500 - va[i] % 500) % 500].second = state[j].second + va[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t//buy all1000\n\t\t\t\t\t\tif (va[i] % 1000 != 0) {//1000??????????????§x%1000==0????????????????????????????§?\n\t\t\t\t\t\t\tif (state2[j + (1000 - (va[i]%1000))].first < state[j].first) {\n\t\t\t\t\t\t\t\tstate2[j + (1000 - (va[i] % 1000))].first = state[j].first;\n\t\t\t\t\t\t\t\tstate2[j + (1000 - (va[i] % 1000))].second = state[j].second + va[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (state2[j + (1000 - (va[i] % 1000))].first == state[j].first) {\n\t\t\t\t\t\t\t\tif (state2[j + (1000 - (va[i] % 1000))].second > state[j].second + va[i]) {\n\t\t\t\t\t\t\t\t\tstate2[j + (1000 - (va[i] % 1000))].second = state[j].second + va[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//buy want500\n\t\t\t\t\t\tif (va[i] % 1000 == 0 && j >= 500) {\n\t\t\t\t\t\t\tif (state2[j -500].first < state[j].first + 1) {\n\t\t\t\t\t\t\t\tstate2[j - 500].first = state[j].first + 1;\n\t\t\t\t\t\t\t\tstate2[j - 500].second = state[j].second + va[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (state2[j - 500].first == state[j].first + 1) {\n\t\t\t\t\t\t\t\tif (state2[j - 500].second > state[j].second + va[i]) {\n\t\t\t\t\t\t\t\t\tstate2[j - 500].second = state[j].second + va[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (va[i] % 1000 > 500 && j >= va[i] % 500) {\n\t\t\t\t\t\t\tif (state2[j - (va[i] % 500)].first < state[j].first + 1) {\n\t\t\t\t\t\t\t\tstate2[j - (va[i] % 500)].first = state[j].first + 1;\n\t\t\t\t\t\t\t\tstate2[j - (va[i] % 500)].second = state[j].second + va[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (state2[j - (va[i] % 500)].first == state[j].first + 1) {\n\t\t\t\t\t\t\t\tif (state2[j - (va[i] % 500)].second > state[j].second + va[i]) {\n\t\t\t\t\t\t\t\t\tstate2[j - (va[i] % 500)].second = state[j].second + va[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstate = state2;\n\t\t}\n\t\tint ans=-1, ans2=9999999;\n\t\tREP(i, 500 * n) {\n\t\t\tif (ans < state[i].first) {\n\t\t\t\tans = state[i].first;\n\t\t\t\tans2= state[i].second;\n\t\t\t}\n\t\t\telse if (ans == state[i].first) \n\t\t\t{\n\t\t\t\tif (ans2 > state[i].second) {\n\t\t\t\t\tans2 = state[i].second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << \" \" << ans2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,unroll-loops\")\n//#pragma GCC target(\"avx\")\n\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\ntypedef pair<int, int> i_i;\nvector<i_i> Prev(100001), Next(100001);\nint main() {\n    while(true) {\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        for(int i = 0; i <= 100000; i++) {\n            Prev[i] = {-INF,0};\n            Next[i] = {-INF,0};\n        }\n        Prev[0] = {0, 0};\n        for(int i = 1; i <= n; i++) {\n            int p;\n            cin >> p;\n            int nowchange = 1000 - ((p + 999) % 1000 + 1);\n            //cerr << \"P:\" << p << endl;\n            for(int change = 0; change <= 100000; change++) {\n                /*\n                for(int num = 0; num <= i; num++) {\n                    Next[change][num] = Prev[change][num];\n                    if(nowchange >= 500) {\n                        if(change - nowchange + 500 >= 0 && num - 1 >= 0) {\n                            Next[change][num] = min(Next[change][num], Prev[change - nowchange + 500][num-1] + p);\n                        }\n                    } else {\n                        if(change - nowchange >= 0) {\n                            Next[change][num] = min(Next[change][num], Prev[change - nowchange][num] + p);\n                        }\n                        if(change + 500 - nowchange <= 1000 * i && num - 1 >= 0) {\n                            Next[change][num] = min(Next[change][num], Prev[change + 500 - nowchange][num-1] + p);\n                        }\n                    }\n                }\n            }\n            */\n                Next[change] = Prev[change];\n                if(nowchange >= 500) {\n                    if(change - nowchange + 500 >= 0) {\n                        i_i tmp = Prev[change-nowchange+500];\n                        tmp.second -= p;\n                        tmp.first++;\n                        Next[change] = max(Next[change], tmp);\n                    }\n                } else {\n                    if(change - nowchange >= 0) {\n                        i_i tmp = Prev[change-nowchange];\n                        tmp.second -= p;\n                        Next[change] = max(Next[change], tmp);\n                    }\n                    if(change + 500 - nowchange <= 100000) {\n                        i_i tmp = Prev[change + 500 - nowchange];\n                        tmp.second -= p;\n                        tmp.first++;\n                        Next[change] = max(Next[change], tmp);\n                    }\n                }\n            }\n            swap(Next, Prev);\n        }\n        /*\n        int ansnum = 0;\n        int ansval = 0;\n        for(int change = 0; change <= 100000; change++) {\n            for(int num = 0; num <= 100; num++) {\n                if(Prev[change][num] < INF) {\n                    if(num > ansnum) {\n                        ansval = Prev[change][num];\n                        ansnum = num;\n                    } else if(num == ansnum && ansval > Prev[change][num]) {\n                        ansval = Prev[change][num];\n                    }\n                }\n            }\n        }\n        */\n        i_i ans = {0, 0};\n        for(int change = 0; change <= 100000; change++) {\n            ans = max(ans, Prev[change]);\n        }\n        cout << ans.first << \" \" << -ans.second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint dp[128][128][1024];\nint n;\nint P[128];\n\nvoid init() {\n  for(int i = 0; i < 128; ++i) {\n    for(int j = 0; j < 128; ++j) {\n      for(int k = 0; k < 1024; ++k) {\n        dp[i][j][k] = -1;\n      }\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d\", &P[i]);\n    }\n    dp[0][0][0] = 0;\n    for(int i = 0; i < n; ++i) {\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < 1024; ++k) {\n          if( dp[i][j][k] == -1 ) continue;\n          // step 1\n          dp[i+1][j][k] = std::max(dp[i+1][j][k], dp[i][j][k]);\n          // step 2\n          int count_1000 = (P[i] + 999) / 1000;\n          int rem = dp[i][j][k] + count_1000 * 1000 - P[i];\n          int& next = dp[i+1][j + (rem>=500 ? 1 : 0)][k + count_1000];\n          next = std::max(next, rem>=500 ? rem - 500 : rem);\n        }\n      }\n    }\n    for(int i = 0; i < 6; ++i) {\n      for(int j = 0; j < 6; ++j) {\n        for(int k = 0; k < 6; ++k) {\n          //printf(\"(i, j, k) = (%d, %d, %d) : %d\\n\", i, j, k, dp[i][j][k]);\n        }\n      }\n    }\n    int res = (1 << 28);\n    int max = -1;\n    for(int j = n; j >= 0; --j) {\n      for(int k = 0; k < 1024; ++k) {\n        if( dp[n][j][k] == -1 ) continue;\n        int cost = k * 1000 - 500 * j - dp[n][j][k];\n        res = std::min(res, cost);\n      }\n      if( res != (1 << 28) ) {\n        max = j;\n        break;\n      }\n    }\n    printf(\"%d %d\\n\", max, res);\n  }\n         \n        \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// dp[i][j]: i番目の店までで100円以下の小銭の総額がjとなるような買い方の{500円玉の枚数,-購入金額}の最大値\n// 遷移は a)500円玉を得られるように買う b)1000円札のみで買って小銭を稼ぐ c)買わない\n// bでも500円玉を得られる場合がある\nint n, p[100];\npii dp[100][50050];\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\trep(i,n) cin >> p[i];\n\t\trept(i,n) rept(j,50000) dp[i][j] = {-1,0};\n\t\tdp[0][0] = {0,0};\n\t\trep(i,n) rept(j,50000) if (dp[i][j].fi!=-1) {\n\t\t\tint g = dp[i][j].fi, u = -dp[i][j].se;\n\t\t\t// 500円玉を得る\n\t\t\tif (j>=(p[i]+500)%1000) chmax(dp[i+1][j-(p[i]+500)%1000], mp(g+1, -(u+p[i])));\n\t\t\t// 1000円札のみ\n\t\t\tif (1<=p[i]%1000 && p[i]%1000<=500) chmax(dp[i+1][j+(500-p[i]%1000)], mp(g+1, -(u+p[i])));\n\t\t\tif (500<p[i]%1000) chmax(dp[i+1][j+(1000-p[i]%1000)], mp(g, -(u+p[i])));\n\t\t\t// 買わない\n\t\t\tchmax(dp[i+1][j], mp(g, -u));\n\t\t}\n\t\tpii res = mp(0,0);\n\t\trept(i,50000) chmax(res, dp[n][i]);\n\t\tcout << res.fi << ' ' << -res.se << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 101;\nconst int M = 2010;\n\nint dp[N][M][N];\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vi a(n); for(auto& e : a) cin >> e;\n\n        rep(i, n + 1) rep(k, n + 1) rep(j, M) dp[i][j][k] = inf;\n        dp[0][0][0] = 0;\n\n        rep(i, n){\n            int org = a[i];\n            int price = org % 1000;\n            rep(k, n){\n                rep(j, M){\n                    int cur = dp[i][j][k];\n                    if(cur == inf) continue;\n\n                    if(price == 0){\n                        chmin(dp[i + 1][j][k], cur);\n                        int diff = (price + 500) % 1000;\n                        if(j - diff >= 0){\n                            chmin(dp[i + 1][j - diff][k + 1], cur + org);\n                        }\n                    }\n                    else if(price <= 500){\n                        chmin(dp[i + 1][min(M, j + 500 - price)][k + 1], cur + org);\n                    }\n                    else {\n                        chmin(dp[i + 1][j][k], cur);\n                        chmin(dp[i + 1][min(M, j + 1000 - price)][k], cur + org);\n                        int diff = (price + 500) % 1000;\n                        if(j - diff >= 0){\n                            chmin(dp[i + 1][j - diff][k + 1], cur + org);\n                        }\n                    }\n                }\n            }\n        }\n\n        pair<int, int> res(-1, -1);\n        rep(i, n + 1){\n            rep(k, n + 1){\n                rep(j, M){\n                    if(dp[i][j][k] == inf) continue;\n                    chmax(res, pair<int, int>(k, -dp[i][j][k]));\n                }\n            }\n        }\n        cout << res.first << \" \" << -res.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <cstring>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\nconst int INF = 1e6;\nint minCost[101][510][110]; // n, thousand, coin\n\nint main(){\n\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n\n        vector<int> p(n);\n        for(int i = 0; i < n; i++){\n            cin >> p[i];\n        }\n\n        for(int i = 0; i <= n; i++){\n            for(int j = 0; j <= 500; j++){\n                for(int k = 0; k <= n; k++){\n                    minCost[i][j][k] = INF;\n                }\n            }\n        }\n\n        minCost[0][0][0] = 0;\n\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < 500; j++){\n                for(int k = 0; k < n; k++){\n                    int temp = minCost[i][j][k];\n                    if(temp == INF){\n                        continue;\n                    }\n\n                    minCost[i + 1][j][k] = min(minCost[i + 1][j][k], minCost[i][j][k]);\n\n                    int nextJ;\n                    int small = 1000 * j - temp - 500 * k;\n                    int r = p[i] % 1000;\n                    if(r != 0 && r <= 500){\n                        nextJ = j + (p[i] / 1000) + 1;\n                        minCost[i + 1][nextJ][k + 1] = min(minCost[i + 1][nextJ][k + 1], temp + p[i]);\n                    }\n                    else{\n                        if(r == 0){\n                            if(small >= 500){\n                                nextJ = j + (p[i] / 1000);\n                                minCost[i + 1][nextJ][k + 1] = min(minCost[i + 1][nextJ][k + 1], temp + p[i]);\n                            }\n                        }\n                        else if(small >= r - 500){\n                            nextJ = j + (p[i] / 1000) + 1;\n                            minCost[i + 1][nextJ][k + 1] = min(minCost[i + 1][nextJ][k + 1], temp + p[i]);\n                        }\n                    }\n\n                    nextJ = j + (int)ceil((double)p[i] / 1000);\n                    minCost[i + 1][nextJ][k] = min(minCost[i + 1][nextJ][k], temp + p[i]);\n                }\n            }\n        }\n\n        int c, s;\n        c = 0;\n        s = 0;\n        for(int i = 0; i <= 500; i++){\n            for(int j = 0; j <= n; j++){\n                int temp = minCost[n][i][j];\n                if(temp == INF){\n                    continue;\n                }\n                if(j > c){\n                    c = j;\n                    s = temp;\n                }\n                else if(j == c && temp < s){\n                    s = temp;\n                }\n            }\n        }\n\n        cout << c << \" \" << s << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define M 25000\n\nint dp[2][101][M];\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int p[100],pp[100];\n    for(int i=0;i<n;i++)scanf(\"%d\",&p[i]),pp[i]=(1000-p[i]%1000)%1000;\n\n    for(int i=0;i<2;i++)\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<M;k++)dp[i][j][k]=1e9;\n    \n    dp[0][0][0]=0;\n\n    for(int i=0;i<n;i++){\n      int ni=(i+1)%2,I=i%2,mm=min(M,500*i+1);\n\n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<mm;k++)dp[ni][j][k]=1e9;\n      \n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<mm;k++){\n\t  int np=k+pp[i];\n\t  int nj=j;\n\t  if(np>=500)nj++,np-=500;\n\t  np=min(M-1,np);\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t  dp[ni][j][k]=min(dp[ni][j][k],dp[I][j][k]);\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t}\n    }\n    \n    int c=0,s=0;\n    for(int i=1;i<=n;i++)\n      for(int j=0;j<M;j++)\n\tif(dp[n%2][i][j]!=1e9&&i>=c){\n\t  if(c==i&&dp[n%2][i][j]<s)s=dp[n%2][i][j];\n\t  else if(c<i)c=i,s=dp[n%2][i][j];\n\t}\n    printf(\"%d %d\\n\",c,s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define SIZE 100100\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nint c[5]={100,50,10,5,1};\nconst int B = 9;\nint encode(vector<int> v){\n\tint S = 0;\n\tfor(int i=0;i<v.size();i++){\n\t\t//assert(v[i]<B);\n\t\tS = S*B+v[i];\n\t}\n\treturn S;\n}\nvector<int> decode(int S){\n\tvector<int> v;\n\tint x = B*B*B*B;\n\tfor(int i=0;i<5;i++){\n\t\tv.pb(S/x);\n\t\tS %= x;\n\t\tx /= B;\n\t}\n\treturn v;\n}\nP dp[105][SIZE];\npair<int,vector<int> > charge(int x){\n\tx %= 1000;\n\tvector<int> v(5,0);\n\tint f = x/500;\n\tx -= f*500;\n\tfor(int i=0;i<5;i++){\n\t\tv[i]=x/c[i];\n\t\tx -= v[i]*c[i];\n\t}\n\t//assert(x==0);\n\treturn make_pair(f,v);\n}\n/*void dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}*/\nP dfs(int id,int V){\n\t/*cout << \"call : \" << id << endl;\n\tcout << \"vec : \";\n\tdump(vec);\n\tcout << endl;*/\n\tint tmp = V;\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tmap<int,P>::iterator it;\n\tif(dp[id][V].fi!=-1){\n\t\treturn dp[id][V];\n\t}\n\tP res = dfs(id+1,V);\n\tvector<int> vec = decode(V);\n\tint h = ((p[id]-1)/1000+1)*1000;;\n\tfor(int i=0;i<5;i++){\n\t\twhile(vec[i]>0&&h-p[id]+c[i]<1000){\n\t\t\tvec[i]--;\n\t\t\th += c[i];\n\t\t}\n\t}\n\tpair<int,vector<int> > ch = charge(h-p[id]);\n\tfor(int i=0;i<5;i++)vec[i] += (ch.sec)[i];\n\tP res2 = dfs(id+1,encode(vec));\n\tres2.fi += ch.fi;\n\tres2.sec -= p[id];\n\tdp[id][tmp]=max(res,res2);\n\t/*cout << \"end : \" << id << endl;\n\tcout << \"vec : \";\n\tdump();\n\tcout << \"result : \" << dp[id][vec].fi << ' ' << -dp[id][vec].sec << endl;*/\n\treturn dp[id][tmp];\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<SIZE;j++){\n\t\t\tdp[i][j]=P(-1,-1);\n\t\t}\n\t}\n\tP ans = dfs(0,0);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nP gre(P x, P y) {\n\tif (x.first > y.first)return x;\n\tif (x.first == y.first&&x.second < y.second)return x;\n\treturn y;\n}\nbool sor(P x, P y) {\n\tif (x.first > y.first)return true;\n\tif (x.first == y.first&&x.second < y.second)return true;\n\treturn false;\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tP dp[101][50000];\n\t\tint cost[101] = {};\n\t\trep(i, n) {\n\t\t\tcin >> cost[i];\n\t\t}\n\t\trep(i, 101) {\n\t\t\trep(j, 50000) {\n\t\t\t\tdp[i][j] = { -1,-1 };\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = { 0,0 };\n\t\trep(i, n) {\n\t\t\trep(j, 50000) {\n\t\t\t\tif (dp[i][j].first == -1)continue;\n\t\t\t\tdp[i + 1][j] = gre(dp[i+1][j], dp[i][j]);\n\t\t\t\tif (cost[i] % 1000 == 0) {\n\t\t\t\t\tif (j >= 500) {\n\t\t\t\t\t\tP res;\n\t\t\t\t\t\tres = { dp[i][j].first + 1,dp[i][j].second+cost[i] };\n\t\t\t\t\t\tdp[i+1][j - 500] = gre(dp[i+1][j - 500], res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (j < cost[i] % 1000||cost[i]>500) {\n\t\t\t\t\tif (1000 - cost[i] % 1000 + j >= 500) {\n\t\t\t\t\t\tP res;\n\t\t\t\t\t\tres = { dp[i][j].first + 1,dp[i][j].second + cost[i] };\n\t\t\t\t\t\tdp[i + 1][500 - cost[i] % 1000 + j] = gre(dp[i + 1][500 - cost[i] % 1000 + j], res);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tP res;\n\t\t\t\t\t\tres = { dp[i][j].first,dp[i][j].second + cost[i] };\n\t\t\t\t\t\tdp[i + 1][1000 - cost[i] % 1000 + j] = gre(dp[i + 1][1000 - cost[i] % 1000 + j], res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (1000 - cost[i] % 1000 >= 500) {\n\t\t\t\t\t\tP res;\n\t\t\t\t\t\tres = { dp[i][j].first + 1,dp[i][j].second + cost[i] };\n\t\t\t\t\t\tdp[i + 1][500 - cost[i] % 1000+j] = gre(dp[i + 1][500 - cost[i] % 1000+j],res);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tP res;\n\t\t\t\t\t\tres = { dp[i][j].first,dp[i][j].second + cost[i] };\n\t\t\t\t\t\tdp[i + 1][1000 - cost[i] % 1000 + j] = gre(dp[i + 1][1000 - cost[i] % 1000 + j], res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(dp[n], dp[n] + 50000, sor);\n\t\tcout << dp[n][0].first << \" \" << dp[n][0].second << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\npair<int,int> dp[101][100000];\n\nbool solve(){\n  int n, p;\n  \n  scanf(\"%d\", &n);\n\n  if(n == 0) return false;\n  \n  for(int i=0;i<=n;i++){\n    for(int j=0;j<=n*499;j++){\n      dp[i][j] = {-INF, 0};\n    }\n  }\n\n  dp[0][0] = {0, 0};\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d\", &p);\n    int p2 = p;\n    p %= 1000; \n    for(int j=0;j<=i*499;j++){\n      dp[i+1][j + (1000-p)%500] = max(dp[i+1][j+(1000-p)%500],\n                                      {dp[i][j].first + (1 <= p && p <= 500), dp[i][j].second - p2});\n\n      if(p + 500 >= j){\n        dp[i+1][j - (p+500)] = max(dp[i+1][j - (p+500)],\n                                   {dp[i][j].first + 1, dp[i][j].second - p2});\n      }\n      \n      if(p >= 501 && j >= p-500){\n        dp[i+1][j - (p-500)] = max(dp[i+1][j-(p-500)],\n                                   {dp[i][j].first + 1, dp[i][j].second - p2});\n      }\n\n      dp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n    }\n  }\n\n  pair<int,int> ans = {0, 0};\n  \n  for(int i=0;i<=n*499;i++){\n    ans = max(ans, dp[n][i]);\n  }\n\n  printf(\"%d %d\\n\", ans.first, -ans.second);\n\n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\nll n, p, dp[101][50001], sum[101][50001];\n\nint main() {\n  while (scanf(\"%lld\", &n), n) {\n    for (ll j = 1; j <= n*500; j++) dp[0][j] = -10000, sum[0][j] = 100000000000LL;\n    for (ll i = 1; i <= n; i++) {\n      scanf(\"%lld\", &p);\n      ll temp = (1000 - p % 1000);\n      if (temp == 1000) temp = 0;\n      if (temp >= 500) {\n        for (ll j = 0; j < temp-500; j++) dp[i][j] = -10000, sum[i][j] = 100000000000LL;\n        for (ll j = temp-500; j <= n*500; j++) {\n          dp[i][j] = dp[i-1][j-(temp-500)]+1, sum[i][j] = sum[i-1][j-(temp-500)] + p;\n        }\n      } else {\n        for (ll j = 0; j <= n*500; j++) {\n          dp[i][j] = dp[i-1][j], sum[i][j] = sum[i-1][j];\n        }\n        for (ll j = temp; j <= n*500; j++) {\n          if (dp[i][j] < dp[i-1][j-temp]) {\n            dp[i][j] = dp[i-1][j-temp];\n            sum[i][j] = sum[i-1][j-temp] + p;\n          } else if (dp[i][j] == dp[i-1][j-temp]) {\n            sum[i][j] = min(sum[i][j], sum[i-1][j-temp] + p);\n          }\n        }\n        for (ll j = 0; j <= n*500+temp-500; j++) {\n          if (dp[i][j] < dp[i-1][j-temp+500]+1) {\n            dp[i][j] = dp[i-1][j-temp+500]+1;\n            sum[i][j] = sum[i-1][j-temp+500] + p;\n          } else if (dp[i][j] == dp[i-1][j-temp+500]+1) {\n            sum[i][j] = min(sum[i][j], sum[i-1][j-temp+500] + p);\n          }\n        }\n      }\n    }\n    ll ans1 = 0, ans2 = 100000000000LL;\n    for (ll j = 0; j <= n*500; j++) {\n      if (ans1 < dp[n][j]) {\n        ans1 = dp[n][j];\n        ans2 = sum[n][j];\n      } else if (ans1 == dp[n][j]) {\n        ans2 = min(ans2, sum[n][j]);\n      }\n    }\n    printf(\"%lld %lld\\n\", ans1, ans2);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint n;\nvi p;\npii dp[101][55555];\n\npii solve(int shop, int coin)\n{\n\tif (shop == n) return pii(0, 0);\n\tif (dp[shop][coin].first >= 0) return dp[shop][coin];\n\tpii res(0, 0);\n\tchmax(res, solve(shop + 1, coin));\n\tpii tmp;\n\tif (p[shop] % 1000 == 0)\n\t{\n\t\tif (coin >= 500)\n\t\t{\n\t\t\ttmp = solve(shop + 1, coin - 500);\n\t\t\tchmax(res, pii(tmp.first + 1, tmp.second - p[shop]));\n\t\t}\n\t}\n\telse if (p[shop] % 1000 > 500)\n\t{\n\t\ttmp = solve(shop + 1, coin + 1000 - p[shop] % 1000);\n\t\tchmax(res, pii(tmp.first, tmp.second - p[shop]));\n\t\tif (p[shop] % 1000 - 500 <= coin)\n\t\t{\n\t\t\ttmp = solve(shop + 1, coin - (p[shop] % 1000 - 500));\n\t\t\tchmax(res, pii(tmp.first + 1, tmp.second - p[shop]));\n\t\t}\n\t}\n\telse\n\t{\n\t\ttmp = solve(shop + 1, coin + 500 - p[shop] % 1000);\n\t\tchmax(res, pii(tmp.first + 1, tmp.second - p[shop]));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\twhile (cin >> n, n)\n\t{\n\t\tp.resize(n);\n\t\tREP(i, n) cin >> p[i];\n\t\tREP(i, 111)REP(j, 55555) dp[i][j] = pii(-1, -1);\n\t\tpii ans = solve(0, 0);\n\t\tcout << ans.first << \" \" << -ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint dp[64][64][256];\nint n;\nint P[64];\n\nvoid init() {\n  for(int i = 0; i < 64; ++i) {\n    for(int j = 0; j < 64; ++j) {\n      for(int k = 0; k < 256; ++k) {\n        dp[i][j][k] = -1;\n      }\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d\", &P[i]);\n    }\n    dp[0][0][0] = 0;\n    for(int i = 0; i < n; ++i) {\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < 256; ++k) {\n          if( dp[i][j][k] == -1 ) continue;\n          dp[i+1][j][k] = std::max(dp[i+1][j][k], dp[i][j][k]);\n          // 1000\n          int count_1000_2 = (P[i] + 999) / 1000;\n          int rem0 = count_1000_2 * 1000 - P[i];\n          int& next0 = dp[i+1][j + (rem0%1000>=500 ? 1 : 0)][k + count_1000_2];\n          next0 = std::max(next0, dp[i][j][k] + (rem0%1000>=500 ? rem0 - 500 : rem0));\n          //\n          int count_1000 = (P[i] + 999) / 1000;\n          int rem1 = dp[i][j][k] + count_1000 * 1000 - P[i];\n          int& next = dp[i+1][j + (rem1%1000>=500 ? 1 : 0)][k + count_1000];\n          next = std::max(next, rem1%1000>=500 ? rem1 - 500 : rem1);\n          // rem\n          if( dp[i][j][k] > P[i] ) {\n            int rem2 = dp[i][j][k] - P[i];\n            int& next = dp[i+1][j + (rem2%1000>=500 ? 1 : 0)][k];\n            next = std::max(next, (rem2%1000>=500 ? rem2 - 500 : rem2));\n          }\n        }\n      }\n    }\n    // for(int i = 0; i <= 4; ++i) {\n    //   for(int j = 0; j <= 4; ++j) {\n    //     for(int k = 0; k < 6; ++k) {\n    //       printf(\"(i, j, k) = (%d, %d, %d) : %d\\n\", i, j, k, dp[i][j][k]);\n    //     }\n    //   }\n    // }\n    int res = (1 << 28);\n    int max = -1;\n    for(int j = n; j >= 0; --j) {\n      for(int k = 0; k < 256; ++k) {\n        if( dp[n][j][k] == -1 ) continue;\n        int cost = k * 1000 - 500 * j - dp[n][j][k];\n        res = std::min(res, cost);\n      }\n      if( res != (1 << 28) ) {\n        max = j;\n        break;\n      }\n    }\n    printf(\"%d %d\\n\", max, res);\n  }\n         \n        \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> Pi;\n\nint N, P[100];\nPi dp[2][501 * 100];\n//dpは　枚数　コスト　の順番で持つ\nconst int INF = 1145141919;\n\nvoid update(Pi& a, Pi b) {\n\tif (a.first < b.first)a = b;\n\telse if (a.first > b.first);\n\telse {\n\t\tif (a.second > b.second)a = b;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tfor (int i = 0; i < N; i++)cin >> P[i];\n\n\t\tfor (int i = 0; i < 2; i++)for (int j = 0; j <= 500 * 100; j++)dp[i][j] = Pi(0, INF);\n\t\tauto now = dp[0], next = dp[1];\n\n\t\tnow[0] = Pi(0, 0);\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j <= N * 500; j++) {\n\t\t\t\tif (now[j] == Pi(0, INF))continue;\n\n\t\t\t\tif (1 <= P[i] % 1000 && P[i] % 1000 <= 500) {\n\t\t\t\t\t//千円札で払えばかならず１枚手に入る\n\t\t\t\t\tupdate(next[j + 500 - (P[i] % 1000)], Pi(now[j].first + 1, now[j].second + P[i]));\n\t\t\t\t}\n\t\t\t\telse if (P[i] % 1000 == 0) {\n\t\t\t\t\t//何もしない\n\t\t\t\t\tnext[j] = now[j];\n\n\t\t\t\t\t//1000円札＋小銭で、五百円玉がおつりででるように払う\n\t\t\t\t\tif (j >= 500) {\n\t\t\t\t\t\tupdate(next[j - 500], Pi(now[j].first + 1, now[j].second + P[i]));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//何もしない\n\t\t\t\t\tnext[j] = now[j];\n\t\t\t\t\t//千円札で買って、小銭を増やす\n\t\t\t\t\tupdate(next[j + (1000 - (P[i] % 1000))], Pi(now[j].first, now[j].second + P[i]));\n\n\t\t\t\t\t//小銭を使って、五百円玉がおつりででるように払う\n\t\t\t\t\tif (j >= (P[i] % 1000) - 500) {\n\t\t\t\t\t\tupdate(next[j - (P[i] % 1000 - 500)], Pi(now[j].first + 1, now[j].second + P[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tswap(now, next);\n\t\t}\n\n\t\tint coin = 0, cost = 0;\n\t\tfor (int i = 0; i <= N * 500; i++) {\n\t\t\tif (now[i] != Pi(INF, INF)) {\n\t\t\t\tif (coin < now[i].first)coin = now[i].first, cost = now[i].second;\n\t\t\t\telse if (coin == now[i].first && cost > now[i].second)cost = now[i].second;\n\t\t\t}\n\t\t}\n\n\t\tcout << coin << \" \" << cost << endl;\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 2\n#define MAX_C 5001\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nint m[MAX_N];\npii dp[MAX_N][MAX_C];\n\nvoid set_m(vector<int> &p)\n{\n    for (int i = 0; i < (int)p.size(); i++) {    \n        m[i] = ((p[i] - 1) / 1000 + 1) * 1000;\n    }\n}\n\nvoid update(pii &a, pii &b)\n{\n    if (a.first < b.first) {\n        a = b;\n    } else if (a.first == b.first) {\n        if (a.second > b.second) {\n            a = b;\n        }\n    }\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<int> p(N);\n        for (int i = 0; i < N; i++) {\n            cin >> p[i];\n        }\n        \n        set_m(p);\n        \n        memset(dp, -1, sizeof(dp));\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < MAX_C; j++) {\n                dp[i][j] = pii(-1, INF);\n            }\n        }\n        \n        dp[0][0] = pii(0, 0);\n        for (int i = 0; i < N; i++) {\n            int curr = (i & 1), next = !(i & 1);\n            for (int j = 0; j < MAX_C; j++) {\n                if (dp[curr][j].first == -1) continue;\n                \n                update(dp[next][j], dp[curr][j]);\n                \n                for (int k = 0; k <= min(j, 999); k++) {\n                    int pay = m[i] + k;\n                    int change = pay - p[i];                    \n                    int _500 = change / 500;\n                    \n                    if (change < 0 || change >= 1000) continue;                    \n                    \n                    int nc = j - k + change - _500 * 500;\n                    if (nc >= MAX_C) continue;\n                    \n                    pii ncost = pii(dp[curr][j].first + _500,\n                                    dp[curr][j].second + p[i]);                    \n                    \n                    update(dp[next][nc], ncost);\n                }\n            }\n            for (int j = 0; j < MAX_C; j++) {\n                dp[curr][j] = pii(-1, INF);\n            }\n        }\n        \n        pii res = pii(-1, INF);\n        for (int i = 0; i < MAX_C; i++) {\n            update(res, dp[N&1][i]);\n        }\n        cout << res.first << \" \" << res.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 100100100;\n\nint main(){\n\n    while(1){        \n        int n; cin >> n;\n        if(!n) break;\n        vector<int> a(n);\n        for(int i = 0; i < n; i++) cin >> a[i];\n\n        //i番目までの品物を見て、得られた500円玉がj枚で持ってる小銭がk円の時の消費金額の最小値\n        vector<vector<vector<int> > > dp(2, vector<vector<int> > (n + 1, vector<int> (500 * n + 1000, INF)));  \n        dp[0][0][0] = 0;\n        int now = 0;\n        int next = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j <= i; j++){\n                for(int k = 0; k <= 500 * i; k++){\n\n                    //買わない\n                    dp[next][j][k] = min(dp[next][j][k], dp[now][j][k]);\n\n                    //1000で割ったあまりによる場合わけ\n                    if(1 <= a[i] % 1000 && a[i] % 1000 <= 500){\n                        //1000札のみで払うのが最適\n                        //500円獲得\n                        dp[next][j + 1][(500 - a[i] % 1000) + k] = min(dp[next][j + 1][(500 - a[i] % 1000) + k], dp[now][j][k] + a[i]);\n                    }else{\n                        //1000円札のみで払う\n                        //500円玉は獲得できない\n                        dp[next][j][(1000 - a[i] % 1000) % 1000 + k] = min(dp[next][j][(1000 - a[i] % 1000) % 1000 + k], dp[now][j][k] + a[i]);\n\n                        //小銭を駆使して500円玉を獲得\n                        int need = a[i] % 1000 - 500;\n                        if(need == -500) need = 500;\n                        if(k - need >= 0) dp[next][j + 1][k - need] = min(dp[next][j + 1][k - need], dp[now][j][k] + a[i]);\n                    }\n                }\n            }\n            swap(now, next);\n        }\n\n        int ans1 = 0, ans2 = INF;\n        for(int j = 0; j <= n; j++){\n            for(int k = 0; k <= 500 * n; k++){\n                if(dp[now][j][k] != INF){\n                    if(ans1 < j || (ans1 == j && ans2 > dp[now][j][k])){\n                        ans1 = j;\n                        ans2 = dp[now][j][k];\n                    }\n                }\n            }\n        }\n\n        cout << ans1 << \" \" << ans2 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nint c[5]={100,50,10,5,1};\nmap<vector<int>,P> dp[105];\npair<int,vector<int> > charge(int x){\n\tx %= 1000;\n\tvector<int> v(5,0);\n\tint f = x/500;\n\tx -= f*500;\n\tfor(int i=0;i<5;i++){\n\t\tv[i]=x/c[i];\n\t\tx -= v[i]*c[i];\n\t}\n\tassert(x==0);\n\treturn make_pair(f,v);\n}\nvoid dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}\nP dfs(int id,vector<int> vec){\n\t/*cout << \"call : \" << id << endl;\n\tcout << \"vec : \";\n\tdump(vec);\n\tcout << endl;*/\n\tvector<int> tmp = vec;\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tmap<vector<int>,P>::iterator it;\n\tit = dp[id].find(vec);\n\tif(it!=dp[id].end()){\n\t\treturn (it->sec);\n\t}\n\tP res = dfs(id+1,vec);\n\tint h = ((p[id]-1)/1000+1)*1000;;\n\tfor(int i=0;i<5;i++){\n\t\twhile(vec[i]>0&&h-p[id]+c[i]<1000){\n\t\t\tvec[i]--;\n\t\t\th += c[i];\n\t\t}\n\t}\n\tpair<int,vector<int> > ch = charge(h-p[id]);\n\tfor(int i=0;i<5;i++)vec[i] += (ch.sec)[i];\n\tP res2 = dfs(id+1,vec);\n\tres2.fi += ch.fi;\n\tres2.sec -= p[id];\n\tdp[id][tmp]=max(res,res2);\n\t/*cout << \"end : \" << id << endl;\n\tcout << \"vec : \";\n\tdump();\n\tcout << \"result : \" << dp[id][vec].fi << ' ' << -dp[id][vec].sec << endl;*/\n\treturn dp[id][tmp];\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<105;i++)dp[i].clear();\n\tvector<int> v;\n\tfor(int i=0;i<5;i++)v.pb(0);\n\tP ans = dfs(0,v);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nint n;\nint a[100];\npair<int, int> dp[110][500];\n\nint main(){\n  while (cin >> n, n){\n    rep(i, n) cin >> a[i];\n    rep(i, 110) rep(j, 500) dp[i][j] = {-inf, 0};\n    dp[0][0] = {0, 0};\n    rep(i, n) rep(j, 500){\n      int x = j;\n      while (x < a[i]) x += 1000;\n      x -= a[i];\n      chmax(dp[i + 1][j], dp[i][j]);\n      chmax(dp[i + 1][x % 500], make_pair(dp[i][j].first + (x >= 500), dp[i][j].second + a[i]));\n    }\n    pair<int, int> res = {-1, -1};\n    rep(i, 500){\n      auto p = make_pair(dp[n][i].first, -dp[n][i].second);\n      chmax(res, p);\n    }\n    cout << res.first << \" \" << -res.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint N;\npair<int, int> dp[100][50000];\nvector<int> P;\n\npair<int, int> dfs(int idx, int ch) {\n    if (idx == N) return make_pair(0, 0);\n    if (dp[idx][ch].first >= 0) return dp[idx][ch];\n\n    // 買わない\n    dp[idx][ch] = dfs(idx + 1, ch);\n\n    int p = P[idx] % 1000;\n\n    if (p == 0) {\n        if (ch >= 500) {\n            // 小銭から500円玉を回収\n            auto ret = dfs(idx + 1, ch - 500);\n            ret.first += 1, ret.second -= P[idx];\n            dp[idx][ch] = max(dp[idx][ch], ret);\n        }\n    } else if (p <= 500) {\n        // 1000円投げて500円玉を回収\n        auto ret = dfs(idx + 1, ch + 1000 - p - 500);\n        ret.first += 1, ret.second -= P[idx];\n        dp[idx][ch] = max(dp[idx][ch], ret);\n    } else {\n        // 1000円で小銭を回収\n        auto ret = dfs(idx + 1, ch + 1000 - p);\n        ret.second -= P[idx];\n        dp[idx][ch] = max(dp[idx][ch], ret);\n\n        int need = p - 500;\n        if (need <= ch) {\n            // 小銭を投げて500円玉を回収\n            auto ret = dfs(idx + 1, ch - need);\n            ret.first += 1;\n            ret.second -= P[idx];\n            dp[idx][ch] = max(dp[idx][ch], ret);\n        }\n    }\n    return dp[idx][ch];\n}\n\nbool solve() {\n    fill(dp[0], dp[100], make_pair(-1, -1));\n    cin >> N;\n    if (N == 0) return false;\n\n    P.resize(N);\n    for (auto& p : P) {\n        cin >> p;\n    }\n    auto ans = dfs(0, 0);\n    cout << ans.first << \" \" << -ans.second << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nstruct State {\n\tint fives, pay;\n};\n\nState comp(const State s1, const State s2) {\n\tif(s1.fives != s2.fives)\n\t\treturn s1.fives > s2.fives ? s1 : s2;\n\treturn s1.pay < s2.pay ? s1 : s2;\n}\n\n\nconst int INF = 1 << 25;\nconst int MAX = 100010;\nState dp[101][MAX];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile(cin >> n, n) {\n\n\t\tfor(int i = 0; i < n + 1; i++) {\n\t\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\t\tdp[i][j].fives = -1;\n\t\t\t\tdp[i][j].pay = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][0].fives = 0;\n\t\tdp[0][0].pay = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint p, pay;\n\t\t\tcin >> pay;\n\n\t\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\t\tif(dp[i][j].fives == -1) continue;\n\t\t\t\tp = pay % 1000;\n\t\t\t\t// ??????\n\t\t\t\tdp[i + 1][j] = comp(dp[i + 1][j], dp[i][j]);\n\t\t\t\t// ?????????\n\t\t\t\tif(p != 0) {\n\t\t\t\t\tif(1000 - p >= 500) {// 500?????????\n\t\t\t\t\t\tint nj = j + 500 - p;\n\t\t\t\t\t\tState ns = State{ dp[i][j].fives + 1, dp[i][j].pay + pay };\n\t\t\t\t\t\tdp[i + 1][nj] = comp(dp[i + 1][nj], ns);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint nj = j + 1000 - p;\n\t\t\t\t\t\tState ns = State{ dp[i][j].fives, dp[i][j].pay + pay };\n\t\t\t\t\t\tdp[i + 1][nj] = comp(dp[i + 1][nj], ns);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ?????£??????\n\t\t\t\tif(p <= 500) {\n\t\t\t\t\tif(p + 500 <= j) {\n\t\t\t\t\t\tint nj = j - (p + 500);\n\t\t\t\t\t\tState ns = State{ dp[i][j].fives + 1, dp[i][j].pay + pay };\n\t\t\t\t\t\tdp[i + 1][nj] = comp(dp[i + 1][nj], ns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(p % 500 <= j) {\n\t\t\t\t\t\tint nj = j - p % 500;\n\t\t\t\t\t\tState ns = State{ dp[i][j].fives + 1, dp[i][j].pay + pay };\n\t\t\t\t\t\tdp[i + 1][nj] = comp(dp[i + 1][nj], ns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tState ans = State{ -1, INF };\n\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\tif(dp[n][j].fives != -1) {\n\t\t\t\tans = comp(ans, dp[n][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ans.fives << \" \" << ans.pay << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nint c[5]={100,50,10,5,1};\nint encode(vector<int> v){\n\tint S = 0;\n\tfor(int i=0;i<v.size();i++){\n\t\tS = S*10+v[i];\n\t}\n\treturn S;\n}\nvector<int> decode(int S){\n\tvector<int> v;\n\tint x = 10000;\n\tfor(int i=0;i<5;i++){\n\t\tv.pb(S/x);\n\t\tS %= x;\n\t\tx /= 10;\n\t}\n\treturn v;\n}\nmap<int,P> dp[105];\npair<int,vector<int> > charge(int x){\n\tx %= 1000;\n\tvector<int> v(5,0);\n\tint f = x/500;\n\tx -= f*500;\n\tfor(int i=0;i<5;i++){\n\t\tv[i]=x/c[i];\n\t\tx -= v[i]*c[i];\n\t}\n\t//assert(x==0);\n\treturn make_pair(f,v);\n}\n/*void dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}*/\nP dfs(int id,int V){\n\t/*cout << \"call : \" << id << endl;\n\tcout << \"vec : \";\n\tdump(vec);\n\tcout << endl;*/\n\tint tmp = V;\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tmap<int,P>::iterator it;\n\tit = dp[id].find(V);\n\tif(it!=dp[id].end()){\n\t\treturn (it->sec);\n\t}\n\tP res = dfs(id+1,V);\n\tvector<int> vec = decode(V);\n\tint h = ((p[id]-1)/1000+1)*1000;;\n\tfor(int i=0;i<5;i++){\n\t\twhile(vec[i]>0&&h-p[id]+c[i]<1000){\n\t\t\tvec[i]--;\n\t\t\th += c[i];\n\t\t}\n\t}\n\tpair<int,vector<int> > ch = charge(h-p[id]);\n\tfor(int i=0;i<5;i++)vec[i] += (ch.sec)[i];\n\tP res2 = dfs(id+1,encode(vec));\n\tres2.fi += ch.fi;\n\tres2.sec -= p[id];\n\tdp[id][tmp]=max(res,res2);\n\t/*cout << \"end : \" << id << endl;\n\tcout << \"vec : \";\n\tdump();\n\tcout << \"result : \" << dp[id][vec].fi << ' ' << -dp[id][vec].sec << endl;*/\n\treturn dp[id][tmp];\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<105;i++)dp[i].clear();\n\tP ans = dfs(0,0);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N;\nvoid solve() {\n    vector<int> shop(N);\n    for (auto& i : shop) cin >> i;\n\n    vector<int> diff(N);\n    for (int i = 0; i < N; i++) {\n        int d = shop[i] % 1000;\n        if (0 < d && d <= 500) diff[i] = 0;\n        else if (d > 500) diff[i] = d - 500;\n        else diff[i] = 500;\n    }\n\n    vector<map<int,P> > dp(N + 1);\n    dp[0][0] = P(0, 0);\n    for (int i = 0; i < N; i++) {\n        for (auto coin : dp[i]) {\n            if (dp[i+1].find(coin.first) == dp[i+1].end()) dp[i+1][coin.first] = coin.second;\n            else dp[i+1][coin.first] = max(dp[i+1][coin.first], coin.second);\n            if (diff[i] == 0) {\n                P ncoin = P(coin.second.first + 1, coin.second.second - shop[i]);\n                int f = coin.first + 500 - (shop[i] % 500);\n                if (dp[i+1].find(f) == dp[i+1].end()) dp[i+1][f] = ncoin;\n                else dp[i+1][f] = max(dp[i+1][f], ncoin);\n            } else {\n                if (diff[i] <= coin.first) {\n                    P ncoin = P(coin.second.first + 1, coin.second.second - shop[i]);\n                    int f = coin.first - diff[i];\n                    if (dp[i+1].find(f) == dp[i+1].end()) dp[i+1][f] = ncoin;\n                    else dp[i+1][f] = max(dp[i+1][f], ncoin);\n                }\n\n                P pcoin = P(coin.second.first, coin.second.second - shop[i]);\n                int f_ = coin.first + (shop[i] % 1000 ? 1000 - shop[i] % 1000 : 0);\n                if (dp[i+1].find(f_) == dp[i+1].end()) dp[i+1][f_] = pcoin;\n                else dp[i+1][f_] = max(dp[i+1][f_], pcoin);\n            }\n        }\n    }\n\n    P ans(0, 0);\n    for (auto p : dp[N]) {\n        ans = max(ans, p.second);\n    }\n\n    cout << ans.first << \" \" << -ans.second << endl;\n}\n\nint main() {\n    while (cin >> N, N) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define fi first\n#define sc second\n#define mp make_pair\npair<int,int> dp[105][100005];\nint n,p[105];\nvoid chh(pair<int,int> &a,pair<int,int> &b){\n\tif(a.fi < b.fi) a = b;\n\telse if(a.fi == b.fi) a.sc = min(a.sc,b.sc);\n}\nint main(){\n\twhile(1){\n\t\tcin>>n; if(!n) return 0;\n\t\tfor(int i=1;i<=n;i++) cin>>p[i];\n\t\tfor(int i=0;i<105;i++) for(int j=0;j<100005;j++) dp[i][j] = mp(-10000,100000000);\n\t\tdp[0][0] = mp(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<=1000*i;j++){\n\t\t\t\tif(dp[i][j].fi < 0) continue; //cout <<i << \" \" <<j<< endl;\n\t\t\t\tif(dp[i+1][j].fi < dp[i][j].fi) dp[i+1][j] = dp[i][j];\n\t\t\t\telse if(dp[i+1][j].fi == dp[i][j].fi) dp[i+1][j].sc = min(dp[i+1][j].sc,dp[i][j].sc);\n\t\t\t\t\n\t\t\t\tif(p[i+1]%1000 == 0){\n\t\t\t\t\tif(j>=500){\n\t\t\t\t\t\tpair<int,int> Q=mp(dp[i][j].fi+1,dp[i][j].sc+p[i+1]) ;\n\t\t\t\t\t\tchh(dp[i+1][j-500],Q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(p[i+1]%1000 <= 500){\n\t\t\t\t\tpair<int,int> Q=mp(dp[i][j].fi+1,dp[i][j].sc+p[i+1]) ;\n\t\t\t\t\tchh(dp[i+1][j+500-(p[i+1]%1000)],Q);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(j+500-(p[i+1]%1000)>=0){\n\t\t\t\t\t\tpair<int,int> Q=mp(dp[i][j].fi+1,dp[i][j].sc+p[i+1]) ;\n\t\t\t\t\t\tchh(dp[i+1][j+500-(p[i+1]%1000)],Q);\n\t\t\t\t\t}\n\t\t\t\t\tpair<int,int> Q=mp(dp[i][j].fi,dp[i][j].sc+p[i+1]) ;\n\t\t\t\t\tchh(dp[i+1][j+1000-(p[i+1]%1000)],Q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int,int> ans = mp(-10000,100000000);\n\t\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<100005;j++){\n\t\t\tif(ans.fi < dp[i][j].fi) ans = dp[i][j];\n\t\t\telse if(ans.fi == dp[i][j].fi) ans.sc = min(ans.sc,dp[i][j].sc);\n\t\t}}\n\t\tcout <<ans.fi<<\" \" << ans.sc << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\n\nbool cmp(pair< int, int > a, pair< int, int > b)\n{\n  if(a.first != b.first) return(a.first > b.first);\n  return(a.second < b.second);\n}\nint main()\n{\n  int N, p[100];\n  \n  while(scanf(\"%d\", &N), N) {\n    for(int i = 0; i < N; i++) {\n      scanf(\"%d\", &p[i]);\n    }\n    \n    pair< int, int > dp[2][50001];\n    fill_n(*dp, 2 * 50001, make_pair(-INF, INF));\n    pair< int, int > *now = dp[0], *nxt = dp[1];\n    \n    now[0] = {0, 0};\n    for(int i = 0; i < N; i++) {\n      int mod = p[i] % 1000;\n      if(1 <= mod && mod <= 500) {\n        int rev = 1000 - mod - 500;\n        for(int j = 50000; j >= rev; j--) {\n          nxt[j] = min(nxt[j], {now[j - rev].first + 1, now[j - rev].second + p[i]}, cmp);\n        }\n      } else {\n        int rev = (1000 - mod) % 1000;\n        int need = (mod + 500) % 1000;\n        for(int j = 50000; j >= 0; j--) {\n          nxt[j] = min(nxt[j], now[j], cmp);\n        }\n        for(int j = 50000; j >= rev; j--) {\n          nxt[j] = min(nxt[j], {now[j - rev].first, now[j - rev].second + p[i]}, cmp);\n        }\n        for(int j = need; j <= 50000; j++) {\n          nxt[j - need] = min(nxt[j - need], {now[j].first + 1, now[j].second + p[i]}, cmp);\n        }\n      }\n      swap(now, nxt);\n      for(int j = 0; j <= 50000; j++) nxt[j] = {-INF, INF};\n    }\n    auto p = *min_element(now, now + 50000, cmp);\n    printf(\"%d %d\\n\", p.first, p.second);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint dp[128][128][1024];\nint n;\nint P[128];\n\nvoid init() {\n  for(int i = 0; i < 128; ++i) {\n    for(int j = 0; j < 128; ++j) {\n      for(int k = 0; k < 1024; ++k) {\n        dp[i][j][k] = -1;\n      }\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d\", &P[i]);\n    }\n    dp[0][0][0] = 0;\n    for(int i = 0; i < n; ++i) {\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < 1024; ++k) {\n          if( dp[i][j][k] == -1 ) continue;\n          dp[i+1][j][k] = std::max(dp[i+1][j][k], dp[i][j][k]);\n          // 1000\n          int count_1000_2 = (P[i] + 999) / 1000;\n          int rem0 = count_1000_2 * 1000 - P[i];\n          int& next0 = dp[i+1][j + (rem0%1000>=500 ? 1 : 0)][k + count_1000_2];\n          next0 = std::max(next0, dp[i][j][k] + (rem0%1000>=500 ? rem0 - 500 : rem0));\n          //\n          int count_1000 = (P[i] + 999) / 1000;\n          int rem1 = dp[i][j][k] + count_1000 * 1000 - P[i];\n          int& next = dp[i+1][j + (rem1>=500 ? 1 : 0)][k + count_1000];\n          next = std::max(next, rem1>=500 ? rem1 - 500 : rem1);\n          // //\n          // int rem11 = rem1 % 1000;\n          // int& next1 = dp[i+1][j + (rem11%1000>=500 ? 1 : 0)][k + count_1000];\n          // next1 = std::max(next1, rem11%1000>=500 ? rem11 - 500 : rem11);\n          // rem\n          if( dp[i][j][k] > P[i] ) {\n            int rem2 = dp[i][j][k] - P[i];\n            int& next = dp[i+1][j + (rem2%1000>=500 ? 1 : 0)][k];\n            next = std::max(next, (rem2%1000>=500 ? rem2 - 500 : rem2));\n          }\n        }\n      }\n    }\n    for(int i = 0; i < 6; ++i) {\n      for(int j = 0; j < 6; ++j) {\n        for(int k = 0; k < 6; ++k) {\n          //printf(\"(i, j, k) = (%d, %d, %d) : %d\\n\", i, j, k, dp[i][j][k]);\n        }\n      }\n    }\n    int res = (1 << 28);\n    int max = -1;\n    for(int j = n; j >= 0; --j) {\n      for(int k = 0; k < 1024; ++k) {\n        if( dp[n][j][k] == -1 ) continue;\n        int cost = k * 1000 - 500 * j - dp[n][j][k];\n        res = std::min(res, cost);\n      }\n      if( res != (1 << 28) ) {\n        max = j;\n        break;\n      }\n    }\n    printf(\"%d %d\\n\", max, res);\n  }\n         \n        \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vii;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip> vip;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 :1e9;\nint dp[110][110][1010];\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi in(n);\n\t\trep(i,n)cin>>in[i];\n\t\trep(i,110)rep(j,110)rep(k,1010)dp[i][j][k]=inf;\n\t\tdp[0][0][0]=0;\n\t\trep(i,n)rep(j,n)rep(k,1010)if(dp[i][j][k]!=inf){\n\t\t\tdp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k]);\n\t\t\tint J=j,K=k,a=in[i]%1000;\n\t\t\tif(k<=a&&a){\n\t\t\t\tK=1000+k-a;\n\t\t\t\tif(K>=500)J++,K-=500;\n\t\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t}else if(k>a&&a){\n\t\t\t\tif(500>=a){\n\t\t\t\t\tK=k+1000-a;\n\t\t\t\t\tJ++;\n\t\t\t\t\tK-=500;\n\t\t\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\t}else{\n\t\t\t\t\tK=k-(a-500);\n\t\t\t\t\tJ++;\n\t\t\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\tif(K>=500)K-=500,J++;\n\t\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tint outc=0,out=inf;\n\t\trep(i,n+1)rep(j,1010)if(dp[n][i][j]!=inf){\n\t\t\tif(outc<i){\n\t\t\t\toutc=i;\n\t\t\t\tout=dp[n][i][j];\n\t\t\t}else if(outc==i)\n\t\t\t\tout=min(out,dp[n][i][j]);\n\t\t}\n\t\tcout<<outc<<\" \"<<out<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORR(i, b, a) for (int i = (a - 1); i >= (b); i--)\n#define ALL(vec) (vec).begin(), (vec).end()\nint get_int() {\n  int tmp;\n  cin >> tmp;\n  return tmp;\n}\nint main() {\n  while (true) {\n    const int n = get_int();\n    if (n == 0) return 0;\n    auto dp = vector<vector<int>>(n + 10, vector<int>(5 * n + 50, -1));\n    dp[0][0] = 0;\n    REP(ni, n) {\n      auto p = get_int();\n      int rest = p % 1000;\n      int sheet = p / 1000;\n      if (rest == 0) {\n        FORR(i, 0, n + 1) FORR(j, 0, 5 * n + 1) {\n          // 小銭と1000円で買う\n          if (i - 1 >= 0 and j - sheet + 1 >= 0 and\n              dp[i - 1][j - sheet + 1] >= 0) {\n            int buy = dp[i - 1][j - sheet + 1] - 500;\n            dp[i][j] = max(dp[i][j], buy);\n          }\n        }\n      } else if (rest > 500) {\n        FORR(i, 0, n + 1) FORR(j, 0, 5 * n + 1) {\n          // 1000円で買う (小銭のみ得る)\n          if (j - 1 - sheet >= 0 and dp[i][j - 1 - sheet] >= 0) {\n            int buy = dp[i][j - 1 - sheet] + 1000 - rest;\n            dp[i][j] = max(dp[i][j], buy);\n          }\n          // 小銭と1000円で買う\n          if (i - 1 >= 0 and j - sheet >= 0 and dp[i - 1][j - sheet] >= 0) {\n            int buy = dp[i - 1][j - sheet] - (rest - 500);\n            dp[i][j] = max(dp[i][j], buy);\n          }\n        }\n      } else {\n        // 買うに決まっている,ついでにuse_get円得ちゃう\n        int use_get = 500 - rest;\n        FORR(i, 1, n + 1) FORR(j, sheet, 5 * n + 1) {\n          if (dp[i - 1][j - sheet] < 0) continue;\n          dp[i][j] = max(dp[i][j], dp[i - 1][j - sheet] + use_get);\n        }\n      }\n    }\n    [&]() {\n      // C++クソでは\n      FORR(i, 0, n + 1) {\n        int min_val = 10000000;\n        bool is_ok = false;\n        FOR(j, 0, 5 * n + 1) {\n          if (dp[i][j] == -1) continue;\n          auto val = -(dp[i][j] - (500 * i) - (1000 * j));\n          if (min_val > val) {\n            min_val = val;\n            is_ok = true;\n          }\n        }\n        if (is_ok) {\n          cout << i << \" \" << min_val << endl;\n          return;\n        }\n      }\n    }();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n\nconst int N=100;\n\nint n;\nint p[N];\nint DP[N+3][N+3][N*5+3];//[店][500円玉枚数][使った1000円札枚数] = 小銭 の最大化\n\nvoid init_dp(){\n    REP(i,N+3){\n        REP(j,N+3){\n            REP(k,N*5+3){\n                DP[i][j][k] = -1;\n            }\n        }\n    }\n}\n\nvoid print_dp(int n){\n    REP(i,n){\n        REP(j,n){\n            REP(k,n*5){\n                if(DP[i][j][k]!=-1){\n                    cout<<\"i:\"<<i<<\" j:\"<<j<<\" k:\"<<k<<\" dp:\"<<DP[i][j][k]<<endl;\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    while(true){\n        cin>>n;\n        if(n==0){\n            break;\n        }\n        REP(i,n){\n            cin>>p[i];\n        }\n\n        init_dp();\n\n        int pr=p[0];\n\n        int maxgo=0;//500円玉の最大枚数\n\n        DP[0][0][0] = 0;\n\n        //店1以降\n        for(int i=0;i<n;++i){\n            pr=p[i];\n            REP(j,N){//500円玉の数\n                REP(k,N*5){//1000円札の枚数\n                    int now = DP[i][j][k];\n                    if( now != -1){\n                        //買う場合\n                        //1〜500円\n                        if((pr-1)%1000 <500){\n                            DP[i+1][j+1][k + (pr-1)/1000 +1] = max(now + ((pr-1)/1000 +1)*1000 - pr - 500, DP[i+1][j+1][k + (pr-1)/1000 +1]);\n                            maxgo=max(maxgo,j+1);\n                        }\n                        //0円, 501〜999円\n                        //残金込で500円が作れる場合\n                        else if( 1000*((pr-1)/1000 + 1) - pr + DP[i][j][k] >= 500 ){\n                            DP[i+1][j+1][k + pr/1000 +1] = max(now -( (pr%1000) - 500 ), DP[i+1][j+1][k + pr/1000 +1]);\n                            maxgo=max(maxgo,j+1);\n                        }\n                        //500円が作れない場合\n                        else {\n                            DP[i+1][j][k + (pr-1)/1000 + 1] = max(now + ((pr-1)/1000 +1)*1000 - pr, DP[i+1][j][k + (pr-1)/1000 + 1]);\n                        }\n\n                        //買わない場合\n                        DP[i+1][j][k] = max(now, DP[i+1][j][k]); \n                    }\n                }\n            }\n        }\n        //print_dp(n+1);\n        int used = 5*N*1000;\n        REP(k, N*5){\n            if(DP[n][maxgo][k] != -1){\n                used = min(used, k*1000 - DP[n][maxgo][k] - 500*maxgo);\n            }\n        }\n        cout<<maxgo<<\" \"<<used<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// i, 500, 100, 50, 10, 5, 1\nint dp[110][110][10][2][5][2][5];\nint p[110];\nint n;\n\nvoid update(int &a, int b) {\n    a = min(a, b);\n}\n\nint calmoney(int b, int c, int d, int e, int f) {\n    return 100*b + 50*c + 10*d + 5*e + f;\n}\n\nvoid debugprint(int mode, int i, int a, int b, int c, int d, int e, int f) {\n    printf(\"debug(%lld): dp[%lld][%lld][%lld][%lld][%lld][%lld][%lld] = %lld\\n\", mode, i, a, b, c, d, e, f, dp[i][a][b][c][d][e][f]);\n}\n\nsigned main() {\n    while(cin >> n, n) {\n        rep(i,0,n) cin >> p[i];\n        repq(i,0,n) rep(a,0,110) rep(b,0,10) rep(c,0,2) rep(d,0,5) rep(e,0,2) rep(f,0,5)\n            dp[i][a][b][c][d][e][f] = INF;\n        dp[0][0][0][0][0][0][0] = 0;\n        rep(i,0,n) rep(a,0,110) rep(b,0,10) rep(c,0,2) rep(d,0,5) rep(e,0,2) rep(f,0,5) {\n            if(dp[i][a][b][c][d][e][f] == INF) continue;\n            int coins = calmoney(b, c, d, e, f);\n            int mo = p[i] % 1000;\n\n            // do not buy\n            update(dp[i+1][a][b][c][d][e][f], dp[i][a][b][c][d][e][f]);\n            \n            // use 500-yen\n            if(coins + 500 >= mo) {\n                int ra = coins + 500 - mo;\n                int na = ra / 500; ra -= 500 * na;\n                int nb = ra / 100; ra -= 100 * nb;\n                int nc = ra /  50; ra -=  50 * nc;\n                int nd = ra /  10; ra -=  10 * nd;\n                int ne = ra /   5; ra -=   5 * ne;\n                int nf = ra;\n                if(a-1+na >= 0) {\n                    update(dp[i+1][a-1+na][nb][nc][nd][ne][nf], dp[i][a][b][c][d][e][f] + p[i]);\n                    // debugprint(1, i+1, a-1+na, nb, nc, nd, ne, nf);\n                }\n            }\n\n            // do not use 500-yen\n            repq(x,0,b) {\n                int ra = (coins - 100*x + 1000 - mo) % 1000;\n                int na = ra / 500; ra -= 500 * na;\n                int nb = ra / 100; ra -= 100 * nb; nb += x;\n                int nc = ra /  50; ra -=  50 * nc;\n                int nd = ra /  10; ra -=  10 * nd;\n                int ne = ra /   5; ra -=   5 * ne;\n                int nf = ra;\n                if(nb < 10) {\n                    update(dp[i+1][a+na][nb][nc][nd][ne][nf], dp[i][a][b][c][d][e][f] + p[i]);\n                    // debugprint(2, i+1, a+na, nb, nc, nd, ne, nf);\n                }\n            }\n        }\n\n        int ansa = -1, ansb = INF;\n        rep(a,0,110) rep(b,0,10) rep(c,0,2) rep(d,0,5) rep(e,0,2) rep(f,0,5) {\n            int val = dp[n][a][b][c][d][e][f];\n            if(val != INF) {\n                // debugprint(3, n, a, b, c, d, e, f);\n                if(a > ansa) {\n                    ansa = a;\n                    ansb = val;\n                }\n                else if(a == ansa && ansb > val) {\n                    ansb = val;\n                }\n            }\n        }\n        printf(\"%lld %lld\\n\", ansa, ansb);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nusing namespace std;\nconst int INF = 1e7;\ntypedef pair<int,int> P;\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<vector<P>> dp(n+1,vector<P>(55000,P(0,-INF)));\n    dp[0][0]=P(0,0);\n    for(int i=0;i<n;i++){\n      int p;\n      cin >> p;\n      for(int j=0;j<=50000;j++){\n\tif(dp[i][j].second<=-INF)\n\t  continue;\n\tdp[i+1][j]=max(dp[i+1][j], dp[i][j]);\n\tint fee=(p+999)/1000*1000;\n\tint back=fee-p;\n\tint get= back+j>=500 ? 1 : 0;\n\tint rest=(back+j)-get*500;\n\t//cout << fee << \" \" << back << \" \" << get << \" \" << rest << endl;\n\tdp[i+1][rest]=max(dp[i+1][rest], P(dp[i][j].first+get,dp[i][j].second-p));\n      }\n    }\n    P ans=P(0,-INF);\n    for(int i=0;i<50000;i++)\n      ans=max(ans,dp[n][i]);\n    cout << ans.first << \" \" << -ans.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int yui = 0; yui < n; yui++ ){ cout << x[yui] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ long long int x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\nconst int N = 50010;\n\nint dp[2][110][N];\n\nint n;\nint p[128];\n\nint main(){\n\n  while( 1 ){\n    n = in();\n    if( n == 0 ){\n      break;\n    }\n    \n    REP( i , n ){\n      p[i] = in();\n    }\n\n    REP( i , 2 ){\n      REP( j , 110 ){\n        REP( k , N ){\n          dp[i][j][k] = INF;\n        }\n      }\n    }\n\n    dp[0][0][0] = 0;\n\n    REP( i , n ){\n      REP( j , i+1 ){\n        REP( k , (i+1)*1000+1 ){\n          dp[(i+1)&1][j][k] = INF;\n        }\n      }\n      REP( j , i+1 ){\n        REP( k , i*1000+1 ){\n          if( dp[i&1][j][k] == INF ){\n            continue;\n          }\n          int nec = 0;\n          int get = 500 - ( p[i] % 1000 );\n          if( p[i] % 1000 == 0 ){\n            nec = 500;\n            get = 0;\n          } else if( p[i] % 1000 > 500 ){\n            nec = p[i] % 1000 - 500;\n            get = 0;\n          }\n\n          // get\n          if( nec <= k ){\n            int nk = k-nec+get;\n            if( 0 <= nk && nk < N ){\n              chmin( dp[(i+1)&1][j+1][nk], dp[i&1][j][k] + p[i] );\n            }\n          }\n        \n          // not get\n          get = 1000 - ( p[i] % 1000 );\n          if( p[i] % 1000 == 0 ){\n            get = 0;\n          }\n          if( k+get < N ){\n            chmin( dp[(i+1)&1][j][k+get], dp[i&1][j][k] + p[i] );\n          }\n          chmin( dp[(i+1)&1][j][k], dp[i&1][j][k] );\n        }\n      }\n    }\n\n    int mg = 0;\n    int mv = 0;\n\n    REP( i , n+1 ){\n      REP( j , 50010 ){\n        if( dp[n&1][i][j] < INF ){\n          if( mg < i ){\n            mg = i;\n            mv = dp[n&1][i][j];\n          } else if( mg == i ){\n            chmin( mv , dp[n&1][i][j] );\n          }\n        }\n      }\n    }\n\n    printf( \"%d %d\\n\" , mg , mv );\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nconst vector<int> coin = {1, 5, 10, 50, 100, 500, 1000};\nconst vector<int> exchange_ = {5, 2, 5, 2, 5};\n\nvector<int> getCharge(int price){\n\tint charge = 5000 - price;\n\tvector<int> res(coin.size(),0);\n\tres[6] = -5;\n\n\tfor(int i = coin.size() - 1; i >= 0; i--){\n\t\tres[i] += charge / coin[i];\n\t\tcharge %= coin[i];\n\t}\n\treturn res;\n}\n\nvoid mergeCharge(vector<int>& charge, vector<int>& wallet){\n\trep(i,coin.size()){\n\t\twallet[i] += charge[i];\n\t}\n\n\trep(i,4){\n\t\twallet[i + 1] += wallet[i] / exchange_[i];\n\t\twallet[i] %= exchange_[i];\n\t}\n\tif(charge[5] == 0 and wallet[4] >= 5){\n\t\twallet[4] -= 5;\n\t\twallet[5]++;\n\t}\n}\n\nint getTotalPrice(int y1, int y5, int y10, int y50, int y100, int y1000){\n\tint res = (500 - y1000) * 1000;\n\tres -= y1 + y5 * 5 + y10 * 10 + y50 * 50 + y100 * 100;\n\treturn res;\n}\n\nint dp[5][2][5][2][501][501];\nint nxt[5][2][5][2][501][501];\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tvector<int> p(n);\n\t\trep(i,n){\n\t\t\tcin >> p[i];\n\t\t}\n\n\t\tvector<vector<int>> charge(n);\n\t\trep(i,n){\n\t\t\tcharge[i] = getCharge(p[i]);\n\t\t\t//cout << charge[i] << endl;\n\t\t}\n\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tmemset(nxt, -1, sizeof(nxt));\n\n\t\tdp[0][0][0][0][0][500] = 0;\n\t\trep(i,n){\n\t\t\trep(y1,5) rep(y5,2) rep(y10,5) rep(y50,2) rep(y100,501) for(int y1000 = 500; y1000 >= 5; y1000--) {\n\t\t\t\tif(dp[y1][y5][y10][y50][y100][y1000] == -1) continue;\n\n\t\t\t\tnxt[y1][y5][y10][y50][y100][y1000] = max(\n\t\t\t\t\t\tnxt[y1][y5][y10][y50][y100][y1000],\n\t\t\t\t\t\tdp[y1][y5][y10][y50][y100][y1000]);\n\n\t\t\t\tvector<int> w = {y1, y5, y10, y50, y100, dp[y1][y5][y10][y50][y100][y1000], y1000};\n\t\t\t\tmergeCharge(charge[i], w);\n\t\t\t\tnxt[w[0]][w[1]][w[2]][w[3]][w[4]][w[6]] = max(nxt[w[0]][w[1]][w[2]][w[3]][w[4]][w[6]], w[5]);\n\t\t\t\t//cout << w << endl;\n\t\t\t}\n\t\t\tmemcpy(dp, nxt, sizeof(nxt));\n\t\t\tmemset(nxt, -1, sizeof(nxt));\n\t\t}\n\n\t\tint y500 = 0, pay = 1e9;\n\t\trep(y1,5) rep(y5,2) rep(y10,5) rep(y50,2) rep(y100,5) for(int y1000 = 500; y1000 >= 5; y1000--) {\n\t\t\tint c = dp[y1][y5][y10][y50][y100][y1000];\n\t\t\tint t = getTotalPrice(y1, y5, y10, y50, y100, y1000);\n\t\t\tif(y500 < c){ \n\t\t\t\ty500 = c;\n\t\t\t\tpay = t;\n\t\t\t}else if(y500 == c and pay > t){\n\t\t\t\tpay = t;\n\t\t\t}\n\t\t}\n\t\tcout << y500 << ' ' << pay - y500 * 500 << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nP dp[100][50005];\nint p[100];\nint main(){\n  int n;\n  while(cin>>n && n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++)cin>>p[i];\n    dp[0][0] = P(0,0);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<50000;j++){\n        if(dp[i][j]==P(-1,-1)) continue;\n        int nf=dp[i][j].first,ns=dp[i][j].second;\n        if(p[i]%1000==0) {\n          if(j>=500) dp[i+1][j-500]=P(nf+1,ns-p[i]);\n          else dp[i+1][j] = P(nf,ns);\n        }\n        else if(p[i]%1000<500) dp[i+1][j+500-p[i]%500]=P(nf+1,ns-p[i]);\n        else if(p[i]%500<=j) dp[i+1][j-p[i]%500] = P(nf+1,ns-p[i]);\n        else{\n          dp[i+1][j+1000-p[i]%1000] = P(nf,ns-p[i]);\n          dp[i+1][j] = P(nf,ns);\n        }\n      }\n    }\n    P ans(0,0);\n    for(int i=0;i<50000;i++) ans=max(ans,dp[n][i]);\n    cout<<ans.first<<\" \"<<-ans.second<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\n\nvoid solve() {\n    vector<int> v(N);\n    for (auto& i : v) cin >> i;\n\n    vector<vector<map<int,int> > > dp(N + 1, vector<map<int,int> >(N + 1));\n    dp[0][0][0] = 0;\n    for (int i = 0; i < N; i++) {\n        int payment = v[i];\n        for (int j = 0; j <= i; j++) {\n            if (i > 2) dp[i - 2][j].clear();\n            for (auto p : dp[i][j]) {\n                int coins = p.first;\n                int cost = p.second;\n\n                if (dp[i+1][j].find(coins) == dp[i+1][j].end()) dp[i+1][j][coins] = cost;\n                else dp[i+1][j][coins] = min(dp[i+1][j][coins], cost);\n\n                int sub = payment % 1000;\n                if (0 < sub && sub <= 500) {\n                    int ncoins = min(coins + 500 - sub, 5000);\n                    if (dp[i+1][j+1].find(ncoins) != dp[i+1][j+1].end())\n                        dp[i + 1][j + 1][ncoins]\n                            = min(dp[i + 1][j + 1][ncoins], cost + payment);\n                    else\n                        dp[i + 1][j + 1][ncoins] = cost + payment;\n                } else {\n                    if (sub == 0) sub = 500;\n                    else sub = sub - 500;\n                    if (sub <= coins) {\n                        int coins_ = coins - sub;\n                        if (dp[i+1][j+1].find(coins_) != dp[i+1][j+1].end())\n                            dp[i + 1][j + 1][coins_] = min(dp[i+1][j+1][coins_], cost + payment);\n                        else\n                            dp[i + 1][j + 1][coins_] = cost + payment;\n                    }\n\n                    int ncoins = min(coins + (1000 - (payment % 1000)) % 1000, 5000);\n                    if (dp[i+1][j].find(ncoins) != dp[i+1][j].end())\n                        dp[i + 1][j][ncoins]\n                            = min(dp[i+1][j][ncoins], cost + payment);\n                    else\n                        dp[i + 1][j][ncoins] = cost + payment;\n                }\n            }\n        }\n    }\n    int ans = 1 << 28, count = 0;\n    for (int i = N; i > -1; i--) {\n        if (count > 0) break;\n        if (dp[N][i].size() == 0) continue;\n        count = i;\n        for (auto p : dp[N][i]) {\n            ans = min(p.second, ans);\n        }\n    }\n    cout << count << \" \" << ans << endl;\n}\n\nint main() {\n    while (cin >> N, N) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_MONEY = 500;\nint n;\nvector<int> p;\n//int big = 0;\nvector<vector<pair<char, int>>> memo;\n\ninline void Change(pair<char, int> &a, pair<char, int> &b) {\n    if ((a.first < b.first) || (a.first == b.first && a.second > b.second))\n        a = b;\n}\n\npair<char, int> Solve(int idx, int money) {\n    // if (big < money) {\n    //     big = money;\n    //     cout << \"money = \" << big << endl;\n    // }\n    if (idx == n)\n        return pair<char, int>(0, 0);\n\n    auto &opt = memo[idx][money];\n    if (opt.second != -1)\n        return opt;\n\n    // idx?????????????????§????????????\n    opt = Solve(idx + 1, money);\n\n    // idx?????????????????§??????\n    if (0 < (p[idx] % 1000) && (p[idx] % 1000) <= 500) {\n        // 1000????????§?????????\n        int res = 1000 - (p[idx] % 1000) - 500 + money;\n        auto tmp = Solve(idx + 1, res);\n        tmp.first += 1;\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n    else if (p[idx] % 1000 == 0) {\n        if (500 <= money) {\n            int res = money - 500;\n            auto tmp = Solve(idx + 1, res);\n            tmp.first += 1;\n            tmp.second += p[idx];\n            Change(opt, tmp);\n        }\n    }\n    else if (500 <= money + 1000 - (p[idx] % 1000)) {\n        // 1000????????¨?°????money??§?????????\n        int res = money + 1000 - (p[idx] % 1000) - 500;\n        auto tmp = Solve(idx + 1, res);\n        tmp.first += 1;\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n    else {\n        // 1000??????????????§?????????\n        int res = 1000 - (p[idx] % 1000) + money;\n        auto tmp = Solve(idx + 1, res);\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n\n    return opt;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n, n) {\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            cin >> p[i];\n\n        memo.clear();\n        memo.resize(n, vector<pair<char, int>>(5000 * n,\n                                              pair<char, int>(0, -1)));\n\n        auto res = Solve(0, 0);\n        cout << (int)res.first << ' ' << res.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\npair<int,int> dp[101][100000];\n\nbool solve(){\n  int n, p;\n  \n  scanf(\"%d\", &n);\n\n  if(n == 0) return false;\n  \n  for(int i=0;i<=n;i++){\n    for(int j=0;j<=n*499;j++){\n      dp[i][j] = {-INF, 0};\n    }\n  }\n\n  dp[0][0] = {0, 0};\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d\", &p);\n    int p2 = p;\n    p %= 1000; \n    for(int j=0;j<=i*499;j++){\n      //1000円のみ\n      dp[i+1][j + (1000-p)%500] = max(dp[i+1][j+(1000-p)%500],\n                                      {dp[i][j].first + (1 <= p && p <= 500), dp[i][j].second - p2});\n\n      //小銭で価格+500円払う\n      if(p + 500 <= j){\n        dp[i+1][j - (p+500)] = max(dp[i+1][j - (p+500)],\n                                   {dp[i][j].first + 1, dp[i][j].second - p2});\n      }\n\n      //札+小銭で価格+500円払う\n      if(p >= 501 && j >= p-500){\n        dp[i+1][j - (p-500)] = max(dp[i+1][j-(p-500)],\n                                   {dp[i][j].first + 1, dp[i][j].second - p2});\n      }\n\n      //買わない\n      dp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n    }\n  }\n\n  pair<int,int> ans = {0, 0};\n  \n  for(int i=0;i<=n*499;i++){\n    ans = max(ans, dp[n][i]);\n  }\n\n  printf(\"%d %d\\n\", ans.first, -ans.second);\n\n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define fi first\n#define sc second\n#define mp make_pair\npair<int,int> dp[105][100005];\nint n,p[105];\nint main(){\n\twhile(1){\n\t\tcin>>n; if(!n) return 0;\n\t\tfor(int i=1;i<=n;i++) cin>>p[i];\n\t\tfor(int i=0;i<105;i++) for(int j=0;j<100005;j++) dp[i][j] = mp(-10000,1000000000);\n\t\tdp[0][0] = mp(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<=500*i;j++){\n\t\t\t\tif(dp[i][j].fi < 0) continue;//cout <<i << \" \" <<j<< endl;\n\t\t\t\tif(dp[i+1][j].fi < dp[i][j].fi) dp[i+1][j] = dp[i][j];\n\t\t\t\telse if(dp[i+1][j].fi == dp[i][j].sc) dp[i+1][j].sc = min(dp[i+1][j].sc,dp[i][j].sc);\n\t\t\t\tint k = 1000-(p[i+1]%1000); if(k==1000) k = 0;\n\t\t\t\tif(dp[i+1][j+k].fi < dp[i][j].fi) {\n\t\t\t\t\tdp[i+1][j+k] = dp[i][j];\n\t\t\t\t\tdp[i+1][j+k].sc += p[i+1];\n\t\t\t\t}\n\t\t\t\telse if(dp[i+1][j+k].fi == dp[i][j].fi){\n\t\t\t\t\tdp[i+1][j+k].sc = min(dp[i+1][j+k].sc ,dp[i][j].sc+p[i+1]);\n\t\t\t\t}\n\t\t\t\tif(!k && j < 500 ) continue;\n\t\t\t\tif((p[i+1]%1000)/100 >=5 && (p[i+1]%1000)-500 >j) continue;\n\t\t\t\tint a = dp[i+1][j+500-(p[i+1]%1000)].fi;\n\t\t\t\tif(a < dp[i][j].fi+1){\n\t\t\t\t\tdp[i+1][j+500-(p[i+1]%1000)] = dp[i][j];\n\t\t\t\t\tdp[i+1][j+500-(p[i+1]%1000)].fi += 1;\n\t\t\t\t\tdp[i+1][j+500-(p[i+1]%1000)].sc += p[i+1];\n\t\t\t\t}\n\t\t\t\telse if(a == dp[i][j].fi+1){\n\t\t\t\t\tdp[i+1][j+500-(p[i+1]%1000)].sc = min(dp[i+1][j+500-(p[i+1]%1000)].sc ,dp[i][j].sc+p[i+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int,int> ans = mp(-10000,1000000000);\n\t\tfor(int j=0;j<100005;j++){\n\t\t\tif(ans.fi < dp[n][j].fi) ans = dp[n][j];\n\t\t\telse if(ans.fi == dp[n][j].fi) ans.sc = min(ans.sc,dp[n][j].sc);\n\t\t}\n\t\tcout <<ans.fi<<\" \" << ans.sc << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 100100100;\n\nint main(){\n\n    while(1){        \n        int n; cin >> n;\n        if(!n) break;\n        vector<int> a(n);\n        for(int i = 0; i < n; i++) cin >> a[i];\n\n        //i番目までの品物を見て、得られた500円玉がj枚で持ってる小銭がk円の時の消費金額の最小値\n        vector<vector<vector<int> > > dp(n + 1, vector<vector<int> > (n + 1, vector<int> (500 * n + 1000, INF)));  \n        dp[0][0][0] = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j <= i; j++){\n                for(int k = 0; k <= 500 * n; k++){\n\n                    //買わない\n                    dp[i + 1][j][k] = min(dp[i + 1][j][k], dp[i][j][k]);\n\n                    //1000で割ったあまりによる場合わけ\n                    if(1 <= a[i] % 1000 && a[i] % 1000 <= 500){\n                        //1000札のみで払うのが最適\n                        //500円獲得\n                        dp[i + 1][j + 1][(500 - a[i] % 1000) + k] = min(dp[i + 1][j + 1][(500 - a[i] % 1000) + k], dp[i][j][k] + a[i]);\n                    }else{\n                        //1000円札のみで払う\n                        //500円玉は獲得できない\n                        dp[i + 1][j][(1000 - a[i] % 1000) % 1000 + k] = min(dp[i + 1][j][(1000 - a[i] % 1000) % 1000 + k], dp[i][j][k] + a[i]);\n\n                        //小銭を駆使して500円玉を獲得\n                        int need = a[i] % 1000 - 500;\n                        if(need == -500) need = 500;\n                        if(k - need >= 0) dp[i + 1][j + 1][k - need] = min(dp[i + 1][j + 1][k - need], dp[i][j][k] + a[i]);\n                    }\n                }\n            }\n\n        }\n\n        int ans1 = 0, ans2 = INF;\n        for(int j = 0; j <= n; j++){\n            for(int k = 0; k <= 500 * n; k++){\n                if(dp[n][j][k] != INF){\n                    if(ans1 < j || (ans1 == j && ans2 > dp[n][j][k])){\n                        ans1 = j;\n                        ans2 = dp[n][j][k];\n                    }\n                }\n            }\n        }\n\n        cout << ans1 << \" \" << ans2 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\n\nP dp[101][50501];\nP pmax(P p,P q){\n    if(p.fs>q.fs) return p;\n    else if(p.fs==q.fs) return (p.sc<q.sc?p:q);\n    else return q;\n}\n\n\nint main(){\n    int N;\n    while(cin >> N){\n        if(!N) return 0;\n        int p[N];\n        for(int i=0;i<N;i++){\n            cin >> p[i];\n        }\n        for(int i=0;i<=N;i++){\n            for(int j=0;j<50001;j++){\n                if(j==0) dp[i][j]=mp(0,0);\n                else dp[i][j]=mp(-1,LINF);\n            }\n        }\n        for(int i=0;i<N;i++){\n            for(int j=0;j<50001;j++){\n                if(dp[i][j].fs==-1){\n                    continue;\n                }\n                P d=dp[i][j];\n                dp[i+1][j]=pmax(dp[i+1][j],d);\n                d.sc+=p[i];\n                int res=(1000-p[i]%1000)%1000;\n                dp[i+1][j+res]=pmax(dp[i+1][j+res],d);\n                if(res>=500){\n                    d.fs++;\n                    res-=500;\n                    dp[i+1][j+res]=pmax(dp[i+1][j+res],d);\n                }\n                else{\n                    d.fs++;\n                    res=500-res;\n                    if(res<=j) dp[i+1][j-res]=pmax(dp[i+1][j-res],d);\n                }\n            }\n        }\n        P ans=mp(0,LINF);\n        for(int i=0;i<=50000;i++){\n            ans=pmax(ans,dp[N][i]);\n        }\n        cout << ans.fs << \" \" << ans.sc << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint a[105];\nint dp[105][100005];\nint DP[105][100005];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=1;i<=n;i++)cin>>a[i];\n    fill(dp[0],dp[105],-1e9);\n    fill(DP[0],DP[105],1e9);\n    \n    int ans=0,ANS=1e9;\n    dp[0][0]=0;\n    DP[0][0]=0;\n    for(int i=1;i<=n;i++){\n      for(int j=0;j<=100000;j++){\n        int A=a[i]%1000;\n        if(A==0)A=1000;\n        \n        dp[i][j]=dp[i-1][j];\n        DP[i][j]=DP[i-1][j];\n\n        if(A<=500){\n          int k=1000-A-500;\n          if(j-k>=0){\n            int d=dp[i-1][j-k]+1;\n            int D=DP[i-1][j-k]+a[i];\n            if( (d==dp[i][j]&&D<DP[i][j]) || d>dp[i][j]){\n              dp[i][j]=d;\n              DP[i][j]=D;\n            }\n          }\n        }else{\n          int k=1000-A;\n          if(j-k>=0){\n            int d=dp[i-1][j-k];\n            int D=DP[i-1][j-k]+a[i];\n            if( (d==dp[i][j]&&D<DP[i][j]) || d>dp[i][j]){\n              dp[i][j]=d;\n              DP[i][j]=D;\n            }\n          }\n          \n          if(j+A-500<=100000){\n            int d=dp[i-1][j+A-500]+1;\n            int D=DP[i-1][j+A-500]+a[i];\n            if( (d==dp[i][j]&&D<DP[i][j]) || d>dp[i][j]){\n              dp[i][j]=d;\n              DP[i][j]=D;\n            }\n          }\n        }\n        if( (ans==dp[i][j]&&DP[i][j]<ANS) || ans<dp[i][j] ){\n          ans=dp[i][j];\n          ANS=DP[i][j];\n        }\n      }\n    }\n    cout<<ans<<' '<<ANS<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\nconst int MAX = 5e2;\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<int> p(n);\n\t\tvector<vector<int>> dp(MAX + 1, vector<int>(101, -1));\n\t\tdp[0][0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> p[i];\n\t\t\tfor (int j = MAX; j >= 0; j--) {\n\t\t\t\tfor (int k = 100; k >= 0; k--) if (dp[j][k] != -1) {\n\t\t\t\t\tint val = (p[i] + 999) / 1000;\n\t\t\t\t\tif (p[i] % 1000 == 0 || p[i] % 1000 > 500) {\n\t\t\t\t\t\tdp[j + val][k] = max(dp[j + val][k], dp[j][k] + val * 1000 - p[i]);\n\t\t\t\t\t\tif (dp[j][k] >= (val * 1000 - p[i] - 500)) {\n\t\t\t\t\t\t\tdp[j + val][k + 1] = max(dp[j + val][k + 1], dp[j][k] + val * 1000 - p[i] - 500);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[j + val][k + 1] = max(dp[j + val][k + 1], dp[j][k] + val * 1000 - p[i] - 500);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt = 0, res = 0;\n\t\tfor (int i = 0; i <= MAX; i++) {\n\t\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\t\tif (dp[i][j] != -1) {\n\t\t\t\t\tif (cnt < j) {\n\t\t\t\t\t\tcnt = j;\n\t\t\t\t\t\tres = i * 1000 - 500 * j - dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse if (cnt == j) {\n\t\t\t\t\t\tres = min(res, i * 1000 - 500 * j - dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << ' ' << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nP dp[101][50001];\n\nvoid Max(P &a,P b){a=max(a,b);}\n\nint main(){\n  int n,p[101];\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>p[i];\n    \n    memset(dp,-1,sizeof(dp));\n    dp[0][0]=P(0,0);\n  \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n*500;j++){\n\tif(dp[i][j]==P(-1,-1))continue;\n\tint coin=dp[i][j].first, ncost=dp[i][j].second-p[i];\n\tMax(dp[i+1][j],dp[i][j]);\n\tif(p[i]%1000<500&&p[i]%1000)Max(dp[i+1][j+(500-p[i]%500)],P(coin+1,ncost));\n\tif(p[i]%1000==0&&j>=500) Max(dp[i+1][j-500],P(coin+1,ncost));\n\t\n\tif(p[i]%1000>=500) {\n\t  if(j>=p[i]%500)Max(dp[i+1][j-p[i]%500],P(coin+1,ncost));\n\t  else Max(dp[i+1][j+(500-p[i]%500)],P(coin,ncost));\n\t}\n      }\n    \n    P ans=P(0,0);\n    for(int i=0;i<50000;i++)Max(ans,dp[n][i]);\n    cout <<ans.first<<\" \"<<-ans.second<<endl;\n    \n  }\t\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 2147483647\nusing namespace std;\nint p[101];\nint dp[100][102][1000];\nint min(int n, int m){ return (n>m)?m:n; }\nint main(void){\n  for(;;){\n    int n;\n    cin >> n;\n    if(n == 0){return 0;}\n    for(int i = 0; i < n ; i++){\n      cin >> p[i];\n    }\n    for(int j = 0 ; j <= n+1 ; j++){\n      for(int coins = 0 ; coins < 1000 ; coins++){\n        dp[0][j][coins] = INF;\n      }\n    }\n    dp[0][0][0] = 0;\n    if(p[0]%1000==0 || p[0]%1000>500){\n      dp[0][0][(1000-(p[0]%1000))%1000] = min(p[0],dp[0][0][(1000-(p[0]%1000))%1000]);\n    }else{\n      dp[0][1][500-(p[0]%1000)] = min(p[0],dp[0][1][500-(p[0]%1000)]);\n    }\n    for(int i = 1 ; i < n ; i++){\n      for(int coins = 0 ; coins < 1000 ; coins++){\n        dp[i][0][coins] = dp[i-1][0][coins];\n      }\n      if(p[i]%1000 >= 500){ dp[i][0][(1000-p[i])%1000] = min(dp[i-1][0][(1000-p[i])%1000], p[i]); }\n      for(int j = 1 ; j <= n+1 ; j++){\n        for(int coins = 0 ; coins < 1000 ; coins++){\n          dp[i][j][coins] = dp[i-1][j][coins];\n        }\n      }\n      for(int j = 1 ; j <= n+1 ; j++){\n        for(int coins = 0 ; coins < 1000 ; coins++){\n          if(p[i]%1000==0 && coins >= 500){\n            if(dp[i-1][j-1][coins] != INF){dp[i][j][coins-500] = dp[i-1][j-1][coins] + p[i];}\n          }else if(p[i]%1000!=0 && 1000-(p[i]%1000)+coins >= 500){\n            if(dp[i-1][j-1][coins] != INF){\n              dp[i][j][(2000+coins-(p[i]%1000)-500)%1000] = min(dp[i][j][(2000+coins-(p[i]%1000)-500)%1000], dp[i-1][j-1][coins]+p[i]);\n            }\n          }else if(p[i]%1000!=0){\n            if(dp[i-1][j][coins] != INF){\n              dp[i][j][(1000+coins-(p[i]%1000))%1000] = min(dp[i][j][(1000+coins-(p[i]%1000))%1000], dp[i-1][j][coins]+p[i]);\n            }\n          }\n        }\n      }\n    }\n    /*\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j <= n+1 ; j++){\n        for(int coins = 0 ; coins < 1000 ; coins ++){\n          if(dp[i][j][coins] != INF){cout << \"dp[\" << i << \"][\" << j << \"][\" << coins << \"] = \" << dp[i][j][coins] << endl;}\n        }\n      }\n    }\n    */\n    int s = INF; int c = INF;\n    for(int j = n ; j >= 0 && (s == INF) ; j--){\n      s = INF;\n      for(int coins = 0 ; coins < 1000 ; coins++){\n        if(s > dp[n-1][j][coins]){s = dp[n-1][j][coins];}\n      }\n      c = j;\n    }\n     cout << c << \" \" << s << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n,p;\npair<int,int> dp[101][50001];\n\nint main() {\n    while (cin>>n && n != 0) {\n        memset(dp,-1,sizeof(dp));\n        dp[0][0] = pair<int,int>(0,0);\n        for (int i = 0; i < n; i++) {\n            cin>>p;\n            for (int t = 0; t < 500*n; t++) {\n                if (dp[i][t] == pair<int,int>(-1,-1)) continue;\n                dp[i+1][t] = max(dp[i][t],dp[i+1][t]);\n                if (p%1000<500 && p%1000) dp[i+1][t+(500-p%500)] = max(dp[i+1][t+(500-p%500)], pair<int,int>(dp[i][t].first+1,dp[i][t].second-p));\n                if (p%1000==0 && t>=500) dp[i+1][t-500] = max(dp[i+1][t-500],pair<int,int>(dp[i][t].first+1,dp[i][t].second-p));\n\n                if (p%1000>=500) {\n                    if (t>=p%500) dp[i+1][t-p%500] = max(dp[i+1][t-p%500], pair<int,int>(dp[i][t].first+1,dp[i][t].second-p));\n                    else dp[i+1][t+(500-p%500)] = max(dp[i+1][t+(500-p%500)], pair<int,int>(dp[i][t].first, dp[i][t].second-p));\n                }\n            }\n        }\n        pair<int,int> ans = pair<int,int>(0,0);\n        for (int i = 0; i < 50000; i++) ans = max(ans, dp[n][i]);\n        cout<<ans.first<<\" \"<<-ans.second<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 100100100;\n\nint main(){\n\n    while(1){        \n        int n; cin >> n;\n        if(!n) break;\n        vector<int> a(n);\n        for(int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n        //i番目までの品物を見て、得られた500円玉がj枚で持ってる小銭がk円の時の消費金額の最小値\n        vector<vector<vector<int> > > dp(2, vector<vector<int> > (n + 1, vector<int> (500 * n + 1000, INF)));  \n        dp[0][0][0] = 0;\n        int now = 0;\n        int next = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j <= i; j++){\n                for(int k = 0; k <= 500 * i; k++){\n\n                    int r = a[i] % 1000;\n                    //買わない\n                    dp[next][j][k] = min(dp[next][j][k], dp[now][j][k]);\n\n                    //1000で割ったあまりによる場合わけ\n                    if(1 <= r && r <= 500){\n                        //1000札のみで払うのが最適\n                        //500円獲得\n                        dp[next][j + 1][(500 - r) + k] = min(dp[next][j + 1][(500 - r) + k], dp[now][j][k] + a[i]);\n                    }else{\n                        //小銭を駆使して500円玉を獲得\n                        int need = r - 500;\n                        if(need == -500) need = 500;\n                        if(k - need >= 0) dp[next][j + 1][k - need] = min(dp[next][j + 1][k - need], dp[now][j][k] + a[i]);\n                        else{\n                            //1000円札のみで払う\n                            //500円玉は獲得できない\n                            dp[next][j][(1000 - r) % 1000 + k] = min(dp[next][j][(1000 - r) % 1000 + k], dp[now][j][k] + a[i]);\n                        }\n                        \n                    }\n                }\n            }\n            swap(now, next);\n        }\n\n        int ans1 = 0, ans2 = INF;\n        for(int j = n; j >= 0; j--){\n            for(int k = 0; k <= 500 * n; k++){\n                if(dp[now][j][k] != INF){\n                    if(ans1 < j || (ans1 == j && ans2 > dp[now][j][k])){\n                        ans1 = j;\n                        ans2 = dp[now][j][k];\n                    }\n                }\n            }\n\n            if(ans1 != 0) break;\n        }\n\n        cout << ans1 << \" \" << ans2 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_num_500,int arg_kozeni){\n\t\tnum_500 = arg_num_500;\n\t\tkozeni = arg_kozeni;\n\t}\n\n\tint num_500,kozeni;\n};\n\nint N,max_kozeni[101],max_500,next_max_500,next_max_kozeni[101];\nint** dp;\nint** next_dp;\n\nvoid func(){\n\n\tint P;\n\tmax_500 = 0;\n\tfor(int i = 0; i <= N; i++){\n\t\tmax_kozeni[i] = 0;\n\t}\n\n\tfor(int i = 0; i <= N; i++){\n\t\tfor(int k = 0; k <= 500*N;k++){\n\t\t\tdp[i][k] = BIG_NUM;\n\t\t\tnext_dp[i][k] = BIG_NUM;\n\t\t}\n\t}\n\n\tvector<Info> Updated;\n\n\tdp[0][0] = 0;\n\tnext_dp[0][0] = 0;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d\",&P);\n\t\tnext_max_500 = max_500;\n\n\t\tfor(int i = 0;i <= N; i++){\n\t\t\tnext_max_kozeni[i] = max_kozeni[i];\n\t\t}\n\n\t\tfor(int num_500 = 0; num_500 <= max_500; num_500++){\n\n\t\t\tfor(int kozeni = 0; kozeni <= max_kozeni[num_500]; kozeni++){\n\t\t\t\tif(dp[num_500][kozeni] == BIG_NUM)continue;\n\n\t\t\t\tif(P%1000 == 0){\n\n\t\t\t\t\tif(kozeni >= 500){\n\t\t\t\t\t\tnext_max_500 = max(next_max_500,num_500+1);\n\t\t\t\t\t\tint next_kozeni = kozeni-500;\n\n\t\t\t\t\t\tif(next_dp[num_500+1][next_kozeni] > dp[num_500][kozeni]+P){\n\t\t\t\t\t\t\tnext_dp[num_500+1][next_kozeni] = dp[num_500][kozeni]+P;\n\t\t\t\t\t\t\tUpdated.push_back(Info(num_500+1,next_kozeni));\n\t\t\t\t\t\t\tnext_max_kozeni[num_500+1] = max(next_max_kozeni[num_500+1],next_kozeni);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\n\t\t\t\t\tint otsuri = 1000*((P/1000)+1)-P;\n\n\t\t\t\t\tif(otsuri >= 500){\n\t\t\t\t\t\tnext_max_500 = max(next_max_500,num_500+1);\n\t\t\t\t\t\tint next_kozeni = (otsuri-500)+kozeni;\n\t\t\t\t\t\tif(next_dp[num_500+1][next_kozeni] > dp[num_500][kozeni]+P){\n\t\t\t\t\t\t\tnext_dp[num_500+1][next_kozeni] = dp[num_500][kozeni]+P;\n\t\t\t\t\t\t\tUpdated.push_back(Info(num_500+1,next_kozeni));\n\t\t\t\t\t\t\tnext_max_kozeni[num_500+1] = max(next_max_kozeni[num_500+1],next_kozeni);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tif(next_dp[num_500][kozeni+otsuri] > dp[num_500][kozeni]+P){\n\t\t\t\t\t\t\tnext_dp[num_500][kozeni+otsuri] = dp[num_500][kozeni]+P;\n\t\t\t\t\t\t\tUpdated.push_back(Info(num_500,kozeni+otsuri));\n\t\t\t\t\t\t\tnext_max_kozeni[num_500] = max(next_max_kozeni[num_500],kozeni+otsuri);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(otsuri+kozeni >= 500){\n\t\t\t\t\t\t\tnext_max_500 = max(next_max_500,num_500+1);\n\t\t\t\t\t\t\tint next_kozeni = otsuri+kozeni-500;\n\t\t\t\t\t\t\tif(next_dp[num_500+1][next_kozeni] > dp[num_500][kozeni]+P){\n\t\t\t\t\t\t\t\tnext_dp[num_500+1][next_kozeni] = dp[num_500][kozeni]+P;\n\t\t\t\t\t\t\t\tUpdated.push_back(Info(num_500+1,next_kozeni));\n\t\t\t\t\t\t\t\tnext_max_kozeni[num_500+1] = max(next_max_kozeni[num_500+1],next_kozeni);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Updated.size(); i++){\n\t\t\tdp[Updated[i].num_500][Updated[i].kozeni] = next_dp[Updated[i].num_500][Updated[i].kozeni];\n\t\t}\n\t\tUpdated.clear();\n\n\t\tfor(int i = 0; i <= N; i++){\n\t\t\tmax_kozeni[i] = next_max_kozeni[i];\n\t\t}\n\n\t\tmax_500 = next_max_500;\n\t}\n\n\tint minimum = BIG_NUM;\n\tfor(int i = 0; i <= max_kozeni[max_500]; i++){\n\t\tminimum = min(minimum,dp[max_500][i]);\n\t}\n\n\tprintf(\"%d %d\\n\",max_500,minimum);\n}\n\nint main(){\n\n\tdp = new int*[101];\n\tnext_dp = new int*[101];\n\n\tfor(int i = 0; i <= 100; i++){\n\t\tdp[i] = new int[50001];\n\t\tnext_dp[i] = new int[50001];\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\ntypedef pair<int, int> PP;\nint N;\nint P[100];\n\nPP dp[100][50000];\n\nPP max(PP a, PP b){\n\tif(a.first == b.first){\n\t\tif(a.second > b.second){\n\t\t\treturn b;\n\t\t}else{\n\t\t\treturn a;\n\t\t}\n\t}else if(a.first >= b.first){\n\t\treturn a;\n\t}else{\n\t\treturn b;\n\t}\n}\n\nPP recur(int idx, int kozeni){\n\tif(idx == N){\n\t\treturn make_pair(0, 0);\n\t}\n\tif(dp[idx][kozeni].first != -1){\n\t\treturn dp[idx][kozeni];\n\t}\n\tPP ans = recur(idx + 1, kozeni);\n\tint nk = (1000 - P[idx] % 1000) % 1000;\n\tif(nk >= 500){\n\t\tPP ans2 = recur(idx + 1, kozeni + nk - 500);\n\t\tans = max(ans, make_pair(ans2.first + 1, ans2.second + P[idx]));\n\n\t}else{\n\t\tPP ans2 = recur(idx + 1, kozeni + nk);\n\t\tans = max(ans, make_pair(ans2.first, ans2.second + P[idx]));\n\t\tif(kozeni + nk >= 500){\n\t\t\tans2 = recur(idx + 1, kozeni + nk - 500);\n\t\t\tans = max(ans, make_pair(ans2.first + 1, ans2.second + P[idx]));\n\t\t}\n\t}\n\treturn dp[idx][kozeni] = ans;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\", &N);\n\t\tif(!N) break;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < 50000; j++){\n\t\t\t\tdp[i][j] = make_pair(-1, -1);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%d\", &P[i]);\n\t\t}\n\t\tPP ans = recur(0, 0);\n\t\tprintf(\"%d %d\\n\", ans.first, ans.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 2\n#define MAX_C 100001\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nint m[MAX_N];\npii dp[MAX_N][MAX_C];\n\nvoid set_m(vector<int> &p)\n{\n    for (int i = 0; i < (int)p.size(); i++) {    \n        m[i] = ((p[i] - 1) / 1000 + 1) * 1000;\n    }\n}\n\nvoid update(pii &a, pii &b)\n{\n    if (a.first < b.first) {\n        a = b;\n    } else if (a.first == b.first) {\n        if (a.second > b.second) {\n            a = b;\n        }\n    }\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<int> p(N);\n        for (int i = 0; i < N; i++) {\n            cin >> p[i];\n        }\n        \n        set_m(p);\n        \n        memset(dp, -1, sizeof(dp));\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < MAX_C; j++) {\n                dp[i][j] = pii(-1, INF);\n            }\n        }\n        \n        dp[0][0] = pii(0, 0);\n        for (int i = 0; i < N; i++) {\n            int curr = (i & 1), next = !(i & 1);\n            for (int j = 0; j < MAX_C; j++) {\n                if (dp[curr][j].first == -1) continue;\n                \n                update(dp[next][j], dp[curr][j]);\n\n                for (int k = 0; k <= min(j, 999); k++) {\n                    int pay = m[i] + k;\n                    int change = pay - p[i];                    \n                    if (change >= 1000) continue;\n                    \n                    int _500 = (change >= 500);\n                    int nc = j - k + change - _500 * 500;                    \n                    \n                    pii ncost = pii(dp[curr][j].first + _500,\n                                    dp[curr][j].second + p[i]);                    \n                    \n                    update(dp[next][nc], ncost);\n                }\n            }\n            \n            for (int j = 0; j < MAX_C; j++) {\n                dp[curr][j] = pii(-1, INF);\n            }\n        }\n        \n        pii res = pii(-1, INF);\n        for (int i = 0; i < MAX_C; i++) {\n            update(res, dp[N&1][i]);\n        }\n        cout << res.first << \" \" << res.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\npair<int, int> dp[101][50001];\nbool used[101][50001];\nint N, P[100];\n\npair<int, int> dfs(int idx, int coins) {\n  if (idx == N) return make_pair(0, 0);\n  if (used[idx][coins]) return dp[idx][coins];\n\n  used[idx][coins] = true;\n  // not buy;\n  pair<int, int> ret = dfs(idx + 1, coins);\n\n  // buy only with bills\n  int change = (1000 - P[idx] % 1000) % 1000;\n  int cnt, money; tie(cnt, money) = dfs(idx + 1, coins + change % 500);\n  ret = max(ret, make_pair(cnt + (change >= 500), money - P[idx]));\n\n  // buy with bills & coins to get 500\n  if ((P[idx] + 500) % 1000 <= coins) {\n    int cnt, money; tie(cnt, money) = dfs(idx + 1, coins - (P[idx] + 500) % 1000);\n    ret = max(ret, make_pair(cnt + 1, money - P[idx]));\n  }\n\n  return dp[idx][coins] = ret;\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    cin >> N;\n    if (not N) break;\n    REP(i, N) cin >> P[i];\n    memset(used, 0, sizeof(used));\n    int cnt, money; tie(cnt, money) = dfs(0, 0);\n    cout << cnt << ' ' << -money << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef signed ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nconst ll M = 100*5000;\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n;\n    while (cin >> n, n) {\n        vector<ll> p(n); cin >> p;\n        vector<vector<P>> dp(n+1, vector<P>(M+1, {-1, -1}));\n        dp[0][0] = {0, 0};\n        rep(i, n) rep(j, M+1) {\n            if (dp[i][j].first < 0) continue;\n            ll c, r; tie(c, r) = dp[i][j];\n            if (0 < p[i] % 1000 && p[i] % 1000 <= 500) {\n                // ??????\n                assert(j+p[i] <= M);\n                chmax(dp[i+1][j+p[i]], P(c+1, r+(500-p[i]%1000)));\n            }\n            else {\n                // ????????????\n                chmax(dp[i+1][j], dp[i][j]);\n                // ???????????????\n                chmax(dp[i+1][j+p[i]], P(c, r+(1000-p[i]%1000)%1000));\n                // 500????????????????????????????????????\n                ll need = (p[i]+500) % 1000;\n                if (r >= need) {\n                    chmax(dp[i+1][j+p[i]], P(c+1, r-need));\n                }\n            }\n        }\n        P ans{0, 0};\n        rep(i, M+1) {\n            chmax(ans, P(dp[n][i].first, -i));\n        }\n        cout << ans.first << \" \" << -ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<17;\n\nP dp[101][50501];\nP pmax(P p,P q){\n    if(p.fs>q.fs) return p;\n    else if(p.fs==q.fs) return (p.sc<q.sc?p:q);\n    else return q;\n}\n\n\nint main(){\n    int N;\n    while(cin >> N){\n        if(!N) return 0;\n        int p[N];\n        for(int i=0;i<N;i++){\n            cin >> p[i];\n        }\n        for(int i=0;i<=N;i++){\n            for(int j=0;j<50001;j++){\n                if(j==0) dp[i][j]=mp(0,0);\n                else dp[i][j]=mp(-1,INF);\n            }\n        }\n        for(int i=0;i<N;i++){\n            for(int j=0;j<50001;j++){\n                if(dp[i][j].fs==-1){\n                    continue;\n                }\n                P d=dp[i][j];\n                dp[i+1][j]=pmax(dp[i+1][j],d);\n                d.sc+=p[i];\n                int res=(1000-p[i]%1000)%1000;\n                dp[i+1][j+res]=pmax(dp[i+1][j+res],d);\n                if(res>=500){\n                    d.fs++;\n                    res-=500;\n                    dp[i+1][j+res]=pmax(dp[i+1][j+res],d);\n                }\n                else{\n                    d.fs++;\n                    res=500-res;\n                    if(res<=j) dp[i+1][j-res]=pmax(dp[i+1][j-res],d);\n                }\n            }\n        }\n        P ans=mp(0,LINF);\n        for(int i=0;i<=50000;i++){\n            ans=pmax(ans,dp[N][i]);\n        }\n        cout << ans.fs << \" \" << ans.sc << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nint c[5]={100,50,10,5,1};\nint encode(vector<int> v){\n\tint S = 0;\n\tfor(int i=0;i<v.size();i++){\n\t\tS = S*10+v[i];\n\t}\n\treturn S;\n}\nvector<int> decode(int S){\n\tvector<int> v;\n\tint x = 10000;\n\tfor(int i=0;i<5;i++){\n\t\tv.pb(S/x);\n\t\tS %= x;\n\t\tx /= 10;\n\t}\n\treturn v;\n}\nmap<int,P> dp[105];\npair<int,vector<int> > charge(int x){\n\tx %= 1000;\n\tvector<int> v(5,0);\n\tint f = x/500;\n\tx -= f*500;\n\tfor(int i=0;i<5;i++){\n\t\tv[i]=x/c[i];\n\t\tx -= v[i]*c[i];\n\t}\n\t//assert(x==0);\n\treturn make_pair(f,v);\n}\n/*void dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}*/\nP dfs(int id,int V){\n\t/*cout << \"call : \" << id << endl;\n\tcout << \"vec : \";\n\tdump(vec);\n\tcout << endl;*/\n\tint tmp = V;\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tmap<int,P>::iterator it;\n\tit = dp[id].find(V);\n\tif(it!=dp[id].end()){\n\t\treturn (it->sec);\n\t}\n\tP res = dfs(id+1,V);\n\tvector<int> vec = decode(V);\n\tint h = ((p[id]-1)/1000+1)*1000;;\n\tfor(int i=0;i<5;i++){\n\t\twhile(vec[i]>0&&h-p[id]+c[i]<1000){\n\t\t\tvec[i]--;\n\t\t\th += c[i];\n\t\t}\n\t}\n\tpair<int,vector<int> > ch = charge(h-p[id]);\n\tfor(int i=0;i<5;i++)vec[i] += (ch.sec)[i];\n\tP res2 = dfs(id+1,encode(vec));\n\tres2.fi += ch.fi;\n\tres2.sec -= p[id];\n\tdp[id][tmp]=max(res,res2);\n\t/*cout << \"end : \" << id << endl;\n\tcout << \"vec : \";\n\tdump();\n\tcout << \"result : \" << dp[id][vec].fi << ' ' << -dp[id][vec].sec << endl;*/\n\treturn dp[id][tmp];\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<105;i++)dp[i].clear();\n\tP ans = dfs(0,0);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if (n == 0) break;\n\n        P ini = {0, 0};\n        vector<P> change(500 * n, ini);\n        vector<P> pre_change(500 * n, ini);\n\n        for (int i = 0; i < n; i++){\n\n            int p;\n            cin >> p;\n\n            if (p % 1000 == 0);\n            else if (pre_change[(1000 - p % 1000) % 500] == ini){\n                pre_change[(1000 - p % 1000) % 500].first = (p % 1000 > 0 && p % 1000 <= 500);\n                pre_change[(1000 - p % 1000) % 500].second = p;\n            }\n            else if (pre_change[(1000 - p % 1000) % 500].first < (p % 1000 > 0 && p % 1000 <= 500)){\n                pre_change[(1000 - p % 1000) % 500].first = (p % 1000 > 0 && p % 1000 <= 500);\n                pre_change[(1000 - p % 1000) % 500].second = p;\n            }\n            else if (pre_change[(1000 - p % 1000) % 500].first == (p % 1000 > 0 && p % 1000 <= 500) && pre_change[p].second > p){\n                pre_change[(1000 - p % 1000) % 500].second = p;\n            }\n\n            for (int j = 0; j < 500 * n; j++){\n                if (change[j] == ini) continue;\n                if (p % 1000 > 0 && p % 1000 <= 500){\n                    if (pre_change[j + (1000 - p % 1000) % 500] == ini){\n                        pre_change[j + (1000 - p % 1000) % 500].first = change[j].first + 1;\n                        pre_change[j + (1000 - p % 1000) % 500].second = change[j].second + p;\n                    }\n                    else if (pre_change[j + (1000 - p % 1000) % 500].first < change[j].first + 1){\n                        pre_change[j + (1000 - p % 1000) % 500].first = change[j].first + 1;\n                        pre_change[j + (1000 - p % 1000) % 500].second = change[j].second + p;\n                    }\n                    else if (pre_change[j + (1000 - p % 1000) % 500].first == change[j].first + 1 && pre_change[j + (1000 - p % 1000) % 500].second > change[j].second + p){\n                        pre_change[j + (1000 - p % 1000) % 500].second = change[j].second + p;\n                    }\n                }\n                else if (p % 1000 > 0 && p % 1000 <= 500 + j){\n                    if (pre_change[j - p % 500] == ini){\n                        pre_change[j - p % 500].first = change[j].first + 1;\n                        pre_change[j - p % 500].second = change[j].second + p;\n                    }\n                    else if (pre_change[j - p % 500].first < change[j].first + 1){\n                        pre_change[j - p % 500].first = change[j].first + 1;\n                        pre_change[j - p % 500].second = change[j].second + p;\n                    }\n                    else if (pre_change[j - p % 500].first == change[j].first + 1 && pre_change[j - p % 500].second > change[j].second + p){\n                        pre_change[j - p % 500].second = change[j].second + p;\n                    }\n                }\n                else if (p % 1000 == 0 && j >= 500){\n                    if (pre_change[j - 500] == ini){\n                        pre_change[j - 500].first = change[j].first + 1;\n                        pre_change[j - 500].second = change[j].second + p;\n                    }\n                    else if (pre_change[j - 500].first < change[j].first + 1){\n                        pre_change[j - 500].first = change[j].first + 1;\n                        pre_change[j - 500].second = change[j].second + p;\n                    }\n                    else if (pre_change[j - 500].first == change[j].first + 1 && pre_change[j - 500].second > change[j].second + p){\n                        pre_change[j - 500].second = change[j].second + p;\n                    }\n                }\n                else if (p % 1000 != 0){\n                    if (pre_change[j + (1000 - p % 1000)] == ini){\n                        pre_change[j + (1000 - p % 1000)].first = change[j].first;\n                        pre_change[j + (1000 - p % 1000)].second = change[j].second + p;\n                    }\n                    else if (pre_change[j + (1000 - p % 1000)].first < change[j].first){\n                        pre_change[j + (1000 - p % 1000)].first = change[j].first;\n                        pre_change[j + (1000 - p % 1000)].second = change[j].second + p;\n                    }\n                    else if (pre_change[j + (1000 - p % 1000)].first == change[j].first && pre_change[j + (1000 - p % 1000)].second > change[j].second + p){\n                        pre_change[j + (1000 - p % 1000)].second = change[j].second + p;\n                    }\n                }\n            }\n            \n            change = pre_change;\n        }\n\n        int c = 0;\n        int s = 0;\n        for (int i = 0; i < 500 * n; i++){\n            if (change[i].first > c){\n                c = change[i].first;\n                s = change[i].second;\n            }\n            else if (change[i].first == c && change[i].second < s) s = change[i].second;\n        }\n        cout << c << \" \" << s << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define M 25000\n\nint dp[2][101][M];\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int p[100],pp[100];\n    for(int i=0;i<n;i++)scanf(\"%d\",&p[i]),pp[i]=(1000-p[i]%1000)%1000;\n\n    for(int i=0;i<2;i++)\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<M;k++)dp[i][j][k]=1e9;\n    \n    dp[0][0][0]=0;\n\n    for(int i=0;i<n;i++){\n      int ni=(i+1)%2,I=i%2,mm=min(M,500*i+1);\n\n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<mm;k++)dp[ni][j][k]=1e9;\n      \n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<mm;k++){\n\t  int np=k+pp[i];\n\t  int nj=j;\n\t  if(np>=500)nj++,np-=500;\n\t  np=min(M-1,np);\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t  dp[ni][j][k]=min(dp[ni][j][k],dp[I][j][k]);\n\t}\n    }\n    \n    int c=0,s=0;\n    for(int i=1;i<=n;i++)\n      for(int j=0;j<M;j++)\n\tif(dp[n%2][i][j]!=1e9&&i>=c){\n\t  if(c==i&&dp[n%2][i][j]<s)s=dp[n%2][i][j];\n\t  else if(c<i)c=i,s=dp[n%2][i][j];\n\t}\n    printf(\"%d %d\\n\",c,s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 100100100;\n\nint main(){\n\n    while(1){        \n        int n; cin >> n;\n        if(!n) break;\n        vector<int> a(n);\n        for(int i = 0; i < n; i++) cin >> a[i];\n\n        //i番目までの品物を見て、得られた500円玉がj枚で持ってる小銭がk円の時の消費金額の最小値\n        vector<vector<vector<int> > > dp(2, vector<vector<int> > (n + 1, vector<int> (500 * n + 1000, INF)));  \n        dp[0][0][0] = 0;\n        int now = 0;\n        int next = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j <= i; j++){\n                for(int k = 0; k <= 500 * i; k++){\n\n                    int r = a[i] % 1000;\n                    //買わない\n                    dp[next][j][k] = min(dp[next][j][k], dp[now][j][k]);\n\n                    //1000で割ったあまりによる場合わけ\n                    if(1 <= r && r <= 500){\n                        //1000札のみで払うのが最適\n                        //500円獲得\n                        dp[next][j + 1][(500 - r) + k] = min(dp[next][j + 1][(500 - r) + k], dp[now][j][k] + a[i]);\n                    }else{\n                        //小銭を駆使して500円玉を獲得\n                        int need = r - 500;\n                        if(need == -500) need = 500;\n                        if(k - need >= 0) dp[next][j + 1][k - need] = min(dp[next][j + 1][k - need], dp[now][j][k] + a[i]);\n                        else{\n                            //1000円札のみで払う\n                            //500円玉は獲得できない\n                            dp[next][j][(1000 - r) % 1000 + k] = min(dp[next][j][(1000 - r) % 1000 + k], dp[now][j][k] + a[i]);\n                        }\n                        \n                    }\n                }\n            }\n            swap(now, next);\n        }\n\n        int ans1 = 0, ans2 = INF;\n        for(int j = 0; j <= n; j++){\n            for(int k = 0; k <= 500 * n; k++){\n                if(dp[now][j][k] != INF){\n                    if(ans1 < j || (ans1 == j && ans2 > dp[now][j][k])){\n                        ans1 = j;\n                        ans2 = dp[now][j][k];\n                    }\n                }\n            }\n        }\n\n        cout << ans1 << \" \" << ans2 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define M 1000000007\n#define LIM 10010\n\nint dp[110][1000];\n\n\nint main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n\n        for (int i = 0; i < 110; ++i) {\n            fill(dp[i], dp[i] + 1000, M);\n        }\n        dp[0][0] = 0;\n        for (int i = 0; i < n; ++i) {\n            int p;\n            cin >> p;\n            int q = (1000 - p % 1000) % 1000;\n            for (int j = 105; j >= 0; --j) {\n                for (int k = 999; k >= 0; --k) {\n                    if (q + k >= 500)\n                        dp[j + 1][(q + k - 500) % 1000] = min(dp[j + 1][(q + k - 500) % 1000], dp[j][k] + p);\n                    else\n                        dp[j][q + k] = min(dp[j][q + k], dp[j][k] + p);\n                }\n            }\n        }\n        for (int i = 105; i >= 0; --i) {\n            int flag = 0;\n            int mi = M;\n            for (int j = 0; j < 1000; ++j) {\n                if (dp[i][j] < M) {\n                    flag = 1;\n                    mi = min(mi, dp[i][j]);\n                }\n            }\n            if (flag) {\n                cout << i << \" \" << mi << \"\\n\";\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint dp[128][128][256];\nint n;\nint P[64];\n\nvoid init() {\n  for(int i = 0; i < 128; ++i) {\n    for(int j = 0; j < 128; ++j) {\n      for(int k = 0; k < 256; ++k) {\n        dp[i][j][k] = -1;\n      }\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d\", &P[i]);\n    }\n    dp[0][0][0] = 0;\n    for(int i = 0; i < n; ++i) {\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < 256; ++k) {\n          if( dp[i][j][k] == -1 ) continue;\n          dp[i+1][j][k] = std::max(dp[i+1][j][k], dp[i][j][k]);\n          // 1000\n          int count_1000_2 = (P[i] + 999) / 1000;\n          int rem0 = count_1000_2 * 1000 - P[i];\n          int& next0 = dp[i+1][j + (rem0%1000>=500 ? 1 : 0)][k + count_1000_2];\n          next0 = std::max(next0, dp[i][j][k] + (rem0%1000>=500 ? rem0 - 500 : rem0));\n          //\n          int count_1000 = (P[i] + 999) / 1000;\n          int rem1 = dp[i][j][k] + count_1000 * 1000 - P[i];\n          int& next = dp[i+1][j + (rem1%1000>=500 ? 1 : 0)][k + count_1000];\n          next = std::max(next, rem1%1000>=500 ? rem1 - 500 : rem1);\n          // rem\n          if( dp[i][j][k] > P[i] ) {\n            int rem2 = dp[i][j][k] - P[i];\n            int& next = dp[i+1][j + (rem2%1000>=500 ? 1 : 0)][k];\n            next = std::max(next, (rem2%1000>=500 ? rem2 - 500 : rem2));\n          }\n        }\n      }\n    }\n    // for(int i = 0; i <= 4; ++i) {\n    //   for(int j = 0; j <= 4; ++j) {\n    //     for(int k = 0; k < 6; ++k) {\n    //       printf(\"(i, j, k) = (%d, %d, %d) : %d\\n\", i, j, k, dp[i][j][k]);\n    //     }\n    //   }\n    // }\n    int res = (1 << 28);\n    int max = -1;\n    for(int j = n; j >= 0; --j) {\n      for(int k = 0; k < 256; ++k) {\n        if( dp[n][j][k] == -1 ) continue;\n        int cost = k * 1000 - 500 * j - dp[n][j][k];\n        res = std::min(res, cost);\n      }\n      if( res != (1 << 28) ) {\n        max = j;\n        break;\n      }\n    }\n    printf(\"%d %d\\n\", max, res);\n  }\n         \n        \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < n; i++)\ntypedef pair<int, int> P;\n\nvoid solve() {\n    int N;\n    cin >> N;\n    if (N == 0) exit(0);\n    vector<int> p(N);\n    REP(i, N) { cin >> p[i]; }\n    // dp[i][j]=i番目までで、おつりがj円の時の、{500円玉の枚数のmax,消費金額のmin}\n    vector<vector<P>> dp(N + 1, vector<P>(50500, {-1, 1e8}));\n    dp[0][0] = {0, 0};\n    REP(i, N) {\n        REP(j, 50005) {\n            if (dp[i][j].first == -1) continue;\n            int otsuri = (1000 - p[i] % 1000) % 1000;\n            int cnt = dp[i][j].first;\n            int cost = dp[i][j].second;\n            //買わない\n            if (cnt > dp[i + 1][j].first) {\n                dp[i + 1][j] = {cnt, cost};\n            } else if (cnt == dp[i + 1][j].first && cost < dp[i + 1][j].second) {\n                dp[i + 1][j] = {cnt, cost};\n            }\n\n            //おつりが500円以上の時(1000円で買えば500円がもらえる)\n            if (otsuri >= 500) {\n                // 500円のmaxを増やせるとき\n                if (cnt + 1 > dp[i + 1][j + otsuri - 500].first) {\n                    dp[i + 1][j + otsuri - 500] = {cnt + 1, cost + p[i]};\n                }\n                //消費金額のminを小さくできるとき\n                else if (cnt + 1 == dp[i + 1][j + otsuri - 500].first &&\n                         cost + p[i] < dp[i + 1][j + otsuri - 500].second) {\n                    dp[i + 1][j + otsuri - 500] = {cnt + 1, cost + p[i]};\n                }\n            } else {\n                //手持ちのおつりと合わせて500円がもらえる\n                if (j + otsuri >= 500) {\n                    int d = 500 - otsuri;  // 500円との差額\n                    //買うけど500円はもらわない\n                    if (cnt > dp[i + 1][j + otsuri].first) {\n                        dp[i + 1][j + otsuri] = {cnt, cost + p[i]};\n                    } else if (cnt == dp[i + 1][j + otsuri].first && cost + p[i] < dp[i + 1][j + otsuri].second) {\n                        dp[i + 1][j + otsuri] = {cnt, cost + p[i]};\n                    }\n\n                    // 500円のmaxを増やせるとき\n                    if (cnt + 1 > dp[i + 1][j - d].first) {\n                        dp[i + 1][j - d] = {cnt + 1, cost + p[i]};\n                    }\n                    //消費金額のminを小さくできるとき\n                    else if (cnt + 1 == dp[i + 1][j - d].first && cost + p[i] < dp[i + 1][j - d].second) {\n                        dp[i + 1][j - d] = {cnt + 1, cost + p[i]};\n                    }\n                } else {\n                    if (cnt > dp[i + 1][j + otsuri].first) {\n                        dp[i + 1][j + otsuri] = {cnt, cost + p[i]};\n                    } else if (cnt == dp[i + 1][j + otsuri].first && cost + p[i] < dp[i + 1][j + otsuri].second) {\n                        dp[i + 1][j + otsuri] = {cnt, cost + p[i]};\n                    }\n                }\n            }\n        }\n    }\n    int cnt_max = 0;\n    REP(j, 50001) { cnt_max = max(cnt_max, dp[N][j].first); }\n    int mn_cost = 1e9;\n    REP(j, 50001) {\n        if (dp[N][j].first == cnt_max) {\n            mn_cost = min(mn_cost, dp[N][j].second);\n        }\n    }\n    cout << cnt_max << \" \" << mn_cost << endl;\n}\nint main() {\n    while (true) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1e13;\n \n//vector<vector<pair<ll, ll>>> dp(100 + 2, vector<pair<ll, ll>>(50700)); // dp[i][j] := i日目にj円持ってるときに持ってる500円の枚数と支払った金額\npair<ll, ll> dp[200][50700];\n \nint main() {\n    ll n, i, j;\n    while(cin >> n, n) {\n        vector<ll> p(n);\n        for(i = 0; i < n; i++) {\n            cin >> p[i];\n        }\n        pair<ll, ll> x = make_pair(0LL, INF);\n        for(i = 0; i <= n; i++) {\n            for(j = 0; j <= 50100; j++) {\n                dp[i][j] = x;\n            }\n        }\n        dp[0][0] = make_pair(0LL, 0LL);\n        for(i = 0; i < n; i++) {\n            for(j = 0; j < 50000; j++) {\n                if(dp[i][j].second == INF) continue;\n                if(dp[i][j].first > dp[i + 1][j].first)\n                    dp[i + 1][j] = dp[i][j]; //何もしないとき\n                else if(dp[i][j].first == dp[i + 1][j].first) {\n                    dp[i + 1][j].second = min(dp[i + 1][j].second, dp[i][j].second);\n                }\n                // 買うとき\n                ll otsuri = (1000 - (p[i] % 1000)) % 1000; // 小銭を使わないで得られるお金\n                if(otsuri >= 500) {\n                    // cerr << j+otsuri-500 << endl;\n                    if(dp[i + 1][j + otsuri - 500].first < dp[i][j].first + 1)\n                        dp[i + 1][j + otsuri - 500] = make_pair(dp[i][j].first + 1, dp[i][j].second + p[i]);\n                    else if(dp[i + 1][j + otsuri - 500].first == dp[i][j].first + 1)\n                        dp[i + 1][j + otsuri - 500].second = min(dp[i + 1][j + otsuri - 500].second, dp[i][j].second + p[i]);\n                } else {\n                    ll must = (p[i] % 1000) - 500; // 500円を得るのに最低必要な小銭\n                    if(must == -500) must = 500;\n                    if(must <= j) {\n                        if(dp[i + 1][j - must].first < dp[i][j].first + 1)\n                            dp[i + 1][j - must] = make_pair(dp[i][j].first + 1, dp[i][j].second + p[i]);\n                        else if(dp[i + 1][j - must].first == dp[i][j].first + 1)\n                            dp[i + 1][j - must].second = min(dp[i + 1][j - must].second, dp[i][j].second + p[i]);\n                    }\n                    //とりあえずお金を稼ぐ\n                    if(dp[i + 1][j + otsuri].first < dp[i][j].first)\n                        dp[i + 1][j + otsuri] = make_pair(dp[i][j].first, dp[i][j].second + p[i]);\n                    else if(dp[i + 1][j + otsuri].first == dp[i][j].first)\n                        dp[i + 1][j + otsuri].second = min(dp[i][j].second + p[i], dp[i + 1][j + otsuri].second);\n                }\n            }\n        }\n        pair<ll, ll> ret(0LL, INF);\n        for(i = 0; i < 50000; i++) {\n            if(dp[n][i].first > ret.first) {\n                ret = dp[n][i];\n            } else if(dp[n][i].first == ret.first) {\n                ret.second = min(ret.second, dp[n][i].second);\n            }\n        }\n        cout << ret.first << \" \" << ret.second << endl;\n        //cout << dp[2][200].first << \" \" << dp[2][200].second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nP dp[105][50005];\nint p[100];\nvoid Max(P &a,P b){a=max(a,b);}\n\nint main(){\n  int n;\n  while(cin>>n && n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++)cin>>p[i];\n    dp[0][0] = P(0,0);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<50000;j++){\n        if(dp[i][j]==P(-1,-1)) continue;\n        int nf=dp[i][j].first,ns=dp[i][j].second-p[i];\n        Max(dp[i+1][j],dp[i][j]);\n        if(p[i]%1000==0)\n          {if(j>=500) Max(dp[i+1][j-500],P(nf+1,ns));}\n        else if(p[i]%1000<500) Max(dp[i+1][j+500-p[i]%500],P(nf+1,ns));\n        else if(p[i]%500<=j) Max(dp[i+1][j-p[i]%500],P(nf+1,ns));\n        else Max(dp[i+1][j+500-p[i]%500],P(nf,ns)); \n      }\n    }\n    P ans(0,0);\n    for(int i=0;i<50000;i++) Max(ans,dp[n][i]);\n    cout<<ans.first<<\" \"<<-ans.second<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint n;\npair<int,int> dp[101][540005];\n//bool me[101][540005]={0};\nsigned main(){\n\twhile(1){\n\tcin>>n;\n\t\tif(n==0) break;\n\t\tpa zx=mp(0,-10000000);\n\t\tfor(int i=0;i<=100;i++)for(int j=0;j<540005;j++){\n\t\t\tdp[i][j]=mp(0,-10000000);\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tdp[0][0]=mp(0,0);\n\t\t\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint p,pq;\n\t\t\tcin>>p;\n\t\t\tpq=p;\n\t\t\tp%=1000;\n\t\t\t\n\t\t\tif(p==0) p+=1000;\n\t\t\tfor(int j=0;j<540005;j++){\n\t\t\t\tif(dp[i-1][j]==zx) continue;\n\t\t\t\n\t\t\t\tif(dp[i][j]<dp[i-1][j]) dp[i][j]=dp[i-1][j];\n\t\t\t\tif(p>500){\n\t//\t\t\t\tme[i][j+(1000-p)]=1;\n\t\t\t\t\tif(dp[i][j+(1000-p)]<mp(dp[i-1][j].first,dp[i-1][j].second-pq)) dp[i][j+(1000-p)]=mp(dp[i-1][j].first,dp[i-1][j].second-pq);\n\t\t\t\t}\n\t\t\t\telse{\n\t//\t\t\t\tme[i][j+(1000-p-500)]=1;\n\t\t\t\t\tif(dp[i][j+(500-p)]<mp(dp[i-1][j].first+1,dp[i-1][j].second-pq)) dp[i][j+(500-p)]=mp(dp[i-1][j].first+1,dp[i-1][j].second-pq);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(p>500){\n\t\t\t\t\tif(j>=p+500-1000){\n\t//\t\t\t\t\tme[i][j-(p-500)]=1;\n\t\t\t\t\t\tif(dp[i][j-(p-500)]<mp(dp[i-1][j].first+1,dp[i-1][j].second-pq)) dp[i][j-(p-500)]=mp(dp[i-1][j].first+1,dp[i-1][j].second-pq);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(j>=p+500){\n\t//\t\t\t\t\tme[i][j-(p+500)]=1;\n\t\t\t\t\t\tif(dp[i][j-(p+500)]<mp(dp[i-1][j].first+1,dp[i-1][j].second-pq)) dp[i][j-(p+500)]=mp(dp[i-1][j].first+1,dp[i-1][j].second-pq);\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpa ans=mp(0,-100000000);\n\t\tfor(int j=0;j<540005;j++){\n\t\t\tif(dp[n][j]==zx) continue;\n\t\t\tif(dp[n][j]>ans)ans=dp[n][j];\n\t\t}\n\t\n\t\t\n\t\tcout<<ans.first<<\" \"<<-ans.second<<endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\nint pr[100010];\nint inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n \n \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n\n\n                         //----------------kokomade tenpure------------\nint n;\npair<int,int> dp[120][540005];\nbool me[120][540005]={0};\nsigned main(){\n\twhile(1){\n\tcin>>n;\n\t\tif(n==0) break;\n\t\t\n\t\tfor(int i=0;i<120;i++)for(int j=0;j<540005;j++){\n\t\t\tdp[i][j]=mp(0,-10000000);\n\t\t\t\n\t\t\tme[i][j]=0;\n\t\t}\n\t\tme[0][0]=1;\n\t\tdp[0][0]=mp(0,0);\n\t\t\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint p,pq;\n\t\t\tcin>>p;\n\t\t\tpq=p;\n\t\t\tp%=1000;\n\t\t\t\n\t\t\tif(p==0) p+=1000;\n\t\t\tfor(int j=0;j<540005;j++){\n\t\t\t\tif(me[i-1][j]==0) continue;\n\t\t\t\tme[i][j]=1;\n\t\t\t\tif(dp[i][j]<dp[i-1][j]) dp[i][j]=dp[i-1][j];\n\t\t\t\tif(p>500){\n\t\t\t\t\tme[i][j+(1000-p)]=1;\n\t\t\t\t\tif(dp[i][j+(1000-p)]<mp(dp[i-1][j].first,dp[i-1][j].second-pq)) dp[i][j+(1000-p)]=mp(dp[i-1][j].first,dp[i-1][j].second-pq);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tme[i][j+(1000-p-500)]=1;\n\t\t\t\t\tif(dp[i][j+(500-p)]<mp(dp[i-1][j].first+1,dp[i-1][j].second-pq)) dp[i][j+(500-p)]=mp(dp[i-1][j].first+1,dp[i-1][j].second-pq);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(p>500){\n\t\t\t\t\tif(j>=p+500-1000){\n\t\t\t\t\t\tme[i][j-(p-500)]=1;\n\t\t\t\t\t\tif(dp[i][j-(p-500)]<mp(dp[i-1][j].first+1,dp[i-1][j].second-pq)) dp[i][j-(p-500)]=mp(dp[i-1][j].first+1,dp[i-1][j].second-pq);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(j>=p+500){\n\t\t\t\t\t\tme[i][j-(p+500)]=1;\n\t\t\t\t\t\tif(dp[i][j-(p+500)]<mp(dp[i-1][j].first+1,dp[i-1][j].second-pq)) dp[i][j-(p+500)]=mp(dp[i-1][j].first+1,dp[i-1][j].second-pq);\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpa ans=mp(0,-100000000);\n\t\tfor(int j=0;j<540005;j++){\n\t\t\tif(me[n][j]==0) continue;\n\t\t\tif(dp[n][j]>ans)ans=dp[n][j];\n\t\t}\n\t\n\t\t\n\t\tcout<<ans.first<<\" \"<<-ans.second<<endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\npair<int, int> dp[109][50009]; int n, x[109], g[109];\n\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0) break;\n\t\tfor (int i = 1; i <= n; i++) { cin >> x[i]; g[i] = x[i]; x[i] %= 1000; }\n\n\t\tfor (int i = 1; i <= n + 1; i++) { for (int j = 0; j <= n * 500; j++) dp[i][j] = make_pair(-1, -1); }\n\n\t\tdp[1][0] = make_pair(0, 0);\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= n * 500; j++) {\n\t\t\t\tif (dp[i][j] == make_pair(-1, -1)) continue;\n\n\t\t\t\tdp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);\n\n\t\t\t\tif (x[i] == 0) {\n\t\t\t\t\t// 何もできない\n\t\t\t\t\tif (j >= 500) dp[i + 1][j - 500] = max(dp[i + 1][j - 500], make_pair(dp[i][j].first + 1, dp[i][j].second - g[i]));\n\t\t\t\t}\n\t\t\t\telse if (x[i] >= 1 && x[i] <= 500) {\n\t\t\t\t\t// 1000 円支払う\n\t\t\t\t\tdp[i + 1][j + (1000 - x[i]) % 500] = max(dp[i + 1][j + (1000 - x[i]) % 500], make_pair(dp[i][j].first + 1, dp[i][j].second - g[i]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// 1000 円支払う\n\t\t\t\t\tif (j - (x[i] - 500) >= 0) {\n\t\t\t\t\t\tdp[i + 1][j - (x[i] - 500)] = max(dp[i + 1][j - (x[i] - 500)], make_pair(dp[i][j].first + 1, dp[i][j].second - g[i]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i + 1][j + (1000 - x[i]) % 500] = max(dp[i + 1][j + (1000 - x[i]) % 500], make_pair(dp[i][j].first, dp[i][j].second - g[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int, int>maxn = make_pair(-1, -1);\n\t\tfor (int i = 0; i <= 50000; i++) maxn = max(maxn, dp[n + 1][i]);\n\t\tcout << maxn.first << \" \" << -maxn.second << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nconst int INF = 5000*100*3;\nconst int max_x = 102;\nconst int max_y = 50000;\n\nint dp[max_x+10][max_y+10];\n\nvoid solve(int n){\n    // init\n    for(int j=0;j<max_x+10;j++) for(int k=0;k<max_y+10;k++) dp[j][k] = INF;\n    vector<int> p(n);\n    for(int i=0;i<n;i++) cin >> p[i];\n\n    dp[0][0] = 0;\n    for(int i=0;i<n;i++){\n        const int &pi = p[i];\n        for(int x=n;x>=0;x--){\n            for(int y=max_y;y>=0;y--){\n                if(pi%1000<=500){\n                    if(pi%1000>0 && y-(500-pi%1000)>=0 && x-1>=0)\n                        dp[x][y] = min(dp[x][y],dp[x-1][y-(500-pi%1000)]+pi);\n                    if(y+(pi%1000+500)<=max_y && x-1>=0)\n                        dp[x][y] = min(dp[x][y],dp[x-1][y+(pi%1000+500)]+pi);\n                }else{\n                    if(y+(pi%1000-500) <= max_y && x-1>=0) dp[x][y] = min(dp[x][y], dp[x-1][y + (pi%1000-500)] + pi);\n                    if(y-(1000-pi%1000)>=0) dp[x][y] = min(dp[x][y], dp[x][y-(1000-pi%1000)] + pi);\n                }\n            }\n        }\n    }\n\n\n    for(int i=100;i>=0;i--){\n        int mn = INF;\n        for(int j=0;j<=max_y;j++){\n            if(dp[i][j] < INF){\n                mn = min(mn,dp[i][j]);\n            }\n        }\n        if(mn != INF){\n            cout << i << \" \" << mn << endl;\n            return;\n        }\n    }\n}\n\nint main(){\n    while(1){\n        int n; cin >> n;\n        if(n==0) break;\n        solve(n);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint dp[128][128][256];\nint n;\nint P[128];\n\nvoid init() {\n  for(int i = 0; i < 128; ++i) {\n    for(int j = 0; j < 128; ++j) {\n      for(int k = 0; k < 256; ++k) {\n        dp[i][j][k] = -1;\n      }\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d\", &P[i]);\n    }\n    dp[0][0][0] = 0;\n    for(int i = 0; i < n; ++i) {\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < 256; ++k) {\n          if( dp[i][j][k] == -1 ) continue;\n          dp[i+1][j][k] = std::max(dp[i+1][j][k], dp[i][j][k]);\n          // 1000\n          int count_1000_2 = (P[i] + 999) / 1000;\n          int rem0 = count_1000_2 * 1000 - P[i];\n          int& next0 = dp[i+1][j + (rem0%1000>=500 ? 1 : 0)][k + count_1000_2];\n          next0 = std::max(next0, dp[i][j][k] + (rem0%1000>=500 ? rem0 - 500 : rem0));\n          //\n          int count_1000 = (P[i] + 999) / 1000;\n          int rem1 = dp[i][j][k] + count_1000 * 1000 - P[i];\n          int& next = dp[i+1][j + (rem1%1000>=500 ? 1 : 0)][k + count_1000];\n          next = std::max(next, rem1%1000>=500 ? rem1 - 500 : rem1);\n          // rem\n          if( dp[i][j][k] > P[i] ) {\n            int rem2 = dp[i][j][k] - P[i];\n            int& next = dp[i+1][j + (rem2%1000>=500 ? 1 : 0)][k];\n            next = std::max(next, (rem2%1000>=500 ? rem2 - 500 : rem2));\n          }\n        }\n      }\n    }\n    // for(int i = 0; i <= 4; ++i) {\n    //   for(int j = 0; j <= 4; ++j) {\n    //     for(int k = 0; k < 6; ++k) {\n    //       printf(\"(i, j, k) = (%d, %d, %d) : %d\\n\", i, j, k, dp[i][j][k]);\n    //     }\n    //   }\n    // }\n    int res = (1 << 28);\n    int max = -1;\n    for(int j = n; j >= 0; --j) {\n      for(int k = 0; k < 256; ++k) {\n        if( dp[n][j][k] == -1 ) continue;\n        int cost = k * 1000 - 500 * j - dp[n][j][k];\n        res = std::min(res, cost);\n      }\n      if( res != (1 << 28) ) {\n        max = j;\n        break;\n      }\n    }\n    printf(\"%d %d\\n\", max, res);\n  }\n         \n        \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define SIZE 100100\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nint c[5]={100,50,10,5,1};\nconst int B = 10;\nint encode(vector<int> v){\n\tint S = 0;\n\tfor(int i=0;i<v.size();i++){\n\t\tassert(v[i]<B);\n\t\tS = S*B+v[i];\n\t}\n\treturn S;\n}\nvector<int> decode(int S){\n\tvector<int> v;\n\tint x = B*B*B*B;\n\tfor(int i=0;i<5;i++){\n\t\tv.pb(S/x);\n\t\tS %= x;\n\t\tx /= B;\n\t}\n\treturn v;\n}\nP dp[105][SIZE];\npair<int,vector<int> > charge(int x){\n\tx %= 1000;\n\tvector<int> v(5,0);\n\tint f = x/500;\n\tx -= f*500;\n\tfor(int i=0;i<5;i++){\n\t\tv[i]=x/c[i];\n\t\tx -= v[i]*c[i];\n\t}\n\t//assert(x==0);\n\treturn make_pair(f,v);\n}\n/*void dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}*/\nP dfs(int id,int V){\n\t/*cout << \"call : \" << id << endl;\n\tcout << \"vec : \";\n\tdump(vec);\n\tcout << endl;*/\n\tint tmp = V;\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tmap<int,P>::iterator it;\n\tif(dp[id][V].fi!=-1){\n\t\treturn dp[id][V];\n\t}\n\tP res = dfs(id+1,V);\n\tvector<int> vec = decode(V);\n\tint h = ((p[id]-1)/1000+1)*1000;;\n\tfor(int i=0;i<5;i++){\n\t\twhile(vec[i]>0&&h-p[id]+c[i]<1000){\n\t\t\tvec[i]--;\n\t\t\th += c[i];\n\t\t}\n\t}\n\tpair<int,vector<int> > ch = charge(h-p[id]);\n\tfor(int i=0;i<5;i++)vec[i] += (ch.sec)[i];\n\tP res2 = dfs(id+1,encode(vec));\n\tres2.fi += ch.fi;\n\tres2.sec -= p[id];\n\tdp[id][tmp]=max(res,res2);\n\t/*cout << \"end : \" << id << endl;\n\tcout << \"vec : \";\n\tdump();\n\tcout << \"result : \" << dp[id][vec].fi << ' ' << -dp[id][vec].sec << endl;*/\n\treturn dp[id][tmp];\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<SIZE;j++){\n\t\t\tdp[i][j]=P(-1,-1);\n\t\t}\n\t}\n\tP ans = dfs(0,0);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint f[100][2010],n,a[100],c[100][2010],z;\nint main(){\n\tscanf(\"%d\",&n);\n\twhile(n){\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=1000;j++){\n\t\t\tf[i][j]=-1000;\n\t\t\tc[i][j]=0;\n\t\t}\n\tf[0][0]=0;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<1000;j++)\n\t\t\tif(f[i][j]>=0){\n\t\t\t\tif(f[i+1][j]<f[i][j]||(f[i+1][j]==f[i][j]&&c[i+1][j]>c[i][j])){\n\t\t\t\t\tf[i+1][j]=f[i][j];\n\t\t\t\t\tc[i+1][j]=c[i][j];\n\t\t\t\t}\n\t\t\t\tint k=(0-a[i])%1000+1000;\n\t\t\t\tif(k==1000)k=0;\n\t\t\t\tif(k>=500){\n\t\t\t\t\tk-=500;\n\t\t\t\t\tint jj=(j+k)%1000;\n\t\t\t\t\tif(f[i+1][jj]<f[i+1][j]+1||(f[i+1][jj]==f[i][j]+1&&c[i+1][jj]>c[i][j]+a[i])){\n\t\t\t\t\t\tf[i+1][jj]=f[i][j]+1;\n\t\t\t\t\t\tc[i+1][jj]=c[i][j]+a[i];\n\t\t\t\t\t}\n\t\t\t\t}else if(j+k>=500){\n\t\t\t\t\tif(j+k<1000){\n\t\t\t\t\t\tint jj=(j+k-500);\n\t\t\t\t\t\t//f[i+1][jj]=max(f[i][j]+1,f[i+1][jj]);\n\t\t\t\t\tif(f[i+1][jj]<f[i+1][j]+1||(f[i+1][jj]==f[i][j]+1&&c[i+1][jj]>c[i][j]+a[i])){\n\t\t\t\t\t\tf[i+1][jj]=f[i][j]+1;\n\t\t\t\t\t\tc[i+1][jj]=c[i][j]+a[i];\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(f[i+1][j+k]<f[i][j]||(f[i+1][j+k]==f[i][j]&&c[i+1][j+k]>c[i][j])){\n\t\t\t\t\t\tf[i+1][j+k]=f[i][j];\n\t\t\t\t\t\tc[i+1][j+k]=c[i][j]+a[i];\n\t\t\t\t\t}\n\t\t\t\t\t//f[i+1][j+k]=max(f[i][j],f[i+1][j+k]);\n\t\t\t\t}\n\t\t\t}\n\tint ans=0,co=0;\n\tfor(int i=0;i<1000;i++)\n\t\tif(ans<f[n][i]||(ans==f[n][i]&&co>c[n][i])){\n\t\t\tans=f[n][i];\n\t\t\tco=c[n][i];\n\t\t}\n\tprintf(\"%d %d\\n\",ans,co);\n\tscanf(\"%d\",&n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef int ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e9;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nconst ll M = 100*5000;\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n;\n    while (cin >> n, n) {\n        vector<ll> p(n); cin >> p;\n        vector<vector<P>> dp(2, vector<P>(M+1, {-1, -1}));\n        dp[0][0] = {0, 0};\n        rep(i, n) {\n            dp[i+1&1].assign(M+1, {-1, -1});\n            rep(j, M+1) {\n                if (dp[i&1][j].first < 0) continue;\n                ll c, r; tie(c, r) = dp[i&1][j];\n                if (0 < p[i] % 1000 && p[i] % 1000 <= 500) {\n                    // ??????\n                    assert(j+p[i] <= M);\n                    chmax(dp[i+1&1][j+p[i]], P(c+1, r+(500-p[i]%1000)));\n                }\n                else {\n                    // ????????????\n                    chmax(dp[i+1&1][j], dp[i&1][j]);\n                    // ???????????????\n                    chmax(dp[i+1&1][j+p[i]], P(c, r+(1000-p[i]%1000)%1000));\n                    // 500????????????????????????????????????\n                    ll need = (p[i]+500) % 1000;\n                    if (r >= need) {\n                        chmax(dp[i+1&1][j+p[i]], P(c+1, r-need));\n                    }\n                }\n            }\n        }\n        P ans{0, 0};\n        rep(i, M+1) {\n            chmax(ans, P(dp[n&1][i].first, -i));\n        }\n        cout << ans.first << \" \" << -ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nusing P = pair<int, int>;\n\nP f(P a, P b) {\n    return (a.first > b.first ? a : a.first < b.first ? b : a.second < b.second ? a : b);\n}\n\nvoid _main() {\n    int n;\n    while (cin >> n, n) {\n        vector<int> p(n);\n        REP (i, n) cin >> p[i];\n        const int INF = 1 << 30;\n        vector<vector<P>> dp(n + 1, vector<P>(50000, P(-INF, INF)));\n        dp[0][0] = P(0, 0);\n        REP (i, n) REP (j, 50000) if (dp[i][j].first != -INF) {\n            dp[i + 1][j] = f(dp[i + 1][j], dp[i][j]);\n            int q = p[i] % 1000;\n            if (q >= 1 && q <= 500) {\n                dp[i + 1][j + 500 - q] = f(dp[i + 1][j + 500 - q], P(dp[i][j].first + 1, dp[i][j].second + p[i]));\n            } else {\n                int r = (q + 500) % 1000;\n                if (j >= r) dp[i + 1][j - r] = f(dp[i + 1][j - r], P(dp[i][j].first + 1, dp[i][j].second + p[i]));\n                if (q != 0) dp[i + 1][j + 1000 - q] = f(dp[i + 1][j + 1000 - q], P(dp[i][j].first, dp[i][j].second + p[i]));\n            }\n        }\n        int x = 0, y = INF;\n        REP (i, 50000) {\n            if (dp[n][i].first > x) {\n                tie(x, y) = dp[n][i];\n            } else if (x == dp[n][i].first) {\n                y = min(y, dp[n][i].second);\n            }\n        }\n        cout << x << \" \" << y << endl;\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint sv[110];\npair<int,int> dp[2][50010];\nbool cmp(pair<int,int> &A, pair<int,int> &B) { \n    return ( A.first < B.first ) || (A.first == B.first && A.second > B.second); \n}\n// first := 500円玉の枚数（多いほどいい）\n// second := 消費金額（少ないほどいい）\nint n;\n\nbool solve()\n{\n\n    cin >> n;\n    if(n == 0) return false;\n    for(int i = 0; i < n; ++i) {\n        cin >> sv[i];\n    }\n\n    int MAX_K = 500*n;\n    for(int i = 0; i < 2; ++i) {\n        for(int j = 0; j < MAX_K; ++j) {\n            dp[i][j].first = -1;\n            dp[i][j].second = 0;\n        }\n    }\n    \n    dp[0][0].first = 0;\n    for(int i = 0; i < n; ++i) {\n        int prv = i%2;\n        int nxt = 1 - prv;\n        for(int j = 0; j < MAX_K; ++j) {\n            dp[nxt][j] = dp[prv][j];\n        }\n\n        int add = (1000 - sv[i]%1000)%1000; // 1000円札だけだしてもらえるおつり\n        int need = (sv[i] + 500)%1000;      // 小銭も出して500円玉を得る場合に必要な金額\n        //cout << \"add: \" << add << \" need: \" << need << endl;\n        for(int j = 0; j < MAX_K; ++j) {\n            if(dp[prv][j].first == -1) continue;\n\n            int num = dp[prv][j].first;\n            int money = dp[prv][j].second;\n\n            if(add >= 500) {\n                // 1000円札だけ出して小銭と500円玉もらう方がいい\n                if(j + add - 500 >= MAX_K) continue;\n                pair<int,int> X = make_pair(num + 1, money + sv[i]);\n                if(cmp(dp[nxt][j + add - 500], X)) dp[nxt][j + add - 500] = X; \n                continue;\n            }\n\n            // 小銭も出して500円玉をもらう\n            if(j - need >= 0) {\n                pair<int,int> X = make_pair(num + 1, money + sv[i]);\n                if(cmp(dp[nxt][j - need], X)) dp[nxt][j - need] = X;\n            }\n\n            // 500円玉を諦め、1000円札だけ出して小銭を得る\n            if(j + add < MAX_K) {\n                pair<int,int> X = make_pair(num, money + sv[i]);\n                if(cmp(dp[nxt][j + add], X)) dp[nxt][j + add] = X;\n            }\n\n        }\n\n        // デバッグ\n        /*\n        for(int j = 0; j < MAX_K; ++j) {\n            if(dp[nxt][j].first != -1) {\n                cout << \"j:\" << j << \" (\" << dp[nxt][j].first << \", \" << dp[nxt][j].second << \")\" << endl;\n            }\n        }\n        */\n    }\n    \n    int num = 0, money = 1000000009;\n    int r = n%2;\n    for(int i = 0; i < MAX_K; ++i) {\n        if(dp[r][i].first == -1) continue;\n        if(num < dp[r][i].first) {\n            num = dp[r][i].first, money = dp[r][i].second;\n        }\n        else if(num == dp[r][i].first) {\n            money = min(money, dp[r][i].second);\n        }\n    }\n\n    cout << num << \" \" << money << endl;\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n \n \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint n;\npair<int,int> dp[101][540005];\nbool me[101][540005]={0};\nsigned main(){\n\twhile(1){\n\tcin>>n;\n\t\tif(n==0) break;\n\t\t\n\t\tfor(int i=0;i<=100;i++)for(int j=0;j<540005;j++){\n\t\t\tdp[i][j]=mp(0,-10000000);\n\t\t\t\n\t\t\tme[i][j]=0;\n\t\t}\n\t\tme[0][0]=1;\n\t\tdp[0][0]=mp(0,0);\n\t\t\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint p,pq;\n\t\t\tcin>>p;\n\t\t\tpq=p;\n\t\t\tp%=1000;\n\t\t\t\n\t\t\tif(p==0) p+=1000;\n\t\t\tfor(int j=0;j<540005;j++){\n\t\t\t\tif(me[i-1][j]==0) continue;\n\t\t\t\tme[i][j]=1;\n\t\t\t\tif(dp[i][j]<dp[i-1][j]) dp[i][j]=dp[i-1][j];\n\t\t\t\tif(p>500){\n\t\t\t\t\tme[i][j+(1000-p)]=1;\n\t\t\t\t\tif(dp[i][j+(1000-p)]<mp(dp[i-1][j].first,dp[i-1][j].second-pq)) dp[i][j+(1000-p)]=mp(dp[i-1][j].first,dp[i-1][j].second-pq);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tme[i][j+(1000-p-500)]=1;\n\t\t\t\t\tif(dp[i][j+(500-p)]<mp(dp[i-1][j].first+1,dp[i-1][j].second-pq)) dp[i][j+(500-p)]=mp(dp[i-1][j].first+1,dp[i-1][j].second-pq);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(p>500){\n\t\t\t\t\tif(j>=p+500-1000){\n\t\t\t\t\t\tme[i][j-(p-500)]=1;\n\t\t\t\t\t\tif(dp[i][j-(p-500)]<mp(dp[i-1][j].first+1,dp[i-1][j].second-pq)) dp[i][j-(p-500)]=mp(dp[i-1][j].first+1,dp[i-1][j].second-pq);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(j>=p+500){\n\t\t\t\t\t\tme[i][j-(p+500)]=1;\n\t\t\t\t\t\tif(dp[i][j-(p+500)]<mp(dp[i-1][j].first+1,dp[i-1][j].second-pq)) dp[i][j-(p+500)]=mp(dp[i-1][j].first+1,dp[i-1][j].second-pq);\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpa ans=mp(0,-100000000);\n\t\tfor(int j=0;j<540005;j++){\n\t\t\tif(me[n][j]==0) continue;\n\t\t\tif(dp[n][j]>ans)ans=dp[n][j];\n\t\t}\n\t\n\t\t\n\t\tcout<<ans.first<<\" \"<<-ans.second<<endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define fi first\n#define sc second\n#define mp make_pair\npair<int,int> dp[105][100005];\nint n,p[105];\nint main(){\n\twhile(1){\n\t\tcin>>n; if(!n) return 0;\n\t\tfor(int i=1;i<=n;i++) cin>>p[i];\n\t\tfor(int i=0;i<105;i++) for(int j=0;j<100005;j++) dp[i][j] = mp(-10000,1000000000);\n\t\tdp[0][0] = mp(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<=1000*i;j++){\n\t\t\t\tif(dp[i][j].fi < 0) continue; //cout <<i << \" \" <<j<< endl;\n\t\t\t\tif(dp[i+1][j].fi < dp[i][j].fi) dp[i+1][j] = dp[i][j];\n\t\t\t\telse if(dp[i+1][j].fi == dp[i][j].sc) dp[i+1][j].sc = min(dp[i+1][j].sc,dp[i][j].sc);\n\t\t\t\tint k = 1000-(p[i+1]%1000); if(k==1000) k = 0;\n\t\t\t\tif(dp[i+1][j+k].fi < dp[i][j].fi) {\n\t\t\t\t\tdp[i+1][j+k] = dp[i][j];\n\t\t\t\t\tdp[i+1][j+k].sc += p[i+1];\n\t\t\t\t}\n\t\t\t\telse if(dp[i+1][j+k].fi == dp[i][j].fi){\n\t\t\t\t\tdp[i+1][j+k].sc = min(dp[i+1][j+k].sc ,dp[i][j].sc+p[i+1]);\n\t\t\t\t}\n\t\t\t\tif(!k && j < 500 ) continue;\n\t\t\t\tif((p[i+1]%1000)/100 >=5 && (p[i+1]%1000)-500 >j) continue;\n\t\t\t\tk =1000-k;\n\t\t\t\tint a = dp[i+1][j+500-k].fi;\n\t\t\t\tif(a < dp[i][j].fi+1){\n\t\t\t\t\tdp[i+1][j+500-k] = dp[i][j];\n\t\t\t\t\tdp[i+1][j+500-k].fi += 1;\n\t\t\t\t\tdp[i+1][j+500-k].sc += p[i+1];\n\t\t\t\t}\n\t\t\t\telse if(a == dp[i][j].fi+1){\n\t\t\t\t\tdp[i+1][j+500-k].sc = min(dp[i+1][j+500-k].sc ,dp[i][j].sc+p[i+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int,int> ans = mp(-10000,1000000000);\n\t\tfor(int j=0;j<100005;j++){\n\t\t\tif(ans.fi < dp[n][j].fi) ans = dp[n][j];\n\t\t\telse if(ans.fi == dp[n][j].fi) ans.sc = min(ans.sc,dp[n][j].sc);\n\t\t}\n\t\tcout <<ans.fi<<\" \" << ans.sc << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define SIZE 5100\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nint c[5]={100,50,10,5,1};\nconst int B = 10;\nint encode(vector<int> v){\n\tint S = 0;\n\tfor(int i=0;i<v.size();i++){\n\t\tassert(v[i]<B);\n\t\tS = S*B+v[i];\n\t}\n\treturn S;\n}\nvector<int> decode(int S){\n\tvector<int> v;\n\tint x = B*B*B*B;\n\tfor(int i=0;i<5;i++){\n\t\tv.pb(S/x);\n\t\tS %= x;\n\t\tx /= B;\n\t}\n\treturn v;\n}\nP dp[105][SIZE];\npair<int,vector<int> > charge(int x){\n\tx %= 1000;\n\tvector<int> v(5,0);\n\tint f = x/500;\n\tx -= f*500;\n\tfor(int i=0;i<5;i++){\n\t\tv[i]=x/c[i];\n\t\tx -= v[i]*c[i];\n\t}\n\t//assert(x==0);\n\treturn make_pair(f,v);\n}\n/*void dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}*/\nP dfs(int id,int V){\n\t/*cout << \"call : \" << id << endl;\n\tcout << \"vec : \";\n\tdump(vec);\n\tcout << endl;*/\n\tint tmp = V;\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tmap<int,P>::iterator it;\n\tif(dp[id][V].fi!=-1){\n\t\treturn dp[id][V];\n\t}\n\tP res = dfs(id+1,V);\n\tvector<int> vec = decode(V);\n\tint h = ((p[id]-1)/1000+1)*1000;;\n\tfor(int i=0;i<5;i++){\n\t\twhile(vec[i]>0&&h-p[id]+c[i]<1000){\n\t\t\tvec[i]--;\n\t\t\th += c[i];\n\t\t}\n\t}\n\tpair<int,vector<int> > ch = charge(h-p[id]);\n\tfor(int i=0;i<5;i++)vec[i] += (ch.sec)[i];\n\tP res2 = dfs(id+1,encode(vec));\n\tres2.fi += ch.fi;\n\tres2.sec -= p[id];\n\tdp[id][tmp]=max(res,res2);\n\t/*cout << \"end : \" << id << endl;\n\tcout << \"vec : \";\n\tdump();\n\tcout << \"result : \" << dp[id][vec].fi << ' ' << -dp[id][vec].sec << endl;*/\n\treturn dp[id][tmp];\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<SIZE;j++){\n\t\t\tdp[i][j]=P(-1,-1);\n\t\t}\n\t}\n\tP ans = dfs(0,0);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvoid chmax(int&a,int b)\n{\n\ta=max(a,b);\n}\nmain()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tvector<vector<int> >dp(n+2,vector<int>(5e5+1,-1));\n\t\tdp[0][0]=0;\n\t\tfor(int count=0;count<n;count++)\n\t\t{\n\t\t\tint p;cin>>p;\n\t\t\tint oturi=p%1000?1000-p%1000:0;\n\t\t\tfor(int k=n;k>=0;k--)\n\t\t\t{\n\t\t\t\tfor(int j=5e5;j>=0;j--)\n\t\t\t\t{\n\t\t\t\t\tif(dp[k][j]<0)continue;\n\t\t\t\t\tchmax(dp[k][j+p],dp[k][j]+oturi);\n\t\t\t\t\tchmax(dp[k+(dp[k][j]+oturi>=500)][j+p],\n\t\t\t\t\t\t\tdp[k][j]+oturi-(dp[k][j]+oturi>=500?500:0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint f=0;\n\t\tfor(int k=n;!f&&k>=0;k--)\n\t\t{\n\t\t\tfor(int i=0;!f&&i<=5e5;i++)\n\t\t\t{\n\t\t\t\tif(dp[k][i]>=0)\n\t\t\t\t{\n\t\t\t\t\tcout<<k<<\" \"<<i<<endl;\n\t\t\t\t\tf=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nconstexpr int MAX = 100;\nconstexpr int RES = 1000;\nconstexpr int INF = 1 << 30;\nint dp[MAX + 1][MAX + 1][RES];  // i?????????:500??????j???:??????????????¬??¨k??? ??¨??????????°?????????????\n\nint main()\n{\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<int> p(n);\n        for (int i = 0; i < n; i++) {\n            cin >> p[i];\n        }\n\n\n        for (int i = 0; i <= MAX; i++) {\n            for (int j = 0; j <= MAX; j++) {\n                for (int k = 0; k < RES; k++) {\n                    dp[i][j][k] = INF;\n                }\n            }\n        }\n        dp[0][0][0] = 0;\n\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= n; j++) {\n                for (int k = 0; k < RES; k++) {\n                    if (dp[i][j][k] != INF) {\n                        dp[i + 1][j][k] = min(dp[i + 1][j][k], dp[i][j][k]);\n                        const int pr = p[i] % 1000;\n                        if (k >= pr) {\n                            const int ret = k - pr;\n                            dp[i + 1][j][ret] = min(dp[i + 1][j][ret], dp[i][j][k] + p[i]);\n                            if (ret >= 500) {\n                                dp[i + 1][j + 1][ret - 500] = min(dp[i + 1][j + 1][ret - 500], dp[i][j][k] + p[i]);\n                            } else if (pr != 0) {\n                                dp[i + 1][j + 1][ret + 500] = min(dp[i + 1][j + 1][ret + 500], dp[i][j][k] + p[i]);\n                            }\n                        } else {\n                            const int pr = p[i] % 1000;\n                            const int ret = k + 1000 - pr;\n                            //                            dp[i + 1][j][ret] = min(dp[i + 1][j][ret], dp[i][j][k] + p[i]);\n                            if (ret >= 500) {\n                                dp[i + 1][j + 1][ret - 500] = min(dp[i + 1][j + 1][ret - 500], dp[i][j][k] + p[i]);\n                            } else {\n                                dp[i + 1][j][ret] = min(dp[i + 1][j][ret], dp[i][j][k] + p[i]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for (int j = n; j >= 0; j--) {\n            int mini = INF;\n            for (int k = 0; k < RES; k++) {\n                mini = min(mini, dp[n][j][k]);\n            }\n            if (mini != INF) {\n                cout << j << \" \" << mini << endl;\n                break;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_MONEY = 5000;\nint n;\nvector<int> p;\nvector<vector<pair<int, int>>> memo;\n\ninline void Change(pair<int, int> &a, pair<int, int> &b) {\n    if ((a.first < b.first) || (a.first == b.first && a.second > b.second))\n        a = b;\n}\n\npair<int, int> Solve(int idx, int money) {\n    if (idx == n)\n        return pair<int, int>(0, 0);\n\n    auto &opt = memo[idx][money];\n    if (opt.first != -1)\n        return opt;\n\n    // idx?????????????????§????????????\n    opt = Solve(idx + 1, money);\n\n    // idx?????????????????§??????\n    if (0 < (p[idx] % 1000) && (p[idx] % 1000) <= 500) {\n        // 1000????????§?????????\n        int res = 1000 - (p[idx] % 1000) - 500 + money;\n        auto tmp = Solve(idx + 1, res);\n        tmp.first += 1;\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n    else if (p[idx] % 1000 == 0) {\n        if (500 <= money) {\n            int res = money - 500;\n            auto tmp = Solve(idx + 1, res);\n            tmp.first += 1;\n            tmp.second += p[idx];\n            Change(opt, tmp);\n        }\n    }\n    else if (500 <= money + 1000 - (p[idx] % 1000)) {\n        // 1000????????¨?°????money??§?????????\n        int res = money + 1000 - (p[idx] % 1000) - 500;\n        auto tmp = Solve(idx + 1, res);\n        tmp.first += 1;\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n    else {\n        // 1000??????????????§?????????\n        int res = 1000 - (p[idx] % 1000) + money;\n        auto tmp = Solve(idx + 1, res);\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n\n    return opt;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n, n) {\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            cin >> p[i];\n\n        memo.clear();\n        memo.resize(n, vector<pair<int, int>>(n * 5000,\n                                              pair<int, int>(-1, 0)));\n\n        auto res = Solve(0, 0);\n        cout << res.first << ' ' << res.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\npair<int, int> memo[100 + 1][50 * 5000 + 1];\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *) array, (T *) (array + N), val);\n}\n\nstd::pair<int, int> f(const int n, int nokori, int n_, const int *p) {\n    if (n <= n_)return std::make_pair(0, 0);\n    if (memo[n_][nokori].second > -1)return memo[n_][nokori];\n    int s = p[n_] % 1000;\n    int c = 0;\n    int nokori_ = nokori;\n    pair<int, int> ans = make_pair(0, 0);\n    if (s > 500 || s == 0) {\n        ans = f(n, nokori, n_ + 1, p);\n    }\n\n    if (s != 0) {\n        if (s <= 500) {\n            c++;\n            nokori += (500 - s);\n        } else {\n            if (s > 500)s -= 500;\n            if (s <= nokori) {\n                c++;\n                nokori -= s;\n            } else {\n                nokori += (500 - s);\n            }\n        }\n    } else if (nokori >= 500) {\n        c++;\n    } else {\n        return memo[n_][nokori_] = ans;\n    }\n    pair<int, int> hoge = f(n, nokori, n_ + 1, p);\n    pair<int, int> hoge_ = make_pair(hoge.first + c, hoge.second + p[n_]);\n    if (ans.first < hoge_.first) {\n        ans = hoge_;\n    } else if (ans.first == hoge_.first && ans.first > hoge_.first) {\n        ans = hoge_;\n    }\n    return memo[n_][nokori_] = ans;\n}\n\nint main() {\n    int n;\n    int p[100];\n    while (cin >> n, n) {\n        Fill(p, 0);\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < 250001; j ++){\n                memo[i][j] = make_pair(0,-1);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            cin >> p[i];\n        }\n        pair<int, int> ans = f(n, 0, 0, p);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define rep1(i,n) for(int i=1;i<=int(n);++i)\n#define all(a) a.begin(),a.end()\n#define lb(s,x) lower_bound(all(s),x)-s.begin()\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n#define INF 1e9\ntypedef long long ll;\n\n#define updmin(dp,x) (dp=(dp == 0 ? x : min(dp,x)))\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        vector<int> p(n);\n        rep(i,n) cin>>p[i];\n        vector<map<int,int>> dp(n+1); // dp[get][coin] = pay\n        dp[0][0] = 0;\n        rep(i,n){\n            for(int k = i; k >= 0; k--){\n                for(auto itr = dp[k].rbegin(); itr != dp[k].rend(); ++itr){\n                    int coin = itr->first;\n                    int pay = itr->second;\n                    int mod = p[i]%500;\n                    if(p[i]%1000 == 0){\n                        if(coin>=500) updmin(dp[k+1][coin-500], pay+p[i]);\n                    }else if(p[i]%1000 == 500){\n                        updmin(dp[k+1][coin], pay+p[i]);\n                    }else if(p[i]%1000 <= 500){\n                        updmin(dp[k+1][coin+500-mod], pay+p[i]);\n                    }else if(mod <= coin){\n                        updmin(dp[k+1][coin-mod], pay+p[i]);\n                    }else{\n                        updmin(dp[k][coin+500-mod], pay+p[i]);\n                    }\n                }\n            }\n        }\n        for(int i = n; i>=0; i--){\n            if(dp[i].size()){\n                int res = 0;\n                for(auto itr : dp[i]){\n                    updmin(res, itr.second);\n                }\n                cout<<i<<\" \"<<res<<endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint dp[101][101][700];\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    int p[n];\n    for(int i=0;i<n;i++) cin>>p[i];\n    memset(dp,-1,sizeof(dp));\n    dp[0][0][0]=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<650;k++){\n\t  if(dp[i][j][k]<0) continue;\n\t  for(int a=0;a<7;a++){\n\t    int tmp=0,flg=0;\n\t    tmp=1000*a-p[i];\n\t    if(tmp>=0) tmp%=1000;\n\t    if(dp[i][j][k]+tmp<0) continue;\n\t    if(dp[i][j][k]+tmp>=500){\n\t      tmp-=500;\n\t      flg=1;\n\t    }\n\t    dp[i+1][j+flg][k+a]=max(dp[i+1][j+flg][k+a],dp[i][j][k]+tmp);\n\t  }\n\t  dp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t}\n      }\n    }\n    /*//\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\tfor(int k=0;k<650;k++){\n\t  if(dp[i][j][k]<0) continue;\n\t  cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<dp[i][j][k]<<endl;\n\t}\n      }\n    }\n    //*/\n    int c=0,s=0;\n    for(int j=0;j<=n;j++){\n      for(int k=0;k<650;k++){\n\tif(dp[n][j][k]<0) continue;\n\tint tmp=1000*k-500*j-dp[n][j][k];\n\tif(c<j) c=j,s=tmp;\n\tif(c==j) s=min(s,tmp);\n      }\n    }\n    cout<<c<<\" \"<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nP dp[101][50001];\n\nvoid Max(P &a,P b){a=max(a,b);}\n\nint main(){\n  int n,p[101];\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>p[i];\n  \n    memset(dp,-1,sizeof(dp));\n    dp[0][0]=P(0,0);\n  \n    for(int i=0;i<n;i++)\n      for(int j=0;j<50000;j++){\n\tif(dp[i][j]==P(-1,-1))continue;\n\tint coin=dp[i][j].first;\n\tint ncost=dp[i][j].second-p[i];\n\tMax(dp[i+1][j],dp[i][j]);\n\tif(p[i]%1000<500&&p[i]%1000)Max(dp[i+1][j+(500-p[i]%500)],P(coin+1,ncost));\n\tif(p[i]%1000==0&&j>=500) Max(dp[i+1][j-500],P(coin+1,ncost));\n\t\n\tif(p[i]%1000>=500) {\n\t  if(j>=p[i]%500)Max(dp[i+1][j-p[i]%500],P(coin+1,ncost));\n\t  else Max(dp[i+1][j+(500-p[i]%500)],P(coin,ncost));\n\t}\n      }\n    \n    P ans=P(0,0);\n    for(int i=0;i<50000;i++)Max(ans,dp[n][i]);\n    cout <<ans.first<<\" \"<<-ans.second<<endl;\n    \n  }\t\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1000000;\nconst ll longinf=1LL<<62 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nvoid chmin(int& x,int y){\n    if(x>y)x=y;\n}\n\nint main(){\n    int n;\n    while(cin>>n,n!=0){\n        int p[n];\n        rep(i,n)cin>>p[i];\n        int dp[n+1][50555],dpp[n+1][50555];\n        rep(i,n+1)rep(j,50555)dp[i][j]=dpp[i][j]=inf;\n        dp[0][0]=0;\n        rep(s,n){\n            rep(j,s+1)rep(k,500*s+1)dpp[j][k]=inf;\n            rep(i,s+1)rep(j,500*s+1){\n            int c=p[s]%1000;\n            dpp[i][j]=min(dpp[i][j],dp[i][j]);\n            if(c==0){\n                if(j>=500)chmin(dpp[i+1][j-500],dp[i][j]+p[s]);\n            }\n            else if(c<=500){\n                chmin(dpp[i+1][j+500-c],dp[i][j]+p[s]);\n            }\n            else {\n                if(c-500<=j)chmin(dpp[i+1][j-c+500],dp[i][j]+p[s]);\n                else chmin(dpp[i][j+1000-c],dp[i][j]+p[s]);\n            }\n            }\n            rep(i,s+1)rep(j,500*s+1)dp[i][j]=dpp[i][j];\n        }\n        rep(i,n+1){\n            sort(dp[n-i],dp[n-i]+50555);\n            if(dp[n-i][0]!=inf){\n                cout<<n-i<<\" \"<<dp[n-i][0]<<endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\ntypedef pair<int,int> P; //500, -totalcost\n\nP dp[101][50000];\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        fill(dp[0],dp[101],P(0,-5000000));\n        dp[0][0]=P(0,0);\n        for(int i=0;i<n;i++){\n            int price;\n            cin>>price;\n            for(int c=0;c<50000;c++){\n                if(dp[i][c].second<=-5000000) continue;\n                dp[i+1][c]=max(dp[i+1][c],dp[i][c]); //????????????\n                if(price%1000==0){\n                    if(c>=500){\n                        dp[i+1][c-500]=max(dp[i+1][c-500],P(dp[i][c].first+1,dp[i][c].second-price));\n                    }\n                    continue;\n                }else{\n                    if(price%1000<=500){//500????????¨?????£???????¢???????\n                        int cc= c + 1000 - price%1000 - 500;\n                        dp[i+1][cc]=max(dp[i+1][cc],P(dp[i][c].first+1,dp[i][c].second-price));\n                    }else{\n                        if(price%1000-500<=c){\n                            int cc = c - (price%1000-500);\n                            //?°???????????????????500??????????¢???????\n                            dp[i+1][cc]=max(dp[i+1][cc],P(dp[i][c].first+1,dp[i][c].second-price));\n                        }\n                        //500??????????¢??????????????°???????????¢???????\n                        int cc = c + (1000-price%1000);\n                        dp[i+1][cc]=max(dp[i+1][cc],P(dp[i][c].first,dp[i][c].second-price));\n                    }\n                }\n            }\n        }\n        P ans = P(0,-5000000);\n        for(int c=0;c<50000;c++) if(dp[n][c].second>-5000000) ans = max(dp[n][c],ans);\n        cout<<ans.first<<' '<<-ans.second<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// finish date: 2018/06/21\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <map>\n#include <climits>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i, a, b) for(int (i)=a;(i)<(b);(i)++)\n#define rep(i, n)  FOR(i,0,n)\n#define ll long long\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vvvi vector<vector<vector<int>>>\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vd vector<double>\n#define vvd vector<vector<double>>\n#define vb vector<bool>\n#define vvb vector<vector<bool>>\n#define vs vector<string>\n#define vc vector<char>\n#define vvc vector<vector<char>>\n#define pii pair<int,int>\nconst int bigmod = 1000000007;\n#define INF 1050000000\n\n\nint main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        vi p(n);\n        rep(i, n) {\n            cin >> p[i];\n        }\n        int maxDP = n * 1000;\n        vector<pii > DP(maxDP, pii(-1, -1));\n        DP[0] = pii(0, 0);\n        vector<pii > newDP;\n        rep(i, n) {\n            newDP = vector<pii >(maxDP, pii(-1, -1));\n            int otsuri = 1000 - p[i] % 1000;\n            if (otsuri == 1000) otsuri = 0;\n            for (int j = maxDP - 1; j >= 0; j--) {\n                if (DP[j] == pii(-1, -1)) continue;\n                bool con1 = newDP[j + otsuri].first < DP[j].first;\n                bool con2 = newDP[j + otsuri].first == DP[j].first;\n                bool con3 = newDP[j + otsuri].second > DP[j].second + p[i];\n                if (con1 || (con2 && con3)) {\n                    newDP[j + otsuri] = DP[j];\n                    newDP[j + otsuri].second += p[i];\n                }\n            }\n            rep(j, maxDP) {\n                if (newDP[j] == pii(-1, -1)) continue;\n                if (j >= 500) {\n                    bool con1 = newDP[j - 500].first < newDP[j].first + 1;\n                    bool con2 = newDP[j - 500].first == newDP[j].first + 1;\n                    bool con3 = newDP[j - 500].second > newDP[j].second;\n                    if (con1 || (con2 && con3)) {\n                        newDP[j - 500] = newDP[j];\n                        newDP[j - 500].first++;\n                    }\n                }\n            }\n            rep(j, maxDP) {\n                if (DP[j].first > newDP[j].first || (DP[j].first == newDP[j].first && DP[j].second < newDP[j].second)) {\n                    newDP[j] = DP[j];\n                }\n            }\n            DP = newDP;\n        }\n\n\n\n        int ma = -1;\n        int ansMoney = 0;\n        rep(i, maxDP) {\n            if (DP[i].first > ma || (DP[i].first == ma && DP[i].second < ansMoney)) {\n                ma = DP[i].first;\n                ansMoney = DP[i].second;\n            }\n        }\n        cout << ma << \" \" << ansMoney << endl;\n\n    }\n\n\n    return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint dp[110][110][1010]={0};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\trep(i,110)rep(j,110)rep(k,1010)dp[i][j][k]=inf;\n\t\tdp[0][0][0]=0;\n\t\tvi a(n);\n\t\trep(i,n)cin>>a[i];\n\t\trep(i,n)rep(j,n)rep(k,1000)if(dp[i][j][k]!=inf){\n\t\t\tint I=i+1,J=j,K=k;\n\t\t\tdp[I][J][K]=min(dp[I][J][K],dp[i][j][k]);\n\t\t\tint t=1000-a[i]%1000;\n\t\t\tif(t==1000)t=0;\n\t\t\tif(a[i]%500<=K&&K&&(a[i]-1)%1000+1>500)dp[I][J+1][K-a[i]%500]=min(dp[I][J+1][K-a[i]%500],dp[i][j][k]+a[i]);\n\t\t\tif(t>=500){\n\t\t\t\tif(t<=K)dp[I][J+1][K-t]=min(dp[I][J+1][K-t],dp[i][j][k]+a[i]);\n\t\t\t\tif(K+t-500<1010)dp[I][J+1][K+t-500]=min(dp[I][J+1][K+t-500],dp[i][j][k]+a[i]);\n\t\t\t}else if(K+t<1010)dp[I][J][K+t]=min(dp[I][J][K+t],dp[i][j][k]+a[i]);\n\t\t}\n\t\tint out=0,ne=inf;\n\t\trep(i,n+1)rep(j,1010)if(out<=i&&dp[n][i][j]!=inf){\n\t\t\tif(out==i)ne=min(ne,dp[n][i][j]);\n\t\t\telse ne=dp[n][i][j];\n\t\t\tout=max(out,i);\n\t\t}\n\t\tcout<<out<<\" \"<<ne<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define _for(i,j,N) for(int i = (j);i < (N);i++)\n#define _rep(i,j,N) for(int i = (j);i <= (N);i++)\n#define ALL(x) x.begin(),x.end()\n#define PB push_back\n#define LL long long\n\nconst int maxzeni = 10000;\n\nint dp[102][10001];\nint pp[102];\nint reals[102];\n\nint money[102][10001];\n\nvoid update2(int &a,int b,int &c,int d){\n    if(a < b){\n        a = b;\n        c = d;\n    }\n    else if(a == b){\n        if(c > d || c < 0) c = d;\n    }\n}\n\nvoid update(int i,int zeni,int c,int real){\n    int val = dp[i][zeni];\n    //cout << \"i:\"<<i << \"zeni:\"<<zeni << \"reals:\"<< real <<endl;\n    update2(dp[i+1][zeni],val,money[i+1][zeni],money[i][zeni]);\n\n    if(zeni - c >= 500){\n        update2(dp[i+1][zeni - c - 500],val+1,money[i+1][zeni - c - 500],money[i][zeni]+real);\n    }\n\n    if(1000 - c >= 500 && (1000 - c - 500+ zeni) <= maxzeni){\n        update2(dp[i+1][1000 - c - 500 + zeni],val+1,money[i+1][1000 - c - 500+zeni],money[i][zeni]+real);\n    }\n\n    else{\n        if(1000 + zeni - c >= 500 && 1000 + zeni - c <= maxzeni){\n            update2(dp[i+1][1000 + zeni - c - 500],val+1,money[i+1][1000 + zeni - c - 500],money[i][zeni]+real);\n        }\n        else{\n            update2(dp[i+1][1000 + zeni - c],val,money[i+1][1000 + zeni - c],money[i][zeni]+real);\n        }\n    }\n\n}\n\nint main()\n{\n    int p;\n    while(scanf(\"%d\",&p)&&p){\n        memset(dp,-1,sizeof(dp));\n        memset(money,-1,sizeof(money));\n        _for(i,0,p) {\n            scanf(\"%d\",&pp[i]);\n            reals[i] = pp[i];\n            pp[i] %= 1000;\n            if(pp[i] == 0) pp[i] = 1000;\n        }\n\n        dp[0][0] = 0;\n        money[0][0] = 0;\n\n        _for(i,0,p){\n            _for(j,0,maxzeni){\n                if(dp[i][j] >= 0){\n                    update(i,j,pp[i],reals[i]);\n                }\n            }\n        }\n\n        int maxcoin = 0;\n        int min_cost = 0;\n        _for(j,0,maxzeni){\n            if(dp[p][j] >= maxcoin){\n                //cout << j <<\" \"<< money[p][j] <<endl;\n                if(dp[p][j] > maxcoin){\n                    maxcoin = dp[p][j];\n                    min_cost = money[p][j];\n                }\n                else{\n                    min_cost = min(min_cost,money[p][j]);\n                }\n            }\n        }\n        cout << maxcoin <<\" \"<<min_cost << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) begin(V), end(V)\n#define ALLR(V) rbegin(V), rend(V)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nconst size_t SIZE1 = 102;\nconst size_t SIZE2 = 5000;\nconst ll inf = 5e15;\nPLL dp[2][SIZE2];\n\nbool solve() {\n    ll N;\n    cin >> N;\n    if (!N) return false;\n\n    V<ll> P(N);\n    for (ll &e : P) cin >> e;\n    \n    fill(ALL(dp[0]), PLL(-inf, inf));\n    dp[0][0] = PLL(0, 0);\n\n    auto get_v = [&](ll i, ll use, bool inc) {\n        PLL p = dp[0][i];\n        p.second += use;\n        if (inc) p.first++;\n        return p;\n    };\n\n    auto upd = [&](ll i, PLL p) {\n        auto &cur = dp[1][i];\n        if (cur.first != p.first) chmax(cur, p);\n        else chmin(cur, p);\n    };\n\n    for (ll pi = 0; pi < N; pi++) {\n        ll p = P[pi];\n        copy(ALL(dp[0]), dp[1]);\n        for (ll j = 0; j < SIZE2; j++) for (ll k = 0; k <= 5; k++) {\n            ll use = 1000 * k;\n            if (1000 <= use - p) break;\n            if (p <= use) {\n                if (500 <= use - p && (j + use - p - 500) < SIZE2) upd(j + use - p - 500, get_v(j, use, true));\n                if (j + use - p < SIZE2) {\n                    if (p + 500 <= j + use) upd(j + use - (p + 500), get_v(j, use, true));\n                    upd(j + use - p, get_v(j, use, false));\n                }\n            }\n            \n            ll rest = p - use;\n            if (0 <= rest) {\n                if (500 <= j - rest) upd(j - rest - 500, get_v(j, use, true));\n                if (rest <= j) upd(j - rest, get_v(j, use, false));\n            } else if (-500 < rest) {\n                rest = 500 + rest;\n                if (rest <= j) upd(j - rest, get_v(j, use, true));\n            }\n        }\n        copy(ALL(dp[1]), dp[0]);\n    }\n\n    ll cnt = 0, sum = 0;\n    for (ll j = 0; j < SIZE2; j++) {\n        ll a, b;\n        tie(a, b) = dp[0][j];\n        if (cnt < a) {\n            cnt = a;\n            sum = b - 500 * cnt - j;\n        } else if (cnt == a) {\n            chmin(sum, b - 500 * cnt - j);\n        }\n    }\n\n    cout << cnt << ' ' << sum << endl;\n    return true;\n}\n\nint main() {\n    while (solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  const int CMAX = 50000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 49900...\n    // value : (-(# 500 yen so far), minimum payment)\n    //\n    //   NOTE: the first element is negated.\n    //\n    // for the same amount of change, pairs (k1, p1) and (k2, p2),\n    //   if k1 < k2 then (k2, p2) has no chance to be the best solution\n    //     because # of coins to be got depends only on the current change\n    // so, we can use lexicographical order of pairs here.\n    vector<pair<int,int>> dp(CMAX+1, pair<int,int>(BIG, BIG));\n    vector<pair<int,int>> dpnew(CMAX+1, pair<int,int>(BIG, BIG));\n    dpnew[0] = make_pair(0, 0);\n    int cmax = 0;\n    for(int i = 0; i < n; i++) {\n      // not buying\n      for(int j = 0; j <= cmax; j++) {\n        dp[j] = dpnew[j];\n      }\n      // buying\n      for(int j = 0; j <= cmax; j++) {\n        if(dp[j].first > 0) continue;\n        const int p = ps[i] % 1000;\n        if(p != 0 && p <= 500) { // got 500!\n          const int jj = min(j + 500 - p, CMAX);\n          cmax = min(max(cmax, jj), CMAX);\n          pair<int,int> dd(dp[j].first - 1, dp[j].second + ps[i]);\n          if(dd < dpnew[jj]) {\n            dpnew[jj] = dd;\n          }\n        } else {\n          // get 500 if possible!\n          const int q = (p == 0 ? 1000 : p) - 500;\n          if(j >= q) {\n            const int jj = j - q;\n            pair<int,int> dd(dp[j].first - 1, dp[j].second + ps[i]);\n            if(dd < dpnew[jj]) {\n              dpnew[jj] = dd;\n            }\n          } else { // get change\n            const int jj = (j + 1000 - p) % 1000;\n            cmax = min(max(cmax, jj), CMAX);\n            if( jj <= CMAX) {\n              pair<int,int> dd(dp[j].first, dp[j].second + ps[i]);\n              if(dd < dpnew[jj]) {\n                dpnew[jj] = dd;\n              }\n            }\n          }\n        }\n      }\n    }\n    pair<int,int> dd(BIG, BIG);\n    for(int j = 0; j <= cmax; j++) {\n      if(dpnew[j] < dd) {\n        dd = dpnew[j];\n      }\n    }\n    cout << -dd.first << \" \" << dd.second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Wrong Answer\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct Pair {\n\tint first, second;\n\tPair(int f, int s) { first = f; second = s; }\n\tPair() {}\n\tbool operator < (const Pair &r) const { return (first != r.first) ? first < r.first : second < r.second; }\n};\n\nint n;\nint p[100];\nPair dp[101][50001];\t//dp[i][j] = ?????????0???i-1?????????????????????????????????, ???1???100?????????????¨?j????????£????????????????????¨??????500?????????-dp[i][j].first?????????????????£????????£????????????dp[i][j].second[???]??§?????????\n\nvoid update(int id, int coin) {\n\tint mod1000 = p[id] % 1000;\n\tint mod500 = p[id] % 500;\n\t\n\tdp[id + 1][coin] = min(dp[id][coin], dp[id + 1][coin]);\n\t\n\tif (mod1000 == 0) {\n\t\tif (coin >= 500) {\n\t\t\tdp[id + 1][coin - 500] = min(dp[id + 1][coin - 500], Pair(dp[id][coin].first - 1, dp[id][coin].second + p[id]));\n\t\t}\n\t}\n\telse if (mod1000 <= 500) {\n\t\tdp[id + 1][coin + 500 - mod1000] = min(dp[id + 1][coin + 500 - mod1000], Pair(dp[id][coin].first - 1, dp[id][coin].second + p[id]));\n\t}\n\telse if (mod1000 <= 999) {\n\t\tdp[id + 1][coin + 1000 - mod1000] = min(dp[id + 1][coin + 1000 - mod1000], Pair(dp[id][coin].first, dp[id][coin].second + p[id]));\n\t\tif (coin >= mod1000 - 500) {\n\t\t\tdp[id + 1][coin - mod1000 + 500] = min(dp[id + 1][coin - mod1000 + 500], Pair(dp[id][coin].first - 1, dp[id][coin].second + p[id]));\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> n) {\n\t\tint i, j;\n\t\t\n\t\tif (!n) break;\n\t\tfor (i = 0; i < n; i++) cin >> p[i];\n\t\t\n\t\tfor (i = 0; i <= n; i++) for (j = 0; j < 500 * n; j++) dp[i][j] = Pair(1, 114514);\t//Be careful!!\n\t\tdp[0][0] = Pair(0, 0);\n\t\t\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < 500 * n; j++) {\n\t\t\t\tif (dp[i][j].first > 0) continue;\t//Be careful!!\n\t\t\t\tupdate(i, j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tPair ans = Pair(0, 0);\t//Be careful!!\n\t\tfor (j = 0; j < 500 * n; j++) {\n\t\t\tans = min(ans, dp[n][j]);\n\t\t}\n\t\tcout << -ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define M 50000\n\nint dp[2][101][M];\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int p[100],pp[100];\n    for(int i=0;i<n;i++)cin>>p[i],pp[i]=(1000-p[i]%1000)%1000;\n\n    for(int i=0;i<2;i++)\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<M;k++)dp[i][j][k]=1e9;\n    \n    dp[0][0][0]=0;\n\n    for(int i=0;i<n;i++){\n      int ni=(i+1)%2,I=i%2;\n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<M*(i+1)/n;k++)dp[ni][j][k]=1e9;\n      \n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<M*(i+1)/n;k++){\n\t  int np=k+pp[i];\n\t  int nj=j;\n\t  if(np>=500)nj++,np-=500;\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t  dp[ni][j][k]=min(dp[ni][j][k],dp[I][j][k]);\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t}\n    }\n    \n    int c=0,s=0;\n    for(int i=1;i<=n;i++)\n      for(int j=0;j<M;j++)\n\tif(dp[n%2][i][j]!=1e9&&i>=c){\n\t  if(c==i&&dp[n%2][i][j]<s)s=dp[n%2][i][j];\n\t  else if(c<i)c=i,s=dp[n%2][i][j];\n\t}\n    cout<<c<<\" \"<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nP dp[105][100000];\nP dfs(int id,int ch){\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tint rem = p[id]%1000;\n\tif(dp[id][ch].fi!=-1)return dp[id][ch];\n\tP res = dfs(id+1,ch);\n\tif(rem==0){\n\t\tif(ch>=500){\n\t\t\tP tmp = dfs(id+1,ch-500);\n\t\t\ttmp.fi++;\n\t\t\ttmp.sec-=p[id];\n\t\t\tres = max(res,tmp);\n\t\t}\n\t}else{\n\t\tif(ch+500-rem>=0){\n\t\t\tP tmp = dfs(id+1,ch+500-rem);\n\t\t\ttmp.fi++;\n\t\t\ttmp.sec -= p[id];\n\t\t\tres = max(res,tmp);\n\t\t}\n\t\tP tmp = dfs(id+1,ch+1000-rem);\n\t\ttmp.sec -= p[id];\n\t\tres = max(res,tmp);\n\t}\n\treturn dp[id][ch]=res;\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<105;i++){\n\t\tfor(int j=0;j<100000;j++){\n\t\t\tdp[i][j]=P(-1,-1);\n\t\t}\n\t}\n\tP ans = dfs(0,0);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 100000;\nconst int MAX_LEFT = 500 * 100 + 1;\nclass Solver {\n  public:\n    bool solve() {\n        int N; cin >> N;\n        if(N == 0) return false;\n        vector<int> P(N); cin >> P;\n        \n        vector<vector<pii>> DP(N + 1, vector<pii>(MAX_LEFT, make_pair(0, -INF))); // := (500???, ?????£??????)\n        DP[0][0] = make_pair(0, 0);\n        rep(n, N) {\n            rep(left, MAX_LEFT) {\n                int num  = DP[n][left].first;\n                int used = DP[n][left].second * -1;\n                if(used >= INF) continue;\n                \n                // ????????????\n                set_max(DP[n + 1][left], DP[n][left]);\n                \n                used += P[n];\n                \n                int b = P[n] % 1000;\n                if(b == 0) {\n                    if(left >= 500) {\n                        set_max(DP[n + 1][left - 500], make_pair(num + 1, -1 * used));\n                    }\n                } else if(b > 500) {\n                    { // ?°?????????????\n                        int add = 1000 - b;\n                        if (left + add < MAX_LEFT)\n                            set_max(DP[n + 1][left + add], make_pair(num, -1 * used));                        \n                    }\n                    int need = b - 500;\n                    if(left >= need) \n                        set_max(DP[n + 1][left - need], make_pair(num + 1, -1 * used));                    \n                } else {\n                    int add = 500 - b;\n                    if(left + add < MAX_LEFT)\n                        set_max(DP[n + 1][left + 500 - b], make_pair(num + 1, -1 * used));\n                }\n            }\n        }\n        pii ans(-1, 0);\n        rep(i, MAX_LEFT) set_max(ans, DP[N][i]);\n        cout << ans.first << \" \" << ans.second * -1 << endl;\n        return true;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        Solver s;\n        if(!s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vii;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip> vip;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 :1e9;\nint dp[110][110][1010];\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi in(n);\n\t\trep(i,n)cin>>in[i];\n\t\trep(i,110)rep(j,110)rep(k,1010)dp[i][j][k]=inf;\n\t\tdp[0][0][0]=0;\n\t\trep(i,n)rep(j,n)rep(k,1010)if(dp[i][j][k]!=inf){\n\t\t\tdp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k]);\n\t\t\tint J=j,K=k,a=in[i]%1000;\n\t\t\tif(k<=a&&a){\n\t\t\t\tK=1000+k-a;\n\t\t\t\tif(K>=500)J++,K-=500;\n\t\t\t}else if(k>a&&a){\n\t\t\t\tif(500>=a){\n\t\t\t\t\tK=k+1000-a;\n\t\t\t\t\tJ++;\n\t\t\t\t\tK-=500;\n\t\t\t\t}else{\n\t\t\t\t\tK=k-(a-500);\n\t\t\t\t\tJ++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(K>=500)K-=500,J++;\n\t\t\t\t\n\t\t\t}\n\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t}\n\t\tint outc=0,out=inf;\n\t\trep(i,n+1)rep(j,1010)if(dp[n][i][j]!=inf){\n\t\t\tif(outc<i){\n\t\t\t\toutc=i;\n\t\t\t\tout=dp[n][i][j];\n\t\t\t}else if(outc==i)\n\t\t\t\tout=min(out,dp[n][i][j]);\n\t\t}\n\t\tcout<<outc<<\" \"<<out<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define updmax(dp,x) dp=(dp.first == 0 ? x : max(dp,x))\n\nusing P = pair<int,int>;\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        vector<int> p(n);\n        rep(i,n) cin>>p[i];\n        map<int,P> cur; // cur[coin] = <get,pay>\n        rep(i,n){\n            map<int,P> nxt;\n            updmax(cur[0],P(0,0));\n            for(auto &itr : cur){\n                int coin = itr.first;\n                int k = itr.second.first;\n                int pay = itr.second.second;\n                updmax(nxt[coin], P(k,pay));\n                pay -= p[i];\n                coin += (1000-p[i]%1000)%1000;\n                if(coin >= 500){\n                    updmax(nxt[coin-500], P(k+1, pay));\n                }else{\n                    updmax(nxt[coin], P(k,pay));\n                }\n            }\n            cur = move(nxt);\n        }\n\n        P res = {0,0};\n        for(auto itr : cur){\n            res = max(res,itr.second);\n        }\n        cout<<res.first<<\" \"<<-res.second<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<int> p(n);\n        for(int i=0; i<n; ++i) {\n            cin >> p[i];\n        }\n        vector<vector<pii>> dp(n+1, vector<pii>(500*n, make_pair(INF, INF)));\n        dp[0][0] = make_pair(0, 0);\n        for(int i=0; i<n; ++i) {\n            for(int j=0; j<500*n; ++j) {\n                if(dp[i][j].first == INF) {\n                    continue;\n                }\n                int noguti = ((p[i] + 999) / 1000) * 1000;\n                if(1 <= p[i] % 1000 && p[i] % 1000 <= 500) {\n                    int coin = noguti - p[i] - 500;\n                    pii next = make_pair(dp[i][j].first - 1, dp[i][j].second + p[i]);\n                    dp[i+1][j+coin] = min(dp[i+1][j+coin], next);\n                } else {\n                    dp[i+1][j] = min(dp[i+1][j], dp[i][j]); // not buy\n                    int cost = ((p[i] % 1000) + 500) % 1000;\n                    if(cost <= j) { // use coin\n                        pii next = make_pair(dp[i][j].first - 1, dp[i][j].second + p[i]);\n                        dp[i+1][j-cost] = min(dp[i+1][j-cost], next);\n                    } else { // only noguti\n                        pii next = make_pair(dp[i][j].first, dp[i][j].second + p[i]);\n                        int coin = noguti - p[i];\n                        dp[i+1][j+coin] = min(dp[i+1][j+coin], next);\n                    }\n                }\n            }\n        }\n        auto res = *min_element(dp[n].begin(), dp[n].end());\n        cout << -res.first << ' ' << res.second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n        int N;\n        while (cin >> N, N) {\n                vector<vector<pair<int, int>>>dp(N + 1, vector<pair<int,int>>(101000, make_pair(INT_MIN / 6, INT_MAX / 6)));\n                dp[0][0] = make_pair(0, 0);\n                for (int i = 0; i < N; i++) {\n                        int p;\n                        cin >> p;\n                        int q = p;\n                        int num1000 = p / 1000;\n                        p %= 1000;\n                        // 500???????????°???????????´???\n                        for (int j = 0; j < 100000 - p; j++) {\n                                if (dp[i + 1][j + (1000 - p) % 1000].first < dp[i][j].first || (dp[i + 1][j + (1000 - p) % 1000].first == dp[i][j].first && dp[i + 1][j + (1000 - p) % 1000].second > dp[i][j].second + q) ) {\n                                        dp[i + 1][j + (1000 - p) % 1000].first = dp[i][j].first;\n                                        dp[i + 1][j + (1000 - p) % 1000].second = dp[i][j].second + q;\n                                }\n                        }\n\n                        // 500????????????????????´???\n                        if (p == 0) {\n                                for (int j = 500 ; j < 100000; j++) {\n                                        if (dp[i + 1][j - 500].first < dp[i][j].first + 1 || (dp[i + 1][j - 500].first == dp[i][j].first + 1 && dp[i + 1][j - 500].second > dp[i][j].second + q)) {\n                                                dp[i + 1][j - 500].first = dp[i][j].first + 1;\n                                                dp[i + 1][j - 500].second = dp[i][j].second + q;\n                                        }\n                                }\n                        } else if (p >= 500) {\n                                for (int j = p - 500 ; j < 100000; j++) {\n                                        if (dp[i + 1][j + 500 - p].first < dp[i][j].first + 1 || (dp[i + 1][j + 500 - p].first == dp[i][j].first + 1 && dp[i + 1][j + 500 - p].second > dp[i][j].second + q)) {\n                                                dp[i + 1][j + 500 - p].first = dp[i][j].first + 1;\n                                                dp[i + 1][j + 500 - p].second = dp[i][j].second + q;\n                                        }\n                                }\n                        } else {\n                                for (int j = 0; j < 100000; j++) {\n                                        if (dp[i + 1][j + 500 - p].first < dp[i][j].first + 1 || (dp[i + 1][j + 500 - p].first == dp[i][j].first + 1 && dp[i + 1][j + 500 - p].second > dp[i][j].second + q)) {\n                                                dp[i + 1][j + 500 - p].first = dp[i][j].first + 1;\n                                                dp[i + 1][j + 500 - p].second = dp[i][j].second + q;\n                                        }\n                                }\n                        }\n\n                        // ????????????????????´???\n                        for (int j = 0; j < 100000; j++) {\n                                if (dp[i + 1][j].first < dp[i][j].first || (dp[i + 1][j].first == dp[i][j].first && dp[i + 1][j].second > dp[i][j].second)) {\n                                        dp[i + 1][j] = dp[i][j];\n                                }\n                        }\n                }\n                pair<int,int>ans = make_pair(INT_MIN, INT_MAX / 6);\n                for (int j = 0; j < 101000; j++) {\n                        if (ans.first < dp[N][j].first || (ans.first == dp[N][j].first && ans.second > dp[N][j].second)) {\n                                ans = dp[N][j];\n                        }\n                }\n                cout<<ans.first<<\" \"<<ans.second<<endl;\n        }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1 ; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1 ; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9+100;\nconst bool debug = 0;\n/***************************************/\n\nint N;\nint p[100];\nint dp[101][25001]; // 500円の枚数, 所持金(100円以下の小銭) = 最小購入金額\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tREP(i, N) scanf(\"%d\", p + i);\n\t\t\n\t\tfill(dp[0], dp[N + 1], INF);\n\t\tdp[0][0] = 0;\n\t\t\n\t\tREP(t, N) {\n\t\t\tint chg = 1000 - (p[t] % 1000);\n\t\t\tchg %= 1000;\n\t\t\t\n\t\t\tfor (int i = N; i >= 0; i--) {\n\t\t\t\tfor (int j = 25000; j >= 0; j--) {\n\t\t\t\t\tif (i) { // 購入して500円玉が増えた場合\n\t\t\t\t\t\tif (chg >= 500) {\n\t\t\t\t\t\t\tint cur = chg - 500; // 増加\n\t\t\t\t\t\t\tif (j - cur >= 0 && dp[i - 1][j - cur] != INF) chmin(dp[i][j], dp[i - 1][j - cur] + p[t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint cur = 500 - chg; // 減少\n\t\t\t\t\t\t\tif (j + cur <= 25000 && dp[i - 1][j + cur] != INF) chmin(dp[i][j], dp[i - 1][j + cur] + p[t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 購入して500円玉が増えなかった場合\n\t\t\t\t\tif (chg < 500 && j - chg >= 0 && dp[i][j - chg] != INF) chmin(dp[i][j], dp[i][j - chg] + p[t]);\n\t\t\t\t\t\n\t\t\t\t\t//小銭j円が多すぎて困ることはないので\n\t\t\t\t\tif (j) chmin(dp[i][j-1], dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpii ans;\n\t\tfor (int i = N; i >= 0; i--) {\n\t\t\tif (dp[i][0] == INF) continue;\n\t\t\tans = pii(i, dp[i][0]);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (debug) printf(\"@ \");\n\t\tprintf(\"%d %d\\n\", ans.fi, ans.se);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 2\n#define MAX_C 100001\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nint m[MAX_N];\npii dp[MAX_N][MAX_C];\n\nvoid set_m(vector<int> &p)\n{\n    for (int i = 0; i < (int)p.size(); i++) {    \n        m[i] = ((p[i] - 1) / 1000 + 1) * 1000;\n    }\n}\n\nvoid update(pii &a, pii &b)\n{\n    if (a.first < b.first) {\n        a = b;\n    } else if (a.first == b.first) {\n        if (a.second > b.second) {\n            a = b;\n        }\n    }\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<int> p(N);\n        for (int i = 0; i < N; i++) {\n            cin >> p[i];\n        }\n        \n        set_m(p);\n        \n        memset(dp, -1, sizeof(dp));\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < MAX_C; j++) {\n                dp[i][j] = pii(-1, INF);\n            }\n        }\n        \n        dp[0][0] = pii(0, 0);\n        for (int i = 0; i < N; i++) {\n            int curr = (i & 1), next = !(i & 1);\n            for (int j = 0; j < MAX_C; j++) {\n                if (dp[curr][j].first == -1) continue;\n                \n                update(dp[next][j], dp[curr][j]);\n                \n                for (int k = 0; k <= min(j, 999); k += 100) {\n                    int pay = m[i] + k;\n                    int change = pay - p[i];                    \n                    int _500 = change / 500;\n                    \n                    if (change < 0 || change >= 1000) continue;                    \n                    \n                    int nc = j - k + change - _500 * 500;\n                    if (nc >= MAX_C) continue;\n                    \n                    pii ncost = pii(dp[curr][j].first + _500,\n                                    dp[curr][j].second + p[i]);                    \n                    \n                    update(dp[next][nc], ncost);\n                }\n            }\n            for (int j = 0; j < MAX_C; j++) {\n                dp[curr][j] = pii(-1, INF);\n            }\n        }\n        \n        pii res = pii(-1, INF);\n        for (int i = 0; i < MAX_C; i++) {\n            update(res, dp[N&1][i]);\n        }\n        cout << res.first << \" \" << res.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\n#define IINF INT_MAX\n#define MAX 110\nint n,p[MAX],dp[2][210][100010];\n\nint main() {\n  while( cin >> n, n ) {\n    rep(i,n) cin >> p[i];\n    int limit = (n * 999) + 1;\n    rep(k,2) rep(i,n+1) rep(j,limit) dp[k][i][j] = IINF;\n    dp[0][0][0] = 0;\n    rep(i,n) {\n      rep(j,n+1) rep(k,limit) dp[(i+1)&1][j][k] = IINF;\n      rep(j,n+1) {\n\trep(k,limit) {\n\t  if( dp[i&1][j][k] == IINF ) continue;\n\t  // use\n\t  //cout << \"dp[\" << i << \"][\" << j << \"][\" << k << \"] = \" << dp[i][j][k] << endl;\n\t  int rem = ( 1000 - p[i] % 1000 ) + k;\n\t  if( p[i] % 1000 == 0 ) rem = k;\n\t  \n\t  if( rem >= 500 ) {\n\t    assert( rem - 500 >= 0 && rem - 500 < limit);\n\t    dp[(i+1)&1][j+1][rem-500] = min(dp[(i+1)&1][j+1][rem-500],\n\t\t\t\t\tdp[i&1][j][k]+p[i]);\n\t  } else {\n\t    assert( 0 <= rem && rem < limit );\n\t    dp[(i+1)&1][j][rem] = min(dp[(i+1)&1][j][rem],dp[i&1][j][k]+p[i]);\n\t  }\n\t  // dont use\n\t  dp[(i+1)&1][j][k] = min(dp[(i+1)&1][j][k],dp[i&1][j][k]);\n\t}\n      }\n    }\n    for(int i=n;i>=0;--i) {\n      int mini = IINF;\n      rep(j,limit) {\n\tif( dp[n&1][i][j] != IINF ) {\n\t  mini = min(mini,dp[n&1][i][j]);\n\t}\n      }\n      if( mini != IINF ) {\n\tcout << i << \" \" << mini << endl;\n\tgoto Skip;\n      }\n    }\n    puts(\"0 0\");\n  Skip:;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint n;\nvi p;\npii dp[101][55555];\n\npii solve(int shop, int coin)\n{\n\tif (shop == n) return pii(0, 0);\n\tif (dp[shop][coin].first >= 0) return dp[shop][coin];\n\tpii res(0, 0);\n\tchmax(res, solve(shop + 1, coin));\n\tpii tmp;\n\tif (p[shop] % 1000 == 0)\n\t{\n\t\tif (coin >= 500)\n\t\t{\n\t\t\ttmp = solve(shop + 1, coin - 500);\n\t\t\tchmax(res, pii(tmp.first + 1, tmp.second - p[shop]));\n\t\t}\n\t}\n\telse if (p[shop] % 1000 > 500)\n\t{\n\t\ttmp = solve(shop + 1, coin + 1000 - p[shop] % 1000);\n\t\tchmax(res, pii(tmp.first, tmp.second - p[shop]));\n\t\tif (p[shop] % 1000 - 500 <= coin)\n\t\t{\n\t\t\ttmp = solve(shop + 1, coin - (p[shop] % 1000 - 500));\n\t\t\tchmax(res, pii(tmp.first + 1, tmp.second - p[shop]));\n\t\t}\n\t}\n\telse\n\t{\n\t\ttmp = solve(shop + 1, coin + 500 - p[shop] % 1000);\n\t\tchmax(res, pii(tmp.first + 1, tmp.second - p[shop]));\n\t}\n\treturn dp[shop][coin] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\twhile (cin >> n, n)\n\t{\n\t\tp.resize(n);\n\t\tREP(i, n) cin >> p[i];\n\t\tREP(i, 101)REP(j, 55555) dp[i][j] = pii(-1, -1);\n\t\tpii ans = solve(0, 0);\n\t\tcout << ans.first << \" \" << -ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nint f(int a){\n    if(a%1000 == 0)return a;\n    a /= 1000;\n    a++;\n    return a*1000;\n}\n\npii dp[105][105*1000];\n//iまで見て小銭がj円のときの\n//dp[i][j].first:500円玉の個数\n//dp[i][j].second:最小金額\n\nvoid update(pii &a,pii b){\n    if(b.second >= INF)return ;\n    if(a.first < b.first)a = b;\n    else if(a.first == b.first && a.second > b.second)a = b;\n}\n\nsigned main(void) {\n    int n;\n    while(cin >> n,n){\n        vi p(n);\n        rep(i,n)cin >> p[i];\n        rep(i,n+1)rep(j,(n+1)*1000)dp[i][j] = pii(0,INF);\n        dp[0][0].second = 0;\n        rep(i,n)rep(j,(n+1)*1000){\n            int cnt = dp[i][j].first;\n            int sum = dp[i][j].second;\n            update(dp[i+1][j],dp[i][j]);//かわない\n            int t = f(p[i]) - p[i];//札のみのときのおつり\n            //if(sum < INF)cout << i << \" \" << j << \" \" << cnt << \" \" << sum << \" \" << t << endl;\n            if(t >= 500){\n                update(dp[i+1][j+t-500], pii(cnt+1,sum+p[i]));\n            }else{\n                update(dp[i+1][j+t], pii(cnt, sum+p[i]));\n                int ne = p[i]%500;//必要な端数\n                if(!ne)ne = 500;\n                if(ne <= j){//端数を消費し500円玉を手に入れる\n                    update(dp[i+1][j-ne], pii(cnt+1,sum+p[i]));\n                }\n            }\n        }\n        pii ans = pii(0,INF);\n        rep(j,(n+1)*1000)update(ans,dp[n][j]);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint f[200][2010][15],n,a[200],c[200][2010][15];\nint main(){\n\tscanf(\"%d\",&n);\n\twhile(n){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tscanf(\"%d\",&a[i]);\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tfor(int j=0;j<=1000;j++)\n\t\t\t\tfor(int z=0;z<11;z++){\n\t\t\t\t\tf[i][j][z]=-100000;\n\t\t\t\t\tc[i][j][z]=0;\n\t\t\t\t}\n\t\tf[0][0][0]=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<1000;j++)\n\t\t\t\tfor(int z=0;z<11;z++)\n\t\t\t\t\tif(f[i][j][z]>=0){\n\t\t\t\t\t\tif(f[i+1][j][z]<f[i][j][z]||(f[i+1][j][z]==f[i][j][z]&&c[i+1][j][z]>c[i][j][z])){\n\t\t\t\t\t\t\tf[i+1][j][z]=f[i][j][z];\n\t\t\t\t\t\t\t//printf(\"%d %d %d\\n\",i,j,z);\n\t\t\t\t\t\t\tc[i+1][j][z]=c[i][j][z];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint k=(0-a[i])%1000+1000;\n\t\t\t\t\t\tif(k==1000)k=0;\n\t\t\t\t\t\tif(k>=500){\n\t\t\t\t\t\t\tk-=500;\n\t\t\t\t\t\t\tint jj=j+k;\n\t\t\t\t\t\t\tif(jj<1000){\n\t\t\t\t\t\t\t\tif(f[i+1][jj][z]<f[i+1][j][z]+1||(f[i+1][jj][z]==f[i][j][z]+1&&c[i+1][jj][z]>c[i][j][z]+a[i])){\n\t\t\t\t\t\t\t\t\tf[i+1][jj][z]=f[i][j][z]+1;\n\t\t\t\t\t\t\t\t\tc[i+1][jj][z]=c[i][j][z]+a[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tjj-=1000;\n\t\t\t\t\t\t\t\tif(f[i+1][jj][z+1]<f[i+1][j][z]+1||(f[i+1][jj][z+1]==f[i][j][z]+1&&c[i+1][jj][z+1]>c[i][j][z]+a[i])){\n\t\t\t\t\t\t\t\t\tf[i+1][jj][z+1]=f[i][j][z]+1;\n\t\t\t\t\t\t\t\t\tc[i+1][jj][z+1]=c[i][j][z]+a[i];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tk+=500;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j+k>=500){\n\t\t\t\t\t\t\tif(j+k<1000){\n\t\t\t\t\t\t\t\tint jj=(j+k-500);\n\t\t\t\t\t\t\t\tif(f[i+1][jj][z]<f[i+1][j][z]+1||(f[i+1][jj][z]==f[i][j][z]+1&&c[i+1][jj][z]>c[i][j][z]+a[i])){\n\t\t\t\t\t\t\t\t\tf[i+1][jj][z]=f[i][j][z]+1;\n\t\t\t\t\t\t\t\t\tc[i+1][jj][z]=c[i][j][z]+a[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else if(true){\n\t\t\t\t\t\t\t\tint jj=(j+k-1000);\n\t\t\t\t\t\t\t\tif(i==3&&j==200&&z==1){\n\t\t\t\t\t\t\t\t\tprintf(\"!%d\\n\",k);\n\t\t\t\t\t\t\t\t\tf[0][0][0]=0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(f[i+1][jj][z+1]<f[i+1][j][z]+1||(f[i+1][jj][z+1]==f[i][j][z]+1&&c[i+1][jj][z+1]>c[i][j][z]+a[i])){\n\t\t\t\t\t\t\t\t\tf[i+1][jj][z+1]=f[i][j][z]+1;\n\t\t\t\t\t\t\t\t\tc[i+1][jj][z+1]=c[i][j][z]+a[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(true){\n\t\t\t\t\t\t\tif(f[i+1][j+k][z]<f[i][j][z]||(f[i+1][j+k][z]==f[i][j][z]&&c[i+1][j+k][z]>c[i][j][z])){\n\t\t\t\t\t\t\t\tf[i+1][j+k][z]=f[i][j][z];\n\t\t\t\t\t\t\t\tc[i+1][j+k][z]=c[i][j][z]+a[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(z>0){\n\t\t\t\t\t\t\t\tint jj=j+k+1000;\n\t\t\t\t\t\t\t\tif(jj<1500){\n\t\t\t\t\t\t\t\t\tjj-=500;\n\t\t\t\t\t\t\t\tif(f[i+1][j+k][z-1]<f[i][j][z]+1||(f[i+1][j+k][z-1]==f[i][j][z]+1&&c[i+1][j+k][z-1]>c[i][j][z])){\n\t\t\t\t\t\t\t\t\tf[i+1][j+k][z-1]=f[i][j][z]+1;\n\t\t\t\t\t\t\t\t\tc[i+1][j+k][z-1]=c[i][j][z]+a[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//f[i+1][j+k]=max(f[i][j][z],f[i+1][j+k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\tint ans=0,co=0;\n\t\tfor(int i=0;i<1000;i++)\n\t\t\tfor(int z=0;z<11;z++)\n\t\t\t\tif(ans<f[n][i][z]||(ans==f[n][i][z]&&co>c[n][i][z])){\n\t\t\t\t\tans=f[n][i][z];\n\t\t\t\t\tco=c[n][i][z];\n\t\t\t\t}\n\t\tprintf(\"%d %d\\n\",ans,co);\n\t\t//printf(\"%d\\n\",f[4][800][0]);\n\t\t//printf(\"%d\\n\",f[3][200][1]);\n\t\tscanf(\"%d\",&n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll ,P> P3;\ntypedef pair<P ,P> PP;\nconst ll MOD = ll(1e9+7);\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nint n, p[105], dp[2][105][500*60];\n\nvoid solve(){\n    REP(i,2)REP(j,n+1) fill(dp[i][j],dp[i][j]+500*60,IINF);\n    dp[0][0][0] = 0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<=i;j++){\n            for(int k=0;k<=500*55;k++){\n                if(dp[i%2][j][k]==IINF)continue;\n\n                int chg = (1000-p[i]%1000)%1000;\n                if(chg < 500){\n                    dp[(i+1)%2][j][k+chg] = min(dp[(i+1)%2][j][k+chg],dp[i%2][j][k]+p[i]);\n                    if(500-chg <= k){\n                        dp[(i+1)%2][j+1][k+chg-500] = min(dp[(i+1)%2][j+1][k+chg-500],dp[i%2][j][k]+p[i]);\n                    }\n                }\n                else{\n                    dp[(i+1)%2][j+1][min(k+chg-500,500*55)] = min(dp[(i+1)%2][j+1][min(k+chg-500,500*55)],dp[i%2][j][k]+p[i]);\n                }\n                dp[(i+1)%2][j][k] = min(dp[(i+1)%2][j][k],dp[i%2][j][k]);\n            }\n        }\n    }\n    int ma = 0, ans = 0;\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<=500*55;j++){\n            if(dp[n%2][i][j] < IINF){\n                if(i > ma){\n                    ma = i;\n                    ans = dp[n%2][i][j];\n                }\n                else if (i==ma){\n                    ans = min(ans, dp[n%2][i][j]);\n                }\n            }\n        }\n    }\n    cout << ma << \" \" << ans << endl;\n}\n\nint main() {\n    while(cin >> n, n){\n        REP(i,n){\n            cin >> p[i];\n        }\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define SIZE 50100\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nint c[5]={100,50,10,5,1};\nconst int B = 7;\nint encode(vector<int> v){\n\tint S = 0;\n\tfor(int i=0;i<v.size();i++){\n\t\tassert(v[i]<B);\n\t\tS = S*B+v[i];\n\t}\n\treturn S;\n}\nvector<int> decode(int S){\n\tvector<int> v;\n\tint x = B*B*B*B;\n\tfor(int i=0;i<5;i++){\n\t\tv.pb(S/x);\n\t\tS %= x;\n\t\tx /= B;\n\t}\n\treturn v;\n}\nP dp[105][SIZE];\npair<int,vector<int> > charge(int x){\n\tx %= 1000;\n\tvector<int> v(5,0);\n\tint f = x/500;\n\tx -= f*500;\n\tfor(int i=0;i<5;i++){\n\t\tv[i]=x/c[i];\n\t\tx -= v[i]*c[i];\n\t}\n\tassert(x==0);\n\treturn make_pair(f,v);\n}\n/*void dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}*/\nP dfs(int id,int V){\n\t/*cout << \"call : \" << id << endl;\n\tcout << \"vec : \";\n\tdump(vec);\n\tcout << endl;*/\n\tint tmp = V;\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tmap<int,P>::iterator it;\n\tif(dp[id][V].fi!=-1){\n\t\treturn dp[id][V];\n\t}\n\tP res = dfs(id+1,V);\n\tvector<int> vec = decode(V);\n\tint h = ((p[id]-1)/1000+1)*1000;;\n\tfor(int i=0;i<5;i++){\n\t\twhile(vec[i]>0&&h-p[id]+c[i]<1000){\n\t\t\tvec[i]--;\n\t\t\th += c[i];\n\t\t}\n\t}\n\tpair<int,vector<int> > ch = charge(h-p[id]);\n\tfor(int i=0;i<5;i++)vec[i] += (ch.sec)[i];\n\tP res2 = dfs(id+1,encode(vec));\n\tres2.fi += ch.fi;\n\tres2.sec -= p[id];\n\tdp[id][tmp]=max(res,res2);\n\t/*cout << \"end : \" << id << endl;\n\tcout << \"vec : \";\n\tdump();\n\tcout << \"result : \" << dp[id][vec].fi << ' ' << -dp[id][vec].sec << endl;*/\n\treturn dp[id][tmp];\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<SIZE;j++){\n\t\t\tdp[i][j]=P(-1,-1);\n\t\t}\n\t}\n\tP ans = dfs(0,0);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nconst ll M = 100*5000;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n;\n    while (cin >> n, n) {\n        vector<ll> p(n); cin >> p;\n        vector<vector<P>> dp(n+1, vector<P>(M+1, {-1, -1}));\n        dp[0][0] = {0, 0};\n        rep(i, n) rep(j, M+1) {\n            if (dp[i][j].first < 0) continue;\n            ll c, r; tie(c, r) = dp[i][j];\n            if (0 < p[i] % 1000 && p[i] % 1000 <= 500) {\n                // ??????\n                assert(j+p[i] <= M);\n                chmax(dp[i+1][j+p[i]], P(c+1, r+(500-p[i]%1000)));\n            }\n            else {\n                // ????????????\n                chmax(dp[i+1][j], dp[i][j]);\n                // ???????????????\n                chmax(dp[i+1][j+p[i]], P(c, r+(1000-p[i]%1000)%1000));\n                // 500????????????????????????????????????\n                ll need = (p[i]+500) % 1000;\n                if (r >= need) {\n                    chmax(dp[i+1][j+p[i]], P(c+1, r-need));\n                }\n            }\n        }\n        P ans{0, 0};\n        rep(i, M+1) {\n            chmax(ans, P(dp[n][i].first, -i));\n        }\n        cout << ans.first << \" \" << -ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nint p[101];\npint dp[101][60001];\nint INF=1000100010;\nint main(){\n    int n;\n    while(cin>>n,n){\n        rep(i,n) cin>>p[i];\n        FOR(i,0,n+1)rep(j,50001) dp[i][j]={0,-INF};\n        dp[0][0]={0,0};\n        rep(i,n){\n            int cp=p[i];\n            rep(j,50001){\n                if(dp[i][j]==pint(0,-INF)) continue;\n                dp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n                if(p[i]%1000==0){\n                    if(j<500) continue;\n                    else{\n                        pint tmp=dp[i][j];\n                        tmp.second-=cp;++tmp.first;\n                        dp[i+1][j-500]=max(dp[i+1][j-500],tmp);\n                    }\n                    continue;\n                }\n                if(cp%1000>500){\n                    if(cp%1000-500<=j){\n                        pint tmp=dp[i][j];\n                        tmp.second-=cp;\n                        dp[i+1][j+1000-cp%1000]=max(dp[i+1][j+1000-cp%1000],tmp);\n                        ++tmp.first;\n                        dp[i+1][j-cp%1000+500]=max(dp[i+1][j-cp%1000+500],tmp);\n                    }\n                    else{\n                        pint tmp=dp[i][j];\n                        tmp.second-=cp;\n                        dp[i+1][j+1000-cp%1000]=max(dp[i+1][j+1000-cp%1000],tmp);\n                    }\n                }\n                else{\n                    pint tmp=dp[i][j];\n                    tmp.second-=cp;++tmp.first;\n                    dp[i+1][j+1000-cp%1000-500]=max(dp[i+1][j+1000-cp%1000-500],tmp);\n                }\n            }\n        }\n        pint mx={0,-INF};\n        rep(i,n+1)rep(j,50001) mx=max(mx,dp[i][j]);\n        cout<<mx.first<<\" \"<<-mx.second<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int M = 100000;\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    auto p = vector<int>(n);\n    for (int i = 0; i < n; ++i) cin >> p[i];\n\n    auto dp1 = vector<vector<int>>(n + 1, vector<int>(M, -1));\n    auto dp2 = vector<vector<int>>(n + 1, vector<int>(M, 100 * 5000));\n    dp1[0][0] = dp2[0][0] = 0;\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < M; ++j) {\n        dp1[i + 1][j] = dp1[i][j];\n        dp2[i + 1][j] = dp2[i][j];\n      }\n      int change = (1000 - p[i] % 1000) % 1000;\n      for (int cur = 0; cur < M; ++cur) {\n        if (dp1[i][cur] == -1) continue;\n        int canGet = (cur + change >= 500);\n        int nxt = cur + change - 500 * canGet;\n        if (dp1[i + 1][nxt] < dp1[i][cur] + canGet) {\n          dp1[i + 1][nxt] = dp1[i][cur] + canGet;\n          dp2[i + 1][nxt] = dp2[i][cur] + p[i];\n        } else if (dp1[i + 1][nxt] == dp1[i][cur] + canGet) {\n          dp2[i + 1][nxt] = min(dp2[i + 1][nxt], dp2[i][cur] + p[i]);\n        }\n      }\n    }\n    int ans1 = -1, ans2 = 100 * 5000;\n    for (int j = 0; j < M; ++j) ans1 = max(ans1, dp1[n][j]);\n    for (int j = 0; j < M; ++j) if (dp1[n][j] == ans1) ans2 = min(ans2, dp2[n][j]);\n    cout << ans1 << ' ' << ans2 << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF = 1e9;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nint N;\nvector<int> P;\n\nPII dp[100][50000];\n\nbool operator < (const PII &l, const PII &r)\n{\n    if (l.first == r.first) return l.second > r.second;\n    return l.first < r.first;\n}\n\n\nPII solve(int n, int x, int sum, int num)\n{\n    if (n == N) return PII(0, 0);\n    if (dp[n][x].first != -1) return dp[n][x];\n\n    PII res = PII(0, INF);\n\n    // ????????????\n    res = max(res, solve(n+1, x, sum, num));\n\n    // ?°????????????£?????????\n    {\n        int kozeni = (P[n] + 500) % 1000;\n        if (kozeni <= x) {\n            PII tmp = solve(n+1, x-kozeni, sum+P[n], num+1);\n            tmp.first++;\n            tmp.second += P[n];\n            res = max(res, tmp);\n        }\n    }\n    \n    // ?????????????????£?????????\n    {\n        int kozeni = (1000 - P[n]%1000)%1000;\n        int get = 0;\n        if (kozeni >= 500) {\n            get = 1;\n            kozeni -= 500;\n        }\n\n        PII tmp = solve(n+1, x+kozeni, sum+P[n], num+get);\n        tmp.first += get;\n        tmp.second += P[n];\n        res = max(res, tmp);\n    }\n\n    return dp[n][x] = res;\n}\n\n\nint main()\n{\n    while (cin >> N, N) {\n        fill(dp[0], dp[0]+100*50000, PII(-1, -1));\n        P.resize(N);\n        rep(i, N) cin >> P[i];\n\n        PII ans = solve(0, 0, 0, 0);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nP dp[101][50001];\n\nvoid Max(P &a,P b){a=max(a,b);}\n\nint main(){\n  int n,p[101];\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>p[i];\n    \n    memset(dp,-1,sizeof(dp));\n    dp[0][0]=P(0,0);\n  \n    for(int i=0;i<n;i++)\n      for(int j=0;j<50000;j++){\n\tif(dp[i][j]==P(-1,-1))continue;\n\tint coin=dp[i][j].first, ncost=dp[i][j].second-p[i];\n\tMax(dp[i+1][j],dp[i][j]);\n\tif(p[i]%1000<500&&p[i]%1000)Max(dp[i+1][j+(500-p[i]%500)],P(coin+1,ncost));\n\tif(p[i]%1000==0&&j>=500) Max(dp[i+1][j-500],P(coin+1,ncost));\n\t\n\tif(p[i]%1000>=500) {\n\t  if(j>=p[i]%500)Max(dp[i+1][j-p[i]%500],P(coin+1,ncost));\n\t  else Max(dp[i+1][j+(500-p[i]%500)],P(coin,ncost));\n\t}\n      }\n    \n    P ans=P(0,0);\n    for(int i=0;i<50000;i++)Max(ans,dp[n][i]);\n    cout <<ans.first<<\" \"<<-ans.second<<endl;\n    \n  }\t\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\n using namespace std;\nbool dp[110][5011];\nlong long int charge[110][5011];\nint p[100];\nint n; \nint main(){\n  while(1){\n  cin>>n;\n  if(n==0){\n     break;\n  }\n  for(int i=0;i<n;i++){\n      cin>>p[i];\n  }\n  for(int i=0;i<110;i++){\n      for(int j=0;j<5011;j++){\n          dp[i][j]=false;\n          charge[i][j]=5000000000;\n      }\n  }\n  dp[0][0]=true;\n  charge[0][0]=0;\n  for(int i=0;i<n;i++){\n      for(int j=n-1;j>=0;j--){\n          for(int k=5000;k>=0;k--){\n              if(dp[j][k]==false){\n                  continue;\n              }\n              //?????£???????¨????\n              int res=1000-(p[i]%1000);\n              int res2=p[i]%1000;\n              //i?????????????????§??????\n              if(res2==0){\n                 if(k>=500){\n                       dp[j+1][k-500]=true;\n                       if(charge[j+1][k-500]>charge[j][k]+p[i]){\n                          charge[j+1][k-500]=charge[j][k]+p[i];\n                       }\n                 }\n                 continue;\n              }\n\n              if(res2<=500){\n                  dp[j+1][k+500-res2]=true;\n                  if(charge[j+1][k+500-res2]>charge[j][k]+p[i]){\n                     charge[j+1][k+500-res2]=charge[j][k]+p[i];\n                  }\n              }else{\n\n                  if((k-(res2-500))>=0){\n                     dp[j+1][k-(res2-500)]=true;\n                     if(charge[j+1][k-(res2-500)]>charge[j][k]+p[i]){\n                        charge[j+1][k-(res2-500)]=charge[j][k]+p[i];\n                     }\n                  }else{\n                     dp[j][k+res]=true;\n                     if(charge[j][k+res]>charge[j][k]+p[i]){\n                        charge[j][k+res]=charge[j][k]+p[i];\n                     }\n                  }\n\n              }\n          }\n      }\n  }\n\n\n  int ans=0;\n  long long int ans2=5000000;\n/*\nfor(int i=0;i<100;i++){\n   for(int j=0;j<5000;j++){\n   if(dp[i][j]==true){\n      //cout<<\"i\"<<i<<\"j\"<<j<<endl;\n   }\n   }\n}\n*/\n\n  bool check=false;\n  for(int i=n;i>=0;i--){\n      for(int j=0;j<5001;j++){\n          if(dp[i][j]==true){\n\n               check=true;\n               ans=i;\n               if(ans2>charge[i][j]){\n                  ans2=charge[i][j];\n               }\n          }\n      }\n      if(check==true){\n          break;\n      }\n  }\n\n  cout<<ans<<\" \"<<ans2<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\n// #define DEBUG\n\n#ifdef DEBUG\n#define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n\n\nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n\nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 101;\nconst int M = 20010;\n\nusing Elem = tuple<int, int>;\nElem dp[N][M];\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vi a(n); for(auto& e : a) cin >> e;\n\n        rep(i, n + 1) rep(j, M) dp[i][j] = Elem(-1, -1);\n        dp[0][0] = Elem(0, 0);\n\n        rep(i, n){\n            int org = a[i];\n            int price = org % 1000;\n            rep(j, M){\n                Elem cur = dp[i][j];\n                int num, total; tie(num, total) = cur;\n                if(num == -1) continue;\n\n                if(price == 0){\n                    chmax(dp[i + 1][j], cur);\n                    int diff = (price + 500) % 1000;\n                    if(j - diff >= 0){\n                        chmax(dp[i + 1][j - diff], Elem(num + 1, total - org)); // ?\n                    }\n                }\n                else if(price <= 500){\n                    chmax(dp[i + 1][min(M, j + 500 - price)], Elem(num + 1, total - org));\n                }\n                else {\n                    chmax(dp[i + 1][j], cur);\n                    chmax(dp[i + 1][min(M, j + 1000 - price)], Elem(num, total - org));\n                    int diff = (price + 500) % 1000;\n                    if(j - diff >= 0){\n                        chmax(dp[i + 1][j - diff], Elem(num + 1, total - org));\n                    }\n                }\n            }\n        }\n\n        Elem res(0, 0);\n        rep(i, n + 1){\n            rep(j, M){\n                chmax(res, dp[i][j]);\n            }\n        }\n        cout << get<0>(res) << \" \" << -get<1>(res) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  const int CMAX = 25000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 49900... too much? to get 50, max = 25000\n    // # of 500 got so far : at most 100\n    // value : minimum payment\n    \n    vector<vector<int>> dp(CMAX+1, vector<int>(101, BIG));\n    vector<vector<int>> dpnew(CMAX+1, vector<int>(101, BIG));\n    dpnew[0][0] = 0;\n    int cmax = 0;\n    for(int i = 0; i < n; i++) {\n      const int ii = i + 1;\n      // not buying\n      for(int j = 0; j <= cmax; j++) {\n        for(int k = 0; k <= i; k++) {\n          dp[j][k] = dpnew[j][k];\n        }\n      }\n      // buying\n      for(int j = 0; j <= cmax; j++) {\n        const int p = ps[i] % 1000;\n        if(p != 0 && p <= 500) { // got 500!\n          const int jj = min(j + 500 - p, CMAX);\n          cmax = min(max(cmax, jj), CMAX);\n          for(int k = 0; k <= i; k++) {\n            const int kk = k + 1;\n            if(dpnew[jj][kk] > dp[j][k] + ps[i]) {\n              dpnew[jj][kk] = dp[j][k] + ps[i];\n            }\n          }\n        } else {\n          // get 500 if possible!\n          const int q = (p == 0 ? 1000 : p) - 500;\n          if(j >= q) {\n            const int jj = j - q;\n            for(int k = 0; k <= i; k++) {\n              const int kk = k + 1;\n              if(dpnew[jj][kk] > dp[j][k] + ps[i]) {\n                dpnew[jj][kk] = dp[j][k] + ps[i];\n              }\n            }\n          } else { // get change\n            const int jj = j + 1000 - p;\n            cmax = min(max(cmax, jj), CMAX);\n            if( jj < 1000) {\n              for(int k = 0; k <= i; k++) {\n                const int kk = k;\n                if(dpnew[jj][kk] > dp[j][k] + ps[i]) {\n                  dpnew[jj][kk] = dp[j][k] + ps[i];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    for(int k = 100; k >= 0; k--) {\n      int p = BIG;\n      for(int j = 0; j <= cmax; j++) {\n        p = min(p, dpnew[j][k]);\n      }\n      if(p != BIG) {\n        cout << k << \" \" << p << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  const int CMAX = 50000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 49900... too much?\n    // # of 500 got so far : at most 100\n    // value : minimum payment\n    \n    vector<vector<int>> dp(CMAX+1, vector<int>(101, BIG));\n    vector<vector<int>> dpnew(CMAX+1, vector<int>(101, BIG));\n    dpnew[0][0] = 0;\n    int cmax = 0;\n    int kmax = 0;\n    for(int i = 0; i < n; i++) {\n      int kmax2 = kmax;\n      const int ii = i + 1;\n      for(int j = 0; j <= cmax; j++) { // not buying\n        for(int k = max(0, kmax - (n-i)); k <= i; k++) {\n          dp[j][k] = dpnew[j][k];\n        }\n      }\n      // buying\n      const int p = ps[i] % 1000;\n      if(p != 0 && p <= 500) { // got 500!\n        for(int j = 0; j <= cmax; j++) {\n          const int jj = min(j + 500 - p, CMAX);\n          cmax = min(max(cmax, jj), CMAX);\n          for(int k = max(0, kmax - (n-i)); k <= kmax; k++) {\n            const int kk = k + 1;\n            if(dpnew[jj][kk] > dp[j][k] + ps[i]) {\n              dpnew[jj][kk] = dp[j][k] + ps[i];\n              kmax2 = max(kmax2, kk);\n            }\n          }\n        }\n      } else {\n        // get 500 if possible!\n        const int q = (p == 0 ? 1000 : p) - 500;\n        for(int j = 0; j <= cmax; j++) {\n          if(j >= q) {\n            const int jj = j - q;\n            for(int k = max(0, kmax - (n-i)); k <= kmax; k++) {\n              const int kk = k + 1;\n              if(dpnew[jj][kk] > dp[j][k] + ps[i]) {\n                dpnew[jj][kk] = dp[j][k] + ps[i];\n                kmax2 = max(kmax2, kk);\n              }\n            }\n          } else { // get change\n            const int jj = j + 1000 - p;\n            cmax = min(max(cmax, jj), CMAX);\n            if( jj < 1000) {\n              for(int k = max(0, kmax - (n-i)); k <= kmax; k++) {\n                const int kk = k;\n                if(dpnew[jj][kk] > dp[j][k] + ps[i]) {\n                  dpnew[jj][kk] = dp[j][k] + ps[i];\n                  kmax2 = max(kmax2, kk);\n                }\n              }\n            }\n          }\n        }\n      }\n      kmax = kmax2;\n    }\n    for(int k = 100; k >= 0; k--) {\n      int p = BIG;\n      for(int j = 0; j <= cmax; j++) {\n        p = min(p, dpnew[j][k]);\n      }\n      if(p != BIG) {\n        cout << k << \" \" << p << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<n; ++i)\n#define rep(i,n) reps(i,0,n)\n#define maxl(a,b) a = max(a, b)\n\npair<int, int> dp[101][101 * 500];\nconst int MAX = 1001001001;\n\nvoid solve(int n)\n{\n    vector<int> p(n);\n    \n    rep(i, n){\n        cin >> p[i];\n    }\n    \n    rep(i, n+1){\n        rep(c, 101*500){\n            dp[i][c] = {-MAX, 0};\n        }\n    }\n    dp[0][0] = {0, 0};\n    \n    rep(i, n){\n        rep(c, 101*500){\n            auto r = dp[i][c];\n            maxl(dp[i+1][c], r);\n            \n            int pr = p[i] % 1000;\n            if(pr == 0){\n                if(c >= 500) maxl(dp[i+1][c - 500], make_pair(r.first+1, r.second - p[i]));\n            }\n            else if(pr <= 500){\n                maxl(dp[i+1][c + 500 - pr], make_pair(r.first+1, r.second - p[i]));\n            }\n            else{\n                maxl(dp[i+1][c - pr + 1000], make_pair(r.first, r.second - p[i]));\n                if(c >= pr - 500) maxl(dp[i+1][c - pr + 500], make_pair(r.first+1, r.second - p[i]));\n            }\n        }\n    }\n    \n    auto ans = *max_element(dp[n], dp[n] + 101*500);\n    cout << ans.first << ' ' << -ans.second << endl;\n}\n\nint main()\n{\n    int n;\n    \n    while(cin >> n, n){\n        solve(n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"iomanip\"\n#include \"cmath\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nclass weight {\npublic:\n\tint coin;\n\tint pay;\n\tweight() {\n\t\tcoin = -1;\n\t\tpay = -1;\n\t}\n\tbool operator < (const weight& w)const {\n\t\tif (coin < w.coin)return true;\n\t\tif (coin==w.coin&&pay > w.pay)return true;\n\t\treturn false;\n\t}\n\tbool operator > (const weight& w)const {\n\t\tif (coin > w.coin)return true;\n\t\tif (coin==w.coin&&pay < w.pay)return true;\n\t\treturn false;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\twhile (N) {\n\t\tweight ans;\n\t\tvector<vector<weight>>dp(N + 1, vector<weight>(N * 999 + 1));\n\t\tdp[0][0].coin = 0;\n\t\tdp[0][0].pay = 0;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tcin >> M;\n\t\t\tfor (int j = 0; j <= (i - 1) * 999; j++) {\n\t\t\t\tif (dp[i - 1][j].coin == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tweight box(dp[i - 1][j]);\n\t\t\t\tdp[i][j] = max(dp[i][j], box);\n\t\t\t\tbox.coin++;\n\t\t\t\tbox.pay += M;\n\t\t\t\tK = M % 1000;\n\t\t\t\tif (K&&K <= 500) {\n\t\t\t\t\tdp[i][j + 500 - K] = max(dp[i][j + 500 - K], box);\n\t\t\t\t\tif (j >= 500+K) {\n\t\t\t\t\t\tdp[i][j - 500 - K] = max(dp[i][j - 500 - K], box);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (K) {\n\t\t\t\t\tif (j >= K - 500) {\n\t\t\t\t\t\tdp[i][j - K + 500] = max(dp[i][j - K + 500], box);\n\t\t\t\t\t}\n\t\t\t\t\tbox.coin--;\n\t\t\t\t\tdp[i][j + 1000 - K] = max(dp[i][j + 1000 - K], box);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (j >= 500) {\n\t\t\t\t\t\tdp[i][j - 500] = max(dp[i][j - 500], box);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto i : dp[N]) {\n\t\t\tif (i.coin != -1) {\n\t\t\t\tans = max(ans, i);\n\t\t\t}\n\t\t}\n\t\tcout << ans.coin << \" \" << ans.pay << endl;\n\t\tcin >> N;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nstruct State{\n    int count,price;\n    State(int count, int price): count(count),price(price){}\n};\n\nbool operator < (const State &e, const State &f){\n    return e.count!=f.count ? e.count < f.count : e.price>f.price;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        vector<int> p(n+1);\n        for(int i=1;i<=n;i++) cin>>p[i];\n        vector<vector<State>> dp(n+1,vector<State>(66666,State(-1,0)));\n        dp[0][0]=State(0,0);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<=50000;j++){\n                int cnt=dp[i][j].count,pri=dp[i][j].price;\n                if(cnt<0) continue;\n                dp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n                int r=(1000-p[i+1]%1000)%1000;\n                dp[i+1][j+r]=max(dp[i+1][j+r],State(cnt,pri+p[i+1]));\n                if(j+r>=500) dp[i+1][(j+r)-500]=max(dp[i+1][(j+r)-500],State(cnt+1,pri+p[i+1]));\n            }\n        }\n        State res=dp[n][0];\n        for(int i=1;i<=50000;i++) res=max(res,dp[n][i]);\n        cout<<res.count<<\" \"<<res.price<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <Math.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\nusing namespace std;\n\nint ans_coin, ans_money;\nint const gohyaku = 0, hyaku = 1, goju = 2, ju = 3, go = 4, ichi = 5;\nint const val[6] = {500, 100, 50, 10, 5, 1};\nint n;\nvector<int> storeVal;\nint Tririri[6];\n\n// ?????£????????§?????¬??????\nvoid Turi(int oturi) {\n    //if(oturi > 999) return;\n    oturi %= 1000;\n    for(int i = 0; i < 6; i++) {\n        Tririri[i] = oturi / val[i];\n        oturi %= val[i];\n    }\n}\n\n// ??§????????????1000????????????????????????????????????????????????\nint NumCoin(int miyageVal, int use, int coinVal, int num) {\n    use -= 1000;\n    int i;\n    for(i = num ; i > 0; i--) {\n        //if((use + coinVal * i) - miyageVal < 1000)\n        if(miyageVal > use + coinVal * i) break;\n    }\n    return i;\n}\n\n// ????????£?????????\nvoid Store(int storeID, int *coinb, int pay) {\n    int coin[6];\n    for(int i=0;i<6;i++) {\n        coin[i] = coinb[i];\n    }\n    if(storeID >= n) {\n        //cout << \"AAAA\" << endl;\n        if(ans_coin == coin[0] && ans_money > pay) {\n            ans_money = pay;\n        }\n        \n        // ?±????\n        \n        return;\n    }\n    if(coin[0] + (n - storeID)  <  ans_coin){\n        //cout << storeID << \" \" << coin[0] << \" \" << ans_coin << endl;\n        if(ans_coin == coin[0] && ans_money > pay) {\n            ans_money = pay;\n        }\n        return;\n    }\n    \n    // ????????????????????????\n    Store(storeID+1, coin, pay);\n\n    // ??????????????????\n    int use = 1000 * ((storeVal[storeID] / 1000) + 1);\n\n    if(storeVal[storeID] % 1000 == 0) {\n        int size = 0;\n        for(int i = 0; i < 6; i++)\n            if(size += val[i] * coin[i] > 500) {\n                use += 500;\n                cout << use << endl;\n                break;\n            }\n    }\n    else {\n        for(int i = 1; i < 6; i++) {\n            use += NumCoin(storeVal[storeID], use, val[i], coin[i]) * val[i];\n        }\n    }\n    \n    Turi(use);\n    for(int i = 1; i < 6; i++) {\n        coin[i] -= Tririri[i];\n    }\n    \n    Turi(use - storeVal[storeID]);\n    for(int i = 0; i < 6; i++) {\n        coin[i] += Tririri[i];\n    }\n    \n    pay += storeVal[storeID];\n\n    \n    // 500????????´??°??????????????????\n    if(ans_coin < coin[0]) {\n        ans_coin = coin[0];\n        ans_money = pay;\n    }\n\n    \n\n    \n    Store(storeID+1, coin, pay);\n}\n\n\nint main() {\n\t\n\twhile(true) {\n        n = 0;\n        cin >> n;\n        if(n == 0) break;\n        \n        storeVal.clear();\n        for(int i = 0; i < n; i++) {\n            int a;\n            cin >> a;\n            storeVal.push_back(a);\n        }\n        ans_coin = 0;\n        ans_money = 10000000;\n        int coin[6] = {0};\n        \n        Store(0, coin, 0);\n        \n        cout << ans_coin << \" \" << ans_money << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\n using namespace std;\nbool dp[110][50011];\nlong long int charge[110][50011];\nint p[100];\nint n; \nint main(){\n  while(1){\n  cin>>n;\n  if(n==0){\n     break;\n  }\n  for(int i=0;i<n;i++){\n      cin>>p[i];\n  }\n  for(int i=0;i<110;i++){\n      for(int j=0;j<50011;j++){\n          dp[i][j]=false;\n          charge[i][j]=5000000000;\n      }\n  }\n  dp[0][0]=true;\n  charge[0][0]=0;\n  for(int i=0;i<n;i++){\n      for(int j=i+1;j>=0;j--){\n          for(int k=50000;k>=0;k--){\n              if(dp[j][k]==false){\n                  continue;\n              }\n              //?????£???????¨????\n              int res=1000-(p[i]%1000);\n              int res2=p[i]%1000;\n              //i?????????????????§??????\n              if(res2==0){\n                 if(k>=500){\n                       dp[j+1][k-500]=true;\n                       if(charge[j+1][k-500]>charge[j][k]+p[i]){\n                          charge[j+1][k-500]=charge[j][k]+p[i];\n                       }\n                 }\n                 continue;\n              }\n\n              if(res2<=500){\n                  dp[j+1][k+500-res2]=true;\n                  if(charge[j+1][k+500-res2]>charge[j][k]+p[i]){\n                     charge[j+1][k+500-res2]=charge[j][k]+p[i];\n                  }\n              }else{\n\n                  if((k-(res2-500))>=0){\n                     dp[j+1][k-(res2-500)]=true;\n                     if(charge[j+1][k-(res2-500)]>charge[j][k]+p[i]){\n                        charge[j+1][k-(res2-500)]=charge[j][k]+p[i];\n                     }\n                  }else{\n                     dp[j][k+res]=true;\n                     if(charge[j][k+res]>charge[j][k]+p[i]){\n                        charge[j][k+res]=charge[j][k]+p[i];\n                     }\n                  }\n\n              }\n          }\n      }\n  }\n\n\n  int ans=0;\n  long long int ans2=5000000;\n/*\nfor(int i=0;i<100;i++){\n   for(int j=0;j<5000;j++){\n   if(dp[i][j]==true){\n      //cout<<\"i\"<<i<<\"j\"<<j<<endl;\n   }\n   }\n}\n*/\n\n  bool check=false;\n  for(int i=n;i>=0;i--){\n      for(int j=0;j<50001;j++){\n          if(dp[i][j]==true){\n\n               check=true;\n               ans=i;\n               if(ans2>charge[i][j]){\n                  ans2=charge[i][j];\n               }\n          }\n      }\n      if(check==true){\n          break;\n      }\n  }\n\n  cout<<ans<<\" \"<<ans2<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  const int CMAX = 25000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 49900... too much?\n    // # of 500 got so far : at most 100\n    // value : minimum payment\n    \n    vector<vector<int>> dp(CMAX+1, vector<int>(101, BIG));\n    vector<vector<int>> dpnew(CMAX+1, vector<int>(101, BIG));\n    dpnew[0][0] = 0;\n    int cmax = 0;\n    for(int i = 0; i < n; i++) {\n      const int ii = i + 1;\n      for(int j = 0; j <= cmax; j++) { // not buying\n        for(int k = 0; k <= i; k++) {\n          dp[j][k] = dpnew[j][k];\n        }\n      }\n      // buying\n      const int p = ps[i] % 1000;\n      if(p != 0 && p <= 500) { // got 500!\n        for(int j = 0; j <= cmax; j++) {\n          const int jj = min(j + 500 - p, CMAX);\n          cmax = min(max(cmax, jj), CMAX);\n          for(int k = 0; k <= i; k++) {\n            const int kk = k + 1;\n            dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n          }\n        }\n      } else {\n        // get 500 if possible!\n        const int q = (p == 0 ? 1000 : p) - 500;\n        for(int j = 0; j <= cmax; j++) {\n          if(j >= q) {\n            const int jj = j - q;\n            for(int k = 0; k <= i; k++) {\n              const int kk = k + 1;\n              dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n            }\n          } else { // get change\n            const int jj = j + 1000 - p;\n            cmax = min(max(cmax, jj), CMAX);\n            if( jj < 1000) {\n              for(int k = 0; k <= i; k++) {\n                const int kk = k;\n                dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n              }\n            }\n          }\n        }\n      }\n    }\n    for(int k = 100; k >= 0; k--) {\n      int p = BIG;\n      for(int j = 0; j <= cmax; j++) {\n        p = min(p, dpnew[j][k]);\n      }\n      if(p != BIG) {\n        cout << k << \" \" << p << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[2][101][50000];\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int p[100],pp[100];\n    for(int i=0;i<n;i++)cin>>p[i],pp[i]=(1000-p[i]%1000)%1000;\n\n    for(int i=0;i<2;i++)\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<50000/2;k++)dp[i][j][k]=1e9;\n    \n    dp[0][0][0]=0;\n\n    for(int i=0;i<n;i++){\n      int ni=(i+1)%2,I=i%2;\n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<50000/2;k++)dp[ni][j][k]=1e9;\n      \n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<50000/2;k++){\n\t  int np=k+pp[i];\n\t  int nj=j;\n\t  if(np>=500)nj++,np-=500;\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t  dp[ni][j][k]=min(dp[ni][j][k],dp[I][j][k]);\n\t}\n    }\n    \n    int c=0,s=0;\n    for(int i=1;i<=n;i++)\n      for(int j=0;j<50000/2;j++)\n\tif(dp[n%2][i][j]!=1e9&&i>=c){\n\t  if(c==i&&dp[n%2][i][j]<s)s=dp[n%2][i][j];\n\t  else if(c<i)c=i,s=dp[n%2][i][j];\n\t}\n    cout<<c<<\" \"<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=n-1; i>=0; i--)\n#define INF 999999\n\nusing namespace std;\n\nint dp[101][101][6001];\nint main(){\n\tint n;\n\twhile(cin >> n ,n){\n\t\tint p[n];\n\t\trep(i,n) cin >> p[i];\n\t\trep(i,n+1) rep(j,n+1) rep(k,6000){\n\t\t\tdp[i][j][k] = INF;\n\t\t}\n\t\tdp[0][0][0] = 0;\n\t\trep(i,n) rep(j,n) rep(k,5000) if(dp[i][j][k] != INF){\n\t\t\tdp[i+1][j][k] = min(dp[i+1][j][k],dp[i][j][k]);\n\t\t/*\tif(k >= 500){\n\t\t\t\tcout << \" k >=500\" << endl;\n\t\t\t\tdp[i][j+k/500][k] = min(dp[i][j+k/500][k], dp[i][j][k]);\n\t\t\t}*/\n\t\t\tint cost = p[i]%1000;\n\t\t\t//cout <<\"i= \"<< i << \" j= \" << j << \" k = \" << k << \" \" << \"cost = \" << cost << endl;\n\t\t\t\n\t\t\t\n\t\t\tif(cost-500 <= k && cost >= 500) {\n\t\t\t\t//cout << \"A \" <<k-cost+500<< endl;\n\t\t\t\tdp[i+1][j+1][k - cost+500] = min(dp[i+1][j+1][k-cost+500],dp[i][j][k] + p[i]);\n\t\t\t}\n\n\t\t\tif(cost <= 500 && cost > 0){\n\t\t\t\t//cout << \"B\" << endl;\n\t\t\t\tdp[i+1][j+1][k + 500 - cost] = min(dp[i+1][j+1][k+500-cost],dp[i][j][k] + p[i]);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(cost <= 500 && k >= cost+500){\n\t\t\t\t//cout << \"C\" << endl;\n\t\t\t\tdp[i+1][j+1][k-500-cost] = min(dp[i+1][j+1][k-500-cost], dp[i][j][k] + p[i]);\n\t\t\t}\n\t\t\t\n\t\t\tif(k-cost >= 0){\n\t\t\t\tdp[i+1][j][k-cost] = min(dp[i+1][j][k-cost], dp[i][j][k] + p[i]);\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i+1][j][k+1000-cost] = min(dp[i+1][j][k+1000-cost], dp[i][j][k] + p[i]);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tint ans = 0,ans_min = INF;\n\t\trep(i,n+1) rep(j,n+1) rep(k,5000) if(dp[i][j][k] != INF){\n\t\t\tif(j > ans || (j== ans && ans_min > dp[i][j][k]) ){\n\t\t\t\tans = j;\n\t\t\t\tans_min = dp[i][j][k];\n\t\t\t}\n\t\t}\n\t\tcout << ans << \" \" << ans_min << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  const int CMAX = 50000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 49900... too much?\n    // # of 500 got so far : at most 100\n    // value : minimum payment\n    vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(CMAX+1, vector<int>(101, BIG)));\n    dp[0][0][0] = 0;\n    for(int i = 0; i < n; i++) {\n      const int ii = i + 1;\n      for(int j = 0; j <= CMAX; j++) { // not buying\n        for(int k = 0; k <= 100; k++) {\n          dp[ii][j][k] = dp[i][j][k];\n        }\n      }\n      // buying\n      const int p = ps[i] % 1000;\n      if(p != 0 && p <= 500) { // got 500!\n        for(int j = 0; j <= CMAX; j++) {\n          const int jj = min(j + 500 - p, CMAX);\n          for(int k = 0; k < 100; k++) {\n            const int kk = k + 1;\n            dp[ii][jj][kk] = min(dp[ii][jj][kk], dp[i][j][k] + ps[i]);\n          }\n        }\n      } else {\n        // get 500 if possible!\n        const int q = (p == 0 ? 1000 : p) - 500;\n        for(int j = 0; j <= CMAX; j++) {\n          if(j >= q) {\n            const int jj = j - q;\n            for(int k = 0; k < 100; k++) {\n              const int kk = k + 1;\n              dp[ii][jj][kk] = min(dp[ii][jj][kk], dp[i][j][k] + ps[i]);\n            }\n          } else { // get change\n            const int jj = j + 1000 - p;\n            if( jj < 1000) {\n              for(int k = 0; k <= 100; k++) {\n                const int kk = k;\n                dp[ii][jj][kk] = min(dp[ii][jj][kk], dp[i][j][k] + ps[i]);\n              }\n            }\n          }\n        }\n      }\n    }\n    for(int k = 100; k >= 0; k--) {\n      int p = BIG;\n      for(int j = 0; j <= CMAX; j++) {\n        p = min(p, dp[n][j][k]);\n      }\n      if(p != BIG) {\n        cout << k << \" \" << p << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 101;\nconst int M = 4010;\n\nint dp[N][M][N];\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vi a(n); for(auto& e : a) cin >> e;\n\n        rep(i, n + 1) rep(k, n + 1) rep(j, M) dp[i][j][k] = inf;\n        dp[0][0][0] = 0;\n\n        rep(i, n){\n            int org = a[i];\n            int price = org % 1000;\n            rep(k, n){\n                rep(j, M){\n                    int cur = dp[i][j][k];\n                    if(cur == inf) continue;\n\n                    if(price == 0){\n                        chmin(dp[i + 1][j][k], cur);\n                        int diff = (price + 500) % 1000;\n                        if(j - diff >= 0){\n                            chmin(dp[i + 1][j - diff][k + 1], cur + org);\n                        }\n                    }\n                    else if(price <= 500){\n                        chmin(dp[i + 1][min(M, j + 500 - price)][k + 1], cur + org);\n                    }\n                    else {\n                        chmin(dp[i + 1][j][k], cur);\n                        chmin(dp[i + 1][min(M, j + 1000 - price)][k], cur + org);\n                        int diff = (price + 500) % 1000;\n                        if(j - diff >= 0){\n                            chmin(dp[i + 1][j - diff][k + 1], cur + org);\n                        }\n                    }\n                }\n            }\n        }\n\n        pair<int, int> res(-1, -1);\n        rep(i, n + 1){\n            rep(k, n + 1){\n                rep(j, M){\n                    if(dp[i][j][k] == inf) continue;\n                    chmax(res, pair<int, int>(k, -dp[i][j][k]));\n                }\n            }\n        }\n        cout << res.first << \" \" << -res.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint n;\nvi p;\npii dp[111][555555];\n\npii solve(int shop, int coin)\n{\n\tif (shop == n) return pii(0, 0);\n\tif (dp[shop][coin].first >= 0) return dp[shop][coin];\n\tpii res(0, 0);\n\tchmax(res, solve(shop + 1, coin));\n\tpii tmp;\n\tif (p[shop] % 1000 == 0)\n\t{\n\t\tif (coin >= 500)\n\t\t{\n\t\t\ttmp = solve(shop + 1, coin - 500);\n\t\t\tchmax(res, pii(tmp.first + 1, tmp.second - p[shop]));\n\t\t}\n\t}\n\telse if (p[shop] % 1000 > 500)\n\t{\n\t\ttmp = solve(shop + 1, coin + 1000 - p[shop] % 1000);\n\t\tchmax(res, pii(tmp.first, tmp.second - p[shop]));\n\t\tif (p[shop] % 1000 - 500 <= coin)\n\t\t{\n\t\t\ttmp = solve(shop + 1, coin - (p[shop] % 1000 - 500));\n\t\t\tchmax(res, pii(tmp.first + 1, tmp.second - p[shop]));\n\t\t}\n\t}\n\telse\n\t{\n\t\ttmp = solve(shop + 1, coin + 500 - p[shop] % 1000);\n\t\tchmax(res, pii(tmp.first + 1, tmp.second - p[shop]));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\twhile (cin >> n, n)\n\t{\n\t\tp.resize(n);\n\t\tREP(i, n) cin >> p[i];\n\t\tREP(i, 111)REP(j, 555555) dp[i][j] = pii(-1, -1);\n\t\tpii ans = solve(0, 0);\n\t\tcout << ans.first << \" \" << -ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\npair<int, int> memo[100 + 1][50 * 5000 + 1];\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *) array, (T *) (array + N), val);\n}\n\nstd::pair<int, int> f(const int n, int nokori, int n_, const int *p) {\n    if (n <= n_)return std::make_pair(0, 0);\n    if (memo[n_][nokori].second > -1)return memo[n_][nokori];\n    int s = p[n_] % 1000;\n    int c = 0;\n    int nokori_ = nokori;\n    pair<int, int> ans = make_pair(0, 0);\n    if (s > 500 || s == 0) {\n        ans = f(n, nokori, n_ + 1, p);\n    }\n\n    if (s != 0) {\n        if (s == 500) {\n            c++;\n            if (nokori >= 500){\n                c++;\n                nokori = (500 - s);\n            }\n        } else if (s < 500) {\n            c++;\n            nokori += (500 - s);\n        } else {\n            if (s > 500)s -= 500;\n            if (s <= nokori) {\n                c++;\n                nokori -= s;\n            } else {\n                nokori += (500 - s);\n            }\n        }\n    } else if (nokori >= 500) {\n        c++;\n    } else {\n        return memo[n_][nokori_] = ans;\n    }\n    pair<int, int> hoge = f(n, nokori, n_ + 1, p);\n    pair<int, int> hoge_ = make_pair(hoge.first + c, hoge.second + p[n_]);\n    if (ans.first < hoge_.first) {\n        ans = hoge_;\n    } else if (ans.first == hoge_.first && ans.first > hoge_.first) {\n        ans = hoge_;\n    }\n    return memo[n_][nokori_] = ans;\n}\n\nint main() {\n    int n;\n    int p[100];\n    while (cin >> n, n) {\n        Fill(p, 0);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 250001; j++) {\n                memo[i][j] = make_pair(0, -1);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            cin >> p[i];\n        }\n        pair<int, int> ans = f(n, 0, 0, p);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[101][101][50000];\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int p[100];\n    for(int i=0;i<n;i++)cin>>p[i];\n    for(int i=0;i<=n;i++)\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<50000;k++)dp[i][j][k]=1e9;\n    dp[0][0][0]=0;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<50000;k++){\n\t  int np=k+(1000-(p[i]%1000))%1000;\n\t  int nj=j;\n\t  if(np>=500)nj++,np-=500;\n\t  dp[i+1][nj][np]=min(dp[i+1][nj][np],dp[i][j][k]+p[i]);\n\t  dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k]);\n\t}\n    \n    int c=0,s=0;\n    for(int i=1;i<=n;i++)\n      for(int j=0;j<50000;j++)\n\tif(dp[n][i][j]!=1e9&&i>=c){\n\t  if(c==i&&dp[n][i][j]<s)s=dp[n][i][j];\n\t  else if(c<i)c=i,s=dp[n][i][j];\n\t}\n    cout<<c<<\" \"<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint dp[128][128][1024];\nint n;\nint P[128];\n\nvoid init() {\n  for(int i = 0; i < 128; ++i) {\n    for(int j = 0; j < 128; ++j) {\n      for(int k = 0; k < 1024; ++k) {\n        dp[i][j][k] = -1;\n      }\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d\", &P[i]);\n    }\n    dp[0][0][0] = 0;\n    for(int i = 0; i < n; ++i) {\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < 1024; ++k) {\n          if( dp[i][j][k] == -1 ) continue;\n          dp[i+1][j][k] = std::max(dp[i+1][j][k], dp[i][j][k]);\n          // 1000\n          int count_1000_2 = (P[i] + 999) / 1000;\n          int rem0 = count_1000_2 * 1000 - P[i];\n          int& next0 = dp[i+1][j + (rem0%1000>=500 ? 1 : 0)][k + count_1000_2];\n          next0 = std::max(next0, dp[i][j][k] + (rem0%1000>=500 ? rem0 - 500 : rem0));\n          //\n          int count_1000 = (P[i] + 999) / 1000;\n          int rem1 = dp[i][j][k] + count_1000 * 1000 - P[i];\n          int& next = dp[i+1][j + (rem1%1000>=500 ? 1 : 0)][k + count_1000];\n          next = std::max(next, rem1%1000>=500 ? rem1 - 500 : rem1);\n          //\n          int rem11 = rem1 % 1000;\n          int next1 = dp[i+1][j + (rem11%1000>=500 ? 1 : 0)][k + count_1000];\n          next1 = std::max(next1, rem11%1000>=500 ? rem11 - 500 : rem11);\n          // rem\n          if( dp[i][j][k] > P[i] ) {\n            int rem2 = dp[i][j][k] - P[i];\n            int& next = dp[i+1][j + (rem2%1000>=500 ? 1 : 0)][k];\n            next = std::max(next, (rem2%1000>=500 ? rem2 - 500 : rem2));\n          }\n        }\n      }\n    }\n    // for(int i = 0; i <= 4; ++i) {\n    //   for(int j = 0; j <= 4; ++j) {\n    //     for(int k = 0; k < 6; ++k) {\n    //       printf(\"(i, j, k) = (%d, %d, %d) : %d\\n\", i, j, k, dp[i][j][k]);\n    //     }\n    //   }\n    // }\n    int res = (1 << 28);\n    int max = -1;\n    for(int j = n; j >= 0; --j) {\n      for(int k = 0; k < 1024; ++k) {\n        if( dp[n][j][k] == -1 ) continue;\n        int cost = k * 1000 - 500 * j - dp[n][j][k];\n        res = std::min(res, cost);\n      }\n      if( res != (1 << 28) ) {\n        max = j;\n        break;\n      }\n    }\n    printf(\"%d %d\\n\", max, res);\n  }\n         \n        \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  const int CMAX = 5000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 49900... too much?\n    // # of 500 got so far : at most 100\n    // value : minimum payment\n    vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(CMAX+1, vector<int>(101, BIG)));\n    dp[0][0][0] = 0;\n    for(int i = 0; i < n; i++) {\n      const int ii = i + 1;\n      for(int j = 0; j <= CMAX; j++) { // not buying\n        for(int k = 0; k <= 100; k++) {\n          dp[ii][j][k] = dp[i][j][k];\n        }\n      }\n      // buying\n      const int p = ps[i] % 1000;\n      if(p != 0 && p <= 500) { // got 500!\n        for(int j = 0; j <= CMAX; j++) {\n          const int jj = min(j + 500 - p, CMAX);\n          for(int k = 0; k < 100; k++) {\n            const int kk = k + 1;\n            dp[ii][jj][kk] = min(dp[ii][jj][kk], dp[i][j][k] + ps[i]);\n          }\n        }\n      } else {\n        // get 500 if possible!\n        const int q = (p == 0 ? 1000 : p) - 500;\n        for(int j = 0; j <= CMAX; j++) {\n          if(j >= q) {\n            const int jj = j - q;\n            for(int k = 0; k < 100; k++) {\n              const int kk = k + 1;\n              dp[ii][jj][kk] = min(dp[ii][jj][kk], dp[i][j][k] + ps[i]);\n            }\n          } else { // get change\n            const int jj = j + 1000 - p;\n            if( jj < 1000) {\n              for(int k = 0; k <= 100; k++) {\n                const int kk = k;\n                dp[ii][jj][kk] = min(dp[ii][jj][kk], dp[i][j][k] + ps[i]);\n              }\n            }\n          }\n        }\n      }\n    }\n    for(int k = 100; k >= 0; k--) {\n      int p = BIG;\n      for(int j = 0; j <= CMAX; j++) {\n        p = min(p, dp[n][j][k]);\n      }\n      if(p != BIG) {\n        cout << k << \" \" << p << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <utility>\nusing namespace std;\n\nconst int MAX = 1e9;\n\nint n, s[101];\npair<int, int> dp[102][101 * 500], result;\n\nvoid solve(int n){\n    for(int i = 0; i < n; i++){\n        scanf(\"%d\", &s[i]);\n    }\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j < 101 * 500; j++){\n            dp[i][j] = make_pair(-MAX, 0);\n        }\n    }\n    dp[0][0] = make_pair(0, 0);\n    for(int i = 1; i <= n; i++){\n        for(int j = 0; j < 101 * 500; j++){\n            int r = s[i-1] % 1000;\n            dp[i][j] = max(dp[i-1][j], dp[i][j]);\n            if(r == 0){\n                if(j >= 500){\n                    dp[i][j-500] = max(dp[i][j-500], make_pair(dp[i-1][j].first + 1, dp[i-1][j].second - s[i-1]));\n                }\n            }\n            else if(r <= 500){\n                dp[i][j+500-r] = max(dp[i][j+500-r], make_pair(dp[i-1][j].first + 1, dp[i-1][j].second - s[i-1]));\n            }\n            else{\n                dp[i][j+1000-r] = max(dp[i][j+1000-r], make_pair(dp[i-1][j].first, dp[i-1][j].second - s[i-1]));\n                if(j >= r - 500){\n                    dp[i][j+500-r] = max(dp[i][j+500-r], make_pair(dp[i-1][j].first + 1, dp[i-1][j].second - s[i-1]));\n                }\n            }\n        }\n        /*for(int j = 0; j < 101 * 500; j++){\n            result = max(result, dp[i][j]);\n        }\n        printf(\"%d %d\\n\", result.first, result.second);*/\n    }\n    int c = 0;\n    result = make_pair(0, 0);\n    for(int i = 0; i < 101 * 500; i++){\n        pair<int, int> a = dp[n][i];\n        result = max(result, dp[n][i]);\n    }\n    printf(\"%d %d\\n\", result.first, -result.second);\n}\n\n\nint main(){\n    while(scanf(\"%d\", &n), n)\n        solve(n);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define M 25000\n\nint dp[2][101][M];\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int p[100],pp[100];\n    for(int i=0;i<n;i++)scanf(\"%d\",&p[i]),pp[i]=(1000-p[i]%1000)%1000;\n\n    dp[0][0][0]=0;\n\n    for(int i=0;i<n;i++){\n      int ni=(i+1)%2,I=i%2,mm=min(M,500*i+1);\n\n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<mm;k++)dp[ni][j][k]=1e9;\n      \n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<mm;k++){\n\t  int np=k+pp[i];\n\t  int nj=j;\n\t  if(np>=500)nj++,np-=500;\n\t  np=min(M-1,np);\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t  dp[ni][j][k]=min(dp[ni][j][k],dp[I][j][k]);\n\t}\n    }\n    \n    int c=0,s=0;\n    for(int i=1;i<=n;i++)\n      for(int j=0;j<M;j++)\n\tif(dp[n%2][i][j]!=1e9&&i>=c){\n\t  if(c==i&&dp[n%2][i][j]<s)s=dp[n%2][i][j];\n\t  else if(c<i)c=i,s=dp[n%2][i][j];\n\t}\n    printf(\"%d %d\\n\",c,s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\ntypedef long long ll;\nusing namespace std;\n\npair<int,int> dp[2][200001];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n;\n\twhile(cin>>n,n){\n\t\tint a[201];\n\t\tfill(a,a+201,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a[i];\n\t\t}\n\t\tfor(int i=0;i<=200000;i++)dp[0][i]=make_pair(-1,0);\n\t\tdp[0][0]=make_pair(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<=200000;j++)dp[(i+1)&1][j]=make_pair(-1,0);\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tif(dp[i&1][j].fi==-1)continue;\n\t\t\t\tint tmp=a[i]%1000;\n\t\t\t\tif(tmp<=500 && tmp>=1)\n\t\t\t\t\tdp[(i+1)&1][j+500-tmp]=max(make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i]),dp[(i+1)&1][j+500-tmp]);\n\t\t\t\telse{\n\t\t\t\t\tint pay=(tmp+500)%1000;\n\t\t\t\t\tdp[(i+1)&1][j]=max(dp[(i+1)&1][j],dp[i&1][j]);\n\t\t\t\t\tif(pay<=j)\n\t\t\t\t\t\tdp[(i+1)&1][j-pay]=max(make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i]),dp[(i+1)&1][j-pay]);\n\t\t\t\t\tint pay2=(1000-tmp)%1000;\n\t\t\t\t\tdp[(i+1)&1][j+pay2]=max(make_pair(dp[i&1][j].fi,dp[i&1][j].se-a[i]),dp[(i+1)&1][j+pay2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int,int> ans=make_pair(0,0);\n\t\tfor(int i=0;i<=200000;i++){\n\t\t\tif(dp[n&1][i]>ans){\n\t\t\t\tans=make_pair(dp[n&1][i].fi,dp[n&1][i].se);\n\t\t\t}\n\t\t}\n\t\tcout<<ans.fi<<\" \"<<-ans.se<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// finish date: 2018/06/21\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <map>\n#include <climits>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i, a, b) for(int (i)=a;(i)<(b);(i)++)\n#define rep(i, n)  FOR(i,0,n)\n#define ll long long\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vvvi vector<vector<vector<int>>>\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vd vector<double>\n#define vvd vector<vector<double>>\n#define vb vector<bool>\n#define vvb vector<vector<bool>>\n#define vs vector<string>\n#define vc vector<char>\n#define vvc vector<vector<char>>\n#define pii pair<int,int>\nconst int bigmod = 1000000007;\n#define INF 1050000000\n\n\nint main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        vi p(n);\n        rep(i, n) {\n            cin >> p[i];\n        }\n        int maxDP = n * 1000;\n        vector<pii > DP(maxDP, pii(-1, -1));\n        DP[0] = pii(0, 0);\n        vector<pii > newDP;\n        rep(i, n) {\n            newDP = vector<pii >(maxDP, pii(-1, -1));\n            int otsuri = 1000 - p[i] % 1000;\n            if (otsuri == 1000) otsuri = 0;\n            for (int j = maxDP - 1; j >= 0; j--) {\n                if (DP[j] == pii(-1, -1)) continue;\n                bool con1 = newDP[j + otsuri].first < DP[j].first;\n                bool con2 = newDP[j + otsuri].first == DP[j].first;\n                bool con3 = newDP[j + otsuri].second > DP[j].second + p[i];\n                if (con1 || (con2 && con3)) {\n                    newDP[j + otsuri] = DP[j];\n                    newDP[j + otsuri].second += p[i];\n                }\n            }\n            rep(j, maxDP) {\n                if (newDP[j] == pii(-1, -1)) continue;\n                if (j >= 500) {\n                    bool con1 = newDP[j - 500].first < newDP[j].first + 1;\n                    bool con2 = newDP[j - 500].first == newDP[j].first + 1;\n                    bool con3 = newDP[j - 500].second > newDP[j].second;\n                    if (con1 || (con2 && con3)) {\n                        newDP[j - 500] = newDP[j];\n                        newDP[j - 500].first++;\n                    }\n                }\n            }\n            rep(j, maxDP) {\n                if (DP[j].first > newDP[j].first || (DP[j].first == newDP[j].first && DP[j].second < newDP[j].second)) {\n                    newDP[j] = DP[j];\n                }\n            }\n            DP = newDP;\n        }\n\n\n\n        int ma = -1;\n        int ansMoney = 0;\n        rep(i, maxDP) {\n            if (DP[i].first > ma || (DP[i].first == ma && DP[i].second < ansMoney)) {\n                ma = DP[i].first;\n                ansMoney = DP[i].second;\n            }\n        }\n        cout << ma << \" \" << ansMoney << endl;\n\n    }\n\n\n    return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1e9;\nconst int MAX_LEFT = 500 * 101 + 1;\nclass Solver {\n  public:\n    bool solve() {\n        int N; cin >> N;\n        if(N == 0) return false;\n        vector<int> P(N); cin >> P;\n        \n        vector<vector<pii>> DP(N + 1, vector<pii>(MAX_LEFT, make_pair(0, -INF))); // := (500???, ?????£??????)\n        DP[0][0] = make_pair(0, 0);\n        rep(n, N) {\n            rep(left, MAX_LEFT) {\n                int num  = DP[n][left].first;\n                int used = DP[n][left].second * -1;\n                if(used >= INF) continue;\n                \n                // ????????????\n                set_max(DP[n + 1][left], DP[n][left]);\n                \n                used += P[n];\n                \n                int p = P[n] % 1000;\n                if(p == 0) {\n                    if(left >= 500) {\n                        set_max(DP[n + 1][left - 500], pii(num + 1, -1 * used));\n                    }\n                } else if(p <= 500) {\n                    int add = 500 - p;\n                    set_max(DP[n + 1][left + add], pii(num + 1, -1 * used));\n                    \n                } else {\n                    int need = p - 500;\n                    if(left >= need) \n                        set_max(DP[n + 1][left - need], pii(num + 1, -1 * used));\n                    else { // ?°?????????????\n                        int add = 1000 - p;\n                        set_max(DP[n + 1][left + add], pii(num, -1 * used));   \n                    }\n                }\n            }\n        }\n        pii ans(-1, 0);\n        rep(i, MAX_LEFT) set_max(ans, DP[N][i]);\n        cout << ans.first << \" \" << ans.second * -1 << endl;\n        return true;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        Solver s;\n        if(!s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  const int CMAX = 25000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 49900... too much? to get 50, max = 25000\n    // # of 500 got so far : at most 100\n    // value : minimum payment\n    \n    vector<vector<int>> dp(CMAX+1, vector<int>(101, BIG));\n    vector<vector<int>> dpnew(CMAX+1, vector<int>(101, BIG));\n    dpnew[0][0] = 0;\n    int cmax = 0;\n    for(int i = 0; i < n; i++) {\n      const int ii = i + 1;\n      // not buying\n      for(int j = 0; j <= cmax; j++) {\n        for(int k = 0; k <= i; k++) {\n          dp[j][k] = dpnew[j][k];\n        }\n      }\n      // buying\n      for(int j = 0; j <= cmax; j++) {\n        const int p = ps[i] % 1000;\n        if(p != 0 && p <= 500) { // got 500!\n          const int jj = min(j + 500 - p, CMAX);\n          cmax = min(max(cmax, jj), CMAX);\n          for(int k = 0; k <= i; k++) {\n            const int kk = k + 1;\n            if(dpnew[jj][kk] > dp[j][k] + ps[i]) {\n              dpnew[jj][kk] = dp[j][k] + ps[i];\n            }\n          }\n        } else {\n          // get 500 if possible!\n          const int q = (p == 0 ? 1000 : p) - 500;\n          if(j >= q) {\n            const int jj = j - q;\n            for(int k = 0; k <= i; k++) {\n              const int kk = k + 1;\n              if(dpnew[jj][kk] > dp[j][k] + ps[i]) {\n                dpnew[jj][kk] = dp[j][k] + ps[i];\n              }\n            }\n          } else { // get change\n            const int jj = j + 1000 - p;\n            cmax = min(max(cmax, jj), CMAX);\n            if( jj < 1000) {\n              for(int k = 0; k <= i; k++) {\n                const int kk = k;\n                if(dpnew[jj][kk] > dp[j][k] + ps[i]) {\n                  dpnew[jj][kk] = dp[j][k] + ps[i];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    for(int k = 100; k >= 0; k--) {\n      int p = BIG;\n      for(int j = 0; j <= cmax; j++) {\n        p = min(p, dpnew[j][k]);\n      }\n      if(p != BIG) {\n        cout << k << \" \" << p << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nP dp[105][50005];\nint p[100];\nvoid Max(P &a,P b){a=max(a,b);}\nint main(){\n  int n;\n  while(cin>>n && n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++)cin>>p[i];\n    dp[0][0] = P(0,0);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<50000;j++){\n        if(dp[i][j]==P(-1,-1)) continue;\n        int nf=dp[i][j].first,ns=dp[i][j].second-p[i];\n        Max(dp[i+1][j],dp[i][j]);\n        if(p[i]%1000==0)\n          {if(j>=500) Max(dp[i+1][j-500],P(nf+1,ns));}\n        else if(p[i]%1000<500) Max(dp[i+1][j+500-p[i]%500],P(nf+1,ns));\n        else if(p[i]%500<=j) Max(dp[i+1][j-p[i]%500],P(nf+1,ns));\n        Max(dp[i+1][j+500-p[i]%500],P(nf,ns)); \n      }\n    }\n    P ans(0,0);\n    for(int i=0;i<50000;i++) Max(ans,dp[n][i]);\n    cout<<ans.first<<\" \"<<-ans.second<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nconst vector<int> money = {500, 100, 50, 10, 5, 1};\nconst int MAX_N = 101;\n\nint n;\nvector<int> p;\npair<int, int> memo[MAX_N][5][2][5][2][5];\n\npair<int, int> Solve(int id, int c1, int c5, int c10, int c50, int c100) {\n    auto &res = memo[id][c1][c5][c10][c50][c100];\n\n    if (res.second != -1)\n        return res;\n\n    // id?????????????????£?±???§??????\n    int sum = 1 * c1 + 5 * c5 + 10 * c10 + 50 * c50 + 100 * c100 + 5000;\n    int r = (sum - p[id]) % 1000;\n    vector<int> c(6, 0);\n    for (int i = 0; i < 6; ++i) {\n        c[i] = r / money[i];\n        r -= c[i] * money[i];\n    }\n    if (id == n - 1) {\n        res.first = c[0];\n        res.second = p[id];\n    }\n    else {\n        res = Solve(id + 1, c[5], c[4], c[3], c[2], c[1]);\n        res.first += c[0];\n        res.second += p[id];\n    }\n\n    // id?????????????????£?±???§????????????\n    if (id == n - 1) {\n        if (res.first == 0)\n            res = make_pair<int, int>(0, 0);\n    }\n    else {\n        auto tmp = Solve(id + 1, c1, c5, c10, c50, c100);\n        if ((res.first < tmp.first) || (res.first == tmp.first && res.second > tmp.second))\n            res = tmp;\n    }\n\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n, n) {\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            cin >> p[i];\n\n        const vector<int> MAX_C = {5, 2, 5, 2, 5};\n        for (int i1 = 0; i1 <= n; ++i1)\n            for (int i2 = 0; i2 < MAX_C[0]; ++i2)\n                for (int i3 = 0; i3 < MAX_C[1]; ++i3)\n                    for (int i4 = 0; i4 < MAX_C[2]; ++i4)\n                        for (int i5 = 0; i5 < MAX_C[3]; ++i5)\n                            for (int i6 = 0; i6 < MAX_C[4]; ++i6)\n                                memo[i1][i2][i3][i4][i5][i6] = make_pair(0, -1);\n\n        auto res = Solve(0, 0, 0, 0, 0, 0);\n\n        cout << res.first << ' ' << res.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 2147483647\nusing namespace std;\nint p[50];\nint dp[50][51][1000];\nint min(int n, int m){ return (n>m)?m:n; }\nint main(void){\n  for(;;){\n    int n;\n    cin >> n;\n    if(n == 0){return 0;}\n    for(int i = 0; i < n ; i++){\n      cin >> p[i];\n    }\n    for(int j = 0 ; j <= n ; j++){\n      for(int coins = 0 ; coins < 1000 ; coins++){\n        dp[0][j][coins] = INF;\n      }\n    }\n    dp[0][0][0] = 0;\n    if(p[0]%1000==0 || p[0]%1000>500){\n      dp[0][0][(1000-(p[0]%1000))%1000] = min(p[0],dp[0][0][(1000-(p[0]%1000))%1000]);\n    }else{\n      dp[0][1][500-(p[0]%1000)] = min(p[0],dp[0][1][500-(p[0]%1000)]);\n    }\n    for(int i = 1 ; i < n ; i++){\n      for(int coins = 0 ; coins < 1000 ; coins++){\n        dp[i][0][coins] = dp[i-1][0][coins];\n      }\n      if(p[i]%1000 >= 500){ dp[i][0][(1000-p[i])%1000] = min(dp[i-1][0][(1000-p[i])%1000], p[i]); }\n      for(int j = 1 ; j <= n ; j++){\n        for(int coins = 0 ; coins < 1000 ; coins++){\n          dp[i][j][coins] = dp[i-1][j][coins];\n        }\n      }\n      for(int j = 1 ; j <= n ; j++){\n        for(int coins = 0 ; coins < 1000 ; coins++){\n          if(p[i]%1000==0 && coins >= 500){\n            if(dp[i-1][j-1][coins] != INF){dp[i][j][coins-500] = dp[i-1][j-1][coins] + p[i];}\n          }else if(p[i]%1000!=0 && 1000-(p[i]%1000)+coins >= 500){\n            if(dp[i-1][j-1][coins] != INF){\n              dp[i][j][(2000+coins-(p[i]%1000)-500)%1000] = min(dp[i][j][(2000+coins-(p[i]%1000)-500)%1000], dp[i-1][j-1][coins]+p[i]);\n            }\n          }else if(p[i]%1000!=0){\n            if(dp[i-1][j][coins] != INF){\n              dp[i][j][(1000+coins-(p[i]%1000))%1000] = min(dp[i][j][(1000+coins-(p[i]%1000))%1000], dp[i-1][j][coins]+p[i]);\n            }\n          }\n        }\n      }\n    }\n    /*\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j <= n ; j++){\n        for(int coins = 0 ; coins < 1000 ; coins ++){\n          if(dp[i][j][coins] != INF){cout << \"dp[\" << i << \"][\" << j << \"][\" << coins << \"] = \" << dp[i][j][coins] << endl;}\n        }\n      }\n    }\n    */\n    int s = INF; int c = INF;\n    for(int j = n ; j >= 0 && (s == INF) ; j--){\n      s = INF;\n      for(int coins = 0 ; coins < 1000 ; coins++){\n        if(s > dp[n-1][j][coins]){s = dp[n-1][j][coins];}\n      }\n      c = j;\n    }\n    cout << c << \" \" << s << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,s,e) for (int i=s;i<(e);i++)\n#define All(v) (v).begin(),(v).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define fi first\n#define se second\n#define int long long\nusing namespace std;\ntypedef long long llint;\ntypedef pair<int, int> P;\nconst int MOD = (int)1e9 + 7;\nconst int INF = (int)1e18 * 5;\n\nP dp[110][50010];\n\nP max(P p1, P p2){\n    if(p1.fi > p2.fi) return p1;\n    if(p1.fi < p2.fi) return p2;\n    if(p1.se < p2.se) return p1;\n    if(p1.se > p2.se) return p2;\n    else return p1;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    while(n != 0){\n        vector<int> p(n);\n        REP(i, n) cin >> p[i];\n        \n        REP(i, n+1)REP(j, 50000) dp[i][j] = mp(-1, 0);\n        dp[0][0] = mp(0, 0);\n        REP(i, n){\n            int req = p[i]%1000;\n            if(req == 0) req = 1000;\n            REP(j, 50000){\n                if(dp[i][j].fi >= 0){\n                    int c = req-500;\n                    // 1000円払って 500円+小銭をGET\n                    if(req <= 500) dp[i+1][j+(500-req)] = mp(dp[i][j].fi+1, dp[i][j].se+p[i]);\n                    else{\n                        // 1000+c円払って 500円を1枚GET\n                        if(j >= c) dp[i+1][j-c] = max(dp[i+1][j-c], mp(dp[i][j].fi+1, dp[i][j].se+p[i]));\n                        // 1000円払って 小銭をGET\n                        dp[i+1][j+(1000-req)] = max(dp[i+1][j+(1000-req)], mp(dp[i][j].fi, dp[i][j].se+p[i]));\n                        // 買わない\n                        dp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n                    }\n                }\n            }\n        }\n        P ans = mp(0, 0);\n        REP(i, 50000){\n            ans = max(ans, dp[n][i]);\n        }\n        cout << ans.fi << \" \" << ans.se << \"\\n\";\n\n        cin >> n;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nstruct State{\n    int count,price;\n    State(int count, int price): count(count),price(price){}\n};\n\nbool operator < (const State &e, const State &f){\n    return e.count!=f.count ? e.count < f.count : e.price>f.price;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        vector<int> p(n+1);\n        for(int i=1;i<=n;i++) cin>>p[i];\n        vector<vector<State>> dp(n+1,vector<State>(1111,State(-1,0)));\n        dp[0][0]=State(0,0);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<=500;j++){\n                int cnt=dp[i][j].count,pri=dp[i][j].price;\n                if(cnt<0) continue;\n                dp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n                //if(p[i+1]%1000==0) continue;\n                int r=1000-p[i+1]%1000;\n                if(j+r<500) dp[i+1][j+r]=max(dp[i+1][j+r],State(cnt,pri+p[i+1]));\n                else dp[i+1][(j+r)%500]=max(dp[i+1][(j+r)%500],State(cnt+1,pri+p[i+1]));\n            }\n        }\n        State res=dp[n][0];\n        for(int i=1;i<500;i++) res=max(res,dp[n][i]);\n        cout<<res.count<<\" \"<<res.price<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// Ryo Kamoi\n// #define DEBUG\n\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint INF = 1000000000;\n\nint n;\nint p[101];\nint res_[101];\nint rt_[101];\npii dp[500*100+1];\npii prevdp[500*100+1];\nint main(){\n  while(1) {\n    cin >> n;\n    if (n==0) break;\n\n    p[0] = INF; // not used\n    REP(i, n) {\n      cin >> p[i+1];\n    }\n\n    REP(k, 500*n+1) {\n      prevdp[k] = pii(0, INF);\n      dp[k] = pii(0, INF);\n    }\n    prevdp[0] = pii(0, 0);\n\n    for(int i=1; i<=n; i++) { \n      REP(k, 500*n+1) {\n        int res = p[i] % 1000;\n        int rt = 1000 - res;\n\n        if (rt == 1000) {\n          res = 1000;\n          rt = 0;\n        }\n\n        dp[k] = prevdp[k];\n        if (rt >= 500) {\n          if (k>=(rt-500)) {\n            pii prev = prevdp[k-(rt-500)];\n            if (prev.second >= INF) continue;\n            if (dp[k].first == prev.first+1) {\n              dp[k] = pii(prev.first+1, min(dp[k].second, prev.second+p[i]));\n            } else if (dp[k].first < prev.first+1) {\n              dp[k] = pii(prev.first+1, prev.second+p[i]);\n            }\n          }\n        } else {\n          if (k<=500*n-(res-500)) {\n            pii prev = prevdp[k+(res-500)];\n            if (prev.second < INF) {\n              if (dp[k].first < prev.first + 1) {\n                dp[k].first = prev.first+1;\n                dp[k].second = prev.second + p[i];\n              } else if (dp[k].first == prev.first + 1) {\n                dp[k].second = min(dp[k].second, prev.second+p[i]);\n              }\n            }\n          }\n          if (k>=rt) {\n            pii prev = prevdp[k-rt];\n            if (prev.second < INF) {\n              if (dp[k].first == prev.first) {\n                dp[k].second = min(dp[k].second, prev.second + p[i]);\n              } else if (dp[k].first < prev.first) {\n                dp[k].first = prev.first;\n                dp[k].second = prev.second + p[i];\n              }\n            }\n          }\n        }\n      }\n\n      REP(k, 500*n+1) {\n        prevdp[k] = dp[k];\n      }\n    }\n\n    int maxnum = 0;\n    int price;\n    REP(k, 500*n+1) {\n      if (dp[k].second >= INF) {\n        continue;\n      }\n\n      if (dp[k].first > maxnum) {\n        maxnum = dp[k].first;\n        price = dp[k].second;\n      } else if (dp[k].first == maxnum) {\n        price = min(price, dp[k].second);\n      }\n    }\n\n    cout << maxnum << \" \" << price << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\nconst int inf = 1e9;\nconst int limit = 1e5;\npair<int, int> operator+(const pair<int, int> &a, const pair<int, int> &b){\n    return make_pair(a.first +b.first, a.second +b.second);\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        \n        vector<int> p(n);\n        for(int i=0; i<n; i++) cin >> p[i];\n\n        vector<pair<int, int> > dp(limit, make_pair(-1,-1));\n        dp[0] = make_pair(0,0);\n        for(int i=0; i<n; i++){\n            vector<pair<int, int> > ndp(limit, make_pair(-1,-1));\n            for(int j=0; j<limit; j++){\n                if(dp[j].first == -1) continue;\n                ndp[j] = max(ndp[j], dp[j]);\n                int ch = (1000 -(p[i]%1000)) %1000;\n                ndp[j+ch%500] = max(ndp[j+ch%500], dp[j] +make_pair(ch/500, -p[i]));\n                if(ch < 500 && ch +j >= 500){\n                    ndp[j-(500-ch)] = max(ndp[j-(500-ch)], dp[j] +make_pair(1, -p[i]));\n                }\n            }\n            dp = ndp;\n        }\n\n        int ansn=0, ansp=0;\n        for(int i=0; i<limit; i++){\n            if(dp[i].first >= ansn){\n                if(dp[i].first != ansn){\n                    ansp = -dp[i].second;\n                }else{\n                    ansp = min(ansp, -dp[i].second);\n                }\n                ansn = dp[i].first;\n            }\n        }\n        cout << ansn << \" \" << ansp << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\n  \nbool cmp(pair< int, int > a, pair< int, int > b)\n{\n  if(a.first != b.first) return(a.first > b.first);\n  return(a.second < b.second);\n}\nint main()\n{\n  int N, p[100];\n    \n  while(scanf(\"%d\", &N), N) {\n    for(int i = 0; i < N; i++) {\n      scanf(\"%d\", &p[i]);\n    }\n      \n    pair< int, int > dp[2][50001];\n    fill_n(*dp, 2 * 50001, make_pair(-INF, INF));\n    pair< int, int > *now = dp[0], *nxt = dp[1];\n      \n    now[0] = {0, 0};\n    int reach = 0;\n    for(int i = 0; i < N; i++) {\n      int mod = p[i] % 1000;\n      if(1 <= mod && mod <= 500) {\n        int rev = 1000 - mod - 500;\n        reach += rev;\n        for(int j = reach; j >= rev; j--) {\n          nxt[j] = min(nxt[j], {now[j - rev].first + 1, now[j - rev].second + p[i]}, cmp);\n        }\n      } else {\n        int rev = (1000 - mod) % 1000;\n        int need = (mod + 500) % 1000;\n        reach += max(rev, need);\n        for(int j = reach; j >= 0; j--) {\n          nxt[j] = min(nxt[j], now[j], cmp);\n        }\n        for(int j = reach; j >= rev; j--) {\n          nxt[j] = min(nxt[j], {now[j - rev].first, now[j - rev].second + p[i]}, cmp);\n        }\n        for(int j = need; j <= reach; j++) {\n          nxt[j - need] = min(nxt[j - need], {now[j].first + 1, now[j].second + p[i]}, cmp);\n        }\n      }\n      swap(now, nxt);\n    }\n    auto p = *min_element(now, now + 50000, cmp);\n    printf(\"%d %d\\n\", p.first, p.second);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nconst int INF = 500002;\nint p[102];\nP dp[102][102][502];\nbool visited[102][102][502];\nint n;\n\nP dfs(int pos, int r, int ex){\n    if(pos == n) return P(0, 0);\n    if(visited[pos][r][ex]) return dp[pos][r][ex];\n    int pay = 1000;\n    while(pay < p[pos]) pay += 1000;\n    int nex = ex + pay - p[pos];\n    int nr = r + nex / 500;\n    nex %= 500;\n    P ret = dfs(pos+1, r, ex);\n    if(nr > 0){\n        P res = dfs(pos+1, nr-1, nex);\n        ret = max(ret, P(res.first + 1, res.second - p[pos]));\n    }else{\n        P res = dfs(pos+1, nr, nex);\n        ret = max(ret, P(res.first, res.second - p[pos]));\n    }\n    dp[pos][r][ex] = ret;\n    visited[pos][r][ex] = true;\n    return ret;\n}\n\nint main(){\n    while(true){\n        cin >> n;\n        if(n == 0) break;\n\n        for(int i=0;i<n;i++){\n            cin >> p[i];\n        }\n\n        memset(visited, 0, sizeof(visited));\n        P ans = dfs(0, 0, 0);\n        cout << ans.first << \" \" << -ans.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// dp[i][500yen][num_1000yen] := remain ([i] is deleted)\nint dp[128][512];\nint n;\nint P[128];\n\nvoid init() {\n  for(int j = 0; j < 128; ++j) {\n    for(int k = 0; k < 512; ++k) {\n      dp[j][k] = -1;\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d\", &P[i]);\n    }\n    dp[0][0] = 0;\n    for(int i = 0; i < n; ++i) {\n      for(int j = i; j >= 0; --j) {\n        for(int k = 512 - 1; k >= 0; --k) {\n          if( dp[j][k] == -1 ) continue;\n          int n1kyen = (P[i] + 999) / 1000;\n          int rem = dp[j][k] + n1kyen * 1000 - P[i];\n          int next_num500yen = j + (rem >= 500 ? 1 : 0);\n          int next_num1kyen  = k + n1kyen;\n          int next_rem       = rem >= 500 ? rem - 500 : rem;\n          int& next = dp[next_num500yen][next_num1kyen];\n          next = std::max(next, next_rem);\n        }\n      }\n    }    \n    int res = (1 << 28);\n    int max = -1;\n    for(int j = n; j >= 0; --j) {\n      for(int k = 0; k < 512; ++k) {\n        if( dp[j][k] == -1 ) continue;\n        int cost = k * 1000 - 500 * j - dp[j][k];\n        res = std::min(res, cost);\n      }\n      if( res != (1 << 28) ) {\n        max = j;\n        break;\n      }\n    }\n    printf(\"%d %d\\n\", max, res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n\n    while (scanf(\"%d\", &n) && n){\n        int a[128];\n        pair<int, int> dp[128][50 * 500];\n\n        for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n\n        for (int i = 0; i <= n; i++){\n            for (int j = 0; j < 50 * 500; j++){\n                dp[i][j] = make_pair(0, -1001001001);\n            }\n        }\n\n        dp[0][0] = make_pair(0, 0);\n        for (int i = 1; i <= n; i++){\n            for (int j = 0; j < min(i, 50) * 500; j++){\n                if (dp[i - 1][j].second != -1001001001){\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j]);\n                    int r = (1000 - a[i] % 1000) % 1000;\n                    if (j + r >= 500){\n                        pair<int, int> nxt = make_pair(dp[i - 1][j].first + 1, dp[i - 1][j].second - a[i]);\n                        dp[i][j + r - 500] = max(dp[i][j + r - 500], nxt);\n                    }\n                    dp[i][j + r] = max(dp[i][j + r], make_pair(dp[i - 1][j].first, dp[i - 1][j].second - a[i]));\n                }\n            }\n        }\n\n        pair<int, int> ans = *max_element(dp[n], dp[n] + 50 * 500);\n        printf(\"%d %d\\n\", ans.first, -ans.second);\n    }\n    \n    return (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nP dp[105][500*55];\n\nint main(){\n  \n  int n;\n  \n  while(cin>>n, n){\n    \n    memset(dp,-1,sizeof(dp));\n    \n    dp[0][0]=P(0,0);\n\n    P ans=P(0,0);\n    \n    for(int i=0;i<n;i++){\n      \n      int p;\n      cin>>p;\n      \n      for(int j=0;j<500*55;j++){\n\tif(dp[i][j]==P(-1,-1)) continue;\n\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\tif(p%1000){\n\t  int rest=1000-p%1000, add500=0;\n\t  if(rest>=500) add500++, rest-=500;\n\t  int idx=min(j+rest,500*55-1);\n\t  dp[i+1][idx]=max(dp[i+1][idx],P(dp[i][j].first+add500,-(-dp[i][j].second+p)));\n\t  ans=max(ans,dp[i+1][idx]);\n\t}\n\tint rest=p+500;\n\trest%=1000;\n\tif(j-rest<0) continue;\n\tdp[i+1][j-rest]=max(dp[i+1][j-rest],P(dp[i][j].first+1,-(-dp[i][j].second+p)));\n\tans=max(ans,dp[i+1][j-rest]);\n      }\n      \n    }\n\n    cout<<ans.first<<' '<<-ans.second<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\nconst int inf = 1e9;\nconst int limit = 5e5;\npair<int, int> operator+(const pair<int, int> &a, const pair<int, int> &b){\n    return make_pair(a.first +b.first, a.second +b.second);\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        \n        vector<int> p(n);\n        for(int i=0; i<n; i++) cin >> p[i];\n\n        vector<pair<int, int> > dp(limit +1, make_pair(-1,-1));\n        dp[0] = make_pair(0,0);\n        for(int i=0; i<n; i++){\n            for(int j=limit; j>=0; j--){\n                if(dp[j].first == -1) continue;\n                int next = j+p[i];\n                int ch = (1000 -(p[i]%1000)) %1000;\n                dp[next] = max(dp[next], dp[j] +make_pair(ch/500, ch%500));\n                if(ch < 500 && ch +dp[j].second >= 500){\n                    dp[next] = max(dp[next], dp[j] +make_pair(1, -(500-ch)));\n                }\n            }\n        }\n\n        int ansn=0, ansp=0;\n        for(int i=0; i<=limit; i++){\n            if(dp[i].first > ansn){\n                ansn = dp[i].first;\n                ansp = i;\n            }\n        }\n        cout << ansn << \" \" << ansp << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define fi first\n#define sc second\n#define mp make_pair\npair<int,int> dp[105][50005];\nint n,p[105];\nvoid chh(pair<int,int> &a,pair<int,int> &b){\n\tif(a.fi < b.fi) a = b;\n\telse if(a.fi == b.fi) a.sc = min(a.sc,b.sc);\n}\nint main(){\n\twhile(1){\n\t\tcin>>n; if(!n) return 0;\n\t\tfor(int i=1;i<=n;i++) cin>>p[i];\n\t\tfor(int i=0;i<105;i++) for(int j=0;j<50005;j++) dp[i][j] = mp(-10000,100000000);\n\t\tdp[0][0] = mp(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<50005;j++){\n\t\t\t\tif(dp[i][j].fi < 0) continue; //cout <<i << \" \" <<j<< endl;\n\t\t\t\tif(dp[i+1][j].fi < dp[i][j].fi) dp[i+1][j] = dp[i][j];\n\t\t\t\telse if(dp[i+1][j].fi == dp[i][j].fi) dp[i+1][j].sc = min(dp[i+1][j].sc,dp[i][j].sc);\n\t\t\t\t\n\t\t\t\tif(p[i+1]%1000 == 0){\n\t\t\t\t\tif(j>=500){\n\t\t\t\t\t\tpair<int,int> Q=mp(dp[i][j].fi+1,dp[i][j].sc+p[i+1]) ;\n\t\t\t\t\t\tchh(dp[i+1][j-500],Q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(p[i+1]%1000 <= 500){\n\t\t\t\t\tpair<int,int> Q=mp(dp[i][j].fi+1,dp[i][j].sc+p[i+1]) ;\n\t\t\t\t\tchh(dp[i+1][j+500-(p[i+1]%1000)],Q);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(j+500-(p[i+1]%1000)>=0){\n\t\t\t\t\t\tpair<int,int> Q=mp(dp[i][j].fi+1,dp[i][j].sc+p[i+1]) ;\n\t\t\t\t\t\tchh(dp[i+1][j+500-(p[i+1]%1000)],Q);\n\t\t\t\t\t}\n\t\t\t\t\tpair<int,int> Q=mp(dp[i][j].fi,dp[i][j].sc+p[i+1]) ;\n\t\t\t\t\tchh(dp[i+1][j+1000-(p[i+1]%1000)],Q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int,int> ans = mp(-10000,100000000);\n\t\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<50005;j++){\n\t\t\tif(ans.fi < dp[i][j].fi) ans = dp[i][j];\n\t\t\telse if(ans.fi == dp[i][j].fi) ans.sc = min(ans.sc,dp[i][j].sc);\n\t\t}}\n\t\tcout <<ans.fi<<\" \" << ans.sc << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <climits>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RFOR(i,a,b) for (int i=(a)-1;i>=(b);i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nusing namespace std;\n\nconst int MAXN = 5003;\n\npair<int,int> maxa(pair<int,int> a, int f,int s,pair<int,int> b){\n\tif(f)a.first++;\n\ta.second+=s;\n\tif(a.first > b.first)return a;\n\telse if(a.first == b.first){\n\t\tif(a.second < b.second)return a;\n\t\telse return b;\n\t}else return b;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<int> p(n);\n\t\tREP(i,n)cin>>p[i];\n\t\tpair<int,int> dp[2][MAXN + 503];\n\t\tfill(dp[0],dp[2],make_pair(0,INF));// num of 500 and imamade ni tukatta okane\n\t\tdp[1][0] = make_pair(0,0);\n\t\tREP(i,n){\n\t\t\tfill(dp[i&1],dp[i&1] + MAXN,make_pair(0,INF));// num of 500 and imamade ni tukatta okane\n\t\t\tfor(int j = MAXN;j >= 0;j--){\n\t\t\t\tif(p[i] % 1000 <= 500 && p[i] % 1000 > 0 && (dp[(i+1)&1][j].second != INF || j==0) ){\n\t\t\t\t\tdp[i&1][j + (5000-p[i])%500] = maxa(dp[(i+1)&1][j],1,p[i],dp[i&1][j + (5000-p[i])%500]);\n\t\t\t\t\t//toriaezu 1000(+500)\n\t\t\t\t}else{\n\t\t\t\t\tif(p[i] %1000 > 0 &&  dp[(i+1)&1][j + p[i]%500].second != INF){\n\t\t\t\t\t\tdp[i&1][j] = maxa(dp[(i+1)&1][j + p[i]%500],1,p[i],dp[i&1][j]);\n\t\t\t\t\t}//1000n + iikanjino\n\t\t\t\t\tif(p[i] %1000 == 0 &&  dp[(i+1)&1][j + 500].second != INF){\n\t\t\t\t\t\tdp[i&1][j] = maxa(dp[(i+1)&1][j + 500],1,p[i],dp[i&1][j]);\n\t\t\t\t\t}// 1000n + 500\n\t\t\t\t\tif(dp[(i+1)&1][j].second != INF || j==0)//toriaezu 1000(not +500)\n\t\t\t\t\t\tdp[i&1][j + (5000-p[i])%500] = maxa(dp[(i+1)&1][j],0,p[i],dp[i&1][j + (5000-p[i])%500]);\n\t\t\t\t}\n\t\t\t\tdp[i&1][j] = maxa(dp[i&1][j],0,0,dp[(i+1)&1][j]);\n\t\t\t}\n\t\t}\n\t\tpair<int,int> ans = make_pair(0,0);\n\t\tfor(int j = MAXN + 500;j >= 0;j--){\n\t\t\tans = maxa(dp[(n-1)&1][j],0,0,ans);\n\t\t}\n\t\tcout << ans.first << ' ' << ans.second << endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\n// #define DEBUG\n\n#ifdef DEBUG\n#define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n\n\nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n\nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 101;\nconst int M = 10010;\n\nusing Elem = tuple<int, int>;\nElem dp[N][M];\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vi a(n); for(auto& e : a) cin >> e;\n\n        rep(i, n + 1) rep(j, M) dp[i][j] = Elem(-1, -1);\n        dp[0][0] = Elem(0, 0);\n\n        rep(i, n){\n            int org = a[i];\n            int price = org % 1000;\n            rep(j, M){\n                Elem cur = dp[i][j];\n                int num, total; tie(num, total) = cur;\n                if(num == -1) continue;\n\n                if(price == 0){\n                    chmax(dp[i + 1][j], cur);\n                    int diff = (price + 500) % 1000;\n                    if(j - diff >= 0){\n                        chmax(dp[i + 1][j - diff], Elem(num + 1, total - org)); // ?\n                    }\n                }\n                else if(price <= 500){\n                    chmax(dp[i + 1][min(M, j + 500 - price)], Elem(num + 1, total - org));\n                }\n                else {\n                    chmax(dp[i + 1][j], cur);\n                    chmax(dp[i + 1][min(M, j + 1000 - price)], Elem(num, total - org));\n                    int diff = (price + 500) % 1000;\n                    if(j - diff >= 0){\n                        chmax(dp[i + 1][j - diff], Elem(num + 1, total - org));\n                    }\n                }\n            }\n        }\n\n        Elem res(0, 0);\n        rep(i, n + 1){\n            rep(j, M){\n                chmax(res, dp[i][j]);\n            }\n        }\n        cout << get<0>(res) << \" \" << -get<1>(res) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct Pair {\n\tint first, second;\n\tPair(int f, int s) { first = f; second = s; }\n\tPair() {}\n\tbool operator < (const Pair &r) const { return (first != r.first) ? first < r.first : second < r.second; }\n};\n\nint n;\nint p[100];\nPair dp[101][50001];\t//dp[i][j] = ?????????0???i-1?????????????????????????????????, ???1???100?????????????¨?j????????£????????????????????¨??????500?????????-dp[i][j].first?????????????????£????????£????????????dp[i][j].second[???]??§?????????\n\nvoid update(int id, int sogaku) {\n\tint mod1000 = p[id] % 1000;\n\tint mod500 = p[id] % 500;\n\t\t\n\t//1000?????§?????? (????????¨?°????????¢???????)\n\tif (mod1000 > 0) {\n\t\tint sogaku2 = (mod500 == 0) ? sogaku : sogaku + 500 - mod500;\n\t\tdp[id + 1][sogaku2] = min(dp[id + 1][sogaku2], Pair(dp[id][sogaku].first - (mod1000 <= 500), dp[id][sogaku].second + p[id]));\n\t}\n\t\n\tif (mod1000 == 0 || mod1000 >= 500) {\n\t\t//?????£???500??????????¢??????? (????????¨?°?????????????)\n\t\tif ((mod1000 > 0 && mod500 <= sogaku) || (mod1000 == 0 && sogaku >= 500)) {\n\t\t\tdp[id + 1][sogaku - mod500] = min(dp[id + 1][sogaku - mod500], Pair(dp[id][sogaku].first - 1, dp[id][sogaku].second + p[id]));\n\t\t}\n\t}\n\t\n\t//????????????\n\tdp[id + 1][sogaku] = min(dp[id + 1][sogaku], dp[id][sogaku]);\n}\n\nint main() {\n\twhile (cin >> n) {\n\t\tint i, j;\n\t\t\n\t\tif (!n) break;\n\t\tfor (i = 0; i < n; i++) cin >> p[i];\n\t\t\n\t\tfor (i = 0; i <= n; i++) for (j = 0; j < 500 * n; j++) dp[i][j] = Pair(1, 114514);\t//Be careful!!\n\t\tdp[0][0] = Pair(0, 0);\n\t\t\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < 500 * n; j++) {\n\t\t\t\tif (dp[i][j].first > 0) continue;\t//Be careful!!\n\t\t\t\tupdate(i, j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tPair ans = Pair(0, 0);\t//Be careful!!\n\t\tfor (j = 0; j < 500 * n; j++) {\n\t\t\tans = min(ans, dp[n][j]);\n\t\t}\n\t\tcout << -ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  const int CMAX = 2000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 1000... really?\n    // # of 500 got so far : at most 100\n    // value : minimum payment\n    vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(CMAX+1, vector<int>(101, BIG)));\n    dp[0][0][0] = 0;\n    for(int i = 0; i < n; i++) {\n      const int ii = i + 1;\n      for(int j = 0; j <= CMAX; j++) { // not buying\n        for(int k = 0; k <= 100; k++) {\n          dp[ii][j][k] = dp[i][j][k];\n        }\n      }\n      // buying\n      const int p = ps[i] % 1000;\n      if(p != 0 && p <= 500) { // got 500!\n        for(int j = 0; j <= CMAX; j++) {\n          const int jj = min(j + 500 - p, 999);\n          for(int k = 0; k < 100; k++) {\n            const int kk = k + 1;\n            dp[ii][jj][kk] = min(dp[ii][jj][kk], dp[i][j][k] + ps[i]);\n          }\n        }\n      } else {\n        // get 500 if possible!\n        const int q = (p == 0 ? 1000 : p) - 500;\n        for(int j = 0; j <= CMAX; j++) {\n          if(j >= q) {\n            const int jj = j - q;\n            for(int k = 0; k < 100; k++) {\n              const int kk = k + 1;\n              dp[ii][jj][kk] = min(dp[ii][jj][kk], dp[i][j][k] + ps[i]);\n            }\n          } else { // get change\n            const int jj = j + 1000 - p;\n            if( jj < 1000) {\n              for(int k = 0; k <= 100; k++) {\n                const int kk = k;\n                dp[ii][jj][kk] = min(dp[ii][jj][kk], dp[i][j][k] + ps[i]);\n              }\n            }\n          }\n        }\n      }\n    }\n    for(int k = 100; k >= 0; k--) {\n      int p = BIG;\n      for(int j = 0; j <= CMAX; j++) {\n        p = min(p, dp[n][j][k]);\n      }\n      if(p != BIG) {\n        cout << k << \" \" << p << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint n;\nint dp[101][540005];\n//bool me[101][540005]={0};\nsigned main(){\n\tint u=10000000;\n\twhile(1){\n\tcin>>n;\n\t\tif(n==0) break;\n\t\tint zx=-9000000;\n\t\tfor(int i=0;i<=100;i++)for(int j=0;j<540005;j++){\n\t\t\tdp[i][j]=zx;\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tdp[0][0]=0;\n\t\t\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint p,pq;\n\t\t\tcin>>p;\n\t\t\tpq=p;\n\t\t\tp%=1000;\n\t\t\t\n\t\t\tif(p==0) p+=1000;\n\t\t\tfor(int j=0;j<540005;j++){\n\t\t\t\tif(dp[i-1][j]==zx) continue;\n\t\t\t\n\t\t\t\tif(dp[i][j]<dp[i-1][j]) dp[i][j]=dp[i-1][j];\n\t\t\t\tif(p>500){\n\t//\t\t\t\tme[i][j+(1000-p)]=1;\n\t\t\t\t\tif(dp[i][j+(1000-p)]<dp[i-1][j]-pq) dp[i][j+(1000-p)]=dp[i-1][j]-pq;\n\t\t\t\t}\n\t\t\t\telse{\n\t//\t\t\t\tme[i][j+(1000-p-500)]=1;\n\t\t\t\t\tif(dp[i][j+(500-p)]<dp[i-1][j]+u-pq) dp[i][j+(500-p)]=dp[i-1][j]+u-pq;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(p>500){\n\t\t\t\t\tif(j>=p+500-1000){\n\t//\t\t\t\t\tme[i][j-(p-500)]=1;\n\t\t\t\t\t\tif(dp[i][j-(p-500)]<dp[i-1][j]+u-pq) dp[i][j-(p-500)]=dp[i-1][j]+u-pq;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(j>=p+500){\n\t//\t\t\t\t\tme[i][j-(p+500)]=1;\n\t\t\t\t\t\tif(dp[i][j-(p+500)]<dp[i-1][j]+u-pq) dp[i][j-(p+500)]=dp[i-1][j]+u-pq;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=zx;\n\t\tfor(int j=0;j<540005;j++){\n\t\t\tif(dp[n][j]==zx) continue;\n\t\t\tif(dp[n][j]>ans)ans=dp[n][j];\n\t\t}\n\t\n\t\t\n\t\tcout<<ans/u +1<<\" \"<<u-ans%u<<endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 100000000\n#define OTU 5000\nint d[101][OTU][2],oturi,otusum;\n\nbool otu(int p){\n    int j=0;\n    while(p>=10000)p-=10000;\n    while(p>=1000)p-=1000;\n    while(p>=500){\n        p-=500;\n        j++;\n    }\n    oturi=500-p;\n    \n    if(!p)return j%2+1;\n    return j%2;\n}\nint main()\n{\n    \n   while(1){\n        int n,p[102];\n        cin>>n;\n        if(!n)return 0;\n       for(int i=0;i<n;i++){\n           cin>>p[i+1];\n       }\n       otusum=1;\n       for(int sum=0;sum<101;sum++)\n           for(int j=0;j<OTU;j++){\n            d[sum][j][0]=INF;\n            d[sum][j][1]=INF;\n       }\n        d[0][0][0]=0;    \n       for(int i=1;i<=n;i++){\n           otusum+=500;\n           otusum=min(otusum,OTU);\n           if(p[i]%1000==0){\n               for(int j=0;j<otusum-500;j++){\n                   d[0][j][i%2]=d[0][j][(i-1)%2];\n                   for(int sum=1;sum<=i;sum++)\n                       d[sum][j][i%2]=min(d[sum][j][(i-1)%2],d[sum-1][j+500][(i-1)%2]+p[i]);\n               }\n               for(int j=otusum-500;j<otusum;j++)\n                   for(int sum=0;sum<=i;sum++)d[sum][j][i%2]=d[sum][j][(i-1)%2];\n           continue;\n           }\n            if(otu(p[i])){\n                for(int j=0;j<oturi;j++){\n                    d[0][j][i%2]=d[0][j][(i-1)%2];\n                    for(int sum=1;sum<=i;sum++)\n                    d[sum][j][i%2]=min(d[sum-1][j+500-oturi][(i-1)%2]+p[i],d[sum][j][(i-1)%2]);\n                }\n                for(int j=oturi;j<otusum-500+oturi;j++){\n                    d[0][j][i%2]=min(d[0][j][(i-1)%2],d[0][j-oturi][(i-1)%2]+p[i]);\n                    for(int sum=1;sum<=i;sum++)\n                    d[sum][j][i%2]=min(d[sum][j-oturi][(i-1)%2]+p[i],min(d[sum-1][j+500-oturi][(i-1)%2]+p[i],d[sum][j][(i-1)%2]));\n                }\n                for(int j=otusum-500+oturi;j<otusum;j++){\n                    d[0][j][i%2]=min(d[0][j][(i-1)%2],d[0][j-oturi][(i-1)%2]+p[i]);\n                    for(int sum=1;sum<=i;sum++)\n                    d[sum][j][i%2]=min(d[sum][j-oturi][(i-1)%2]+p[i],d[sum][j][(i-1)%2]);\n                }\n            }\n           else{\n               for(int j=0;j<oturi;j++){\n                    d[0][j][i%2]=d[0][j][(i-1)%2];\n                    for(int sum=1;sum<=i;sum++)\n                    d[sum][j][i%2]=d[sum][j][(i-1)%2];\n                }\n                for(int j=oturi;j<otusum;j++){\n                    d[0][j][i%2]=d[0][j][(i-1)%2];\n                    for(int sum=1;sum<=i;sum++)\n                    d[sum][j][i%2]=min(d[sum-1][j-oturi][(i-1)%2]+p[i],d[sum-1][j][(i-1)%2]+p[i]);\n                }\n            }\n          // int ans=INF;\n       //for(int sum=100;sum>=0;sum--){\n         //  for(int j=0;j<1000;j++){\n           // ans=min(d[sum][j][i%2],ans);\n             //  if(d[sum][j][i%2]<INF)\n               //cout<<\"i \"<<i<<\" sum \"<<sum<<\" ans \"<<ans<<\" oturi \"<<j<<endl;\n           //}\n           //if(ans<INF){\n             //  cout<<\"I　 \"<<i<<\" sum \"<<sum<<\" ans \"<<ans<<endl;\n               //break;\n         //  }\n       //}\n       \n       }\n       int ans=INF;\n       for(int sum=100;sum>=0;sum--){\n           for(int j=0;j<OTU;j++){\n            ans=min(d[sum][j][n%2],ans);\n           }\n           if(ans<INF){\n               cout<<sum<<\" \"<<ans<<endl;\n               break;\n           }\n       }  \n       \n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nint p[111];\nint dp[111][111][1111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    rep(i,n)cin>>p[i];\n    rep(i,111)rep(j,111)rep(k,1111)dp[i][j][k]=INF;\n    dp[0][0][0]=0;\n    rep(i,n)rep(j,111)rep(k,511){\n      if(dp[i][j][k]==INF)continue;\n      int rest1=(k+1000000-p[i])%1000;\n      int rest2=(1000000-p[i])%1000;\n      minch(dp[i+1][j+rest1/500][rest1%500],dp[i][j][k]+p[i]);\n      minch(dp[i+1][j+rest2/500][rest2%500+k],dp[i][j][k]+p[i]);\n      minch(dp[i+1][j][k],dp[i][j][k]);\n    }\n    int resa=0,resb=INF;\n    rep(j,111)rep(k,1111){\n      if(dp[n][j][k]!=INF&&resa<j){\n        resa=j;\n        resb=dp[n][j][k];\n      }else if(resa==j)minch(resb,dp[n][j][k]);\n    }\n    printf(\"%d %d\\n\", resa,resb);\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nint n;\nint a[100];\npair<int, int> dp[110][500];\n\nint main(){\n  while (cin >> n, n){\n    rep(i, n) cin >> a[i];\n    rep(i, 110) rep(j, 500) dp[i][j] = {-inf, 0};\n    dp[0][0] = {0, 0};\n    rep(i, n) rep(j, 500){\n      int x = j;\n      while (x < a[i]) x += 1000;\n      x -= a[i];\n      chmax(dp[i + 1][j], dp[i][j]);\n      chmax(dp[i + 1][x % 500], make_pair(dp[i][j].first + (x >= 500), dp[i][j].second - a[i]));\n    }\n    pair<int, int> res = {-1, -1};\n    rep(i, 500) chmax(res, dp[n][i]);\n    cout << res.first << \" \" << -res.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\n#define REP(i, n) for (int i = 0; i < (n); i ++)\n\nusing namespace std;\n\nvoid chmax(int& x, int y) { if (x < y) x = y; }\nvoid chmin(int& x, int y) { if (x > y) x = y; }\n\nint main() {\n    while(true)  {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<int> p(n);\n        REP(i, n) cin >> p[i];\n        // dp[store][500][spend1000]\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(n + 1, vector<int>(601, -1)));\n        dp[0][0][0] = 0;\n        int maxcoin = 0;\n        REP(pi, n) {\n            int price = p[pi];\n            int oturi = 1000 - (price % 1000);\n            int us = (price - 1) / 1000 + 1;\n            if (oturi == 1000) oturi = 0;\n            //cout << \"pi: \" << pi <<  \" price: \"<< price << \" Use: \" << us << \" Oturi:\" << oturi << endl;\n            REP(i5, n) {\n                REP(s, 600) {\n                    int hav = dp[pi][i5][s];\n                    if (hav == -1) continue;\n                    //cout << \"i5: \" << i5 << \" s: \" << s << \" hav : \" << hav << endl;\n                    chmax(dp[pi + 1][i5][s], hav); // 買わない\n                    if (oturi >= 500) {\n                        //cout <<\"MUST\" << endl;\n                        chmax(dp[pi + 1][i5 + 1][s + us], hav + oturi - 500);\n                        chmax(maxcoin, i5 + 1);\n                    }else{\n                        chmax(dp[pi + 1][i5][s + us], hav + oturi); //買う\n                        if (500 - oturi <= hav) {\n                            //cout <<\"MORE BUY\" << endl;\n                            chmax(dp[pi + 1][i5 + 1][s + us], hav - (500 - oturi)); //余計に出して買う\n                            chmax(maxcoin, i5 + 1);\n                        }\n                    }\n                }\n            }\n        }\n        int used = 100000000;\n\n        cout << maxcoin << \" \";\n        REP(i, 601) {\n            int hav = dp[n][maxcoin][i];\n            if (hav != -1) {\n                //cout << \"S: \" << i <<  \" - \" << hav << endl;\n                chmin(used, 1000 * i - hav - maxcoin * 500);\n            }\n        }\n        cout << used << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nP dp[105][50005];\nint p[100];\nvoid Max(P &a,P b){a=max(a,b);}\n\nint main(){\n  int n;\n  while(cin>>n && n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++)cin>>p[i];\n    dp[0][0] = P(0,0);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<50000;j++){\n        if(dp[i][j]==P(-1,-1)) continue;\n        int nf=dp[i][j].first,ns=dp[i][j].second-p[i];\n        Max(dp[i+1][j],dp[i][j]);\n        if(p[i]%1000==0)\n          {if(j>=500) Max(dp[i+1][j-500],P(nf+1,ns-p[i]));}\n        else if(p[i]%1000<500) Max(dp[i+1][j+500-p[i]%500],P(nf+1,ns));\n        else if(p[i]%500<=j) Max(dp[i+1][j-p[i]%500],P(nf+1,ns));\n        else Max(dp[i+1][j+1000-p[i]%1000],P(nf,ns)); \n      }\n    }\n    P ans(0,0);\n    for(int i=0;i<50000;i++) ans=max(ans,dp[n][i]);\n    cout<<ans.first<<\" \"<<-ans.second<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n\n    while (scanf(\"%d\", &n) && n){\n        int a[128];\n        pair<int, int> dp[128][50 * 500];\n\n        for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n\n        for (int i = 0; i <= n; i++){\n            for (int j = 0; j < 50 * 500; j++){\n                dp[i][j] = make_pair(0, -1001001001);\n            }\n        }\n\n        dp[0][0] = make_pair(0, 0);\n        for (int i = 1; i <= n; i++){\n            for (int j = 0; j < min(i, 50) * 500; j++){\n                if (dp[i - 1][j].second != -1001001001){\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j]);\n                    int r = (1000 - a[i] % 1000) % 1000;\n                    if (j + r >= 500){\n                        pair<int, int> nxt = make_pair(dp[i - 1][j].first + 1, dp[i - 1][j].second - a[i]);\n                        dp[i][j + r - 500] = max(dp[i][r % 500], nxt);\n                    }\n                    else {\n                        dp[i][j + r] = max(dp[i][j + r], make_pair(dp[i - 1][j].first, dp[i - 1][j].second - a[i]));\n                    }\n                }\n            }\n        }\n\n        pair<int, int> ans = *max_element(dp[n], dp[n] + 500);\n        printf(\"%d %d\\n\", ans.first, -ans.second);\n    }\n    \n    return (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\n#define IINF INT_MAX\n#define MAX 110\nint n,p[MAX],dp[MAX][210][10010];\n\nint main() {\n  while( cin >> n, n ) {\n    rep(i,n) cin >> p[i];\n    rep(k,MAX) rep(i,210) rep(j,10010) dp[k][i][j] = IINF;\n    dp[0][0][0] = 0;\n    rep(i,n) {\n      rep(j,210) {\n\trep(k,10010) {\n\t  if( dp[i][j][k] == IINF ) continue;\n\t  // use\n\t  //cout << \"dp[\" << i << \"][\" << j << \"][\" << k << \"] = \" << dp[i][j][k] << endl;\n\t  int rem = ( 1000 - p[i] % 1000 ) + k;\n\t  if( p[i] % 1000 == 0 ) rem = k;\n\t  \n\t  if( rem >= 500 ) {\n\t    dp[i+1][j+1][rem-500] = min(dp[i+1][j+1][rem-500],\n\t\t\t\t\tdp[i][j][k]+p[i]);\n\t  } else {\n\t    dp[i+1][j][rem] = min(dp[i+1][j][rem],dp[i][j][k]+p[i]);\n\t  }\n\t  // dont use\n\t  dp[i+1][j][k] = min(dp[i+1][j][k],dp[i][j][k]);\n\t}\n      }\n    }\n    for(int i=209;i>=0;--i) {\n      int mini = IINF;\n      rep(j,500) {\n\tif( dp[n][i][j] != IINF ) {\n\t  mini = min(mini,dp[n][i][j]);\n\t}\n      }\n      if( mini != IINF ) {\n\tcout << i << \" \" << mini << endl;\n\tgoto Skip;\n      }\n    }\n    puts(\"0 0\");\n  Skip:;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 2\n#define MAX_C 15001\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nint m[MAX_N];\npii dp[MAX_N][MAX_C];\n\nvoid set_m(vector<int> &p)\n{\n    for (int i = 0; i < (int)p.size(); i++) {    \n        m[i] = ((p[i] - 1) / 1000 + 1) * 1000;\n    }\n}\n\nvoid update(pii &a, pii &b)\n{\n    if (a.first < b.first) {\n        a = b;\n    } else if (a.first == b.first) {\n        if (a.second > b.second) {\n            a = b;\n        }\n    }\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<int> p(N);\n        for (int i = 0; i < N; i++) {\n            cin >> p[i];\n        }\n        \n        set_m(p);\n        \n        memset(dp, -1, sizeof(dp));\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < MAX_C; j++) {\n                dp[i][j] = pii(-1, INF);\n            }\n        }\n        \n        dp[0][0] = pii(0, 0);\n        for (int i = 0; i < N; i++) {\n            int curr = (i & 1), next = !(i & 1);\n            for (int j = 0; j < MAX_C; j++) {\n                if (dp[curr][j].first == -1) continue;\n                \n                update(dp[next][j], dp[curr][j]);\n                \n                for (int k = 0; k <= min(j, 999); k++) {\n                    int pay = m[i] + k;\n                    int change = pay - p[i];                    \n                    int _500 = change / 500;\n                    \n                    if (change < 0 || change >= 1000) continue;                    \n                    \n                    int nc = j - k + change - _500 * 500;\n                    if (nc >= MAX_C) continue;\n                    \n                    pii ncost = pii(dp[curr][j].first + _500,\n                                    dp[curr][j].second + p[i]);                    \n                    \n                    update(dp[next][nc], ncost);\n                }\n            }\n            for (int j = 0; j < MAX_C; j++) {\n                dp[curr][j] = pii(-1, INF);\n            }\n        }\n        \n        pii res = pii(-1, INF);\n        for (int i = 0; i < MAX_C; i++) {\n            update(res, dp[N&1][i]);\n        }\n        cout << res.first << \" \" << res.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<complex>\n#include<string>\n#include<cstring>\n\nusing namespace std;\n#define rep2(x,from,to) for(long long x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n#define INF 10000000000000\n#define all(x) x.begin(),x.end()\ntypedef pair<long long,long long> P;\ntypedef pair<long long,P> PP;\nlong long n;\nlong long ans_yen;\nlong long ans_five;\nlong long p[105];\nlong long pp[105];\nlong long dp[105][1000][105];\nint main()\n{\n\twhile(1)\n\t{\n\t\tans_yen=INF;\n\t\tans_five=0;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\trep(i,n)\n\t\t{\n\t\t\tcin>>p[i];\n\t\t\tpp[i]=p[i];\n\t\t\tp[i]%=1000;\n\t\t}\n\t\trep(i,105)rep(j,1000)rep(k,105)dp[i][j][k]=INF;\n\t\tdp[0][0][0]=0;\n\t\trep(i,n)\n\t\t{\n\t\t\trep(j,1000)\n\t\t\t{\n\t\t\t\trep(k,n)\n\t\t\t\t{\n\t\t\t\t\tif(dp[i][j][k]==INF)continue;\n\t\t\t\t\tdp[i+1][j][k]=min(dp[i][j][k],dp[i+1][j][k]);\n\t\t\t\t\t/*dp[i+1][(j+1000-p[i])%1000][k]=min(dp[i][j][k]+p[i],dp[i+1][(j+1000-p[i])%1000][k]);\n\t\t\t\t\tif(j>=(p[i]+500)%1000)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+1][j-(p[i]+500)%1000][k+1]=min(dp[i+1][j-(p[i]+500)%1000][k+1],dp[i][j][k]+p[i]);\n\t\t\t\t\t}*/\n\t\t\t\t\tif(p[i]<=500&&p[i]!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+1][(j+500-p[i])%1000][k+1]=min(dp[i][j][k]+pp[i],dp[i+1][(j+1000-p[i])%1000][k+1]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+1][(j+1000-p[i])%1000][k]=min(dp[i][j][k]+pp[i],dp[i+1][(j+1000-p[i])%1000][k]);\n\t\t\t\t\tif(j>=(p[i]+500)%1000)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+1][j-(p[i]+500)%1000][k+1]=min(dp[i+1][j-(p[i]+500)%1000][k+1],dp[i][j][k]+pp[i]);\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j,1000)rep(k,n+1)\n\t\t{\n\t\t\tif(dp[n][j][k]!=INF)\n\t\t\t{\n\t\t\t\tif(ans_five<k)\n\t\t\t\t{\n\t\t\t\t\tans_yen=dp[n][j][k];\n\t\t\t\t\tans_five=k;\n\t\t\t\t}\n\t\t\t\tif(ans_five==k)\n\t\t\t\t{\n\t\t\t\t\tans_yen=min(dp[n][j][k],ans_yen);\n\t\t\t\t}\n\t\t\t\t//cout<<j<<\" \"<<k<<\" \"<<dp[n][j][k]<<endl;\n\t\t\t}\n\t\t}\n\t\trep(i,n+1)rep(j,1000)rep(k,n+1)\n\t\t{\n\t\t\tif(dp[i][j][k]!=INF)\n\t\t\t{\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<dp[i][j][k]<<endl;\n\t\t\t}\n\t\t}\n\t\tcout<<ans_five<<\" \"<<ans_yen<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n\n    while (scanf(\"%d\", &n) && n){\n        int a[128];\n        pair<int, int> dp[128][50 * 500];\n\n        for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n\n        for (int i = 0; i <= n; i++){\n            for (int j = 0; j < 50 * 500; j++){\n                dp[i][j] = make_pair(0, -1001001001);\n            }\n        }\n\n        dp[0][0] = make_pair(0, 0);\n        for (int i = 1; i <= n; i++){\n            for (int j = 0; j < min(i, 50) * 500; j++){\n                if (dp[i - 1][j].second != -1001001001){\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j]);\n                    int r = (1000 - a[i] % 1000) % 1000;\n                    if (j + r >= 500){\n                        pair<int, int> nxt = make_pair(dp[i - 1][j].first + 1, dp[i - 1][j].second - a[i]);\n                        dp[i][j + r - 500] = max(dp[i][r % 500], nxt);\n                    }\n                    else {\n                        dp[i][j + r] = max(dp[i][j + r], make_pair(dp[i - 1][j].first, dp[i - 1][j].second - a[i]));\n                    }\n                }\n            }\n        }\n\n        pair<int, int> ans = *max_element(dp[n], dp[n] + 50 * 500);\n        printf(\"%d %d\\n\", ans.first, -ans.second);\n    }\n    \n    return (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nPIP pay (int coin, P p, int price) {\n    int back = 5000 - price;\n    if (coin < price) back += coin, coin = 0;\n    p.se += price;\n    back %= 1000;\n    p.fi += back / 500;\n    return PIP(back % 500 + coin, p);\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    int n;\n    while(cin >> n, n) {\n        vector<int> p(n);\n        rep(i, n) cin >> p[i];\n\n        P dp[1000];\n        rep(i, 1000) dp[i] = P(0, INF);\n        bool check[1000];\n        dp[0] = P(0, 0);\n        rep(i, n) {\n            memset(check, 0, sizeof(check));\n            rep(j, 1000) {\n                if (dp[j] != P(0, INF) && !check[j]) {\n                    PIP tmp = pay(j, dp[j], p[i]);\n                    if (dp[tmp.fi].se == INF) dp[tmp.fi] = tmp.se, check[tmp.fi] = true;\n                    else if (dp[tmp.fi].fi < tmp.se.fi) dp[tmp.fi] = tmp.se, check[tmp.fi] = true;\n                    else if (dp[tmp.fi].fi == tmp.se.fi && dp[tmp.fi].se > tmp.se.se) dp[tmp.fi] = tmp.se, check[tmp.fi] = true;\n                }\n            }\n            PIP tmp = pay(0, P(0, 0), p[i]);\n            if (dp[tmp.fi].se == INF) dp[tmp.fi] = tmp.se;\n            else if (dp[tmp.fi].fi < tmp.se.fi) dp[tmp.fi] = tmp.se;\n            else if (dp[tmp.fi].fi == tmp.se.fi && dp[tmp.fi].se > tmp.se.se) dp[tmp.fi] = tmp.se;\n        }\n        P maxi = P(0, INF);\n        rep(i, 1000) {\n            if (maxi.se == INF) maxi = dp[i];\n            else if (maxi.fi < dp[i].fi) maxi = dp[i];\n            else if (maxi.fi == dp[i].fi && maxi.se > dp[i].se) maxi = dp[i];\n        }\n\n        cout << maxi.fi << \" \" << maxi.se << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint f[200][2010][15],n,a[200],c[200][2010][15];\nint main(){\n\tscanf(\"%d\",&n);\n\twhile(n){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tscanf(\"%d\",&a[i]);\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tfor(int j=0;j<=1000;j++)\n\t\t\t\tfor(int z=0;z<11;z++){\n\t\t\t\t\tf[i][j][z]=-100000;\n\t\t\t\t\tc[i][j][z]=0;\n\t\t\t\t}\n\t\tf[0][0][0]=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<1000;j++)\n\t\t\t\tfor(int z=0;z<11;z++)\n\t\t\t\t\tif(f[i][j][z]>=0){\n\t\t\t\t\t\tif(f[i+1][j][z]<f[i][j][z]||(f[i+1][j][z]==f[i][j][z]&&c[i+1][j][z]>c[i][j][z])){\n\t\t\t\t\t\t\tf[i+1][j][z]=f[i][j][z];\n\t\t\t\t\t\t\t//printf(\"%d %d %d\\n\",i,j,z);\n\t\t\t\t\t\t\tc[i+1][j][z]=c[i][j][z];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint k=(0-a[i])%1000+1000;\n\t\t\t\t\t\tif(k==1000)k=0;\n\t\t\t\t\t\tif(k>=500){\n\t\t\t\t\t\t\tk-=500;\n\t\t\t\t\t\t\tint jj=j+k;\n\t\t\t\t\t\t\tif(jj<1000){\n\t\t\t\t\t\t\t\tif(f[i+1][jj][z]<f[i+1][j][z]+1||(f[i+1][jj][z]==f[i][j][z]+1&&c[i+1][jj][z]>c[i][j][z]+a[i])){\n\t\t\t\t\t\t\t\t\tf[i+1][jj][z]=f[i][j][z]+1;\n\t\t\t\t\t\t\t\t\tc[i+1][jj][z]=c[i][j][z]+a[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tjj-=1000;\n\t\t\t\t\t\t\t\tif(f[i+1][jj][z+1]<f[i+1][j][z]+1||(f[i+1][jj][z+1]==f[i][j][z]+1&&c[i+1][jj][z+1]>c[i][j][z]+a[i])){\n\t\t\t\t\t\t\t\t\tf[i+1][jj][z+1]=f[i][j][z]+1;\n\t\t\t\t\t\t\t\t\tc[i+1][jj][z+1]=c[i][j][z]+a[i];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tk+=500;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j+k>=500){\n\t\t\t\t\t\t\tif(j+k<1000){\n\t\t\t\t\t\t\t\tint jj=(j+k-500);\n\t\t\t\t\t\t\t\tif(f[i+1][jj][z]<f[i+1][j][z]+1||(f[i+1][jj][z]==f[i][j][z]+1&&c[i+1][jj][z]>c[i][j][z]+a[i])){\n\t\t\t\t\t\t\t\t\tf[i+1][jj][z]=f[i][j][z]+1;\n\t\t\t\t\t\t\t\t\tc[i+1][jj][z]=c[i][j][z]+a[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else if(true){\n\t\t\t\t\t\t\t\tint jj=(j+k-1000);\n\t\t\t\t\t\t\t\tif(f[i+1][jj][z+1]<f[i+1][j][z]+1||(f[i+1][jj][z+1]==f[i][j][z]+1&&c[i+1][jj][z+1]>c[i][j][z]+a[i])){\n\t\t\t\t\t\t\t\t\tf[i+1][jj][z+1]=f[i][j][z]+1;\n\t\t\t\t\t\t\t\t\tc[i+1][jj][z+1]=c[i][j][z]+a[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(true){\n\t\t\t\t\t\t\tif(f[i+1][j+k][z]<f[i][j][z]||(f[i+1][j+k][z]==f[i][j][z]&&c[i+1][j+k][z]>c[i][j][z])){\n\t\t\t\t\t\t\t\tf[i+1][j+k][z]=f[i][j][z];\n\t\t\t\t\t\t\t\tc[i+1][j+k][z]=c[i][j][z]+a[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(z>0){\n\t\t\t\t\t\t\t\tint jj=j+k+1000;\n\t\t\t\t\t\t\t\tif(jj<1500){\n\t\t\t\t\t\t\t\t\tjj-=500;\n\t\t\t\t\t\t\t\tif(f[i+1][j+k][z-1]<f[i][j][z]+1||(f[i+1][j+k][z-1]==f[i][j][z]+1&&c[i+1][j+k][z-1]>c[i][j][z])){\n\t\t\t\t\t\t\t\t\tf[i+1][j+k][z-1]=f[i][j][z]+1;\n\t\t\t\t\t\t\t\t\tc[i+1][j+k][z-1]=c[i][j][z]+a[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//f[i+1][j+k]=max(f[i][j][z],f[i+1][j+k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\tint ans=0,co=0;\n\t\tfor(int i=0;i<1000;i++)\n\t\t\tfor(int z=0;z<11;z++)\n\t\t\t\tif(ans<f[n][i][z]||(ans==f[n][i][z]&&co>c[n][i][z])){\n\t\t\t\t\tans=f[n][i][z];\n\t\t\t\t\tco=c[n][i][z];\n\t\t\t\t}\n\t\tprintf(\"%d %d\\n\",ans,co);\n\t\t//printf(\"%d\\n\",f[4][800][0]);\n\t\t//printf(\"%d\\n\",f[3][200][1]);\n\t\tscanf(\"%d\",&n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n//int pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n \n \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n\n\n                         //----------------kokomade tenpure------------\nint n;\npair<int,int> dp[101][540005];\nbool me[101][540005]={0};\nsigned main(){\n\twhile(1){\n\tcin>>n;\n\t\tif(n==0) break;\n\t\t\n\t\tfor(int i=0;i<=100;i++)for(int j=0;j<540005;j++){\n\t\t\tdp[i][j]=mp(0,-10000000);\n\t\t\t\n\t\t\tme[i][j]=0;\n\t\t}\n\t\tme[0][0]=1;\n\t\tdp[0][0]=mp(0,0);\n\t\t\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint p,pq;\n\t\t\tcin>>p;\n\t\t\tpq=p;\n\t\t\tp%=1000;\n\t\t\t\n\t\t\tif(p==0) p+=1000;\n\t\t\tfor(int j=0;j<540005;j++){\n\t\t\t\tif(me[i-1][j]==0) continue;\n\t\t\t\tme[i][j]=1;\n\t\t\t\tif(dp[i][j]<dp[i-1][j]) dp[i][j]=dp[i-1][j];\n\t\t\t\tif(p>500){\n\t\t\t\t\tme[i][j+(1000-p)]=1;\n\t\t\t\t\tif(dp[i][j+(1000-p)]<mp(dp[i-1][j].first,dp[i-1][j].second-pq)) dp[i][j+(1000-p)]=mp(dp[i-1][j].first,dp[i-1][j].second-pq);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tme[i][j+(1000-p-500)]=1;\n\t\t\t\t\tif(dp[i][j+(500-p)]<mp(dp[i-1][j].first+1,dp[i-1][j].second-pq)) dp[i][j+(500-p)]=mp(dp[i-1][j].first+1,dp[i-1][j].second-pq);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(p>500){\n\t\t\t\t\tif(j>=p+500-1000){\n\t\t\t\t\t\tme[i][j-(p-500)]=1;\n\t\t\t\t\t\tif(dp[i][j-(p-500)]<mp(dp[i-1][j].first+1,dp[i-1][j].second-pq)) dp[i][j-(p-500)]=mp(dp[i-1][j].first+1,dp[i-1][j].second-pq);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(j>=p+500){\n\t\t\t\t\t\tme[i][j-(p+500)]=1;\n\t\t\t\t\t\tif(dp[i][j-(p+500)]<mp(dp[i-1][j].first+1,dp[i-1][j].second-pq)) dp[i][j-(p+500)]=mp(dp[i-1][j].first+1,dp[i-1][j].second-pq);\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpa ans=mp(0,-100000000);\n\t\tfor(int j=0;j<540005;j++){\n\t\t\tif(me[n][j]==0) continue;\n\t\t\tif(dp[n][j]>ans)ans=dp[n][j];\n\t\t}\n\t\n\t\t\n\t\tcout<<ans.first<<\" \"<<-ans.second<<endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF = 1e9;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nint N;\nvector<int> P;\n\nPII dp[100][50000];\n\nbool operator < (const PII &l, const PII &r)\n{\n    cerr << \"A\" << endl;\n    if (l.first == r.first) return l.second > r.second;\n    return l.first < r.first;\n}\n\n\nPII solve(int n, int x, int sum, int num)\n{\n    if (n == N) return PII(0, 0);\n    if (dp[n][x].first != -1) return dp[n][x];\n\n    PII res = PII(0, INF);\n\n    // ????????????\n    res = max(res, solve(n+1, x, sum, num));\n\n    // ?°????????????£?????????\n    {\n        int kozeni = (P[n] + 500) % 1000;\n        if (kozeni <= x) {\n            PII tmp = solve(n+1, x-kozeni, sum+P[n], num+1);\n            tmp.first++;\n            tmp.second += P[n];\n            res = max(res, tmp);\n        }\n    }\n    \n    // ?????????????????£?????????\n    {\n        int kozeni = (1000 - P[n]%1000)%1000;\n        int get = 0;\n        if (kozeni >= 500) {\n            get = 1;\n            kozeni -= 500;\n        }\n\n        PII tmp = solve(n+1, x+kozeni, sum+P[n], num+get);\n        tmp.first += get;\n        tmp.second += P[n];\n        res = max(res, tmp);\n    }\n\n    return dp[n][x] = res;\n}\n\n\nint main()\n{\n    cerr << (PII(5, 10) < PII(5, 5)) << endl;\n    while (cin >> N, N) {\n        fill(dp[0], dp[0]+100*50000, PII(-1, -1));\n        P.resize(N);\n        rep(i, N) cin >> P[i];\n\n        PII ans = solve(0, 0, 0, 0);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define SIZE 10100\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nint c[5]={100,50,10,5,1};\nconst int B = 5;\nint encode(vector<int> v){\n\tint S = 0;\n\tfor(int i=0;i<v.size();i++){\n\t\tassert(v[i]<B);\n\t\tS = S*B+v[i];\n\t}\n\treturn S;\n}\nvector<int> decode(int S){\n\tvector<int> v;\n\tint x = B*B*B*B;\n\tfor(int i=0;i<5;i++){\n\t\tv.pb(S/x);\n\t\tS %= x;\n\t\tx /= B;\n\t}\n\treturn v;\n}\nP dp[105][SIZE];\npair<int,vector<int> > charge(int x){\n\tx %= 1000;\n\tvector<int> v(5,0);\n\tint f = x/500;\n\tx -= f*500;\n\tfor(int i=0;i<5;i++){\n\t\tv[i]=x/c[i];\n\t\tx -= v[i]*c[i];\n\t}\n\t//assert(x==0);\n\treturn make_pair(f,v);\n}\n/*void dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}*/\nP dfs(int id,int V){\n\t/*cout << \"call : \" << id << endl;\n\tcout << \"vec : \";\n\tdump(vec);\n\tcout << endl;*/\n\tint tmp = V;\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tmap<int,P>::iterator it;\n\tif(dp[id][V].fi!=-1){\n\t\treturn dp[id][V];\n\t}\n\tP res = dfs(id+1,V);\n\tvector<int> vec = decode(V);\n\tint h = ((p[id]-1)/1000+1)*1000;;\n\tfor(int i=0;i<5;i++){\n\t\twhile(vec[i]>0&&h-p[id]+c[i]<1000){\n\t\t\tvec[i]--;\n\t\t\th += c[i];\n\t\t}\n\t}\n\tpair<int,vector<int> > ch = charge(h-p[id]);\n\tfor(int i=0;i<5;i++){\n\t\tvec[i] += (ch.sec)[i];\n\t\tvec[i]%=5;\n\t}\n\tP res2 = dfs(id+1,encode(vec));\n\tres2.fi += ch.fi;\n\tres2.sec -= p[id];\n\tdp[id][tmp]=max(res,res2);\n\t/*cout << \"end : \" << id << endl;\n\tcout << \"vec : \";\n\tdump();\n\tcout << \"result : \" << dp[id][vec].fi << ' ' << -dp[id][vec].sec << endl;*/\n\treturn dp[id][tmp];\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<SIZE;j++){\n\t\t\tdp[i][j]=P(-1,-1);\n\t\t}\n\t}\n\tP ans = dfs(0,0);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\ntypedef long long ll;\nusing namespace std;\n\npair<int,int> dp[2][200001];\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  while(cin>>n,n){\n    int a[201];\n    fill(a,a+201,0);\n    for(int i=0;i<n;i++){\n      cin>>a[i];\n    }\n    for(int i=0;i<=200000;i++)dp[0][i]=make_pair(-1,0);\n    dp[0][0]=make_pair(0,0);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<=200000;j++)dp[(i+1)&1][j]=make_pair(-1,0);\n      for(int j=0;j<=200000;j++){\n        if(dp[i&1][j].fi==-1)continue;\n        int tmp=a[i]%1000;\n        if(tmp<=500 && tmp>=1)\n          dp[(i+1)&1][j+500-tmp]=max(make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i]),dp[(i+1)&1][j+500-tmp]);\n        else{\n          int pay=(tmp+500)%1000;\n          dp[(i+1)&1][j]=max(dp[(i+1)&1][j],dp[i&1][j]);\n          if(pay<=j)\n            dp[(i+1)&1][j-pay]=max(make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i]),dp[(i+1)&1][j-pay]);\n          int pay2=(1000-tmp)%1000;\n          dp[(i+1)&1][j+pay2]=max(make_pair(dp[i&1][j].fi,dp[i&1][j].se-a[i]),dp[(i+1)&1][j+pay2]);\n        }\n      }\n    }\n    pair<int,int> ans=make_pair(0,0);\n    for(int i=0;i<=200000;i++){\n      ans=max(ans,dp[n&1][i]);\n    }\n    cout<<ans.fi<<\" \"<<-ans.se<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing ll = long long;\n\nusing namespace std;\n\n#define MAX 50100\n\nusing P = pair<int, int>;\n#define fi first\n#define se second\n\n#define amax(a, b) (a = (a < b ? b : a))\n\n#define INF 1000000\n\nint main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        int p[n]; for (auto &pi:p) {\n            cin >> pi;\n        }\n        P dp[n+1][MAX];\n        fill(dp[0], dp[n+1], P{-INF, -INF});\n        dp[0][0] = P{0, 0};\n        for (int i=0; i<n; i++) {\n            for (int j=0; j<MAX; j++) {\n                amax(dp[i+1][j], dp[i][j]);\n                if (j >= (p[i] + 500) % 1000)\n                    amax(dp[i+1][j - ((p[i] + 500) % 1000)], P(dp[i][j].fi + 1, dp[i][j].se - p[i]));\n                int change = 1000 - ((p[i] - 1) % 1000 + 1);\n                if (j + change % 500 <= MAX)\n                    amax(dp[i+1][j + change % 500], P(dp[i][j].fi + change / 500, dp[i][j].se - p[i]));\n                // if (j % 100 == 0 && j < 1000)\n                //     cerr << i << ' ' << j << ' ' << dp[i][j].fi << ' ' << dp[i][j].se << ' ' << (p[i] + 500) % 1000 << '\\n';\n            }\n        }\n        P ans = {0, -INF};\n        for (auto &di:dp[n]) amax(ans, di);\n        cout << ans.fi << ' ' << -ans.se << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    vector<int> ps(n);\n    for(int i=0;i<n;i++) cin>>ps[i];\n\n    const int MAX = 600;\n    const int INF = 1e9;\n    vector< vector<int> > dp(n+1,vector<int>(MAX,INF));\n    dp[0][0]=0;\n    for(int p:ps){\n      int q=p%1000;\n      for(int i=n-1;i>=0;i--){\n        for(int j=MAX-1;j>=0;j--){\n          if(dp[i][j]==INF) continue;\n          int coin=j*1000-dp[i][j]-i*500;\n          assert(coin>=0);\n\n          int k=(p+999)/1000;\n\n          // get 500 yen\n          if((q==0&&500<=coin)||(0<q&&q<=500)||(500<q&&q%500<=coin))\n            chmin(dp[i+1][j+k],dp[i][j]+p);\n\n          // no 500 yen\n          chmin(dp[i][j+k],dp[i][j]+p);\n        }\n      }\n    }\n\n    for(int i=n;i>=0;i--){\n      int res=INF;\n      for(int j=0;j<MAX;j++)\n        chmin(res,dp[i][j]);\n      if(res==INF) continue;\n      cout<<i<<\" \"<<res<<endl;\n      break;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF = 1e9;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nint N;\nvector<int> P;\n\nPII dp[100][50000];\nbool cmp (const PII &l, const PII &r)\n{\n    if (l.first == r.first) return l.second > r.second;\n    return l.first < r.first;\n}\n\n\nPII solve(int n, int x, int sum, int num)\n{\n    if (n == N) return PII(0, 0);\n    if (dp[n][x].first != -1) return dp[n][x];\n\n    PII res = PII(0, INF);\n\n    // ????????????\n    res = max(res, solve(n+1, x, sum, num), cmp);\n\n    // ?°????????????£?????????\n    {\n        int kozeni = (P[n] + 500) % 1000;\n        if (kozeni <= x) {\n            PII tmp = solve(n+1, x-kozeni, sum+P[n], num+1);\n            tmp.first++;\n            tmp.second += P[n];\n            res = max(res, tmp, cmp);\n        }\n    }\n    \n    // ?????????????????£?????????\n    {\n        int kozeni = (1000 - P[n]%1000)%1000;\n        int get = 0;\n        if (kozeni >= 500) {\n            get = 1;\n            kozeni -= 500;\n        }\n\n        PII tmp = solve(n+1, x+kozeni, sum+P[n], num+get);\n        tmp.first += get;\n        tmp.second += P[n];\n        res = max(res, tmp, cmp);\n    }\n\n    return dp[n][x] = res;\n}\n\n\nint main()\n{\n    while (cin >> N, N) {\n        fill(dp[0], dp[0]+100*50000, PII(-1, -1));\n        P.resize(N);\n        rep(i, N) cin >> P[i];\n\n        PII ans = solve(0, 0, 0, 0);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint dp[110][110][1010]={0};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\trep(i,110)rep(j,110)rep(k,1010)dp[i][j][k]=inf;\n\t\tdp[0][0][0]=0;\n\t\tvi a(n);\n\t\trep(i,n)cin>>a[i];\n\t\trep(i,n)rep(j,n)rep(k,1000)if(dp[i][j][k]!=inf){\n\t\t\tint I=i+1,J=j,K=k;\n\t\t\tdp[I][J][K]=min(dp[I][J][K],dp[i][j][k]);\n\t\t\tint t=1000-a[i]%1000;\n\t\t\tif(t==1000)t=0;\n\t\t\tif(t>=500)dp[I][J+1][K+t-500]=min(dp[I][J+1][K+t-500],dp[i][j][k]+a[i]);\n\t\t\telse dp[I][J][K+t]=min(dp[I][J][K+t],dp[i][j][k]+a[i]);\n\t\t\tif(a[i]%500<=K&&K)dp[I][J+1][K-a[i]%500]=min(dp[I][J+1][K-a[i]%500],dp[i][j][k]+a[i]);\n\t\t}\n\t\tint out=0,ne=inf;\n\t\trep(i,n+1)rep(j,1010)if(out<=i&&dp[n][i][j]!=inf){\n\t\t\tif(out==i)ne=min(ne,dp[n][i][j]);\n\t\t\telse ne=dp[n][i][j];\n\t\t\tout=max(out,i);\n\t\t}\n\t\tcout<<out<<\" \"<<ne<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n#define REP(i,x,n) for(int i = x; i < n; i++)\nconst int N = 1e5+10;\n \nvoid solve(int n) {\n    vector<int> a(n);\n    REP(i, 0, n) cin >> a[i];\n \n    using P = pair<int, int>;\n \n    P dp[2][N];\n    REP(i, 0, 2) REP(j, 0, N) dp[i][j] = P(-1000,0);\n    dp[0][0] = P(0,0);\n    REP(i, 0, n) {\n        int tmp = a[i] % 1000;\n        if (tmp == 0) tmp = 1000;\n        REP(j, 0, N) dp[(i+1)&1][j] = P(-1000,0);\n        REP(j, 0, 100001) {\n            if (tmp <= 500) {\n                if (j + 500 - tmp < N) dp[(i + 1) & 1][j + 500 - tmp] = max(dp[(i + 1) & 1][j + 500 - tmp], P(dp[i & 1][j].first+1,dp[i&1][j].second-a[i]));\n            }\n            else{\n                if (j - (tmp - 500) >= 0) dp[(i + 1)&1][j - (tmp - 500)] = max(dp[(i + 1)&1][j - (tmp - 500)], P(dp[i & 1][j].first + 1, dp[i & 1][j].second - a[i]));\n                if(j+1000-tmp < N) dp[(i + 1)&1][j + 1000 -tmp] = max(dp[(i + 1)&1][j + 1000 - tmp], P(dp[i & 1][j].first, dp[i & 1][j].second - a[i]));\n            }\n            dp[(i + 1) & 1][j] = max(dp[(i + 1) & 1][j], dp[i & 1][j]);\n        }\n    }\n \n    P ans = P(0,0);\n    REP(i, 0, N) ans = max(ans, dp[n&1][i]);\n \n    cout << ans.first << \" \" << -ans.second << endl;\n}\n \nint main() {\n    int n;\n    while (cin >> n, n) {\n        solve(n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define long long long\nusing pi = pair<int, int>;\n\npi dp[500][105];\npi before[500][105];\nconst int inf = 1145141919;\n\npi ch(pi a, pi b)\n{\n    if (a.second >= inf) {\n        return b;\n    }\n    else if(b.second >= inf)\n    {\n        return a;\n    }\n    \n    \n    if(a.first == b.first)\n    {\n        if(a.second < b.second) {\n            return a;\n        }\n        else{\n            return b;\n        }\n        \n    }\n    else\n    {\n        if (a.first > b.first)\n            return a;\n        else\n            return b;\n    }\n    \n}\nint main()\n{\n    while (true)\n    {\n        int N;\n        cin >> N;\n        if (N == 0)\n            return 0;\n\n        rep(i, 500) rep(j, 105)\n        {\n            dp[i][j] = pi(0, inf);\n        }\n\n        dp[0][0] = pi(0, 0);\n\n        rep(t, N)\n        {\n            int P;\n            cin >> P;\n\n            swap(dp, before);\n            rep(i, 500) rep(j, 105)\n            {\n                dp[i][j] = pi(0, inf);\n            }\n\n            int X = P % 1000;\n            \n\n            if (0 < X && X <= 500)\n            {\n                //にせ500を使わない\n                //before[i][j][k]から遷移\n\n                rep(i, 500) rep(j, 103)\n                {\n                    int k = before[i][j].first;\n                    int cost = before[i][j].second;\n                    //買わない\n                    dp[i][j] = ch(before[i][j], dp[i][j]);\n                    //買う\n                    int tsuri = (1000 - X) % 500;\n                    int next = i + tsuri;\n                    int nise = 0;\n                    if (next >= 500)\n                    {\n                        next -= 500;\n                        nise++;\n                    }\n                    dp[next][j + nise] = ch(dp[next][j + nise], pi(k + 1, cost + P));\n                }\n            }\n            else\n            {\n                //にせ500を使える\n                rep(i, 500) rep(j, 103)\n                {\n                    int k = before[i][j].first;\n                    int cost = before[i][j].second;\n                    //買わない\n                    dp[i][j] = ch(before[i][j], dp[i][j]);\n\n                    //買うけどにせ500使わない\n                    int tsuri = (1000 - X) % 500;\n                    int next = i + tsuri;\n\n                    int shin = 0;\n                    if (next >= 500)\n                    {\n                        next -= 500;\n                        shin++;\n                    }\n                    dp[next][j] = ch(dp[next][j], pi(k + shin, cost + P));\n\n                    // にせ500使う\n                    if (j > 0)\n                    {\n                        tsuri = (1500 - X) % 500;\n                        next = i + tsuri;\n\n                        int nise = 0;\n                        if (next >= 500)\n                        {\n                            next -= 500;\n                            nise++;\n                        }\n\n                        dp[next][j - 1 + nise] = ch(dp[next][j - 1 + nise], pi(k + 1, cost + P));\n                    }\n                }\n            }\n\n            // rep(i, 500) rep(j, 105) rep(k, 105)\n            // {\n            //     if(dp[i][j][k] < inf)\n            //     {\n            //         cout << t << \" \" << i << \" \" << j << \" \" << k << \" \" << dp[i][j][k] << endl;\n            //     }\n            // }\n        }\n\n        pi ans = pi(0, 0);\n        rep(i, 500)\n        {\n            rep(j, 105)\n            {\n                ans = ch(ans, dp[i][j]);\n            }\n        }\n\n        cout << ans.first << \" \" << ans.second << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 2\n#define MAX_C 100001\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nint m[MAX_N];\npii dp[MAX_N][MAX_C];\n\nvoid set_m(vector<int> &p)\n{\n    for (int i = 0; i < (int)p.size(); i++) {    \n        m[i] = ((p[i] - 1) / 1000 + 1) * 1000;\n    }\n}\n\nvoid update(pii &a, pii &b)\n{\n    if (a.first < b.first) {\n        a = b;\n    } else if (a.first == b.first) {\n        if (a.second > b.second) {\n            a = b;\n        }\n    }\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<int> p(N);\n        for (int i = 0; i < N; i++) {\n            cin >> p[i];\n        }\n        \n        set_m(p);\n        \n        memset(dp, -1, sizeof(dp));\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < MAX_C; j++) {\n                dp[i][j] = pii(-1, INF);\n            }\n        }\n        \n        dp[0][0] = pii(0, 0);\n        for (int i = 0; i < N; i++) {\n            int curr = (i & 1), next = !(i & 1);\n            for (int j = 0; j < MAX_C; j++) {\n                if (dp[curr][j].first == -1) continue;\n                \n                update(dp[next][j], dp[curr][j]);\n\n                for (int k = 0; k <= min(j, 999); k++) {\n                    int pay = m[i] + k;\n                    int change = pay - p[i];                    \n                    if (change >= 1000) continue;\n                    \n                    int _500 = (change >= 500);\n                    int nc = j - k + change - _500 * 500;                    \n\n                    if (nc >= MAX_C) continue;\n                    \n                    pii ncost = pii(dp[curr][j].first + _500,\n                                    dp[curr][j].second + p[i]);                    \n                    \n                    update(dp[next][nc], ncost);\n                }\n            }\n            \n            for (int j = 0; j < MAX_C; j++) {\n                dp[curr][j] = pii(-1, INF);\n            }\n        }\n        \n        pii res = pii(-1, INF);\n        for (int i = 0; i < MAX_C; i++) {\n            update(res, dp[N&1][i]);\n        }\n        cout << res.first << \" \" << res.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\ntypedef pair<int,int> P; //500, -totalcost\n\nP dp[101][50000];\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        fill(dp[0],dp[101],P(0,-5000000));\n        dp[0][0]=P(0,0);\n        for(int i=0;i<n;i++){\n            int price;\n            cin>>price;\n            for(int c=0;c<50000;c++){\n                if(dp[i][c].second<=-5000000) continue;\n                dp[i+1][c]=max(dp[i+1][c],dp[i][c]); //ティツイツキテ」ツつ湘」ツ?ェテ」ツ??\n                if(price%1000==0){\n                    if(c>=500){\n                        dp[i+1][c-500]=max(dp[i+1][c-500],P(dp[i][c].first+1,dp[i][c].second-price));\n                    }\n                    continue;\n                }else{\n                    if(price%1000<=500){//500テ・ツ??ァツ篠嘉」ツ?ィテ」ツ?甘ゥツ?」テ」ツつ甘」ツ?古・ツ「ツ療」ツ?暗」ツつ?\n                        int cc= c + 1000 - price%1000 - 500;\n                        dp[i+1][cc]=max(dp[i+1][cc],P(dp[i][c].first+1,dp[i][c].second-price));\n                    }else{\n                        if(price%1000-500<=c){\n                            int cc = c - (price%1000-500);\n                            //テ・ツーツ湘ゥツ環ュテ」ツつ津ヲツクツ崚」ツつ嘉」ツ?療」ツ?ヲ500テ・ツ??ァツ篠嘉」ツつ津・ツ「ツ療」ツつ?」ツ??\n                            dp[i+1][cc]=max(dp[i+1][cc],P(dp[i][c].first+1,dp[i][c].second-price));\n                        }\n                        //500テ・ツ??ァツ篠嘉」ツつ津・ツ「ツ療」ツつ?」ツ?陛」ツ?堙」ツ?ォテ・ツーツ湘ゥツ環ュテ」ツ??」ツ?妥・ツ「ツ療」ツつ?」ツ??\n                        int cc = c + (1000-price%1000);\n                        dp[i+1][cc]=max(dp[i+1][cc],P(dp[i][c].first,dp[i][c].second-price));\n                    }\n                }\n            }\n        }\n        P ans = P(0,-5000000);\n        for(int c=0;c<50000;c++) if(dp[n][c].second>-5000000) ans = max(dp[n][c],ans);\n        cout<<ans.first<<' '<<-ans.second<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// dp[i][j]: i番目の店までで100円以下の小銭の総額がjとなるような買い方の{500円玉の枚数,-購入金額}の最大値\n// 遷移は a)500円玉を得られるように買う b)1000円札のみで買って小銭を稼ぐ c)買わない\n// bでも500円玉を得られる場合がある\nint n, p[100];\npii dp[101][50050];\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\trep(i,n) cin >> p[i];\n\t\trept(i,n) rept(j,50000) dp[i][j] = {-1,0};\n\t\tdp[0][0] = {0,0};\n\t\trep(i,n) rept(j,50000) if (dp[i][j].fi!=-1) {\n\t\t\tint g = dp[i][j].fi, u = -dp[i][j].se;\n\t\t\t// 500円玉を得る\n\t\t\tif (j>=(p[i]+500)%1000) chmax(dp[i+1][j-(p[i]+500)%1000], mp(g+1, -(u+p[i])));\n\t\t\t// 1000円札のみ\n\t\t\tif (1<=p[i]%1000 && p[i]%1000<=500) chmax(dp[i+1][j+(500-p[i]%1000)], mp(g+1, -(u+p[i])));\n\t\t\tif (500<p[i]%1000) chmax(dp[i+1][j+(1000-p[i]%1000)], mp(g, -(u+p[i])));\n\t\t\t// 買わない\n\t\t\tchmax(dp[i+1][j], mp(g, -u));\n\t\t}\n\t\tpii res = mp(0,0);\n\t\trept(i,50000) chmax(res, dp[n][i]);\n\t\tcout << res.fi << ' ' << -res.se << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\ntypedef long long ll;\nusing namespace std;\n\npair<int,int> dp[2][200001];\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  while(cin>>n,n){\n    int a[201];\n    fill(a,a+201,0);\n    for(int i=0;i<n;i++){\n      cin>>a[i];\n    }\n    for(int i=0;i<=200000;i++)dp[0][i]=make_pair(-1,0);\n    dp[0][0]=make_pair(0,0);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<=200000;j++)dp[(i+1)&1][j]=make_pair(-1,0);\n      for(int j=0;j<=200000;j++){\n        if(dp[i&1][j].fi==-1)continue;\n        int tmp=a[i]%1000;\n        if(tmp<=500 && tmp>=1)\n          dp[(i+1)&1][j+500-tmp]=max(make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i]),dp[(i+1)&1][j+500-tmp]);\n        else{\n          int pay=(tmp+500)%1000;\n          dp[(i+1)&1][j]=max(dp[(i+1)&1][j],dp[i&1][j]);\n          if(pay<=j)\n            dp[(i+1)&1][j-pay]=max(make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i]),dp[(i+1)&1][j-pay]);\n          int pay2=(1000-tmp)%1000;\n          dp[(i+1)&1][j+pay2]=max(make_pair(dp[i&1][j].fi,dp[i&1][j].se-a[i]),dp[(i+1)&1][j+pay2]);\n        }\n      }\n    }\n    pair<int,int> ans=make_pair(0,0);\n    for(int i=0;i<=200000;i++){\n      if(dp[n&1][i]>ans){\n        ans=make_pair(dp[n&1][i].fi,dp[n&1][i].se);\n      }\n    }\n    cout<<ans.fi<<\" \"<<-ans.se<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <map>\n#include <string>\nusing namespace std;\n\nint ans_coin, ans_money;\nint const gohyaku = 0, hyaku = 1, goju = 2, ju = 3, go = 4, ichi = 5;\nint const val[6] = {500, 100, 50, 10, 5, 1};\nint n;\nvector<int> storeVal;\nint Tririri[6];\n\n// ?????£????????§?????¬??????\nvoid Turi(int oturi) {\n    //if(oturi > 999) return;\n    oturi %= 1000;\n    for(int i = 0; i < 6; i++) {\n        Tririri[i] = oturi / val[i];\n        oturi %= val[i];\n    }\n}\n\n// ??§????????????1000????????????????????????????????????????????????\nint NumCoin(int miyageVal, int use, int coinVal, int num) {\n    use -= 1000;\n    int i;\n    for(i = num ; i > 0; i--) {\n        //if((use + coinVal * i) - miyageVal < 1000)\n        if(miyageVal > use + coinVal * i) break;\n    }\n    return i;\n}\n\n// ????????£?????????\nvoid Store(int storeID, int *coinb, int pay) {\n    int coin[6];\n    for(int i=0;i<6;i++) {\n        coin[i] = coinb[i];\n    }\n    if(storeID >= n) {\n        //cout << \"AAAA\" << endl;\n        if(ans_coin == coin[0] && ans_money > pay) {\n            ans_money = pay;\n        }\n        \n        // ?±????\n        \n        return;\n    }\n    if(coin[0] + (n - storeID)  <  ans_coin){\n        //cout << storeID << \" \" << coin[0] << \" \" << ans_coin << endl;\n        if(ans_coin == coin[0] && ans_money > pay) {\n            ans_money = pay;\n        }\n        return;\n    }\n    \n    // ????????????????????????\n    Store(storeID+1, coin, pay);\n\n    // ??????????????????\n    int use = 1000 * ((storeVal[storeID] / 1000) + 1);\n\n    if(storeVal[storeID] % 1000 == 0) {\n        int size = 0;\n        for(int i = 0; i < 6; i++)\n            if(size += val[i] * coin[i] > 500) {\n                use += 500;\n                cout << use << endl;\n                break;\n            }\n    }\n    else {\n        for(int i = 1; i < 6; i++) {\n            use += NumCoin(storeVal[storeID], use, val[i], coin[i]) * val[i];\n        }\n    }\n    \n    Turi(use);\n    for(int i = 1; i < 6; i++) {\n        coin[i] -= Tririri[i];\n    }\n    \n    Turi(use - storeVal[storeID]);\n    for(int i = 0; i < 6; i++) {\n        coin[i] += Tririri[i];\n    }\n    \n    pay += storeVal[storeID];\n\n    \n    // 500????????´??°??????????????????\n    if(ans_coin < coin[0]) {\n        ans_coin = coin[0];\n        ans_money = pay;\n    }\n\n    \n\n    \n    Store(storeID+1, coin, pay);\n}\n\n\nint main() {\n\t\n\twhile(true) {\n        n = 0;\n        cin >> n;\n        if(n == 0) break;\n        \n        storeVal.clear();\n        for(int i = 0; i < n; i++) {\n            int a;\n            cin >> a;\n            storeVal.push_back(a);\n        }\n        ans_coin = 0;\n        ans_money = 10000000;\n        int coin[6] = {0};\n        \n        Store(0, coin, 0);\n        \n        cout << ans_coin << \" \" << ans_money << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\nusing namespace std;\n#define int long long\nint dp[51][1000];\nint ndp[51][1000];\nint INF = (int)1 << 60;\nsigned main() {\n\n\twhile (true) {\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tvector<int>p(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tfor (int i = 0; i < 51; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t\tndp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = 0;\n\t\tndp[0][0] = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint p0 = p[i] % 1000;\n\t\t\tfor (int j = 0; j < 50; j++) {\n\t\t\t\tfor (int k = 0; k < 1000; k++) {\n\t\t\t\t\tif (p0 <= k) {\n\t\t\t\t\t\tif (p0 + 500 <= k) {\n\t\t\t\t\t\t\tndp[j + 1][k - p0 - 500] = min(ndp[j + 1][k - p0 - 500], dp[j][k] + p[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tndp[j][k - p0] = min(ndp[j][k - p0], dp[j][k] + p[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (0 < p0 && p0 <= 500) {\n\t\t\t\t\t\tif (k + 500 - p0 < 1000) {\n\t\t\t\t\t\t\tndp[j + 1][k + 500 - p0] = min(ndp[j + 1][k + 500 - p0], dp[j][k] + p[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (k + 1000 - p0 < 1000) {\n\t\t\t\t\t\t\tndp[j][k + 1000 - p0] = min(ndp[j][k + 1000 - p0], dp[j][k] + p[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (1000 + k - p0 >= 500 && 1000 + k - p0 < 1000) {\n\t\t\t\t\t\tif (k + 500 - p0 < 1000) {\n\t\t\t\t\t\t\tndp[j + 1][k + 500 - p0] = min(ndp[j + 1][k + 500 - p0], dp[j][k] + p[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (1000 + k - p0 < 500) {\n\t\t\t\t\t\tif (k + 1000 - p0 < 1000) {\n\t\t\t\t\t\t\tndp[j][k + 1000 - p0] = min(ndp[j][k + 1000 - p0], dp[j][k] + p[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < 51; j++) {\n\t\t\t\tfor (int k = 0; k < 1000; k++) {\n\t\t\t\t\tdp[j][k] = ndp[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mn = INF;\n\t\tbool f = false;\n\t\tfor (int i = 50; i >= 0; i--) {\n\t\t\tmn = INF;\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tmn = min(mn, dp[i][j]);\n\t\t\t}\n\t\t\tif (mn < INF) {\n\t\t\t\tcout << i << \" \" << mn << endl;\n\t\t\t\tf = true;\n\t\t\t}\n\t\t\tif (f)break;\n\t\t}\n\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  const int CMAX = 50000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 49900... too much?\n    // # of 500 got so far : at most 100\n    // value : minimum payment\n    \n    vector<vector<int>> dp(CMAX+1, vector<int>(101, BIG));\n    vector<vector<int>> dpnew(CMAX+1, vector<int>(101, BIG));\n    dpnew[0][0] = 0;\n    int cmax = 0;\n    for(int i = 0; i < n; i++) {\n      const int ii = i + 1;\n      for(int j = 0; j <= cmax; j++) { // not buying\n        for(int k = 0; k <= i; k++) {\n          dp[j][k] = dpnew[j][k];\n        }\n      }\n      // buying\n      const int p = ps[i] % 1000;\n      if(p != 0 && p <= 500) { // got 500!\n        for(int j = 0; j <= cmax; j++) {\n          const int jj = min(j + 500 - p, CMAX);\n          cmax = max(cmax, jj);\n          for(int k = 0; k <= i; k++) {\n            const int kk = k + 1;\n            dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n          }\n        }\n      } else {\n        // get 500 if possible!\n        const int q = (p == 0 ? 1000 : p) - 500;\n        for(int j = 0; j <= cmax; j++) {\n          if(j >= q) {\n            const int jj = j - q;\n            for(int k = 0; k <= i; k++) {\n              const int kk = k + 1;\n              dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n            }\n          } else { // get change\n            const int jj = j + 1000 - p;\n            cmax = max(cmax, jj);\n            if( jj < 1000) {\n              for(int k = 0; k <= i; k++) {\n                const int kk = k;\n                dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n              }\n            }\n          }\n        }\n      }\n    }\n    for(int k = 100; k >= 0; k--) {\n      int p = BIG;\n      for(int j = 0; j <= cmax; j++) {\n        p = min(p, dpnew[j][k]);\n      }\n      if(p != BIG) {\n        cout << k << \" \" << p << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define M 50000\n\nint dp[2][101][M];\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int p[100],pp[100];\n    for(int i=0;i<n;i++)cin>>p[i],pp[i]=(1000-p[i]%1000)%1000;\n\n    for(int i=0;i<2;i++)\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<M;k++)dp[i][j][k]=1e9;\n    \n    dp[0][0][0]=0;\n\n    for(int i=0;i<n;i++){\n      int ni=(i+1)%2,I=i%2;\n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<M*(i+1)/n;k++)dp[ni][j][k]=1e9;\n      \n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<M*(i+1)/n;k++){\n\t  int np=k+pp[i];\n\t  int nj=j;\n\t  if(np>=500)nj++,np-=500;\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t  dp[ni][j][k]=min(dp[ni][j][k],dp[I][j][k]);\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t}\n    }\n    \n    int c=0,s=0;\n    for(int i=1;i<=n;i++)\n      for(int j=0;j<M;j++)\n\tif(dp[n%2][i][j]!=1e9&&i>=c){\n\t  if(c==i&&dp[n%2][i][j]<s)s=dp[n%2][i][j];\n\t  else if(c<i)c=i,s=dp[n%2][i][j];\n\t}\n    cout<<c<<\" \"<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nP dp[101][50001];\n\nvoid Max(P &a,P b){a=max(a,b);}\n\nint main(){\n  int n,p[101];\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>p[i];\n  \n    memset(dp,-1,sizeof(dp));\n    dp[0][0]=P(0,0);\n  \n    for(int i=0;i<n;i++)\n      for(int j=0;j<50000;j++){\n\tif(dp[i][j]==P(-1,-1))continue;\n\tint coin=dp[i][j].first;\n\tint cost=-dp[i][j].second;\n\tMax(dp[i+1][j],dp[i][j]);\n\tif(p[i]%1000<=500&&p[i]%1000)Max(dp[i+1][j+(500-p[i]%500)],P(coin+1,-(cost+p[i])));\n\tif(p[i]%1000==0&&j>=500) Max(dp[i+1][j-500],P(coin+1,-(cost+p[i])));\n\n\tif(p[i]%1000>500) {\n\t  if(j>=p[i]%500)Max(dp[i+1][j-p[i]%500],P(coin+1,-(cost+p[i])));\n\t  else Max(dp[i+1][j+(500-p[i]%500)],P(coin,-(cost+p[i])));\n\t}\n      }\n  \n  \n    P ans=P(0,0);\n    for(int i=0;i<50000;i++)Max(ans,dp[n][i]);\n    cout <<ans.first<<\" \"<<-ans.second<<endl;\n    \n  }\t\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nint c[5]={100,50,10,5,1};\nmap<vector<int>,P> dp[105];\npair<int,vector<int> > charge(int x){\n\tx %= 1000;\n\tvector<int> v(5,0);\n\tint f = x/500;\n\tx -= f*500;\n\tfor(int i=0;i<5;i++){\n\t\tv[i]=x/c[i];\n\t\tx -= v[i]*c[i];\n\t}\n\tassert(x==0);\n\treturn make_pair(f,v);\n}\nvoid dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}\nP dfs(int id,vector<int> vec){\n\t/*cout << \"call : \" << id << endl;\n\tcout << \"vec : \";\n\tdump(vec);\n\tcout << endl;*/\n\tvector<int> tmp = vec;\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tmap<vector<int>,P>::iterator it;\n\tit = dp[id].find(vec);\n\tif(it!=dp[id].end()){\n\t\treturn (it->sec);\n\t}\n\tP res = dfs(id+1,vec);\n\tint h = ((p[id]-1)/1000+1)*1000;;\n\tfor(int i=0;i<5;i++){\n\t\twhile(vec[i]>0&&h-p[id]+c[i]<1000){\n\t\t\tvec[i]--;\n\t\t\th += c[i];\n\t\t}\n\t}\n\tpair<int,vector<int> > ch = charge(h-p[id]);\n\tfor(int i=0;i<5;i++)vec[i] += (ch.sec)[i];\n\tP res2 = dfs(id+1,vec);\n\tres2.fi += ch.fi;\n\tres2.sec -= p[id];\n\tdp[id][tmp]=max(res,res2);\n\t/*cout << \"end : \" << id << endl;\n\tcout << \"vec : \";\n\tdump();\n\tcout << \"result : \" << dp[id][vec].fi << ' ' << -dp[id][vec].sec << endl;*/\n\treturn dp[id][tmp];\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<105;i++)dp[i].clear();\n\tvector<int> v;\n\tfor(int i=0;i<5;i++)v.pb(0);\n\tP ans = dfs(0,v);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 101;\nconst int M = 3010;\n\nint dp[N][M][N];\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vi a(n); for(auto& e : a) cin >> e;\n\n        rep(i, n + 1) rep(k, n + 1) rep(j, M) dp[i][j][k] = inf;\n        dp[0][0][0] = 0;\n\n        rep(i, n){\n            int org = a[i];\n            int price = org % 1000;\n            rep(k, n){\n                rep(j, M){\n                    int cur = dp[i][j][k];\n                    if(cur == inf) continue;\n\n                    if(price == 0){\n                        chmin(dp[i + 1][j][k], cur);\n                        int diff = (price + 500) % 1000;\n                        if(j - diff >= 0){\n                            chmin(dp[i + 1][j - diff][k + 1], cur + org);\n                        }\n                    }\n                    else if(price <= 500){\n                        chmin(dp[i + 1][min(M, j + 500 - price)][k + 1], cur + org);\n                    }\n                    else {\n                        chmin(dp[i + 1][j][k], cur);\n                        chmin(dp[i + 1][min(M, j + 1000 - price)][k], cur + org);\n                        int diff = (price + 500) % 1000;\n                        if(j - diff >= 0){\n                            chmin(dp[i + 1][j - diff][k + 1], cur + org);\n                        }\n                    }\n                }\n            }\n        }\n\n        pair<int, int> res(-1, -1);\n        rep(i, n + 1){\n            rep(k, n + 1){\n                rep(j, M){\n                    if(dp[i][j][k] == inf) continue;\n                    chmax(res, pair<int, int>(k, -dp[i][j][k]));\n                }\n            }\n        }\n        cout << res.first << \" \" << -res.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nconst int INF = 5000*100*3;\nconst int max_x = 102;\nconst int max_y = 25000;\n\nint dp[max_x+10][max_y+10];\n\nvoid solve(int n){\n    // init\n    for(int j=0;j<max_x+10;j++) for(int k=0;k<max_y+10;k++) dp[j][k] = INF;\n    vector<int> p(n);\n    for(int i=0;i<n;i++) cin >> p[i];\n\n    dp[0][0] = 0;\n    for(int i=0;i<n;i++){\n        const int &pi = p[i];\n        for(int x=n;x>=0;x--){\n            for(int y=max_y;y>=0;y--){\n                if(pi%1000<=500){\n                    if(pi%1000>0 && y-(500-pi%1000)>=0 && x-1>=0)\n                        dp[x][y] = min(dp[x][y],dp[x-1][y-(500-pi%1000)]+pi);\n                    if(y+(pi%1000+500)<=max_y && x-1>=0)\n                        dp[x][y] = min(dp[x][y],dp[x-1][y+(pi%1000+500)]+pi);\n                }else{\n                    if(y+(pi%1000-500) <= max_y && x-1>=0) dp[x][y] = min(dp[x][y], dp[x-1][y + (pi%1000-500)] + pi);\n                    if(y-(1000-pi%1000)>=0) dp[x][y] = min(dp[x][y], dp[x][y-(1000-pi%1000)] + pi);\n                }\n            }\n        }\n    }\n\n    for(int i=100;i>=0;i--){\n        int mn = INF;\n        for(int j=0;j<=max_y;j++){\n            if(dp[i][j] < INF){\n                mn = min(mn,dp[i][j]);\n            }\n        }\n        if(mn != INF){\n            cout << i << \" \" << mn << endl;\n            return;\n        }\n    }\n}\n\nint main(){\n    while(1){\n        int n; cin >> n;\n        if(n==0) break;\n        solve(n);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 100100100;\n\nint main(){\n\n    while(1){        \n        int n; cin >> n;\n        if(!n) break;\n        vector<int> a(n);\n        for(int i = 0; i < n; i++) cin >> a[i];\n\n        //i番目までの品物を見て、得られた500円玉がj枚で持ってる小銭がk円の時の消費金額の最小値\n        vector<vector<vector<int> > > dp(2, vector<vector<int> > (n + 1, vector<int> (500 * n + 1000, INF)));  \n        dp[0][0][0] = 0;\n        int now = 0;\n        int next = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j <= i; j++){\n                for(int k = 0; k <= 500 * n; k++){\n\n                    //買わない\n                    dp[next][j][k] = min(dp[next][j][k], dp[now][j][k]);\n\n                    //1000で割ったあまりによる場合わけ\n                    if(1 <= a[i] % 1000 && a[i] % 1000 <= 500){\n                        //1000札のみで払うのが最適\n                        //500円獲得\n                        dp[next][j + 1][(500 - a[i] % 1000) + k] = min(dp[next][j + 1][(500 - a[i] % 1000) + k], dp[now][j][k] + a[i]);\n                    }else{\n                        //1000円札のみで払う\n                        //500円玉は獲得できない\n                        dp[next][j][(1000 - a[i] % 1000) % 1000 + k] = min(dp[next][j][(1000 - a[i] % 1000) % 1000 + k], dp[now][j][k] + a[i]);\n\n                        //小銭を駆使して500円玉を獲得\n                        int need = a[i] % 1000 - 500;\n                        if(need == -500) need = 500;\n                        if(k - need >= 0) dp[next][j + 1][k - need] = min(dp[next][j + 1][k - need], dp[now][j][k] + a[i]);\n                    }\n                }\n            }\n            swap(now, next);\n        }\n\n        int ans1 = 0, ans2 = INF;\n        for(int j = 0; j <= n; j++){\n            for(int k = 0; k <= 500 * n; k++){\n                if(dp[now][j][k] != INF){\n                    if(ans1 < j || (ans1 == j && ans2 > dp[now][j][k])){\n                        ans1 = j;\n                        ans2 = dp[now][j][k];\n                    }\n                }\n            }\n        }\n\n        cout << ans1 << \" \" << ans2 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\n\npii max(pii a, pii b){\n  if(a.first > b.first){\n    return a;\n  }else if(a.first < b.first){\n    return b;\n  }else{\n    if(a.second > b.second){\n      return b;\n    }else{\n      return a;\n    }\n  }\n}\n\nint main(){\n  int n;\n  while(std::cin >> n, n){\n    pii dp[n + 1][50000];\n    vector<int> shop(n);\n    for (int i = 0; i < n; i++) std::cin >> shop[i];\n    for (int i = 0; i <= n; i++) {\n      \n      for (int j = 0; j < 50000; j++) {\n        dp[i][j] = pii(-1e9, 0);\n      }\n    }\n    dp[0][0] = pii(0, 0);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 50000; j++) {\n        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);\n        \n        int tf = dp[i][j].first;\n        int tc = dp[i][j].second;\n        int five_hundred;\n        int diff = (5000 - shop[i])%1000;\n        if(j + diff >= 500)\n          dp[i + 1][j + diff - 500] = max(dp[i + 1][j + diff - 500], pii(tf + 1, tc + shop[i]));\n        else\n          dp[i + 1][j + diff] = max(dp[i + 1][j + diff],\n                                    pii(tf, tc + shop[i]));\n      }\n    }\n    pii ans = pii(0, 0);\n    for (int i = 0; i < 50000; i++) {\n      ans = max(ans, dp[n][i]);\n    }\n    std::cout << ans.first << \" \" << ans.second << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Initialization\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) { arr = v; }\ntemplate<typename T, typename U>\nvoid fill_all(T& arr, const U& v) { for (auto& i : arr) fill_all(i, v); }\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v ) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n\nstruct edge { int to, cost; };\nostream& operator<<(ostream& os, const edge& e) {\n    os << \"(\" << e.to << \", \" << e.cost << \")\";\n    return os;\n}\n\nconst LL LINF = 1LL<<60;\nconst int IINF = 1<<30;\nconst LL MOD = 1e9+7;\n\nstruct Pair {\n    int k, cost;\n};\nbool operator<(const Pair& lhs, const Pair& rhs) {\n    if (lhs.k == rhs.k) return lhs.cost < rhs.cost;\n    return lhs.k > rhs.k;\n}\nostream& operator<<(ostream& os, const Pair& p) {\n    os << \"(\" << p.k << \", \" << p.cost << \")\";\n    return os;\n}\n\nint main()\n{\n    vector<int> ns;\n    vector<vector<int>> ps;\n\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<int> p(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> p[i];\n        }\n        ns.push_back(n);\n        ps.push_back(p);\n    }\n\n    for (int t = 0; t < ns.size(); ++t) {\n        int n = ns[t];\n        auto p = ps[t];\n\n        vector<int> q(n);\n        for (int i = 0; i < n; ++i) {\n            q[i] = ((-p[i] % 1000) + 1000) % 1000;\n        }\n\n        int sumq = accumulate(q.begin(), q.end(), 0);\n\n        auto dp = make_v<Pair>(2, sumq+1);\n        // dp[i%2][s] := (k, c)\n        //                 [0,i) までで500円がk枚, 手持ちがs 円のときの\n        //                 支払額がc. kが大きいほど, cが小さいほど良い\n        fill_all(dp, Pair{-IINF,IINF});\n        dp[0][0] = Pair{0, 0};\n\n        for (int i = 0; i < n; ++i) {\n            for (int s = 0; s <= sumq; ++s) {\n                // 買わないとき\n                chmin(dp[(i+1)&1][s], dp[i&1][s]);\n\n                // 買うとき\n                // 500円を生み出せるとき\n                if (s+q[i] >= 500) {\n                    if (s+q[i]-500 <= sumq) {\n                        auto tmp = dp[i&1][s];\n                        tmp.k += 1;\n                        tmp.cost += p[i];\n                        chmin(dp[(i+1)&1][s+q[i]-500], tmp);\n                    }\n                }\n                if (s+q[i] <= sumq) {\n                    auto tmp = dp[i&1][s];\n                    tmp.cost += p[i];\n                    chmin(dp[(i+1)&1][s+q[i]], tmp);\n                }\n            }\n        }\n\n        Pair Min{-IINF, IINF};\n        for (int s = 0; s <= sumq; ++s) {\n            chmin(Min, dp[n%2][s]);\n        }\n        cout << Min.k << \" \" << Min.cost << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100000000\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n;\nint p[101];\nP dp[101][50001];\n\nP max_get(P a,P b){\n\tif(a.first>b.first){\n\t\treturn a;\n\t}\n\tif(a.first<b.first){\n\t\treturn b;\n\t}\n\treturn (a.second<=b.second)?a:b;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&p[i]);\n\t\t}\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=500000;j++){\n\t\t\t\tdp[i][j]=P(0,INF);\n\t\t\t}\n\t\t}\n\t\tdp[0][0]=P(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint need=(p[i]%1000)-500;\n\t\t\tif(need<0)need+=1000;\n\t\t\tint oturi=1000-(p[i]%1000);\n\t\t\tif(oturi==1000)oturi=0;\n\t\t\tfor(int j=0;j<=50000;j++){\n\t\t\t\tif(dp[i][j].second!=INF){\n\t\t\t\t\tdp[i+1][j]=max_get(dp[i+1][j],dp[i][j]);\n\t\t\t\t\tif(p[i]%1000<500 && ((p[i]%1000)!=0)){\n\t\t\t\t\t\tP np=dp[i][j];\n\t\t\t\t\t\tnp.first++;\n\t\t\t\t\t\tnp.second+=p[i];\n\t\t\t\t\t\tdp[i+1][j+oturi-500]=max_get(dp[i+1][j+oturi-500],np);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(j>=need){\n\t\t\t\t\t\t\tP np=dp[i][j];\n\t\t\t\t\t\t\tnp.first++;\n\t\t\t\t\t\t\tnp.second+=p[i];\n\t\t\t\t\t\t\tdp[i+1][j-need]=max_get(dp[i+1][j-need],np);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tP np=dp[i][j];\n\t\t\t\t\t\t\tnp.second+=p[i];\n\t\t\t\t\t\t\tdp[i+1][j+oturi]=max_get(dp[i+1][j+oturi],np);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r1=0,r2=0;\n\t\tfor(int i=0;i<=50000;i++){\n\t\t\tif(dp[n][i].second!=INF){\n\t\t\t\tif(r1==dp[n][i].first && r2>dp[n][i].second){\n\t\t\t\t\tr1=dp[n][i].first;\n\t\t\t\t\tr2=dp[n][i].second;\n\t\t\t\t}\n\t\t\t\tif(r1<dp[n][i].first){\n\t\t\t\t\tr1=dp[n][i].first;\n\t\t\t\t\tr2=dp[n][i].second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",r1,r2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n\n    while (scanf(\"%d\", &n) && n){\n        int a[128];\n        pair<int, int> dp[128][50 * 500];\n\n        for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n\n        for (int i = 0; i <= n; i++){\n            for (int j = 0; j < 50 * 500; j++){\n                dp[i][j] = make_pair(0, -1001001001);\n            }\n        }\n\n        dp[0][0] = make_pair(0, 0);\n        for (int i = 1; i <= n; i++){\n            for (int j = 0; j < min(i, 50) * 500; j++){\n                if (dp[i - 1][j].second != -1001001001){\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j]);\n                    int r = (1000 - a[i] % 1000) % 1000;\n                    if (j + r >= 500){\n                        pair<int, int> nxt = make_pair(dp[i - 1][j].first + 1, dp[i - 1][j].second - a[i]);\n                        dp[i][j + r - 500] = max(dp[i][r % 500], nxt);\n                    }\n                    dp[i][j + r] = max(dp[i][j + r], make_pair(dp[i - 1][j].first, dp[i - 1][j].second - a[i]));\n                }\n            }\n        }\n\n        pair<int, int> ans = *max_element(dp[n], dp[n] + 500);\n        printf(\"%d %d\\n\", ans.first, -ans.second);\n    }\n    \n    return (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct entry {\n    int score, cost;\n\n    entry() {}\n    entry(int a, int b): score(a), cost(b) {}\n\n    bool operator < (const entry& o) const {\n        return score == o.score ? cost > o.cost : score < o.score;\n    }\n\n    bool operator > (const entry& o) const {\n        return score == o.score ? cost < o.cost : score > o.score;\n    }\n};\n\nconstexpr int INF = 1 << 28;\n\nint N, P[100];\n\nconstexpr int LIM = 50050;\nentry dp[105][LIM];\n\nentry solve() {\n    for (int i = 0; i <= N; ++i) for (int j = 0; j < LIM; ++j)\n        dp[i][j] = entry(-INF, INF);\n    dp[0][0] = entry(0, 0);\n\n    for (int i = 0; i < N; ++i) {\n        if (P[i] % 1000 <= 500) {\n            int r = P[i]%1000 == 0 ? INF : 500 - P[i]%1000;\n            int s = 500 + P[i]%1000;\n            for (int j = 0; j < LIM; ++j) {\n                dp[i+1][j] = dp[i][j];\n                if (j >= r)\n                    dp[i+1][j] = max(dp[i+1][j], entry(dp[i][j-r].score + 1, dp[i][j-r].cost + P[i]));\n                if (j+s < LIM)\n                    dp[i+1][j] = max(dp[i+1][j], entry(dp[i][j+s].score + 1, dp[i][j+s].cost + P[i]));\n            }\n        } else {\n            int r = P[i]%1000 - 500;\n            for (int j = 0; j < LIM; ++j) {\n                dp[i+1][j] = dp[i][j];\n                if (j+r < LIM)\n                    dp[i+1][j] = max(dp[i+1][j], entry(dp[i][j+r].score + 1, dp[i][j+r].cost + P[i]));\n                if (j-(500-r) >= 0)\n                    dp[i+1][j] = max(dp[i+1][j], entry(dp[i][j-(500-r)].score, dp[i][j-(500-r)].cost + P[i]));\n            }\n        }\n    }\n\n    entry ans(0, 0);\n    for (int i = 0; i < LIM; ++i) {\n        ans = max(ans, dp[N][i]);\n    }\n\n    return ans;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n        for (int i = 0; i < N; ++i) cin >> P[i];\n        entry ans = solve();\n        cout << ans.score << \" \" << ans.cost << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define SIZE 5100\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nint c[5]={100,50,10,5,1};\nconst int B = 10;\nint encode(vector<int> v){\n\tint S = 0;\n\tfor(int i=0;i<v.size();i++){\n\t\tassert(v[i]<B);\n\t\tS = S*B+v[i];\n\t}\n\treturn S;\n}\nvector<int> decode(int S){\n\tvector<int> v;\n\tint x = B*B*B*B;\n\tfor(int i=0;i<5;i++){\n\t\tv.pb(S/x);\n\t\tS %= x;\n\t\tx /= B;\n\t}\n\treturn v;\n}\nP dp[105][SIZE];\npair<int,vector<int> > charge(int x){\n\tx %= 1000;\n\tvector<int> v(5,0);\n\tint f = x/500;\n\tx -= f*500;\n\tfor(int i=0;i<5;i++){\n\t\tv[i]=x/c[i];\n\t\tx -= v[i]*c[i];\n\t}\n\t//assert(x==0);\n\treturn make_pair(f,v);\n}\n/*void dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}*/\nP dfs(int id,int V){\n\t/*cout << \"call : \" << id << endl;\n\tcout << \"vec : \";\n\tdump(vec);\n\tcout << endl;*/\n\tint tmp = V;\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tmap<int,P>::iterator it;\n\tif(dp[id][V].fi!=-1){\n\t\treturn dp[id][V];\n\t}\n\tP res = dfs(id+1,V);\n\tvector<int> vec = decode(V);\n\tint h = ((p[id]-1)/1000+1)*1000;;\n\tfor(int i=0;i<5;i++){\n\t\twhile(vec[i]>0&&h-p[id]+c[i]<1000){\n\t\t\tvec[i]--;\n\t\t\th += c[i];\n\t\t}\n\t}\n\tpair<int,vector<int> > ch = charge(h-p[id]);\n\tfor(int i=0;i<5;i++)vec[i] += (ch.sec)[i];\n\tP res2 = dfs(id+1,encode(vec));\n\tres2.fi += ch.fi;\n\tres2.sec -= p[id];\n\tdp[id][tmp]=max(res,res2);\n\t/*cout << \"end : \" << id << endl;\n\tcout << \"vec : \";\n\tdump();\n\tcout << \"result : \" << dp[id][vec].fi << ' ' << -dp[id][vec].sec << endl;*/\n\treturn dp[id][tmp];\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<SIZE;j++){\n\t\t\tdp[i][j]=P(-1,-1);\n\t\t}\n\t}\n\tP ans = dfs(0,0);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<complex>\n#include<string>\n#include<cstring>\n\nusing namespace std;\n#define rep2(x,from,to) for(long long x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n#define INF 100000000\n#define all(x) x.begin(),x.end()\ntypedef pair<long long,long long> P;\ntypedef pair<long long,P> PP;\nlong long n;\nlong long ans_yen;\nlong long ans_five;\nlong long p[105];\nlong long pp[105];\nlong long dp[105][1000][105];\nint main()\n{\n\twhile(1)\n\t{\n\t\tans_yen=INF;\n\t\tans_five=0;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\trep(i,n)\n\t\t{\n\t\t\tcin>>p[i];\n\t\t\tpp[i]=p[i];\n\t\t\tp[i]%=1000;\n\t\t}\n\t\trep(i,105)rep(j,1000)rep(k,105)dp[i][j][k]=INF;\n\t\tdp[0][0][0]=0;\n\t\trep(i,n)\n\t\t{\n\t\t\trep(j,1000)\n\t\t\t{\n\t\t\t\trep(k,n)\n\t\t\t\t{\n\t\t\t\t\tif(dp[i][j][k]==INF)continue;\n\t\t\t\t\tdp[i+1][j][k]=min(dp[i][j][k],dp[i+1][j][k]);\n\t\t\t\t\t/*dp[i+1][(j+1000-p[i])%1000][k]=min(dp[i][j][k]+p[i],dp[i+1][(j+1000-p[i])%1000][k]);\n\t\t\t\t\tif(j>=(p[i]+500)%1000)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+1][j-(p[i]+500)%1000][k+1]=min(dp[i+1][j-(p[i]+500)%1000][k+1],dp[i][j][k]+p[i]);\n\t\t\t\t\t}*/\n\t\t\t\t\tif(p[i]<=500&&p[i]!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+1][(j+500-p[i])%1000][k+1]=min(dp[i][j][k]+pp[i],dp[i+1][(j+1000-p[i])%1000][k+1]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+1][(j+1000-p[i])%1000][k]=min(dp[i][j][k]+pp[i],dp[i+1][(j+1000-p[i])%1000][k]);\n\t\t\t\t\tif(j>=(p[i]+500)%1000)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+1][j-(p[i]+500)%1000][k+1]=min(dp[i+1][j-(p[i]+500)%1000][k+1],dp[i][j][k]+pp[i]);\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j,1000)rep(k,n+1)\n\t\t{\n\t\t\tif(dp[n][j][k]!=INF)\n\t\t\t{\n\t\t\t\tif(ans_five<k)\n\t\t\t\t{\n\t\t\t\t\tans_yen=dp[n][j][k];\n\t\t\t\t\tans_five=k;\n\t\t\t\t}\n\t\t\t\tif(ans_five==k)\n\t\t\t\t{\n\t\t\t\t\tans_yen=min(dp[n][j][k],ans_yen);\n\t\t\t\t}\n\t\t\t\t//cout<<j<<\" \"<<k<<\" \"<<dp[n][j][k]<<endl;\n\t\t\t}\n\t\t}\n\t\trep(i,n+1)rep(j,1000)rep(k,n+1)\n\t\t{\n\t\t\tif(dp[i][j][k]!=INF)\n\t\t\t{\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<dp[i][j][k]<<endl;\n\t\t\t}\n\t\t}\n\t\tcout<<ans_five<<\" \"<<ans_yen<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<n; ++i)\n#define rep(i,n) reps(i,0,n)\n#define mm(a,b) a = min(a, b)\n\nint dp[101][101][1000];\n\nvoid solve(int n)\n{\n    vector<int> p(n);\n    \n    rep(i, n){\n        cin >> p[i];\n    }\n    \n    rep(i, n+1){\n        rep(g, n+1){\n            rep(c, 1000){\n                dp[i][g][c] = 1001001001;\n            }\n        }\n    }\n    dp[0][0][0] = 0;\n    \n    rep(i, n){\n        rep(g, n+1){\n            rep(c, 1000){\n                int v = dp[i][g][c];\n                mm(dp[i+1][g][c], v);\n                if(g == n) continue;\n                \n                int m = (p[i] - c + 999) / 1000;\n                int nc = c - p[i] + 1000 * m;\n                v += p[i];\n                if(nc >= 500) mm(dp[i+1][g+1][nc-500], v);\n                else{\n                    mm(dp[i+1][g][nc], v);\n                    int s = p[i] - 1000*m - 1;\n                    if(0 <= s && s <= c) mm(dp[i+1][g+1][nc + 500], v);\n                }\n            }\n        }\n    }\n    \n    for(int g=n; g>=0; --g){\n        int ans = 1001001001;\n        rep(c, 1000){\n            int v = dp[n][g][c];\n            mm(ans, v);\n        }\n        \n        if(ans < 1001001001){\n            cout << g << ' ' << ans << endl;\n            return;\n        }\n    }\n}\n\nint main()\n{\n    int n;\n    \n    while(cin >> n, n){\n        solve(n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define M 25000\n\nint dp[2][101][M];\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int p[100],pp[100];\n    for(int i=0;i<n;i++)scanf(\"%d\",&p[i]),pp[i]=(1000-p[i]%1000)%1000;\n\n    for(int i=0;i<2;i++)\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<M;k++)dp[i][j][k]=1e9;\n    \n    dp[0][0][0]=0;\n\n    for(int i=0;i<n;i++){\n      int ni=(i+1)%2,I=i%2,mm=min(M,2*M*(i+1)/n);\n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<mm;k++)dp[ni][j][k]=1e9;\n      \n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<mm;k++){\n\t  int np=k+pp[i];\n\t  int nj=j;\n\t  if(np>=500)nj++,np-=500;\n\t  np=min(M-1,np);\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t  dp[ni][j][k]=min(dp[ni][j][k],dp[I][j][k]);\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t}\n    }\n    \n    int c=0,s=0;\n    for(int i=1;i<=n;i++)\n      for(int j=0;j<M;j++)\n\tif(dp[n%2][i][j]!=1e9&&i>=c){\n\t  if(c==i&&dp[n%2][i][j]<s)s=dp[n%2][i][j];\n\t  else if(c<i)c=i,s=dp[n%2][i][j];\n\t}\n    cout<<c<<\" \"<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vii;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip> vip;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 :1e9;\n#define MAX 50010\nint dp[110][MAX];\nint mo[110][MAX];\nvoid f(int a,int b,int c,int d){\n    if(dp[a][b]<c){\n        dp[a][b]=c;\n        mo[a][b]=d;\n    }else if(dp[a][b]==c)\n        mo[a][b]=min(mo[a][b],d);\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        vi in(n);\n        rep(i,n)cin>>in[i];\n        rep(j,110)rep(k,MAX)dp[j][k]=-inf;\n        dp[0][0]=mo[0][0]=0;\n        rep(i,n)rep(j,MAX)if(dp[i][j]!=-inf){\n            f(i+1,j,dp[i][j],mo[i][j]);\n            int a=in[i]%1000;\n            int t=1000-a;\n            if(a)f(i+1,j+t%500,dp[i][j]+(t>=500),mo[i][j]+in[i]);\n            else if(j>=500)f(i+1,j-500,dp[i][j]+1,mo[i][j]+in[i]);\n            t=500+j-a;\n            if(t>=0&&a>=500)f(i+1,t,dp[i][j]+1,mo[i][j]+in[i]);\n        }\n \n        int outc=0,out=inf;\n        rep(i,MAX)if(dp[n][i]!=-inf){\n            if(outc<dp[n][i]){\n                outc=dp[n][i];\n                out=mo[n][i];\n            }else if(outc==dp[n][i])\n                out=min(out,mo[n][i]);\n        }\n        cout<<outc<<\" \"<<out<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nint c[5]={100,50,10,5,1};\nint encode(vector<int> v){\n\tint S = 0;\n\tfor(int i=0;i<v.size();i++){\n\t\tS = S*10+v[i];\n\t}\n\treturn S;\n}\nvector<int> decode(int S){\n\tvector<int> v;\n\tint x = 10000;\n\tfor(int i=0;i<5;i++){\n\t\tv.pb(S/x);\n\t\tS %= x;\n\t\tx /= 10;\n\t}\n\treturn v;\n}\nmap<int,P> dp[105];\npair<int,vector<int> > charge(int x){\n\tx %= 1000;\n\tvector<int> v(5,0);\n\tint f = x/500;\n\tx -= f*500;\n\tfor(int i=0;i<5;i++){\n\t\tv[i]=x/c[i];\n\t\tx -= v[i]*c[i];\n\t}\n\t//assert(x==0);\n\treturn make_pair(f,v);\n}\n/*void dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}*/\nP dfs(int id,int V){\n\t/*cout << \"call : \" << id << endl;\n\tcout << \"vec : \";\n\tdump(vec);\n\tcout << endl;*/\n\tint tmp = V;\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tmap<int,P>::iterator it;\n\tit = dp[id].find(V);\n\tif(it!=dp[id].end()){\n\t\treturn (it->sec);\n\t}\n\tP res = dfs(id+1,V);\n\tvector<int> vec = decode(V);\n\tint h = ((p[id]-1)/1000+1)*1000;;\n\tfor(int i=0;i<5;i++){\n\t\twhile(vec[i]>0&&h-p[id]+c[i]<1000){\n\t\t\tvec[i]--;\n\t\t\th += c[i];\n\t\t}\n\t}\n\tpair<int,vector<int> > ch = charge(h-p[id]);\n\tfor(int i=0;i<5;i++)vec[i] += (ch.sec)[i];\n\tP res2 = dfs(id+1,encode(vec));\n\tres2.fi += ch.fi;\n\tres2.sec -= p[id];\n\tdp[id][tmp]=max(res,res2);\n\t/*cout << \"end : \" << id << endl;\n\tcout << \"vec : \";\n\tdump();\n\tcout << \"result : \" << dp[id][vec].fi << ' ' << -dp[id][vec].sec << endl;*/\n\treturn dp[id][tmp];\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<105;i++)dp[i].clear();\n\tP ans = dfs(0,0);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<n;i++)\ntypedef pair<int, int> P;\n\n\nvoid solve() {\n\tint N; cin >> N;\n\tif (N == 0)exit(0);\n\tvector<int>p(N);\n\tREP(i, N) {\n\t\tcin >> p[i];\n\t}\n\t//dp[i][j]=i番目までで、おつりがj円の時の、{500円玉の枚数のmax,消費金額のmin}\n\tvector<vector<P>>dp(N + 1, vector<P>(50500, { -1,1e8 }));\n\tdp[0][0] = { 0,0 };\n\tREP(i, N) {\n\t\tREP(j, 50005) {\n\t\t\tif (dp[i][j].first <0)continue;\n\t\t\tint otsuri = (1000 - p[i] % 1000) % 1000;\n\t\t\tint cnt = dp[i][j].first;\n\t\t\tint cost = dp[i][j].second;\n\t\t\t//買わない\n\t\t\tif (cnt>dp[i + 1][j].first) {\n\t\t\t\tdp[i + 1][j] = { cnt,cost };\n\t\t\t}\n\t\t\telse if (cnt == dp[i + 1][j].first&&cost<dp[i + 1][j].second) {\n\t\t\t\tdp[i + 1][j] = { cnt,cost };\n\t\t\t}\n\n\t\t\t//おつりが500円以上の時(1000円で買えば500円がもらえる)\n\t\t\tif (otsuri >= 500) {\n\t\t\t\t//500円のmaxを増やせるとき\n\t\t\t\tif (cnt + 1>dp[i + 1][j + otsuri - 500].first) {\n\t\t\t\t\tdp[i + 1][j + otsuri - 500] = { cnt + 1,cost + p[i] };\n\t\t\t\t}\n\t\t\t\t//消費金額のminを小さくできるとき\n\t\t\t\telse if (cnt + 1 == dp[i + 1][j + otsuri - 500].first&&cost + p[i]<dp[i + 1][j + otsuri - 500].second) {\n\t\t\t\t\tdp[i + 1][j + otsuri - 500] = { cnt + 1,cost + p[i] };\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//手持ちのおつりと合わせて500円がもらえる\n\t\t\t\tif (j + otsuri >= 500) {\n\t\t\t\t\tint d = 500 - otsuri;//500円との差額\n\t\t\t\t\t\t\t\t\t\t //買うけど500円はもらわない\n\t\t\t\t\tif (cnt>dp[i + 1][j + otsuri].first) {\n\t\t\t\t\t\tdp[i + 1][j + otsuri] = { cnt,cost + p[i] };\n\t\t\t\t\t}\n\t\t\t\t\telse if (cnt == dp[i + 1][j + otsuri].first&&cost + p[i]<dp[i + 1][j + otsuri].second) {\n\t\t\t\t\t\tdp[i + 1][j + otsuri] = { cnt,cost + p[i] };\n\t\t\t\t\t}\n\n\t\t\t\t\t//500円のmaxを増やせるとき\n\t\t\t\t\tif (cnt + 1>dp[i + 1][j - d].first) {\n\t\t\t\t\t\tdp[i + 1][j - d] = { cnt + 1,cost + p[i] };\n\t\t\t\t\t}\n\t\t\t\t\t//消費金額のminを小さくできるとき\n\t\t\t\t\telse if (cnt + 1 == dp[i + 1][j - d].first && cost + p[i]<dp[i + 1][j - d].second) {\n\t\t\t\t\t\tdp[i + 1][j - d] = { cnt + 1,cost + p[i] };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (cnt>dp[i + 1][j + otsuri].first) {\n\t\t\t\t\t\tdp[i + 1][j + otsuri] = { cnt,cost + p[i] };\n\t\t\t\t\t}\n\t\t\t\t\telse if (cnt == dp[i + 1][j + otsuri].first&&cost + p[i]<dp[i + 1][j + otsuri].second) {\n\t\t\t\t\t\tdp[i + 1][j + otsuri] = { cnt,cost + p[i] };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt_max = 0;\n\tREP(j, 50001) {\n\t\tcnt_max = max(cnt_max, dp[N][j].first);\n\t}\n\tint mn_cost = 1e9;\n\tREP(j, 50001) {\n\t\tif (dp[N][j].first == cnt_max) {\n\t\t\tmn_cost = min(mn_cost, dp[N][j].second);\n\t\t}\n\t}\n\tcout << cnt_max << \" \" << mn_cost << endl;\n}\nint main() {\n\twhile (true)solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n\nusing namespace std;\n\nconstexpr int MAX = 100;\nconstexpr int RES = 1000;\nconstexpr int INF = 1 << 30;\nint dp[MAX + 1][MAX + 1][RES];  // i?????????:500??????j???:??????????????¬??¨k??? ??¨??????????°?????????????\n\nint main()\n{\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<int> p(n);\n        for (int i = 0; i < n; i++) {\n            cin >> p[i];\n        }\n\n\n        for (int i = 0; i <= MAX; i++) {\n            for (int j = 0; j <= MAX; j++) {\n                for (int k = 0; k < RES; k++) {\n                    dp[i][j][k] = INF;\n                }\n            }\n        }\n        dp[0][0][0] = 0;\n\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= n; j++) {\n                for (int k = 0; k < RES; k++) {\n                    if (dp[i][j][k] != INF) {\n                        dp[i + 1][j][k] = min(dp[i + 1][j][k], dp[i][j][k]);\n                        const int pr = p[i] % 1000;\n                        if (k >= pr) {\n                            const int ret = k - pr;\n                            dp[i + 1][j][ret] = min(dp[i + 1][j][ret], dp[i][j][k] + p[i]);\n                            if (ret >= 500) {\n                                dp[i + 1][j + 1][ret - 500] = min(dp[i + 1][j + 1][ret - 500], dp[i][j][k] + p[i]);\n                            } else if (pr != 0) {\n                                dp[i + 1][j + 1][ret + 500] = min(dp[i + 1][j + 1][ret + 500], dp[i][j][k] + p[i]);\n                            }\n                        } else {\n                            const int ret = k + 1000 - pr;\n                            dp[i + 1][j][ret] = min(dp[i + 1][j][ret], dp[i][j][k] + p[i]);\n                            if (ret >= 500) {\n                                dp[i + 1][j + 1][ret - 500] = min(dp[i + 1][j + 1][ret - 500], dp[i][j][k] + p[i]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for (int j = n; j >= 0; j--) {\n            int mini = INF;\n            for (int k = 0; k < RES; k++) {\n                mini = min(mini, dp[n][j][k]);\n            }\n            if (mini != INF) {\n                cout << j << \" \" << mini << endl;\n                break;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define rep(i, n) for (signed i = 0; i < signed(n); i++)\n#define REP(i, s, n) for (signed i = signed(s); i < signed(n); i++)\n#define rrep(i, n) for (signed i = signed(n) - 1; i >= 0; i--)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nconst int M = 25001;\nint dp[M][101];\nint buf[M][101];\nvoid calc() {\n\tint n;\n\tconst int inf = 1 << 29;\n\twhile (cin >> n && n) {\n\t\tfill(dp[0], dp[25001], inf);\n\t\tfill(buf[0], buf[25001], inf);\n\t\tbuf[0][0] = dp[0][0] = 0;\n\t\trep(i, n) {\n\t\t\tint p; cin >> p;\n\t\t\tint m = p % 1000;\n\t\t\tint rm = (1000 - m) % 1000;\n\t\t\trrep(k, n) rep(j, M) if (dp[j][k] < inf) {\n\t\t\t\tif (m == 0) {\n\t\t\t\t\tif (j >= 500) {\n\t\t\t\t\t\tminup(buf[min(M, j - 500ll)][k + 1], dp[j][k] + p);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (m <= 500) {\n\t\t\t\t\tminup(buf[min(M, j + 500 - m)][k + 1], dp[j][k] + p);\n\t\t\t\t} else {\n\t\t\t\t\tminup(buf[min(M, j + rm)][k], dp[j][k] + p);\n\t\t\t\t\tint sub = m - 500;\n\t\t\t\t\tif (j >= sub) {\n\t\t\t\t\t\tminup(buf[min(M, j - sub)][k + 1], dp[j][k] + p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemcpy(dp, buf, M * (101));\n\t\t}\n\t\tint ans = inf;\n\t\tint cnt = 0;\n\t\trep(i, M) rep(j, n + 1) if (dp[i][j] < inf) {\n\t\t\tif (j == cnt) minup(ans, dp[i][j]);\n\t\t\tif (j > cnt) {\n\t\t\t\tans = dp[i][j];\n\t\t\t\tcnt = j;\n\t\t\t}\n\t\t}\n\t\tif (cnt == 0) cout << \"0 0\" << endl;\n\t\telse cout << cnt << \" \" << ans << endl;\n\t}\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcalc();\n#ifdef _MSC_VER\n\tsystem(\"pause\");\n#endif\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1 ; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1 ; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9+100;\nconst bool debug = 0;\n/***************************************/\n\nint N;\nint p[100];\nint dp[101][25001]; // 500円の枚数, 所持金(100円以下の小銭) = 最小購入金額\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tREP(i, N) scanf(\"%d\", p + i);\n\t\t\n\t\tfill(dp[0], dp[N + 1], INF);\n\t\tdp[0][0] = 0;\n\t\t\n\t\tint lim[101] = {};\n\t\tfor (int i = N - 1; i >= 0; i--) {\n\t\t\tint chg = (1000 - (p[i] % 1000)) % 1000;\n\t\t\tif (chg >= 500) chg = 500;\n\t\t\tlim[i] = 500 - chg + lim[i + 1];\n\t\t}\n\t\tREP(t, N) {\n\t\t\tint chg = 1000 - (p[t] % 1000);\n\t\t\tchg %= 1000;\n\t\t\t\n\t\t\tfor (int i = N; i >= 0; i--) {\n\t\t\t\tfor (int j = min(25000, lim[i]); j >= 0; j--) {\n\t\t\t\t\tif (i) { // 購入して500円玉が増えた場合\n\t\t\t\t\t\tif (chg >= 500) {\n\t\t\t\t\t\t\tint cur = chg - 500; // 増加\n\t\t\t\t\t\t\tif (j - cur >= 0 && dp[i - 1][j - cur] != INF) chmin(dp[i][j], dp[i - 1][j - cur] + p[t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint cur = 500 - chg; // 減少\n\t\t\t\t\t\t\tif (j + cur <= 25000 && dp[i - 1][j + cur] != INF) chmin(dp[i][j], dp[i - 1][j + cur] + p[t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 購入して500円玉が増えなかった場合\n\t\t\t\t\tif (chg < 500 && j - chg >= 0 && dp[i][j - chg] != INF) chmin(dp[i][j], dp[i][j - chg] + p[t]);\n\t\t\t\t\t\n\t\t\t\t\t//小銭j円が多すぎて困ることはない\n\t\t\t\t\tif (j) chmin(dp[i][j-1], dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpii ans;\n\t\tfor (int i = N; i >= 0; i--) {\n\t\t\tif (dp[i][0] == INF) continue;\n\t\t\tans = pii(i, dp[i][0]);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (debug) printf(\"@ \");\n\t\tprintf(\"%d %d\\n\", ans.fi, ans.se);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\npair<int,int> dp[101][50501];\n\nbool ge(pair<int,int>p1,pair<int,int>p2){\n\tif(p1.first > p2.first)return 0;\n\tif(p1.first < p2.first)return 1;\n\tif(p1.second < p2.second)return 0;\n\treturn 1;\n}\n\n\nint main(){\n\tint n;\n\tint x;\n\tpair<int,int> p1,p2;\t\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int j=0;j<50001;j++){\n\t\t\t\tdp[i][j]=make_pair(0,0);\n\t\t\t}\n\t\t}\n\t\tvector<int> v(n+1,0);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tx = (v[i]-1)%1000+1;\n\t\t\tif(x<=500){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<50000;j++){\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tdp[i][j+500-x] = make_pair(1,v[i]);\n\t\t\t\t\t\tdp[i][j+500-x] = max(dp[i][j+500-x],dp[i-1][j+500-x],ge);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(dp[i-1][j]!=make_pair(0,0)){\n\t\t\t\t\t\t\tdp[i][j+500-x] = dp[i-1][j];\n\t\t\t\t\t\t\tdp[i][j+500-x].first +=1;\n\t\t\t\t\t\t\tdp[i][j+500-x].second +=v[i];\n\t\t\t\t\t\t\tdp[i][j+500-x] = max(dp[i][j+500-x],dp[i-1][j+500-x],ge);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i][j+500-x] = dp[i-1][j+500-x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<50000;j++){\n\t\t\t\t\tp1 = make_pair(0,0);\n\t\t\t\t\tp2 = make_pair(0,0);\n\t\t\t\t\tif(j-(1000-x)>=0){\n\t\t\t\t\t\tif(dp[i-1][j-(1000-x)]!=make_pair(0,0)){\n\t\t\t\t\t\t\tp1 = dp[i-1][j-(1000-x)];\n\t\t\t\t\t\t\tp1.second += v[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i-1][j+x-500]!=make_pair(0,0)){\n\t\t\t\t\t\tp2 = dp[i-1][j+x-500];\n\t\t\t\t\t\tp2.first +=1;\n\t\t\t\t\t\tp2.second +=v[i];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\tif(j-(1000-x)==0){\n\t\t\t\t\t\tif(dp[i-1][j]==make_pair(0,0)){\n\t\t\t\t\t\t\tdp[i][j]=make_pair(0,v[i]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i][j]=max(dp[i-1][j],make_pair(0,v[i]),ge);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p1!=make_pair(0,0)){\n\t\t\t\t\t\tdp[i][j] = max(dp[i][j],p1,ge);\n\t\t\t\t\t}\n\t\t\t\t\tif(p2!=make_pair(0,0)){\n\t\t\t\t\t\tdp[i][j] = max(dp[i][j],p2,ge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int,int> mx = make_pair(0,0);\n\t\tfor(int j=0;j<50000;j++){\n\t\t\tmx = max(mx,dp[n][j],ge);\n\t\t}\n\t\tcout << mx.first << \" \" << mx.second << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 99999999\nusing namespace std;\n\ntypedef struct{\n  int v;\n  int cha;\n}souv;\ntypedef struct{\n  int v;\n  int cnt;\n}dp;\n\nsouv memo[105];\ndp ans[105][50005];\nint n;\nvoid solve();\nvoid infset();\n\nint main(){\n  int answer=0;\n  int i;\n  while(1){\n    vector<int> dummy;\n    cin >> n;\n    if(n==0)break;\n    answer=0;\n    for(i=0;i<n;i++){\n      cin >> memo[i].v;\n      memo[i].cha=1000-(memo[i].v%1000);\n      if(memo[i].cha==1000){\n\tmemo[i].cha=0;\n\tdummy.push_back(memo[i].v);\n      }\n    }\n    infset();\n    solve();\n    //for(int j=0;j<=n*500;j++)if(ans[n][j]!=inf)cout <<n << \" \"<<j <<\" \"<< ans[n][j] <<endl;\n    //cout << ans[n][1500] << endl;\n    for(i=0;i<=n*500;i++){\n      if(ans[n][i].v==inf)continue;\n      if(i/500>answer/500)answer=i;\n      else if((i/500==answer/500)&&ans[n][i].v<ans[n][answer].v)answer=i;\n      //break;\n    }\n    if(!dummy.empty())sort(dummy.begin(),dummy.end());\n    //cout << ans[n][answer].cnt;\n    i=0;\n    while(answer/500>ans[n][answer].cnt){\n      //cout << dummy[i];\n      ans[n][answer].v+=dummy[i];\n      ans[n][answer].cnt++;\n      i++;\n    }\n    cout << answer/500 << \" \" << ans[n][answer].v << endl;\n  }\n  return 0;\n}\n\nvoid solve(){\n  int i,j;\n  for(i=0;i<n;i++)for(j=0;j<=n*500;j++){\n      //cout << j << \" \" << memo[i].cha<<endl;\n      if(j<memo[i].cha){\n\tans[i+1][j].v=ans[i][j].v;\n\tans[i+1][j].cnt=ans[i][j].cnt;\n      }\n      else {\n\tans[i+1][j].v=min(ans[i][j].v,ans[i][j-memo[i].cha].v+memo[i].v);\n\tif(ans[i+1][j].v==ans[i][j].v)ans[i+1][j].cnt=ans[i][j].cnt;\n\telse ans[i+1][j].cnt=ans[i][j-memo[i].cha].cnt+1;\n      }  \n    }\n}\nvoid infset(){\n  int i,j;\n  ans[0][0].cnt=0;\n  ans[0][0].v=0;\n  for(j=1;j<=n*500;j++){\n    ans[0][j].v=inf;\n    ans[0][j].cnt=-1;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<n; ++i)\n#define rep(i,n) reps(i,0,n)\n#define maxl(a,b) a = max(a, b)\n\npair<int, int> dp[101][210 * 500];\nconst int MAX = 1001001001;\n\nvoid solve(int n)\n{\n    vector<int> p(n);\n    \n    rep(i, n){\n        cin >> p[i];\n    }\n    \n    rep(i, n+1){\n        rep(c, 20*500){\n            dp[i][c] = {-MAX, 0};\n        }\n    }\n    dp[0][0] = {0, 0};\n    \n    rep(i, n){\n        rep(c, (n+10)*500){\n            auto r = dp[i][c];\n            maxl(dp[i+1][c], r);\n            \n            int pr = p[i] % 1000;\n            if(pr == 0){\n                if(c >= 500) maxl(dp[i+1][c - 500], make_pair(r.first+1, r.second - p[i]));\n            }\n            else if(pr <= 500){\n                maxl(dp[i+1][c + 500 - pr], make_pair(r.first+1, r.second - p[i]));\n            }\n            else{\n                maxl(dp[i+1][c - pr + 1000], make_pair(r.first, r.second - p[i]));\n                if(c >= pr - 500) maxl(dp[i+1][c - pr + 500], make_pair(r.first+1, r.second - p[i]));\n            }\n        }\n    }\n    \n    auto ans = *max_element(dp[n], dp[n] + 210*500);\n    cout << ans.first << ' ' << -ans.second << endl;\n}\n\nint main()\n{\n    int n;\n    \n    while(cin >> n, n){\n        solve(n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define M 25000\n\nint dp[101][101][M];\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int p[100],pp[100];\n    for(int i=0;i<n;i++)scanf(\"%d\",&p[i]),pp[i]=(1000-p[i]%1000)%1000;\n\n    for(int i=0;i<2;i++)\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<M;k++)dp[i][j][k]=1e9;\n    \n    dp[0][0][0]=0;\n\n    for(int i=0;i<n;i++){\n      int ni=(i+1)%2,I=i%2,mm=min(M,2*M*(i+1)/n);\n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<mm;k++)dp[ni][j][k]=1e9;\n      \n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<mm;k++){\n\t  int np=k+pp[i];\n\t  int nj=j;\n\t  if(np>=500)nj++,np-=500;\n\t  np=min(M-1,np);\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t  dp[ni][j][k]=min(dp[ni][j][k],dp[I][j][k]);\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t}\n    }\n    \n    int c=0,s=0;\n    for(int i=1;i<=n;i++)\n      for(int j=0;j<M;j++)\n\tif(dp[n%2][i][j]!=1e9&&i>=c){\n\t  if(c==i&&dp[n%2][i][j]<s)s=dp[n%2][i][j];\n\t  else if(c<i)c=i,s=dp[n%2][i][j];\n\t}\n    cout<<c<<\" \"<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> mypair;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define chmax(x,y) x= max(x,y)\nint main(){\n\nint n;\nwhile(1){\ncin>>n;\nif(n==0)break;\nvector<int> p(n);\nvector<vector<mypair> > dp(n+1,vector<mypair> (n*500+1,mypair(-1,-1)) );\ndp[0][0] = mypair(0,0);\n\trep(i,n)cin>>p[i];\n\trep(i,n)rep(j,500*n+1)if(dp[i][j]!=mypair(-1,-1)){\n\t\t//if(j>500)cout<<\"ok\"<<j<<endl;\n\t\tint coin = dp[i][j].first,cost = dp[i][j].second;\n\t\tif(j>=(p[i]+500)%1000) chmax(dp[i+1][j-(p[i]+500)%1000],mypair(coin+1,cost-p[i]));\n\t\tif(1<=p[i]%1000 &&p[i]%1000<=500)chmax(dp[i+1][j+(500-p[i]%1000)],mypair(coin+1,cost-p[i]));\n\t\tif(500<p[i]%1000)chmax(dp[i+1][j+(1000-p[i]%1000)],mypair(coin,cost-p[i]));\n\t\tchmax(dp[i+1][j],mypair(coin,cost));\n\t}\n\tmypair ans = mypair(0,0);\n\trep(i,500*n+1)chmax(ans,dp[n][i]);\n\tcout<<ans.first<<' '<<-ans.second<<endl;\n}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <deque>\n#include <utility>\n#include <set>\n#include <queue>\n#include <functional>\n\n#define REP(i, n) FOR(i, 0, n)\n#define FOR(i, a, b) for(int i = int(a); i < int(b); ++i)\n#define RREP(i, n) RFOR(i, 0, n)\n#define RFOR(i, a, b) for(int i = int(b) - 1; i >= int(a); --i)\n\n#define CHMAX(a, b) a = (a < b ? b : a)\n\nconstexpr double EPS = 1e-7;\n\nusing PAIR = std::pair<int, int>;\n\nPAIR dp[102][49901];\n// dp[i][j] = i番目まで見て小銭をj円持ってる時の(最大500円枚数, そのときの最小消費金額)\n\nsigned main() {\n\n\twhile (true) {\n\t\tint n;\n\t\tstd::cin >> n;\n\t\tif (n == 0) break;\n\t\tstd::vector<int> p(n);\n\t\tREP(i, n) std::cin >> p[i];\n\n\t\tREP(i, n + 1) REP(j, 49901) dp[i][j] = PAIR(-1, 0);\n\t\tdp[0][0] = PAIR(0, 0);\n\t\tREP(i, n) REP(j, 49901) {\n\t\t\tif (dp[i][j].first == -1) continue;\n\t\t\tCHMAX(dp[i + 1][j], dp[i][j]);\n\t\t\tif (p[i] % 1000 > 500) {\n\t\t\t\tCHMAX(dp[i + 1][j + 1000 - p[i] % 1000], PAIR(dp[i][j].first, dp[i][j].second - p[i]));\n\t\t\t\tif (p[i] % 1000 - 500 <= j) {\n\t\t\t\t\tCHMAX(dp[i + 1][j - (p[i] % 1000 - 500)], PAIR(dp[i][j].first + 1, dp[i][j].second - p[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (p[i] % 1000 == 0) {\n\t\t\t\tif (j >= 500) {\n\t\t\t\t\tCHMAX(dp[i + 1][j - 500], PAIR(dp[i][j].first + 1, dp[i][j].second - p[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCHMAX(dp[i + 1][j + 500 - p[i] % 1000], PAIR(dp[i][j].first + 1, dp[i][j].second - p[i]));\n\t\t\t}\n\t\t}\n\n\t\tPAIR ans(-1, 0);\n\t\tREP(j, 49901) CHMAX(ans, dp[n][j]);\n\t\tstd::cout << ans.first << \" \" << -ans.second << \"\\n\";\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\npair<int,int> dp[101][50501];\n\nbool ge(pair<int,int>p1,pair<int,int>p2){\n\tif(p1.first==0&&p1.second==0)return 1;\n\tif(p2.first==0&&p2.second==0)return 0;\n\tif(p1.first > p2.first)return 0;\n\tif(p1.first < p2.first)return 1;\n\tif(p1.second < p2.second)return 0;\n\treturn 1;\n}\n\n\nint main(){\n\tint n;\n\tint x;\n\tpair<int,int> p1,p2;\t\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int j=0;j<50001;j++){\n\t\t\t\tdp[i][j]=make_pair(0,0);\n\t\t\t}\n\t\t}\n\t\tvector<int> v(n+1,0);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tx = (v[i]-1)%1000+1;\n\t\t\tif(x<=500){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<50000;j++){\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tdp[i][j+500-x] = make_pair(1,v[i]);\n\t\t\t\t\t\tdp[i][j+500-x] = max(dp[i][j+500-x],dp[i-1][j+500-x],ge);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(dp[i-1][j]!=make_pair(0,0)){\n\t\t\t\t\t\t\tdp[i][j+500-x] = dp[i-1][j];\n\t\t\t\t\t\t\tdp[i][j+500-x].first +=1;\n\t\t\t\t\t\t\tdp[i][j+500-x].second +=v[i];\n\t\t\t\t\t\t\tdp[i][j+500-x] = max(dp[i][j+500-x],dp[i-1][j+500-x],ge);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i][j+500-x] = dp[i-1][j+500-x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<50000;j++){\n\t\t\t\t\tp1 = make_pair(0,0);\n\t\t\t\t\tp2 = make_pair(0,0);\n\t\t\t\t\tif(j-(1000-x)>=0){\n\t\t\t\t\t\tif(dp[i-1][j-(1000-x)]!=make_pair(0,0)){\n\t\t\t\t\t\t\tp1 = dp[i-1][j-(1000-x)];\n\t\t\t\t\t\t\tp1.second += v[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i-1][j+x-500]!=make_pair(0,0)){\n\t\t\t\t\t\tp2 = dp[i-1][j+x-500];\n\t\t\t\t\t\tp2.first +=1;\n\t\t\t\t\t\tp2.second +=v[i];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\tif(j-(1000-x)==0){\n\t\t\t\t\t\tif(dp[i-1][j]==make_pair(0,0)){\n\t\t\t\t\t\t\tdp[i][j]=make_pair(0,v[i]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i][j]=max(dp[i-1][j],make_pair(0,v[i]),ge);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = max(dp[i][j],p1,ge);\n\t\t\t\t\tdp[i][j] = max(dp[i][j],p2,ge);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int,int> mx = make_pair(0,0);\n\t\tfor(int j=0;j<50000;j++){\n\t\t\tmx = max(mx,dp[n][j],ge);\n\t\t}\n\t\tif(mx.first==0){\n\t\t\tcout << 0 << \" \" << 0 << endl;\n\t\t}else{\n\t\t\tcout << mx.first << \" \" << mx.second << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\npair<int,int> dp[101][50501];\n\nbool ge(pair<int,int>p1,pair<int,int>p2){\n\tif(p1.first==0&&p1.second==0)return 1;\n\tif(p2.first==0&&p2.second==0)return 0;\n\tif(p1.first > p2.first)return 0;\n\tif(p1.first < p2.first)return 1;\n\tif(p1.second < p2.second)return 0;\n\treturn 1;\n}\n\n\nint main(){\n\tint n;\n\tint x;\n\tpair<int,int> p1,p2;\t\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int j=0;j<50001;j++){\n\t\t\t\tdp[i][j]=make_pair(0,0);\n\t\t\t}\n\t\t}\n\t\tvector<int> v(n+1,0);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tx = (v[i]-1)%1000+1;\n\t\t\tif(x<=500){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<50000;j++){\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tdp[i][j+500-x] = make_pair(1,v[i]);\n\t\t\t\t\t\tdp[i][j+500-x] = max(dp[i][j+500-x],dp[i-1][j+500-x],ge);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(dp[i-1][j]!=make_pair(0,0)){\n\t\t\t\t\t\t\tdp[i][j+500-x] = dp[i-1][j];\n\t\t\t\t\t\t\tdp[i][j+500-x].first +=1;\n\t\t\t\t\t\t\tdp[i][j+500-x].second +=v[i];\n\t\t\t\t\t\t\tdp[i][j+500-x] = max(dp[i][j+500-x],dp[i-1][j+500-x],ge);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i][j+500-x] = dp[i-1][j+500-x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<50000;j++){\n\t\t\t\t\tp1 = make_pair(0,0);\n\t\t\t\t\tp2 = make_pair(0,0);\n\t\t\t\t\tif(j-(1000-x)>=0){\n\t\t\t\t\t\tif(dp[i-1][j-(1000-x)]!=make_pair(0,0)){\n\t\t\t\t\t\t\tp1 = dp[i-1][j-(1000-x)];\n\t\t\t\t\t\t\tp1.second += v[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i-1][j+x-500]!=make_pair(0,0)){\n\t\t\t\t\t\tp2 = dp[i-1][j+x-500];\n\t\t\t\t\t\tp2.first +=1;\n\t\t\t\t\t\tp2.second +=v[i];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\tif(j-(1000-x)==0){\n\t\t\t\t\t\tif(dp[i-1][j]==make_pair(0,0)){\n\t\t\t\t\t\t\tdp[i][j]=make_pair(0,v[i]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i][j]=max(dp[i-1][j],make_pair(0,v[i]),ge);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = max(dp[i][j],p1,ge);\n\t\t\t\t\tdp[i][j] = max(dp[i][j],p2,ge);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int,int> mx = make_pair(0,0);\n\t\tfor(int j=0;j<50000;j++){\n\t\t\tmx = max(mx,dp[n][j],ge);\n\t\t}\n\t\tcout << mx.first << \" \" << mx.second << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tvector<pair<int, int>> dp(1, make_pair(0, 0));\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint price;\n\t\t\tcin >> price;\n\n\t\t\tconst int need = min((i + 1) * 499, (n - i - 1) * 500);\n\t\t\tvector<pair<int, int>> next_dp(need + 1, make_pair(-1, -1));\n\n\t\t\tfor(int small = 0; small < dp.size(); ++small) {\n\t\t\t\tif(dp[small].first == -1) continue;\n\n\t\t\t\tchmax(next_dp[min(small, need)], dp[small]);\n\t\t\t\tconst int num = dp[small].first;\n\t\t\t\tconst int cost = -dp[small].second;\n\n\t\t\t\tconst auto update = [&](const int pay) {\n\t\t\t\t\tconst int need_small = pay % 1000;\n\t\t\t\t\tif(need_small > small) return;\n\n\t\t\t\t\tconst int change = pay - price;\n\t\t\t\t\tconst int next_small = min(small - need_small + change % 500, need);\n\t\t\t\t\tconst int next_num = num + change / 500;\n\t\t\t\t\tconst int next_cost = cost + price;\n\t\t\t\t\tchmax(next_dp[next_small], make_pair(next_num, -next_cost));\n\t\t\t\t};\n\n\t\t\t\tupdate((price + 999) / 1000 * 1000);\n\t\t\t\tupdate(price + 500);\n\t\t\t}\n\n\t\t\tdp = move(next_dp);\n\t\t}\n\n\t\tcout << dp[0].first << ' ' << -dp[0].second << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\n\nvoid solve() {\n    vector<int> v(N);\n    for (auto& i : v) cin >> i;\n\n    vector<vector<map<int,int> > > dp(N + 1, vector<map<int,int> >(N + 1));\n    dp[0][0][0] = 0;\n    for (int i = 0; i < N; i++) {\n        int payment = v[i];\n        for (int j = 0; j <= i; j++) {\n            for (auto p : dp[i][j]) {\n                int coins = p.first;\n                int cost = p.second;\n\n                if (dp[i+1][j].find(coins) == dp[i+1][j].end()) dp[i+1][j][coins] = cost;\n                else dp[i+1][j][coins] = min(dp[i+1][j][coins], cost);\n\n                int sub = payment % 1000;\n                if (0 < sub && sub <= 500) {\n                    int ncoins = min(coins + 500 - sub, 5000);\n                    if (dp[i+1][j+1].find(ncoins) != dp[i+1][j+1].end())\n                        dp[i + 1][j + 1][ncoins]\n                            = min(dp[i + 1][j + 1][ncoins], cost + payment);\n                    else\n                        dp[i + 1][j + 1][ncoins] = cost + payment;\n                } else {\n                    if (sub == 0) sub = 500;\n                    else sub = sub - 500;\n                    if (sub <= coins) {\n                        int coins_ = coins - sub;\n                        if (dp[i+1][j+1].find(coins_) != dp[i+1][j+1].end())\n                            dp[i + 1][j + 1][coins_] = min(dp[i+1][j+1][coins_], cost + payment);\n                        else\n                            dp[i + 1][j + 1][coins_] = cost + payment;\n                    }\n\n                    int ncoins = min(coins + (1000 - (payment % 1000)) % 1000, 5000);\n                    if (dp[i+1][j].find(ncoins) != dp[i+1][j].end())\n                        dp[i + 1][j][ncoins]\n                            = min(dp[i+1][j][ncoins], cost + payment);\n                    else\n                        dp[i + 1][j][ncoins] = cost + payment;\n                }\n            }\n        }\n    }\n    int ans = 1 << 28, count = 0;\n    for (int i = N; i > -1; i--) {\n        if (count > 0) break;\n        if (dp[N][i].size() == 0) continue;\n        count = i;\n        for (auto p : dp[N][i]) {\n            ans = min(p.second, ans);\n        }\n    }\n    cout << count << \" \" << ans << endl;\n}\n\nint main() {\n    while (cin >> N, N) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *) array, (T *) (array + N), val);\n}\n\nstd::pair<int, int> f(const int n, int nokori, int n_, const int *p) {\n    if (n <= n_)return std::make_pair(0, 0);\n    int s = p[n_] % 1000;\n    int c = 0;\n    pair<int, int> ans = make_pair(0, INF);\n    if (s > 500 || s == 0) {\n        ans = f(n, nokori, n_ + 1, p);\n    }\n\n    if (s != 0) {\n        if (s <= 500) {\n            c++;\n            nokori += (500 - s);\n        } else {\n            if (s > 500)s -= 500;\n            if (s <= nokori) {\n                c++;\n                nokori -= s;\n            } else {\n                nokori += (500 - s);\n            }\n        }\n    } else if (nokori >= 500) {\n        c++;\n    } else {\n        return ans;\n    }\n    pair<int, int> hoge = f(n, nokori, n_ + 1, p);\n    pair<int, int> hoge_ = make_pair(hoge.first + c, hoge.second + p[n_]);\n    if (ans.first < hoge_.first) {\n        ans = hoge_;\n    } else if (ans.first == hoge_.first && ans.first > hoge_.first) {\n        ans = hoge_;\n    }\n    return ans;\n}\n\nint main() {\n    int n;\n    int p[50];\n    while (cin >> n, n) {\n        Fill(p, 0);\n        for (int i = 0; i < n; i++) {\n            cin >> p[i];\n        }\n        pair<int, int> ans = f(n, 0, 0, p);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint dp[110][110][1010]={0};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\trep(i,110)rep(j,110)rep(k,1010)dp[i][j][k]=inf;\n\t\tdp[0][0][0]=0;\n\t\tvi a(n);\n\t\trep(i,n)cin>>a[i];\n\t\trep(i,n)rep(j,n)rep(k,1000)if(dp[i][j][k]!=inf){\n\t\t\tint I=i+1,J=j,K=k;\n\t\t\tdp[I][J][K]=min(dp[I][J][K],dp[i][j][k]);\n\t\t\tint t=1000-a[i]%1000;\n\t\t\tif(t==1000)t=0;\n\t\t\tif(a[i]%500<=K&&K&&a[i]>500)dp[I][J+1][K-a[i]%500]=min(dp[I][J+1][K-a[i]%500],dp[i][j][k]+a[i]);\n\t\t\telse{\n\t\t\t\tif(t>=500)dp[I][J+1][K+t-500]=min(dp[I][J+1][K+t-500],dp[i][j][k]+a[i]);\n\t\t\t\telse dp[I][J][K+t]=min(dp[I][J][K+t],dp[i][j][k]+a[i]);\n\t\t\t}\n\t\t}\n\t\tint out=0,ne=inf;\n\t\trep(i,n+1)rep(j,1010)if(out<=i&&dp[n][i][j]!=inf){\n\t\t\tif(out==i)ne=min(ne,dp[n][i][j]);\n\t\t\telse ne=dp[n][i][j];\n\t\t\tout=max(out,i);\n\t\t}\n\t\tcout<<out<<\" \"<<ne<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPEQ(i, n) FOREQ(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n\ntemplate <typename T> inline int size(const T& x) { return x.size(); }\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int n;\n    while (cin >> n, n) {\n\n        vector<int> prices(n);\n        REP(i, n) cin >> prices[i];\n\n        static const int MAX_COIN = 100*500;\n        vector<pair<int, int>> dp[2];\n        REP(i, 2) dp[i].resize(MAX_COIN);\n\n        dp[0][0] = make_pair(0, 0);\n        FOR(i, 1, MAX_COIN) dp[0][i] = make_pair(-10000000, 0);\n\n        REP(i, n) {\n            int curr = i % 2;\n            int next = (i+1) % 2;\n\n            REP(coin, MAX_COIN) {\n                dp[next][coin] = make_pair(-10000000, 0);\n            }\n\n            REP(coin, MAX_COIN) {\n                auto c = dp[curr][coin];\n                int change = (1000 - prices[i]%1000) % 1000;\n\n                if (change >= 500) {\n                    // 1000????????§?????£???500?????????????????\\?????´???\n                    int next_coin = coin + change - 500;\n                    if (next_coin < MAX_COIN)\n                        dp[next][next_coin] = max(dp[next][next_coin], make_pair(c.first+1, c.second-prices[i]));\n                    continue;\n                }\n\n                // ??????????????´???\n                dp[next][coin] = max(dp[next][coin], c);\n\n                if (change + coin >= 500) {\n                    // ????????´?????§????°???????????????°500?????????????????\\?????´???\n                    int next_coin = coin + change - 500;\n                    if (next_coin < MAX_COIN)\n                        dp[next][next_coin] = max(dp[next][next_coin], make_pair(c.first+1, c.second-prices[i]));\n                } else {\n                    // ????????´?????§???500???????????\\?????????????????´???\n                    int next_coin = coin + change;\n                    if (next_coin < MAX_COIN)\n                        dp[next][next_coin] = max(dp[next][next_coin], make_pair(c.first, c.second-prices[i]));\n                }\n            }\n        }\n\n        auto ans = make_pair(-10000000, 0);\n        REP(coin, MAX_COIN) ans = max(ans, dp[n%2][coin]);\n\n        cout << ans.first << ' ' << -ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef int ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nconst ll M = 100*5000;\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n;\n    while (cin >> n, n) {\n        vector<ll> p(n); cin >> p;\n        vector<vector<P>> dp(n+1, vector<P>(M+1, {-1, -1}));\n        dp[0][0] = {0, 0};\n        rep(i, n) rep(j, M+1) {\n            if (dp[i][j].first < 0) continue;\n            ll c, r; tie(c, r) = dp[i][j];\n            if (0 < p[i] % 1000 && p[i] % 1000 <= 500) {\n                // ??????\n                assert(j+p[i] <= M);\n                chmax(dp[i+1][j+p[i]], P(c+1, r+(500-p[i]%1000)));\n            }\n            else {\n                // ????????????\n                chmax(dp[i+1][j], dp[i][j]);\n                // ???????????????\n                chmax(dp[i+1][j+p[i]], P(c, r+(1000-p[i]%1000)%1000));\n                // 500????????????????????????????????????\n                ll need = (p[i]+500) % 1000;\n                if (r >= need) {\n                    chmax(dp[i+1][j+p[i]], P(c+1, r-need));\n                }\n            }\n        }\n        P ans{0, 0};\n        rep(i, M+1) {\n            chmax(ans, P(dp[n][i].first, -i));\n        }\n        cout << ans.first << \" \" << -ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N=110;\nconst int INF=123456789;\n\nint n,p[100];\nint dp1[N][50000],dp2[N][50000];\n\nint main()\n{\n    while(scanf(\" %d\", &n),n)\n    {\n        rep(i,n) scanf(\" %d\", &p[i]);\n\n        fill(dp1[0],dp1[N],-INF);\n        fill(dp2[0],dp2[N],INF);\n\n        dp1[0][0]=0;\n        dp2[0][0]=0;\n        rep(i,n)\n        {\n            rep(j,50000)\n            {\n                // ??????\n                // ???????????????????????????\n                int r = (1000-p[i]%1000)%1000;\n                int add=0;\n                if(r>=500)\n                {\n                    add=1;\n                    r-=500;\n                }\n                if(j+r<50000)\n                {\n                    if(dp1[i+1][j+r] < dp1[i][j]+add)\n                    {\n                        dp1[i+1][j+r] = dp1[i][j]+add;\n                        dp2[i+1][j+r] = dp2[i][j]+p[i];\n                    }\n                    else if(dp1[i+1][j+r] == dp1[i][j]+add)\n                    {\n                        dp2[i+1][j+r] = min(dp2[i+1][j+r],dp2[i][j]+p[i]);\n                    }\n                }\n\n                // ?°?????????????\n                int need = p[i]%1000;\n                if(need>=500) need-=500;\n                else need+=500;\n                if(need<=j)\n                {\n                    if(dp1[i+1][j-need] < dp1[i][j]+1)\n                    {\n                        dp1[i+1][j-need] = dp1[i][j]+1;\n                        dp2[i+1][j-need] = dp2[i][j]+p[i];\n                    }\n                    else if(dp1[i+1][j-need] == dp1[i][j]+1)\n                    {\n                        dp2[i+1][j-need] = min(dp2[i+1][j-need],dp2[i][j]+p[i]);\n                    }\n                }\n\n                // ????????????\n                if(dp1[i+1][j] < dp1[i][j])\n                {\n                    dp1[i+1][j] = dp1[i][j];\n                    dp2[i+1][j] = dp2[i][j];\n                }\n                else if(dp1[i+1][j] == dp1[i][j])\n                {\n                    dp2[i+1][j] = min(dp2[i+1][j],dp2[i][j]);\n                }\n            }\n        }\n\n        int x=0;\n        rep(i,50000) x = max(x,dp1[n][i]);\n\n        int y=INF;\n        rep(i,50000)\n        {\n            if(dp1[n][i] == x) y = min(y,dp2[n][i]);\n        }\n\n        printf(\"%d %d\\n\", x,y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 100000000\nusing namespace std;\n\n//お土産の購入額と1000札のみで購入したときのおつり\ntypedef struct {\n  int v;\n  int cha;\n} souv;\n\n// DP配列の中身。500円玉の枚数と、購入額\ntypedef struct {\n  int mon;\n  int sum;\n} table;\n\nbool cmp(table l, table r) {\n  if(l.mon > r.mon) return 1;\n  if(l.mon == r.mon && l.sum < r.sum) return 1;\n  return 0;\n}\n\nvoid dpset();\nvoid solve();\n\nsouv memo[105];\ntable dp[105][1000 * 102];\nint n;\n\nint main() {\n  int i;\n  table ans;\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    for(i = 1; i <= n; i++) {\n      cin >> memo[i].v;\n      memo[i].cha = 1000 - (memo[i].v % 1000);\n      if(memo[i].cha == 1000) memo[i].cha = 0;\n    }\n    dpset();\n    solve();\n    ans.mon = 0;\n    ans.sum = inf;\n    for(i = 0; i <= n * 1000; ++i)\n      if(cmp(dp[n][i], ans)) ans = dp[n][i];\n    if(ans.sum == inf) ans.sum = 0;\n    cout << ans.mon << \" \" << ans.sum << endl;\n  }\n  return 0;\n}\n\nvoid dpset() {\n  for(int i = 0; i <= n; ++i)\n    for(int j = 0; j <= (n + 1) * 1000; ++j) {\n      dp[i][j].mon = 0;\n      if(j == 0)\n        dp[i][j].sum = 0;\n      else\n        dp[i][j].sum = inf;\n    }\n}\n\nvoid solve() {\n  int i, j;\n  table now;\n  for(i = 1; i <= n; ++i) {\n    for(j = 0; j <= n * 1000; ++j) {\n      //札払いでおつりが500超えるので確実に購入\n      if(memo[i].cha >= 500 && j >= memo[i].cha % 500 &&\n         dp[i - 1][j - memo[i].cha % 500].sum != inf) {\n        dp[i][j] = dp[i - 1][j - memo[i].cha % 500];\n        ++dp[i][j].mon;\n        if(dp[i][j].sum == inf) dp[i][j].sum = 0;\n        dp[i][j].sum += memo[i].v;\n      }\n      //札払いでおつりが500を超えない\n      else if(memo[i].cha < 500) {\n        //購入しない\n        dp[i][j] = dp[i - 1][j];\n        //端数使って枚数増やすパターン\n        if(dp[i - 1][j + (500 - memo[i].cha)].sum != inf) {\n          now = dp[i - 1][j + (500 - memo[i].cha)];\n          ++now.mon;\n          now.sum += memo[i].v;\n          if(cmp(now, dp[i][j])) dp[i][j] = now;\n        }\n        //端数増やすパターン\n        if(j >= memo[i].cha && memo[i].cha != 0 &&\n           dp[i - 1][j - memo[i].cha].sum != inf) {\n          now = dp[i - 1][j - memo[i].cha];\n          if(now.sum == inf) now.sum = 0;\n          now.sum += memo[i].v;\n          if(cmp(now, dp[i][j])) dp[i][j] = now;\n        }\n      }\n      //if(dp[i][j].sum!=inf)cout << dp[i][j].sum << \" \" << dp[i][j].mon<<\" \" ;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1000000;\nconst ll longinf=1LL<<62 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nvoid chmin(int& x,int y){\n    if(x>y)x=y;\n}\n\nint main(){\n    int n;\n    while(cin>>n,n!=0){\n        int p[n];\n        rep(i,n)cin>>p[i];\n        int dp[n+1][50555],dpp[n+1][50555];\n        rep(i,n+1)rep(j,50555)dp[i][j]=dpp[i][j]=inf;\n        dp[0][0]=0;\n        rep(s,n){\n            rep(j,n+1)rep(k,50001)dpp[j][k]=inf;\n            rep(i,n+1)rep(j,50001){\n            int c=p[s]%1000;\n            dpp[i][j]=min(dpp[i][j],dp[i][j]);\n            if(c==0){\n                if(j>=500)chmin(dpp[i+1][j-500],dp[i][j]+p[s]);\n            }\n            else if(c<=500){\n                chmin(dpp[i+1][j+500-c],dp[i][j]+p[s]);\n            }\n            else {\n                if(c-500<=j)chmin(dpp[i+1][j-c+500],dp[i][j]+p[s]);\n                else chmin(dpp[i][j+1000-c],dp[i][j]+p[s]);\n            }\n            }\n            rep(i,n+1)rep(j,50555)dp[i][j]=dpp[i][j];\n        }\n        rep(i,n+1){\n            sort(dp[n-i],dp[n-i]+50555);\n            if(dp[n-i][0]!=inf){\n                cout<<n-i<<\" \"<<dp[n-i][0]<<endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1012345678;\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<int> A(N);\n\t\tfor (int i = 0; i < N; ++i) cin >> A[i];\n\t\tvector<pair<int, int> > dp = { make_pair(0, 0) };\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tvector<pair<int, int> > ndp((i + 1) * 1000 + 1, make_pair(-inf, inf));\n\t\t\tfor (int j = 0; j <= i * 1000; ++j) {\n\t\t\t\tndp[j] = max(ndp[j], dp[j]);\n\t\t\t\tint reward = (500 - A[i] % 500) % 500;\n\t\t\t\tndp[j + reward] = max(ndp[j + reward], make_pair(dp[j].first, dp[j].second - A[i]));\n\t\t\t\tint loss = 500 - (1000 - A[i] % 1000) % 1000;\n\t\t\t\tif (j >= loss) ndp[j - loss] = max(ndp[j - loss], make_pair(dp[j].first + 1, dp[j].second - A[i]));\n\t\t\t}\n\t\t\tdp = ndp;\n\t\t}\n\t\tpair<int, int> ans = *max_element(dp.begin(), dp.end());\n\t\tcout << ans.first << ' ' << -ans.second << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 100100100;\n\nint main(){\n\n    while(1){        \n        int n; cin >> n;\n        if(!n) break;\n        vector<int> a(n);\n        for(int i = 0; i < n; i++) cin >> a[i];\n\n        //i番目までの品物を見て、得られた500円玉がj枚で持ってる小銭がk円の時の消費金額の最小値\n        vector<vector<vector<int> > > dp(2, vector<vector<int> > (n + 1, vector<int> (500 * n + 1000, INF)));  \n        dp[0][0][0] = 0;\n        int now = 0;\n        int next = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j <= i; j++){\n                for(int k = 0; k <= 500 * i; k++){\n\n                    int r = a[i] % 1000;\n                    //買わない\n                    dp[next][j][k] = min(dp[next][j][k], dp[now][j][k]);\n\n                    //1000で割ったあまりによる場合わけ\n                    if(1 <= r && r <= 500){\n                        //1000札のみで払うのが最適\n                        //500円獲得\n                        dp[next][j + 1][(500 - r) + k] = min(dp[next][j + 1][(500 - r) + k], dp[now][j][k] + a[i]);\n                    }else{\n                        //小銭を駆使して500円玉を獲得\n                        int need = r - 500;\n                        if(need == -500) need = 500;\n                        if(k - need >= 0) dp[next][j + 1][k - need] = min(dp[next][j + 1][k - need], dp[now][j][k] + a[i]);\n                        else{\n                            //1000円札のみで払う\n                            //500円玉は獲得できない\n                            dp[next][j][(1000 - r) % 1000 + k] = min(dp[next][j][(1000 - r) % 1000 + k], dp[now][j][k] + a[i]);\n                        }\n                        \n                    }\n                }\n            }\n            swap(now, next);\n        }\n\n        int ans1 = 0, ans2 = INF;\n        for(int j = 0; j <= n; j++){\n            for(int k = 0; k <= 500 * n; k++){\n                if(dp[now][j][k] != INF){\n                    if(ans1 < j || (ans1 == j && ans2 > dp[now][j][k])){\n                        ans1 = j;\n                        ans2 = dp[now][j][k];\n                    }\n                }\n            }\n        }\n\n        cout << ans1 << \" \" << ans2 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 100;\nconst int MAX_MONEY = 500 * MAX_N;\nint n;\nint p[MAX_N];\npair<char, int> memo[MAX_N][MAX_MONEY];\n\ninline void Change(pair<char, int> &a, pair<char, int> &b) {\n    if ((a.first < b.first) || (a.first == b.first && a.second > b.second))\n        a = b;\n}\n\npair<char, int> Solve(int idx, int money) {\n    if (idx == n)\n        return pair<char, int>(0, 0);\n\n    auto &opt = memo[idx][money];\n    if (opt.second != -1)\n        return opt;\n\n    // idx?????????????????§????????????\n    opt = Solve(idx + 1, money);\n\n    // idx?????????????????§??????\n    if (0 < (p[idx] % 1000) && (p[idx] % 1000) <= 500) {\n        // 1000????????§?????????\n        int res = 1000 - (p[idx] % 1000) - 500 + money;\n        auto tmp = Solve(idx + 1, res);\n        tmp.first += 1;\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n    else if (p[idx] % 1000 == 0) {\n        if (500 <= money) {\n            int res = money - 500;\n            auto tmp = Solve(idx + 1, res);\n            tmp.first += 1;\n            tmp.second += p[idx];\n            Change(opt, tmp);\n        }\n    }\n    else if (500 <= money + 1000 - (p[idx] % 1000)) {\n        // 1000????????¨?°????money??§?????????\n        int res = money + 1000 - (p[idx] % 1000) - 500;\n        auto tmp = Solve(idx + 1, res);\n        tmp.first += 1;\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n    else {\n        // 1000??????????????§?????????\n        int res = 1000 - (p[idx] % 1000) + money;\n        auto tmp = Solve(idx + 1, res);\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n\n    return opt;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n, n) {\n        for (int i = 0; i < n; ++i)\n            cin >> p[i];\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n * 500; ++j)\n                memo[i][j] = pair<char, int>(0, -1);\n\n        auto res = Solve(0, 0);\n        cout << (int)res.first << ' ' << res.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(long long i=0;i<n;i++)\n#define REP1(i,n) for(long long i=1;i<=n;i++)\n#define REP2D(i,j,h,w) for(long long i=0;i<h;i++) for(long long j=0;j<w;j++)\n#define REP2D1(i,j,h,w) for(long long i=1;i<=h;i++) for(long long j=1;j<=w;j++)\n#define PER(i,n) for(long long i=((n)-1);i>=0;i--)\n#define PER1(i,n) for(long long i=(n);i>0;i--)\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define FORE(i,a,b) for(long long i=(a);i<=(b);i++)\n#define ITE(arr) for(auto ite=(arr).begin();ite!=(arr).end();++ite)\n#define ALL(a) (a.begin()),(a.end())\n#define RAN(a) (a),(a+sizeof(a)/sizeof(a[0]))\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define YNPRT(b) cout<<((b)?\"Yes\":\"No\")<<endl\n#define REV(arr) reverse(ALL(arr))\n#define PRT(a) cout<<a<<endl;\n#define PRTLST(arr,num) REP(_i,num) cout<<_i<<\" - \"<<arr[_i]<<endl;\n#define PRTLST2(arr2,d1,d2) REP(_i,d1) REP(_j,d2) cout<<_i<<\",\"<<_j<<\" : \"<<arr2[_i][_j]<<endl;\n#define PRTLST2D(arr2,d1,d2) do{cout<<\"L\\t\";REP(_i,d2) cout<<_i<<\"\\t\"; cout<<endl; REP(_i,d1){cout<<_i<<\"\\t\";REP(_j,d2){cout<<arr2[_i][_j]<<\"\\t\";}cout<<endl;}}while(0);\n#define MIN(target,v1) (target)=min(target,v1)\n#define MAX(target,v1) (target)=max(target,v1) \n#define P1 first\n#define P2 second\n#define PB push_back\n#define UB upper_bound\n#define LB lower_bound\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int INF_INT = 2147483647;\nconst ll INF_LL = 9223372036854775807LL;\nconst ull INF_ULL = 18446744073709551615Ull;\nconst ll P = 92540646808111039LL;\nconst int Move[4][2] = {-1,0,0,1,1,0,0,-1};\nconst int Move_[8][2] = {-1,0,-1,-1,0,1,1,1,1,0,1,-1,0,-1,-1,-1};\n\n//---------------------\n#define MAXN 101\n#define INF (1<<20)\n//---------------------\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p) {os<<\"( \"<<p.P1<<\" , \"<<p.P2<<\" )\";return os;}\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& v) {ITE(v) os << (ite-v.begin()) << \" : \" << *ite <<endl;return os;}\n\nbool Cmp(const pii& a, const pii& b){\n\treturn a.P1==b.P1 ? a.P2>b.P2 : a.P1<b.P1 ; \n}\n\nint n,p[MAXN];\npii dp[2][MAXN*499];\n\n\nbool init(){\n\tZERO(p);\n\tREP2D(i,j,2,MAXN*499) dp[i][j]=pii(0,INF);\n\tcin>>n;\n\tif(n==0) return false;\n\tREP1(i,n) cin>>p[i];\n\t\n\t//sort(p+1,p+n+1,mycmp);\n\t\n\treturn true;\n}\n\nvoid maxopr(pii& a, pii b){\n\tif(Cmp(a,b)) a=b;\n}\n\nint main(){\n\twhile(init()){\n\t  \tdp[1][0]=pii(0,0); // not buy\n\t  \tint firstchange=(1000-(p[1]%1000))%1000; \n\t  \tmaxopr(dp[1][firstchange%500],pii(firstchange/500,p[1])); // buy & 1000\n\t\tfor(int i=1;i<=n-1;i++){\n\t\t\tint cur=i%2;\n\t\t\tint next=1-cur;\n\t\t\tREP(j,MAXN*499){\n\t\t\t\tif(dp[cur][j].P2>=INF) continue;\n\t\t\t\tpii curdp=dp[cur][j];\n\t\t\t\tmaxopr(dp[next][j],curdp); // not buy\n\t\t\t\tint change=(1000-(p[i+1]%1000))%1000;\n\t\t\t\tif(change>=500) {maxopr(dp[next][j+change-500],pii(curdp.P1+1,curdp.P2+p[i+1]));} // buy & 1000\n\t\t\t\telse {\n\t\t\t\t\tmaxopr(dp[next][j+change],pii(curdp.P1,curdp.P2+p[i+1])); // buy & 1000\n\t\t\t\t\tif(j>=500-change) maxopr(dp[next][j-(500-change)],pii(curdp.P1+1,curdp.P2+p[i+1])); // buy & change\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpii ret=dp[n%2][0];\n\t\tREP(j,MAXN*499) {if(dp[n%2][j].P2>=INF) continue; maxopr(ret,dp[n%2][j]);}\n\t\tcout<<ret.P1<<\" \"<<ret.P2<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint dp[101][501][501];\n\nint roundup(int v){\n\treturn (v + 999) / 1000 * 1000;\n}\n\nbool solve(){\n  int INF = 5000 * 1000;\n  int n;\n  cin >> n;\n  if (n == 0)\n \treturn true;\n  vector<int> P(n);\n  for (auto &p: P) cin >> p;\n  for (auto &i: dp){\n  \tfor (auto &j: i){\n      for (auto &k: j){\n      \tk = -INF;\n      }\n    }\n  }\n  \n  int max_500 = 0;\n  dp[0][0][0] = 0;\n  \n  for (int i = 0; i < n; i++){\n    for (int j = 0; j < 501; j++){\n      for (int k = 0; k < 501; k++){\n        if (dp[i][j][k] < 0) continue;\n        dp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k]);\n        int change = min(dp[i][j][k], 999 - (roundup(P[i]) - P[i]));\n        int pay = roundup(P[i]) + change;\n        int next = dp[i][j][k] + roundup(P[i]) - P[i];\n        if (pay - P[i] >= 500){\n          dp[i + 1][j + roundup(P[i]) / 1000][k + 1] = max(dp[i + 1][j + roundup(P[i]) / 1000][k + 1], next - 500);\n          max_500 = max(max_500, k + 1);\n        }\n        else\n          dp[i + 1][j + roundup(P[i]) / 1000][k] = max(dp[i + 1][j + roundup(P[i]) / 1000][k] , next);\n      }\n    }\n  }\n  \n  int ans = INF;\n  for (int i = 0; i < 501; i++)\n    ans = min(ans, i * 1000 - dp[n][i][max_500] - 500 * max_500);\n  \n  cout << max_500 << \" \" << ans << endl;;\n  \n  return false;\n  \n  \n}\n\nint main(){\n\twhile (true){\n    \tif (solve())\n          break;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n\nconst int N=100;\n\nint n;\nint p[N];\nint DP[N+3][N+3][N*5+3];//[店][500円玉枚数][使った1000円札枚数] = 小銭 の最大化\n\nvoid init_dp(){\n    REP(i,N+3){\n        REP(j,N+3){\n            REP(k,N*5+3){\n                DP[i][j][k] = -1;\n            }\n        }\n    }\n}\n\nvoid print_dp(int n){\n    REP(i,n){\n        REP(j,n){\n            REP(k,n*5){\n                if(DP[i][j][k]!=-1){\n                    cout<<\"i:\"<<i<<\" j:\"<<j<<\" k:\"<<k<<\" dp:\"<<DP[i][j][k]<<endl;\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    while(true){\n        cin>>n;\n        if(n==0){\n            break;\n        }\n        REP(i,n){\n            cin>>p[i];\n        }\n\n        init_dp();\n\n        int pr=p[0];\n\n        int maxgo=0;//500円玉の最大枚数\n\n        //店0\n        //買う\n        if((pr-1)%1000 <500){\n            DP[0][1][(pr-1)/1000 +1] = ((pr-1)/1000 +1)*1000 - pr - 500;\n        } else {\n            DP[0][0][(pr-1)/1000 +1] = ((pr-1)/1000 +1)*1000 - pr;\n        }\n        //買わない\n        DP[0][0][0] = 0;\n\n        //店1以降\n        for(int i=0;i<n-1;++i){\n            pr=p[i+1];\n            REP(j,N){//500円玉の数\n                REP(k,N*5){//1000円札の枚数\n                    int now = DP[i][j][k];\n                    if( now != -1){\n                        //買う場合\n                        //1〜500円\n                        if((pr-1)%1000 <500){\n                            DP[i+1][j+1][k + (pr-1)/1000 +1] = max(now + ((pr-1)/1000 +1)*1000 - pr - 500, DP[i+1][j+1][k + (pr-1)/1000 +1]);\n                            maxgo=max(maxgo,j+1);\n                        }\n                        //0円, 501〜999円\n                        //残金込で500円が作れる場合\n                        else if( 1000*((pr-1)/1000 + 1) - pr + DP[i][j][k] >= 500 ){\n                            DP[i+1][j+1][k + pr/1000 +1] = max(now -( (pr%1000) - 500 ), DP[i+1][j+1][k + pr/1000 +1]);\n                            maxgo=max(maxgo,j+1);\n                        }\n                        //500円が作れない場合\n                        else {\n                            DP[i+1][j][k + (pr-1)/1000 + 1] = max(now + ((pr-1)/1000 +1)*1000 - pr, DP[i+1][j][k + (pr-1)/1000 + 1]);\n                        }\n\n                        //買わない場合\n                        DP[i+1][j][k] = max(now, DP[i+1][j][k]); \n                    }\n                }\n            }\n        }\n        //print_dp(n);\n        int used = 5*N*1000;\n        REP(k, N*5){\n            if(DP[n-1][maxgo][k] != -1){\n                used = min(used, k*1000 - DP[n-1][maxgo][k] - 500*maxgo);\n            }\n        }\n        cout<<maxgo<<\" \"<<used<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// finish date: 2018/06/21\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <map>\n#include <climits>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i, a, b) for(int (i)=a;(i)<(b);(i)++)\n#define rep(i, n)  FOR(i,0,n)\n#define ll long long\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vvvi vector<vector<vector<int>>>\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vd vector<double>\n#define vvd vector<vector<double>>\n#define vb vector<bool>\n#define vvb vector<vector<bool>>\n#define vs vector<string>\n#define vc vector<char>\n#define vvc vector<vector<char>>\n#define pii pair<int,int>\nconst int bigmod = 1000000007;\n#define INF 1050000000\n\n\nint main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        vi p(n);\n        rep(i, n) {\n            cin >> p[i];\n        }\n        int maxDP = n * 5000;\n        vector<pii > DP(maxDP, pii(-1, -1));\n        DP[0] = pii(0, 0);\n        rep(i, n) {\n            int otsuri = 1000 - p[i] % 1000;\n            if (otsuri == 1000) otsuri = 0;\n            for (int j = maxDP - 1; j >= 0; j--) {\n                if (DP[j] == pii(-1, -1)) continue;\n                bool con1 = DP[j + otsuri].first < DP[j].first;\n                bool con2 = DP[j + otsuri].first == DP[j].first;\n                bool con3 = DP[j + otsuri].second > DP[j].second + p[i];\n                if (con1 || (con2 && con3)) {\n                    DP[j + otsuri] = DP[j];\n                    DP[j + otsuri].second += p[i];\n                }\n            }\n            rep(j,maxDP){\n                if (DP[j] == pii(-1, -1)) continue;\n                if (j >= 500) {\n                    bool con1 = DP[j - 500].first < DP[j].first + 1;\n                    bool con2 = DP[j - 500].first == DP[j].first + 1;\n                    bool con3 = DP[j - 500].second > DP[j].second;\n                    if (con1 || (con2 && con3)) {\n                        DP[j - 500] = DP[j];\n                        DP[j - 500].first++;\n                    }\n                }\n            }\n        }\n        int ma = -1;\n        int ansMoney = 0;\n        rep(i, maxDP) {\n            if (DP[i].first > ma || (DP[i].first == ma && DP[i].second < ansMoney)) {\n                ma = DP[i].first;\n                ansMoney = DP[i].second;\n            }\n        }\n        cout << ma << \" \" << ansMoney << endl;\n\n    }\n\n\n    return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nP dp[101][50001];\n\nvoid Max(P &a,P b){a=max(a,b);}\n\nint main(){\n  int n,p[101];\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>p[i];\n  \n    memset(dp,-1,sizeof(dp));\n    dp[0][0]=P(0,0);\n  \n    for(int i=0;i<n;i++)\n      for(int j=0;j<50000;j++){\n\tif(dp[i][j]==P(-1,-1))continue;\n\tint coin=dp[i][j].first;\n\tint ncost=dp[i][j].second-p[i];\n\tMax(dp[i+1][j],dp[i][j]);\n\tif(p[i]%1000<=500&&p[i]%1000)Max(dp[i+1][j+(1000-p[i]%1000)%500],P(coin+1,ncost));\n\tif(p[i]%1000==0&&j>=500) Max(dp[i+1][j-500],P(coin+1,ncost));\n\t\n\tif(p[i]%1000>500) {\n\t  if(j>=p[i]%500)Max(dp[i+1][j-p[i]%500],P(coin+1,ncost));\n\t  else Max(dp[i+1][j+(500-p[i]%500)],P(coin,ncost));\n\t}\n      }\n  \n  \n    P ans=P(0,0);\n    for(int i=0;i<50000;i++)Max(ans,dp[n][i]);\n    cout <<ans.first<<\" \"<<-ans.second<<endl;\n    \n  }\t\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 99999999\nusing namespace std;\n\ntypedef struct{\n  int v;\n  int cha;\n}souv;\ntypedef struct{\n  int v;\n  int cnt;\n  bool use[105];\n}dp;\n\nsouv memo[105];\ndp ans[105][51005];\nint n;\nvoid solve();\nvoid infset();\n\nint main(){\n  int answer=0;\n  int i;\n  while(1){\n    vector<int> dummy;\n    cin >> n;\n    if(n==0)break;\n    answer=0;\n    for(i=0;i<n;i++){\n      cin >> memo[i].v;\n      memo[i].cha=1000-(memo[i].v%1000);\n      if(memo[i].cha==1000){\n\tmemo[i].cha=0;\n\t//dummy.push_back(memo[i].v);\n      }\n    }\n    infset();\n    solve();\n    //for(int j=0;j<=n*500;j++)if(ans[n][j]!=inf)cout <<n << \" \"<<j <<\" \"<< ans[n][j] <<endl;\n    //cout << ans[n][1500] << endl;\n    for(i=0;i<=(n+2)*500;i++){\n      if(ans[n][i].v==inf)continue;\n      if(i/500>answer/500)answer=i;\n      else if((i/500==answer/500)&&ans[n][i].v<ans[n][answer].v)answer=i;\n      //break;\n    }\n    if(!dummy.empty())sort(dummy.begin(),dummy.end());\n    //cout << ans[n][answer].cnt;\n    //for(i=0;i<n;i++)cout<< ans[n][answer].use[i]<<\" \";\n    for(i=0;i<n;i++)if(!ans[n][answer].use[i])dummy.push_back(memo[i].v);\n    if(!dummy.empty())sort(dummy.begin(),dummy.end());\n    i=0;\n    //cout << ans[n][answer].cnt <<\" \"<< answer <<\" \" <<n;\n    while(answer/500>ans[n][answer].cnt&&n>ans[n][answer].cnt){\n      //cout << dummy[i];\n      ans[n][answer].v+=dummy[i];\n      ans[n][answer].cnt++;\n      i++;\n    }\n    cout << min(n,answer/500) << \" \" << ans[n][answer].v << endl;\n  }\n  return 0;\n}\n\nvoid solve(){\n  int i,j;\n  for(i=0;i<n;i++)for(j=0;j<=(n+2)*500;j++){\n      //cout << j << \" \" << memo[i].cha<<endl;\n      if(j<memo[i].cha){\n\tans[i+1][j]=ans[i][j];\n      }\n      else {\n\t//ans[i+1][j].v=min(ans[i][j].v,ans[i][j-memo[i].cha].v+memo[i].v);\n\tif(ans[i][j].v<=ans[i][j-memo[i].cha].v+memo[i].v)ans[i+1][j]=ans[i][j];\n\telse {\n\t  ans[i+1][j]=ans[i][j-memo[i].cha];\n\t  ans[i+1][j].v+=memo[i].v;\n\t  ans[i+1][j].cnt++;\n\t  ans[i+1][j].use[i]=1;\n\t}\n      }  \n    }\n}\nvoid infset(){\n  int i,j;\n  ans[0][0].cnt=0;\n  ans[0][0].v=0;\n  for(i=0;i<n;i++)ans[0][0].use[i]=0;\n  for(j=1;j<=(n+2)*500;j++){\n    ans[0][j].v=inf;\n    ans[0][j].cnt=-1;\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define M 25000\n\nint dp[2][101][M];\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int p[100],pp[100];\n    for(int i=0;i<n;i++)cin>>p[i],pp[i]=(1000-p[i]%1000)%1000;\n\n    for(int i=0;i<2;i++)\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<M;k++)dp[i][j][k]=1e9;\n    \n    dp[0][0][0]=0;\n\n    for(int i=0;i<n;i++){\n      int ni=(i+1)%2,I=i%2;\n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<min(M,2*M*(i+1)/n);k++)dp[ni][j][k]=1e9;\n      \n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<min(M,2*M*(i+1)/n);k++){\n\t  int np=k+pp[i];\n\t  int nj=j;\n\t  if(np>=500)nj++,np-=500;\n\t  np=min(M-1,np);\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t  dp[ni][j][k]=min(dp[ni][j][k],dp[I][j][k]);\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t}\n    }\n    \n    int c=0,s=0;\n    for(int i=1;i<=n;i++)\n      for(int j=0;j<M;j++)\n\tif(dp[n%2][i][j]!=1e9&&i>=c){\n\t  if(c==i&&dp[n%2][i][j]<s)s=dp[n%2][i][j];\n\t  else if(c<i)c=i,s=dp[n%2][i][j];\n\t}\n    cout<<c<<\" \"<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nP dp[105][50005];\nint p[100];\nvoid Max(P &a,P b){a=max(a,b);}\nint main(){\n  int n;\n  while(cin>>n && n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++)cin>>p[i];\n    dp[0][0] = P(0,0);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<50000;j++){\n        if(dp[i][j]==P(-1,-1)) continue;\n        int nf=dp[i][j].first,ns=dp[i][j].second-p[i];\n        Max(dp[i+1][j],dp[i][j]);\n        if(p[i]%1000==0)\n          {if(j>=500) Max(dp[i+1][j-500],P(nf+1,ns));}\n        else if(p[i]%1000<500) Max(dp[i+1][j+500-p[i]%500],P(nf+1,ns));\n        else if(p[i]%500<=j) Max(dp[i+1][j-p[i]%500],P(nf+1,ns));\n        Max(dp[i+1][j+1000-p[i]%1000],P(nf,ns)); \n      }\n    }\n    P ans(0,0);\n    for(int i=0;i<50000;i++) Max(ans,dp[n][i]);\n    cout<<ans.first<<\" \"<<-ans.second<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 100100100;\n\nint main(){\n\n    while(1){        \n        int n; cin >> n;\n        if(!n) break;\n        vector<int> a(n);\n        for(int i = 0; i < n; i++) cin >> a[i];\n\n        //i番目までの品物を見て、得られた500円玉がj枚で持ってる小銭がk円の時の消費金額の最小値\n        vector<vector<vector<int> > > dp(n + 1, vector<vector<int> > (n + 1, vector<int> (500 * n + 1000, INF)));  \n        dp[0][0][0] = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j <= i; j++){\n                for(int k = 0; k <= 500 * n; k++){\n\n                    //買わない\n                    dp[i + 1][j][k] = min(dp[i + 1][j][k], dp[i][j][k]);\n\n                    //1000で割ったあまりによる場合わけ\n                    if(1 <= a[i] % 1000 && a[i] % 1000 <= 500){\n                        //1000札のみで払うのが最適\n                        //500円獲得\n                        dp[i + 1][j + 1][(500 - a[i] % 1000) + k] = min(dp[i + 1][j + 1][(500 - a[i] % 1000) + k], dp[i][j][k] + a[i]);\n                    }else{\n                        //1000円札のみで払う\n                        //500円玉は獲得できない\n                        dp[i + 1][j][(1000 - a[i] % 1000) % 1000 + k] = min(dp[i + 1][j][(1000 - a[i] % 1000) % 1000 + k], dp[i][j][k] + a[i]);\n\n                        //小銭を駆使して500円玉を獲得\n                        int need = a[i] % 1000 - 500;\n                        if(need == -500) need = 500;\n                        if(k - need >= 0) dp[i + 1][j + 1][k - need] = min(dp[i + 1][j + 1][k - need], dp[i][j][k] + a[i]);\n                    }\n                }\n            }\n\n        }\n\n        int ans1 = 0, ans2 = INF;\n        for(int j = 0; j <= n; j++){\n            for(int k = 0; k <= 500 * n; k++){\n                if(dp[n][j][k] != INF){\n                    if(ans1 < j || (ans1 == j && ans2 > dp[n][j][k])){\n                        ans1 = j;\n                        ans2 = dp[n][j][k];\n                    }\n                }\n            }\n        }\n\n        cout << ans1 << \" \" << ans2 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nP dp[105][50005];\nint p[100];\nint main(){\n  int n;\n  while(cin>>n && n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++)cin>>p[i];\n    dp[0][0] = P(0,0);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<50000;j++){\n        if(dp[i][j]==P(-1,-1)) continue;\n        int nf=dp[i][j].first,ns=dp[i][j].second;\n        if(p[i]%1000==0) {\n          if(j>=500) dp[i+1][j-500]=P(nf+1,ns-p[i]);\n          else dp[i+1][j] = P(nf,ns);\n        }\n        else if(p[i]%1000<500) dp[i+1][j+500-p[i]%500]=P(nf+1,ns-p[i]);\n        else if(p[i]%500<=j) dp[i+1][j-p[i]%500] = P(nf+1,ns-p[i]);\n        else{\n          dp[i+1][j+1000-p[i]%1000] = P(nf,ns-p[i]);\n          dp[i+1][j] = P(nf,ns);\n        }\n      }\n    }\n    P ans(0,0);\n    for(int i=0;i<50000;i++) ans=max(ans,dp[n][i]);\n    cout<<ans.first<<\" \"<<-ans.second<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// dp[i][500yen][num_1000yen] := remain ([i] is deleted)\nint dp[128][512];\nint n;\nint P[128];\n\nvoid init() {\n  for(int j = 0; j < 128; ++j) {\n    for(int k = 0; k < 512; ++k) {\n      dp[j][k] = -1;\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d\", &P[i]);\n    }\n    dp[0][0] = 0;\n    for(int i = 0; i < n; ++i) {\n      for(int j = n-1; j >= 0; --j) {\n        for(int k = 512 - 1; k >= 0; --k) {\n          if( dp[j][k] == -1 ) continue;\n          int n1kyen = (P[i] + 999) / 1000;\n          int rem = dp[j][k] + n1kyen * 1000 - P[i];\n          int next_num500yen = j + (rem >= 500 ? 1 : 0);\n          int next_num1kyen  = k + n1kyen;\n          int next_rem       = rem >= 500 ? rem - 500 : rem;\n          int& next = dp[next_num500yen][next_num1kyen];\n          next = std::max(next, next_rem);\n        }\n      }\n    }    \n    int res = (1 << 28);\n    int max = -1;\n    for(int j = n; j >= 0; --j) {\n      for(int k = 0; k < 512; ++k) {\n        if( dp[j][k] == -1 ) continue;\n        int cost = k * 1000 - 500 * j - dp[j][k];\n        res = std::min(res, cost);\n      }\n      if( res != (1 << 28) ) {\n        max = j;\n        break;\n      }\n    }\n    printf(\"%d %d\\n\", max, res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream> \n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>  \nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000000000000000000000001\n#define LONG_INF 10000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define REP(i,n) for(long long i = 0;i < n;++i)\npair<int, int> dp[2][99901];//左から1円,5円,10円,50円,100円\nint main() {\n\twhile (true) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) return 0;\n\t\tfor (int i = 1; i < 99901; ++i) {\n\t\t\tdp[0][i] = make_pair(-1000, 0);\n\t\t\tdp[1][i] = make_pair(-1000, 0);\n\t\t}\n\t\tdp[0][0] = make_pair(0, 0);\n\t\tdp[1][0] = make_pair(0, 0);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint now = 0;\n\t\t\tscanf(\"%d\", &now);\n\t\t\tfor (int j = 0; j < 99901; ++j) {\n\t\t\t\tif (dp[i % 2][j].first >= 0) {\n\t\t\t\t\tif (now % 1000 <= 500&&now % 1000 != 0) {\n\t\t\t\t\t\tint ok = 0;\n\t\t\t\t\t\tif (dp[(i + 1) % 2][j + 500 - now % 1000].first < dp[i % 2][j].first + 1) {\n\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dp[(i + 1) % 2][j + 500 - now % 1000].first == dp[i % 2][j].first+1 && dp[(i + 1) % 2][j + 500 - now % 1000].first > dp[i % 2][j].second + now) {\n\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok == 1) {\n\t\t\t\t\t\t\tdp[(i + 1) % 2][j + 500 - now % 1000] = make_pair(dp[i % 2][j].first + 1, dp[i % 2][j].second + now);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t//not taking\n\t\t\t\t\t\tint ok = 0;\n\t\t\t\t\t\t\tint itr = j + (1000 - now % 1000) % 1000;\n\t\t\t\t\t\t\tif (dp[(i + 1) % 2][itr].first < dp[i % 2][j].first) {\n\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (dp[(i + 1) % 2][itr].first == dp[i % 2][j].first && dp[(i + 1) % 2][itr].first > dp[i % 2][j].second + now) {\n\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ok == 1) {\n\t\t\t\t\t\t\t\tdp[(i + 1) % 2][itr] = make_pair(dp[i % 2][j].first, dp[i % 2][j].second + now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\titr = j;\n\t\t\t\t\t\t\tif (dp[(i + 1) % 2][itr].first < dp[i % 2][j].first)ok = 1;\n\t\t\t\t\t\t\telse if (dp[(i + 1) % 2][itr].first == dp[i % 2][j].first && dp[(i + 1) % 2][itr].second > dp[i % 2][j].second) ok = 1;\n\t\t\t\t\t\t\tif (ok == 1) dp[(i + 1) % 2][itr] = dp[i % 2][j];\n\t\t\t\t\t\t\titr = j - (now % 1000 + 500) % 1000;\n\t\t\t\t\t\t\tif (itr < 0) continue;\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tif (dp[(i + 1) % 2][itr].first < dp[i % 2][j].first + 1) ok = 1;\n\t\t\t\t\t\t\tif (dp[(i + 1) % 2][itr].first == dp[i % 2][j].first + 1 && dp[(i + 1) % 2][itr].second >= dp[i % 2][j].second + now) {\n\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ok == 1) {\n\t\t\t\t\t\t\t\tdp[(i + 1) % 2][itr] = make_pair(dp[i % 2][j].first + 1, dp[i % 2][j].second + now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int, int> ans = make_pair(0, 0);\n\t\tfor (int i = 0; i < 99901; ++i) {\n\t\t\tint ok = 0;\n\t\t\tif (ans.first < dp[n % 2][i].first) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t\tif (ans.first == dp[n % 2][i].first && ans.second > dp[n % 2][i].second) ok = 1;\n\t\t\tif (ok == 1) {\n\t\t\t\tans = dp[n % 2][i];\n\t\t\t}\n\t\t}\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\n#define MAX_C 100001\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nint m[MAX_N];\npii dp[2][MAX_C];\n\nvoid set_m(vector<int> &p)\n{\n    for (int i = 0; i < (int)p.size(); i++) {    \n        m[i] = ((p[i] - 1) / 1000 + 1) * 1000;\n    }\n}\n\nvoid update(pii &a, pii &b)\n{\n    if (a.first < b.first) {\n        a = b;\n    } else if (a.first == b.first) {\n        if (a.second > b.second) {\n            a = b;\n        }\n    }\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<int> p(N);\n        for (int i = 0; i < N; i++) {\n            cin >> p[i];\n        }\n        \n        set_m(p);\n        \n        memset(dp, -1, sizeof(dp));\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < MAX_C; j++) {\n                dp[i][j] = pii(-1, INF);\n            }\n        }\n        \n        dp[0][0] = pii(0, 0);\n        for (int i = 0; i < N; i++) {\n            int curr = (i & 1), next = !(i & 1);\n            for (int j = 0; j < MAX_C; j++) {\n                if (dp[curr][j].first == -1) continue;\n                \n                update(dp[next][j], dp[curr][j]);\n                \n                {\n                    int pay = m[i];\n                    int change = pay - p[i];                    \n\n                    int _500 = (change / 500);\n                    int nc = j + change - _500 * 500;                    \n                    \n                    pii ncost = pii(dp[curr][j].first + _500,\n                                    dp[curr][j].second + p[i]);                    \n                    \n                    update(dp[next][nc], ncost);\n                }\n                \n                {\n                    int pp = p[i] % 1000;\n                    if (pp > 500) {\n                        if (pp - 500 <= j) {\n                            int pay = m[i] + (pp - 500);\n                            int change = pay - p[i];\n                            int _500 = (change / 500);\n                            int nc = j - (pp - 500) + change - _500 * 500;\n                            \n                            pii ncost = pii(dp[curr][j].first + _500,\n                                            dp[curr][j].second + p[i]);                    \n                    \n                            update(dp[next][nc], ncost);\n                        }\n                    } else if (pp == 0) {\n                        if (500 <= j) {\n                            int pay = m[i] + (500);\n                            int change = pay - p[i];\n                            int _500 = (change / 500);\n                            int nc = j - (500) + change - _500 * 500;\n                            \n                            pii ncost = pii(dp[curr][j].first + _500,\n                                            dp[curr][j].second + p[i]);                    \n                    \n                            update(dp[next][nc], ncost);\n                        }\n                    }\n                }\n            }\n            \n            for (int j = 0; j < MAX_C; j++) {\n                dp[curr][j] = pii(-1, INF);\n            }\n        }\n        \n        pii res = pii(-1, INF);\n        for (int i = 0; i < MAX_C; i++) {\n            update(res, dp[N&1][i]);            \n        }\n        cout << res.first << \" \" << res.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define rep(i, n) for (signed i = 0; i < signed(n); i++)\n#define REP(i, s, n) for (signed i = signed(s); i < signed(n); i++)\n#define rrep(i, n) for (signed i = signed(n) - 1; i >= 0; i--)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nconst int M = 25001;\nint dp[M][101];\nint buf[M][101];\nvoid calc() {\n\tint n;\n\tconst int inf = 1 << 29;\n\twhile (cin >> n && n) {\n\t\tfill(dp[0], dp[25001], inf);\n\t\tfill(buf[0], buf[25001], inf);\n\t\tbuf[0][0] = dp[0][0] = 0;\n\t\trep(i, n) {\n\t\t\tint p; cin >> p;\n\t\t\tint m = p % 1000;\n\t\t\tint rm = (1000 - m) % 1000;\n\t\t\trrep(k, n) rep(j, M) if (dp[j][k] < inf) {\n\t\t\t\tif (m == 0) {\n\t\t\t\t\tif (j >= 500) {\n\t\t\t\t\t\tminup(buf[min(M, j - 500ll)][k + 1], dp[j][k] + p);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (m <= 500) {\n\t\t\t\t\tminup(buf[min(M, j + 500 - m)][k + 1], dp[j][k] + p);\n\t\t\t\t} else {\n\t\t\t\t\tminup(buf[min(M, j + rm)][k], dp[j][k] + p);\n\t\t\t\t\tint sub = m - 500;\n\t\t\t\t\tif (j >= sub) {\n\t\t\t\t\t\tminup(buf[min(M, j - sub)][k + 1], dp[j][k] + p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(k, n + 1) rep(j, M) dp[j][k] = buf[j][k];\n\t\t}\n\t\tint ans = inf;\n\t\tint cnt = 0;\n\t\trep(i, M) rep(j, n + 1) if (dp[i][j] < inf) {\n\t\t\tif (j == cnt) minup(ans, dp[i][j]);\n\t\t\tif (j > cnt) {\n\t\t\t\tans = dp[i][j];\n\t\t\t\tcnt = j;\n\t\t\t}\n\t\t}\n\t\tif (cnt == 0) cout << \"0 0\" << endl;\n\t\telse cout << cnt << \" \" << ans << endl;\n\t}\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcalc();\n#ifdef _MSC_VER\n\tsystem(\"pause\");\n#endif\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 100100100;\n\nint main(){\n\n    while(1){        \n        int n; cin >> n;\n        if(!n) break;\n        vector<int> a(n);\n        for(int i = 0; i < n; i++) cin >> a[i];\n\n        //i番目までの品物を見て、得られた500円玉がj枚で持ってる小銭がk円の時の消費金額の最小値\n        vector<vector<vector<int> > > dp(2, vector<vector<int> > (n + 1, vector<int> (500 * n + 1000, INF)));  \n        dp[0][0][0] = 0;\n        int now = 0;\n        int next = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j <= i; j++){\n                for(int k = 0; k <= 500 * i; k++){\n\n                    int r = a[i] % 1000;\n                    //買わない\n                    dp[next][j][k] = min(dp[next][j][k], dp[now][j][k]);\n\n                    //1000で割ったあまりによる場合わけ\n                    if(1 <= r && r <= 500){\n                        //1000札のみで払うのが最適\n                        //500円獲得\n                        dp[next][j + 1][(500 - r) + k] = min(dp[next][j + 1][(500 - r) + k], dp[now][j][k] + a[i]);\n                    }else{\n                        //小銭を駆使して500円玉を獲得\n                        int need = r - 500;\n                        if(need == -500) need = 500;\n                        if(k - need >= 0) dp[next][j + 1][k - need] = min(dp[next][j + 1][k - need], dp[now][j][k] + a[i]);\n                        else{\n                            //1000円札のみで払う\n                            //500円玉は獲得できない\n                            dp[next][j][(1000 - r) % 1000 + k] = min(dp[next][j][(1000 - r) % 1000 + k], dp[now][j][k] + a[i]);\n                        }\n                        \n                    }\n                }\n            }\n            swap(now, next);\n        }\n\n        int ans1 = 0, ans2 = INF;\n        for(int j = 0; j <= n; j++){\n            for(int k = 0; k <= 500 * n; k++){\n                if(dp[now][j][k] != INF){\n                    if(ans1 < j || (ans1 == j && ans2 > dp[now][j][k])){\n                        ans1 = j;\n                        ans2 = dp[now][j][k];\n                    }\n                }\n            }\n        }\n\n        cout << ans1 << \" \" << ans2 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\n\nvoid solve() {\n    vector<int> v(N);\n    for (auto& i : v) cin >> i;\n\n    vector<vector<map<int,int> > > dp(N + 1, vector<map<int,int> >(N + 1));\n    dp[0][0][0] = 0;\n    for (int i = 0; i < N; i++) {\n        int payment = v[i];\n        for (int j = 0; j <= i; j++) {\n            for (auto p : dp[i][j]) {\n                int coins = p.first;\n                int cost = p.second;\n\n                if (dp[i+1][j].find(coins) == dp[i+1][j].end()) dp[i+1][j][coins] = cost;\n                else dp[i+1][j][coins] = min(dp[i+1][j][coins], cost);\n\n                int sub = payment % 1000;\n                if (0 < sub && sub <= 500) {\n                    if (dp[i+1][j+1].find(coins + 500 - sub) != dp[i+1][j+1].end())\n                        dp[i + 1][j + 1][coins + 500 - sub]\n                            = min(dp[i + 1][j + 1][coins + 500 - sub], cost + payment);\n                    else\n                        dp[i + 1][j + 1][coins + 500 - sub] = cost + payment;\n                } else {\n                    if (sub == 0) sub = 500;\n                    else sub = sub - 500;\n                    if (sub <= coins) {\n                        int coins_ = coins - sub;\n                        if (dp[i+1][j+1].find(coins_) != dp[i+1][j+1].end())\n                            dp[i + 1][j + 1][coins_] = min(dp[i+1][j+1][coins_], cost + payment);\n                        else\n                            dp[i + 1][j + 1][coins_] = cost + payment;\n                    }\n\n                    if (dp[i+1][j].find(coins + ((1000 - (payment % 1000)) % 1000)) != dp[i+1][j].end())\n                        dp[i + 1][j][coins + ((1000 - (payment % 1000)) % 1000)]\n                            = min(dp[i+1][j][coins + ((1000 - (payment % 1000)) % 1000)], cost + payment);\n                    else\n                        dp[i + 1][j][coins + ((1000 - (payment % 1000)) % 1000)] = cost + payment;\n                }\n            }\n        }\n    }\n    int ans = 1 << 28, count = 0;\n    for (int i = N; i > -1; i--) {\n        if (count > 0) break;\n        if (dp[N][i].size() == 0) continue;\n        count = i;\n        for (auto p : dp[N][i]) {\n            ans = min(p.second, ans);\n        }\n    }\n    cout << count << \" \" << ans << endl;\n}\n\nint main() {\n    while (cin >> N, N) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint n;\nvi p;\npii dp[101][55555];\n\npii solve(int shop, int coin)\n{\n\tif (shop == n) return pii(0, 0);\n\tif (dp[shop][coin].first >= 0) return dp[shop][coin];\n\tpii res(0, 0);\n\tchmax(res, solve(shop + 1, coin));\n\tpii tmp;\n\tif (p[shop] % 1000 == 0)\n\t{\n\t\tif (coin >= 500)\n\t\t{\n\t\t\ttmp = solve(shop + 1, coin - 500);\n\t\t\tchmax(res, pii(tmp.first + 1, tmp.second - p[shop]));\n\t\t}\n\t}\n\telse if (p[shop] % 1000 > 500)\n\t{\n\t\ttmp = solve(shop + 1, coin + 1000 - p[shop] % 1000);\n\t\tchmax(res, pii(tmp.first, tmp.second - p[shop]));\n\t\tif (p[shop] % 1000 - 500 <= coin)\n\t\t{\n\t\t\ttmp = solve(shop + 1, coin - (p[shop] % 1000 - 500));\n\t\t\tchmax(res, pii(tmp.first + 1, tmp.second - p[shop]));\n\t\t}\n\t}\n\telse\n\t{\n\t\ttmp = solve(shop + 1, coin + 500 - p[shop] % 1000);\n\t\tchmax(res, pii(tmp.first + 1, tmp.second - p[shop]));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\twhile (cin >> n, n)\n\t{\n\t\tp.resize(n);\n\t\tREP(i, n) cin >> p[i];\n\t\tREP(i, 101)REP(j, 55555) dp[i][j] = pii(-1, -1);\n\t\tpii ans = solve(0, 0);\n\t\tcout << ans.first << \" \" << -ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint n;\nint dp[101][540005];\n//bool me[101][540005]={0};\nsigned main(){\n\tint u=10000000;\n\twhile(1){\n\tcin>>n;\n\t\tif(n==0) break;\n\t\tint zx=-9000000;\n\t\tfor(int i=0;i<=100;i++)for(int j=0;j<540005;j++){\n\t\t\tdp[i][j]=zx;\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tdp[0][0]=0;\n\t\t\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint p,pq;\n\t\t\tcin>>p;\n\t\t\tpq=p;\n\t\t\tp%=1000;\n\t\t\t\n\t\t\tif(p==0) p+=1000;\n\t\t\tfor(int j=0;j<540005;j++){\n\t\t\t\tif(dp[i-1][j]==zx) continue;\n\t\t\t\n\t\t\t\tif(dp[i][j]<dp[i-1][j]) dp[i][j]=dp[i-1][j];\n\t\t\t\tif(p>500){\n\t//\t\t\t\tme[i][j+(1000-p)]=1;\n\t\t\t\t\tif(dp[i][j+(1000-p)]<dp[i-1][j]-pq) dp[i][j+(1000-p)]=dp[i-1][j]-pq;\n\t\t\t\t}\n\t\t\t\telse{\n\t//\t\t\t\tme[i][j+(1000-p-500)]=1;\n\t\t\t\t\tif(dp[i][j+(500-p)]<dp[i-1][j]+u-pq) dp[i][j+(500-p)]=dp[i-1][j]+u-pq;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(p>500){\n\t\t\t\t\tif(j>=p+500-1000){\n\t//\t\t\t\t\tme[i][j-(p-500)]=1;\n\t\t\t\t\t\tif(dp[i][j-(p-500)]<dp[i-1][j]+u-pq) dp[i][j-(p-500)]=dp[i-1][j]+u-pq;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(j>=p+500){\n\t//\t\t\t\t\tme[i][j-(p+500)]=1;\n\t\t\t\t\t\tif(dp[i][j-(p+500)]<dp[i-1][j]+u-pq) dp[i][j-(p+500)]=dp[i-1][j]+u-pq;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=zx;\n\t\tfor(int j=0;j<540005;j++){\n\t\t\tif(dp[n][j]==zx) continue;\n\t\t\tif(dp[n][j]>ans)ans=dp[n][j];\n\t\t}\n\t\n\t\tif(ans%u!=0){\n\t\tcout<<ans/u +1<<\" \"<<u-ans%u<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<ans/u<<\" 0\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define fi first\n#define sc second\n#define mp make_pair\npair<int,int> dp[105][100005];\nint n,p[105];\nvoid chh(pair<int,int> &a,pair<int,int> &b){\n\tif(a.fi < b.fi) a = b;\n\telse if(a.fi == b.fi) a.sc = min(a.sc,b.sc);\n}\nint main(){\n\twhile(1){\n\t\tcin>>n; if(!n) return 0;\n\t\tfor(int i=1;i<=n;i++) cin>>p[i];\n\t\tfor(int i=0;i<105;i++) for(int j=0;j<100005;j++) dp[i][j] = mp(-10000,1000000000);\n\t\tdp[0][0] = mp(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<=1000*i;j++){\n\t\t\t\tif(dp[i][j].fi < 0) continue; //cout <<i << \" \" <<j<< endl;\n\t\t\t\tif(dp[i+1][j].fi < dp[i][j].fi) dp[i+1][j] = dp[i][j];\n\t\t\t\telse if(dp[i+1][j].fi == dp[i][j].sc) dp[i+1][j].sc = min(dp[i+1][j].sc,dp[i][j].sc);\n\t\t\t\t\n\t\t\t\tif(p[i+1]%1000 == 0){\n\t\t\t\t\tif(j>=500){\n\t\t\t\t\t\tpair<int,int> Q=mp(dp[i][j].fi+1,dp[i][j].sc+p[i+1]) ;\n\t\t\t\t\t\tchh(dp[i+1][j-500],Q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(p[i+1]%1000 <= 500){\n\t\t\t\t\tpair<int,int> Q=mp(dp[i][j].fi+1,dp[i][j].sc+p[i+1]) ;\n\t\t\t\t\tchh(dp[i+1][j+500-(p[i+1]%1000)],Q);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(j+500-(p[i+1]%1000)>=0){\n\t\t\t\t\t\tpair<int,int> Q=mp(dp[i][j].fi+1,dp[i][j].sc+p[i+1]) ;\n\t\t\t\t\t\tchh(dp[i+1][j+500-(p[i+1]%1000)],Q);\n\t\t\t\t\t}\n\t\t\t\t\tpair<int,int> Q=mp(dp[i][j].fi,dp[i][j].sc+p[i+1]) ;\n\t\t\t\t\tchh(dp[i+1][j+1000-(p[i+1]%1000)],Q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int,int> ans = mp(-10000,1000000000);\n\t\tfor(int j=0;j<100005;j++){\n\t\t\tif(ans.fi < dp[n][j].fi) ans = dp[n][j];\n\t\t\telse if(ans.fi == dp[n][j].fi) ans.sc = min(ans.sc,dp[n][j].sc);\n\t\t}\n\t\tcout <<ans.fi<<\" \" << ans.sc << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF = 1e9;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nint N;\nvector<int> P;\n\nPII dp[100][50000];\nbool cmp (const PII &l, const PII &r)\n{\n    if (l.first == r.first) return l.second > r.second;\n    return l.first < r.first;\n}\n\n\nPII solve(int n, int x, int sum, int num)\n{\n    if (n == N) return PII(0, 0);\n    if (dp[n][x].first != -1) return dp[n][x];\n\n    PII res = PII(0, INF);\n\n    // ????????????\n    res = max(res, solve(n+1, x, sum, num), cmp);\n\n    // ?°????????????£?????????\n    {\n        int kozeni = (P[n] + 500) % 1000;\n        if (kozeni <= x) {\n            PII tmp = solve(n+1, x-kozeni, sum+P[n], num+1);\n            tmp.first++;\n            tmp.second += P[n];\n            res = max(res, tmp, cmp);\n        }\n    }\n    \n    // ?????????????????£?????????\n    {\n        int kozeni = (1000 - P[n]%1000)%1000;\n        int get = 0;\n        if (kozeni >= 500) {\n            get = 1;\n            kozeni -= 500;\n        }\n\n        PII tmp = solve(n+1, x+kozeni, sum+P[n], num+get);\n        tmp.first += get;\n        tmp.second += P[n];\n        res = max(res, tmp, cmp);\n    }\n\n    return dp[n][x] = res;\n}\n\n\nint main()\n{\n    while (cin >> N, N) {\n        fill(dp[0], dp[0]+100*50000, PII(-1, -1));\n        P.resize(N);\n        rep(i, N) cin >> P[i];\n\n        PII ans = solve(0, 0, 0, 0);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N;\n    vector<int> P;\n    bool input() {\n        cin >> N;\n        if (N == 0) return false;\n        P.clear(); P.resize(N); cin >> P;\n        return true;\n    }\n\n    struct Pair : pair<int,int> {\n        Pair(int a, int b) : pair<int,int>(a, b) {}\n    };\n\n    const int INF = 1<<28;\n    bool operator<(const Pair& a, const Pair& b) {\n        if (a.first == b.first) return a.second > b.second;\n        return a.first < b.first;\n    }\n    Pair max(const Pair& a, const Pair& b) {\n        return (b < a ? a : b);\n    }\n\n    const int MAX_R = 101 * 500 + 5;\n\n    void solve() {\n        vector<vector<Pair>> dp(N + 1, vector<Pair>(MAX_R, Pair(-INF, INF)));\n        dp[0][0] = Pair(0, 0);\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < MAX_R; j++) {\n                const auto& cur = dp[i][j];\n                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);\n                int p = P[i] % 1000;\n                if (p == 0) {\n                    if (j >= 500) {\n                        auto& next = dp[i + 1][j - 500];\n                        next = max(next, Pair(dp[i][j].first + 1, dp[i][j].second + P[i]));\n                    }\n                } else if (p <= 500) {\n                    int nrem = j + (1000 - p) % 500;\n                    auto& next = dp[i + 1][nrem];\n                    next = max(next, Pair(cur.first + 1, cur.second + P[i]));\n                } else {\n                    int d = p % 500;\n                    if (j >= d) {\n                        auto& next = dp[i + 1][j - d];\n                        next = max(next, Pair(cur.first + 1, cur.second + P[i]));\n                    } else {\n                        auto& next = dp[i + 1][j + 1000 - p];\n                        next = max(next, Pair(cur.first, cur.second + P[i]));\n                    }\n                }\n            }\n        }\n        auto ans = Pair(-INF, INF);\n        for (int i = 0; i < MAX_R; i++) {\n            ans = max(ans, dp[N][i]);\n        }\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define fi first\n#define sc second\n#define mp make_pair\npair<int,int> dp[105][50005];\nint n,p[105];\nvoid chh(pair<int,int> &a,pair<int,int> &b){\n\tif(a.fi < b.fi) a = b;\n\telse if(a.fi == b.fi) a.sc = min(a.sc,b.sc);\n}\nint main(){\n\twhile(1){\n\t\tcin>>n; if(!n) return 0;\n\t\tfor(int i=1;i<=n;i++) cin>>p[i];\n\t\tfor(int i=0;i<105;i++) for(int j=0;j<50005;j++) dp[i][j] = mp(-10000,100000000);\n\t\tdp[0][0] = mp(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<=1000*i;j++){\n\t\t\t\tif(dp[i][j].fi < 0) continue; //cout <<i << \" \" <<j<< endl;\n\t\t\t\tif(dp[i+1][j].fi < dp[i][j].fi) dp[i+1][j] = dp[i][j];\n\t\t\t\telse if(dp[i+1][j].fi == dp[i][j].fi) dp[i+1][j].sc = min(dp[i+1][j].sc,dp[i][j].sc);\n\t\t\t\t\n\t\t\t\tif(p[i+1]%1000 == 0){\n\t\t\t\t\tif(j>=500){\n\t\t\t\t\t\tpair<int,int> Q=mp(dp[i][j].fi+1,dp[i][j].sc+p[i+1]) ;\n\t\t\t\t\t\tchh(dp[i+1][j-500],Q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(p[i+1]%1000 <= 500){\n\t\t\t\t\tpair<int,int> Q=mp(dp[i][j].fi+1,dp[i][j].sc+p[i+1]) ;\n\t\t\t\t\tchh(dp[i+1][j+500-(p[i+1]%1000)],Q);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(j+500-(p[i+1]%1000)>=0){\n\t\t\t\t\t\tpair<int,int> Q=mp(dp[i][j].fi+1,dp[i][j].sc+p[i+1]) ;\n\t\t\t\t\t\tchh(dp[i+1][j+500-(p[i+1]%1000)],Q);\n\t\t\t\t\t}\n\t\t\t\t\tpair<int,int> Q=mp(dp[i][j].fi,dp[i][j].sc+p[i+1]) ;\n\t\t\t\t\tchh(dp[i+1][j+1000-(p[i+1]%1000)],Q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int,int> ans = mp(-10000,100000000);\n\t\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<50005;j++){\n\t\t\tif(ans.fi < dp[i][j].fi) ans = dp[i][j];\n\t\t\telse if(ans.fi == dp[i][j].fi) ans.sc = min(ans.sc,dp[i][j].sc);\n\t\t}}\n\t\tcout <<ans.fi<<\" \" << ans.sc << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\npint INF(INT_MAX,INT_MAX);\n\npint dp[55555];\npint nex[55555];\n\nint N;\nint P[111];\n\n\n\nvoid solve(){\n    rep(i,N)cin>>P[i];\n\n    fill_n(dp,55555,INF);\n    dp[0]=pint(0,0);\n\n    for(int i=0;i<N;i++){\n        fill_n(nex,55555,INF);\n        for(int j=0;j<50000;j++){\n            chmin(nex[j],dp[j]);\n\n            int p=P[i]%1000;\n            if(p==0){\n                pint w=dp[j];\n                w.fi--;w.se+=P[i];\n                if(j>=500)chmin(nex[j-500],w);\n            }\n            else if(p<=500){\n                pint w=dp[j];\n                w.fi--;\n                w.se+=P[i];\n                chmin(nex[j+500-p],w);\n            }\n            else{\n                pint w=dp[j];\n                w.se+=P[i];\n                chmin(nex[j+1000-p],w);\n                w.fi--;\n                if(j-(p-500)>=0)chmin(nex[j-(p-500)],w);\n            }\n        }\n        rep(j,55555)dp[j]=nex[j];\n    }\n\n    pint ans=INF;\n    rep(i,55555)chmin(ans,dp[i]);\n\n}\n\nsigned main(){\n    while(cin>>N,N)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nint c[5]={100,50,10,5,1};\nint encode(vector<int> v){\n\tint S = 0;\n\tfor(int i=0;i<v.size();i++){\n\t\tS = S*10+v[i];\n\t}\n\treturn S;\n}\nvector<int> decode(int S){\n\tvector<int> v;\n\tint x = 10000;\n\tfor(int i=0;i<5;i++){\n\t\tv.pb(S/x);\n\t\tS %= x;\n\t\tx /= 10;\n\t}\n\treturn v;\n}\nP dp[105][101000];\npair<int,vector<int> > charge(int x){\n\tx %= 1000;\n\tvector<int> v(5,0);\n\tint f = x/500;\n\tx -= f*500;\n\tfor(int i=0;i<5;i++){\n\t\tv[i]=x/c[i];\n\t\tx -= v[i]*c[i];\n\t}\n\t//assert(x==0);\n\treturn make_pair(f,v);\n}\n/*void dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}*/\nP dfs(int id,int V){\n\t/*cout << \"call : \" << id << endl;\n\tcout << \"vec : \";\n\tdump(vec);\n\tcout << endl;*/\n\tint tmp = V;\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tmap<int,P>::iterator it;\n\tif(dp[id][V].fi!=-1){\n\t\treturn dp[id][V];\n\t}\n\tP res = dfs(id+1,V);\n\tvector<int> vec = decode(V);\n\tint h = ((p[id]-1)/1000+1)*1000;;\n\tfor(int i=0;i<5;i++){\n\t\twhile(vec[i]>0&&h-p[id]+c[i]<1000){\n\t\t\tvec[i]--;\n\t\t\th += c[i];\n\t\t}\n\t}\n\tpair<int,vector<int> > ch = charge(h-p[id]);\n\tfor(int i=0;i<5;i++)vec[i] += (ch.sec)[i];\n\tP res2 = dfs(id+1,encode(vec));\n\tres2.fi += ch.fi;\n\tres2.sec -= p[id];\n\tdp[id][tmp]=max(res,res2);\n\t/*cout << \"end : \" << id << endl;\n\tcout << \"vec : \";\n\tdump();\n\tcout << \"result : \" << dp[id][vec].fi << ' ' << -dp[id][vec].sec << endl;*/\n\treturn dp[id][tmp];\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<100100;j++){\n\t\t\tdp[i][j]=P(-1,-1);\n\t\t}\n\t}\n\tP ans = dfs(0,0);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[2][101][50000];\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int p[100],pp[100];\n    for(int i=0;i<n;i++)cin>>p[i],pp[i]=(1000-p[i]%1000)%1000;\n\n    for(int i=0;i<2;i++)\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<50000;k++)dp[i][j][k]=1e9;\n    \n    dp[0][0][0]=0;\n\n    for(int i=0;i<n;i++){\n      int ni=(i+1)%2,I=i%2;\n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<50000;k++)dp[ni][j][k]=1e9;\n      \n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<50000;k++){\n\t  int np=k+pp[i];\n\t  int nj=j;\n\t  if(np>=500)nj++,np-=500;\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[I][j][k]+p[i]);\n\t  dp[ni][j][k]=min(dp[ni][j][k],dp[I][j][k]);\n\t}\n    }\n    \n    int c=0,s=0;\n    for(int i=1;i<=n;i++)\n      for(int j=0;j<50000;j++)\n\tif(dp[n%2][i][j]!=1e9&&i>=c){\n\t  if(c==i&&dp[n%2][i][j]<s)s=dp[n%2][i][j];\n\t  else if(c<i)c=i,s=dp[n%2][i][j];\n\t}\n    cout<<c<<\" \"<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nP dp[105][50005];\nint p[100];\nvoid Max(P &a,P b){a=max(a,b);}\n\nint main(){\n  int n;\n  while(cin>>n && n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++)cin>>p[i];\n    dp[0][0] = P(0,0);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<50000;j++){\n        if(dp[i][j]==P(-1,-1)) continue;\n        int nf=dp[i][j].first,ns=dp[i][j].second-p[i];\n        Max(dp[i+1][j],dp[i][j]);\n        if(p[i]%1000==0)\n          {if(j>=500) Max(dp[i+1][j-500],P(nf+1,ns));}\n        else if(p[i]%1000<500) Max(dp[i+1][j+500-p[i]%500],P(nf+1,ns));\n        else if(p[i]%500<=j) Max(dp[i+1][j-p[i]%500],P(nf+1,ns));\n        else Max(dp[i+1][j+500-p[i]%500],dp[i][j]); \n      }\n    }\n    P ans(0,0);\n    for(int i=0;i<50000;i++) Max(ans,dp[n][i]);\n    cout<<ans.first<<\" \"<<-ans.second<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\n\nP dp[101][50501];\nP pmax(P p,P q){\n    if(p.fs>q.fs) return p;\n    else if(p.fs==q.fs) return (p.sc<q.sc?p:q);\n    else return q;\n}\n\n\nint main(){\n    int N;\n    while(cin >> N){\n        if(!N) return 0;\n        int p[N];\n        for(int i=0;i<N;i++){\n            cin >> p[i];\n        }\n        for(int i=0;i<=N;i++){\n            for(int j=0;j<50001;j++){\n                if(j==0) dp[i][j]=mp(0,0);\n                else dp[i][j]=mp(-1,LINF);\n            }\n        }\n        for(int i=0;i<N;i++){\n            for(int j=0;j<50001;j++){\n                if(dp[i][j].fs==-1){\n                    continue;\n                }\n                P d=dp[i][j];\n                dp[i+1][j]=pmax(dp[i+1][j],d);\n                d.sc+=p[i];\n                int res=(1000-p[i]%1000)%1000;\n                dp[i+1][j+res]=pmax(dp[i+1][j+res],d);\n                if(res>=500){\n                    d.fs++;\n                    res-=500;\n                    dp[i+1][j+res]=pmax(dp[i+1][j+res],d);\n                }\n                else{\n                    d.fs++;\n                    res=500-res;\n                    if(res<=j) dp[i+1][j-res]=pmax(dp[i+1][j-res],d);\n                }\n            }\n        }\n        P ans=mp(0,LINF);\n        for(int i=0;i<=50000;i++){\n            ans=pmax(ans,dp[N][i]);\n        }\n        cout << ans.fs << \" \" << ans.sc << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// dp[i][500yen][num_1000yen] := remain ([i] is deleted)\nint dp[128][1024];\nint n;\nint P[128];\n\nvoid init() {\n  for(int j = 0; j < 128; ++j) {\n    for(int k = 0; k < 1024; ++k) {\n      dp[j][k] = -1;\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d\", &P[i]);\n    }\n    dp[0][0] = 0;\n    for(int i = 0; i < n; ++i) {\n      for(int j = n-1; j >= 0; --j) {\n        for(int k = 1024 - 1; k >= 0; --k) {\n          if( dp[j][k] == -1 ) continue;\n          int n1kyen = (P[i] + 999) / 1000;\n          int rem = dp[j][k] + n1kyen * 1000 - P[i];\n          int next_num500yen = j + (rem >= 500 ? 1 : 0);\n          int next_num1kyen  = k + n1kyen;\n          int next_rem       = rem >= 500 ? rem - 500 : rem;\n          int& next = dp[next_num500yen][next_num1kyen];\n          next = std::max(next, next_rem);\n        }\n      }\n    }    \n    int res = (1 << 28);\n    int max = -1;\n    for(int j = n; j >= 0; --j) {\n      for(int k = 0; k < 1024; ++k) {\n        if( dp[j][k] == -1 ) continue;\n        int cost = k * 1000 - 500 * j - dp[j][k];\n        res = std::min(res, cost);\n      }\n      if( res != (1 << 28) ) {\n        max = j;\n        break;\n      }\n    }\n    printf(\"%d %d\\n\", max, res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vii;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip> vip;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 :1e9;\n#define MAX 10010\nint dp[110][MAX];\nint mo[110][MAX];\nvoid f(int a,int b,int c,int d){\n\tif(dp[a][b]<c){\n\t\tdp[a][b]=c;\n\t\tmo[a][b]=d;\n\t}else if(dp[a][b]==c)\n\t\tmo[a][b]=min(mo[a][b],d);\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi in(n);\n\t\trep(i,n)cin>>in[i];\n\t\trep(j,110)rep(k,MAX)dp[j][k]=-inf;\n\t\tdp[0][0]=mo[0][0]=0;\n\t\trep(i,n)rep(j,MAX)if(dp[i][j]!=-inf){\n\t\t\tf(i+1,j,dp[i][j],mo[i][j]);\n\t\t\tint a=in[i]%1000;\n\t\t\tint t=1000-a;\n\t\t\tif(a)f(i+1,j+t%500,dp[i][j]+(t>=500),mo[i][j]+in[i]);\n\t\t\telse if(j>=500)f(i+1,j-500,dp[i][j]+1,mo[i][j]+in[i]);\n\t\t\tt=500+j-a;\n\t\t\tif(t>=0&&a>=500)f(i+1,t,dp[i][j]+1,mo[i][j]+in[i]);\n\t\t}\n\n\t\tint outc=0,out=inf;\n\t\trep(i,MAX)if(dp[n][i]!=-inf){\n\t\t\tif(outc<dp[n][i]){\n\t\t\t\toutc=dp[n][i];\n\t\t\t\tout=mo[n][i];\n\t\t\t}else if(outc==dp[n][i])\n\t\t\t\tout=min(out,mo[n][i]);\n\t\t}\n\t\tcout<<outc<<\" \"<<out<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nconst int INF = 500002;\nint p[102];\nP dp[102][102][502];\nbool visited[102][102][502];\nint n;\n\nP dfs(int pos, int r, int ex){\n    if(pos == n) return P(0, 0);\n    if(visited[pos][r][ex]) return dp[pos][r][ex];\n    int pay = 1000;\n    while(pay < p[pos]) pay += 1000;\n    int nex = ex + pay - p[pos];\n    int nr = r + nex / 500;\n    nex %= 500;\n    P ret = dfs(pos+1, r, ex);\n    if(nr > 0){\n        P res = dfs(pos+1, nr-1, nex);\n        ret = max(ret, P(res.first + 1, res.second - p[pos]));\n    }else{\n        P res = dfs(pos+1, nr, nex);\n        ret = max(ret, P(res.first, res.second - p[pos]));\n    }\n    dp[pos][r][ex] = ret;\n    visited[pos][r][ex] = true;\n    return ret;\n}\n\nint main(){\n    while(true){\n        cin >> n;\n        if(n == 0) break;\n\n        for(int i=0;i<n;i++){\n            cin >> p[i];\n        }\n\n        memset(visited, 0, sizeof(visited));\n        P ans = dfs(0, 0, 0);\n        cout << ans.first << \" \" << -ans.second << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvoid chmin(int&a,int b)\n{\n\tif(~a)a=min(a,b);\n\telse a=b;\n}\nmain()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tvector<vector<vector<int> > >dp(n+1,vector<vector<int> >(1001,vector<int>(2*n+2,-1)));\n\t\tdp[0][0][0]=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint p;cin>>p;\n\t\t\tint next=p%1000?1000-p%1000:0;\n\t\t\tfor(int j=0;j<=1000;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<=2*n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(dp[i][j][k]<0)continue;\n\t\t\t\t\tchmin(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t\tchmin(dp[i+1][j+next>=500?j+next-500:j+next][k+(j+next>=500)],\n\t\t\t\t\t\t\tdp[i][j][k]+((p+999)/1000*1000));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=n;i>=0;i--)\n\t\t{\n\t\t\tint ans=1e9;\n\t\t\tfor(int j=0;j<=1000;j++)\n\t\t\t{\n\t\t\t\tif(dp[n][j][i]>=0)ans=min(ans,dp[n][j][i]-j-i*500);\n\t\t\t}\n\t\t\tif(ans<1e9)\n\t\t\t{\n\t\t\t\tcout<<i<<\" \"<<ans<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1 ; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1 ; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9+100;\nconst bool debug = 0;\n/***************************************/\n\nint N;\nint p[100];\nint dp[101][25001]; // 500円の枚数, 所持金(100円以下の小銭) = 最小購入金額\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tREP(i, N) scanf(\"%d\", p + i);\n\t\t\n\t\tint cut[101] = {};\n\t\tcut[N] = 0;\n\t\tfor (int i = N - 1; i >= 0; i--) {\n\t\t\tcut[i] = cut[i + 1];\n\t\t\tint chg = 1000 - (p[i] % 1000);\n\t\t\tchg %= 1000;\n\t\t\tif (chg < 500) cut[i] += chg - 500;\n\t\t}\n\t\t\n\t\tfill(dp[0], dp[N + 1], INF);\n\t\tdp[0][0] = 0;\n\t\t\n\t\tREP(t, N) {\n\t\t\tint chg = 1000 - (p[t] % 1000);\n\t\t\tchg %= 1000;\n\t\t\t\n\t\t\tfor (int i = N; i >= 0; i--) {\n\t\t\t\tfor (int j = min(25000, cut[i] + 1000); j >= 0; j--) {\n\t\t\t\t\tif (i) { // 購入して500円玉が増えた場合\n\t\t\t\t\t\tif (chg >= 500) {\n\t\t\t\t\t\t\tint cur = chg - 500; // 増加\n\t\t\t\t\t\t\tif (j - cur >= 0 && dp[i - 1][j - cur] != INF) chmin(dp[i][j], dp[i - 1][j - cur] + p[t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint cur = 500 - chg; // 減少\n\t\t\t\t\t\t\tif (j + cur <= 25000 && dp[i - 1][j + cur] != INF) chmin(dp[i][j], dp[i - 1][j + cur] + p[t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 購入して500円玉が増えなかった場合\n\t\t\t\t\tif (chg < 500 && j - chg >= 0 && dp[i][j - chg] != INF) chmin(dp[i][j], dp[i][j - chg] + p[t]);\n\t\t\t\t\t\n\t\t\t\t\t//小銭j円が多すぎて困ることはないので\n\t\t\t\t\tif (j) chmin(dp[i][j-1], dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpii ans;\n\t\tfor (int i = N; i >= 0; i--) {\n\t\t\tif (dp[i][0] == INF) continue;\n\t\t\tans = pii(i, dp[i][0]);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (debug) printf(\"@ \");\n\t\tprintf(\"%d %d\\n\", ans.fi, ans.se);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = 100000000;\n\nint dp[102][102][500];\n\nint main()\n{\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        int p[102];\n        int charge[102] {0};\n        for(int i = 1; i <= n; i++){\n            cin >> p[i];\n            charge[i] = charge[i - 1] + (6000 - p[i]) % 1000;\n        }\n        for(int i = 0; i <= n; i++){\n            for(int j = 0; j <= n; j++){\n                for(int k = 0; k < 500; k++){\n                    dp[i][j][k] = INF;\n                }\n            }\n        }\n        for(int i = 0; i <= n; i++){\n            for(int k = 0; k < 500; k++){\n                dp[i][0][k] = 0;\n            }\n        }\n        for(int i = 1; i <= n; i++){\n            for(int j = 0; j <= n; j++){\n                for(int k = 0; k < 500; k++){\n                    dp[i][j][k] = min(dp[i - 1][j][k] + p[i], INF);\n                    if((6000 - p[i]) % 1000 <= k){\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - (6000 - p[i]) % 1000]);\n                    }\n                    if(j > 0 && charge[i - 1] - k - (j - 1) * 500 + (6000 - p[i]) % 1000 >= 500){\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][k] + p[i]);\n                    }\n                }\n            }\n        }\n        int j = 0;\n        for(; j <= n; j++){\n            if(dp[n][j][0] == INF) break;\n        }\n        int ans = INF;\n        for(int k = 0; k < 500; k++) ans = min(ans, dp[n][j - 1][k]);\n        cout << j - 1 << \" \" << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint main(){\n  int n;\n  while(std::cin >> n, n){\n    pii dp[n + 1][5][2][5][2][5];//1, 5, 10, 50, 100;\n    for (int i = 0; i <= n; i++) {\n      for (int j = 0; j < 5; j++) {\n        for (int k = 0; k < 2; k++) {\n          for (int l = 0; l < 5; l++) {\n            for (int m = 0; m < 2; m++) {\n              for (int o = 0; o < 5; o++) {\n                dp[i][j][k][l][m][o] = pii(-1e9, -1e9);\n              }\n            }\n          }\n        }\n      }\n    }\n    vector<int> shop(n);\n    for (int i = 0; i < n; i++) {\n      std::cin >> shop[i];\n    }\n    dp[0][0][0][0][0][0] = pii(0, 0);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 5; j++) {\n        for (int k = 0; k < 2; k++) {\n          for (int l = 0; l < 5; l++) {\n            for (int m = 0; m < 2; m++) {\n              for (int o = 0; o < 5; o++) {\n                int tf = dp[i][j][k][l][m][o].first;\n                int tc = dp[i][j][k][l][m][o].second;\n                int one, five, ten, fifty;\n                int hundred, five_hundred;\n                \n                int diff = (50000 - shop[i])%1000;\n                five_hundred = diff/500;\n                diff %= 500;\n                \n                hundred = diff/100;\n                diff %= 100;\n                \n                fifty = diff/50;\n                diff %= 50;\n                \n                ten = diff/10;\n                diff %= 10;\n                \n                five = diff/5;\n                diff %= 5;\n                \n                one = diff;\n                \n                int nj = j + one;\n                int nk = k + five    + nj/5;\n                int nl = l + ten     + nk/2;\n                int nm = m + fifty   + nl/5;\n                int no = o + hundred + nm/2;\n                five_hundred += no/5;\n                \n                dp[i + 1][nj%5][nk%2][nl%5][nm%2][no%5] = \n                  max(dp[i + 1][nj%5][nk%2][nl%5][nm%2][no%5],\n                      pii(tf + five_hundred, tc - shop[i]));\n                \n                dp[i + 1][j][k][l][m][o] =\n                  max(dp[i + 1][j][k][l][m][o],\n                      dp[i][j][k][l][m][o]);\n              }\n            }\n          }\n        }\n      }\n    }\n    pii ans = pii(0, -1e9);\n    for (int j = 0; j < 5; j++) {\n      for (int k = 0; k < 2; k++) {\n        for (int l = 0; l < 5; l++) {\n          for (int m = 0; m < 2; m++) {\n            for (int o = 0; o < 5; o++) {\n              ans = max(ans, dp[n][j][k][l][m][o]);\n            }\n          }\n        }\n      }\n    }\n    std::cout << ans.first << \" \" << -ans.second << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nint c[5]={100,50,10,5,1};\nmap<vector<int>,P> dp[105];\npair<int,vector<int> > charge(int x){\n\tx %= 1000;\n\tvector<int> v(5,0);\n\tint f = x/500;\n\tx -= f*500;\n\tfor(int i=0;i<5;i++){\n\t\tv[i]=x/c[i];\n\t\tx -= v[i]*c[i];\n\t}\n\tassert(x==0);\n\treturn make_pair(f,v);\n}\nvoid dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}\nP dfs(int id,vector<int> vec){\n\t/*cout << \"call : \" << id << endl;\n\tcout << \"vec : \";\n\tdump(vec);\n\tcout << endl;*/\n\tvector<int> tmp = vec;\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tmap<vector<int>,P>::iterator it;\n\tit = dp[id].find(vec);\n\tif(it!=dp[id].end()){\n\t\treturn (it->sec);\n\t}\n\tP res = dfs(id+1,vec);\n\tint h = ((p[id]-1)/1000+1)*1000;;\n\tfor(int i=0;i<5;i++){\n\t\twhile(vec[i]>0&&h-p[id]+c[i]<1000){\n\t\t\tvec[i]--;\n\t\t\th += c[i];\n\t\t}\n\t}\n\tpair<int,vector<int> > ch = charge(h-p[id]);\n\tfor(int i=0;i<5;i++)vec[i] += (ch.sec)[i];\n\tP res2 = dfs(id+1,vec);\n\tres2.fi += ch.fi;\n\tres2.sec -= p[id];\n\tdp[id][tmp]=max(res,res2);\n\t/*cout << \"end : \" << id << endl;\n\tcout << \"vec : \";\n\tdump();\n\tcout << \"result : \" << dp[id][vec].fi << ' ' << -dp[id][vec].sec << endl;*/\n\treturn dp[id][tmp];\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<105;i++)dp[i].clear();\n\tvector<int> v;\n\tfor(int i=0;i<5;i++)v.pb(0);\n\tP ans = dfs(0,v);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\n#define IINF INT_MAX\n#define MAX 110\nint n,p[MAX],dp[210][10010];\n\nint main() {\n  while( cin >> n, n ) {\n    rep(i,n) cin >> p[i];\n    rep(i,210) rep(j,10010) dp[i][j] = IINF;\n    dp[0][0] = 0;\n    rep(i,n) {\n      for(int j=209;j>=0;--j) {\n\tfor(int k=10009;k>=0;--k) {\n\t  if( dp[j][k] == IINF ) continue;\n\t  // use\n\t  //cout << \"dp[\" << i << \"][\" << j << \"][\" << k << \"] = \" << dp[i][j][k] << endl;\n\t  int rem = ( 1000 - p[i] % 1000 ) + k;\n\t  if( p[i] % 1000 == 0 ) rem = k;\n\t  \n\t  if( rem >= 500 ) {\n\t    dp[j+1][rem-500] = min(dp[j+1][rem-500],\n\t\t\t\t   dp[j][k]+p[i]);\n\t  } else {\n\t    dp[j][rem] = min(dp[j][rem],dp[j][k]+p[i]);\n\t  }\n\t  // dont use\n\t  dp[j][k] = min(dp[j][k],dp[j][k]);\n\t}\n      }\n    }\n    for(int i=209;i>=0;--i) {\n      int mini = IINF;\n      rep(j,500) {\n\tif( dp[i][j] != IINF ) {\n\t  mini = min(mini,dp[i][j]);\n\t}\n      }\n      if( mini != IINF ) {\n\tcout << i << \" \" << mini << endl;\n\tgoto Skip;\n      }\n    }\n    puts(\"0 0\");\n  Skip:;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n\nint n,a[110];\nusing P = pair<int,int>;\nP dp[110][50010];\n\nP operator+(const P &p1,const P &p2){\n\treturn P(p1.first + p2.first,p1.second + p2.second);\n}\n\nvoid solve(){\n\tconst int INF = 1e+9;\n\tfor(int i = 0;i < n;i++) cin >> a[i];\n\tfor(int i = 0;i <= n;i++){\n\t\tfor(int j = 0;j <= n * 500;j++) dp[i][j] = P(-INF,-INF);\n\t}\n\tdp[0][0] = P(0,0);\n\tfor(int i = 0;i < n;i++){\n\t\tint b = (a[i] % 1000 ? a[i] % 1000 : 1000);\n\t\tfor(int j = 0;j <= n * 500;j++){\n\t\t\tchmax(dp[i + 1][j],dp[i][j]);\n\t\t\tif(j + 500 - b >= 0 && j + 500 - b <= n * 500) chmax(dp[i + 1][j + 500 - b],dp[i][j] + P(1,-a[i]));\n\t\t\tif(b > 500 && j + 1000 - b <= n * 500) chmax(dp[i + 1][j + 1000 - b],dp[i][j] + P(0,-a[i]));\n\t\t}\n\t}\n\tP ans(-INF,-INF);\n\tfor(int i = 0;i <= n * 500;i++){\n\t\tchmax(ans,dp[n][i]);\n\t}\n\tcout << ans.first << \" \" << -ans.second << endl;\n}\n\nsigned main(){\n\twhile(cin >> n,n) solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  const int CMAX = 25000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 49900... too much? to get 50, max = 25000\n    // # of 500 got so far : at most 100\n    // value : minimum payment\n    \n    vector<vector<int>> dp(CMAX+1, vector<int>(101, BIG));\n    vector<vector<int>> dpnew(CMAX+1, vector<int>(101, BIG));\n    dpnew[0][0] = 0;\n    int cmax = 0;\n    for(int i = 0; i < n; i++) {\n      const int ii = i + 1;\n      // not buying\n      for(int j = 0; j <= cmax; j++) {\n        for(int k = 0; k <= i; k++) {\n          dp[j][k] = dpnew[j][k];\n        }\n      }\n      // buying\n      for(int j = 0; j <= cmax; j++) {\n        const int p = ps[i] % 1000;\n        if(p != 0 && p <= 500) { // got 500!\n          const int jj = min(j + 500 - p, CMAX);\n          cmax = min(max(cmax, jj), CMAX);\n          for(int k = 0; k <= i; k++) {\n            const int kk = k + 1;\n            dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n          }\n        } else {\n          // get 500 if possible!\n          const int q = (p == 0 ? 1000 : p) - 500;\n          if(j >= q) {\n            const int jj = j - q;\n            for(int k = 0; k <= i; k++) {\n              const int kk = k + 1;\n              dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n            }\n          } else { // get change\n            const int jj = j + 1000 - p;\n            cmax = min(max(cmax, jj), CMAX);\n            if( jj < 1000) {\n              for(int k = 0; k <= i; k++) {\n                const int kk = k;\n                dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n              }\n            }\n          }\n        }\n      }\n    }\n    for(int k = 100; k >= 0; k--) {\n      int p = BIG;\n      for(int j = 0; j <= cmax; j++) {\n        p = min(p, dpnew[j][k]);\n      }\n      if(p != BIG) {\n        cout << k << \" \" << p << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N;\nvoid solve() {\n    vector<int> shop(N);\n    for (auto& i : shop) cin >> i;\n\n    vector<int> diff(N);\n    for (int i = 0; i < N; i++) {\n        int d = shop[i] % 1000;\n        if (0 < d && d <= 500) diff[i] = 0;\n        else if (d > 500) diff[i] = d - 500;\n        else diff[i] = 500;\n    }\n\n    vector<vector<P> > dp(N + 1, vector<P>(500 * N, P(0, -500 * N - 1)));\n    dp[0][0] = P(0, 0);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= 500 * i; j++) {\n            auto coin = dp[i][j];\n            if (coin.second == -500 * N  - 1) continue;\n            dp[i+1][j] = max(dp[i+1][j], coin);\n            if (diff[i] == 0) {\n                P ncoin = P(coin.first + 1, coin.second - shop[i]);\n                int f = j + 500 - (shop[i] % 500);\n                dp[i+1][f] = max(dp[i+1][f], ncoin);\n            } else {\n                if (diff[i] <= j) {\n                    P ncoin = P(coin.first + 1, coin.second - shop[i]);\n                    int f = j - diff[i];\n                    dp[i+1][f] = max(dp[i+1][f], ncoin);\n                }\n\n                P pcoin = P(coin.first, coin.second - shop[i]);\n                int f_ = j + (shop[i] % 1000 ? 1000 - shop[i] % 1000 : 0);\n                dp[i+1][f_] = max(dp[i+1][f_], pcoin);\n            }\n        }\n    }\n\n    P ans(0, 0);\n    for (auto p : dp[N]) {\n        ans = max(ans, p);\n    }\n\n    cout << ans.first << \" \" << -ans.second << endl;\n}\n\nint main() {\n    while (cin >> N, N) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct state{\n\tint coin, cost;\n\tstate(){}\n\tstate(int c, int s){\n\t\tcoin = c, cost = s;\n\t}\n\tbool operator<(const state& ope)const{\n\t\treturn coin < ope.coin || (coin == ope.coin && cost > ope.cost);\n\t}\n};\n\nint n;\nint p[105];\nstate dp[105][250005];\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tfor(int i = 1; i <= n; i++) cin >> p[i];\n\t\t\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tfor(int j = 0; j < 250005; j++){\n\t\t\t\tdp[i][j] = state(-inf, inf);\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = state(0, 0);\n\t\t\n\t\tint pay, ret;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < 250005; j++){\n\t\t\t\tdp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n\t\t\t\t\n\t\t\t\tpay = (p[i+1] + 999) / 1000 * 1000;\n\t\t\t\tret = pay - p[i+1];\n\t\t\t\tif(ret >= 500) dp[i+1][j+ret-500] = max(dp[i+1][j+ret-500], state(dp[i][j].coin+1, dp[i][j].cost+p[i+1]));\n\t\t\t\telse dp[i+1][j+ret] = max(dp[i+1][j+ret], state(dp[i][j].coin, dp[i][j].cost+p[i+1]));\n\t\t\t\t\n\t\t\t\tret = (p[i+1] + 500) % 1000;\n\t\t\t\tif(ret <= j){\n\t\t\t\t\tdp[i+1][j-ret] = max(dp[i+1][j-ret], state(dp[i][j].coin+1, dp[i][j].cost+p[i+1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstate ans = state(-inf, inf);\n\t\tfor(int i = 0; i < 250005; i++){\n\t\t\tans = max(ans, dp[n][i]);\n\t\t}\n\t\t\n\t\tcout << ans.coin << \" \" << ans.cost << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1 ; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1 ; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9+100;\nconst bool debug = 0;\n/***************************************/\n\nint N;\nint p[100];\nint dp[101][25001]; // 500円の枚数, 所持金(100円以下の小銭) = 最小購入金額\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tREP(i, N) scanf(\"%d\", p + i);\n\t\t\n\t\tfill(dp[0], dp[N + 1], INF);\n\t\tdp[0][0] = 0;\n\t\t\n\t\tint lim[101] = {};\n\t\tfor (int i = N - 1; i >= 0; i--) {\n\t\t\tint chg = (1000 - (p[i] % 1000)) % 1000;\n\t\t\tif (chg >= 500) chg = 500;\n\t\t\tlim[i] = 500 - chg + lim[i + 1];\n\t\t}\n\t\tREP(t, N) {\n\t\t\tint chg = 1000 - (p[t] % 1000);\n\t\t\tchg %= 1000;\n\t\t\t\n\t\t\tfor (int i = N; i >= 0; i--) {\n\t\t\t\tfor (int j = min(25000, lim[i] + 1000); j >= 0; j--) {\n\t\t\t\t\tif (i) { // 購入して500円玉が増えた場合\n\t\t\t\t\t\tif (chg >= 500) {\n\t\t\t\t\t\t\tint cur = chg - 500; // 増加\n\t\t\t\t\t\t\tif (j - cur >= 0 && dp[i - 1][j - cur] != INF) chmin(dp[i][j], dp[i - 1][j - cur] + p[t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint cur = 500 - chg; // 減少\n\t\t\t\t\t\t\tif (j + cur <= 25000 && dp[i - 1][j + cur] != INF) chmin(dp[i][j], dp[i - 1][j + cur] + p[t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 購入して500円玉が増えなかった場合\n\t\t\t\t\tif (chg < 500 && j - chg >= 0 && dp[i][j - chg] != INF) chmin(dp[i][j], dp[i][j - chg] + p[t]);\n\t\t\t\t\t\n\t\t\t\t\t//小銭j円が多すぎて困ることはない\n\t\t\t\t\tif (j) chmin(dp[i][j-1], dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpii ans;\n\t\tfor (int i = N; i >= 0; i--) {\n\t\t\tif (dp[i][0] == INF) continue;\n\t\t\tans = pii(i, dp[i][0]);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (debug) printf(\"@ \");\n\t\tprintf(\"%d %d\\n\", ans.fi, ans.se);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                     #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\nint pr[100010];\nint inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n \n \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n\n\n                         //----------------kokomade tenpure------------\nint n;\npair<int,int> dp[120][540005];\nbool me[120][540005]={0};\nsigned main(){\n\twhile(1){\n\tcin>>n;\n\t\tif(n==0) break;\n\t\t\n\t\tfor(int i=0;i<120;i++)for(int j=0;j<540005;j++){\n\t\t\tdp[i][j]=mp(0,-10000000);\n\t\t\t\n\t\t\tme[i][j]=0;\n\t\t}\n\t\tme[0][0]=1;\n\t\tdp[0][0]=mp(0,0);\n\t\t\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint p,pq;\n\t\t\tcin>>p;\n\t\t\tpq=p;\n\t\t\tp%=1000;\n\t\t\t\n\t\t\tif(p==0) p+=1000;\n\t\t\tfor(int j=0;j<540005;j++){\n\t\t\t\tif(me[i-1][j]==0) continue;\n\t\t\t\tme[i][j]=1;\n\t\t\t\tif(dp[i][j]<dp[i-1][j]) dp[i][j]=dp[i-1][j];\n\t\t\t\tif(p>500){\n\t\t\t\t\tme[i][j+(1000-p)]=1;\n\t\t\t\t\tif(dp[i][j+(1000-p)]<mp(dp[i-1][j].first,dp[i-1][j].second-pq)) dp[i][j+(1000-p)]=mp(dp[i-1][j].first,dp[i-1][j].second-pq);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tme[i][j+(1000-p-500)]=1;\n\t\t\t\t\tif(dp[i][j+(500-p)]<mp(dp[i-1][j].first+1,dp[i-1][j].second-pq)) dp[i][j+(500-p)]=mp(dp[i-1][j].first+1,dp[i-1][j].second-pq);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(p>500){\n\t\t\t\t\tif(j>=p+500-1000){\n\t\t\t\t\t\tme[i][j-(p-500)]=1;\n\t\t\t\t\t\tif(dp[i][j-(p-500)]<mp(dp[i-1][j].first+1,dp[i-1][j].second-pq)) dp[i][j-(p-500)]=mp(dp[i-1][j].first+1,dp[i-1][j].second-pq);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(j>=p+500){\n\t\t\t\t\t\tme[i][j-(p+500)]=1;\n\t\t\t\t\t\tif(dp[i][j-(p+500)]<mp(dp[i-1][j].first+1,dp[i-1][j].second-pq)) dp[i][j-(p+500)]=mp(dp[i-1][j].first+1,dp[i-1][j].second-pq);\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpa ans=mp(0,-100000000);\n\t\tfor(int j=0;j<540005;j++){\n\t\t\tif(me[n][j]==0) continue;\n\t\t\tif(dp[n][j]>ans)ans=dp[n][j];\n\t\t}\n\t\n\t\t\n\t\tcout<<ans.first<<\" \"<<-ans.second<<endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<int> p(n);\n        for(int i=0;i<n;i++) cin>>p[i];\n        const int INF=1e8;\n        vector<vector<pair<int,int>>> dp(n+1,vector<pair<int,int>>(100000,make_pair(-INF,INF)));\n        dp[0][0]=make_pair(0,0);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<dp[i].size();j++){\n                if(0<p[i]%1000 && p[i]%1000<=500){\n                    pair<int,int> x=make_pair(dp[i][j].first+1,dp[i][j].second-p[i]);\n                    int to=j+1000-p[i]%1000;\n                    if(to<dp[i+1].size()){\n                        dp[i+1][to]=max(dp[i+1][to],x);\n                    }\n                }\n                else if(500<p[i]%1000){\n                    int to=j+1000-p[i]%1000;\n                    if(to<dp[i+1].size()){\n                        dp[i+1][to]=max(dp[i+1][to],make_pair(dp[i][j].first,dp[i][j].second-p[i]));\n                    }\n                    to=j-(p[i]+500)%1000;\n                    if(to>=0){\n                        dp[i+1][to]=max(dp[i+1][to],make_pair(dp[i][j].first+1,dp[i][j].second-p[i]));\n                    }\n                }\n                dp[i+1][j]=max(dp[i][j],dp[i+1][j]);\n            }\n        }\n        pair<int,int> res=make_pair(-INF,INF);\n        for(int i=0;i<dp[n].size();i++){\n            res=max(res,dp[n][i]);\n        }\n        cout<<res.first<<\" \"<<-res.second<<endl;\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  const int CMAX = 20000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 49900... too much?\n    // # of 500 got so far : at most 100\n    // value : minimum payment\n    \n    vector<vector<int>> dp(CMAX+1, vector<int>(101, BIG));\n    vector<vector<int>> dpnew(CMAX+1, vector<int>(101, BIG));\n    dpnew[0][0] = 0;\n    int cmax = 0;\n    for(int i = 0; i < n; i++) {\n      const int ii = i + 1;\n      for(int j = 0; j <= cmax; j++) { // not buying\n        for(int k = 0; k <= i; k++) {\n          dp[j][k] = dpnew[j][k];\n        }\n      }\n      // buying\n      const int p = ps[i] % 1000;\n      if(p != 0 && p <= 500) { // got 500!\n        for(int j = 0; j <= cmax; j++) {\n          const int jj = min(j + 500 - p, CMAX);\n          cmax = min(max(cmax, jj), CMAX);\n          for(int k = 0; k <= i; k++) {\n            const int kk = k + 1;\n            dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n          }\n        }\n      } else {\n        // get 500 if possible!\n        const int q = (p == 0 ? 1000 : p) - 500;\n        for(int j = 0; j <= cmax; j++) {\n          if(j >= q) {\n            const int jj = j - q;\n            for(int k = 0; k <= i; k++) {\n              const int kk = k + 1;\n              dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n            }\n          } else { // get change\n            const int jj = j + 1000 - p;\n            cmax = min(max(cmax, jj), CMAX);\n            if( jj < 1000) {\n              for(int k = 0; k <= i; k++) {\n                const int kk = k;\n                dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n              }\n            }\n          }\n        }\n      }\n    }\n    for(int k = 100; k >= 0; k--) {\n      int p = BIG;\n      for(int j = 0; j <= cmax; j++) {\n        p = min(p, dpnew[j][k]);\n      }\n      if(p != BIG) {\n        cout << k << \" \" << p << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint n;\nint a[105];\nint dp[105][100005];\nint DP[105][100005];\n \nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=1;i<=n;i++)cin>>a[i];\n    fill(dp[0],dp[105],-1e9);\n    fill(DP[0],DP[105],1e9);\n     \n    int ans=0,ANS=1e9;\n    dp[0][0]=0;\n    DP[0][0]=0;\n    for(int i=1;i<=n;i++){\n      for(int j=0;j<=100000;j++){\n        int A=a[i]%1000;\n        if(A==0)A=1000;\n         \n        dp[i][j]=dp[i-1][j];\n        DP[i][j]=DP[i-1][j];\n \n        if(A<=500){\n          int k=1000-A-500;\n          if(j-k>=0){\n            int d=dp[i-1][j-k]+1;\n            int D=DP[i-1][j-k]+a[i];\n            if( (d==dp[i][j]&&D<DP[i][j]) || d>dp[i][j]){\n              dp[i][j]=d;\n              DP[i][j]=D;\n            }\n          }\n        }else{\n          int k=1000-A;\n          if(j-k>=0){\n            int d=dp[i-1][j-k];\n            int D=DP[i-1][j-k]+a[i];\n            if( (d==dp[i][j]&&D<DP[i][j]) || d>dp[i][j]){\n              dp[i][j]=d;\n              DP[i][j]=D;\n            }\n          }\n           \n          if(j+A-500<=100000){\n            int d=dp[i-1][j+A-500]+1;\n            int D=DP[i-1][j+A-500]+a[i];\n            if( (d==dp[i][j]&&D<DP[i][j]) || d>dp[i][j]){\n              dp[i][j]=d;\n              DP[i][j]=D;\n            }\n          }\n        }\n        if( (ans==dp[i][j]&&DP[i][j]<ANS) || ans<dp[i][j] ){\n          ans=dp[i][j];\n          ANS=DP[i][j];\n        }\n      }\n    }\n    cout<<ans<<' '<<ANS<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vii;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip> vip;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 :1e9;\n#define MAX 1010\nint dp[110][110][MAX];\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi in(n);\n\t\trep(i,n)cin>>in[i];\n\t\trep(i,110)rep(j,110)rep(k,MAX)dp[i][j][k]=inf;\n\t\tdp[0][0][0]=0;\n\t\trep(i,n)rep(j,n)rep(k,MAX)if(dp[i][j][k]!=inf){\n\t\t\tdp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k]);\n\t\t\tint J=j,K=k,a=in[i]%1000;\n\t\t\tif(k<=a&&a){\n\t\t\t\tK=1000+k-a;\n\t\t\t\tif(K<MAX)dp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\tif(K>=500)J++,K-=500;\n\t\t\t\tif(K<MAX)dp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t}else if(k>a&&a){\n\t\t\t\tif(a+500<=k)\n\t\t\t\t\tK=k-a;\n\t\t\t\telse K=k+1000-a;\n\t\t\t\tif(K<MAX)dp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\tJ++;\n\t\t\t\tK-=500;\n\t\t\t\tif(K<MAX)dp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t}else{\n\t\t\t\tif(K>=500)K-=500,J++;\n\t\t\t\tif(K<MAX)dp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t}\n\t\t}\n\t\tint outc=0,out=inf;\n\t\trep(i,n+1)rep(j,MAX)if(dp[n][i][j]!=inf){\n\t\t\tif(outc<i){\n\t\t\t\toutc=i;\n\t\t\t\tout=dp[n][i][j];\n\t\t\t}else if(outc==i)\n\t\t\t\tout=min(out,dp[n][i][j]);\n\t\t}\n\t\tcout<<outc<<\" \"<<out<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 1000... really?\n    // # of 500 got so far : at most 100\n    // value : minimum payment\n    vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(1000, vector<int>(101, BIG)));\n    dp[0][0][0] = 0;\n    for(int i = 0; i < n; i++) {\n      const int ii = i + 1;\n      for(int j = 0; j < 1000; j++) { // not buying\n        for(int k = 0; k <= 100; k++) {\n          dp[ii][j][k] = dp[i][j][k];\n        }\n      }\n      // buying\n      const int p = ps[i] % 1000;\n      if(p != 0 && p <= 500) { // got 500!\n        for(int j = 0; j < 1000; j++) {\n          const int jj = min(j + 500 - p, 999);\n          for(int k = 0; k < 100; k++) {\n            const int kk = k + 1;\n            dp[ii][jj][kk] = min(dp[ii][jj][kk], dp[i][j][k] + ps[i]);\n          }\n        }\n      } else {\n        // get 500 if possible!\n        const int q = (p == 0 ? 1000 : p) - 500;\n        for(int j = 0; j < 1000; j++) {\n          if(j >= q) {\n            const int jj = j - q;\n            for(int k = 0; k < 100; k++) {\n              const int kk = k + 1;\n              dp[ii][jj][kk] = min(dp[ii][jj][kk], dp[i][j][k] + ps[i]);\n            }\n          } else { // get change\n            const int jj = j + 1000 - p;\n            if( jj < 1000) {\n              for(int k = 0; k <= 100; k++) {\n                const int kk = k;\n                dp[ii][jj][kk] = min(dp[ii][jj][kk], dp[i][j][k] + ps[i]);\n              }\n            }\n          }\n        }\n      }\n    }\n    for(int k = 100; k >= 0; k--) {\n      int p = BIG;\n      for(int j = 0; j < 1000; j++) {\n        p = min(p, dp[n][j][k]);\n      }\n      if(p != BIG) {\n        cout << k << \" \" << p << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nP dp[105][50005];\nint p[100];\nvoid Max(P &a,P b){a=max(a,b);}\n\nint main(){\n  int n;\n  while(cin>>n && n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++)cin>>p[i];\n    dp[0][0] = P(0,0);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<50000;j++){\n        if(dp[i][j]==P(-1,-1)) continue;\n        int nf=dp[i][j].first,ns=dp[i][j].second-p[i];\n        Max(dp[i+1][j],dp[i][j]);\n        if(p[i]%1000==0)\n          {if(j>=500) Max(dp[i+1][j-500],P(nf+1,ns));}\n        else if(p[i]%1000<500) Max(dp[i+1][j+500-p[i]%500],P(nf+1,ns));\n        else if(p[i]%500<=j) Max(dp[i+1][j-p[i]%500],P(nf+1,ns));\n        else Max(dp[i+1][j+500-p[i]%500],P(nf,ns)); \n      \n    }\n    P ans(0,0);\n    for(int i=0;i<50000;i++) Max(ans,dp[n][i]);\n    cout<<ans.first<<\" \"<<-ans.second<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint n, p[100];\n\nvoid getSolution(int gain, int used, int kozeni, int i, int* max_gain, int* min_used)\n{\n\tif(i >= n){\n\t\t*max_gain = gain;\n\t\t*min_used = used;\n\t\treturn;\n\t}\n\t\n\tint now_max_gain, now_min_used;\n\tint tmp_max_gain, tmp_min_used;\n\t\n\tgetSolution(gain, used, kozeni, i+1, &now_max_gain, &now_min_used);\n\t\n\tif( (p[i] + 500) % 1000 <= kozeni ){\n\t\tgetSolution(gain + 1, used + p[i], kozeni - (p[i] + 500) % 1000, i+1, &tmp_max_gain, &tmp_min_used);\n\t\tif(tmp_max_gain > now_max_gain || (tmp_max_gain == now_max_gain && tmp_min_used < now_min_used) ){\n\t\t\tnow_max_gain = tmp_max_gain;\n\t\t\tnow_min_used = tmp_min_used;\n\t\t}\n\t}\n\t\n\tif(p[i] % 1000 != 500){\n\t\tint ex = (1000 - p[i] % 1000) % 1000;\n\t\tint dgain = ex / 500;\n\t\tex -= dgain * 500;\n\t\tgetSolution(gain + dgain, used + p[i], kozeni + ex, i+1, &tmp_max_gain, &tmp_min_used);\n\t\tif(tmp_max_gain > now_max_gain || (tmp_max_gain == now_max_gain && tmp_min_used < now_min_used) ){\n\t\t\tnow_max_gain = tmp_max_gain;\n\t\t\tnow_min_used = tmp_min_used;\n\t\t}\n\t}\n\t\n\t*max_gain = now_max_gain;\n\t*min_used = now_min_used;\n}\n\n\nint main(void)\n{\n\t\n\t\n\twhile(1){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t}\n\t\t\n\t\tint max_gain, min_used;\n\t\tgetSolution(0, 0, 0, 0, &max_gain, &min_used);\n\t\t\n\t\tprintf(\"%d %d\\n\", max_gain, min_used);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define rep1(i,n) for(int i=1;i<=int(n);++i)\n#define all(a) a.begin(),a.end()\n#define lb(s,x) lower_bound(all(s),x)-s.begin()\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n#define INF 1e9\ntypedef long long ll;\n\n#define updmin(dp,x) (dp=(dp == 0 ? x : min(dp,x)))\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        vector<int> p(n);\n        rep(i,n) cin>>p[i];\n        // vector<map<int,int>> dp(n+1); // dp[get][coin] = pay\n        vector<vector<int>> dp(n+1, vector<int>(500*n,INF));\n        dp[0][0] = 0;\n        int coin_max = 0;\n        rep(i,n){\n            for(int k = i; k >= 0; k--){\n                // for(auto itr = dp[k].rbegin(); itr != dp[k].rend(); ++itr){\n                for(int coin = 500*n-1; coin>=0; coin--){\n                    if(dp[k][coin] == INF) continue;\n                    // int coin = itr->first;\n                    // coin_max = max(coin_max, coin);\n                    int pay = dp[k][coin];\n                    // int pay = itr->second;\n                    int mod = p[i]%500;\n                    if(p[i]%1000 == 0){\n                        if(coin>=500) updmin(dp[k+1][coin-500], pay+p[i]);\n                    }else if(p[i]%1000 == 500){\n                        updmin(dp[k+1][coin], pay+p[i]);\n                    }else if(p[i]%1000 <= 500){\n                        // if(mod+500<=coin){\n                        //     updmin(dp[k+1][coin-500-mod], pay+p[i]);\n                        // }else{\n                            updmin(dp[k+1][coin+500-mod], pay+p[i]);\n                        // }\n                    }else if(mod <= coin){\n                        updmin(dp[k+1][coin-mod], pay+p[i]);\n                    }else{\n                        updmin(dp[k][coin+500-mod], pay+p[i]);\n                    }\n                }\n            }\n        }\n        for(int i = n; i>=0; i--){\n            // if(dp[i].size()){\n                int res = INF;\n                for(auto itr : dp[i]){\n                    // res = min(res,itr.second);\n                    res = min(res,itr);\n\n                }\n                if(res != INF){\n                cout<<i<<\" \"<<res<<endl;\n                break;\n            }\n            // }\n        }\n        // debug(coin_max);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 500;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<vector<int>> dp(MAX + 1, vector<int>(n + 1, -1));\n\t\tdp[0][0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tfor (int j = MAX; j >= 0; j--) {\n\t\t\t\tfor (int k = n; k >= 0; k--) if (dp[j][k] != -1) {\n\t\t\t\t\tint val = (p + 999) / 1000;\n\t\t\t\t\tif (p % 1000 != 0 && p % 1000 <= 500) {\n\t\t\t\t\t\tdp[j + val][k + 1] = max(dp[j + val][k + 1], dp[j][k] + val * 1000 - p - 500);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[j + val][k] = max(dp[j + val][k], dp[j][k] + val * 1000 - p);\n\t\t\t\t\t\tif (val * 1000 - p + dp[j][k] >= 500) {\n\t\t\t\t\t\t\tdp[j + val][k + 1] = max(dp[j + val][k + 1], dp[j][k] + val * 1000 - p - 500);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt = 0, sum = 0;\n\t\tfor (int i = 0; i <= MAX; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) if (dp[i][j] != -1) {\n\t\t\t\tif (j > cnt) {\n\t\t\t\t\tcnt = j;\n\t\t\t\t\tsum = i * 1000 - j * 500 - dp[i][j];\n\t\t\t\t}\n\t\t\t\telse if (j == cnt) {\n\t\t\t\t\tsum = min(sum, i * 1000 - j * 500 - dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << ' ' << sum << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N;\nvoid solve() {\n    vector<int> shop(N);\n    for (auto& i : shop) cin >> i;\n\n    vector<int> diff(N);\n    for (int i = 0; i < N; i++) {\n        int d = shop[i] % 1000;\n        if (0 < d && d <= 500) diff[i] = 0;\n        else if (d > 500) diff[i] = d - 500;\n        else diff[i] = 500;\n    }\n\n    vector<vector<P> > dp(N + 1, vector<P>(500 * N + 1, P(0, -500 * N - 1)));\n    dp[0][0] = P(0, 0);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= 500 * i; j++) {\n            auto coin = dp[i][j];\n            if (coin.second == -500 * N - 1) continue;\n            dp[i+1][j] = max(dp[i+1][j], coin);\n            if (diff[i] == 0) {\n                P ncoin = P(coin.first + 1, coin.second - shop[i]);\n                int f = j + 500 - (shop[i] % 500);\n                dp[i+1][f] = max(dp[i+1][f], ncoin);\n            } else {\n                if (diff[i] <= j) {\n                    P ncoin = P(coin.first + 1, coin.second - shop[i]);\n                    int f = j - diff[i];\n                    dp[i+1][f] = max(dp[i+1][f], ncoin);\n                }\n\n                P pcoin = P(coin.first, coin.second - shop[i]);\n                int f_ = j + (shop[i] % 1000 ? 1000 - shop[i] % 1000 : 0);\n                dp[i+1][f_] = max(dp[i+1][f_], pcoin);\n            }\n        }\n    }\n\n    P ans(0, 0);\n    for (auto p : dp[N]) {\n        ans = max(ans, p);\n    }\n\n    cout << ans.first << \" \" << -ans.second << endl;\n}\n\nint main() {\n    while (cin >> N, N) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define M 25000\n\nint dp[101][101][M];\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int p[100],pp[100];\n    for(int i=0;i<n;i++)scanf(\"%d\",&p[i]),pp[i]=(1000-p[i]%1000)%1000;\n\n    for(int i=0;i<=n;i++)\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<M;k++)dp[i][j][k]=1e9;\n    \n    dp[0][0][0]=0;\n\n    for(int i=0;i<n;i++){\n      int mm=min(M,2*M*(i+1)/n);\n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<mm;k++){\n\t  int np=k+pp[i];\n\t  int nj=j;\n\t  if(np>=500)nj++,np-=500;\n\t  np=min(M-1,np);\n\t  dp[i+1][nj][np]=min(dp[i+1][nj][np],dp[i][j][k]+p[i]);\n\t  dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k]);\n\t  dp[i+1][nj][np]=min(dp[i+1][nj][np],dp[i][j][k]+p[i]);\n\t}\n    }\n    \n    int c=0,s=0;\n    for(int i=1;i<=n;i++)\n      for(int j=0;j<M;j++)\n\tif(dp[n%2][i][j]!=1e9&&i>=c){\n\t  if(c==i&&dp[n%2][i][j]<s)s=dp[n%2][i][j];\n\t  else if(c<i)c=i,s=dp[n%2][i][j];\n\t}\n    cout<<c<<\" \"<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\nstruct State {\n\tbool reached;\n\tint num_coins;\n\tint paid;\n};\n\nbool is_better(State& x, State& y) {\n\tif (!y.reached) return true;\n\tif (x.num_coins > y.num_coins) return true;\n\tif (x.num_coins < y.num_coins) return false;\n\treturn x.paid < y.paid;\n}\n\nconst int MAX_POCKET = 1000;\n\nint stores[100];\nState dp[100][MAX_POCKET];\n\nint main()\n{\n\twhile (true) {\n\t\tint n;\n\t\tstd::cin >> n;\n\n\t\tif (n == 0) return 0;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint p;\n\t\t\tstd::cin >> p;\n\t\t\tstores[i] = p;\n\t\t}\n\n\t\tstd::memset(dp, 0, sizeof(dp));\n\n\t\t{\n\t\t\tdp[0][0].reached = true;\n\n\t\t\tState state = { true, 0, stores[0] };\n\t\t\tint change = stores[0] % 1000;\n\t\t\tif (change != 0) {\n\t\t\t\tchange = 1000 - change;\n\t\t\t\tif (change >= 500) {\n\t\t\t\t\tstate.num_coins++;\n\t\t\t\t\tchange -= 500;\n\t\t\t\t}\n\t\t\t\tdp[0][change] = state;\n\t\t\t}\n\t\t}\n\n\t\tfor (int store_index = 1; store_index < n; store_index++) {\n\t\t\tfor (int pocket = 0; pocket < MAX_POCKET; pocket++) {\n\t\t\t\tState& prev_state = dp[store_index - 1][pocket];\n\t\t\t\tif (!prev_state.reached) continue;\n\n\t\t\t\t// ????????????\n\t\t\t\tif (is_better(prev_state, dp[store_index][pocket]))\n\t\t\t\t\tdp[store_index][pocket] = prev_state;\n\n\t\t\t\t// ??????\n\t\t\t\tint price = stores[store_index];\n\t\t\t\tfor (int pay_from_pocket = 0; pay_from_pocket <= pocket; pay_from_pocket++) {\n\t\t\t\t\tState new_state = prev_state;\n\t\t\t\t\tnew_state.paid += price;\n\n\t\t\t\t\tint p = price - pay_from_pocket;\n\t\t\t\t\twhile (p > 0) p -= 1000;\n\t\t\t\t\tint change = -p;\n\t\t\t\t\tif (change >= 500) {\n\t\t\t\t\t\tnew_state.num_coins++;\n\t\t\t\t\t\tchange -= 500;\n\t\t\t\t\t}\n\n\t\t\t\t\tint new_pocket = (pocket - pay_from_pocket + change) % 1000;\n\t\t\t\t\tif (is_better(new_state, dp[store_index][new_pocket]))\n\t\t\t\t\t\tdp[store_index][new_pocket] = new_state;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tState& best = dp[n - 1][0];\n\t\tfor (int i = 1; i < MAX_POCKET; i++) {\n\t\t\tState& current = dp[n - 1][i];\n\t\t\tif (current.reached && is_better(current, best))\n\t\t\t\tbest = dp[n - 1][i];\n\t\t}\n\n\t\tstd::cout << best.num_coins << \" \" << best.paid << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define updmax(dp,x) dp=(dp.first == 0 ? x : max(dp,x))\n\nusing P = pair<int,int>;\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        vector<int> p(n);\n        rep(i,n) cin>>p[i];\n        map<int,P> cur; // cur[coin] = <get,pay>\n        rep(i,n){\n            map<int,P> nxt;\n            updmax(cur[0],P(0,0));\n            for(auto &itr : cur){\n                int coin = itr.first;\n                int k = itr.second.first;\n                int pay = itr.second.second;\n                updmax(nxt[coin], P(k,pay));\n                pay -= p[i];\n                coin += (1000-p[i]%1000)%1000;\n                if(coin >= 500){\n                    updmax(nxt[coin-500], P(k+1, pay));\n                }else if(p[i]%1000){\n                    updmax(nxt[coin], P(k,pay));\n                }\n            }\n            cur = move(nxt);\n        }\n\n        P res = {0,0};\n        for(auto itr : cur){\n            res = max(res,itr.second);\n        }\n        cout<<res.first<<\" \"<<-res.second<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 100100100;\n\nint main(){\n\n    while(1){        \n        int n; cin >> n;\n        if(!n) break;\n        vector<int> a(n);\n        for(int i = 0; i < n; i++) cin >> a[i];\n\n        //i番目までの品物を見て、得られた500円玉がj枚で持ってる小銭がk円の時の消費金額の最小値\n        vector<vector<vector<int> > > dp(2, vector<vector<int> > (n + 1, vector<int> (500 * n + 1000, INF)));  \n        dp[0][0][0] = 0;\n        int now = 0;\n        int next = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j <= i; j++){\n                for(int k = 0; k <= 500 * n; k++){\n\n                    //買わない\n                    dp[next][j][k] = min(dp[next][j][k], dp[now][j][k]);\n\n                    //1000で割ったあまりによる場合わけ\n                    if(1 <= a[i] % 1000 && a[i] % 1000 <= 500){\n                        //1000札のみで払うのが最適\n                        //500円獲得\n                        dp[next][j + 1][(500 - a[i] % 1000) + k] = min(dp[next][j + 1][(500 - a[i] % 1000) + k], dp[now][j][k] + a[i]);\n                    }else{\n                        //1000円札のみで払う\n                        //500円玉は獲得できない\n                        dp[next][j][(1000 - a[i] % 1000) % 1000 + k] = min(dp[next][j][(1000 - a[i] % 1000) % 1000 + k], dp[now][j][k] + a[i]);\n\n                        //小銭を駆使して500円玉を獲得\n                        int need = a[i] % 1000 - 500;\n                        if(need == -500) need = 500;\n                        if(k - need >= 0) dp[next][j + 1][k - need] = min(dp[next][j + 1][k - need], dp[now][j][k] + a[i]);\n                    }\n                }\n            }\n            swap(now, next);\n        }\n\n        int ans1 = 0, ans2 = INF;\n        for(int j = 0; j <= n; j++){\n            for(int k = 0; k <= 500 * n; k++){\n                if(dp[now][j][k] != INF){\n                    if(ans1 < j || (ans1 == j && ans2 > dp[now][j][k])){\n                        ans1 = j;\n                        ans2 = dp[now][j][k];\n                    }\n                }\n            }\n        }\n\n        cout << ans1 << \" \" << ans2 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1 ; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1 ; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9+100;\nconst bool debug = 0;\n/***************************************/\n\nint N;\nint p[100];\nint dp[101][25001]; // 500円の枚数, 所持金(100円以下の小銭) = 最小購入金額\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tREP(i, N) scanf(\"%d\", p + i);\n\t\t\n\t\tint cut[101] = {};\n\t\tcut[N] = 0;\n\t\tfor (int i = N - 1; i >= 0; i--) {\n\t\t\tcut[i] = cut[i + 1];\n\t\t\tint chg = 1000 - (p[i] % 1000);\n\t\t\tchg %= 1000;\n\t\t\tif (chg < 500) cut[i] += chg - 500;\n\t\t}\n\t\t\n\t\tfill(dp[0], dp[N + 1], INF);\n\t\tdp[0][0] = 0;\n\t\t\n\t\tREP(t, N) {\n\t\t\tint chg = 1000 - (p[t] % 1000);\n\t\t\tchg %= 1000;\n\t\t\t\n\t\t\tfor (int i = N; i >= 0; i--) {\n\t\t\t\tfor (int j = min(25000, cut[i] + 10000); j >= 0; j--) {\n\t\t\t\t\tif (i) { // 購入して500円玉が増えた場合\n\t\t\t\t\t\tif (chg >= 500) {\n\t\t\t\t\t\t\tint cur = chg - 500; // 増加\n\t\t\t\t\t\t\tif (j - cur >= 0 && dp[i - 1][j - cur] != INF) chmin(dp[i][j], dp[i - 1][j - cur] + p[t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint cur = 500 - chg; // 減少\n\t\t\t\t\t\t\tif (j + cur <= 25000 && dp[i - 1][j + cur] != INF) chmin(dp[i][j], dp[i - 1][j + cur] + p[t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 購入して500円玉が増えなかった場合\n\t\t\t\t\tif (chg < 500 && j - chg >= 0 && dp[i][j - chg] != INF) chmin(dp[i][j], dp[i][j - chg] + p[t]);\n\t\t\t\t\t\n\t\t\t\t\t//小銭j円が多すぎて困ることはないので\n\t\t\t\t\tif (j) chmin(dp[i][j-1], dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpii ans;\n\t\tfor (int i = N; i >= 0; i--) {\n\t\t\tif (dp[i][0] == INF) continue;\n\t\t\tans = pii(i, dp[i][0]);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (debug) printf(\"@ \");\n\t\tprintf(\"%d %d\\n\", ans.fi, ans.se);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n\ntypedef std::pair<int, int> P;\n\nusing namespace std;\n\nconst int INF = 1001001001;\n\ntemplate<typename T>\nvoid maxe(T& a, T b){ a = max(a, b); }\n\nP dp[110][110 * 1000];\n\nint main()\n{\n\tint n;\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\tfor (int i = 0; i < 110; i++){\n\t\t\tfor (int j = 0; j < 110 * 1000; j++){\n\t\t\t\tdp[i][j] = P(0, -INF);\n\t\t\t}\n\t\t}\n\t\tP ans;\n\t\tdp[0][0] = P(0, 0);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint p;\n\t\t\tscanf(\"%d\", &p);\n\t\t\tfor (int j = 0; j < 110 * 1000; j++){\n\t\t\t\tif (dp[i][j].second == -INF) continue;\n\t\t\t\tmaxe(dp[i + 1][j], dp[i][j]);\n\t\t\t\tint x = (1000 - p % 1000) % 1000;\n\t\t\t\tif (j + x % 500 < 110 * 1000){\n\t\t\t\t\tmaxe(dp[i + 1][j + x % 500], P(dp[i][j].first + x / 500, dp[i][j].second - p));\n\t\t\t\t}\n\t\t\t\tif (j >= 500 - x && j - 500 + x < 110 * 1000) maxe(dp[i + 1][j - 500 + x], P(dp[i][j].first + 1, dp[i][j].second - p));\n\t\t\t}\n\t\t\tmaxe(ans, *max_element(dp[i + 1], dp[i + 1] + 110 * 1000));\n\t\t}\n\t\tprintf(\"%d %d\\n\", ans.first, -ans.second);\n\t}\n\t\n\treturn (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 100000000\n#define OTU 5000\nint d[101][OTU][2],oturi,otusum;\n\nbool otu(int p){\n    int j=0;\n    while(p>=10000)p-=10000;\n    while(p>=1000)p-=1000;\n    while(p>=500){\n        p-=500;\n        j++;\n    }\n    oturi=500-p;\n    \n    if(!p)return j%2+1;\n    return j%2;\n}\nint main()\n{\n    \n   while(1){\n        int n,p[102];\n        cin>>n;\n        if(!n)return 0;\n       for(int i=0;i<n;i++){\n           cin>>p[i+1];\n       }\n       otusum=1;\n       for(int sum=0;sum<101;sum++)\n           for(int j=0;j<OTU;j++){\n            d[sum][j][0]=INF;\n            d[sum][j][1]=INF;\n       }\n        d[0][0][0]=0;    \n       for(int i=1;i<=n;i++){\n           otusum+=500;\n           otusum=min(otusum,OTU);\n           if(p[i]%1000==0){\n               for(int j=0;j<otusum-500;j++){\n                   d[0][j][i%2]=d[0][j][(i-1)%2];\n                   for(int sum=1;sum<=i;sum++)\n                       d[sum][j][i%2]=min(d[sum][j][(i-1)%2],d[sum-1][j+500][(i-1)%2]+p[i]);\n               }\n               for(int j=otusum-500;j<otusum;j++)\n                   for(int sum=0;sum<=i;sum++)d[sum][j][i%2]=d[sum][j][(i-1)%2];\n           continue;\n           }\n            if(otu(p[i])){\n                for(int j=0;j<oturi;j++){\n                    d[0][j][i%2]=d[0][j][(i-1)%2];\n                    for(int sum=1;sum<=i;sum++)\n                    d[sum][j][i%2]=min(d[sum-1][j+500-oturi][(i-1)%2]+p[i],d[sum][j][(i-1)%2]);\n                }\n                for(int j=oturi;j<otusum-500+oturi;j++){\n                    d[0][j][i%2]=min(d[0][j][(i-1)%2],d[0][j-oturi][(i-1)%2]+p[i]);\n                    for(int sum=1;sum<=i;sum++)\n                    d[sum][j][i%2]=min(d[sum][j-oturi][(i-1)%2]+p[i],min(d[sum-1][j+500-oturi][(i-1)%2]+p[i],d[sum][j][(i-1)%2]));\n                }\n                for(int j=otusum-500+oturi;j<otusum;j++){\n                    d[0][j][i%2]=min(d[0][j][(i-1)%2],d[0][j-oturi][(i-1)%2]+p[i]);\n                    for(int sum=1;sum<=i;sum++)\n                    d[sum][j][i%2]=min(d[sum][j-oturi][(i-1)%2]+p[i],d[sum][j][(i-1)%2]);\n                }\n            }\n           else{\n               for(int j=0;j<oturi;j++){\n                    d[0][j][i%2]=d[0][j][(i-1)%2];\n                    for(int sum=1;sum<=i;sum++)\n                    d[sum][j][i%2]=d[sum][j][(i-1)%2];\n                }\n                for(int j=oturi;j<otusum;j++){\n                    d[0][j][i%2]=d[0][j][(i-1)%2];\n                    for(int sum=1;sum<=i;sum++)\n                    d[sum][j][i%2]=min(d[sum-1][j-oturi][(i-1)%2]+p[i],d[sum-1][j][(i-1)%2]+p[i]);\n                }\n            }\n          // int ans=INF;\n       //for(int sum=100;sum>=0;sum--){\n         //  for(int j=0;j<1000;j++){\n           // ans=min(d[sum][j][i%2],ans);\n             //  if(d[sum][j][i%2]<INF)\n               //cout<<\"i \"<<i<<\" sum \"<<sum<<\" ans \"<<ans<<\" oturi \"<<j<<endl;\n           //}\n           //if(ans<INF){\n             //  cout<<\"I　 \"<<i<<\" sum \"<<sum<<\" ans \"<<ans<<endl;\n               //break;\n         //  }\n       //}\n       \n       }\n       int ans=INF;\n       for(int sum=100;sum>=0;sum--){\n           for(int j=0;j<OTU;j++){\n            ans=min(d[sum][j][n%2],ans);\n           }\n           if(ans<INF){\n               cout<<sum<<\" \"<<ans<<endl;\n               break;\n           }\n       }  \n       \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\n#define MAX_C 100001\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nint m[MAX_N];\npii dp[2][MAX_C];\n\nvoid set_m(vector<int> &p)\n{\n    for (int i = 0; i < (int)p.size(); i++) {    \n        m[i] = ((p[i] - 1) / 1000 + 1) * 1000;\n    }\n}\n\nvoid update(pii &a, pii &b)\n{\n    if (a.first < b.first) {\n        a = b;\n    } else if (a.first == b.first) {\n        if (a.second > b.second) {\n            a = b;\n        }\n    }\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<int> p(N);\n        for (int i = 0; i < N; i++) {\n            cin >> p[i];\n        }\n        \n        set_m(p);\n        \n        memset(dp, -1, sizeof(dp));\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < MAX_C; j++) {\n                dp[i][j] = pii(-1, INF);\n            }\n        }\n        \n        dp[0][0] = pii(0, 0);\n        for (int i = 0; i < N; i++) {\n            int curr = (i & 1), next = !(i & 1);\n            for (int j = 0; j < MAX_C; j++) {\n                if (dp[curr][j].first == -1) continue;\n                \n                update(dp[next][j], dp[curr][j]);\n                \n                {\n                    int pay = m[i];\n                    int change = pay - p[i];                    \n\n                    int _500 = (change / 500);\n                    int nc = j + change - _500 * 500;                    \n                    \n                    pii ncost = pii(dp[curr][j].first + _500,\n                                    dp[curr][j].second + p[i]);                    \n                    \n                    update(dp[next][nc], ncost);\n                }\n                \n                {\n                    int pp = p[i] % 1000;\n                    if (pp > 500 || pp == 0) {\n                        if (abs(pp - 500) <= j) {\n                            int pay = m[i] + abs(pp - 500);\n                            int change = pay - p[i];\n                            int _500 = (change / 500);\n                            int nc = j - abs(pp - 500) + change - _500 * 500;\n                            \n                            pii ncost = pii(dp[curr][j].first + _500,\n                                            dp[curr][j].second + p[i]);                    \n                    \n                            update(dp[next][nc], ncost);\n                        }\n                    } \n                }\n            }\n            \n            for (int j = 0; j < MAX_C; j++) {\n                dp[curr][j] = pii(-1, INF);\n            }\n        }\n        \n        pii res = pii(-1, INF);\n        for (int i = 0; i < MAX_C; i++) {\n            update(res, dp[N&1][i]);            \n        }\n        cout << res.first << \" \" << res.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 100110;\nint main(){\n\n    while(1){        \n        int n; cin >> n;\n        if(!n) break;\n        vector<int> a(n);\n        for(int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n        //i番目までの品物を見て、持ってる小銭がj円の時の{500玉の個数、-消費金額}のmax\n        vector<vector<pair<int, int> > > dp(n + 1, vector<pair<int, int> > (500 * n + 1000, {-INF, -INF}));\n        //vector<vector<vector<int> > > dp(2, vector<vector<int> > (n + 1, vector<int> (500 * n + 1000, INF)));  \n        dp[0][0] = {0, 0};\n        pair<int, int> ans = {0, 0};\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j <= 500 * n; j++){\n\n                if(dp[i][j].first == -INF || dp[i][j].second == -INF) continue;\n                //cout << i << \" \" << j << \" \" << dp[i][j].first << \" \" << dp[i][j].second << endl;\n\n                //買わない\n                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);\n\n                //買うんだけども、これに場合分けが生じる\n                int r = a[i] % 1000;\n                //cout << r << endl;\n                if(1 <= r && r <= 500){\n                    //1000札のみで払い、お釣りを受け取るのが最適で、500円玉1枚加算される\n                    pair<int, int> next = dp[i][j];\n                    next.first++;\n                    next.second -= a[i];\n                    dp[i + 1][j + 500 - r] = max(dp[i + 1][j + 500 - r], next);\n                }else if(r == 0){\n                    //小銭があるのなら、500円玉に両替する感覚が適切な可能性あり\n                    //cout << \"ok\" << endl;\n                    pair<int, int> next = dp[i][j];\n                    next.first++;\n                    next.second -= a[i];\n                    if(j - 500 >= 0) dp[i + 1][j - 500] = max(dp[i + 1][j - 500], next);\n                }else{\n                    pair<int, int> next = dp[i][j];\n                    next.second -= a[i];\n                    //cout << \"ok\" << endl;\n                    //1000札のみを用いて、小銭を増やす作戦\n                    dp[i + 1][j + 1000 - r] = max(dp[i + 1][j + 1000 - r], next);\n                    //cout << dp[i + 1][j + 1000 - r].first << \" \" << dp[i + 1][j + 1000 - r].second << endl;\n                    //小銭を駆使して、500円玉を入手\n                    next.first++;\n                    if(j - r + 500 >= 0) dp[i + 1][j - r + 500] = max(dp[i + 1][j - r + 500], next);\n                    //cout << dp[i + 1][j + r - 500].first << \" \" << dp[i + 1][j + 1000 - r].second << endl;\n                    \n                }\n\n                \n            }\n        }\n\n        for(int j = 0; j < 500 * n + 1000; j++) ans = max(ans, dp[n][j]);\n        //cout << dp[1][0].first << \" \" << dp[1][0].second << endl;\n        cout << ans.first << \" \" << -ans.second << endl;\n        \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nP gre(P x, P y) {\n\tif (x.first > y.first)return x;\n\tif (x.first == y.first&&x.second < y.second)return x;\n\treturn y;\n}\nbool sor(P x, P y) {\n\tif (x.first > y.first)return true;\n\tif (x.first == y.first&&x.second < y.second)return true;\n\treturn false;\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tP dp[101][1000];\n\t\tint cost[101] = {};\n\t\trep(i, n) {\n\t\t\tcin >> cost[i];\n\t\t}\n\t\trep(i, 101) {\n\t\t\trep(j, 1000) {\n\t\t\t\tdp[i][j] = { -1,-1 };\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = { 0,0 };\n\t\trep(i, n) {\n\t\t\trep(j, 1000) {\n\t\t\t\tif (dp[i][j].first == -1)continue;\n\t\t\t\tdp[i + 1][j] = gre(dp[i+1][j], dp[i][j]);\n\t\t\t\tif (cost[i] % 1000 == 0) {\n\t\t\t\t\tif (j >= 500) {\n\t\t\t\t\t\tP res;\n\t\t\t\t\t\tres = { dp[i][j].first + 1,dp[i][j].second+cost[i] };\n\t\t\t\t\t\tdp[i+1][j - 500] = gre(dp[i+1][j - 500], res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (j < cost[i] % 1000) {\n\t\t\t\t\tif (1000 - cost[i] % 1000 + j >= 500) {\n\t\t\t\t\t\tP res;\n\t\t\t\t\t\tres = { dp[i][j].first + 1,dp[i][j].second + cost[i] };\n\t\t\t\t\t\tdp[i + 1][500 - cost[i] % 1000 + j] = gre(dp[i + 1][500 - cost[i] % 1000 + j], res);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tP res;\n\t\t\t\t\t\tres = { dp[i][j].first,dp[i][j].second + cost[i] };\n\t\t\t\t\t\tdp[i + 1][1000 - cost[i] % 1000 + j] = gre(dp[i + 1][1000 - cost[i] % 1000 + j], res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (1000 - cost[i] % 1000 >= 500) {\n\t\t\t\t\t\tP res;\n\t\t\t\t\t\tres = { dp[i][j].first + 1,dp[i][j].second + cost[i] };\n\t\t\t\t\t\tdp[i + 1][500 - cost[i] % 1000+j] = gre(dp[i + 1][500 - cost[i] % 1000+j],res);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tP res;\n\t\t\t\t\t\tres = { dp[i][j].first,dp[i][j].second + cost[i] };\n\t\t\t\t\t\tdp[i + 1][1000 - cost[i] % 1000 + j] = gre(dp[i + 1][1000 - cost[i] % 1000 + j], res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(dp[n], dp[n] + 1000, sor);\n\t\tcout << dp[n][0].first << \" \" << dp[n][0].second << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint f[200][2010],n,a[200],c[200][2010],z;\nint main(){\n\tscanf(\"%d\",&n);\n\twhile(n){\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=1000;j++){\n\t\t\tf[i][j]=-100000;\n\t\t\tc[i][j]=0;\n\t\t}\n\tf[0][0]=0;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<1000;j++)\n\t\t\tif(f[i][j]>=0){\n\t\t\t\tif(f[i+1][j]<f[i][j]||(f[i+1][j]==f[i][j]&&c[i+1][j]>c[i][j])){\n\t\t\t\t\tf[i+1][j]=f[i][j];\n\t\t\t\t\tc[i+1][j]=c[i][j];\n\t\t\t\t}\n\t\t\t\tint k=(0-a[i])%1000+1000;\n\t\t\t\tif(k==1000)k=0;\n\t\t\t\tif(k>=500){\n\t\t\t\t\tk-=500;\n\t\t\t\t\tint jj=(j+k)%1000;\n\t\t\t\t\tif(f[i+1][jj]<f[i+1][j]+1||(f[i+1][jj]==f[i][j]+1&&c[i+1][jj]>c[i][j]+a[i])){\n\t\t\t\t\t\tf[i+1][jj]=f[i][j]+1;\n\t\t\t\t\t\tc[i+1][jj]=c[i][j]+a[i];\n\t\t\t\t\t}\n\t\t\t\t}else if(j+k>=500){\n\t\t\t\t\tif(j+k<1000){\n\t\t\t\t\t\tint jj=(j+k-500);\n\t\t\t\t\t\t//f[i+1][jj]=max(f[i][j]+1,f[i+1][jj]);\n\t\t\t\t\tif(f[i+1][jj]<f[i+1][j]+1||(f[i+1][jj]==f[i][j]+1&&c[i+1][jj]>c[i][j]+a[i])){\n\t\t\t\t\t\tf[i+1][jj]=f[i][j]+1;\n\t\t\t\t\t\tc[i+1][jj]=c[i][j]+a[i];\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(f[i+1][j+k]<f[i][j]||(f[i+1][j+k]==f[i][j]&&c[i+1][j+k]>c[i][j])){\n\t\t\t\t\t\tf[i+1][j+k]=f[i][j];\n\t\t\t\t\t\tc[i+1][j+k]=c[i][j]+a[i];\n\t\t\t\t\t}\n\t\t\t\t\t//f[i+1][j+k]=max(f[i][j],f[i+1][j+k]);\n\t\t\t\t}\n\t\t\t}\n\tint ans=0,co=0;\n\tfor(int i=0;i<1000;i++)\n\t\tif(ans<f[n][i]||(ans==f[n][i]&&co>c[n][i])){\n\t\t\tans=f[n][i];\n\t\t\tco=c[n][i];\n\t\t}\n\tprintf(\"%d %d\\n\",ans,co);\n\tscanf(\"%d\",&n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n#define REP(i,x,n) for(int i = x; i < n; i++)\nconst int N = 1e5+10;\n\nvoid solve(int n) {\n\tvector<int> a(n);\n\tREP(i, 0, n) cin >> a[i];\n\n\tusing P = pair<int, int>;\n\n\tP dp[2][N];\n\tREP(i, 0, 2) REP(j, 0, N) dp[i][j] = P(-1000,0);\n\tdp[0][0] = P(0,0);\n\tREP(i, 0, n) {\n\t\tint tmp = a[i] % 1000;\n\t\tif (tmp == 0) tmp = 1000;\n\t\tREP(j, 0, N) dp[(i+1)&1][j] = P(-1000,0);\n\t\tREP(j, 0, 100001) {\n\t\t\tif (tmp <= 500) {\n\t\t\t\tif (j + 500 - tmp < N) dp[(i + 1) & 1][j + 500 - tmp] = max(dp[(i + 1) & 1][j + 500 - tmp], P(dp[i & 1][j].first+1,dp[i&1][j].second-a[i]));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (j - (tmp - 500) >= 0) dp[(i + 1)&1][j - (tmp - 500)] = max(dp[(i + 1)&1][j - (tmp - 500)], P(dp[i & 1][j].first + 1, dp[i & 1][j].second - a[i]));\n\t\t\t\tif(j+1000-tmp < N) dp[(i + 1)&1][j + 1000 -tmp] = max(dp[(i + 1)&1][j + 1000 - tmp], P(dp[i & 1][j].first, dp[i & 1][j].second - a[i]));\n\t\t\t}\n\t\t\tdp[(i + 1) & 1][j] = max(dp[(i + 1) & 1][j], dp[i & 1][j]);\n\t\t}\n\t}\n\n\tP ans = P(0,0);\n\tREP(i, 0, N) ans = max(ans, dp[n&1][i]);\n\n\tcout << ans.first << \" \" << -ans.second << endl;\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tsolve(n);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 2\n#define MAX_C 5001\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nint m[MAX_N];\npii dp[MAX_N][MAX_C];\n\nvoid set_m(vector<int> &p)\n{\n    for (int i = 0; i < (int)p.size(); i++) {    \n        m[i] = ((p[i] - 1) / 1000 + 1) * 1000;\n    }\n}\n\nvoid update(pii &a, pii &b)\n{\n    if (a.first < b.first) {\n        a = b;\n    } else if (a.first == b.first) {\n        if (a.second > b.second) {\n            a = b;\n        }\n    }\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<int> p(N);\n        for (int i = 0; i < N; i++) {\n            cin >> p[i];\n        }\n        \n        set_m(p);\n        \n        memset(dp, -1, sizeof(dp));\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < MAX_C; j++) {\n                dp[i][j] = pii(-1, INF);\n            }\n        }\n        \n        dp[0][0] = pii(0, 0);\n        for (int i = 0; i < N; i++) {\n            int curr = (i & 1), next = !(i & 1);\n            for (int j = 0; j < MAX_C; j++) {\n                if (dp[curr][j].first == -1) continue;\n                \n                update(dp[next][j], dp[curr][j]);\n                \n                for (int k = 0; k <= min(j, 999); k++) {\n                    int pay = m[i] + k;\n                    int change = pay - p[i];                    \n                    int _500 = change / 500;\n                    \n                    if (change >= 1000) continue;\n                    \n                    int nc = j - k + change - _500 * 500;\n                    \n                    pii ncost = pii(dp[curr][j].first + _500,\n                                    dp[curr][j].second + p[i]);                    \n                    \n                    update(dp[next][nc], ncost);\n                }\n            }\n            for (int j = 0; j < MAX_C; j++) {\n                dp[curr][j] = pii(-1, INF);\n            }\n        }\n        \n        pii res = pii(-1, INF);\n        for (int i = 0; i < MAX_C; i++) {\n            update(res, dp[N&1][i]);\n        }\n        cout << res.first << \" \" << res.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define updmax(dp,x) dp=(dp.first == 0 ? x : max(dp,x))\n\nusing P = pair<int,int>;\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        vector<int> p(n);\n        rep(i,n) cin>>p[i];\n        map<int,P> cur; // cur[coin] = <get,pay>\n        cur[0] = {0,0};\n        rep(i,n){\n            map<int,P> nxt;\n            for(auto &itr : cur){\n                int coin = itr.first;\n                int k = itr.second.first;\n                int pay = itr.second.second;\n                updmax(nxt[coin], P(k,pay));\n                pay -= p[i];\n                int mod = p[i]%500;\n                if(p[i]%1000 == 0){\n                    if(coin>=500) updmax(nxt[coin-500], P(k+1,pay));\n                }else if(p[i]%1000 == 500){\n                    updmax(nxt[coin], P(k+1,pay));\n                }else if(p[i]%1000 <= 500){\n                    updmax(nxt[coin+500-mod], P(k+1, pay));\n                }else if(mod <= coin){\n                    updmax(nxt[coin-mod], P(k+1,pay));\n                }else{\n                    updmax(nxt[coin+500-mod], P(k,pay));\n                }\n            }\n            cur = move(nxt);\n        }\n\n        P res = {0,0};\n        for(auto itr : cur){\n            res = max(res,itr.second);\n        }\n        cout<<res.first<<\" \"<<-res.second<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef int ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nconst ll M = 100*5000;\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n;\n    while (cin >> n, n) {\n        vector<ll> p(n); cin >> p;\n        vector<vector<P>> dp(n+1, vector<P>(M+1, {-1, -1}));\n        dp[0][0] = {0, 0};\n        rep(i, n) rep(j, M+1) {\n            if (dp[i][j].first < 0) continue;\n            ll c, r; tie(c, r) = dp[i][j];\n            if (0 < p[i] % 1000 && p[i] % 1000 <= 500) {\n                // ??????\n                assert(j+p[i] <= M);\n                chmax(dp[i+1][j+p[i]], P(c+1, r+(500-p[i]%1000)));\n            }\n            else {\n                // ????????????\n                chmax(dp[i+1][j], dp[i][j]);\n                // ???????????????\n                chmax(dp[i+1][j+p[i]], P(c, r+(1000-p[i]%1000)%1000));\n                // 500????????????????????????????????????\n                ll need = (p[i]+500) % 1000;\n                if (r >= need) {\n                    chmax(dp[i+1][j+p[i]], P(c+1, r-need));\n                }\n            }\n        }\n        P ans{0, 0};\n        rep(i, M+1) {\n            chmax(ans, P(dp[n][i].first, -i));\n        }\n        cout << ans.first << \" \" << -ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define updmax(dp,x) dp=(dp.first == 0 ? x : max(dp,x))\n\nusing P = pair<int,int>;\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        vector<int> p(n);\n        rep(i,n) cin>>p[i];\n        map<int,P> cur; // cur[coin] = <get,pay>\n        cur[0] = {0,0};\n        rep(i,n){\n            map<int,P> nxt;\n            for(auto &itr : cur){\n                int coin = itr.first;\n                int k = itr.second.first;\n                int pay = itr.second.second;\n                updmax(nxt[coin], P(k,pay));\n                pay -= p[i];\n                coin += (1000-p[i]%1000)%1000;\n                if(coin >= 500){\n                    updmax(nxt[coin-500], P(k+1, pay));\n                }else{\n                    updmax(nxt[coin], P(k,pay));\n                }\n            }\n            cur = move(nxt);\n        }\n\n        P res = {0,0};\n        for(auto itr : cur){\n            res = max(res,itr.second);\n        }\n        cout<<res.first<<\" \"<<-res.second<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_N 100\n#define MAX_C 100001\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n \nint m[MAX_N];\npii dp[2][MAX_C];\n \nvoid set_m(vector<int> &p)\n{\n    for (int i = 0; i < (int)p.size(); i++) {    \n        m[i] = ((p[i] - 1) / 1000 + 1) * 1000;\n    }\n}\n \nvoid update(pii &a, pii &b)\n{\n    if (a.first < b.first) {\n        a = b;\n    } else if (a.first == b.first) {\n        if (a.second > b.second) {\n            a = b;\n        }\n    }\n}\n \nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<int> p(N);\n        for (int i = 0; i < N; i++) {\n            cin >> p[i];\n        }\n         \n        set_m(p);\n         \n        memset(dp, -1, sizeof(dp));\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < MAX_C; j++) {\n                dp[i][j] = pii(-1, INF);\n            }\n        }\n         \n        dp[0][0] = pii(0, 0);\n        for (int i = 0; i < N; i++) {\n            int curr = (i & 1), next = !(i & 1);\n            for (int j = 0; j < MAX_C; j++) {\n                if (dp[curr][j].first == -1) continue;\n                 \n                update(dp[next][j], dp[curr][j]);\n                 \n                {\n                    int pay = m[i];\n                    int change = pay - p[i];                    \n \n                    int _500 = (change / 500);\n                    int nc = j + change - _500 * 500;                    \n                     \n                    pii ncost = pii(dp[curr][j].first + _500,\n                                    dp[curr][j].second + p[i]);                    \n                     \n                    update(dp[next][nc], ncost);\n                }\n                 \n                {\n                    int pp = p[i] % 1000;\n                    if (pp > 500 || pp == 0) {\n                        if (abs(pp - 500) <= j) {\n                            int pay = m[i] + abs(pp - 500);\n                            int change = pay - p[i];\n                            int _500 = (change / 500);\n                            int nc = j - abs(pp - 500) + change - _500 * 500;\n                             \n                            pii ncost = pii(dp[curr][j].first + _500,\n                                            dp[curr][j].second + p[i]);                    \n                     \n                            update(dp[next][nc], ncost);\n                        }\n                    } \n                }\n            }\n             \n            for (int j = 0; j < MAX_C; j++) {\n                dp[curr][j] = pii(-1, INF);\n            }\n        }\n         \n        pii res = pii(-1, INF);\n        for (int i = 0; i < MAX_C; i++) {\n            update(res, dp[N&1][i]);            \n        }\n        cout << res.first << \" \" << res.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\n#define INF 10000000\nusing namespace std;\n\nstruct state {\n  int n, cost;\n  bool operator<(const state s) const {\n    if(n < s.n) return true;\n    if(n > s.n) return false;\n    return cost > s.cost;\n  }\n};\n\nint N, P[100];\nstate dp[2][50000];\n\nstate max_state(state a, state b) {\n  return a < b ? b : a;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> P[i];\n\n    int current = 0, next = 1;\n    state m = (state) { 0, INF };\n    REP(i, 0, 2) REP(j, 0, 50000) dp[i][j] = m;\n    dp[current][0].cost = 0;\n\n    REP(i, 0, N) {\n      REP(j, 0, 50000) dp[next][j] = dp[current][j];\n      REP(j, 0, 50000) {\n        int change = (1000 - P[i] % 1000) % 1000;\n        int n = dp[current][j].n;\n        int cost = dp[current][j].cost;\n        int nn, ncost, nj;\n        if(cost >= INF) continue;\n        if(change >= 500) {\n          nn = n + 1;\n          nj = j + change - 500;\n        } else if(change < 500) {\n          if(j >= (500 - change)) {\n            nn = n + 1;\n            nj = j - (500 - change);\n          } else {\n            nn = n;\n            nj = j + change;\n          }\n        }\n        ncost = cost + P[i];\n        dp[next][nj] = max_state(dp[next][nj], (state) { nn, ncost });\n      }\n      swap(current, next);\n    }\n\n    state ans = m;\n    REP(i, 0, 50000) ans = max_state(ans, dp[current][i]);\n    cout << ans.n << \" \" << ans.cost << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\n\nbool cmp(pair< int, int > a, pair< int, int > b)\n{\n  if(a.first != b.first) return(a.first > b.first);\n  return(a.second < b.second);\n}\nint main()\n{\n  int N, p[100];\n  \n  while(scanf(\"%d\", &N), N) {\n    for(int i = 0; i < N; i++) {\n      scanf(\"%d\", &p[i]);\n    }\n    \n    pair< int, int > dp[2][50001];\n    fill_n(*dp, 2 * 50001, make_pair(-INF, INF));\n    pair< int, int > *now = dp[0], *nxt = dp[1];\n    \n    now[0] = {0, 0};\n    int reach = 0;\n    for(int i = 0; i < N; i++) {\n      int mod = p[i] % 1000;\n      if(1 <= mod && mod <= 500) {\n        int rev = 1000 - mod - 500;\n        reach += rev;\n        for(int j = reach; j >= rev; j--) {\n          nxt[j] = min(nxt[j], {now[j - rev].first + 1, now[j - rev].second + p[i]}, cmp);\n        }\n      } else {\n        int rev = (1000 - mod) % 1000;\n        int need = (mod + 500) % 1000;\n        reach += max(rev, need);\n        for(int j = reach; j >= 0; j--) {\n          nxt[j] = min(nxt[j], now[j], cmp);\n        }\n        for(int j = reach; j >= rev; j--) {\n          nxt[j] = min(nxt[j], {now[j - rev].first, now[j - rev].second + p[i]}, cmp);\n        }\n        for(int j = need; j <= reach; j++) {\n          nxt[j - need] = min(nxt[j - need], {now[j].first + 1, now[j].second + p[i]}, cmp);\n        }\n      }\n      swap(now, nxt);\n      for(int j = 0; j <= reach; j++) nxt[j] = {-INF, INF};\n    }\n    auto p = *min_element(now, now + 50000, cmp);\n    printf(\"%d %d\\n\", p.first, p.second);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nstruct State {\n\tint fives, pay;\n};\n\nState comp(const State s1, const State s2) {\n\tif(s1.fives != s2.fives)\n\t\treturn s1.fives > s2.fives ? s1 : s2;\n\treturn s1.pay < s2.pay ? s1 : s2;\n}\n\n\nconst int INF = 1 << 25;\nconst int MAX = 100010;\nState dp[101][MAX];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile(cin >> n, n) {\n\n\t\tfor(int i = 0; i < n + 1; i++) {\n\t\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\t\tdp[i][j].fives = -1;\n\t\t\t\tdp[i][j].pay = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][0].fives = 0;\n\t\tdp[0][0].pay = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint p;\n\t\t\tcin >> p;\n\n\t\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\t\tif(dp[i][j].fives == -1) continue;\n\n\t\t\t\t// ??????\n\t\t\t\tdp[i + 1][j] = comp(dp[i + 1][j], dp[i][j]);\n\t\t\t\t// ?????????\n\t\t\t\tif(p % 1000 <= 500) {\n\t\t\t\t\tif(p % 1000 != 0) {\n\t\t\t\t\t\tint nj = 500 - p % 500;\n\t\t\t\t\t\tState ns = State{ dp[i][j].fives + 1, dp[i][j].pay + p };\n\t\t\t\t\t\tdp[i + 1][nj] = comp(dp[i + 1][nj], ns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint nj = 1000 - p % 1000;\n\t\t\t\t\tState ns = State{ dp[i][j].fives, dp[i][j].pay + p };\n\t\t\t\t\tdp[i + 1][nj] = comp(dp[i + 1][nj], ns);\n\t\t\t\t}\n\n\t\t\t\t// ?????£??????\n\t\t\t\tif(p % 1000 <= 500) {\n\t\t\t\t\tif(p % 1000 + 500 <= j) {\n\t\t\t\t\t\tint nj = j - (p % 1000 + 500);\n\t\t\t\t\t\tState ns = State{ dp[i][j].fives + 1, dp[i][j].pay + p };\n\t\t\t\t\t\tdp[i + 1][nj] = comp(dp[i + 1][nj], ns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(p % 500 <= j) {\n\t\t\t\t\t\tint nj = j - p % 500;\n\t\t\t\t\t\tState ns = State{ dp[i][j].fives + 1, dp[i][j].pay + p };\n\t\t\t\t\t\tdp[i + 1][nj] = comp(dp[i + 1][nj], ns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tState ans = State{ -1, INF };\n\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\tif(dp[n][j].fives != -1) {\n\t\t\t\tans = comp(ans, dp[n][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ans.fives << \" \" << ans.pay << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\ntypedef long long ll;\nusing namespace std;\n\npair<int,int> dp[2][200001];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n;\n\twhile(cin>>n,n){\n\t\tint a[201];\n\t\tfill(a,a+201,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a[i];\n\t\t}\n\t\tfor(int i=0;i<=200000;i++)dp[0][i]=make_pair(-1,0);\n\t\tdp[0][0]=make_pair(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<=200000;j++)dp[(i+1)&1][j]=make_pair(-1,0);\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tif(dp[i&1][j].fi==-1)continue;\n\t\t\t\tint tmp=a[i]%1000;\n\t\t\t\tif(tmp<=500 && tmp>=1){\n\t\t\t\t\tif(dp[(i+1)&1][j+500-tmp]<make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i])){\n\t\t\t\t\t\tdp[(i+1)&1][j+500-tmp]=make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i]);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tint pay=(tmp+500)%1000;\n\t\t\t\t\tdp[(i+1)&1][j]=max(dp[(i+1)&1][j],dp[i&1][j]);\n\t\t\t\t\tif(pay<=j){\n\t\t\t\t\t\tif(dp[(i+1)&1][j-pay]<make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i])){\n\t\t\t\t\t\t\tdp[(i+1)&1][j-pay]=make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint pay2=(1000-tmp)%1000;\n\t\t\t\t\tif(dp[(i+1)&1][j+pay2]<make_pair(dp[i&1][j].fi,dp[i&1][j].se-a[i])){\n\t\t\t\t\t\tdp[(i+1)&1][j+pay2]=make_pair(dp[i&1][j].fi,dp[i&1][j].se-a[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int,int> ans=make_pair(0,0);\n\t\tfor(int i=0;i<=200000;i++){\n\t\t\tif(dp[n&1][i]>ans){\n\t\t\t\tans=make_pair(dp[n&1][i].fi,dp[n&1][i].se);\n\t\t\t}\n\t\t}\n\t\tcout<<ans.fi<<\" \"<<-ans.se<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * D.cpp\n *\n *  Created on: 2017/07/01\n *      Author: LitMc\n */\n\n//#define MYDEBUG\n#include <bits/stdc++.h>\n\n#ifdef MYDEBUG\n#define dbp(x) cout<<#x<<\": \"<<x<<endl\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define dbp4(w,x,y,z) cout<<#w<<\",\"<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<w<<\",\"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define ifcin(x) std::ifstream cin(x)\n#else\n#define dbp(x)\n#define dbp2(x,y)\n#define dbp3(x,y,z)\n#define dbp4(w,x,y,z)\n#define ifcin(x)\n#endif\n#define ll long long\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define rep(i, from, to) for(int i=from; i<to; ++i)\n#define REP(i, from, to) for(int i=from; i<=to; ++i)\n#define EPS = 1e-14;\nusing std::vector;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::max;\nusing std::min;\nusing std::swap;\nusing std::string;\nusing std::fill;\nusing std::pair;\nusing std::sort;\nusing std::reverse;\nusing std::pair;\nusing std::greater;\nusing std::priority_queue;\nusing std::ostream;\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n  for (size_t i = 0; i < v.size(); ++i) {\n    out << v[i] << endl;\n  }\n  return out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n  out << \"[\";\n  size_t last = v.size() - 1;\n  for (size_t i = 0; i < v.size(); ++i) {\n    out << v[i];\n    if (i != last) {\n      out << \",\";\n    }\n  }\n  out << \"]\";\n  return out;\n}\ntypedef pair<int, int> P;\nbool cmp(const P &p1, const P &p2) {\n  if (p1.first == p2.first) {\n    return p1.second > p2.second;\n  } else {\n    return p1.first < p2.first;\n  }\n}\nstatic const int MAX_N = 102;\nstatic const int MAX_E = 1000 * MAX_N; //10^5\nint n;\nint p[MAX_N];\nP dp[MAX_N][MAX_E];\n//P ch[MAX_N][MAX_E]; //??????????????¨\n//dp[i][k]: k????°?????????????????????¶?????§???i????????\\????????????????????£?????????????????????????????§???\n//dp[1][0]: ?¬??????????\n//dp[n+1][*]: ?????????(0???, 0???)\n\nvoid init() {\n  rep(i,0,MAX_N)\n  {\n    p[i] = 0;\n    rep(j,0,MAX_E)\n    {\n      dp[i][j] = P(0, 0);\n    }\n  }\n}\n\n//ex: 900\n//p: 400\n//1900?????????\n//1000 = (400+1000-1)/1000\n//900: ex\n//1900 - 400 = 1500\n//%1000????????¨500, 1???get\n//??????\n//base: (p + 1000 - 1) / 1000 : 1000???????????§??????????????????\n//?????????????????£????????¨?????????: ex\n//????????????: base + ex\n//????????????: ret = (base+ex) - p\n//????????????500??????????????°: ret%1000\n//?????????????????????: p\n//500????????????????????????????????£???: ret - ((ret%1000) / 500) * 500\n//100?????????????????????, ?°????700???\n//1000 + 700 - 100 = 1600\n//1600%1000 = 600\n//600/500 = 1\n//?????£???: 1600 - 1*500 = 1100\n//1700????????£???+1100???(600???????????????)\n//????±???????????????£????????????p???????????????????????????????????£????????????????????£?????????\n\n//??????price??????1000???????????§???????????????????????????\nint only1000(int &price) {\n  return ((price + 1000 - 1) / 1000) * 1000;\n}\n\nvoid doDP() {\n  rep(k,0,MAX_E)\n  {\n    dp[n + 1][k] = P(0, 0);\n  }\n  for (int i = n; i >= 1; --i) {\n    int base = only1000(p[i]);\n    int pay, ret, get; //get: 500??????????????????????????°(0???1)\n    rep(ex,0, MAX_E-1000) //1??????1000?????\\???????°???????????????\\???????????¨?????????\n    {\n      P nobuy, buy1000, try500; //???????????§??????????????¢????????§??????3???(????????????, ?°??????????, 500????????????)w\n      //????????????\n      nobuy = dp[i + 1][ex];\n      //??????\n      //    ?°?????????£???????????????\n      pay = base;\n      ret = pay - p[i];\n      get = ret / 500;\n      ret -= get * 500;      //500??????????????????????????????????¶??????????\n      buy1000 = dp[i + 1][ret + ex];      //?°?????????????????????£????????§???????¶????\n      buy1000.first += get;\n      buy1000.second += p[i];\n//      int ret1000 = ret;\n      //    500?????????????????????\n      int usedEx = 0;\n      pay = base;\n      ret = pay - p[i];\n      if (ret >= 500) {      //500??????????°?????????¢???????????????\n        usedEx = 0;\n        get = ret / 500;\n        ret -= get * 500;\n      } else if (ret + ex >= 500) {      //?°???????????????°500?????????????????§??????\n        usedEx = 500 - ret;\n        pay += usedEx;\n        ret = pay - p[i];      //??????500??????????????????\n        get = ret / 500;\n        ret -= get * 500;\n      } else {\n        //1000???????????§?????£???????°????????????£??????500??????????????§?????????\n        usedEx = 0;\n      }\n      try500 = dp[i + 1][ret + ex - usedEx];\n      try500.first += get;\n      try500.second += p[i];\n      P best = max(buy1000, try500, cmp);\n      best = max(best, nobuy, cmp);\n//      if (best == nobuy) {\n//        ch[i][ex] = P(i + 1, ex);\n//      } else if (best == buy1000) {\n//        ch[i][ex] = P(i + 1, ret1000);\n//      } else if (best == try500) {\n//        ch[i][ex] = P(i + 1, ret);\n//      }\n      dp[i][ex] = best;\n    }\n  }\n}\n\n//void trace() {      //???????????????????????°??¨\n//  int i = 1;\n//  int ex = 0;\n//  REP(t,1,4)\n//  {\n//    dbp4(i, ex, dp[i][ex].first, dp[i][ex].second);\n//    P next = ch[i][ex];\n//    i = next.first;\n//    ex = next.second;\n//  }\n//}\n\nvoid solve() {\n  while (cin >> n, n) {\n    init();\n    REP(i,1,n)\n    {\n      cin >> p[i];\n    }\n    doDP();\n    cout << dp[1][0].first << \" \" << dp[1][0].second << endl;\n  }\n}\n\nint main() {\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_num_500,int arg_kozeni){\n\t\tnum_500 = arg_num_500;\n\t\tkozeni = arg_kozeni;\n\t}\n\n\tint num_500,kozeni;\n};\n\nint N,max_kozeni[101],max_500,next_max_500,next_max_kozeni[101];\nint** dp;\nint** next_dp;\n\nvoid func(){\n\n\tint P;\n\tmax_500 = 0;\n\tfor(int i = 0; i <= N; i++){\n\t\tmax_kozeni[i] = 0;\n\t}\n\n\tfor(int i = 0; i <= N; i++){\n\t\tfor(int k = 0; k <= 1000*N;k++){\n\t\t\tdp[i][k] = BIG_NUM;\n\t\t\tnext_dp[i][k] = BIG_NUM;\n\t\t}\n\t}\n\n\tvector<Info> Updated;\n\n\tdp[0][0] = 0;\n\tnext_dp[0][0] = 0;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d\",&P);\n\t\tnext_max_500 = max_500;\n\n\t\tfor(int num_500 = 0; num_500 <= max_500; num_500++){\n\n\t\t\tfor(int i = 0;i <= N; i++){\n\t\t\t\tnext_max_kozeni[i] = max_kozeni[i];\n\t\t\t}\n\n\t\t\tfor(int kozeni = 0; kozeni <= max_kozeni[num_500]; kozeni++){\n\t\t\t\tif(dp[num_500][kozeni] == BIG_NUM)continue;\n\n\t\t\t\tif(P%1000 == 0){\n\n\t\t\t\t\tif(kozeni >= 500){\n\t\t\t\t\t\tnext_max_500 = max(next_max_500,num_500+1);\n\t\t\t\t\t\tint next_kozeni = kozeni-500;\n\n\t\t\t\t\t\tif(dp[num_500+1][next_kozeni] > dp[num_500][kozeni]+P){\n\t\t\t\t\t\t\tif(next_dp[num_500+1][next_kozeni] > dp[num_500][kozeni]+P){\n\t\t\t\t\t\t\t\tnext_dp[num_500+1][next_kozeni] = dp[num_500][kozeni]+P;\n\t\t\t\t\t\t\t\tUpdated.push_back(Info(num_500+1,next_kozeni));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnext_max_kozeni[num_500+1] = max(next_max_kozeni[num_500+1],next_kozeni);\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\n\t\t\t\t\tint got_kozeni = 1000*((P/1000)+1)-P;\n\n\t\t\t\t\tnext_max_kozeni[num_500] = max(next_max_kozeni[num_500],kozeni+got_kozeni);\n\t\t\t\t\tif(dp[num_500][kozeni+got_kozeni] > dp[num_500][kozeni]+P){\n\t\t\t\t\t\tif(next_dp[num_500][kozeni+got_kozeni] > dp[num_500][kozeni]+P){\n\t\t\t\t\t\t\tnext_dp[num_500][kozeni+got_kozeni] = dp[num_500][kozeni]+P;\n\t\t\t\t\t\t\tUpdated.push_back(Info(num_500,kozeni+got_kozeni));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(got_kozeni+kozeni >= 500){\n\t\t\t\t\t\tnext_max_500 = max(next_max_500,num_500+1);\n\t\t\t\t\t\tint next_kozeni = got_kozeni+kozeni-500;\n\t\t\t\t\t\tif(dp[num_500+1][next_kozeni] > dp[num_500][kozeni]+P){\n\t\t\t\t\t\t\tif(next_dp[num_500+1][next_kozeni] > dp[num_500][kozeni]+P){\n\t\t\t\t\t\t\t\tnext_dp[num_500+1][next_kozeni] = dp[num_500][kozeni]+P;\n\t\t\t\t\t\t\t\tUpdated.push_back(Info(num_500+1,next_kozeni));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext_max_kozeni[num_500+1] = max(next_max_kozeni[num_500+1],next_kozeni);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Updated.size(); i++){\n\t\t\tdp[Updated[i].num_500][Updated[i].kozeni] = next_dp[Updated[i].num_500][Updated[i].kozeni];\n\t\t}\n\t\tUpdated.clear();\n\n\t\tfor(int i = 0; i <= N; i++){\n\t\t\tmax_kozeni[i] = next_max_kozeni[i];\n\t\t}\n\n\t\tmax_500 = next_max_500;\n\t}\n\n\tint minimum = BIG_NUM;\n\tfor(int i = 0; i <= max_kozeni[max_500]; i++){\n\t\tminimum = min(minimum,dp[max_500][i]);\n\t}\n\n\tprintf(\"%d %d\\n\",max_500,minimum);\n}\n\nint main(){\n\n\tdp = new int*[101];\n\tnext_dp = new int*[101];\n\n\tfor(int i = 0; i <= 100; i++){\n\t\tdp[i] = new int[50001];\n\t\tnext_dp[i] = new int[50001];\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\ntypedef long long ll;\nusing namespace std;\n\npair<int,int> dp[2][200001];\n//bool past[2][200001];\nconst int inf=1000000000;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n;\n\twhile(cin>>n,n){\n\t\tint a[201];\n\t\tfill(a,a+201,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a[i];\n\t\t}\n\t\tfor(int i=0;i<=200000;i++)dp[0][i]=make_pair(-1,0);\n\t\tdp[0][0]=make_pair(0,0);\n\t\t//for(int i=0;i<2;i++)for(int j=0;j<=200000;j++)past[i][j]=0;\n\t\t//past[0][0]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\t//for(int j=0;j<=200000;j++)past[(i+1)&1][j]=0;\n\t\t\tfor(int j=0;j<=200000;j++)dp[(i+1)&1][j]=make_pair(-1,0);\n\t\t\tfor(int j=0;j<=200000;j++){\n\t\t\t\tif(dp[i&1][j].fi==-1)continue;\n\t\t\t\t//cerr<<\"dp[\"<<j<<\"]=(\"<<dp[j].fi<<\",\"<<dp[j].se<<\")\\n\";\n\t\t\t\tdp[(i+1)&1][j]=make_pair(dp[i&1][j].fi,dp[i&1][j].se);\n\t\t\t\tint tmp=a[i]%1000;\n\t\t\t\tif(tmp<=500 && tmp>=1){\n\t\t\t\t\tif(dp[i&1][j+500-tmp]<make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i])){\n\t\t\t\t\t\t//past[(i+1)&1][j+500-tmp]=1;\n\t\t\t\t\t\tdp[(i+1)&1][j+500-tmp]=make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i]);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tint pay=(tmp+500)%1000;\n\t\t\t\t\tif(pay<=j){\n\t\t\t\t\t\tif(dp[i&1][j-pay]<make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i])){\n\t\t\t\t\t\t\t//past[(i+1)&1][j-pay]=1;\n\t\t\t\t\t\t\tdp[(i+1)&1][j-pay]=make_pair(dp[i&1][j].fi+1,dp[i&1][j].se-a[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint pay2=(1000-tmp)%1000;\n\t\t\t\t\tif(dp[i&1][j+pay2]<make_pair(dp[i&1][j].fi,dp[i&1][j].se-a[i])){\n\t\t\t\t\t\t//past[(i+1)&1][j+pay2]=1;\n\t\t\t\t\t\tdp[(i+1)&1][j+pay2]=make_pair(dp[i&1][j].fi,dp[i&1][j].se-a[i]);\n\t\t\t\t\t}\n\t\t\t\t\t//if(dp[j].se-a[i]==-2100)cerr<<dp[j].se<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int,int> ans=make_pair(0,0);\n\t\tfor(int i=0;i<=200000;i++){\n\t\t\tif(dp[n&1][i]>ans){\n\t\t\t\t//cerr<<\"dp[\"<<i<<\"]=(\"<<dp[i].fi<<\",\"<<dp[i].se<<\")\\n\";\n\t\t\t\tans=make_pair(dp[n&1][i].fi,dp[n&1][i].se);\n\t\t\t}\n\t\t}\n\t\tcout<<ans.fi<<\" \"<<-ans.se<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nint n;\nint d[110];\n\nconst int vmax=499*100+1;\nint dp[110][vmax];\nint dp2[110][vmax];\n\nint main(void){\n\twhile(cin >> n,n){\n\t\trep(i,n) cin >> d[i];\n\t\trep(i,n+1)rep(j,vmax) dp[i][j]=-1,dp2[0][0]=0;\n\t\tdp[0][0]=0;\n\t\trep(i,n)rep(j,vmax){\n\t\t\tif(dp[i][j]==-1) continue;\n\t\t\tif(dp[i+1][j]<dp[i][j]||(dp[i][j]==dp[i+1][j]&&dp2[i][j]<dp2[i+1][j])){\n\t\t\t\tdp[i+1][j]=dp[i][j];\n\t\t\t\tdp2[i+1][j]=dp2[i][j];\n\t\t\t}\n\t\t\tint next=dp[i][j];\n\t\t\tint next2=dp2[i][j]+d[i];\n\t\t\tint change=(5000-d[i])%1000;\n\t\t\tint nj=j+change;\n\t\t\tif(nj>=500) next++,nj-=500;\n\t\t\tif(dp[i+1][nj]<next||(next==dp[i+1][nj]&&next2<dp2[i+1][nj])){\n\t\t\t\tdp[i+1][nj]=next;\n\t\t\t\tdp2[i+1][nj]=next2;\n\t\t\t}\n\t\t}\n\t\tint ans=0,ans2=0;\n\t\trep(j,vmax){\n\t\t\tif(ans<dp[n][j]||(dp[n][j]==ans&&dp2[n][j]<ans2)){\n\t\t\t\tans=dp[n][j];\n\t\t\t\tans2=dp2[n][j];\n\t\t\t}\n\t\t}\n\t\tcout << ans << \" \" << ans2 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nusing namespace std;\nint a=0;\nvector<string>sts;\nvector<int>ens;\nint getnum(){\n  if(sts[a]==\"*\"){\n    int num=1;\n    int pe=ens[a];\n    a++;\n    while(ens[a]==pe){\n      num*=getnum();\n    }\n    a++;\n    return num;\n  }\n    else if(sts[a]==\"+\"){\n      int num=0;\n      int pe=ens[a];\n      a++;\n      while(ens[a]==pe){\n\tnum+=getnum();\n      }\n      a++;\n      return num;\n    }else{\n      int num=stoi(sts[a]);\n      a++;\n      return num;\n    }\n}\nint main()\n{\n  while(1){\n    int n;cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;++i){\n      string st;cin>>st;\n      int n=st.find_first_not_of(\".\");\n      sts.push_back(st.substr(n));\n      ens.push_back(n);\n    }\n    int ans=getnum();\n    cout<<ans<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\nconst int M = 1000000007;\n\nint main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n        \n        int lim = n * 499 + 1;\n        vector<P> dp(lim, P(-M, -M));\n        dp[0] = P(0, 0);\n        for (int i = 0; i < n; ++i) {\n            int p;\n            cin >> p;\n            vector<P> nex = dp;\n            int q = (500 - p % 500) % 500;\n            if (p % 1000 > 0 && p % 1000 <= 500)\n                for (int j = q; j < lim; ++j)\n                    nex[j] = max(nex[j], P(dp[j - q].first + 1, dp[j - q].second - p));\n\n            else {\n                int r = p % 500 == 0 ? 500 : p % 500;\n                for (int j = q; j < lim; ++j)\n                    nex[j] = max(nex[j], P(dp[j - q].first, dp[j - q].second - p));\n                for (int j = 0; j + r < lim; ++j)\n                    nex[j] = max(nex[j], P(dp[j + r].first + 1, dp[j + r].second - p));\n            }\n            dp = nex;\n        }\n        int ma = 0, mi = 0;\n        for (auto& a : dp) {\n            if (a.first > ma) {\n                ma = a.first;\n                mi = -a.second;\n            }\n            else if (a.first == ma && -a.second < mi)\n                mi = -a.second;\n        }\n        cout << ma << \" \" << mi << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  const int CMAX = 50000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 49900... too much?\n    // # of 500 got so far : at most 100\n    // value : minimum payment\n    \n    vector<vector<int>> dp(CMAX+1, vector<int>(101, BIG));\n    vector<vector<int>> dpnew(CMAX+1, vector<int>(101, BIG));\n    dpnew[0][0] = 0;\n    for(int i = 0; i < n; i++) {\n      const int ii = i + 1;\n      for(int j = 0; j <= CMAX; j++) { // not buying\n        for(int k = 0; k <= 100; k++) {\n          dp[j][k] = dpnew[j][k];\n        }\n      }\n      // buying\n      const int p = ps[i] % 1000;\n      if(p != 0 && p <= 500) { // got 500!\n        for(int j = 0; j <= CMAX; j++) {\n          const int jj = min(j + 500 - p, CMAX);\n          for(int k = 0; k < 100; k++) {\n            const int kk = k + 1;\n            dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n          }\n        }\n      } else {\n        // get 500 if possible!\n        const int q = (p == 0 ? 1000 : p) - 500;\n        for(int j = 0; j <= CMAX; j++) {\n          if(j >= q) {\n            const int jj = j - q;\n            for(int k = 0; k < 100; k++) {\n              const int kk = k + 1;\n              dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n            }\n          } else { // get change\n            const int jj = j + 1000 - p;\n            if( jj < 1000) {\n              for(int k = 0; k <= 100; k++) {\n                const int kk = k;\n                dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n              }\n            }\n          }\n        }\n      }\n    }\n    for(int k = 100; k >= 0; k--) {\n      int p = BIG;\n      for(int j = 0; j <= CMAX; j++) {\n        p = min(p, dpnew[j][k]);\n      }\n      if(p != BIG) {\n        cout << k << \" \" << p << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\nstruct Info {\n    int mai;\n    int cost;\n    bool operator<(const Info& i) const\n    {\n        return (mai != i.mai) ? mai > i.mai : cost < i.cost;\n    }\n    bool operator==(const Info& i) const\n    {\n        return mai == i.mai and cost == i.cost;\n    }\n    Info operator+(const Info& i) const\n    {\n        return Info{mai + i.mai, cost + i.cost};\n    }\n};\nconstexpr int MAX = 100;\nconstexpr int RES = 49900;\nconstexpr int INF = 1 << 30;\nconst Info IINF = Info{0, INF};\nInfo dp[MAX + 1][RES + 1];\n\nint main()\n{\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<int> p(n);\n        for (int i = 0; i < n; i++) {\n            cin >> p[i];\n        }\n\n\n        for (int i = 0; i <= MAX; i++) {\n            for (int j = 0; j <= RES; j++) {\n                dp[i][j] = IINF;\n            }\n        }\n        dp[0][0] = Info{0, 0};\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= RES; j++) {\n                if (not(dp[i][j] == IINF)) {\n                    const int price = p[i] % 1000;\n                    dp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n                    int rest = j - price;\n                    for (int m = 0; m < 2 and m * 500 <= rest; m++) {\n                        dp[i + 1][rest - m * 500] = min(dp[i + 1][rest - m * 500], dp[i][j] + Info{m, p[i]});\n                    }\n                    if (price != 0) {\n                        rest = 1000 + j - price;\n                        for (int m = 0; m < 2 and m * 500 <= rest; m++) {\n                            dp[i + 1][rest - m * 500] = min(dp[i + 1][rest - m * 500], dp[i][j] + Info{m, p[i]});\n                        }\n                    }\n                }\n            }\n        }\n\n        Info mini = IINF;\n        for (int j = 0; j <= RES; j++) {\n            mini = min(mini, dp[n][j]);\n        }\n        cout << mini.mai << \" \" << mini.cost << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[2][101][50000];\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int p[100];\n    for(int i=0;i<n;i++)cin>>p[i];\n    for(int i=0;i<2;i++)\n      for(int j=0;j<=n;j++)\n\tfor(int k=0;k<50000;k++)dp[i][j][k]=1e9;\n    dp[0][0][0]=0;\n    for(int i=0;i<n;i++){\n      int ni=(i+1)%2;\n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<50000;k++)dp[ni][j][k]=1e9;\n      \n      for(int j=0;j<=i;j++)\n\tfor(int k=0;k<50000;k++){\n\t  int np=k+(1000-(p[i]%1000))%1000;\n\t  int nj=j;\n\t  if(np>=500)nj++,np-=500;\n\t  dp[ni][nj][np]=min(dp[ni][nj][np],dp[i%2][j][k]+p[i]);\n\t  dp[ni][j][k]=min(dp[ni][j][k],dp[i%2][j][k]);\n\t}\n      \n    }\n    int c=0,s=0;\n    for(int i=1;i<=n;i++)\n      for(int j=0;j<50000;j++)\n\tif(dp[n%2][i][j]!=1e9&&i>=c){\n\t  if(c==i&&dp[n%2][i][j]<s)s=dp[n%2][i][j];\n\t  else if(c<i)c=i,s=dp[n%2][i][j];\n\t}\n    cout<<c<<\" \"<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define updmax(dp,x) dp=(dp.first == 0 ? x : max(dp,x))\n\nusing P = pair<int,int>;\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        vector<int> p(n);\n        rep(i,n) cin>>p[i];\n        map<int,P> cur; // cur[coin] = <get,pay>\n        cur[0] = P(0,0);\n        rep(i,n){\n            map<int,P> nxt;\n            for(auto &itr : cur){\n                int coin = itr.first;\n                int k = itr.second.first;\n                int pay = itr.second.second;\n                updmax(nxt[coin], P(k,pay));\n                pay -= p[i];\n                coin += (1000-p[i]%1000)%1000;\n                if(coin >= 500){\n                    updmax(nxt[coin-500], P(k+1, pay));\n                }else if(p[i]%1000){\n                    updmax(nxt[coin], P(k,pay));\n                }\n            }\n            cur = move(nxt);\n        }\n\n        P res = {0,0};\n        for(auto itr : cur){\n            res = max(res,itr.second);\n        }\n        cout<<res.first<<\" \"<<-res.second<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\n \nbool cmp(pair< int, int > a, pair< int, int > b)\n{\n  if(a.first != b.first) return(a.first > b.first);\n  return(a.second < b.second);\n}\nint main()\n{\n  int N, p[100];\n   \n  while(scanf(\"%d\", &N), N) {\n    for(int i = 0; i < N; i++) {\n      scanf(\"%d\", &p[i]);\n    }\n     \n    pair< int, int > dp[2][50001];\n    fill_n(*dp, 2 * 50001, make_pair(-INF, INF));\n    pair< int, int > *now = dp[0], *nxt = dp[1];\n     \n    now[0] = {0, 0};\n    int reach = 0;\n    for(int i = 0; i < N; i++) {\n      int mod = p[i] % 1000;\n      if(1 <= mod && mod <= 500) {\n        int rev = 1000 - mod - 500;\n        reach += rev;\n        for(int j = reach; j >= rev; j--) {\n          nxt[j] = min(nxt[j], {now[j - rev].first + 1, now[j - rev].second + p[i]}, cmp);\n        }\n      } else {\n        int rev = (1000 - mod) % 1000;\n        int need = (mod + 500) % 1000;\n        reach += max(rev, need);\n        for(int j = reach; j >= 0; j--) {\n          nxt[j] = min(nxt[j], now[j], cmp);\n        }\n        for(int j = reach; j >= rev; j--) {\n          nxt[j] = min(nxt[j], {now[j - rev].first, now[j - rev].second + p[i]}, cmp);\n        }\n        for(int j = need; j <= reach; j++) {\n          nxt[j - need] = min(nxt[j - need], {now[j].first + 1, now[j].second + p[i]}, cmp);\n        }\n      }\n      swap(now, nxt);\n    }\n    auto p = *min_element(now, now + 50000, cmp);\n    printf(\"%d %d\\n\", p.first, p.second);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N;\n    vector<int> P;\n    bool input() {\n        cin >> N;\n        if (N == 0) return false;\n        P.clear(); P.resize(N); cin >> P;\n        return true;\n    }\n\n    struct Pair : pair<int,int> {\n        Pair(int a, int b) : pair<int,int>(a, b) {}\n    };\n\n    const int INF = 1<<28;\n    bool operator<(const Pair& a, const Pair& b) {\n        if (a.first == b.first) return a.second > b.second;\n        return a.first < b.first;\n    }\n    Pair max(const Pair& a, const Pair& b) {\n        return (b < a ? a : b);\n    }\n\n    void solve() {\n        vector<vector<Pair>> dp(N + 1, vector<Pair>(1001, Pair(-INF, INF)));\n        dp[0][0] = Pair(0, 0);\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j <= 1000; j++) {\n                const auto& cur = dp[i][j];\n                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);\n                if (j >= 500) {\n                    auto& next = dp[i + 1][j - 500];\n                    next = max(next, Pair(dp[i][j].first + 1, dp[i][j].second + P[i]));\n                }\n                int p = P[i] % 1000;\n                if (p == 0) continue;\n                if (p <= 500) {\n                    int nrem = j + (1000 - p) % 500;\n                    auto& next = dp[i + 1][nrem];\n                    next = max(next, Pair(cur.first + 1, cur.second + P[i]));\n                } else {\n                    int d = p % 500;\n                    if (j >= d) {\n                        auto& next = dp[i + 1][j - d];\n                        next = max(next, Pair(cur.first + 1, cur.second + P[i]));\n                    } else {\n                        auto& next = dp[i + 1][j + 1000 - p];\n                        next = max(next, Pair(cur.first, cur.second + P[i]));\n                    }\n                }\n            }\n        }\n        auto ans = Pair(-INF, INF);\n        for (int i = 0; i <= 1000; i++) {\n            ans = max(ans, dp[N][i]);\n        }\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i = 0;i < (n) ;i++)\nusing P = pair<int,int>;\n\nint n;\nint q[100];\nint p[100];\nP dp[101][50000];\n\nP operator+(P a, P b) {\n    return P(a.first+b.first, a.second+b.second);\n}\n\nvoid init(void) {\n    rep(i,n+1) {\n        rep(j,50000) {\n            dp[i][j] = P(-1,1);\n        }\n    }\n}\n\nP rec(int i, int r) {\n    if (dp[i][r] != P(-1,1)) return dp[i][r];\n    if (i >= n) return dp[i][r] = P(0,0);\n    if (1 <= q[i] && q[i] <= 500) {\n        P a = P(1,-p[i]) + rec(i + 1, r + 500 - q[i]);\n        P b = rec(i + 1, r);\n        return dp[i][r] = max(a,b);\n    }\n    int qq = q[i];\n    if (qq == 0) qq = 1000;\n    P a = P(-1,1), b;\n    if (r >= qq - 500) {\n        a = P(1, -p[i]) + rec(i + 1, r - qq + 500);\n    }\n    b = P(0, -p[i]) + rec(i + 1, r + 1000 - qq);\n    P c = rec(i+1, r);\n    return dp[i][r] = max(a, max(b,c));\n}\n\nvoid solve(void) {\n    init();\n    P ans = rec(0,0);\n    cout << ans.first << \" \" << -ans.second << endl;\n}\n\nsigned main (void) {\n    while(true) {\n        cin >> n;\n        if (n == 0) break;\n        rep(i,n) {\n            cin >> p[i];\n            q[i] = p[i] % 1000;\n        }\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// dp[i][500yen][num_1000yen] := remain ([i] is deleted)\nint dp[128][512];\nint n;\nint P[128];\n\nvoid init() {\n  for(int j = 0; j < 128; ++j) {\n    for(int k = 0; k < 512; ++k) {\n      dp[j][k] = -1;\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d\", &P[i]);\n    }\n    int k_max = 0;\n    dp[0][0] = 0;\n    for(int i = 0; i < n; ++i) {\n      k_max += (P[i] + 999) / 1000;\n      for(int j = i; j >= 0; --j) {\n        for(int k = k_max; k >= 0; --k) {\n          if( dp[j][k] == -1 ) continue;\n          int n1kyen = (P[i] + 999) / 1000;\n          int rem = dp[j][k] + n1kyen * 1000 - P[i];\n          int next_num500yen = j + (rem >= 500 ? 1 : 0);\n          int next_num1kyen  = k + n1kyen;\n          int next_rem       = rem >= 500 ? rem - 500 : rem;\n          int& next = dp[next_num500yen][next_num1kyen];\n          next = std::max(next, next_rem);\n        }\n      }\n    }    \n    int res = (1 << 28);\n    int max = -1;\n    for(int j = n; j >= 0; --j) {\n      for(int k = 0; k < 512; ++k) {\n        if( dp[j][k] == -1 ) continue;\n        int cost = k * 1000 - 500 * j - dp[j][k];\n        res = std::min(res, cost);\n      }\n      if( res != (1 << 28) ) {\n        max = j;\n        break;\n      }\n    }\n    printf(\"%d %d\\n\", max, res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_MONEY = 5000;\nint n;\nvector<int> p;\nvector<vector<pair<int, int>>> memo;\n\ninline void Change(pair<int, int> &a, pair<int, int> &b) {\n    if ((a.first < b.first) || (a.first == b.first && a.second > b.second))\n        a = b;\n}\n\npair<int, int> Solve(int idx, int money) {\n    if (idx == n)\n        return pair<int, int>(0, 0);\n\n    auto &opt = memo[idx][money];\n    if (opt.first != -1)\n        return opt;\n\n    // idx?????????????????§????????????\n    opt = Solve(idx + 1, money);\n\n    // idx?????????????????§??????\n    if (0 < (p[idx] % 1000) && (p[idx] % 1000) <= 500) {\n        // 1000????????§?????????\n        int res = 1000 - (p[idx] % 1000) - 500 + money;\n        auto tmp = Solve(idx + 1, res);\n        tmp.first += 1;\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n    else if (p[idx] % 1000 == 0) {\n        if (500 <= money) {\n            int res = money - 500;\n            auto tmp = Solve(idx + 1, res);\n            tmp.first += 1;\n            tmp.second += p[idx];\n            Change(opt, tmp);\n        }\n    }\n    else if (500 <= money + 1000 - (p[idx] % 1000)) {\n        // 1000????????¨?°????money??§?????????\n        int res = money + 1000 - (p[idx] % 1000) - 500;\n        auto tmp = Solve(idx + 1, res);\n        tmp.first += 1;\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n    else {\n        // 1000??????????????§?????????\n        int res = 1000 - (p[idx] % 1000) + money;\n        auto tmp = Solve(idx + 1, res);\n        tmp.second += p[idx];\n        Change(opt, tmp);\n    }\n\n    return opt;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n, n) {\n        p.resize(n);\n        for (int i = 0; i < n; ++i)\n            cin >> p[i];\n\n        memo.clear();\n        memo.resize(n, vector<pair<int, int>>(n * 5000,\n                                              pair<int, int>(-1, 0)));\n\n        auto res = Solve(0, 0);\n        cout << res.first << ' ' << res.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vii;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip> vip;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 :1e9;\n#define MAX 1010\nint dp[110][110][MAX];\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi in(n);\n\t\trep(i,n)cin>>in[i];\n\t\trep(i,110)rep(j,110)rep(k,MAX)dp[i][j][k]=inf;\n\t\tdp[0][0][0]=0;\n\t\trep(i,n)rep(j,n)rep(k,MAX)if(dp[i][j][k]!=inf){\n\t\t\tdp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k]);\n\t\t\tdp[i+1][j+(1000+k-in[i]%1000>=500)][(1000+k-in[i]%1000)%500]=\n\t\t\t\tmin(dp[i+1][j+1][(1000+k-in[i]%1000)%500],dp[i][j][k]+in[i]);\n\t\t\t\n\t\t\t\n/*\t\t\tdp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k]);\n\t\t\tint J=j,K=k,a=in[i]%1000;\n\t\t\tif(i==99){\n\t\t\t\tcout<<J<<\" \"<<K<<\" \"<<dp[i][j][k]<<endl;\n\t\t\t}\n\t\t\tif(k<=a&&a){\n\t\t\t\tK=1000+k-a;\n\t\t\t\tif(K<MAX)dp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\tif(K>=500)J++,K-=500;\n\t\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t}else if(k>a&&a){\n\t\t\t\tK=k+1000-a;\n\t\t\t\tif(K<MAX)dp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\tJ++;\n\t\t\t\tK-=500;\n\t\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t}else{\n\t\t\t\tif(K>=500)K-=500,J++;\n\t\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\t\n\t\t\t}\n*/\t\t}\n\t\tint outc=0,out=inf;\n\t\trep(i,n+1)rep(j,MAX)if(dp[n][i][j]!=inf){\n\t\t\tif(outc<i){\n\t\t\t\toutc=i;\n\t\t\t\tout=dp[n][i][j];\n\t\t\t}else if(outc==i)\n\t\t\t\tout=min(out,dp[n][i][j]);\n\t\t}\n\t\tcout<<outc<<\" \"<<out<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint dp[110][110][1010]={0};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\trep(i,110)rep(j,110)rep(k,1010)dp[i][j][k]=inf;\n\t\tdp[0][0][0]=0;\n\t\tvi a(n);\n\t\trep(i,n)cin>>a[i];\n\t\trep(i,n)rep(j,n)rep(k,1000)if(dp[i][j][k]!=inf){\n\t\t\tint I=i+1,J=j,K=k;\n\t\t\tdp[I][J][K]=min(dp[I][J][K],dp[i][j][k]);\n\t\t\tint t=1000-a[i]%1000;\n\t\t\tif(t==1000)t=0;\n\t\t\tif(t>=500)dp[I][J+1][K+t-500]=min(dp[I][J+1][K+t-500],dp[i][j][k]+a[i]);\n\t\t\telse dp[I][J][K+t]=min(dp[I][J][K+t],dp[i][j][k]+a[i]);\n\t\t\tif(a[i]%500<=K&&K&&a[i]>500)dp[I][J+1][K-a[i]%500]=min(dp[I][J+1][K-a[i]%500],dp[i][j][k]+a[i]);\n\t\t}\n\t\tint out=0,ne=inf;\n\t\trep(i,n+1)rep(j,1010)if(out<=i&&dp[n][i][j]!=inf){\n\t\t\tif(out==i)ne=min(ne,dp[n][i][j]);\n\t\t\telse ne=dp[n][i][j];\n\t\t\tout=max(out,i);\n\t\t}\n\t\tcout<<out<<\" \"<<ne<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define rep1(i,n) for(int i=1;i<=int(n);++i)\n#define all(a) a.begin(),a.end()\n#define lb(s,x) lower_bound(all(s),x)-s.begin()\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n#define INF 1e9\ntypedef long long ll;\n\n#define updmax(dp,x) dp=(dp.first == 0 ? x : max(dp,x))\n\nusing P = pair<int,int>;\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        vector<int> p(n);\n        rep(i,n) cin>>p[i];\n        map<int,P> cur; // cur[coin] = <get,pay>\n        cur[0] = {0,0};\n        rep(i,n){\n            map<int,P> nxt;\n            for(auto &itr : cur){\n                int coin = itr.first;\n                int k = itr.second.first;\n                int pay = itr.second.second;\n                updmax(nxt[coin], P(k,pay));\n                pay -= p[i];\n                int mod = p[i]%500;\n                if(p[i]%1000 == 0){\n                    if(coin>=500) updmax(nxt[coin-500], P(k+1,pay));\n                }else if(p[i]%1000 == 500){\n                    updmax(nxt[coin], P(k+1,pay));\n                }else if(p[i]%1000 <= 500){\n                    updmax(nxt[coin+500-mod],P(k+1, pay));\n                }else if(mod <= coin){\n                    updmax(nxt[coin-mod], P(k+1,pay));\n                }else{\n                    updmax(nxt[coin+500-mod], P(k,pay));\n                }\n            }\n            cur = move(nxt);\n        }\n        P res = {0,0};\n        for(auto itr : cur){\n            res = max(res,itr.second);\n        }\n        cout<<res.first<<\" \"<<-res.second<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nconst bool comp (const P &p1, const P &p2) {\n  if(p1.first == p2.first) {\n    return p1.second < p2.second;\n  } else {\n    return p1.first > p2.first;\n  }\n}\nP min(const P &p1, const P &p2) {\n  if(comp(p1, p2)) return p1;\n  else return p2;\n}\nvoid solve(int n) {\n  vi p(n);\n  int ma = 0;\n  for(int i=0;i<n;++i) {\n    cin >> p[i];\n    ma = max(ma, p[i]);\n  }\n  ma = 1000;\n  vector<P> d(n*ma+1, {-INF, INF});\n  d[0] = {0, 0};\n  for(int i=0;i<n;++i) {\n    int mod = p[i] % 1000;\n    vector<P> dnxt(n*ma+1, {-INF, INF});\n    for(int j=0;j<=n*ma;++j) {\n      if(d[j] == make_pair(-INF, INF)) continue;\n      if(1 <= mod && mod <= 500) {\n        dnxt[j+500-mod] = min(dnxt[j+500-mod], {d[j].first + 1, d[j].second + p[i]});\n      } else {\n        dnxt[j] = min(dnxt[j], d[j]);\n        if(mod == 0 && j >= 500) dnxt[j-500] = min(dnxt[j-500], {d[j].first + 1, d[j].second + p[i]});\n        if(mod != 0 && j >= mod - 500) dnxt[j-(mod - 500)] = min(dnxt[j - (mod - 500)], {d[j].first + 1, d[j].second + p[i]});\n        if(mod != 0) dnxt[j+1000-mod] = min(dnxt[j+1000-mod], {d[j].first, d[j].second + p[i]});\n      }\n    }\n    d = dnxt;\n  }\n  P ans = {-INF, INF};\n  for(int i=0;i<=n*ma;++i) {\n    ans = min(ans, d[i]);\n  }\n  cout << ans.first << \" \" << ans.second << endl;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    solve(n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\n\nP dp[101][50501];\nP pmax(P p,P q){\n    if(p.fs>q.fs) return p;\n    else if(p.fs==q.fs) return (p.sc<q.sc?p:q);\n    else return q;\n}\n\n\nint main(){\n    int N;\n    while(cin >> N){\n        if(!N) return 0;\n        int p[N];\n        for(int i=0;i<N;i++){\n            cin >> p[i];\n        }\n        for(int i=0;i<=N;i++){\n            for(int j=0;j<50001;j++){\n                if(j==0) dp[i][j]=mp(0,0);\n                else dp[i][j]=mp(-1,LINF);\n            }\n        }\n        for(int i=0;i<N;i++){\n            for(int j=0;j<50001;j++){\n                if(dp[i][j].fs==-1){\n                    continue;\n                }\n                P d=dp[i][j];\n                dp[i+1][j]=pmax(dp[i+1][j],d);\n                d.sc+=p[i];\n                int res=(1000-p[i]%1000)%1000;\n                dp[i+1][j+res]=pmax(dp[i+1][j+res],d);\n                if(res>=500){\n                    d.fs++;\n                    res-=500;\n                    dp[i+1][j+res]=pmax(dp[i+1][j+res],d);\n                }\n                else{\n                    d.fs++;\n                    res=500-res;\n                    if(res<=j) dp[i+1][j-res]=pmax(dp[i+1][j-res],d);\n                }\n            }\n        }\n        P ans=mp(0,LINF);\n        for(int i=0;i<=50000;i++){\n            ans=pmax(ans,dp[N][i]);\n        }\n        cout << ans.fs << \" \" << ans.sc << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nP dp[2][100 * 499 + 1];\n\nint main(){\n    cin.sync_with_stdio(false);\n    int n;\n    while(cin >> n, n) {\n        vector<int> p(n);\n        rep(i, n) cin >> p[i];\n\n        rep(i, n * 499 + 1) dp[0][i] = dp[1][i] = P(0, INF);\n        dp[0][0] = dp[1][0] = P(0, 0);\n        rep(i, n) {\n            rep(j, n * 499 + 1) dp[(i + 1) % 2][j] = dp[i % 2][j];\n\n            rep(j, n * 499 + 1) {\n                if (dp[i % 2][j].se != INF) {\n                    int change = (5000 - p[i]) % 1000;\n                    if (change >= 500) {\n                        if (dp[i % 2][j + change - 500].fi < dp[i % 2][j].fi + 1) {\n                            dp[(i + 1) % 2][j + change - 500].fi = dp[i % 2][j].fi + 1;\n                            dp[(i + 1) % 2][j + change - 500].se = dp[i % 2][j].se + p[i];\n                        } else if (dp[i % 2][j + change - 500].fi == dp[i % 2][j].fi + 1) {\n                            if (dp[i % 2][j + change - 500].se > dp[i % 2][j].se + p[i]) {\n                                dp[(i + 1) % 2][j + change - 500].se = dp[i % 2][j].se + p[i];\n                            }\n                        }\n                    } else {\n                        if (dp[i % 2][j + change].fi < dp[i % 2][j].fi) {\n                            dp[(i + 1) % 2][j + change].fi = dp[i % 2][j].fi;\n                            dp[(i + 1) % 2][j + change].se = dp[i % 2][j].se + p[i];\n                        } else if (dp[i % 2][j + change].fi == dp[i % 2][j].fi) {\n                            if (dp[i % 2][j + change].se > dp[i % 2][j].se + p[i]) {\n                                dp[(i + 1) % 2][j + change].se = dp[i % 2][j].se + p[i];\n                            }\n                        }\n\n                        if (j + change >= 500) {\n                            if (dp[i % 2][j + change - 500].fi < dp[i % 2][j].fi + 1) {\n                                dp[(i + 1) % 2][j + change - 500].fi = dp[i % 2][j].fi + 1;\n                                dp[(i + 1) % 2][j + change - 500].se = dp[i % 2][j].se + p[i];\n                            } else if (dp[i % 2][j + change - 500].fi == dp[i % 2][j].fi + 1) {\n                                if (dp[i % 2][j + change - 500].se > dp[i % 2][j].se + p[i]) {\n                                    dp[(i + 1) % 2][j + change - 500].se = dp[i % 2][j].se + p[i];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        P maxi = P(0, 0);\n        rep(i, n * 499 + 1) {\n            if (maxi.fi < dp[n % 2][i].fi) maxi = dp[n % 2][i];\n            else if (maxi.fi == dp[n % 2][i].fi && maxi.se > dp[n % 2][i].se) maxi = dp[n % 2][i];\n        }\n\n        cout << maxi.fi << \" \" << maxi.se << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nint main() {\n\twhile (1) {\n\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<int>ps(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> ps[i];\n\t\t}\n\t\tvector < vector<pair<int, int>>>dp(N + 1, vector<pair<int, int>>(50000,make_pair(-1000,0)));\n\t\tdp[0][0] = make_pair(0, 0);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < 49500; ++j) {\n\t\t\t\tconst int nc = dp[i][j].first;\n\t\t\t\tconst int nmoney = -dp[i][j].second;\n\t\t\t\tdp[i + 1][j] = max(dp[i + 1][j], make_pair(nc, -nmoney));\n\t\t\t\tconst int price = ps[i];\n\t\t\t\tconst int amari = price % 1000;\n\t\t\t\tif (amari == 0) {\n\t\t\t\t\tint nextmoney = j;\n\t\t\t\t\tint plusc = 0;\n\t\t\t\t\tif (nextmoney >= 500) {\n\t\t\t\t\t\tplusc++;\n\t\t\t\t\t\tnextmoney -= 500;;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][nextmoney] = max(dp[i + 1][nextmoney], make_pair(nc + plusc, -nmoney - price));\n\n\t\t\t\t}else\n\t\t\t\tif (amari <= 500) {\n\t\t\t\t\tint nextmoney = j + 500 - amari;\n\t\t\t\t\tint plusc = 1;\n\t\t\t\t\t\n\t\t\t\t\tdp[i + 1][nextmoney] = max(dp[i + 1][nextmoney], make_pair(nc + plusc, -nmoney-price));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint nextmoney =j + 1000 - amari;\n\t\t\t\t\tint plusc = 0;\n\t\t\t\t\tif (nextmoney >= 500) {\n\t\t\t\t\t\tplusc++;\n\t\t\t\t\t\tnextmoney -= 500;;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][nextmoney] = max(dp[i + 1][nextmoney], make_pair(nc + plusc, -nmoney - price));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int, int>ans = make_pair(0, 0);\n\t\tfor (int i = 0; i < 50000; ++i) {\n\t\t\tans = max(ans, dp[N][i]);\n\t\t}\n\t\tcout << ans.first << \" \" << -ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\npair<int,int> dp[101][50501];\n\nbool ge(pair<int,int>p1,pair<int,int>p2){\n\tif(p1.first==0&&p1.second==0)return 1;\n\tif(p2.first==0&&p2.second==0)return 0;\n\tif(p1.first > p2.first)return 0;\n\tif(p1.first < p2.first)return 1;\n\tif(p1.second < p2.second)return 0;\n\treturn 1;\n}\n\n\nint main(){\n\tint n;\n\tint x;\n\tpair<int,int> p1,p2;\t\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int j=0;j<50001;j++){\n\t\t\t\tdp[i][j]=make_pair(0,0);\n\t\t\t}\n\t\t}\n\t\tvector<int> v(n+1,0);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tx = (v[i]-1)%1000+1;\n\t\t\tif(x<=500){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<50000;j++){\n\t\t\t\t\tif(j==0&&dp[i-1][j]==make_pair(0,0)){\n\t\t\t\t\t\tdp[i][j+500-x] = make_pair(1,v[i]);\n\t\t\t\t\t\tdp[i][j+500-x] = max(dp[i][j+500-x],dp[i-1][j+500-x],ge);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(dp[i-1][j]!=make_pair(0,0)){\n\t\t\t\t\t\t\tdp[i][j+500-x] = dp[i-1][j];\n\t\t\t\t\t\t\tdp[i][j+500-x].first +=1;\n\t\t\t\t\t\t\tdp[i][j+500-x].second +=v[i];\n\t\t\t\t\t\t\tdp[i][j+500-x] = max(dp[i][j+500-x],dp[i-1][j+500-x],ge);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i][j+500-x] = dp[i-1][j+500-x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<50000;j++){\n\t\t\t\t\tp1 = make_pair(0,0);\n\t\t\t\t\tp2 = make_pair(0,0);\n\t\t\t\t\tif(j-(1000-x)>=0){\n\t\t\t\t\t\tif(dp[i-1][j-(1000-x)]!=make_pair(0,0)){\n\t\t\t\t\t\t\tp1 = dp[i-1][j-(1000-x)];\n\t\t\t\t\t\t\tp1.second += v[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i-1][j+x-500]!=make_pair(0,0)){\n\t\t\t\t\t\tp2 = dp[i-1][j+x-500];\n\t\t\t\t\t\tp2.first +=1;\n\t\t\t\t\t\tp2.second +=v[i];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t\tif(j-(1000-x)==0){\n\t\t\t\t\t\tif(dp[i-1][j]==make_pair(0,0)){\n\t\t\t\t\t\t\tdp[i][j]=make_pair(0,v[i]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i][j]=max(dp[i-1][j],make_pair(0,v[i]),ge);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = max(dp[i][j],p1,ge);\n\t\t\t\t\tdp[i][j] = max(dp[i][j],p2,ge);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<int,int> mx = make_pair(0,0);\n\t\tfor(int j=0;j<50000;j++){\n\t\t\tmx = max(mx,dp[n][j],ge);\n\t\t}\n\t\tif(mx.first==0){\n\t\t\tcout << 0 << \" \" << 0 << endl;\n\t\t}else{\n\t\t\tcout << mx.first << \" \" << mx.second << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n\nconst int N=100;\n\nint n;\nint p[N];\nint DP[N+3][N+3][N*5+3];//[店][500円玉枚数][使った1000円札枚数] = 小銭 の最大化\n\nvoid init_dp(){\n    REP(i,N+3){\n        REP(j,N+3){\n            REP(k,N*5+3){\n                DP[i][j][k] = -1;\n            }\n        }\n    }\n}\n\nvoid print_dp(int n){\n    REP(i,n){\n        REP(j,n){\n            REP(k,n*5){\n                if(DP[i][j][k]!=-1){\n                    cout<<\"i:\"<<i<<\" j:\"<<j<<\" k:\"<<k<<\" dp:\"<<DP[i][j][k]<<endl;\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    while(true){\n        cin>>n;\n        if(n==0){\n            break;\n        }\n        REP(i,n){\n            cin>>p[i];\n        }\n\n        init_dp();\n\n        int pr=p[0];\n\n        int maxgo=0;//500円玉の最大枚数\n\n        DP[0][0][0] = 0;\n\n        //店1以降\n        for(int i=0;i<n;++i){\n            pr=p[i];\n            REP(j,N){//500円玉の数\n                REP(k,N*5){//1000円札の枚数\n                    int now = DP[i][j][k];\n                    if( now != -1){\n                        //買う場合\n                        //1〜500円\n                        if((pr-1)%1000 <500){\n                            DP[i+1][j+1][k + (pr-1)/1000 +1] = max(now + ((pr-1)/1000 +1)*1000 - pr - 500, DP[i+1][j+1][k + (pr-1)/1000 +1]);\n                            maxgo=max(maxgo,j+1);\n                        }\n                        //0円, 501〜999円\n                        //残金込で500円が作れる場合\n                        else if( 1000*((pr-1)/1000 + 1) - pr + now >= 500 ){\n                            if(pr%1000==0){\n                               DP[i+1][j+1][k + pr/1000] = max(now - 500, DP[i+1][j+1][k + pr/1000]);\n                            } else {\n                               DP[i+1][j+1][k + pr/1000 +1] = max(now -( (pr%1000) - 500 ), DP[i+1][j+1][k + pr/1000 +1]);\n                            }\n                            maxgo=max(maxgo,j+1);\n                        }\n                        //500円が作れない場合\n                        else {\n                            DP[i+1][j][k + (pr-1)/1000 + 1] = max(now + ((pr-1)/1000 +1)*1000 - pr, DP[i+1][j][k + (pr-1)/1000 + 1]);\n                        }\n\n                        //買わない場合\n                        DP[i+1][j][k] = max(now, DP[i+1][j][k]); \n                    }\n                }\n            }\n        }\n        //print_dp(n+1);\n        int used = 5*N*1000;\n        REP(k, N*5){\n            if(DP[n][maxgo][k] != -1){\n                used = min(used, k*1000 - DP[n][maxgo][k] - 500*maxgo);\n            }\n        }\n        cout<<maxgo<<\" \"<<used<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint N;\n\nint dp[2][101][100050];\n\nconst int INF=1e9;\n\nvoid chmin(int &a,int b){\n    if(a>b) a=b;\n}\n\nvoid solve(){\n    vector<int> P(N);\n    for(int i=0;i<N;i++) cin>>P[i];\n\n    for(int i=0;i<2;i++){\n        for(int j=0;j<=N;j++){\n            for(int k=0;k<=1000*N;k++){\n                dp[i][j][k]=INF;\n            }\n        }\n    }\n\n    dp[0][0][0]=0;\n    int t=0;\n    int rest=0;\n    for(int i=0;i<N;i++){\n        for(int j=0;j<=i;j++){\n            for(int k=0;k<=rest;k++){\n                if(dp[t][j][k]==INF) continue;\n\n                chmin(dp[1-t][j][k],dp[t][j][k]);\n\n                int thousand=(1000-P[i]%1000)%1000;\n                rest=max(rest,k+thousand);\n                if(thousand>=500) chmin(dp[1-t][j+1][k+thousand-500],dp[t][j][k]+P[i]);\n                else chmin(dp[1-t][j][k+thousand],dp[t][j][k]+P[i]);\n\n                int z=0;\n                if(thousand==0) z=500;\n                else if(thousand<500) z=500-thousand;\n                if(z==0) continue;\n                if(z>k) continue;\n\n                chmin(dp[1-t][j+1][k-z],dp[t][j][k]+P[i]);\n            }\n        }\n\n        for(int j=0;j<=i;j++){\n            for(int k=0;k<=rest;k++){\n                dp[t][j][k]=INF;\n            }\n        }\n        t=1-t;\n    }\n\n    int ma=0,mi=INF;\n    for(int j=N;j>=0;j--){\n        for(int k=0;k<=1000*N;k++){\n            if(dp[t][j][k]==INF) continue;\n            ma=j;\n            mi=min(mi,dp[t][j][k]);\n        }\n        if(ma>0) break;\n    }\n    cout<<ma<<\" \"<<mi<<endl;\n}\n\nint main(){\n  while(1){\n      cin>>N;\n      if(N==0) break;\n      solve();\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=1000000007;\nP dp[110][50010];\nconst int INF=1e7;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    for(;;){\n        int n;\n        cin>>n;\n        if(!n) return 0;\n        vector<int> p(n);\n        rep(i,0,n) cin>>p[i];\n        rep(i,0,n){\n            fill(dp[i], dp[i]+50010, P(INF,INF));\n        }\n        rep(i,0,n) dp[i][0]=P(0,0);\n        if(p[0]%1000!=0){\n            if(p[0]%1000<=500) dp[0][500-p[0]%1000]=P(-1, p[0]);\n            else dp[0][1000-p[0]%1000]=P(0, p[0]);\n        }\n        rep(i,0,n-1){\n            if(p[i+1]%1000==0){\n                rep(j,0,50010){\n                    if(dp[i][j]!=P(INF,INF)){\n                        dp[i+1][j]=min(dp[i+1][j], dp[i][j]);\n                        dp[i+1][(j>=500?j-500:j)]=min(dp[i+1][(j>=500?j-500:j)],P(dp[i][j].fr-(j>=500?1:0), dp[i][j].sc+p[i+1]));\n                    }\n                }\n                continue;\n            }\n            rep(j,0,50010){\n                dp[i+1][j]=dp[i][j];\n            }\n            if(p[i+1]%1000<=500) dp[i+1][500-p[i+1]%1000]=min(dp[i+1][500-p[i+1]%1000],P(-1, p[i+1]));\n            else dp[i+1][1000-p[i+1]%1000]=min(dp[i+1][1000-p[i+1]%1000], P(0, p[i+1]));\n            rep(j,0,50010){\n                if(dp[i][j]!=P(INF,INF)){\n                    if(p[i+1]%1000<=500){\n                        int x=j+500-p[i+1]%1000;\n                        dp[i+1][x]=min(dp[i+1][x], P(dp[i][j].fr-1, dp[i][j].sc+p[i+1]));\n                    }\n                    else{\n                        if(j>=p[i+1]%500){\n                            int x=j-p[i+1]%500;\n                            dp[i+1][x]=min(dp[i+1][x], P(dp[i][j].fr-1, dp[i][j].sc+p[i+1]));\n                        }\n                        int x=j+1000-p[i+1]%1000;\n                        if(x>=500){\n                            dp[i+1][x-500]=min(dp[i+1][x-500], P(dp[i][j].fr-1, dp[i][j].sc+p[i+1]));\n                        }\n                        else{\n                            dp[i+1][x]=min(dp[i+1][x], P(dp[i][j].fr, dp[i][j].sc+p[i+1]));\n                        }\n                    }\n                }\n            }\n        }\n        int ans=500;\n        rep(i,0,50010){\n            if(dp[n-1][i]!=P(INF,INF)){\n                ans=min(ans, dp[n-1][i].fr);\n            }\n        }\n        int res=1e8;\n        rep(i,0,50010){\n            if(dp[n-1][i]!=P(INF,INF)){\n                if(dp[n-1][i].fr==ans) res=min(res, dp[n-1][i].sc);\n            }\n        }\n        cout<<-ans<<\" \"<<res<<\"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<int> p(n);\n        for(int i=0;i<n;i++) cin>>p[i];\n        const int INF=1e8;\n        vector<vector<pair<int,int>>> dp(n+1,vector<pair<int,int>>(100000,make_pair(-INF,INF)));\n        dp[0][0]=make_pair(0,0);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<dp[i].size();j++){\n                if(0<p[i]%1000 && p[i]%1000<=500){\n                    pair<int,int> x=make_pair(dp[i][j].first+1,dp[i][j].second-p[i]);\n                    int to=j+1000-p[i]%1000;\n                    if(to<dp[i+1].size()){\n                        dp[i+1][to]=max(dp[i+1][to],x);\n                    }\n                }\n                else if(500<p[i]%1000){\n                    int to=j+1000-p[i]%1000;\n                    if(to<dp[i+1].size()){\n                        dp[i+1][to]=max(dp[i+1][to],make_pair(dp[i][j].first,dp[i][j].second-p[i]));\n                    }\n                    to=j-(p[i]+500)%1000;\n                    if(to>=0){\n                        dp[i+1][to]=max(dp[i+1][to],make_pair(dp[i][j].first+1,dp[i][j].second-p[i]));\n                    }\n                }\n                dp[i+1][j]=max(dp[i][j],dp[i+1][j]);\n            }\n        }\n        pair<int,int> res=make_pair(-INF,INF);\n        for(int i=0;i<dp[n].size();i++){\n            res=max(res,dp[n][i]);\n        }\n        cout<<res.first<<\" \"<<-res.second<<endl;\n    }\n    return 0;\n\n}                        dp[i+1][to]=max(dp[i+1][to],make_pair(dp[i][j].first,dp[i][j].second-p[i]));\n                    }\n                    to=j-(p[i]+500)%1000;\n                    if(to>=0){\n                        dp[i+1][to]=max(dp[i+1][to],make_pair(dp[i][j].first+1,dp[i][j].second-p[i]));\n                    }\n                }\n                dp[i+1][j]=max(dp[i][j],dp[i+1][j]);\n            }\n        }\n        pair<int,int> res=make_pair(-INF,INF);\n        for(int i=0;i<dp[n].size();i++){\n            res=max(res,dp[n][i]);\n        }\n        cout<<res.first<<\" \"<<-res.second<<endl;\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint dp[128][128][512];\nint n;\nint P[128];\n\nvoid init() {\n  for(int i = 0; i < 128; ++i) {\n    for(int j = 0; j < 128; ++j) {\n      for(int k = 0; k < 512; ++k) {\n        dp[i][j][k] = -1;\n      }\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    init();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d\", &P[i]);\n    }\n    dp[0][0][0] = 0;\n    for(int i = 0; i < n; ++i) {\n      for(int j = 0; j < n; ++j) {\n        for(int k = 0; k < 512; ++k) {\n          if( dp[i][j][k] == -1 ) continue;\n          dp[i+1][j][k] = std::max(dp[i+1][j][k], dp[i][j][k]);\n          // 1000\n          int count_1000_2 = (P[i] + 999) / 1000;\n          int rem0 = count_1000_2 * 1000 - P[i];\n          int& next0 = dp[i+1][j + (rem0%1000>=500 ? 1 : 0)][k + count_1000_2];\n          next0 = std::max(next0, dp[i][j][k] + (rem0%1000>=500 ? rem0 - 500 : rem0));\n          //\n          int count_1000 = (P[i] + 999) / 1000;\n          int rem1 = dp[i][j][k] + count_1000 * 1000 - P[i];\n          int& next = dp[i+1][j + (rem1%1000>=500 ? 1 : 0)][k + count_1000];\n          next = std::max(next, rem1%1000>=500 ? rem1 - 500 : rem1);\n          // rem\n          if( dp[i][j][k] > P[i] ) {\n            int rem2 = dp[i][j][k] - P[i];\n            int& next = dp[i+1][j + (rem2%1000>=500 ? 1 : 0)][k];\n            next = std::max(next, (rem2%1000>=500 ? rem2 - 500 : rem2));\n          }\n        }\n      }\n    }\n    // for(int i = 0; i <= 4; ++i) {\n    //   for(int j = 0; j <= 4; ++j) {\n    //     for(int k = 0; k < 6; ++k) {\n    //       printf(\"(i, j, k) = (%d, %d, %d) : %d\\n\", i, j, k, dp[i][j][k]);\n    //     }\n    //   }\n    // }\n    int res = (1 << 28);\n    int max = -1;\n    for(int j = n; j >= 0; --j) {\n      for(int k = 0; k < 512; ++k) {\n        if( dp[n][j][k] == -1 ) continue;\n        int cost = k * 1000 - 500 * j - dp[n][j][k];\n        res = std::min(res, cost);\n      }\n      if( res != (1 << 28) ) {\n        max = j;\n        break;\n      }\n    }\n    printf(\"%d %d\\n\", max, res);\n  }\n         \n        \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<complex>\n#include<string>\n#include<cstring>\n \nusing namespace std;\n#define rep2(x,from,to) for(long long x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n#define INF 10000000000000\n#define all(x) x.begin(),x.end()\ntypedef pair<long long,long long> P;\ntypedef pair<long long,P> PP;\nlong long n;\nlong long ans_yen;\nlong long ans_five;\nlong long p[105];\nlong long pp[105];\nlong long dp[105][1000][105];\nint main()\n{\n    while(1)\n    {\n        ans_yen=INF;\n        ans_five=0;\n        cin>>n;\n        if(n==0)break;\n        rep(i,n)\n        {\n            cin>>p[i];\n            pp[i]=p[i];\n            p[i]%=1000;\n        }\n        rep(i,105)rep(j,1000)rep(k,105)dp[i][j][k]=INF;\n        dp[0][0][0]=0;\n        rep(i,n)\n        {\n            rep(j,1000)\n            {\n                rep(k,n)\n                {\n                    if(dp[i][j][k]==INF)continue;\n                    dp[i+1][j][k]=min(dp[i][j][k],dp[i+1][j][k]);\n                    /*dp[i+1][(j+1000-p[i])%1000][k]=min(dp[i][j][k]+p[i],dp[i+1][(j+1000-p[i])%1000][k]);\n                    if(j>=(p[i]+500)%1000)\n                    {\n                        dp[i+1][j-(p[i]+500)%1000][k+1]=min(dp[i+1][j-(p[i]+500)%1000][k+1],dp[i][j][k]+p[i]);\n                    }*/\n                    if(p[i]<=500&&p[i]!=0)\n                    {\n                        dp[i+1][(j+500-p[i])%1000][k+1]=min(dp[i][j][k]+pp[i],dp[i+1][(j+500-p[i])%1000][k+1]);\n                    }\n                    else\n                    {\n                        dp[i+1][(j+1000-p[i])%1000][k]=min(dp[i][j][k]+pp[i],dp[i+1][(j+1000-p[i])%1000][k]);\n                    if(j>=(p[i]+500)%1000)\n                    {\n                        dp[i+1][j-(p[i]+500)%1000][k+1]=min(dp[i+1][j-(p[i]+500)%1000][k+1],dp[i][j][k]+pp[i]);\n                    }\n                    }\n                }\n            }\n        }\n        rep(j,1000)rep(k,n+1)\n        {\n            if(dp[n][j][k]!=INF)\n            {\n                if(ans_five<k)\n                {\n                    ans_yen=dp[n][j][k];\n                    ans_five=k;\n                }\n                if(ans_five==k)\n                {\n                    ans_yen=min(dp[n][j][k],ans_yen);\n                }\n                //cout<<j<<\" \"<<k<<\" \"<<dp[n][j][k]<<endl;\n            }\n        }\n        rep(i,n+1)rep(j,1000)rep(k,n+1)\n        {\n            if(dp[i][j][k]!=INF)\n            {\n                //cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<dp[i][j][k]<<endl;\n            }\n        }\n        cout<<ans_five<<\" \"<<ans_yen<<endl;\n    }\n    return 0;\n}\n \n\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nP dp[111][111111];\nint n,x;\n\nvoid MAX(P &a,P b){\n    if(b.second>=1e9)return ;\n    if(a.first<b.first)a=b;\n    else if(a.first==b.first&&a.second>b.second)a=b;\n}\n\n\nsigned main(){\n    while(cin>>n,n){\n        P ans=P(0,1e9);\n        r(i,111)r(j,111111)dp[i][j]=P(0,1e9);\n        dp[0][0]=P(0,0);\n        r(i,n){\n            cin>>x;\n            int a=((x%1000)?(x%1000):1000);\n            r(j,100000){\n                int A=dp[i][j].first;\n                int B=dp[i][j].second;\n                MAX(dp[i+1][j],dp[i][j]);\n                if(a<=500)MAX(dp[i+1][j+500-a],P(A+1,B+x));\n                else{\n                    int b=((a%500)?(a%500):500);\n                    MAX(dp[i+1][j+1000-a],P(A,B+x));\n                    if(b<=j)MAX(dp[i+1][j-b],P(A+1,B+x));\n                }\n            }\n        }\n        r(i,111111)MAX(ans,dp[n][i]);\n        cout<<ans.first<<' '<<ans.second<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1 ; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1 ; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9+100;\nconst bool debug = 0;\n/***************************************/\n\nint N;\nint p[100];\nint dp[101][25001]; // 500円の枚数, 所持金(100円以下の小銭) = 最小購入金額\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tREP(i, N) scanf(\"%d\", p + i);\n\t\t\n\t\tfill(dp[0], dp[N + 1], INF);\n\t\tdp[0][0] = 0;\n\t\t\n\t\tREP(t, N) {\n\t\t\tint chg = 1000 - (p[t] % 1000);\n\t\t\tchg %= 1000;\n\t\t\t\n\t\t\tfor (int i = N; i >= 0; i--) {\n\t\t\t\tfor (int j = 25000; j >= 0; j--) {\n\t\t\t\t\tif (i) { // 購入して500円玉が増えた場合\n\t\t\t\t\t\tif (chg >= 500) {\n\t\t\t\t\t\t\tint cur = chg - 500; // 増加\n\t\t\t\t\t\t\tif (j - cur >= 0 && dp[i - 1][j - cur] != INF) chmin(dp[i][j], dp[i - 1][j - cur] + p[t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint cur = 500 - chg; // 減少\n\t\t\t\t\t\t\tif (j + cur <= 25000 && dp[i - 1][j + cur] != INF) chmin(dp[i][j], dp[i - 1][j + cur] + p[t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 購入して500円玉が増えなかった場合\n\t\t\t\t\tif (j - chg >= 0 && dp[i][j - chg] != INF) chmin(dp[i][j], dp[i][j - chg] + p[t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpii ans;\n\t\tfor (int i = N; i >= 0; i--) {\n\t\t\tint mi = *min_element(dp[i], dp[i+1]);\n\t\t\tif (mi == INF) continue;\n\t\t\tans = pii(i, mi);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (debug) printf(\"@ \");\n\t\tprintf(\"%d %d\\n\", ans.fi, ans.se);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n\nconst int N=100;\n\nint n;\nint p[N];\nint DP[N+3][N+3][N*5+3];//[店][500円玉枚数][使った1000円札枚数] = 小銭 の最大化\n\nvoid init_dp(){\n    REP(i,N+3){\n        REP(j,N+3){\n            REP(k,N*5+3){\n                DP[i][j][k] = -1;\n            }\n        }\n    }\n}\n\nvoid print_dp(int n){\n    REP(i,n){\n        REP(j,n){\n            REP(k,n*5+3){\n                if(DP[i][j][k]!=-1){\n                    cout<<\"i:\"<<i<<\" j:\"<<j<<\" k:\"<<k<<\" dp:\"<<DP[i][j][k]<<endl;\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    while(true){\n        cin>>n;\n        if(n==0){\n            break;\n        }\n        REP(i,n){\n            cin>>p[i];\n        }\n\n        init_dp();\n\n        int pr=p[0];\n\n        int maxgo=0;//500円玉の最大枚数\n\n        DP[0][0][0] = 0;\n\n        //店1以降\n        for(int i=0;i<n;++i){\n            pr=p[i];\n            REP(j,N+1){//500円玉の数\n                REP(k,N*5+3){//1000円札の枚数\n                    int now = DP[i][j][k];\n                    if( now != -1){\n                        //買う場合\n                        //1〜500円\n                        if((pr-1)%1000 <500){\n                            DP[i+1][j+1][k + (pr-1)/1000 +1] = max(now + ((pr-1)/1000 +1)*1000 - pr - 500, DP[i+1][j+1][k + (pr-1)/1000 +1]);\n                            maxgo=max(maxgo,j+1);\n                        }\n                        //0円, 501〜999円\n                        //残金込で500円が作れる場合\n                        else if( 1000*((pr-1)/1000 + 1) - pr + now >= 500 ){\n                            if(pr%1000==0){\n                               DP[i+1][j+1][k + pr/1000] = max(now - 500, DP[i+1][j+1][k + pr/1000]);\n                            } else {\n                               DP[i+1][j+1][k + pr/1000 +1] = max(now -( (pr%1000) - 500 ), DP[i+1][j+1][k + pr/1000 +1]);\n                            }\n                            maxgo=max(maxgo,j+1);\n                        }\n                        //500円が作れない場合\n                        else {\n                            DP[i+1][j][k + (pr-1)/1000 + 1] = max(now + ((pr-1)/1000 +1)*1000 - pr, DP[i+1][j][k + (pr-1)/1000 + 1]);\n                        }\n\n                        //買わない場合\n                        DP[i+1][j][k] = max(now, DP[i+1][j][k]); \n                    }\n                }\n            }\n        }\n        //print_dp(n+1);\n        int used = 5*N*1000;\n        REP(k, N*5+3){\n            if(DP[n][maxgo][k] != -1){\n                used = min(used, k*1000 - DP[n][maxgo][k] - 500*maxgo);\n            }\n        }\n        cout<<maxgo<<\" \"<<used<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_num_500,int arg_kozeni){\n\t\tnum_500 = arg_num_500;\n\t\tkozeni = arg_kozeni;\n\t}\n\n\tint num_500,kozeni;\n};\n\nint N,max_kozeni[101],max_500,next_max_500,next_max_kozeni[101];\nint** dp;\nint** next_dp;\n\nvoid func(){\n\n\tint P;\n\tmax_500 = 0;\n\tfor(int i = 0; i <= N; i++){\n\t\tmax_kozeni[i] = 0;\n\t}\n\n\tfor(int i = 0; i <= N; i++){\n\t\tfor(int k = 0; k <= 1000*N;k++){\n\t\t\tdp[i][k] = BIG_NUM;\n\t\t\tnext_dp[i][k] = BIG_NUM;\n\t\t}\n\t}\n\n\tvector<Info> Updated;\n\n\tdp[0][0] = 0;\n\tnext_dp[0][0] = 0;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d\",&P);\n\t\tnext_max_500 = max_500;\n\n\t\tfor(int num_500 = 0; num_500 <= max_500; num_500++){\n\n\t\t\tfor(int i = 0;i <= N; i++){\n\t\t\t\tnext_max_kozeni[i] = max_kozeni[i];\n\t\t\t}\n\n\t\t\tfor(int kozeni = 0; kozeni <= max_kozeni[num_500]; kozeni++){\n\t\t\t\tif(dp[num_500][kozeni] == BIG_NUM)continue;\n\n\t\t\t\tif(P%1000 == 0){\n\n\t\t\t\t\tif(kozeni >= 500){\n\t\t\t\t\t\tnext_max_500 = max(next_max_500,num_500+1);\n\t\t\t\t\t\tint next_kozeni = kozeni-500;\n\n\t\t\t\t\t\tif(dp[num_500+1][next_kozeni] > dp[num_500][kozeni]+P){\n\t\t\t\t\t\t\tif(next_dp[num_500+1][next_kozeni] > dp[num_500][kozeni]+P){\n\t\t\t\t\t\t\t\tnext_dp[num_500+1][next_kozeni] = dp[num_500][kozeni]+P;\n\t\t\t\t\t\t\t\tUpdated.push_back(Info(num_500+1,next_kozeni));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnext_max_kozeni[num_500+1] = max(next_max_kozeni[num_500+1],next_kozeni);\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\n\t\t\t\t\tint got_kozeni = 1000*((P/1000)+1)-P;\n\n\t\t\t\t\tnext_max_kozeni[num_500] = max(next_max_kozeni[num_500],kozeni+got_kozeni);\n\t\t\t\t\tif(dp[num_500][kozeni+got_kozeni] > dp[num_500][kozeni]+P){\n\t\t\t\t\t\tif(next_dp[num_500][kozeni+got_kozeni] > dp[num_500][kozeni]+P){\n\t\t\t\t\t\t\tnext_dp[num_500][kozeni+got_kozeni] = dp[num_500][kozeni]+P;\n\t\t\t\t\t\t\tUpdated.push_back(Info(num_500,kozeni+got_kozeni));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(got_kozeni+kozeni >= 500){\n\t\t\t\t\t\tnext_max_500 = max(next_max_500,num_500+1);\n\t\t\t\t\t\tint next_kozeni = got_kozeni+kozeni-500;\n\t\t\t\t\t\tif(dp[num_500+1][next_kozeni] > dp[num_500][kozeni]+P){\n\t\t\t\t\t\t\tif(next_dp[num_500+1][next_kozeni] > dp[num_500][kozeni]+P){\n\t\t\t\t\t\t\t\tnext_dp[num_500+1][next_kozeni] = dp[num_500][kozeni]+P;\n\t\t\t\t\t\t\t\tUpdated.push_back(Info(num_500+1,next_kozeni));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext_max_kozeni[num_500+1] = max(next_max_kozeni[num_500+1],next_kozeni);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Updated.size(); i++){\n\t\t\tdp[Updated[i].num_500][Updated[i].kozeni] = next_dp[Updated[i].num_500][Updated[i].kozeni];\n\t\t}\n\t\tUpdated.clear();\n\n\t\tfor(int i = 0; i <= N; i++){\n\t\t\tmax_kozeni[i] = next_max_kozeni[i];\n\t\t}\n\n\t\tmax_500 = next_max_500;\n\t}\n\n\tint minimum = BIG_NUM;\n\tfor(int i = 0; i <= max_kozeni[max_500]; i++){\n\t\tminimum = min(minimum,dp[max_500][i]);\n\t}\n\n\tprintf(\"%d %d\\n\",max_500,minimum);\n}\n\nint main(){\n\n\tdp = new int*[101];\n\tnext_dp = new int*[101];\n\n\tfor(int i = 0; i <= 100; i++){\n\t\tdp[i] = new int[100001];\n\t\tnext_dp[i] = new int[100001];\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n\n#define all(x) begin(x),end(x)\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\n#pragma O3\n\n//using ll = long long;\nusing ll = int;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\n//const ll LINF = LLONG_MAX / 2;\n\ntemplate<class T>\ninline bool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\n// edit\n\nll dp[2][105][100001];\n\nbool solve() {\n//    memset(dp, 0, sizeof(dp));\n    \n\n    int N;\n    cin >> N;\n    \n    if(N == 0) return false;\n    \n    for(int j = 0; j <= N; ++j){\n        for(int k = 0; k <= 500 * N; ++k){\n            dp[0][j][k] = INF;\n            dp[1][j][k] = INF;\n        }\n    }\n    vector<int> p(N);\n    for(int i = 0; i < N; ++i){\n        cin >> p[i];\n    }\n    \n    dp[0][0][0] = 0;\n    \n    for(int i = 0; i < N; ++i){\n        // reset i + 1\n        int ci = i % 2;\n        int ni = (i + 1) % 2;\n        for(int j = 0; j <= N; ++j){\n//            for(int k = 0; k < 100001; ++k){\n            for(int k = 0; k <= 500 * i; ++k){\n                dp[ni][j][k] = INF;\n            }\n        }\n        \n        for(int j = 0; j <= i; ++j){\n//            for(int k = 0; k < 100001; ++k){\n            for(int k = 0; k <= 500 * i; ++k){\n                if(dp[ci][j][k] == INF) continue;\n                // お金を使わない場合\n                chmin(dp[ni][j][k], dp[ci][j][k]);\n                \n                // お金を使う場合\n                int turi = 1000 - p[i] % 1000;\n                if(turi == 1000) turi = 0;\n                if(k + turi >= 500){\n                    chmin(dp[ni][j + 1][k + turi - 500], dp[ci][j][k] + p[i]);\n                }else{\n                    chmin(dp[ni][j][k + turi], dp[ci][j][k] + p[i]);\n                }\n            }\n        }\n        \n    }\n    \n    ll max_val = 0, min_cost = 0;\n    \n    for(int x = 0; x <= N; ++x){\n//        for(int y = 0; y < 100001; ++y){\n        for(int y = 0; y <= 500 * N; ++y){\n            if(dp[N % 2][x][y] < INF){\n                if(x > max_val){\n                    max_val = x;\n                    min_cost = dp[N%2][x][y];\n                }else if(x == max_val){\n                    chmin(min_cost, dp[N%2][x][y]);\n                }\n            }\n        }\n    }\n    \n    cout << max_val << \" \" << min_cost << endl;\n\n    return true;\n    \n\n    \n\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    while( solve());\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint main(){\n  int n;\n  while(std::cin >> n, n){\n    pii dp[n + 1][5][2][5][2][5];//1, 5, 10, 50, 100;\n    for (int i = 0; i <= n; i++) {\n      for (int j = 0; j < 5; j++) {\n        for (int k = 0; k < 2; k++) {\n          for (int l = 0; l < 5; l++) {\n            for (int m = 0; m < 2; m++) {\n              for (int o = 0; o < 5; o++) {\n                dp[i][j][k][l][m][o] = pii(-1e9, -1e9);\n              }\n            }\n          }\n        }\n      }\n    }\n    vector<int> shop(n);\n    for (int i = 0; i < n; i++) {\n      std::cin >> shop[i];\n    }\n    dp[0][0][0][0][0][0] = pii(0, 0);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 5; j++) {\n        for (int k = 0; k < 2; k++) {\n          for (int l = 0; l < 5; l++) {\n            for (int m = 0; m < 2; m++) {\n              for (int o = 0; o < 5; o++) {\n                int tf = dp[i][j][k][l][m][o].first;\n                int tc = dp[i][j][k][l][m][o].second;\n                int one, five, ten, fifty;\n                int hundred, five_hundred;\n                \n                int diff = (50000 - shop[i])%1000;\n                five_hundred = diff/500;\n                diff %= 500;\n                \n                hundred = diff/100;\n                diff %= 100;\n                \n                fifty = diff/50;\n                diff %= 50;\n                \n                ten = diff/10;\n                diff %= 10;\n                \n                five = diff/5;\n                diff %= 5;\n                \n                one = diff;\n                \n                int nj = j + one;\n                int nk = k + five    + nj/5;\n                int nl = l + ten     + nk/2;\n                int nm = m + fifty   + nl/5;\n                int no = o + hundred + nm/2;\n                five_hundred += no/5;\n                \n                dp[i + 1][nj%5][nk%2][nl%5][nm%2][no%5] = \n                  max(dp[i + 1][nj%5][nk%2][nl%5][nm%2][no%5],\n                      pii(tf + five_hundred, tc - shop[i]));\n                \n                dp[i + 1][j][k][l][m][o] =\n                  max(dp[i + 1][j][k][l][m][o],\n                      dp[i][j][k][l][m][o]);\n              }\n            }\n          }\n        }\n      }\n    }\n    pii ans = pii(-1e9, -1e9);\n    for (int j = 0; j < 5; j++) {\n      for (int k = 0; k < 2; k++) {\n        for (int l = 0; l < 5; l++) {\n          for (int m = 0; m < 2; m++) {\n            for (int o = 0; o < 5; o++) {\n              ans = max(ans, dp[n][j][k][l][m][o]);\n            }\n          }\n        }\n      }\n    }\n    if(ans.first != -1e9) std::cout << ans.first << \" \" << -ans.second << std::endl;\n    else std::cout << \"0 0\" << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 100100100;\n\nint main(){\n\n    while(1){        \n        int n; cin >> n;\n        if(!n) break;\n        vector<int> a(n);\n        for(int i = 0; i < n; i++) cin >> a[i];\n\n        //i番目までの品物を見て、得られた500円玉がj枚で持ってる小銭がk円の時の消費金額の最小値\n        vector<vector<vector<int> > > dp(2, vector<vector<int> > (n + 1, vector<int> (500 * n + 1000, INF)));  \n        dp[0][0][0] = 0;\n        int now = 0;\n        int next = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j <= i; j++){\n                for(int k = 0; k <= 500 * i; k++){\n\n                    int r = a[i] % 1000;\n                    //買わない\n                    dp[next][j][k] = min(dp[next][j][k], dp[now][j][k]);\n\n                    //1000で割ったあまりによる場合わけ\n                    if(1 <= r && r <= 500){\n                        //1000札のみで払うのが最適\n                        //500円獲得\n                        dp[next][j + 1][(500 - r) + k] = min(dp[next][j + 1][(500 - r) + k], dp[now][j][k] + a[i]);\n                    }else{\n                        //1000円札のみで払う\n                        //500円玉は獲得できない\n                        dp[next][j][(1000 - r) % 1000 + k] = min(dp[next][j][(1000 - r) % 1000 + k], dp[now][j][k] + a[i]);\n\n                        //小銭を駆使して500円玉を獲得\n                        int need = r - 500;\n                        if(need == -500) need = 500;\n                        if(k - need >= 0) dp[next][j + 1][k - need] = min(dp[next][j + 1][k - need], dp[now][j][k] + a[i]);\n                    }\n                }\n            }\n            swap(now, next);\n        }\n\n        int ans1 = 0, ans2 = INF;\n        for(int j = 0; j <= n; j++){\n            for(int k = 0; k <= 500 * n; k++){\n                if(dp[now][j][k] != INF){\n                    if(ans1 < j || (ans1 == j && ans2 > dp[now][j][k])){\n                        ans1 = j;\n                        ans2 = dp[now][j][k];\n                    }\n                }\n            }\n        }\n\n        cout << ans1 << \" \" << ans2 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nvector<int> p(101);\n\nbool input() {\n\tcin >> n;\n\tif (n == 0) return false;\n\tfor (int i = 1; i <= n; ++i)\n\t\tcin >> p[i];\n\treturn true;\n}\n\nusing pii = pair<int, int>;\nconst int MAX_CHANGE = 100000;\n\nvoid update(pii& a, pii b) {\n\tif (a.first > b.first) return;\n\tif (a.first < b.first) a = b;\n\telse if (a.second > b.second) a = b;\n}\n\nvoid solve() {\n\tstatic vector<vector<pii>>\n\t\tdp(101, vector<pii>(MAX_CHANGE));\n\tfor (int j = 1; j < MAX_CHANGE; ++j)\n\t\tdp[0][j] = make_pair(-1000, 0);\n\tdp[0][0] = make_pair(0, 0);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < MAX_CHANGE; ++j) {\n\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif (p[i] % 1000 > 500) {\n\t\t\t\t// p[i] に?000円支払う\n\t\t\t\tint change = 1000 - (p[i] % 1000);\n\t\t\t\tif (j >= change) {\n\t\t\t\t\tpii tmp = dp[i - 1][j - change];\n\t\t\t\t\ttmp.second += p[i];\n\t\t\t\t\tupdate(dp[i][j], tmp);\n\t\t\t\t}\n\t\t\t\t// p[i] に?000 + p[i] % 500円支払う\n\t\t\t\tint use = p[i] % 500;\n\t\t\t\tif (j + use < MAX_CHANGE) {\n\t\t\t\t\tpii tmp = dp[i - 1][j + use];\n\t\t\t\t\t++tmp.first; tmp.second += p[i];\n\t\t\t\t\tupdate(dp[i][j], tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// p[i] に?000円支払う\n\t\t\t\tif (p[i] % 1000) {\n\t\t\t\t\tint change = 500 - (p[i] % 1000);\n\t\t\t\t\tif (j >= change) {\n\t\t\t\t\t\tpii tmp = dp[i - 1][j - change];\n\t\t\t\t\t\t++tmp.first;  tmp.second += p[i];\n\t\t\t\t\t\tupdate(dp[i][j], tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// p[i] に?000円 + おつりを用いる\n\t\t\t\tint use = (p[i] % 1000) + 500;\n\t\t\t\tif (j + use < MAX_CHANGE) {\n\t\t\t\t\tpii tmp = dp[i - 1][j + use];\n\t\t\t\t\t++tmp.first; tmp.second += p[i];\n\t\t\t\t\tupdate(dp[i][j], tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpii res = { 0, 0 };\n\tfor (int j = 0; j < MAX_CHANGE; ++j)\n\t\tupdate(res, dp[n][j]);\n\tcout << res.first << \" \" << res.second << endl;\n}\n\nint main() {\n\twhile (input()) solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\nstruct Info {\n    int mai;\n    int cost;\n    bool operator<(const Info& i) const\n    {\n        return (mai != i.mai) ? mai > i.mai : cost < i.cost;\n    }\n    bool operator==(const Info& i) const\n    {\n        return mai == i.mai and cost == i.cost;\n    }\n    Info operator+(const Info& i) const\n    {\n        return Info{mai + i.mai, cost + i.cost};\n    }\n};\nconstexpr int MAX = 100;\nconstexpr int RES = 49900;\nconstexpr int INF = 1 << 30;\nconst Info IINF = Info{0, INF};\nInfo dp[MAX + 100][RES + 100];\n\nint main()\n{\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<int> p(n);\n        for (int i = 0; i < n; i++) {\n            cin >> p[i];\n        }\n\n\n        for (int i = 0; i <= MAX; i++) {\n            for (int j = 0; j <= RES; j++) {\n                dp[i][j] = IINF;\n            }\n        }\n        dp[0][0] = Info{0, 0};\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= RES; j++) {\n                if (not(dp[i][j] == IINF)) {\n                    const int price = p[i] % 1000;\n                    dp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n                    int rest = j - price;\n                    for (int m = 0; m < 2 and m * 500 <= rest; m++) {\n                        dp[i + 1][rest - m * 500] = min(dp[i + 1][rest - m * 500], dp[i][j] + Info{m, p[i]});\n                    }\n                    if (price != 0) {\n                        rest = 1000 + j - price;\n                        for (int m = 0; m < 2 and m * 500 <= rest; m++) {\n                            dp[i + 1][rest - m * 500] = min(dp[i + 1][rest - m * 500], dp[i][j] + Info{m, p[i]});\n                        }\n                    }\n                }\n            }\n        }\n\n        Info mini = IINF;\n        for (int j = 0; j <= RES; j++) {\n            mini = min(mini, dp[n][j]);\n        }\n        cout << mini.mai << \" \" << mini.cost << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nP dp[105][50005];\nint p[100],n;\nvoid Max(P &a,P b){a=max(a,b);}\nint main(){\n  while(cin>>n&&n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++)cin>>p[i];\n    dp[0][0] = P(0,0);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<500*n;j++){\n        if(dp[i][j]==P(-1,-1)) continue;\n        int nf=dp[i][j].first,ns=dp[i][j].second-p[i];\n        Max(dp[i+1][j],dp[i][j]);\n        if(p[i]%1000==0) {if(j>=500)Max(dp[i+1][j-500],P(nf+1,ns));}\n        else if(p[i]%1000<500) Max(dp[i+1][j+500-p[i]%500],P(nf+1,ns));\n        else if(p[i]%500<=j) Max(dp[i+1][j-p[i]%500],P(nf+1,ns));\n        else Max(dp[i+1][j+500-p[i]%500],P(nf,ns)); \n      }\n    }\n    P ans(0,0);\n    for(int i=0;i<500*n;i++) Max(ans,dp[n][i]);\n    cout<<ans.first<<\" \"<<-ans.second<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nint c[5]={100,50,10,5,1};\nint encode(vector<int> v){\n\tint S = 0;\n\tfor(int i=0;i<v.size();i++){\n\t\tS = S*5+v[i];\n\t}\n\treturn S;\n}\nvector<int> decode(int S){\n\tvector<int> v;\n\tint x = 5*5*5*5;\n\tfor(int i=0;i<5;i++){\n\t\tv.pb(S/x);\n\t\tS %= x;\n\t\tx /= 5;\n\t}\n\treturn v;\n}\nP dp[105][5000];\npair<int,vector<int> > charge(int x){\n\tx %= 1000;\n\tvector<int> v(5,0);\n\tint f = x/500;\n\tx -= f*500;\n\tfor(int i=0;i<5;i++){\n\t\tv[i]=x/c[i];\n\t\tx -= v[i]*c[i];\n\t}\n\t//assert(x==0);\n\treturn make_pair(f,v);\n}\n/*void dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}*/\nP dfs(int id,int V){\n\t/*cout << \"call : \" << id << endl;\n\tcout << \"vec : \";\n\tdump(vec);\n\tcout << endl;*/\n\tint tmp = V;\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tmap<int,P>::iterator it;\n\tif(dp[id][V].fi!=-1){\n\t\treturn dp[id][V];\n\t}\n\tP res = dfs(id+1,V);\n\tvector<int> vec = decode(V);\n\tint h = ((p[id]-1)/1000+1)*1000;;\n\tfor(int i=0;i<5;i++){\n\t\twhile(vec[i]>0&&h-p[id]+c[i]<1000){\n\t\t\tvec[i]--;\n\t\t\th += c[i];\n\t\t}\n\t}\n\tpair<int,vector<int> > ch = charge(h-p[id]);\n\tfor(int i=0;i<5;i++)vec[i] += (ch.sec)[i];\n\tP res2 = dfs(id+1,encode(vec));\n\tres2.fi += ch.fi;\n\tres2.sec -= p[id];\n\tdp[id][tmp]=max(res,res2);\n\t/*cout << \"end : \" << id << endl;\n\tcout << \"vec : \";\n\tdump();\n\tcout << \"result : \" << dp[id][vec].fi << ' ' << -dp[id][vec].sec << endl;*/\n\treturn dp[id][tmp];\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<100100;j++){\n\t\t\tdp[i][j]=P(-1,-1);\n\t\t}\n\t}\n\tP ans = dfs(0,0);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<int> p(n);\n        for(int i=0;i<n;i++) cin>>p[i];\n        const int INF=1e8;\n        vector<vector<pair<int,int>>> dp(n+1,vector<pair<int,int>>(100000,make_pair(-INF,INF)));\n        dp[0][0]=make_pair(0,0);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<dp[i].size();j++){\n                if(0<p[i]%1000 && p[i]%1000<=500){\n                    pair<int,int> x=make_pair(dp[i][j].first+1,dp[i][j].second-p[i]);\n                    int to=j+500-p[i]%1000;\n                    if(to<dp[i+1].size()){\n                        dp[i+1][to]=max(dp[i+1][to],x);\n                    }\n                }\n                else if(500<p[i]%1000){\n                    int to=j+1000-p[i]%1000;\n                    if(to<dp[i+1].size()){\n                        dp[i+1][to]=max(dp[i+1][to],make_pair(dp[i][j].first,dp[i][j].second-p[i]));\n                    }\n                    to=j-(p[i]+500)%1000;\n                    if(to>=0){\n                        dp[i+1][to]=max(dp[i+1][to],make_pair(dp[i][j].first+1,dp[i][j].second-p[i]));\n                    }\n                }\n                else{\n                    if(j>=500) dp[i+1][j-500]=max(dp[i+1][j-p[i]%1000-500],make_pair(dp[i][j].first+1,dp[i][j].second-p[i]));\n                }\n                dp[i+1][j]=max(dp[i][j],dp[i+1][j]);\n            }\n        }\n        pair<int,int> res=make_pair(-INF,INF);\n        for(int i=0;i<dp[n].size();i++){\n            res=max(res,dp[n][i]);\n        }\n        cout<<res.first<<\" \"<<-res.second<<endl;\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\n// #define DEBUG\n\n#ifdef DEBUG\n#define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n\n\nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n\nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 101;\nconst int M = 50010;\n\nusing Elem = tuple<int, int>;\nElem dp[N][M];\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vi a(n); for(auto& e : a) cin >> e;\n\n        rep(i, n + 1) rep(j, M) dp[i][j] = Elem(-1, -1);\n        dp[0][0] = Elem(0, 0);\n\n        rep(i, n){\n            int org = a[i];\n            int price = org % 1000;\n            rep(j, M){\n                Elem cur = dp[i][j];\n                int num, total; tie(num, total) = cur;\n                if(num == -1) continue;\n\n                if(price == 0){\n                    chmax(dp[i + 1][j], cur);\n                    int diff = (price + 500) % 1000;\n                    if(j - diff >= 0){\n                        chmax(dp[i + 1][j - diff], Elem(num + 1, total - org)); // ?\n                    }\n                }\n                else if(price <= 500){\n                    chmax(dp[i + 1][min(M, j + 500 - price)], Elem(num + 1, total - org));\n                }\n                else {\n                    chmax(dp[i + 1][j], cur);\n                    chmax(dp[i + 1][min(M, j + 1000 - price)], Elem(num, total - org));\n                    int diff = (price + 500) % 1000;\n                    if(j - diff >= 0){\n                        chmax(dp[i + 1][j - diff], Elem(num + 1, total - org));\n                    }\n                }\n            }\n        }\n\n        Elem res(0, 0);\n        rep(i, n + 1){\n            rep(j, M){\n                chmax(res, dp[i][j]);\n            }\n        }\n        cout << get<0>(res) << \" \" << -get<1>(res) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<n; ++i)\n#define rep(i,n) reps(i,0,n)\n#define maxl(a,b) a = max(a, b)\n\npair<int, int> dp[101][210 * 500];\nconst int MAX = 1001001001;\n\nvoid solve(int n)\n{\n    vector<int> p(n);\n    \n    rep(i, n){\n        cin >> p[i];\n    }\n    \n    rep(i, n+1){\n        rep(c, 210*500){\n            dp[i][c] = {-MAX, 0};\n        }\n    }\n    dp[0][0] = {0, 0};\n    \n    rep(i, n){\n        rep(c, (n+10)*500){\n            auto r = dp[i][c];\n            maxl(dp[i+1][c], r);\n            \n            int pr = p[i] % 1000;\n            if(pr == 0){\n                if(c >= 500) maxl(dp[i+1][c - 500], make_pair(r.first+1, r.second - p[i]));\n            }\n            else if(pr <= 500){\n                maxl(dp[i+1][c + 500 - pr], make_pair(r.first+1, r.second - p[i]));\n            }\n            else{\n                maxl(dp[i+1][c - pr + 1000], make_pair(r.first, r.second - p[i]));\n                if(c >= pr - 500) maxl(dp[i+1][c - pr + 500], make_pair(r.first+1, r.second - p[i]));\n            }\n        }\n    }\n    \n    auto ans = *max_element(dp[n], dp[n] + 210*500);\n    cout << ans.first << ' ' << -ans.second << endl;\n}\n\nint main()\n{\n    int n;\n    \n    while(cin >> n, n){\n        solve(n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vii;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip> vip;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 :1e9;\nint dp[110][110][1010];\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi in(n);\n\t\trep(i,n)cin>>in[i];\n\t\trep(i,110)rep(j,110)rep(k,1010)dp[i][j][k]=inf;\n\t\tdp[0][0][0]=0;\n\t\trep(i,n)rep(j,n)rep(k,1010)if(dp[i][j][k]!=inf){\n\t\t\tdp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k]);\n\t\t\tint J=j,K=k,a=in[i]%1000;\n\t\t\tif(k<=a&&a){\n\t\t\t\tK=1000+k-a;\n\t\t\t\tif(K>=500)J++,K-=500;\n\t\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t}else if(k>a&&a){\n\t\t\t\tif(500>=a){\n\t\t\t\t\tK=k+1000-a;\n\t\t\t\t\tJ++;\n\t\t\t\t\tK-=500;\n\t\t\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\t}else{\n\t\t\t\t\tK=k+1000-a;\n\t\t\t\t\tif(K>=500)K-=500,J++;\n\t\t\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\tif(K>=500)K-=500,J++;\n\t\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tint outc=0,out=inf;\n\t\trep(i,n+1)rep(j,1010)if(dp[n][i][j]!=inf){\n\t\t\tif(outc<i){\n\t\t\t\toutc=i;\n\t\t\t\tout=dp[n][i][j];\n\t\t\t}else if(outc==i)\n\t\t\t\tout=min(out,dp[n][i][j]);\n\t\t}\n\t\tcout<<outc<<\" \"<<out<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef pair<int, int>P;\n\nint main(){\n    for(int n; cin>>n,n;){\n        int mx = 0;\n        vector<int>p(n);\n        for(int i=0;i<n;i++){\n            cin>>p[i];\n        }\n        map<P, int>dp[2];\n        dp[0][P(0, 0)] = 0;\n        for(int i=0;i<n;i++){\n            map<P, int>::iterator it = dp[i%2].begin();\n            for(;it!=dp[i%2].end();it++){\n                int earn = (*it).first.first;\n                int satsu = (*it).first.second;\n                int pay = (*it).second;\n                int zeni = satsu * 1000 - pay - earn * 500;\n\n                //pass\n                if(dp[(i+1)%2].find(P(earn, satsu)) == dp[(i+1)%2].end()){\n                    dp[(i+1)%2][P(earn, satsu)] = pay;\n                }\n                else{\n                    dp[(i+1)%2][P(earn, satsu)] = min(dp[(i+1)%2][P(earn, satsu)], pay);\n                }\n\n                //1000円だけで払う\n                int turi = 1000 - p[i] % 1000, get500 = 0;\n                if(turi == 1000)turi = 0;\n                if(turi >= 500){\n                    turi -= 500;\n                    get500 = 1;\n                }\n                int nxtEarn = earn + get500;\n                int nxtPay = pay + p[i];\n                int nxtSatsu = satsu + p[i] / 1000 + (p[i] % 1000 == 0?0:1);\n                if(dp[(i+1)%2].find(P(nxtEarn, nxtSatsu)) == dp[(i+1)%2].end()){\n                    dp[(i+1)%2][P(nxtEarn, nxtSatsu)] = nxtPay;\n                }\n                else{\n                    dp[(i+1)%2][P(nxtEarn, nxtSatsu)] = min(dp[(i+1)%2][P(nxtEarn, nxtSatsu)], nxtPay);\n                }\n                \n                //500円もらえるように払う\n                int need = abs((p[i] % 1000) - 500);\n                if(zeni < need)continue;\n                nxtEarn = earn + 1;\n                nxtPay = pay + p[i];\n                if(dp[(i+1)%2].find(P(nxtEarn, nxtSatsu)) == dp[(i+1)%2].end()){\n                    dp[(i+1)%2][P(nxtEarn, nxtSatsu)] = nxtPay;\n                }\n                else{\n                    dp[(i+1)%2][P(nxtEarn, nxtSatsu)] = min(dp[(i+1)%2][P(nxtEarn, nxtSatsu)], nxtPay);\n                }\n\n            }\n            dp[i%2].clear();\n        }\n        int c = 0, s = 0;\n        for(map<P, int>::iterator it = dp[n%2].begin(); it != dp[n%2].end(); it++){\n            int earn = (*it).first.first;\n            int satsu = (*it).first.second;\n            int pay = (*it).second;\n            int zeni = satsu * 1000 - pay - earn * 500;\n            if(earn > c){\n                c = earn;\n                s = pay;\n            }\n            else if(earn == c && pay < s){\n                c = earn;\n                s = pay;\n            }\n\n        }\n        cout<<c<<\" \"<<s<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N;\nvoid solve() {\n    vector<int> shop(N);\n    for (auto& i : shop) cin >> i;\n\n    vector<int> diff(N);\n    for (int i = 0; i < N; i++) {\n        int d = shop[i] % 1000;\n        if (d == 0) diff[i] = 500;\n        else if (d < 500) diff[i] = 0;\n        else diff[i] = d - 500;\n    }\n\n    vector<vector<P> > dp(N + 1, vector<P>(500 * N + 1, P(-1, 0)));\n    dp[0][0] = P(0, 0);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= 500 * i; j++) {\n            auto coin = dp[i][j];\n            if (coin.first == - 1) continue;\n            dp[i+1][j] = max(dp[i+1][j], coin);\n            if (diff[i] == 0) {\n                P ncoin = P(coin.first + 1, coin.second - shop[i]);\n                int f = j + 500 - (shop[i] % 1000);\n                dp[i+1][f] = max(dp[i+1][f], ncoin);\n            } else {\n                if (diff[i] <= j) {\n                    P ncoin = P(coin.first + 1, coin.second - shop[i]);\n                    int f = j - diff[i];\n                    dp[i+1][f] = max(dp[i+1][f], ncoin);\n                }\n\n                P pcoin = P(coin.first, coin.second - shop[i]);\n                int f_ = j + (shop[i] % 1000 ? 1000 - shop[i] % 1000 : 0);\n                dp[i+1][f_] = max(dp[i+1][f_], pcoin);\n            }\n        }\n    }\n\n    P ans(0, 0);\n    for (auto p : dp[N]) {\n        ans = max(ans, p);\n    }\n\n    cout << ans.first << \" \" << -ans.second << endl;\n}\n\nint main() {\n    while (cin >> N, N) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  const int CMAX = 10000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 49900... too much?\n    // # of 500 got so far : at most 100\n    // value : minimum payment\n    \n    vector<vector<int>> dp(CMAX+1, vector<int>(101, BIG));\n    vector<vector<int>> dpnew(CMAX+1, vector<int>(101, BIG));\n    dpnew[0][0] = 0;\n    int cmax = 0;\n    for(int i = 0; i < n; i++) {\n      const int ii = i + 1;\n      for(int j = 0; j <= cmax; j++) { // not buying\n        for(int k = 0; k <= i; k++) {\n          dp[j][k] = dpnew[j][k];\n        }\n      }\n      // buying\n      const int p = ps[i] % 1000;\n      if(p != 0 && p <= 500) { // got 500!\n        for(int j = 0; j <= cmax; j++) {\n          const int jj = min(j + 500 - p, CMAX);\n          cmax = min(max(cmax, jj), CMAX);\n          for(int k = 0; k <= i; k++) {\n            const int kk = k + 1;\n            dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n          }\n        }\n      } else {\n        // get 500 if possible!\n        const int q = (p == 0 ? 1000 : p) - 500;\n        for(int j = 0; j <= cmax; j++) {\n          if(j >= q) {\n            const int jj = j - q;\n            for(int k = 0; k <= i; k++) {\n              const int kk = k + 1;\n              dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n            }\n          } else { // get change\n            const int jj = j + 1000 - p;\n            cmax = min(max(cmax, jj), CMAX);\n            if( jj < 1000) {\n              for(int k = 0; k <= i; k++) {\n                const int kk = k;\n                dpnew[jj][kk] = min(dpnew[jj][kk], dp[j][k] + ps[i]);\n              }\n            }\n          }\n        }\n      }\n    }\n    for(int k = 100; k >= 0; k--) {\n      int p = BIG;\n      for(int j = 0; j <= cmax; j++) {\n        p = min(p, dpnew[j][k]);\n      }\n      if(p != BIG) {\n        cout << k << \" \" << p << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int BIG = 1000000;\n  const int CMAX = 25000;\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> ps;\n    for(int i = 0; i < n; i++) {\n      int p; cin >> p; ps.push_back(p);\n    }\n    // shop : at most 100\n    // change : at most 49900... too much?\n    // # of 500 got so far : at most 100\n    // value : minimum payment\n    \n    vector<vector<int>> dp(CMAX+1, vector<int>(101, BIG));\n    vector<vector<int>> dpnew(CMAX+1, vector<int>(101, BIG));\n    dpnew[0][0] = 0;\n    int cmax = 0;\n    int kmax = 0;\n    for(int i = 0; i < n; i++) {\n      int kmax2 = kmax;\n      const int ii = i + 1;\n      // not buying\n      for(int j = 0; j <= cmax; j++) {\n        for(int k = max(0, kmax - (n-i)); k <= i; k++) {\n          dp[j][k] = dpnew[j][k];\n        }\n      }\n      // buying\n      for(int j = 0; j <= cmax; j++) {\n        const int p = ps[i] % 1000;\n        if(p != 0 && p <= 500) { // got 500!\n          const int jj = min(j + 500 - p, CMAX);\n          cmax = min(max(cmax, jj), CMAX);\n          for(int k = max(0, kmax - (n-i)); k <= kmax; k++) {\n            const int kk = k + 1;\n            if(dpnew[jj][kk] > dp[j][k] + ps[i]) {\n              dpnew[jj][kk] = dp[j][k] + ps[i];\n              kmax2 = max(kmax2, kk);\n            }\n          }\n        } else {\n          // get 500 if possible!\n          const int q = (p == 0 ? 1000 : p) - 500;\n          if(j >= q) {\n            const int jj = j - q;\n            for(int k = max(0, kmax - (n-i)); k <= kmax; k++) {\n              const int kk = k + 1;\n              if(dpnew[jj][kk] > dp[j][k] + ps[i]) {\n                dpnew[jj][kk] = dp[j][k] + ps[i];\n                kmax2 = max(kmax2, kk);\n              }\n            }\n          } else { // get change\n            const int jj = j + 1000 - p;\n            cmax = min(max(cmax, jj), CMAX);\n            if( jj < 1000) {\n              for(int k = max(0, kmax - (n-i)); k <= kmax; k++) {\n                const int kk = k;\n                if(dpnew[jj][kk] > dp[j][k] + ps[i]) {\n                  dpnew[jj][kk] = dp[j][k] + ps[i];\n                  kmax2 = max(kmax2, kk);\n                }\n              }\n            }\n          }\n        }\n      }\n      kmax = kmax2;\n    }\n    for(int k = 100; k >= 0; k--) {\n      int p = BIG;\n      for(int j = 0; j <= cmax; j++) {\n        p = min(p, dpnew[j][k]);\n      }\n      if(p != BIG) {\n        cout << k << \" \" << p << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nconst int MAXP = 100 * 500;\npair<int, int> dp[3][MAXP];\nint solve_testcase() {\n    int N; scanf(\"%d\", &N);\n    if(N == 0) return 1;\n\n    vector<int> P(N);\n    for(int i=0; i<N; i++) scanf(\"%d\", &P[i]);\n\n    auto update = [](pair<int, int> &A, pair<int, int> &B) {\n        if(A.first < B.first) A = B;\n        else if(A.first == B.first and A.second > B.second) A = B;\n    };\n\n    const pair<int, int> NIL(-1, INF);\n    fill(dp[0], dp[2], NIL);\n    dp[0][0] = make_pair(0, 0);\n    for(int i=0; i<N; i++) {\n        int p = P[i] % 1000;\n        int cur = i % 2, nxt = 1 ^ cur;\n        for(int j=0; j<MAXP; j++) {\n            if(dp[cur][j] == NIL) continue;\n            \n            // 買わない\n            update(dp[nxt][j], dp[cur][j]);\n\n            {\n                // 買う (小銭を調整しない)\n                {\n                    int x = -p, g = 0;\n                    if(x < 0) x += 1000;\n                    g += (x >= 500);\n                    x %= 500;\n                    pair<int, int> ndp(dp[cur][j].first + g,\n                                       dp[cur][j].second + P[i]);\n                    update(dp[nxt][j+x], ndp);\n                }\n                \n                // 買う (小銭から 500 円使う)\n                if(j >= 500) {\n                    int x = 500 - p, g = 0;\n                    if(x < 0) x += 1000;\n                    g += (x >= 500);\n                    x %= 500;\n                    \n                    pair<int, int> ndp(dp[cur][j].first + g,\n                                       dp[cur][j].second + P[i]);\n                    update(dp[nxt][j-500+x], ndp);\n                }\n\n                if(j < 500) {\n                    int x = j - p, g = 0;\n                    if(x < 0) x += 1000;\n                    g += (x >= 500);\n                    x %= 500;\n\n                    pair<int, int> ndp(dp[cur][j].first + g,\n                                       dp[cur][j].second + P[i]);\n                    update(dp[nxt][x], ndp);\n                }\n            }\n\n            dp[cur][j] = NIL;\n        }\n    }\n\n    pair<int, int> ans = NIL;\n    for(int i=0; i<MAXP; i++) {\n        update(ans, dp[N%2][i]);\n    }\n    printf(\"%d %d\\n\", ans.first, ans.second);\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vii;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip> vip;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 :1e9;\nint dp[110][110][1010];\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi in(n);\n\t\trep(i,n)cin>>in[i];\n\t\trep(i,110)rep(j,110)rep(k,1010)dp[i][j][k]=inf;\n\t\tdp[0][0][0]=0;\n\t\trep(i,n)rep(j,n)rep(k,1010)if(dp[i][j][k]!=inf){\n\t\t\tdp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k]);\n\t\t\tint J=j,K=k,a=in[i]%1000;\n\t\t\tif(k<=a&&a){\n\t\t\t\tK=1000+k-a;\n\t\t\t\tif(K<1000)dp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\tif(K>=500)J++,K-=500;\n\t\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t}else if(k>a&&a){\n\t\t\t\tK=k+1000-a;\n\t\t\t\tJ++;\n\t\t\t\tK-=500;\n\t\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t}else{\n\t\t\t\tif(K<1000)dp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\tif(K>=500)K-=500,J++;\n\t\t\t\tdp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tint outc=0,out=inf;\n\t\trep(i,n+1)rep(j,1010)if(dp[n][i][j]!=inf){\n\t\t\tif(outc<i){\n\t\t\t\toutc=i;\n\t\t\t\tout=dp[n][i][j];\n\t\t\t}else if(outc==i)\n\t\t\t\tout=min(out,dp[n][i][j]);\n\t\t}\n\t\tcout<<outc<<\" \"<<out<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <tuple>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\n#include <random>\n#include <set>\n\nvoid renew(std::pair<int, int>& a, const std::pair<int, int> pair) {\n\tif (a.first < pair.first) {\n\t\ta = pair;\n\t}\n\telse if (a.first == pair.first && a.second > pair.second) {\n\t\ta = pair;\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tint n; std::cin >> n; if (n == 0) break;\n\t\tstd::vector<int> price(n); for (auto& p : price) std::cin >> p;\n\t\tstd::vector<std::vector<std::pair<int, int>>> memo(2, std::vector<std::pair<int, int>>(n * 500 + 1, std::make_pair(-1, 0))); memo[0][0].first = 0;\n\t\tfor (const auto p : price) {\n\t\t\tif (p % 1000 == 0) {\n\t\t\t\tfor (auto i = 0; i < memo[0].size(); ++i) {\n\t\t\t\t\tif (memo[0][i].first >= 0) {\n\t\t\t\t\t\trenew(memo[1][i], memo[0][i]);\n\t\t\t\t\t\tif (i >= 500) {\n\t\t\t\t\t\t\trenew(memo[1][i - 500], std::make_pair(memo[0][i].first + 1, memo[0][i].second + p));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (p % 1000 == 500) {\n\t\t\t\tfor (auto i = 0; i < memo[0].size(); ++i) {\n\t\t\t\t\tif (memo[0][i].first >= 0) {\n\t\t\t\t\t\trenew(memo[1][i], memo[0][i]);\n\t\t\t\t\t\trenew(memo[1][i], std::make_pair(memo[0][i].first + 1, memo[0][i].second + p));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (p % 1000 <= 500) {\n\t\t\t\tconst auto diff = 500 - p % 500;\n\t\t\t\tfor (auto i = 0; i < memo[0].size(); ++i) {\n\t\t\t\t\tif (memo[0][i].first >= 0 ) {\n\t\t\t\t\t\trenew(memo[1][i], memo[0][i]);\n\t\t\t\t\t\tif (i + diff < memo[1].size())\n\t\t\t\t\t\t\trenew(memo[1][i + diff], std::make_pair(memo[0][i].first + 1, memo[0][i].second + p));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst auto diff = 500 - p % 500;\n\t\t\t\tfor (auto i = 0; i < memo[0].size(); ++i) {\n\t\t\t\t\tif (memo[0][i].first >= 0) {\n\t\t\t\t\t\trenew(memo[1][i], memo[0][i]);\n\t\t\t\t\t\tif (i >= p % 500) {\n\t\t\t\t\t\t\trenew(memo[1][i - p % 500], std::make_pair(memo[0][i].first + 1, memo[0][i].second + p));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i + diff < memo[1].size()) {\n\t\t\t\t\t\t\trenew(memo[1][i + diff], std::make_pair(memo[0][i].first, memo[0][i].second + p));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::swap(memo[0], memo[1]);\n\t\t}\n\t\tconst auto res = *std::max_element(memo.front().begin(), memo.front().end(), [](std::pair<int, int>& a, const std::pair<int, int>& b) {return a.first == b.first ? a.second > b.second : a.first < b.first; });\n\t\tstd::cout << res.first << ' ' << res.second << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nint p[101];\npint dp[101][60001];\nint INF=1000100010;\nint main(){\n    int n;\n    while(cin>>n,n){\n        rep(i,n) cin>>p[i];\n        FOR(i,0,n+1)rep(j,50001) dp[i][j]={0,-INF};\n        dp[0][0]={0,0};\n        rep(i,n){\n            int cp=p[i];\n            rep(j,50001){\n                if(dp[i][j]==pint(0,-INF)) continue;\n                dp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n                if(p[i]%1000==0){\n                    if(j<500) continue;\n                    else{\n                        pint tmp=dp[i][j];\n                        tmp.second-=cp;++tmp.first;\n                        dp[i+1][j-500]=max(dp[i+1][j-500],tmp);\n                    }\n                }\n                if(cp%1000>500){\n                    if(cp%1000-500<=j){\n                        pint tmp=dp[i][j];\n                        tmp.second-=cp;\n                        dp[i+1][j+1000-cp%1000]=max(dp[i+1][j+1000-cp%1000],tmp);\n                        ++tmp.first;\n                        dp[i+1][j-cp%1000+500]=max(dp[i+1][j-cp%1000+500],tmp);\n                    }\n                    else{\n                        pint tmp=dp[i][j];\n                        tmp.second-=cp;\n                        dp[i+1][j+1000-cp%1000]=max(dp[i+1][j+1000-cp%1000],tmp);\n                    }\n                }\n                else{\n                    pint tmp=dp[i][j];\n                    tmp.second-=cp;++tmp.first;\n                    dp[i+1][j+1000-cp%1000-500]=max(dp[i+1][j+1000-cp%1000-500],tmp);\n                }\n            }\n        }\n        pint mx={0,-INF};\n        rep(i,n+1)rep(j,50001) mx=max(mx,dp[i][j]);\n        cout<<mx.first<<\" \"<<-mx.second<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N, P[110];\n\n// dp[i][j] := i ???????????§???????????£???????°???? j ????????????????????¨??????\n// 500 ??????????????§?????¨?????????????¶?????????????????°????\npii dp[110][50000];\n\nsigned main() {\n    while(cin >> N, N) {\n        rep(i,0,N) cin >> P[i];\n        rep(i,0,110) rep(j,0,50000) dp[i][j] = pii(-1, INF);\n\n        dp[0][0] = pii(0, 0);\n        rep(i,0,N) rep(j,0,50000) {\n            if(dp[i][j].first == -1) continue;\n            chmax(dp[i+1][j], dp[i][j]);\n\n            int change = (1000 - (P[i] % 1000)) % 1000;\n            int getcoin = (j + change >= 500);\n            int next_money = j + change - 500 * getcoin;\n            chmax(dp[i+1][next_money], pii(dp[i][j].first + getcoin, dp[i][j].second - P[i]));\n        }\n\n        pii ans(-1, INF);\n        rep(i,0,50000) chmax(ans, dp[N][i]);\n        printf(\"%lld %lld\\n\", ans.first, -ans.second);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define int long long\n#define INF 1001000100010001000\n\nusing namespace std;\n\nint dp[101][101][50000];\nint data[100];\nint n;\n\nsigned main(void)\n{\n\tcin >> n;\n\twhile (n) {\n\t\trep(i, 101) rep(k, 101) rep(j, 50000) dp[i][k][j] = INF;\n\t\trep(i, n) cin >> data[i];\n\t\tdp[0][0][0] = 0;\n\n\t\trep(i, n) {\n\t\t\tfor (int j = 100; j >= 0; j--) {\n\t\t\t\tfor (int k = 50000-1; k >= 0; k--) {\n\n\t\t\t\t\tif (data[i] % 1000 == 0) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (data[i] % 1000 <= 500) {\n\t\t\t\t\t\tint ret = 1000 - (data[i] % 1000);\n\t\t\t\t\t\tdp[i+1][j][k + ret] = min(dp[i+1][j+1][k + ret], \n\t\t\t\t\t\t\t\tdp[i][j][k] + data[i]);\n\t\t\t\t\t\tdp[i+1][j+1][k + (ret - 500)] = min(dp[i+1][j+1][k + (ret - 500)], \n\t\t\t\t\t\t\t\tdp[i][j][k] + data[i]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint ret = 1000 - (data[i] % 1000);\n\t\t\t\t\t\tdp[i+1][j][k + ret] = min(dp[i+1][j][k + ret], \n\t\t\t\t\t\t\t\tdp[i][j][k] + data[i]);\n\t\t\t\t\t\tif (k >= (500 - ret)) {\n\t\t\t\t\t\t\tdp[i+1][j+1][k - (500 - ret)] = min(dp[i+1][j+1][k - (500 - ret)], \n\t\t\t\t\t\t\t\t\tdp[i][j][k] + data[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int i = 100; i >= 0; i--) {\n\t\t\tif (*min_element(dp[n][i], dp[n][i] + 50000) != INF) {\n\t\t\t\tcout << *min_element(dp[n][i], dp[n][i] + 50000) << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcin >> n;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef int ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e9;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nconst ll M = 100*5000;\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n;\n    while (cin >> n, n) {\n        vector<ll> p(n); cin >> p;\n        vector<vector<P>> dp(n+1, vector<P>(M+1, {-1, -1}));\n        dp[0][0] = {0, 0};\n        rep(i, n) rep(j, M+1) {\n            if (dp[i][j].first < 0) continue;\n            ll c, r; tie(c, r) = dp[i][j];\n            if (0 < p[i] % 1000 && p[i] % 1000 <= 500) {\n                // ??????\n                assert(j+p[i] <= M);\n                chmax(dp[i+1][j+p[i]], P(c+1, r+(500-p[i]%1000)));\n            }\n            else {\n                // ????????????\n                chmax(dp[i+1][j], dp[i][j]);\n                // ???????????????\n                chmax(dp[i+1][j+p[i]], P(c, r+(1000-p[i]%1000)%1000));\n                // 500????????????????????????????????????\n                ll need = (p[i]+500) % 1000;\n                if (r >= need) {\n                    chmax(dp[i+1][j+p[i]], P(c+1, r-need));\n                }\n            }\n        }\n        P ans{0, 0};\n        rep(i, M+1) {\n            chmax(ans, P(dp[n][i].first, -i));\n        }\n        cout << ans.first << \" \" << -ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define SIZE 50100\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nint c[5]={100,50,10,5,1};\nconst int B = 7;\nint encode(vector<int> v){\n\tint S = 0;\n\tfor(int i=0;i<v.size();i++){\n\t\t//assert(v[i]<B);\n\t\tS = S*B+v[i];\n\t}\n\treturn S;\n}\nvector<int> decode(int S){\n\tvector<int> v;\n\tint x = B*B*B*B;\n\tfor(int i=0;i<5;i++){\n\t\tv.pb(S/x);\n\t\tS %= x;\n\t\tx /= B;\n\t}\n\treturn v;\n}\nP dp[105][SIZE];\npair<int,vector<int> > charge(int x){\n\tx %= 1000;\n\tvector<int> v(5,0);\n\tint f = x/500;\n\tx -= f*500;\n\tfor(int i=0;i<5;i++){\n\t\tv[i]=x/c[i];\n\t\tx -= v[i]*c[i];\n\t}\n\t//assert(x==0);\n\treturn make_pair(f,v);\n}\n/*void dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}*/\nP dfs(int id,int V){\n\t/*cout << \"call : \" << id << endl;\n\tcout << \"vec : \";\n\tdump(vec);\n\tcout << endl;*/\n\tint tmp = V;\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tmap<int,P>::iterator it;\n\tif(dp[id][V].fi!=-1){\n\t\treturn dp[id][V];\n\t}\n\tP res = dfs(id+1,V);\n\tvector<int> vec = decode(V);\n\tint h = ((p[id]-1)/1000+1)*1000;;\n\tfor(int i=0;i<5;i++){\n\t\twhile(vec[i]>0&&h-p[id]+c[i]<1000){\n\t\t\tvec[i]--;\n\t\t\th += c[i];\n\t\t}\n\t}\n\tpair<int,vector<int> > ch = charge(h-p[id]);\n\tfor(int i=0;i<5;i++)vec[i] += (ch.sec)[i];\n\tP res2 = dfs(id+1,encode(vec));\n\tres2.fi += ch.fi;\n\tres2.sec -= p[id];\n\tdp[id][tmp]=max(res,res2);\n\t/*cout << \"end : \" << id << endl;\n\tcout << \"vec : \";\n\tdump();\n\tcout << \"result : \" << dp[id][vec].fi << ' ' << -dp[id][vec].sec << endl;*/\n\treturn dp[id][tmp];\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<SIZE;j++){\n\t\t\tdp[i][j]=P(-1,-1);\n\t\t}\n\t}\n\tP ans = dfs(0,0);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define SIZE 5100\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint n;\nint p[105];\nint c[5]={100,50,10,5,1};\nconst int B = 5;\nint encode(vector<int> v){\n\tint S = 0;\n\tfor(int i=0;i<v.size();i++){\n\t\tassert(v[i]<B);\n\t\tS = S*B+v[i];\n\t}\n\treturn S;\n}\nvector<int> decode(int S){\n\tvector<int> v;\n\tint x = B*B*B*B;\n\tfor(int i=0;i<5;i++){\n\t\tv.pb(S/x);\n\t\tS %= x;\n\t\tx /= B;\n\t}\n\treturn v;\n}\nP dp[105][SIZE];\npair<int,vector<int> > charge(int x){\n\tx %= 1000;\n\tvector<int> v(5,0);\n\tint f = x/500;\n\tx -= f*500;\n\tfor(int i=0;i<5;i++){\n\t\tv[i]=x/c[i];\n\t\tx -= v[i]*c[i];\n\t}\n\t//assert(x==0);\n\treturn make_pair(f,v);\n}\n/*void dump(vector<int> &v){\n\tfor(int i=0;i<v.size();i++){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}*/\nP dfs(int id,int V){\n\t/*cout << \"call : \" << id << endl;\n\tcout << \"vec : \";\n\tdump(vec);\n\tcout << endl;*/\n\tint tmp = V;\n\tif(id==n){\n\t\treturn P(0,0);\n\t}\n\tmap<int,P>::iterator it;\n\tif(dp[id][V].fi!=-1){\n\t\treturn dp[id][V];\n\t}\n\tP res = dfs(id+1,V);\n\tvector<int> vec = decode(V);\n\tint h = ((p[id]-1)/1000+1)*1000;;\n\tfor(int i=0;i<5;i++){\n\t\twhile(vec[i]>0&&h-p[id]+c[i]<1000){\n\t\t\tvec[i]--;\n\t\t\th += c[i];\n\t\t}\n\t}\n\tpair<int,vector<int> > ch = charge(h-p[id]);\n\tfor(int i=0;i<5;i++)vec[i] += (ch.sec)[i];\n\tP res2 = dfs(id+1,encode(vec));\n\tres2.fi += ch.fi;\n\tres2.sec -= p[id];\n\tdp[id][tmp]=max(res,res2);\n\t/*cout << \"end : \" << id << endl;\n\tcout << \"vec : \";\n\tdump();\n\tcout << \"result : \" << dp[id][vec].fi << ' ' << -dp[id][vec].sec << endl;*/\n\treturn dp[id][tmp];\n}\nbool solve(){\n\tcin >> n;\n\tif(n==0)return false;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<SIZE;j++){\n\t\t\tdp[i][j]=P(-1,-1);\n\t\t}\n\t}\n\tP ans = dfs(0,0);\n\tcout << ans.fi << ' ' << -ans.sec << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nP gre(P x, P y) {\n\tif (x.first > y.first)return x;\n\tif (x.first == y.first&&x.second < y.second)return x;\n\treturn y;\n}\nbool sor(P x, P y) {\n\tif (x.first > y.first)return true;\n\tif (x.first == y.first&&x.second < y.second)return true;\n\treturn false;\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tP dp[101][50000];\n\t\tint cost[101] = {};\n\t\trep(i, n) {\n\t\t\tcin >> cost[i];\n\t\t}\n\t\trep(i, 101) {\n\t\t\trep(j, 50000) {\n\t\t\t\tdp[i][j] = { -1,-1 };\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = { 0,0 };\n\t\trep(i, n) {\n\t\t\trep(j, 50000) {\n\t\t\t\tif (dp[i][j].first == -1)continue;\n\t\t\t\tdp[i + 1][j] = gre(dp[i+1][j], dp[i][j]);\n\t\t\t\tif (cost[i] % 1000 == 0) {\n\t\t\t\t\tif (j >= 500) {\n\t\t\t\t\t\tP res;\n\t\t\t\t\t\tres = { dp[i][j].first + 1,dp[i][j].second+cost[i] };\n\t\t\t\t\t\tdp[i+1][j - 500] = gre(dp[i+1][j - 500], res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (j < cost[i] % 1000) {\n\t\t\t\t\tif (1000 - cost[i] % 1000 + j >= 500) {\n\t\t\t\t\t\tP res;\n\t\t\t\t\t\tres = { dp[i][j].first + 1,dp[i][j].second + cost[i] };\n\t\t\t\t\t\tdp[i + 1][500 - cost[i] % 1000 + j] = gre(dp[i + 1][500 - cost[i] % 1000 + j], res);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tP res;\n\t\t\t\t\t\tres = { dp[i][j].first,dp[i][j].second + cost[i] };\n\t\t\t\t\t\tdp[i + 1][1000 - cost[i] % 1000 + j] = gre(dp[i + 1][1000 - cost[i] % 1000 + j], res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (1000 - cost[i] % 1000 >= 500) {\n\t\t\t\t\t\tP res;\n\t\t\t\t\t\tres = { dp[i][j].first + 1,dp[i][j].second + cost[i] };\n\t\t\t\t\t\tdp[i + 1][500 - cost[i] % 1000+j] = gre(dp[i + 1][500 - cost[i] % 1000+j],res);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tP res;\n\t\t\t\t\t\tres = { dp[i][j].first,dp[i][j].second + cost[i] };\n\t\t\t\t\t\tdp[i + 1][1000 - cost[i] % 1000 + j] = gre(dp[i + 1][1000 - cost[i] % 1000 + j], res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(dp[n], dp[n] + 50000, sor);\n\t\tcout << dp[n][0].first << \" \" << dp[n][0].second << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 101;\nconst int M = 5010;\n\nint dp[N][M][N];\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vi a(n); for(auto& e : a) cin >> e;\n\n        rep(i, n + 1) rep(k, n + 1) rep(j, M) dp[i][j][k] = inf;\n        dp[0][0][0] = 0;\n\n        rep(i, n){\n            int org = a[i];\n            int price = org % 1000;\n            rep(k, n){\n                rep(j, M){\n                    int cur = dp[i][j][k];\n                    if(cur == inf) continue;\n\n                    if(price == 0){\n                        chmin(dp[i + 1][j][k], cur);\n                        int diff = (price + 500) % 1000;\n                        if(j - diff >= 0){\n                            chmin(dp[i + 1][j - diff][k + 1], cur + org);\n                        }\n                    }\n                    else if(price <= 500){\n                        chmin(dp[i + 1][min(M, j + 500 - price)][k + 1], cur + org);\n                    }\n                    else {\n                        chmin(dp[i + 1][j][k], cur);\n                        chmin(dp[i + 1][min(M, j + 1000 - price)][k], cur + org);\n                        int diff = (price + 500) % 1000;\n                        if(j - diff >= 0){\n                            chmin(dp[i + 1][j - diff][k + 1], cur + org);\n                        }\n                    }\n                }\n            }\n        }\n\n        pair<int, int> res(-1, -1);\n        rep(i, n + 1){\n            rep(k, n + 1){\n                rep(j, M){\n                    if(dp[i][j][k] == inf) continue;\n                    chmax(res, pair<int, int>(k, -dp[i][j][k]));\n                }\n            }\n        }\n        cout << res.first << \" \" << -res.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);++i)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nint main() {\n  while (true) {\n    int n;\n    cin>>n;\n    if(!n) break;\n    vector<int> p(n);\n    for(auto& v:p) cin>>v;\n    vector<vector<pair<int, int>>> dp(n+1,vector<pair<int, int>>(50000, make_pair(-INF, -INF)));\n    dp[0][0] = make_pair(0,0);\n    REP(i,n) {\n      REP(j,50000) {\n        dp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n        int ex = (1000 - p[i] % 1000) % 1000;\n        if (ex < 500) {\n          if (j + ex < 50000) {\n            dp[i+1][j+ex] = max(dp[i+1][j+ex], make_pair(dp[i][j].first, dp[i][j].second - p[i]));\n          }\n          if (j + ex >= 500) {\n            dp[i+1][j+ex-500] = max(dp[i+1][j+ex-500], make_pair(dp[i][j].first+1, dp[i][j].second - p[i]));\n          }\n        } else {\n          dp[i+1][j+ex-500] = max(dp[i+1][j+ex-500], make_pair(dp[i][j].first+1, dp[i][j].second - p[i]));\n        }\n      }\n    }\n    pair<int, int> res(0, 0);\n    REP(i,50000) res = max(res, dp[n][i]);\n    cout << res.first << ' ' << -res.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\n#define int long long\n\nusing namespace std;\n\n\nclass Solver {\n};\n\nsigned main() {\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\n\t\tvector<int> prices(n, 0);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> prices[i];\n\t\t}\n\n\t\tint change = 50000;\n\t\tint cnt = 100;\n\t\tvector <tuple<int, int>> dp(change + 500);\n\t\tfor (int i = 0; i < change + 500; i++)dp[i] = make_tuple(0, 1e9);\n\t\tget<1>(dp[0]) = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvector <tuple<int, int>> next(change + 500);\n\t\t\tfor (int j = 0; j < change + 500; j++)next[j] = make_tuple(0, 1e9);\n\t\t\tfor (int j = 0; j < change; j++) {\n\t\t\t\tint cnt_tmp = get<0>(dp[j]);\n\t\t\t\tint price_tmp = get<1>(dp[j]);\n\t\t\t\tif (price_tmp == 1e9)continue;\n\n\t\t\t\tif(get<0>(next[j])<cnt_tmp\n\t\t\t\t\t|| (get<0>(next[j]) == cnt_tmp \n\t\t\t\t\t\t&& get<1>(next[j]) > price_tmp)) {\n\t\t\t\t\tnext[j] = make_tuple(cnt_tmp, price_tmp);\n\t\t\t\t}\n\n\t\t\t\tint next_price = price_tmp + prices[i];\n\n\t\t\t\tif (prices[i] % 1000 == 0) {\n\t\t\t\t\tif (j >= 500) {\n\t\t\t\t\t\tint next_change = j - 500;\n\t\t\t\t\t\tif (get<0>(next[next_change]) < cnt_tmp + 1\n\t\t\t\t\t\t\t|| (get<0>(next[next_change]) == cnt_tmp + 1\n\t\t\t\t\t\t\t\t&& get<1>(next[next_change]) > next_price)) {\n\t\t\t\t\t\t\tnext[next_change] = make_tuple(cnt_tmp + 1, next_price);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (prices[i] % 1000 <= 500) {\n\t\t\t\t\tint next_change = j + 500 - (prices[i] % 1000);\n\t\t\t\t\tif (get<0>(next[next_change]) < cnt_tmp + 1\n\t\t\t\t\t\t|| (get<0>(next[next_change]) == cnt_tmp + 1\n\t\t\t\t\t\t\t&& get<1>(next[next_change]) > next_price)) {\n\t\t\t\t\t\tnext[next_change] = make_tuple(cnt_tmp + 1, next_price);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint next_change = j + 1000 - (prices[i] % 1000);\n\t\t\t\t\tif (get<0>(next[next_change]) < cnt_tmp\n\t\t\t\t\t\t|| (get<0>(next[next_change]) == cnt_tmp\n\t\t\t\t\t\t\t&& get<1>(next[next_change]) > next_price)) {\n\t\t\t\t\t\tnext[next_change] = make_tuple(cnt_tmp, next_price);\n\t\t\t\t\t}\n\t\t\t\t\tif (j >= prices[i] % 500) {\n\t\t\t\t\t\tnext_change = j - (prices[i] % 500);\n\t\t\t\t\t\tif (get<0>(next[next_change]) < cnt_tmp + 1\n\t\t\t\t\t\t\t|| (get<0>(next[next_change]) == cnt_tmp + 1\n\t\t\t\t\t\t\t\t&& get<1>(next[next_change]) > next_price)) {\n\t\t\t\t\t\t\tnext[next_change] = make_tuple(cnt_tmp + 1, next_price);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = next;\n\t\t}\n\n\t\tint res_cnt = 0;\n\t\tint res_price = 1e9;\n\t\tfor (int i = 0; i < change;i++) {\n\t\t\tint cnt_tmp = get<0>(dp[i]);\n\t\t\tint price_tmp = get<1>(dp[i]);\n\t\t\tif (res_cnt < cnt_tmp\n\t\t\t\t|| (res_cnt == cnt_tmp && price_tmp < res_price)) {\n\t\t\t\tres_cnt = cnt_tmp;\n\t\t\t\tres_price = price_tmp;\n\t\t\t}\n\t\t}\n\n\t\tcout << res_cnt << \" \" << res_price << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vii;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip> vip;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 :1e9;\n#define MAX 4010\nint dp[110][110][MAX];\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi in(n);\n\t\trep(i,n)cin>>in[i];\n\t\trep(i,110)rep(j,110)rep(k,MAX)dp[i][j][k]=inf;\n\t\tdp[0][0][0]=0;\n\t\trep(i,n)rep(j,n)rep(k,MAX)if(dp[i][j][k]!=inf){\n\t\t\tdp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k]);\n\t\t\tint J=j,K=k,a=in[i]%1000;\n\t\t\tif(k<=a&&a){\n\t\t\t\tK=1000+k-a;\n\t\t\t\tif(K<MAX)dp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\tif(K>=500)J++,K-=500;\n\t\t\t\tif(K<MAX)dp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t}else if(k>a&&a){\n\t\t\t\tif(a+500<=k)\n\t\t\t\t\tK=k-a;\n\t\t\t\telse K=k+1000-a;\n\t\t\t\tif(K<MAX)dp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t\tJ++;\n\t\t\t\tK-=500;\n\t\t\t\tif(K<MAX)dp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t}else{\n\t\t\t\tif(K>=500)K-=500,J++;\n\t\t\t\tif(K<MAX)dp[i+1][J][K]=min(dp[i+1][J][K],dp[i][j][k]+in[i]);\n\t\t\t}\n\t\t}\n\t\tint outc=0,out=inf;\n\t\trep(i,n+1)rep(j,MAX)if(dp[n][i][j]!=inf){\n\t\t\tif(outc<i){\n\t\t\t\toutc=i;\n\t\t\t\tout=dp[n][i][j];\n\t\t\t}else if(outc==i)\n\t\t\t\tout=min(out,dp[n][i][j]);\n\t\t}\n\t\tcout<<outc<<\" \"<<out<<endl;\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1603\n  Title:500 yen saver\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n\nstruct k_inf_st\n{\n  int change;\n  int c500;\n  int amount;\n} inf[100000],work[100000];\nint cnt;\nint n ,p[100];\n\nint compare_st(const void *a, const void *b)\n{\n  int a1,b1;\n  a1 = ((struct k_inf_st *)a)->change;\n  b1 = ((struct k_inf_st *)b)->change;\n\n  if(a1  >  b1)\n    return(1);\n  if(a1 <   b1)\n    return(-1);\n\n  a1 = ((struct k_inf_st *)a)->c500;\n  b1 = ((struct k_inf_st *)b)->c500;\n\n  if(a1  >  b1)\n    return(-1);\n  if(a1 <   b1)\n    return(1);\n\n\n  a1 = ((struct k_inf_st *)a)->amount;\n  b1 = ((struct k_inf_st *)b)->amount;\n\n\n  if(a1  >  b1)\n    return(1);\n  if(a1 <   b1)\n    return(-1);\n  if(a1 ==  b1)\n    return(0);\n}\n\nvoid dump(int n)\n{\n  int i;\n  \n  for(i=0;i<n;i++)\n    printf(\"%d [%d][%d]|\\n\",inf[i].c500,inf[i].change,inf[i].amount);\n  \n  printf(\"--[cnt=%d]--\\n\",cnt);\n}\n\nvoid shrink()\n{\n  int i,j,ch,c5,amt;\n\n  for(i=0,j=0,ch=-1;i<cnt;i++)\n    if(inf[i].change != ch)\n      {\n\tmemcpy(&work[j],&inf[i],sizeof(struct k_inf_st));\n\tch = inf[i].change;\n\tj++;\n      }\n  cnt=j;\n  memcpy(inf,work,sizeof(struct k_inf_st)*cnt);\n\n  for(i=0,j=0,c5=-1;i<cnt;i++)\n    if(inf[i].c500 > c5)\n      {\n\tmemcpy(&work[j],&inf[i],sizeof(struct k_inf_st));\n\tc5  = inf[i].c500;\n\tamt = inf[i].amount;\n\tj++;\n      }\n    else if(inf[i].c500 == c5 && inf[i].amount < amt) \n      {\n\tmemcpy(&work[j],&inf[i],sizeof(struct k_inf_st));\n\tch  = inf[i].change;\n\tamt = inf[i].amount;\n\tj++;\n      }\n\n  cnt=j;\n  memcpy(inf,work,sizeof(struct k_inf_st)*cnt);\n  \n }\n\nvoid calc(int n)\n{\n  int ch,i,cnt_old,ch2,c2,pr,pr2;\n  \n  pr=p[n];\n  //printf(\"no=%d pr=%d\\n\",n,pr);\n\n  if(pr % 1000 == 0)\n    {\n      memcpy(&inf[cnt],&inf[0],sizeof(struct k_inf_st)*cnt);\n      //dump(cnt*2);\n      cnt_old=cnt;\n      cnt *= 2;\n      for(i=cnt_old;i<cnt_old*2;i++)\n\t  {\n\t    inf[i].change = inf[i].change + 500;\n\t    inf[i].c500 ++;\n\t    inf[i].amount += pr;\n\t  }\n    }\n  else if(pr % 1000 <= 500)\n    {\n      ch = 500 - (pr % 1000);\n      for(i=0;i<=cnt;i++)\n\t{\n\t  inf[i].change = max(0,inf[i].change - ch);\n\t  inf[i].c500 ++;\n\t  inf[i].amount += pr;\n\t}\n    }\n  else\n    {\n      ch = (pr % 1000) - 500;\n      memcpy(&inf[cnt],&inf[0],sizeof(struct k_inf_st)*cnt);\n      //dump(cnt*2);\n      cnt_old=cnt;\n      cnt *= 2;\n      for(i=cnt_old;i<cnt_old*2;i++)\n\t{\n\t  inf[i].change += ch;\n\t  ch2 = inf[i].change;\n\n\t  c2  = inf[i].c500;\n\t  inf[i].c500++;\n\n\t  inf[i].amount += pr;\n\t  pr2 = inf[i].amount;\n\n\t  //printf(\"** [%d] [%d]\\n\",ch,c2);\n\t  if(ch2 >= 500 && c2 > 0)\n\t    {\n\t      memcpy(&inf[cnt],&inf[1],sizeof(struct k_inf_st));\n\t      inf[cnt].change = ch2 - 500;\n\t      inf[cnt].c500   = c2;\n\t      inf[cnt].amount = pr2;\n\t      cnt ++;\n\t    }\n\t  else if(ch2 < 500 && c2 > 0)\n\t    {\n\t      memcpy(&inf[cnt],&inf[1],sizeof(struct k_inf_st));\n\t      inf[cnt].change = 0;\n\t      inf[cnt].c500   = c2;\n\t      inf[cnt].amount = pr2;\n\t      cnt ++;\n\t    }\n\t}\n      //dump(cnt);\n    }\n  qsort(inf,cnt,sizeof(struct k_inf_st),compare_st);\n  shrink();\n  //dump(cnt);\n}\n\n\nmain()\n{\n  int i,ret,ret2;\n  \n   while(scanf(\"%d\",&n) && n)\n    {\n      memset(inf,0,sizeof(inf));\n      for(i=0;i<n;i++)\n\tscanf(\"%d\",&p[i]);\n\n      cnt=1;\n      \n      for(i=n-1;i>=0;i--)\n\tcalc(i);\n\n      printf(\"%d %d\\n\",inf[0].c500,inf[0].amount);\n    }\n \n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1603: 500-yen Saving\n// 2018.1.30 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX  49900\n\nint p[101];\nchar dc[101][50000]; int ds[101][50000];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint n, i, k, ii, j, c, s, a, b, f;\n\n\twhile (n = in()) {\n\t\tfor (i = 0; i < n; i++) p[i] = in();\n\t\tmemset(dc, -1, sizeof(dc)), memset(ds, 0, sizeof(ds));\n        dc[0][0] = 0;\n\n\t\tfor (i = 0, ii = 1; i < n; i++, ii++) for (j = 0; j <= MAX; j++) if (dc[i][j] >= 0) {\n            if (dc[ii][j] < dc[i][j] || dc[i][j] == dc[ii][j] && ds[i][j] < ds[ii][j]) {\n                dc[ii][j] = dc[i][j], ds[ii][j] = ds[i][j];\n            }\n            a = dc[i][j], b = ds[i][j] + p[i];\n            f = (5000 - p[i]) % 1000;\n\t\t\tk = j + f; if (k >= 500) a++, k -= 500;\n            if (dc[ii][k] < a || dc[ii][k] == a && b < ds[ii][k]) dc[ii][k] = a, ds[ii][k] = b;\n        }\n        c = s = 0;\n\t\tfor (j = 0; j <= MAX; j++) {\n\t\t\tif (c < dc[n][j] || dc[n][j] == c && ds[n][j] < s)\n\t\t\t\tc = dc[n][j], s = ds[n][j];\n\t\t}\n        printf(\"%d %d\\n\", c, s);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1603: 500-yen Saving\n// 2018.1.30 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 49900\n\nint p[101];\nint dp[2][101][50000];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint n, i, j, c, s, a, b, f, g;\n\n\twhile (n = in()) {\n\t\tfor (i = 0; i < n; i++) p[i] = in();\n\t\tmemset(dp[0], -1, sizeof(dp[0])), memset(dp[1], 0, sizeof(dp[1]));\n        dp[0][0][0] = 0;\n\n\t\tfor (i = 0; i < n; i++) for (j = 0; j <= MAX; j++) if (dp[0][i][j] >= 0) {\n            if (dp[0][i+1][j] < dp[0][i][j] || dp[0][i][j] == dp[0][i+1][j] && dp[1][i][j] < dp[1][i+1][j]) {\n                dp[0][i+1][j] = dp[0][i][j], dp[1][i+1][j] = dp[1][i][j];\n            }\n            a = dp[0][i][j], b = dp[1][i][j] + p[i];\n            f = (5000 - p[i]) % 1000, g = j + f;\n            if (g >= 500) a++, g -= 500;\n            if (dp[0][i+1][g] < a || dp[0][i+1][g] == a && b < dp[1][i+1][g]) dp[0][i+1][g] = a, dp[1][i+1][g] = b;\n        }\n        c = s = 0;\n\t\tfor (j = 0; j <= MAX; j++) {\n\t\t\tif (c < dp[0][n][j] || dp[0][n][j] == c && dp[1][n][j] < s)\n\t\t\t\tc = dp[0][n][j], s = dp[1][n][j];\n\t\t}\n        printf(\"%d %d\\n\", c, s);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1603\n  Title:500 yen saver\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n\nstruct k_inf_st\n{\n  int change;\n  int c500;\n  int amount;\n} inf[1000],work[1000];\nint cnt;\nint n ,p[100];\n\nint compare_st(const void *a, const void *b)\n{\n  int a1,b1;\n  a1 = ((struct k_inf_st *)a)->change;\n  b1 = ((struct k_inf_st *)b)->change;\n\n  if(a1  >  b1)\n    return(1);\n  if(a1 <   b1)\n    return(-1);\n\n  a1 = ((struct k_inf_st *)a)->c500;\n  b1 = ((struct k_inf_st *)b)->c500;\n\n  if(a1  >  b1)\n    return(-1);\n  if(a1 <   b1)\n    return(1);\n\n\n  a1 = ((struct k_inf_st *)a)->amount;\n  b1 = ((struct k_inf_st *)b)->amount;\n\n\n  if(a1  >  b1)\n    return(1);\n  if(a1 <   b1)\n    return(-1);\n  if(a1 ==  b1)\n    return(0);\n}\n\nvoid dump(int n)\n{\n  int i;\n  for(i=0;i<n;i++)\n    printf(\"%d [%d][%d]|\\n\",inf[i].c500,inf[i].change,inf[i].amount);\n  printf(\"--[cnt=%d]--\\n\",cnt);\n}\n\nvoid shrink()\n{\n  int i,j,ch,c5,amt;\n\n  for(i=0,j=0,ch=-1;i<cnt;i++)\n    if(inf[i].change != ch)\n      {\n\tmemcpy(&work[j],&inf[i],sizeof(struct k_inf_st));\n\tch = inf[i].change;\n\tj++;\n      }\n  cnt=j;\n  memcpy(inf,work,sizeof(struct k_inf_st)*cnt);\n\n  for(i=0,j=0,c5=-1;i<cnt;i++)\n    if(inf[i].c500 > c5)\n      {\n\tmemcpy(&work[j],&inf[i],sizeof(struct k_inf_st));\n\tc5  = inf[i].c500;\n\tamt = inf[i].amount;\n\tj++;\n      }\n    else if(inf[i].c500 == c5 && inf[i].amount < amt) \n      {\n\tmemcpy(&work[j],&inf[i],sizeof(struct k_inf_st));\n\tch  = inf[i].change;\n\tamt = inf[i].amount;\n\tj++;\n      }\n\n  cnt=j;\n  memcpy(inf,work,sizeof(struct k_inf_st)*cnt);\n  \n }\n\nvoid calc(int n)\n{\n  int ch,i,cnt_old,ch2,c2,pr,pr2;\n  \n  pr=p[n];\n  //printf(\"no=%d pr=%d\\n\",n,pr);\n\n  if(pr % 1000 == 0)\n    {\n      memcpy(&inf[cnt],&inf[0],sizeof(struct k_inf_st)*cnt);\n      //dump(cnt*2);\n      cnt_old=cnt;\n      cnt *= 2;\n      for(i=cnt_old;i<cnt_old*2;i++)\n\t  {\n\t    inf[i].change = inf[i].change + 500;\n\t    inf[i].c500 ++;\n\t    inf[i].amount += pr;\n\t  }\n    }\n  else if(pr % 1000 <= 500)\n    {\n      ch = 500 - (pr % 1000);\n      for(i=0;i<=cnt;i++)\n\t{\n\t  inf[i].change = max(0,inf[i].change - ch);\n\t  inf[i].c500 ++;\n\t  inf[i].amount += pr;\n\t}\n    }\n  else\n    {\n      ch = (pr % 1000) - 500;\n      memcpy(&inf[cnt],&inf[0],sizeof(struct k_inf_st)*cnt);\n      //dump(cnt*2);\n      cnt_old=cnt;\n      cnt *= 2;\n      for(i=cnt_old;i<cnt_old*2;i++)\n\t{\n\t  inf[i].change += ch;\n\t  ch2 = inf[i].change;\n\n\t  c2  = inf[i].c500;\n\t  inf[i].c500++;\n\n\t  inf[i].amount += pr;\n\t  pr2 = inf[i].amount;\n\n\t  //printf(\"** [%d] [%d]\\n\",ch,c2);\n\t  if(ch2 >= 500 && c2 > 0)\n\t    {\n\t      memcpy(&inf[cnt],&inf[1],sizeof(struct k_inf_st));\n\t      inf[cnt].change = ch2 - 500;\n\t      inf[cnt].c500   = c2;\n\t      inf[cnt].amount = pr2;\n\t      cnt ++;\n\t    }\n\t  else if(ch2 < 500 && c2 > 0)\n\t    {\n\t      memcpy(&inf[cnt],&inf[1],sizeof(struct k_inf_st));\n\t      inf[cnt].change = 0;\n\t      inf[cnt].c500   = c2;\n\t      inf[cnt].amount = pr2;\n\t      cnt ++;\n\t    }\n\t}\n      //dump(cnt);\n    }\n  qsort(inf,cnt,sizeof(struct k_inf_st),compare_st);\n  shrink();\n  //dump(cnt);\n}\n\n\nmain()\n{\n  int i,ret,ret2;\n  \n\n  while(scanf(\"%d\",&n) && n)\n    {\n      memset(inf,0,sizeof(inf));\n      for(i=0;i<n;i++)\n\tscanf(\"%d\",&p[i]);\n\n      cnt=1;\n      \n      for(i=n-1;i>=0;i--)\n\tcalc(i);\n\n      printf(\"%d %d\\n\",inf[0].c500,inf[0].amount);\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1603\n  Title:500 yen saver\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n\nstruct k_inf_st\n{\n  int change;\n  int c500;\n  int amount;\n  int flag;\n} inf[10000],work[10000];\nint cnt;\nint n ,p[100];\n\nint compare_st(const void *a, const void *b)\n{\n  int a1,b1;\n  a1 = ((struct k_inf_st *)a)->change;\n  b1 = ((struct k_inf_st *)b)->change;\n\n  if(a1  >  b1)\n    return(1);\n  if(a1 <   b1)\n    return(-1);\n\n  a1 = ((struct k_inf_st *)a)->c500;\n  b1 = ((struct k_inf_st *)b)->c500;\n\n  if(a1  >  b1)\n    return(-1);\n  if(a1 <   b1)\n    return(1);\n\n\n  a1 = ((struct k_inf_st *)a)->amount;\n  b1 = ((struct k_inf_st *)b)->amount;\n\n\n  if(a1  >  b1)\n    return(1);\n  if(a1 <   b1)\n    return(-1);\n  if(a1 ==  b1)\n    return(0);\n}\n\nvoid dump(int n)\n{\n  int i;\n  for(i=0;i<n;i++)\n    printf(\"%d [%d][%d]|\\n\",inf[i].c500,inf[i].change,inf[i].amount);\n  printf(\"--[cnt=%d]--\\n\",cnt);\n}\n\nvoid shrink()\n{\n  int i,j,ch,c5,amt;\n\n  for(i=0,j=0,ch=-1;i<cnt;i++)\n    if(inf[i].change != ch)\n      {\n\tmemcpy(&work[j],&inf[i],sizeof(struct k_inf_st));\n\tch = inf[i].change;\n\tj++;\n      }\n  cnt=j;\n  memcpy(inf,work,sizeof(struct k_inf_st)*cnt);\n\n  for(i=0,j=0,c5=-1;i<cnt;i++)\n    if(inf[i].c500 > c5)\n      {\n\tmemcpy(&work[j],&inf[i],sizeof(struct k_inf_st));\n\tc5  = inf[i].c500;\n\tamt = inf[i].amount;\n\tj++;\n      }\n    else if(inf[i].c500 == c5 && inf[i].amount < amt) \n      {\n\tmemcpy(&work[j],&inf[i],sizeof(struct k_inf_st));\n\tch  = inf[i].change;\n\tamt = inf[i].amount;\n\tj++;\n      }\n\n  cnt=j;\n  memcpy(inf,work,sizeof(struct k_inf_st)*cnt);\n  \n }\n\nvoid calc(int n)\n{\n  int ch,i,cnt_old,ch2,c2,pr,pr2;\n  \n  pr=p[n];\n  //printf(\"no=%d pr=%d\\n\",n,pr);\n\n  if(pr % 1000 == 0)\n    {\n      memcpy(&inf[cnt],&inf[0],sizeof(struct k_inf_st)*cnt);\n      //dump(cnt*2);\n      cnt_old=cnt;\n      cnt *= 2;\n      for(i=cnt_old;i<cnt_old*2;i++)\n\t  {\n\t    inf[i].change = inf[i].change + 500;\n\t    inf[i].c500 ++;\n\t    inf[i].amount += pr;\n\t  }\n    }\n  else if(pr % 1000 <= 500)\n    {\n      ch = 500 - (pr % 1000);\n      for(i=0;i<=cnt;i++)\n\t{\n\t  inf[i].change = max(0,inf[i].change - ch);\n\t  inf[i].c500 ++;\n\t  inf[i].amount += pr;\n\t}\n    }\n  else\n    {\n      ch = (pr % 1000) - 500;\n      memcpy(&inf[cnt],&inf[0],sizeof(struct k_inf_st)*cnt);\n      //dump(cnt*2);\n      cnt_old=cnt;\n      cnt *= 2;\n      for(i=cnt_old;i<cnt_old*2;i++)\n\t{\n\t  inf[i].change += ch;\n\t  ch2 = inf[i].change;\n\n\t  c2  = inf[i].c500;\n\t  inf[i].c500++;\n\n\t  inf[i].amount += pr;\n\t  pr2 = inf[i].amount;\n\n\t  //printf(\"** [%d] [%d]\\n\",ch,c2);\n\t  if(ch2 >= 500 && c2 > 0)\n\t    {\n\t      memcpy(&inf[cnt],&inf[1],sizeof(struct k_inf_st));\n\t      inf[cnt].change = ch2 - 500;\n\t      inf[cnt].c500   = c2;\n\t      inf[cnt].amount = pr2;\n\t      cnt ++;\n\t    }\n\t  else if(ch2 < 500 && c2 > 0)\n\t    {\n\t      memcpy(&inf[cnt],&inf[1],sizeof(struct k_inf_st));\n\t      inf[cnt].change = 0;\n\t      inf[cnt].c500   = c2;\n\t      inf[cnt].amount = pr2;\n\t      cnt ++;\n\t    }\n\t}\n      //dump(cnt);\n    }\n  qsort(inf,cnt,sizeof(struct k_inf_st),compare_st);\n  shrink();\n  //dump(cnt);\n}\n\n\nmain()\n{\n  int i,ret,ret2;\n  \n\n  while(scanf(\"%d\",&n) && n)\n    {\n      memset(inf,0,sizeof(inf));\n      for(i=0;i<n;i++)\n\tscanf(\"%d\",&p[i]);\n\n      cnt=1;\n      \n      for(i=n-1;i>=0;i--)\n\tcalc(i);\n\n      printf(\"%d %d\\n\",inf[0].c500,inf[0].amount);\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1603\n  Title:500 yen saver\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n\nstruct k_inf_st\n{\n  int change;\n  int c500;\n  int amount;\n  int flag;\n} inf[10000],work[10000];\nint cnt;\nint n ,p[100];\n\nint compare_st(const void *a, const void *b)\n{\n  int a1,b1;\n  a1 = ((struct k_inf_st *)a)->change;\n  b1 = ((struct k_inf_st *)b)->change;\n\n  if(a1  >  b1)\n    return(1);\n  if(a1 <   b1)\n    return(-1);\n\n  a1 = ((struct k_inf_st *)a)->c500;\n  b1 = ((struct k_inf_st *)b)->c500;\n\n  if(a1  >  b1)\n    return(-1);\n  if(a1 <   b1)\n    return(1);\n\n\n  a1 = ((struct k_inf_st *)a)->amount;\n  b1 = ((struct k_inf_st *)b)->amount;\n\n\n  if(a1  >  b1)\n    return(1);\n  if(a1 <   b1)\n    return(-1);\n  if(a1 ==  b1)\n    return(0);\n}\n\nvoid dump(int n)\n{\n  int i;\n  for(i=0;i<n;i++)\n    printf(\"%d [%d][%d]|\\n\",inf[i].c500,inf[i].change,inf[i].amount);\n  printf(\"---------\\n\");\n}\n\nvoid shrink()\n{\n  int i,j,ch,c5,amt;\n\n  for(i=0,j=0,ch=-1;i<cnt;i++)\n    if(inf[i].change != ch)\n      {\n\tmemcpy(&work[j],&inf[i],sizeof(struct k_inf_st));\n\tch = inf[i].change;\n\tj++;\n      }\n  cnt=j;\n  memcpy(inf,work,sizeof(struct k_inf_st)*cnt);\n\n  \n  for(i=0,j=0,c5=-1;i<cnt;i++)\n    if(inf[i].c500 != c5)\n      {\n\tmemcpy(&work[j],&inf[i],sizeof(struct k_inf_st));\n\tc5  = inf[i].c500;\n\tamt = inf[i].amount;\n\tj++;\n      }\n    else if(inf[i].amount < amt) \n      {\n\tmemcpy(&work[j],&inf[i],sizeof(struct k_inf_st));\n\tch  = inf[i].change;\n\tamt = inf[i].amount;\n\tj++;\n      }\n  cnt=j;\n  memcpy(inf,work,sizeof(struct k_inf_st)*cnt);\n  \n }\n\nvoid calc(int n)\n{\n  int ch,i,cnt_old,ch2,c2,pr,pr2;\n  \n  pr=p[n];\n  //printf(\"no=%d pr=%d\\n\",n,pr);\n\n  if(pr % 1000 == 0)\n    {\n      memcpy(&inf[cnt],&inf[0],sizeof(struct k_inf_st)*cnt);\n      //dump(cnt*2);\n      cnt_old=cnt;\n      cnt *= 2;\n      for(i=cnt_old;i<cnt_old*2;i++)\n\t  {\n\t    inf[i].change = inf[i].change + 500;\n\t    inf[i].c500 ++;\n\t    inf[i].amount += pr;\n\t  }\n    }\n  else if(pr % 1000 <= 500)\n    {\n      ch = 500 - (pr % 1000);\n      for(i=0;i<=cnt;i++)\n\t{\n\t  inf[i].change = max(0,inf[i].change - ch);\n\t  inf[i].c500 ++;\n\t  inf[i].amount += pr;\n\t}\n    }\n  else\n    {\n      ch = (pr % 1000) - 500;\n      memcpy(&inf[cnt],&inf[0],sizeof(struct k_inf_st)*cnt);\n      //dump(cnt*2);\n      cnt_old=cnt;\n      cnt *= 2;\n      for(i=cnt_old;i<cnt_old*2;i++)\n\t{\n\t  inf[i].change += ch;\n\t  ch2 = inf[i].change;\n\n\t  c2  = inf[i].c500;\n\t  inf[i].c500++;\n\n\t  inf[i].amount += pr;\n\t  pr2 = inf[i].amount;\n\n\t  //printf(\"** [%d] [%d]\\n\",ch,c2);\n\t  if(ch2 >= 500 && c2 > 0)\n\t    {\n\t      memcpy(&inf[cnt],&inf[1],sizeof(struct k_inf_st));\n\t      inf[cnt].change = ch2 - 500;\n\t      inf[cnt].c500   = c2;\n\t      inf[cnt].amount = pr2;\n\t      cnt ++;\n\t    }\n\t  else if(ch2 < 500 && c2 > 0)\n\t    {\n\t      memcpy(&inf[cnt],&inf[1],sizeof(struct k_inf_st));\n\t      inf[cnt].change = 0;\n\t      inf[cnt].c500   = c2;\n\t      inf[cnt].amount = pr2;\n\t      cnt ++;\n\t    }\n\t}\n      //dump(cnt);\n    }\n  qsort(inf,cnt,sizeof(struct k_inf_st),compare_st);\n  shrink();\n  //dump(cnt);\n}\n\n\nmain()\n{\n  int i,ret,ret2;\n  \n\n  while(scanf(\"%d\",&n) && n)\n    {\n      memset(inf,0,sizeof(inf));\n      for(i=0;i<n;i++)\n\tscanf(\"%d\",&p[i]);\n\n      cnt=1;\n      \n      for(i=n-1;i>=0;i--)\n\tcalc(i);\n\n      printf(\"%d %d\\n\",inf[0].c500,inf[0].amount);\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1603\n  Title:500 yen saver\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n\nstruct k_inf_st\n{\n  int change;\n  int c500;\n  int amount;\n} inf[100000],work[100000];\nint cnt;\nint n ,p[100];\n\nint compare_st(const void *a, const void *b)\n{\n  int a1,b1;\n  a1 = ((struct k_inf_st *)a)->change;\n  b1 = ((struct k_inf_st *)b)->change;\n\n  if(a1  >  b1)\n    return(1);\n  if(a1 <   b1)\n    return(-1);\n\n  a1 = ((struct k_inf_st *)a)->c500;\n  b1 = ((struct k_inf_st *)b)->c500;\n\n  if(a1  >  b1)\n    return(-1);\n  if(a1 <   b1)\n    return(1);\n\n\n  a1 = ((struct k_inf_st *)a)->amount;\n  b1 = ((struct k_inf_st *)b)->amount;\n\n\n  if(a1  >  b1)\n    return(1);\n  if(a1 <   b1)\n    return(-1);\n  if(a1 ==  b1)\n    return(0);\n}\n\nvoid dump(int n)\n{\n  int i;\n  \n  for(i=0;i<n;i++)\n    printf(\"%d [%d][%d]|\\n\",inf[i].c500,inf[i].change,inf[i].amount);\n  \n  printf(\"--[cnt=%d]--\\n\",cnt);\n}\n\nvoid shrink()\n{\n  int i,j,ch,c5,amt;\n\n  for(i=0,j=0,ch=-1;i<cnt;i++)\n    if(inf[i].change != ch)\n      {\n\tmemcpy(&work[j],&inf[i],sizeof(struct k_inf_st));\n\tch = inf[i].change;\n\tj++;\n      }\n  cnt=j;\n  memcpy(inf,work,sizeof(struct k_inf_st)*cnt);\n\n  for(i=0,j=0,c5=-1;i<cnt;i++)\n    if(inf[i].c500 > c5)\n      {\n\tmemcpy(&work[j],&inf[i],sizeof(struct k_inf_st));\n\tc5  = inf[i].c500;\n\tamt = inf[i].amount;\n\tj++;\n      }\n    else if(inf[i].c500 == c5 && inf[i].amount < amt) \n      {\n\tmemcpy(&work[j],&inf[i],sizeof(struct k_inf_st));\n\tch  = inf[i].change;\n\tamt = inf[i].amount;\n\tj++;\n      }\n\n  cnt=j;\n  memcpy(inf,work,sizeof(struct k_inf_st)*cnt);\n  \n }\n\nvoid calc(int n)\n{\n  int ch,i,cnt_old,ch2,c2,pr,pr2;\n  \n  pr=p[n];\n  printf(\"no=%d pr=%d\\n\",n,pr);\n\n  if(pr % 1000 == 0)\n    {\n      memcpy(&inf[cnt],&inf[0],sizeof(struct k_inf_st)*cnt);\n      //dump(cnt*2);\n      cnt_old=cnt;\n      cnt *= 2;\n      for(i=cnt_old;i<cnt_old*2;i++)\n\t  {\n\t    inf[i].change = inf[i].change + 500;\n\t    inf[i].c500 ++;\n\t    inf[i].amount += pr;\n\t  }\n    }\n  else if(pr % 1000 <= 500)\n    {\n      ch = 500 - (pr % 1000);\n      for(i=0;i<=cnt;i++)\n\t{\n\t  inf[i].change = max(0,inf[i].change - ch);\n\t  inf[i].c500 ++;\n\t  inf[i].amount += pr;\n\t}\n    }\n  else\n    {\n      ch = (pr % 1000) - 500;\n      memcpy(&inf[cnt],&inf[0],sizeof(struct k_inf_st)*cnt);\n      //dump(cnt*2);\n      cnt_old=cnt;\n      cnt *= 2;\n      for(i=cnt_old;i<cnt_old*2;i++)\n\t{\n\t  inf[i].change += ch;\n\t  ch2 = inf[i].change;\n\n\t  c2  = inf[i].c500;\n\t  inf[i].c500++;\n\n\t  inf[i].amount += pr;\n\t  pr2 = inf[i].amount;\n\n\t  //printf(\"** [%d] [%d]\\n\",ch,c2);\n\t  if(ch2 >= 500 && c2 > 0)\n\t    {\n\t      memcpy(&inf[cnt],&inf[1],sizeof(struct k_inf_st));\n\t      inf[cnt].change = ch2 - 500;\n\t      inf[cnt].c500   = c2;\n\t      inf[cnt].amount = pr2;\n\t      cnt ++;\n\t    }\n\t  else if(ch2 < 500 && c2 > 0)\n\t    {\n\t      memcpy(&inf[cnt],&inf[1],sizeof(struct k_inf_st));\n\t      inf[cnt].change = 0;\n\t      inf[cnt].c500   = c2;\n\t      inf[cnt].amount = pr2;\n\t      cnt ++;\n\t    }\n\t}\n      //dump(cnt);\n    }\n  qsort(inf,cnt,sizeof(struct k_inf_st),compare_st);\n  shrink();\n  dump(cnt);\n}\n\n\nmain()\n{\n  int i,ret,ret2;\n  \n   while(scanf(\"%d\",&n) && n)\n    {\n      memset(inf,0,sizeof(inf));\n      for(i=0;i<n;i++)\n\tscanf(\"%d\",&p[i]);\n\n      cnt=1;\n      \n      for(i=n-1;i>=0;i--)\n\tcalc(i);\n\n      printf(\"%d %d\\n\",inf[0].c500,inf[0].amount);\n    }\n \n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\ntypedef struct{\n    int coin;\n    int cost;\n}Data;\nint shop[100];\nint n;\nint main(void){\n    while(1){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        for(int i=0;i<n;i++){\n            scanf(\"%d\",&shop[i]);\n        }\n        Data dp[50001][2];\n        for(int i=0;i<2;i++){\n            for(int j=0;j<50001;j++){\n                dp[j][i].coin=dp[j][i].cost=-1;\n            }\n        }\n        //dp[小銭][店]\n        dp[0][0].coin=dp[0][0].cost=0;\n        dp[0][1].coin=dp[0][1].cost=0;\n        for(int j=0;j<n;j++){\n            int change=(1000 - shop[j] % 1000)%1000;\n            int tmp=(500-(change)%500);\n            for(int i=0;i<50001;i++){\n                if(dp[i][j&1].coin>=0){\n                    //買ってお釣りと500円玉\n                    int coin,cost;\n                    int next_coin;\n                    int next_cost;\n                    if(change>=500){\n                        next_coin=dp[i+change-500][!(j&1)].coin;\n                        next_cost=dp[i+change-500][!(j&1)].cost;\n                        coin=(dp[i][j&1].coin+1);\n                        cost=(dp[i][j&1].cost+shop[j]);\n                        if(next_coin<coin){\n                            dp[i+change-500][!(j&1)].coin=coin;\n                            dp[i+change-500][!(j&1)].cost=cost;\n                        }\n                        if(next_coin==coin&&next_cost>cost){\n                            dp[i+change-500][!(j&1)].coin=coin;\n                            dp[i+change-500][!(j&1)].cost=cost;\n                        }\n                    }\n                    else{\n                        next_coin=dp[i][!(j&1)].coin;\n                        next_cost=dp[i][!(j&1)].cost;\n                        coin=(dp[i][j&1].coin);\n                        cost=(dp[i][j&1].cost);\n                        if(next_coin<coin){\n                            dp[i][!(j&1)].coin=coin;\n                            dp[i][!(j&1)].cost=cost;\n                        }\n                        if(next_coin==coin&&next_cost>cost){\n                            dp[i][!(j&1)].coin=coin;\n                            dp[i][!(j&1)].cost=cost;\n                        }\n                        \n                        if(change>0){\n                            next_coin=dp[i+change][!(j&1)].coin;\n                            next_cost=dp[i+change][!(j&1)].cost;\n                            coin=(dp[i][j&1].coin);\n                            cost=(dp[i][j&1].cost+shop[j]);\n                            //dp[i+change][!(j&1)].coin=dp[i][j&1].coin;\n                            //dp[i+change][!(j&1)].cost=dp[i][j&1].cost+shop[j];\n                            if(next_coin<coin){\n                                dp[i+change][!(j&1)].coin=coin;\n                                dp[i+change][!(j&1)].cost=cost;\n                            }\n                            if(next_coin==coin&&next_cost>cost){\n                                dp[i+change][!(j&1)].coin=coin;\n                                dp[i+change][!(j&1)].cost=cost;\n                            }\n                        }\n\n                        //お釣りを出して500円玉\n                        if(i>=tmp){\n                            next_coin=dp[i-tmp][!(j&1)].coin;\n                            next_cost=dp[i-tmp][!(j&1)].cost;\n                            coin=(dp[i][j&1].coin+1);\n                            cost=(dp[i][j&1].cost+shop[j]);\n                            //dp[i-tmp][!(j&1)].coin=(coin=(dp[i][j&1].coin+1));\n                            //dp[i-tmp][!(j&1)].cost=(cost=(dp[i][j&1].cost+shop[j]));\n                            if(next_coin<coin){\n                                dp[i-tmp][!(j&1)].coin=coin;\n                                dp[i-tmp][!(j&1)].cost=cost;\n                            }\n                            if(next_coin==coin&&next_cost>cost){\n                                dp[i-tmp][!(j&1)].coin=coin;\n                                dp[i-tmp][!(j&1)].cost=cost;\n                            }\n                        }\n                    }\n                    //printf(\"i:%3d j:%d coin:%d cost:%d\\n\"\n                    //,i,j,dp[i][j&1].coin,dp[i][j&1].cost);\n                }\n            }\n            //for(int i=0;i<50001;i++) dp[i][j&1]=dp[i][!(j&1)];\n        }\n        int max=0;\n        int min=0;\n        n=n&1;\n        for(int i=0;i<50001;i++){\n            if(dp[i][n].coin>max){\n                max=dp[i][n].coin;\n                min=dp[i][n].cost;\n            }else if(dp[i][n].coin==max&&dp[i][n].cost<min){\n                min=dp[i][n].cost;\n            }\n        }\n        printf(\"%d %d\\n\",max,min);\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] p = new int[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\t\t\tlong[][][] f = new long[n + 1][500 * n + 1][2];\n\t\t\tfor (int i = 0; i < f.length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[i].length; ++j) {\n\t\t\t\t\tf[i][j][0] = -Integer.MAX_VALUE / 3;//500yen硬貨の枚数\n\t\t\t\t\tf[i][j][1] = Integer.MAX_VALUE / 3;//支払い金額\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[0][0][0] = 0;\n\t\t\tf[0][0][1] = 0;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < f[i].length; ++j) {\n\t\t\t\t\tf[i + 1][j][0] = f[i][j][0];\n\t\t\t\t\tf[i + 1][j][1] = f[i][j][1];\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < f[i].length; ++j) {\n\t\t\t\t\tif (f[i][j][0] < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (1 <= p[i] % 1000 && p[i] <= 500) {\n\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\tf[i + 1][j + coin] = choice(f[i + 1][j + coin],\n\t\t\t\t\t\t\t\tnew long[] { f[i][j][0] + 1, p[i] + f[i][j][1] });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\tf[i + 1][j + coin] = choice(f[i + 1][j + coin], new long[] { f[i][j][0], p[i] + f[i][j][1] });\n\t\t\t\t\t\tint need = (p[i] + 500) % 1000;\n\t\t\t\t\t\tif (need == 0)\n\t\t\t\t\t\t\tneed = 500;\n\t\t\t\t\t\tif (need <= j) {\n\t\t\t\t\t\t\tf[i + 1][j - need] = choice(f[i + 1][j - need],\n\t\t\t\t\t\t\t\t\tnew long[] { f[i][j][0] + 1, p[i] + f[i][j][1] });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong[] ans = new long[] { 0, 0 };\n\t\t\tfor (int i = 0; i < f[n].length; ++i) {\n\t\t\t\tans = choice(ans, f[n][i]);\n\t\t\t}\n\t\t\tSystem.out.println(ans[0] + \" \" + ans[1]);\n\t\t}\n\n\t}\n\n\tlong[] choice(long[] a, long[] b) {\n\t\tif (a[0] != b[0]) {\n\t\t\tif (a[0] > b[0]) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\treturn b;\n\t\t\t}\n\t\t} else {\n\t\t\tif (a[1] < b[1]) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\treturn b;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "package tester;\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] p = new int[n];\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\tp[i] = sc.nextInt();\n\n\t\t\tint[][][] f = new int[3][n + 1][500 * n + 1];\n\t\t\tfor (int i = 0; i < f.length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < f[i][j].length; ++k)\n\t\t\t\t\t\tf[i][j][k] = -Integer.MAX_VALUE / 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[0][0][0] = 0;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j <= 0; ++j) {\n\t\t\t\t\tArrays.fill(f[(i + 1) % 3][j], -Integer.MAX_VALUE / 3);\n\t\t\t\t}\n\t\t\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\t\t\tfor (int k = f[i % 3][j].length - 1; k >= 0; --k) {\n\t\t\t\t\t\tf[(i + 1) % 3][j][k] = Math.max(f[i % 3][j][k], f[(i + 1) % 3][j][k]);\n\t\t\t\t\t\tif (f[i % 3][j][k] < 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (1 <= p[i] % 1000 && p[i] % 1000 <= 500) {\n\t\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\t\tf[(i + 1) % 3][j + 1][k + coin] = Math.max(f[(i + 1) % 3][j + 1][k + coin],\n\t\t\t\t\t\t\t\t\tf[i % 3][j][k] + p[i]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\t\tf[(i + 1) % 3][j][k + coin] = Math.max(f[(i + 1) % 3][j][k + coin], f[i % 3][j][k] + p[i]);\n\t\t\t\t\t\t\tint v = p[i] % 1000 - 500 + (p[i] % 1000 == 0 ? 1000 : 0);\n\t\t\t\t\t\t\tif (k >= v) {\n\t\t\t\t\t\t\t\tf[(i + 1) % 3][j + 1][k - v] = Math.max(f[(i + 1) % 3][j + 1][k - v],\n\t\t\t\t\t\t\t\t\t\tf[i % 3][j][k] + p[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = 0, s = 0;\n\t\t\tfor (int i = 0; i < f[n % 3].length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[n % 3][i].length; ++j) {\n\t\t\t\t\tif (f[n % 3][i][j] < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (c < i || s > f[n % 3][i][j]) {\n\t\t\t\t\t\tc = i;\n\t\t\t\t\t\ts = f[n % 3][i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c + \" \" + s);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] p = new int[n];\n      for (int i = 0; i < n; ++i) {\n        p[i] = ni();\n      }\n\n      Node[][] dp = new Node[n + 1][1000];\n      for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j < 1000; ++j) {\n          Node node = new Node();\n          node.gohyaku = 0;\n          node.kingaku = INF;\n          dp[i][j] = node;\n        }\n      }\n      boolean[][] done = new boolean[n + 1][1000];\n      done[0][0] = true;\n      Node atom = new Node();\n      atom.gohyaku = 0;\n      atom.kingaku = 0;\n      dp[0][0] = atom;\n      for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 1000; ++j) {\n          if (!done[i][j]) {\n            continue;\n          }\n          // skip\n          if (dp[i + 1][j].compareTo(dp[i][j]) < 0) {\n            dp[i + 1][j] = dp[i][j];\n            done[i + 1][j] |= true;\n          }\n          // get 500 yen\n          int v = (p[i] + 500) % 1000;\n          if (v <= j) {\n            Node node = new Node();\n            node.gohyaku = dp[i][j].gohyaku + 1;\n            node.kingaku = dp[i][j].kingaku + p[i];\n            if (dp[i + 1][j - v].compareTo(node) < 0) {\n              dp[i + 1][j - v] = node;\n              done[i + 1][j - v] |= true;\n            }\n          }\n          // buy\n          int are = p[i] % 1000 == 0 ? p[i] / 1000 : p[i] / 1000 + 1;\n          int nokori = are * 1000 - p[i];\n          int aru = nokori / 500;\n          nokori -= 500 * aru;\n          Node node = new Node();\n          node.gohyaku = dp[i][j].gohyaku + aru;\n          node.kingaku = dp[i][j].kingaku + p[i];\n          int next = (nokori + j) % 1000;\n          if (dp[i + 1][next].compareTo(node) < 0) {\n            dp[i + 1][next] = node;\n            done[i + 1][next] |= true;\n          }\n//          debug(i + 1, j);\n//          for (int k = 0; k < 1000; ++k) {\n//            if (done[i + 1][k]) {\n//              debug(\"\\t\", dp[i + 1][k]);\n//            }\n//          }\n        }\n      }\n      Node ans = new Node();\n      ans.gohyaku = 0;\n      ans.kingaku = INF;\n      for (int i = 0; i < 1000; ++i) {\n        if (!done[n][i]) {\n          continue;\n        }\n        if (ans.compareTo(dp[n][i]) < 0) {\n          ans = dp[n][i];\n        }\n      }\n      System.out.println(ans.gohyaku + \" \" + ans.kingaku);\n    }\n  }\n\n  class Node implements Comparable<Node> {\n    int gohyaku = 0;\n    int kingaku = 0;\n\n    @Override\n    public int compareTo(Node node) {\n      if (gohyaku != node.gohyaku) {\n        return gohyaku - node.gohyaku;\n      }\n      return node.kingaku - kingaku;\n    }\n\n    @Override\n    public String toString() {\n      return \"{ gohyaku = \" + gohyaku + \", kingaku = \" + kingaku + \" }\";\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "package tester;\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] p = new int[n];\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\tp[i] = sc.nextInt();\n\n\t\t\tint[][][] f = new int[n + 1][n + 1][500 * n + 1];\n\t\t\tfor (int i = 0; i < f.length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < f[i][j].length; ++k)\n\t\t\t\t\t\tf[i][j][k] = -Integer.MAX_VALUE / 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[0][0][0] = 0;\n\t\t\t// f[i][coin]=\n\t\t\t// 100*500*100*100\n\t\t\t// f[i][j]=500円i枚、消費j円の時の硬貨は最大何円あるか\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\t\t\tfor (int k = f[i][j].length - 1; k >= 0; --k) {\n\t\t\t\t\t\tf[i + 1][j][k] = Math.max(f[i][j][k], f[i + 1][j][k]);\n\t\t\t\t\t\tif (f[i][j][k] < 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (1 <= p[i] % 1000 && p[i] % 1000 <= 500) {\n\t\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\t\tf[i + 1][j + 1][k + coin] = Math.max(f[i + 1][j + 1][k + coin], f[i][j][k] + p[i]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\t\tf[i + 1][j][k + coin] = Math.max(f[i + 1][j][k + coin], f[i][j][k] + p[i]);\n\t\t\t\t\t\t\tint v = p[i] % 1000 - 500 + (p[i] % 1000 == 0 ? 1000 : 0);\n\t\t\t\t\t\t\tif (k >= v) {\n\t\t\t\t\t\t\t\tf[i + 1][j + 1][k - v] = Math.max(f[i + 1][j + 1][k - v], f[i][j][k] + p[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = 0, s = 0;\n\t\t\tfor (int i = 0; i <f[n].length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[n][i].length; ++j) {\n\t\t\t\t\tif (f[n][i][j] < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (c < i || s > f[n][i][j]) {\n\t\t\t\t\t\tc = i;\n\t\t\t\t\t\ts = f[n][i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c + \" \" + s);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] p = new int[n];\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\tp[i] = sc.nextInt();\n\n\t\t\tint[][][] f = new int[n + 1][n + 1][500 * n + 1];\n\t\t\tfor (int i = 0; i < f.length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < f[i][j].length; ++k)\n\t\t\t\t\t\tf[i][j][k] = -Integer.MAX_VALUE / 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[0][0][0] = 0;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\t\t\tfor (int k = f[i][j].length - 1; k >= 0; --k) {\n\t\t\t\t\t\tf[i + 1][j][k] = Math.max(f[i][j][k], f[i + 1][j][k]);\n\t\t\t\t\t\tif (f[i][j][k] < 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (1 <= p[i] % 1000 && p[i] % 1000 <= 500) {\n\t\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\t\tf[i + 1][j + 1][k + coin] = Math.max(f[i + 1][j + 1][k + coin], f[i][j][k] + p[i]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\t\tf[i + 1][j][k + coin] = Math.max(f[i + 1][j][k + coin], f[i][j][k] + p[i]);\n\t\t\t\t\t\t\tint v = p[i] % 1000 - 500 + (p[i] % 1000 == 0 ? 1000 : 0);\n\t\t\t\t\t\t\tif (k >= v) {\n\t\t\t\t\t\t\t\tf[i + 1][j + 1][k - v] = Math.max(f[i + 1][j + 1][k - v], f[i][j][k] + p[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = 0, s = 0;\n\t\t\tfor (int i = 0; i <f[n].length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[n][i].length; ++j) {\n\t\t\t\t\tif (f[n][i][j] < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (c < i || s > f[n][i][j]) {\n\t\t\t\t\t\tc = i;\n\t\t\t\t\t\ts = f[n][i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c + \" \" + s);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] p = new int[n];\n      for (int i = 0; i < n; ++i) {\n        p[i] = ni();\n      }\n\n      Node[][] dp = new Node[n + 1][1000];\n      for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j < 1000; ++j) {\n          Node node = new Node();\n          node.gohyaku = 0;\n          node.kingaku = INF;\n          dp[i][j] = node;\n        }\n      }\n      boolean[][] done = new boolean[n + 1][1000];\n      done[0][0] = true;\n      Node atom = new Node();\n      atom.gohyaku = 0;\n      atom.kingaku = 0;\n      dp[0][0] = atom;\n      for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 1000; ++j) {\n          if (!done[i][j]) {\n            continue;\n          }\n          // skip\n          if (dp[i + 1][j].compareTo(dp[i][j]) < 0) {\n            dp[i + 1][j] = dp[i][j];\n            done[i + 1][j] |= true;\n          }\n          // get 500 yen\n          int v = (p[i] + 500) % 1000;\n          if (v <= j) {\n            Node node = new Node();\n            node.gohyaku = dp[i][j].gohyaku + 1;\n            node.kingaku = dp[i][j].kingaku + p[i];\n            if (dp[i + 1][j - v].compareTo(node) < 0) {\n              dp[i + 1][j - v] = node;\n              done[i + 1][j - v] |= true;\n            }\n          }\n          // get 500 yes 2\n          int nantoka = j;\n          while (nantoka < p[i]) {\n            nantoka += 1000;\n          }\n          if (nantoka - p[i] >= 500) {\n            Node node = new Node();\n            node.gohyaku = dp[i][j].gohyaku + 1;\n            node.kingaku = dp[i][j].kingaku + p[i];\n            int next = nantoka - p[i] - 500;\n            if (dp[i + 1][next].compareTo(node) < 0) {\n              dp[i + 1][next] = node;\n              done[i + 1][next] |= true;\n            }\n          }\n          // buy\n          int are = p[i] % 1000 == 0 ? p[i] / 1000 : p[i] / 1000 + 1;\n          int nokori = are * 1000 - p[i];\n          int aru = nokori / 500;\n          nokori -= 500 * aru;\n          Node node = new Node();\n          node.gohyaku = dp[i][j].gohyaku + aru;\n          node.kingaku = dp[i][j].kingaku + p[i];\n          int next = (nokori + j) % 1000;\n          if (dp[i + 1][next].compareTo(node) < 0) {\n            dp[i + 1][next] = node;\n            done[i + 1][next] |= true;\n          }\n//          debug(i + 1, j);\n//          for (int k = 0; k < 1000; ++k) {\n//            if (done[i + 1][k]) {\n//              debug(\"\\t\", dp[i + 1][k]);\n//            }\n//          }\n        }\n      }\n      Node ans = new Node();\n      ans.gohyaku = 0;\n      ans.kingaku = INF;\n      for (int i = 0; i < 1000; ++i) {\n        if (!done[n][i]) {\n          continue;\n        }\n        if (ans.compareTo(dp[n][i]) < 0) {\n          ans = dp[n][i];\n        }\n      }\n      System.out.println(ans.gohyaku + \" \" + ans.kingaku);\n    }\n  }\n\n  class Node implements Comparable<Node> {\n    int gohyaku = 0;\n    int kingaku = 0;\n\n    @Override\n    public int compareTo(Node node) {\n      if (gohyaku != node.gohyaku) {\n        return gohyaku - node.gohyaku;\n      }\n      return node.kingaku - kingaku;\n    }\n\n    @Override\n    public String toString() {\n      return \"{ gohyaku = \" + gohyaku + \", kingaku = \" + kingaku + \" }\";\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] p = new int[n];\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\tp[i] = sc.nextInt();\n\n\t\t\tint[][][] f = new int[n + 1][n + 1][500 * n + 1];\n\t\t\tfor (int i = 0; i < f.length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < f[i][j].length; ++k)\n\t\t\t\t\t\tf[i][j][k] = -Integer.MAX_VALUE / 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[0][0][0] = 0;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\t\t\tfor (int k = f[i][j].length - 1; k >= 0; --k) {\n\t\t\t\t\t\tf[i + 1][j][k] = Math.max(f[i][j][k], f[i + 1][j][k]);\n\t\t\t\t\t\tif (f[i][j][k] < 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (1 <= p[i] % 1000 && p[i] % 1000 <= 500) {\n\t\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\t\tf[i + 1][j + 1][k + coin] = Math.max(f[i + 1][j + 1][k + coin], f[i][j][k] + p[i]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\t\tf[i + 1][j][k + coin] = Math.max(f[i + 1][j][k + coin], f[i][j][k] + p[i]);\n\t\t\t\t\t\t\tint v = p[i] % 1000 - 500 + (p[i] % 1000 == 0 ? 1000 : 0);\n\t\t\t\t\t\t\tif (k >= v) {\n\t\t\t\t\t\t\t\tf[i + 1][j + 1][k - v] = Math.max(f[i + 1][j + 1][k - v], f[i][j][k] + p[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = 0, s = 0;\n\t\t\tfor (int i = 0; i <f[n].length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[n][i].length; ++j) {\n\t\t\t\t\tif (f[n][i][j] < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (c < i || s > f[n][i][j]) {\n\t\t\t\t\t\tc = i;\n\t\t\t\t\t\ts = f[n][i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c + \" \" + s);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] p = new int[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\t\t\tlong[][][] f = new long[n + 1][500 * n + 1][2];\n\t\t\tfor (int i = 0; i < f.length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[i].length; ++j) {\n\t\t\t\t\tf[i][j][0] = -Integer.MAX_VALUE / 3;//500yen硬貨の枚数\n\t\t\t\t\tf[i][j][1] = Integer.MAX_VALUE / 3;//支払い金額\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[0][0][0] = 0;\n\t\t\tf[0][0][1] = 0;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < f[i].length; ++j) {\n\t\t\t\t\tf[i + 1][j][0] = f[i][j][0];\n\t\t\t\t\tf[i + 1][j][1] = f[i][j][1];\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < f[i].length; ++j) {\n\t\t\t\t\tif (f[i][j][0] < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (1 <= p[i] % 1000 && p[i] <= 500) {\n\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\tf[i + 1][j + coin] = choice(f[i + 1][j + coin],\n\t\t\t\t\t\t\t\tnew long[] { f[i][j][0] + 1, p[i] + f[i][j][1] });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\tf[i + 1][j + coin] = choice(f[i + 1][j + coin], new long[] { f[i][j][0], p[i] + f[i][j][1] });\n\t\t\t\t\t\tint need = (p[i] + 500) % 1000;\n\t\t\t\t\t\tif (need == 0)\n\t\t\t\t\t\t\tneed = 500;\n\t\t\t\t\t\tif (need <= j) {\n\t\t\t\t\t\t\tf[i + 1][j - need] = choice(f[i + 1][j - need],\n\t\t\t\t\t\t\t\t\tnew long[] { f[i][j][0] + 1, p[i] + f[i][j][1] });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong[] ans = new long[] { 0, 0 };\n\t\t\tfor (int i = 0; i < f[n].length; ++i) {\n\t\t\t\tans = choice(ans, f[n][i]);\n\t\t\t}\n\t\t\tSystem.out.println(ans[0] + \" \" + ans[1]);\n\t\t}\n\n\t}\n\n\tlong[] choice(long[] a, long[] b) {\n\t\tif (a[0] != b[0]) {\n\t\t\tif (a[0] > b[0]) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\treturn b;\n\t\t\t}\n\t\t} else {\n\t\t\tif (a[1] < b[1]) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\treturn b;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] p = new int[n];\n      for (int i = 0; i < n; ++i) {\n        p[i] = ni();\n      }\n\n      Node[][] dp = new Node[n + 1][50000];\n      for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j < 50000; ++j) {\n          Node node = new Node();\n          node.gohyaku = 0;\n          node.kingaku = INF;\n          dp[i][j] = node;\n        }\n      }\n      boolean[][] done = new boolean[n + 1][50000];\n      done[0][0] = true;\n      Node atom = new Node();\n      atom.gohyaku = 0;\n      atom.kingaku = 0;\n      dp[0][0] = atom;\n      for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 50000; ++j) {\n          if (!done[i][j]) {\n            continue;\n          }\n          // skip\n          if (dp[i + 1][j].compareTo(dp[i][j]) < 0) {\n            dp[i + 1][j] = dp[i][j];\n            done[i + 1][j] |= true;\n          }\n          // get 500 yen\n          int v = (p[i] + 500) % 1000;\n          if (v <= j) {\n            Node node = new Node();\n            node.gohyaku = dp[i][j].gohyaku + 1;\n            node.kingaku = dp[i][j].kingaku + p[i];\n            if (dp[i + 1][j - v].compareTo(node) < 0) {\n              dp[i + 1][j - v] = node;\n              done[i + 1][j - v] |= true;\n            }\n          }\n          // get 500 yen 2\n          int kozeni = p[i] % 1000;\n          if (1 <= kozeni && kozeni <= 500) {\n            Node node = new Node();\n            node.gohyaku = dp[i][j].gohyaku + 1;\n            node.kingaku = dp[i][j].kingaku + p[i];\n            int next = 1000 - kozeni - 500 + j;\n            if (dp[i + 1][next].compareTo(node) < 0) {\n              dp[i + 1][next] = node;\n              done[i + 1][next] |= true;\n            }\n          }\n          // buy\n          {\n            int are = p[i] % 1000;\n            int nokori = (1000 - are) % 1000;\n            Node node = new Node();\n            node.gohyaku = dp[i][j].gohyaku;\n            node.kingaku = dp[i][j].kingaku + p[i];\n            int next = nokori + j;\n            int add = next / 500;\n            add = Math.min(add, 1);\n            node.gohyaku += add;\n            next -= 500 * add;\n            if (dp[i + 1][next].compareTo(node) < 0) {\n              dp[i + 1][next] = node;\n              done[i + 1][next] |= true;\n            }\n          }\n//          debug(i + 1, j);\n//          for (int k = 0; k < 1000; ++k) {\n//            if (done[i + 1][k]) {\n//              debug(\"\\t\", dp[i + 1][k]);\n//            }\n//          }\n        }\n      }\n      Node ans = new Node();\n      ans.gohyaku = 0;\n      ans.kingaku = INF;\n      for (int i = 0; i < 50000; ++i) {\n        if (!done[n][i]) {\n          continue;\n        }\n        if (ans.compareTo(dp[n][i]) < 0) {\n          ans = dp[n][i];\n        }\n      }\n      System.out.println(ans.gohyaku + \" \" + ans.kingaku);\n    }\n  }\n\n  class Node implements Comparable<Node> {\n    int gohyaku = 0;\n    int kingaku = 0;\n\n    @Override\n    public int compareTo(Node node) {\n      if (gohyaku != node.gohyaku) {\n        return gohyaku - node.gohyaku;\n      }\n      return node.kingaku - kingaku;\n    }\n\n    @Override\n    public String toString() {\n      return \"{ gohyaku = \" + gohyaku + \", kingaku = \" + kingaku + \" }\";\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nusing namespace std;\nint a=0;\nvector<string>sts;\nvector<int>ens;\nint getnum(){\n  if(sts[a]==\"*\"){\n    int num=1;\n    int pe=ens[a];\n    a++;\n    while(ens[a]==pe){\n      num*=getnum();\n    }\n    a++;\n    return num;\n  }\n    else if(sts[a]==\"+\"){\n      int num=0;\n      int pe=ens[a];\n      a++;\n      while(ens[a]==pe){\n\tnum+=getnum();\n      }\n      a++;\n      return num;\n    }else{\n      int num=stoi(sts[a]);\n      a++;\n      return num;\n    }\n}\nint main()\n{\n  while(1){\n    int n;cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;++i){\n      string st;cin>>st;\n      int n=st.find_first_not_of(\".\");\n      sts.push_back(st.substr(n));\n      ens.push_back(n);\n    }\n    int ans=getnum();\n    cout<<ans<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] p = new int[n];\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\tp[i] = sc.nextInt();\n\n\t\t\tint[][][] f = new int[3][n + 1][500 * n + 1];\n\t\t\tfor (int i = 0; i < f.length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < f[i][j].length; ++k)\n\t\t\t\t\t\tf[i][j][k] = -Integer.MAX_VALUE / 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[0][0][0] = 0;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j <= 0; ++j) {\n\t\t\t\t\tArrays.fill(f[(i + 1) % 3][j], -Integer.MAX_VALUE / 3);\n\t\t\t\t}\n\t\t\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\t\t\tfor (int k = f[i % 3][j].length - 1; k >= 0; --k) {\n\t\t\t\t\t\tf[(i + 1) % 3][j][k] = Math.max(f[i % 3][j][k], f[(i + 1) % 3][j][k]);\n\t\t\t\t\t\tif (f[i % 3][j][k] < 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (1 <= p[i] % 1000 && p[i] % 1000 <= 500) {\n\t\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\t\tf[(i + 1) % 3][j + 1][k + coin] = Math.max(f[(i + 1) % 3][j + 1][k + coin],\n\t\t\t\t\t\t\t\t\tf[i % 3][j][k] + p[i]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\t\tf[(i + 1) % 3][j][k + coin] = Math.max(f[(i + 1) % 3][j][k + coin], f[i % 3][j][k] + p[i]);\n\t\t\t\t\t\t\tint v = p[i] % 1000 - 500 + (p[i] % 1000 == 0 ? 1000 : 0);\n\t\t\t\t\t\t\tif (k >= v) {\n\t\t\t\t\t\t\t\tf[(i + 1) % 3][j + 1][k - v] = Math.max(f[(i + 1) % 3][j + 1][k - v],\n\t\t\t\t\t\t\t\t\t\tf[i % 3][j][k] + p[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = 0, s = 0;\n\t\t\tfor (int i = 0; i < f[n % 3].length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[n % 3][i].length; ++j) {\n\t\t\t\t\tif (f[n % 3][i][j] < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (c < i || s > f[n % 3][i][j]) {\n\t\t\t\t\t\tc = i;\n\t\t\t\t\t\ts = f[n % 3][i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c + \" \" + s);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,1,0,-1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic int idx;\n\tstatic char[][] str;\n\tstatic int lv;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint[] p = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[][] dpA = new int[n+1][500001];\n\t\t\tint[][] dpB = new int[n+1][500001];\n\t\t\tfor(int i = 0; i < dpA.length; i++) {\n\t\t\t\tArrays.fill(dpA[i], -1);\n\t\t\t\tArrays.fill(dpB[i], INF);\n\t\t\t}\n\t\t\tdpA[0][0] = 0;\n\t\t\tdpB[0][0] = 0;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = 0; j < dpA[i].length; j++) {\n\t\t\t\t\tif(dpA[i][j] == -1) continue;\n\t\t\t\t\t//not buy\n\t\t\t\t\tif(dpA[i+1][j] < dpA[i][j] || (dpA[i+1][j] == dpA[i][j] && dpB[i+1][j] > dpB[i][j])) {\n\t\t\t\t\t\tdpA[i+1][j] = dpA[i][j];\n\t\t\t\t\t\tdpB[i+1][j] = dpB[i][j];\n\t\t\t\t\t}\n\t\t\t\t\t//buy only 1k\n\t\t\t\t\tint o2 = (1000 - (p[i]%1000))%1000;\n\t\t\t\t\tif(dpA[i+1][j + o2] < dpA[i][j] || (dpA[i+1][j + o2] == dpA[i][j] && dpB[i+1][j + o2] > dpB[i][j] + p[i])) {\n\t\t\t\t\t\tdpA[i+1][j + o2] = dpA[i][j];\n\t\t\t\t\t\tdpB[i+1][j + o2] = dpB[i][j] + p[i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//buy\n\t\t\t\t\to2 = (1000 - (p[i]%1000))%1000;\n\t\t\t\t\tint need = 500 - o2;\n\t\t\t\t\tif(j >= need) {\n\t\t\t\t\t\tint nex = j - need;\n\t\t\t\t\t\tif(dpA[i+1][nex] < dpA[i][j] + 1 || (dpA[i+1][nex] == dpA[i][j]+1 && dpB[i+1][nex] > dpB[i][j] + p[i])) {\n\t\t\t\t\t\t\tdpA[i+1][nex] = dpA[i][j] + 1;\n\t\t\t\t\t\t\tdpB[i+1][nex] = dpB[i][j] + p[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tint MAX = INF;\n\t\t\tfor(int i = 0; i < dpA[n].length; i++) {\n\t\t\t\tif(ans < dpA[n][i] || (ans == dpA[n][i] && MAX > dpB[n][i])) {\n\t\t\t\t\tans = dpA[n][i];\n\t\t\t\t\tMAX = dpB[n][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans + \" \" + MAX);\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\t\n\t\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] p = new int[100];\n\t\tlong[][][] f = new long[100 + 1][100 * 500 + 1][2];\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[i].length; ++j) {\n\t\t\t\t\tf[i][j][0] = -Integer.MAX_VALUE / 3;//500yen硬貨の枚数\n\t\t\t\t\tf[i][j][1] = Integer.MAX_VALUE / 3;//支払い金額\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[0][0][0] = 0;\n\t\t\tf[0][0][1] = 0;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < 500 * n + 1; ++j) {\n\t\t\t\t\tf[i + 1][j][0] = f[i][j][0];\n\t\t\t\t\tf[i + 1][j][1] = f[i][j][1];\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < 500 * n + 1; ++j) {\n\t\t\t\t\tif (f[i][j][0] < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (1 <= p[i] % 1000 && p[i] <= 500) {\n\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\tf[i + 1][j + coin] = choice(f[i + 1][j + coin],\n\t\t\t\t\t\t\t\tnew long[] { f[i][j][0] + 1, p[i] + f[i][j][1] });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\tf[i + 1][j + coin] = choice(f[i + 1][j + coin], new long[] { f[i][j][0], p[i] + f[i][j][1] });\n\t\t\t\t\t\tint need = (p[i] + 500) % 1000;\n\t\t\t\t\t\tif (need == 0)\n\t\t\t\t\t\t\tneed = 500;\n\t\t\t\t\t\tif (need <= j) {\n\t\t\t\t\t\t\tf[i + 1][j - need] = choice(f[i + 1][j - need],\n\t\t\t\t\t\t\t\t\tnew long[] { f[i][j][0] + 1, p[i] + f[i][j][1] });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong[] ans = new long[] { 0, 0 };\n\t\t\tfor (int i = 0; i < f[n].length; ++i) {\n\t\t\t\tans = choice(ans, f[n][i]);\n\t\t\t}\n\t\t\tSystem.out.println(ans[0] + \" \" + ans[1]);\n\t\t}\n\n\t}\n\n\tlong[] choice(long[] a, long[] b) {\n\t\tif (a[0] != b[0]) {\n\t\t\tif (a[0] > b[0]) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\treturn b;\n\t\t\t}\n\t\t} else {\n\t\t\tif (a[1] < b[1]) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\treturn b;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] p = new int[100];\n\t\tlong[][][] f = new long[100 + 1][100 * 500 + 1][2];\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < f.length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[i].length; ++j) {\n\t\t\t\t\tf[i][j][0] = -Integer.MAX_VALUE / 3;//500yen硬貨の枚数\n\t\t\t\t\tf[i][j][1] = Integer.MAX_VALUE / 3;//支払い金額\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[0][0][0] = 0;\n\t\t\tf[0][0][1] = 0;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < 500 * n + 1; ++j) {\n\t\t\t\t\tf[i + 1][j][0] = f[i][j][0];\n\t\t\t\t\tf[i + 1][j][1] = f[i][j][1];\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < 500 * n + 1; ++j) {\n\t\t\t\t\tif (f[i][j][0] < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (1 <= p[i] % 1000 && p[i] % 1000 <= 500) {\n\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\tf[i + 1][j + coin] = choice(f[i + 1][j + coin],\n\t\t\t\t\t\t\t\tnew long[] { f[i][j][0] + 1, p[i] + f[i][j][1] });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\tf[i + 1][j + coin] = choice(f[i + 1][j + coin], new long[] { f[i][j][0], p[i] + f[i][j][1] });\n\t\t\t\t\t\tint need = (p[i] + 500) % 1000;\n\t\t\t\t\t\tif (need == 0)\n\t\t\t\t\t\t\tneed = 500;\n\t\t\t\t\t\tif (need <= j) {\n\t\t\t\t\t\t\tf[i + 1][j - need] = choice(f[i + 1][j - need],\n\t\t\t\t\t\t\t\t\tnew long[] { f[i][j][0] + 1, p[i] + f[i][j][1] });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong[] ans = new long[] { 0, 0 };\n\t\t\tfor (int i = 0; i < f[n].length; ++i) {\n\t\t\t\tans = choice(ans, f[n][i]);\n\t\t\t}\n\t\t\tSystem.out.println(ans[0] + \" \" + ans[1]);\n\t\t}\n\n\t}\n\n\tlong[] choice(long[] a, long[] b) {\n\t\tif (a[0] != b[0]) {\n\t\t\tif (a[0] > b[0]) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\treturn b;\n\t\t\t}\n\t\t} else {\n\t\t\tif (a[1] < b[1]) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\treturn b;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] p = new int[n];\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\tp[i] = sc.nextInt();\n\n\t\t\tint[][] f = new int[n + 1][5000 * n + 1];\n\t\t\tfor (int i = 0; i < f.length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[i].length; ++j) {\n\t\t\t\t\tf[i][j] = -Integer.MAX_VALUE / 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[0][0] = 0;\n\t\t\t// f[i][j]=500円i枚、消費j円の時の硬貨は最大何円あるか\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\t\t\tfor (int k = f[i].length - p[i] - 1; k >= 0; --k) {\n\t\t\t\t\t\tif (f[j][k] < 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (p[i] % 1000 > 0 && p[i] % 1000 <= 500) {\n\t\t\t\t\t\t\tf[j + 1][k + p[i]] = Math.max(f[j + 1][k + p[i]], f[j][k] + (1000 - p[i] % 1000) % 500);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tf[j][k + p[i]] = Math.max(f[j][k + p[i]], f[j][k] + (1000 - p[i]) % 1000);\n\t\t\t\t\t\t\tif (f[j][k] >= p[i] % 1000 - 500 + (p[i] % 1000 == 0 ? 1000 : 0)) {\n\t\t\t\t\t\t\t\tf[j + 1][k + p[i]] = Math.max(f[j + 1][k + p[i]], f[j][k] - (p[i] % 1000 - 500));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = 0, s = 0;\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\tfor (int j = 0; j < f[i].length; ++j) {\n\t\t\t\t\tif (f[i][j] < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tc = i;\n\t\t\t\t\ts = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c + \" \" + s);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] p = new int[n];\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\tp[i] = sc.nextInt();\n\n\t\t\tint[][][] f = new int[3][n + 1][500 * n + 1];\n\t\t\tfor (int i = 0; i < f.length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < f[i][j].length; ++k)\n\t\t\t\t\t\tf[i][j][k] = -Integer.MAX_VALUE / 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[0][0][0] = 0;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j <= 0; ++j) {\n\t\t\t\t\tArrays.fill(f[(i + 1) % 3][j], -Integer.MAX_VALUE / 3);\n\t\t\t\t}\n\t\t\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\t\t\tfor (int k = f[i % 3][j].length - 1; k >= 0; --k) {\n\t\t\t\t\t\tf[(i + 1) % 3][j][k] = Math.max(f[i % 3][j][k], f[(i + 1) % 3][j][k]);\n\t\t\t\t\t\tif (f[i % 3][j][k] < 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (1 <= p[i] % 1000 && p[i] % 1000 <= 500) {\n\t\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\t\tf[(i + 1) % 3][j + 1][k + coin] = Math.max(f[(i + 1) % 3][j + 1][k + coin],\n\t\t\t\t\t\t\t\t\tf[i % 3][j][k] + p[i]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint coin = (1000 - p[i] % 1000) % 500;\n\t\t\t\t\t\t\tf[(i + 1) % 3][j][k + coin] = Math.max(f[(i + 1) % 3][j][k + coin], f[i % 3][j][k] + p[i]);\n\t\t\t\t\t\t\tint v = p[i] % 1000 - 500 + (p[i] % 1000 == 0 ? 1000 : 0);\n\t\t\t\t\t\t\tif (k >= v) {\n\t\t\t\t\t\t\t\tf[(i + 1) % 3][j + 1][k - v] = Math.max(f[(i + 1) % 3][j + 1][k - v],\n\t\t\t\t\t\t\t\t\t\tf[i % 3][j][k] + p[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = 0, s = 0;\n\t\t\tfor (int i = 0; i < f[n % 3].length; ++i) {\n\t\t\t\tfor (int j = 0; j < f[n % 3][i].length; ++j) {\n\t\t\t\t\tif (f[n % 3][i][j] < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (c < i || s > f[n % 3][i][j]) {\n\t\t\t\t\t\tc = i;\n\t\t\t\t\t\ts = f[n % 3][i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c + \" \" + s);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] p = new int[n];\n      for (int i = 0; i < n; ++i) {\n        p[i] = ni();\n      }\n\n      Node[][] dp = new Node[n + 1][1000];\n      for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j < 1000; ++j) {\n          Node node = new Node();\n          node.gohyaku = 0;\n          node.kingaku = INF;\n          dp[i][j] = node;\n        }\n      }\n      boolean[][] done = new boolean[n + 1][1000];\n      done[0][0] = true;\n      Node atom = new Node();\n      atom.gohyaku = 0;\n      atom.kingaku = 0;\n      dp[0][0] = atom;\n      for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 1000; ++j) {\n          if (!done[i][j]) {\n            continue;\n          }\n          // skip\n          if (dp[i + 1][j].compareTo(dp[i][j]) < 0) {\n            dp[i + 1][j] = dp[i][j];\n            done[i + 1][j] |= true;\n          }\n          // get 500 yen\n          int v = (p[i] + 500) % 1000;\n          if (v <= j) {\n            Node node = new Node();\n            node.gohyaku = dp[i][j].gohyaku + 1;\n            node.kingaku = dp[i][j].kingaku + p[i];\n            if (dp[i + 1][j - v].compareTo(node) < 0) {\n              dp[i + 1][j - v] = node;\n              done[i + 1][j - v] |= true;\n            }\n          }\n          // get 500 yes 2\n          if (j - p[i] >= 500) {\n            Node node = new Node();\n            node.gohyaku = dp[i][j].gohyaku + 1;\n            node.kingaku = dp[i][j].kingaku + p[i];\n            int next = j - p[i];\n            if (dp[i + 1][next].compareTo(node) < 0) {\n              dp[i + 1][next] = node;\n              done[i + 1][next] |= true;\n            }\n          }\n          // buy\n          int are = p[i] % 1000 == 0 ? p[i] / 1000 : p[i] / 1000 + 1;\n          int nokori = are * 1000 - p[i];\n          int aru = nokori / 500;\n          nokori -= 500 * aru;\n          Node node = new Node();\n          node.gohyaku = dp[i][j].gohyaku + aru;\n          node.kingaku = dp[i][j].kingaku + p[i];\n          int next = (nokori + j) % 1000;\n          if (dp[i + 1][next].compareTo(node) < 0) {\n            dp[i + 1][next] = node;\n            done[i + 1][next] |= true;\n          }\n//          debug(i + 1, j);\n//          for (int k = 0; k < 1000; ++k) {\n//            if (done[i + 1][k]) {\n//              debug(\"\\t\", dp[i + 1][k]);\n//            }\n//          }\n        }\n      }\n      Node ans = new Node();\n      ans.gohyaku = 0;\n      ans.kingaku = INF;\n      for (int i = 0; i < 1000; ++i) {\n        if (!done[n][i]) {\n          continue;\n        }\n        if (ans.compareTo(dp[n][i]) < 0) {\n          ans = dp[n][i];\n        }\n      }\n      System.out.println(ans.gohyaku + \" \" + ans.kingaku);\n    }\n  }\n\n  class Node implements Comparable<Node> {\n    int gohyaku = 0;\n    int kingaku = 0;\n\n    @Override\n    public int compareTo(Node node) {\n      if (gohyaku != node.gohyaku) {\n        return gohyaku - node.gohyaku;\n      }\n      return node.kingaku - kingaku;\n    }\n\n    @Override\n    public String toString() {\n      return \"{ gohyaku = \" + gohyaku + \", kingaku = \" + kingaku + \" }\";\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal int MAX_M = 500 * 1000;\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tint[] p = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tp[i] = scan.nextInt();\n\t\t\t\n\t\t\tint[][] dp = new int[n + 1][MAX_M];\n\t\t\tint[][] ans = new int[n + 1][MAX_M];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < MAX_M; j++) {\n\t\t\t\t\tdp[i][j] = -1;\n\t\t\t\t\tans[i][j] = MAX_M;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp[0][0] = 0;\n\t\t\tans[0][0] = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t// 商品を買わない\n\t\t\t\tfor (int j = 0; j < MAX_M; j++) {\n\t\t\t\t\tdp[i + 1][j] = dp[i][j];\n\t\t\t\t\tans[i + 1][j] = ans[i][j];\n\t\t\t\t}\n\n\t\t\t\t// 商品を買う\n\t\t\t\tint change = (p[i] % 1000 == 0) ? 0 : (1000 - p[i] % 1000);\n\t\t\t\tfor (int j = 0; j < MAX_M; j++) {\n\t\t\t\t\tif (dp[i][j] == -1) continue;\n\n\t\t\t\t\tint get500Coin = j + change < 500 ? 0 : 1;\n\t\t\t\t\tint nextMoney = j + change - (500 * get500Coin);\n\t\t\t\t\tif (dp[i + 1][nextMoney] < dp[i][j] + get500Coin) {\n\t\t\t\t\t\tdp[i + 1][nextMoney] = dp[i][j] + get500Coin;\n\t\t\t\t\t\tans[i + 1][nextMoney] = ans[i][j] + p[i];\n\t\t\t\t\t} else if (dp[i + 1][nextMoney] == dp[i][j] + get500Coin) {\n\t\t\t\t\t\tans[i + 1][nextMoney] = Math.min(ans[i + 1][nextMoney], ans[i][j] + p[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint maxMAX_MCoin = 0;\n\t\t\tint minPay = 0;\n\t\t\tfor (int i = 0; i < MAX_M; i++) {\n\t\t\t\tif (maxMAX_MCoin < dp[n][i]) {\n\t\t\t\t\tmaxMAX_MCoin = dp[n][i];\n\t\t\t\t\tminPay = ans[n][i];\n\t\t\t\t} else if (maxMAX_MCoin == dp[n][i]) {\n\t\t\t\t\tminPay = Math.min(minPay, ans[n][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(maxMAX_MCoin + \" \" + minPay);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal int MAX_M = 500 * 1000;\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tint[] p = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tp[i] = scan.nextInt();\n\t\t\t\n\t\t\tchar[][] dp = new char[n + 1][MAX_M];\n\t\t\tint[][] ans = new int[n + 1][MAX_M];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < MAX_M; j++) {\n\t\t\t\t\tdp[i][j] = (char)-1;\n\t\t\t\t\tans[i][j] = MAX_M;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp[0][0] = 0;\n\t\t\tans[0][0] = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t// 商品を買わない\n\t\t\t\tfor (int j = 0; j < MAX_M; j++) {\n\t\t\t\t\tdp[i + 1][j] = dp[i][j];\n\t\t\t\t\tans[i + 1][j] = ans[i][j];\n\t\t\t\t}\n\n\t\t\t\t// 商品を買う\n\t\t\t\tint change = (p[i] % 1000 == 0) ? 0 : (1000 - p[i] % 1000);\n\t\t\t\tfor (int j = 0; j < MAX_M; j++) {\n\t\t\t\t\tif (dp[i][j] == -1) continue;\n\n\t\t\t\t\tint get500Coin = j + change < 500 ? 0 : 1;\n\t\t\t\t\tint nextMoney = j + change - (500 * get500Coin);\n\t\t\t\t\tif (dp[i + 1][nextMoney] < dp[i][j] + get500Coin) {\n\t\t\t\t\t\tdp[i + 1][nextMoney] = (char)(dp[i][j] + get500Coin);\n\t\t\t\t\t\tans[i + 1][nextMoney] = ans[i][j] + p[i];\n\t\t\t\t\t} else if (dp[i + 1][nextMoney] == dp[i][j] + get500Coin) {\n\t\t\t\t\t\tans[i + 1][nextMoney] = Math.min(ans[i + 1][nextMoney], ans[i][j] + p[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint maxMAX_MCoin = 0;\n\t\t\tint minPay = 0;\n\t\t\tfor (int i = 0; i < MAX_M; i++) {\n\t\t\t\tif (maxMAX_MCoin < dp[n][i]) {\n\t\t\t\t\tmaxMAX_MCoin = dp[n][i];\n\t\t\t\t\tminPay = ans[n][i];\n\t\t\t\t} else if (maxMAX_MCoin == dp[n][i]) {\n\t\t\t\t\tminPay = Math.min(minPay, ans[n][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(maxMAX_MCoin + \" \" + minPay);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,1,0,-1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic int idx;\n\tstatic char[][] str;\n\tstatic int lv;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint[] p = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[][] dpA = new int[n+1][100001];\n\t\t\tint[][] dpB = new int[n+1][100001];\n\t\t\tfor(int i = 0; i < dpA.length; i++) {\n\t\t\t\tArrays.fill(dpA[i], -1);\n\t\t\t\tArrays.fill(dpB[i], INF);\n\t\t\t}\n\t\t\tdpA[0][0] = 0;\n\t\t\tdpB[0][0] = 0;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = 0; j < dpA[i].length; j++) {\n\t\t\t\t\tif(dpA[i][j] == -1) continue;\n\t\t\t\t\t//not buy\n\t\t\t\t\tif(dpA[i+1][j] < dpA[i][j] || (dpA[i+1][j] == dpA[i][j] && dpB[i+1][j] > dpB[i][j])) {\n\t\t\t\t\t\tdpA[i+1][j] = dpA[i][j];\n\t\t\t\t\t\tdpB[i+1][j] = dpB[i][j];\n\t\t\t\t\t}\n\t\t\t\t\t//buy only 1k\n\t\t\t\t\tint o2 = (1000 - (p[i]%1000))%1000;\n\t\t\t\t\tif(dpA[i+1][j + o2] < dpA[i][j] || (dpA[i+1][j + o2] == dpA[i][j] && dpB[i+1][j + o2] > dpB[i][j] + p[i])) {\n\t\t\t\t\t\tdpA[i+1][j + o2] = dpA[i][j];\n\t\t\t\t\t\tdpB[i+1][j + o2] = dpB[i][j] + p[i];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//buy\n\t\t\t\t\to2 = (1000 - (p[i]%1000))%1000;\n\t\t\t\t\tint need = 500 - o2;\n\t\t\t\t\tif(j >= need) {\n\t\t\t\t\t\tint nex = j - need;\n\t\t\t\t\t\tif(dpA[i+1][nex] < dpA[i][j] + 1 || (dpA[i+1][nex] == dpA[i][j]+1 && dpB[i+1][nex] > dpB[i][j] + p[i])) {\n\t\t\t\t\t\t\tdpA[i+1][nex] = dpA[i][j] + 1;\n\t\t\t\t\t\t\tdpB[i+1][nex] = dpB[i][j] + p[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tint MAX = INF;\n\t\t\tfor(int i = 0; i < dpA[n].length; i++) {\n\t\t\t\tif(ans < dpA[n][i] || (ans == dpA[n][i] && MAX > dpB[n][i])) {\n\t\t\t\t\tans = dpA[n][i];\n\t\t\t\t\tMAX = dpB[n][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans + \" \" + MAX);\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\t\n\t\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal int MAX_M = 100 * 1000;\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tint[] p = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tp[i] = scan.nextInt();\n\t\t\t\n\t\t\tint[][] dp = new int[n + 1][MAX_M];\n\t\t\tint[][] ans = new int[n + 1][MAX_M];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < MAX_M; j++) {\n\t\t\t\t\tdp[i][j] = -1;\n\t\t\t\t\tans[i][j] = MAX_M;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp[0][0] = 0;\n\t\t\tans[0][0] = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t// 商品を買わない\n\t\t\t\tfor (int j = 0; j < MAX_M; j++) {\n\t\t\t\t\tdp[i + 1][j] = dp[i][j];\n\t\t\t\t\tans[i + 1][j] = ans[i][j];\n\t\t\t\t}\n\n\t\t\t\t// 商品を買う\n\t\t\t\tint change = (p[i] % 1000 == 0) ? 0 : (1000 - p[i] % 1000);\n\t\t\t\tfor (int j = 0; j < MAX_M; j++) {\n\t\t\t\t\tif (dp[i][j] == -1) continue;\n\n\t\t\t\t\tint get500Coin = j + change < 500 ? 0 : 1;\n\t\t\t\t\tint nextMoney = j + change - (500 * get500Coin);\n\t\t\t\t\tif (dp[i + 1][nextMoney] < dp[i][j] + get500Coin) {\n\t\t\t\t\t\tdp[i + 1][nextMoney] = dp[i][j] + get500Coin;\n\t\t\t\t\t\tans[i + 1][nextMoney] = ans[i][j] + p[i];\n\t\t\t\t\t} else if (dp[i + 1][nextMoney] == dp[i][j] + get500Coin) {\n\t\t\t\t\t\tans[i + 1][nextMoney] = Math.min(ans[i + 1][nextMoney], ans[i][j] + p[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint maxMAX_MCoin = 0;\n\t\t\tint minPay = 0;\n\t\t\tfor (int i = 0; i < MAX_M; i++) {\n\t\t\t\tif (maxMAX_MCoin < dp[n][i]) {\n\t\t\t\t\tmaxMAX_MCoin = dp[n][i];\n\t\t\t\t\tminPay = ans[n][i];\n\t\t\t\t} else if (maxMAX_MCoin == dp[n][i]) {\n\t\t\t\t\tminPay = Math.min(minPay, ans[n][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(maxMAX_MCoin + \" \" + minPay);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,1,0,-1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic int idx;\n\tstatic char[][] str;\n\tstatic int lv;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true){\n\t\tint N = sc.nextInt();\n\t\tif(N == 0) break;\n\t\tint[] p = new int[N];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tp[i] = sc.nextInt();\n\t\t}\n\t\tint[][][][][][] count = new int[N+1][6][3][6][3][6];\n\t\tint[][][][][][] sum   = new int[N+1][6][3][6][3][6];\n\t\tfor(int i = 0; i < count.length; i++) {\n\t\t\tfor(int j = 0; j < count[i].length; j++) {\n\t\t\t\tfor(int k = 0; k < count[i][j].length; k++) {\n\t\t\t\t\tfor(int l = 0; l < count[i][j][k].length; l++) {\n\t\t\t\t\t\tfor(int m = 0; m < count[i][j][k][l].length; m++) {\n\t\t\t\t\t\t\tArrays.fill(count[i][j][k][l][m], -1);\n\t\t\t\t\t\t\tArrays.fill(sum[i][j][k][l][m], INF);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcount[0][0][0][0][0][0] = 0;\n\t\tsum[0][0][0][0][0][0] = 0;\n\t\tfor(int i = 0; i < count.length-1; i++) {\n\t\t\tfor(int j = 0; j < count[i].length; j++) {\n\t\t\t\tfor(int k = 0; k < count[i][j].length; k++) {\n\t\t\t\t\tfor(int l = 0; l < count[i][j][k].length; l++) {\n\t\t\t\t\t\tfor(int m = 0; m < count[i][j][k][l].length; m++) {\n\t\t\t\t\t\t\tfor(int n = 0; n < count[i][j][k][l][m].length; n++) {\n\t\t\t\t\t\t\t\tif(count[i][j][k][l][m][n] == -1) continue;\n\t\t\t\t\t\t\t\tif(count[i+1][j][k][l][m][n] < count[i][j][k][l][m][n] || (count[i+1][j][k][l][m][n] == count[i][j][k][l][m][n] && sum[i+1][j][k][l][m][n] > sum[i][j][k][l][m][n]) || count[i+1][j][k][l][m][n] == -1) {\n\t\t\t\t\t\t\t\t\tcount[i+1][j][k][l][m][n] = count[i][j][k][l][m][n];\n\t\t\t\t\t\t\t\t\tsum[i+1][j][k][l][m][n] = sum[i][j][k][l][m][n];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tIN100:for(int use100 = 0; use100 <= j; use100++) {\n\t\t\t\t\t\t\t\t\tIN50:for(int use50 = 0; use50 <= k; use50++) {\n\t\t\t\t\t\t\t\t\t\tIN10:for(int use10 = 0; use10 <= l; use10++) {\n\t\t\t\t\t\t\t\t\t\t\tIN5:for(int use5 = 0; use5 <= m; use5++) {\n\t\t\t\t\t\t\t\t\t\t\t\tIN1:for(int use1 = 0; use1 <= n; use1++) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tint tmp = use100 * 100 + use50 * 50 + use10 * 10 + use5 * 5 + use1;\n\t\t\t\t\t\t\t\t\t\t\t\t\twhile(p[i] > tmp) tmp += 1000;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint[] o2 = check(tmp - p[i]);\n\t\t\t\t\t\t\t\t\t\t\t\t\tint n500 = count[i][j][k][l][m][n] + o2[1];\n\t\t\t\t\t\t\t\t\t\t\t\t\tint n100 = o2[2] + j - use100;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint n50  = o2[3] + k - use50;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint n10  = o2[4] + l - use10;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint n5   = o2[5] + m - use5;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint n1   = o2[6] + n - use1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(n100 >= 6) continue IN100;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(n50  >= 3) continue IN50;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(n10 >= 6) continue IN10;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(n5  >= 3) continue IN5;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(n1  >= 6) continue IN1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(count[i+1][n100][n50][n10][n5][n1] < n500 || (count[i+1][n100][n50][n10][n5][n1] == n500 && sum[i+1][n100][n50][n10][n5][n1] > sum[i][j][k][l][m][n] + p[i]) || count[i+1][n100][n50][n10][n5][n1] == -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount[i+1][n100][n50][n10][n5][n1] = n500;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsum[i+1][n100][n50][n10][n5][n1] = sum[i][j][k][l][m][n] + p[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\tint su = INF;\n\t\tfor(int j = 0; j < count[N].length; j++) {\n\t\t\tfor(int k = 0; k < count[N][j].length; k++) {\n\t\t\t\tfor(int l = 0; l < count[N][j][k].length; l++) {\n\t\t\t\t\tfor(int m = 0; m < count[N][j][k][l].length; m++) {\n\t\t\t\t\t\tfor(int n = 0; n < count[N][j][k][l][m].length; n++) {\n\t\t\t\t\t\t\tif(ans < count[N][j][k][l][m][n] || (ans == count[N][j][k][l][m][n] && su > sum[N][j][k][l][m][n])) {\n\t\t\t\t\t\t\t\tans = count[N][j][k][l][m][n];\n\t\t\t\t\t\t\t\tsu  = sum[N][j][k][l][m][n];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans + \" \" + su);\n\t}\n\t}\n\tstatic int[] check(int a) {\n\t\tint[] o2 = new int[7];\n\t\twhile(a >= 1000) {\n\t\t\to2[0]++;\n\t\t\ta -= 1000;\n\t\t}\n\t\twhile(a >= 500) {\n\t\t\to2[1]++;\n\t\t\ta -= 500;\n\t\t}\n\t\twhile(a >= 100) {\n\t\t\to2[2]++;\n\t\t\ta -= 100;\n\t\t}\n\t\twhile(a >= 50) {\n\t\t\to2[3]++;\n\t\t\ta -= 50;\n\t\t}\n\t\twhile(a >= 10) {\n\t\t\to2[4]++;\n\t\t\ta -= 10;\n\t\t}\n\t\twhile(a >= 5) {\n\t\t\to2[5]++;\n\t\t\ta -= 5;\n\t\t}\n\t\twhile(a >= 1) {\n\t\t\to2[6]++;\n\t\t\ta -= 1;\n\t\t}\n\t\treturn o2;\n\t}\n\t\t\n\t\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = input()\n    if n == 0:\n        break\n    dp = [[None]*2001 for i in xrange(n+1)]\n    dp[0][0] = (0, 0)\n    for i in xrange(n):\n        cost = int(raw_input())\n        dost = cost % 1000\n        for j in xrange(2001):\n            if dp[i][j] is None:\n                continue\n            c, s = dp[i][j]\n            dp[i+1][j] = max(dp[i][j], dp[i+1][j])\n            if dost == 0:\n                if j >= 500:\n                    dp[i+1][j - 500] = max(dp[i+1][j - 500], (c+1, s-cost))\n                else:\n                    dp[i+1][j] = max(dp[i+1][j], (c, s-cost))\n            elif 1 <= dost <= 500+j:\n                dp[i+1][j + (500 - dost)] = max(dp[i+1][j + (500 - dost)], (c+1, s-cost))\n            else:\n                dp[i+1][j + (1000 - dost)] = max(dp[i+1][j + (1000 - dost)], (c, s-cost))\n    c, s = max(dp[n])\n    print c, -s"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = input()\n    if n == 0:\n        break\n    dp = [[None]*1000 for i in xrange(n+1)]\n    dp[0][0] = (0, 0)\n    for i in xrange(n):\n        cost = int(raw_input())\n        for j in xrange(1000):\n            if dp[i][j] is None:\n                continue\n            dp[i+1][j] = max(dp[i][j], dp[i+1][j])\n            c, s = dp[i][j]\n            if cost <= 500:\n                s -= cost\n                dp[i+1][(-s) % 1000] = max(dp[i+1][(-s) % 1000], (c, s))\n                dp[i+1][(-s+500) % 1000] = max(dp[i+1][(-s+500) % 1000], (c+1, s-500))\n            else:\n                s -= cost\n                dp[i+1][(-s) % 1000] = max(dp[i+1][(-s) % 1000], (c, s))\n                if 1 <= (-s) % 1000 <= 500:\n                    dp[i+1][(-s+500) % 1000] = max(dp[i+1][(-s+500) % 1000], (c+1, s-500))\n    c, s = max(dp[n])\n    print c, -s-500*c"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = input()\n    if n == 0:\n        break\n    dp = [[None]*10001 for i in xrange(n+1)]\n    dp[0][0] = (0, 0)\n    for i in xrange(n):\n        cost = int(raw_input())\n        dost = cost % 1000\n        for j in xrange(10001):\n            if dp[i][j] is None:\n                continue\n            c, s = dp[i][j]\n            dp[i+1][j] = max(dp[i][j], dp[i+1][j])\n            if dost == 0:\n                if j >= 500:\n                    dp[i+1][j - 500] = max(dp[i+1][j - 500], (c+1, s-cost))\n                else:\n                    dp[i+1][j] = max(dp[i+1][j], (c, s-cost))\n            elif 1 <= dost <= 500+j:\n                dp[i+1][j + (500 - dost)] = max(dp[i+1][j + (500 - dost)], (c+1, s-cost))\n            else:\n                dp[i+1][j + (1000 - dost)] = max(dp[i+1][j + (1000 - dost)], (c, s-cost))\n    c, s = max(dp[n])\n    print c, -s"
  },
  {
    "language": "Python",
    "code": "from operator import itemgetter\n\ndef compare(state1, state2):\n    if state1 == None:\n        return False\n    if state2 == None:\n        return True\n    return state1[0] > state2[0] or (state1[0] == state2[0] and state1[1] < state2[1])\n\ndef compute(prices, max_sum_having_coin):\n    \"\"\"\n    DP\n    t?????????????????????????????????????????????????????£???????????????t??¨?????¶???\n    ????????§??????????????\\???????????????\n    ??????t???????????????500?????????????????°???ct???????????\\????????¬??¨???????¨????st??§?????????????????????????????????????????§\n    ???????????§???????????£????????????????°?????????????????????¨??????????????????????????????????????????i(i < t)??§???\n    500?????????????????°???ci, ????????\\????????¬??¨???????¨????si??§????????¨????????¨??????????????§???????????£????????????????????¶?????¨???????????????????????§????°???§?????????\n    ??????????°?????????????????????????????????¨?????????????????????t??????????????????????°?????????????????????????????????¨???????????¨??????????????????\n    \"\"\"\n    n = len(prices)\n    m = max_sum_having_coin\n    # table[i][j] = ??????i???????????¬??¨j???????????? (500??????????????§???, 500??????????????§?????¨????????¨??????????????£????????????????°????)\n    table = []\n    for i in range(n + 1):\n        table.append([None] * (m + 1))\n    table[0][0] = (0, 0)\n    for i in range(1, n + 1):\n        price = prices[i - 1]\n        for j in range(0, m + 1):\n            state = None\n            # ?????\\???500?????????????????\\???????????¨???\n            if price % 1000 != 0 and j >= 500 - price % 500:\n                temp = table[i - 1][j - (500 - price % 500)]\n                if temp != None:\n                    temp = (temp[0], temp[1] + price)\n                    if compare(temp, state):\n                        state = temp\n            # ?????\\???????????¨???\n            temp = table[i - 1][j]\n            if temp != None and compare(temp, state):\n                state = temp\n            # ?????\\???500?????????????????\\????????¨???\n            if price % 1000 == 0:\n                if j + 500 <= m:\n                    temp = table[i - 1][j + 500]\n                    if temp != None:\n                        temp = (temp[0] + 1, temp[1] + price)\n                        if compare(temp, state):\n                            state = temp\n            elif price % 1000 <= 500:\n                temp = table[i - 1][j - (500 - price % 500)]\n                if temp != None:\n                    temp = (temp[0] + 1, temp[1] + price)\n                    if compare(temp, state):\n                        state = temp\n            elif j + price % 500 <= m:\n                temp = table[i - 1][j + price % 500]\n                if temp != None:\n                    temp = (temp[0] + 1, temp[1] + price)\n                    if compare(temp, state):\n                        state = temp\n            if state != None:\n                table[i][j] = state\n    max_state = None\n    for j in range(0, m + 1):\n        state = table[n][j]\n        if state == None:\n            continue\n        if compare(state, max_state):\n            max_state = state\n    return max_state\n\n# results = []\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    prices = []\n    for i in range(n):\n        prices.append(int(input()))\n    # ???????????????????????????500????????\\????????????????????????????¨??????????500??????????¢?????????????\n    # ????????°????????????n????????§?????????????????????????¨????????????? 500 * n ??§??????\n    # max_sum_having_coin = 500 * n\n    max_sum_having_coin = 10000\n    result = compute(prices, max_sum_having_coin)\n    # results.append(result)\n    print(result[0], result[1])\n\n# for r in results:\n#     print(r)"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = input()\n    if n == 0:\n        break\n    L = 500*n\n    dp = [None]*(L+1)\n    dp[0] = (0, 0)\n    for i in xrange(n):\n        dp2 = dp[:]\n        cost = int(raw_input())\n        d3 = cost % 1000\n        for j in xrange(L+1):\n            if dp[j] is None:\n                continue\n            num, su = dp[j]\n            if d3 == 0:\n                if 500 <= j:\n                    dp2[j - 500] = max(dp2[j - 500], (num+1, su-cost))\n            elif 1 <= d3 <= 500+j:\n                dp2[j + (500 - d3)] = max(dp2[j + (500 - d3)], (num+1, su-cost))\n            else:\n                dp2[j + (1000 - d3)] = max(dp2[j + (1000 - d3)], (num, su-cost))\n        dp, dp2 = dp2, dp\n    num, su = max(dp)\n    print num, -su"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = input()\n    if n == 0:\n        break\n    dp = [[None]*2001 for i in xrange(n+1)]\n    dp[0][0] = (0, 0)\n    for i in xrange(n):\n        cost = int(raw_input())\n        dost = cost % 1000\n        for j in xrange(2001):\n            if dp[i][j] is None:\n                continue\n            c, s = dp[i][j]\n            dp[i+1][j] = max(dp[i][j], dp[i+1][j])\n            if dost == 0:\n                if j >= 500:\n                    dp[i+1][j + (500 - dost)] = max(dp[i+1][j + (500 - dost)], (c+1, s-cost))\n                else:\n                    dp[i+1][j] = max(dp[i+1][j], (c, s-cost))\n            elif 1 <= dost <= 500+j:\n                dp[i+1][j + (500 - dost)] = max(dp[i+1][j + (500 - dost)], (c+1, s-cost))\n            else:\n                dp[i+1][j + (1000 - dost)] = max(dp[i+1][j + (1000 - dost)], (c, s-cost))\n    c, s = max(dp[n])\n    print c, -s"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+9\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n):\n        a = [I() for _ in range(n)]\n        t = [(0,0,0)]\n        for c in a:\n            nt = collections.defaultdict(lambda: inf)\n            c1 = c % 1000\n            c5 = c % 500\n            mc5 = 500 - c5\n            for g,k,p in t:\n                nt[(g,k)] = p\n            if c1 == 0:\n                for g,k,p in t:\n                    if k >= 500 and nt[(g+1,k-500)] > p + c:\n                        nt[(g+1,k-500)] = p + c\n            elif c1 == 500:\n                for g,k,p in t:\n                    if nt[(g+1, k)] > p + c:\n                        nt[(g+1, k)] = p + c\n            elif c1 < 500:\n                for g,k,p in t:\n                    if nt[(g+1, k+mc5)] > p + c:\n                        nt[(g+1, k+mc5)] = p + c\n            else:\n                for g,k,p in t:\n                    if k + mc5 >= 500 and nt[(g+1,k+mc5-500)] > p + c:\n                        nt[(g+1,k+mc5-500)] = p + c\n                    if nt[(g, k+mc5)] > p + c:\n                        nt[(g, k+mc5)] = p + c\n            t = []\n            cg = -1\n            mk = -1\n            mp = inf\n            # print('nt',nt)\n            for g,k in sorted(nt.keys(), reverse=True):\n                p = nt[(g,k)]\n                if p == inf:\n                    continue\n                if cg != g:\n                    mp = inf\n                    cg = g\n                if mk < k or mp > p:\n                    t.append((g,k,p))\n                    if mk < k:\n                        mk = k\n                    if mp > p:\n                        mp = p\n            # print(len(t))\n        r = 0\n        rp = inf\n        for g,k,p in t:\n            if r < g or (r==g and rp > p):\n                r = g\n                rp = p\n        return '{} {}'.format(r, rp)\n\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nwhile(N != 0):\n    coin = [-1 for _ in range(50000)]\n    coin[0] = 0\n    minprice = [0 for i in range(50000)]\n    for i in range(N):\n        price = int(input())\n        charge = (1000 - (price % 1000)) % 1000\n        coin_tmp = coin[:]\n        minprice_tmp = minprice[:]\n        for state in range(50000):\n            if(coin[state] != -1):\n                #print(\"#\", state, coin[state])\n                getcoin = (charge+state) // 500\n                newstate = max((charge+state) % 500, (charge+state) - 500)\n                if(getcoin == 0):\n                    if(coin[newstate] == -1):  # ??°??¶???\n                        coin_tmp[newstate] = coin[state]\n                        minprice_tmp[newstate] = minprice[state] + price\n                    else:\n                        minprice_tmp[newstate] = min(minprice[newstate], minprice[state] + price)\n                else:\n                    if(coin[newstate] < coin[state] + 1):\n                        coin_tmp[newstate] = coin[state] + 1\n                        minprice_tmp[newstate] = minprice[state] + price\n                    elif(coin[newstate] == coin[state] + 1):\n                        minprice_tmp[newstate] = min(minprice[newstate], minprice[state] + price)\n        coin = coin_tmp[:]\n        minprice = minprice_tmp[:]\n\n    coin_ans = -1\n    coin_ans_price = []\n    for i in range(50000):\n        if(coin_ans < coin[i]):\n            coin_ans = coin[i]\n            coin_ans_price = [minprice[i]]\n        elif(coin_ans == coin[i]):\n            coin_ans_price.append(minprice[i])\n    print(coin_ans, min(coin_ans_price))\n    N = int(input())"
  },
  {
    "language": "Python",
    "code": "import sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\nMAX_COINS = 500 * 100\nINF = 10 ** 9\n\n\ndef dfs(idx, coins):\n    if idx == N:\n        return 0, 0\n    elif dp[idx][coins] != -1:\n        return dp[idx][coins]\n\n    ret = (0, -INF)\n\n    # not buy\n    ret = max(ret, dfs(idx + 1, coins))\n\n    # buy using only bills\n    change = (1000 - P[idx] % 1000) % 1000\n    cand, money = dfs(idx + 1, coins + change % 500)\n    ret = max(ret, (cand + (change >= 500), money - P[idx]))\n\n    # buy using both and get 500\n    if (P[idx] + 500) % 1000 <= coins:\n        cand, money = dfs(idx + 1, coins - (P[idx] + 500) % 1000)\n        ret = max(ret, (cand + 1, money - P[idx]))\n    dp[idx][coins] = ret\n    # print(idx, coins, ret)\n    return ret\n\n\nwhile True:\n    N = int(input())\n    if not N:\n        break\n    P = [int(input()) for _ in range(N)]\n\n    dp = [[-1] * (MAX_COINS + 1) for _ in range(N + 1)]\n    ans, money = dfs(0, 0)\n    print(ans, -money)"
  },
  {
    "language": "Python",
    "code": "import sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\nsys.setrecursionlimit(10 ** 6)\nMAX_COINS = 500 * 100\nINF = 10 ** 9\n\n\ndef dfs(idx, coins):\n    if idx == N:\n        return 0, 0\n    elif dp[idx][coins] != -1:\n        return dp[idx][coins]\n\n    ret = (0, -INF)\n\n    # not buy\n    ret = max(ret, dfs(idx + 1, coins))\n\n    # buy using only bills\n    change = (1000 - P[idx] % 1000) % 1000\n    cand, money = dfs(idx + 1, coins + change % 500)\n    ret = max(ret, (cand + (change >= 500), money - P[idx]))\n\n    # buy using both and get 500\n    if (P[idx] + 500) % 1000 <= coins:\n        cand, money = dfs(idx + 1, coins - (P[idx] + 500) % 1000)\n        ret = max(ret, (cand + 1, money - P[idx]))\n    dp[idx][coins] = ret\n    # print(idx, coins, ret)\n    return ret\n\n\nwhile True:\n    N = int(input())\n    if not N:\n        break\n    P = [int(input()) for _ in range(N)]\n\n    dp = [[-1] * (MAX_COINS + 1) for _ in range(N + 1)]\n    ans, money = dfs(0, 0)\n    print(ans, -money)"
  },
  {
    "language": "Python",
    "code": "\ndef compute_max_num_500_coins(prices):\n    num_500_coins = 0\n    coin = 0\n    possible_thousand_coin_prices = []\n    for p in prices:\n        if p % 1000 == 0:\n            if coin >= 500:\n                possible_thousand_coin_prices.append(p)\n        elif p % 1000 <= 500:\n            num_500_coins += 1\n            coin += 500 - p % 500\n        elif p % 500 <= coin:\n            num_500_coins += 1\n            coin -= p % 500\n        else:\n            coin += 500 - p % 500\n\n    thousand_coin_price = 0\n    if len(possible_thousand_coin_prices) > 0 and coin >= 500:\n        thousand_coin_price = min(possible_thousand_coin_prices)\n        num_500_coins += 1\n        coin -= 500\n    return num_500_coins, coin, thousand_coin_price\n\ndef find_unneeded_prices(prices, remaining_coin):\n    table = []\n    for i in range(len(prices) + 1):\n        table.append([0] * (remaining_coin + 1))\n    for i in range(1, len(prices) + 1):\n        p = prices[i - 1]\n        prev_row = table[i - 1]\n        row = table[i]\n        for j in range(remaining_coin + 1):\n            r = 500 - p % 500\n            if j < r:\n                row[j] = prev_row[j]\n            else:\n                row[j] = max(prev_row[j], prev_row[j - r] + p)\n    i = len(prices)\n    j = remaining_coin\n    unneeded_prices = []\n    while i > 0 and j > 0:\n        if table[i][j] > table[i - 1][j]:\n            j -= (500 - prices[i - 1] % 500)\n            unneeded_prices.append(prices[i - 1])\n        i -= 1\n    return unneeded_prices\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    prices = []\n    for i in range(n):\n        prices.append(int(input()))\n    no_thousand_prices = [p for p in prices if p % 1000 != 0]\n    max_num_500_coins, remaining_coin, thousand_coin_price = compute_max_num_500_coins(prices)\n    target_prices = [p for p in prices if p % 1000 > 500]\n    unneeded_prices = find_unneeded_prices(target_prices, remaining_coin)\n    expense = sum(no_thousand_prices) - sum(unneeded_prices) + thousand_coin_price\n    print(max_num_500_coins, expense)"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = input()\n    if n == 0:\n        break\n    dp = [[None]*100001 for i in xrange(n+1)]\n    dp[0][0] = (0, 0)\n    for i in xrange(n):\n        cost = int(raw_input())\n        dost = cost % 1000\n        for j in xrange(100001):\n            if dp[i][j] is None:\n                continue\n            c, s = dp[i][j]\n            dp[i+1][j] = max(dp[i][j], dp[i+1][j])\n            if dost == 0:\n                if j >= 500:\n                    dp[i+1][j - 500] = max(dp[i+1][j - 500], (c+1, s-cost))\n                else:\n                    dp[i+1][j] = max(dp[i+1][j], (c, s-cost))\n            elif 1 <= dost <= 500+j:\n                dp[i+1][j + (500 - dost)] = max(dp[i+1][j + (500 - dost)], (c+1, s-cost))\n            else:\n                dp[i+1][j + (1000 - dost)] = max(dp[i+1][j + (1000 - dost)], (c, s-cost))\n    c, s = max(dp[n])\n    print c, -s"
  },
  {
    "language": "Python",
    "code": "MAX_COINS = 500 * 100\nINF = 10 ** 9\n\n\ndef dfs(idx, coins):\n    if idx == N:\n        return 0, 0\n    elif dp[idx][coins] != -1:\n        return dp[idx][coins]\n\n    ret = (0, -INF)\n\n    # not buy\n    ret = max(ret, dfs(idx + 1, coins))\n\n    # buy using only bills\n    change = (1000 - P[idx] % 1000) % 1000\n    cand, money = dfs(idx + 1, coins + change % 500)\n    ret = max(ret, (cand + (change >= 500), money - P[idx]))\n\n    # buy using both and get 500\n    if (P[idx] + 500) % 1000 <= coins:\n        cand, money = dfs(idx + 1, coins - (P[idx] + 500) % 1000)\n        ret = max(ret, (cand + 1, money - P[idx]))\n    dp[idx][coins] = ret\n    # print(idx, coins, ret)\n    return ret\n\n\nwhile True:\n    N = int(input())\n    if not N:\n        break\n    P = [int(input()) for _ in range(N)]\n\n    dp = [[-1] * (MAX_COINS + 1) for _ in range(N + 1)]\n    ans, money = dfs(0, 0)\n    print(ans, -money)"
  },
  {
    "language": "Python",
    "code": "import sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\nsys.setrecursionlimit(10 ** 6)\nMAX_COINS = 500 * 100\nINF = 10 ** 9\n\n\ndef dfs(idx, coins):\n    if idx == N:\n        return 0, 0\n    elif dp[idx][coins] != -1:\n        return dp[idx][coins]\n\n    ret = (0, -INF)\n\n    # not buy\n    ret = max(ret, dfs(idx + 1, coins))\n\n    # buy using only bills\n    change = (1000 - P[idx] % 1000) % 1000\n    cand, money = dfs(idx + 1, coins + change % 500)\n    ret = max(ret, (cand + (change >= 500), money - P[idx]))\n\n    # buy using both and get 500\n    if (P[idx] + 500) % 1000 <= coins:\n        cand, money = dfs(idx + 1, coins - (P[idx] + 500) % 1000)\n        ret = max(ret, (cand + 1, money - P[idx]))\n    dp[idx][coins] = ret\n    # print(idx, coins, ret)\n    return ret\n\n\nwhile True:\n    N = int(input())\n    if not N:\n        break\n    P = [int(input()) for _ in range(N)]\n\n    dp = [[-1] * (MAX_COINS + 1) for _ in range(N + 1)]\n    ans, money = dfs(0, 0)\n    print(ans, -money)"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = input()\n    if n == 0:\n        break\n    dp = [[None]*1000 for i in xrange(n+1)]\n    dp[0][0] = (0, 0)\n    for i in xrange(n):\n        cost = int(raw_input())\n        for j in xrange(1000):\n            if dp[i][j] is None:\n                continue\n            dp[i+1][j] = max(dp[i][j], dp[i+1][j])\n            c, s = dp[i][j]\n            if cost <= 500 or 1 <= cost % 1000 <= 500:\n                s -= cost\n                dp[i+1][(-s) % 1000] = max(dp[i+1][(-s) % 1000], (c, s))\n                dp[i+1][(-s+500) % 1000] = max(dp[i+1][(-s+500) % 1000], (c+1, s-500))\n            else:\n                s -= cost\n                dp[i+1][(-s) % 1000] = max(dp[i+1][(-s) % 1000], (c, s))\n                if 1 <= (-s) % 1000 <= 500:\n                    dp[i+1][(-s+500) % 1000] = max(dp[i+1][(-s+500) % 1000], (c+1, s-500))\n    c, s = max(dp[n])\n    print c, -s-500*c"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nfrom operator import itemgetter\n\ndef buy(p, cr):\n    cnt, rem = cr\n    r1000 = p % 1000\n    r500 = p % 500\n    m500 = 500 - r500\n    m1000 = 1000 - r1000\n    if r1000 == 0:\n        if rem < 500:\n            return ((cnt, rem),)\n        else:\n            return ((cnt+1, rem-500),)\n    elif r1000 == 500:\n        return ((cnt+1, rem),)\n    elif r1000 < 500:\n        return ((cnt+1, rem + m500), (cnt, rem + m1000))\n    else:\n        if rem - r500 >= 0:\n            return ((cnt+1, rem - r500),)\n        else:\n            return ((cnt, rem + m500),)\n\nINF = 10**20\n\ndef solve(plist):\n    dp = {\n        (0, 0): 0\n    }\n    for p in plist:\n        ndp = {}\n        for cr in list(dp.keys()):\n            for ncr in buy(p, cr):\n                ndp[ncr] = min(dp[cr] + p, dp.get(ncr, INF))\n\n        dp.update(ndp)\n        ndp = {}\n        cc = -1\n        mp = INF\n        for c, r in sorted(dp.keys(), reverse=True):\n            pp = dp[(c, r)]\n            if cc != c:\n                mp = INF\n                cc = c\n            if mp > pp:\n                ndp[(c, r)] = pp\n                mp = pp\n        dp = ndp\n\n    cplist = ((t[0][0], t[1]) for t in dp.items())\n    return sorted(sorted(cplist, key=itemgetter(1)),\n                  key=itemgetter(0), reverse=True)[0]\n\ndef main():\n    while True:\n        n = int(input().strip())\n        if n == 0:\n            break\n        plist = [int(input().strip()) for _ in range(n)]\n        print(\" \".join(str(i) for i in solve(plist)))\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from operator import itemgetter\n\ndef compute(prices, max_sum_having_coin):\n    \"\"\"\n    DP\n    t?????????????????????????????????????????????????????£???????????????t??¨?????¶???\n    ????????§??????????????\\???????????????\n    ??????t???????????????500?????????????????°???ct???????????\\????????¬??¨???????¨????st??§?????????????????????????????????????????§\n    ???????????§???????????£????????????????°?????????????????????¨??????????????????????????????????????????i(i < t)??§???\n    500?????????????????°???ci, ????????\\????????¬??¨???????¨????si??§????????¨????????¨??????????????§???????????£????????????????????¶?????¨???????????????????????§????°???§?????????\n    ??????????°?????????????????????????????????¨?????????????????????t??????????????????????°?????????????????????????????????¨???????????¨??????????????????\n    \"\"\"\n    n = len(prices)\n    m = max_sum_having_coin\n    # table[i][j] = ??????i???????????¬??¨j???????????? (500??????????????§???, 500??????????????§?????¨????????¨??????????????£????????????????°????)\n    table = []\n    for i in range(n + 1):\n        table.append([None] * (m + 1))\n    table[0][0] = (0, 0)\n    for i in range(1, n + 1):\n        for j in range(0, m + 1):\n            price = prices[i - 1]\n            states = []\n            # ?????\\???500?????????????????\\???????????¨???\n            if price % 1000 != 0 and j >= 500 - price % 500:\n                temp = table[i - 1][j - (500 - price % 500)]\n                if temp != None:\n                    states.append((temp[0], temp[1] + price))\n            # ?????\\???????????¨???\n            temp = table[i - 1][j]\n            if temp != None:\n                states.append(temp)\n            # ?????\\???500?????????????????\\????????¨???\n            if price % 1000 == 0:\n                if j + 500 <= m:\n                    temp = table[i - 1][j + 500]\n                    if temp != None:\n                        states.append((temp[0] + 1, temp[1] + price))\n            elif price % 1000 <= 500:\n                temp = table[i - 1][j - (500 - price % 500)]\n                if temp != None:\n                    states.append((temp[0] + 1, temp[1] + price))\n            elif j + price % 500 <= m:\n                temp = table[i - 1][j + price % 500]\n                if temp != None:\n                    states.append((temp[0] + 1, temp[1] + price))\n            if len(states) > 0:\n                states.sort(key=itemgetter(1))\n                states.sort(key=itemgetter(0), reverse=True)\n                table[i][j] = states[0]\n    max_state = None\n    for j in range(0, m + 1):\n        state = table[n][j]\n        if state == None:\n            continue\n        if max_state == None or state[0] > max_state[0] or (state[0] == max_state[0] and state[1] < max_state[1]):\n            max_state = state\n    return max_state\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    prices = []\n    for i in range(n):\n        prices.append(int(input()))\n    # ???????????????????????????500????????\\????????????????????????????¨??????????500??????????¢?????????????\n    # ????????°????????????n????????§?????????????????????????¨????????????? 500 * n ??§??????\n    max_sum_having_coin = 500 * n\n    result = compute(prices, max_sum_having_coin)\n    print(result[0], result[1])"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef main(n):\n    m = n * 499 + 1\n    dp =  defaultdict(list)\n    dp[0] = [0, 0]\n    for _ in range(n):\n        ndp = defaultdict(lambda:[-1,-1])\n        for key, value in dp.items():\n            ndp[key] = value[:]\n        p = int(input())\n        a = -p % 1000\n        if a >= 500:\n            b = a - 500\n            for j in dp.keys():\n                if dp[j][0] < 0: continue\n                tmp = ndp[j + b]\n                if tmp[0] < dp[j][0] + 1:\n                    tmp[0] = dp[j][0] + 1\n                    tmp[1] = dp[j][1] + p\n                elif tmp[0] == dp[j][0] + 1 and tmp[1] > dp[j][1] + p:\n                    tmp[0] = dp[j][0] + 1\n                    tmp[1] = dp[j][1] + p\n        else:\n            b = 500 - a % 500\n            for j in dp.keys():\n                if dp[j][0] < 0: continue\n                tmp = ndp[j + a]\n                if tmp[0] < dp[j][0]:\n                    tmp[0] = dp[j][0]\n                    tmp[1] = dp[j][1] + p\n                elif tmp[0] == dp[j][0] and tmp[1] > dp[j][1] + p:\n                    tmp[1] = dp[j][1] + p\n                if j - b >= 0:\n                    tmp = ndp[j - b]\n                    if tmp[0] < dp[j][0] + 1:\n                        tmp[0] = dp[j][0] + 1\n                        tmp[1] = dp[j][1] + p\n                    elif tmp[0] == dp[j][0] + 1 and tmp[1] > dp[j][1] + p:\n                        tmp[1] = dp[j][1] + p\n        dp = ndp\n    ans = [0, 0]\n    for n, c in dp.values():\n        if n > ans[0]:\n            ans = [n, c]\n        elif n == ans[0] and c < ans[1]:\n            ans = [n, c]\n    print(*ans)\n\nif __name__ == \"__main__\":\n    while 1:\n        n = int(input())\n        if n:\n            main(n)\n        else:\n            break\n\n"
  },
  {
    "language": "Rust",
    "code": "#[derive(Hash, Clone, Default, Eq, PartialEq)]\nstruct State {\n    one: usize,\n    five: usize,\n    ten: usize,\n    fifty: usize,\n    handred: usize,\n}\n\nuse std::cmp::{max, min};\nuse std::collections::HashMap;\nfn main() {\n    let stdin = std::io::stdin();\n    let mut sc = Scanner::new(stdin.lock());\n    loop {\n        let n = sc.read::<usize>();\n        if n == 0 {\n            break;\n        }\n        let ps: Vec<usize> = sc.read_vec(n);\n        let mut dp = vec![(0, isize::min_value()); 1000 * 101 + 1];\n        dp[0] = (0, 0);\n        // 100, 500 * 100\n        for p in ps {\n            let mut ndp = dp.clone();\n            for have in 0..1000 * 101 + 1 {\n                let (max_500, spent) = dp[have];\n                if spent == isize::min_value() {\n                    continue;\n                }\n                let spent = (-spent) as usize;\n                // Get 500\n                let next_spent = spent + p;\n                let pb = p % 1000;\n                let rest = (1000 - pb) % 1000;\n                let need = if rest < 500 { 500 - rest } else { 0 };\n                let add = if rest < 500 { 0 } else { rest - 500 };\n                if need > have {\n                    continue;\n                }\n                let next_have = have - need + add;\n                let next_500 = max_500 + 1;\n                ndp[next_have] = max(ndp[next_have], (next_500, -(next_spent as isize)));\n            }\n            for have in 0..1000 * 101 + 1 {\n                let (max_500, spent) = dp[have];\n                if spent == isize::min_value() {\n                    continue;\n                }\n                let spent = (-spent) as usize;\n                // No 500\n                let next_spent = spent + p;\n                let pb = p % 1000;\n                let rest = (1000 - pb) % 1000;\n                let next_have = have + rest;\n                let next_500 = max_500;\n                ndp[next_have] = max(ndp[next_have], (next_500, -(next_spent as isize)));\n            }\n            dp = ndp;\n        }\n        let mut answer = (0, isize::min_value());\n        for have in 0..1000 * 101 + 1 {\n            let (max_500, spent) = dp[have];\n            if spent == isize::min_value() {\n                continue;\n            }\n            let spent = (-spent) as usize;\n            let cand = (max_500, -(spent as isize));\n            if answer < cand {\n                answer = cand;\n            }\n        }\n        println!(\"{} {}\", answer.0, -answer.1);\n    }\n}\n\npub struct Scanner<R> {\n    reader: R,\n}\n\nimpl<R> Scanner<R> {\n    pub fn new(reader: R) -> Scanner<R> {\n        Scanner { reader }\n    }\n}\n\nfn is_whitespace(b: u8) -> bool {\n    b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t'\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        let buf = std::io::Read::bytes(self.reader.by_ref())\n            .map(|b| b.expect(\"Read failed\"))\n            .skip_while(|&b| is_whitespace(b))\n            .take_while(|&b| !is_whitespace(b))\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error\")\n    }\n\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n\n    pub fn read_chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n\n"
  }
]