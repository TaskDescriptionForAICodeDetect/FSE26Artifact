[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\ntypedef struct {\n    double x1, y1, x2, y2, h;\n} Block;\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble min(double a, double b) {\n    return a < b ? a : b;\n}\n\ndouble distanceToSegment(Point p, Point a, Point b) {\n    double A = p.x - a.x;\n    double B = p.y - a.y;\n    double C = b.x - a.x;\n    double D = b.y - a.y;\n\n    double dot = A * C + B * D;\n    double len_sq = C * C + D * D;\n    double param = -1;\n    if (len_sq != 0)\n        param = dot / len_sq;\n\n    double xx, yy;\n\n    if (param < 0) {\n        xx = a.x;\n        yy = a.y;\n    } else if (param > 1) {\n        xx = b.x;\n        yy = b.y;\n    } else {\n        xx = a.x + param * C;\n        yy = a.y + param * D;\n    }\n\n    double dx = p.x - xx;\n    double dy = p.y - yy;\n    return sqrt(dx * dx + dy * dy);\n}\n\ndouble pointToLineDistance(Point p, Point a, Point b) {\n    double A = p.x - a.x;\n    double B = p.y - a.y;\n    double C = b.x - a.x;\n    double D = b.y - a.y;\n\n    double cross = A * D - B * C;\n    double len = sqrt(C * C + D * D);\n    return fabs(cross) / len;\n}\n\ndouble maxBallRadius(Point start, Point end, Block blocks[], int n) {\n    double minRadius = DBL_MAX;\n    double courseLength = sqrt((end.x - start.x) * (end.x - start.x) + (end.y - start.y) * (end.y - start.y));\n\n    for (int i = 0; i < n; i++) {\n        Block block = blocks[i];\n        Point blockCorners[4] = {\n            {block.x1, block.y1},\n            {block.x1, block.y2},\n            {block.x2, block.y2},\n            {block.x2, block.y1}\n        };\n\n        double minDist = DBL_MAX;\n        for (int j = 0; j < 4; j++) {\n            Point a = blockCorners[j];\n            Point b = blockCorners[(j + 1) % 4];\n            double dist = distanceToSegment(start, a, b);\n            if (dist < minDist) {\n                minDist = dist;\n            }\n        }\n\n        double lineDist = pointToLineDistance((Point){block.x1, block.y1}, start, end);\n        double height = block.h;\n        double radius = min(minDist, height);\n\n        if (radius < minRadius) {\n            minRadius = radius;\n        }\n    }\n\n    return minRadius;\n}\n\nint main() {\n    int dataset = 1;\n    int n;\n    Point start, end;\n\n    while (scanf(\"%d\", &n) == 1) {\n        scanf(\"%lf %lf %lf %lf\", &start.x, &start.y, &end.x, &end.y);\n        Block blocks[n];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf %lf %lf %lf %lf\", &blocks[i].x1, &blocks[i].y1, &blocks[i].x2, &blocks[i].y2, &blocks[i].h);\n        }\n\n        double radius = maxBallRadius(start, end, blocks, n);\n        printf(\"Dataset %d: %.2lf\\n\", dataset++, radius);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:08:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RollABigBall {\n    static class Block {\n        int x1, x2, y1, y2, height;\n        Block(int x1, int y1, int x2, int y2, int height) {\n            this.x1 = Math.min(x1, x2);\n            this.x2 = Math.max(x1, x2);\n            this.y1 = Math.min(y1, y2);\n            this.y2 = Math.max(y1, y2);\n            this.height = height;\n        }\n    }\n\n    public static double findMaxRadius(int start, int end, Block[] blocks) {\n        double low = 0, high = Math.abs(end - start);\n\n        while (high - low > 1e-6) {\n            double mid = (low + high) / 2;\n            if (canRoll(start, end, blocks, mid)) {\n                low = mid;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    static boolean canRoll(int start, int end, Block[] blocks, double radius) {\n        for (Block block : blocks) {\n            double blockMinX = block.x1 - radius;\n            double blockMaxX = block.x2 + radius;\n            double blockMinY = block.y1 - radius;\n            double blockMaxY = block.y2 + radius;\n\n            if (blockMinX <= start && blockMaxX >= start ||\n                blockMinX <= end && blockMaxX >= end ||\n                start <= blockMinX && end >= blockMaxX) {\n                if (block.height >= radius) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int datasets = sc.nextInt();\n\n        for (int dataset = 0; dataset < datasets; dataset++) {\n            int numBlocks = sc.nextInt();\n            int start = sc.nextInt();\n            int end = sc.nextInt();\n\n            Block[] blocks = new Block[numBlocks];\n            for (int i = 0; i < numBlocks; i++) {\n                int x1 = sc.nextInt();\n                int y1 = sc.nextInt();\n                int x2 = sc.nextInt();\n                int y2 = sc.nextInt();\n                int height = sc.nextInt();\n                blocks[i] = new Block(x1, y1, x2, y2, height);\n            }\n\n            double maxRadius = findMaxRadius(start, end, blocks);\n            System.out.printf(\"%.2f\\n\", maxRadius);\n        }\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 19:09:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\nstruct Rectangle {\n    Point bottomLeft, topRight;\n    double height;\n    Rectangle(Point bl, Point tr, double h) : bottomLeft(bl), topRight(tr), height(h) {}\n};\n\ndouble distanceToSegment(Point p, Point a, Point b) {\n    double l2 = pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n    if (l2 == 0) return sqrt(pow(p.x - a.x, 2) + pow(p.y - a.y, 2));\n    double t = max(0.0, min(1.0, ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2));\n    Point projection(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));\n    return sqrt(pow(p.x - projection.x, 2) + pow(p.y - projection.y, 2));\n}\n\ndouble minDistanceToRect(Point p, Rectangle rect) {\n    double minDist = numeric_limits<double>::max();\n    Point bl = rect.bottomLeft;\n    Point br(rect.topRight.x, rect.bottomLeft.y);\n    Point tr = rect.topRight;\n    Point tl(rect.bottomLeft.x, rect.topRight.y);\n\n    minDist = min(minDist, distanceToSegment(p, bl, br));\n    minDist = min(minDist, distanceToSegment(p, br, tr));\n    minDist = min(minDist, distanceToSegment(p, tr, tl));\n    minDist = min(minDist, distanceToSegment(p, tl, bl));\n\n    return minDist;\n}\n\ndouble computeMaxRadius(Point start, Point end, const vector<Rectangle>& blocks) {\n    double low = 0.0;\n    double high = numeric_limits<double>::max();\n    double eps = 1e-8;\n\n    while (high - low > eps) {\n        double mid = (low + high) / 2.0;\n        bool possible = true;\n\n        for (const auto& rect : blocks) {\n            if (rect.height < mid) continue;\n            double dist = minDistanceToRect(start, rect);\n            if (dist < mid) {\n                possible = false;\n                break;\n            }\n        }\n\n        if (possible) {\n            low = mid;\n        } else {\n            high = mid;\n        }\n    }\n\n    return low;\n}\n\nint main() {\n    int dataset = 1;\n    int N;\n    while (cin >> N) {\n        Point start, end;\n        cin >> start.x >> start.y >> end.x >> end.y;\n        vector<Rectangle> blocks;\n        for (int i = 0; i < N; ++i) {\n            Point bl, tr;\n            double h;\n            cin >> bl.x >> bl.y >> tr.x >> tr.y >> h;\n            blocks.emplace_back(bl, tr, h);\n        }\n        double maxRadius = computeMaxRadius(start, end, blocks);\n        cout << fixed << setprecision(2) << \"Dataset \" << dataset++ << \": \" << maxRadius << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:10:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX_BLOCKS 100\n\ntypedef struct {\n    double x1, y1, x2, y2;\n} Block;\n\ndouble dist(double x1, double y1, double x2, double y2) {\n    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\ndouble min(double a, double b) {\n    return a < b ? a : b;\n}\n\nint intersect(double x, double y, double r, Block b) {\n    double cx = min(max(x, b.x1), b.x2);\n    double cy = min(max(y, b.y1), b.y2);\n    return dist(x, y, cx, cy) < r;\n}\n\ndouble solve(double sx, double sy, double ex, double ey, Block blocks[], int n) {\n    double left = 0, right = 1000;\n    \n    while (right - left > 1e-6) {\n        double mid = (left + right) / 2;\n        int valid = 1;\n        \n        for (int i = 0; i < n; i++) {\n            if (intersect(sx, sy, mid, blocks[i]) ||\n                intersect(ex, ey, mid, blocks[i])) {\n                valid = 0;\n                break;\n            }\n        }\n        \n        if (valid) {\n            for (int i = 0; i < n; i++) {\n                double dx = (blocks[i].x1 + blocks[i].x2) / 2;\n                double dy = (blocks[i].y1 + blocks[i].y2) / 2;\n                \n                if (dist(sx, sy, dx, dy) < mid + dist(blocks[i].x1, blocks[i].y1, blocks[i].x2, blocks[i].y2)/2 ||\n                    dist(ex, ey, dx, dy) < mid + dist(blocks[i].x1, blocks[i].y1, blocks[i].x2, blocks[i].y2)/2) {\n                    valid = 0;\n                    break;\n                }\n            }\n        }\n        \n        if (valid) {\n            left = mid;\n        } else {\n            right = mid;\n        }\n    }\n    \n    return left;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        int n;\n        double sx, sy, ex, ey;\n        \n        scanf(\"%d %lf %lf %lf %lf\", &n, &sx, &sy, &ex, &ey);\n        \n        Block blocks[MAX_BLOCKS];\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf %lf %lf %lf\", &blocks[i].x1, &blocks[i].y1, &blocks[i].x2, &blocks[i].y2);\n        }\n        \n        printf(\"%.6f\\n\", solve(sx, sy, ex, ey, blocks, n));\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:11:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nstruct Block {\n    double x1, y1, x2, y2;\n};\n\ndouble distance(double x1, double y1, double x2, double y2) {\n    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nbool intersect(double x, double y, double r, const Block& block) {\n    double closestX = max(block.x1, min(x, block.x2));\n    double closestY = max(block.y1, min(y, block.y2));\n    \n    double distanceX = x - closestX;\n    double distanceY = y - closestY;\n    \n    return (distanceX * distanceX + distanceY * distanceY) <= r * r;\n}\n\ndouble solve(double startX, double startY, double endX, double endY, const vector<Block>& blocks) {\n    double left = 0, right = 10000;\n    \n    for (int iter = 0; iter < 100; iter++) {\n        double mid = (left + right) / 2;\n        bool possible = true;\n        \n        for (const Block& block : blocks) {\n            if (intersect(startX, startY, mid, block) || \n                intersect(endX, endY, mid, block)) {\n                possible = false;\n                break;\n            }\n        }\n        \n        if (possible) {\n            for (size_t i = 0; i < blocks.size(); i++) {\n                for (size_t j = i + 1; j < blocks.size(); j++) {\n                    double centerX = (blocks[i].x1 + blocks[i].x2) / 2;\n                    double centerY = (blocks[i].y1 + blocks[i].y2) / 2;\n                    \n                    if (intersect(centerX, centerY, mid, blocks[j])) {\n                        possible = false;\n                        break;\n                    }\n                }\n                if (!possible) break;\n            }\n        }\n        \n        if (possible) {\n            left = mid;\n        } else {\n            right = mid;\n        }\n    }\n    \n    return left;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    \n    cout << fixed << setprecision(10);\n    \n    for (int t = 1; t <= T; t++) {\n        int N;\n        double startX, startY, endX, endY;\n        \n        cin >> N >> startX >> startY >> endX >> endY;\n        \n        vector<Block> blocks(N);\n        for (int i = 0; i < N; i++) {\n            cin >> blocks[i].x1 >> blocks[i].y1 >> blocks[i].x2 >> blocks[i].y2;\n        }\n        \n        double result = solve(startX, startY, endX, endY, blocks);\n        cout << \"Case #\" << t << \": \" << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:11:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Point {\n    double x, y;\n    Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Block {\n    double x1, y1, x2, y2, height;\n    Block(double x1, double y1, double x2, double y2, double height) {\n        this.x1 = Math.min(x1, x2);\n        this.y1 = Math.min(y1, y2);\n        this.x2 = Math.max(x1, x2);\n        this.y2 = Math.max(y1, y2);\n        this.height = height;\n    }\n}\n\npublic class RollABigBall {\n    static final double EPS = 1e-8;\n\n    static double distanceToSegment(Point p, Point a, Point b) {\n        double len = Math.hypot(b.x - a.x, b.y - a.y);\n        if (len < EPS) return Math.hypot(p.x - a.x, p.y - a.y);\n        double t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / (len * len);\n        t = Math.max(0, Math.min(1, t));\n        double projX = a.x + t * (b.x - a.x);\n        double projY = a.y + t * (b.y - a.y);\n        return Math.hypot(p.x - projX, p.y - projY);\n    }\n\n    static double minDistanceToBlock(Point p, Block block) {\n        if (block.x1 <= p.x && p.x <= block.x2 && block.y1 <= p.y && p.y <= block.y2) {\n            return 0;\n        }\n        Point[] corners = {\n            new Point(block.x1, block.y1),\n            new Point(block.x1, block.y2),\n            new Point(block.x2, block.y1),\n            new Point(block.x2, block.y2)\n        };\n        double minDist = Double.POSITIVE_INFINITY;\n        for (int i = 0; i < 4; i++) {\n            Point a = corners[i];\n            Point b = corners[(i + 1) % 4];\n            minDist = Math.min(minDist, distanceToSegment(p, a, b));\n        }\n        return minDist;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int N = sc.nextInt();\n            if (N == 0) break;\n            double startX = sc.nextDouble();\n            double startY = sc.nextDouble();\n            double endX = sc.nextDouble();\n            double endY = sc.nextDouble();\n            Point start = new Point(startX, startY);\n            Point end = new Point(endX, endY);\n            Block[] blocks = new Block[N];\n            for (int i = 0; i < N; i++) {\n                double x1 = sc.nextDouble();\n                double y1 = sc.nextDouble();\n                double x2 = sc.nextDouble();\n                double y2 = sc.nextDouble();\n                double h = sc.nextDouble();\n                blocks[i] = new Block(x1, y1, x2, y2, h);\n            }\n\n            double low = 0;\n            double high = Double.POSITIVE_INFINITY;\n            for (int iter = 0; iter < 100; iter++) {\n                double mid = (low + high) / 2;\n                boolean possible = true;\n                for (Block block : blocks) {\n                    double minDist = minDistanceToBlock(start, block);\n                    minDist = Math.min(minDist, minDistanceToBlock(end, block));\n                    if (minDist < mid + EPS && block.height >= mid - EPS) {\n                        possible = false;\n                        break;\n                    }\n                }\n                if (possible) {\n                    low = mid;\n                } else {\n                    high = mid;\n                }\n            }\n            System.out.printf(\"%.6f\\n\", low);\n        }\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 19:11:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_largest_radius(course_length, blocks):\n    def is_collision(ball_center, ball_radius):\n        for block in blocks:\n            if (block[0] - ball_radius <= ball_center <= block[1] + ball_radius) and ball_height < block[2] + ball_radius:\n                return True\n        return False\n    \n    low, high = 0, course_length\n    while high - low > 1e-9:\n        mid = (low + high) / 2\n        ball_center, ball_radius, ball_height = 0, mid, mid\n        if is_collision(ball_center, ball_radius):\n            high = mid\n        else:\n            ball_center = course_length\n            if is_collision(ball_center, ball_radius):\n                high = mid\n            else:\n                low = mid\n    return low\n\n# Read input\nnum_datasets = int(input())\nresults = []\nfor _ in range(num_datasets):\n    num_blocks, start, end = map(float, input().split())\n    course_length = end - start\n    blocks = [tuple(map(float, input().split())) for _ in range(int(num_blocks))]\n    max_radius = find_largest_radius(course_length, blocks)\n    results.append(max_radius)\n\n# Output results\nfor result in results:\n    print(f\"{result:.9f}\")",
    "timestamp": "2025-08-13 02:40:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.awt.geom.Rectangle2D;\nimport java.util.Scanner;\n\npublic class RollABigBall {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numDatasets = scanner.nextInt();\n\n        for (int dataset = 0; dataset < numDatasets; dataset++) {\n            double startX = scanner.nextDouble();\n            double startY = scanner.nextDouble();\n            double endX = scanner.nextDouble();\n            double endY = scanner.nextDouble();\n            int numBlocks = scanner.nextInt();\n\n            Rectangle2D[] blocks = new Rectangle2D[numBlocks];\n            for (int i = 0; i < numBlocks; i++) {\n                double x1 = scanner.nextDouble();\n                double y1 = scanner.nextDouble();\n                double x2 = scanner.nextDouble();\n                double y2 = scanner.nextDouble();\n                blocks[i] = new Rectangle2D.Double(x1, y1, Math.abs(x2 - x1), Math.abs(y2 - y1));\n            }\n            \n            double left = 0, right = Math.min(Math.abs(endX - startX), Math.abs(endY - startY)) / 2;\n            double precision = 1e-6;\n\n            while (right - left > precision) {\n                double mid = (left + right) / 2;\n                \n                if (canRoll(startX, startY, endX, endY, mid, blocks)) {\n                    left = mid;\n                } else {\n                    right = mid;\n                }\n            }\n            \n            System.out.println(left);\n        }\n        scanner.close();\n    }\n\n    private static boolean canRoll(double startX, double startY, double endX, double endY, double radius, Rectangle2D[] blocks) {\n        for (Rectangle2D block : blocks) {\n            if (collisionWithBlock(startX, startY, endX, endY, radius, block)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean collisionWithBlock(double startX, double startY, double endX, double endY, double radius, Rectangle2D block) {\n        double sx = startX + radius;\n        double ex = endX - radius;\n        double sy = startY + radius;\n        double ey = endY - radius;\n        \n        return block.intersectsLine(sx, sy, ex, ey);\n    }\n}",
    "timestamp": "2025-08-13 02:40:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double x1, y1, x2, y2, height;\n} Block;\n\nint n;\ndouble sx, sy, ex, ey;\nBlock *blocks;\n\nint isCollision(double x, double y, double radius) {\n    for (int i = 0; i < n; i++) {\n        Block b = blocks[i];\n        if (x + radius >= b.x1 && x - radius <= b.x2 &&\n            y + radius >= b.y1 && y - radius <= b.y2) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint canRoll(double radius) {\n    double distance = hypot(ex - sx, ey - sy);\n    double steps = distance / 0.1;\n    double dx = (ex - sx) / steps;\n    double dy = (ey - sy) / steps;\n    double x = sx, y = sy;\n\n    for (int i = 0; i <= steps; i++) {\n        if (isCollision(x, y, radius)) {\n            return 0;\n        }\n        x += dx;\n        y += dy;\n    }\n    return 1;\n}\n\ndouble findMaxRadius() {\n    double low = 0.0, high = 1e9; // assume an initial high range\n    for (int i = 0; i < 100; i++) { // binary search with fixed iterations\n        double mid = (low + high) / 2.0;\n        if (canRoll(mid)) {\n            low = mid;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n\nint main() {\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        scanf(\"%lf %lf %lf %lf\", &sx, &sy, &ex, &ey);\n        blocks = malloc(n * sizeof(Block));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf %lf %lf %lf %lf\", &blocks[i].x1, &blocks[i].y1, &blocks[i].x2, &blocks[i].y2, &blocks[i].height);\n        }\n        printf(\"%.6f\\n\", findMaxRadius());\n        free(blocks);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 02:40:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_roll_a_big_ball(start, end, blocks):\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    def is_inside_block(point, block):\n        x, y = point\n        bx, by, bw, bh = block\n        return bx <= x <= bx + bw and by <= y <= by + bh\n\n    def can_roll(radius):\n        def circle_intersects_block(block):\n            bx, by, bw, bh = block\n            block_center_x = bx + bw/2\n            block_center_y = by + bh/2\n            \n            # Check distance between ball center and block center\n            dist = distance([start[0] + radius, start[1]], [block_center_x, block_center_y])\n            diag = ((bw/2)**2 + (bh/2)**2)**0.5\n            \n            return dist <= radius + diag\n\n        # Check if ball touches any block or goes outside course\n        for block in blocks:\n            if circle_intersects_block(block):\n                return False\n        \n        return True\n\n    # Binary search for maximum radius\n    left, right = 0, distance(start, end)\n    while right - left > 1e-6:\n        mid = (left + right) / 2\n        if can_roll(mid):\n            left = mid\n        else:\n            right = mid\n\n    return left\n\n# Input parsing and output\ndef main():\n    datasets = int(input())\n    for _ in range(datasets):\n        n = int(input())\n        start_x, start_y = map(float, input().split())\n        end_x, end_y = map(float, input().split())\n        \n        blocks = []\n        for _ in range(n):\n            bx, by, bw, bh = map(float, input().split())\n            blocks.append([bx, by, bw, bh])\n        \n        result = solve_roll_a_big_ball([start_x, start_y], [end_x, end_y], blocks)\n        print(f\"{result:.6f}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:40:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef solve():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    while True:\n        n = int(input[ptr])\n        ptr += 1\n        if n == -1:\n            break\n        sx, sy, ex, ey = map(float, input[ptr:ptr+4])\n        ptr +=4\n        blocks = []\n        for _ in range(n):\n            x1, y1, x2, y2, h = map(float, input[ptr:ptr+5])\n            ptr +=5\n            blocks.append((min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2), h))\n        \n        # The course is from (sx, sy) to (ex, ey)\n        # The ball's path is the line segment from (sx, sy) to (ex, ey)\n        # The radius is limited by the distance to the blocks\n        \n        # Parametric equations: x = sx + t*(ex-sx), y = sy + t*(ey-sy), t in [0,1]\n        # For each block, find the minimal distance from the line segment to the block\n        # The radius must be <= min distance for all blocks\n        \n        min_r = float('inf')\n        dx = ex - sx\n        dy = ey - sy\n        seg_len_sq = dx*dx + dy*dy\n        seg_len = math.sqrt(seg_len_sq)\n        \n        for (x1, y1, x2, y2, h) in blocks:\n            # Find minimal distance from segment to the rectangle (x1,y1) to (x2,y2)\n            # The distance is the minimal distance from the segment to the rectangle's sides or corners\n            # Also consider the height h: the ball's radius must be <= h\n            \n            # First, find the closest point on the segment to the rectangle\n            # Project the rectangle's corners onto the segment\n            # The minimal distance is the minimal distance from the segment to any of the rectangle's edges or corners\n            \n            # Check if the segment intersects the rectangle\n            # If it does, the minimal distance is 0, so radius must be 0\n            # Else, compute minimal distance\n            \n            # Check for intersection between segment and rectangle\n            def ccw(A, B, C):\n                return (B[0]-A[0])*(C[1]-A[1]) - (B[1]-A[1])*(C[0]-A[0])\n            \n            def intersect(A, B, C, D):\n                return ccw(A, B, C) * ccw(A, B, D) <= 0 and ccw(C, D, A) * ccw(C, D, B) <= 0\n            \n            seg_start = (sx, sy)\n            seg_end = (ex, ey)\n            rect_corners = [(x1, y1), (x2, y1), (x2, y2), (x1, y2)]\n            rect_edges = [\n                ((x1, y1), (x2, y1)),\n                ((x2, y1), (x2, y2)),\n                ((x2, y2), (x1, y2)),\n                ((x1, y2), (x1, y1))\n            ]\n            \n            intersects = False\n            for edge in rect_edges:\n                if intersect(seg_start, seg_end, edge[0], edge[1]):\n                    intersects = True\n                    break\n            if intersects:\n                min_r = 0.0\n                continue\n            \n            # No intersection, compute minimal distance\n            # The minimal distance is the minimal distance from the segment to any of the rectangle's edges or corners\n            min_dist = float('inf')\n            \n            # Check distance to each corner\n            for (cx, cy) in rect_corners:\n                # Project (cx, cy) onto the segment\n                t = ((cx - sx)*dx + (cy - sy)*dy) / seg_len_sq\n                t = max(0.0, min(1.0, t))\n                proj_x = sx + t * dx\n                proj_y = sy + t * dy\n                dist_sq = (cx - proj_x)**2 + (cy - proj_y)**2\n                dist = math.sqrt(dist_sq)\n                if dist < min_dist:\n                    min_dist = dist\n            \n            # Check distance to each edge of the rectangle\n            # For horizontal and vertical edges, it's easier\n            # Edge (x1,y1)-(x2,y1)\n            if sx != ex:\n                t = (y1 - sy) / dy if dy != 0 else float('inf')\n                if 0 <= t <= 1:\n                    proj_x = sx + t * dx\n                    if x1 <= proj_x <= x2:\n                        dist = abs(y1 - (sy + t * dy))\n                        if dist < min_dist:\n                            min_dist = dist\n            # Edge (x2,y1)-(x2,y2)\n            if sy != ey:\n                t = (x2 - sx) / dx if dx != 0 else float('inf')\n                if 0 <= t <= 1:\n                    proj_y = sy + t * dy\n                    if y1 <= proj_y <= y2:\n                        dist = abs(x2 - (sx + t * dx))\n                        if dist < min_dist:\n                            min_dist = dist\n            # Edge (x2,y2)-(x1,y2)\n            if sx != ex:\n                t = (y2 - sy) / dy if dy != 0 else float('inf')\n                if 0 <= t <= 1:\n                    proj_x = sx + t * dx\n                    if x1 <= proj_x <= x2:\n                        dist = abs(y2 - (sy + t * dy))\n                        if dist < min_dist:\n                            min_dist = dist\n            # Edge (x1,y2)-(x1,y1)\n            if sy != ey:\n                t = (x1 - sx) / dx if dx != 0 else float('inf')\n                if 0 <= t <= 1:\n                    proj_y = sy + t * dy\n                    if y1 <= proj_y <= y2:\n                        dist = abs(x1 - (sx + t * dx))\n                        if dist < min_dist:\n                            min_dist = dist\n            \n            current_r = min(min_dist, h)\n            if current_r < min_r:\n                min_r = current_r\n        \n        # Also, the ball must not leave the course, so the radius is limited by the distance to the course boundaries\n        # The course is the line segment from (sx, sy) to (ex, ey)\n        # The ball's center must be at least radius away from the segment\n        # But the problem says \"the ball's bottom point does not leave the course\"\n        # Assuming the course is the line segment, and the ball's bottom must stay on it\n        # So the ball's radius is limited by the minimal distance to blocks and the height of blocks\n        # So no additional constraints\n        \n        print(\"{0:.2f}\".format(min_r))\n\nsolve()",
    "timestamp": "2025-08-13 02:41:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Block {\n    int x1, y1, x2, y2;\n};\n\nbool doesCollide(const Block& block, int x, int y, double radius) {\n    return x + radius > block.x1 && x - radius < block.x2 && y + radius > block.y1 && y - radius < block.y2;\n}\n\ndouble findLargestRadius(int startX, int startY, int endX, int endY, const std::vector<Block>& blocks) {\n    double left = 0.0, right = 1e6; // Arbitrary large value for the upper bound of radius\n    double tolerance = 1e-6;\n    \n    while (right - left > tolerance) {\n        double mid = (left + right) / 2;\n        bool collision = false;\n        for (const auto& block : blocks) {\n            if (doesCollide(block, startX, startY, mid) || doesCollide(block, endX, endY, mid)) {\n                collision = true;\n                break;\n            }\n        }\n        if (collision) right = mid;\n        else left = mid;\n    }\n    return left;\n}\n\nint main() {\n    int n; // Number of blocks\n    std::cin >> n;\n    int startX, startY, endX, endY;\n    std::cin >> startX >> startY >> endX >> endY;\n    std::vector<Block> blocks(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> blocks[i].x1 >> blocks[i].y1 >> blocks[i].x2 >> blocks[i].y2;\n    }\n    double largestRadius = findLargestRadius(startX, startY, endX, endY, blocks);\n    std::cout << largestRadius << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:07:10"
  }
]