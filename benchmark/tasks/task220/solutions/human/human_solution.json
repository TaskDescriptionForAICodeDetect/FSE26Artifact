[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <utility>\nusing namespace std;\n\n#define EPS 1e-8\n\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\n\ndouble dot(rP a, rP b){\n\treturn real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(rP a, rP b){\n\treturn real(a) * imag(b) - imag(a) * real(b);\n}\n\nint ccw(const seg &s, P c){\n\tP b = s.second - s.first;\n\tc -= s.first;\n\tdouble cr = cross(b, c);\n\tif(cr < -EPS){ return 1; }\n\tif(cr > EPS){ return -1; }\n\tif(dot(b, c) < -EPS){ return 2; }\n\tif(norm(b) < norm(c) - EPS){ return -2; }\n\treturn 0;\n}\n\nbool intersectSS(const seg &s, const seg &t){\n\treturn ccw(s, t.first) * ccw(s, t.second) <= 0 &&\n\t       ccw(t, s.first) * ccw(t, s.second) <= 0;\n}\n\ndouble distanceSP(const seg &s, rP c){\n\trP a = s.first, b = s.second;\n\tif(dot(b - a, c - a) <= 0.0) return abs(c - a);\n\tif(dot(a - b, c - b) <= 0.0) return abs(c - b);\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\ndouble distanceSS(const seg &s, const seg &t){\n\tif(intersectSS(s, t)){ return 0.0; }\n\treturn min(min(distanceSP(s, t.first), distanceSP(s, t.second)),\n\t           min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\n\nint main(){\n\tint n;\n\tdouble x1, x2, y1, y2, h;\n\twhile(scanf(\"%d%lf%lf%lf%lf\", &n, &x1, &y1, &x2, &y2) == 5){\n\t\tseg crs(P(x1, y1), P(x2, y2));\n\t\tdouble ans = 1e99;\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf%lf%lf%lf\", &x1, &y1, &x2, &y2, &h);\n\t\t\t\n\t\t\tif(x1 <= real(crs.first) && real(crs.first) <= x2 &&\n\t\t\t   y1 <= imag(crs.first) && imag(crs.first) <= y2){\n\t\t\t\tans = 0.0;\n\t\t\t}\n\t\t\t\n\t\t\tP box[5];\n\t\t\tbox[0] = box[4] = P(x1, y1);\n\t\t\tbox[1] = P(x1, y2);\n\t\t\tbox[2] = P(x2, y2);\n\t\t\tbox[3] = P(x2, y1);\n\n\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\tdouble d = distanceSS(crs, seg(box[j], box[j + 1]));\n\t\t\t\tdouble r;\n\t\t\t\tif(d <= h){\n\t\t\t\t\tr = d;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tr = (d * d + h * h) / (2.0 * h);\n\t\t\t\t}\n\t\t\t\tans = min(ans, r);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<array>\n#include<cassert>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\ntypedef double Real;\n\nconst Real EPS = 1e-8;\n\nint sign(Real d){\n\treturn d > EPS ? 1 : d < -EPS ? -1 : 0;\n}\n\nstruct Point{\n\tReal x,y;\t\n\texplicit Point(Real x_ = 0,Real y_ = 0):x(x_),y(y_){}\n\tPoint operator+(const Point &p) const {return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p) const {return Point(x-p.x,y-p.y);}\n\tPoint operator*(Real s) const {return Point(x*s,y*s);}\n\tPoint operator/(Real s) const {return Point(x/s,y/s);}\n\tbool operator<(const Point &p) const{return sign(x-p.x) == -1 || (sign(x-p.x) == 0 && sign(y-p.y) == -1);}\n\tbool operator==(const Point &p) const{return sign(x-p.x) == 0 && sign(y-p.y) == 0;}\n\n};\n\nistream &operator>>(istream &is,Point &p){return is >> p.x >> p.y;}//??\\???????°???????\nostream &operator<<(ostream &os ,const Point &p){return os << '(' << p.x << \", \" << p.y << ')';}//??????????°???????\n\nstruct Segment : public array<Point,2>{\n\tSegment(const Point &a,const Point &b){\tat(0) = a; at(1) = b;}\n};\n\nstruct Line : public array<Point,2>{\n\tLine(const Point &a,const Point &b){at(0) = a; at(1) = b;}\n};\n\nstruct Circle{\n\tPoint c;\n\tReal r;\n\n\tCircle(const Point &c_, Real r_):c(c_),r(r_){}\n};\n\ntypedef vector<Point> Polygon;\n\nPoint rotate90(const Point &p){\n\treturn Point(-p.y,p.x);\n}\n\nPoint rotate(const Point &p,Real theta){\n\tconst Real s = sin(theta),c = cos(theta);\n\treturn Point(c*p.x-s*p.y,s*p.x+c*p.y);\n}\n\nReal angle(const Point &p){\n\treturn atan2(p.y,p.x);\n}\n\nReal dot(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.x+a.y*b.y;\n}\n\nReal cross(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.y-a.y*b.x;\n}\n\n\nReal norm(const Point &p){\n\treturn p.x*p.x+p.y*p.y;\n}\n\nReal abs(const Point &p){\n\treturn sqrt(norm(p));\n}\n\nenum { CCW=1,CW=-1,BACK=2,FRONT=-2,ON=0 };\nint ccw(const Point &a,const Point &b,const Point &c){\n\tconst Point p = b-a;\n\tconst Point q = c-a;\n\tconst int sgn = sign(cross(p,q));\n\t\n\tif(sgn == 1) return CCW;\n\tif(sgn == -1) return CW;\n\tif(sign(dot(p,q)) == -1) return BACK;\n\tif(sign(norm(p) - norm(q)) == -1) return FRONT;\n\treturn ON;\n}\n\nPoint project(const Line &l,const Point &p){ //?°???±\n\tReal t = dot(p-l[0], l[1]-l[0]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\n\nPoint refrect(const Line &l,const Point &p){ //????°?\n\tconst Point c = project(l,p);\n\treturn c+(c-p);\n}\n\nbool intersect(const Segment &a,const Segment &b){\n\treturn ccw(a[0],a[1],b[0])*ccw(a[0],a[1],b[1]) <= 0\n\t\t&& ccw(b[0],b[1],a[0])*ccw(b[0],b[1],a[1]) <= 0;\n}\n\nbool intersect(const Segment &s,const Point &p){\n\treturn ccw(s[0],s[1],p) == ON;\n}\n\nbool intersect(const Line &l,const Segment &s){\n\treturn sign(cross(l[1]-l[0],s[0]-l[0])) * cross(l[1]-l[0],s[1]-l[0]) <= 0;\n}\n\nbool intersect(const Line &l,const Point &p){\n\treturn abs(ccw(l[0],l[1],p)) != 1;\n}\n\nbool intersect(const Line &a,const Line &b){ //????????????\n\treturn sign(cross(a[1]-a[0],b[1]-b[0])) != 0\n\t\t||\tsign(cross(a[1]-a[0],b[1]-a[0]) == 0);\n}\n\nReal dist(const Point &a,const Point &b){\n\treturn abs(a-b);\t\n}\n\nReal dist(const Line &l,const Point &p){\n\tconst Point a = l[1]-l[0];\n\tconst Point b = p-l[0];\n\treturn abs(cross(a,b))/abs(a);\n}\n\nReal dist(const Line &l,const Segment &s){\n\tif(intersect(l,s)) return 0;\n\treturn min(dist(l,s[0]),dist(l,s[1]));\n}\n\nReal dist(const Line &a,const Line &b){\n\tif(intersect(a,b)) return 0;\n\treturn dist(a,b[0]);\n}\n\nReal dist(const Segment &s,const Point &p){\n\tif(sign(dot(s[1]-s[0],p-s[0]))==-1) return dist(s[0],p);\n\tif(sign(dot(s[0]-s[1],p-s[1]))==-1) return dist(s[1],p);\n\treturn dist(Line(s[0],s[1]),p);\n}\n\nReal dist(const Segment &a,const Segment &b){\n\tif(intersect(a,b)) return 0;\n\treturn min({dist(a,b[0]),dist(a,b[1]),dist(b,a[0]),dist(b,a[1])});\n}\n\nbool intersect(const Circle &a,const Circle &b){\n\treturn sign(dist(a.c,b.c)-(a.r+b.r)) <=0\n\t\t\t&& sign(dist(a.c,b.c)-abs(a.r-b.r)) >= 0;\n}\n\nbool intersect(const Circle &c,const Segment &s){\n\treturn sign(dist(s,c.c)-c.r)<=0;\n}\n\nbool intersect(const Circle &c,const Line &l){\n\treturn sign(dist(l,c.c)-c.r)<=0;\n}\n\nbool contain(const Circle &c,const Point &p){\n\treturn sign(dist(c.c,p)-c.r) <=0;\n}\n\nbool contain(const Polygon &P,const Point &p){\n\tbool res = false;\n\n\tfor(int i=0;i<P.size();++i){\n\t\tPoint v1=P[i]-p;\n\t\tPoint v2=P[(i+1)%P.size()]-p;\n\t\tif(v1.y>v2.y) swap(v1,v2);\n\n\t\tif(sign(cross(v1,v2))==0&&sign(dot(v1,v2))<=0){\n\t\t\treturn true;//on edge \n\t\t}\n\t\tif(sign(v1.y)<=0&&sign(v2.y)==1&&sign(cross(v1,v2))==1){\n\t\t\tres=!res;\n\t\t}\n\t}\n\treturn res;\n}\n\nPoint crosspoint(const Line &a,const Line &b){\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1]-a[0],b[1]-b[0]);\n\tif(sign(crs) == 0) return a[0];\n\treturn b[0]+(b[1]-b[0])*(cross(a[1]-a[0],a[1]-b[0])/crs);\n}\n\n\n//??¬??¢?????????????????¨?????°?????????????????????Intersect?????????\nPoint crosspoint(const Segment &a,const Segment &b){\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1]-a[0],b[1]-b[0]);\n\tif(sign(crs)==0){\n\t\tif(intersect(a,b[0])) return b[0];\n\t\tif(intersect(a,b[1])) return b[1];\n\t\tif(intersect(b,a[0])) return a[0];\n\t\treturn a[1];\n\t}\n\treturn b[0]+(b[1]-b[0])*(cross(a[1]-a[0],a[1]-b[0])/crs);\n}\n\nvector<Point> crosspoint(const Circle &c,const Line &l){\n\tconst Point p = project(l,c.c);\n\tconst Real h = dist(p,c.c);\n\n\tvector<Point> res;\n\tif(sign(h-c.r)==1){\n\t\t//nothing\n\t}else if(sign(h-c.r)==0){\n\t\tres.emplace_back(p);\t\n\t}else{\n\t\tconst Real b = sqrt(c.r*c.r-h*h);\n\t\tconst Point e = (l[1]-l[0])/abs(l[1]-l[0]);\n\t\tres.emplace_back(p+e*b);\n\t\tres.emplace_back(p-e*b);\n\t}\n\treturn res;\n}\n\nvector<Point> crosspoint(const Circle &a,const Circle &b){\n\tif(!intersect(a,b)) return vector<Point>();\n\n\tvector<Point> res;\n\tconst Real d = dist(a.c,b.c);\n\n\tif(sign(d-(a.r+b.r))==0){\n\t\tconst Point v = b.c - a.c;\n\t\tres.emplace_back(a.c + (v * (a.r /abs(v))));\n\t}else{\n\t\tconst Real theta = acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\t\tconst Real phi = angle(b.c-a.c);\n\t\tres.emplace_back(a.c+rotate(Point(a.r,0),phi+theta));\n\t\tres.emplace_back(a.c+rotate(Point(a.r,0),phi-theta));\n\t}\n\treturn res;\n}\n\nReal area(const Polygon &P){\n\tReal res = 0.0;\n\tfor(int i=0;i<P.size();++i){\n\t\tres+=cross(P[i],P[(i+1)%P.size()]);\n\t}\n\treturn abs(res) * 0.5;\n}\n\nReal height[51];\nReal mindist[51];\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\twhile(1){\n\t\tint N;\n\t\tPoint sp,ep;\n\t\tcin >> N;\n\t\tif(N==0) break;\t\n\t\tcin >> sp >> ep;\n\n\t\tvector<Polygon> lects(N);\n\t\tfill_n((Real *)mindist,sizeof(mindist)/sizeof(Real),1e9);\n\t\trep(i,N){\t\n\t\t\tPoint minP,maxP;\n\t\t\tcin >> minP >> maxP >> height[i];\n\t\t\tlects[i].push_back(minP);\t\n\t\t\tlects[i].push_back(Point(maxP.x,minP.y));\n\t\t\tlects[i].push_back(maxP);\n\t\t\tlects[i].push_back(Point(minP.x,maxP.y));\t\n\t\t}\t\n\n\t\trep(i,N){\n\t\t\trep(j,4){\n\t\t\t\tmindist[i]=min(mindist[i],dist(Segment(sp,ep),Segment(lects[i][j],lects[i][(j+1)%4])));\t\n\t\t\t}\n\t\t}\n\n\t\tReal ans=1e9;\n\t\t\n\t\trep(i,N){\n\t\t\tif(contain(lects[i],sp) || contain(lects[i],ep)){\n\t\t\t\tans=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(mindist[i]>height[i]) ans=min(ans,((height[i]*height[i])+(mindist[i]*mindist[i]))/(2*height[i]));\n\t\t\telse ans=min(ans,mindist[i]);\n\t\t}\n\t\t\n\n\t\tcout << ans << endl;\n\n\t}\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <complex>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef complex<double> P;\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L() {}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n};\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    double sx, sy, ex, ey;\n    cin>>sx>>sy>>ex>>ey;\n    double ans = INF;\n    L root = L(P(sx,sy), P(ex,ey));\n    REP(i, N){\n      double mx, my, nx, ny, h;\n      cin>>mx>>my>>nx>>ny>>h;\n      if(mx <= sx && sx <= nx && my <= sy && sy <= ny) ans = 0;\n      L ls[4];\n      ls[0] = L(P(mx,my),P(nx,my));\n      ls[1] = L(P(mx,my),P(mx,ny));\n      ls[2] = L(P(mx,ny),P(nx,ny));\n      ls[3] = L(P(nx,my),P(nx,ny));\n      REP(j, 4){\n        L l = ls[j];\n        double dist = distanceSS(root, l);\n        if(dist == 0) ans = 0;\n        //cout<<l[0]<<\" \"<<l[1]<<\":\"<<dist<<endl;\n        double radian = max((h*h + dist*dist)/(2*h), dist);\n        ans = min(ans, radian);\n      }\n    }\n    printf(\"%.10lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\ntypedef complex<ld> Point;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine () : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle () : p(Point(0, 0)), r(0) {}\n\tCircle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll (Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps){\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d,\tc.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0,\t1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j,n) res += cross(p[j], p[(j+1)%n]);\n\treturn res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i,n) {\n\t\tPoint a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i,n) {\n\t\tPoint a = poly[i], b = poly[(i+1)%n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i,n) {\n\t\tPoint A = ps[i], B = ps[(i+1)%n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i,m) {\n\t\tvector<pair<ld,int>> vec;\n\t\tREP(j,n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j,vec.size()-1) {\n\t\t\tint from = vec[j].second, to = vec[j+1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i,m) {\n\t\tvector<pair<ld,int>> vec;\n\t\tREP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j,vec.size()-1) {\n\t\t\tint from = vec[j].second, to = vec[j+1].second;\n\t\t\tld angle = vec[j+1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i,1024) REP(j,1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld,int,bool>>> tup(N);\n\tREP(i,s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i,N) sort(ALL(tup[i]));\n\tREP(i,N) {\n\t\tREP(j,tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i,N) REP(j,i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back((Edge){from, to});\n\t\t\tg[to].push_back((Edge){to, from});\n\t\t}\n\t}\n\treturn g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tld sx, sy, ex, ey; cin >> sx >> sy >> ex >> ey;\n\t\tLine l0(Point(sx, sy), Point(ex, ey));\n\t\tld ans = linf;\n\t\tREP(i, N) {\n\t\t\tld x1, y1, x2, y2, h; cin >> x1 >> y1 >> x2 >> y2 >> h;\n\t\t\tPolygon pol = {Point(x1, y1), Point(x1, y2), Point(x2, y2), Point(x2, y1)};\n\t\t\tld r = linf;\n\t\t\tif ( is_in_polygon(pol, l0.a) || is_in_polygon(pol,l0.b) ) {\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tREP(j, pol.size()) {\n\t\t\t\t\tLine l(pol[j], pol[(j+1)%pol.size()]);\n\t\t\t\t\tr = min(r, dist_ss(l0, l));\n//\t\t\t\t\tdebug(dist_ss(l0, l));\n\t\t\t\t}\n//\t\t\t\tdebug(r);\n//\t\t\t\tdebug(h);\n\t\t\t}\n\t\t\tld R = r <= h+eps ? r : (r*r + h*h)/(2*h);\n\t\t\tans = min(ans, R);\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline point rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\ninline point rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ninline double angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ninline double abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ninline double norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ninline double cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ninline point projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\ninline bool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\ninline bool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ninline bool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline bool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\ninline bool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ninline double dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ninline double dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ninline double dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ninline double dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ninline double dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\ninline double dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ninline point crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn m.a + (m.b - m.a) * cross(l.b - l.a, l.a - m.a) * (1.0 / tmp);\n}\n\ninline point crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\n//先に，intersectを用いて交差判定を行うこと\ninline vector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ninline double areaTriangle(point a, point b, const point& c) {\n\ta = a - c;\n\tb = b - c;\n\treturn fabs(a.x * b.y - b.x * a.y) / 2.0;\n}\n\ninline double area(const polygon& p) {\n\tconst int num = p.size();\n\tif(num < 3)\n\t\treturn 0;\n\n\tif(num == 3)\n\t\treturn areaTriangle(p[0], p[1], p[2]);\n\n\tdouble res = cross(p[num - 1], p[0]);\n\tfor(int i = 1; i < num; ++i)\n\t\tres += cross(p[i - 1], p[i]);\n\n\treturn res * 0.5;\n}\n\n// L.aからL.bの方向を見た場合に，点aが左側に来る．\ninline line bisector(const point& a, const point& b) {\n\treturn line(point((a.x - a.y + b.x + b.y) / 2.0, (a.y + a.x + b.y - b.x) / 2.0),\n\t\t\t\tpoint((a.x + a.y + b.x - b.y) / 2.0, (a.y - a.x + b.y + b.x) / 2.0));\n}\n\n// L.aからL.bを向いた時の左側を残して切断する．\ninline polygon convex_cut(const polygon& p, const line& l) {\n\tconst int num = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < num; ++i) {\n\t\tconst int next = (i + 1) % num;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1)\n\t\t\tres.push_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0)\n\t\t\tres.push_back(crosspoint(l, line(p[i], p[next])));\n\t}\n\n\treturn res;\n}\n\nvector<point> tangent(const circle& c, const point& p) {\n\tconst double x = norm(p - c.c);\n\tdouble d = x - c.r * c.r;\n\tif(d < -EPS) return vector<point>();\n\td = max(d, 0.0);\n\tconst point q1 = (p - c.c) * (c.r * c.r / x);\n\tconst point q2 = rotate90((p - c.c) * (-c.r * sqrt(d) / x));\n\tvector<point> res;\n\tres.push_back(c.c + q1 - q2);\n\tres.push_back(c.c + q1 + q2);\n\treturn res;\n}\n\nvector<line> tangent(const circle &a, const circle& b) {\n\tvector<line> res;\n\tif(abs(a.r - b.r) < EPS) {\n\t\tpoint dir = b.c - a.c;\n\t\tdir = rotate90(dir * (a.r / abs(dir)));\n\t\tres.push_back(line(a.c + dir, b.c + dir));\n\t\tres.push_back(line(a.c - dir, b.c - dir));\n\t}\n\telse {\n\t\tpoint p = a.c * (-b.r) + b.c * a.r;\n\t\tp = p * (1.0 / (a.r - b.r));\n\t\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\t\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\t\tres.push_back(line(ps[i], qs[i]));\n\t}\n\n\tpoint p = a.c * b.r + b.c * a.r;\n\tp = p * (1.0 / (a.r + b.r));\n\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\tres.push_back(line(ps[i], qs[i]));\n\n\treturn res;\n}\n\nconst int MAX_N = 50;\nconst double INF = 2000;\nint n;\ndouble d[MAX_N];\nint h[MAX_N];\n\nbool check(double r) {\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(h[i] >= r) {\n\t\t\tif(d[i] < r)\n\t\t\t\treturn false;\n\t\t}\n\n\t\telse {\n\t\t\tconst double a = r - h[i];\n\t\t\tif(d[i] * d[i] + a * a < r * r)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\twhile(scanf(\"%d\", &n), n) {\n\t\tint sx, sy, ex, ey;\n\t\tscanf(\"%d %d %d %d\", &sx, &sy, &ex, &ey);\n\n\t\tsegment course(point(sx, sy), point(ex, ey));\n\n\t\tfill(d, d + n, INF);\n\t\tbool on = false;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint minX, minY, maxX, maxY;\n\t\t\tscanf(\"%d %d %d %d %d\", &minX, &minY, &maxX, &maxY, &h[i]);\n\n\t\t\tvector<point> points;\n\t\t\tpoints.reserve(4);\n\t\t\tpoints.push_back(point(minX, minY));\n\t\t\tpoints.push_back(point(minX, maxY));\n\t\t\tpoints.push_back(point(maxX, maxY));\n\t\t\tpoints.push_back(point(maxX, minY));\n\n\t\t\tif(minX <= sx && sx <= maxX && minY <= sy && sy <= maxY\n\t\t\t   || minX <= ex && ex <= maxX && minY <= ey && ey <= maxY) {\n\t\t\t\ton = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\n\t\t\tfor(int j = 0; j < 4; ++j) {\n\t\t\t\tconst segment edge(points[j], points[(j + 1) % 4]);\n\t\t\t\tif(intersect(course, edge)) {\n\t\t\t\t\ton = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchmin(d[i], dist(course, points[j]));\n\t\t\t\tchmin(d[i], dist(course, edge));\n\t\t\t}\n\t\t}\n\n\t\tif(on) {\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tdouble low = 0.0, high = 1000.0;\n\t\tfor(int i = 0; i < 100; ++i) {\n\t\t\tconst double mid = (low + high) / 2;\n\t\t\tif(check(mid))\n\t\t\t\tlow = mid;\n\n\t\t\telse\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\tprintf(\"%.15lf\\n\", low);\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <iostream>\n\nusing namespace std;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\ntypedef long double ld;\nconst ld EPS=1e-9;\n\nstruct Point{\n\tPoint(ld x,ld y):x(x), y(y){}\n\tPoint(){}\n\tld x,y;\n};\n\nPoint operator+(const Point &a, const Point &b){\n\treturn Point(a.x+b.x, a.y+b.y);\n}\n\nPoint operator-(const Point &a, const Point &b){\n\treturn Point(a.x-b.x, a.y-b.y);\n}\n\nPoint operator*(const Point &a, const ld b){\n\treturn Point(a.x*b, a.y*b);\n}\n\nld cross(const Point &a, const Point &b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nld dot(const Point &a, const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\nld norm(const Point &a){\n\treturn dot(a,a);\n}\n\nld abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nstruct Line:vector<Point>{\n\tLine(Point a = Point(0,0), Point b = Point(0,0)){\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n};\n\nint ccw(Point a, Point b, Point c){\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b,c) > EPS) return 1;\n\tif(cross(b,c) < -EPS) return -1;\n\tif(dot(b,c) < 0) return 2;\n\tif(norm(b)<norm(c)) return -2;\n\treturn 0;\n}\n\nbool is_intersect_SS(const Line &s, const Line &t){\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nbool is_intersect_SP(const Line &l, const Point &p){\n\treturn ccw(l[0],l[1],p)==0;\n}\n\nPoint projection(const Line &l, const Point &p){\n\tld t = dot(p-l[0],l[1]-l[0])/norm(l[0]-l[1]);\n\treturn l[0]+(l[1]-l[0])*t;\n}\n\nld distance_SP(const Line &s, const Point &p){\n\tconst Point r = projection(s,p);\n\tif(is_intersect_SP(s,r))return abs(r-p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\nld distance_SS(const Line &s, const Line &t){\n\tif(is_intersect_SS(s,t)) return 0;\n\treturn min(min(distance_SP(s,t[0]),distance_SP(s,t[1])),min(distance_SP(t,s[0]),distance_SP(t, s[1])));\n}\n\nbool lt(ld x, ld y){\n\treturn x - y < EPS;\n}\n\nint n;\nLine L;\nLine data[100];\nint H[100];\n\nld Max;\n\nvoid input(){\n\tint w, x, y, z;\n\tMax = 1e10;\n\tscanf(\"%d%d%d%d\", &w, &x, &y, &z);\n\tL = Line(Point(w,x), Point(y,z));\n\tfor(int i = 0 ; i< n;i++){\n\t\tscanf(\"%d%d%d%d%d\", &w, &x, &y, &z, &H[i]);\n\t\tdata[i] = Line(Point(w,x), Point(y,z));\n\t}\n}\n\nvoid process(){\n\tld minX = min(L[0].x, L[1].x);\n\tld minY = min(L[0].y, L[1].y);\n\tld maxX = max(L[0].x, L[1].x);\n\tld maxY = max(L[0].y, L[1].y);\n\t//Check rect & line\n\tfor(int i = 0; i < n;i++){\n\t\tif(is_intersect_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][0].x, data[i][1].y))) ||\n\t\t\tis_intersect_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][1].x, data[i][0].y))) ||\n\t\t\tis_intersect_SS(L, Line(Point(data[i][0].x, data[i][1].y), Point(data[i][1].x, data[i][1].y))) ||\n\t\t\tis_intersect_SS(L, Line(Point(data[i][1].x, data[i][0].y), Point(data[i][1].x, data[i][1].y)))) {\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif(lt(data[i][0].x , minX) && lt(data[i][0].y , minY) && lt(maxX , data[i][1].x) && lt(maxY , data[i][1].y)) {\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t//get r;\n\tfor(int i = 0; i < n; i++) {\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][0].x, data[i][1].y)));\n\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\tif(lt(r, Max)) Max = r;\n\t\t}\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][1].x, data[i][0].y)));\n\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\tif(lt(r,Max)) Max = r;\n\t\t}\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][0].x, data[i][1].y), Point(data[i][1].x, data[i][1].y)));\n\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\tif(lt(r,Max)) Max = r;\n\t\t}\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][1].x, data[i][0].y), Point(data[i][1].x, data[i][1].y)));\n\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\tif(lt(r,Max)) Max = r;\n\t\t}\n\t}\n\tprintf(\"%llf\\n\", Max);\n}\n\nint main() {\n\twhile(true){\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tinput();\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define REPD(i,n) for(int i=(int)(n); i-->0;)\n#define REPI(i,a,b) for(int i=(int)(a); i<=(int)(b); i++)\n#define ALL(a) (a).begin(),(a).end()\n#define mp make_pair\n#define fst first\n#define snd second\n\n#define INFTY 1000000000\n#define EPS 1e-9\n#define PI 3.141592653589793\n\n#define INF (INFTY/3)\n\n#define rev(s) (string((s).rbegin(), (s).rend()))\n\ntypedef long long Int;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<double,double> pdd;\n\nvoid debug(vi v){ REP(i,v.size()) cout<<v[i]<<\" \"; cout<<endl; }\n\nint nextInt(){ int t; cin>>t; return t; }\n\ndefine ZEROP(x) (fabs(x) < EPS)\n#define EQ(x, y) ZEROP((x) - (y))\n#define LT(x, y) ((x) - (y) <= -EPS) // x < y\n#define LE(x, y) ((x) - (y) < +EPS) // x <= y\n#define SIGN(x) ((x)<-EPS?-1:((x)>EPS?+1:0))\n\ntypedef complex<double> P;\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nnamespace std {\n   bool operator < (const P& a, const P& b) {\n     return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n   }\n}\ndouble cross(const P& a, const P& b) {\n   return imag(conj(a)*b);\n} \ndouble dot(const P& a, const P& b) {\n   return real(conj(a)*b); \n}  \nstruct L : public vector<P> {\n  L() {}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  } \n};  \ntypedef vector<P> G;  \nstruct C {\n   P p; double r;\n   C(const P &p, double r) : p(p), r(r) { }\n}; \n\n\n#define MAXN 50\nint N;\nL sl; // start line\nint minx[MAXN];\nint miny[MAXN];\nint maxx[MAXN];\nint maxy[MAXN];\nint h[MAXN];\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (LT( 0, cross(b, c)) )   return +1;       // counter clockwise\n  if (LT( cross(b, c), 0) )   return -1;       // clockwise\n  if (LT( dot(b, c), 0) )     return +2;       // c--a--b on line\n  if (LT( norm(b), norm(c)) ) return -2;       // a--b--c on line\n  return 0;\n}\n\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n// USE IN THIS PROBLEM\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nbool covered(int sx,int sy,int ex,int ey,int ax,int ay,int bx,int by) {\n  return ax < sx && ay < sy && ex < bx && ey < by;\n}\n\n\ndouble solve() {\n  double r = INT_MAX;\n  REP(i,N) {\n    L l[]={L(P(minx[i],miny[i]),P(maxx[i],miny[i])),\n\t   L(P(maxx[i],miny[i]),P(maxx[i],maxy[i])),\n\t   L(P(maxx[i],maxy[i]),P(minx[i],maxy[i])),\n\t   L(P(minx[i],maxy[i]),P(minx[i],miny[i]))};\n    double mind = INT_MAX;\n    int mini; //min index\n    if(covered(real(sl[0]),imag(sl[0]),real(sl[1]),imag(sl[1]),\n\t       minx[i],miny[i],maxx[i],maxy[i])) return 0.0;\n    REP(j,4) {\n      double dd = distanceSS(l[j],sl);\n      if(LT(dd,mind)) {\n\tmind = dd;\n\tmini = j;\n      }\n    }\n    double r2;\n    //printf(\"mind=%lf\\n\",mind);\n    if(LE(mind,h[i])) { // mind <= h[i]\n      r2=mind;\n    } else {\n      r2=(h[i]*h[i] + mind*mind) / (2*h[i]);\n    }\n    r=min(r,r2);\n    //printf(\"r=%lf\\n\",r);\n  }\n  return r;\n}\n\t\nmain() {\n  while(cin>>N,N) {\n    int sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    sl = L(P(sx,sy),P(ex,ey));\n    REP(i,N)\n      cin>>minx[i]>>miny[i]>>maxx[i]>>maxy[i]>>h[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return conj(P(imag(a),real(a)));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\n\nFP lldist(line a,line b){\n  return\n    min4(lpdist(a,b.F),lpdist(a,b.S),\n         lpdist(b,a.F),lpdist(b,a.S));\n}\n\n\n\n\nint n;\nint sx,sy,ex,ey;\nint minx[50],miny[50],maxx[50],maxy[50],h[50];\n\nvoid solve(){\n  cin >> sx >> sy >> ex >> ey;\n\n  rep(i,n)\n    cin >> minx[i] >> miny[i] >> maxx[i] >> maxy[i] >> h[i];\n\n  double r=100000;\n  P ort(ortho(pt(ex,ey)-pt(sx,sy)));\n  \n  rep(i,n){\n    if(minx[i]<=sx && sx<=maxx[i] &&\n       miny[i]<=sy && sy<=maxy[i]){\n      cout << 0 << endl;\n      return;\n    }\n    line ball(pt(sx,sy),pt(ex,ey));\n    P a(minx[i],miny[i]),b(minx[i],maxy[i]);\n    P c(maxx[i],miny[i]),d(maxx[i],maxy[i]);\n    if(iscrs(line(a,b),ball) ||\n       iscrs(line(b,d),ball) ||\n       iscrs(line(d,c),ball) ||\n       iscrs(line(c,a),ball)){\n      cout << 0 << endl;\n      return;\n    }\n\n    P p[]={a,b,c,d};\n    double mindi=lldist(line(a,b),ball);\n    mindi=min(mindi,lldist(line(b,d),ball));\n    mindi=min(mindi,lldist(line(d,c),ball));\n    mindi=min(mindi,lldist(line(c,a),ball));\n    if(mindi>h[i]) r=min(r,(mindi*mindi+h[i]*h[i])/(h[i]*2));\n    else r=min(r,mindi);\n  }\n  \n  printf(\"%.8f\\n\",r);\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n && n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector< vector<int> > vvi;\n\ntypedef pair< double, int > pdi;\ntypedef complex<double> P;\n\ndouble dot(P a, P b) {\n\treturn real(conj(a)*b);\n}\n\ndouble cross(P a, P b) {\n\treturn imag(conj(a)*b);\n}\n\nP projection(P s, P e, P p) {\n\tdouble t = dot(p-s, s-e) / norm(s-e);\n\treturn s + t*(s-e);\n}\n\nbool intersectSP(P s, P e, P r) {\n\treturn abs(s-r) + abs(e-r) - abs(e-s) < 1e-5;\n}\n\n// ??????s-e ??¨ ???(x,y) ????????¢\ndouble dist(P s, P e, int x, int y) {\n\tP p(x,y);\n\tP r = projection(s, e, p);\n\tif( intersectSP(s, e, r) ) return abs(r-p);\n\treturn min( abs(s-p), abs(e-p) );\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(P s, P e, P p, P q) {\n\treturn ccw(s,e,p) * ccw(s,e,q) <= 0 &&\n\t\t   ccw(p,q,s) * ccw(p,q,e) <= 0;\n}\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint sx, sy, ex, ey;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tP s(sx,sy), e(ex,ey);\n\t\tvector<pdi> v;\n\t\tbool err = false;\n\t\trep(i, n) {\n\t\t\tint ix, iy, ax, ay, h;\n\t\t\tcin >> ix >> iy >> ax >> ay >> h;\n\t\t\tP p0(ix,iy), p1(ax,iy), p2(ax,ay), p3(ix,ay);\n\t\t\tv.push_back(pdi(dist(s, e, ix, iy), h));\n\t\t\tv.push_back(pdi(dist(s, e, ax, iy), h));\n\t\t\tv.push_back(pdi(dist(s, e, ax, ay), h));\n\t\t\tv.push_back(pdi(dist(s, e, ix, ay), h));\n\t\t\tv.push_back(pdi(dist(p0, p1, sx, sy), h));\n\t\t\tv.push_back(pdi(dist(p1, p2, sx, sy), h));\n\t\t\tv.push_back(pdi(dist(p2, p3, sx, sy), h));\n\t\t\tv.push_back(pdi(dist(p3, p0, sx, sy), h));\n\t\t\tv.push_back(pdi(dist(p0, p1, ex, ey), h));\n\t\t\tv.push_back(pdi(dist(p1, p2, ex, ey), h));\n\t\t\tv.push_back(pdi(dist(p2, p3, ex, ey), h));\n\t\t\tv.push_back(pdi(dist(p3, p0, ex, ey), h));\n\n\t\t\tif(!err) {\n\t\t\t\tif( ix < sx && ix < ex && sx < ax && ex < ax &&\n\t\t\t\t\t\tiy < sy && iy < ey && sy < ay && ey < ay ) {\n\t\t\t\t\terr = true;\n\t\t\t\t}\n\t\t\t\telse if( intersectSS(s, e, p0, p1) ||\n\t\t\t\t\t\tintersectSS(s, e, p1, p2) ||\n\t\t\t\t\t\tintersectSS(s, e, p2, p3) ||\n\t\t\t\t\t\tintersectSS(s, e, p3, p0) ) {\n\t\t\t\t\terr = true;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif(err) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdouble l=0.0, r=1000.0;\n\t\twhile(r-l > 1e-5) {\n\t\t\tdouble c = (l+r)/2.0;\n\t\t\tbool ok = true;\n\t\t\trep(i, v.size()) {\n\t\t\t\tif( v[i].first <= c ) {\n\t\t\t\t\tdouble h = c - sqrt(c*c - v[i].first*v[i].first);\n\t\t\t\t\tif( h < v[i].second ) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) {\n\t\t\t\tl = c;\n\t\t\t}else {\n\t\t\t\tr = c - 1e-5;\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(7) << l << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <complex>\nusing namespace std;\n#ifdef DEBUGRUN\n#define log(a) (cerr<<#a\"=\"<<a<<endl)\n#else\n#define log(a) ((void)0)\n#endif\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\ntypedef long long Int;\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\ndouble sq(double a) { return a*a; }\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\nint ccw(const P& a, P b, P c) {\n    b -= a, c -= a;\n    if(cross(b, c)>0) return 1;\n    if(cross(b, c)<0) return -1;\n    if(dot(b, c)<0) return 2;\n    if(norm(b)<norm(c)) return -2;\n    return 0;\n}\nbool crossing(const P& l0, const P& l1, const P& m0, const P& m1) {\n    return ccw(m0, m1, l0)*ccw(m0, m1, l1)<=0\n        && ccw(l0, l1, m0)*ccw(l0, l1, m1)<=0;\n}\nP projection(const P& l0, const P& l1, const P& p) {\n    double t = dot(p-l0, l0-l1) / norm(l0-l1);\n    return l0 + t*(l0-l1);\n}\nbool intersectSP(const P& s0, const P& s1, const P& p) {\n    return abs(s0-p)+abs(s1-p)-abs(s1-s0)<EPS;\n}\ndouble distanceSP(const P& s0, const P& s1, const P& p) {\n    const P r(projection(s0, s1, p));\n    if(intersectSP(s0, s1, r)) return abs(r-p);\n    return min(abs(s0-p), abs(s1-p));\n}\ndouble distanceSS(const P& s0, const P& s1, const P& t0, const P& t1) {\n    if(crossing(s0, s1, t0, t1)) return 0;\n    return min(min(distanceSP(s0, s1, t0), distanceSP(s0, s1, t1)),\n               min(distanceSP(t0, t1, s0), distanceSP(t0, t1, s1)));\n}\n\nint n, sx, sy, ex, ey;\nint xa[100], ya[100], xb[100], yb[100], h[100];\nP sp, ep, ps[100][4];\n\nbool check() {\n    rep(i, n) {\n        rep(j, 4) {\n            if(crossing(sp, ep, ps[i][j], ps[i][(j+1)%4])) return false;\n        }\n        if(crossing(sp, ep, ps[i][0], ps[i][2])) return false;\n        if(crossing(sp, ep, ps[i][1], ps[i][3])) return false;\n        if(xa[i]<=sx && sx<=xb[i] && ya[i]<=sy && sy<=yb[i]) return false;\n        if(xa[i]<=ex && ex<=xb[i] && ya[i]<=ey && ey<=yb[i]) return false;\n    }\n    return true;\n}\n\nbool can(double r) {\n    rep(i, n) {\n        const double lim = h[i]>=r ? r : sqrt(sq(r)-sq(r-h[i]));\n        rep(j, 4) {\n            if(distanceSS(sp, ep, ps[i][j], ps[i][(j+1)%4])<lim) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d\", &n);\n        if(n==0) return 0;\n        scanf(\"%d%d%d%d\", &sx, &sy, &ex, &ey);\n        rep(i, n) scanf(\"%d%d%d%d%d\", xa+i, ya+i, xb+i, yb+i, h+i);\n        sp = P(sx, sy);\n        ep = P(ex, ey);\n        rep(i, n) {\n            ps[i][0] = P(xa[i], ya[i]);\n            ps[i][1] = P(xa[i], yb[i]);\n            ps[i][2] = P(xb[i], yb[i]);\n            ps[i][3] = P(xb[i], ya[i]);\n        }\n        double ans = 0;\n        if(check()) {\n            log(true);\n            double l=0, r=1000;\n            rep(_, 200) {\n                const double mid=(l+r)/2;\n                if(can(mid)) l=mid;\n                else r=mid;\n            }\n            ans = l;\n        }\n        printf(\"%.9f\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#define _USE_MATH_DEFINES\n#include<cmath>\nusing namespace std;\n\n\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//誤差を考慮して足し算\ndouble add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2次元ベクトル\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator / (double d){\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p){//内積\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){//外積\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tbool equal(P p){\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\n};\n//typedef pair<P,P> Line;\n\n//線分p1-p2上に点qがあるか判定\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//直線p1-p2と直線q1-q2の交点\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*( (q2-q1).det(q1-p1)/(q2-q1).det(p2-p1) );\n}\n\n\n//線分p1-p2と線分q1-q2が交差するか\nbool intersecting(P p1,P p2,P q1,P q2){\n\tif(on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2))return true;\n\tif((p1-p2).det(q1-q2)==0 )return false;//平行\n\tP a=intersection(p1,p2,q1,q2);\n\treturn on_seg(p1,p2,a) && on_seg(q1,q2,a);\n}\n//原点中心回転\nP rotate(P p,double rad){\n\tdouble s=sin(rad),c=cos(rad);\n\treturn P(c*p.x-s*p.y, s*p.x+c*p.y);\n}\n//originを中心に回転\nP rotate(P p,double rad,P origin){\n\treturn origin + rotate(p - origin,rad);\n}\n//二点間の距離\ndouble dist(P p,P q){\n\tp = p-q;\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\n//単位ベクトルに変換\nP to_unit(P p){\n\tdouble d = sqrt(p.x*p.x+p.y*p.y);\n\treturn p/d;\n}\n//円同士の交点を計算\npair<P,P> circle_intersection(double x1,double y1,double r1,double x2,double y2,double r2){\n\tdouble rad = atan2(y2-y1,x2-x1);\n\tx2 -= x1;\n\ty2 -= y1;\n\tP tmp = rotate(P(x2,y2),-rad);\n\tx2 = tmp.x;\n\ty2 = tmp.y;\n\tdouble x = (r1*r1-r2*r2+x2*x2)/(2*x2);\n\tif(abs(r1) < abs(x))return make_pair(P(0,0),P(0,0));//交点なし\n\tdouble y = sqrt(r1*r1-x*x);\n\treturn make_pair( P(x1,y1)+rotate(P(x,y),rad) ,  P(x1,y1)+rotate(P(x,-y),rad) );\n}\n//2点を通る円の中心座標\npair<P,P> circle_on_2P(P p,P q,double r){\n\tif(2*r < dist(p,q))return make_pair(P(0,0),P(0,0));//解なし\n\tif(q.x < p.x)swap(p,q);\n\tq = q - p;\n\tdouble rad = atan2(q.y,q.x);\n\tP tmp = rotate(q,-rad);\n\tdouble x = tmp.x/2;\n\tdouble y = sqrt(4*r*r-tmp.x*tmp.x)/2;\n\treturn make_pair( p+rotate(P(x,y),rad) ,  p+rotate(P(x,-y),rad) );\n}\n//線分と点の距離\ndouble dist_LP(P p1,P p2,P q){\n\tdouble dx,dy;\n\tdx = p1.x-p2.x;\n\tdy = p1.y-p2.y;\n\tdouble d = min(dist(p1,q) ,dist(p2,q));\n\tpair<P,P> normal = make_pair(q+to_unit(P(-dy,dx))*d ,q+to_unit(P(dy,-dx))*d);//法線ベクトル\n\tif(intersecting(p1,p2,normal.first,normal.second)){\n\t\treturn dist(q, intersection(p1,p2,normal.first,normal.second));\n\t}\n\treturn d;\n}\n//線分間の距離\ndouble dist_LL(P p1,P p2,P q1,P q2){\n\tif(intersecting(p1,p2,q1,q2))return 0;\n\treturn min( min(dist_LP(p1,p2,q1),dist_LP(p1,p2,q2))\n\t\t,min(dist_LP(q1,q2,p1),dist_LP(q1,q2,p2)) );\n}\n//ラジアンに変換\ndouble radian(double angle){\n\treturn angle/180.0*M_PI;\n}\n\n\n\nint minx[50],miny[50],maxx[50],maxy[50],h[50];\nint n;\nint sx,sy,ex,ey;\n\nbool in_block(int x,int y,int minx,int miny,int maxx,int maxy){\n\treturn minx<=x&&x<=maxx&&miny<=y&&y<=maxy;\n}\nbool on_line(){//ライン上にブロックがある\n\tP s(sx,sy),e(ex,ey);\n\tfor(int i=0;i<n;i++){\n\t\tP a(minx[i],miny[i]),b(minx[i],maxy[i]),c(maxx[i],miny[i]),d(maxx[i],maxy[i]);\n\t\tif(intersecting(s,e,a,b))return true;\n\t\tif(intersecting(s,e,a,c))return true;\n\t\tif(intersecting(s,e,b,d))return true;\n\t\tif(intersecting(s,e,c,d))return true;\n\t\tif(in_block(sx,sy,minx[i],miny[i],maxx[i],maxy[i]))return true;\n\t\tif(in_block(ex,ey,minx[i],miny[i],maxx[i],maxy[i]))return true;\n\t}\n\treturn false;\n}\ndouble square(double a){\n\treturn a*a;\n}\ndouble min(double a,double b){\n\treturn a<b?a:b;\n}\nbool f(double r){\n\tP s(sx,sy),e(ex,ey);\n\tfor(int i=0;i<n;i++){\n\t\tP a(minx[i],miny[i]),b(minx[i],maxy[i]),c(maxx[i],miny[i]),d(maxx[i],maxy[i]);\n\t\tdouble hei = min(r,h[i]);\n\t\tdouble mind=INF;\n\t\tmind = min(mind,dist_LL(s,e,a,b));\n\t\tmind = min(mind,dist_LL(s,e,a,c));\n\t\tmind = min(mind,dist_LL(s,e,b,d));\n\t\tmind = min(mind,dist_LL(s,e,c,d));\n\t\tdouble di = sqrt(square(mind)+square(r-hei));\n\t\tif(di<r)return false;\n\t}\n\treturn true;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tcin>>sx>>sy>>ex>>ey;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>minx[i]>>miny[i]>>maxx[i]>>maxy[i]>>h[i];\n\t\t}\n\t\tif(on_line()){\n\t\t\tprintf(\"%.4f\\n\",0.0);\n\t\t}else{\n\t\t\tdouble lb=0,ub=1001;\n\t\t\tfor(int i=0;i<25;i++){\n\t\t\t\tdouble m=(lb+ub)/2;\n\t\t\t\tif(f(m))lb=m;\n\t\t\t\telse ub=m;\n\t\t\t}\n\t\t\tprintf(\"%.4f\\n\",lb);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\nclass Circle{\n\tpublic:\n\t\tPoint c;\n\t\tdouble r;\n\t\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n\treturn (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n\treturn isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n\treturn isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n\treturn EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n\treturn isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n\treturn distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n\tif ( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif ( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n\treturn distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n\treturn isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n\tVector base = b2 - b1;\n\tdouble d1 = abs(cross(base, a1 - b1));\n\tdouble d2 = abs(cross(base, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n\treturn intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n\treturn !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n\treturn isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n\tPoint a = a2 - a1; Point b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n\treturn intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n\tif(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n\treturn min(\n\t\t\tmin(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n\t\t\t\tdistanceLsPoint(s1.p1, s1.p2, s2.p2)),\n\t\t\tmin(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n\t\t\t\tdistanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n\tSegment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n\treturn distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n\treturn Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n\tdouble x, y;\n\tx = p.real() * cos(angle) - p.imag() * sin(angle);\n\ty = p.real() * sin(angle) + p.imag() * cos(angle);\n\treturn Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n\tint n = g.size();\n\tbool x = false;\n\trep(i,n){\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n\t\tif( a.imag() > b.imag() ) swap(a, b);\n\t\tif( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n\t}\n\treturn ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n\tPolygon u;\n\tif( s.size() < 3 ) return s;\n\tsort(s.begin(), s.end());\n\n\trange(i,0,s.size()){\n\t\t//== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n\t\t//!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n\t\tfor(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.emplace_back(s[i]);\n\t}\n\n\tfor(int i = s.size() - 2; i >= 0; i--){\n\t\t//????????? == ??¨ != ????????´??????\n\t\tfor(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.emplace_back(s[i]);\n\t}\n\n\treverse(u.begin(), u.end());\n\tu.pop_back();\n\n\t//?????????????????????????????§??????????????????????????????????¨??????????????????????\n\t/*\n\t   int i = 0;\n\t   while(i < u.size() - 1){\n\t   if(u[i].imag() > u[i + 1].imag()){\n\t   u.emplace_back(u[i]);\n\t   u.erase(u.begin());\n\t   continue;\n\t   }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n\t   u.emplace_back(u[i]);\n\t   u.erase(u.begin());\n\t   continue;\n\t   }\n\t   break;\n\t   }\n\t   */\n\n\treturn u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n\tPolygon s = convexHull(p);\n\tint n = s.size();\n\n\tif(n == 2) return abs(s[1] - s[0]);\n\n\tint i = 0, j = 0;\n\trep(k,n){\n\t\tif(not (s[i] < s[k])) i = k;\n\t\tif(s[j] < s[k]) j = k;\n\t}\n\n\tdouble ret = 0.0;\n\tint is = i, js = j;\n\n\twhile(i != js || j != is){\n\t\tret = max(ret, abs(s[i] - s[j]));\n\t\tif(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n\t\t\ti = (i + 1) % n;\n\t\t}else{\n\t\t\tj = (j + 1) % n;\n\t\t}\n\t}\n\treturn ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n\tdouble A = cross(a.p2 - a.p1, b.p2 - b.p1);\n\tdouble B = cross(a.p2 - a.p1, a.p2 - b.p1);\n\tif(abs(A) < EPS && abs(B) < EPS) return b.p1;\n\treturn b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n\tPolygon q;\n\trep(i,p.size()){\n\t\tPoint a = p[i], b = p[(i + 1) % p.size()];\n\t\tif (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\tq.emplace_back(getCrossPointLL(Line{a, b}, l));\n\t\t}\n\t}\n\treturn q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n\tdouble w, x, y, z;\n\tw = b.real()-a.real();\n\tx = b.imag()-a.imag();\n\ty = c.real()-a.real();\n\tz = c.imag()-a.imag();\n\treturn abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n\tint n = g.size();\n\tdouble ret = 0.0;\n\trep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n\treturn abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n\tint n = g.size();\n\trep(i,n){\n\t\tif(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n\t}\n\treturn true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n\tint cnt = 0;\n\trep(i,p.size()){\n\t\tif(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n\t}\n\treturn cnt / 2 + 1;\n}\n\n//????§???¢??????????±???¨??????????????§?¨?\nPoint pointSymmetry(Polygon g){\n\tint size = g.size() / 2;\n\tif(g.size() % 2) return Point{INF,INF};\n\n\tset<Point> s;\n\trep(i,size){\n\t\trep(j,size){\n\t\t\tif(i == j) continue;\n\t\t\ts.insert(intersectionLs(g[i], g[i + size], g[j], g[j + size]));\n\t\t}\n\t}\n\tif(s.size() > 1) return Point{INF,INF};\n\treturn *s.begin();\n}\n\ninline Segment inputSegment(){\n\tdouble a, b, c, d;\n\tcin >> a >> b >> c >> d;\n\treturn Segment{Point{a,b}, Point{c,d}};\n}\n\nvoid inputRect(Point r[4], double& h){\n\tdouble a, b, c, d;\n\tcin >> a >> b >> c >> d >> h;\n\tr[0] = Point{a,b};\n\tr[1] = Point{c,b};\n\tr[2] = Point{c,d};\n\tr[3] = Point{a,d};\n}\n\nbool isCross(Segment s1, Segment s2, Segment seg){\n\tbool res = false;\n\tres |= isIntersectedLs(s1, seg);\n\tres |= isIntersectedLs(s2, seg);\n\treturn res;\n}\n\nint n;\nbool isZero(const Point r[55][4], const Segment seg){\n\tbool res = false;\n\trep(i,n){\n\t\tres |= isCross(Segment{r[i][0], r[i][2]}, Segment{r[i][1], r[i][3]}, seg);\n\t}\n\treturn res;\n}\n\ndouble length(const double r, const Segment seg, const Segment e, const double h){\n\tdouble dist = distanceLL(seg, e);\n\t//show(dist)\n\tif(r <= h) return dist;\n\n\tdouble high = abs(r - h);\n\t//show(high)\n\t//cout << p.real() << ' ' << p.imag() << endl;\n\t//cout << h << endl;\n\t//show(r)\n\t//show(sqrt(dist * dist + high * high))\n\t//show( sqrt(dist * dist + high * high))\n\treturn sqrt(dist * dist + high * high);\n}\n\nbool C(const double r, const Segment seg, const Point rect[55][4], const double h[55]){\n\trep(i,n){\n\t\trep(j,4){ //????????????\n\t\t\tSegment edge = Segment{Point{rect[i][j]}, Point{rect[i][(j + 1) % 2]}};\n\t\t\tif(length(r, seg, edge, h[i]) <= r + EPS){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble binarySearch(const Segment seg, const Point rect[55][4], const double h[55]){\n\tdouble right = 1000, left = 0;\n\trep(i,100){\n\t\tdouble mid = (right + left ) / 2;\n\t\tif(C(mid, seg, rect, h)) left = mid;\n\t\telse right = mid;\n\t}\n\treturn left;\n}\n\nint main(){\n\twhile(cin >> n,n){\n\t\tSegment seg = inputSegment();\n\t\tPoint rect[55][4];\n\t\tdouble h[55];\n\t\trep(i,n) inputRect(rect[i], h[i]);\n\n\t\t//bool aa = C(1.5,seg,rect,h);\n\t\t//show(distanceLL(seg, Segment{rect[0][1], rect[0][2]}));\n\t\t//show(aa)\n\t\t//return 0;\n\n\t\tif(isZero(rect, seg)){\n\t\t\tcout << 0 << endl;\n\t\t}else{\n\t\t\tcout << fixed << setprecision(5) << binarySearch(seg, rect, h) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define reps(i,a,b) for(int i=(a); i<(b); ++i)\n#define rep(i,n) reps(i,0,n)\n\n#define fs first\n#define sc second\n\ntypedef double R;\ntypedef complex<R> P;\ntypedef pair<P, P> S;\n\n#define X real()\n#define Y imag()\n\nconst R INFR = 1e21;\nconst R eps = 1e-9;\n\n\n\nR inp(P a, P b){\n\treturn (conj(a)*b).X;\n}\n\nR outp(P a, P b){\n\treturn (conj(a)*b).Y;\n}\n\nint sig(R x){\n\treturn (abs(x) < eps ? 0 : x > 0 ? 1 : -1);\n}\nint cww (P s, P t, P p, int adv){\n\tint res = sig(outp(t-s, p-s));\n\tif(res || !adv) return res;\n\tif(inp(t-s, p-s) < -eps) return -2;\n\tif(inp(s-t, p-t) < -eps) return 2;\n\treturn 0;\n}\n\nbool inter(P a, P b, P c, P d){\n\tint p = cww(c, d, a, 1) * cww(c, d, b, 1);\n\tint q = cww(a, b, c, 1) * cww(a, b, d, 1);\n\treturn p<=0 && q <=0;\n}\n\n\n\nR dist(P a, P b, P p){\n\tif(inp(p-a, b-a) < eps) return abs(p-a);\n\tif(inp(p-b, a-b) < eps) return abs(p-b);\n\treturn abs(outp(b-a, p-a))/abs(b-a);\n}\n\nbool f(int h, R d, R r){\n\tif(h >= r){\n\t\tif( d<r ) return true;\n\t}else{\n\t\tif(r>=(h*h+d*d)/(2*h)) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(;;){\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N==0) break;\n\n\t\tint sx,sy,ex,ey;\n\t\tcin >> sx >> sy >> ex >> ey;\n\n\t\tP s(sx,sy), e(ex,ey);\n\t\tS se(s,e);\n\n\t\tvector<S> ps;\n\t\tvector<int> Hs;\n\t\t\n\t\tbool F = false;\n\t\trep(i, N){\n\t\t\tint x1, y1, x2, y2, h;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> h;\n\t\t\t\n\t\t\tps.push_back({{x1,y1},{x1,y2}});\n\t\t\tps.push_back({{x1,y2},{x2,y2}});\n\t\t\tps.push_back({{x2,y2},{x2,y1}});\n\t\t\tps.push_back({{x2,y1},{x1,y1}});\n\t\t\tHs.push_back(h);\n\t\t\tHs.push_back(h);\n\t\t\tHs.push_back(h);\n\t\t\tHs.push_back(h);\n\t\t\tbool FF;\n\t\t\tFF = true;\n\t\t\trep(j,4) if(cww(ps[i*4+j].fs, ps[i*4+j].sc, s,0) > 0) FF= false;\n\t\t\tif(FF) F=true;\n\n\t\t\tFF = true;\n\t\t\trep(j,4) if(cww(ps[i*4+j].fs, ps[i*4+j].sc, s,0) < 0) FF= false;\n\t\t\tif(FF) F=true;\n\n\t\t\tFF = true;\n\t\t\trep(j,4) if(cww(ps[i*4+j].fs, ps[i*4+j].sc, e,0) > 0) FF= false;\n\t\t\tif(FF) F=true;\n\n\t\t\tFF = true;\n\t\t\trep(j,4) if(cww(ps[i*4+j].fs, ps[i*4+j].sc, e, 0) < 0) FF= false;\n\t\t\tif(FF) F=true;\n\t\t}\n\t\tif(F){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\tfor(auto s:ps) printf(\"line(%lf, %lf, %lf, %lf)\\n\", s.fs.X, s.fs.Y, s.sc.X, s.sc.Y);\n\t\tprintf(\"circle(%d, %d, 5 )\\n\", sx,sy);\n\t\tprintf(\"circle(%d, %d, 10)\\n\", ex,ey);\n\t\tbreak;\n\t\t//*/\n\n\n\t\tR a=0, b=1e5;\n\t\trep(foobar, 60){\n\t\t\tR r=(a+b)/2;\n\n\t\t\tbool g = [&](){\n\t\t\t\trep(i, (int)ps.size()){\n\t\t\t\t\tS p = ps[i];\n\t\t\t\t\tint h = Hs[i];\n\t\t\t\t\tR d = dist(p.fs, p.sc, s);\n\t\t\t\t\t//cout << d << endl;\n\t\t\t\t\tif(f(h, d, r)) return false;\n\n\t\t\t\t\td = dist(p.fs, p.sc, e);\n\t\t\t\t\tif(f(h, d, r)) return false;\n\n\t\t\t\t\td = dist(s, e, p.fs);\n\t\t\t\t\tif(f(h, d, r)) return false;\n\n\t\t\t\t\tif(inter(s, e, p.fs, p.sc)) return false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}();\n\t\t\tif(g) a = r;\n\t\t\telse  b = r;\n\n\n\t\t\t//printf(\"---------------------\\n\");\n\t\t\t//break;\n\t\t}\n\t\tprintf(\"%.10lf\\n\",a);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ninline double sq(double x) { return x * x; }\n\nstruct point {\n    double x, y, z;\n    point() {}\n    point(double x, double y, double z): x(x), y(y), z(z) {}\n    point operator + (const point& o) const { return point(x+o.x, y+o.y, z+o.z); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y, z-o.z); }\n    point operator * (const double a) const { return point(x*a,   y*a,   z*a); }\n};\n\ndouble fabs(point p) { return sqrt(sq(p.x) + sq(p.y) + sq(p.z)); }\ndouble dist(point p, point q) { return fabs(p - q); }\ndouble dot(point p, point q) { return p.x*q.x + p.y*q.y + p.z*q.z; }\npoint cross(point p, point q) {\n    return point(\n        p.y*q.z - p.z*q.y,\n        p.z*q.x - p.x*q.z,\n        p.x*q.y - p.y*q.x\n    );\n}\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\ndouble dist_point_line(point p, line l) {\n    if (dot(l.b - l.a, p - l.a) >= 0 && dot(l.a - l.b, p - l.b) >= 0) {\n        point h = l.a + (l.b - l.a) * (dot(l.b - l.a, p - l.a) / sq(fabs(l.b - l.a)));\n        return dist(p, h);\n    }\n\n    return min(dist(p, l.a), dist(p, l.b));\n}\n\nint N; double Sx, Sy, Ex, Ey;\nvector<vector<point>> rects;\nvector<line> vs;\n\ndouble solve() {\n    line c(point(Sx, Sy, 0), point(Ex, Ey, 0));\n    for (vector<point> r : rects) {\n        for (int i = 0; i < r.size(); ++i) {\n            for (int j = i+1; j < r.size(); ++j) {\n                double c1 = cross(c.b - c.a, r[i] - c.a).z * cross(c.b - c.a, r[j] - c.a).z;\n                double c2 = cross(r[j] - r[i], c.a - r[i]).z * cross(r[j] - r[i], c.b - r[i]).z;\n                if (c1 < 0 && c2 < 0) {\n                    return 0;\n                } else if (c1 * c2 == 0) {\n                    double d1 = dist_point_line(r[i], c);  \n                    double d2 = dist_point_line(r[j], c);  \n                    double d3 = dist_point_line(c.a, line(r[i], r[j]));  \n                    double d4 = dist_point_line(c.b, line(r[i], r[j]));  \n                    if (min(min(d1, d2), min(d3, d4)) == 0) {\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n\n    double l = 0, r = 1050;\n    for (int g = 0; g < 100; ++g) {\n        double m = (l + r) / 2;\n\n        line c(point(Sx, Sy, m), point(Ex, Ey, m));\n\n        bool ok = true;\n        for (line p : vs) {\n            if (dist_point_line(p.a, c) <= m || dist_point_line(p.b, c) <= m)\n                ok = false;\n            if (dist_point_line(c.a, p) <= m || dist_point_line(c.b, p) <= m)\n                ok = false;\n            if (m < p.a.z) p.a.z = p.b.z = m;\n            if (dist_point_line(p.a, c) <= m || dist_point_line(p.b, c) <= m)\n                ok = false;\n            if (dist_point_line(c.a, p) <= m || dist_point_line(c.b, p) <= m)\n                ok = false;\n        }\n\n        (ok ? l : r) = m;\n    }\n\n    return (l + r) / 2;\n}\n\nint main(void) {\n    cout << fixed << setprecision(4);\n    while (true) {\n        cin >> N; if (N == 0) break;\n        cin >> Sx >> Sy >> Ex >> Ey;\n        vs.clear();\n        rects.clear();\n        for (int i = 0; i < N; ++i) {\n            double minx, miny, maxx, maxy, h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            vs.emplace_back(point(minx, miny, h), point(minx, maxy, h));\n            vs.emplace_back(point(minx, miny, h), point(maxx, miny, h));\n            vs.emplace_back(point(minx, maxy, h), point(maxx, maxy, h));\n            vs.emplace_back(point(maxx, miny, h), point(maxx, maxy, h));\n\n            vector<point> vv;\n            vv.emplace_back(minx, miny, h);\n            vv.emplace_back(minx, maxy, h);\n            vv.emplace_back(maxx, miny, h);\n            vv.emplace_back(maxx, maxy, h);\n            rects.push_back(vv);\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n#include<cmath>\n\n#define EPS (1e-10)\n#define fs first\n#define sc second\n\nusing namespace std;\n\ntypedef complex<int> P;\ntypedef pair<P,P> L;\n\n//for vector\n\nint dot(P x,P y){return real(conj(x)*y);}\n\nint cross(P x,P y){return imag(conj(x)*y);}\n\ndouble dis(P x, P y){\n  return sqrt( (real(x)-real(y))*(real(x)-real(y)) \n\t       + (imag(x)-imag(y))*(imag(x)-imag(y)) );\n}\n\n//for line(segment)\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ndouble seg_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return dis(x,a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return dis(x,a.sc);\n  return abs((double)cross(a.sc-a.fs,x-a.fs))/dis(a.sc,a.fs);\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ndouble seg_close(L a, L b){\n  double res = 1e10;\n  res = min(res, seg_dis(a,b.first));\n  res = min(res, seg_dis(a,b.second));\n  res = min(res, seg_dis(b,a.first));\n  res = min(res, seg_dis(b,a.second));\n  return res;\n}\n\nint main(){\n  int n,sx,sy,ex,ey;\n  int x1,y1,x2,y2,h;\n\n  while(cin >> n ,n){\n    cin >> sx >> sy >> ex >> ey;\n    L l = L(P(sx,sy),P(ex,ey));\n\n    double r = 100000.0;\n    for(int i=0;i<n;i++){\n      cin >> x1 >> y1 >> x2 >> y2 >> h;\n      if(r<EPS)continue;\n\n      if(x1>x2)swap(x1,x2);\n      if(y1>y2)swap(y1,y2);\n      L A = L(P(x1,y1),P(x1,y2));\n      L B = L(P(x1,y2),P(x2,y2));\n      L C = L(P(x2,y2),P(x2,y1));\n      L D = L(P(x2,y1),P(x1,y1));\n\n      if(is_cp(l,A))r = 0.0;\n      else if(is_cp(l,B))r = 0.0;\n      else if(is_cp(l,C))r = 0.0;\n      else if(is_cp(l,D))r = 0.0;\n      else if(x1<=sx && sx<=x2 && y1<=sy && sy<=y2)r = 0.0;\n      else{\n\tdouble dis = min(min(seg_close(l,A),seg_close(l,B)),\n\t\t\t min(seg_close(l,C),seg_close(l,D)));\n\tif(dis<h)r = min(r,dis);\n\telse r = min(r,(h*h+dis*dis)/(2*h));\n      }\n    }\n    cout << r << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double の切り替え cmathの関数はオーバーロードに対応しているので問題ない\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//誤差\n#define EQ(a,b) (abs((a)-(b)) < EPS)//２つの実数が等しいか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//２つのベクトルが等しいか\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){//内積ok\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){//外積ok\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nbool is_orthogonal(Line a,Line b){//2直線の直行判定ok\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2直線の並行判定ok\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n//////////////射影と反射\nPoint projection(Line l,Point p){//射影を求めるok\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//反射を求めるok\n    return p + (R)2.0 * (projection(l,p) - p);\n}\n\n\n\n////////////////////交差判定\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a→bで反時計周りに折れてb→c\n    if(cross(b,c) < -EPS) return -1;//a→bで時計周りに折れてb→c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(absじゃなくて二乗するのは差が出やすいから?)\n    return 0;//a--c--bまたはb==c\n}\n\nbool is_intersection_ll(Line l,Line m){//２つの直線が交わるかok\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //平行でない\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //平行だが同じ線\n}\n\nbool is_intersection_ls(Line l,Line s){//直線lと線分sが交わるか\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//直線lと点pが交わるか\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//２つの線分が交わるかok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//線分と点の交差判定 三角不等式の利用\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n\nbool intersection_cc(Circle c1,Circle c2){//２つの円の交差判定ok\n    return abs(c1.ft - c2.ft) - (c1.sd + c2.sd) < -EPS;\n}\n\n/*bool is_p_along_s(Point p,Line s) {//点が線分に沿った場所にあるか？\n    Point q = reflection(s,p);\n    return is_intersection_ss(Line(q,p),s) ;\n}*/\n\n\n/////////////距離\nR dis_lp(Line l,Point p){//直線lと点pの距離ok\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//２つの直線の距離\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//直線lと線分sの距離\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//線分sと点pの距離ok\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//２つの線分の距離ok\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n//////////////交点(交差する保証してないときは交差判定してからつかってね)\n\nPoint intersection_ll(Line l,Line m){//交差判定してるなら線分にも使えるok\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//同じ線\n    //if(abs(A) < EPS)assert(false);//並行で交点なし\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ２つの円の交点をLineに入れて返す(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))を満たす必要があるok\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ではオーバーロードが可能であるため、sqrt または float 型を受け取る long double のオーバーロードを呼び出すことができます。 C プログラムでは、sqrt は常に double を受け取って返します。\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\n/////////////////////////polygon\n\n#define currP(P,i) P[(i) % P.size()]//今の頂点\n#define nextP(P,i) P[((i) + 1)%P.size()]//次の頂点\n\nint is_contains_p_in_Poly(Poly po,Point p){//点が多角形の内部(1)、境界(-1)、外部(0)のどこにあるかを判定ok\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(EQ(cross(a,b),0.0) && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nbool is_intersection_Ps(Poly po,Line s) {//多角形と線分が交差するか\n    if(is_contains_p_in_Poly(po,s.ft) != 0 || is_contains_p_in_Poly(po,s.sd) != 0) {\n        return true;\n    }\n    REP(i,po.size()) {\n        if(is_intersection_ss(Line(currP(po,i),nextP(po,i)),Line(s))) {\n            return true;\n        }\n    }\n    return false;\n}\n\nR area2(Poly po){//多角形の面積の二倍を求めるok\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n\n\n\n///////////////////////////凸\n\nbool comp_complex_real(Point a,Point b){//x→yの辞書順ok\n    if(EQ(a.real(),b.real()))\n        return b.imag() - a.imag() > EPS;\n    return b.real() - a.real() > EPS;\n}\n\nPoly convex_hull(Poly ps){//凸包ok\n    int n = ps.size(),k = 0;\n    sort(ps.begin(),ps.end(),comp_complex_real);\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0 && ccw(ch[k - 2],ch[k - 1],ps[i]) > -2) --k;//３つ目の条件は180度を含むときのみ必要\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0 && ccw(ch[k - 2],ch[k - 1],ps[i]) > -2) --k;//上に同じ\n    ch.resize(k - 1);\n    return ch;\n}\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){//凸性判定時計回り反時計周りに対応\n    bool cl = false,ccl = false;\n    for(int i = 0;i < P.size();++i){\n        int c = ccw(prevP(P,i),currP(P,i),nextP(P,i));\n        if(c == -2)continue;//180度を含むときのみ　360度も含むときはc == -2 || c == 0\n        if(c == 1)ccl = true;\n        else if(c == 2)cl = true;\n        else return false;\n    }\n    return !(cl && ccl);\n}\n\nPoint s,e;\nPoly recs[100];\nint h[100];\nint n;\nconst R INF = 1e10;\n\nbool C(R x) {\n\n    Line l = Line(s,e);\n\n    for(int i = 0;i < n;i++) {\n        auto rec = recs[i];\n\n        R mind = INF;\n\n        for(auto p : rec) {\n            mind = min(dis_sp(l,p),mind);\n        }\n\n        REP(i,rec.size()) {\n            Line a = Line(rec[i],rec[(i+1)%rec.size()]);\n            mind = min(dis_sp(a,s),mind);\n            mind = min(dis_sp(a,e),mind);\n        }\n\n        if(mind > x) {\n            continue;\n        }\n        \n        R h2 = x - sqrt(x * x - mind * mind);\n\n        if(h2 < h[i])\n            return false;\n    }\n    return true;\n}\n\nint main(){\n    while(true) {\n        cin  >> n;\n        if(n == 0)break;\n\n        int sx,sy,ex,ey;\n        cin >> sx >> sy >> ex >> ey;\n        s = Point(sx,sy);\n        e = Point(ex,ey);\n        Line l = Line(s,e);\n\n        REP(i,n) {\n            int x[2],y[2];\n\n            cin >> x[0] >> y[0] >> x[1] >> y[1] >> h[i];\n\n            recs[i].clear();\n            recs[i].pb(Point(x[0],y[0]));\n            recs[i].pb(Point(x[0],y[1]));\n            recs[i].pb(Point(x[1],y[1]));\n            recs[i].pb(Point(x[1],y[0]));\n\n        }\n        bool f = false;\n        for(int i = 0;i < n;i++) {\n            auto rec = recs[i];\n            if(is_intersection_Ps(rec,l)) {\n                printf(\"0 \\n\");\n                f = true;\n                break;\n            }\n        }\n        if(f) continue;\n\n        R lb = 0,ub = 1000;\n        while(ub - lb > 1e-12) {\n            R mid = (ub + lb) / 2;\n            if(C(mid)) {\n                lb = mid;\n            }else {\n                ub = mid;\n            }\n        }\n        printf(\"%.12f\\n\",ub);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n\nusing namespace std;\nstatic const double EPS = 1e-6;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nstruct Point {\n  double x;\n  double y;\n  double z;\n  Point() {;}\n  Point(double x, double y, double z) : x(x), y(y), z(z) {;}\n};\n\nint n;\nPoint start, end;\nPoint box[100][4];\n\ninline double square(double x) { return x * x; }\ninline double dist(double x1, double y1, double z1, double x2, double y2, double z2) {\n  return sqrt(square(x1 - x2) + square(y1 - y2) + square(z1 - z2));\n}\n\ndouble ts2(double x, double y, double z) {\n  double lx = start.x;\n  double ly = start.y;\n  double rx = end.x;\n  double ry = end.y;\n  double r = start.z;\n  REP(iter, 30) {\n    double mlx = (lx * 2 + rx) / 3.0;\n    double mly = (ly * 2 + ry) / 3.0;\n    double mrx = (lx + rx * 2) / 3.0;\n    double mry = (ly + ry * 2) / 3.0;\n    double mlans = dist(x, y, z, mlx, mly, r);\n    double mrans = dist(x, y, z, mrx, mry, r);\n    if (mlans < r || mrans < r) {\n      return 0.0;\n    }\n    if (fabs(mlans - mrans) < EPS) { return mlans; }\n    if (mlans < mrans) {\n      rx = mrx; ry = mry;\n    } else {\n      lx = mlx; ly = mly;\n    }\n  }\n  return dist(lx, ly, r, x, y, z);\n}\n\nbool ts1(int i, int j, double h) {\n  int pj = j; int nj = (j + 1) % 4;\n  double lx = box[i][pj].x;\n  double ly = box[i][pj].y;\n  double rx = box[i][nj].x;\n  double ry = box[i][nj].y;\n  double z = min(box[i][0].z, h);\n  REP(iter, 30) {\n    double mlx = (lx * 2 + rx) / 3.0;\n    double mly = (ly * 2 + ry) / 3.0;\n    double mrx = (lx + rx * 2) / 3.0;\n    double mry = (ly + ry * 2) / 3.0;\n    double mlans = ts2(mlx, mly, z);\n    double mrans = ts2(mrx, mry, z);\n    if (mlans < h || mrans < h) {\n      return true;\n    }\n    if (fabs(mlans - mrans) < EPS) { return false; }\n    if (mlans < mrans) {\n      rx = mrx; ry = mry;\n    } else {\n      lx = mlx; ly = mly;\n    }\n  }\n  return false;\n}\n\nbool hit(double h) {\n  start.z = h;\n  end.z = h;\n  REP(i, n) {\n    REP(j, 4) {\n      if (ts1(i, j, h)) { return true; }\n    }\n  }\n  return false;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    double a, b, c, d, e;\n    scanf(\"%lf %lf %lf %lf\", &a, &b, &c, &d);\n    start = Point(a, b, 10000);\n    end = Point(c, d, 10000);\n    bool ok = true;\n    REP(i, n) {\n      scanf(\"%lf %lf %lf %lf %lf\", &a, &b, &c, &d, &e);\n      box[i][0] = Point(a, b, e);\n      box[i][1] = Point(a, d, e);\n      box[i][2] = Point(c, d, e);\n      box[i][3] = Point(c, b, e);\n      if (start.x >= a && start.x <= c && start.y >= b && start.y <= d) {\n        ok = false;\n      }\n    }\n    if (!ok) {\n      puts(\"0.00000\");\n      continue;\n    }\n    double l = 0.0;\n    double r = 1000.0;\n    while (r - l > EPS) {\n      double mid = (l + r) / 2.0;\n      if (hit(mid)) {\n        r = mid;\n      } else {\n        l = mid;\n      }\n    }\n    printf(\"%.5lf\\n\", l);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline point rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\ninline point rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ninline double angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ninline double abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ninline double norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ninline double cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ninline point projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\ninline bool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\ninline bool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ninline bool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline bool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\ninline bool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ninline double dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ninline double dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ninline double dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ninline double dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ninline double dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\ninline double dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ninline point crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn m.a + (m.b - m.a) * cross(l.b - l.a, l.a - m.a) * (1.0 / tmp);\n}\n\ninline point crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\n//先に，intersectを用いて交差判定を行うこと\ninline vector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ninline double areaTriangle(point a, point b, const point& c) {\n\ta = a - c;\n\tb = b - c;\n\treturn fabs(a.x * b.y - b.x * a.y) / 2.0;\n}\n\ninline double area(const polygon& p) {\n\tconst int num = p.size();\n\tif(num < 3)\n\t\treturn 0;\n\n\tif(num == 3)\n\t\treturn areaTriangle(p[0], p[1], p[2]);\n\n\tdouble res = cross(p[num - 1], p[0]);\n\tfor(int i = 1; i < num; ++i)\n\t\tres += cross(p[i - 1], p[i]);\n\n\treturn res * 0.5;\n}\n\n// L.aからL.bの方向を見た場合に，点aが左側に来る．\ninline line bisector(const point& a, const point& b) {\n\treturn line(point((a.x - a.y + b.x + b.y) / 2.0, (a.y + a.x + b.y - b.x) / 2.0),\n\t\t\t\tpoint((a.x + a.y + b.x - b.y) / 2.0, (a.y - a.x + b.y + b.x) / 2.0));\n}\n\n// L.aからL.bを向いた時の左側を残して切断する．\ninline polygon convex_cut(const polygon& p, const line& l) {\n\tconst int num = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < num; ++i) {\n\t\tconst int next = (i + 1) % num;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1)\n\t\t\tres.push_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0)\n\t\t\tres.push_back(crosspoint(l, line(p[i], p[next])));\n\t}\n\n\treturn res;\n}\n\nvector<point> tangent(const circle& c, const point& p) {\n\tconst double x = norm(p - c.c);\n\tdouble d = x - c.r * c.r;\n\tif(d < -EPS) return vector<point>();\n\td = max(d, 0.0);\n\tconst point q1 = (p - c.c) * (c.r * c.r / x);\n\tconst point q2 = rotate90((p - c.c) * (-c.r * sqrt(d) / x));\n\tvector<point> res;\n\tres.push_back(c.c + q1 - q2);\n\tres.push_back(c.c + q1 + q2);\n\treturn res;\n}\n\nvector<line> tangent(const circle &a, const circle& b) {\n\tvector<line> res;\n\tif(abs(a.r - b.r) < EPS) {\n\t\tpoint dir = b.c - a.c;\n\t\tdir = rotate90(dir * (a.r / abs(dir)));\n\t\tres.push_back(line(a.c + dir, b.c + dir));\n\t\tres.push_back(line(a.c - dir, b.c - dir));\n\t}\n\telse {\n\t\tpoint p = a.c * (-b.r) + b.c * a.r;\n\t\tp = p * (1.0 / (a.r - b.r));\n\t\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\t\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\t\tres.push_back(line(ps[i], qs[i]));\n\t}\n\n\tpoint p = a.c * b.r + b.c * a.r;\n\tp = p * (1.0 / (a.r + b.r));\n\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\tres.push_back(line(ps[i], qs[i]));\n\n\treturn res;\n}\n\nconst int MAX_N = 50;\nconst double INF = 2000;\nint n;\ndouble d[MAX_N];\nint h[MAX_N];\n\nbool check(double r) {\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(h[i] >= r) {\n\t\t\tif(d[i] < r)\n\t\t\t\treturn false;\n\t\t}\n\n\t\telse {\n\t\t\tconst double a = r - h[i];\n\t\t\tif(d[i] * d[i] + a * a < r * r)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\twhile(scanf(\"%d\", &n), n) {\n\t\tint sx, sy, ex, ey;\n\t\tscanf(\"%d %d %d %d\", &sx, &sy, &ex, &ey);\n\n\t\tsegment course(point(sx, sy), point(ex, ey));\n\n\t\tfill(d, d + n, INF);\n\t\tbool on = false;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint minX, minY, maxX, maxY;\n\t\t\tscanf(\"%d %d %d %d %d\", &minX, &minY, &maxX, &maxY, &h[i]);\n\n\t\t\tvector<point> points;\n\t\t\tpoints.reserve(4);\n\t\t\tpoints.push_back(point(minX, minY));\n\t\t\tpoints.push_back(point(minX, maxY));\n\t\t\tpoints.push_back(point(maxX, maxY));\n\t\t\tpoints.push_back(point(maxX, minY));\n\n\t\t\tif(minX <= sx && sx <= maxX && minY <= sy && sy <= maxY\n\t\t\t   || minX <= ex && ex <= maxX && minY <= ey && ey <= maxY) {\n\t\t\t\ton = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\tfor(int j = 0; j < 4; ++j) {\n\t\t\t\tconst segment edge(points[j], points[(j + 1) % 4]);\n\t\t\t\tif(intersect(course, edge)) {\n\t\t\t\t\ton = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchmin(d[i], dist(course, points[j]));\n\t\t\t\tchmin(d[i], dist(course, edge));\n\t\t\t}\n\t\t}\n\n\t\tif(on) {\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tdouble low = 0.0, high = 1000.0;\n\t\tfor(int i = 0; i < 100; ++i) {\n\t\t\tconst double mid = (low + high) / 2;\n\t\t\tif(check(mid))\n\t\t\t\tlow = mid;\n\n\t\t\telse\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\tprintf(\"%.15lf\\n\", low);\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n#include<cmath>\n\n#define EPS (1e-10)\n#define fs first\n#define sc second\n\nusing namespace std;\n\ntypedef complex<int> P;\ntypedef pair<P,P> L;\n\n//for vector\n\nint dot(P x,P y){return real(conj(x)*y);}\n\nint cross(P x,P y){return imag(conj(x)*y);}\n\ndouble dis(P x, P y){\n  return sqrt( (real(x)-real(y))*(real(x)-real(y)) \n\t       + (imag(x)-imag(y))*(imag(x)-imag(y)) );\n}\n\ndouble norm(P x){return sqrt(real(x)*real(x) + imag(x)*imag(x) );}\n\n//for line(segment)\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (norm(b)<norm(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ndouble seg_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return dis(x,a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return dis(x,a.sc);\n  return abs((double)cross(a.sc-a.fs,x-a.fs))/dis(a.sc,a.fs);\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ndouble seg_close(L a, L b){\n  double res = 1e10;\n  res = min(res, seg_dis(a,b.first));\n  res = min(res, seg_dis(a,b.second));\n  res = min(res, seg_dis(b,a.first));\n  res = min(res, seg_dis(b,a.second));\n  return res;\n}\n\nint main(){\n  int n,sx,sy,ex,ey;\n  int x1,y1,x2,y2,h;\n\n  while(cin >> n ,n){\n    cin >> sx >> sy >> ex >> ey;\n    L l = L(P(sx,sy),P(ex,ey));\n\n    double r = 100000.0;\n    for(int i=0;i<n;i++){\n      cin >> x1 >> y1 >> x2 >> y2 >> h;\n      if(r<EPS)continue;\n\n      if(x1>x2)swap(x1,x2);\n      if(y1>y2)swap(y1,y2);\n      L A = L(P(x1,y1),P(x1,y2));\n      L B = L(P(x1,y2),P(x2,y2));\n      L C = L(P(x2,y2),P(x2,y1));\n      L D = L(P(x2,y1),P(x1,y1));\n\n      if(is_cp(l,A))r = 0.0;\n      else if(is_cp(l,B))r = 0.0;\n      else if(is_cp(l,C))r = 0.0;\n      else if(is_cp(l,D))r = 0.0;\n      else if(x1<=sx && sx<=x2 && y1<=sy && sy<=y2)r = 0.0;\n      else{\n\tdouble dis = min(min(seg_close(l,A),seg_close(l,B)),\n\t\t\t min(seg_close(l,C),seg_close(l,D)));\n\tif(dis<h)r = min(r,dis);\n\telse r = min(r,(h*h+dis*dis)/(2*h));\n      }\n    }\n    cout << r << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<double, double> PDD;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nPDD operator-(const PDD &a, const PDD &b) {\n  return PDD(a.fi - b.fi, a.se - b.se);\n}\n\ndouble len(PDD p) {\n  return sqrt(p.fi * p.fi + p.se * p.se);\n}\n\ndouble dot(PDD a, PDD b) {\n  return a.fi * b.fi + a.se * b.se;\n}\n\ndouble cross(PDD a, PDD b) {\n  return a.fi * b.se - a.se * b.fi;\n}\n\ndouble distance(PDD p1, PDD p2, PDD q1, PDD q2) {\n  if (cross(p2 - p1, q1 - p1) * cross(p2 - p1, q2 - p1) < 0 && cross(q2 - q1, p1 - q1) * cross(q2 - q1, p2 - q1) < 0) {\n    return 0;\n  } else {\n    double mini = INF;\n    if (dot(p2 - p1, q1 - p1) < 1e-7) minch(mini, len(q1 - p1));\n    else if (dot(p1 - p2, q1 - p2) < 1e-7) minch(mini, len(q1 - p2));\n    else minch(mini, abs(cross(p2 - p1, q1 - p1)) / len(p2 - p1));\n\n    if (dot(p2 - p1, q2 - p1) < 1e-7) minch(mini, len(q2 - p1));\n    else if (dot(p1 - p2, q2 - p2) < 1e-7) minch(mini, len(q2 - p2));\n    else minch(mini, abs(cross(p2 - p1, q2 - p1)) / len(p2 - p1));\n\n    if (dot(q2 - q1, p1 - q1) < 1e-7) minch(mini, len(p1 - q1));\n    else if (dot(q1 - q2, p1 - q2) < 1e-7) minch(mini, len(p1 - q2));\n    else minch(mini, abs(cross(q2 - q1, p1 - q1)) / len(q2 - q1));\n\n    if (dot(q2 - q1, p2 - q1) < 1e-7) minch(mini, len(p2 - q1));\n    else if (dot(q1 - q2, p2 - q2) < 1e-7) minch(mini, len(p2 - q2));\n    else minch(mini, abs(cross(q2 - q1, p2 - q1)) / len(q2 - q1));\n\n    return mini;\n  }\n}\n\nint main(){\n  int n;\n  while(cin >> n, n) {\n    PDD s, e;\n    cin >> s.fi >> s.se >> e.fi >> e.se;\n\n    double ans = INF;\n    bool ok = true;\n    rep(i, n) {\n      PDD mi, ma;\n      double h;\n      cin >> mi.fi >> mi.se >> ma.fi >> ma.se >> h;\n      double mini = INF;\n      minch(mini, distance(s, e, mi, PDD(ma.fi, mi.se)));\n      minch(mini, distance(s, e, mi, PDD(mi.fi, ma.se)));\n      minch(mini, distance(s, e, ma, PDD(ma.fi, mi.se)));\n      minch(mini, distance(s, e, ma, PDD(mi.fi, ma.se)));\n      minch(mini, distance(s, e, mi, ma));\n      if (mini == 0) {\n        ok = false;\n        break;\n      } else {\n        if (mini < h) {\n          minch(ans, mini);\n        } else {\n          double high = 1000, low = mini, mid;\n          rep(j, 100) {\n            mid = (high + low) / 2;\n            if ((mid - h) * (mid - h) + mini * mini >= mid * mid) low = mid;\n            else high = mid;\n          }\n          minch(ans, mid);\n        }\n      }\n    }\n\n    if (ok) {\n      printf(\"%.10f\\n\", ans);\n    } else {\n      printf(\"0\");\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint sx = in.nextInt();\n\t\t\tint sy = in.nextInt();\n\t\t\tint ex = in.nextInt();\n\t\t\tint ey = in.nextInt();\n\t\t\tPos s = new Pos(sx, sy);\n\t\t\tPos e = new Pos(ex, ey);\n\t\t\tArrayList<Pos> list = new ArrayList<Pos>();\n\t\t\tboolean zero = false;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint lx = in.nextInt();\n\t\t\t\tint ly = in.nextInt();\n\t\t\t\tint rx = in.nextInt();\n\t\t\t\tint ry = in.nextInt();\n\t\t\t\tint h = in.nextInt();\n\t\t\t\tif(zero) continue;\n\t\t\t\tPos[] p = {\n\t\t\t\t\t\tnew Pos(lx, ly),\n\t\t\t\t\t\tnew Pos(lx, ry),\n\t\t\t\t\t\tnew Pos(rx, ry),\n\t\t\t\t\t\tnew Pos(rx, ly),\n\t\t\t\t};\n\t\t\t\tdouble minLen = 100000000;\n\t\t\t\tdouble sign = 0;\n\t\t\t\tboolean inter = true;\n\t\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t\tif(cross(p[j], p[(j+1)%4], s, e)){\n\t\t\t\t\t\tzero = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdouble l = Math.abs(dist(s, e, p[j]));\n\t\t\t\t\tl = Math.min(l, Math.abs(sign = dist(p[j], p[(j+1)%4], s)));\n\t\t\t\t\tl = Math.min(l, Math.abs(dist(p[j], p[(j+1)%4], e)));\n\t\t\t\t\tminLen = Math.min(minLen, l);\n\t\t\t\t\tif(sign > 0 || minLen == 0) inter = false;\n\t\t\t\t}\n\t\t\t\tif(inter) zero = true;\n\t\t\t\tlist.add(new Pos(minLen, h));\n\t\t\t}\n\t\t\tif(zero){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.println(binarySearch(list));\n\t\t}\n\t}\n\t\n\tpublic static final int times = 5000;\n\tpublic static double binarySearch(ArrayList<Pos> list){\n\t\tdouble max = 1000;\n\t\tdouble min = 0;\n\t\tdouble mid = 0;\n\t\tfor(int i=0; i<times; i++){\n\t\t\tmid = (max+min)/2;\n\t\t\tif(check(mid, list)){\n\t\t\t\tmin = mid;\n\t\t\t}else{\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\t\n\tpublic static boolean check(double r, ArrayList<Pos> list){\n\t\tfor(Pos p: list){\n\t\t\tdouble h = p.y;\n\t\t\tif(h > r) h = r;\n\t\t\tPos o = new Pos(0, r);\n\t\t\tif(o.dist2(p) < r*r) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static double triarea(Pos a, Pos b, Pos c){\n\t\tdouble dx1 = b.x - a.x;\n\t\tdouble dy1 = b.y - a.y;\n\t\tdouble dx2 = c.x - a.x;\n\t\tdouble dy2 = c.y - a.y;\n\t\treturn dx1*dy2 - dx2*dy1;\n\t}\n\t\n\tpublic static boolean cross(Pos a1, Pos a2, Pos b1, Pos b2){\n\t\treturn triarea(a1, a2, b1)*triarea(a1, a2, b2) <= 0\n\t\t\t\t&& triarea(b1, b2, a1)*triarea(b1, b2, a2) <= 0;\n\t}\n\t\n\tpublic static double dist(Pos a, Pos b, Pos c){\n\t\t// a->b ??¨ c??¨????????¢\n\t\tif(dot(b.x-a.x, b.y-a.y, c.x-a.x, c.y-a.y) <= 0)\n\t\t\treturn Math.sqrt(a.dist2(c));\n\t\tif(dot(a.x-b.x, a.y-b.y, c.x-b.x, c.y-b.y) <= 0)\n\t\t\treturn Math.sqrt(b.dist2(c));\n\t\treturn triarea(a, b, c)/Math.sqrt(a.dist2(b));\n\t}\n\t\n\tpublic static double dot(double x, double y, double x1, double y2){\n\t\treturn x*x1 + y*y2;\n\t}\n\t\n\tpublic static double dot(Pos a, Pos b){\n\t\treturn a.x*b.x + a.y*b.y;\n\t}\n}\n\nclass Pos{\n\tdouble x, y;\n\tpublic Pos(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic double dist2(Pos p){\n\t\treturn (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// dot of a and b\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// cross of a and b\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\n// CCW::counter clockwise\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c : counter-clockwise\n\tif (cross(b, c) < -eps) return -1; // a,b,c : clockwise\n\tif (dot(b, c) < 0) return 2;       // c,a,b : on a line\n\tif (norm(b) < norm(c)) return -2;  // a,b,c : on a line\n\treturn 0;                          // a,c,b : on a line\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nstruct Square{\n    Point left_d,left_u,right_d,right_u;\n    ld h;\n    Square(Point left_d,Point left_u,Point right_d,Point right_u,ld h): \n        left_d(left_d),left_u(left_u),right_d(right_d),right_u(right_u),h(h){}\n};\n\nbool intersect(Square s, Point st, Point gt){\n    bool ret=false;\n    Line l=Line(st,gt);\n    ret |= isis_ss(l, Line(s.left_d,s.left_u));\n    ret |= isis_ss(l, Line(s.left_u,s.right_u));\n    ret |= isis_ss(l, Line(s.right_u,s.right_d));\n    ret |= isis_ss(l, Line(s.right_d,s.left_d));\n    return ret;\n}\n\nbool check(const vector<Square> &v, Point st, Point gt, ld r){\n    bool ret=true;\n    int sz=v.size();\n    Line l = Line(st,gt);\n    for(int i=0;i<sz;i++){\n        ld d=dist_ss(l,Line(v[i].left_d,v[i].left_u));\n        d = min(d, dist_ss(l,Line(v[i].left_u,v[i].right_u)));\n        d = min(d, dist_ss(l,Line(v[i].right_u,v[i].right_d)));\n        d = min(d, dist_ss(l,Line(v[i].right_d,v[i].left_d)));\n\n        if(v[i].h>r) ret &= (d+eps>r);\n        else ret &= (d+eps > sqrt(r*r-(r-v[i].h)*(r-v[i].h)));\n    }\n    return ret;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        ld sx,sy,ex,ey;\n        ld minx,miny,maxx,maxy,h;\n        Point left_d,left_u,right_d,right_u;\n        vector<Square> v;\n\n        cin>>sx>>sy>>ex>>ey;\n        Point st=Point(sx,sy),gt=Point(ex,ey);\n        bool f=false;\n        for(int i=0;i<n;i++){\n            cin>>minx>>miny>>maxx>>maxy>>h;\n            left_d=Point(minx,miny); left_u=Point(minx,maxy);\n            right_d = Point(maxx,miny); right_u = Point(maxx,maxy);\n            v.push_back(Square(left_d,left_u,right_d,right_u,h));\n            f |= intersect(v[i],st,gt);\n\n            if(minx<=sx&&sx<=maxx&&miny<=sy&&sy<=maxy&& minx<=ex&&ex<=maxx&&miny<=ey&&ey<=maxy) f=true;\n        }\n        if(f){\n            cout<<fixed<<setprecision(10)<<0<<endl;\n            continue;\n        }\n        ld low=0,high=1e6;\n        for(int i=0;i<100;i++){\n            ld mid=(low+high)/2;\n            if(check(v,st,gt,mid)){\n                low=mid;\n            }\n            else{\n                high=mid;\n            }\n        }\n        cout<<fixed<<setprecision(10)<<low<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(int i = 1 ; i <= x ; i ++)\n\ntypedef long double ld;\nconst ld PI = 3.141592653589793238462643383279;\n\nstruct po{\n\tld x;\n\tld y;\n\tpo(ld a){ x = a; y = 0; }\n\tpo(ld a,ld b){ x = a; y = b; }\n\tpo(){}\n\tinline ld operator()(const po& rhs) const {\n\t\treturn x*rhs.x+y*rhs.y;\n\t}\n\tinline ld norm() {\n\t\treturn sqrt((*this)(*this));\n\t}\n\tinline po& operator+=(const po& rhs){\n\t\tx += rhs.x;\n\t\ty += rhs.y;\n\t\treturn *this;\n\t}\n\tinline po& operator-=(const po& rhs){\n\t\tx -= rhs.x;\n\t\ty -= rhs.y;\n\t\treturn *this;\n\t}\n\tinline po& operator*=(const po& rhs){\n\t\tld x_ = x*rhs.x-y*rhs.y;\n\t\ty = x*rhs.y+y*rhs.x;\n\t\tx = x_;\n\t\treturn *this;\n\t}\n\tinline po& operator/=(const po& rhs){\n\t\tld x_ = x*rhs.x+y*rhs.y;\n\t\ty = -x*rhs.y+y*rhs.x;\n\t\tx = x_;\n\t\tld nor = rhs(rhs);\n\t\tx /= nor;\n\t\ty /= nor;\n\t\treturn *this;\n\t}\n\tinline void in(){\n\t\tscanf(\"%Lf%Lf\",&x,&y);\n\t}\n};\ninline po operator+(const po& a, const po& b){ return po(a) += b; }\ninline po operator-(const po& a, const po& b){ return po(a) -= b; }\ninline po operator*(const po& a, const po& b){ return po(a) *= b; }\ninline po operator/(const po& a, const po& b){ return po(a) /= b; }\n\ninline po similar(const po& a,const po& b,const po& c,const po& p,const po& q){\n\treturn p+(q-p)*(c-a)/(b-a);\n}\n\ntypedef pair<po,po> se;\n#define fr first\n#define sc second\n\nstruct li{\n\tld a;\n\tld b;\n\tld c;\n\tli(po p,po q){\n\t\ta = q.y-p.y;\n\t\tb = p.x-q.x;\n\t\tc = p.y*q.x-p.x*q.y;\n\t}\n\t/*explicit li(se s){\n\t\ta = s.sc.y-s.fr.y;\n\t\tb = s.fr.x-s.sc.x;\n\t\tc = s.fr.y*s.sc.x-s.fr.x*s.sc.y;\n\t\tli(s.fr,s.sc);\n\t}*/\n\tli(){}\n\tinline ld operator()(const po& p) const {\n\t\treturn a*p.x+b*p.y+c;\n\t}\n};\n\nvoid intersect(const li &l,const li &m,po* &ret){\n\tif(abs(l.a*m.b-m.a*l.b) <= 1e-18){\n\t\tret = nullptr;\n\t\treturn;\n\t}\n\tret = new po;\n\tret->x = -(l.c*m.b-m.c*l.b)/(l.a*m.b-m.a*l.b);\n\tret->y = -(l.a*m.c-m.a*l.c)/(l.a*m.b-m.a*l.b);\n}\ninline bool on(const po &p,const se &s){\n\treturn (s.fr-p)(s.sc-p) <= 1e-9;\n}\nvoid intersect(const se &s,const se &t,po* &ret){\n\tli l = li(s.fr,s.sc);\n\tli m = li(t.fr,t.sc);\n\tpo *p;\n\tintersect(l,m,p);\n\tif(p == nullptr || (on(*p,s)&&on(*p,t)))ret = p;\n\telse{\n\t\tdelete p;\n\t\tret = nullptr;\n\t}\n}\ninline ld dist(const po &p,const po &q){\n\treturn sqrt((p-q)(p-q));\n}\ninline li perpen(const po &p,const li &l){\n\tli ret;\n\tret.a = l.b;\n\tret.b = -l.a;\n\tret.c = l.a*p.y-l.b*p.x;\n\treturn ret;\n}\ninline po perpen_leg(const po &p,const li &l){\n\tpo ret;\n\tli m = perpen(p,l);\n\tret.x = -(l.c*m.b-m.c*l.b)/(l.a*m.b-m.a*l.b);\n\tret.y = -(l.a*m.c-m.a*l.c)/(l.a*m.b-m.a*l.b);\n\treturn ret;\n}\ninline ld dist(const po &p,const se &s){\n\tpo h = perpen_leg(p,li(s.fr,s.sc));\n\tif(on(h,s))return dist(p,h);\n\telse return min( dist(p,s.fr) , dist(p,s.sc) );\n}\ninline ld dist(const se &s,const se &t){\n\tpo *p;\n\tintersect(s,t,p);\n\tif(p != nullptr){\n\t\tdelete p;\n\t\treturn 0.0;\n\t}\n\tld ret = min( dist(s.fr,t) , dist(s.sc,t) );\n\tret = min( ret , min( dist(t.fr,s) , dist(t.sc,s) ) );\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)break;\n\t\tpo s,e;\n\t\tld x1[52],y1[52],x2[52],y2[52],h[52];\n\t\ts.in();\n\t\te.in();\n\t\trep1(i,n){\n\t\t\tscanf(\"%Lf%Lf%Lf%Lf%Lf\",&x1[i],&y1[i],&x2[i],&y2[i],&h[i]);\n\t\t}\n\t\tld ret = 100000000.0;\n\t\trep1(i,n){\n\t\t\tld d = 100000000.0;\n\t\t\td = min( d , dist(se(s,e),se(po(x1[i],y1[i]),po(x1[i],y2[i]))) );\n\t\t\td = min( d , dist(se(s,e),se(po(x2[i],y1[i]),po(x2[i],y2[i]))) );\n\t\t\td = min( d , dist(se(s,e),se(po(x1[i],y1[i]),po(x2[i],y1[i]))) );\n\t\t\td = min( d , dist(se(s,e),se(po(x1[i],y2[i]),po(x2[i],y2[i]))) );\n\t\t\tif(x1[i] <= s.x && s.x <= x2[i] && y1[i] <= s.y && s.y <= y2[i]){\n\t\t\t\td = 0.0;\n\t\t\t}\n\t\t\tif(h[i] < d){\n\t\t\t\td = (h[i]*h[i]+d*d)/(2.0*h[i]);\n\t\t\t}\n\t\t\tret = min( ret , d );\n\t\t}\n\t\tprintf(\"%.20lf\\n\",(double)ret);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\n// point\ntypedef double T;\ntypedef pair<T,T> P;\n\n// difference\nP operator-(const P& lhs, const P& rhs)\n{\n\treturn P(lhs.first-rhs.first,lhs.second-rhs.second);\n}\n\nP operator+(const P& lhs, const P& rhs)\n{\n\treturn P(lhs.first+rhs.first, lhs.second+rhs.second);\n}\n\n// scalar product\nP operator*(T t, P p){\n\treturn P(t*p.first,t*p.second);\n}\n\n// outer product\nT Cross(const P& lhs, const P& rhs)\n{\n\treturn lhs.first*rhs.second-lhs.second*rhs.first;\n}\n\n// inner product \nT Dot(const P& lhs, const P& rhs)\n{\n\treturn lhs.first*rhs.first+lhs.second*rhs.second;\n}\n\n// square of distance\nT Dist2(const P& lhs, const P& rhs){\n\treturn Dot(lhs-rhs,lhs-rhs);\n}\n\n// b is on segment a c\nbool onSegment(P a, P b, P c){\n\tP v=c-a;\n\tP w=b-a;\n\treturn Cross(v,w)==0 && 0<=Dot(v,w)&&Dot(v,w)<=Dot(v,v);\n}\n\n\n// intersection of segments\nbool Intersects(P s0, P e0, P s1, P e1)\n{\n\tP a=s1-s0;\n\tP v=e0-s0;\n\tP w=s1-e1;\n\tT det=Cross(v,w);\n\tT t0=w.second*a.first-w.first*a.second;\n\tT t1=-v.second*a.first+v.first*a.second;\n\tif (det<0){\n\t\tif (det <= t0 && det <= t1 && t0 <= 0 && t1 <= 0){\n\t\t\treturn true;\n\t\t}\n\t}\n\telse if (det > 0)\n\t{\n\t\tif (0 <= t0 && 0 <= t1 && t0 <= det && t1 <= det){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn onSegment(s0,s1,e0) ||\n\t\tonSegment(s0,e1,e0)||\n\t\tonSegment(s1,s0,e1)||\n\t\tonSegment(s1,e0,e1);\n}\n\n// intersection of line\nbool IntersectParam(P s0, P e0, P s1, P e1, T& t0, T& t1)\n{\n\tP a=s1-s0;\n\tP v=e0-s0;\n\tP w=s1-e1;\n\tT det=Cross(v,w);\n\tif(det == 0){\n\t\treturn false;\n\t}\n\tt0=Cross(a,w)/det;\n\tt1=Cross(v,a)/det;\n\treturn true;\n}\n\nP Interpolate(P s, P e, T t)\n{\n\treturn (1-t)*s+t*e;\n}\n\n// intersection of polygons\nbool Intersects(vector<P>& lhs, vector<P>& rhs)\n{\n\tfor(int i=1;i<lhs.size();i++){\n\t\tfor (int j=1;j<rhs.size();j++){\n\t\t\tif (Intersects(lhs[i],lhs[i-1],rhs[j],rhs[j-1])){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool IsInside(vector<P>& ps, P p)\n{\n\tint count=0;\n\tfor(int i=1;i<ps.size();i++){\n\t\tP a=ps[i-1];\n\t\tP b=ps[i];\n\t\tif(min(a.first,b.first)<=p.first&&p.first<max(a.first,b.first))\n\t\t{\n\t\t\tT c=Cross(p-a,b-a);\n\t\t\tif(c==0){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(c<0){\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\telse if (a.first==p.first&&b.first==p.first)\n\t\t{\n\t\t\tif(min(a.second,b.second)<=p.first&&p.first<=max(a.second,b.second))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count!=0;\n}\n\nbool IntersectSegmentCircle(P s, P e, P c, T r)\n{\n\ts=s-c;\n\te=e-c;\n\tif(Dot(s,s)<r*r||Dot(e,e)<r*r){\n\t\treturn true;\n\t}\n\n\tP v=P(0,0)-s;\n\tdouble cr=Cross(e-s,v);\n\tdouble se=Dist2(e,s);\n\tif(cr*cr<se*r*r){\n\t\tif(0<=Dot(e-s,v)&&Dot(e-s,v)<=Dot(e-s,e-s))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nP s,e;\nP rot; \ndouble ps[50][2][2];\ndouble h[50];\nint N;\nbool intersects(double r,int a)\n{\n\tdouble offset;\n\tif(r>h[a])\n\t{\n\t\toffset=sqrt(r*r-(r-h[a])*(r-h[a]));\n\t}\n\telse\n\t{\n\t\toffset=r;\n\t}\n\n\tvector<P> poly;\n\tpoly.push_back(P(ps[a][0][0],ps[a][0][1]));\n\tpoly.push_back(P(ps[a][1][0],ps[a][0][1]));\n\tpoly.push_back(P(ps[a][1][0],ps[a][1][1]));\n\tpoly.push_back(P(ps[a][0][0],ps[a][1][1]));\n\tpoly.push_back(P(ps[a][0][0],ps[a][0][1]));\n\n\tvector<P> poly2;\n\tpoly2.push_back(s+offset*rot);\n\tpoly2.push_back(e+offset*rot);\n\tpoly2.push_back(e-offset*rot);\n\tpoly2.push_back(s-offset*rot);\n\tpoly2.push_back(s+offset*rot);\n\n\tif(Intersects(poly,poly2))\n\t{\n\t\treturn true;\n\t}\n\tP mid=0.5*(poly[0]+poly[2]);\n\tP mid2=0.5*(poly2[0]+poly2[2]);\n\tif(IsInside(poly,mid2)||IsInside(poly2,mid))\n\t{\n\t\treturn true;\n\t}\n\n\tfor(int i=1;i<=4;i++){\n\t\tif(IntersectSegmentCircle(poly[i],poly[i-1],s,offset))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif(IntersectSegmentCircle(poly[i],poly[i-1],e,offset))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid exec()\n{\n\tcin >> N;\n\tif(N==0)exit(0);\n\tcin >> s.first >> s.second >> e.first >> e.second;\n\tdouble len=sqrt(Dist2(s,e));\n\trot=P((s.second-e.second)/len,(e.first-s.first)/len);\n\tfor(int i=0;i<N;i++){\n\t\tcin >> ps[i][0][0] >> ps[i][0][1] >> ps[i][1][0] >> ps[i][1][1] >> h[i];\n\t}\n\tdouble low=0;\n\tdouble hi=1000;\n\twhile(low+0.001<hi)\n\t{\n\t\tdouble mid=(low+hi)/2;\n\t\tbool ng=false;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(intersects(mid,i))\n\t\t\t{\n\t\t\t\tng=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ng){\n\t\t\thi=mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlow=mid;\n\t\t}\n\t}\n\tcout << (low+hi)/2 << endl;\n}\nint main(int argc, char** argv) {\n\twhile(1)exec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1e-8\n#define INF 1e8\n\ntypedef complex<double> Point;\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tPoint operator / (const Point &p, const double &a){\n\t\treturn Point(real(p)/a, imag(p)/a);\n\t}\n\tPoint operator * (const Point &p, const double &a){\n\t\treturn Point(real(p)*a, imag(p)*a);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn real(a) == real(b) && real(a) == real(b);\n\t}\n}\n\n\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point>{\n\tLine(){}\n\tLine(const Point &a, const Point &b){\n\t\tpush_back(a); push_back(b);\n\t}\n};\nstruct Circle{\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &c, double r):c(c),r(r){}\n};\n\ndouble dot(const Point &a, const Point &b){\n\treturn real(conj(a) * b);\n}\n\ndouble cross(const Point &a, const Point &b){\n\treturn imag(conj(a)*b);\n}\n\nPoint projection(const Line &l, const Point &p){\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t * (l[0]-l[1]);\n}\n\nint ccw(Point a, Point b, Point c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > 0) return +1;\n\tif(cross(b,c) < 0) return -1;\n\tif(dot(b,c) < 0) return +2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\ndouble distancePP(const Point &a, const Point &b){\n\treturn abs(a-b);\n}\n\nbool intersectSS(const Line &s, const Line &t){\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\t\t\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const Line &s, const Point &p){\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1]-s[0]) < EPS;\n}\n\ndouble distanceSP(const Line &s, const Point &p){\n\tconst Point r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r-p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const Line &s, const Line &t){\n\tdouble d = INF;\n\td = min(d, distanceSP(s, t[0]));\n\td = min(d, distanceSP(s, t[1]));\n\td = min(d, distanceSP(t, s[0]));\n\td = min(d, distanceSP(t, s[0]));\n\treturn d;\n}\n\n\nbool intersectLL(const Line &l, const Line &m){\n\treturn abs(cross(l[1]-l[0], m[1]-m[0])) > EPS ||\n\t\t\t\t\tabs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n\nbool inPolygon(const Polygon &g, const Point &p){\n\tdouble sum = 0.0;\n\tint n = g.size();\n\tfor(int i = 0; i < g.size(); i++){\n\t\tint j = (i+1)%n;\n\t\tif(intersectSP(Line(g[i], g[j]), p)) return true;\n\t\tsum += arg((g[j]-p)/(g[i]-p));\n\t}\n\treturn abs(sum) > 1;\n}\n\nint main(void){\n\tint N;\n\twhile(cin >> N, N){\n\t\tint miss = 0;\n\t\tdouble sx, sy, ex, ey;\n\t\tvector<Point> ps(N, Point(INF,INF));\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tLine root = Line(Point(sx, sy), Point(ex, ey));\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tdouble ax, ay, bx, by, h;\n\t\t\tdouble d = INF;\n\t\t\tcin >> ax>>ay>>bx>>by>>h;\n\t\t\tPolygon g;\n\t\t\tg.push_back(Point(ax,ay));\n\t\t\tg.push_back(Point(bx,ay));\n\t\t\tg.push_back(Point(bx,by));\n\t\t\tg.push_back(Point(ax,by));\n\t\t\t//内部判定\n\t\t\tif(inPolygon(g, root[0]) || inPolygon(g, root[1])) miss = 1;\n\t\t\t//接触判定\n\t\t\tif(intersectSS(root, Line(Point(ax, ay), Point(bx, ay)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(bx, ay), Point(bx, by)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(bx, by), Point(ax, by)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(ax, by), Point(ax, ay)))) miss = 1;\n\t\t\tif(miss) continue;\n\t\t\t//最小距離\n\t\t\tfor(int j = 0; j < g.size(); j++){\n\t\t\t\td = min(d, distanceSS(root, Line(g[(j+1)%g.size()], g[j])));\n\t\t\t}\n\t\t\tps[i] = Point(d, h);\n\t\t}\n\t\tif(miss){\n\t\t\tcout << \"0\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble left = 0, right = 10000;\n\t\tdouble ans = 0;\n\t\twhile(right - left > EPS){\n\t\t\tdouble mid = (left + right) / 2;\n\t\t\tdouble ret = INF;\n\t\t\tfor(int i = 0; i < ps.size(); i++){\n\t\t\t\tif(imag(ps[i]) <= mid){\n\t\t\t\t\tret = min(ret, distancePP(Point(0, mid), ps[i]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tret = min(ret, real(ps[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ret <= mid + EPS) right = mid;\n\t\t\telse{ ans = mid; left = mid;}\n//\t\t\tprintf(\"%.4lf -> ret:ans = [%.4lf : %.4lf]\\n\", mid, ret, ans);\n\t\t}\n\t\tprintf(\"%.9lf\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define INF 1e14\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\n\ndouble dot(Point a, Point b) {\n    return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(Point a, Point b) {\n    return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(Point a, Point b, Point c) {\n    b -= a;  c -= a;\n    if (cross(b,c) >  EPS) return +1;  // counter clockwise\n    if (cross(b,c) < -EPS) return -1;  // clockwise\n    if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n    return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isecSP(Point a1, Point a2, Point b) {\n    return !ccw(a1, a2, b);\n}\n\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n    return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n           ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\nPoint proj(Point a1, Point a2, Point p) {\n    return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\ndouble distSP(Point a1, Point a2, Point p) {\n    Point r = proj(a1, a2, p);\n    if (isecSP(a1, a2, r)) return abs(r-p);\n    return min(abs(a1-p), abs(a2-p));\n}\n\ndouble distSS(Point a1, Point a2, Point b1, Point b2) {\n    if (isecSS(a1, a2, b1, b2)) return 0;\n    return min({\n        distSP(a1, a2, b1),\n        distSP(a1, a2, b2),\n        distSP(b1, b2, a1),\n        distSP(b1, b2, a2)});\n}\n\nbool inPolygon(Point p,VP& ps){\n    int n = ps.size();\n    double sumAngle=0;\n    rep(i,n){\n        double t = arg(ps[(i+1)%n]-p)-arg(ps[i]-p);\n        while(t > +PI) t-=2*PI;\n        while(t < -PI) t+=2*PI;\n        sumAngle += t;\n    }\n    return (abs(sumAngle) > 0.1);\n}\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        double sx,sy,ex,ey;\n        cin>>sx>>sy>>ex>>ey;\n        Point s(sx,sy);\n        Point e(ex,ey);\n        vector<double> d(n,INF), h(n);\n        bool ng = false;\n        rep(i,n){\n            double x1,y1,x2,y2;\n            cin>>x1>>y1>>x2>>y2>>h[i];\n            VP p = {{x1,y1},{x2,y1},{x2,y2},{x1,y2}};\n            if(inPolygon(s,p) || inPolygon(e,p)){\n                ng = true;\n            }\n            rep(j,4){\n                d[i] = min(d[i],distSS(s,e,p[j],p[(j+1)%4]));\n            }\n        }\n        if(ng){\n            cout<<\"0.0000\"<<endl;\n            continue;\n        }\n\n        double l = 0, r = 1000;\n        rep(loop,100){\n            double R = (l+r)/2;\n            bool ok = true;\n            rep(i,n){\n                if(sqrt(pow(max(R-h[i],0.0),2) + pow(d[i],2)) < R){\n                    ok = false;\n                }\n            }\n            if(ok) l = R;\n            else   r = R;\n        }\n        printf(\"%.4f\\n\",l);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\n#define double long double\nconst int mod=1000000007,MAX=35,INF=1<<29;\nconst double eps=1e-10;\nconst double pi=acos((double)-1.0L);\n#define equals(a,b) (fabs((a)-(b))<eps)\n\ndouble torad(int deg) {return (double)(deg)*pi/180.0;}\ndouble todeg(double ang) {return ang*180.0/pi;}\n\nclass Point{\npublic:\n    double x,y;\n    \n    Point(double x=0,double y=0):x(x),y(y){}\n    \n    Point operator + (Point p){return Point(x+p.x,y+p.y);}\n    Point operator - (Point p){return Point(x-p.x,y-p.y);}\n    Point operator * (double a){return Point(a*x,a*y);}\n    Point operator / (double a){return Point(x/a,y/a);}\n    \n    double abs(){return sqrt(norm());}\n    double norm(){return x*x+y*y;}\n    \n    bool operator < (const Point &p)const{\n        return x!=p.x ? x<p.x : y<p.y;\n    }\n    \n    bool operator == (const Point &p)const{\n        return fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n    }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a){\n    return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\nstruct Segment{\n    Point p1,p2;\n};\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nstatic const int counter_clockwise=1;\nstatic const int clockwise=-1;\nstatic const int online_back=2;\nstatic const int online_front=-2;\nstatic const int on_segment=0;\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    \n    if(cross(a,b)>eps) return counter_clockwise;\n    if(cross(a,b)<-eps) return clockwise;\n    if(dot(a,b)<-eps) return online_back;\n    if(a.norm()<b.norm()) return online_front;\n    \n    return on_segment;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return(ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ntypedef Segment Line;\n\ndouble getDistance(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min({getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2),getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)});\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nclass Circle{\npublic:\n    Point c;\n    double r;\n    Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\nPoint CircleCenter(Point a,Point b,Point c){\n    Point u=a-b,v=a-c;\n    double m1=(norm(a)-norm(b))/2.0,m2=(norm(a)-norm(c))/2.0;\n    \n    Point res;\n    if(cross(u,v)==0.0){\n        res.x=1e9;\n        res.y=1e9;\n        \n        return res;\n    }\n    res.x=(m1*v.y-m2*u.y)/cross(u,v);\n    res.y=(m1*v.x-m2*u.x)/cross(v,u);\n    \n    return res;\n}\n\npair<Point,Point> segCrossPpoints(Circle c,Line l){\n    //assert(intersect(c,l));\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p){return atan2(p.y,p.x);}\nVector polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    //assert(intersect(c1,c2));\n    double d=abs(c1.c-c2.c);\n    double a=acos((c1.r*c1.r+d*d-c2.r-c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\ntypedef vector<Point> Polygon;\n\n/*\n IN 2\n ON 1\n OUT 0\n */\n\nint contains(Polygon g,Point p){\n    int n=int(g.size());\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<eps&&eps<b.y&&cross(a,b)>eps) x=!x;\n    }\n    return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s,bool ok){\n    Polygon u,l;\n    sort(all(s));\n    \n    if(int(s.size())<3) return s;\n    int n=int(s.size());\n    \n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    \n    l.push_back(s[n-1]);\n    l.push_back(s[n-2]);\n    \n    if(ok){\n        for(int i=2;i<n;i++){\n            for(int j=int(u.size());j>=2&&ccw(u[j-2],u[j-1],s[i])==counter_clockwise;j--){\n                u.pop_back();\n            }\n            u.push_back(s[i]);\n        }\n        \n        for(int i=int(s.size())-3;i>=0;i--){\n            for(int j=int(l.size());j>=2&&ccw(l[j-2],l[j-1],s[i])==counter_clockwise;j--){\n                l.pop_back();\n            }\n            l.push_back(s[i]);\n        }\n    }\n    \n    if(!ok){\n        for(int i=2;i<n;i++){\n            for(int j=int(u.size());j>=2&&ccw(u[j-2],u[j-1],s[i])!=clockwise;j--){\n                u.pop_back();\n            }\n            u.push_back(s[i]);\n        }\n        \n        for(int i=int(s.size())-3;i>=0;i--){\n            for(int j=int(l.size());j>=2&&ccw(l[j-2],l[j-1],s[i])!=clockwise;j--){\n                l.pop_back();\n            }\n            l.push_back(s[i]);\n        }\n    }\n    \n    reverse(all(l));\n    \n    for(int i=int(u.size())-2;i>=1;i--) l.push_back(u[i]);\n    \n    return l;\n}//ok==1なら辺の上も含める\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N;cin>>N;\n        if(N==0) break;\n        Segment s;\n        cin>>s.p1.x>>s.p1.y>>s.p2.x>>s.p2.y;\n        \n        double ans=INF;\n        \n        for(int i=0;i<N;i++){\n            double a,b,c,d,h;cin>>a>>b>>c>>d>>h;\n            double dis=INF;\n            Segment t;\n            t={{a,b},{c,b}};\n            chmin(dis,getDistance(s,t));\n            t={{a,d},{c,d}};\n            chmin(dis,getDistance(s,t));\n            \n            t={{c,b},{c,d}};\n            chmin(dis,getDistance(s,t));\n            t={{a,b},{a,d}};\n            chmin(dis,getDistance(s,t));\n            \n            chmin(dis,getDistanceSP(s,{a,b}));\n            chmin(dis,getDistanceSP(s,{a,d}));\n            chmin(dis,getDistanceSP(s,{c,b}));\n            chmin(dis,getDistanceSP(s,{c,d}));\n            \n            if(dis==0){\n                ans=0;\n                continue;\n            }\n            if(a<=s.p1.x&&s.p1.x<=c&&a<=s.p2.x&&s.p2.x<=c){\n                if(b<=s.p1.y&&s.p1.y<=d&&b<=s.p2.y&&s.p2.y<=d) ans=0;\n            }\n            if(h>=dis) chmin(ans,dis);\n            else chmin(ans,(h*h+dis*dis)/(2.0*h));\n        }\n        \n        cout<<setprecision(25)<<ans<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <iostream>\n\nusing namespace std;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\ntypedef long double ld;\nconst ld EPS=1e-9;\n\nstruct Point{\n\tPoint(ld x,ld y):x(x), y(y){}\n\tPoint(){}\n\tld x,y;\n};\n\nPoint operator+(const Point &a, const Point &b){\n\treturn Point(a.x+b.x, a.y+b.y);\n}\n\nPoint operator-(const Point &a, const Point &b){\n\treturn Point(a.x-b.x, a.y-b.y);\n}\n\nPoint operator*(const Point &a, const ld b){\n\treturn Point(a.x*b, a.y*b);\n}\n\nld cross(const Point &a, const Point &b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nld dot(const Point &a, const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\nld norm(const Point &a){\n\treturn dot(a,a);\n}\n\nld abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nstruct Line:vector<Point>{\n\tLine(Point a = Point(0,0), Point b = Point(0,0)){\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n};\n\nint ccw(Point a, Point b, Point c){\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b,c) > EPS) return 1;\n\tif(cross(b,c) < -EPS) return -1;\n\tif(dot(b,c) < 0) return 2;\n\tif(norm(b)<norm(c)) return -2;\n\treturn 0;\n}\n\nbool is_intersect_SS(const Line &s, const Line &t){\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nbool is_intersect_SP(const Line &l, const Point &p){\n\treturn ccw(l[0],l[1],p)==0;\n}\n\nPoint projection(const Line &l, const Point &p){\n\tld t = dot(p-l[0],l[1]-l[0])/norm(l[0]-l[1]);\n\treturn l[0]+(l[1]-l[0])*t;\n}\n\nld distance_SP(const Line &s, const Point &p){\n\tconst Point r = projection(s,p);\n\tif(is_intersect_SP(s,r))return abs(r-p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\nld distance_SS(const Line &s, const Line &t){\n\tif(is_intersect_SS(s,t)) return 0;\n\treturn min(min(distance_SP(s,t[0]),distance_SP(s,t[1])),min(distance_SP(t,s[0]),distance_SP(t, s[1])));\n}\n\nint n;\nLine L;\nLine data[100];\nint H[100];\n\nld Max;\n\nvoid input(){\n\tint w, x, y, z;\n\tMax = 1e10;\n\tscanf(\"%d%d%d%d\", &w, &x, &y, &z);\n\tL = Line(Point(w,x), Point(y,z));\n\tfor(int i = 0 ; i< n;i++){\n\t\tscanf(\"%d%d%d%d%d\", &w, &x, &y, &z, &H[i]);\n\t\tdata[i] = Line(Point(w,x), Point(y,z));\n\t}\n}\n\nvoid process(){\n\tld minX = min(L[0].x, L[1].x);\n\tld minY = min(L[0].y, L[1].y);\n\tld maxX = max(L[0].x, L[1].x);\n\tld maxY = max(L[0].y, L[1].y);\n\t//Check rect & line\n\tfor(int i = 0; i < n;i++){\n\t\tif(is_intersect_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][0].x, data[i][1].y))) ||\n\t\t\tis_intersect_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][1].x, data[i][0].y))) ||\n\t\t\tis_intersect_SS(L, Line(Point(data[i][0].x, data[i][1].y), Point(data[i][1].x, data[i][1].y))) ||\n\t\t\tis_intersect_SS(L, Line(Point(data[i][1].x, data[i][0].y), Point(data[i][1].x, data[i][1].y)))) {\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif(data[i][0].x <= minX && data[i][0].y <= minY && maxX <= data[i][1].x && maxY <= data[i][1].y) {\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t//get r;\n\tfor(int i = 0; i < n; i++) {\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][0].x, data[i][1].y)));\n\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\tif(Max > r) Max = r;\n\t\t}\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][1].x, data[i][0].y)));\n\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\tif(Max > r) Max = r;\n\t\t}\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][0].x, data[i][1].y), Point(data[i][1].x, data[i][1].y)));\n\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\tif(Max > r) Max = r;\n\t\t}\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][1].x, data[i][0].y), Point(data[i][1].x, data[i][1].y)));\n\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\tif(Max > r) Max = r;\n\t\t}\n\t}\n\tprintf(\"%llf\\n\", Max);\n}\n\nint main() {\n\twhile(true){\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tinput();\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nconst double INF = 1<<29;\nconst double EPS = 1e-8;\n\nstruct Vec { double x, y, z; };\nVec operator+(const Vec& a, const Vec& b) {\n    return { a.x + b.x, a.y + b.y, a.z + b.z };\n}\nVec operator-(const Vec& a, const Vec& b) {\n    return { a.x - b.x, a.y - b.y, a.z - b.z };\n}\nVec operator*(const Vec& v, double n) {\n    return { v.x * n, v.y * n, v.z * n };\n}\ndouble operator*(const Vec& a, const Vec& b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\ndouble abs(const Vec& v) {\n    return pow(v * v, 0.5);\n}\n\ndouble dist_l2p(Vec a, Vec b, Vec p) {\n    Vec l = (b - a) * (1.0 / abs(b - a));\n    double len = l * (p - a);\n    if (len < 0) return abs(a - p);\n    if (len > abs(b - a)) return abs(b - p);\n    return abs((l * len) - (p - a));\n}\n\ndouble dist_l2l(Vec a1, Vec a2, Vec b1, Vec b2) {\n    double l = 0, r = 1;\n    while (l + EPS < r) {\n        double m = (l + r) / 2;\n        double v1 = dist_l2p(a1, a2, b1 + ((b2 - b1) * m));\n        double v2 = dist_l2p(a1, a2, b1 + ((b2 - b1) * (m + EPS)));\n        if (v1 < v2) r = m;\n        else l = m;\n    }\n    return dist_l2p(a1, a2, b1 + ((b2 - b1) * l));\n}\n\ndouble dist(Vec s, Vec t, Vec a, Vec b, double h) {\n    double d = dist_l2l(s, t, a, b);\n    if (d < h) return d;\n    a.z = h, b.z = h;\n    double l = d, r = 2000;\n    while (l + EPS < r) {\n        double m = (l + r) / 2;\n        s.z = m, t.z = m;\n        if (m < dist_l2l(s, t, a, b)) l = m;\n        else r = m;\n    }\n    return l;\n}\n\nint main()\n{\n    while (1) {\n        int n; cin >> n;\n        if (!n) break;\n        Vec s, t;\n        cin >> s.x >> s.y >> t.x >> t.y;\n        s.z = 0, t.z = 0;\n        double ans = INF;\n        while (n--) {\n            Vec a, b, c, d;\n            double h;\n            cin >> a.x >> a.y >> c.x >> c.y >> h;\n            b.x = a.x, b.y = c.y, d.x = c.x, d.y = a.y;\n            a.z = b.z = c.z = d.z = 0;\n            if (a.x < min(s.x, t.x) && a.y < min(s.y, t.y) && c.x > max(s.x, t.x) && c.y > max(s.y, t.y)) ans = 0;\n            ans = min(ans, dist(s, t, a, b, h));\n            ans = min(ans, dist(s, t, b, c, h));\n            ans = min(ans, dist(s, t, c, d, h));\n            ans = min(ans, dist(s, t, d, a, h));\n        }\n        cout << setprecision(8) << fixed << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define EPS 1e-10\n \nusing namespace std;\ntypedef long long int ll;\n \ndouble add(double a, double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b))) return 0;\n\treturn a+b;\n}\n \nstruct P{\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y): x(x), y(y){\n\t}\n\tP operator+ (P p){\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator- (P p){\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator* (double d){\n\t\treturn P(x*d, y*d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n};\n \nbool on_seg(P p1, P p2, P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n \nP intersection(P p1, P p2, P q1, P q2){\n\treturn p1+(p2-p1)*((q2-q1).det(q1-p1) / (q2-q1).det(p2-p1));\n}\n\ndouble dist(P p1, P p2, P q){\n\tdouble d1=sqrt((p1-q).dot(p1-q)), d2=sqrt((p2-q).dot(p2-q));\n\tif(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS){\n\t\treturn d1;\n\t}\n\tP r=P((p2-p1).y, (p1-p2).x);\n\tP s=intersection(p1, p2, q, q+r);\n\tif(on_seg(p1, p2, s)){\n\t\treturn sqrt((q-s).dot(q-s));\n\t}else{\n\t\treturn min(d1, d2);\n\t}\n}\n\ndouble dist_segs(P p1, P p2, P q1, P q2){\n\tif((q2-q1).det(p2-p1)!=0){\n\t\tP r=intersection(p1, p2, q1, q2);\n\t\tif(on_seg(p1, p2, r) && on_seg(q1, q2, r)) return 0;\n\t}\n\tdouble d1=dist(p1, p2, q1), d2=dist(p1, p2, q2), d3=dist(q1, q2, p1), d4=dist(q1, q2, p2);\n\tdouble d=min(d1, min(d2, min(d3, d4)));\n\treturn d;\n}\n\nint main()\n{\n\twhile(1){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0) return 0;\n\t\tP s, e;\n\t\tdouble sx, sy, ex, ey;\n\t\tscanf(\"%lf %lf %lf %lf\", &sx, &sy, &ex, &ey);\n\t\ts=P(sx, sy), e=P(ex, ey);\n\t\tdouble d[50], h[50];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tdouble minx, miny, maxx, maxy;\n\t\t\tP p1, p2, p3, p4;\n\t\t\tscanf(\"%lf %lf %lf %lf %lf\", &minx, &miny, &maxx, &maxy, &h[i]);\n\t\t\tp1=P(minx, miny), p2=P(maxx, miny), p3=P(maxx, maxy), p4=P(minx, maxy);\n\t\t\tif(minx<=s.x && s.x<=maxx && miny<=s.y && s.y<=maxy){\n\t\t\t\td[i]=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(minx<=e.x && e.x<=maxx && miny<=e.y && e.y<=maxy){\n\t\t\t\td[i]=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[i]=dist_segs(s, e, p1, p2);\n\t\t\td[i]=min(d[i], dist_segs(s, e, p2, p3));\n\t\t\td[i]=min(d[i], dist_segs(s, e, p3, p4));\n\t\t\td[i]=min(d[i], dist_segs(s, e, p4, p1));\n\t\t}\n\t\tdouble r1=0, r2=1000.0;\n\t\tfor(int t=0; t<100; t++){\n\t\t\tdouble r=(r1+r2)/2.0;\n\t\t\tbool e=0;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(h[i]>r){\n\t\t\t\t\tif(d[i]<r) e=1;\n\t\t\t\t}else{\n\t\t\t\t\tdouble d0=sqrt(r*r-(r-h[i])*(r-h[i]));\n\t\t\t\t\tif(d[i]<d0) e=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(e==0){\n\t\t\t\tr1=r;\n\t\t\t}else{\n\t\t\t\tr2=r;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.6lf\\n\", r1);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p1;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n//\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tint x=ccw(s.p1,s.p2,pr);\n//\tif(x>=-1&&x<=1) return d;\n\tif(x==0) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t//\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\tif(ccw(q[0],q[1],r)==0){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t//\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\tif(ccw(p[0],p[1],r)==0){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// cpp_range (generic range class, very small equivalent of boost::irange)\n// (C) @cielavenir under Boost Software License.\n// note: end position is exclusive.\n\n#include <iterator>\ntemplate<typename T>\nclass range{\npublic:\n\tstruct iterator{\n\t\tconst T a,b;\n\t\tT p;\n\t\tconst long long d; //because T might be unsigned.\n\t\titerator(T _a,T _b,T _p,long long _d=1):a(_a),b(_b),p(_p),d(_d){}\n\n\tpublic:\n\t\ttypedef T value_type;\n\t\ttypedef T& reference;\n\t\ttypedef T* pointer;\n\t\ttypedef std::ptrdiff_t difference_type;\n\t\ttypedef std::random_access_iterator_tag iterator_category;\n\n\t\t//copy\n\t\titerator(const iterator &other):a(other.a),b(other.b),p(other.p),d(other.d){}\n\t\titerator operator=(const iterator &other){return iterator(other.a,other.b,other.p,other.d);}\n\n\t\t//advance\n\t\titerator& operator+=(T n){p+=n*d;return *this;}\n\t\titerator& operator-=(T n){return *this+=(-n);}\n\t\titerator& operator++(){return *this+=1;}\n\t\titerator& operator--(){return *this-=1;}\n\t\titerator operator+(T n) const{return iterator(a,b,p+n*d);}\n\t\titerator operator-(T n) const{return *this+(-n);}\n\n\t\t//difference\n\t\tT operator-(const iterator& other) const{return p-other.p;}\n\n\t\t//equality\n\t\tbool operator==(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p==other.p;}\n\t\tbool operator!=(const iterator& other) const{return !(*this==other);}\n\n\t\t//compare\n\t\tbool operator<(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p*d<other.p*d;}\n\t\tbool operator>(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p*d>other.p*d;}\n\n\t\t//reference\n\t\tconst T& operator*() const{return p;}\n\t};\n\nprivate:\n\tconst T a,b;\n\tT siz;\n\tlong long d;\npublic:\n\trange(T _a,T _b,long long _d=1):a(_a),b(_b){\n\t\td=_d;\n\t\tif(d==0)d=1; //\n\t\tsiz=( (d>0?(b-a):(a-b)) - 1)  / (d>0?d:-d);\n\t}\n\n\tT operator[](T n){return a+n*d;}\n\titerator begin(){return iterator(a,a+d*siz,a,d);}\n\titerator end(){return iterator(a,a+d*siz,a+d*(siz+1),d);}\n\titerator rbegin(){return iterator(b-d*siz,b,b,-1*d);}\n\titerator rend(){return iterator(b-d*siz,b,b-d*(siz+1),-1*d);}\n\tT size(){return siz;}\n};\ntemplate<typename T>\nrange<T> make_range(T a,T b,long long d=1){return range<T>(a,b,d);}\n\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cfloat>\nusing namespace std;\ntypedef double val_t;\ntypedef complex<val_t> P;\ntypedef vector<P> VP;\nconst val_t EPS=1e-9;\n\nval_t cross(const P &a,const P &b){return (conj(a)*b).imag();}\nval_t dot(const P &a,const P &b){return (conj(a)*b).real();}\nP projection(const VP &l,const P &p){\n\tP t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n\treturn l[0]+t*(l[0]-l[1]);\n}\nbool intersectSP(const VP &s,const P &p){\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nval_t distanceSP(const VP &s,const P &p){\n\tP r=projection(s,p);\n\tif(intersectSP(s,r))return abs(r-p);\n\treturn min(abs(s[0]-p),abs(s[1]-p));\n}\nbool intersectSS(const VP &l,const VP &m){\n\tval_t a=cross(l[1]-l[0],m[1]-m[0]);\n\tval_t b=cross(l[1]-l[0],l[1]-m[0]);\n\t//VP pt=abs(a)<EPS ? abs(b)<EPS ? {l[0],l[1],m[0],m[1]} : VP() : {m[0]+b/a*(m[1]-m[0])};\n\tVP pt=vector<VP>{{l[0],l[1],m[0],m[1]},{},{m[0]+b/a*(m[1]-m[0])}}[abs(a)<EPS?abs(b)<EPS?0:1:2];\n\treturn accumulate(pt.begin(),pt.end(),false,[&](bool S,const P &e){\n\t\treturn S||(dot(l[0]-e,l[1]-e)<EPS && dot(m[0]-e,m[1]-e)<EPS);\n\t});\n}\nval_t distanceSS(const VP &s,const VP &t){\n\tif(intersectSS(s,t))return 0;\n\treturn min(\n\t\taccumulate(s.begin(),s.end(),DBL_MAX,[&](val_t S,const P &e){return min(S,distanceSP(t,e));}),\n\t\taccumulate(t.begin(),t.end(),DBL_MAX,[&](val_t S,const P &e){return min(S,distanceSP(s,e));})\n\t);\n}\nint main(){\n\tint n;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tdouble sx,sy,ex,ey;\n\t\tscanf(\"%lf%lf%lf%lf\",&sx,&sy,&ex,&ey);\n\t\tVP s={P(sx,sy),P(ex,ey)};\n\t\tauto ra0=make_range(0,n);\n\t\tvector<val_t>r;\n\t\tprintf(\"%f\\n\",accumulate(ra0.begin(),ra0.end(),DBL_MAX,[&](val_t S,int _)->val_t{\n\t\t\tint f=0;\n\t\t\tdouble x1,y1,x2,y2,h;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf\",&x1,&y1,&x2,&y2,&h);\n\t\t\tVP a;\n\t\t\tfor(auto &x:{x1,x2})for(auto &y:{y1,y2})a.emplace_back(x,y);\n\t\t\tswap(a[2],a[3]);\n\t\t\tauto ra1=make_range(0,4);\n\t\t\tvector<val_t>vd;\n\t\t\tval_t d=accumulate(ra1.begin(),ra1.end(),DBL_MAX,[&](val_t S,int i){\n\t\t\t\tf+=cross(a[i]-s[0],a[(i+1)%4]-s[0])<EPS;\n\t\t\t\treturn min(S,distanceSS(s,{a[i],a[(i+1)%4]}));\n\t\t\t});\n\t\t\treturn min(S,\n\t\t\t\tf==4 ? 0 : //inside\n\t\t\t\td>h ? (h*h+d*d)/h/2 :\n\t\t\t\td\n\t\t\t);\n\t\t}));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\nconst double EPS = 1e-8;\n\n\ntemplate<class T> bool eq(T a, T b) { return abs(a - b) < EPS; }\n// point ??? complex<double> ??§???????????????????????????\n#define CPR const Point&\n/*\nstruct Point {\n    using T = double;\n  private:\n    T x, y;\n  public:\n    Point() {}\n    Point(T x, T y):x(x), y(y) {}\n    T X() const { return x; }\n    T Y() const { return y; }\n    bool operator == (CPR p) const { return eq(x, p.x) and eq(y, p.y); }\n    bool operator != (CPR p) const { return !(*this == p); }    \n    Point operator + (CPR p) const { return Point(x + p.x, y + p.y); }\n    Point operator - (CPR p) const { return *this + (-p); }\n    // x, y ???\n    bool operator <  (CPR p) const { return !eq(x, p.x) ? x < p.x : y < p.y; }\n    bool operator >  (CPR p) const { return !eq(x, p.x) ? x > p.x : y > p.y; }\n    Point operator - () const { return Point(-x, -y); }\n    Point operator * (T k) const { return Point(x * k, y * k); }\n    Point operator / (T k) const { return Point(x / k, y / k); }\n    friend istream &operator >> (istream& is, Point& p) { return is >> p.x >> p.y;}\n    friend ostream &operator << (ostream& os, CPR p) { return os << \"(\" << p.x << \",\" << p.y << \")\";}\n};\n*/\n\nusing Point = complex<double>;\n#define X(a) real(a)\n#define Y(a) imag(a)\nbool operator < (CPR a, CPR b) { return !eq(a.X(), b.X()) ? a.X() < b.X() : a.Y() < b.Y(); }\nbool operator > (CPR a, CPR b) { return !eq(a.X(), b.X()) ? a.X() > b.X() : a.Y() > b.Y(); }\nistream &operator >> (istream& is, Point& p) { double a, b; is >> a >> b; p.X(a); p.Y(b); return is; }\n\ndouble dot(CPR a, CPR b) { return a.X() * b.X() + a.Y() * b.Y(); }\ndouble cross(CPR a, CPR b) { return a.X() * b.Y() - a.Y() * b.X(); }\ndouble length2(CPR p) { return p.X() * p.X() + p.Y() * p.Y(); }\ndouble length(CPR p) { return sqrt(length2(p)); }\ndouble distance(CPR a, CPR b) { return length(a - b); }\nPoint unit(CPR p) { return p / length(p); }\n\nenum ccw_t {\n    COUNTER_CLOCK_WISE = 1,\n    CLOCK_WISE = -1,\n    STRAIGHT_C_A_B = 2,\n    STRAIGHT_A_B_C = -2,\n    STRAIGHT_A_C_B = 0\n};\n\nccw_t ccw(CPR a, CPR b, CPR c){\n    Point ab = b - a, ac = c - a;\n    if( cross(ab,ac) > EPS ) return COUNTER_CLOCK_WISE; // +1 a-b-c ???????¨???????\n    if( cross(ab,ac) < -EPS ) return CLOCK_WISE;        // -1 a-b-c ????¨???????\n    if( dot(ab,ac) < -EPS ) return STRAIGHT_C_A_B;      // +2 c-a-b\n    if( length2(ab) < length2(ac) )return STRAIGHT_A_B_C;     // -2 a-b-c or a==b\n    return STRAIGHT_A_C_B;                              //  0 a-c-b or b==c or a==c\n}\n\n#define CSR const Segment&\nstruct Segment {\n    Point a, b;\n    Segment(){}\n    Segment(const Point& a, const Point& b):a(a), b(b){}\n    pair<Point,Point> to_pair() const { return make_pair(a,b); }\n    bool operator == (CSR s) const { return to_pair() == s.to_pair();}\n    bool operator != (CSR s) const { return !(*this == s); }\n    friend istream &operator >> (istream& is, Segment &s){ return is >> s.a >> s.b;}\n    friend ostream &operator << (ostream& os, CSR s) { return os << s.a << \"->\" << s.b;}\n};\ndouble length(CSR s) {\n    return distance(s.a, s.b);\n}\nbool contain(CSR s, CPR p) {\n    return ccw(s.a, s.b, p) == 0; // STRAIGHT_A_C_B;\n}\nPoint projection(CSR s, CPR p) {\n    Point v = s.b - s.a;\n    double t = dot(p - s.a, v) / length2(v); // ??????\n    return v * t + s.a;\n}\nPoint closest_point(CSR s, CPR p) {\n    Point pp = projection(s, p);\n    return contain(s, pp) ? pp : distance(s.a, p) < distance(s.b, p) ? s.a : s.b;\n}\ndouble distance(CSR s, CPR p) {\n    if( dot(s.b - s.a ,p - s.a) < EPS ) return distance(p, s.a);\n    if( dot(s.a - s.b ,p - s.b) < EPS ) return distance(p, s.b);\n    return abs(cross(s.b - s.a, p - s.a) / length(s));\n}\nbool intersect(CSR s, CSR t) { // ????????????\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 and ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\nstruct Rectangle {\n    array<Point, 4> p;\n    // order:\n    //     3 2\n    //     0 1\n    Rectangle(const array<Point, 4> &pp):p(pp) {\n        // ????????????????????????????????????\n        rep(i, 3) repeat(j, i + 1, 4) {\n            int cnt = 0;\n            rep(k, 4) if(k != i and k != j){\n                cnt += ccw(p[i], p[j], p[k]) == COUNTER_CLOCK_WISE;\n            }\n            if(cnt == 2) {\n                swap(p[i + 1], p[j]);\n                break;\n            }\n        } \n    }\n    bool intersect(CSR s) {\n        bool res = false;\n        rep(i, 4) res |= ::intersect(s, Segment(p[i], p[(i + 1) % 4]));\n        return res;\n    }\n    bool contain(CPR pp) {\n        bool flg = true;\n        rep(i, 4) flg &= ccw(p[i], p[(i + 1) % 4], pp) == COUNTER_CLOCK_WISE;\n        return flg;\n    }\n    bool contain(CSR s) {\n        return contain(s.a) and contain(s.b);\n    }\n    Point closest_point(CPR pp) {\n        Point res = p[0];\n        rep(i, 4) {\n            Point ppp = ::closest_point(Segment(p[i], p[(i+1)%4]), pp);\n            if(distance(res, pp) > distance(ppp, pp)) res = ppp;\n        }\n        return res;\n    }\n    Point closest_point(CSR s) {\n        Point res = p[0];\n        repeat(i, 1, 4) if(distance(s, res) > distance(s, p[i])) res = p[i];\n        for(Point pp : {s.a, s.b}) {\n            Point ppp = closest_point(pp);\n            if(distance(s, res) > distance(s, ppp)) res = ppp;\n        }\n        return res;\n    }\n};\n\n\nclass Solver {\n  public:\n    Segment S;\n    vector<Point> minP, maxP;\n    vector<double> H;\n    bool solve() {\n\n        int N; cin >> N;\n        if(not N) return false;\n        cin >> S;\n        minP.resize(N);\n        maxP.resize(N);\n        H.resize(N);\n        rep(i, N) cin >> minP[i] >> maxP[i] >> H[i];\n        \n        double max_r = INF;\n\n        rep(i, N) {            \n            Rectangle rect({minP[i], maxP[i], Point(minP[i].X(), maxP[i].Y()), Point(maxP[i].X(), minP[i].Y())});\n\n            if(rect.intersect(S) or rect.contain(S)) {\n                cout << 0 << endl;\n                return true;\n            }\n\n            double d = distance(S, rect.closest_point(S));\n            double r = (d * d + H[i] * H[i]) / (2 * H[i]);\n            if(r < H[i]) r = d;\n            set_min(max_r, r);\n        }\n\n        cout << max_r << endl;\n        return true;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\nint n;\nint sx,sy,gx,gy;\nint xa[SIZE],ya[SIZE],xb[SIZE],yb[SIZE],h[SIZE];\n\ntypedef double P_type;\ntypedef complex<P_type> P;\nconst P_type P_eps = 1e-8;\n\n//??????\ndouble dot(P a, P b) {\n  return (a * conj(b)).real();\n}\n\n//??????\ndouble cross(P a, P b) {\n  return (a * conj(b)).imag();\n}\n\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < P_eps ) return abs(c-a);\n  if ( dot(a-b, c-b) < P_eps ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n/* ?????????????????? */\nbool IntersectionSS(P a1,P a2, P b1, P b2){\n    \n  //??????a ??¨ ??´???b\n  P_type a = cross(b1-b2,a1-b1);\n  P_type b = cross(b1-b2,a2-b1);\n  \n  //??????b ??¨ ??´???a\n  P_type c = cross(a1-a2,b1-a1);\n  P_type d = cross(a1-a2,b2-a1);\n  \n  if(a*b<P_eps && c*d<P_eps) // T?????????????????? -P_eps\n    return true;\n  else\n    return false;\n}\n\nbool check(double r){\n  \n  P l_s = P(sx,sy);\n  P l_g = P(gx,gy);\n  \n  for(int i=0;i<n;i++){\n    P p[4];\n    p[0] = P(xa[i],ya[i]);\n    p[1] = P(xa[i],yb[i]);\n    p[2] = P(xb[i],yb[i]);\n    p[3] = P(xb[i],ya[i]);\n    double H = min((double)h[i],r);\n    double R = sqrt(r*r - (r-H)*(r-H));\n\n    for(int j=0;j<4;j++){\n      double dis = distance_ls_p(l_s, l_g, p[j]);\n      bool is = IntersectionSS(l_s,l_g,p[j],p[(j+1)%4]);\n      bool in = (xa[i] <= sx && sx <= xb[i] && ya[i] <= sy && sy <= yb[i]) ||\n        (xa[i] <= gx && gx <= xb[i] && ya[i] <= gy && gy <= yb[i]);\n      \n      if(dis < R || is || in){\n        return false;\n      }\n    }\n  }\n  \n  for(int i=0;i<n;i++){\n    P p[4];\n    p[0] = P(xa[i],ya[i]);\n    p[1] = P(xa[i],yb[i]);\n    p[2] = P(xb[i],yb[i]);\n    p[3] = P(xb[i],ya[i]);\n    double H = min((double)h[i],r);\n    double R = sqrt(r*r - (r-H)*(r-H));\n\n    for(int j=0;j<4;j++){\n      double dis1 = distance_ls_p(p[j],p[(j+1)%4],l_s);\n      double dis2 = distance_ls_p(p[j],p[(j+1)%4],l_g);\n      \n      if(dis1 < R || dis2 < R){\n        return false;\n      }\n    }\n\n  }\n  \n  return true;\n}\n\nbool solve(){\n  \n  \n  scanf(\"%d\",&n);\n\n  if(n == 0) return false;\n\n  scanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d%d%d%d\",xa+i, ya+i, xb+i, yb+i, h+i);\n  }\n\n  double l=0, r=1000;\n\n  while(r-l > 1e-8){\n    double mid = (l+r)/2;\n\n    if(check(mid)){\n      l = mid;\n    }else{\n      r = mid;\n    }\n  }\n\n  printf(\"%.7lf\\n\",l);\n  \n  return true;\n}\n\nint main(){\n\n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ndouble PI=acos(-1.0);\n#define eps (1e-6)\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n    Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n    Point operator*(Point p) {return Point(x*p.x-y*p.y,x*p.y+y*p.x);}\n    Point operator*(double k){return Point(x*k,y*k);}\n    Point operator/(double k){return Point(x/k,y/k);}\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n    bool operator == (const Point &p) const{return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n    double arg(){return atan2(y,x);}\n    double dot(Point p){return x*p.x+y*p.y;}\n    double det(Point p){return x*p.y-y*p.x;}\n};\nstruct Line{\n    Point p1,p2;\n    Line(){}\n    Line(Point p1, Point p2):p1(p1),p2(p2){}\n};\nint ccw(Point a,Point b,Point c){\n    Point t1=b-a,t2=c-a;\n    if(t1.det(t2)> eps) return 1;//counter clockwise\n    if(t1.det(t2)< -eps) return -1;//clockwise\n    if(t1.dot(t2)< -eps) return 2;//c-a-b online\n    if(t1.norm()<t2.norm()) return -2;//a-b-c online\n    return 0;//a-c-b online\n}\nbool intersectSS(Point a,Point b,Point c,Point d){\n    return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n}\nPoint project(Line l,Point p){\n    Point base=l.p2-l.p1;\n    double r=(p-l.p1).dot(base)/base.norm();\n    return l.p1+base*r;\n}\ndouble distanceLP1(Line l,Point p){\n    Point r=project(l,p);\n    if(abs(ccw(l.p1,l.p2,r))==0) return (p-r).abs();\n    else return min((p-l.p1).abs(),(p-l.p2).abs());//projection not online\n}\ndouble x[2],y[2],h[51];\nLine l;\nPoint po[51];\nint n;\nbool test(double d){\n    rep(i,n){\n        double dist=distanceLP1(l,po[i]);\n        if(d<=h[i]){\n            if(dist<d) return false;\n        }\n        else{\n            if((h[i]*h[i]+dist*dist)/(2.0*h[i])<d) return false;\n        }\n    }\n    return true;\n}\nint main(){\n    double sx,sy,ex,ey;\n    while(cin>>n,n){\n        cin>>sx>>sy>>ex>>ey;\n        Point s=Point(sx,sy),e=Point(ex,ey);\n        l=Line(s,e);\n        bool flag=false;\n        rep(i,n){\n            cin>>x[0]>>y[0]>>x[1]>>y[1]>>h[i];\n            rep(j,2)rep(k,2)rep(q,2)rep(r,2){\n                if(intersectSS(s,e,Point(x[j],y[k]),Point(x[q],y[r]))) flag=true;\n            }\n            double mn=10001000,cx,cy;\n            rep(j,2)rep(k,2){\n                double td=distanceLP1(l,Point(x[j],y[k]));\n                if(td<mn) mn=td,cx=x[j],cy=y[k];\n            }\n            rep(j,2)rep(k,2)rep(q,2)rep(r,2){\n                Line l2=Line(Point(x[j],y[k]),Point(x[q],y[r]));\n                double td=distanceLP1(l2,s);\n                if(td<mn){\n                    mn=td;\n                    Point tp=project(l2,s);\n                    cx=tp.x,cy=tp.y;\n                }\n                td=distanceLP1(l2,e);\n                if(td<mn){\n                    mn=td;\n                    Point tp=project(l2,e);\n                    cx=tp.x,cy=tp.y;\n                }\n            }\n            po[i]=Point(cx,cy);\n        }\n        if(flag){\n            cout<<0.0<<endl;\n            continue;\n        }\n        double lb=0,ub=1000;\n        while(ub-lb>eps){\n            double mid=(ub+lb)/2;\n            if(test(mid)) lb=mid;\n            else ub=mid;\n        }\n        cout<<fixed<<setprecision(7)<<lb<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\nstruct Circle;\nstruct Segment;\ntypedef Segment Line;\ndouble norm(Point a);\ndouble abs(Point a);\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistance(Point a, Point b);\ndouble getDistanceLP(Line l, Point p);\ndouble getDistanceSP(Segment s, Point p);\ndouble getDistance(Segment s1, Segment s2);\nbool isOrthogonal(Vector a, Vector b);\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2);\nbool isOrthogonal(Segment s1, Segment s2);\nbool isParallel(Vector a, Vector b);\nbool isParallel(Point a1, Point a2, Point b1, Point b2);\nbool isParallel(Segment s1, Segment s2);\nint ccw(Point p0, Point p1, Point p2);\nbool intersect(Point p1, Point p2, Point p3, Point p4);\nbool intersect(Segment s1, Segment s2);\nbool intersect(Circle c, Line l); // 誤差の検証をしていない\nbool intersect(Circle c1, Circle c2); // 誤差の検証をしていない\n\nPoint project(Segment s, Point p);\nPoint reflect(Segment s, Point p);\nPoint getCrossPoint(Segment s1, Segment s2);\npair<Point,Point> getCrossPoints(Circle c, Line l);\npair<Point,Point> getCrossPoints(Circle c1, Circle c2); // 誤差の検証をしていない\npair<Point,Point> getContactPoints(Circle c, Point p); // 接点 点は円の外部\n\ndouble area(Polygon g); // convexでなくてもよい. absを消せば符号付き面積\nbool isConvex(Polygon g); // O(n^2) 線形時間アルゴリズムが存在するらしい\nint contains(Polygon g, Point p);\n\ndouble arg(Vector p);   // 偏角\nVector polar(double a, double r); // 極座標系->ベクトル\n\nPolygon andrewScan(Polygon g); // 凸包の辺上の点も含めたければ!=CLOCKWISEを==COUNTER_CLOCKWISEに\ndouble convexDiameter(Polygon g); // gはconvex \n\n\nstruct Point{\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n    Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n    Point operator * (double a){ return Point(a*x, a*y); }\n    Point operator / (double a){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x*x + y*y; }\n\n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\n\ndouble norm(Point a){\n    return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Point a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble getDistance(Point a, Point b){\n    return abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2-s.p1, p-s.p1) < 0.0)    return abs(p-s.p1);\n    if(dot(s.p1-s.p2, p-s.p2) < 0.0)    return abs(p-s.p2);\n    return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n    if(intersect(s1, s2))   return 0.0;\n    return min({getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), \n                getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)});\n}\n\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n    return isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1, Segment s2){\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n    return isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1, Segment s2){\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;   // p2->p0->p1\nstatic const int ONLINE_FRONT = -2; // p0->p1->p2\nstatic const int ON_SEGMENT = 0;    // p0->p2->p1\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS)   return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS)  return CLOCKWISE;\n    if(dot(a, b) < -EPS)    return ONLINE_BACK;\n    if(norm(a) < norm(b))   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nbool intersect(Circle c, Line l){\n    return getDistanceLP(l, c.c) < c.r+EPS;\n}\nbool intersect(Circle c1, Circle c2){\n    return abs(c1.r-c2.r) <= getDistance(c1.c, c2.c) && getDistance(c1.c, c2.c) < c1.r+c2.r+EPS;\n}\n\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2.0;\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1-s2.p1));\n    double d2 = abs(cross(base, s1.p2-s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point,Point> getCrossPoints(Circle c, Line l){\n    assert(intersect(c, l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e*base, pr - e*base);\n}\n\npair<Point,Point> getCrossPoints(Circle c1, Circle c2){\n    assert(intersect(c1, c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos( (c1.r*c1.r + d*d - c2.r*c2.r)/(2*c1.r*d) );\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t+a), c1.c + polar(c1.r, t-a));\n}\n\npair<Point,Point> getContactPoints(Circle c, Point p){\n    assert(c.r < getDistance(c.c, p));\n    double d = getDistance(c.c, p);\n    return getCrossPoints(c, Circle(p, sqrt(d*d-c.r*c.r)));\n}\n\ndouble area(Polygon g){\n    if(g.size() < 3)    return 0;\n    int n = g.size();\n    Point o(0.0, 0.0);\n    double s = 0.0;\n    for(int i = 0; i < n; i++)  s += cross(g[i]-o, g[(i+1)%n]-o);\n    return abs(s) / 2.0;\n}\n\nbool isConvex(Polygon g){\n    bool ret = true;\n    int n = g.size();\n    for(int i = 0; i < n; i++){\n        for(int j = i+1; j < n; j++){\n            if(cross(g[i]-g[(i+n-1)%n], g[j]-g[(i+n-1)%n]) < -EPS || cross(g[(i+1)%n]-g[i], g[j]-g[i]) < -EPS){\n                ret = false;\n            }\n        }\n    }\n    return ret;\n}\n\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0; i < n; i++){\n        Point a = g[i] - p, b = g[(i+1)%n] - p;\n        if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)   return ON;\n        if(a.y > b.y)   swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return x ? IN : OUT;\n}\n\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\nVector polar(double a, double r){\n    return Point(a * cos(r), a * sin(r));\n}\n\n\nPolygon andrewScan(Polygon g){\n    Polygon u, l;\n    if(g.size() < 3)    return g;\n    sort(g.begin(), g.end());\n    u.push_back(g[0]);\n    u.push_back(g[1]);\n    l.push_back(g[g.size()-1]);\n    l.push_back(g[g.size()-2]);\n\n    // upper\n    for(int i = 2; i < g.size(); i++){\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], g[i]) != CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.push_back(g[i]);\n    }\n\n    // lower\n    for(int i = g.size()-3; i >= 0; i--){\n        for(int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], g[i]) != CLOCKWISE; n--){\n            l.pop_back();\n        }\n        l.push_back(g[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for(int i = u.size()-2; i >= 1; i--)    l.push_back(u[i]);\n\n    return l;\n}\n\ndouble convexDiameter(Polygon g){\n    double d = 0.0;\n    int n = g.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n        if(g[i].y > g[is].y)    is = i;\n        if(g[i].y < g[js].y)    js = i;\n    }\n    d = getDistance(g[is], g[js]);\n\n    int i = is, j = js, maxi = is, maxj = js;\n    do{\n        if(cross(g[(i+1)%n]-g[i], g[(j+1)%n]-g[j]) >= 0.0)  j = (j+1)%n;\n        else    i = (i+1)%n;\n        if(getDistance(g[i], g[j]) > d){\n            d = getDistance(g[i], g[j]);\n            maxi = i, maxj = j;\n        }\n    }while(i != is || j != js);\n\n    return d; // farthest pair is (maxi, maxj).\n}\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        double ans = 1000;\n        int sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        Segment s(Point(sx,sy), Point(ex,ey));\n        for(int i = 0; i < n; i++){\n            int x[2], y[2], h;\n            cin >> x[0] >> y[0] >> x[1] >> y[1] >> h;\n            if(x[0] <= min(sx,ex) && max(sx,ex) <= x[1] && y[0] <= min(sy,ey) && max(sy,ey) <= y[1])    ans = 0;\n            Point p[4] = {Point(x[0],y[0]), Point(x[0],y[1]), Point(x[1],y[1]), Point(x[1],y[0])};\n            for(int j = 0; j < 4; j++){\n                double d = getDistance(s, Segment(p[j], p[(j+1)%4]));\n                if(d <= h)  ans = min(ans, d);\n                else        ans = min(ans, (d*d+h*h)/2/h);\n                if(intersect(s, Segment(p[j], p[(j+1)%4]))) ans = 0;\n            }\n        }\n        cout << fixed << setprecision(12) << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define uint unsigned int\n#define pii pair<int, int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORR(i,a,b) for(int i=(a);i>=(b);--i)\n#define REP(i,n) FOR(i,0,n)\n#define REPR(i,n) FORR(i,n,0)\n#define ALL(c) ((c).begin(),(c).end())\n#define PB(a) push_back(a)\n#define EMPB(...) emplace_back(__VA_ARGS__)\n#define EMP(...) emplace(__VA_ARGS__)\n#define MP(a,b) make_pair(a,b)\n#define MT(...) make_tuple(__VA_ARGS__)\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define PW(n) (1LL<<(n))\nusing namespace std;\ntemplate <class T> inline bool CHMIN(T& a, T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <class T> inline bool CHMAX(T& a, T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <class T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <class T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <class T> inline void UNI(T& a) { SORT(a); a.erase(unique(ALL(a)),a.end()); }\ntemplate <class S, class T> ostream& operator<<(ostream& os, const pair<S,T> a) {\n  return os << a.first << ' ' << a.second;\n}\nconst int MOD = 1000000007;\n// const int INF = 0x3f3f3f3f3f3f3f3f;\n// const double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* 基本要素 */\n \nusing D = double; // 座標値の型 doubleかlong double\nusing P = complex<D>; // Point\nusing L = pair<P,P>;  // Line\nusing VP = vector<P>;\nconst double EPS = 1e-8;  // 許容誤差\nconst double INF = 1e12;\n#define X real()\n#define Y imag()\n#define LT(n,m) ((n)+EPS<(m)) // n < m ?\n#define LE(n,m) ((n)-EPS<(m)) // n <= m ?\n#define GT(n,m) LT(m,n) // n > m ?\n#define GE(n,m) LE(m,n) // n >= m ?\n#define EQ(n,m) (abs((n)-(m))<EPS)\n#define NE(n,m) !EQ(n,m)\n#define rep(i,n) for (int i=0;i<(n);++i)\n \nnamespace std {\n  istream& operator >> (istream& is, P& p) {\n    int F, S;\n    is >> F >> S;\n    p = P(F,S);\n    return is;\n  }\n  bool operator < (const P a, const P b) {\n    return NE(a.X,b.X) ? LT(a.X,b.X) : LT(a.Y,b.Y);\n  }\n  bool operator > (const P a, const P b) {\n    return NE(a.X,b.X) ? GT(a.X,b.X) : GT(a.Y,b.Y);\n  }\n  bool sort_y(const P a, const P b) {\n    return LT(a.Y,b.Y);\n  }\n  void swap(P& a, P& b) {\n    P c = a; a = b; b = c;\n  }\n}\n\n// 内積\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n// 点aから見た、点bから点cへの方向\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (GT(cross(b,c),0)) return +1;  // counter clockwise\n  if (LT(cross(b,c),0)) return -1;  // clockwise\n  if (LT(dot(b,c),0)) return +2;  // c--a--b on line\n  if (LT(norm(b),norm(c))) return -2; // a--b--c on line or a==b\n  return 0;                     // a--c--b on line or a==c or b==c\n}\n\n/* 交差判定 直線・線分は縮退してはならない．接する場合は交差するとみなす */\n \n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return NE(abs(ccw(a1,a2,b)),1);\n}\n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1,b2-b1,0) || isecLP(a1,b1,b2);\n}\n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return LE(cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1),0);\n}\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 && ccw(b1,b2,a1)*ccw(b1,b2,a2) <= 0;\n}\n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n\n/* 距離 各直線・線分は縮退してはならない */\n \n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1,p-a1)/norm(a2-a1) * (a2-a1);\n}\n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1,a2,p)-p;\n}\n// 直線と点\nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1,a2,p)-p);\n}\n// 直線と直線\nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1,a2,b1,b2) ? 0 : distLP(a1,a2,b1);\n}\n// 直線と線分\nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1,a2,b1,b2) ? 0 : min(distLP(a1,a2,b1),distLP(a1,a2,b2));\n}\n// 線分と点\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1,a2,p);\n  if (isecSP(a1,a2,r)) return abs(r-p);\n  return min(abs(a1-p),abs(a2-p));\n}\n// 線分と線分\nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1,a2,b1,b2)) return 0;\n  return min(min(distSP(a1,a2,b1),distSP(a1,a2,b2)),min(distSP(b1,b2,a1),distSP(b1,b2,a2)));\n}\n\n// 凸多角形の内部判定 O(n)\n// 点が領域内部なら1、境界上なあら2、外部なら0を返す\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0],ps[1],p);\n  rep (i,n) {\n    int ccwc = ccw(ps[i],ps[(i+1)%n],p);\n    if (!ccwc) return 2;  // 線分上に存在\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n\nint N;\nP s,g;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (cin >> N >> s >> g, N) {\n    double ans = 1000;\n    REP(_,N) {\n      int minx,miny,maxx,maxy,h;\n      cin >> minx >> miny >> maxx >> maxy >> h;\n      VP ps;\n      ps.EMPB(minx,miny);\n      ps.EMPB(maxx,miny);\n      ps.EMPB(maxx,maxy);\n      ps.EMPB(minx,maxy);\n      double mind = INF;\n      for (int i = 0; i < ps.size(); i++) {\n        P p = ps[i], q = ps[(i+1)%ps.size()];\n        double d = distSS(p,q,s,g);\n        CHMIN(mind, d);\n      }\n      double r = 1000;\n      if (GE(h,mind)) r = mind;\n      else r = (h*h+mind*mind)/(2*h);\n      if (inConvex(s,ps) || inConvex(g,ps)) r = 0.0;\n      CHMIN(ans,r);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<complex>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\nconst double EPS = 1e-8;\n\n#define X real()\n#define Y imag()\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nbool eq(double a, double b) {return abs(a - b) < EPS;}\nint sig(double r) {return (r < -EPS) ? -1 : (r > EPS) ? 1: 0;}\n\nP vec(L a) {return a.second - a.first;}\n\ndouble dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\ndouble cross(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nint ccw(const P a, P b, P x) {\n  b -= a;\n  x -= a;\n  double cr = cross(b, x);\n  if (eq(cr, 0)) {\n    if (dot(b, x) < 0) return BACK;\n    if (abs(b) < abs(x)) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\nbool iSS(L a, L b) {\n  int cwaf = ccw(a.first, a.second, b.first);\n  int cwbf = ccw(b.first, b.second, a.first);\n  int cwas = ccw(a.first, a.second, b.second);\n  int cwbs = ccw(b.first, b.second, a.second);\n  if ((cwaf | cwas | cwbf | cwbs) & ON) return true;\n  return ((cwaf | cwas) & (cwbf | cwbs)) == (LEFT | RIGHT);\n}\n\ndouble dLP(L l, P x) {return abs(cross(vec(l), x - l.first)) / abs(vec(l));}\ndouble dSP(L s, P x) {\n  if (dot(vec(s), x - s.first) <= 0) return abs(x - s.first);\n  if (dot(-vec(s), x - s.second) <= 0) return abs(x - s.second);\n  return dLP(s, x);\n}\ndouble dSS(L a, L b) {return iSS(a, b) ? 0 : min(min(dSP(a, b.first), dSP(a, b.second)), min(dSP(b, a.first), dSP(b, a.second)));}\n\nP s, g;\ndouble ax, ay, bx, by, h;\n\ndouble f(L seg, double h) {\n  double a = 0, b = 1111;\n  L l = make_pair(s, g);\n  double d = dSS(seg, l);\n  //cout << d << endl;\n  while (a < b - 1e-8) {\n    double m = (a + b) / 2;\n    if (m < d) a = m;\n    else if (m < h) b = m;\n    else if (m - sqrt(max(m * m - d * d, 0.)) > h) a = m;\n    else b = m;\n  }\n  return a;\n}\n\nint main() {\n  int n;\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n    cin >> s.X >> s.Y >> g.X >> g.Y;\n    double res = 1e40;\n    rep (i, n) {\n      cin >> ax >> ay >> bx >> by >> h;\n      res = min(res, f(make_pair(P(ax, ay), P(ax, by)), h));\n      res = min(res, f(make_pair(P(ax, ay), P(bx, ay)), h));\n      res = min(res, f(make_pair(P(bx, by), P(ax, by)), h));\n      res = min(res, f(make_pair(P(bx, by), P(bx, ay)), h));\n      if (sig(ax - s.X) * sig(bx - s.X) <= 0 && sig(ay - s.Y) * sig(by - s.Y) <= 0) res = 0;\n      if (sig(ax - g.X) * sig(bx - g.X) <= 0 && sig(ay - g.Y) * sig(by - g.Y) <= 0) res = 0;\n    }\n    printf(\"%.12lf\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tif(online(s[0]) || online(s[0]) || s.online(at(0)) || s.online(at(1))) return BORDER;\n\t\t\treturn (ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1) <= 0 &&\n\t\t\t\t\tccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1) <= 0);\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return !sig(abs(p-SELF) - r) ? BORDER : abs(p-SELF) < r - EPS;}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tif(c.inside(s[0]) != FALSE && c.inside(s[1]) != FALSE) return c.inside(s[0]) | c.inside(s[1]) == 1 ? 0 : -1;\n\t\treturn less(s.distance(c), c.r);\n\t}\n\t\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tS l;\n\t\tR ans = INF;\n\t\tcin >> l;\n\t\tREP(i, n){\n\t\t\tG g;\n\t\t\tR sx, sy, tx, ty, h;\n\t\t\tcin >> sx >> sy >> tx >> ty >> h;\n\t\t\tg.emplace_back(sx, sy);\n\t\t\tg.emplace_back(sx, ty);\n\t\t\tg.emplace_back(tx, ty);\n\t\t\tg.emplace_back(tx, sy);\n\t\t\tR dist = g.distance(l);\n\t\t\tif(dist <= h) ans = min(ans, dist);\n\t\t\telse ans = min(ans, (dist*dist + h*h)*0.5/h);\n\t\t}\n\t\tprintf(\"%.4f\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<complex>\n\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define min_int(a,b) ((a)<(b)?(a):(b))\n#define INF 10000000 //2^31\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\nusing namespace std;\n\nclass Gio{\nprivate:\n\ttypedef complex<double>point;\n\tstruct line{ \n\t\tpoint st, ed;//始点,終点\n\t};\n\tpoint min_p,max_p;\n\tline orig, test;\n\tdouble min_R;//保存用\n\tdouble test_R;//実行用\n\tdouble dot(point a, point b);//内積\n\tdouble cross(point a, point b);//外積\n\npublic:\n\tGio(double sx, double sy,double ex,double ey);\n\tvoid set_p(point* p, double x, double y);\n\tvoid set_line(line* l, point s, point e);\n\tvoid set_testline(double sx, double sy, double ex, double ey);\n\tvoid calc_r(double sx,double sy,double lx,double ly,double h);\n\tdouble get_r();\n\tdouble get_d_pp();//min_pとmax_pの距離を返す\n\tdouble get_d_lp();//min_pとtestの長さを返す\n\tdouble get_d_ll();//origとtestの長さを返す\n\tbool intersect();//origとtestが交差していればtrue\n};\n\nGio::Gio(double sx, double sy, double ex, double ey){\n\tset_p(&min_p, sx, sy);\n\tset_p(&max_p, ex, ey);\n\tset_line(&orig, min_p, max_p);\n\tmin_R = INF;\n}\nvoid Gio::set_p(point *p, double x, double y){\n\tpoint a(x, y);\n\t*p = a;\n}\nvoid Gio::set_line(line* l, point s, point e){\n\tl->st = s;\n\tl->ed=e;\n}\nvoid Gio::set_testline(double sx,double sy,double ex,double ey){\n\tpoint a, b;\n\tset_p(&a, sx, sy); set_p(&b, ex, ey);\n\tset_line(&test, a, b);\n\t//printf(\"%lf,%lf\\n\", test.st.real(), test.st.imag());\n}\ndouble Gio::dot(point a, point b){\n\treturn(a.real()*b.real() + a.imag()*b.imag());\n}\ndouble Gio::cross(point a, point b){\n\treturn(a.real()*b.imag() - a.imag()*b.real());\n}\ndouble Gio::get_d_pp(){ return(abs(max_p - min_p)); }\ndouble Gio::get_d_lp(){\n\tpoint a = test.st;\n\tpoint b = test.ed;\n\tpoint c = min_p;\n\tif (dot(b - a, c - a) < EPS)return(abs(c - a));\n\tif (dot(a - b, c - b) < EPS)return(abs(c - b));\n\treturn(abs(cross(b - a, c - a)) / abs(b - a));\n}\nbool Gio::intersect(){\n\tpoint a = orig.st, b = orig.ed, c = test.st, d = test.ed;\n\treturn((cross(b - a, c - a)*cross(b - a, d - a) < EPS) && (cross(d - c, a - c)*cross(d - c, b - c) < EPS));\n}\n\ndouble Gio::get_d_ll(){\n\tif (intersect())return(0);\n\tpoint a0, a1,b0,b1;\n\ta0 = orig.st;\n\ta1 = orig.ed;\n\tb0 = test.st;\n\tb1 = test.ed;\n\tdouble d1, d2, d3, d4;\n\tmin_p = a0; d1 = get_d_lp();\n\tmin_p = a1; d2 = get_d_lp();\n\tset_line(&test, a0, a1);\n\tmin_p = b0; d3 = get_d_lp();\n\tmin_p = b1; d4 = get_d_lp();\n\td1 = min_int(d1, d2);\n\td2 = min_int(d3, d4);\n\treturn(min_int(d1, d2));\n}\n\nvoid Gio::calc_r(double sx, double sy, double lx, double ly,double h){\n\tdouble d1, d2, d3, d4;\n\tpoint p = orig.st;\n\tif (sx <= p.real() && p.real() <= lx&&sy <= p.imag()&&p.imag() <= ly){\n\t\tmin_R = 0; return;\n\t}\n\n\tset_testline(sx, sy, sx, ly); d1 = get_d_ll();\n\tset_testline(sx, sy, lx, sy); d2 = get_d_ll();\n\tset_testline(sx, ly, lx, ly); d3 = get_d_ll();\n\tset_testline(lx, sy, lx, ly); d4 = get_d_ll();\n\td1 = min_int(min_int(d1, d2), min_int(d3, d4));\n\tif (h >= d1)test_R = d1;\n\telse{\n\t\ttest_R = ((d1*d1 + h*h) / h) / 2;\n\t}\n\tmin_R = min_int(min_R, test_R);\n}\ndouble Gio::get_r(){\n\treturn(min_R);\n}\n\nint b_num;\n\n\n\nint main(void){\n\t//Gio g(1, 1, 2, 2);\n\t//g.set_testline(1, 2, 2, 3);\n\t//cout << g.get_d_ll()<<endl;\n\twhile (true){\n\t\tcin >> b_num;\n\t\tif (b_num == 0)return(0);\n\t\tdouble sx, sy, ex, ey,h;\n\t\tcin >> sx >> sy>>ex >> ey;\n\t\tGio g(sx, sy, ex, ey);\n\t\trep(i, 0, b_num){\n\t\t\tcin >> sx >> sy >> ex >> ey>>h;\n\t\t\tg.calc_r(sx, sy, ex, ey, h);\n\t\t}\n\n\t\tprintf(\"%.10lf\\n\", g.get_r());\n\n\t}\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<double, double> PDD;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nPDD operator-(const PDD &a, const PDD &b) {\n  return PDD(a.fi - b.fi, a.se - b.se);\n}\n\ndouble len(PDD p) {\n  return sqrt(p.fi * p.fi + p.se * p.se);\n}\n\ndouble dot(PDD a, PDD b) {\n  return a.fi * b.fi + a.se * b.se;\n}\n\ndouble cross(PDD a, PDD b) {\n  return a.fi * b.se - a.se * b.fi;\n}\n\ndouble distance(PDD p1, PDD p2, PDD q1, PDD q2) {\n  if (cross(p2 - p1, q1 - p1) * cross(p2 - p1, q2 - p1) < 0 && cross(q2 - q1, p1 - q1) * cross(q2 - q1, p2 - q1) < 0) {\n    return 0;\n  } else {\n    double mini = INF;\n    if (dot(p2 - p1, q1 - p1) < 1e-7) minch(mini, len(q1 - p1));\n    else if (dot(p1 - p2, q1 - p2) < 1e-7) minch(mini, len(q1 - p2));\n    else minch(mini, abs(cross(p2 - p1, q1 - p1)) / len(p2 - p1));\n\n    if (dot(p2 - p1, q2 - p1) < 1e-7) minch(mini, len(q2 - p1));\n    else if (dot(p1 - p2, q2 - p2) < 1e-7) minch(mini, len(q2 - p2));\n    else minch(mini, abs(cross(p2 - p1, q2 - p1)) / len(p2 - p1));\n\n    if (dot(q2 - q1, p1 - q1) < 1e-7) minch(mini, len(p1 - q1));\n    else if (dot(q1 - q2, p1 - q2) < 1e-7) minch(mini, len(p1 - q2));\n    else minch(mini, abs(cross(q2 - q1, p1 - q1)) / len(q2 - q1));\n\n    if (dot(q2 - q1, p2 - q1) < 1e-7) minch(mini, len(p2 - q1));\n    else if (dot(q1 - q2, p2 - q2) < 1e-7) minch(mini, len(p2 - q2));\n    else minch(mini, abs(cross(q2 - q1, p2 - q1)) / len(q2 - q1));\n\n    return mini;\n  }\n}\n\nint main(){\n  int n;\n  while(cin >> n, n) {\n    PDD s, e;\n    cin >> s.fi >> s.se >> e.fi >> e.se;\n    vector<double> v;\n\n    bool ok = true;\n    rep(i, n) {\n      PDD mi, ma;\n      double h;\n      cin >> mi.fi >> mi.se >> ma.fi >> ma.se >> h;\n      double mini = INF;\n      minch(mini, distance(s, e, mi, PDD(ma.fi, mi.se)));\n      minch(mini, distance(s, e, mi, PDD(mi.fi, ma.se)));\n      minch(mini, distance(s, e, ma, PDD(ma.fi, mi.se)));\n      minch(mini, distance(s, e, ma, PDD(mi.fi, ma.se)));\n      minch(mini, distance(s, e, mi, ma));\n      if (mini == 0) {\n        ok = false;\n        break;\n      } else {\n        if (mini < h) {\n          v.pb(mini);\n        } else {\n          double high = 10000, low = mini, mid;\n          rep(j, 100) {\n            mid = (high + low) / 2;\n            if ((mid - h) * (mid - h) + mini * mini >= mid * mid) low = mid;\n            else high = mid;\n          }\n          v.pb(low);\n        }\n      }\n    }\n\n    if (ok) {\n      sort(all(v));\n      printf(\"%.10f\\n\", v[0]);\n    } else {\n      printf(\"0\");\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tif(online(s[0]) || online(s[0]) || s.online(at(0)) || s.online(at(1))) return BORDER;\n\t\t\treturn (ccw(at(0), at(1),  s[0]) * ccw(at(0), at(1),  s[1]) <= 0 &&\n\t\t\t\t\tccw( s[0],  s[1], at(0)) * ccw( s[0],  s[1], at(1)) <= 0);\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return !sig(abs(p-SELF) - r) ? BORDER : abs(p-SELF) < r - EPS;}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tif(c.inside(s[0]) != FALSE && c.inside(s[1]) != FALSE) return c.inside(s[0]) | c.inside(s[1]) == 1 ? 0 : -1;\n\t\treturn less(s.distance(c), c.r);\n\t}\n\t\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at((i+1)%size()));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()) res = min(res, edge(i).distance(t));\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tS l;\n\t\tR ans = INF;\n\t\tcin >> l;\n\t\tREP(i, n){\n\t\t\tG g;\n\t\t\tR sx, sy, tx, ty, h;\n\t\t\tcin >> sx >> sy >> tx >> ty >> h;\n\t\t\tg.emplace_back(sx, sy);\n\t\t\tg.emplace_back(sx, ty);\n\t\t\tg.emplace_back(tx, ty);\n\t\t\tg.emplace_back(tx, sy);\n\t\t\tR dist = g.distance(l);\n\t\t\tif(dist <= h) ans = min(ans, dist);\n\t\t\telse ans = min(ans, (dist*dist + h*h)*0.5/h);\n\t\t}\n\t\tprintf(\"%.10f\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n \nusing namespace std;\n \ntypedef long long lint;\n \n//?????°\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n \n//???????????¢??£\n#define zclear(a) memset((a), 0 ,sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n \n//???????????°??????\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n \nbool eq(double a, double b) //a == b\n{\n    return (fabs(a - b) <= EPS);\n}\n \nbool neq(double a, double b) //a != b\n{\n    return (!eq(a, b));\n}\n   \nbool lt(double a, double b) //a < b\n{\n    return (a - b < -EPS);\n}\n   \nbool leq(double a, double b) //a <= b\n{\n    return (lt(a, b) || eq(a, b));\n}\n   \nbool gt(double a, double b) //a > b\n{\n    return (a - b > +EPS);\n}\n   \nbool geq(double a, double b) //a >= b\n{\n    return (gt(a, b) || eq(a, b));\n}\n \nclass Point{\npublic:\n    double x, y;\n    Point(double x = 0, double y = 0): x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(x * a, y * a);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    Point operator * (const Point &a){\n        return Point(x * a.x - y * a.y, x * a.y + y * a.x);\n    }\n    bool operator < (const Point &p) const {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const Point &p) const {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n};\n \ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n \ndouble norm(Vector a){return (a.x * a.x + a.y * a.y);}\ndouble abs(Vector a){return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b){return (sqrt(norm(a - b)));}\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\ndouble atan(Vector a){return atan2(a.y, a.x);}\nbool sortX(Point a, Point b){return (a.x != b.x ? lt(a.x, b.x) : lt(a.y, b.y));}\nbool sortY(Point a, Point b){return (a.y != b.y ? lt(a.y, b.y) : lt(a.x, b.x));}\nPoint p;\nbool sortT(Point a, Point b){return (gt(cross(a - p, b - p), 0));}\n \nint ccw(Point p0, Point p1, Point p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS) return (+1); //p0, p1, p2 ??????????¨???¨???\n    if (cross(a, b) < -EPS) return (-1);//p0, p1, p2 ???????¨???????\n    if (dot(a, b) < -EPS) return (+2); //p2--p0--p1 ????????§?????´??????\n    if (norm(a) < norm(b)) return (-2); //p0--p1--p2 ????????§?????´??????\n    return (0); //p0--p2--p1 ????????§?????´??????\n}\n \nPolygon normalize(Polygon &v)\n{\n    int pt = 0;\n    for (int i = 1; i < v.size(); i++){\n        if (v[pt].y > v[i].y || (v[pt].y == v[i].y && v[pt].x > v[i].x)){\n            pt = i;\n        }\n    }\n    swap(v[pt], v[0]);\n    p = v[0];\n    sort(v.begin() + 1, v.end(), sortT);\n    return (v);\n}\n \nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n       \n    for (int i = 0; i < n; i++){\n      while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < EPS) k--;\n      qs[k++] = ps[i];\n    }\n   \n    for (int i = n - 2, t = k; i >= 0; i--){\n      while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < EPS) k--;\n      qs[k++] = ps[i];\n    }\n   \n    qs.resize(k - 1);\n    return (qs);\n}\n \ndouble getArea(Polygon t){\n    double ans = 0.0;\n    t = normalize(t);\n    for (unsigned int i = 0; i < t.size(); i++)\n        ans += cross(t[i] , t[(i + 1) % t.size()]);\n    return (fabs(ans) / 2);\n}\n \nbool isIntersectLL(Point p1, Point p2, Point p3, Point p4)\n{// ????????´????????´??????????????????????????¨????????????.\n    return (abs(cross(p2 - p1, p4 - p3)) > EPS || // ???????????°??????\n        abs(cross(p2 - p1, p4 - p3)) < EPS); // ????????´?????§??????\n}\nbool isIntersectLS(Point p1, Point p2, Point p3, Point p4)\n{// ????????´?????????????????´??????????????¨??????\n    return (cross(p2 - p1, p3 - p1) * cross(p2 - p1, p4 - p1) < EPS);\n}\nbool isIntersectLP(Point p1, Point p2, Point p)\n{\n    return (neq(abs(ccw(p1, p2, p)), 1));\n}\nbool isIntersectSS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool isIntersectSP(Point p1, Point p2, Point p)\n{\n    return (eq(ccw(p1, p2, p), 0));\n}\nbool isInsideCP(Point c, double r, Point p)\n{\n    return (leq(abs(c - p), r));\n}\nbool isInsideCC(Point c1, double r1, Point c2, double r2)\n{\n    return (leq(abs(c1 - c2), r1 + r2) && geq(abs(c1 - c2), abs(r1 - r2)));\n}\nbool isInsidePolyP(Polygon gon, Point p)\n{\n    for (int i = 0; i < gon.size(); i++){\n        if (ccw(gon[i], gon[(i + 1) % gon.size()], p) == -1) return (false);\n    }\n    return (true);\n}\n \nPoint projection(Point p1, Point p2, Point p3) //??´???p1p2 ???????????????\n{\n    double t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n    return (p1 + (p2 - p1) * t);\n}\nPoint reflection(Point p1, Point p2, Point p3) //??´???p1p2 ?????????????°?\n{\n    return (p3 + (projection(p1, p2, p3) - p) * 2);\n}\ndouble distanceLP(Point p1, Point p2, Point p)\n{\n    return (abs(p - projection(p1, p2, p)));\n}\ndouble distanceLL(Point l1, Point l2, Point m1, Point m2)\n{\n    return (isIntersectLL(l1, l2, m1, m2) ? 0 : distanceLP(l1, l2, m1));\n}\ndouble distanceLS(Point l1, Point l2, Point s1, Point s2)\n{\n    if (isIntersectLS(l1, l2, s1, s2)) return (0);\n    return (min(distanceLP(l1, l2, s1), distanceLP(l1, l2, s2)));\n}\ndouble distanceSP(Point s1, Point s2, Point p)\n{\n    Point r = projection(s1, s2, p);\n    if (isIntersectSP(s1, s2, r)) return (abs(r - p));\n    return (min(abs(s1 - p), abs(s2 - p)));\n}\ndouble distanceSS(Point s1, Point s2, Point t1, Point t2){\n    if (isIntersectSS(s1, s2, t1, t2)) return (0);\n    return (min(min(distanceSP(s1, s2, t1), distanceSP(s1, s2, t2)),\n            min(distanceSP(t1, t2, s1), distanceSP(t1, t2, s2))));\n}\nPoint interPointLL(Point a1, Point a2, Point b1, Point b2)\n{\n    double d = cross(a2 - a1, b2 - b1);\n    if (abs(d) < EPS) throw \"Segment is Paralell!\";\n    Point a = a2 - a1, b = b2 - b1;\n    double t = cross(b, b1 - a1) / cross(b, a);\n    return (a1 + a * t);\n}\nvector<Point> interPointCC(Point c1, double r1, Point c2, double r2)\n{\n    vector<Point> res;\n    if (abs(c1 - c2) < EPS) return (vector<Point>()); // ???????????¶????????????\n    double d = abs(c1 - c2);\n    double rc = (d * d + r1 * r1 - r2 * r2) / (2 * d);\n    double rs = sqrt(r1 * r1 - rc * rc);\n    Point diff = (c2 - c1) / d;\n    res.push_back(Point(c1 + diff * Point(rc, rs)));\n    res.push_back(Point(c1 + diff * Point(rc, -rs)));\n    return (res);\n}\nvector<Point> crosspointCL(Point a, double ra, Point b1, Point b2)\n{\n    vector<Point> res;\n    double dist = distanceLP(b1, b2, a);\n    if (leq(dist, ra)){\n        Point s = projection(b1, b2, a);\n        dist = sqrt(ra * ra - dist * dist);\n        Point t = (b2 - b1) / abs(b2 - b1);\n        res.push_back(s + t * dist);\n        res.push_back(s - t * dist);\n    }\n    return (res);\n}\n \nPoint unitVector(Vector t)\n{\n    double u = abs(t);\n    return (Point(t.x / u , t.y / u));\n}\n \nPoint normalVector(Point p, Point a, Point b)\n{\n    Point v = unitVector(b - a);\n    v = cross(v, p - a) > 0 ? Point(v.y, -v.x) : Point(-v.y, v.x);\n    return v * distanceLP(p, a, b);\n}\n   \ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n   \ndouble getSin(Vector a, Vector b)\n{\n    double t = getCos(a, b);\n    return (sqrt(1.0 - t * t));\n}\n   \ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n \nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n \nint main()\n{\n    int n;\n    while (scanf(\"%d\", &n) && n){\n        Point s, e;\n        scanf(\"%lf %lf %lf %lf\", &s.x, &s.y, &e.x, &e.y);\n\n        double ans = 1001001001ll;\n        for (int i = 0; i < n; i++){\n            double minx, miny, maxx, maxy, h;\n            scanf(\"%lf %lf %lf %lf %lf\", &minx, &miny, &maxx, &maxy, &h);\n            Point p1 = Point(minx, miny), p2 = Point(minx, maxy),\n                  p3 = Point(maxx, miny), p4 = Point(maxx, maxy);\n            double dist = min(min(distanceSS(p1, p2, s, e), distanceSS(p3, p4, s, e)),\n                              min(distanceSS(p1, p3, s, e), distanceSS(p2, p4, s, e)));\n            Polygon P;\n            P.push_back(p3); P.push_back(p4); P.push_back(p2); P.push_back(p1);\n            if (isInsidePolyP(P, s) && isInsidePolyP(P, e)) ans = 0;\n            if (dist <= h) ans = min(ans, dist);\n            else {\n                ans = min(ans, 0.5 * (h + dist * dist / h));\n            }\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define PI acos(-1)\n#define INF (1e9 + 7)\n\nclass Point {\npublic:\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n    Point operator + (Point p) {\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator - (Point p) {\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator * (double c) {\n        return Point(c * x, c * y);\n    }\n    Point operator / (double c) {\n        return Point(x / c, y / c);\n    }\n    bool operator < (const Point &p) {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const Point &p) {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n    bool operator != (const Point &p) {\n        return (fabs(x - p.x) > EPS || fabs(y - p.y) > EPS);\n    }\n\n    double norm() {\n        return (x * x + y * y);\n    }\n    double abs() {\n        return sqrt(norm());\n    }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n    return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b) {\n    return (a.x * b.y - a.y * b.x);\n}\n\ndouble norm(Vector a) {\n    return (a.x * a.x + a.y * a.y);\n}\n\ndouble abs(Vector a) {\n    return sqrt(norm(a));\n}\n\nclass Segment {\npublic:\n    Point p1, p2;\n    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\ndouble distL(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble distS(Segment s, Point p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n    return distL(s, p);\n}\n\nconst int CCW = 1, CW = -1, ONBACK = 2, ONFRONT = -2, ONSEG = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n\n    if (cross(a, b) > EPS) return CCW;\n    if (cross(a, b) < -EPS) return CW;\n    if (dot(a, b) < -EPS) return ONBACK;\n    if (a.norm() < b.norm()) return ONFRONT;\n    return ONSEG;\n}\n\nbool intersect(Point a, Point b, Point c, Point d) {\n    return (ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0);\n}\n\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble distSS(Segment s1, Segment s2) {\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(distS(s1, s2.p1), distS(s1, s2.p2)), min(distS(s2, s1.p1), distS(s2, s1.p2)));\n}\n\nclass Block {\npublic:\n    double lx, ly, rx, ry, h;\n    vector<Segment> seg, diagonal;\n\n    Block(double lx = 0.0, double ly = 0.0, double rx = 0.0, double ry = 0.0, double h  = 0.0) : lx(lx), ly(ly), rx(rx), ry(ry), h(h) {}\n\n    void setSeg() {\n        seg.resize(4);\n        diagonal.resize(2);\n        seg[0] = Segment(Point(lx, ly), Point(lx, ry));\n        seg[1] = Segment(Point(lx, ry), Point(rx, ry));\n        seg[2] = Segment(Point(rx, ry), Point(rx, ly));\n        seg[3] = Segment(Point(rx, ly), Point(lx, ly));\n        diagonal[0] = Segment(Point(lx, ly), Point(rx, ry));\n        diagonal[1] = Segment(Point(lx, ry), Point(rx, ly));\n    }\n};\n\ninline double dst(double r, double h) {\n    if ((r * r - (r - h) * (r - h)) < 0.0) return r;\n    return sqrt(r * r - (r - h) * (r - h));\n}\n\nint N, sx, sy, ex, ey, a, b, c, d, h;\ndouble ans, min_dist, l, r, mid;\nvector<Block> bk;\nSegment road;\n\nint main() {\n\n    while (scanf(\"%d\", &N), N) {\n        bk.resize(N);\n        ans = 1001.0;\n\n        scanf(\"%d%d%d%d\", &sx, &sy, &ex, &ey);\n        road = Segment(Point(sx, sy), Point(ex, ey));\n\n        for (int i = 0; i < N; ++i) {\n            scanf(\"%d%d%d%d%d\", &a, &b, &c, &d, &h);\n            bk[i] = Block(a, b, c, d, h);\n            bk[i].setSeg();\n        }\n\n        for (int i = 0; i < N; ++i) {\n            min_dist = INF;\n            for (int j = 0; j < 4; ++j) {\n                min_dist = min(min_dist, distSS(Segment(Point(sx, sy), Point(ex, ey)), bk[i].seg[j]));\n            }\n\n            if (intersect(bk[i].diagonal[0], road) || intersect(bk[i].diagonal[1], road)) {\n                ans = 0.0;\n                break;\n            }\n\n            //cout << i << \" \" << min_dist << endl;\n            l = 0.0; r = double(ans);\n            while (r - l > EPS) {\n                mid = (l + r) / 2.0;\n                if (min_dist < dst(mid, bk[i].h)) r = mid;\n                else l = mid;\n            }\n\n            //cout << \"l = \" << l << endl;\n\n            if (ans == 1001.0) ans = l;\n            else ans = min(ans, l);\n            //cout << \"d = \" << dst(ans, bk[i].h) << endl;\n            //printf(\"%.20lf\\n\", ans);\n        }\n\n        printf(\"%lf\\n\", ans);\n\n        bk.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\nint i,j,t;\n\nclass P{\npublic:\n\tdouble x,y;\n\tP(){}\n\tP(const double &s, const double &e){x=s;y=e;}\n};\nclass L{\npublic:\n\tP p1,p2;\n\tL(){}\n\tL(P p1, P p2){this->p1=p1;this->p2=p2;}\n\tL reflect(L l);\n};\nint isIntersect(L l1, L l2){\n\tif (((l1.p1.x - l1.p2.x) * (l2.p1.y - l1.p1.y) + (l1.p1.y - l1.p2.y) * (l1.p1.x - l2.p1.x)) * \n\t\t((l1.p1.x - l1.p2.x) * (l2.p2.y - l1.p1.y) + (l1.p1.y - l1.p2.y) * (l1.p1.x - l2.p2.x)) < 0){\n\t\tif (((l2.p1.x - l2.p2.x) * (l1.p1.y - l2.p1.y) + (l2.p1.y - l2.p2.y) * (l2.p1.x - l1.p1.x)) * \n\t\t\t((l2.p1.x - l2.p2.x) * (l1.p2.y - l2.p1.y) + (l2.p1.y - l2.p2.y) * (l2.p1.x - l1.p2.x)) < 0\t){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\ndouble lpdistance(L l, P p){\n\tint dx, dy, r2;\n\tdouble t, cx, cy;\n\tdx = l.p2.x - l.p1.x;\n\tdy = l.p2.y - l.p1.y;\n\tif (dx == 0 && dy == 0)\n\t\treturn sqrt((p.x - l.p1.x) * (p.x - l.p1.x) + (p.y - l.p1.y) * (p.y - l.p1.y));\n\tr2 = dx * dx + dy * dy;\n\tt = (dx * (p.x - l.p1.x) + dy * (p.y - l.p1.y)) / (double)r2;\n\tif (t < 0)\n\t\treturn sqrt((p.x - l.p1.x) * (p.x - l.p1.x) + (p.y - l.p1.y) * (p.y - l.p1.y));\n\tif (t * t > r2)\n\t\treturn sqrt((p.x - l.p2.x) * (p.x - l.p2.x) + (p.y - l.p2.y) * (p.y - l.p2.y));\n\tcx = (1 - t) * l.p1.x + t * l.p2.x;\n\tcy = (1 - t) * l.p1.y + t * l.p2.y;\n\treturn sqrt((p.x - cx) * (p.x - cx) + (p.y - cy) * (p.y - cy));\n}\n\ndouble lldistance(L l1, L l2){\n\tif(isIntersect(l1, l2)) return 0;\n\tdouble minl = lpdistance(l1, l2.p1);\n\tminl = min(minl, lpdistance(l1, l2.p2));\n\tminl = min(minl, lpdistance(l2, l1.p1));\n\tminl = min(minl, lpdistance(l2, l1.p2));\n\treturn minl;\n}\n\nmain(){\n\tint N,i,j;\n\twhile(cin>>N, N){\n\t\tdouble x1,y1,x2,y2,h,Min = 1e6;\n\t\tP S,E;\n\t\tcin >> S.x>>S.y>>E.x>>E.y;\n\t\tfor(i=0;i<N;i++){\n\t\t\tcin >> x1>>y1>>x2>>y2>>h;\n\t\t\tP p1 = P(x1,y1);\n\t\t\tP p2 = P(x1,y2);\n\t\t\tP p3 = P(x2,y1);\n\t\t\tP p4 = P(x2,y2);\n\t\t\tdouble l = lldistance(L(p1, p2), L(S, E));\n\t\t\tif(lldistance(L(p2, p4), L(S, E)) < l) l = lldistance(L(p2, p4), L(S, E));\n\t\t\tif(lldistance(L(p4, p3), L(S, E)) < l) l = lldistance(L(p4, p3), L(S, E));\n\t\t\tif(lldistance(L(p3, p1), L(S, E)) < l) l = lldistance(L(p3, p1), L(S, E));\n\t\t\tdouble a;\n\t\t\tif(l < h) a = l;\n\t\t\telse{\n\t\t\t\ta = (h*h+l*l)/2/h;\n\t\t\t}\n\t\t\tif(x1 < S.x && y1 < S.y && E.x < x2 && E.y < y2) a = 0;\n\t\t\tMin = min(Min, a);\n\t\t}\n\t\t\n\t\t\n\t\tcout << Min << endl;\n\t}\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x real()\n#define y imag()\n#define INF (1e9)\n#define EPS (1e-6)\nusing namespace std;\ntypedef complex<double> point;\npoint s,g;\ndouble dot(point a,point b){return a.x*b.x+a.y*b.y;}\ndouble cross(point a,point b){return a.x*b.y-a.y*b.x;}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<0) return 2;//\"ONLINE_BACK\"\n  if(abs(d) < abs(e)) return -2;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\nbool intersection(point a,point b,point c,point d){\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble get_dis(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n/*double get_dis(point a,point b,point c){\n  a-=b;c-=b;\n  point na=a*conj(a)/abs(a);\n  c=c*conj(a)/abs(a);\n  if((0<=c.x&&c.x<=na.x)||(na.x<=c.x&&c.x<=0)) return abs(c.y);\n  return min(abs(c),abs(c-na));\n  }*/\n\n/*double get_dis(point a,point b,point c){\n  b-=a;c-=a;\n  point nb=b*conj(b)/abs(b);\n  c=c*conj(b)/abs(b);\n  if(0<=c.x&&c.x<=nb.x) return abs(c.y);\n  return min(abs(c),abs(c-nb));\n  }*/\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    double a,b,c,d,h;\n    cin>>a>>b>>c>>d;\n    s=point(a,b),g=point(c,d);\n    \n    double ans=INF;\n    for(int i=0;i<n;i++) {\n      cin>>a>>b>>c>>d>>h;\n      if(intersection(s,g,point(a,b),point(c,b)))ans=0;\n      if(intersection(s,g,point(a,b),point(a,d)))ans=0;\n      if(intersection(s,g,point(a,d),point(c,d)))ans=0;     \n      if(intersection(s,g,point(c,b),point(c,d)))ans=0;\n      \n      double dis=get_dis(s,g,point(a,b));\n      dis=min(dis,get_dis(s,g,point(c,d)));\n      dis=min(dis,get_dis(s,g,point(a,d)));\n      dis=min(dis,get_dis(s,g,point(c,b)));\n      if(dis>h) ans=min(ans,(dis*dis+h*h)/(2*h));\n      else ans=min(ans,dis);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <limits.h>\n\nusing namespace std;\n\n#define ZEROP(x) (fabs(x) < EPS)\n#define EQ(x, y) ZEROP((x) - (y))\n#define LT(x, y) ((x) - (y) <= -EPS) // x < y\n#define LE(x, y) ((x) - (y) < +EPS) // x <= y\n#define SIGN(x) ((x)<-EPS?-1:((x)>EPS?+1:0))\n\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define REPD(i,n) for(int i=(int)(n); i-->0;)\n#define REPI(i,a,b) for(int i=(int)(a); i<=(int)(b); i++)\n#define ALL(a) (a).begin(),(a).end()\n#define mp make_pair\n#define fst first\n#define snd second\n\n#define INFTY 1000000000\n#define EPS 1e-9\n#define PI 3.141592653589793\n\n#define INF (INFTY/3)\n\n#define rev(s) (string((s).rbegin(), (s).rend()))\n\ntypedef long long Int;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<double,double> pdd;\n\nvoid debug(vi v){ REP(i,v.size()) cout<<v[i]<<\" \"; cout<<endl; }\n\nint nextInt(){ int t; cin>>t; return t; } // DæÊÉCðÂ¯Äg¤±Æ\n\ntypedef complex<double> P;\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nnamespace std {\n   bool operator < (const P& a, const P& b) {\n     return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n   }\n}\ndouble cross(const P& a, const P& b) {\n   return imag(conj(a)*b); //OÏu~vÌå«³Dü«ÍL=[u,v]ÉÎµÄCu©çvÖÌEË¶\n} \ndouble dot(const P& a, const P& b) {\n   return real(conj(a)*b); \n}  \nstruct L : public vector<P> {\n  L() {}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  } \n};  \ntypedef vector<P> G;  \nstruct C {\n   P p; double r;\n   C(const P &p, double r) : p(p), r(r) { }\n}; \n\n\n#define MAXN 50\nint N;\nL sl; // start line\nint minx[MAXN];\nint miny[MAXN];\nint maxx[MAXN];\nint maxy[MAXN];\nint h[MAXN];\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (LT( 0, cross(b, c)) )   return +1;       // counter clockwise\n  if (LT( cross(b, c), 0) )   return -1;       // clockwise\n  if (LT( dot(b, c), 0) )     return +2;       // c--a--b on line\n  if (LT( norm(b), norm(c)) ) return -2;       // a--b--c on line\n  return 0;\n}\n\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n// USE IN THIS PROBLEM\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nbool covered(int sx,int sy,int ex,int ey,int ax,int ay,int bx,int by) {\n  return ax <= sx && ay <= sy && ex <= bx && ey <= by;\n}\n\n\ndouble solve() {\n  double r = INT_MAX;\n  REP(i,N) {\n    L l[]={L(P(minx[i],miny[i]),P(maxx[i],miny[i])),\n\t   L(P(maxx[i],miny[i]),P(maxx[i],maxy[i])),\n\t   L(P(maxx[i],maxy[i]),P(minx[i],maxy[i])),\n\t   L(P(minx[i],maxy[i]),P(minx[i],miny[i]))};\n    double mind = INT_MAX;\n    int mini; //min index\n    if(covered(real(sl[0]),imag(sl[0]),real(sl[1]),imag(sl[1]),\n\t       minx[i],miny[i],maxx[i],maxy[i])) return 0.0;\n    REP(j,4) {\n      if(intersectSS(l[j],sl)) return 0.0;\n      double dd = distanceSS(l[j],sl);\n      if(LT(dd,mind)) {\n\tmind = dd;\n\tmini = j;\n      }\n    }\n    double r2;\n    //printf(\"mind=%lf\\n\",mind);\n    if(LE(mind,h[i])) { // mind <= h[i]\n      r2=mind;\n    } else {\n      r2=(h[i]*h[i] + mind*mind) / (2*h[i]);\n    }\n    r=min(r,r2);\n    //printf(\"r=%lf\\n\",r);\n  }\n  return r;\n}\n\t\nmain() {\n  while(cin>>N,N) {\n    int sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    sl = L(P(sx,sy),P(ex,ey));\n    REP(i,N)\n      cin>>minx[i]>>miny[i]>>maxx[i]>>maxy[i]>>h[i];\n    printf(\"%.7lf\\n\",solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\n\n////////////////////////////\n// 基本要素 (点, 線分)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL<<60;      // to be set appropriately\nconst DD EPS = 1e-10;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\n/* Point */\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\n/* Line */\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\n\n////////////////////////////\n// 円や直線の交差判定, 距離\n////////////////////////////\n\n/*\n ccw を用いている\n \n P: point\n L: Line\n S: Segment\n \n distancePL は、「点」と「直線」の距離\n distancePS は、「点」と「線分」の距離\n */\n\nint ccw_for_dis(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\nPoint proj(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(const Point &p, const Line &l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(const Point &p, const Line &l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(const Point &p, const Line &s) {\n    return (ccw_for_dis(s[0], s[1], p) == 0);\n}\nbool isinterLL(const Line &l, const Line &m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(const Line &s, const Line &t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw_for_dis(s[0], s[1], t[0]) * ccw_for_dis(s[0], s[1], t[1]) <= 0 &&\n            ccw_for_dis(t[0], t[1], s[0]) * ccw_for_dis(t[0], t[1], s[1]) <= 0);\n}\nDD distancePL(const Point &p, const Line &l) {\n    return abs(p - proj(p, l));\n}\nDD distancePS(const Point &p, const Line &s) {\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nDD distanceLL(const Line &l, const Line &m) {\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nDD distanceSS(const Line &s, const Line &t) {\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\n\n\n\nint main() {\n    int N;\n    while (cin >> N, N) {\n        double sx, sy, ex, ey; cin >> sx >> sy >> ex >> ey;\n        Line s(Point(sx, sy), Point(ex, ey));\n\n        double res = 1100;\n        for (int i = 0; i < N; ++i) {\n            double x[2], y[2], h;\n            cin >> x[0] >> y[0] >> x[1] >> y[1] >> h;\n            vector<Point> vp;\n            for (int j = 0; j < 2; ++j)\n                for (int k = 0; k < 2; ++k)\n                    vp.push_back(Point(x[j], y[k]));\n            for (int j = 0; j < 4; ++j) {\n                Line seg(vp[j], vp[(j+1)%4]);\n                double d = distanceSS(s, seg);\n                if (d < EPS) res = 0.0;\n                else if (d <= h) res = min(res, d);\n                else res = min(res, (d*d + h*h)/(h*2));\n            }\n        }\n        cout << fixed << setprecision(10) << res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(const Point &p0,const Point &p1,const Point &p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nPoint projection(const Segment &s,const Point &p){\n    Vector b = s.t-s.s;\n    double t = dot(p-s.s,b)/norm(b);\n    return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n    return (ccw(s.s,s.t,p) == 0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n            ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n    Point r = projection(s,p);\n    if(isIntersectSP(s,r)) return abs(r-p);\n    return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment &a,const Segment &b){\n    if(isIntersectSS(a,b)) return 0;\n    return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n           min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nstruct Block{\n    Point a,b;\n    double h;\n    Block(){}\n    Block(Point &a,Point &b,double h) :\n        a(a),b(b),h(h) {}\n};\n\nistream &operator >> (istream &is,Point &p){ \n    return is >> p.x >> p.y;\n}\n\ndouble calc(double a,double b){\n    return sqrt(a*a+b*b);\n}\n\nbool c(double r,Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point a = v[i].a,b = v[i].b;\n        Point c(a.x,b.y),d(b.x,a.y);\n        Segment s1(a,c),s2(a,d),s3(c,b),s4(d,b);\n        double dst[] = {\n            distanceSS(p,s1),distanceSS(p,s2),\n            distanceSS(p,s3),distanceSS(p,s4)\n        };\n \n        if(r < v[i].h){\n            if(!(r < dst[0] && r < dst[1] &&\n                 r < dst[2] && r < dst[3])){\n                return 0;\n            }\n        }else{\n            double nh = r - v[i].h;\n            if(!(r < calc(nh,dst[0]) && r < calc(nh,dst[1]) &&\n                 r < calc(nh,dst[2]) && r < calc(nh,dst[3]))){\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nbool check(Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point a = v[i].a,b = v[i].b;\n        Point c(a.x,b.y),d(b.x,a.y);\n        Segment s1(a,c),s2(a,d),s3(c,b),s4(d,b);\n        if((a.x < p.s.x && p.s.x < b.x &&\n            a.y < p.s.y && p.s.y < b.y) ||\n           (a.x < p.t.x && p.t.x < b.x &&\n            a.y < p.t.y && p.t.y < b.y)){\n            return 1;\n        }\n        if(isIntersectSS(p,s1)) return 1;\n        if(isIntersectSS(p,s2)) return 1;\n        if(isIntersectSS(p,s3)) return 1;\n        if(isIntersectSS(p,s4)) return 1;\n    }\n    return 0;\n}\n\nint main(){\n    int N;\n    while(cin >> N,N){\n        Segment seg;\n        cin >> seg.s >> seg.t;\n        vector<Block> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].a >> v[i].b >> v[i].h;\n        }\n        if(check(seg,v)){\n            cout << 0 << endl;\n            continue;\n        }\n        double l = 0,r = 1001;\n        for(int i = 0 ; i < 100 ; i++){\n            double mid = (l + r) / 2;\n            if(c(mid,seg,v)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n        printf(\"%.10f\\n\",l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nvoid print(Point p);\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tprint(p1);\n\t\t\tprint(p2);\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p2;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n//\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tint x=ccw(s.p1,s.p2,pr);\n\tif(x==0) return d;\n//\tif(x>=-1&&x<=1) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t//\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\tif(ccw(q[0],q[1],r)==0){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t//\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\tif(ccw(p[0],p[1],r)==0){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\ntypedef complex<double> Point;\n\nint n;\ndouble sx, sy, ex, ey;\ndouble lx[50], ly[50], rx[50], ry[50], h[50];\n\ndouble dot(Point a, Point b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(Point a, Point b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > 0) return +1;\t\t//counter clockwise\n\tif (cross(b, c) < 0) return -1;\t\t//clockwise\n\tif (dot(b, c) < 0) return +2;\t\t//c--a--b on line.\n\tif (norm(b) < norm(c)) return -2;\t//a--b--c on line.\n\treturn 0;\n}\n\nbool is_intersect(Point a, Point b, Point c, Point d) {\n\treturn ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0;\n}\n\n//in:2, on:1, out:0\nint is_cover(vector<Point> poly, Point p) {\n\tint n = poly.size() - 1;\n\tint i;\n\t\n\tbool in = false;\n\trep(i, n) {\n\t\tPoint a = poly[i] - p;\n\t\tPoint b = poly[i + 1] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) > 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n//S:Segment(線分), P:Point(点)\ndouble dist_SP(Point s, Point e, Point p) {\n\tif (dot(e - s, p - s) < 0) return abs(p - s);\n\tif (dot(s - e, p - e) < 0) return abs(p - e);\n\treturn abs(cross(e - s, p - s)) / abs(e - s);\n}\n\ndouble dist_SS(Point a, Point b, Point c, Point d) {\n\treturn min({\n\tdist_SP(a, b, c),\n\tdist_SP(a, b, d),\n\tdist_SP(c, d, a),\n\tdist_SP(c, d, b)});\n}\n\n//A: Area(閉面）\ndouble dist_AS(vector<Point> poly, Point a, Point b) {\n\tint n = poly.size() - 1;\n\tint i;\n\tdouble ret;\n\trep(i, n) {\n\t\tdouble res = dist_SS(poly[i], poly[i + 1], a, b);\n\t\tif (i == 0) ret = res;\n\t\telse ret = min(ret, res);\n\t}\n\treturn ret;\n}\n\nbool pre_check() {\n\tint i, j;\n\tPoint s = Point(sx, sy);\n\tPoint e = Point(ex, ey);\n\t\n\trep(i, n) {\n\t\tvector<Point> poly;\n\t\tpoly.push_back(Point(lx[i], ly[i]));\n\t\tpoly.push_back(Point(rx[i], ly[i]));\n\t\tpoly.push_back(Point(rx[i], ry[i]));\n\t\tpoly.push_back(Point(lx[i], ry[i]));\n\t\tpoly.push_back(poly[0]);\n\t\t\n\t\trep(j, 4) {\n\t\t\tif (is_intersect(poly[j], poly[j + 1], s, e)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (is_cover(poly, s) >= 1) return false;\n\t\tif (is_cover(poly, e) >= 1) return false;\n\t}\n\treturn true;\n}\n\nbool check(double r) {\n\tint i, j;\n\tPoint s = Point(sx, sy);\n\tPoint e = Point(ex, ey);\n\t\n\t//平面幾何 (線分と線分の距離）に帰着する\n\trep(i, n) {\n\t\tvector<Point> poly;\n\t\tpoly.push_back(Point(lx[i], ly[i]));\n\t\tpoly.push_back(Point(rx[i], ly[i]));\n\t\tpoly.push_back(Point(rx[i], ry[i]));\n\t\tpoly.push_back(Point(lx[i], ry[i]));\n\t\tpoly.push_back(poly[0]);\n\t\t\n\t\tdouble d = dist_AS(poly, s, e);\n\t\tdouble length;\n\t\tif (h[i] >= r) {\n\t\t\tlength = d;\n\t\t}\n\t\telse {\n\t\t\tlength = sqrt(d * d + (r - h[i]) * (r - h[i]));\n\t\t}\n\t\tif (length <= r) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tint i;\n\n\twhile (cin >> n) {\n\t\tif (!n) break;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\trep(i, n) cin >> lx[i] >> ly[i] >> rx[i] >> ry[i] >> h[i];\n\t\tif (!pre_check()) { cout << 0 << endl; continue; }\n\t\t\n\t\tdouble st = 0, ed = 1e+5, mid;\n\t\trep(i, 150) {\n\t\t\tmid = (st + ed) / 2;\n\t\t\tif (check(mid)) st = mid;\n\t\t\telse ed = mid;\n\t\t}\n\t\tprintf(\"%.14f\\n\", st);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ndouble INF = 1000000;\ndouble EPS = 0.000000001;\nint sign(double x){\n  if (x >= EPS){\n    return 1;\n  } else if (x <= - EPS){\n    return -1;\n  } else {\n    return 0;\n  }\n}\nstruct point{\n  double x, y;\n  point(){\n  }\n  point(double x, double y): x(x), y(y){\n  }\n  point operator +(point P){\n    return point(x + P.x, y + P.y);\n  }\n  point operator -(point P){\n    return point(x - P.x, y - P.y);\n  }\n  point operator *(double k){\n    return point(x * k, y * k);\n  }\n  point operator /(double k){\n    return point(x / k, y / k);\n  }\n};\ndouble abs(point P){\n  return sqrt(pow(P.x, 2) + pow(P.y, 2));\n}\ndouble dist(point P, point Q){\n  return abs(Q - P);\n}\ndouble dot(point P, point Q){\n  return P.x * Q.x + P.y * Q.y;\n}\ndouble cross(point P, point Q){\n  return P.x * Q.y - P.y * Q.x;\n}\nstruct line{\n  point A, B;\n  line(){\n  }\n  line(point A, point B): A(A), B(B){\n  }\n};\npoint vec(line L){\n  return L.B - L.A;\n}\ndouble is_parallel(line L1, line L2){\n  return sign(cross(vec(L1), vec(L2))) == 0;\n}\npoint line_intersection(line L1, line L2){\n  return L1.A + vec(L1) * cross(L2.A - L1.A, vec(L2)) / cross(vec(L1), vec(L2));\n}\nbool on_segment(point P, line L){\n  return sign(dot(P - L.A, vec(L))) > 0 && sign(dot(P - L.B, vec(L))) < 0;\n}\ndouble point_line_distance(point P, line L){\n  return abs(cross(P - L.A, vec(L))) / abs(vec(L));\n}\ndouble point_segment_distance(point P, line L){\n  if (sign(dot(P - L.A, vec(L))) < 0){\n    return dist(P, L.A);\n  } else if (sign(dot(P - L.B, vec(L))) > 0){\n    return dist(P, L.B);\n  } else {\n    return point_line_distance(P, L);\n  }\n}\ndouble segment_distance(line L1, line L2){\n  if (!is_parallel(L1, L2)){\n    point P = line_intersection(L1, L2);\n    if (on_segment(P, L1) && on_segment(P, L2)){\n      return 0;\n    }\n  }\n  double ans = INF;\n  ans = min(ans, point_segment_distance(L1.A, L2));\n  ans = min(ans, point_segment_distance(L1.B, L2));\n  ans = min(ans, point_segment_distance(L2.A, L1));\n  ans = min(ans, point_segment_distance(L2.B, L1));\n  return ans;\n}\nint main(){\n  cout << fixed << setprecision(20);\n  while (1){\n    int N;\n    cin >> N;\n    if (N == 0){\n      break;\n    }\n    line L;\n    cin >> L.A.x >> L.A.y >> L.B.x >> L.B.y;\n    vector<double> x1(N), x2(N), y1(N), y2(N);\n    vector<point> A(N), B(N), C(N), D(N);\n    vector<double> h(N);\n    for (int i = 0; i < N; i++){\n      cin >> x1[i] >> y1[i] >> x2[i] >> y2[i] >> h[i];\n      A[i] = point(x1[i], y1[i]);\n      B[i] = point(x1[i], y2[i]);\n      C[i] = point(x2[i], y2[i]);\n      D[i] = point(x2[i], y1[i]);\n    }\n    double tv = 0;\n    double fv = 1000;\n    for (int i = 0; i < 50; i++){\n      double mid = (tv + fv) / 2;\n      bool ok = true;\n      for (int j = 0; j < N; j++){\n        double r;\n        if (h[j] >= mid){\n          r = mid;\n        } else {\n          r = sqrt(pow(mid, 2) - pow(mid - h[j], 2));\n        }\n        if (x1[j] <= L.A.x && L.A.x <= x2[j] && y1[j] <= L.A.y && L.A.y <= y2[j]){\n          ok = false;\n        }\n        if (x1[j] <= L.B.x && L.B.x <= x2[j] && y1[j] <= L.B.y && L.B.y <= y2[j]){\n          ok = false;\n        }\n        if (segment_distance(L, line(A[j], B[j])) < r){\n          ok = false;\n        }\n        if (segment_distance(L, line(B[j], C[j])) < r){\n          ok = false;\n        }\n        if (segment_distance(L, line(C[j], D[j])) < r){\n          ok = false;\n        }\n        if (segment_distance(L, line(D[j], A[j])) < r){\n          ok = false;\n        }\n      }\n      if (ok){\n        tv = mid;\n      } else {\n        fv = mid;\n      }\n    }\n    cout << tv << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tdouble min_x,min_y,max_x,max_y,h;\n};\n\nint N;\nInfo info[50];\ndouble start_x,start_y,end_x,end_y;\n\nstruct Point{\n\tdouble x,y;\n};\n\ntypedef Point Vector;\n\nstruct Segment{\n\tvoid set(double x1,double y1,double x2,double y2){\n\t\tp1.x = x1;\n\t\tp1.y = y1;\n\t\tp2.x = x2;\n\t\tp2.y = y2;\n\t}\n\tPoint p1,p2;\n};\n\ntypedef Segment Line;\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\nPoint calc_minus(Point a,Point b){\n\tPoint ret;\n\n\tret.x = a.x-b.x;\n\tret.y = a.y-b.y;\n\n\treturn ret;\n}\n\ndouble calc_len(Vector a){\n\treturn sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble getDistanceLP(Line l,Point p){\n\treturn fabs(cross(calc_minus(l.p2,l.p1),calc_minus(p,l.p1))/calc_len(calc_minus(l.p2,l.p1)));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n\tif(dot(calc_minus(s.p2,s.p1),calc_minus(p,s.p1)) < 0.0)return calc_len(calc_minus(p,s.p1));\n\tif(dot(calc_minus(s.p1,s.p2),calc_minus(p,s.p2)) < 0.0)return calc_len(calc_minus(p,s.p2));\n\treturn getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n\treturn min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t\t\tmin(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nvoid solve(){\n\n\tscanf(\"%lf %lf %lf %lf\",&start_x,&start_y,&end_x,&end_y);\n\n\tSegment base_seg;\n\tbase_seg.set(start_x,start_y,end_x,end_y);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf %lf %lf\",&info[i].min_x,&info[i].min_y,&info[i].max_x,&info[i].max_y,&info[i].h);\n\t}\n\n\tdouble R = 1000.0;\n\n\tSegment A,B,C,D;\n\tdouble tmp_dist;\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tif(start_x > info[i].min_x && end_x > info[i].min_x && start_x < info[i].max_x && end_x < info[i].max_x &&\n\t\t\t\tstart_y > info[i].min_y && end_y > info[i].min_y && start_y < info[i].max_y && end_y < info[i].max_y){\n\t\t\tprintf(\"0.0000\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif((func(start_x,start_y,end_x,end_y,info[i].min_x,info[i].min_y)*func(start_x,start_y,end_x,end_y,info[i].min_x,info[i].max_y) <= 0 &&\n\t\t\t\tfunc(info[i].min_x,info[i].min_y,info[i].min_x,info[i].max_y,start_x,start_y) * func(info[i].min_x,info[i].min_y,info[i].min_x,info[i].max_y,end_x,end_y) <= 0) ||\n\t\t\t\t(func(start_x,start_y,end_x,end_y,info[i].min_x,info[i].max_y)*func(start_x,start_y,end_x,end_y,info[i].max_x,info[i].max_y) <= 0 &&\n\t\t\t\tfunc(info[i].min_x,info[i].max_y,info[i].max_x,info[i].max_y,start_x,start_y) * func(info[i].min_x,info[i].max_y,info[i].max_x,info[i].max_y,end_x,end_y) <= 0) ||\n\t\t\t\t(func(start_x,start_y,end_x,end_y,info[i].max_x,info[i].max_y)*func(start_x,start_y,end_x,end_y,info[i].max_x,info[i].min_y) <= 0 &&\n\t\t\t\tfunc(info[i].max_x,info[i].max_y,info[i].max_x,info[i].min_y,start_x,start_y) * func(info[i].max_x,info[i].max_y,info[i].max_x,info[i].min_y,end_x,end_y) <= 0) ||\n\t\t\t\t(func(start_x,start_y,end_x,end_y,info[i].max_x,info[i].min_y)*func(start_x,start_y,end_x,end_y,info[i].min_x,info[i].min_y) <= 0 &&\n\t\t\t\tfunc(info[i].max_x,info[i].min_y,info[i].min_x,info[i].min_y,start_x,start_y) * func(info[i].max_x,info[i].min_y,info[i].min_x,info[i].min_y,end_x,end_y) <= 0)){\n\t\t\tprintf(\"0.0000\\n\");\n\t\t\treturn;\n\t\t}else{\n\n\t\t\tA.set(info[i].min_x,info[i].min_y,info[i].min_x,info[i].max_y);\n\t\t\tB.set(info[i].min_x,info[i].max_y,info[i].max_x,info[i].max_y);\n\t\t\tC.set(info[i].max_x,info[i].max_y,info[i].max_x,info[i].min_y);\n\t\t\tD.set(info[i].max_x,info[i].min_y,info[i].min_x,info[i].min_y);\n\n\t\t\ttmp_dist = min(min(getDistance(base_seg,A),getDistance(base_seg,B)),min(getDistance(base_seg,C),getDistance(base_seg,D)));\n\n\t\t\tif(info[i].h < tmp_dist){\n\t\t\t\tR = min(R,(info[i].h*info[i].h+tmp_dist*tmp_dist)/(2*info[i].h));\n\t\t\t}else{\n\t\t\t\tR = min(R,tmp_dist);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.4lf\\n\",R);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // üªª½sÈêÍdÈÁÄ¢È¢±ÆÉ·é\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 0;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\t//if(d1<r&&d2<r)\n\t//\treturn true;\n\tdouble d = distance_ls_p(a,b,c);\n\treturn (EQ(d,r)||d<r);\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\nbool isInRectangle(P p1,P p2,P p3,P p4,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n    P d=p4-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,d)>0&&cross(d,a)<0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,d)<0&&cross(d,a)<0));\n}\n// Op`ÌÊÏðÀW©çvZ\ndouble calcAreaOfTriangle(P a,P b,P c){\n\treturn abs((b.real()-a.real())*(c.imag()-a.imag()) - (c.real()-a.real())*(b.imag()-a.imag()))/2;\n}\n// ^¦çê½~ÌÍÍàÉ_ª¶Ý·é©Ç¤©\nbool isContainingDot(P c,double r,P a){\n\treturn (((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag())<r*r)\n\t\t||EQ((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag()),r*r));\n}\n// ½p`ÌÊÏö®\ndouble calcPolygonArea(vector<P> p){\n\tdouble sum=0;\n\tfor(int i = 0; i < p.size(); i++)\n\t\tsum+=cross(p[i],p[(i+1)%(p.size())]);\n\treturn sum/2;\n}\n// 2xNgÔÌpx\n// a©çbÖ¶üèÅ½x©(0->2*PI)\ndouble diffAngle(P a,P b){\n    double angle=atan2(cross(a,b),dot(a,b));\n    if(angle<0)\n        return 2*PI+angle;\n    return angle;\n}\n\nclass Object{\npublic:\n    int minx,miny,maxx,maxy,h;\n};\n\nint n;\nint sx,sy,ex,ey;\nvector<Object> objects;\nconst double INF=100000;\n\nbool check(double r){\n    for(int i = 0; i < objects.size(); i++){\n        // startn_Ægoaln_É éªÔÂ©é©Ì`FbN\n        double h=objects[i].h;\n        double useR=sqrt(2*h*r-h*h);\n        if(!(r>objects[i].h||EQ(r,objects[i].h)))\n            useR=r;\n        vector<pair<P, P> > rect;\n        rect.push_back(make_pair(P(objects[i].minx,objects[i].miny),P(objects[i].minx,objects[i].maxy)));\n        rect.push_back(make_pair(P(objects[i].minx,objects[i].miny),P(objects[i].maxx,objects[i].miny)));\n        rect.push_back(make_pair(P(objects[i].maxx,objects[i].maxy),P(objects[i].maxx,objects[i].miny)));\n        rect.push_back(make_pair(P(objects[i].maxx,objects[i].maxy),P(objects[i].minx,objects[i].maxy)));\n        for(int j = 0; j < rect.size(); j++){\n            if(isCircleCrossLine(rect[j].first,rect[j].second,P(sx,sy),useR)\n                ||isCircleCrossLine(rect[j].first,rect[j].second,P(ex,ey),useR)){\n                return false;\n            }\n        }\n        if(isContainingDot(P(sx,sy),useR,P(objects[i].minx,objects[i].miny))\n            &&isContainingDot(P(sx,sy),useR,P(objects[i].minx,objects[i].maxy))\n            &&isContainingDot(P(sx,sy),useR,P(objects[i].maxx,objects[i].miny))\n            &&isContainingDot(P(sx,sy),useR,P(objects[i].maxx,objects[i].maxy))){\n                return false;\n        }\n        if(isContainingDot(P(ex,ey),useR,P(objects[i].minx,objects[i].miny))\n            &&isContainingDot(P(ex,ey),useR,P(objects[i].minx,objects[i].maxy))\n            &&isContainingDot(P(ex,ey),useR,P(objects[i].maxx,objects[i].miny))\n            &&isContainingDot(P(ex,ey),useR,P(objects[i].maxx,objects[i].maxy))){\n                return false;\n        }\n        // X^[gn_ÌQ_ÆS[n_ÌQ_ðßé\n        P ss1,ss2,gg1,gg2;\n        P e=P(sx-ex,sy-ey);e/=abs(e);\n        e=P(-e.imag(),e.real());\n        ss1=e*useR+P(sx,sy);\n        ss2=-e*useR+P(sx,sy);\n        gg1=e*useR+P(ex,ey);\n        gg2=-e*useR+P(ex,ey);\n        if(objects[i].minx<=sx\n            &&objects[i].maxx>=sx\n            &&objects[i].miny<=sy\n            &&objects[i].maxy>=sy\n            ){\n                return false;\n        }\n        if(objects[i].minx<=ex\n            &&objects[i].maxx>=ex\n            &&objects[i].miny<=ey\n            &&objects[i].maxy>=ey\n            ){\n                return false;\n        }\n        //  éé`àÉ_ª¶Ý·é©`FbN\n        if(isInRectangle(ss1,ss2,gg2,gg1,P(objects[i].minx,objects[i].miny))\n            ||isInRectangle(ss1,ss2,gg2,gg1,P(objects[i].minx,objects[i].maxy))\n            ||isInRectangle(ss1,ss2,gg2,gg1,P(objects[i].maxx,objects[i].miny))\n            ||isInRectangle(ss1,ss2,gg2,gg1,P(objects[i].maxx,objects[i].maxy))\n            )\n        {\n            return false;\n        }\n\n        // üªÌyAðSi[µASär·é\n        vector<pair<P,P> > lines;\n        lines.push_back(make_pair(ss1,gg1));\n        lines.push_back(make_pair(ss2,gg2));\n        // Çê©êÂÅàüªªÔÂ©êÎI¹\n        for(int j = 0; j < lines.size(); j++)\n            for(int k = 0; k < rect.size(); k++)\n                if(is_intersected_ls(lines[j].first,lines[j].second,rect[k].first,rect[k].second))\n                    return false;\n    }\n    return true;\n}\n\nint main(){\n    while(cin>>n&&n!=0){\n        cin>>sx>>sy>>ex>>ey;\n        objects.clear();\n        for(int i = 0; i < n; i++){\n            Object o;\n            cin>>o.minx>>o.miny>>o.maxx>>o.maxy>>o.h;\n            objects.push_back(o);\n        }\n        double ub=INF;\n        double lb=0;\n        while(ub-lb>EPS){\n            double med=(ub+lb)/2;\n            if(check(med))\n                lb=med;\n            else\n                ub=med;\n        }\n        printf(\"%.6f\\n\",ub);\n        //cout<<ub<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\n\nconstexpr ld eps = 1e-8;\n\n\nnamespace geometry2d {\n\n\nusing point = std::complex<long double>;\nusing polygon = std::vector<point>;\n\n\nbool eq(long double a, long double b) {\n    return (std::abs(a-b) < eps);\n}\n\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\n\nclass segment {\npublic:\n    segment()\n        : a(point(0, 0)),\n          b(point(0, 0))\n    {}\n    segment(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n};\n\nclass line {\npublic:\n    line()\n        : a(point(0, 0)), b(point(0, 0))\n    {}\n    line(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n    line(segment s)\n        : a(s.a), b(s.b)\n    {}\n\n    point a, b;\n};\n\nclass circle {\npublic:\n    circle()\n        : p(point(0, 0)), r(0)\n    {}\n    circle(point p_, long double r_)\n        : p(p_), r(r_)\n    {}\n\n    point p;\n    long double r;\n};\n\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\n\nbool isis_ll(line l, line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - s.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nlong double dist_lp(line l, point p) {\n    return std::abs(p - proj(l, p));\n}\n\nlong double dist_ll(line l, line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nlong double dist_ls(line l, segment s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\n\nstd::vector<point> is_cc(circle const& c1, circle const& c2) {\n    std::vector<point> res;\n    long double d = std::abs(c1.p - c2.p);\n    long double rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    long double dfr = c1.r * c1.r - rc * rc;\n    if(std::abs(dfr) < eps) {\n        dfr = 0.0;\n    } else if(dfr < 0.0) {\n        return res;\n    }\n\n    long double rs = std::sqrt(dfr);\n    point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * point(rc, rs));\n    if(dfr != 0.0) {\n        res.push_back(c1.p + diff * point(rc, -rs));\n    }\n    return res;\n}\n\n// 0 -> on, 1 -> in, 2 -> out\nint is_in_polygon(polygon const& poly, point p) {\n    int N = poly.size();\n    ld sum = 0;\n    for(int i=0; i<N; ++i) {\n        point p1 = poly[i], p2 = poly[(i+1)%N];\n        if(isis_sp(segment(p1, p2), p)) {\n            return 0;\n        }\n        sum += arg((p2 - p) / (p1 - p));\n    }\n    return eq(sum, 0) ? 2 : 1;\n}\n\n\n} // namespace geometry2d\n\nusing namespace geometry2d;\n\nconstexpr ld INF = 1e18;\n\nint main() {\n    int N;\n    while(cin >> N, N) {\n        //polygon poly(4);\n        //for(int i=0; i<4; ++i) {\n        //    ld x, y;\n        //    cin >> x >> y;\n        //    poly[i] = point(x, y);\n        //}\n        //ld x, y;\n        //cin >> x >> y;\n        //cout << is_in_polygon(poly, point(x, y)) << endl;\n        ld sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        segment s(point(sx, sy), point(ex, ey));\n        vector<ld> d(N, INF);\n        vector<ld> h(N);\n        for(int i=0; i<N; ++i) {\n            ld x[2], y[2];\n            cin >> x[0] >> y[0] >> x[1] >> y[1] >> h[i];\n            polygon poly(4);\n            poly[0] = point(x[0], y[0]);\n            poly[1] = point(x[1], y[0]);\n            poly[2] = point(x[1], y[1]);\n            poly[3] = point(x[0], y[1]);\n            if(is_in_polygon(poly, s.a) != 2 || is_in_polygon(poly, s.b) != 2) {\n                d[i] = 0;\n                continue;\n            }\n            ld t = INF;\n            t = min(t, dist_ss(s, segment(poly[0], poly[1])));\n            t = min(t, dist_ss(s, segment(poly[1], poly[2])));\n            t = min(t, dist_ss(s, segment(poly[2], poly[3])));\n            t = min(t, dist_ss(s, segment(poly[3], poly[0])));\n            d[i] = min(d[i], t);\n        }\n        ld res = INF;\n        for(int i=0; i<N; ++i) {\n            if(h[i] >= d[i]) {\n                res = min(res, d[i]);\n            } else {\n                res = min(res, (d[i] * d[i] + h[i] * h[i]) / (2 * h[i]));\n            }\n        }\n        cout << fixed << setprecision(10) << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nconst double EPS = 1e-9;\ntemplate<typename T>\nT sqr(T a) { return a * a; }\n\nstruct search_point {\n\tdouble x, y;\n\tdouble h;\n\tsearch_point(double x_, double y_, double h_) {\n\t\tx = x_; y = y_; h = h_;\n\t}\n};\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tdouble sx, sy, ex, ey;\n\t\tvector<search_point> v;\n\t\tvector<pair<search_point,search_point> > line;\n\t\tvector<pair<search_point,search_point> > lect;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tdouble R = 10000;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble h;\n\t\t\tcin >> x0 >> y0 >> x1 >> y1 >> h;\n\n\t\t\tif(h < EPS)\n\t\t\t\th = EPS;\n\n\t\t\tv.push_back(search_point(x0, y0, h));\n\t\t\tv.push_back(search_point(x1, y1, h));\n\t\t\tv.push_back(search_point(x0, y1, h));\n\t\t\tv.push_back(search_point(x1, y0, h));\n\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x0, y0, 0), search_point(x1, y0, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x1, y0, 0), search_point(x1, y1, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x1, y1, 0), search_point(x0, y1, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x0, y1, 0), search_point(x0, y0, 0)));\n\n\t\t\tlect.push_back(pair<search_point,search_point>(search_point(x0, y0, 0), search_point(x1, y1, 0)));\n\n\t\t\tif(x0 <= sx && sx <= x1) {\n\t\t\t\tv.push_back(search_point(sx, y0, h));\n\t\t\t\tv.push_back(search_point(sx, y1, h));\n\t\t\t}\n\t\t\tif(y0 <= sy && sy <= y1) {\n\t\t\t\tv.push_back(search_point(x0, sy, h));\n\t\t\t\tv.push_back(search_point(x1, sy, h));\n\t\t\t}\n\t\t\tif(x0 <= ex && ex <= x1) {\n\t\t\t\tv.push_back(search_point(ex, y0, h));\n\t\t\t\tv.push_back(search_point(ex, y1, h));\n\t\t\t}\n\t\t\tif(y0 <= ey && ey <= y1) {\n\t\t\t\tv.push_back(search_point(x0, ey, h));\n\t\t\t\tv.push_back(search_point(x1, ey, h));\n\t\t\t}\n\t\t}\n\n\t\tdouble veclx = (ex - sx);\n\t\tdouble vecly = (ey - sy);\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tdouble d;\n\t\t\tdouble mx, my;\n\t\t\tdouble r;\n\n\t\t\tmx = (v[i].x * sqr(veclx) + v[i].y * veclx * vecly + vecly * (sx * ey - sy * ex)) / (sqr(veclx) + sqr(vecly));\n\t\t\tmy = (v[i].y * sqr(vecly) + v[i].x * vecly * veclx + veclx * (sy * ex - sx * ey)) / (sqr(vecly) + sqr(veclx));\n\t\t\t/*\n\t\t\tif((ey - sy) * mx - (ex - sx) * my + (ex * sy - sx * ey) > EPS) {\n\t\t\t\tcout << \"error\" << \" \" << (sy - ey) * mx - (sx - ex) * my - (ex * sy - sx * ey) << endl;\n\t\t\t\tcout << mx << \",\" << my << endl;\n\t\t\t}\n\t\t\t// */\n\t\t\td = sqrt(sqr(mx - v[i].x) + sqr(my - v[i].y));\n\t\t\tif(mx <= min(sx,ex) || max(sx,ex) <= mx || my <= min(sy,ey) || max(sy,ey) <= my) {\n\t\t\t\td = min(sqrt(sqr(sx - v[i].x) + sqr(sy -  v[i].y)), sqrt(sqr(ex - v[i].x) + sqr(ey - v[i].y)));\n\t\t\t}\n\t\t\tr = fabs(sqr(min(v[i].h,d)) + sqr(d)) / (2 * v[i].h);\n\t\t\tR = min(R, r);\n\t\t}\n\t\tfor(int i = 0; i < line.size(); i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble s, t;\n\t\t\tx0 = line[i].first.x; y0 = line[i].first.y;\n\t\t\tx1 = line[i].second.x; y1 = line[i].second.y;\n\n\t\t\ts = ((ex - sx) * (y1 - sy) - (ey - sy) * (x1 - sx)) / ((x0 - sx) * (y1 - sy) - (y0 - sy) * (x1 - sx));\n\t\t\tt = ((ex - sx) * (y0 - sy) - (ey - sy) * (x0 - sx)) / ((x1 - sx) * (y0 - sy) - (y1 - sy) * (x0 - sx));\n\n\t\t\tif(s > -EPS && t > -EPS && s + t > 1 - EPS) {\n\t\t\t\tif(isnan(s) | isnan(s))\n\t\t\t\t\texit(1);\n\t\t\t\tR = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < lect.size(); i++) {\n\t\t\tbool flag0, flag1;\n\t\t\tflag0 = lect[i].first.x < sx && sx < lect[i].second.x && lect[i].first.y < sy && sy < lect[i].second.y;\n\t\t\tflag1 = lect[i].first.x < ex && ex < lect[i].second.x && lect[i].first.y < ey && ey < lect[i].second.y;\n\n\t\t\tif(flag0 | flag1)\n\t\t\t\tR = 0;\n\t\t}\n\t\tprintf(\"%.10f\\n\", R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-7;\nconst double PI  = acos(-1.0);\n\n#define M INT_MAX\nstruct P{\n  double x;\n  double y;\n\n  P(){\n\tx=M; y=M;\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n\n};\ndouble dot(P a,P b){\n  return (a.x*b.x+a.y*b.y);\n}\n\ndouble cross(P a,P b){\n  return (a.x*b.y-a.y*b.x);\n}\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\ndouble psd(P p , P a , P b){\n  if( dot( b-a , p-a ) < EPS) return fabs(dis(p-a));\n  if( dot( a-b , p-b ) < EPS) return fabs(dis(p-b));\n  return fabs(cross( b-a , p-a )) / fabs(dis(b-a));\n}\n\nbool intersect_s(P a1 , P a2 , P b1 , P b2){\n  return ( cross(a2-a1 , b1-a1)*cross(a2-a1 , b2-a1) < EPS) &&\n\t( cross(b2-b1 , a1-b1)*cross(b2-b1 , a2-b1) < EPS);\n}\n\ndouble dist_s(P p1, P p2, P q1, P q2){\n  if(intersect_s(p1,p2,q1,q2)) return 0;\n  return min(min(psd(p1, q1, q2), psd(p2, q1, q2)),\n\t\t\t min(psd(q1, p1, p2), psd(q2, p1, p2)));\n}\n\nbool isin(P p, P a1, P a2){\n  double mx = min(a1.x, a2.x), Mx = max(a1.x, a2.x);\n  double my = min(a1.y, a2.y), My = max(a1.y, a2.y);\n  return mx < p.x && p.x < Mx\n\t&& my < p.y  && p.y < My;\n}\n\nint main(){\n  int N;\n  while(cin>>N,N){\n\tP s, e;\n\tvector< vector<P> > ps(N, vector<P>(4));\n\tvector<double> h(N), d(N, M);\n\tcin >> s.x >> s.y >> e.x >> e.y;\n\tREP(i,N)\n\t  cin >> ps[i][0].x >> ps[i][0].y >> ps[i][2].x >> ps[i][2].y >> h[i];\n\tREP(i,N){\n\t  ps[i][1].x = ps[i][0].x;\n\t  ps[i][1].y = ps[i][2].y;\n\n\t  ps[i][3].x = ps[i][2].x;\n\t  ps[i][3].y = ps[i][0].y;\n\t}\n\n\tbool ng = false;\n\tREP(i,N){\n\t  if(isin(s, ps[i][0], ps[i][2]) || isin(e, ps[i][0], ps[i][2]))\n\t\tng = true;\n\t  REP(j,4)\n\t\tif(intersect_s(s,e,ps[i][j],ps[i][(j+1)%4]))\n\t\t   ng = true;\n\t}\n\tif(ng){\n\t  cout << 0 << endl;\n\t  continue;\n\t}\n\n\tREP(i,N) REP(j,4){\n\t  d[i] = min(d[i], dist_s(s, e, ps[i][j], ps[i][(j+1)%4]));\n\t}\n\n\tdouble r_lb = 0., r_ub = 1000.;\n\n\tREP(i,100){\n\t  bool flag = true;\n\t  double r = (r_lb + r_ub) / 2.;\n\t  REP(j,N){\n\t\tif(d[j] < sqrt(r*r - (r-min(r, h[j]))*(r-min(r, h[j])))){\n\t\t  flag = false;\n\t\t  break;\n\t\t}\n\t  }\n\n\t  if(flag) r_lb = r;\n\t  else r_ub = r;\n\t}\n\n\tcout << fixed << setprecision(6) << r_lb << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p1;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n//\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tint x=ccw(s.p1,s.p2,pr);\n//\tif(x>=-1&&x<=1) return d;\n\tif(x==0) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t\tbool flg1=(abs(oneLineCCW(q[0],q[1],r))<=1);\n\t\tbool flg2=ccw(q[0],q[1],r)==0;\n\t\tif(flg1!=flg2) assert(0);\n\t//\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\tif(ccw(q[0],q[1],r)==0){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t\tflg1=abs(oneLineCCW(p[0],p[1],r)<=1);\n\t\tflg2=ccw(p[0],p[1],r);\n\t\tif(flg1!=flg2) assert(0);\n\t//\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\tif(ccw(p[0],p[1],r)==0){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tif(eq(abs(s-t),0.0)) for(;;);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tif(eq(abs(e.p1-e.p2),0.0)) for(;;);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = long double;\nconstexpr R pi = acos((R)-1), eps = 1e-10;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\n// -2: back, -1: cw, 0: on, 1: ccw, 2: front\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\nP intxn(L l, L m) {\n  assert(sgn(crs(l.vec(), m.vec())));\n  return l.s + crs(m.s - l.s, m.vec()) / crs(l.vec(), m.vec()) * l.vec();\n}\n\nusing G = V<P>;\nR area(const G& g) {\n  if (g.size() < 3) return 0;\n  R res = 0;\n  P a = g.back();\n  for (P b : g) {\n    res += crs(a, b) / 2;\n    a = b;\n  }\n  return res;\n}\n// -1: in, 0: on, 1: out\nint contains(const G& g, P p) {\n  assert(g.size() >= 3);\n  int c = 0;\n  P q = p + P(pi, 1), a = g.back();\n  for (P b : g) {\n    if (!ccw(a, b, p)) return 0;\n    if (!sgn(distLS({p, q}, {a, b}))) {\n      c += ccw(p, q, intxn({p, q}, {a, b})) >= 0;\n    }\n    a = b;\n  }\n  return c & 1 ? -1 : 1;\n}\nG half_convex_hull(const V<P>& ps, bool strict) {\n  G g;\n  for (P p : ps) {\n    while (g.size() >= 2) {\n      int c = ccw(g[g.size() - 2], g.back(), p);\n      if (c == 1 or !strict and c == 2) break;\n      g.pop_back();\n    }\n    g.push_back(p);\n  }\n  g.pop_back();\n  return g;\n}\nG convex_hull(V<P> ps, bool strict = true) {\n  sort(begin(ps), end(ps), cmp);\n  ps.erase(unique(begin(ps), end(ps), eql), end(ps));\n  if (ps.size() < 3) return ps;\n  G g = half_convex_hull(ps, strict);\n  reverse(begin(ps), end(ps));\n  G h = half_convex_hull(ps, strict);\n  g.insert(end(g), begin(h), end(h));\n  return g;\n}\nR diameter(const G& g) {\n  auto e = minmax_element(begin(g), end(g), cmp);\n  int n = g.size(), i = e.first - begin(g), j = e.second - begin(g);\n  R res = 0;\n  for (int _ = 0; _ < n; ++_) { // n: 半周, 2n: 一周\n    res = max(res, distPP(g[i], g[j]));\n    int ni = (i + 1) % n, nj = (j + 1) % n;\n    if (sgn(crs(g[ni] - g[i], g[nj] - g[j])) < 0) i = ni;\n    else j = nj;\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int n; cin >> n;\n    if (!n) break;\n    P ps, pt; cin >> ps >> pt;\n    R res = 2000;\n    while (n--) {\n      P pa, pb, pc, pd;\n      cin >> pb >> pd;\n      pa = P(real(pb), imag(pd));\n      pc = P(real(pd), imag(pb));\n      R d = min({\n        distSS({ps, pt}, {pa, pb}),\n        distSS({ps, pt}, {pb, pc}),\n        distSS({ps, pt}, {pc, pd}),\n        distSS({ps, pt}, {pd, pa}),\n      });\n      R h; cin >> h;\n      if (sgn(h, d) >= 0) res = min(res, d);\n      else {\n        res = min(res, (d * d + h * h) / (2 * h));\n      }\n      if (contains({pa, pb, pc, pd}, ps) <= 0 or contains({pa, pb, pc, pd}, ps) <= 0) res = 0;\n    }\n    cout << fixed << setprecision(15) << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e9)\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(P a, P b, P c){\n  if(cross(b-a,c-a) > EPS) return 1;\n  if(cross(b-a,c-a) < -EPS) return -1;\n  if(dot(b-a,c-a) < EPS) return 2;\n  if(abs(b-a) + EPS < abs(c-a)) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\ndouble p_to_s_dist(P a, L s){\n  if(dot(s.second-s.first,a-s.first) >= 0 && dot(s.first-s.second,a-s.second) >= 0){\n    return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n  }\n  return min(abs(a-s.first), abs(a-s.second));\n}\n\ndouble s_to_s_dist(L a, L b){\n  if(is_cross(a,b)) return 0;\n  return min(min(p_to_s_dist(a.first,b),p_to_s_dist(a.second,b)),\n\t     min(p_to_s_dist(b.first,a),p_to_s_dist(b.second,a)));\n}\n\nint main(){\n  int N;\n  double h, d, x[2], y[2];\n  while(cin >> N, N){\n    vector<P> V;\n    cin >> x[0] >> y[0] >> x[1] >> y[1];\n    P s = P(x[0],y[0]), e = P(x[1],y[1]);\n    L c = L(s,e);\n    for(int i = 0; i < N; ++i){\n      cin >> x[0] >> y[0] >> x[1] >> y[1] >> h;\n      L edge[4];\n      for(int j = 0; j < 4; ++j){\n\tedge[j] = L(P(x[j/2],y[j%2]),P(x[((j+1)/2)%2],y[(j+1)%2]));\n      }\n      d = 100000;\n      for(int j = 0; j < 4; ++j){\n\td = min(d, s_to_s_dist(c, edge[j]));\n      }\n      V.push_back(P(d,h));\n    }\n    sort(V.begin(), V.end());\n    if(abs(V[0].X) < EPS){\n      cout << 0 << endl;\n      continue;\n    }\n    double ub = 100000, lb = 0, r = ub/2;\n    for(int t = 0; t < 100000; ++t){\n      r = (ub+lb)/2;\n      bool f = true;\n      for(int i = 0; i < N; ++i){\n\tif((r > norm(V[i])/2/V[i].Y) && (r > V[i].X)){\n\t  f = false;\n\t  break;\n\t}\n      }\n      if(f) lb = r;\n      else ub = r;\n    }\n    printf(\"%.10lf\\n\", r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std;\n\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\n// 誤差を加味した符号判定\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\n\n// 比較演算子\nnamespace std{\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\n// 内積・外積\ndouble dot(P a, P b){\n    return real(conj(a) * b);\n}\ndouble cross(P a, P b){\n    return imag(conj(a) * b);\n}\n\n// OAとOBのなす符号付き角度 [-pi, pi]\n// example : (1, 0), (0, 1) -> pi/2\ndouble angle(P a, P b){\n    return arg(conj(a) * b);\n}\n\n// aをc中心にb[rad]回転\n// verify : not yet.\nP rotate(P a, double b, P c = P()){\n    return (a - c) * polar(1.0, b) + c;\n}\n\n// 直線ABに対する点Cの位置\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > +EPS)   return +1; // 反時計回り\n    if (cross(b, c) < -EPS)   return -1; // 時計回り\n    if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n    if (norm(b) < norm(c)) return -2; // a--b--c の順番で一直線上\n    return 0;                         // 点が線分ab上にある\n}\n\nenum{ OUT, ON, IN };\nstruct L : public vector<P> {\n    L(){}\n    L(const P& a, const P& b) {\n        push_back(a); push_back(b);\n    }\n    P vector() const {\n        return back() - front();\n    }\n};\n\n// 注意: 端点で交わったり直線が重なったりする場合も交差していると判定する\n\n// 二直線の平行判定\n// verify : aoj0021\nbool paralell(L l, L m){\n    return sign(cross(l.vector(), m.vector())) == 0;\n}\n\n// 二直線の同一判定\nbool equalLL(L l, L m){\n    return sign(cross(l.vector(), m[0] - l[0])) == 0;\n}\n\n// 直線と点の交差判定\nbool iLP(L l, P p) {\n    // 直線lとl[0]からpへの直線が平行\n    return sign(cross(l.vector(), p - l[0])) == 0;\n}\n\n// 線分と点の交差判定(端点の処理に注意)\n// verify : aoj1279\nbool iSP(L s, P p) {\n    return ccw(s[0], s[1], p) == 0;\n}\n\n// 直線と線分の交差判定(線分が重なっている時に注意)\nbool iLS(L l, L s) {\n    // 直線lについて、線分sの端点が異なる側にある\n    return sign(cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0])) <= 0;\n}\n\n// 二つの線分の交差判定(線分が重なっている時や端点の処理に注意)\nbool iSS(L s, L t) {\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n        ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\n\n// 点pから直線lに対する射影\nP proj(L l, P p){\n    double t = dot(p - l[0], l.vector()) / norm(l.vector());\n    return l[0] + t * l.vector();\n}\n\n// 点pの直線lに関する反射\nP refl(L l, P p){\n    return 2.0 * proj(l, p) - p;\n}\n\n// 直線と点の距離\ndouble dLP(L l, P p){\n    // return abs(p - projection(l, p));\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\n\n// 線分と点の距離 ( not verified !!! )\ndouble dSP(L s, P p){\n    if(sign(dot(s.vector(), p - s[0])) <= 0) return abs(p - s[0]);\n    if(sign(dot(-s.vector(), p - s[1])) <= 0) return abs(p - s[1]);\n    return dLP(s, p);\n}\n\n// 直線と直線の距離\ndouble dLL(L l, L m){\n    // 平行でないときは0, 平行のときは垂線の長さ\n    return paralell(l, m) ? dLP(l, m[0]) : 0;\n}\n\n// 直線と線分の距離\ndouble dLS(L l, L s){\n    if(iLS(l, s)) return 0;\n    return min(dLP(l, s[0]), dLP(l, s[1]));\n}\n\n// 線分と線分の距離\ndouble dSS(L s, L t){\n    if(iSS(s, t)) return 0;\n    return min({dSP(s, t[0]), dSP(s, t[1]), dSP(t, s[0]), dSP(t, s[1])});\n}\n\n// 直線と直線の交点\nP pLL(L l, L m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n    if(sign(A) == 0) assert(false); // 直線が交わらない\n    return m[0] + m.vector() * B / A;\n}\n\ntypedef vector<P> Polygon; // 反時計回りを仮定\n\n// Polygonの要素へのアクセス\nP curr(const Polygon& a, int x){ return a[x]; }\nP next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nP prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n// 点が多角形のどこにあるのか判定する\n// verify : aoj0012\nint contains(const Polygon& A, const P& p){\n    // 点pから半直線をひき、辺と交差する回数を数える\n    bool in = false;\n    for(int i = 0; i < A.size(); i++){\n        P a = curr(A, i) - p;\n        P b = next(A, i) - p;\n        if(a.imag() > b.imag()) swap(a, b);\n        // aからbの直線がy=0と交わり、その交点は原点の右側である\n        if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0){ \n            in = !in;\n        }\n        if(sign(cross(a, b)) == 0 && sign(dot(a, b)) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\n// 多角形の面積\n// verify : aoj0079 aoj1100\ndouble area(const Polygon& A) {\n    double res = 0;\n    for(int i = 0; i < A.size(); i++){\n        res += cross(curr(A, i), next(A, i));\n    }\n    return abs(res) / 2.0;\n}\n\n// 凸包\nPolygon convex_hull(vector<P> ps) {\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<P> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){ // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){ // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\nbool is_convex(const Polygon& A){\n    for(int i = 0; i < A.size(); i++){\n        if(ccw(prev(A, i), curr(A, i), next(A, i)) > 0) return false;\n    }\n    return true;\n}\n\n// 凸多角形の直線による切断。直線の左側だけ残す\n// verify : aoj1283\nPolygon convex_cut(const Polygon& A, L l){\n    Polygon B;\n    for(int i = 0; i < A.size(); i++){\n        P a = curr(A, i), b = next(A, i);\n        if(ccw(l[0], l[1], a) != -1) B.push_back(a); //Aが直線lの右側でない\n        if(ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0)\n            B.push_back(pLL(l, L(a, b)));\n    }\n    return B;\n}\n// 垂直二等分線\n// verify: maximamcup2013 D\nL bisector(P a, P b){\n    P mid = (a + b) / 2.0;\n    P vec = (mid - a) * P(0.0, 1.0);\n    return L(mid, mid + vec);\n}\n// 点集合psのうちs番目のボロノイ領域\n// verify: maximamcup2013 D\nPolygon voronoi_cell(Polygon A, const vector<P>& ps, int s){\n    for(int i = 0; i < ps.size(); i++){\n        if(i != s) A = convex_cut(A, bisector(ps[s], ps[i]));\n    }\n    return A;\n}\nstruct Circle {\n    P p;\n    double r;\n    Circle() {}\n    Circle(P p, double r) : p(p), r(r) { }\n};\n\n// 円と点の内外判定\nint contains(const Circle& C, const P& p){\n    double d = abs(C.p - p);\n    if(sign(d - C.r) > 0) return OUT;\n    if(sign(d - C.r) == 0) return ON;\n    return IN;\n}\n\n// 円と線分の交差判定(境界を含む)\n// Verified: AOJ 0129\nbool iCS(const Circle& C, const L& l){\n    int c1 = contains(C, l[0]);\n    int c2 = contains(C, l[1]);\n    if(c1 > c2) swap(c1, c2);\n\n    // (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) の6通り\n    if(c1 == OUT && c2 == IN) return true;\n    if(c1 == IN  && c2 == IN) return false;\n    if(c1 == ON) return true; // (接するとき) \n    double d = dSP(l, C.p);\n    if(sign(d - C.r) < 0) return true;\n    if(sign(d - C.r) == 0) return true; // (接するとき)\n    if(sign(d - C.r) > 0) return false;\n}\n\n// 二つの円の交差判定(接する時を含む)\nbool iCC(const Circle& C, const Circle& D){\n    // 円の中心同士の距離が、半径の和以下であり、半径の差以上である\n    double e = abs(C.p - D.p);\n    return sign(e - (C.r + D.r)) <= 0 && sign(e - abs(C.r - D.r)) >= 0;\n}\n\n// 円と直線の交点\n// verify : aoj2045\nvector<P> pLC(const L &l, const Circle &c) {\n    vector<P> res;\n    P center = proj(l, c.p);\n    double d = abs(center - c.p);\n    double tt = c.r * c.r - d * d;\n    if(tt < 0 && tt > -EPS) tt = 0;\n    if(tt < 0) return res;\n    double t = sqrt(tt);\n    P vect = l.vector();\n    vect /= abs(vect);\n    res.push_back(center - vect * t);\n    if (t > EPS) {\n        res.push_back(center + vect * t);\n    }\n    return res;\n}\n\n// 円と線分の交点\nvector<P> pSC(const L &s, const Circle &c) {\n    vector<P> ret;\n    vector<P> nret = pLC(s, c);\n    for (int i = 0; i < nret.size(); i++) {\n        if (iSP(s, nret[i])) ret.push_back(nret[i]);\n    }\n    return ret;\n}\n\n// 円と円の交点\n// verify : aoj1183\nvector<P> pCC(Circle a, Circle b){\n    vector<P> res;\n\n    double l = abs(b.p - a.p);\n\n    if(sign(l) == 0 && sign(a.r - b.r) == 0) assert(false); // 解が無限に存在する\n    if(sign(l - abs(a.r - b.r)) < 0 || sign(l - (a.r + b.r)) > 0) return res; // 解が存在しない\n\n    double th1 = arg(b.p - a.p);\n    if(sign(l - abs(a.r - b.r)) == 0 || sign(l - (a.r + b.r)) == 0){\n        res.push_back(a.p + polar(a.r, th1));\n    }else {\n        double th2 = acos( (a.r * a.r - b.r * b.r + l * l) / (2 * a.r * l) );\n        res.push_back(a.p + polar(a.r, th1 - th2));\n        res.push_back(a.p + polar(a.r, th1 + th2));\n    }\n    return res;\n}\n\n// 2点を通る半径rの円の中心\n// verify : aoj1132\nvector<P> touching_circle2(P a, P b, double r){\n    vector<P> res;\n\n    double d = abs(b - a);\n    if(d > 2 * r) return res;\n\n    P mid = 0.5 * (a + b);\n    P dir = polar(sqrt(r * r - d * d / 4), arg(b - a) + M_PI / 2);\n    res.push_back(mid + dir);\n    res.push_back(mid - dir);\n    return res;\n}\n\n// 3点を通る円\nCircle touching_circle3(P a, P b, P c){\n    // ２つの垂直二等分線の交点が円の中心\n    P mid_ab = (a + b) / 2.0;\n    L bis_ab(mid_ab, (mid_ab - a) * P(0.0, 1.0));\n    P mid_bc = (b + c) / 2.0;\n    L bis_bc(mid_bc, (mid_bc - b) * P(0.0, 1.0));\n\n    assert(!paralell(bis_ab, bis_bc)); \n\n    P center = pLL(bis_ab, bis_bc);\n    return Circle(center, abs(a - center));\n}\n\n// 円と円の共通部分の面積を求める．\n// ref: nya3j\ndouble cc_area(const Circle& c1, const Circle& c2) {\n    double d = abs(c1.p - c2.p);\n    if (c1.r + c2.r < d + EPS) {\n        return 0.0;\n    } else if (d < abs(c1.r - c2.r) + EPS) {\n        double r = min(c1.r, c2.r); // 元は c1.r >? c2.r だった．\n        return r * r * M_PI;\n    } else {\n        double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n        double theta = acos(rc / c1.r);\n        double phi = acos((d - rc) / c2.r);\n        return c1.r*c1.r*theta + c2.r*c2.r*phi - d*c1.r*sin(theta);\n    }\n}\n// 円の接線 (中心から偏角thの点で接する接線)\n// verified: AOJ 2201 Immortal Jewels \nL circle_tangent(const Circle& C, double th){\n    P p0 = C.p + polar(C.r, th);\n    P p1 = p0 + polar(1.0, th + M_PI / 2);\n    return L(p0, p1);\n}\n\n// 二つの円の共通接線 (Cの中心から接点へのベクトルの偏角を返す)\n// verified: AOJ 2201 Immortal Jewels \n// 参考: http://geom.web.fc2.com/geometry/circle-circle-tangent.html\nvector<double> common_tangents(const Circle& C, const Circle& D){\n    vector<double> res;\n    P v = D.p - C.p;\n    double l = abs(v); // 二円の中心間の距離\n    double a = arg(v); // 二円の中心間の偏角\n    if(sign(l - abs(C.r - D.r)) > 0){\n        // 交わる or 外接 or 離れている\n        // 二つの外側接線\n        double a1 = acos((C.r - D.r) / l);\n        res.push_back(a + a1);\n        res.push_back(a - a1);\n        if(sign(l - (C.r + D.r)) > 0){\n            // 離れている\n            // 二つの内側接線\n            double a2 = acos((C.r + D.r) / l);\n            res.push_back(a + a2);\n            res.push_back(a - a2);\n        }\n    }\n    if((sign(l - abs(C.r - D.r)) == 0 || sign(l - (C.r + D.r)) == 0) && sign(l) != 0){\n        // 内接 or 外接\n        // 一つの接線\n        res.push_back(a);\n    }\n    return res;\n}\n\n// 1点を通る円の接線( pがCの外側にあることが前提条件 )\n// verified : AOJ 2579\nvector<L> tangents_through_point(const Circle& C, const P& p){\n    vector<L> tangents;\n    double d = abs(C.p - p);\n    // d ^ 2 == r ^ 2 + e ^ 2\n    double e = sqrt(d * d - C.r * C.r); // 点pと円の接点の距離\n    // d * sin(th) = r\n    double th = asin(C.r / d);\n    P q1 = p + (C.p - p) * polar(1.0, +th) * e / d;\n    P q2 = p + (C.p - p) * polar(1.0, -th) * e / d;\n    tangents.push_back(L(p, q1));\n    tangents.push_back(L(p, q2));\n    return tangents;\n}\nint main(){\n    int N;\n    while(cin>>N && N){\n        double sx, sy, gx, gy;\n        cin>>sx>>sy>>gx>>gy;\n        P sp(sx, sy);\n        P gp(gx, gy);\n        double ans = 1e8;\n        L route(sp, gp);\n        for(int i = 0; i < N; i++) {\n            double mx, my, nx, ny, h;\n            cin>>mx>>my>>nx>>ny>>h;\n            if(mx <= sx && sx <= nx && my <= sy && sy <= ny) ans = 0;\n            L ls[4];\n            ls[0] = L(P(mx,my),P(nx,my));\n            ls[1] = L(P(mx,my),P(mx,ny));\n            ls[2] = L(P(mx,ny),P(nx,ny));\n            ls[3] = L(P(nx,my),P(nx,ny));\n            for(int j = 0; j < 4; j++) {\n                L l = ls[j];\n                double dist = dSS(route, l);\n                if(dist == 0) ans = 0;\n                double radian;\n                if(dist - EPS < h) radian = dist;\n                else radian = (h*h + dist*dist)/(2*h);\n                ans = min(ans, radian);\n            }\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n\ntypedef complex<double> P;\ntypedef vector<P> G;\ndouble const inf=1e10;\ndouble const eps=1e-8;\n\ninline double cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\ninline double dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n};\n\ninline int ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;\n    if (cross(b, c) < 0)   return -1;\n    if (dot(b, c) < 0)     return +2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\n\ninline P projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\ninline bool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\ninline bool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < eps; // triangle inequality\n}\n\nbool intersectRS(const G &r, const L &l){\n    if(r[0].real()<=l[0].real() && l[0].real()<=r[2].real() &&\n       r[0].imag()<=l[0].imag() && l[0].imag()<=r[2].imag() &&\n       r[0].real()<=l[1].real() && l[1].real()<=r[2].real() &&\n       r[0].imag()<=l[1].imag() && l[1].imag()<=r[2].imag()){\n        return true;\n    }\n    rep(i,4){\n        L m(r[i],r[(i+1)%4]);\n        if(intersectSS(l,m)) return true;\n    }\n    return false;\n}\n\ninline double distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nint n;\nL l{0,0};\nG rs[50];\ndouble hs[50];\n\ndouble maxr(P p, G const& rect, double h){\n    double res=inf;\n    rep(i,4){\n        double d=distanceSP({rect[i],rect[(i+1)%4]},p);\n        if(d<h) res=min(res,d);\n        else res=min(res,(d*d+h*h)/(2*h));\n    }\n    // printf(\" %lf\\n\",res);\n    return res;\n}\n\ndouble solve(){\n    double ans=inf;\n    rep(i,n){\n        if(intersectRS(rs[i],l)) return 0;\n    }\n    rep(i,n){\n        rep(j,4){\n            P prj = projection(l,rs[i][j]);\n            if(!intersectSP(l,prj)) continue;\n            ans=min(ans, maxr(prj,rs[i],hs[i]));\n        }\n        // printf(\" %lf\\n\",ans);\n        ans=min(ans,maxr(l[0],rs[i],hs[i]));\n        ans=min(ans,maxr(l[1],rs[i],hs[i]));\n    }\n    return ans;\n}\n\nint main(){\n    while(cin>>n && n){\n        double sx,sy,ex,ey;\n        cin >> sx>>sy>>ex>>ey;\n        l = L{P(sx,sy),P(ex,ey)};\n        rep(i,n){\n            double mx,my,Mx,My;\n            cin>>mx>>my>>Mx>>My >> hs[i];\n            rs[i] = {P(mx,my),P(Mx,my),P(Mx,My),P(mx,My)};\n        }\n        printf(\"%.5lf\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n#define EPS (1e-10)\n\nint SX, SY, TX, TY;\nint N;\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\nbool intersect(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\ndouble dist(P a, P b, P c) {\n  if (dot(b-a, c-a) < 0) return abs(c-a);\n  if (dot(a-b, c-b) < 0) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble f(double d, double h) {\n  if (h >= d) return d;\n  double lo = d, hi = 1e10;\n  rep(_, 200) {\n    double mid = (lo + hi) / 2;\n    double t = mid / (mid/h - 1);\n    double g = sqrt(t*t - h*h) * (mid/h - 1);\n    if (d >= g) lo = mid;\n    else hi = mid;\n  }\n  return lo;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> N) {\n    if (N == 0) break;\n    cin >> SX >> SY >> TX >> TY;\n    double ans = 1e10;\n    rep(i, N) {\n      int lx, ly, rx, ry, h;\n      cin >> lx >> ly >> rx >> ry >> h;\n      if (intersect(P(SX, SY), P(TX, TY), P(lx, ly), P(lx, ry))) ans = 0;\n      if (intersect(P(SX, SY), P(TX, TY), P(lx, ry), P(rx, ry))) ans = 0;\n      if (intersect(P(SX, SY), P(TX, TY), P(rx, ry), P(rx, ly))) ans = 0;\n      if (intersect(P(SX, SY), P(TX, TY), P(rx, ly), P(lx, ly))) ans = 0;\n      if (lx<=SX&&ly<=SY&&rx>=TX&&ry>=TY) ans = 0;\n      ans = min(ans, f(dist(P(SX, SY), P(TX, TY), P(lx, ly)), h));\n      ans = min(ans, f(dist(P(SX, SY), P(TX, TY), P(lx, ry)), h));\n      ans = min(ans, f(dist(P(SX, SY), P(TX, TY), P(rx, ly)), h));\n      ans = min(ans, f(dist(P(SX, SY), P(TX, TY), P(rx, ry)), h));\n\n      ans = min(ans, f(dist(P(lx, ly), P(lx, ry), P(SX, SY)), h));\n      ans = min(ans, f(dist(P(lx, ry), P(rx, ry), P(SX, SY)), h));\n      ans = min(ans, f(dist(P(rx, ry), P(rx, ly), P(SX, SY)), h));\n      ans = min(ans, f(dist(P(rx, ly), P(lx, ly), P(SX, SY)), h));\n\n      ans = min(ans, f(dist(P(lx, ly), P(lx, ry), P(TX, TY)), h));\n      ans = min(ans, f(dist(P(lx, ry), P(rx, ry), P(TX, TY)), h));\n      ans = min(ans, f(dist(P(rx, ry), P(rx, ly), P(TX, TY)), h));\n      ans = min(ans, f(dist(P(rx, ly), P(lx, ly), P(TX, TY)), h));\n    }\n    cout << fixed << setprecision(20) << ans << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-9;\ntemplate<typename T>\nT sqr(T a) { return a * a; }\n\nstruct search_point {\n\tdouble x, y;\n\tdouble h;\n\tsearch_point(double x_, double y_, double h_) {\n\t\tx = x_; y = y_; h = h_;\n\t}\n};\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tdouble sx, sy, ex, ey;\n\t\tvector<search_point> v;\n\t\tvector<search_point> on_l;\n\t\tvector<pair<search_point, search_point> > lect;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\ton_l.push_back(search_point(sx,sy,0));\n\t\ton_l.push_back(search_point(ex,ey,0));\n\t\tdouble R = 10000;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble h;\n\t\t\tcin >> x0 >> y0 >> x1 >> y1 >> h;\n\n\t\t\tlect.push_back(pair<search_point, search_point>(search_point(x0,y0,h), search_point(x1,y1,h)));\n\n\t\t\tif(h < EPS)\n\t\t\t\th = EPS;\n\n\t\t\tv.push_back(search_point(x0, y0, h));\n\t\t\tv.push_back(search_point(x1, y1, h));\n\t\t\tv.push_back(search_point(x0, y1, h));\n\t\t\tv.push_back(search_point(x1, y0, h));\n\n\t\t\tif(x0 < sx && sx < x1) {\n\t\t\t\tv.push_back(search_point(sx, y0, h));\n\t\t\t\tv.push_back(search_point(sx, y1, h));\n\t\t\t}\n\t\t\tif(y0 < sy && sy < y1) {\n\t\t\t\tv.push_back(search_point(x0, sy, h));\n\t\t\t\tv.push_back(search_point(x1, sy, h));\n\t\t\t}\n\t\t\tif(x0 < ex && ex < x1) {\n\t\t\t\tv.push_back(search_point(ex, y0, h));\n\t\t\t\tv.push_back(search_point(ex, y1, h));\n\t\t\t}\n\t\t\tif(y0 < ey && ey < y1) {\n\t\t\t\tv.push_back(search_point(x0, ey, h));\n\t\t\t\tv.push_back(search_point(x1, ey, h));\n\t\t\t}\n\t\t}\n\n\t\tdouble veclx = (ex - sx);\n\t\tdouble vecly = (ey - sy);\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tdouble d;\n\t\t\tdouble mx, my;\n\t\t\tdouble r;\n\n\t\t\tmx = (v[i].x * sqr(veclx) + v[i].y * veclx * vecly + vecly * (sx * ey - sy * ex)) / (sqr(veclx) + sqr(vecly));\n\t\t\tmy = (v[i].y * sqr(vecly) + v[i].x * vecly * veclx + veclx * (sy * ex - sx * ey)) / (sqr(vecly) + sqr(veclx));\n\t\t\t/*\n\t\t\tif((ey - sy) * mx - (ex - sx) * my + (ex * sy - sx * ey) > EPS) {\n\t\t\t\tcout << \"error\" << \" \" << (sy - ey) * mx - (sx - ex) * my - (ex * sy - sx * ey) << endl;\n\t\t\t\tcout << mx << \",\" << my << endl;\n\t\t\t}\n\t\t\t// */\n\t\t\td = sqrt(sqr(mx - v[i].x) + sqr(my - v[i].y));\n\t\t\tif(mx <= min(sx,ex) - EPS || max(sx,ex) + EPS <= mx || my <= min(sy,ey) - EPS || max(sy,ey) + EPS <= my) {\n\t\t\t\td = min(sqrt(sqr(sx - v[i].x) + sqr(sy -  v[i].y)), sqrt(sqr(ex - v[i].x) + sqr(ey - v[i].y)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\ton_l.push_back(search_point(mx, my, 0));\n\t\t\t}\n\t\t\tr = fabs(sqr(min(v[i].h,d)) + sqr(d)) / (2 * v[i].h);\n\t\t\tR = min(R, r);\n\t\t}\n\n\t\tfor(int i = 0; i < on_l.size(); i++) {\n\t\t\tfor(int j = 0; j < lect.size(); j++) {\n\t\t\t\tif((lect[j].first.x - EPS <= on_l[i].x && on_l[i].x <= lect[j].second.x + EPS)\n\t\t\t\t\t\t&& (lect[j].first.y - EPS <= on_l[i].y && on_l[i].y <= lect[j].second.y + EPS)) {\n\t\t\t\t\tR = 0;\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nfail:\n\t\tprintf(\"%.10f\\n\", R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <limits.h>\n\nusing namespace std;\n\n#define ZEROP(x) (fabs(x) < EPS)\n#define EQ(x, y) ZEROP((x) - (y))\n#define LT(x, y) ((x) - (y) <= -EPS) // x < y\n#define LE(x, y) ((x) - (y) < +EPS) // x <= y\n#define SIGN(x) ((x)<-EPS?-1:((x)>EPS?+1:0))\n\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define REPD(i,n) for(int i=(int)(n); i-->0;)\n#define REPI(i,a,b) for(int i=(int)(a); i<=(int)(b); i++)\n#define ALL(a) (a).begin(),(a).end()\n#define mp make_pair\n#define fst first\n#define snd second\n\n#define INFTY 1000000000\n#define EPS 1e-9\n#define PI 3.141592653589793\n\n#define INF (INFTY/3)\n\n#define rev(s) (string((s).rbegin(), (s).rend()))\n\ntypedef long long Int;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<double,double> pdd;\n\nvoid debug(vi v){ REP(i,v.size()) cout<<v[i]<<\" \"; cout<<endl; }\n\nint nextInt(){ int t; cin>>t; return t; } // DæÊÉCðÂ¯Äg¤±Æ\n\ntypedef complex<double> P;\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nnamespace std {\n   bool operator < (const P& a, const P& b) {\n     return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n   }\n}\ndouble cross(const P& a, const P& b) {\n   return imag(conj(a)*b); //OÏu~vÌå«³Dü«ÍL=[u,v]ÉÎµÄCu©çvÖÌEË¶\n} \ndouble dot(const P& a, const P& b) {\n   return real(conj(a)*b); \n}  \nstruct L : public vector<P> {\n  L() {}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  } \n};  \ntypedef vector<P> G;  \nstruct C {\n   P p; double r;\n   C(const P &p, double r) : p(p), r(r) { }\n}; \n\n\n#define MAXN 50\nint N;\nL sl; // start line\nint minx[MAXN];\nint miny[MAXN];\nint maxx[MAXN];\nint maxy[MAXN];\nint h[MAXN];\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (LT( 0, cross(b, c)) )   return +1;       // counter clockwise\n  if (LT( cross(b, c), 0) )   return -1;       // clockwise\n  if (LT( dot(b, c), 0) )     return +2;       // c--a--b on line\n  if (LT( norm(b), norm(c)) ) return -2;       // a--b--c on line\n  return 0;\n}\n\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n// USE IN THIS PROBLEM\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nbool covered(int sx,int sy,int ex,int ey,int ax,int ay,int bx,int by) {\n  return ax < sx && ay < sy && ex < bx && ey < by;\n}\n\n\ndouble solve() {\n  double r = INT_MAX;\n  REP(i,N) {\n    L l[]={L(P(minx[i],miny[i]),P(maxx[i],miny[i])),\n\t   L(P(maxx[i],miny[i]),P(maxx[i],maxy[i])),\n\t   L(P(maxx[i],maxy[i]),P(minx[i],maxy[i])),\n\t   L(P(minx[i],maxy[i]),P(minx[i],miny[i]))};\n    double mind = INT_MAX;\n    int mini; //min index\n    if(covered(real(sl[0]),imag(sl[0]),real(sl[1]),imag(sl[1]),\n\t       minx[i],miny[i],maxx[i],maxy[i])) return 0.0;\n    REP(j,4) {\n      if(intersectSS(l[j],sl)) return 0.0;\n      double dd = distanceSS(l[j],sl);\n      if(LT(dd,mind)) {\n\tmind = dd;\n\tmini = j;\n      }\n    }\n    double r2;\n    //printf(\"mind=%lf\\n\",mind);\n    if(LE(mind,h[i])) { // mind <= h[i]\n      r2=mind;\n    } else {\n      r2=(h[i]*h[i] + mind*mind) / (2*h[i]);\n    }\n    r=min(r,r2);\n    //printf(\"r=%lf\\n\",r);\n  }\n  return r;\n}\n\t\nmain() {\n  while(cin>>N,N) {\n    int sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    sl = L(P(sx,sy),P(ex,ey));\n    REP(i,N)\n      cin>>minx[i]>>miny[i]>>maxx[i]>>maxy[i]>>h[i];\n    printf(\"%.7lf\\n\",solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\ntypedef double Num;\ntypedef complex<Num> Pt2;\ntypedef vector<Pt2>  Polygon2;\n\nstruct Line2 : public vector<Pt2> {\n\tLine2(Pt2 a, Pt2 b) { push_back(a); push_back(b); }\n};\n\nconst double eps = 1e-10;\nNum  dot  (Pt2 a, Pt2 b) { return (a*conj(b)).real(); }\nNum  cross(Pt2 a, Pt2 b) { return (conj(a)*b).imag(); }\nPt2  vec  (Line2 l)      { return l[1]-l[0]; }\n\nint ccw(Pt2 a, Pt2 b, Pt2 c) {\n\tb-=a; c-=a;\n\tif(cross(b,c) > 0 ) return +1; // ccw\n\tif(cross(b,c) < 0 ) return -1; // cw\n\tif(  dot(b,c) < 0 ) return +2; // cab\n\tif(norm(b)<norm(c)) return -2; // abc\n\treturn 0;                      // acb\n}\n\nint ccw(Line2 s, Pt2 p) {\n\treturn ccw(s[0], s[1], p);\n}\n\nbool intersectSP(Line2 s, Pt2 p) {\n\treturn abs(s[0]-p)+abs(s[1]-p) < abs(s[1]-s[0])+eps;\n}\n\nbool intersectSS(Line2 s, Line2 t) {\n\treturn ccw(s,t[0])*ccw(s,t[1]) <= 0 \n\t    && ccw(t,s[0])*ccw(t,s[1]) <= 0;\n}\n\nPt2 projection(Line2 l, Pt2 p) {\n  double t = dot(p-l[0], vec(l)) / norm(vec(l));\n  return l[0] + t*(vec(l));\n}\n\nPt2 reflection(Line2 l, Pt2 p) {\n\treturn p + 2.0*(projection(l,p) - p);\n}\n\nNum distanceSP(Line2 s, Pt2 p) {\n  Pt2 r = projection(s,p);\n  if(intersectSP(s,r)) return abs(r-p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\nNum distanceSS(Line2 s, Line2 t) {\n  if(intersectSS(s,t)) return 0;\n  return min(min(distanceSP(s,t[0]), distanceSP(s,t[1])),\n             min(distanceSP(t,s[0]), distanceSP(t,s[1])));\n}\n\nbool convex_contains(Polygon2 g, Pt2 p)\n{\n\tfor(int i=0; i<g.size(); i++)\n\t{\n\t\tif(ccw(Line2(g[i],g[(i+1)%g.size()]), p)==-1) return false;\n\t}\n\treturn true;\n}\n\ndouble dist(Line2 s, Line2 t, double h) {\n\tdouble d=distanceSS(s,t);\n\tif(d<=h) return d;\n\treturn (d*d+h*h)/(2*h);\n}\n\n\nint main()\n{\n\tint N;\n\twhile(cin>>N, N)\n\t{\n\t\tNum x1,y1,x2,y2,h;\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tLine2 course(Pt2(x1,y1),Pt2(x2,y2));\n\n\t\tdouble ans=1e10;\n\t\twhile(N--)\n\t\t{\t\t\n\t\t\tcin>>x1>>y1>>x2>>y2>>h;\n\t\t\tPolygon2 g(4);\n\t\t\tg[0]=Pt2(x1,y2); g[3]=Pt2(x2,y2);\n\t\t\tg[1]=Pt2(x1,y1); g[2]=Pt2(x2,y1);\n\n\t\t\tif(convex_contains(g,course[0]) || convex_contains(g,course[1]))\n\t\t\t{\n\t\t\t\tans=0; break;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<g.size(); i++)\n\t\t\t{\n\t\t\t\tans = min(ans, dist(course,Line2(g[i],g[(i+1)%g.size()]),h));\n\t\t\t}\n\n\t\t\tif(ans==0) break;\n\t\t}\n\t\tcout.setf(ios::fixed);\n\t\tcout.precision(5);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef complex<double> P;\n\nint N;\ndouble sx,sy,ex,ey,mx,my,Mx,My,h;\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint insected(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\ndouble dist(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\nint main(){\n\twhile(cin>>N&&N){\n\t\tcin>>sx>>sy>>ex>>ey;\n\t\tP s(sx,sy),e(ex,ey);\n\t\tdouble ans=1e9;\n\t\trep(i,N){\n\t\t\tcin>>mx>>my>>Mx>>My>>h;\n\t\t\tP a(mx,my),b(Mx,my),c(Mx,My),d(mx,My);\n\t\t\tif(mx<=min(sx,ex)&&Mx>=max(sx,ex)&&my<=min(sy,ey)&&My>=max(sy,ey))ans=0;\n\t\t\tif(insected(s,e,a,b)||insected(s,e,b,c)||insected(s,e,c,d)||insected(s,e,d,a))ans=0;\n\t\t\telse{\n\t\t\t\tdouble D;\n\t\t\t\tif(Mx<=min(sx,ex))D=min(sx,ex)-Mx;\n\t\t\t\telse if(mx>=max(sx,ex))D=mx-max(sx,ex);\n\t\t\t\telse if(My<=min(sy,ey))D=min(sy,ey)-My;\n\t\t\t\telse if(my>=max(sy,ey))D=my-max(sy,ey);\n\t\t\t\telse D=min(dist(s,e,a),min(dist(s,e,b),min(dist(s,e,c),dist(s,e,d))));\n\t\t\t\tif(h>D)ans=min(ans,D);\n\t\t\t\telse ans=min(ans,(D*D+h*h)/2/h);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p1;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(eq(crossProduct(b,c),0.0)) for(;;);\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n//\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tint x=ccw(s.p1,s.p2,pr);\n//\tif(x>=-1&&x<=1) return d;\n\tif(x==0) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t\tbool flg1=(abs(oneLineCCW(q[0],q[1],r))<=1);\n\t\tbool flg2=ccw(q[0],q[1],r)==0;\n\t\tif(flg1!=flg2) assert(0);\n\t//\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\tif(ccw(q[0],q[1],r)==0){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t\tflg1=abs(oneLineCCW(p[0],p[1],r)<=1);\n\t\tflg2=ccw(p[0],p[1],r);\n\t\tif(flg1!=flg2) assert(0);\n\t//\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\tif(ccw(p[0],p[1],r)==0){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tif(eq(abs(s-t),0.0)) for(;;);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tif(eq(abs(e.p1-e.p2),0.0)) for(;;);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-9;\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\nint main(){\n  while(true){\n    int n;\n    cin>>n;\n    if(!n)break;\n    double r,r_min = 1000;\n    double sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    P s=P(sx,sy),e=P(ex,ey);\n    for(int i=0;i<n;i++){\n      double x1,y1,x2,y2,h;\n      cin>>x1>>y1>>x2>>y2>>h;\n      P p[4]={ P(x1,y1),P(x2,y1),P(x2,y2),P(x1,y2)};\n      if(is_intersected_ls(s,e,p[0],p[1])\n\t ||is_intersected_ls(s,e,p[1],p[2])\n\t ||is_intersected_ls(s,e,p[2],p[3])\n\t ||is_intersected_ls(s,e,p[3],p[0])\n\t ||(x1<sx&&y1<sy&&ex<x2&&ey<y2)){\n\tr_min = 0;\n      }\n      if(r_min-EPS>0){\n\tdouble l=1000;\n\tfor(int j=0;j<4;j++){\n\t  l = min(l,distance_ls_p(s,e,p[j]));\n\t  l = min(l,distance_ls_p(p[j],p[(j+1)%4],s));\n\t  l = min(l,distance_ls_p(p[j],p[(j+1)%4],e));\n\t}\n\tr = h>l?l:(h*h+l*l)/(2*h);\n\tif(r<r_min)r_min = r;\n      }\n    }\n    cout<<r_min<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p1;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n//\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tint x=ccw(s.p1,s.p2,pr);\n//\tif(x>=-1&&x<=1) return d;\n\tif(x==0) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t\tbool flg1=(abs(oneLineCCW(q[0],q[1],r))<=1);\n\t\tbool flg2=ccw(q[0],q[1],r)==0;\n\t\tif(flg1!=flg2) assert(0);\n\t//\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\tif(ccw(q[0],q[1],r)==0){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t\tflg1=abs(oneLineCCW(p[0],p[1],r)<=1);\n\t\tflg2=ccw(p[0],p[1],r);\n\t\tif(flg1!=flg2) assert(0);\n\t//\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\tif(ccw(p[0],p[1],r)==0){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stdlib.h>\n#include <string.h>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble EPS = 1e-8;\n\ntypedef struct {\n\tP s,e;\n\tdouble h;\n}RECT;\n\nvoid P_cin(P& p){\n\tdouble x,y;\n\tcin >>x >> y;\n\tp.real(x); p.imag(y);\n}\ndouble dot(P& a,P& b){ return a.real() * b.real() + a.imag() * b.imag(); }\ndouble cross(P& a,P& b){ return a.real() * b.imag() - a.imag() * b.real(); } \n\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\ndouble distance_lp(P& s,P& e,P &p){\n\tif(dot(e-s,p-s) < EPS) return abs(p-s); //_sÆÌ£\n\tif(dot(s-e,p-e) < EPS) return abs(p-e); //_eÆÌ£\n\treturn abs(cross(e-s,p-s)) / abs(e-s); //_Æ¼üÆÌ£\n}\n\nbool is_contained(P& a,P& b,P& p){\n\treturn (a.real() <= p.real() && p.real() <= b.real()) &&\n\t\t(a.imag() <= p.imag() && p.imag() <= b.imag());\n}\n\ndouble distance_rl(P& a,P& b,P& s,P& e){\n\tif(is_contained(a,b,s) || is_contained(a,b,e))\n\t\treturn 0.0; //R[X©Ìª ÉüÁÄé\n\n\tdouble len = 1e10;\n\tP rectP[] = {a,P(a.real(),b.imag()),b,P(b.real(),a.imag())};\n\tfor(int i = 0; i < 4; i++){\n\t\tif(is_intersected_ls(rectP[i],rectP[(i+1)%4],s,e)) return 0.0; //ð·µÄ¢é\n\t\tlen = min(len,distance_lp(rectP[i],rectP[(i+1)%4],s));\n\t\tlen = min(len,distance_lp(rectP[i],rectP[(i+1)%4],e));\n\t\tlen = min(len,distance_lp(e,s,rectP[i]));\n\t}\n\n\treturn len;\n}\n\ndouble distance(RECT &r,P& s,P& e){\n\tdouble len = distance_rl(r.s,r.e,s,e);\n\tif(len <= r.h) return len; //cÉ¢\n\treturn (r.h + len * len / r.h) / 2; //cÌûªá¢ÌÅvZ·é\n}\n\nint N;\n\nvoid solve(){\n\n\tP s,e;\n\tP_cin(s);\n\tP_cin(e);\n\n\tvector<RECT> rects(N);\n\tfor(int i = 0; i < N; i++){\n\t\tRECT &r = rects[i];\n\t\tP_cin(r.s);\n\t\tP_cin(r.e);\n\t\tcin >> r.h;\n\t}\n\t\n\tdouble ans = 1e10;\n\tfor(int i = 0; i < N; i++){\n\t\tans = min(ans,distance(rects[i],s,e));\n\t}\n\n\tcout << ans << endl;\n}\n\nint main()\n{\n\twhile(cin >> N,N){\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\ntypedef complex<ld> Point;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine () : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle () : p(Point(0, 0)), r(0) {}\n\tCircle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll (Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps){\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d,\tc.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0,\t1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j,n) res += cross(p[j], p[(j+1)%n]);\n\treturn res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i,n) {\n\t\tPoint a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i,n) {\n\t\tPoint a = poly[i], b = poly[(i+1)%n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i,n) {\n\t\tPoint A = ps[i], B = ps[(i+1)%n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i,m) {\n\t\tvector<pair<ld,int>> vec;\n\t\tREP(j,n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j,vec.size()-1) {\n\t\t\tint from = vec[j].second, to = vec[j+1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i,m) {\n\t\tvector<pair<ld,int>> vec;\n\t\tREP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j,vec.size()-1) {\n\t\t\tint from = vec[j].second, to = vec[j+1].second;\n\t\t\tld angle = vec[j+1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i,1024) REP(j,1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld,int,bool>>> tup(N);\n\tREP(i,s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i,N) sort(ALL(tup[i]));\n\tREP(i,N) {\n\t\tREP(j,tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i,N) REP(j,i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back((Edge){from, to});\n\t\t\tg[to].push_back((Edge){to, from});\n\t\t}\n\t}\n\treturn g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tld sx, sy, ex, ey; cin >> sx >> sy >> ex >> ey;\n\t\tLine l0(Point(sx, sy), Point(ex, ey));\n\t\tld ans = linf;\n\t\tREP(i, N) {\n\t\t\tld x1, y1, x2, y2, h; cin >> x1 >> y1 >> x2 >> y2 >> h;\n\t\t\tPolygon pol = {Point(x1, y1), Point(x1, y2), Point(x2, y2), Point(x2, y1)};\n\t\t\tld r = linf;\n\t\t\tif ( is_in_polygon(pol, l0.a) || is_in_polygon(pol,l0.b) ) {\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tREP(j, pol.size()) {\n\t\t\t\t\tLine l(pol[j], pol[(j+1)%pol.size()]);\n\t\t\t\t\tr = min(r, dist_ss(l0, l));\n//\t\t\t\t\tdebug(dist_ss(l0, l));\n\t\t\t\t}\n//\t\t\t\tdebug(r);\n//\t\t\t\tdebug(h);\n\t\t\t}\n\t\t\tld R = r <= h+eps ? r : (r*r + h*h)/(2*h);\n\t\t\tans = min(ans, R);\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-10;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 点座標のデバッグ出力\nvoid print(P p) {\n\tcout << \"point\" << p << \";\" << endl;\n}\n\n// * 2乗する\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ベクトルaの単位ベクトルを求める\nP unit(P a) {\n\treturn a / abs(a);\n}\n\n// ベクトルaの法線ベクトルを求める\nvector<P> normal(P a) {\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a) {\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// 原点を軸に点 p を角度 a (ラジアン)だけ回転させた点を返す\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// 点 a を軸に点 b を角度 a (ラジアン)だけ回転させた点を返す\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n\tb-=a, c-=a;\n\tdouble rotdir = cross(b,c);\n\tif( rotdir >  EPS ) return CCW;\n\tif( rotdir < -EPS ) return CW;\n\treturn ON;\n}\n\n\n// 線分の表現\nstruct Segment{\n\t// 点 a, b を端点とする線分\n\tP a, b;\n\t// コンストラクタで初期化\n\tSegment(P a_, P b_) {\n\t\t// x 座標の小さいほうの点を 点 a とする. (不要なときはこの1行を削除すること!!!)\n\t\tif( b_ < a_ ) swap(a_,b_);\n\t\ta = a_; b = b_;\n\t}\n\t// 線分の長さを返す\n\tdouble length() { return abs(a-b); }\n\t// 中点を返す\n\tP mid() { return P( (a.X+b.X)/2.0 , (a.Y+b.Y)/2.0 ); }\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と点 p の距離\n\tdouble distance(P p) {\n\t\tif( dot(b-a, p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b, p-b) < EPS ) return abs(p-b);\n\t\treturn abs(cross(b-a, p-a)) / abs(b-a);\n\t}\n\t// 線分の交差判定\n\tbool is_intersection(const Segment& s) {\n\t\treturn ( cross(b-a, s.a-a) * cross(b-a, s.b-a) < EPS ) &&\n\t\t\t   ( cross(s.b-s.a, a-s.a) * cross(s.b-s.a, b-s.a) < EPS );\n\t}\n\t// 線分の交差判定と交点計算\n\tbool intersection(Segment s, P& p) {\n\t\tbool result = is_intersection( s );\n\t\tif( result ) {\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) ) {\n\t\t\t\t\tp = s.a;\n\t\t\t\t}else if( this->contain(s.b) ) {\n\t\t\t\t\tp = s.b;\n\t\t\t\t}else if( s.contain( a ) ) {\n\t\t\t\t\tp = a;\n\t\t\t\t}else if( s.contain( b ) ) {\n\t\t\t\t\tp = b;\n\t\t\t\t}else {\n\t\t\t\t\tp = INF_P;\n\t\t\t\t}\n\t\t\t}else if( abs(d1) < EPS ) {\n\t\t\t\tp = INF_P;\n\t\t\t}else {\n\t\t\t\tdouble t = d1 / (d1 + d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t}\n\t\t}else{\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// 線分と線分の距離\n\tdouble distance(Segment s) {\n\t\tif( this->is_intersection( s ) ) { // 交差するとき\t\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) || this->contain(s.b) ) {\n\t\t\t\t\treturn 0.0;\n\t\t\t\t}else if( s.contain( a ) || s.contain( b ) ) {\n\t\t\t\t\treturn 0.0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t}\n\t\tdouble A = this->distance(s.a);\n\t\tdouble B = this->distance(s.b);\n\t\tdouble C = s.distance( (*this).a );\n\t\tdouble D = s.distance( (*this).b );\n\t\treturn min( min(A,B) , min(C,D) );\n\t}\n\t// デバッグ出力\n\tvoid print() { printf(\"line(%f,%f,%f,%f); \\n\", a.X, a.Y, b.X, b.Y ); }\n};\n// Segment の順序を定義 (x座標の小さい端点で比較)\nbool operator < (const Segment& s1, const Segment& s2) { return s1.a < s2.a; }\n\n// 直線の表現 ((*this)[0]) と ((*this)[1]) を通る直線\nstruct Line : public vector<P> {\n\tLine(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tLine(vector<P> v){\n\t\tpush_back(v[0]); push_back(v[1]);\n\t}\n\tLine(){}\n\t// 2直線の直交判定\n\tbool orthogonal(const Line& l) {\n\t\treturn equal( dot( (*this)[0] - (*this)[1] , l[0] - l[1] ) , 0.0 );\n\t}\n\t// 2直線の平行判定\n\tbool parallel(const Line& l) {\n\t\treturn equal( cross( (*this)[0] - (*this)[1] , l[0] - l[1] ), 0.0 );\n\t}\n\t// 点 p が直線上に乗っているか\n\tbool contain(P p) {\n\t\treturn equal( cross( (*this)[1] - (*this)[0] , p - (*this)[0] ) , 0.0 );\n\t}\n\t// 直線と点 p の距離\n\tdouble distance(P a) {\n\t\tP p1 = (*this)[0];\n\t\tP p2 = (*this)[1];\n\t\treturn abs( cross( p2 - p1 , a - p1) ) / abs(p2 - p1);\n\t}\n\t// 点 (*this)[0] から 点 (*this)[1] への角度を返す [0,2π]\n\tdouble get_dir() {\n\t\tP p = (*this)[0] - (*this)[1];\n\t\tdouble angle = atan2( p.Y , p.X );\n\t\tif( p.X < 0 ) angle += PI;\n\t\tif( angle < 0 ) angle += 2.0 * PI;\n\t\treturn angle;\n\t}\n\t// 直線の交差判定\n\tbool is_intersection(const Line& l) {\n\t\treturn !equal( cross( (*this)[0] - (*this)[1], l[0] - l[1] ) , 0.0 );\n\t}\n\t// 直線の交差判定と交点計算\n\tbool intersection(Line l, P& p) {\n\t\tbool result = this->is_intersection( l );\n\t\tif( result ) {\n\t\t\tP a = (*this)[1] - (*this)[0];\n\t\t\tP b = l[1] - l[0];\n\t\t\tp = (*this)[0] + a * cross(b, l[0] - (*this)[0]) / cross(b, a);\n\t\t}else {\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t// デバッグ出力\n\tvoid print() {\n\t\tP p1 = (*this)[0];\n\t\tP p2 = (*this)[1];\n\t\tdouble dx = p1.X - p2.X;\n\t\tdouble dy = p1.Y - p2.Y;\n\t\t::print( p1 );\n\t\t::print( p2 );\n\t\tp1.X += 100 * dx;\n\t\tp1.Y += 100 * dy;\n\t\tp2.X -= 100 * dx;\n\t\tp2.Y -= 100 * dy;\n\t\tSegment s( p1 , p2 );\n\t\ts.print();\n\t}\n};\n\n// 円の表現\nstruct Circle{\n\t// 円の中心\n\tP p;\n\t// 円の半径\n\tdouble r;\n\t// コンストラクタで初期化\n\tCircle(P p_, double r_) { p = p_; r = r_; }\n\t// 円の面積\n\tdouble get_area() { return r * r * PI; }\n\t// 円周\n\tdouble circumference() { return 2.0 * r * PI; }\n\t// 点 a が円の内部にあるかどうか\n\tbool is_inside(P a) { return ( dist(a,p) <= r ); }\n\t// 点 a が円周上にあるかどうか\n\tbool on_boundary(P a) { return equal( dist(a,p) , r ); }\n\t\n\t// 直線と円の距離 (円の中心の点と直線の距離 - 円の半径)\n\tdouble distance(Line l){\n\t\treturn l.distance( p ) - r;\n\t}\n\t// 等しいかどうか\n\tbool operator==(const Circle& c) { return (p == c.p && r == c.r) ; };\n\t// 2つの円の位置関係\n\t// 2 つの円が離れている => 0\n\t// 2 つの円が外接する   => 1\n\t// 2 つの円が交わる     => 2\n\t// 2 つの円が内接する    => 3 (2つの円が等しいときは内接)\n\t// 円が含まれている       => 4\n\tint is_pos(const Circle& c) {\n\t\tdouble d = abs(p - c.p);\n\t\tif( r + c.r + EPS < d ) { // 離れている\n\t\t\treturn 0;\n\t\t}else if( equal( r + c.r , d ) ) { // 外接する\n\t\t\treturn 1;\n\t\t}else if( equal( fabs(r-c.r) , d ) ) { // 内接する\n\t\t\treturn 3;\n\t\t}else if( d < fabs(r-c.r) ) { // 含まれる\n\t\t\treturn 4;\n\t\t}else { // 交わる\t\n\t\t\treturn 2;\n\t\t}\n\t}\n\t// 円と直線の交わる点を返す\n\tpair<P,P> intersection(Line l) {\n\t\tpair<P,P> pp;\n\t\tif( this->distance(l) > EPS ) { // 円と直線の交点がないとき\t\n\t\t\tpp.first = pp.second = INF_P;\n\t\t}else { // 円と直線の交点があるとき\n\t\t\tdouble d = l.distance( p );\n\t\t\tdouble angle = -l.get_dir();\n\t\t\t// 点 l[0] を軸に点 l[1] と円の中心を回転\n\t\t\tP lp = rot2( l[0] , l[1] , angle );\n\t\t\tP cp = rot2( l[0] , p    , angle );\n\t\t\tdouble x1 = cp.X - sqrt( sq(r) - sq(d) );\n\t\t\tdouble x2 = cp.X + sqrt( sq(r) - sq(d) );\n\t\t\tP p1(x1,l[0].Y);\n\t\t\tP p2(x2,l[0].Y);\n\t\t\t// 回転して元に戻す\n\t\t\tp1 = rot2( l[0] , p1 , -angle );\n\t\t\tp2 = rot2( l[0] , p2 , -angle );\n\t\t\tpp.first = p1;\n\t\t\tpp.second = p2;\n\t\t}\n\t\treturn pp;\n\t}\n\t// デバッグ出力\n\tvoid print() { printf(\"circle(%f,%f,%f); \\n\", p.X, p.Y, r ); }\n};\n\nstruct Rect{\n\tint x1, y1, x2, y2, h;\n\tRect(int x1_, int y1_, int x2_, int y2_, int h_){\n\t\tx1 = x1_; y1 = y1_; x2 = x2_; y2 = y2_; h = h_;\n\t};\n};\n\nint main(){\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint sx, sy, ex, ey;\n\t\tdouble ans = 0;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tSegment s( P(sx,sy) , P(ex,ey) );\n\t\t\n\t\tvector<Rect> v;\n\t\tvector<Segment> vs;\n\t\tbool NA_flag = false;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint min_x, min_y, max_x, max_y, h;\n\t\t\tcin >> min_x >> min_y >> max_x >> max_y >> h;\n\t\t\t\n\t\t\t// p1, p2, p3, p4 は i 番目の長方形の座標を表す.\n\t\t\tP p1(min_x,min_y), p2(min_x,max_y), p3(max_x,min_y), p4(max_x,max_y);\n\t\t\t// s1, s2, s3, s4 は i 番目の長方形の辺(=線分)を表す.\n\t\t\tSegment s1(p1,p2), s2(p1,p3), s3(p2,p4), s4(p3,p4);\n\t\t\t// スタートからゴールまでの線分と交差する長方形があるかどうか調べる\n\t\t\tif( s.is_intersection(s1) || s.is_intersection(s2) ){\n\t\t\t\tNA_flag = true;\n\t\t\t}else if( s.is_intersection(s1) || s.is_intersection(s2) ){\n\t\t\t\tNA_flag = true;\n\t\t\t}else if( min_x <= sx && sx <= max_x && min_y <= sy && sy <= max_y ){\n\t\t\t\tNA_flag = true;\n\t\t\t}else if( min_x <= ex && ex <= max_x && min_y <= ey && ey <= max_y ){\n\t\t\t\tNA_flag = true;\n\t\t\t}\n\t\t\t\n\t\t\t// d は 長方形と線分 s との距離\n\t\t\tdouble d = min( s.distance(p1) , s.distance(p2) );\n\t\t\td = min( d , min( s.distance(p3) , s.distance(p4) ) );\n\t\t\t// 真横からみた座標に 辺の追加\n\t\t\tvs.push_back( Segment( P(d,0) , P(d,h) ) );\n\t\t\t\n\t\t\tv.push_back( Rect( min_x, min_y, max_x, max_y, h ) );\n\t\t}\n\t\tif( NA_flag ){\n\t\t\tcout << 0 << endl;\n\t\t}else{\n\t\t\tdouble low=0.0, high=1000.0,mid=500.0;\n\t\t\t// 適当に二分探索\n\t\t\tfor(int i=0 ; i < 100 ; i++ ){\n\t\t\t\tmid = (low+high) / 2.0;\n\t\t\t\tCircle c( P(0,mid) , mid );\n\t\t\t\tbool flag = false;\n\t\t\t\tfor(int i=0 ; i < vs.size() ; i++ ){\n\t\t\t\t\tLine l( vs[i].a , vs[i].b );\n\t\t\t\t\tpair<P,P> pp = c.intersection( l );\n\t\t\t\t\t\n\t\t\t\t\tif( pp.first == INF_P || pp.first == pp.second ){ // 交差しない\n\t\t\t\t\t}else{\n\t\t\t\t\t\tP p1 = pp.first;\n\t\t\t\t\t\tP p2 = pp.second;\n\t\t\t\t\t\t// 円と線分が交差するとき\n\t\t\t\t\t\tif( vs[i].contain(p1) || vs[i].contain(p2) ){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( flag ){ // 交差するとき\n\t\t\t\t\thigh = mid;\n\t\t\t\t}else{ // 交差しないとき\n\t\t\t\t\tlow = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = mid;\n\t\t\t// cout << ans << endl;\n\t\t\tprintf(\"%.6f\\n\", ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct point { double x, y; };\nstruct line { point p, q; };\nstruct rect { point p[4]; line l[4]; };\n\nint N;\ndouble LX[50], LY[50], RX[50], RY[50], H[50];\npoint S, E;\nline c;\nrect o[50];\ndouble d[50];\n\nbool intersect(line l1, line l2) {\n  double ax = l1.p.x, ay = l1.p.y;\n  double bx = l1.q.x, by = l1.q.y;\n  double cx = l2.p.x, cy = l2.p.y;\n  double dx = l2.q.x, dy = l2.q.y;\n  double ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n  double tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n  double tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n  double td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n  return tc * td < 0 && ta * tb < 0;\n}\n\ndouble distance(line l, point p) {\n  double x0 = p.x, y0 = p.y;\n  double x1 = l.p.x, y1 = l.p.y;\n  double x2 = l.q.x, y2 = l.q.y;\n  double a = x2 - x1;\n  double b = y2 - y1;\n  double a2 = a * a;\n  double b2 = b * b;\n  double r2 = a2 + b2;\n  double tt = -(a*(x1 - x0) + b*(y1 - y0));\n  if(tt < 0) return sqrt((x1 - x0)*(x1-x0) + (y1 - y0)*(y1-y0));\n  if(tt > r2) return sqrt((x2 - x0)*(x2 - x0) + (y2 - y0)*(y2 - y0));\n  double f1 = a*(y1 - y0) - b*(x1 - x0);\n  return sqrt((f1*f1)/r2);\n}\n\nbool check(double r) {\n  REP(i, 0, N) if(d[i] < sqrt(pow(r, 2) - pow(r - min(r, (double) H[i]), 2))) return false;\n  return true;\n}\n\ndouble solve() {\n  REP(i, 0, N) REP(j, 0, 4) {\n    if(intersect(c, o[i].l[j])) return 0;\n    if(LX[i] <= S.x && S.x <= RX[i] && LY[i] <= S.y && S.y <= RY[i]) return 0;\n    if(LX[i] <= E.x && E.x <= RX[i] && LY[i] <= E.y && E.y <= RY[i]) return 0;\n  }\n\n  REP(i, 0, N) {\n    d[i] = 1e10;\n    REP(j, 0, 4) {\n      d[i] = min(d[i], distance(c, o[i].p[j]));\n      d[i] = min(d[i], distance(o[i].l[j], S));\n      d[i] = min(d[i], distance(o[i].l[j], E));\n    }\n  }\n\n  double low = 0, high = 1005;\n  REP(i, 0, 100) {\n    double mid = (low + high) * 0.5;\n    if(check(mid)) low = mid;\n    else high = mid;\n  }\n  return low;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    cin >> S.x >> S.y >> E.x >> E.y;\n    c = (line) { S, E };\n\n    REP(i, 0, N) {\n      cin >> LX[i] >> LY[i] >> RX[i] >> RY[i] >> H[i];\n      o[i].p[0] = (point) { LX[i], LY[i] };\n      o[i].p[1] = (point) { LX[i], RY[i] };\n      o[i].p[2] = (point) { RX[i], RY[i] };\n      o[i].p[3] = (point) { RX[i], LY[i] };\n      o[i].l[0] = (line) { o[i].p[0], o[i].p[1] };\n      o[i].l[1] = (line) { o[i].p[1], o[i].p[2] };\n      o[i].l[2] = (line) { o[i].p[2], o[i].p[3] };\n      o[i].l[3] = (line) { o[i].p[3], o[i].p[0] };\n    }\n\n    printf(\"%.8lf\\n\", solve());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\nconst double EPS = 1e-9;\n\nstruct Point {\n\tdouble x, y;\n\tPoint() : x(0), y(0) { }\n\tPoint(double x, double y) : x(x), y(y) { }\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double s) const { return Point(x * s, y * s); }\n\tPoint operator/(double s) const { return Point(x / s, y / s); }\n\tPoint &operator+=(const Point &p){ x += p.x; y += p.y; return *this; }\n\tPoint &operator-=(const Point &p){ x -= p.x; y -= p.y; return *this; }\n\tPoint &operator*=(double s){ x *= s; y *= s; return *this; }\n\tPoint &operator/=(double s){ x /= s; y /= s; return *this; }\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n\tbool operator!=(const Point &p) const { return x != p.x || y != p.y; }\n\tbool operator<(const Point &p) const {\n\t\treturn (x == p.x) ? (y < p.y) : (x < p.x);\n\t}\n};\ninline Point operator*(double s, const Point &p){ return p * s; }\n\ninline double norm(const Point &p){ return p.x * p.x + p.y * p.y; }\ninline double abs(const Point &p){ return sqrt(norm(p)); }\ninline double cross(const Point &a, const Point &b){\n\treturn a.x * b.y - a.y * b.x;\n}\ninline double dot(const Point &a, const Point &b){\n\treturn a.x * b.x + a.y * b.y;\n}\ninline int ccw(const Point &a, const Point &b, const Point &c){\n\tconst Point d = b - a, e = c - a;\n\tif(cross(d, e) > 0.0){ return 1; }\n\tif(cross(d, e) < 0.0){ return -1; }\n\tif(dot(d, e) < 0.0){ return 2; }\n\tif(abs(d) < abs(e)){ return -2; }\n\treturn 0;\n}\n\nstruct Line {\n\tPoint a, b;\n\tLine() : a(), b() { }\n\tLine(const Point &a, const Point &b) : a(a), b(b) { }\n\tbool operator==(const Line &l) const { return a == l.a && b == l.b; }\n\tbool operator!=(const Line &l) const { return a != l.a || b != l.b; }\n\tbool operator<(const Line &l) const {\n\t\treturn (a == l.a) ? (b < l.b) : (a < l.a);\n\t}\n};\n\ninline Point projection(const Line &l, const Point &p){\n\tdouble t = dot(p - l.a, l.b - l.a) / norm(l.b - l.a);\n\treturn l.a + t * (l.b - l.a);\n}\n\nstruct Segment : public Line {\n\tSegment() : Line() { }\n\tSegment(const Point &a, const Point &b) : Line(a, b) { }\n};\n\ninline bool intersect(const Segment &s, const Point &p){\n\treturn abs(s.a - p) + abs(s.b - p) < abs(s.a - s.b) + EPS;\n}\ninline bool intersect(const Segment &a, const Segment &b){\n\tif(ccw(a.a, a.b, b.a) * ccw(a.a, a.b, b.b) > 0){ return false; }\n\tif(ccw(b.a, b.b, a.a) * ccw(b.a, b.b, a.b) > 0){ return false; }\n\treturn true;\n}\ninline double dist(const Segment &s, const Point &p){\n\tconst Point r = projection(s, p);\n\tif(intersect(s, r)){ return abs(r - p); }\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\ninline double dist(const Segment &a, const Segment &b){\n\tif(intersect(a, b)){ return 0; }\n\tconst double x = min(dist(b, a.a), dist(b, a.b));\n\tconst double y = min(dist(a, b.a), dist(a, b.b));\n\treturn min(x, y);\n}\n\ninline bool between(double a, double b, double c){\n\treturn a <= b && b <= c;\n}\n\nstruct Block {\n\tdouble x0, y0, x1, y1, h;\n};\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcout << setprecision(10) << setiosflags(ios::fixed);\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tSegment path;\n\t\tcin >> path.a.x >> path.a.y >> path.b.x >> path.b.y;\n\t\tconst double sx = path.a.x, sy = path.a.y;\n\t\tvector<Block> blocks(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tBlock &b = blocks[i];\n\t\t\tcin >> b.x0 >> b.y0 >> b.x1 >> b.y1 >> b.h;\n\t\t}\n\t\tdouble left = 0.0, right = 1000.0;\n\t\tfor(int iter = 0; iter < 100; ++iter){\n\t\t\tconst double center = (left + right) * 0.5;\n\t\t\tbool accept = true;\n\t\t\tfor(int i = 0; accept && i < n; ++i){\n\t\t\t\tconst Block &b = blocks[i];\n\t\t\t\tif(between(b.x0, sx, b.x1) && between(b.y0, sy, b.y1)){\n\t\t\t\t\taccept = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst double r = center, h = b.h;\n\t\t\t\tconst double limit = (r > h) ? sqrt(2 * r * h - h * h) : r;\n\t\t\t\tconst Point p0(b.x0, b.y0);\n\t\t\t\tconst Point p1(b.x1, b.y0);\n\t\t\t\tconst Point p2(b.x1, b.y1);\n\t\t\t\tconst Point p3(b.x0, b.y1);\n\t\t\t\tif(dist(path, Segment(p0, p1)) < limit){ accept = false; }\n\t\t\t\tif(dist(path, Segment(p1, p2)) < limit){ accept = false; }\n\t\t\t\tif(dist(path, Segment(p2, p3)) < limit){ accept = false; }\n\t\t\t\tif(dist(path, Segment(p3, p0)) < limit){ accept = false; }\n\t\t\t}\n\t\t\tif(accept){\n\t\t\t\tleft = center;\n\t\t\t}else{\n\t\t\t\tright = center;\n\t\t\t}\n\t\t}\n\t\tcout << left << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n\n#define th (*this)\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> C;\n\nconst D INF = 1e100;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ntemplate<class T> bool eq(T a, T b) {return abs(a - b) < EPS;}\n\nstruct P {\n  complex<D> comp;\n  P(C c) : comp(c) {}\n  P(D x , D y) : comp(x,y) {}\n  \n  D & x(){ return comp.real(); }\n  D & y(){ return comp.imag(); }\n\n  P operator+(P r) { return P(th.comp + r.comp); }\n  P operator-(P r) { return P(th.comp - r.comp); }\n  D operator*(P r) { return abs(comp)*abs(r.comp)/arg(comp/r.comp); }\n  D operator/(P r) { return (comp*r.comp).imag(); } // 外積\n    \n  P & operator+=(P r) { return th = th + r; }\n  P & operator-=(P r) { return th = th - r; }\n  P & operator*=(D r) { return th = P(th.comp*r); }\n  P & operator/=(D r) { return th = P(th.comp/r); }\n\n  P operator+() { return th; }\n  P operator-() { return P(-comp); }\n  D operator!() { return abs(comp); }\n  D operator~() { return norm(comp); }\n\nprivate:\n  P & operator*=(P r);\n  P & operator/=(P r);\n};\n\nP operator*(P p , D k){ p.comp*=k; return p; }\nP operator*(D k , P p){ p.comp*=k; return p; }\nP operator/(P p , D k){ p.comp/=k; return p; }\n\nint main(){\n  P a(2,3);\n  a += P(3,1);\n  cout << a.comp << endl;\n\n  P b(1,1);\n  cout << b.comp << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n#define M INT_MAX\nstruct P{\n  double x;\n  double y;\n\n  P(){\n\tx=M; y=M;\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n\n};\ndouble dot(P a,P b){\n  return (a.x*b.x+a.y*b.y);\n}\n\ndouble cross(P a,P b){\n  return (a.x*b.y-a.y*b.x);\n}\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\ndouble psd(P p , P a , P b){\n  if( dot( b-a , p-a ) < EPS) return fabs(dis(p-a));\n  if( dot( a-b , p-b ) < EPS) return fabs(dis(p-b));\n  return fabs(cross( b-a , p-a )) / fabs(dis(b-a));\n}\n\nbool intersect_s(P a1 , P a2 , P b1 , P b2){\n  return ( cross(a2-a1 , b1-a1)*cross(a2-a1 , b2-a1) < EPS) &&\n\t( cross(b2-b1 , a1-b1)*cross(b2-b1 , a2-b1) < EPS);\n}\n\ndouble dist_s(P p1, P p2, P q1, P q2){\n  if(intersect_s(p1,p2,q1,q2)) return 0;\n  return min(min(psd(p1, q1, q2), psd(p2, q1, q2)),\n\t\t\t min(psd(q1, p1, p2), psd(q2, p1, p2)));\n}\n\nbool isin(P p, P a1, P a2){\n  double mx = min(a1.x, a2.x), Mx = max(a1.x, a2.x);\n  double my = min(a1.y, a2.y), My = max(a1.y, a2.y);\n  return mx < p.x && p.x < Mx\n\t&& my < p.y  && p.y < My;\n}\n\nint main(){\n  int N;\n  while(cin>>N,N){\n\tP s, e;\n\tvector< vector<P> > ps(N, vector<P>(4));\n\tvector<double> h(N), d(N, 1e+10);\n\tcin >> s.x >> s.y >> e.x >> e.y;\n\tREP(i,N){\n\t  cin >> ps[i][0].x >> ps[i][0].y >> ps[i][2].x >> ps[i][2].y >> h[i];\n\t  ps[i][1].x = ps[i][0].x;\n\t  ps[i][1].y = ps[i][2].y;\n\n\t  ps[i][3].x = ps[i][2].x;\n\t  ps[i][3].y = ps[i][0].y;\n\t}\n\n\tbool ng = false;\n\tREP(i,N){\n\t  if(isin(s, ps[i][0], ps[i][2]) || isin(e, ps[i][0], ps[i][2]))\n\t\tng = true;\n\t  REP(j,4)\n\t\tif(intersect_s(s,e,ps[i][j],ps[i][(j+1)%4]))\n\t\t   ng = true;\n\t}\n\tif(ng){\n\t  cout << 0 << endl;\n\t  continue;\n\t}\n\n\tREP(i,N) REP(j,4){\n\t  d[i] = min(d[i], dist_s(s, e, ps[i][j], ps[i][(j+1)%4]));\n\t}\n\n\tdouble r_lb = 0., r_ub = 1100.;\n\n\tREP(i,100){\n\t  bool flag = true;\n\t  double r = (r_lb + r_ub) / 2.;\n\t  REP(j,N){\n\t\tif((h[j] >= r && d[j] < r) || h[j]*h[j] + d[j]*d[j] < 2*r*h[j]){\n\t\t  flag = false;\n\t\t  break;\n\t\t}\n\t  }\n\n\t  if(flag) r_lb = r;\n\t  else r_ub = r;\n\t}\n\n\tcout << fixed << setprecision(6) << r_lb << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <complex>\n#include <vector>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n\nconst double EPS=1e-6;\nconst double INFTY=1e20;\n\ntypedef complex<double> Point;\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n};\n\ndouble Signum(double x)\n{\n\treturn abs(x)<EPS?0:x>0?1:-1;\n}\ndouble Comp(double a,double b)\n{\n\treturn Signum(a-b);\n}\ndouble Dot(Point a,Point b)\n{\n\treturn real(conj(a)*b);\n}\ndouble Cross(Point a,Point b)\n{\n\treturn imag(conj(a)*b);\n}\nPoint Proj(Point a,Point b)\n{\n\treturn Dot(a,b)/norm(b)*b;\n}\nPoint Perp(Point a,Point b)\n{\n\treturn Proj(a,b)-a;\n}\nint CCW(Point a,Point b,Point c)\n{\n\tPoint d1=b-a,d2=c-a;\n\tdouble sign=Signum(Cross(d1,d2));\n\tif(sign)\n\t\treturn sign;\n\tif(Comp(Dot(d1,d2),0)<0)\n\t\treturn -2; // c-a-b\n\tif(Comp(norm(d1),norm(d2))<0)\n\t\treturn 2;  // a-b-c\n\treturn 0;      // a-c-b\n}\nbool IntersectLS(Line l,Line s)\n{\n\tPoint a=l.pos;\n\tPoint b=l.pos+l.dir;\n\tPoint c=s.pos;\n\tPoint d=s.pos+s.dir;\n\treturn CCW(a,b,c)*CCW(a,b,d)<0;\n}\nbool IntersectSS(Line s1,Line s2)\n{\n\treturn IntersectLS(s1,s2) && IntersectLS(s2,s1);\n}\ndouble DistLP(Line l,Point p)\n{\n\treturn abs(Perp(p-l.pos,l.dir));\n}\ndouble DistSP(Line s,Point p)\n{\n\tPoint a=s.pos+Proj(p-s.pos,s.dir);\n\tint ccw=CCW(s.pos,s.pos+s.dir,a);\n\tif(ccw==-2)\n\t\treturn abs(p-s.pos);\n\tif(ccw==2)\n\t\treturn abs(p-(s.pos+s.dir));\n\treturn DistLP(s,p);\n}\ndouble DistSS(Line s1,Line s2)\n{\n\tif(IntersectSS(s1,s2))\n\t\treturn 0;\n\tdouble a=DistSP(s1,s2.pos);\n\tdouble b=DistSP(s1,s2.pos+s2.dir);\n\tdouble c=DistSP(s2,s1.pos);\n\tdouble d=DistSP(s2,s1.pos+s1.dir);\n\treturn min(min(a,b),min(c,d));\n}\nbool IsCover(Line l,int sx,int sy,int ex,int ey)\n{\n\tPoint a=l.pos,b=l.pos+l.dir;\n\tPoint p[4]={Point(sx,sy),Point(ex,sy),Point(ex,ey),Point(sx,ey)};\n\tint c1=CCW(p[3],p[0],a),c2=CCW(p[3],p[0],b);\n\tfor(int i=1;i<4;i++)\n\t\tif(c1*CCW(p[i-1],p[i],a)<0 || c2*CCW(p[i-1],p[i],b)<0)\n\t\t\treturn false;\n\treturn true;\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tint sx,sy,ex,ey; cin>>sx>>sy>>ex>>ey;\n\t\tLine l(Point(sx,sy),Point(ex-sx,ey-sy));\n\t\tvector<double> ds(n,INFTY),hs(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>sx>>sy>>ex>>ey>>hs[i];\n\t\t\tif(IsCover(l,sx,sy,ex,ey)){\n\t\t\t\tds[i]=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble a=DistSS(l,Line(Point(sx,sy),Point(ex-sx,0)));\n\t\t\tdouble b=DistSS(l,Line(Point(sx,sy),Point(0,ey-sy)));\n\t\t\tdouble c=DistSS(l,Line(Point(ex,ey),Point(sx-ex,0)));\n\t\t\tdouble d=DistSS(l,Line(Point(ex,ey),Point(0,sy-ey)));\n\t\t\tds[i]=min(min(a,b),min(c,d));\n\t\t}\n\t\t\n\t\tdouble res=INFTY;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble d=ds[i],h=hs[i];\n\t\t\tdouble x;\n\t\t\tif(d<h)\n\t\t\t\tx=d;\n\t\t\telse\n\t\t\t\tx=(h*h+d*d)/(2*h);\n\t\t\tres=min(res,x);\n\t\t}\n\t\tprintf(\"%.4f\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<utility>\n#include<vector>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef double Real;\ntypedef complex<Real> Point;\ntypedef pair<Point,Point> Line;\ntypedef pair<Point,Point> Segment;\ntypedef vector<Point> Polygon;\n\nconst Real eps=1e-9;\nconst Real inf=1e9;\n\nPoint NPoint=Point(NAN,NAN);\n\nvoid print(Point p,char ch='\\n'){\n\tprintf(\"(%f %f)%c\",p.real(),p.imag(),ch);\n}\n\ntemplate<class T> bool eq(T a, T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T a){\n\tif(eq(a,(Real)0)) return 0;\n\treturn a>0?1:-1;\n}\n\nbool onSeg(Point a,Point b,Point c){\n\treturn eq(abs(a-b),abs(a-c)+abs(c-b));\n}\n\nbool onSeg(Segment s,Point p){\n\treturn onSeg(s.first,s.second,p);\n}\n\nReal doP(Point a,Point b){\n\treturn (conj(a)*b).real();\n}\n\nReal crP(Point a,Point b){\n\treturn (conj(a)*b).imag();\n}\n\nPoint proj(Point p,Point b){\n\treturn b*doP(p,b)/norm(b);\n}\n\nbool isPara_(Point a,Point b){\n\treturn eq(crP(a,b),(Real)0);\n}\n\nbool isPara_(Line l1,Line l2){\n\treturn isPara_(l1.second-l1.first,l2.second-l2.first);\n}\n\nPoint iLL(Line l1,Line l2){\n\tif(isPara_(l1,l2)) return NPoint;\n\tPoint a1=l1.first,a2=l1.second;\n\tPoint b1=l2.first,b2=l2.second;\n\tReal num=crP(b1-a1,a2-a1);\n\tReal den=crP(a2-a1,b2-b1);\n\treturn b1+(b2-b1)*(num/den);\n}\n\nPoint perp(Line l,Point a){\n\tPoint p=l.first,q=l.second;\n\treturn p+proj(a-p,q-p);\n}\n\nReal dPS(Point p,Segment s){\n\tPoint h=perp(s,p);\n\tif(onSeg(s,h)) return abs(h-p);\n\treturn min(abs(s.first-p),abs(s.second-p));\n}\n\nbool iSS_(Segment s1,Segment s2){\n\tPoint p1=s1.first,q1=s1.second;\n\tPoint p2=s2.first,q2=s2.second;\n\tif(isPara_(s1,s2)){\n\t\treturn onSeg(s1,p2)||onSeg(s1,q2)||onSeg(s2,p1)||onSeg(s2,q1);\n\t}\n\tPoint p=iLL(s1,s2);\n\treturn onSeg(s1,p)&&onSeg(s2,p);\n}\n\nReal dSS(Segment s1,Segment s2){\n\tReal res=inf;\n\tif(iSS_(s1,s2)) return 0;\n\tres=min(res,dPS(s1.first,s2));\n\tres=min(res,dPS(s1.second,s2));\n\tres=min(res,dPS(s2.first,s1));\n\tres=min(res,dPS(s2.second,s1));\n/*\tprint(s1.first);\n\tprint(s1.second);\n\tprint(s2.first);\n\tprint(s2.second);\n\tprintf(\"%f\\n\",res);*/\n\treturn res;\n}\n\n\nReal calc(Real d,Real h){\n\tif(h>d) return d;\n\treturn (d*d+h*h)/(2.0*h);\n}\n\nReal calc(Segment s1,Segment s2,Real h){\n\tReal d=dSS(s1,s2);\n\tif(sgn(d)<=0) return 0;\n\treturn calc(d,h);\n}\n\nbool check(Real mx,Real my,Real Mx,Real My,Real x,Real y){\n\treturn sgn(mx-x)<=0&&sgn(my-y)<=0&&sgn(Mx-x)>=0&&sgn(My-y)>=0;\n}\n\nvector<Segment> segs;\nvector<Real> hs;\nPoint s,e;\nSegment seg;\nint N;\n\nReal solve(){\n\tReal res=inf;\n\tfor(int i=0;i<segs.size();i++){\n\t\tres=min(res,calc(segs[i],seg,hs[i]));\n\t}\n\treturn res;\n}\n\nvoid init(){\n\tsegs.clear();\n\ths.clear();\n}\n\nPoint readPoint(){\n\tReal x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nbool input(){\n\tscanf(\"%d\",&N);\n\tif(N==0) exit(0);\n\ts=readPoint();\n\te=readPoint();\n\tseg=Segment(s,e);\n\tbool flg=true;\n\tfor(int i=0;i<N;i++){\n\t\tPoint p1=readPoint();\n\t\tPoint p3=readPoint();\n\t\tReal h;\n\t\tscanf(\"%lf\",&h);\n\t\tflg&=(!check(p1.real(),p1.imag(),p3.real(),p3.imag(),s.real(),s.imag()));\n\t\tPoint p2=Point(p3.real(),p1.imag());\n\t\tPoint p4=Point(p1.real(),p3.imag());\n\t\tsegs.push_back(Segment(p1,p2));\n\t\tsegs.push_back(Segment(p2,p3));\n\t\tsegs.push_back(Segment(p3,p4));\n\t\tsegs.push_back(Segment(p4,p1));\n\t\tfor(int j=0;j<4;j++) hs.push_back(h);\n\t}\n\treturn flg;\n}\n\nint main(){\n\twhile(true){\n\t\tinit();\n\t\tbool flg=input();\n\t\tif(flg==false){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tReal ans=solve();\n\t\tprintf(\"%f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> xy;\ndouble eps = 1e-9;\ndouble dot_product(xy a,xy b) {return (conj(a)*b).real();}\ndouble cross_product(xy a,xy b) {return (conj(a)*b).imag();}\ndouble dist_lp(xy a1,xy a2,xy p){\n    if(dot_product(a2-a1,p-a1)<eps) return abs(p-a1);\n    if(dot_product(a1-a2,p-a2)<eps) return abs(p-a2);\n    return abs(cross_product(a2-a1,p-a1))/abs(a2-a1);\n}\n\nbool is_online(xy a1,xy a2,xy p){\n    return abs(a1-p)+abs(a2-p)<=abs(a1-a2)+eps;    \n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    if(is_online(a1,a2,b1) || is_online(a1,a2,b2)) return true;\n    if(is_online(b1,b2,a1) || is_online(b1,b2,a2)) return true;\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<-eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<-eps;\n}\n\ndouble dist_ll(xy a1,xy a2,xy b1,xy b2){\n    if(is_intersected(a1,a2,b1,b2)) return 0;\n    return min({dist_lp(a1,a2,b1),dist_lp(a1,a2,b2),dist_lp(b1,b2,a1),dist_lp(b1,b2,a2)\n    ,abs(a1-b1),abs(a1-b2),abs(a2-b1),abs(a2-b2)});   \n}\n\nint N;\ndouble sx,sy,gx,gy,mi_x,mi_y,ma_x,ma_y;\ndouble h;\n\n\nint main(){\n    while(cin>>N && N>0){\n        double ans = 1e9;\n        cin >> sx >> sy >> gx >> gy;\n        if(sx>gx){\n            swap(sx,sy);\n            swap(gx,gy);\n        }\n        xy s = xy(sx,sy),g = xy(gx,gy);\n        for(int i=1;i<=N;i++){\n            cin >> mi_x >> mi_y >> ma_x >> ma_y >> h;\n            if(mi_x<=sx && sx<=ma_x && mi_y<=sy && sy<=ma_y && \n            mi_x<=gx && gx<=ma_x && mi_y<=gy && gy<=ma_y) ans = 0;\n            double d = min({dist_ll(s,g,xy(mi_x,mi_y),xy(mi_x,ma_y)),\n            dist_ll(s,g,xy(mi_x,ma_y),xy(ma_x,ma_y)),\n            dist_ll(s,g,xy(ma_x,ma_y),xy(ma_x,mi_y)),\n            dist_ll(s,g,xy(ma_x,mi_y),xy(mi_x,mi_y))});\n            if(d<=h) ans = min(ans,d);\n            else ans = min(ans,(h*h+d*d)/(2.0*h));\n        }\n        cout << fixed;\n        cout << setprecision(10) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n#include <complex>\ntypedef complex<double> Point;\ndouble dot(Point a, Point b){\n  return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n  return imag(conj(a) * b);\n}\nstruct Line : public vector<Point> {\n  Line(Point a, Point b){\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\nint ccw(Point a, Point b, Point c){\n  b -= a; c -= a;\n  if(cross(b, c) > EPS) return 1;\n  if(cross(b, c) < -EPS) return -1;\n  if(dot(b, c) < 0) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\nbool intersectSP(const Line& s, const Point& p){\n  return ccw(s[0], s[1], p) == 0;\n}\nbool intersectSS(const Line& s, const Line& t){\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 && \n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / norm(l.vector());\n  return l[0] + t * l.vector();\n}\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nint main(){\n  int N;\n  while(cin >> N && N){\n    Point sp, gp;\n    cin >> sp.real() >> sp.imag();\n    cin >> gp.real() >> gp.imag();\n    Line l(sp, gp);\n    vector<double> bx(N), ex(N), by(N), ey(N), h(N);\n    REP(i, N) cin >> bx[i] >> by[i] >> ex[i] >> ey[i] >> h[i];\n    double ans = 1e8;\n    REP(i, N){\n      double d = 1e8;\n      Point p[4] = { Point(bx[i], by[i]), \n                     Point(ex[i], by[i]),\n                     Point(ex[i], ey[i]),\n                     Point(bx[i], ey[i]) };\n      REP(j, 4) d = min(d, distanceSS(l, Line(p[j], p[(j + 1) % 4])));\n      REP(j, 2){\n        if(bx[i] <= l[j].real() && l[j].real() <= ex[i] &&\n            by[i] <= l[j].imag() && l[j].imag() <= ey[i]  ){\n          d = 0.0;\n        }\n      }\n\n      if(h[i] >= d) ans = min(ans, d);\n      else ans = min(ans, h[i] / 2.0 + d * d / (2.0 * h[i]));\n    }\n    printf(\"%.12f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define EPS 1e-10\nusing namespace std;\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0.0;\n\treturn a+b;\n}\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tPoint operator+(Point p){\n\t\treturn Point(add(x,p.x),add(y,p.y));\n\t}\n\tPoint operator-(Point p){\n\t\treturn Point(add(x,-p.x),add(y,-p.y));\n\t}\n\tPoint operator*(double d){\n\t\treturn Point(x*d,y*d);\n\t}\n\tPoint operator/(double d){\n\t\treturn Point(x/d,y/d);\n\t}\n};\n\nclass Segment{\npublic:\n\tPoint p1,p2;\n\tSegment(){}\n\tSegment(Point pp1,Point pp2){\n\t\tp1=pp1;\n\t\tp2=pp2;\n\t}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector v){\n\treturn add(v.x*v.x,v.y*v.y);\n}\n\ndouble abs(Vector v){\n\treturn sqrt(norm(v));\n}\n\ndouble dot(Vector a,Vector b){\n\treturn add(a.x*b.x,a.y*b.y);\n}\n\ndouble cross(Vector a,Vector b){\n\treturn add(a.x*b.y,-a.y*b.x);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return 1;\n\tif(cross(a,b)<-EPS)return -1;\n\tif(dot(a,b)<-EPS)return 2;\n\tif(norm(a)<norm(b))return -2;\n\treturn 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n\treturn intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n\ndouble getDistanceLP(Line l,Point p){\n\treturn abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n\tif(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n\tif(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n\treturn getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n\tif(intersect(s1,s2))return 0.0;\n\treturn min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nbool contains(Polygon g,Point p){\n\tint n=g.size();\n\tbool x=false;\n\tfor(int i=0;i<n;i++){\n\t\tPoint a=g[i]-p,b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b))<EPS && dot(a,b)<EPS)return true;\n\t\tif(a.y>b.y)swap(a,b);\n\t\tif(a.y<EPS && EPS<b.y && cross(a,b)>EPS)x=!x;\n\t}\n\treturn x;\n}\nint n;\nPoint s,e;\ndouble minx[51],maxx[51],miny[51],maxy[51],h[51];\n\nbool check(){\n\tfor(int i=0;i<n;i++){\n\t\tif(intersect(Segment(s,e),Segment(Point(minx[i],miny[i]),Point(maxx[i],miny[i]))))return false;\n\t\tif(intersect(Segment(s,e),Segment(Point(minx[i],miny[i]),Point(minx[i],maxy[i]))))return false;\n\t\tif(intersect(Segment(s,e),Segment(Point(maxx[i],maxy[i]),Point(maxx[i],miny[i]))))return false;\n\t\tif(intersect(Segment(s,e),Segment(Point(maxx[i],maxy[i]),Point(minx[i],maxy[i]))))return false;\n\t\tPolygon p;\n\t\tp.push_back(Point(minx[i],miny[i]));\n\t\tp.push_back(Point(maxx[i],miny[i]));\n\t\tp.push_back(Point(maxx[i],maxy[i]));\n\t\tp.push_back(Point(minx[i],maxy[i]));\n\t\tif(contains(p,s) || contains(p,e))return false;\n\t}\n\treturn true;\n}\n\n\nbool C(double r){\n\tfor(int i=0;i<n;i++){\n\t\tPoint p1=Point(minx[i],miny[i]);\n\t\tPoint p2=Point(maxx[i],miny[i]);\n\t\tPoint p3=Point(minx[i],maxy[i]);\n\t\tPoint p4=Point(maxx[i],maxy[i]);\n\t\tdouble dist=getDistance(Segment(s,e),Segment(p1,p2));\n\t\tdist=min(dist,getDistance(Segment(s,e),Segment(p1,p3)));\n\t\tdist=min(dist,getDistance(Segment(s,e),Segment(p4,p2)));\n\t\tdist=min(dist,getDistance(Segment(s,e),Segment(p4,p3)));\n\t\tif(h[i]<r){\n\t\t\tdist=sqrt(dist*dist+(r-h[i])*(r-h[i]));\n\t\t}\n\t\tif(dist<r)return false;\n\t}\n\treturn true;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tscanf(\"%lf %lf %lf %lf\",&s.x,&s.y,&e.x,&e.y);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf %lf %lf %lf %lf\",&minx[i],&miny[i],&maxx[i],&maxy[i],&h[i]);\n\t\t}\n\t\tif(!check()){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tdouble l=0.0,r=1000.1;\n\t\tfor(int i=0;i<100;i++){\n\t\t\tdouble mid=(l+r)/2.0;\n\t\t\tif(C(mid))l=mid;\n\t\t\telse r=mid;\n\t\t}\n\t\tprintf(\"%.9f\\n\",l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define EPS (1e-10)\ntypedef complex<double> P;\n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\ndouble distance(P p0, P p1, P p2, P p3){\n  double ans = 1e10;\n        ans = min(ans, distance_ls_p(p0, p1, p2));\n        ans = min(ans, distance_ls_p(p0, p1, p3));\n        ans = min(ans, distance_ls_p(p2, p3, p0));\n        ans = min(ans, distance_ls_p(p2, p3, p1));\n        if(is_intersected_ls(p0, p1, p2, p3)) ans = 0.0;\n\t\treturn ans;\n}\n\nint main(){\n\tfor(int z = 0; z < 26; z++){\n\t\tint n; cin >> n;\n\t\tif(n == 0 )break;\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tP s = P(x,y);\n\t\tcin >> x >> y;\n\t\tP g = P(x,y);\n\t\tvector<P> mins(n), maxs(n);\n\t\tvector<double> h(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\t//if(z == 24)printf(\"%.0f %.0f\",x,y);\n\t\t\tmins[i].real(x); mins[i].imag(y);\n\t\t\tcin >> x >> y;\n\t\t\t//if(z == 24)printf(\" %.0f %.0f\",x,y);\n\t\t\tmaxs[i].real(x); maxs[i].imag(y);\n\t\t\tcin >> h[i];\n\t\t\t//if(z == 24)printf(\" %.0f \\n\",h[i]);\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tfor(int i = 0; i < n;i++){\n\t\t\tdouble d = 1e9;\n\t\t\tP p1 = mins[i], p3 = maxs[i];\n\t\t\tP p2(mins[i].real(), maxs[i].imag());\n\t\t\tP p4(maxs[i].real(), mins[i].imag());\n\t\t\tif(p1.real() < s.real() && s.real() < p3.real() && \n\t\t\t\tp1.imag() < s.imag() && s.imag() < p3.imag()){\n\t\t\t\tans = 0;/*\n\t\t\t\tif(z==24){\n\t\t\t\t\tprintf(\"%.0f %.0f %.0f %.0f\\n\",p1.real(),p1.imag(),p3.real(),p3.imag());\n\t\t\t\t\tcout << \"break\" << endl;}*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, distance(s, g, p1,p2));\n\t\t\td = min(d, distance(s, g, p2,p3));\n\t\t\td = min(d, distance(s, g, p3,p4));\n\t\t\td = min(d, distance(s, g, p4,p1));\n\t\t\tdouble r = (h[i]*h[i]+d*d)/(2*h[i]);\n\t\t\tif(h[i] < d){\n\t\t\t\tans = min(ans, r);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = min(ans, d);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4f\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-7;\nconst double PI  = acos(-1.0);\n\n#define M INT_MAX\nstruct P{\n  double x;\n  double y;\n\n  P(){\n\tx=M; y=M;\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n\n};\ndouble dot(P a,P b){\n  return (a.x*b.x+a.y*b.y);\n}\n\ndouble cross(P a,P b){\n  return (a.x*b.y-a.y*b.x);\n}\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\ndouble psd(P p , P a , P b){\n  if( dot( b-a , p-a ) < EPS) return fabs(dis(p-a));\n  if( dot( a-b , p-b ) < EPS) return fabs(dis(p-b));\n  return fabs(cross( b-a , p-a )) / fabs(dis(b-a));\n}\n\nbool intersect_s(P a1 , P a2 , P b1 , P b2){\n  return ( cross(a2-a1 , b1-a1)*cross(a2-a1 , b2-a1) < EPS) &&\n\t( cross(b2-b1 , a1-b1)*cross(b2-b1 , a2-b1) < EPS);\n}\n\nbool isin(P p, P a1, P a2){\n  double mx = min(a1.x, a2.x), Mx = max(a1.x, a2.x);\n  double my = min(a1.y, a2.y), My = max(a1.y, a2.y);\n  return mx < p.x + EPS && p.x < Mx + EPS\n\t&& my < p.y + EPS && p.y < My + EPS;\n}\n\nint main(){\n  int N;\n  while(cin>>N,N){\n\tP s, e;\n\tvector< vector<P> > ps(N, vector<P>(4));\n\tvector<double> h(N), d(N, M);\n\tcin >> s.x >> s.y >> e.x >> e.y;\n\tREP(i,N)\n\t  cin >> ps[i][0].x >> ps[i][0].y >> ps[i][2].x >> ps[i][2].y >> h[i];\n\tREP(i,N){\n\t  ps[i][1].x = ps[i][0].x;\n\t  ps[i][1].y = ps[i][2].y;\n\n\t  ps[i][3].x = ps[i][2].x;\n\t  ps[i][3].y = ps[i][0].y;\n\t}\n\n\tREP(i,N) REP(j,4){\n\t  d[i] = min(d[i], psd(ps[i][j], s, e));\n\t  d[i] = min(d[i], psd(s, ps[i][j], ps[i][(j+1)%4]));\n\t  d[i] = min(d[i], psd(e, ps[i][j], ps[i][(j+1)%4]));\n\t}\n\n\tdouble r_lb = 0., r_ub = 1000.;\n\tREP(i,N) REP(j,4){\n\t  if(intersect_s(s,e,ps[i][j],ps[i][(j+1)%4]))\n\t\tr_ub = 0.;\n\t  if(isin(s, ps[i][0], ps[i][2]) || isin(e, ps[i][0], ps[i][2]))\n\t\tr_ub = 0.;\n\t}\n\n\tREP(i,100){\n\t  bool flag = true;\n\t  double r = (r_lb + r_ub) / 2.;\n\t  REP(j,N){\n\t\tif(d[j] > r) continue;\n\t\tif(r < h[j] + EPS || d[j]*d[j]+h[j]*h[j] - 2*r*h[j] < EPS){\n\t\t  flag = false;\n\t\t  break;\n\t\t}\n\t  }\n\n\t  if(flag) r_lb = r;\n\t  else r_ub = r;\n\t}\n\n\tcout << fixed << setprecision(6) << r_lb << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<complex>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define inf (1<<29)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -inf,double y = -inf): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<Point> vp;\ntypedef vector<vp> vvp;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\n// 度をラジアンに変換\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\n//0 <= <= 180 && -180 < <= 0 \ndouble toDo(double rad)\n{\n  return rad*180.0/M_PI;\n}\n\ndouble args(Point p){\n  return atan2(p.y,p.x);\n}\n\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nstruct Circle\n{\n  Point p;\n  double r;\n  Circle(Point p=Point(),double r=inf):p(p),r(r){}\n};\n\nbool isIntersectLC(Line l,Circle c)\n{\n  double Mdist = getDistanceLP(l,c.p);\n  return Mdist <= c.r;\n  //return equals(Mdist,c.r) || (!equals(Mdist,c.r) && Mdist < c.r);\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //polyの最後の要素 = polyの最初の要素 であることが前提\n  \n  //そうでない場合は\n    rep(i,poly.size())\n      if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n    double sum = 0;\n    for(int i=0; i < (int)poly.size() ;i++)\n      {\n        if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n          sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n        else\n          sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n      }\n      return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n      //と書き換えること\n    \n  \n}  \n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\nassert(isIntersect(a1,a2,b1,b2));//交差していない　これを外してもある程度（またはしっかり？）はうごいてくれる\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\n// Line Line 上と同じ assertなし\nPoint getCrossPointLines( Line s1, Line s2){\n    Point a = s1.p2 - s1.p1;\n    Point base = s2.p2 -s2.p1;\n    return s1.p1 + a * (cross(base, s2.p1 - s1.p1)/cross(base, a));\n}\n\n\nPoint project(Segment s,Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1 + base*t;\n}\n\ndouble getDistance(Segment s1,Segment s2)\n{\n  if(isIntersect(s1,s2))return 0;\n  return min( min(getDistanceSP(s1,s2.p1), getDistanceSP(s1,s2.p2) ),\n\t      min(getDistanceSP(s2,s1.p1), getDistanceSP(s2,s1.p2) ));\n}\n\nstruct Obj\n{\n  vector<Point> ps;\n  double h;\n  Obj(Point ps1=Point(),Point ps2=Point(),double h=-inf):h(h)\n  {\n    ps.resize(4);\n    ps[0].x = ps1.x,ps[0].y = ps1.y;\n    ps[1].x = ps1.x,ps[1].y = ps2.y;\n    ps[2].x = ps2.x,ps[2].y = ps2.y;\n    ps[3].x = ps2.x,ps[3].y = ps1.y;\n  }\n};\nint N;\nPoint s,e;\n\nint main()\n{\n \n  while(cin >> N,N)\n    {\n      cin >> s.x >> s.y >> e.x >> e.y;\n      //vector<Obj> vec;\n      Obj vec;\n      Circle c(s);\n      Point st = e-s;\n      Point E = st/sqrt(norm(st)); \n      double cont = 1000000;\n      Line line(E*(-cont) + s,E*cont + s);\n      //cout << \"line( (\" << line.p1.x << \",\" << line.p1.y << \") , (\" << line.p2.x << \",\" << line.p2.y << \") )\" << endl;\n      Segment seg(s,e);\n      rep(i,N)\n\t{\n\t  Point a,b;\n\t  double h;\n\t  cin >> a.x >> a.y >> b.x >> b.y >> h;\n\t  if(c.r == 0)continue;\n\t  vec = Obj(a,b,h);\n\t  rep(j,4)\n\t    {\n\t      if(isIntersect(seg,Segment(vec.ps[j],vec.ps[(j+1)%4])) )\n\t\t{\n\t\t  c.r = 0;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  if(inPolygon(vec.ps,s) || inPolygon(vec.ps,e))\n\t    {\n\t      c.r = 0;\n\t      break;\n\t    }\n\n\t  rep(j,4)\n\t    {\n\t      /*\n\t      Point p = project(line,vec[i].ps[j]);\n\t      cout << \"on point = \" << p.x << \",\" << p.y << endl;\n\t      c.p = p;\n\t      */\n\t      double w = getDistance(seg,Segment(vec.ps[j],vec.ps[(j+1)%4]));\n\t      //cout << \"w = \"<< w << endl;\n\t      //if(equals(w,h) || w < h)continue;\n\t   \n\t      double dist = (h*h+w*w)/(2.0*h);\n\t      //cout <<\"the distance is \" << dist << endl; \n\t      c.r = min(c.r,dist);\n\t      //cout << \"c.r = \" << c.r << endl;\n\t    }\n\t  \n\n\t  \n\t  //cout << endl;\n\t}\n      cout << setiosflags(ios::fixed) << setprecision(10) << c.r << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing msi = map<string, int>;\nusing mii = map<int, int>;\nusing psi = pair<string, int>;\nusing pii = pair<int, int>;\nusing vlai = valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF (ll)1E9\n#define EPS 1E-3\n#define MOD 1000000007\n#define PI 3.1415926535897932384\n\ntemplate <class T>ostream &operator<<(std::ostream &o, const vector<T> &v)\n{\n\trep(i, v.size()) {\n\t\to << (i > 0 ? \" \" : \"\") << v[i];\n\t}\n\treturn o;\n}\n\n//int dx[]={1,1,1,0,-1,-1,-1,0},dy[8]={1,0,-1,-1,-1,0,1,1,1};\n\n//constexpr ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;   // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n\t\t\t\t\t   // 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n\treturn (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n\treturn (conj(a)*b).Y;\n}\n\n// 点の進行方向\nint ccw(P a, P b, P c) {\n\tb -= a;  c -= a;\n\tif (cross(b, c) >  EPS) return +1;  // counter clockwise\n\tif (cross(b, c) < -EPS) return -1;  // clockwise\n\tif (dot(b, c)   < -EPS) return +2;  // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n\treturn 0;                          // a--c--b on line or a==c or b==c\n}\n\n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n\n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n\treturn abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n\n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n\treturn !isecLP(a2 - a1, b2 - b1, 0) || isecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n\treturn cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS;\n}\n\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n\t\tccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n\treturn !ccw(a1, a2, b);\n}\n\n\n/* 距離　各直線・線分は縮退してはならない */\n\n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n\treturn a1 + dot(a2 - a1, p - a1) / norm(a2 - a1) * (a2 - a1);\n}\n\n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n\treturn 2.0*proj(a1, a2, p) - p;\n}\n\nD distLP(P a1, P a2, P p) {\n\treturn abs(proj(a1, a2, p) - p);\n}\n\nD distLL(P a1, P a2, P b1, P b2) {\n\treturn isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n\nD distLS(P a1, P a2, P b1, P b2) {\n\treturn isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n\nD distSP(P a1, P a2, P p) {\n\tP r = proj(a1, a2, p);\n\tif (isecSP(a1, a2, r)) return abs(r - p);\n\treturn min(abs(a1 - p), abs(a2 - p));\n}\n\nD distSS(P a1, P a2, P b1, P b2) {\n\tif (isecSS(a1, a2, b1, b2)) return 0;\n\treturn min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n\t\tmin(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\n// 2直線の交点\nP crosspointLL(P a1, P a2, P b1, P b2) {\n\tD d1 = cross(b2 - b1, b1 - a1);\n\tD d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n\tif (EQ(d2, 0)) throw \"kouten ga nai\";   // 交点がない\n\treturn a1 + d1 / d2 * (a2 - a1);\n}\n\n\n\nvoid solve(int n) {\n\tdouble ans = 100000;\n\tdouble sx, sy, ex, ey;\n\tvector<double> in(4), h(n) ,d(n,100000);\n\tcomplex<double> s, e, vec;\n\tvector<vector<complex<double>>> dat(n, vector<complex<double>>(4));\n\tcin >> sx >> sy >> ex >> ey;\n\ts = { sx,sy }; e = { ex,ey };\n\tbool sw = false;\n\trep(i, n) {\n\t\tcin >> in[0] >> in[1] >> in[2] >> in[3] >> h[i];\n\t\trep(j, 4) {\n\t\t\tcomplex<double> c = {in[(j/2)*2],in[(j%2)*2+1]};\n\t\t\tdat[i][j] = c;\n\t\t}\n\t\tif (in[0] <= sx&&sx <= in[2] &&\n\t\t\tin[0] <= ex&&ex <= in[2] &&\n\t\t\tin[1] <= sy&&sy <= in[3] &&\n\t\t\tin[1] <= ey&&ey <= in[3]\n\t\t\t)sw = true;\n\t}\n\tif (sw) {\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\t//cout << distSS( { 8541, 5883 }, { 3011 ,-5535 } ,{ 5887,-161 }, { 5887,-152 }) << endl;\n\t//cout << s << \" \" << e << endl;\n\trep(i, n) {\n\t\tdouble dist;\n\t\trep(j, 4) {\n\t\t\t//cout << dat[i][j].real() << \" \"<< dat[i][j].imag() <<endl;\n\t\t}\n\t\tdist = distSS(dat[i][0], dat[i][1], s, e);\n\t\t//cout <<s<<e<< dat[i][0]<<\"===\"<< dat[i][1]<<\" \"<<dist << endl;\n\t\td[i] = min(d[i], dist);\n\t\tdist = distSS(dat[i][0], dat[i][2], s, e);\n\t\t//cout << dat[i][0] << \"===\" << dat[i][2] << \" \" << dist << endl;\n\t\td[i] = min(d[i], dist);\n\t\tdist = distSS(dat[i][1], dat[i][3], s, e);\n\t\t//cout << dat[i][1] << \"===\" << dat[i][3] << \" \" << dist << endl;\n\t\td[i] = min(d[i], dist);\n\t\tdist = distSS(dat[i][2], dat[i][3], s, e);\n\t\t//cout << dat[i][2] << \"===\" << dat[i][3] << \" \" << dist << endl;\n\t\td[i] = min(d[i], dist);\n\t\t//cout << endl;\n\t}\n\t//cout << d << endl;\n\trep(i, n) {\n\t\tdouble r;\n\t\tif (d[i] <= h[i])r = d[i];\n\t\telse {\n\t\t\tr=(h[i] * h[i] + d[i] * d[i]) / (2 * h[i]);\n\t\t}\n\t\t//cout << r << endl;\n\t\tans = min(ans, r);\n\t}\n\tcout << setprecision(15) <<ans << endl;\n\n}\n\nint main(void) {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tsolve(n);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-8\n#define equal(a,b) (fabs(a-b) < EPS)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(const Point &p0,const Point &p1,const Point &p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nPoint projection(const Segment &s,const Point &p){\n    Vector b = s.t-s.s;\n    double t = dot(p-s.s,b)/norm(b);\n    return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n    return (ccw(s.s,s.t,p) == 0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n            ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n    Point r = projection(s,p);\n    if(isIntersectSP(s,r)) return abs(r-p);\n    return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment &a,const Segment &b){\n    if(isIntersectSS(a,b)) return 0;\n    return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n           min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nstruct Block{\n    Point a,b;\n    double h;\n    Block(){}\n    Block(Point &a,Point &b,double h) :\n        a(a),b(b),h(h) {}\n};\n\nistream &operator >> (istream &is,Point &p){ \n    return is >> p.x >> p.y;\n}\n\ndouble calc(double a,double b){\n    return sqrt(a*a+b*b);\n}\n\nbool c(double r,Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point a = v[i].a,b = v[i].b;\n        Point c(a.x,b.y),d(b.x,a.y);\n        Segment s1(a,c),s2(a,d),s3(c,b),s4(d,b);\n        double dst[] = {\n            distanceSS(p,s1),distanceSS(p,s2),\n            distanceSS(p,s3),distanceSS(p,s4)\n        };\n \n        if(r < v[i].h){\n            if(!(r < dst[0] && r < dst[1] &&\n                 r < dst[2] && r < dst[3])){\n                return 0;\n            }\n        }else{\n            double nh = r - v[i].h;\n            if(!(r < calc(nh,dst[0]) && r < calc(nh,dst[1]) &&\n                 r < calc(nh,dst[2]) && r < calc(nh,dst[3]))){\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nbool check(Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point a = v[i].a,b = v[i].b;\n        Point c(a.x,b.y),d(b.x,a.y);\n        Segment s1(a,c),s2(a,d),s3(c,b),s4(d,b);\n        if((a.x < p.s.x && p.s.x < b.x &&\n            a.y < p.s.y && p.s.y < b.y) ||\n           (a.x < p.t.x && p.t.x < b.x &&\n            a.y < p.t.y && p.t.y < b.y)){\n            return 1;\n        }\n\t/*   if(isIntersectSS(p,s1)) return 1;\n        if(isIntersectSS(p,s2)) return 1;\n        if(isIntersectSS(p,s3)) return 1;\n        if(isIntersectSS(p,s4)) return 1;\n\t*/\n    }\n    return 0;\n}\n\nint main(){\n    int N;\n    while(cin >> N,N){\n        Segment seg;\n        cin >> seg.s >> seg.t;\n        vector<Block> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].a >> v[i].b >> v[i].h;\n        }\n        if(check(seg,v)){\n            cout << 0 << endl;\n            continue;\n        }\n        double l = 0,r = 1001;\n        for(int i = 0 ; i < 100 ; i++){\n            double mid = (l + r) / 2;\n            if(c(mid,seg,v)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n        printf(\"%.10f\\n\",l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#define X real()\n#define Y imag()\n\n\ntypedef complex<double> Point;\ntypedef pair<Point,double> Point3;\n\nconst int N = 333;\n\nint n;\nint stx,sty,enx,eny;\nint ina[N],inb[N],inc[N],ind[N],inh[N];\n\nvector<Point3> point;\nvector<Point3> pointbase;\n\nvoid slide(Point p){\n\trep(i,point.size()){\n\t\tpoint[i].first -= p;\n\t}\n}\n\nvoid rotate(double theta){\n\trep(i,point.size()){\n\t\tdouble nx = cos(theta)*point[i].first.X - sin(theta)*point[i].first.Y;\n\t\tdouble ny = sin(theta)*point[i].first.X + cos(theta)*point[i].first.Y;\n\t\t\n\t\tpoint[i] = Point3(Point(nx,ny), point[i].second);\n\t}\n}\n\nvoid print(){\n\tputs(\"Points\");\n\trep(i,point.size()){\n\t\tprintf(\"(%lf %lf),%lf\\n\",point[i].first.X, point[i].first.Y, point[i].second);\n\t}\n}\n\ndouble getlen(Point3 point3, Point p){\n\tdouble left = 0;\n\tdouble right = 11111;\n\t\n\tconst double EPS = 0.000000001;\n\t\n\twhile(1){\n\t\tdouble h = (left+right)/2;\n\t\t\n\t\tPoint3 A = Point3(p, h);\n\t\tPoint3 B = Point3(point3.first, min(point3.second, h));\n\t\t\n\t\tdouble dx = A.first.X - B.first.X;\n\t\tdouble dy = A.first.Y - B.first.Y;\n\t\tdouble dz = A.second - B.second;\n\t\t\n\t\tdouble len = sqrt(dx*dx + dy*dy + dz*dz);\n\t\t\n\t\tif(len>h){\n\t\t\tleft = h;\n\t\t}else{\n\t\t\tright = h;\n\t\t}\n\t\t\n\t\tif(left +  EPS > right)break;\n\t}\n\treturn left;\n}\n\ndouble getmin(double loadlen){\n\tdouble ret = 11111;\n\trep(i,point.size()){\n\t\tif(point[i].first.X < 0){\n\t\t\tret = min(ret, getlen(point[i], Point(0,0)) );\n\t\t\tcontinue;\n\t\t}\n\t\tif(point[i].first.X >loadlen){\n\t\t\tret = min(ret, getlen(point[i], Point(loadlen,0)) );\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tret = min(ret, getlen(point[i], Point(point[i].first.X, 0)));\n\t}\n\t\n\treturn ret;\n}\n\ndouble getlen2(Point p, int num){\n\t\n\tdouble ans = 11111;\n\tbool xin = ina[num]<p.X && p.X<inc[num];\n\tbool yin = inb[num]<p.Y && p.Y<ind[num];\n\t\n\tif(yin){\n\t\tif(ina[num]>p.X) ans = min(ans ,getlen(Point3(Point(ina[num],p.Y), inh[num]), p));\n\t\tif(inc[num]<p.X) ans = min(ans ,getlen(Point3(Point(inc[num],p.Y), inh[num]), p));\n\t}\n\tif(xin){\n\t\tif(inb[num]>p.Y) ans = min(ans ,getlen(Point3(Point(p.X, inb[num]), inh[num]), p));\n\t\tif(ind[num]<p.Y) ans = min(ans ,getlen(Point3(Point(p.X, ind[num]), inh[num]), p));\n\t}\n\t\n\tif(xin && yin)return 0;\n\t\n\treturn ans;\n}\ndouble solve2(){\n\t\n\tdouble ret = 11111;\n\t\n\t\n\trep(i,n){\n\t\tret = min(ret, getlen2(Point(stx,sty), i));\n\t\tret = min(ret, getlen2(Point(enx,eny), i));\n\t}\n\t\n\treturn ret;\n}\n\n\ndouble cross(Point a,Point b){\n\treturn a.X*b.Y - a.Y*b.X;\n}\n\nbool ccw(Point a, Point b, Point c){\n\treturn cross(b-a, c-a)>0;\n}\n\nbool linehit(Point a,Point b,Point c, Point d){\n\tbool ret = (ccw(a,b,c)!=ccw(a,b,d))&&(ccw(c,d,a)!=ccw(c,d,b));\n\t//if(ret)cout<<a<<b<<c<<d<<endl;;\n\treturn ret;\n}\n\ndouble solve3(){\n\t\n\tdouble ret = 11111;\n\trep(i,n){\n\t\tPoint st = Point(stx,sty);\n\t\tPoint en = Point(enx,eny);\n\t\t\n\t\tbool flg = false;\n\t\tflg |= linehit(st, en, Point(ina[i], inb[i]), Point(ina[i], ind[i]));\n\t\tflg |= linehit(st, en, Point(ina[i], ind[i]), Point(inc[i], ind[i]));\n\t\tflg |= linehit(st, en, Point(inc[i], ind[i]), Point(inc[i], inb[i]));\n\t\tflg |= linehit(st, en, Point(inc[i], inb[i]), Point(ina[i], inb[i]));\n\t\t\n\t\tif(flg)ret = 0;\n\t}\n\treturn ret;\n}\n\ndouble solve(){\n\tcin>>stx>>sty>>enx>>eny;\n\n\t\n\tvector<Point3> temppt;\n\t\n\trep(i,n){\n\t\tdouble a,b,c,d,h;\n\t\tcin>>a>>b>>c>>d>>h;\n\t\t\n\t\tina[i] = a; inb[i]=b; inc[i]=c; ind[i]=d; inh[i]=h;\n\t\t\n\t\ttemppt.push_back(Point3(Point(a,b),h));\n\t\ttemppt.push_back(Point3(Point(a,d),h));\n\t\ttemppt.push_back(Point3(Point(c,b),h));\n\t\ttemppt.push_back(Point3(Point(c,d),h));\n\t}\n\t\n\t\n\tpoint = temppt;\n\tpointbase = temppt;\n\t\n\tslide(Point(stx,sty));\n\trotate(-atan2(eny-sty, enx-stx));\n\t\n\tdouble loadlen = abs(Point(stx,sty)-Point(enx,eny));\n\tdouble mini = getmin( loadlen ); \n\t\n\t//print();\n\t\n\tdouble ans2 = solve2();\n\tdouble ans3 = solve3();\n\t\n\treturn min(mini, min(ans2, ans3));\n}\n\n\nint main(){\n\t\n\t/*\n\tPoint p1 = Point(0,0);\n\tPoint3 p2(Point(5,0), 4);\n\t\n\tdouble val = getlen(p2,p1);\n\tprintf(\"%lf\\n\",val);\n\t*/\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tprintf(\"%.9lf\\n\",solve());\n\t\t\n\t\t//break;\n\t}\n}\n\n/*\n1\n1 1 3 3\n2 1 3 2 5\n\n\n1\n1 0 5 2\n2 3 4 5 10\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef complex<double> C;\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nbool eq(C c1,C c2)\n{\n  return (eq(c1.real(),c2.real()) && eq(c1.imag(),c2.imag()));\n}\n\n//?????¶??????sqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return  arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return  imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return  real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n//??´???????????????????????????(????????´??????True)\nbool intersectLL(const L &l, const L &m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//??´?????¨?????????????????????(????????±??????????????¨??????)\nbool intersectLS(const L &l, const L &s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//??´?????¨????????????(??±???)??????\nbool intersectLP(const L &l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//??????????????????????????????(????????±??????????????¨??????)\nbool intersectSS(const L &s, const L &t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//????????¨????????????(??±???)??????\nbool intersectSP(const L &s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//???p?????´???l???????°???±\nC projection(const L &l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//???p?????´???l????????¨??????????§°?§????\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//?????¨??´???????????¢\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//??´?????¨??´???????????¢\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//??´?????¨??????????????¢\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//????????¨???????????¢\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//????????¨??????????????¢\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n//??´???????????????????????????\nC crosspointLL(const L &l, const L &m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//?????¨??´????????????\ndouble gettime(C c1,C c2)\n{\n  return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//?????¨??´????????????\nvector<C> crosspointCL(C c1,double r1,L l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n//?????¨???????????????\nvector<C> crosspointCS(C c1,double r1,L s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(eq(abs(s[1]-s[0]),abs(s[0]-tmp[i])+abs(s[1]-tmp[i]))){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//?????????????????????\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n  C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n  C d = b*b-4.0*a*c;\n  C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n  return L(z1, z2);\n}\n//?????¨????§???¢?????±?????¨????????¢???\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\ndouble getcrossarea(vector<C> t,C c1,double r1)\n{\n    int n=t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//??????????±???????\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//?????§??????\nbool isconvex(const vector<C> &ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//????§???¢?????¢???\ndouble area(const vector<C> &ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//???????§???¢?????´?????§???????????????????????´????????¢\nvector<C> convex_cut(const vector<C> &ps, const L &l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//??????????§???¢???????????????????????????(0??????????????????,1?????????,2???????????????)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//???????§???¢?????´???????±???????(?????£????????????)\n//maxi,maxj?????????????????¨??????\ndouble convex_diameter(const vector<C> &ps)\n{\n    const int n = ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\n//????????????????±???????\ndouble closest_pair(C *a, int n)\n{\n    if(n<=1) return INF;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\ndouble compute_shortest(C *a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2??????????????¢????????????(????????????2??????????????±?????\\????????°)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//?????????????????\\???????????????????????\\???\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//????????????????????\\???\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //??????????????¨??????????????´???\n    if(eq(s,t)){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2????????±????????\\???????±???????\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2????????±????????\\???????±???????\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2????????±?????\\???????±???????(?????´??????????????????????????????????????\\???)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nbool possible(const L &l1,const vector<L>* vec,int n,double r,vector<int>& h)\n{\n    bool flag = true;\n    rep(i,n){\n        double mn = INF;\n        rep(j,vec[i].size()){\n            mn = min(mn,distanceSS(l1,vec[i][j]));\n        }\n        if(mn < r){\n            if(r - sqrt(r*r - mn*mn) < h[i]){\n                flag = false;\n                break;\n            }\n        }\n    }\n    return flag;\n}\n\nint main()\n{\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        int sx,sy,ex,ey;\n        cin >> sx >> sy >> ex >> ey;\n        L l1 = L(C(sx,sy),C(ex,ey));\n        vector<int> h(51);\n        vector<C> con[51];\n        vector<L> l[51];\n        bool flag = false;\n        rep(i,n){\n            int a,b,c,d;\n            cin >> a >> b >> c >> d >> h[i];\n            if(flag){\n                continue;\n            }\n            l[i].pb(L(C(a,b),C(a,d)));\n            l[i].pb(L(C(a,b),C(c,b)));\n            l[i].pb(L(C(a,d),C(c,d)));\n            l[i].pb(L(C(c,b),C(c,d)));\n            con[i].pb(C(a,b)),con[i].pb(C(a,d)),con[i].pb(C(c,b)),con[i].pb(C(c,d));\n            if(contains(con[i],l1[0]) || contains(con[i],l1[1])){\n                flag = true;\n                cout << \"0\\n\";\n            }\n        }\n        if(flag){\n            continue;\n        }\n        double low = 0;\n        double high = 1001;\n        while(1){\n            double mid = (low+high)/2;\n            if(abs(mid-low) < EPS){\n                printf(\"%.10f\\n\",mid);\n                break;\n            }\n            if(possible(l1,l,n,mid,h)){\n                low = mid;\n            }else{\n                high = mid;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : VP{\n    L(const P& a, const P& b){ resize(2); at(0)=a; at(1)=b; }\n    L(){ resize(2); }\n};\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\n\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //counter clockwise\n    if(cross(b,c) <-EPS) return -1; //clockwise\n    if(dot(b,c) < EPS) return +2; //c-a-b\n    if(norm(b) < norm(c)) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nbool intersectSS(const L& s, const L& t){\n    return ( ccw(s[0],s[1],t[0]) *ccw(s[0],s[1],t[1]) <= 0 ) &&\n        ( ccw(t[0],t[1],s[0]) *ccw(t[0],t[1],s[1]) <= 0 );\n}\nbool intersectSP(const L& s, const P& p){\n    return abs(s[0]-p) +abs(s[1]-p) -abs(s[1]-s[0]) < EPS;\n}\nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        int sx,sy,ex,ey;\n        cin >> sx >> sy >> ex >> ey;\n        L stoe(P(sx, sy), P(ex, ey));\n        double ans = INF;\n        for(int i=0; i<n; i++){\n            vector<P> p(4);\n            int x1,y1,x2,y2,h;\n            cin >> x1 >> y1 >> x2 >> y2 >> h;\n            p[0] = P(x1, y1);\n            p[1] = P(x1, y2);\n            p[2] = P(x2, y2);\n            p[3] = P(x2, y1);\n            double dist = INF;\n            if(x1<sx && sx<x2 && y1<sy && sy<y2) dist=0;\n            if(x1<ex && ex<x2 && y1<ey && ey<y2) dist=0;\n            for(int i=0; i<4; i++){\n                dist = min(dist, distanceSS(stoe, L(p[i], p[(i+1)%4])));\n            }\n            if(dist > h){\n                ans = min(ans, (dist*dist+h*h)/(2*h));\n            }else{\n                ans = min(ans, dist);\n            }\n        }\n        cout << fixed;\n        cout << setprecision(5);\n        cout << ans << endl;\n    }    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst double EPS = 1e-9;\n\nstruct Block{\n    vector<point> ps;\n    double h;\n    Block(double minx,\n          double miny,\n          double maxx,\n          double maxy,\n          double th){\n        ps.push_back(point(minx,miny));\n        ps.push_back(point(maxx,miny));\n        ps.push_back(point(maxx,maxy));\n        ps.push_back(point(minx,maxy));\n        h = th;\n    }\n};\n\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\nbool is_intersected_linesegment(point a1,point a2,point b1,point b2){\n    if(max(a1.real(),a2.real()) + EPS < min(b1.real(),b2.real())) return false;\n    if(max(b1.real(),b2.real()) + EPS < min(a1.real(),a2.real())) return false;\n    if(max(a1.imag(),a2.imag()) + EPS < min(b1.imag(),b2.imag())) return false;\n    if(max(b1.imag(),b2.imag()) + EPS < min(a1.imag(),a2.imag())) return false;\n\n    return (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) < EPS and\n            cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < EPS);\n\n}\n\n// 直線と点の最短距離を実現する直線の点(すいせんの足)\npoint nearest_point_line_and_point(point a1,point a2,point b){\n    return b - ((cross(a2-a1,b-a1) / abs(a2-a1)) * (a2-a1) / abs(a2-a1));\n}\n\n// 線分と点の最短距離を実現する線分嬢の点\npoint nearest_point_linesegment_and_point(point a1,point a2,point b){\n    if(dot(a2-a1,b-a1) < EPS) return a1;\n    if(dot(a1-a2,b-a2) < EPS) return a2;\n    return nearest_point_line_and_point(a1,a2,b);\n}\n\nint ccw(point a,point b,point c){\n    b -= a; c -= a;\n    if(cross(b,c) > 0) return +1;\n    if(cross(b,c) < 0) return -1;\n    if(dot(b,c) < 0) return +2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\nbool is_inner_point_vertex(vector<point> ps,point a){\n    int cc = ccw(ps[0],ps[1],a);\n    if(not (cc == 1 or cc == -1)) return false;\n    for(int i=0;i<ps.size();i++){\n        if(cc != ccw(ps[i],ps[(i+1)%ps.size()],a)) return false;\n    }\n    return true;\n}\n\ndouble solve(point s,point e,vector<Block> blocks){\n    int N = blocks.size();\n    for(int i=0;i<N;i++){\n        for(int j=0;j<4;j++){\n            if(is_intersected_linesegment(s,e,blocks[i].ps[j],\n                                              blocks[i].ps[(j+1)%4])){\n                return 0;\n            }else if(is_inner_point_vertex(blocks[i].ps,s) and\n                     is_inner_point_vertex(blocks[i].ps,e)){\n                return 0;\n            }\n        }\n    }\n    double lower = 0;\n    double upper = 1000;\n\n    for(int lp=0;lp<100;lp++){\n        double mid = (lower+upper) / 2;\n        bool ok = true;\n        for(int i=0;i<N;i++){\n            for(int j=0;j<4;j++){\n                point reg = nearest_point_linesegment_and_point(s,e,blocks[i].ps[j]);\n                double re = abs(reg-blocks[i].ps[j]);\n                if(re > mid) continue;\n                if(blocks[i].h < (mid - sqrt(mid*mid - re*re))) continue;\n                ok = false;\n            }\n        }\n        for(int i=0;i<N;i++){\n            for(int j=0;j<4;j++){\n                point a1 = blocks[i].ps[j],a2 = blocks[i].ps[(j+1)%4];\n                point reg = nearest_point_linesegment_and_point(a1,a2,s);\n                double re = abs(reg-s);\n                if(re > mid) continue;\n                if(blocks[i].h < (mid - sqrt(mid*mid - re*re))) continue;\n                ok = false;\n            }\n        }\n        for(int i=0;i<N;i++){\n            for(int j=0;j<4;j++){\n                point a1 = blocks[i].ps[j],a2 = blocks[i].ps[(j+1)%4];\n                point reg = nearest_point_linesegment_and_point(a1,a2,e);\n                double re = abs(reg-e);\n                if(re > mid) continue;\n                if(blocks[i].h < (mid - sqrt(mid*mid - re*re))) continue;\n                ok = false;\n            }\n        }\n\n        if(ok){\n            lower = mid;\n        }else{\n            upper = mid;\n        }\n    }\n    return lower;\n}\n\nint main(){\n    cout << fixed << setprecision(10);\n    while(true){\n        int N;\n        cin >> N;\n        if(N == 0) break;\n        double sx,sy,ex,ey;\n        cin >> sx >> sy >> ex >> ey;\n        vector<Block> blocks;\n        for(int i=0;i<N;i++){\n            double minx,miny,maxx,maxy,h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            blocks.push_back(Block(minx,miny,maxx,maxy,h));\n        }\n        cout << solve(point(sx,sy),point(ex,ey),blocks) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\nconst int INF = 1 << 30;\nconst double EPS = 1e-8;\n\ntemplate<class T> bool eq(T a, T b) { return abs(a - b) < EPS; }\nusing Point = complex<double>;\n#define X(a) real(a)\n#define Y(a) imag(a)\nistream &operator >> (istream& is, Point& p) { double a, b; is >> a >> b; p.X(a); p.Y(b); return is; }\n\ndouble dot(Point a, Point b) { return a.X() * b.X() + a.Y() * b.Y(); }\ndouble cross(Point a, Point b) { return a.X() * b.Y() - a.Y() * b.X(); }\ndouble length2(Point p) { return p.X() * p.X() + p.Y() * p.Y(); }\ndouble length(Point p) { return sqrt(length2(p)); }\ndouble distance(Point a, Point b) { return length(a - b); }\nPoint unit(Point p) { return p / length(p); }\n\nenum ccw_t {\n    COUNTER_CLOCK_WISE = 1,\n    CLOCK_WISE = -1,\n    STRAIGHT_C_A_B = 2,\n    STRAIGHT_A_B_C = -2,\n    STRAIGHT_A_C_B = 0\n};\n\nccw_t ccw(Point a, Point b, Point c){\n    Point ab = b - a, ac = c - a;\n    if( cross(ab,ac) > EPS ) return COUNTER_CLOCK_WISE; // +1 a-b-c ???????¨???????\n    if( cross(ab,ac) < -EPS ) return CLOCK_WISE;        // -1 a-b-c ????¨???????\n    if( dot(ab,ac) < -EPS ) return STRAIGHT_C_A_B;      // +2 c-a-b\n    if( length2(ab) < length2(ac) )return STRAIGHT_A_B_C;     // -2 a-b-c or a==b\n    return STRAIGHT_A_C_B;                              //  0 a-c-b or b==c or a==c\n}\n\nstruct Segment {\n    Point a, b;\n    Segment(){}\n    Segment(const Point& a, const Point& b):a(a), b(b){}\n    pair<Point,Point> to_pair() const { return make_pair(a,b); }\n    bool operator == (Segment s) const { return to_pair() == s.to_pair();}\n    bool operator != (Segment s) const { return !(*this == s); }\n    friend istream &operator >> (istream& is, Segment &s){ return is >> s.a >> s.b;}\n    friend ostream &operator << (ostream& os, Segment s) { return os << s.a << \"->\" << s.b;}\n};\ndouble length(Segment s) { return distance(s.a, s.b); }\nbool contain(Segment s, Point p) {\n    return ccw(s.a, s.b, p) == 0; // STRAIGHT_A_C_B;\n}\nPoint projection(Segment s, Point p) {\n    Point v = s.b - s.a;\n    double t = dot(p - s.a, v) / length2(v); // ??????\n    return v * t + s.a;\n}\nPoint closest_point(Segment s, Point p) {\n    Point pp = projection(s, p);\n    return contain(s, pp) ? pp : distance(s.a, p) < distance(s.b, p) ? s.a : s.b;\n}\ndouble distance(Segment s, Point p) {\n    if( dot(s.b - s.a ,p - s.a) < EPS ) return distance(p, s.a);\n    if( dot(s.a - s.b ,p - s.b) < EPS ) return distance(p, s.b);\n    return abs(cross(s.b - s.a, p - s.a) / length(s));\n}\nbool intersect(Segment s, Segment t) { // ????????????\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 and ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\nstruct Rectangle {\n    array<Point, 4> p;\n    // order:\n    //     3 2\n    //     0 1\n    Rectangle(const array<Point, 4> &pp):p(pp) {\n        // ????????????????????????????????????\n        rep(i, 3) repeat(j, i + 1, 4) {\n            int cnt = 0;\n            rep(k, 4) if(k != i and k != j){\n                cnt += ccw(p[i], p[j], p[k]) == COUNTER_CLOCK_WISE;\n            }\n            if(cnt == 2) {\n                swap(p[i + 1], p[j]);\n                break;\n            }\n        } \n    }\n    bool intersect(Segment s) {\n        bool res = false;\n        rep(i, 4) res |= ::intersect(s, Segment(p[i], p[(i + 1) % 4]));\n        return res;\n    }\n    bool contain(Point pp) {\n        bool flg = true;\n        rep(i, 4) flg &= ccw(p[i], p[(i + 1) % 4], pp) == COUNTER_CLOCK_WISE;\n        return flg;\n    }\n    bool contain(Segment s) {\n        return contain(s.a) and contain(s.b);\n    }\n    Point closest_point(Point pp) {\n        Point res = p[0];\n        rep(i, 4) {\n            Point ppp = ::closest_point(Segment(p[i], p[(i+1)%4]), pp);\n            if(distance(res, pp) > distance(ppp, pp)) res = ppp;\n        }\n        return res;\n    }\n    Point closest_point(Segment s) {\n        Point res = p[0];\n        repeat(i, 1, 4) if(distance(s, res) > distance(s, p[i])) res = p[i];\n        for(Point pp : {s.a, s.b}) {\n            Point ppp = closest_point(pp);\n            if(distance(s, res) > distance(s, ppp)) res = ppp;\n        }\n        return res;\n    }\n};\n\n\nclass Solver {\n  public:\n    Segment S;\n    vector<Point> minP, maxP;\n    vector<double> H;\n    bool solve() {\n\n        int N; cin >> N;\n        if(not N) return false;\n        cin >> S;\n        minP.resize(N);\n        maxP.resize(N);\n        H.resize(N);\n        rep(i, N) cin >> minP[i] >> maxP[i] >> H[i];\n        \n        double max_r = INF;\n\n        rep(i, N) {            \n            Rectangle rect({minP[i], maxP[i], Point(minP[i].X(), maxP[i].Y()), Point(maxP[i].X(), minP[i].Y())});\n\n            if(rect.intersect(S) or rect.contain(S)) {\n                cout << 0 << endl;\n                return true;\n            }\n\n            double d = distance(S, rect.closest_point(S));\n            double r = (d * d + H[i] * H[i]) / (2 * H[i]);\n            if(r < H[i]) r = d;\n            set_min(max_r, r);\n        }\n\n        cout << max_r << endl;\n        return true;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-10;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p1;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(!eq(crossProduct(b,c),0.0)) for(;;);\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n//\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tint x=ccw(s.p1,s.p2,pr);\n//\tif(x>=-1&&x<=1) return d;\n\tif(x==0) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t\tbool flg1=(abs(oneLineCCW(q[0],q[1],r))<=1);\n\t\tbool flg2=ccw(q[0],q[1],r)==0;\n\t\tif(flg1!=flg2) assert(0);\n\t//\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\tif(ccw(q[0],q[1],r)==0){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t\tflg1=abs(oneLineCCW(p[0],p[1],r)<=1);\n\t\tflg2=ccw(p[0],p[1],r);\n\t\tif(flg1!=flg2) assert(0);\n\t//\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\tif(ccw(p[0],p[1],r)==0){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tif(eq(abs(s-t),0.0)) for(;;);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tif(eq(abs(e.p1-e.p2),0.0)) for(;;);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//二次元幾何ライブラリ\n#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define ML make_pair \ntypedef long double D;\ntypedef bool B;\ntypedef complex<D> P;   //点\ntypedef complex<D> V;   //ベクトル\ntypedef pair<P,P>  L;   //直線\ntypedef pair<P,D>  C;   //円\ntypedef vector<P>  Pol; //多角形\n\n//変数名定義\nconst D INF = 1e100;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ntemplate<class T> bool operator==(T a, T b){return abs(a - b )< EPS;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n\n\n\n// ベクトルaの絶対値を求める\n// D Length = abs(a);\n\n// 2点a,b間の距離を求める\n// D Distance = abs(a-b); \n\n// 内積 (Inner Product) : a・b = |a||b|cosθ\nD IP(V a, V b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (Exterior Product) : |a×b| = |a||b|sinθ \nD EP(V a, V b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n// 点の進行方向について\nint ccw(P a, P b, P c) {              //点aと点bが与えられた問いに\n  b -= a; c -= a;\n  if (EP(b, c) > 0)   return +1;      // counter clockwise\n  if (EP(b, c) < 0)   return -1;      // clockwise\n  if (IP(b, c) < 0)     return +2;    // c--a--b on line\n  if (norm(b) < norm(c)) return -2;   // a--b--c on line\n  return 0;                           // a--c--b on line  aとbの線分判定はこれ\n}\n\n\n// 2直線の垂直判定 : a⊥b <=> IP(a, b) = 0\nB IsVecular(L l1, L l2) {\n\treturn IP(l1.first-l1.second, l2.first-l2.second)==0.0;\n}\n\n// 2直線の平行判定 : a//b <=> EP(a, b) = 0\nB IsParallel(L l1, L l2) {\n\treturn EP(l1.first-l1.second, l2.first-l2.second)== 0.0;\n}\n\n// 2線分の交差判定 \nB IIS(L l1, L l2) {\n  return ( EP(l1.second-l1.first, l2.first-l1.first) * EP(l1.second-l1.first, l2.second-l1.first) < EPS ) &&\n         ( EP(l2.second-l2.first, l1.first-l2.first) * EP(l2.second-l2.first, l1.second-l2.first) < EPS );\n}\n\n// 符号付き点と直線の距離 (Distance of Point and Line)  //lの構造 x座標 first<second y座標 first<second 左上 正 右下 負 一致 0\nD  DPL(P p,L l){\n\tV v1=(l.second-l.first);\n\tV v2=(p-l.first);\n\treturn EP(v1,v2)/abs(v1);\n}\n\n// 点と線分の距離 (Distance of Point and Segment)  //lの構造 x座標 first<second y座標 first < second \nD  DPS(P p,L l){\n\tV v1,v2,v3;\n\tv1=l.second-l.first;\n\tv2=p-l.first;\n\tv3=p-l.second;\n\tif(IP (v1,v2) <0)\n\t\treturn abs(p-l.first);\n\telse if(IP(-v1,v3)<0)\n\t\treturn abs(p-l.second);\n\telse\n\t\treturn abs(DPL(p,l));\n}\n\n// 線分と線分の距離 (Distance of Segment and Segment)  //lの構造 x座標 first<second y座標 first < second \nD DSS(L l1,L l2){\n\tif(IIS(l1,l2))\n\t\treturn 0;\n\telse{\n\t\tD tem,tem1,tem2;\n\t\ttem1=min(DPS(l1.first,l2),DPS(l1.second,l2));\n\t\ttem2=min(DPS(l2.first,l1),DPS(l2.second,l1));\n\t\treturn\tmin(tem1,tem2);\n\t}\n}\n\n// 三角形の領域判定 Teritory of Triangle 1が内部 0が境界と外部\nB TT(P p1,P p2,P p3,P p){\n\tL l1,l2,l3;\n\tl1=make_pair(p2,p3);\n\tl2=make_pair(p3,p1);\n\tl3=make_pair(p1,p2);\n\n\tif(sig(DPL(p1,l1))!=sig(DPL(p,l1)))\n\t\treturn false;\n\telse if(sig(DPL(p2,l2))!=sig(DPL(p,l2)))\n\t\treturn false;\n\telse if(sig(DPL(p3,l3))!=sig(DPL(p,l3)))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n//変数名 = 型 代入したいもの\n//example : v1 = V(5.0,-3.0) p1=P(0.0,4.0)\nint main(void){\n\twhile(true){\n\tint N;\n\t\tcin >>N; \n\tif(!N)\n\t\tbreak;\n\tD Block[50][2][2];\n\tD h[50];\n\tP root1,root2;\n\tL root;\n\tD r;\n\tD rmin=INF;\n\t\tcin >> root1.real() >> root1.imag() >> root2.real() >> root2.imag();\n\trep(i,N)\n\t\tcin >>Block[i][0][0] >>Block[i][0][1] >> Block[i][1][0] >> Block[i][1][1] >>h[i] ;\n\troot=ML(root1,root2);\n\trep(i,N){\n\t\t\tD tem,tem1,tem2;\n\t\t\tP p1,p2,p3,p4;\n\t\t\tp1=P(Block[i][0][0],Block[i][0][1]);\n\t\t\tp2=P(Block[i][1][0],Block[i][0][1]);\n\t\t\tp3=P(Block[i][1][0],Block[i][1][1]);\n\t\t\tp4=P(Block[i][0][0],Block[i][1][1]);\n\t\t\tL la,lb,lc,ld;\n\t\t\tla=ML(p1,p2);\n\t\t\tlb=ML(p2,p3);\n\t\t\tlc=ML(p3,p4);\n\t\t\tld=ML(p4,p1);\n\t\t\tif(p1.real()<root1.real()&&root1.real()<p3.real()&&p1.imag()<root1.imag()&&root1.imag()<p3.imag())\n\t\t\t\ttem=0;\n\t\t\telse {\n\t\t\t\ttem1=min(DSS(root,la),DSS(root,lb));\n\t\t\t\ttem2=min(DSS(root,lc),DSS(root,ld));\n\t\t\t\ttem=min(tem1,tem2);\n\t\t\t}\n\t\t\tif(tem<=h[i])\n\t\t\t\tr=tem;\n\t\t\telse\n\t\t\t\tr=(h[i]+tem*tem/h[i])/2.0;\n\t\t\tif(rmin > r)\n\t\t\t\trmin=r;\n\t}\n    cout << fixed << rmin << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include <complex>\nusing namespace std;\n\n#define REP(i,a,n) for(int i = a; i < n ; i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\ntypedef complex<double> P;\n\n#define EPS (1e-10)\n\nint n;\nP s,g;\nP p[52][4];\ndouble h[52];\n\ndouble dot(P a,P b){\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(P a,P b){\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint ccw(P a,P b,P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > 0) return +1;\n  if(cross(b,c) < 0) return -1;\n  if(dot(b,c) < 0) return +2;\n  if(abs(b) < abs(c)) return -2;\n  return 0;\n}\n\ndouble distanceSP(P a,P b,P c){\n  if(dot(b-a,c-a) < EPS) return abs(c-a);\n  if(dot(a-b,c-b) < EPS) return abs(c-b);\n  return abs(cross(b-a,c-a)) / abs(b-a);\n}\n\nint inter(P a,P b,P c,P d){\n  return\n    ccw(a,b,c) * ccw(a,b,d) <= 0 &&\n    ccw(c,d,a) * ccw(c,d,b) <= 0;\n}\n\nbool error(int i){\n  P a = p[i][0];\n  P b = p[i][2];\n  if(a.real() <= s.real() && s.real()<= b.real()\n     && a.imag() <= s.imag() && s.imag() <= b.imag()){\n    return true;\n  }\n  if(a.real() <= g.real() && g.real()<= b.real()\n     && a.imag() <= g.imag() && g.imag() <= b.imag()){\n    return true;\n  }\n\n  rep(j,4){\n    if(inter(s,g,p[i][j],p[i][(j+1)%4])){\n      return true;\n    }\n  }\n\n  return false;\n}\n\ndouble calc(double r , double hh){\n  if(r<=hh){\n    return r;\n  }\n  else{\n    return (hh*hh+r*r)/(2*hh);\n  }\n}\n\nvoid solve(){\n  double r = 999999999;\n\n  rep(i,n){\n    if(error(i)){\n      //cout<<\"error \"<<endl;\n      cout<<\"0.0000\"<<endl;\n      return;\n    }\n\n    double minDist = 999999999;\n    rep(j,4){\n      double dist = distanceSP(s,g,p[i][j]);\n      dist = min(dist  ,distanceSP(p[i][j] , p[i][(j+1)%4] , s));\n      dist = min(dist  ,distanceSP(p[i][j] , p[i][(j+1)%4] , g));\n      //            cout<<\"dist\"<<j<<\" \"<<dist<<endl;\n      minDist = min(dist,minDist);\n\n    }\n    r = min(r,calc(minDist,h[i]));\n  }\n  printf(\"%.4f\\n\",r);\n}\n\nint main(){\n  /*\n  P d = P(0,0);\n  P e = P(10,0);\n  P f = P(12,0);\n  P g = P(20,0);\n  cout<<inter(d,e,f,g)<<endl;\n  */\n\n  while(cin>>n && n){\n    cin>>s.real()>>s.imag()>>g.real()>>g.imag();\n\n    rep(i,n){\n      P a,b;\n      cin>>a.real()>>a.imag()>>b.real()>>b.imag()>>h[i];\n      p[i][0] = a;\n      p[i][1] = P(a.real(),b.imag());\n      p[i][2] = b;\n      p[i][3] = P(b.real(),a.imag());\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\n\n#define EPS (1.0e-10)\n#define equal(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\n\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\n\ndouble norm(Vector a) {\n  return a.x*a.x + a.y*a.y;\n}\ndouble abs(Vector a) {\n  return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b) {\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n  return a.x*b.y - a.y*b.x;\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4) {\n  return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool isIntersect(Segment s1, Segment s2) {\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line s, Point p) {\n  return fabs(cross(s.p2 - s.p1, p - s.p1))/abs(s.p2 - s.p1);\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < -EPS) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < -EPS) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n  if(isIntersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\ntypedef Segment Rect;\nSegment course;\nRect block;\ndouble h;\n\ndouble getRadius() {\n  double radius = 99999999;\n  Segment s[4];\n\n  if(block.p1.x < course.p1.x && block.p1.y < course.p1.y &&\n     block.p1.x < course.p2.x && block.p1.y < course.p2.y &&\n     block.p2.x > course.p1.x && block.p2.y > course.p1.y &&\n     block.p2.x > course.p2.x && block.p2.y > course.p2.y ) {\n    return 0.0;\n  }\n\n  s[0].p1 = Point(block.p1.x, block.p1.y);\n  s[0].p2 = Point(block.p2.x, block.p1.y);\n  s[1].p1 = Point(block.p1.x, block.p1.y);\n  s[1].p2 = Point(block.p1.x, block.p2.y);\n  s[2].p1 = Point(block.p1.x, block.p2.y);\n  s[2].p2 = Point(block.p2.x, block.p2.y);\n  s[3].p1 = Point(block.p2.x, block.p1.y);\n  s[3].p2 = Point(block.p2.x, block.p2.y);\n  for(int i = 0; i < 4; ++i) {\n    double d;\n    if(dot(course.p2 - course.p1, s[i].p1 - course.p1) < -EPS && \n       dot(course.p2 - course.p1, s[i].p2 - course.p1) < -EPS ) {\n      d = getDistanceSP(s[i], course.p1);\n    } else if(dot(course.p1 - course.p2, s[i].p1 - course.p2) < -EPS && \n\t      dot(course.p1 - course.p2, s[i].p2 - course.p2) < -EPS ) {\n      d = getDistanceSP(s[i], course.p2);\n    } else {\n      d = getDistance(course, s[i]);\n    }\n    if(d <= h) radius = min(radius, d);\n    else       radius = min(radius, (d*d+h*h)/(2*h));\n  }\n  return radius;\n}\n\nmain() {\n  int N;\n  double maxR;\n\n  while((cin >> N) && N) {\n    maxR = 99999999;\n    cin >> course.p1.x >> course.p1.y >> course.p2.x >> course.p2.y;\n    for(int i = 0; i < N; ++i) {\n      cin >> block.p1.x >> block.p1.y >> block.p2.x >> block.p2.y >> h;\n      maxR = min(maxR, getRadius());\n    }\n    cout <<  maxR << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline point rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\ninline point rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ninline double angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ninline double abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ninline double norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ninline double cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ninline point projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\ninline bool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\ninline bool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ninline bool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline bool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\ninline bool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ninline double dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ninline double dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ninline double dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ninline double dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ninline double dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\ninline double dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ninline point crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn m.a + (m.b - m.a) * cross(l.b - l.a, l.a - m.a) * (1.0 / tmp);\n}\n\ninline point crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\n//先に，intersectを用いて交差判定を行うこと\ninline vector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ninline double areaTriangle(point a, point b, const point& c) {\n\ta = a - c;\n\tb = b - c;\n\treturn fabs(a.x * b.y - b.x * a.y) / 2.0;\n}\n\ninline double area(const polygon& p) {\n\tconst int num = p.size();\n\tif(num < 3)\n\t\treturn 0;\n\n\tif(num == 3)\n\t\treturn areaTriangle(p[0], p[1], p[2]);\n\n\tdouble res = cross(p[num - 1], p[0]);\n\tfor(int i = 1; i < num; ++i)\n\t\tres += cross(p[i - 1], p[i]);\n\n\treturn res * 0.5;\n}\n\n// L.aからL.bの方向を見た場合に，点aが左側に来る．\ninline line bisector(const point& a, const point& b) {\n\treturn line(point((a.x - a.y + b.x + b.y) / 2.0, (a.y + a.x + b.y - b.x) / 2.0),\n\t\t\t\tpoint((a.x + a.y + b.x - b.y) / 2.0, (a.y - a.x + b.y + b.x) / 2.0));\n}\n\n// L.aからL.bを向いた時の左側を残して切断する．\ninline polygon convex_cut(const polygon& p, const line& l) {\n\tconst int num = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < num; ++i) {\n\t\tconst int next = (i + 1) % num;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1)\n\t\t\tres.push_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0)\n\t\t\tres.push_back(crosspoint(l, line(p[i], p[next])));\n\t}\n\n\treturn res;\n}\n\nvector<point> tangent(const circle& c, const point& p) {\n\tconst double x = norm(p - c.c);\n\tdouble d = x - c.r * c.r;\n\tif(d < -EPS) return vector<point>();\n\td = max(d, 0.0);\n\tconst point q1 = (p - c.c) * (c.r * c.r / x);\n\tconst point q2 = rotate90((p - c.c) * (-c.r * sqrt(d) / x));\n\tvector<point> res;\n\tres.push_back(c.c + q1 - q2);\n\tres.push_back(c.c + q1 + q2);\n\treturn res;\n}\n\nvector<line> tangent(const circle &a, const circle& b) {\n\tvector<line> res;\n\tif(abs(a.r - b.r) < EPS) {\n\t\tpoint dir = b.c - a.c;\n\t\tdir = rotate90(dir * (a.r / abs(dir)));\n\t\tres.push_back(line(a.c + dir, b.c + dir));\n\t\tres.push_back(line(a.c - dir, b.c - dir));\n\t}\n\telse {\n\t\tpoint p = a.c * (-b.r) + b.c * a.r;\n\t\tp = p * (1.0 / (a.r - b.r));\n\t\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\t\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\t\tres.push_back(line(ps[i], qs[i]));\n\t}\n\n\tpoint p = a.c * b.r + b.c * a.r;\n\tp = p * (1.0 / (a.r + b.r));\n\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\tres.push_back(line(ps[i], qs[i]));\n\n\treturn res;\n}\n\nconst int MAX_N = 50;\nconst double INF = 2000;\nint n;\ndouble d[MAX_N];\nint h[MAX_N];\n\nbool check(double r) {\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(h[i] >= r) {\n\t\t\tif(d[i] < r)\n\t\t\t\treturn false;\n\t\t}\n\n\t\telse {\n\t\t\tconst double a = r - h[i];\n\t\t\tif(d[i] * d[i] + a * a < r * r)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\twhile(scanf(\"%d\", &n), n) {\n\t\tint sx, sy, ex, ey;\n\t\tscanf(\"%d %d %d %d\", &sx, &sy, &ex, &ey);\n\n\t\tsegment course(point(sx, sy), point(ex, ey));\n\n\t\tfill(d, d + n, INF);\n\t\tbool on = false;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint minX, minY, maxX, maxY;\n\t\t\tscanf(\"%d %d %d %d %d\", &minX, &minY, &maxX, &maxY, &h[i]);\n\n\t\t\tvector<point> points;\n\t\t\tpoints.reserve(4);\n\t\t\tpoints.push_back(point(minX, minY));\n\t\t\tpoints.push_back(point(minX, maxY));\n\t\t\tpoints.push_back(point(maxX, maxY));\n\t\t\tpoints.push_back(point(maxX, minY));\n\n\t\t\tif(minX <= sx && sx <= maxX && minY <= sy && sy <= maxY\n\t\t\t   || minX <= ex && ex <= maxX && minY <= ey && ey <= maxY) {\n\t\t\t\ton = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\n\t\t\tfor(int j = 0; j < 4; ++j) {\n\t\t\t\tconst segment edge(points[j], points[(j + 1) % 4]);\n\t\t\t\tif(intersect(course, edge)) {\n\t\t\t\t\ton = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchmin(d[i], dist(course, points[j]));\n\t\t\t\tchmin(d[i], dist(course, edge));\n\t\t\t}\n\t\t}\n\n\t\tif(on) {\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tdouble low = 0.0, high = 1000.0;\n\t\tfor(int i = 0; i < 1000; ++i) {\n\t\t\tconst double mid = (low + high) / 2;\n\t\t\tif(check(mid))\n\t\t\t\tlow = mid;\n\n\t\t\telse\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\tprintf(\"%.15lf\\n\", low);\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<complex>\n\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define min_int(a,b) ((a)<(b)?(a):(b))\n#define INF 10000 //2^31\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\nusing namespace std;\n\nclass Gio{\nprivate:\n\ttypedef complex<double>point;\n\tstruct line{ \n\t\tpoint st, ed;//始点,終点\n\t};\n\tpoint min_p,max_p;\n\tline orig, test;\n\tdouble min_R;//保存用\n\tdouble test_R;//実行用\n\tdouble dot(point a, point b);//内積\n\tdouble cross(point a, point b);//外積\n\npublic:\n\tGio(double sx, double sy,double ex,double ey);\n\tvoid set_p(point* p, double x, double y);\n\tvoid set_line(line* l, point s, point e);\n\tvoid set_testline(double sx, double sy, double ex, double ey);\n\tvoid calc_r(double sx,double sy,double lx,double ly,double h);\n\tdouble get_r();\n\tdouble get_d_pp();//min_pとmax_pの距離を返す\n\tdouble get_d_lp();//min_pとtestの長さを返す\n\tdouble get_d_ll();//origとtestの長さを返す\n\tbool intersect();//origとtestが交差していればtrue\n};\n\nGio::Gio(double sx, double sy, double ex, double ey){\n\tset_p(&min_p, sx, sy);\n\tset_p(&max_p, ex, ey);\n\tset_line(&orig, min_p, max_p);\n\tmin_R = INF;\n}\nvoid Gio::set_p(point *p, double x, double y){\n\tpoint a(x, y);\n\t*p = a;\n}\nvoid Gio::set_line(line* l, point s, point e){\n\tl->st = s;\n\tl->ed=e;\n}\nvoid Gio::set_testline(double sx,double sy,double ex,double ey){\n\tpoint a, b;\n\tset_p(&a, sx, sy); set_p(&b, ex, ey);\n\tset_line(&test, a, b);\n\t//printf(\"%lf,%lf\\n\", test.st.real(), test.st.imag());\n}\ndouble Gio::dot(point a, point b){\n\treturn(a.real()*b.real() + a.imag()*b.imag());\n}\ndouble Gio::cross(point a, point b){\n\treturn(a.real()*b.imag() - a.imag()*b.real());\n}\ndouble Gio::get_d_pp(){ return(abs(max_p - min_p)); }\ndouble Gio::get_d_lp(){\n\tpoint a = test.st;\n\tpoint b = test.ed;\n\tpoint c = min_p;\n\tif (dot(b - a, c - a) < EPS)return(abs(c - a));\n\tif (dot(a - b, c - b) < EPS)return(abs(c - b));\n\treturn(abs(cross(b - a, c - a)) / abs(b - a));\n}\nbool Gio::intersect(){\n\tpoint a = orig.st, b = orig.ed, c = test.st, d = test.ed;\n\t//printf(\"%lf %lf %lf %lf \\n\",  cross(b - a, d - a), cross(b - a, c - a), cross(d - c, a - c), cross(d - c, b - c));\n\treturn((cross(b - a, c - a)*cross(b - a, d - a) < -EPS) && (cross(d - c, a - c)*cross(d - c, b - c) < -EPS));\n}\n\ndouble Gio::get_d_ll(){\n\tif (intersect())return(0);\n\tpoint a0, a1,b0,b1;\n\ta0 = orig.st;\n\ta1 = orig.ed;\n\tb0 = test.st;\n\tb1 = test.ed;\n\tdouble d1, d2, d3, d4;\n\tmin_p = a0; d1 = get_d_lp();\n\tmin_p = a1; d2 = get_d_lp();\n\tset_line(&test, a0, a1);\n\tmin_p = b0; d3 = get_d_lp();\n\tmin_p = b1; d4 = get_d_lp();\n\td1 = min_int(d1, d2);\n\td2 = min_int(d3, d4);\n\treturn(min_int(d1, d2));\n}\n\nvoid Gio::calc_r(double sx, double sy, double lx, double ly,double h){\n\tdouble d1, d2, d3, d4;\n\tpoint p = orig.st;\n\tif (sx <= p.real() && p.real() <= lx&&sy <= p.imag()&&p.imag() <= ly){\n\t\tmin_R = 0; return;\n\t}\n\n\tset_testline(sx, sy, sx, ly); d1 = get_d_ll();\n\tset_testline(sx, sy, lx, sy); d2 = get_d_ll();\n\tset_testline(sx, ly, lx, ly); d3 = get_d_ll();\n\tset_testline(lx, sy, lx, ly); d4 = get_d_ll();\n\td1 = min_int(min_int(d1, d2), min_int(d3, d4));\n\tif (h >= d1)test_R = d1;\n\telse{\n\t\ttest_R = ((d1*d1 + h*h) / h) / 2;\n\t}\n\tmin_R = min_int(min_R, test_R);\n}\ndouble Gio::get_r(){\n\treturn(min_R);\n}\n\nint b_num;\n\n\n\nint main(void){\n\t//Gio g(1, 1, 2, 2);\n\t//g.set_testline(1, 2, 2, 3);\n\t//cout << g.get_d_ll()<<endl;\n\twhile (true){\n\t\tcin >> b_num;\n\t\tif (b_num == 0)return(0);\n\t\tdouble sx, sy, ex, ey,h;\n\t\tcin >> sx >> sy>>ex >> ey;\n\t\tGio g(sx, sy, ex, ey);\n\t\trep(i, 0, b_num){\n\t\t\tcin >> sx >> sy >> ex >> ey>>h;\n\t\t\tg.calc_r(sx, sy, ex, ey, h);\n\t\t}\n\n\t\tprintf(\"%.6lf\\n\", g.get_r());\n\n\t}\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-6;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<long double> point;\ntypedef pair<point,point> line;\nbool equal(const long double x1,const long double x2){ return abs(x1-x2)<eps; }\nbool equal(const point& a,const point& b){ return equal(a.real(),b.real()) and equal(a.imag(),b.imag()); }\nlong double length(const point& a){ return abs(a); }\nlong double distance(const point& a,const point& b){ return abs(a-b); }\nlong double dot(const point& a,const point& b){ return a.real()*b.real()+a.imag()*b.imag(); }\nlong double cross(const point& a,const point& b){ return a.real()*b.imag()-a.imag()*b.real(); }\nbool is_orthogonal(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(dot(a1-a2,b1-b2),0.0); }\nbool is_orthogonal(const line& l,const line& m){ return is_orthogonal(l.first,l.second,m.first,m.second); }\nbool is_parallel(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(cross(a1-a2, b1-b2),0.0); }\nbool is_parallel(const line& l,const line& m){ return is_parallel(l.first,l.second,m.first,m.second); }\nint ccw(point a,point b,point c) {\n    b-=a; c-=a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\nbool intersectLL(const line& l, const line& m){\n    return abs(cross(l.second-l.first, m.second-m.first)) > eps || // non-parallel\n           abs(cross(l.second-l.first, m.first-l.first)) < eps;   // same line\n}\nbool intersectLS(const line& l, const line& s){\n    return cross(l.second-l.first, s.first-l.first)*       // s.first is left of l\n           cross(l.second-l.first, s.second-l.first) < eps; // s.second is right of l\n}\nbool intersectLP(const line& l, const point& p){\n    return abs(cross(l.second-p, l.first-p)) < eps;\n}\nbool intersectSS(const line& s, const line& t){\n    return ccw(s.first,s.second,t.first)*ccw(s.first,s.second,t.second) <= 0 &&\n           ccw(t.first,t.second,s.first)*ccw(t.first,t.second,s.second) <= 0;\n}\nbool intersectSP(const line& s, const point& p){\n    return abs(s.first-p)+abs(s.second-p)-abs(s.second-s.first) < eps; // triangle inequality\n}\npoint projection(const line& l, const point& p) {\n    long double t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n    return l.first + t*(l.first-l.second);\n}\npoint reflection(const line& l, const point& p){\n    return p+point((projection(l, p) - p).real()*2,(projection(l, p) - p).imag()*2);\n}\nlong double distanceLP(const line &l, const point& p){\n    return abs(p - projection(l, p));\n}\nlong double distanceLL(const line &l, const line &m){\n    return intersectLL(l, m) ? 0 : distanceLP(l, m.first);\n}\nlong double distanceLS(const line &l, const line &s){\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s.first), distanceLP(l, s.second));\n}\nlong double distanceSP(const line &s, const point& p) {\n    const point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s.first - p), abs(s.second - p));\n}\nlong double distanceSS(const line &s, const line &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)),\n             min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(!n) break;\n\n        line l;\n        vector<pair<line,int>> ps;\n\n        long double sx,sy,ex,ey;\n        cin >> sx >> sy >> ex >> ey;\n        l.first=point(sx,sy);\n        l.second=point(ex,ey);\n\n        if(![&](){\n            bool ok=true;\n            rep(i,0,n){\n                long double minx,miny,maxx,maxy,tmp_h;\n                cin >> minx >> miny >> maxx >> maxy >> tmp_h;\n                if(minx<=min(sx,ex) and miny<=min(sy,ey) and max(sx,ex)<=maxx and max(sy,ey)<=maxy) ok=false;\n                const point p1=point(minx,miny),p2=point(minx,maxy),p3=point(maxx,miny),p4=point(maxx,maxy);\n                ps.emplace_back(make_pair(line(p1,p2),tmp_h));\n                ps.emplace_back(make_pair(line(p2,p4),tmp_h));\n                ps.emplace_back(make_pair(line(p4,p3),tmp_h));\n                ps.emplace_back(make_pair(line(p3,p1),tmp_h));\n            }\n            return ok;\n        }()){\n            cout << 0 << endl;\n            continue;\n        }\n\n        auto ok=[&](const long double r){\n            for(const auto &p:ps){\n                const long double d=distanceSS(l,p.first),h=p.second;\n                const point tmp_p=point(0,r);\n                const line tmp_l=line(make_pair(point(d,0),point(d,h)));\n                if(r>distanceSP(tmp_l,tmp_p)) return false;\n            }\n            return true;\n        };\n\n        long double lb=0,ub=2000;\n        rep(i,0,100){\n            long double mid=(lb+ub)/2;\n            if(ok(mid)) lb=mid;\n            else ub=mid;\n        }\n        cout << lb << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-9;\ntemplate<typename T>\nT sqr(T a) { return a * a; }\n\nstruct search_point {\n\tdouble x, y;\n\tdouble h;\n\tsearch_point(double x_, double y_, double h_) {\n\t\tx = x_; y = y_; h = h_;\n\t}\n};\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tdouble sx, sy, ex, ey;\n\t\tvector<search_point> v;\n\t\tvector<pair<search_point,search_point> > line;\n\t\tvector<pair<search_point,search_point> > lect;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tdouble R = 10000;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble h;\n\t\t\tcin >> x0 >> y0 >> x1 >> y1 >> h;\n\n\t\t\tif(h < EPS)\n\t\t\t\th = EPS;\n\n\t\t\tv.push_back(search_point(x0, y0, h));\n\t\t\tv.push_back(search_point(x1, y1, h));\n\t\t\tv.push_back(search_point(x0, y1, h));\n\t\t\tv.push_back(search_point(x1, y0, h));\n\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x0, y0, 0), search_point(x1, y0, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x1, y0, 0), search_point(x1, y1, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x1, y1, 0), search_point(x0, y1, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x0, y1, 0), search_point(x0, y0, 0)));\n\n\t\t\tlect.push_back(pair<search_point,search_point>(search_point(x0, y0, 0), search_point(x1, y1, 0)));\n\n\t\t\tif(x0 < sx && sx < x1) {\n\t\t\t\tv.push_back(search_point(sx, y0, h));\n\t\t\t\tv.push_back(search_point(sx, y1, h));\n\t\t\t}\n\t\t\tif(y0 < sy && sy < y1) {\n\t\t\t\tv.push_back(search_point(x0, sy, h));\n\t\t\t\tv.push_back(search_point(x1, sy, h));\n\t\t\t}\n\t\t\tif(x0 < ex && ex < x1) {\n\t\t\t\tv.push_back(search_point(ex, y0, h));\n\t\t\t\tv.push_back(search_point(ex, y1, h));\n\t\t\t}\n\t\t\tif(y0 < ey && ey < y1) {\n\t\t\t\tv.push_back(search_point(x0, ey, h));\n\t\t\t\tv.push_back(search_point(x1, ey, h));\n\t\t\t}\n\t\t}\n\n\t\tdouble veclx = (ex - sx);\n\t\tdouble vecly = (ey - sy);\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tdouble d;\n\t\t\tdouble mx, my;\n\t\t\tdouble r;\n\n\t\t\tmx = (v[i].x * sqr(veclx) + v[i].y * veclx * vecly + vecly * (sx * ey - sy * ex)) / (sqr(veclx) + sqr(vecly));\n\t\t\tmy = (v[i].y * sqr(vecly) + v[i].x * vecly * veclx + veclx * (sy * ex - sx * ey)) / (sqr(vecly) + sqr(veclx));\n\t\t\t/*\n\t\t\tif((ey - sy) * mx - (ex - sx) * my + (ex * sy - sx * ey) > EPS) {\n\t\t\t\tcout << \"error\" << \" \" << (sy - ey) * mx - (sx - ex) * my - (ex * sy - sx * ey) << endl;\n\t\t\t\tcout << mx << \",\" << my << endl;\n\t\t\t}\n\t\t\t// */\n\t\t\td = sqrt(sqr(mx - v[i].x) + sqr(my - v[i].y));\n\t\t\tif(mx <= min(sx,ex) || max(sx,ex) <= mx || my <= min(sy,ey) || max(sy,ey) <= my) {\n\t\t\t\td = min(sqrt(sqr(sx - v[i].x) + sqr(sy -  v[i].y)), sqrt(sqr(ex - v[i].x) + sqr(ey - v[i].y)));\n\t\t\t}\n\t\t\tr = fabs(sqr(min(v[i].h,d)) + sqr(d)) / (2 * v[i].h);\n\t\t\tR = min(R, r);\n\t\t}\n\t\tfor(int i = 0; i < line.size(); i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble s, t;\n\t\t\tx0 = line[i].first.x; y0 = line[i].first.y;\n\t\t\tx1 = line[i].second.x; y1 = line[i].second.y;\n\n\t\t\ts = ((ex - sx) * (y1 - sy) - (ey - sy) * (x1 - sx)) / ((x0 - sx) * (y1 - sy) - (y0 - sy) * (x1 - sx));\n\t\t\tt = ((ex - sx) * (y0 - sy) - (ey - sy) * (x0 - sx)) / ((x1 - sx) * (y0 - sy) - (y1 - sy) * (x0 - sx));\n\n\t\t\tif(isnan(s) || isnan(t))\n\t\t\t\texit(1);\n\n\t\t\tif(s > 0 && t > 0 && s + t >= 1)\n\t\t\t\tR = 0;\n\t\t}\n\t\tfor(int i = 0; i < lect.size(); i++) {\n\t\t\tbool flag0, flag1;\n\t\t\tflag0 = lect[i].first.x < sx && sx < lect[i].second.x && lect[i].first.y < sy && sy < lect[i].second.y;\n\t\t\tflag1 = lect[i].first.x < ex && ex < lect[i].second.x && lect[i].first.y < ey && ey < lect[i].second.y;\n\n\t\t\tif(flag0 | flag1)\n\t\t\t\tR = 0;\n\t\t}\n\t\tprintf(\"%.10f\\n\", R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ntypedef vector<P> G;\n\nbool contains(const P p, const G g) {\n  REP(i,g.size())\n    if (ccw(g[i],g[(i+1)%g.size()], p) != -1)\n      return 0;\n  return 1;\n}\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    P s(sx,sy), e(ex,ey);\n    L l(s,e);\n    G rect[n];\n    int h[n];\n    bool f = 0;\n    REP(i,n) {\n      int x1,y1,x2,y2;\n      cin>>x1>>y1>>x2>>y2>>h[i];\n      rect[i].push_back(P(x1,y1));\n      rect[i].push_back(P(x1,y2));\n      rect[i].push_back(P(x2,y2));\n      rect[i].push_back(P(x2,y1));\n\n      REP(j,4) {\n        if (intersectSS(l, L(rect[i][j], rect[i][(j+1)%4]))) // R[XãÉubNª éB\n          f = 1;\n      }\n      if (contains(s,rect[i]))  // ubNªR[XðÜÞB\n        f = 1;\n    }\n    if (f) {\n      puts(\"0.0000\");\n//      cout << 0 << endl;\n      continue;\n    }\n    double ans = INF;\n\n    // R[XÆubNÌÓÆÌ£ÌÅZðßéB\n    REP(i,n) {\n      REP(j,4) {\n        double d = distanceSS(l, L(rect[i][j], rect[i][(j+1)%4]));\n        if (h[i] >= d)\n          ans = min(ans, d);\n        else\n          ans = min(ans, (d*d+h[i]*h[i])/(2*h[i]));\n      }\n    }\n    printf(\"%.5f\\n\", ans);\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={1,0,-1,-1,-1,0,1,1};\nint dy[]={1,1,1,0,-1,-1,-1,0};\n\ndouble block[55][4];\ndouble h[55];\nint n;\ndouble sx,sy,ex,ey;\n\ndouble min_d2(double x0,double y0,double x1,double y1,double x2,double y2) {\n    double a = x2 - x1;\n    double b = y2 - y1;\n    double a2 = a * a;\n    double b2 = b * b;\n    double r2 = a2 + b2;\n    double tt = -(a*(x1-x0)+b*(y1-y0));\n    if( tt < 0 ) {\n        return ( (x1-x0)*(x1-x0) + (y1-y0)*(y1-y0) );\n    }\n    if( tt > r2 ) {\n        return ( (x2-x0)*(x2-x0) + (y2-y0)*(y2-y0) );\n    }\n    double f1 = a*(y1-y0)-b*(x1-x0);\n    return ( (f1*f1)/r2 );\n}\n\nbool judgeIenter(double ax,double ay,double bx,double by,double cx,double cy,double dx,double dy) {\n    double ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n    double tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n    double tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n    double td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\n    return (tc * td < 0 && ta * tb < 0);\n    // return tc * td <= 0 && ta * tb <= 0; // 端点を含む場合\n}\n\ndouble dist(int m){\n    bool flag = false;\n    double b[4];\n    for(int k = 0;k < 4;k++) b[k] = block[m][k];\n    flag = ( judgeIenter(sx,sy,ex,ey,b[0],b[1],b[0],b[3]) || flag );\n    flag = ( judgeIenter(sx,sy,ex,ey,b[0],b[1],b[2],b[1]) || flag );\n    flag = ( judgeIenter(sx,sy,ex,ey,b[0],b[3],b[2],b[3]) || flag );\n    flag = ( judgeIenter(sx,sy,ex,ey,b[2],b[1],b[2],b[3]) || flag );\n    if(flag)return 0;\n    double ret = min_d2(b[0],b[1],sx,sy,ex,ey);\n    ret = min(ret,min_d2(b[0],b[3],sx,sy,ex,ey));\n    ret = min(ret,min_d2(b[2],b[1],sx,sy,ex,ey));\n    ret = min(ret,min_d2(b[2],b[3],sx,sy,ex,ey));\n\n    ret = min(ret,min_d2(sx,sy,b[0],b[1],b[0],b[3]));\n    ret = min(ret,min_d2(sx,sy,b[0],b[1],b[2],b[1]));\n    ret = min(ret,min_d2(sx,sy,b[0],b[3],b[2],b[3]));\n    ret = min(ret,min_d2(sx,sy,b[2],b[1],b[2],b[3]));\n\n    ret = min(ret,min_d2(ex,ey,b[0],b[1],b[0],b[3]));\n    ret = min(ret,min_d2(ex,ey,b[0],b[1],b[2],b[1]));\n    ret = min(ret,min_d2(ex,ey,b[0],b[3],b[2],b[3]));\n    ret = min(ret,min_d2(ex,ey,b[2],b[1],b[2],b[3]));\n    return sqrt(ret);\n}\n\nint main(){\n    \n    while(true){\n        cin >> n;\n        if(n == 0)break;\n        cin >> sx >> sy >> ex >> ey;\n        if(sx > ex){\n            int tmpx = sx,tmpy = sy;\n            sx = ex;\n            sy = ey;\n            ex = tmpx;\n            ey = tmpy;\n        }\n        for(int i = 0;i < n;i++){\n            for(int j = 0;j < 4;j++){\n                cin >> block[i][j];\n            }\n            cin >> h[i];\n        }\n        double ans = 1000;\n        for(int i = 0;i < n;i++){\n            double d = dist(i);\n    //        cout << i << \":\" << d << endl;\n            if(d == 0){\n                ans = 0;\n                break;\n            }\n            if(block[i][0] <= sx && block[i][2] >= ex && block[i][1] <= min(sy,ey) && block[i][3] >= max(sy,ey)){\n                ans = 0;\n                break;\n            }\n            double tmpans;\n            if(d <= h[i]){\n                tmpans = d;\n            }else{\n                tmpans = (d*d + h[i]*h[i]) / (2*h[i]);\n            }\n            if(ans > tmpans) ans = tmpans;\n        }\n        printf(\"%f\\n\",ans);\n    //    cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    int y, x;\n    Point(){\n        y = x = 0;\n    }\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2.0) + pow(x - p.x, 2.0));\n    }\n    int dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cos慮\n    }\n    int cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sin慮\n    }\n};\n\ndouble segmentPointDist(const Point& a1, const Point& a2, const Point& p)\n{\n    if((a2-a1).dot(p-a1) < 0)\n        return a1.dist(p);\n    else if((a1-a2).dot(p-a2) < 0)\n        return a2.dist(p);\n    else\n        return abs((a2-a1).cross(p-a1)) / a1.dist(a2);\n}\n\ndouble segmentsDist(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(((a2-a1).cross(b1-a1) * (long long)(a2-a1).cross(b2-a1) < 0) && ((b2-b1).cross(a1-b1) * (long long)(b2-b1).cross(a2-b1) < 0))\n        return 0.0;\n\n    double ret = segmentPointDist(a1, a2, b1);\n    ret = min(ret, segmentPointDist(a1, a2, b2));\n    ret = min(ret, segmentPointDist(b1, b2, a1));\n    ret = min(ret, segmentPointDist(b1, b2, a2));\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        Point s, e;\n        cin >> s.x >> s.y >> e.x >> e.y;\n\n        vector<vector<Point> > p(n, vector<Point>(4));\n        vector<int> h(n);\n        double ret = DBL_MAX;\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<2; ++j)\n                cin >> p[i][j*2].x >> p[i][j*2].y;\n            cin >> h[i];\n\n            p[i][1] = Point(p[i][0].y, p[i][2].x);\n            p[i][3] = Point(p[i][2].y, p[i][0].x);\n\n            if(p[i][0].x <= s.x && s.x <= p[i][2].x && p[i][0].y <= s.y && s.y <= p[i][2].y)\n                ret = 0.0;\n        }\n\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<4; ++j){\n                double d = segmentsDist(s, e, p[i][j], p[i][(j+1)%4]);\n                if(d < EPS){\n                    ret = 0.0;\n                }else{\n                    double r = (pow(h[i], 2.0) + pow(d, 2.0)) / (2 * h[i]);\n                    ret = min(ret, r);\n                }\n            }\n        }\n\n        printf(\"%.10f\\n\", ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\ntypedef pair<P,double> C;\n\nconst double PI = acos(-1);\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)==real(b)?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\n//for vector\n\ndouble dot(P x,P y){return real(conj(x)*y);}\n\ndouble cross(P x,P y){return imag(conj(x)*y);}\n\n//for line(segment)\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nbool orth(L a,L b){return abs(dot(a.fs-a.sc,b.fs-b.sc))<EPS;}\n\nbool para(L a,L b){return abs(cross(a.fs-a.sc,b.fs-b.sc))<EPS;}\n\ndouble seg_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nP seg_cp(L a,L b){\n  double d = abs(cross(b.sc-b.fs,a.fs-b.fs));\n  return a.fs + (a.sc-a.fs)*( d /(d + abs(cross(b.sc-b.fs,a.sc-b.fs))) );\n}\n\ndouble seg_close(L a, L b){\n  double res = 1e10;\n  res = min(res, seg_dis(a,b.first));\n  res = min(res, seg_dis(a,b.second));\n  res = min(res, seg_dis(b,a.first));\n  res = min(res, seg_dis(b,a.second));\n  return res;\n}\n\nint main(){\n  int n,sx,sy,ex,ey;\n  int x1,y1,x2,y2,h;\n\n  while(cin >> n ,n){\n    cin >> sx >> sy >> ex >> ey;\n    L l = L(P(sx,sy),P(ex,ey));\n\n    double r = 100000.0;\n    for(int i=0;i<n;i++){\n      cin >> x1 >> y1 >> x2 >> y2 >> h;\n      if(x1>x2)swap(x1,x2);\n      if(y1>y2)swap(y1,y2);\n      if(r<EPS)continue;\n      P a = P(x1,y1);\n      P b = P(x1,y2);\n      P c = P(x2,y2);\n      P d = P(x2,y1);\n      L A = L(a,b);\n      L B = L(b,c);\n      L C = L(c,d);\n      L D = L(d,a);\n\n      if(is_cp(l,A))r = 0.0;\n      else if(is_cp(l,B))r = 0.0;\n      else if(is_cp(l,C))r = 0.0;\n      else if(is_cp(l,D))r = 0.0;\n      else if(x1<=sx && sx<=x2 && y1<=sy && sy<=y2)r = 0.0;\n      else{\n\tdouble dis = min(min(seg_close(l,A),seg_close(l,B)),\n\t\t\t min(seg_close(l,C),seg_close(l,D)));\n\tif(dis<h)r = min(r,dis);\n\telse r = min(r,(h*h+dis*dis)/(2*h));\n      }\n    }\n    cout << r << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-8;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// ベクトル演算\ndouble dot(P a, P b) {return (a.real()*b.real()+a.imag()*b.imag());}\t// 内積\ndouble cross(P a, P b) {return (a.real()*b.imag()-a.imag()*b.real());}\t// 外積\nbool orth(P a1, P a2, P b1, P b2) {return deq(dot(a1-a2,b1-b2),0.0);}\t// 直交\nbool para(P a1, P a2, P b1, P b2) {return deq(cross(a1-a2,b1-b2),0.0);}\t// 平行\nbool pol(P a, P b, P c) {return deq(cross(b-a,c-a),0.0);}\t// 点cが直線ab上にあるかどうか\nbool pols(P a, P b, P c) {return (abs(a-c)+abs(c-b)<abs(a-b)+eps);}\t// 点cが線分ab上にあるかどうか\nbool intls(P a1, P a2, P b1, P b2) {\t// 線分a1a2と線分b1b2の交差判定\n\treturn (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<eps)\n\t\t   && (cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<eps);}\nP pintl(P a1, P a2, P b1, P b2) {\t// 直線a1a2と直線b1b2の交点 (要交差判定)\n\tP a = a2-a1, b = b2-b1;\n\treturn a1+a*cross(b,b1-a1)/cross(b,a);}\nP pintls(P a1, P a2, P b1, P b2) {\t// 線分a1a2と線分b1b2の交点 (〃)\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b,a1-b1)), d2 = abs(cross(b,a2-b1)), t = d1/(d1+d2);\n\treturn a1+(a2-a1)*t;}\ndouble disl(P a, P b, P c) {return abs(cross(b-a,c-a))/abs(b-a);}\t// 点cと直線abとの距離\ndouble disls(P a, P b, P c) {\t// 点cと線分abとの距離\n\tif (dot(b-a,c-a)<eps) return abs(c-a);\n\tif (dot(a-b,c-b)<eps) return abs(c-b);\n\treturn abs(cross(b-a,c-a))/abs(b-a);}\ndouble dislss(P a1, P a2, P b1, P b2) {\t// 線分a1a2と線分b1b2の距離\n\tif (intls(a1,a2,b1,b2)) return 0;\n\tdouble a = min(disls(a1,a2,b1),disls(a1,a2,b2)), b = min(disls(b1,b2,a1),disls(b1,b2,a2));\n\treturn min(a,b);}\n\nint n, xl[50], yl[50], xr[50], yr[50], h[50];\ndouble d[50];\nP s, g;\n\nbool ok(double r) {\n\trep(i,n) {\n\t\tif (r<=h[i] && d[i]<r) return false;\n\t\telse if (h[i]<r) {\n\t\t\tdouble t = sqrt(d[i]*d[i] + (r-h[i])*(r-h[i]));\n\t\t\tif (t<r) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\tdouble sx, sy, gx, gy;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\ts = P(sx,sy), g = P(gx,gy);\n\t\trep(i,n) {\n\t\t\tcin >> xl[i] >> yl[i] >> xr[i] >> yr[i] >> h[i];\n\t\t\tP p1 = P(xl[i],yl[i]), p2 = P(xr[i],yl[i]), p3 = P(xr[i],yr[i]), p4 = P(xl[i],yr[i]);\n\t\t\tdouble a = min(dislss(p1,p2,s,g), dislss(p2,p3,s,g)), b = min(dislss(p3,p4,s,g), dislss(p4,p1,s,g));\n\t\t\td[i] = min(a,b);\n\t\t\tif (intls(p1,p3,s,g) || intls(p2,p4,s,g)) d[i] = 0;\n\t\t}\n\t\tdouble l = 0, r = 1001;\n\t\trep(i,100) {\n\t\t\tdouble m = (l+r)/2;\n\t\t\tif (ok(m)) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tprintf(\"%.14lf\\n\",l);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1e-8\n#define INF 1e8\n\ntypedef complex<double> Point;\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tPoint operator / (const Point &p, const double &a){\n\t\treturn Point(real(p)/a, imag(p)/a);\n\t}\n\tPoint operator * (const Point &p, const double &a){\n\t\treturn Point(real(p)*a, imag(p)*a);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn real(a) == real(b) && real(a) == real(b);\n\t}\n}\n\n\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point>{\n\tLine(){}\n\tLine(const Point &a, const Point &b){\n\t\tpush_back(a); push_back(b);\n\t}\n};\nstruct Circle{\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &c, double r):c(c),r(r){}\n};\n\ndouble dot(const Point &a, const Point &b){\n\treturn real(conj(a) * b);\n}\n\ndouble cross(const Point &a, const Point &b){\n\treturn imag(conj(a)*b);\n}\n\nPoint projection(const Line &l, const Point &p){\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t * (l[0]-l[1]);\n}\n\nint ccw(Point a, Point b, Point c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > 0) return +1;\n\tif(cross(b,c) < 0) return -1;\n\tif(dot(b,c) < 0) return +2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\ndouble distancePP(const Point &a, const Point &b){\n\treturn abs(a-b);\n}\n\nbool intersectSS(const Line &s, const Line &t){\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\t\t\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const Line &s, const Point &p){\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1]-s[0]) < EPS;\n}\n\ndouble distanceSP(const Line &s, const Point &p){\n\tconst Point r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r-p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\nbool intersectLL(const Line &l, const Line &m){\n\treturn abs(cross(l[1]-l[0], m[1]-m[0])) > EPS ||\n\t\t\t\t\tabs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n\nbool inPolygon(const Polygon &g, const Point &p){\n\tdouble sum = 0.0;\n\tint n = g.size();\n\tfor(int i = 0; i < g.size(); i++){\n\t\tint j = (i+1)%n;\n\t\tif(intersectSP(Line(g[i], g[j]), p)) return true;\n\t\tsum += arg((g[j]-p)/(g[i]-p));\n\t}\n\treturn abs(sum) > 1;\n}\n\nint main(void){\n\tint N;\n\twhile(cin >> N, N){\n\t\tint miss = 0;\n\t\tdouble sx, sy, ex, ey;\n\t\tvector<Point> ps(N, INF);\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tLine root = Line(Point(sx, sy), Point(ex, ey));\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tdouble ax, ay, bx, by, h;\n\t\t\tdouble d = INF;\n\t\t\tcin >> ax>>ay>>bx>>by>>h;\n\t\t\tPolygon g;\n\t\t\tg.push_back(Point(ax,ay));\n\t\t\tg.push_back(Point(bx,ay));\n\t\t\tg.push_back(Point(bx,by));\n\t\t\tg.push_back(Point(ax,by));\n\t\t\t//内部判定\n\t\t\tif(inPolygon(g, root[0]) && inPolygon(g, root[1])) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(ax, ay), Point(bx, ay)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(bx, ay), Point(bx, by)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(bx, by), Point(ax, by)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(ax, by), Point(ax, ay)))) miss = 1;\n\t\t\tif(miss) break;\n\t\t\t\n\t\t\t//最小距離\n\t\t\td = min(d, distanceSP(root, Point(ax, ay)));\n\t\t\td = min(d, distanceSP(root, Point(bx, by)));\n\t\t\td = min(d, distanceSP(root, Point(ax, by)));\n\t\t\td = min(d, distanceSP(root, Point(bx, ay)));\n\n\t\t\td = min(d, distanceSP(Line(Point(ax, ay), Point(bx, ay)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(ax, ay), Point(bx, ay)), root[1]));\n\n\t\t\td = min(d, distanceSP(Line(Point(bx, ay), Point(bx, by)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(bx, ay), Point(bx, by)), root[1]));\n\n\t\t\td = min(d, distanceSP(Line(Point(bx, by), Point(ax, by)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(bx, by), Point(ax, by)), root[1]));\n\n\t\t\td = min(d, distanceSP(Line(Point(ax, by), Point(ax, ay)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(ax, by), Point(ax, ay)), root[1]));\n\n\t\t\tps[i] = Point(d, h);\n\t\t}\n\t\tif(miss){\n\t\t\tcout << \"0\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble left = 0, right = 10000;\n\t\tdouble ans = 0;\n\t\twhile(right - left > EPS){\n\t\t\tdouble mid = (left + right) / 2;\n\t\t\tdouble ret = INF;\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tret = min(ret, distancePP(Point(0, mid), ps[i]));\n\t\t\t}\n\t\t\tif(ret <= mid + EPS) right = mid;\n\t\t\telse ans = ret, left = mid;\n//\t\t\tprintf(\"%.4lf -> ret:ans = [%.4lf : %.4lf]\\n\", mid, ret, ans);\n\t\t}\n\t\tprintf(\"%.9lf\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\ntypedef double Num;\ntypedef complex<Num> Pt2;\ntypedef vector<Pt2>  Polygon2;\n\nstruct Line2 : public vector<Pt2> {\n\tLine2(Pt2 a, Pt2 b) { push_back(a); push_back(b); }\n};\n\nconst double eps = 1e-10;\nNum  dot  (Pt2 a, Pt2 b) { return (a*conj(b)).real(); }\nNum  cross(Pt2 a, Pt2 b) { return (conj(a)*b).imag(); }\nPt2  vec  (Line2 l)      { return l[1]-l[0]; }\n\nint ccw(Pt2 a, Pt2 b, Pt2 c) {\n\tb-=a; c-=a;\n\tif(cross(b,c) > 0 ) return +1; // ccw\n\tif(cross(b,c) < 0 ) return -1; // cw\n\tif(  dot(b,c) < 0 ) return +2; // cab\n\tif(norm(b)<norm(c)) return -2; // abc\n\treturn 0;                      // acb\n}\n\nint ccw(Line2 s, Pt2 p) {\n\treturn ccw(s[0], s[1], p);\n}\n\nbool intersectSP(Line2 s, Pt2 p) {\n\treturn abs(s[0]-p)+abs(s[1]-p) < abs(s[1]-s[0])+eps;\n}\n\nbool intersectSS(Line2 s, Line2 t) {\n\treturn ccw(s,t[0])*ccw(s,t[1]) <= 0 \n\t    && ccw(t,s[0])*ccw(t,s[1]) <= 0;\n}\n\nPt2 projection(Line2 l, Pt2 p) {\n  double t = dot(p-l[0], vec(l)) / norm(vec(l));\n  return l[0] + t*(vec(l));\n}\n\nPt2 reflection(Line2 l, Pt2 p) {\n\treturn p + 2.0*(projection(l,p) - p);\n}\n\nNum distanceSP(Line2 s, Pt2 p) {\n  Pt2 r = projection(s,p);\n  if(intersectSP(s,r)) return abs(r-p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\nNum distanceSS(Line2 s, Line2 t) {\n  if(intersectSS(s,t)) return 0;\n  return min(min(distanceSP(s,t[0]), distanceSP(s,t[1])),\n             min(distanceSP(t,s[0]), distanceSP(t,s[1])));\n}\n\nbool convex_contains(Polygon2 g, Pt2 p)\n{\n\tfor(int i=0; i<g.size(); i++)\n\t{\n\t\tif(ccw(Line2(g[i],g[(i+1)%g.size()]), p)==-1) return false;\n\t}\n\treturn true;\n}\n\ndouble dist(Line2 s, Line2 t, double h) {\n\tdouble d=distanceSS(s,t);\n\tif(d<=h) return d;\n\treturn (d*d+h*h)/(2*h);\n}\n\n\nint main()\n{\n\tint N;\n\twhile(cin>>N, N)\n\t{\n\t\tNum x1,y1,x2,y2,h;\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tLine2 course(Pt2(x1,y1),Pt2(x2,y2));\n\n\t\tdouble ans=1e10;\n\t\twhile(N--)\n\t\t{\t\t\n\t\t\tcin>>x1>>y1>>x2>>y2>>h;\n\t\t\tPolygon2 g(4);\n\t\t\tg[0]=Pt2(x1,y2); g[3]=Pt2(x2,y2);\n\t\t\tg[1]=Pt2(x1,y1); g[2]=Pt2(x2,y1);\n\n\t\t\tif(convex_contains(g,course[0]) || convex_contains(g,course[1]))\n\t\t\t{\n\t\t\t\tans=0;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<g.size(); i++)\n\t\t\t{\n\t\t\t\tans = min(ans, dist(course,Line2(g[i],g[(i+1)%g.size()]),h));\n\t\t\t}\n\n\t\t\tif(ans==0) break;\n\t\t}\n\t\tcout.setf(ios::fixed);\n\t\tcout.precision(5);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <iostream>\n\nusing namespace std;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\ntypedef double ld;\nconst ld EPS=1e-5;\n\nstruct Point{\n\tPoint(ld x,ld y):x(x), y(y){}\n\tPoint(){}\n\tld x,y;\n};\n\nPoint operator+(const Point &a, const Point &b){\n\treturn Point(a.x+b.x, a.y+b.y);\n}\n\nPoint operator-(const Point &a, const Point &b){\n\treturn Point(a.x-b.x, a.y-b.y);\n}\n\nPoint operator*(const Point &a, const ld b){\n\treturn Point(a.x*b, a.y*b);\n}\n\nld cross(const Point &a, const Point &b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nld dot(const Point &a, const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\nld norm(const Point &a){\n\treturn dot(a,a);\n}\n\nld abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nstruct Line:vector<Point>{\n\tLine(Point a = Point(0,0), Point b = Point(0,0)){\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n};\n\nint ccw(Point a, Point b, Point c){\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b,c) > EPS) return 1;\n\tif(cross(b,c) < -EPS) return -1;\n\tif(dot(b,c) < 0) return 2;\n\tif(norm(b)<norm(c)) return -2;\n\treturn 0;\n}\n\nbool is_intersect_SS(const Line &s, const Line &t){\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nbool is_intersect_SP(const Line &l, const Point &p){\n\treturn ccw(l[0],l[1],p)==0;\n}\n\nPoint projection(const Line &l, const Point &p){\n\tld t = dot(p-l[0],l[1]-l[0])/norm(l[0]-l[1]);\n\treturn l[0]+(l[1]-l[0])*t;\n}\n\nld distance_SP(const Line &s, const Point &p){\n\tconst Point r = projection(s,p);\n\tif(is_intersect_SP(s,r))return abs(r-p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\nld distance_SS(const Line &s, const Line &t){\n\tif(is_intersect_SS(s,t)) return 0;\n\treturn min(min(distance_SP(s,t[0]),distance_SP(s,t[1])),min(distance_SP(t,s[0]),distance_SP(t, s[1])));\n}\n\nbool lt(ld x, ld y){\n\treturn x < y+EPS;\n}\n\nint n;\nLine L;\nLine data[100];\nint H[100];\n\nld Max;\n\nvoid input(){\n\tint w, x, y, z;\n\tMax = 1e10;\n\tscanf(\"%d%d%d%d\", &w, &x, &y, &z);\n\tL = Line(Point(w,x), Point(y,z));\n\tfor(int i = 0 ; i< n;i++){\n\t\tscanf(\"%d%d%d%d%d\", &w, &x, &y, &z, &H[i]);\n\t\tdata[i] = Line(Point(w,x), Point(y,z));\n\t}\n}\n\nvoid process(){\n\tld minX = min(L[0].x, L[1].x);\n\tld minY = min(L[0].y, L[1].y);\n\tld maxX = max(L[0].x, L[1].x);\n\tld maxY = max(L[0].y, L[1].y);\n\t//Check rect & line\n\tfor(int i = 0; i < n;i++){\n\t\tif(is_intersect_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][0].x, data[i][1].y))) ||\n\t\t\tis_intersect_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][1].x, data[i][0].y))) ||\n\t\t\tis_intersect_SS(L, Line(Point(data[i][0].x, data[i][1].y), Point(data[i][1].x, data[i][1].y))) ||\n\t\t\tis_intersect_SS(L, Line(Point(data[i][1].x, data[i][0].y), Point(data[i][1].x, data[i][1].y)))) {\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif(lt(data[i][0].x , minX) && lt(data[i][0].y , minY) && lt(maxX , data[i][1].x) && lt(maxY , data[i][1].y)) {\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t//get r;\n\tfor(int i = 0; i < n; i++) {\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][0].x, data[i][1].y)));\n\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\tif(lt(r, Max)) Max = r;\n\t\t}\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][1].x, data[i][0].y)));\n\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\tif(lt(r,Max)) Max = r;\n\t\t}\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][0].x, data[i][1].y), Point(data[i][1].x, data[i][1].y)));\n\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\tif(lt(r,Max)) Max = r;\n\t\t}\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][1].x, data[i][0].y), Point(data[i][1].x, data[i][1].y)));\n\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\tif(lt(r,Max)) Max = r;\n\t\t}\n\t}\n\tprintf(\"%lf\\n\", Max);\n}\n\nint main() {\n\twhile(true){\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tinput();\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> P;\nconst int MAX_N = 59;\nint N;\ndouble SX, SY, GX, GY;\ndouble minx[MAX_N], maxx[MAX_N], miny[MAX_N], maxy[MAX_N], hs[MAX_N], ds[MAX_N];\nP S, G;\n\nconst double EPS = 1e-12;\n\ndouble sq(double x){ return x*x; }\n\nint sig(double a){\n\treturn a==0?0:a>0?1:-1;\n}\n\ndouble iprod(P p1, P p2){\n\treturn (p1.real()*p2.real()) + (p1.imag()*p2.imag());\n}\n\ndouble oprod(P p1, P p2){\n\treturn (p1.real()*p2.imag()) - (p1.imag()*p2.real());\n}\n\ndouble disLP(P p1, P p2, P q){\n\treturn abs( oprod( (p2-p1), (q-p1) ) ) / abs(p2-p1);\n}\n\ndouble disSP(P p1, P p2, P q){\n\tif(iprod( (p2-p1), (q-p1) ) < 0) return abs(q-p1);\n\tif(iprod( (p1-p2), (q-p2) ) < 0) return abs(q-p2);\n\treturn disLP(p1, p2, q);\n}\n\nbool crsSS(P p1, P p2, P q1, P q2){\n\tif(max(p1.real(), p2.real()) + EPS < min(q1.real(), q2.real())) return false;\n\tif(max(q1.real(), q2.real()) + EPS < min(p1.real(), p2.real())) return false;\n\tif(max(p1.imag(), p2.imag()) + EPS < min(q1.imag(), q2.imag())) return false;\n\tif(max(p1.imag(), p2.imag()) + EPS < min(q1.imag(), q2.imag())) return false;\n\treturn sig(oprod(p2-p1, q1-p1)) * sig(oprod(p2-p1, q2-p1)) < EPS\n\t\t&& sig(oprod(q2-q1, p1-q1)) * sig(oprod(q2-q1, p2-q1)) < EPS;\n}\n\n\nbool init(){\n\tfor(int i=0; i<N; i++){\n\t\tif(crsSS(S,G,P(minx[i],miny[i]),P(minx[i],maxy[i])) ||\n\t\t\tcrsSS(S,G,P(minx[i],miny[i]),P(maxx[i],miny[i])) || \n\t\t\tcrsSS(S,G,P(maxx[i],maxy[i]),P(minx[i],maxy[i])) || \n\t\t\tcrsSS(S,G,P(maxx[i],maxy[i]),P(maxx[i],miny[i]))){\n\t\t\treturn false;\n\t\t}\n\t\tif(minx[i] <= SX && SX <= maxx[i] && miny[i] <= SY && SY <= maxy[i]){\n\t\t\treturn false;\n\t\t}\n\t\tif(minx[i] <= GX && GX <= maxx[i] && miny[i] <= GY && GY <= maxy[i]){\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor(int i=0; i<N; i++){\n\t\tds[i] = 1e10;\n\t\tds[i] = min(ds[i], disSP(S,G,P(minx[i],miny[i])));\n\t\tds[i] = min(ds[i], disSP(S,G,P(minx[i],maxy[i])));\n\t\tds[i] = min(ds[i], disSP(S,G,P(maxx[i],miny[i])));\n\t\tds[i] = min(ds[i], disSP(S,G,P(maxx[i],maxy[i])));\n\n\t\tds[i] = min(ds[i], disSP(P(minx[i],miny[i]),P(minx[i],maxy[i]),S));\n\t\tds[i] = min(ds[i], disSP(P(minx[i],miny[i]),P(maxx[i],miny[i]),S));\n\t\tds[i] = min(ds[i], disSP(P(maxx[i],maxy[i]),P(minx[i],maxy[i]),S));\n\t\tds[i] = min(ds[i], disSP(P(maxx[i],maxy[i]),P(maxx[i],miny[i]),S));\n\n\t\tds[i] = min(ds[i], disSP(P(minx[i],miny[i]),P(minx[i],maxy[i]),G));\n\t\tds[i] = min(ds[i], disSP(P(minx[i],miny[i]),P(maxx[i],miny[i]),G));\n\t\tds[i] = min(ds[i], disSP(P(maxx[i],maxy[i]),P(minx[i],maxy[i]),G));\n\t\tds[i] = min(ds[i], disSP(P(maxx[i],maxy[i]),P(maxx[i],miny[i]),G));\n\t}\n\n\treturn true;\n}\n\nbool check(double r){\n\tfor(int i=0; i<N; i++){\n\t\tif(ds[i] < sqrt(sq(r) - sq(r-min(r,hs[i])))){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble solve(){\n\tif(!init()){\n\t\treturn 0;\n\t}\n\tdouble low = 0.0, high = 1009;\n\tfor(int i=0; i<100; i++){\n\t\tdouble mid = (low + high)*0.5;\n\t\tif(check(mid)) low = mid;\n\t\telse high = mid;\n\t}\n\treturn low;\n}\n\nint main(){\n\twhile(scanf(\"%d\",&N),N){\n\t\tscanf(\"%lf%lf%lf%lf\",&SX,&SY,&GX,&GY);\n\t\tS = P(SX,SY); G = P(GX,GY);\n\t\tfor(int i=0; i<N; i++){\n\t\t\tscanf(\"%lf%lf%lf%lf%lf\",minx+i,miny+i,maxx+i,maxy+i,hs+i);\n\t\t}\n\t\tprintf(\"%.7f\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ninline double sq(double x) { return x * x; }\n\nstruct point {\n    double x, y, z;\n    point() {}\n    point(double x, double y, double z): x(x), y(y), z(z) {}\n    point operator + (const point& o) const { return point(x+o.x, y+o.y, z+o.z); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y, z-o.z); }\n    point operator * (const double a) const { return point(x*a,   y*a,   z*a); }\n};\n\ndouble fabs(point p) { return sqrt(sq(p.x) + sq(p.y) + sq(p.z)); }\ndouble dist(point p, point q) { return fabs(p - q); }\ndouble dot(point p, point q) { return p.x*q.x + p.y*q.y + p.z*q.z; }\npoint cross(point p, point q) {\n    return point(\n        p.y*q.z - p.z*q.y,\n        p.z*q.x - p.x*q.z,\n        p.x*q.y - p.y*q.x\n    );\n}\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\ndouble dist_point_line(point p, line l) {\n    if (dot(l.b - l.a, p - l.a) >= 0 && dot(l.a - l.b, p - l.b) >= 0) {\n        point h = l.a + (l.b - l.a) * (dot(l.b - l.a, p - l.a) / sq(fabs(l.b - l.a)));\n        return dist(p, h);\n    }\n\n    return min(dist(p, l.a), dist(p, l.b));\n}\n\nint N; double Sx, Sy, Ex, Ey;\nvector<vector<point>> rects;\nvector<line> vs;\n\ndouble solve() {\n    line c(point(Sx, Sy, 0), point(Ex, Ey, 0));\n    for (vector<point> r : rects) {\n        for (int i = 0; i < r.size(); ++i) {\n            for (int j = i+1; j < r.size(); ++j) {\n                double c1 = cross(c.b - c.a, r[i] - c.a).z * cross(c.b - c.a, r[j] - c.a).z;\n                double c2 = cross(r[j] - r[i], c.a - r[i]).z * cross(r[j] - r[i], c.b - r[i]).z;\n                if (c1 <= 0 && c2 <= 0)\n                    return 0;\n            }\n        }\n    }\n\n    double l = 0, r = 1050;\n    for (int g = 0; g < 100; ++g) {\n        double m = (l + r) / 2;\n\n        line c(point(Sx, Sy, m), point(Ex, Ey, m));\n\n        bool ok = true;\n        for (line p : vs) {\n            if (dist_point_line(p.a, c) <= m || dist_point_line(p.b, c) <= m)\n                ok = false;\n            if (dist_point_line(c.a, p) <= m || dist_point_line(c.b, p) <= m)\n                ok = false;\n            if (m < p.a.z) p.a.z = p.b.z = m;\n            if (dist_point_line(p.a, c) <= m || dist_point_line(p.b, c) <= m)\n                ok = false;\n            if (dist_point_line(c.a, p) <= m || dist_point_line(c.b, p) <= m)\n                ok = false;\n        }\n\n        (ok ? l : r) = m;\n    }\n\n    return (l + r) / 2;\n}\n\nint main(void) {\n    cout << fixed << setprecision(4);\n    while (true) {\n        cin >> N; if (N == 0) break;\n        cin >> Sx >> Sy >> Ex >> Ey;\n        vs.clear();\n        rects.clear();\n        for (int i = 0; i < N; ++i) {\n            double minx, miny, maxx, maxy, h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            vs.emplace_back(point(minx, miny, h), point(minx, maxy, h));\n            vs.emplace_back(point(minx, miny, h), point(maxx, miny, h));\n            vs.emplace_back(point(minx, maxy, h), point(maxx, maxy, h));\n            vs.emplace_back(point(maxx, miny, h), point(maxx, maxy, h));\n\n            vector<point> vv;\n            vv.emplace_back(minx, miny, h);\n            vv.emplace_back(minx, maxy, h);\n            vv.emplace_back(maxx, miny, h);\n            vv.emplace_back(maxx, maxy, h);\n            rects.push_back(vv);\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(const Point &p0,const Point &p1,const Point &p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nPoint projection(const Segment &s,const Point &p){\n    Vector b = s.t-s.s;\n    double t = dot(p-s.s,b)/norm(b);\n    return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n    return (ccw(s.s,s.t,p) == 0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n            ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n    Point r = projection(s,p);\n    if(isIntersectSP(s,r)) return abs(r-p);\n    return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment &a,const Segment &b){\n    if(isIntersectSS(a,b)) return 0;\n    return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n           min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nstruct Block{\n    Point a,b;\n    double h;\n    Block(){}\n    Block(Point &a,Point &b,double h) :\n        a(a),b(b),h(h) {}\n};\n\nistream &operator >> (istream &is,Point &p){ \n    return is >> p.x >> p.y;\n}\n\ndouble calc(double a,double b){\n    return sqrt(a*a+b*b);\n}\n\nbool c(double r,Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point a = v[i].a,b = v[i].b;\n        Point c(a.x,b.y),d(b.x,a.y);\n        Segment s1(a,c),s2(a,d),s3(c,b),s4(d,b);\n        double dst[] = {\n            distanceSS(p,s1),distanceSS(p,s2),\n            distanceSS(p,s3),distanceSS(p,s4)\n        };\n \n        if(r < v[i].h){\n            if(!(r <= dst[0] && r <= dst[1] &&\n                 r <= dst[2] && r <= dst[3])){\n                return 0;\n            }\n        }else{\n            double nh = r - v[i].h;\n            if(!(r <= calc(nh,dst[0]) && r <= calc(nh,dst[1]) &&\n                 r <= calc(nh,dst[2]) && r <= calc(nh,dst[3]))){\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nbool check(Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point c(v[i].a.x,v[i].b.y);\n        Point d(v[i].b.x,v[i].a.y);\n        Segment s1(v[i].a,c),s2(v[i].a,d),s3(c,v[i].b),s4(d,v[i].b);\n        if((v[i].a.x <= p.s.x && p.s.x <= v[i].b.x &&\n            v[i].a.y <= p.s.y && p.s.y <= v[i].b.y) ||\n           (v[i].a.x <= p.t.x && p.t.x <= v[i].b.x &&\n            v[i].a.y <= p.t.y && p.t.y <= v[i].b.y)){\n            return 1;\n        }\n        if(isIntersectSS(p,s1)) return 1;\n        if(isIntersectSS(p,s2)) return 1;\n        if(isIntersectSS(p,s3)) return 1;\n        if(isIntersectSS(p,s4)) return 1;\n    }\n    return 0;\n}\n\nint main(){\n    int N;\n    while(cin >> N,N){\n        Point s,e;\n        Segment seg;\n        cin >> seg.s >> seg.t;\n        vector<Block> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].a >> v[i].b >> v[i].h;\n        }\n        if(check(seg,v)){\n            cout << 0 << endl;\n            continue;\n        }\n        double l = 0,r = 1001;\n        for(int i = 0 ; i < 100 ; i++){\n            double mid = (l + r) / 2;\n            if(c(mid,seg,v)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n        printf(\"%.10f\\n\",r);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point{\n    double x, y;\n    \n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double norm() {return x * x + y * y; }\n    double abs() {return sqrt(norm()); }\n\n    bool operator < (const Point &p) const{\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n\n    bool operator == (const Point &p) const{\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n};\n\ntypedef Point Vector;\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble norm(Vector a){\n    return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS) return CLOCKWISE;\n    if(dot(a, b) < -EPS) return ONLINE_BACK;\n    if(a.norm() < b.norm()) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n    if(intersect(s1, s2)) return 0.0;\n    return min({getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)});\n}\n\nint main(){\n    while(1){\n        int n; cin>>n;\n        if(n == 0) return 0;\n        double sx, sy, ex, ey;\n        cin>>sx>>sy>>ex>>ey;\n        Segment s0 = {Point(sx, sy), Point(ex, ey)};\n\n        double minx = min(sx, ex);\n        double miny = min(sy, ey);\n        double maxx = max(sx, ex);\n        double maxy = max(sy, ey);\n\n        double ans = 1e9;\n        for(int i=0; i<n; i++){\n            double x1, y1, x2, y2, h;\n            cin>>x1>>y1>>x2>>y2>>h;\n\n            if(x1 <= minx && y1 <= miny && maxx <= x2 && maxy <= y2){\n                ans = 0;\n                continue;\n            }\n\n            Point p1 = {x1, y1};\n            Point p2 = {x2, y1};\n            Point p3 = {x2, y2};\n            Point p4 = {x1, y2};\n\n            Segment s1 = {p1, p2};\n            Segment s2 = {p2, p3};\n            Segment s3 = {p3, p4};\n            Segment s4 = {p4, p1};\n\n            double dist1 = getDistance(s0, s1);\n            double dist2 = getDistance(s0, s2);\n            double dist3 = getDistance(s0, s3);\n            double dist4 = getDistance(s0, s4);\n\n            double mindist = min({dist1, dist2, dist3, dist4});\n\n            if(mindist <= h){\n                ans = min(ans, mindist);\n            }\n            else{\n                double r = (h * h + mindist * mindist) / 2 / h;\n                ans = min(ans, r);\n            }\n        }\n\n        printf(\"%.10f\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> Pi;\ntypedef pair<double,int> Pd;\ntypedef pair<Pd,Pi> S;\n\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\n/*\n  ?????????????????????\n  a.real() * b.real() + a.imag() * b.imag()\n*/\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\n\n/*\n  ?????????????????????\n  a.real() * b.imag() - a.imag() * b.real()\n*/\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\n\n// ????????¨?????????????????????????????????????????????true???\nbool isIntersect(L s1, L s2){\n  \n  //ccw ??????????????????????????¨, ????????????????????´?????????????????¨??????????????????????????????\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  //??´?????¨???????????¢\n}\n\n\n// ????????¨??????????????¢\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\n\ndouble cal(L a,L b,double h){\n  double d=getDistanceSS(a,b);\n  if(h>d)return d;\n  return (h*h+d*d)/2/h;\n}\n\nint main(){\n  int n;\n\n  while(cin>>n,n){\n    double ans=1e9;\n    P s,e;\n    double minx,maxx,miny,maxy,h;\n    cin>>s.x>>s.y>>e.x>>e.y;\n    for(int i=0;i<n;i++){\n      cin>>minx>>miny>>maxx>>maxy>>h;\n      if(minx<=s.x&&s.x<=maxx&&miny<=s.y&&s.y<=maxy)ans=0;\n      if(minx<=e.x&&e.x<=maxx&&miny<=e.y&&e.y<=maxy)ans=0;\n      ans=min(ans,cal(L(s,e),L(P(minx,miny),P(minx,maxy)),h));\n      ans=min(ans,cal(L(s,e),L(P(minx,maxy),P(maxx,maxy)),h));\n      ans=min(ans,cal(L(s,e),L(P(maxx,maxy),P(maxx,miny)),h));\n      ans=min(ans,cal(L(s,e),L(P(maxx,miny),P(minx,miny)),h));\n    }\n    printf(\"%.8lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nvoid print(Point p);\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tprint(p1);\n\t\t\tprint(p2);\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p2;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tif(x>=-1&&x<=1) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\n// AOJ1183\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187, AOJ1183\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n    const gtype feps = 1e-9;\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -feps\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -feps)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\n// AOJ1157\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection), AOJ1183(by ip_CL)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& g)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n    {\n        if (ccw(g[(i - 1 + g.size()) % g.size()], g[i], g[(i + 1) % g.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079, AOJ0187\ngtype area(const G& g)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t\ts += cross(g[i], g[(i + 1) % g.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain { OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (intersect_SP(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// a contains b?\n// AOJ0214\nbool contain_GG(const G& a, const G& b)\n{\n    rep(i, b.size())\n        if (contain_GP(a, b[i]) == OUT)\n            return false;\n    return true;\n}\n// AOJ0214\nbool intersect_GG(const G& a, const G& b)\n{\n    rep(i, a.size()) rep(j, b.size())\n        if (intersect_SS(Line(a[i], a[(i + 1) % a.size()]), Line(b[j], b[(j + 1) % b.size()])))\n            return true;\n    return contain_GG(a, b) || contain_GG(b, a);\n}\n\n// AOJ1157(gは長方形)\nbool intersect_GS(const G& g, const Seg& s)\n{\n    if (contain_GP(g, s.first) || contain_GP(g, s.second))\n        return true;\n    rep(i, g.size())\n        if (intersect_SS(Seg(g[i], g[(i + 1) % g.size()]), s))\n            return true;\n    return false;\n}\nbool intersect_SG(const Seg& s, const G& g)\n{\n    return intersect_GS(g, s);\n}\n\n// 円\n\n// AOJ0023(feps = 0)\nenum res_pos_CC\n{\n    not_intersect,\n    intersect,\n\n    tangent,\n\n    a_in_b,\n    b_in_a,\n};\nres_pos_CC pos_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nres_contain contain_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(c.p - p);\n    if (d > c.r + feps)\n        return OUT;\n    else if (d < c.r + feps)\n        return IN;\n    else\n        return ON;\n}\n\n// 円周と線分が交わるか\n// AOJ0129\nbool intersect_CS(const Circle& c, const Seg& seg)\n{\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Seg& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\n// AOJ2201\ngtype dist_CL(const Circle& c, const Line& line)\n{\n    return max<gtype>(0, dist_LP(line, c.p) - c.r);\n}\ngtype dist_LC(const Line& line, const Circle& c)\n{\n    return dist_CL(c, line);\n}\n\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    if (pos_CC(a, b) != intersect)\n        return vector<Point>();\n    // if (abs(a.p - b.p) < a.r + b.r - feps)\n    //     return vector<Line>();\n\n    Point ab = b.p - a.p;\n    gtype t = (norm(ab) + a.r*a.r - b.r*b.r) / (2 * abs(ab));\n    Point u = ab / abs(ab);\n    Point q = a.p + t * u;\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - t*t));\n    Point v = Point(0, h) * u;\n\n    vector<Point> res;\n    res.push_back(q + v);\n    if (h > feps)\n        res.push_back(q - v); // 2点\n    return res;\n}\n\n// AOJ1183\nvector<Point> ip_CL(const Circle& c, const Line& line)\n{\n    const gtype feps = 1e-9;\n\n    Point p = projection(line, c.p);\n    Point cp = p - c.p;\n    gtype d = abs(cp);\n    if (d > c.r + feps)\n        return vector<Point>();\n\n    gtype t = sqrt(max<gtype>(0, c.r*c.r - d*d));\n    Point u = line.second - line.first;\n    Point v = u / abs(u) * t;\n\n    vector<Point> res;\n    res.push_back(p + v);\n    if (t > feps)\n        res.push_back(p - v); // 2点\n    return res;\n}\n\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CS(const Circle& c, const Seg& seg)\n{\n    vector<Point> ip = ip_CL(c, seg);\n    vector<Point> res;\n    rep(i, ip.size())\n        if (intersect_SP(seg, ip[i]))\n            res.push_back(ip[i]);\n    return res;\n}\n\n// 点pを通るcの接線\n// AOJ 2201(円が重ならないケースしかない)\nvector<Line> tangent_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-8;\n\n    Point vec = c.p - p;\n    double d = abs(vec);\n    if (d < c.r)\n        return vector<Line>();\n\n    double t = sqrt(max<gtype>(0, d*d - c.r*c.r));\n    Point rota = Point(t / d, c.r / d);\n    rota *= 1; // 線分の長さが0にならないように\n\n    vector<Line> res;\n    res.pb(Line(p, p + vec * rota));\n    if (d > feps)\n        res.push_back(Line(p, p + vec * conj(rota)));\n    return res;\n}\n\n// 共通外接線\n// AOJ 2201(円が重ならないケースしかない)\nvector<Line> tangent_ext_CC(const Circle& a, const Circle& b)\n{\n    if (abs(a.p - b.p) < abs(a.r - b.r))\n        return vector<Line>(); // 内包\n    \n    if (abs(a.r - b.r) > 1e-8)\n    {\n        Point ip = (-a.p * b.r + b.p * a.r) / (a.r - b.r);\n        return tangent_CP(a, ip);        \n    }\n    else\n    {\n        vector<Line> res;\n        Point v = b.p - a.p;\n        v /= abs(v);\n        v *= Point(0, a.r);\n        res.push_back(Line(a.p + v, b.p + v));\n        res.push_back(Line(a.p - v, b.p - v));\n        return res;\n    }\n}\n// 共通内接線\n// AOJ 2201(円が重ならないケースしかない)\nvector<Line> tangent_in_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-8;\n    if (abs(a.p - b.p) < a.r + b.r - feps)\n        return vector<Line>();\n    else\n    {\n        Point ip = (a.p * b.r + b.p * a.r) / (a.r + b.r);\n        return tangent_CP(a, ip);\n    }\n}\n// 共通接線\n// AOJ 2201(円が重ならないケースしかない)\nvector<Line> tangent_CC(const Circle& a, const Circle& b)\n{\n    vector<Line> res;\n    vector<Line> ext = tangent_ext_CC(a, b);\n    vector<Line> in = tangent_in_CC(a, b);\n    rep(i, ext.size())\n        res.pb(ext[i]);\n    rep(i, in.size())\n        res.pb(in[i]);\n    return res;\n}\n\n\n\n\n/////////////////// \nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n        Seg path;\n        cin >> path.first >> path.second;\n        double res = 1e60;\n        rep(i, n)\n        {\n            double h;\n            int x[2], y[2];\n            rep(j, 2)\n                cin >> x[j] >> y[j];\n            cin >> h;\n\n            Point p[] = { Point(x[0], y[0]), Point(x[1], y[0]), Point(x[1], y[1]), Point(x[0], y[1]) };\n            double d = 1e60;\n            rep(j, 4)\n            {\n                Seg seg(p[j], p[(j + 1) % 4]);\n                chmin(d, dist_SS(path, seg));\n\n                if (h > d)\n                    chmin(res, d);\n                else\n                    chmin(res, (d*d + h*h) / (2 * h));\n            }\n            if (intersect_GS(G(p, p + 4), path))\n                res = 0;\n        }\n        printf(\"%.8f\\n\", res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst double EPS = 1e-9;\n\nstruct Point\n{\n\tdouble x, y;\n\n\tPoint() : x( 0 ), y( 0 ) {}\n\tPoint( const double x, const double y ) : x( x ), y( y ) {}\n\tPoint( const Point &a ) : x( a.x ), y( a.y ) {}\n\t\n\tconst Point operator + ( const Point &a ) const\n\t{\n\t\treturn Point( x + a.x, y + a.y );\n\t}\n\n\tPoint& operator += ( const Point &a ) \n\t{\n\t\tx += a.x;\n\t\ty += a.y;\n\n\t\treturn *this;\n\t}\n\n\tconst Point operator - ( const Point &a ) const\n\t{\n\t\treturn Point( x + ( -a.x ), y + ( -a.y ) );\n\t}\n\n\tPoint& operator -= ( const Point &a )\n\t{\n\t\tx -= a.x;\n\t\ty -= a.y;\n\n\t\treturn *this;\n\t}\n\n\tconst Point operator * ( const double a ) const\n\t{\n\t\treturn Point( x * a, y * a );\n\t}\n\n\tPoint& operator *= ( const double a )\n\t{\n\t\tx *= a;\n\t\ty *= a;\n\n\t\treturn *this;\n\t}\n\n\tconst Point operator / ( const double a ) const\n\t{\n\t\treturn Point( x / a, y / a );\n\t}\n\n\tPoint& operator /= ( const double a )\n\t{\n\t\tx /= a;\n\t\ty /= a;\n\n\t\treturn *this;\n\t}\n\n\tbool operator < ( const Point &a ) const\n\t{\n\t\treturn x == a.x ? y < a.y : x < a.x;\n\t}\n\n\tdouble abs() const\n\t{\n\t\treturn sqrt( pow( x, 2. ) + pow( y, 2. ) );\n\t}\n};\n\n// 二点間の距離\ndouble distance( const Point &a, const Point &b )\n{\n\treturn sqrt( pow( a.x - b.x, 2. ) + pow( a.y - b.y, 2. ) );\n}\n\n// 内積（ドット積）\ndouble dot( const Point &a, const Point &b )\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n// 外積（クロス積）\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// 線分 ( p1, p2 ) と点 q の距離\ndouble distance_segment_point( const Point &p1, const Point &p2, const Point q )\n{\n\tif ( EPS < dot( p2 - p1, q - p1 ) && EPS < dot( p1 - p2, q - p2 ) )\n\t{\n\t\treturn abs( cross( p2 - p1, q - p1 ) ) / ( p2 - p1 ).abs();\n\t}\n\telse\n\t{\n\t\treturn min( distance( p1, q ), distance( p2, q ) );\n\t}\n}\n\n// 線分 ( p1, p2 ) に点 q が乗っているか\nbool point_on_segment( const Point &p1, const Point &p2, const Point &q )\n{\n\treturn abs( cross( p1 - q, p2 - q ) ) <= EPS && dot( p1 - q, p2 - q ) <= EPS;\n}\n\n// 直線 ( p1, p2 ) と直線 ( q1, q2 ) の交点\nPoint lines_intersection( const Point &p1, const Point &p2, const Point &q1, const Point &q2 )\n{\n\treturn p1 + ( p2 - p1 ) * ( cross( q2 - q1, q1 - p1 ) / cross( q2 - q1, p2 - p1 ) );\n}\n\n// 線分 ( p1, p2 ) と線分 ( q1, q2 ) が交差するか\nbool segments_intersection( const Point &p1, const Point &p2, const Point &q1, const Point &q2 )\n{\t\t\n\tif ( abs( cross( p1 - p2, q1 - q2 ) ) <= EPS ) // is parallel\n\t{\n\t\treturn point_on_segment( p1, p2, q1 ) ||\n\t\t\t   point_on_segment( p1, p2, q2 ) ||\n\t\t\t   point_on_segment( q1, q2, p1 ) ||\n\t\t\t   point_on_segment( q1, q2, p2 );\n\t}\n\telse\n\t{\n\t\tPoint r( lines_intersection( p1, p2, q1, q2 ) );\n\t\treturn point_on_segment( p1, p2, r ) && point_on_segment( q1, q2, r );\n\t}\n}\n\n// 三角形 ( a, b, c ) の中に点 p があるか\nbool point_in_triangle( const Point &a, const Point &b, const Point &c, const Point &p )\n{\n\tint res = 0;\n\tres += EPS < cross( b - a, p - a ) ? 1 : -1;\n\tres += EPS < cross( c - b, p - b ) ? 1 : -1;\n\tres += EPS < cross( a - c, p - c ) ? 1 : -1;\n\n\tif ( abs( res ) == 3 )\n\t{\n\t\treturn true;\n\t}\n\treturn point_on_segment( a, b, p ) || point_on_segment( b, c, p ) || point_on_segment( c, a, p );\n}\n\ndouble search( const Point &p1, const Point &p2, const Point &q, const int h )\n{\n\tconst double dist = distance_segment_point( p1, p2, q );\n\tif ( dist - EPS <= h )\n\t{\n\t\treturn dist;\n\t}\n\n\tdouble lb = 0, ub = 1000;\n\tREP( i, 0, 100 )\n\t{\n\t\tdouble r = ( lb + ub ) / 2;\n\t\tif ( r <= distance( Point( 0, r ), Point( dist, h ) ) + EPS )\n\t\t{\n\t\t\tlb = r;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tub = r;\n\t\t}\n\t}\n\n\treturn lb;\n}\n\ndouble solve( const int n )\n{\n\tint sx, sy, ex, ey;\n\tcin >> sx >> sy >> ex >> ey;\n\tPoint s( sx, sy ), e( ex, ey );\n\n\tVI hs;\n\tvector< Point > points;\n\tvector< pair<Point,Point> > lines;\n\n\tREP( i, 0, n )\n\t{\n\t\tint x1, y1, x2, y2, h;\n\t\tcin >> x1 >> y1 >> x2 >> y2 >> h;\n\n\t\tpoints.PB( Point( x1, y1 ) );\n\t\tpoints.PB( Point( x2, y2 ) );\n\t\tpoints.PB( Point( x1, y2 ) );\n\t\tpoints.PB( Point( x2, y1 ) );\n\n\t\tlines.PB( MP( Point( x1, y1 ), Point( x1, y2 ) ) );\n\t\tlines.PB( MP( Point( x1, y2 ), Point( x2, y2 ) ) );\n\t\tlines.PB( MP( Point( x2, y2 ), Point( x2, y1 ) ) );\n\t\tlines.PB( MP( Point( x2, y1 ), Point( x1, y1 ) ) );\n\n\t\ths.PB( h );\n\t}\n\n\tREP( i, 0, lines.size() )\n\t{\n\t\tif ( segments_intersection( s, e, lines[i].fst, lines[i].snd ) )\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tREP( i, 0, n )\n\t{\n\t\tif ( point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 2 ], s ) ||\n\t\t\t point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 2 ], e ) ||\n\t\t\t point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 3 ], s ) ||\n\t\t\t point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 3 ], e ) )\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdouble res = 1000;\n\tREP( i, 0, n )\n\t{\n\t\tREP( j, 0, 4 )\n\t\t{\n\t\t\tconst int idx = i * 4 + j;\n\t\t\tres = min( res, search( s, e, points[ idx ], hs[i] ) );\n\t\t\tres = min( res, search( lines[ idx ].fst, lines[ idx ].snd, s, hs[i] ) );\n\t\t\tres = min( res, search( lines[ idx ].fst, lines[ idx ].snd, e, hs[i] ) );\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\tcout << setprecision( 4 ) << fixed;\n\n\twhile ( true )\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif ( !n )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << solve( n ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<double, double> PDD;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nPDD operator-(const PDD &a, const PDD &b) {\n  return PDD(a.fi - b.fi, a.se - b.se);\n}\n\ndouble len(PDD p) {\n  return sqrt(p.fi * p.fi + p.se * p.se);\n}\n\ndouble dot(PDD a, PDD b) {\n  return a.fi * b.fi + a.se * b.se;\n}\n\ndouble cross(PDD a, PDD b) {\n  return a.fi * b.se - a.se * b.fi;\n}\n\ndouble distance(PDD p1, PDD p2, PDD q1, PDD q2) {\n  if (cross(p2 - p1, q1 - p1) * cross(p2 - p1, q2 - p1) < 0 && cross(q2 - q1, p1 - q1) * cross(q2 - q1, p2 - q1) < 0) {\n    return 0;\n  } else {\n    double mini = INF;\n    if (dot(p2 - p1, q1 - p1) < 1e-7) minch(mini, len(q1 - p1));\n    else if (dot(p1 - p2, q1 - p2) < 1e-7) minch(mini, len(q1 - p2));\n    else minch(mini, abs(cross(p2 - p1, q1 - p1)) / len(p2 - p1));\n\n    if (dot(p2 - p1, q2 - p1) < 1e-7) minch(mini, len(q2 - p1));\n    else if (dot(p1 - p2, q2 - p2) < 1e-7) minch(mini, len(q2 - p2));\n    else minch(mini, abs(cross(p2 - p1, q2 - p1)) / len(p2 - p1));\n\n    if (dot(q2 - q1, p1 - q1) < 1e-7) minch(mini, len(p1 - q1));\n    else if (dot(q1 - q2, p1 - q2) < 1e-7) minch(mini, len(p1 - q2));\n    else minch(mini, abs(cross(q2 - q1, p1 - q1)) / len(q2 - q1));\n\n    if (dot(q2 - q1, p2 - q1) < 1e-7) minch(mini, len(p2 - q1));\n    else if (dot(q1 - q2, p2 - q2) < 1e-7) minch(mini, len(p2 - q2));\n    else minch(mini, abs(cross(q2 - q1, p2 - q1)) / len(q2 - q1));\n\n    return mini;\n  }\n}\n\nint main(){\n  int n;\n  while(cin >> n, n) {\n    PDD s, e;\n    cin >> s.fi >> s.se >> e.fi >> e.se;\n    vector<double> v;\n\n    bool ok = true;\n    rep(i, n) {\n      PDD mi, ma;\n      double h;\n      cin >> mi.fi >> mi.se >> ma.fi >> ma.se >> h;\n      double mini = INF;\n      minch(mini, distance(s, e, mi, PDD(ma.fi, mi.se)));\n      minch(mini, distance(s, e, mi, PDD(mi.fi, ma.se)));\n      minch(mini, distance(s, e, ma, PDD(ma.fi, mi.se)));\n      minch(mini, distance(s, e, ma, PDD(mi.fi, ma.se)));\n      minch(mini, distance(s, e, mi, ma));\n      cout << mini << \" \" << h << endl;\n      if (mini == 0) {\n        ok = false;\n        break;\n      } else {\n        if (mini < h) v.pb(mini);\n        else {\n          double high = 10000, low = mini, mid;\n          rep(j, 100) {\n            mid = (high + low) / 2;\n            if ((mid - h) * (mid - h) + mini * mini >= mid * mid) low = mid;\n            else high = mid;\n          }\n          v.pb(low);\n        }\n        cout << v[v.size() - 1] << endl;\n      }\n    }\n\n    if (ok) {\n      sort(all(v));\n      printf(\"%.10f\\n\", v[0]);\n    } else {\n      cout << 0 << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ninline double sq(double x) { return x * x; }\n\nstruct point {\n    double x, y, z;\n    point() {}\n    point(double x, double y, double z): x(x), y(y), z(z) {}\n    point operator + (const point& o) const { return point(x+o.x, y+o.y, z+o.z); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y, z-o.z); }\n    point operator * (const double a) const { return point(x*a,   y*a,   z*a); }\n};\n\ndouble fabs(point p) { return sqrt(sq(p.x) + sq(p.y) + sq(p.z)); }\ndouble dist(point p, point q) { return fabs(p - q); }\ndouble dot(point p, point q) { return p.x*q.x + p.y*q.y + p.z*q.z; }\npoint cross(point p, point q) {\n    return point(\n        p.y*q.z - p.z*q.y,\n        p.z*q.x - p.x*q.z,\n        p.x*q.y - p.y*q.x\n    );\n}\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\ndouble dist_point_line(point p, line l) {\n    if (dot(l.b - l.a, p - l.a) >= 0 && dot(l.a - l.b, p - l.b) >= 0) {\n        point h = l.a + (l.b - l.a) * (dot(l.b - l.a, p - l.a) / sq(fabs(l.b - l.a)));\n        return dist(p, h);\n    }\n\n    return min(dist(p, l.a), dist(p, l.b));\n}\n\nint N; double Sx, Sy, Ex, Ey;\nvector<line> vs;\n\ndouble solve() {\n    double l = 0, r = 1050;\n    for (int g = 0; g < 100; ++g) {\n        double m = (l + r) / 2;\n\n        line c(point(Sx, Sy, m), point(Ex, Ey, m));\n        line c0 = c; c0.a.z = c0.b.z = 0;\n\n        bool ok = true;\n        for (line p : vs) {\n            if (m < p.a.z) p.a.z = p.b.z = m;\n            if (dist_point_line(p.a, c) <= m || dist_point_line(p.b, c) <= m)\n                ok = false;\n\n            p.a.z = p.b.z = 0;\n            if (cross(c0.b-c0.a, p.a-c0.a).z * cross(c0.b-c0.a, p.b-c0.a).z <= 0 &&\n                cross(p.b-p.a, c0.a-p.a).z * cross(p.b-p.a, c0.b-p.a).z <= 0)\n                return 0;\n        }\n\n        (ok ? l : r) = m;\n    }\n\n    return (l + r) / 2;\n}\n\nint main(void) {\n    cout << fixed << setprecision(10);\n    while (true) {\n        cin >> N; if (N == 0) break;\n        cin >> Sx >> Sy >> Ex >> Ey;\n        vs.clear();\n        for (int i = 0; i < N; ++i) {\n            double minx, miny, maxx, maxy, h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            minx = max(minx, min(maxx, min(Sx, Ex)));\n            miny = max(miny, min(maxy, min(Sy, Ey)));\n            maxx = min(maxx, max(minx, max(Sx, Ex)));\n            maxy = min(maxy, max(miny, max(Sy, Ey)));\n            vs.emplace_back(point(minx, miny, h), point(minx, maxy, h));\n            vs.emplace_back(point(minx, miny, h), point(maxx, miny, h));\n            vs.emplace_back(point(minx, maxy, h), point(maxx, maxy, h));\n            vs.emplace_back(point(maxx, miny, h), point(maxx, maxy, h));\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<complex>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define inf (1<<29)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -inf,double y = -inf): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<Point> vp;\ntypedef vector<vp> vvp;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nbool pequals(Point a,Point b)\n{\n  return equals(a.x,b.x) && equals(a.y,b.y);\n}\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad)\n{\n  return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y);\n}\n\n// 度をラジアンに変換\ndouble toRad(double agl)\n{\n  return agl*M_PI/180.0;\n}\n\n//0 <= <= 180 && -180 < <= 0 \ndouble toDo(double rad)\n{\n  return rad*180.0/M_PI;\n}\n\ndouble args(Point p){\n  return atan2(p.y,p.x);\n}\n\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nstruct Circle\n{\n  Point p;\n  double r;\n  Circle(Point p=Point(),double r=inf):p(p),r(r){}\n};\n\nbool isIntersectLC(Line l,Circle c)\n{\n  double Mdist = getDistanceLP(l,c.p);\n  return Mdist <= c.r;\n  //return equals(Mdist,c.r) || (!equals(Mdist,c.r) && Mdist < c.r);\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //polyの最後の要素 = polyの最初の要素 であることが前提\n  \n  //そうでない場合は\n    rep(i,poly.size())\n      if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n    double sum = 0;\n    for(int i=0; i < (int)poly.size() ;i++)\n      {\n        if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n          sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n        else\n          sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n      }\n      return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n      //と書き換えること\n    \n  \n}  \n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\nassert(isIntersect(a1,a2,b1,b2));//交差していない　これを外してもある程度（またはしっかり？）はうごいてくれる\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\n// Line Line 上と同じ assertなし\nPoint getCrossPointLines( Line s1, Line s2){\n    Point a = s1.p2 - s1.p1;\n    Point base = s2.p2 -s2.p1;\n    return s1.p1 + a * (cross(base, s2.p1 - s1.p1)/cross(base, a));\n}\n\n\nPoint project(Segment s,Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1 + base*t;\n}\n\ndouble getDistance(Segment s1,Segment s2)\n{\n  if(isIntersect(s1,s2))return 0;\n  return min( min(getDistanceSP(s1,s2.p1), getDistanceSP(s1,s2.p2) ),\n\t      min(getDistanceSP(s2,s1.p1), getDistanceSP(s2,s1.p2) ));\n}\n\nstruct Obj\n{\n  vector<Point> ps;\n  double h;\n  Obj(Point ps1=Point(),Point ps2=Point(),double h=-inf):h(h)\n  {\n    ps.resize(4);\n    ps[0].x = ps1.x,ps[0].y = ps1.y;\n    ps[1].x = ps1.x,ps[1].y = ps2.y;\n    ps[2].x = ps2.x,ps[2].y = ps2.y;\n    ps[3].x = ps2.x,ps[3].y = ps1.y;\n  }\n};\nint N;\nPoint s,e;\n\nint main()\n{\n  cout << setiosflags(ios::fixed) << setprecision(3);\n  while(cin >> N,N)\n    {\n      cin >> s.x >> s.y >> e.x >> e.y;\n      vector<Obj> vec;\n      Circle c(s);\n      Point st = e-s;\n      Point E = st/sqrt(norm(st)); \n      double cont = 1000000;\n      Line line(E*(-cont) + s,E*cont + s);\n      //cout << \"line( (\" << line.p1.x << \",\" << line.p1.y << \") , (\" << line.p2.x << \",\" << line.p2.y << \") )\" << endl;\n      Segment seg(s,e);\n      rep(i,N)\n\t{\n\t  Point a,b;\n\t  double h;\n\t  cin >> a.x >> a.y >> b.x >> b.y >> h;\n\t  if(c.r == 0)continue;\n\t  vec.push_back(Obj(a,b,h));\n\t  rep(j,4)\n\t    {\n\t      if(isIntersect(seg,Segment(vec[i].ps[j],vec[i].ps[(j+1)%4])) )\n\t\t{\n\t\t  //cout <<\"oh, keep out ----- \" << endl << endl;\n\t\t  c.r = 0;\n\t\t  break;\n\t\t}\n\t      //cout << \"ps[\" << j << \"] = \" << vec[i].ps[j].x << \",\" << vec[i].ps[j].y << endl;\n\t    }\n\n\t  if(inPolygon(vec[i].ps,s) || inPolygon(vec[i].ps,e))\n\t    {\n\t      c.r = 0;\n\t      break;\n\t    }\n\n\t  rep(j,4)\n\t    {\n\t      /*\n\t      Point p = project(line,vec[i].ps[j]);\n\t      cout << \"on point = \" << p.x << \",\" << p.y << endl;\n\t      c.p = p;\n\t      */\n\t      double w = getDistance(seg,Segment(vec[i].ps[j],vec[i].ps[(j+1)%4]));\n\t      //cout << \"w = \"<< w << endl;\n\t      //if(equals(w,h) || w < h)continue;\n\t   \n\t      double dist = (h*h+w*w)/(2.0*h);\n\t      //cout <<\"the distance is \" << dist << endl; \n\t      c.r = min(c.r,dist);\n\t      //cout << \"c.r = \" << c.r << endl;\n\t    }\n\t  \n\n\t  \n\t  //cout << endl;\n\t}\n      cout << setiosflags(ios::fixed) << setprecision(10) << c.r << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS 1e-10\n#define EQ(a,b) (abs(a - b) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n//外積\ndouble cross (P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n//内積\ndouble dot (P a, P b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//直行\nbool is_orthogonal(P a1, P a2, P b1, P b2) {\n    return EQ( dot(a1 - a2, b1 - b2), 0.0);\n}\n\n//平行\nbool is_parallel(P a1, P a2, P b1, P b2) {\n    return EQ( cross(a1 - a2, b1 - b2), 0.0);\n}\n\n//直線上\nbool is_point_on_vector(P a, P b, P c) {\n    return EQ( cross(a - c, c - b), 0.0);\n}\n\n//線分上\nbool is_point_on_line (P a, P b, P c) {\n    return (abs(a - c) + abs(c - b) < abs(a - b) + EPS);\n}\n\n//角度　線分の距離は小数点以下３桁まで\ndouble angle (P a, P b, P p) {\n    return (acos(dot(a-p,b-p) / (abs(a-p) * abs(b-p))) * 180.0 / M_PI);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_l(P a1, P a2, P b1, P b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2 - a1; P b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n    if ( dot(b-a, c-a) < EPS ) return fabs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return fabs(c-b);\n    return abs(cross(b-a, c-a)) / fabs(b-a);\n}\n\n/***************************************\n *\n * 2点を通る直線とある点からの垂線との交点\n *\n * a, b を直線\n * p    をある点\n *\n ***************************************/\nP crossNormalVector (P a, P b, P p) {\n    double t = dot(b-a, p-a) / (abs(b-a) * abs(b - a));\n    return a + t * (b - a);\n}\n\ndouble calc (double h, double r) {\n    // if (h > r) h = r;\n    // cout << \"# \"<< h << \" \" << r << endl;\n    // double x = sqrt(h * h + r * r) / 2.;\n    // double y = x * tan((0.5 * M_PI) - atan((h / r)));\n    // double res = sqrt(x * x + y * y);\n    // cout << r / x << endl;\n    // cout << \"# > \" << x << \" \" << y << endl;\n    // cout << res << endl;\n    return (r * r + h * h) / (2 * h);\n}\n\nint main ()\n{\n    int n;\n    while (cin >> n, n) {\n        double sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        P s(sx, sy), e(ex, ey);\n\n        double res_h = 1000.;\n        while (n--) {\n            // cout << \"Count # \" << n << endl;\n            \n            double minx, miny, maxx, maxy;\n\n            double h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            vector<P> v = { P(minx, miny), P(minx, maxy), P(maxx, maxy), P(maxx, miny)};\n\n            if (minx <= s.real() && s.real() <= maxx && miny <= s.imag() && s.imag() <= maxy) res_h = 0.;\n            if (minx <= e.real() && e.real() <= maxx && miny <= e.imag() && e.imag() <= maxy) res_h = 0.;\n\n            for (int i = 0; i < 4; i++) {\n                int anf = (i + 1) % 4, bfr = (i + 4 - 1) % 4;\n                int now = i;\n\n                if (is_intersected_ls(e, s, v[now], v[anf])) res_h = 0.;\n                if (is_intersected_ls(e, s, v[now], v[bfr])) res_h = 0.;\n                \n                // cout << \"DBG > \" << min(v[now].real(), v[anf].real()) << \" \" << max(v[now].real(), v[anf].real()) << endl;\n                // cout << \"      \" << min(v[now].imag(), v[anf].imag()) << \" \" << max(v[now].imag(), v[anf].imag()) << endl;\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[anf], s)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[bfr], s)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[anf], e)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[bfr], e)));\n                // res_h = min(res_h, calc(h, min(abs(minx - s.real()), abs(maxx - s.real()))));\n                // res_h = min(res_h, calc(h, min(abs(miny - s.imag()), abs(maxy - s.imag()))));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[now])));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[anf])));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[bfr])));\n            }\n        }\n\n        cout << res_h << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include <complex>\nusing namespace std;\n\n#define REP(i,a,n) for(int i = a; i < n ; i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\ntypedef complex<double> P;\n\n#define EPS (1e-10)\n\nint n;\nP s,g;\nP p[52][4];\ndouble h[52];\n\ndouble dot(P a,P b){\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(P a,P b){\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\ndouble distanceSP(P a,P b,P c){\n  if(dot(b-a,c-a) < EPS) return abs(c-a);\n  if(dot(a-b,c-b) < EPS) return abs(c-b);\n  return abs(cross(b-a,c-a)) / abs(b-a);\n}\n\nint inter(P a,P b,P c,P d){\n  return\n    (cross(b-a,c-a) * cross(b-a,d-a) < EPS) &&\n    (cross(d-c,a-c) * cross(d-c,b-c) < EPS);\n}\n\nbool error(int i){\n  P a = p[i][0];\n  P b = p[i][2];\n  if(a.real() <= s.real() && s.real()<= b.real()\n     && a.imag() <= s.imag() && s.imag() <= b.imag()){\n    return true;\n  }\n  if(a.real() <= g.real() && g.real()<= b.real()\n     && a.imag() <= g.imag() && g.imag() <= b.imag()){\n    return true;\n  }\n\n  rep(j,4){\n    if(inter(s,g,p[i][j],p[i][(j+1)%4])){\n      return true;\n    }\n  }\n\n  return false;\n}\n\ndouble calc(double r , double hh){\n  if(r<=hh){\n    return r;\n  }\n  else{\n    return (hh*hh+r*r)/(2*hh);\n  }\n}\n\nvoid solve(){\n  double r = 999999999;\n\n  rep(i,n){\n    if(error(i)){\n      cout<<0<<endl;\n      return;\n    }\n\n    double minDist = 999999999;\n    rep(j,4){\n      double dist = distanceSP(s,g,p[i][j]);\n      dist = min(dist  ,distanceSP(p[i][j] , p[i][(j+1)%4] , s));\n      dist = min(dist  ,distanceSP(p[i][j] , p[i][(j+1)%4] , g));\n\n\n      //            cout<<\"dist\"<<j<<\" \"<<dist<<endl;\n      minDist = min(dist,minDist);\n\n    }\n    r = min(r,calc(minDist,h[i]));\n  }\n  printf(\"%.8lf\\n\",r);\n}\n\nint main(){\n  while(cin>>n && n){\n    cin>>s.real()>>s.imag()>>g.real()>>g.imag();\n\n    rep(i,n){\n      P a,b;\n      cin>>a.real()>>a.imag()>>b.real()>>b.imag()>>h[i];\n      p[i][0] = a;\n      p[i][1] = P(a.real(),b.imag());\n      p[i][2] = b;\n      p[i][3] = P(b.real(),a.imag());\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x real()\n#define y imag()\n#define INF (1e9)\n#define EPS (1e-5)\nusing namespace std;\ntypedef complex<double> point;\npoint s,g;\ndouble dot(point a,point b){return a.x*b.x+a.y*b.y;}\ndouble cross(point a,point b){return a.x*b.y-a.y*b.x;}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<0) return 2;//\"ONLINE_BACK\"\n  if(abs(d)<abs(e)) return -2;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\nbool intersection(point a,point b,point c,point d){\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n}\n\n//???????§???¢????????´??????????????????\nint get_state(vector <point> a,point b){\n  int n=a.size();\n  for(int i=0;i<n;i++){\n    int res=ccw(a[i],a[(i+1)%n],b);\n    if(!res)return 0; //?¢???????\n    if(res!=1) return 1;//?????´\n  }\n  return -1;//?????´\n}\n\n\n//???????§???¢??¨???????????¢????±??????????\ndouble get_dis_sp(point a, point b, point c) {\n  if (dot(b-a,c-a)<EPS) return abs(c-a);\n  if (dot(a-b,c-b) <EPS) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n\n//????????¨??????????????¢\ndouble get_dis_sg_sg(point a,point b,point c,point d){\n  if(intersection(a,b,c,d)) return 0;\n  return min(min(get_dis_sp(a,b,c),get_dis_sp(a,b,d)),\n\t     min(get_dis_sp(c,d,a),get_dis_sp(c,d,b)));\n}\n\n//???????§???¢??¨??????????????¢\ndouble get_dis_totsu_sg(vector <point> a,point b,point c){\n  if(get_state(a,b) !=1||get_state(a,c)!=1)return 0;\n  int n=a.size();\n  double res=get_dis_sg_sg(a[0],a[1],b,c);\n  for(int i=0;i<n;i++) res=min(res,get_dis_sg_sg(a[i],a[(i+1)%n],b,c));\n  return res;\n}\n\n\nint main(){\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    double a,b,c,d,h;\n    cin>>a>>b>>c>>d;\n    s=point(a,b),g=point(c,d);\n\n    double ans=INF;\n    vector <point> v;\n    v.resize(4);\n    for(int i=0;i<n;i++) {\n      cin>>a>>b>>c>>d>>h;\n      v[3]=point(a,b);\n      v[2]=point(a,d);\n      v[1]=point(c,d);\n      v[0]=point(c,b);\n      double dis=get_dis_totsu_sg(v,s,g);\n      if(dis>h) ans=min(ans,(dis*dis+h*h)/(2*h));\n      else ans=min(ans,dis);\n    }\n    printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tif(online(s[0]) || online(s[0]) || s.online(at(0)) || s.online(at(1))) return BORDER;\n\t\t\treturn (ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1) <= 0 &&\n\t\t\t\t\tccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1) <= 0);\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return !sig(abs(p-SELF) - r) ? BORDER : abs(p-SELF) < r - EPS;}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tif(c.inside(s[0]) != FALSE && c.inside(s[1]) != FALSE) return c.inside(s[0]) | c.inside(s[1]) == 1 ? 0 : -1;\n\t\treturn less(s.distance(c), c.r);\n\t}\n\t\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at((i+1)%size()));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tS l;\n\t\tR ans = INF;\n\t\tcin >> l;\n\t\tREP(i, n){\n\t\t\tG g;\n\t\t\tR sx, sy, tx, ty, h;\n\t\t\tcin >> sx >> sy >> tx >> ty >> h;\n\t\t\tg.emplace_back(sx, sy);\n\t\t\tg.emplace_back(sx, ty);\n\t\t\tg.emplace_back(tx, ty);\n\t\t\tg.emplace_back(tx, sy);\n\t\t\tR dist = g.distance(l);\n\t\t\tif(dist <= h) ans = min(ans, dist);\n\t\t\telse ans = min(ans, (dist*dist + h*h)*0.5/h);\n\t\t}\n\t\tprintf(\"%.4f\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XYツ催?標\n#define X real()\n#define Y imag()\n\n// * ツ点ツづ個表ツ個サ\ntypedef complex<double> P;\n\n// * ツ仰鳴容ツつキツづゥツ古ォツ債キツε?\nconst double EPS = 1e-10;\n// * Infinity\nconst double INF = 1e12;\n// * ツ円ツ偲シツ猟ヲ\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> ツづ個渉?渉伉づーツ津ィツ義ツつキツづゥ\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 2ツ湘ヲツつキツづゥ\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2ツ点ツ甘板づ個仰猟猟」\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2ツづつづ個スツカツδ可ーツつェツ督卍つオツつ「ツつゥツづ?つ、ツつゥ\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2ツづつづ個ベツクツトツδ仰つェツ督卍つオツつ「ツつゥツづ?つ、ツつゥ\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ツベツクツトツδ蟻ツづ個単ツ暗環ベツクツトツδ仰づーツ仰?づ淞づゥ\nP unit(P a) {\n\treturn a / abs(a);\n}\n\n// ツベツクツトツδ蟻ツづ個法ツ静シツベツクツトツδ仰づーツ仰?づ淞づゥ\nvector<P> normal(P a) {\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ツベツクツトツδ?a ツづ個単ツ暗環法ツ静シツベツクツトツδ仰づーツ仰?づ淞づゥ\nvector<P> normal_unit(P a) {\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// * ツ禿?静?(dot product) : aツ・b = |a||b|cosツδヲ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * ツ外ツ静?(cross product) : aツ×b = |a||b|sinツδヲ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// CCW : ツ板スツ篠楪計ツ嘉アツづィ (Counter Clock Wise)\n// CW : ツ篠楪計ツ嘉アツづィ (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3ツ点ツつェツづ?つソツづァツ嘉アツづィツづ?つ?づゥツつゥツ陛板つキ, 3ツ点ツつェ1ツ陳シツ静シツづ可湘ヲツづ?づ?つ「ツづゥツづ?つォツづ?ON ツづーツ陛板つキ\nint ccw(const P &a, P b, P c) {\n    b-=a, c-=a;\n    if( cross(b,c) >  EPS ) return CCW; // CCW : ツ板スツ篠楪計ツ嘉アツづィ\n    if( cross(b,c) < -EPS ) return CW;  // CW : ツ篠楪計ツ嘉アツづィ\n    if(dot(b, c) < -EPS )   return +2;  // c--a--b on line\n    if(dot(b, b) + EPS < dot(c, c) ) return -2; // a--b--c on line ???\n    return ON;\n}\n\n// ツδ可ジツアツδ督つゥツづァツ度ツ青板づ鳴陛渉環キツつオツづ?陛板つキ\ndouble to_deg(double rad) {\n\treturn rad * 180.0 / PI;\n}\n\n// ツ度ツ青板つゥツづァツδ可ジツアツδ督づ可陛渉環キツつオツづ?陛板つキ\ndouble to_rad(double deg) {\n\treturn deg * PI / 180.0;\n}\n\n// ツ個エツ点ツづーツ篠イツづ可点 p ツづーツ角ツ度 a (ツδ可ジツアツδ?ツつセツつッツ嘉アツ転ツつウツつケツつスツ点ツづーツ陛板つキ\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// ツ点 a ツづーツ篠イツづ可点 b ツづーツ角ツ度 a (ツδ可ジツアツδ?ツつセツつッツ嘉アツ転ツつウツつケツつスツ点ツづーツ陛板つキ\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// ツ点 a ツつゥツづァ ツ点 b ツづ鳴づ個角ツ度ツづーツ陛板つキ [0,2ツε讃\ndouble dir(P a, P b) {\n\tP p = a - b;\n\tdouble angle = atan2( p.Y , p.X );\n\tif( p.X < 0 ) angle += PI;\n\tif( angle < 0 ) angle += 2.0 * PI;\n\treturn angle;\n}\n\n// ツ静シツ閉ェツクツδ可ス\nstruct Segment{\n    P a, b;\n    Segment(P a_, P b_){\n        a = a_; b = b_;\n    }\n    // ツ点 p ツづ?静シツ閉ェツづ個仰猟猟」ツづーツ陛板つキ.\n    double distance(P p){\n        if( dot(b-a,p-a) < EPS ) return abs(p-a);\n        if( dot(a-b,p-b) < EPS ) return abs(p-b);\n        return abs( cross(b-a,p-a) ) / abs(b-a) ;\n    }\n    // ツ静シツ閉ェ s ツづ?古ーツ債キツつオツづ?つ「ツづゥツつゥツづ?つ、ツつゥツづーツ陛板つキ.\n    bool is_intersection(const Segment& s){\n        return ( ccw(a, b, s.a)   * ccw(a, b, s.b) <= 0 && \n                 ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0 );\n    }\n    // ツ点 p ツつェツ静シツ閉ェツ湘」ツづ可つ?づゥツつゥツづ?つ、ツつゥ\n    bool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n    // ツ静シツ閉ェツづ?静シツ閉ェツづ個仰猟猟」\n    double distance(Segment s) {\n        if( is_intersection(s) ) return 0.0;\n        return min( min(distance(s.a), distance(s.b)), min(s.distance(a), s.distance(b)) );\n    }\n    // ツデツバツッツグツ出ツ療?\n    void print(){\n        printf(\"line(%f,%f,%f,%f);\\n\", a.X ,a.Y, b.X, b.Y );\n    }\n};\n\n// ツ陳シツ静シツづ個表ツ個サ ((*this)[0]) ツづ?((*this)[1]) ツづーツ津環づゥツ陳シツ静シ\nstruct Line : public vector<P> {\n\tLine(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tLine(vector<P> v){\n\t\tpush_back(v[0]); push_back(v[1]);\n\t}\n\tLine(){}\n\t// 2ツ陳シツ静シツづ個陳シツ古ーツ板サツ津ィ\n\tbool orthogonal(const Line& l) {\n\t\treturn equal( dot( (*this)[0] - (*this)[1] , l[0] - l[1] ) , 0.0 );\n\t}\n\t// 2ツ陳シツ静シツづ個閉スツ行ツ板サツ津ィ\n\tbool parallel(const Line& l) {\n\t\treturn equal( cross( (*this)[0] - (*this)[1] , l[0] - l[1] ), 0.0 );\n\t}\n\t// ツ点 p ツつェツ陳シツ静シツ湘」ツづ可湘ヲツづ?づ?つ「ツづゥツつゥ\n\tbool contain(P p) {\n\t\treturn equal( cross( (*this)[1] - (*this)[0] , p - (*this)[0] ) , 0.0 );\n\t}\n\t// ツ陳シツ静シツづ?点 p ツづ個仰猟猟」\n\tdouble distance(P a) {\n\t\tP p1 = (*this)[0];\n\t\tP p2 = (*this)[1];\n\t\treturn abs( cross( p2 - p1 , a - p1) ) / abs(p2 - p1);\n\t}\n\t// ツ陳シツ静シツづ個古ーツ債キツ板サツ津ィ\n\tbool is_intersection(const Line& l) {\n\t\treturn !equal( cross( (*this)[0] - (*this)[1], l[0] - l[1] ) , 0.0 );\n\t}\n\t// ツ陳シツ静シツづ個古ーツ債キツ板サツ津ィツづ?古ーツ点ツ計ツ算\n\tbool intersection(Line l, P& p) {\n\t\tbool result = this->is_intersection( l );\n\t\tif( result ) {\n\t\t\tP a = (*this)[1] - (*this)[0];\n\t\t\tP b = l[1] - l[0];\n\t\t\tp = (*this)[0] + a * cross(b, l[0] - (*this)[0]) / cross(b, a);\n\t\t}else {\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// ツ点 (*this)[0] ツつゥツづァ ツ点 (*this)[1] ツづ鳴づ個角ツ度ツづーツ陛板つキ [0,2ツε讃\n\tdouble get_dir() {\n\t\tP p = (*this)[0] - (*this)[1];\n\t\tdouble angle = atan2( p.Y , p.X );\n\t\tif( p.X < 0 ) angle += PI;\n\t\tif( angle < 0 ) angle += 2.0 * PI;\n\t\treturn angle;\n\t}\n};\n\n// ツ円ツづ個表ツ個サ\nstruct Circle{\n\t// ツ円ツづ個陳?心\n\tP p;\n\t// ツ円ツづ個板シツ径\n\tdouble r;\n\t// ツコツδ督スツトツδ可クツタツづ?渉可甘コツ可サ\n\tCircle(P p_, double r_) { p = p_; r = r_; }\n\t// ツ円ツづ個姪環静?\n\tdouble get_area() { return r * r * PI; }\n\t// ツ円ツ偲シ\n\tdouble circumference() { return 2.0 * r * PI; }\n\t// ツ点 a ツつェツ円ツづ個禿?閉板づ可つ?づゥツつゥツづ?つ、ツつゥ\n\tbool is_inside(P a) { return ( dist(a,p) <= r ); }\n\t// ツ点 a ツつェツ円ツ偲シツ湘」ツづ可つ?づゥツつゥツづ?つ、ツつゥ\n\tbool on_boundary(P a) { return equal( dist(a,p) , r ); }\n\t// ツ角ツ度 [a,b] ツづ個古環づ個陳キツつウツづーツ陛板つキ (a,bツづ債δ可ジツアツδ?\n\tdouble arc(double a, double b) {\n\t\twhile( a > b ) b += 2.0 * PI;\n\t\treturn r * (b - a);\n\t}\n\t// ツ円ツ偲シツ湘」ツづ個点 a,b ツづ個古環づ個陳キツつウツづーツ陛板つキ. \n\t// (ツ円ツ偲シツ湘」ツづ個点ツづ?づ按つ「ツづ?つォツづ? ツ円ツづ個陳?心 p ツづ?点 a ツづーツ個仰づアツづ?古ーツ債キツつキツづゥツ点ツづーツ点 a ツづ?つキツづゥ.ツ点 b ツづ?督ッツ様) \n\tdouble arc(P a, P b){\n\t\tP p1 = a - p;\n\t\tdouble angle1 = atan2( p1.Y , p1.X );\n\t\tif( p1.X < 0 ) angle1 += PI;\n\t\tif( angle1 < 0 ) angle1 += 2.0 * PI;\n\t\tP p2 = b - p;\n\t\tdouble angle2 = atan2( p2.Y , p2.X );\n\t\tif( p2.X < 0 ) angle2 += PI;\n\t\tif( angle2 < 0 ) angle2 += 2.0 * PI;\n\t\treturn this->arc( angle1 , angle2 );\n\t}\n\t// ツ角ツ度 [a,b] ツづ個静ョツ形ツづ個姪環静渉づーツ陛板つキ (a,bツづ債δ可ジツアツδ?\n\tdouble sector(double a, double b) {\n\t\twhile( a > b ) b += 2.0 * PI;\n\t\treturn 0.5 * r * r * (b - a);\n\t}\n\t// ツ円ツ偲シツ湘」ツづ個点 a,b ツづ?円ツづ個陳?心 p ツつゥツづァツづ按づゥツ静ョツ形ツづ個姪環静渉づーツ陛板つキ. \n\t// (ツ円ツ偲シツ湘」ツづ個点ツづ?づ按つ「ツづ?つォツづ? ツ円ツづ個陳?心 p ツづ?点 a ツづーツ個仰づアツづ?古ーツ債キツつキツづゥツ点ツづーツ点 a ツづ?つキツづゥ.ツ点 b ツづ?督ッツ様) \n\tdouble sector(P a, P b){\n\t\tP p1 = a - p;\n\t\tdouble angle1 = atan2( p1.Y , p1.X );\n\t\tif( p1.X < 0 ) angle1 += PI;\n\t\tif( angle1 < 0 ) angle1 += 2.0 * PI;\n\t\tP p2 = b - p;\n\t\tdouble angle2 = atan2( p2.Y , p2.X );\n\t\tif( p2.X < 0 ) angle2 += PI;\n\t\tif( angle2 < 0 ) angle2 += 2.0 * PI;\n\t\treturn this->sector( angle1 , angle2 );\n\t}\n\t// ツ陳シツ静シツづ?円ツづ個仰猟猟」 (ツ円ツづ個陳?心ツづ個点ツづ?陳シツ静シツづ個仰猟猟」 - ツ円ツづ個板シツ径)\n\tdouble distance(Line l){\n\t\treturn l.distance( p ) - r;\n\t}\n\t// ツ点 a ツづーツ津環づゥツ静堋静シツづーツ陛板つキ.\n\tpair<Line,Line> tangent(P a) {\n\t\tpair<Line,Line> pl;\n\t\tif( this->on_boundary( a ) ) { // ツ点 a ツつェツ円ツ偲シツ湘」ツづ可つ?づゥツづ?つォ\n\t\t\tLine l( normal(a - p) ); // ツ法ツ静シツベツクツトツδ?\n\t\t\tl[0] += a;\n\t\t\tl[1] += a;\n\t\t\tpl.first = pl.second = l ;\n\t\t\treturn pl;\n\t\t}else if( !this->is_inside(a) ) { // ツ点 a ツつェツ円ツづ個外ツ堕、ツづ可つ?づゥツづ?つォ\n\t\t\tdouble xp = a.X - p.X;\n\t\t\tdouble yp = a.Y - p.Y;\n\t\t\tdouble A = sqrt( sq(xp) + sq(yp) - sq(r) );\n\t\t\tdouble B = sq(xp) + sq(yp);\n\t\t\tP p1( r * (xp * r + yp * A) / B , r * (yp * r - xp * A) / B );\n\t\t\tP p2( r * (xp * r - yp * A) / B , r * (yp * r + xp * A) / B );\n\t\t\tpl.first = Line( a , p1+p );\n\t\t\tpl.second = Line( a , p2+p );\n\t\t}else{ // ツ点 a ツつェツ円ツづ個禿?堕、ツづ可つ?づゥツづ?つォ\n\t\t\tpl.first = pl.second = Line(INF_P,INF_P);\n\t\t}\n\t\treturn pl;\n\t}\n\t// ツ督卍つオツつ「ツつゥツづ?つ、ツつゥ\n\tbool operator==(const Circle& c) { return (p == c.p && r == c.r) ; };\n\t// 2ツづつづ個円ツづ個暗環置ツ甘鳴係\n\t// 2 ツづつづ個円ツつェツ猟」ツづェツづ?つ「ツづゥ => 0\n\t// 2 ツづつづ個円ツつェツ外ツ静堋つキツづゥ   => 1\n\t// 2 ツづつづ個円ツつェツ古ーツづュツづゥ     => 2\n\t// 2 ツづつづ個円ツつェツ禿?静堋つキツづゥ    => 3 (2ツづつづ個円ツつェツ督卍つオツつ「ツづ?つォツづ債禿?静?\n\t// ツ円ツつェツ甘慊づ慊づェツづ?つ「ツづゥ       => 4\n\tint is_pos(const Circle& c) {\n\t\tdouble d = abs(p - c.p);\n\t\tif( r + c.r + EPS < d ) { // ツ猟」ツづェツづ?つ「ツづゥ\n\t\t\treturn 0;\n\t\t}else if( equal( r + c.r , d ) ) { // ツ外ツ静堋つキツづゥ\n\t\t\treturn 1;\n\t\t}else if( equal( fabs(r-c.r) , d ) ) { // ツ禿?静堋つキツづゥ\n\t\t\treturn 3;\n\t\t}else if( d < fabs(r-c.r) ) { // ツ甘慊づ慊づェツづゥ\n\t\t\treturn 4;\n\t\t}else { // ツ古ーツづュツづゥ\t\n\t\t\treturn 2;\n\t\t}\n\t}\n\t// ツ円ツづ?陳シツ静シツづ個古ーツづュツづゥツ点ツづーツ陛板つキ\n\tpair<P,P> intersection(Line l) {\n\t\tpair<P,P> pp;\n\t\tif( this->distance(l) > EPS ) { // ツ円ツづ?陳シツ静シツづ個古ーツ点ツつェツづ按つ「ツづ?つォ\t\n\t\t\tpp.first = pp.second = INF_P;\n\t\t}else { // ツ円ツづ?陳シツ静シツづ個古ーツ点ツつェツつ?づゥツづ?つォ\n\t\t\tdouble d = l.distance( p );\n\t\t\tdouble angle = -l.get_dir();\n\t\t\t// ツ点 l[0] ツづーツ篠イツづ可点 l[1] ツづ?円ツづ個陳?心ツづーツ嘉アツ転\n\t\t\tP lp = rot2( l[0] , l[1] , angle );\n\t\t\tP cp = rot2( l[0] , p    , angle );\n\t\t\tdouble x1 = cp.X - sqrt( sq(r) - sq(d) );\n\t\t\tdouble x2 = cp.X + sqrt( sq(r) - sq(d) );\n\t\t\tP p1(x1,l[0].Y);\n\t\t\tP p2(x2,l[0].Y);\n\t\t\t// ツ嘉アツ転ツつオツづ?個ウツづ可姪淞つキ\n\t\t\tp1 = rot2( l[0] , p1 , -angle );\n\t\t\tp2 = rot2( l[0] , p2 , -angle );\n\t\t\tpp.first = p1;\n\t\t\tpp.second = p2;\n\t\t}\n\t\treturn pp;\n\t}\n\t// ツデツバツッツグツ出ツ療?\n\tvoid print() { printf(\"circle(%f,%f,%f); \\n\", p.X, p.Y, r ); }\n};\n\n\nint main(){\n\tint N;\n\twhile( cin >> N , N ){\n\t\tint sx, sy, ex, ey;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tP S(sx,sy), E(ex,ey);\n\t\tSegment SE( S , E );\n\t\t\n\t\tbool flag = false;\n\t\tvector<Segment> v;\n\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\tint min_x, min_y, max_x, max_y, h;\n\t\t\tcin >> min_x >> min_y >> max_x >> max_y >> h;\n\t\t\tSegment s1( P(min_x,min_y) , P(min_x,max_y) );\n\t\t\tSegment s2( P(min_x,min_y) , P(max_x,min_y) );\n\t\t\tSegment s3( P(min_x,max_y) , P(max_x,max_y) );\n\t\t\tSegment s4( P(max_x,min_y) , P(max_x,max_y) );\n\t\t\tif( min_x <= sx && sx <= max_x && min_y <= sy && sy <= max_y ){\n\t\t\t\tflag = true;\n\t\t\t}else if( min_x <= ex && ex <= max_x && min_y <= ey && ey <= max_y ){\n\t\t\t\tflag = true;\n\t\t\t}else if( SE.is_intersection(s1) || SE.is_intersection(s2) ){\n\t\t\t\tflag = true;\n\t\t\t}else if( SE.is_intersection(s3) || SE.is_intersection(s4) ){\n\t\t\t\tflag = true;\n\t\t\t}else if( !flag ){\n\t\t\t\tdouble d = min( SE.distance(s1), SE.distance(s2) );\n\t\t\t\td = min( d , min( SE.distance(s3), SE.distance(s4) ) );\n\t\t\t\tP p1(d,0);\n\t\t\t\tP p2(d,h);\n\t\t\t\tv.push_back( Segment(p1,p2) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( flag ){\n\t\t\tcout << 0 << endl;\n\t\t}else{\n\t\t\tdouble low=0, high=1000, mid;\n\t\t\tfor(int i=0 ; i < 100 ; i++ ){\n\t\t\t\tmid = (low+high) / 2.0;\n\t\t\t\tCircle c( P(0,mid) , mid );\n\t\t\t\tbool flag = false;\n\t\t\t\tfor(int j=0 ; j < v.size() ; j++ ){\n\t\t\t\t\tLine l( v[j].a , v[j].b );\n\t\t\t\t\tpair<P,P> pp = c.intersection( l );\n\t\t\t\t\tif( pp.first == pp.second ) continue;\n\t\t\t\t\tif( v[j].contain( pp.first ) || v[j].contain( pp.second ) ){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( flag ){\n\t\t\t\t\thigh = mid;\n\t\t\t\t}else{\n\t\t\t\t\tlow = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%.8f\\n\", mid);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<int,int> Pi;\ntypedef pair<double,int> Pd;\ntypedef pair<Pd,Pi> S;\n\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\n/*\n  ?????????????????????\n  a.real() * b.real() + a.imag() * b.imag()\n*/\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\n\n/*\n  ?????????????????????\n  a.real() * b.imag() - a.imag() * b.real()\n*/\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\n\n// ????????¨?????????????????????????????????????????????true???\nbool isIntersect(L s1, L s2){\n  \n  //ccw ??????????????????????????¨, ????????????????????´?????????????????¨??????????????????????????????\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  //??´?????¨???????????¢\n}\n\n\n// ????????¨??????????????¢\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\n\ndouble cal(L a,L b,double h){\n  double d=getDistanceSS(a,b);\n  if(!d)return 0;\n  return (h*h+d*d)/2/h;\n}\n\nint main(){\n  int n;\n\n  while(cin>>n,n){\n    double ans=1e9;\n    P s,e;\n    double minx,maxx,miny,maxy,h;\n    cin>>s.x>>s.y>>e.x>>e.y;\n    for(int i=0;i<n;i++){\n      cin>>minx>>miny>>maxx>>maxy>>h;\n      if(minx<=s.x&&s.x<=maxx&&miny<=s.y&&s.y<=maxy)ans=0;\n      if(minx<=e.x&&e.x<=maxx&&miny<=e.y&&e.y<=maxy)ans=0;\n      ans=min(ans,cal(L(s,e),L(P(minx,miny),P(minx,maxy)),h));\n      ans=min(ans,cal(L(s,e),L(P(minx,maxy),P(maxx,maxy)),h));\n      ans=min(ans,cal(L(s,e),L(P(maxx,maxy),P(maxx,miny)),h));\n      ans=min(ans,cal(L(s,e),L(P(maxx,miny),P(minx,miny)),h));\n    }\n    printf(\"%.8lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double INF = 1e+9;\nconst double EPS = 1e-8;\n\nstruct Circle{\n  P c;\n  double r;\n\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n\n  double get_r(double h){\n    h = max(r - h, 0.0);\n    return sqrt(r*r - h*h);\n  }\n};\n\nstruct rect{\n  P p[4];\n  double h;\n  \n  rect(double minx, double miny, double maxx, double maxy, double h):h(h){\n    p[0] = P(minx, miny);\n    p[1] = P(maxx, miny);\n    p[2] = P(maxx, maxy);\n    p[3] = P(minx, maxy);\n  }\n};\n\nstruct state{\n  P p;\n  int pos;\n  state(P p, int pos):p(p),pos(pos){}\n};\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nP proj(P p, L l){\n    return l.first + dot(p - l.first, l.second - l.first) / norm(l.second - l.first) * (l.second - l.first);\n}\n\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nbool isIntersect(L s1, L s2){\n  \n  //ccw ??????????????????????????¨, ????????????????????´?????????????????¨??????????????????????????????\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\nenum {OUT, BORDER, IN};\nint convex_contains(P v[], int n, P p){ \n  P g = (v[0] + v[n/3] + v[2*n/3]) / 3.0; \n  int a = 0, b = n; \n  while(a + 1 < b){ \n    int c = (a + b) / 2; \n    if(cross(v[a] - g, v[c] - g) > EPS){ \n      if(cross(v[a]-g, p-g) > EPS && cross(v[c]-g, p-g) < -EPS) b = c; \n      else a = c; \n    } else { \n      if(cross(v[a]-g, p-g) < EPS && cross(v[c]-g, p-g) > -EPS) a = c; \n      else b = c; \n    } \n  } \n  b %= n; \n  if(cross(v[a] - p, v[b] - p) < -EPS) return 0; \n  if(cross(v[a] - p, v[b] - p) > EPS) return 2; \n  return 1; \n}\n\nvector<P> getIntersectCS(Circle c, L s){\n  vector<P> res;\n  P h = proj(c.c, s);\n  double d = abs(c.c - h);\n  if(d > c.r + EPS);\n  else if(d > c.r - EPS){\n    if(isIntersectSP(s,h)) res.push_back(h);\n  }\n  else {\n    P v = s.second - s.first;\n    v = (sqrt(c.r*c.r - d*d) / abs(v)) * v;\n    if(isIntersectSP(s, h+v)) res.push_back(h+v);\n    if(isIntersectSP(s, h-v)) res.push_back(h-v);\n  }\n  return res;\n}\n\n\nint n;\nP st, go;\nvector<rect> v;\nvector<state> pv;\n\nvoid make_pv(){\n  L l = L(st, go);\n\n  pv.clear();\n  for(int i=0;i<v.size();i++){\n    P ce = v[i].p[0];\n    for(int j=0;j<4;j++){\n      P res = proj(v[i].p[j], l);\n      if(isIntersectSP(l, res)) pv.push_back(state(res, i));      \n      if(j > 0) ce += v[i].p[j];\n    }    \n    ce /= 4.0;\n\n    P res = proj(ce, l);\n    if(isIntersectSP(l, res)) {\n      pv.push_back(state(res, i));\n    }\n\n    pv.push_back(state(st, i));\n    pv.push_back(state(go, i));\n  }\n}\n\nbool isok(double mid){\n  for(int i=0;i<pv.size();i++){\n    Circle c = Circle(pv[i].p, mid);\n    const rect &rec = v[pv[i].pos];\n    Circle hc = Circle(c.c, c.get_r(rec.h));\n    for(int j=0;j<4;j++){\n      L lp = L(rec.p[j], rec.p[(j+1)%4]);\n      if(getIntersectCS(hc, lp).size() >= 1 || abs(hc.c - rec.p[j]) < hc.r + EPS){\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\ndouble solve(){\n  double le = 0.0, ri = INF, mid;\n\n  for(int i=0;i<n;i++){\n    if(convex_contains(v[i].p, 4, st) != OUT || convex_contains(v[i].p, 4, go) != OUT){\n      return 0.0;\n    }\n    for(int j=0;j<4;j++){\n      if(isIntersect(L(st, go), L(v[i].p[j], v[i].p[(j+1)%4]))){\n        return 0.0;\n      }\n    }\n  }\n\n  make_pv();\n\n  while(ri - le > EPS){\n    mid = (le + ri) / 2.0;\n    if(isok(mid)) le = mid;\n    else ri = mid;\n  }\n\n  return (le + ri) / 2.0;\n}\n\nint main(){\n  double x1, y1, x2, y2, h;\n  while(cin >> n && n){\n    v.clear();\n    cin >> x1 >> y1 >> x2 >> y2;\n    st = P(x1, y1);\n    go = P(x2, y2);\n    for(int i=0;i<n;i++){\n      cin >> x1 >> y1 >> x2 >> y2 >> h;\n      v.push_back(rect(x1, y1, x2, y2, h));      \n    }\n    printf(\"%.7f\\n\", solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nvoid print(Point p);\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tprint(p1);\n\t\t\tprint(p2);\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p1;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tif(x>=-1&&x<=1) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\nbool is(P a,P b,P c,P d){\n  return (a.real()<=d.real())==(c.real()<=b.real())\n    &&(a.imag()<=d.imag())==(c.imag()<=b.imag())\n    &&cr(a-b,c-b)*cr(a-b,d-b)<=0&&cr(c-d,a-d)*cr(c-d,b-d)<=0;\n}\n\ndouble dt(P a,P b,P c,P d){\n  P p[4]={a,b,c,d};\n  double m=1<<30;\n  for(int i=0;i<2;i++){\n    for(int j=0;j<2;j++){\n      m=min(m,abs(p[i]-p[j+2]));\n    }\n  }\n  for(int i=0;i<2;i++){\n    swap(p[0],p[2]);\n    swap(p[1],p[3]);\n    for(int j=0;j<2;j++){\n      if(dot(p[2+j]-p[0],p[1]-p[0])*dot(p[2+j]-p[1],p[0]-p[1])>0){\n\tm=min(m,fabs(cr(p[2+j]-p[0],p[1]-p[0]))/abs(p[1]-p[0]));\n      }\n    }\n  }\n  //  cout<<a<<' '<<b<<' '<<c<<' '<<d<<' '<<m<<endl;\n  return m;\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    int sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    P s=P(sx,sy),e=P(ex,ey);\n    int ix[50],iy[50],ax[50],ay[50],h[50];\n    P ll[50],hl[50],hh[50],lh[50];\n    bool on=false;\n    for(int i=0;i<n;i++){\n      cin>>ix[i]>>iy[i]>>ax[i]>>ay[i]>>h[i];\n      ll[i]=P(ix[i],iy[i]);\n      hl[i]=P(ax[i],iy[i]);\n      hh[i]=P(ax[i],ay[i]);\n      lh[i]=P(ix[i],ay[i]);\n      on|=is(s,e,ll[i],hl[i])|is(s,e,hl[i],hh[i])|is(s,e,hh[i],lh[i])|is(s,e,lh[i],ll[i]);\n      on|=ix[i]<=min(sx,ex)&&max(sx,ex)<=ax[i]&&iy[i]<=min(sy,ey)&&max(sy,sy)<=ay[i];\n    }\n    if(on){\n      cout<<0<<endl;\n    }else{\n      double m=1<<30;\n      for(int i=0;i<n;i++){\n\tP *p[4]={ll+i,hl+i,hh+i,lh+i};\n\tfor(int j=0;j<4;j++){\n\t  double d=dt(*p[j],*p[(j+1)%4],e,s);\n\t  if(d<h[i]){\n\t    m=min(m,d);\n\t  }else{\n\t    m=min(m,(d*d+h[i]*h[i])/2/h[i]);\n\t  }\n\t}\n      }\n      cout<<fixed<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-8;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// ベクトル演算\ndouble dot(P a, P b) {return (a.real()*b.real()+a.imag()*b.imag());}\t// 内積\ndouble cross(P a, P b) {return (a.real()*b.imag()-a.imag()*b.real());}\t// 外積\nbool orth(P a1, P a2, P b1, P b2) {return deq(dot(a1-a2,b1-b2),0.0);}\t// 直交\nbool para(P a1, P a2, P b1, P b2) {return deq(cross(a1-a2,b1-b2),0.0);}\t// 平行\nbool pol(P a, P b, P c) {return deq(cross(b-a,c-a),0.0);}\t// 点cが直線ab上にあるかどうか\nbool pols(P a, P b, P c) {return (abs(a-c)+abs(c-b)<abs(a-b)+eps);}\t// 点cが線分ab上にあるかどうか\nbool intls(P a1, P a2, P b1, P b2) {\t// 線分a1a2と線分b1b2の交差判定\n\treturn (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<eps)\n\t\t   && (cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<eps);}\nP pintl(P a1, P a2, P b1, P b2) {\t// 直線a1a2と直線b1b2の交点 (要交差判定)\n\tP a = a2-a1, b = b2-b1;\n\treturn a1+a*cross(b,b1-a1)/cross(b,a);}\nP pintls(P a1, P a2, P b1, P b2) {\t// 線分a1a2と線分b1b2の交点 (〃)\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b,a1-b1)), d2 = abs(cross(b,a2-b1)), t = d1/(d1+d2);\n\treturn a1+(a2-a1)*t;}\ndouble disl(P a, P b, P c) {return abs(cross(b-a,c-a))/abs(b-a);}\t// 点cと直線abとの距離\ndouble disls(P a, P b, P c) {\t// 点cと線分abとの距離\n\tif (dot(b-a,c-a)<eps) return abs(c-a);\n\tif (dot(a-b,c-b)<eps) return abs(c-b);\n\treturn abs(cross(b-a,c-a))/abs(b-a);}\ndouble dislss(P a1, P a2, P b1, P b2) {\t// 線分a1a2と線分b1b2の距離\n\tif (abs(cross(a1-a2,b1-b2))>=eps && intls(a1,a2,b1,b2)) return 0;\n\tdouble a = min(disls(a1,a2,b1),disls(a1,a2,b2)), b = min(disls(b1,b2,a1),disls(b1,b2,a2));\n\treturn min(a,b);}\n\nint n, xl[50], yl[50], xr[50], yr[50], h[50];\ndouble d[50];\nP s, g;\n\nvector<double> res;\n\nbool ok(double r) {\n\trep(i,n) {\n\t\tif (r<=h[i] && d[i]<r) return false;\n\t\telse if (h[i]<r) {\n\t\t\tdouble t = sqrt(d[i]*d[i] + (r-h[i])*(r-h[i]));\n\t\t\tif (t<r) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\tdouble sx, sy, gx, gy;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\ts = P(sx,sy), g = P(gx,gy);\n\t\trep(i,n) {\n\t\t\tcin >> xl[i] >> yl[i] >> xr[i] >> yr[i] >> h[i];\n\t\t\tP p1 = P(xl[i],yl[i]), p2 = P(xr[i],yl[i]), p3 = P(xr[i],yr[i]), p4 = P(xl[i],yr[i]);\n\t\t\tdouble a = min(dislss(p1,p2,s,g), dislss(p2,p3,s,g)), b = min(dislss(p3,p4,s,g), dislss(p4,p1,s,g));\n\t\t\td[i] = min(a,b);\n\t\t\tif (intls(p1,p3,s,g) || intls(p2,p4,s,g)) d[i] = 0;\n\t\t}\n\t\tdouble l = 0, r = 1001;\n\t\trep(i,100) {\n\t\t\tdouble m = (l+r)/2;\n\t\t\tif (ok(m)) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tprintf(\"%.14lf\\n\",l);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\ntypedef double Num;\ntypedef complex<Num> Pt2;\ntypedef vector<Pt2>  Polygon2;\n\nstruct Line2 : public vector<Pt2> {\n\tLine2(Pt2 a, Pt2 b) { push_back(a); push_back(b); }\n};\n\nconst double eps = 1e-10;\nNum  dot  (Pt2 a, Pt2 b) { return (a*conj(b)).real(); }\nNum  cross(Pt2 a, Pt2 b) { return (conj(a)*b).imag(); }\nPt2  vec  (Line2 l)      { return l[1]-l[0]; }\n\nint ccw(Pt2 a, Pt2 b, Pt2 c) {\n\tb-=a; c-=a;\n\tif(cross(b,c) > 0 ) return +1; // ccw\n\tif(cross(b,c) < 0 ) return -1; // cw\n\tif(  dot(b,c) < 0 ) return +2; // cab\n\tif(norm(b)<norm(c)) return -2; // abc\n\treturn 0;                      // acb\n}\n\nint ccw(Line2 s, Pt2 p) {\n\treturn ccw(s[0], s[1], p);\n}\n\nbool intersectSP(Line2 s, Pt2 p) {\n\treturn abs(s[0]-p)+abs(s[1]-p) < abs(s[1]-s[0])+eps;\n}\n\nbool intersectSS(Line2 s, Line2 t) {\n\treturn ccw(s,t[0])*ccw(s,t[1]) <= 0 \n\t    && ccw(t,s[0])*ccw(t,s[1]) <= 0;\n}\n\nPt2 projection(Line2 l, Pt2 p) {\n  double t = dot(p-l[0], vec(l)) / norm(vec(l));\n  return l[0] + t*(vec(l));\n}\n\nPt2 reflection(Line2 l, Pt2 p) {\n\treturn p + 2.0*(projection(l,p) - p);\n}\n\nNum distanceSP(Line2 s, Pt2 p) {\n  Pt2 r = projection(s,p);\n  if(intersectSP(s,r)) return abs(r-p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\nNum distanceSS(Line2 s, Line2 t) {\n  if(intersectSS(s,t)) return 0;\n  return min(min(distanceSP(s,t[0]), distanceSP(s,t[1])),\n             min(distanceSP(t,s[0]), distanceSP(t,s[1])));\n}\n\nbool convex_contains(Polygon2 g, Pt2 p)\n{\n\tfor(int i=0; i<g.size(); i++)\n\t{\n\t\tif(ccw(Line2(g[i],g[(i+1)%g.size()]), p)==-1) return false;\n\t}\n\treturn true;\n}\n\ndouble dist(Line2 s, Line2 t, double h) {\n\tdouble d=distanceSS(s,t);\n\tif(d<=h) return d;\n\treturn (d*d+h*h)/(2*h);\n}\n\n\nint main()\n{\n\tint N;\n\twhile(cin>>N, N)\n\t{\n\t\tNum x1,y1,x2,y2,h;\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tLine2 course(Pt2(x1,y1),Pt2(x2,y2));\n\n\t\tdouble ans=1e10;\n\t\twhile(N--)\n\t\t{\t\t\n\t\t\tcin>>x1>>y1>>x2>>y2>>h;\n\t\t\tPolygon2 g(4);\n\t\t\tg[0]=Pt2(x1,y2); g[3]=Pt2(x2,y2);\n\t\t\tg[1]=Pt2(x1,y1); g[2]=Pt2(x2,y1);\n\n\t\t\tif(convex_contains(g,course[0]) || convex_contains(g,course[1]))\n\t\t\t{\n\t\t\t\tans=0;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<g.size(); i++)\n\t\t\t{\n\t\t\t\tans = min(ans, dist(course,Line2(g[i],g[(i+1)%g.size()]),h));\n\t\t\t}\n\n\t\t}\n\t\tcout.setf(ios::fixed);\n\t\tcout.precision(5);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<complex>\n#include<vector>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n \nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP start,end;\nP wolf[50][4];\ndouble h[50];\nint main(){\n    int a;\n    while(scanf(\"%d\",&a),a){\n        int W,Z,X,Y;\n        scanf(\"%d%d\",&X,&Y);\n        start=P(X,Y);\n        scanf(\"%d%d\",&X,&Y);\n        end=P(X,Y);\n        double left=0;\n        double right=1000;\n        for(int i=0;i<a;i++){\n            scanf(\"%d%d%d%d%lf\",&X,&Y,&W,&Z,h+i);\n            if((real(start)-X)*(real(start)-W)<=0&&(imag(start)-Y)*(imag(start)-Z)<=0)right=0;\n            wolf[i][0]=P(X,Y);\n            wolf[i][1]=P(X,Z);\n            wolf[i][2]=P(W,Z);\n            wolf[i][3]=P(W,Y);\n        }\n        for(int i=0;i<100;i++){\n            double M=(left+right)/2;\n            bool ok=true;\n            for(int j=0;j<a;j++){\n                double V=M;\n                if(h[j]<M)V=sqrt(M*M-(M-h[j])*(M-h[j]));\n                for(int k=0;k<4;k++){\n                    if(distanceSS(L(start,end),L(wolf[j][k],wolf[j][(k+1)%4]))<V)ok=false;\n                }\n            }\n            if(ok)left=M;\n            else right=M;\n        }\n        printf(\"%f\\n\",left);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nconst double EPS = 1e-9;\ntemplate<typename T>\nT sqr(T a) { return a * a; }\n\nstruct search_point {\n\tdouble x, y;\n\tdouble h;\n\tsearch_point(double x_, double y_, double h_) {\n\t\tx = x_; y = y_; h = h_;\n\t}\n};\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tdouble sx, sy, ex, ey;\n\t\tvector<search_point> v;\n\t\tvector<pair<search_point,search_point> > line;\n\t\tvector<pair<search_point,search_point> > lect;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tdouble R = 10000;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble h;\n\t\t\tcin >> x0 >> y0 >> x1 >> y1 >> h;\n\n\t\t\tif(h < EPS)\n\t\t\t\th = EPS;\n\n\t\t\tv.push_back(search_point(x0, y0, h));\n\t\t\tv.push_back(search_point(x1, y1, h));\n\t\t\tv.push_back(search_point(x0, y1, h));\n\t\t\tv.push_back(search_point(x1, y0, h));\n\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x0, y0, 0), search_point(x1, y0, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x1, y0, 0), search_point(x1, y1, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x1, y1, 0), search_point(x0, y1, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x0, y1, 0), search_point(x0, y0, 0)));\n\n\t\t\tlect.push_back(pair<search_point,search_point>(search_point(x0, y0, 0), search_point(x1, y1, 0)));\n\n\t\t\tif(x0 < sx && sx < x1) {\n\t\t\t\tv.push_back(search_point(sx, y0, h));\n\t\t\t\tv.push_back(search_point(sx, y1, h));\n\t\t\t}\n\t\t\tif(y0 < sy && sy < y1) {\n\t\t\t\tv.push_back(search_point(x0, sy, h));\n\t\t\t\tv.push_back(search_point(x1, sy, h));\n\t\t\t}\n\t\t\tif(x0 < ex && ex < x1) {\n\t\t\t\tv.push_back(search_point(ex, y0, h));\n\t\t\t\tv.push_back(search_point(ex, y1, h));\n\t\t\t}\n\t\t\tif(y0 < ey && ey < y1) {\n\t\t\t\tv.push_back(search_point(x0, ey, h));\n\t\t\t\tv.push_back(search_point(x1, ey, h));\n\t\t\t}\n\t\t}\n\n\t\tdouble veclx = (ex - sx);\n\t\tdouble vecly = (ey - sy);\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tdouble d;\n\t\t\tdouble mx, my;\n\t\t\tdouble r;\n\n\t\t\tmx = (v[i].x * sqr(veclx) + v[i].y * veclx * vecly + vecly * (sx * ey - sy * ex)) / (sqr(veclx) + sqr(vecly));\n\t\t\tmy = (v[i].y * sqr(vecly) + v[i].x * vecly * veclx + veclx * (sy * ex - sx * ey)) / (sqr(vecly) + sqr(veclx));\n\t\t\t/*\n\t\t\tif((ey - sy) * mx - (ex - sx) * my + (ex * sy - sx * ey) > EPS) {\n\t\t\t\tcout << \"error\" << \" \" << (sy - ey) * mx - (sx - ex) * my - (ex * sy - sx * ey) << endl;\n\t\t\t\tcout << mx << \",\" << my << endl;\n\t\t\t}\n\t\t\t// */\n\t\t\td = sqrt(sqr(mx - v[i].x) + sqr(my - v[i].y));\n\t\t\tif(mx <= min(sx,ex) || max(sx,ex) <= mx || my <= min(sy,ey) || max(sy,ey) <= my) {\n\t\t\t\td = min(sqrt(sqr(sx - v[i].x) + sqr(sy -  v[i].y)), sqrt(sqr(ex - v[i].x) + sqr(ey - v[i].y)));\n\t\t\t}\n\t\t\tr = fabs(sqr(min(v[i].h,d)) + sqr(d)) / (2 * v[i].h);\n\t\t\tR = min(R, r);\n\t\t}\n\t\tfor(int i = 0; i < line.size(); i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble s, t;\n\t\t\tx0 = line[i].first.x; y0 = line[i].first.y;\n\t\t\tx1 = line[i].second.x; y1 = line[i].second.y;\n\n\t\t\ts = ((ex - sx) * (y1 - sy) - (ey - sy) * (x1 - sx)) / ((x0 - sx) * (y1 - sy) - (y0 - sy) * (x1 - sx));\n\t\t\tt = ((ex - sx) * (y0 - sy) - (ey - sy) * (x0 - sx)) / ((x1 - sx) * (y0 - sy) - (y1 - sy) * (x0 - sx));\n\n\t\t\tif(isnan(s) || isnan(t))\n\t\t\t\texit(1);\n\n\t\t\tif(s > 0 && t > 0 && s + t >= 1)\n\t\t\t\tR = 0;\n\t\t}\n\t\tfor(int i = 0; i < lect.size(); i++) {\n\t\t\tbool flag0, flag1;\n\t\t\tflag0 = lect[i].first.x < sx && sx < lect[i].second.x && lect[i].first.y < sy && sy < lect[i].second.y;\n\t\t\tflag1 = lect[i].first.x < ex && ex < lect[i].second.x && lect[i].first.y < ey && ey < lect[i].second.y;\n\n\t\t\tif(flag0 | flag1)\n\t\t\t\tR = 0;\n\t\t}\n\t\tprintf(\"%.10f\\n\", R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e9)\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(P a, P b, P c){\n  if(cross(b-a,c-a) > EPS) return 1;\n  if(cross(b-a,c-a) < -EPS) return -1;\n  if(dot(b-a,c-a) < EPS) return 2;\n  if(abs(b-a) + EPS < abs(c-a)) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\ndouble p_to_s_dist(P a, L s){\n  if(dot(s.second-s.first,a-s.first) >= 0 && dot(s.first-s.second,a-s.second) >= 0){\n    return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n  }\n  return min(abs(a-s.first), abs(a-s.second));\n}\n\ndouble s_to_s_dist(L a, L b){\n  if(is_cross(a,b)) return 0;\n  return min(min(p_to_s_dist(a.first,b),p_to_s_dist(a.second,b)),\n\t     min(p_to_s_dist(b.first,a),p_to_s_dist(b.second,a)));\n}\n\nint main(){\n  int N;\n  double h, d, x[2], y[2];\n  while(cin >> N, N){\n    vector<P> V;\n    cin >> x[0] >> y[0] >> x[1] >> y[1];\n    P s = P(x[0],y[0]), e = P(x[1],y[1]);\n    L c = L(s,e);\n    for(int i = 0; i < N; ++i){\n      cin >> x[0] >> y[0] >> x[1] >> y[1] >> h;\n      L edge[4];\n      for(int j = 0; j < 4; ++j){\n\tedge[j] = L(P(x[j/2],y[j%2]),P(x[((j+1)/2)%2],y[(j+1)%2]));\n      }\n      d = 100000;\n      for(int j = 0; j < 4; ++j){\n\td = min(d, s_to_s_dist(c, edge[j]));\n      }\n      V.push_back(P(d,h));\n    }\n    sort(V.begin(), V.end());\n    double ub = 100000, lb = 0, r = ub/2;\n    for(int t = 0; t < 10000; ++t){\n      r = (ub+lb)/2;\n      bool f = true;\n      for(int i = 0; i < N; ++i){\n\tif((V[i].X < EPS) || ((r > norm(V[i])/2/V[i].Y || V[i].Y > r) && (r > V[i].X))){\n\t  f = false;\n\t  break;\n\t}\n      }\n      if(f) lb = r;\n      else ub = r;\n    }\n    printf(\"%.4lf\\n\", r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cos慮\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sin慮\n    }\n};\n\ndouble segmentPointDist(const Point& a1, const Point& a2, const Point& p)\n{\n    if((a2-a1).dot(p-a1) < 0)\n        return a1.dist(p);\n    else if((a1-a2).dot(p-a2) < 0)\n        return a2.dist(p);\n    else\n        return abs((a2-a1).cross(p-a1)) / a1.dist(a2);\n}\n\ndouble segmentsDist(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) < -EPS) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) < -EPS))\n        return 0.0;\n\n    double ret = segmentPointDist(a1, a2, b1);\n    ret = min(ret, segmentPointDist(a1, a2, b2));\n    ret = min(ret, segmentPointDist(b1, b2, a1));\n    ret = min(ret, segmentPointDist(b1, b2, a2));\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        Point s, e;\n        cin >> s.x >> s.y >> e.x >> e.y;\n\n        vector<vector<Point> > p(n, vector<Point>(4));\n        vector<double> h(n);\n        double ret = DBL_MAX;\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<2; ++j)\n                cin >> p[i][j*2].x >> p[i][j*2].y;\n            cin >> h[i];\n\n            p[i][1] = Point(p[i][0].y, p[i][2].x);\n            p[i][3] = Point(p[i][2].y, p[i][0].x);\n\n            if(p[i][0].x <= s.x && s.x <= p[i][2].x && p[i][0].y <= s.y && s.y <= p[i][2].y)\n                ret = 0.0;\n        }\n\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<4; ++j){\n                double d = segmentsDist(s, e, p[i][j], p[i][(j+1)%4]);\n                if(d < EPS){\n                    ret = 0.0;\n                }else if(d < h[i]){\n                    ret = min(ret, d);\n                }else{\n                    double r = (pow(h[i], 2.0) + pow(d, 2.0)) / (2 * h[i]);\n                    ret = min(ret, r);\n                }\n            }\n        }\n\n        printf(\"%.10f\\n\", ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\nint i,j,t;\n\nclass P{\npublic:\n\tdouble x,y;\n\tP(){}\n\tP(const double &s, const double &e){x=s;y=e;}\n};\nclass L{\npublic:\n\tP p1,p2;\n\tL(){}\n\tL(P p1, P p2){this->p1=p1;this->p2=p2;}\n\tL reflect(L l);\n};\nint isIntersect(L l1, L l2){\n\tif (((l1.p1.x - l1.p2.x) * (l2.p1.y - l1.p1.y) + (l1.p1.y - l1.p2.y) * (l1.p1.x - l2.p1.x)) * \n\t\t((l1.p1.x - l1.p2.x) * (l2.p2.y - l1.p1.y) + (l1.p1.y - l1.p2.y) * (l1.p1.x - l2.p2.x)) < 0){\n\t\tif (((l2.p1.x - l2.p2.x) * (l1.p1.y - l2.p1.y) + (l2.p1.y - l2.p2.y) * (l2.p1.x - l1.p1.x)) * \n\t\t\t((l2.p1.x - l2.p2.x) * (l1.p2.y - l2.p1.y) + (l2.p1.y - l2.p2.y) * (l2.p1.x - l1.p2.x)) < 0\t){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\ndouble lpdistance(L l, P p){\n\tint dx, dy, r2;\n\tdouble t, cx, cy;\n\tdx = l.p2.x - l.p1.x;\n\tdy = l.p2.y - l.p1.y;\n\tif (dx == 0 && dy == 0)\n\t\treturn sqrt((p.x - l.p1.x) * (p.x - l.p1.x) + (p.y - l.p1.y) * (p.y - l.p1.y));\n\tr2 = dx * dx + dy * dy;\n\tt = (dx * (p.x - l.p1.x) + dy * (p.y - l.p1.y)) / (double)r2;\n\tif (t < 0)\n\t\treturn sqrt((p.x - l.p1.x) * (p.x - l.p1.x) + (p.y - l.p1.y) * (p.y - l.p1.y));\n\tif (t * t > r2)\n\t\treturn sqrt((p.x - l.p2.x) * (p.x - l.p2.x) + (p.y - l.p2.y) * (p.y - l.p2.y));\n\tcx = (1 - t) * l.p1.x + t * l.p2.x;\n\tcy = (1 - t) * l.p1.y + t * l.p2.y;\n\treturn sqrt((p.x - cx) * (p.x - cx) + (p.y - cy) * (p.y - cy));\n}\n\ndouble lldistance(L l1, L l2){\n\tif(isIntersect(l1, l2)) return 0;\n\tdouble minl = lpdistance(l1, l2.p1);\n\tminl = min(minl, lpdistance(l1, l2.p2));\n\tminl = min(minl, lpdistance(l2, l1.p1));\n\tminl = min(minl, lpdistance(l2, l1.p2));\n\treturn minl;\n}\n\nmain(){\n\tint N,i,j;\n\twhile(cin>>N, N){\n\t\tdouble x1,y1,x2,y2,h,Min = 1e6;\n\t\tP S,E;\n\t\tcin >> S.x>>S.y>>E.x>>E.y;\n\t\tfor(i=0;i<N;i++){\n\t\t\tcin >> x1>>y1>>x2>>y2>>h;\n\t\t\tP p1 = P(x1,y1);\n\t\t\tP p2 = P(x1,y2);\n\t\t\tP p3 = P(x2,y1);\n\t\t\tP p4 = P(x2,y2);\n\t\t\tdouble l = lldistance(L(p1, p2), L(S, E));\n\t\t\tif(lldistance(L(p2, p4), L(S, E)) < l) l = lldistance(L(p2, p4), L(S, E));\n\t\t\tif(lldistance(L(p4, p3), L(S, E)) < l) l = lldistance(L(p4, p3), L(S, E));\n\t\t\tif(lldistance(L(p3, p1), L(S, E)) < l) l = lldistance(L(p3, p1), L(S, E));\n\t\t\tdouble a;\n\t\t\tif(l < h) a = l;\n\t\t\telse{\n\t\t\t\ta = (h*h+l*l)/2/h;\n\t\t\t}\n\t\t\tif(x1 < S.x && y1 < S.y && E.x < x2 && E.y < y2) a = 0;\n\t\t\tMin = min(Min, a);\n\t\t}\n\t\t\n\t\t\n\t\tprintf(\"%.5lf\\n\", Min);\n\t}\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n  bool operator<(const P &lhs, const P &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n  }\n}\n\n// Line\nclass L{\npublic:\n  P a, b;\n  L (P aa, P bb) { a = aa; b = bb; }\n  L (ld ax, ld ay, ld bx, ld by) { a = P(ax, ay); b = P(bx, by); }\n};\n\nint ccw (P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // counter clockwise\n  if (cross(b, c) < -eps) return -1; // clockwise\n  if (dot(b, c) < 0) return 2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line\n  return 0;                          // a--c--b on line\n}\n\nbool isis_ss(L s, L t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n         ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_sp(L s, P p) {\n  return abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nld dist_sp(L s, P p) {\n  P r = proj(s, p);\n  if (isis_sp(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n  if (isis_ss(s, t)) return 0;\n  ld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n  ld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n  return min(a, b);\n}\n\nint main() {\n  while(1) {\n    int n;\n    cin>>n;\n    if(!n) break;\n    ld sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    L l(sx,sy,ex,ey);\n    typedef tuple<ld,ld,ld,ld,ld> box;\n    vector<box> bv;\n    REP(i,n) {\n      int mnx,mny,mxx,mxy,h;\n      cin>>mnx>>mny>>mxx>>mxy>>h;\n      bv.emplace_back(mnx,mny,mxx,mxy,h);\n    }\n    ld lb = 0.0, ub = 1000.0;\n    REP(i,50) {\n      ld mid = (lb + ub) / 2.0;\n      bool ok = true;\n      REP(j,n) {\n        int mnx,mny,mxx,mxy,h;\n        tie(mnx,mny,mxx,mxy,h) = bv[j];\n        ld r = (h > mid) ? mid : sqrt(mid*mid - (mid-h)*(mid-h));\n        vector<L> vl;\n        vl.emplace_back(mnx,mny,mxx,mny);\n        vl.emplace_back(mnx,mxy,mxx,mxy);\n        vl.emplace_back(mnx,mny,mnx,mxy);\n        vl.emplace_back(mxx,mny,mxx,mxy);\n        REP(k,4)\n          if (dist_ss(vl[k], l) < r) ok = false;\n        if (max(sx,ex) < mxx && min(sx,ex) > mnx && max(sy,ey) < mxy && min(sy,ey) > mny) ok = false;\n      }\n      if (ok) lb = mid;\n      else ub = mid;\n    }\n    cout << setprecision(10) << fixed << lb << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst double EPS = 1e-6;\n\nstruct Point\n{\n\tdouble x, y;\n\n\tPoint() : x( 0 ), y( 0 ) {}\n\tPoint( const double x, const double y ) : x( x ), y( y ) {}\n\tPoint( const Point &a ) : x( a.x ), y( a.y ) {}\n\t\n\tconst Point operator + ( const Point &a ) const\n\t{\n\t\treturn Point( x + a.x, y + a.y );\n\t}\n\n\tPoint& operator += ( const Point &a ) \n\t{\n\t\tx += a.x;\n\t\ty += a.y;\n\n\t\treturn *this;\n\t}\n\n\tconst Point operator - ( const Point &a ) const\n\t{\n\t\treturn Point( x + ( -a.x ), y + ( -a.y ) );\n\t}\n\n\tPoint& operator -= ( const Point &a )\n\t{\n\t\tx -= a.x;\n\t\ty -= a.y;\n\n\t\treturn *this;\n\t}\n\n\tconst Point operator * ( const double a ) const\n\t{\n\t\treturn Point( x * a, y * a );\n\t}\n\n\tPoint& operator *= ( const double a )\n\t{\n\t\tx *= a;\n\t\ty *= a;\n\n\t\treturn *this;\n\t}\n\n\tconst Point operator / ( const double a ) const\n\t{\n\t\treturn Point( x / a, y / a );\n\t}\n\n\tPoint& operator /= ( const double a )\n\t{\n\t\tx /= a;\n\t\ty /= a;\n\n\t\treturn *this;\n\t}\n\n\tbool operator < ( const Point &a ) const\n\t{\n\t\treturn x == a.x ? y < a.y : x < a.x;\n\t}\n\n\tdouble abs() const\n\t{\n\t\treturn sqrt( pow( x, 2. ) + pow( y, 2. ) );\n\t}\n};\n\n// 二点間の距離\ndouble distance( const Point &a, const Point &b )\n{\n\treturn sqrt( pow( a.x - b.x, 2. ) + pow( a.y - b.y, 2. ) );\n}\n\n// 内積（ドット積）\ndouble dot( const Point &a, const Point &b )\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n// 外積（クロス積）\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// 線分 ( p1, p2 ) と点 q の距離\ndouble distance_segment_point( const Point &p1, const Point &p2, const Point q )\n{\n\tif ( EPS < dot( p2 - p1, q - p1 ) && EPS < dot( p1 - p2, q - p2 ) )\n\t{\n\t\treturn abs( cross( p2 - p1, q - p1 ) ) / ( p2 - p1 ).abs();\n\t}\n\telse\n\t{\n\t\treturn min( distance( p1, q ), distance( p2, q ) );\n\t}\n}\n\n// 線分 ( p1, p2 ) に点 q が乗っているか\nbool point_on_segment( const Point &p1, const Point &p2, const Point &q )\n{\n\treturn abs( cross( p1 - q, p2 - q ) ) <= EPS && dot( p1 - q, p2 - q ) <= EPS;\n}\n\n// 直線 ( p1, p2 ) と直線 ( q1, q2 ) の交点\nPoint lines_intersection( const Point &p1, const Point &p2, const Point &q1, const Point &q2 )\n{\n\treturn p1 + ( p2 - p1 ) * ( cross( q2 - q1, q1 - p1 ) / cross( q2 - q1, p2 - p1 ) );\n}\n\n// 線分 ( p1, p2 ) と線分 ( q1, q2 ) が交差するか\nbool segments_intersection( const Point &p1, const Point &p2, const Point &q1, const Point &q2 )\n{\t\t\n\tif ( abs( cross( p1 - p2, q1 - q2 ) ) <= EPS ) // is parallel\n\t{\n\t\treturn point_on_segment( p1, p2, q1 ) ||\n\t\t\t   point_on_segment( p1, p2, q2 ) ||\n\t\t\t   point_on_segment( q1, q2, p1 ) ||\n\t\t\t   point_on_segment( q1, q2, p2 );\n\t}\n\telse\n\t{\n\t\tPoint r( lines_intersection( p1, p2, q1, q2 ) );\n\t\treturn point_on_segment( p1, p2, r ) && point_on_segment( q1, q2, r );\n\t}\n}\n\n// 三角形 ( a, b, c ) の中に点 p があるか\nbool point_in_triangle( const Point &a, const Point &b, const Point &c, const Point &p )\n{\n\tint res = 0;\n\tres += EPS < cross( b - a, p - a ) ? 1 : -1;\n\tres += EPS < cross( c - b, p - b ) ? 1 : -1;\n\tres += EPS < cross( a - c, p - c ) ? 1 : -1;\n\n\tif ( abs( res ) == 3 )\n\t{\n\t\treturn true;\n\t}\n\treturn point_on_segment( a, b, p ) || point_on_segment( b, c, p ) || point_on_segment( c, a, p );\n}\n\ndouble search( const Point &p1, const Point &p2, const Point &q, const int h )\n{\n\tconst double dist = distance_segment_point( p1, p2, q );\n\tif ( dist - EPS <= h )\n\t{\n\t\treturn dist;\n\t}\n\n\tdouble lb = 0, ub = 1000;\n\tREP( i, 0, 100 )\n\t{\n\t\tdouble r = ( lb + ub ) / 2;\n\t\tif ( r <= distance( Point( 0, r ), Point( dist, h ) ) + EPS )\n\t\t{\n\t\t\tlb = r;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tub = r;\n\t\t}\n\t}\n\n\treturn lb;\n}\n\ndouble solve( const int n )\n{\n\tint sx, sy, ex, ey;\n\tcin >> sx >> sy >> ex >> ey;\n\tPoint s( sx, sy ), e( ex, ey );\n\n\tVI hs;\n\tvector< Point > points;\n\tvector< pair<Point,Point> > lines;\n\n\tREP( i, 0, n )\n\t{\n\t\tint x1, y1, x2, y2, h;\n\t\tcin >> x1 >> y1 >> x2 >> y2 >> h;\n\n\t\tpoints.PB( Point( x1, y1 ) );\n\t\tpoints.PB( Point( x2, y2 ) );\n\t\tpoints.PB( Point( x1, y2 ) );\n\t\tpoints.PB( Point( x2, y1 ) );\n\n\t\tlines.PB( MP( Point( x1, y1 ), Point( x1, y2 ) ) );\n\t\tlines.PB( MP( Point( x1, y1 ), Point( x2, y1 ) ) );\n\t\tlines.PB( MP( Point( x2, y2 ), Point( x1, y2 ) ) );\n\t\tlines.PB( MP( Point( x2, y2 ), Point( x2, y1 ) ) );\n\n\t\ths.PB( h );\n\t}\n\n\tREP( i, 0, lines.size() )\n\t{\n\t\tif ( segments_intersection( s, e, lines[i].fst, lines[i].snd ) )\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tREP( i, 0, n )\n\t{\n\t\tif ( point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 2 ], s ) ||\n\t\t\t point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 2 ], e ) ||\n\t\t\t point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 3 ], s ) ||\n\t\t\t point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 3 ], e ) )\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdouble res = 1000;\n\tREP( i, 0, n * 4 )\n\t{\n\t\tres = min( res, search( s, e, points[i], hs[ i / 4 ] ) );\n\t\tres = min( res, search( lines[i].fst, lines[i].snd, s, hs[ i / 4 ] ) );\n\t\tres = min( res, search( lines[i].fst, lines[i].snd, e, hs[ i / 4 ] ) );\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\tcout << setprecision( 4 ) << fixed;\n\n\twhile ( true )\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif ( !n )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << solve( n ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define endl \"\\n\"\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\n#define rrep(i, a, b) for (auto i = (a); i > (b); --i)\n#define UNIQUE(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\n#ifdef LOCAL_DEFINE\nstruct InitInput\n{\n  InitInput()\n  {\n    FILE *stream1;\n    stream1 = freopen(\"in.txt\", \"r\", stdin);\n    assert(stream1 != nullptr);\n    cerr << \"This problem is not interactive\" << endl;\n  }\n} LOCAL_INPUT;\nstruct LOCAL_OUTPUT\n{\n  LOCAL_OUTPUT()\n  {\n    FILE *stream2;\n    const char *outputfile = \"out.txt\";\n    stream2 = freopen(outputfile, \"w\", stdout);\n    assert(stream2 != nullptr);\n    cerr << \"output [ \" << outputfile << \" ]\" << endl;\n  }\n} /*LOCAL_OUTPUT*/;\n#define show(x) cerr << #x << \" = \" << (x) << \" (line \" << __LINE__ << \")\" << endl\n#define showA(a, n)                                            \\\n  do                                                           \\\n  {                                                            \\\n    for (int _i_t_e_ = 0; _i_t_e_ < (n); _i_t_e_++)            \\\n      cerr << \"(\" << _i_t_e_ << \" = \" << (a)[_i_t_e_] << \") \"; \\\n    cerr << endl;                                              \\\n  } while (0)\n#define showA2(a, n, m)                                                                        \\\n  do                                                                                           \\\n  {                                                                                            \\\n    for (int _i_t_e_ = 0; _i_t_e_ < (n); _i_t_e_++)                                            \\\n    {                                                                                          \\\n      for (int _i_t_e_2 = 0; _i_t_e_2 < (m); _i_t_e_2++)                                       \\\n      {                                                                                        \\\n        cerr << \"(\" << _i_t_e_ << \", \" << _i_t_e_2 << \" = \" << (a)[_i_t_e_][_i_t_e_2] << \") \"; \\\n      }                                                                                        \\\n      cerr << endl;                                                                            \\\n    }                                                                                          \\\n    cerr << endl;                                                                              \\\n  } while (0)\n#else\n#define show(x)\n#define showA(a, n)\n#define showA2(a, n, m)\n#endif\n\nstruct InitAim\n{\n  InitAim()\n  {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(12);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    cerr << \"This problem is not interactive\" << endl;\n#endif\n  }\n} aim_cpo;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconstexpr const int INT_INF = 0x3f3f3f3f;       //1061109567\nconstexpr const ll LL_INF = 0x3f3f3f3f3f3f3f3f; //4557430888798830399\n\ntemplate <typename T>\nbool chmin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T>\nbool chmax(T &a, T b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T>\nvoid ln(T i, T n) { cout << (i == n - 1 ? \"\\n\" : \" \"); }\ntemplate <typename T, typename S>\nostream &operator<<(ostream &out, const pair<T, S> &pair1)\n{\n  out << '(' << pair1.fi << \", \" << pair1.se << ')';\n  return out;\n}\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &vector1)\n{\n  out << '[';\n  for (unsigned int i = 0; i < vector1.size(); i++)\n  {\n    out << vector1[i];\n    if (i == vector1.size() - 1)\n      out << \"]\";\n    else\n      out << \", \";\n  }\n  return out;\n}\n\n// INT\n#define GCD(a, b) __gcd(a, b)\ntemplate <typename T>\nT LCM(T a, T b)\n{\n  return a / GCD(a, b) * b;\n}\ntemplate <typename T>\nT EXTGCD(T a, T b, T &x, T &y)\n{\n  T d = a;\n  if (b != 0)\n  {\n    d = EXTGCD(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n  else\n    x = 1, y = 0;\n  return d;\n}\ntemplate <typename T>\nbool is_prime(T a)\n{\n  for (int i = 2; i * i <= a; i++)\n    if (a % i == 0)\n      return true;\n  return false;\n}\ntemplate <typename T, typename S>\nT Pow(T a, S b)\n{\n  T res = 1, now = a;\n  while (b)\n  {\n    if (b & 1)\n      res *= now;\n    b >>= 1;\n    now *= now;\n  }\n  return res;\n}\n\n// MOD\nll MOD = 1000000000L + 7L;\n#define Madd(a, b) (((a) % MOD) + ((b) % MOD)) % MOD\n#define Mmul(a, b) (((a) % MOD) * ((b) % MOD)) % MOD\n#define Msub(a, b) (((a) % MOD) + MOD - ((b) % MOD)) % MOD\ntemplate <typename T, typename S>\nT ModPow(T a, S b)\n{\n  assert(b >= 0);\n  T res = 1, now = Msub(a, 0);\n  while (b)\n  {\n    if (b & 1)\n      res = Mmul(res, now);\n    b >>= 1;\n    now = Mmul(now, now);\n  }\n  return res;\n}\ntemplate <typename T>\nT ModInverse(T a, T mod, bool prime)\n{ // if mod is prime, \"prime\" is true.\n  if (prime)\n    return ModPow(a, mod - 2);\n  else\n  {\n    T x, y;\n    EXTGCD(a, mod, x, y);\n    return (mod + x % mod) % mod;\n  }\n}\ntemplate <typename T>\nT EulerTotient(T a)\n{\n  vector<pair<int, int>> v;\n  for (T i = 2; i * i <= a; i++)\n  {\n    int cnt = 0;\n    while (a % i == 0)\n    {\n      cnt++;\n      a /= i;\n    }\n    if (cnt != 0)\n      v.emplace_back(i, cnt);\n  }\n  if (a != 1)\n    v.emplace_back(a, 1);\n  //showV(v, (int) v.size());\n  T res = 1;\n  for (int i = 0; i < (int)v.size(); i++)\n  {\n    if (v[i].se == 1)\n    {\n      //res *= v[i].fi - 1;\n      res = Mmul(res, v[i].fi - 1);\n    }\n    else\n    {\n      //res *= Pow(v[i].fi, v[i].se) - Pow(v[i].fi, v[i].se - 1);\n      res = Mmul(res, Msub(ModPow(v[i].fi, v[i].se), ModPow(v[i].fi, v[i].se - 1)));\n    }\n  }\n  return res;\n}\n#define Mdivide(a, b) Mmul(((a) % MOD), (ModInverse((b), MOD, true))) % MOD\nll comb(ll a, ll b)\n{\n  chmin(b, a - b);\n  ll res = 1LL, now = a;\n  for (ll i = 1; i <= b; i++)\n  {\n    res = Mmul(res, now);  //res *= now;\n    res = Mdivide(res, i); // res /= i;\n    now--;\n  }\n  return res;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// TEMPLATE(data structure)\n///////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\nclass BIT\n{\npublic:\n  BIT(int size)\n  {\n    BITTable.assign(++size, 0);\n  }\n  T sum(int k)\n  {\n    T res = 0;\n    for (++k; k > 0; k -= k & -k)\n    {\n      res += BITTable[k];\n    }\n    return res;\n  }\n  T sum(int l, int r)\n  {\n    if (l == 0)\n      return sum(r);\n    return sum(r) - sum(l - 1);\n  }\n  void update(int k, T x)\n  { // b[k] += x;\n    for (++k; k < (int)BITTable.size(); k += k & -k)\n      BITTable[k] += x;\n  }\n\nprivate:\n  vector<T> BITTable;\n};\n\ntemplate <typename T>\nclass IntervalTree\n{\n  using F = function<T(T, T)>;\n\npublic:\n  IntervalTree(int n, const F func, const T init) : func(func), init(init)\n  {\n    size = 1;\n    while ((int)size < n)\n      size <<= 1;\n    table.assign(2 * size, init);\n  }\n  void set(int k, T &x)\n  {\n    table[size + k] = x;\n  }\n  void build()\n  {\n    for (int i = size - 1; i >= 0; --i)\n    {\n      table[i] = func(table[i * 2], table[i * 2 + 1]);\n    }\n  }\n  void update(int k, const T &x)\n  {\n    k += size;\n    table[k] = x;\n    while (k >>= 1)\n    {\n      table[k] = func(table[k * 2], table[k * 2 + 1]);\n    }\n  }\n  T query(int a, int b)\n  {\n    T L = init, R = init;\n    for (a += size, b += size; a < b; a >>= 1, b >>= 1)\n    {\n      if (a & 1)\n        L = func(L, table[a++]);\n      if (b & 1)\n        R = func(table[--b], R);\n    }\n    return func(L, R);\n  }\n  T operator[](const int k) const\n  {\n    return table[k + size];\n  }\n\nprivate:\n  unsigned int size;\n  vector<T> table;\n  const F func;\n  const T init;\n};\n\nclass UnionFind\n{\npublic:\n  explicit UnionFind(int _n) : n(_n)\n  {\n    par.resize(static_cast<unsigned long>(_n));\n    rank.resize(static_cast<unsigned long>(_n));\n    sizes.resize(static_cast<unsigned long>(_n));\n    for (int i = 0; i < _n; i++)\n    {\n      par[i] = i;\n      rank[i] = 0;\n      sizes[i] = 1;\n    }\n  }\n  int find(int a)\n  {\n    if (par[a] == a)\n      return a;\n    return par[a] = find(par[a]);\n  }\n  bool same(int a, int b)\n  {\n    return find(a) == find(b);\n  }\n  void unite(int a, int b)\n  {\n    link(find(a), find(b));\n  }\n  int size(int a)\n  {\n    return sizes[find(a)];\n  }\n  void view()\n  {\n    for (int i = 0; i < n; i++)\n    {\n      cout << \" par\"\n           << \"[\" << i << \"]=\" << par[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    for (int i = 0; i < n; i++)\n    {\n      cout << \"size\"\n           << \"[\" << i << \"]=\" << sizes[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    cout << endl;\n  }\n\nprivate:\n  void link(int a, int b)\n  {\n    if (same(a, b))\n      return;\n    if (rank[a] > rank[b])\n    {\n      par[b] = a;\n      sizes[a] += sizes[b];\n      sizes[b] = 0;\n    }\n    else\n    {\n      par[a] = b;\n      if (rank[a] == rank[b])\n        rank[b]++;\n      sizes[b] += sizes[a];\n      sizes[a] = 0;\n    }\n  }\n  int n;\n  vector<int> par;\n  vector<int> rank;\n  vector<int> sizes;\n};\n\nnamespace geo\n{\n#define IL inline\n#define FOR(i, bg, ed) for (int i = (bg); i < (ed); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\ntypedef double D;\ntypedef bool B;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\nB comp(const P &l, const P &r)\n{\n  return (l.X == r.X) ? l.Y < r.Y : l.X < r.X;\n}\ntypedef pair<P, P> L;  //line\ntypedef pair<P, P> LS; //line segment\ntypedef pair<P, D> C;  //circle\ntypedef vector<P> Poly;\nconst D EPS = 1e-8;\n//Decompotision Macro\n#define DCl(a, b, l) \\\n  P a, b;            \\\n  tie(a, b) = l\n#define DCc(a, b, c) \\\n  P a;               \\\n  D b;               \\\n  tie(a, b) = c\n\n//A dot B\nIL D dot(P a, P b) { return a.X * b.X + a.Y * b.Y; }\n//A cross B\nIL D cross(P a, P b) { return a.X * b.Y - a.Y * b.X; }\nIL D ccw(P a, P b, P c)\n{\n  return cross(b - a, c - a);\n}\n\nIL int sgn(P a, P b, P c)\n{\n  if (cross(b - a, c - a) > EPS)\n    return 1;\n  if (cross(b - a, c - a) < -EPS)\n    return -1;\n  if (dot(b - a, c - a) < -EPS)\n    return 2; // b-a-c\n  if (dot(a - b, c - b) < -EPS)\n    return -2; // a-b-c\n  return 0;\n}\nIL D signed_distance_P_L(P p, L l)\n{\n  DCl(a, b, l);\n  return ccw(a, b, p) / abs(b - a);\n}\n\nIL D distance_P_L(P p, L l)\n{\n  return abs(signed_distance_P_L(p, l));\n}\n\nIL D distance_P_LS(P p, LS ls)\n{\n  DCl(a, b, ls);\n  if (dot(b - a, p - a) < EPS)\n    return abs(p - a);\n  if (dot(a - b, p - b) < EPS)\n    return abs(p - b);\n  return abs(cross(b - a, p - a)) / abs(b - a);\n}\n\nIL B is_L_L(L p, L q)\n{\n  DCl(a, b, p);\n  DCl(c, d, q);\n  return abs(cross(a - b, c - d)) > EPS ||\n         abs(cross(a - b, d - b)) < EPS;\n}\nIL B is_L_LS(L l, LS ls)\n{\n  DCl(a, b, l);\n  DCl(c, d, ls);\n  return ccw(a, b, c) * ccw(a, b, d) < EPS;\n}\nIL B is_LS_LS(LS p, LS q)\n{\n  DCl(a, b, p);\n  DCl(c, d, q);\n  return sgn(a, b, c) * sgn(a, b, d) <= 0 && sgn(c, d, a) * sgn(c, d, b) <= 0;\n}\n\nIL D distance_LS_LS(LS p, LS q)\n{\n  if (is_LS_LS(p, q))\n    return 0;\n  return min({distance_P_LS(p.fi, q),\n              distance_P_LS(p.se, q),\n              distance_P_LS(q.fi, p),\n              distance_P_LS(q.se, p)});\n}\n\n//caution: have to use isintersected_L_L before this function\nIL P cross_L_L(L p, L q)\n{\n  DCl(a, b, p);\n  D d1 = signed_distance_P_L(a, q);\n  D d2 = signed_distance_P_L(b, q);\n  return (a * d2 - b * d1) / (d2 - d1);\n}\n\nIL B is_C_C(C p, C q)\n{\n  DCc(cp, rp, p);\n  DCc(cq, rq, q);\n  D d = abs(cp - cq);\n  return abs(rp - rq) - d < EPS &&\n         rp + rq - d > -EPS;\n}\nIL LS cross_C_C(C p, C q)\n{\n  DCc(cp, rp, p);\n  DCc(cq, rq, q);\n  D d = abs(cp - cq);\n  D rc = (d * d + rp * rp - rq * rq) / (2 * d);\n  D rs = sqrt(rp * rp - rc * rc);\n  P diff = (cq - cp) / d;\n  return {cp + P(rc, rs) * diff, cp + P(rc, -rs) * diff};\n}\nIL Poly convex_hull(Poly p)\n{\n  int n = p.size();\n  Poly res(2 * n);\n  int k = 0, t;\n  sort(ALL(p), comp);\n  REP(i, n)\n  {\n    while (k > 1 && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n      k--;\n    res[k++] = p[i];\n  }\n  t = k;\n  REP(j, n - 1)\n  {\n    int i = n - 2 - j;\n    while (k > t && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n      k--;\n    res[k++] = p[i];\n  }\n  res.resize(k - 1);\n  return res;\n}\nIL B convex_in(Poly &l, P &p)\n{\n  int a = 0, b = l.size(), c;\n  D A, C;\n  P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n  while (b - a > 1)\n  {\n    c = (a + b) / 2;\n    A = cross(l[a] - g, p - l[a]);\n    C = cross(l[c] - g, p - l[c]);\n    if (cross(l[a] - g, l[c] - g) >= 0)\n    {\n      if (A > -EPS && C < -EPS)\n        b = c;\n      else\n        a = c;\n    }\n    else\n    {\n      if (C < -EPS || A > -EPS)\n        b = c;\n      else\n        a = c;\n    }\n  }\n  return (cross(l[b % l.size()] - l[a], p - l[b % l.size()]) > -EPS);\n}\n\n//not necessary?\nIL D convex_area(Poly &l)\n{\n  double res = 0;\n  int n = l.size();\n  FOR(i, 2, n)\n  res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n  return res;\n}\nIL D area(Poly &l)\n{\n  double res = 0;\n  int n = l.size();\n  REP(i, n)\n  res += cross(l[i], l[(i + 1) % n]);\n  return abs(res) / 2.0;\n}\ninline vector<L> tangent_line(C c, P p)\n{\n  vector<L> res;\n  DCc(cp, r, c);\n  P v = p - cp;\n  D dist = abs(v);\n  if (dist - r > -EPS)\n  {\n    double _cos = r / dist;\n    double _sin = sqrt(1.0 - _cos * _cos);\n    v = v * (r / dist);\n    {\n      P e = P(_cos * v.X - _sin * v.Y, _sin * v.X + _cos * v.Y);\n      res.push_back({p, cp + e});\n    }\n    if (dist - r > EPS)\n    {\n      P e = P(_cos * v.X + _sin * v.Y, -_sin * v.X + _cos * v.Y);\n      res.push_back({p, cp + e});\n    }\n  }\n  return res;\n}\nIL vector<L> inner_common_tangent_line(C p, C q)\n{\n  vector<L> res;\n  DCc(Mp, Rp, p);\n  DCc(Mq, Rq, q);\n  D dist = abs(Mp - Mq);\n  if (dist - (Rp + Rq) > -EPS)\n  {\n    P mid = (Mq * Rp + Mp * Rq) / (Rp + Rq);\n    res = tangent_line(p, mid);\n  }\n  return res;\n}\ninline vector<L> outer_common_tangent_line(C p, C q)\n{\n  vector<L> res;\n  DCc(Mp, Rp, p);\n  DCc(Mq, Rq, q);\n  P v = Mp - Mq;\n  D dist = abs(v);\n  if (dist - abs(Rp - Rq) > -EPS)\n  {\n    if (abs(Rp - Rq) < EPS)\n    {\n      P e = v * P(0, 1);\n      e = e / dist;\n      res.pb(L(Mp + e, Mq + e));\n      res.pb(L(Mp - e, Mq - e));\n    }\n    else\n    {\n      P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n      res = tangent_line(p, mid);\n    }\n  }\n  return res;\n}\n\nvector<Poly> decomposition(Poly p)\n{\n  int n = p.size();\n  vector<Poly> res;\n  while (n >= 3)\n  {\n    [&]() {\n      FOR(i, 0, n)\n      {\n        P a = p[i];\n        P b = p[(i + 1) % n];\n        P c = p[(i + 2) % n];\n        if (ccw(a, b, c) < 0)\n          continue;\n        if ([&]() {\n              FOR(j, 3, n)\n              {\n                P d = p[(i + j) % n];\n                if (ccw(a, b, d) > -EPS && ccw(b, c, d) > -EPS && ccw(c, a, d) > -EPS)\n                  return true;\n              }\n              return false;\n            }())\n          continue;\n        Poly nxt;\n        REP(j, n)\n        if ((i + j) % n != (i + 1) % n)\n          nxt.push_back(p[(i + j) % n]);\n        swap(p, nxt);\n        res.push_back({a, b, c});\n        n--;\n        return;\n      }\n    }();\n  }\n  return res;\n}\nint in_triangle(P p, Poly q)\n{\n  REP(i, 3)\n  if (abs(p - q[i]) < EPS)\n    return 3; //on point\n  REP(i, 3)\n  {\n    int s = sgn(q[i], q[(i + 1) % 3], p);\n    if (s != 1)\n    {\n      if (s == 0)\n        return 2; //on line\n      else\n        return 0; // not in\n    }\n  }\n  return 1; // inside triangle\n}\nint in_C(P q, C c)\n{\n  DCc(p, r, c);\n  if (abs(r - abs(p - q)) < EPS)\n    return 2; //on\n  return r - abs(p - q) > -EPS ? 1 : 0;\n}\nint is_triangle_C(Poly t, C c)\n{\n  t = convex_hull(t);\n  DCc(p, r, c);\n  int cnt = 0;\n  REP(i, 3)\n  cnt += (in_C(t[i], c) > 0);\n  if (cnt == 3)\n    return 3; // t in c\n  if (cnt == 0)\n  {\n    double d = distance_P_LS(p, LS(t[2], t[0]));\n    REP(i, 2)\n    d = min(d, distance_P_LS(p, LS(t[i], t[i + 1])));\n    if (r - d > EPS)\n      return 1; //intersect\n    if (in_triangle(p, t))\n      return 2; //c in t\n    else if (r - d < -EPS)\n      return 0; //not intersect\n  }\n  return 1; //intersect\n}\n\n//p must be convex and ccw\nLS diameter(Poly &p)\n{\n  int n = p.size();\n  int is = 0, js = 0;\n  REP(i, n)\n  if (p[i].Y > p[is].Y)\n    is = i;\n  REP(i, n)\n  if (p[i].Y < p[js].Y)\n    js = i;\n  LS res = {p[is], p[js]};\n  {\n    int i = is;\n    int j = js;\n    do\n    {\n      int ni = (i + 1) % n;\n      int nj = (j + 1) % n;\n      if (cross(p[ni] - p[i], p[nj] - p[j]) < EPS)\n        i = ni;\n      else\n        j = nj;\n      if (abs(res.fi - res.se) < abs(p[i] - p[j]))\n        res = LS(p[i], p[j]);\n    } while (i != is || j != js);\n  }\n  return res;\n}\n\nPoly cross_C_L(C c, L v)\n{\n  DCc(p, r, c);\n  DCl(a, b, v);\n  a -= p;\n  b -= p;\n  P u = a - b;\n  u = P(-u.Y, u.X);\n  P x = cross_L_L({a, b}, {P(0, 0), u});\n  D d = abs(x);\n  Poly res;\n  if (d - r > EPS)\n    return res;\n  D y = sqrt(r * r - d * d);\n  res.pb(p + x + (b - a) * y / abs(b - a));\n  //if(d-r>-EPS)return res;\n  res.pb(p + x + (a - b) * y / abs(b - a));\n  return res;\n}\n} // namespace geo\n\n///////////////////////////////////////////////////////////////////////////////////\n// MAIN\n///////////////////////////////////////////////////////////////////////////////////\n// 735134400 約数が1344個ある高度合成数(<= 1e9)\n// 897612484786617600 約数が103680個ある高度合成数(<= 1e18)\n// 苦手分野 重複順列\n// LLの数値をつかう時は最後にLLをつける癖をつけよう\n\nvoid solve(int &n)\n{\n  int sx, sy, ex, ey;\n  cin >> sx >> sy >> ex >> ey;\n  geo::P S(sx, sy), E(ex, ey);\n  geo::LS seg(S, E);\n  vector<geo::LS> v[51];\n  double height[51];\n  bool is_ok = true;\n  for (int i = 0; i < n; i++)\n  {\n    int minx, miny, maxx, maxy, h;\n    cin >> minx >> miny >> maxx >> maxy >> h;\n    geo::LS l1(geo::P(minx, miny), geo::P(minx, maxy)), l2(geo::P(minx, miny), geo::P(maxx, miny)), l3(geo::P(maxx, maxy), geo::P(maxx, miny)), l4(geo::P(maxx, maxy), geo::P(minx, maxy));\n    if (geo::is_LS_LS(l1, seg) || geo::is_LS_LS(l2, seg) || geo::is_LS_LS(l3, seg) || geo::is_LS_LS(l4, seg))\n    {\n      is_ok = false;\n    }\n    if (minx <= sx && sx <= maxx && minx <= ex && ex <= maxx && miny <= sy && sy <= maxy && miny <= ey && ey <= maxy)\n    {\n      is_ok = false;\n    }\n    v[i].push_back(l1);\n    v[i].push_back(l2);\n    v[i].push_back(l3);\n    v[i].push_back(l4);\n    height[i] = h;\n  }\n  if (!is_ok)\n  {\n    cout << 0 << endl;\n    return;\n  }\n  double ok = 0., ng = 1001.;\n  for (int cont = 0; cont < 50; cont++)\n  {\n    double mid = (ok + ng) / 2;\n    auto check = [&](double mid) {\n      for (int i = 0; i < n; i++)\n      {\n        for (int j = 0; j < (int)v[i].size(); j++)\n        {\n          if (height[i] >= mid)\n          {\n            if (geo::distance_LS_LS(seg, v[i][j]) < mid)\n              return false;\n          }\n          else\n          {\n            if (geo::distance_LS_LS(seg, v[i][j]) < sqrt(mid * mid - (mid - height[i]) * (mid - height[i])))\n              return false;\n          }\n        }\n      }\n      return true;\n    };\n    if (check(mid))\n      ok = mid;\n    else\n      ng = mid;\n  }\n  cout << ok << endl;\n}\n\nint n;\n\nint main()\n{\n  while (cin >> n, n)\n  {\n    solve(n);\n  }\n#ifdef LOCAL_DEFINE\n  cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s.\" << endl;\n  show(MOD);\n#endif\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// NOTE\n///////////////////////////////////////////////////////////////////////////////////\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\n// AOJ1183\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187, AOJ1183\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n    const gtype feps = 1e-9;\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -feps\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -feps)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\n// AOJ1157\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection), AOJ1183(by ip_CL)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& g)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n    {\n        if (ccw(g[(i - 1 + g.size()) % g.size()], g[i], g[(i + 1) % g.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079, AOJ0187\ngtype area(const G& g)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t\ts += cross(g[i], g[(i + 1) % g.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain { OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (intersect_SP(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// a contains b?\n// AOJ0214\nbool contain_GG(const G& a, const G& b)\n{\n    rep(i, b.size())\n        if (contain_GP(a, b[i]) == OUT)\n            return false;\n    return true;\n}\n// AOJ0214\nbool intersect_GG(const G& a, const G& b)\n{\n    rep(i, a.size()) rep(j, b.size())\n        if (intersect_SS(Line(a[i], a[(i + 1) % a.size()]), Line(b[j], b[(j + 1) % b.size()])))\n            return true;\n    return contain_GG(a, b) || contain_GG(b, a);\n}\n\n// AOJ1157(gは長方形)\nbool intersect_GS(const G& g, const Seg& s)\n{\n    if (contain_GP(g, s.first) || contain_GP(g, s.second))\n        return true;\n    rep(i, g.size())\n        if (intersect_SS(Seg(g[i], g[(i + 1) % g.size()]), s))\n            return true;\n    return false;\n}\nbool intersect_SG(const Seg& s, const G& g)\n{\n    return intersect_GS(g, s);\n}\n\n// 円\n\n// AOJ0023(feps = 0)\nenum res_pos_CC\n{\n    not_intersect,\n    intersect,\n\n    tangent,\n\n    a_in_b,\n    b_in_a,\n};\nres_pos_CC pos_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nres_contain contain_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(c.p - p);\n    if (d > c.r + feps)\n        return OUT;\n    else if (d < c.r + feps)\n        return IN;\n    else\n        return ON;\n}\n\n// 円周と線分が交わるか\n// AOJ0129\nbool intersect_CS(const Circle& c, const Seg& seg)\n{\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Seg& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\n// AOJ2201\ngtype dist_CL(const Circle& c, const Line& line)\n{\n    return max<gtype>(0, dist_LP(line, c.p) - c.r);\n}\ngtype dist_LC(const Line& line, const Circle& c)\n{\n    return dist_CL(c, line);\n}\n\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    if (pos_CC(a, b) != intersect)\n        return vector<Point>();\n    // if (abs(a.p - b.p) < a.r + b.r - feps)\n    //     return vector<Line>();\n\n    Point ab = b.p - a.p;\n    gtype t = (norm(ab) + a.r*a.r - b.r*b.r) / (2 * abs(ab));\n    Point u = ab / abs(ab);\n    Point q = a.p + t * u;\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - t*t));\n    Point v = Point(0, h) * u;\n\n    vector<Point> res;\n    res.push_back(q + v);\n    if (h > feps)\n        res.push_back(q - v); // 2点\n    return res;\n}\n\n// AOJ1183\nvector<Point> ip_CL(const Circle& c, const Line& line)\n{\n    const gtype feps = 1e-9;\n\n    Point p = projection(line, c.p);\n    Point cp = p - c.p;\n    gtype d = abs(cp);\n    if (d > c.r + feps)\n        return vector<Point>();\n\n    gtype t = sqrt(max<gtype>(0, c.r*c.r - d*d));\n    Point u = line.second - line.first;\n    Point v = u / abs(u) * t;\n\n    vector<Point> res;\n    res.push_back(p + v);\n    if (t > feps)\n        res.push_back(p - v); // 2点\n    return res;\n}\n\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CS(const Circle& c, const Seg& seg)\n{\n    vector<Point> ip = ip_CL(c, seg);\n    vector<Point> res;\n    rep(i, ip.size())\n        if (intersect_SP(seg, ip[i]))\n            res.push_back(ip[i]);\n    return res;\n}\n\n// 点pを通るcの接線\n// AOJ 2201(円が重ならないケースしかない)\nvector<Line> tangent_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-8;\n\n    Point vec = c.p - p;\n    double d = abs(vec);\n    if (d < c.r)\n        return vector<Line>();\n\n    double t = sqrt(max<gtype>(0, d*d - c.r*c.r));\n    Point rota = Point(t / d, c.r / d);\n    rota *= 1; // 線分の長さが0にならないように\n\n    vector<Line> res;\n    res.pb(Line(p, p + vec * rota));\n    if (d > feps)\n        res.push_back(Line(p, p + vec * conj(rota)));\n    return res;\n}\n\n// 共通外接線\n// AOJ 2201(円が重ならないケースしかない)\nvector<Line> tangent_ext_CC(const Circle& a, const Circle& b)\n{\n    if (abs(a.p - b.p) < abs(a.r - b.r))\n        return vector<Line>(); // 内包\n    \n    if (abs(a.r - b.r) > 1e-8)\n    {\n        Point ip = (-a.p * b.r + b.p * a.r) / (a.r - b.r);\n        return tangent_CP(a, ip);        \n    }\n    else\n    {\n        vector<Line> res;\n        Point v = b.p - a.p;\n        v /= abs(v);\n        v *= Point(0, a.r);\n        res.push_back(Line(a.p + v, b.p + v));\n        res.push_back(Line(a.p - v, b.p - v));\n        return res;\n    }\n}\n// 共通内接線\n// AOJ 2201(円が重ならないケースしかない)\nvector<Line> tangent_in_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-8;\n    if (abs(a.p - b.p) < a.r + b.r - feps)\n        return vector<Line>();\n    else\n    {\n        Point ip = (a.p * b.r + b.p * a.r) / (a.r + b.r);\n        return tangent_CP(a, ip);\n    }\n}\n// 共通接線\n// AOJ 2201(円が重ならないケースしかない)\nvector<Line> tangent_CC(const Circle& a, const Circle& b)\n{\n    vector<Line> res;\n    vector<Line> ext = tangent_ext_CC(a, b);\n    vector<Line> in = tangent_in_CC(a, b);\n    rep(i, ext.size())\n        res.pb(ext[i]);\n    rep(i, in.size())\n        res.pb(in[i]);\n    return res;\n}\n\n\n\n\n/////////////////// \nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n        Seg path;\n        cin >> path.first >> path.second;\n        double res = 1e60;\n        rep(i, n)\n        {\n            double h;\n            int x[2], y[2];\n            rep(j, 2)\n                cin >> x[j] >> y[j];\n            cin >> h;\n            if (res < 1e-9)\n                continue;\n            Point p[] = { Point(x[0], y[0]), Point(x[1], y[0]), Point(x[1], y[1]), Point(x[0], y[1]) };\n            double d = 1e60;\n            rep(j, 4)\n            {\n                Seg seg(p[j], p[(j + 1) % 4]);\n                chmin(d, dist_SS(path, seg));\n\n                if (h > d)\n                    chmin(res, d);\n                else\n                    chmin(res, (d*d + h*h) / (2 * h));\n            }\n            if (intersect_GS(G(p, p + 4), path))\n                res = 0;\n        }\n        printf(\"%.8f\\n\", res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define REPD(i,n) for(int i=(int)(n); i-->0;)\n#define REPI(i,a,b) for(int i=(int)(a); i<=(int)(b); i++)\n#define ALL(a) (a).begin(),(a).end()\n#define mp make_pair\n#define fst first\n#define snd second\n\n#define INFTY 1000000000\n#define EPS 1e-9\n#define PI 3.141592653589793\n\n#define INF (INFTY/3)\n\n#define rev(s) (string((s).rbegin(), (s).rend()))\n\ntypedef long long Int;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<double,double> pdd;\n\nvoid debug(vi v){ REP(i,v.size()) cout<<v[i]<<\" \"; cout<<endl; }\n\nint nextInt(){ int t; cin>>t; return t; } // ツ優ツ静ヲツ渉暗環づ可気ツづーツづつつッツづ使ツつ、ツつアツづ．\n\ndefine ZEROP(x) (fabs(x) < EPS)\n#define EQ(x, y) ZEROP((x) - (y))\n#define LT(x, y) ((x) - (y) <= -EPS) // x < y\n#define LE(x, y) ((x) - (y) < +EPS) // x <= y\n#define SIGN(x) ((x)<-EPS?-1:((x)>EPS?+1:0))\n\ntypedef complex<double> P;\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nnamespace std {\n   bool operator < (const P& a, const P& b) {\n     return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n   }\n}\ndouble cross(const P& a, const P& b) {\n   return imag(conj(a)*b); //ツ外ツ静瞬ツ×vツづ個妥・ツつォツつウツ．ツ古シツつォツづ広=[u,v]ツづ可妥篠つオツづ，uツつゥツづァvツづ鳴づ個右ツづ仰つカ\n} \ndouble dot(const P& a, const P& b) {\n   return real(conj(a)*b); \n}  \nstruct L : public vector<P> {\n  L() {}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  } \n};  \ntypedef vector<P> G;  \nstruct C {\n   P p; double r;\n   C(const P &p, double r) : p(p), r(r) { }\n}; \n\n\n#define MAXN 50\nint N;\nL sl; // start line\nint minx[MAXN];\nint miny[MAXN];\nint maxx[MAXN];\nint maxy[MAXN];\nint h[MAXN];\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (LT( 0, cross(b, c)) )   return +1;       // counter clockwise\n  if (LT( cross(b, c), 0) )   return -1;       // clockwise\n  if (LT( dot(b, c), 0) )     return +2;       // c--a--b on line\n  if (LT( norm(b), norm(c)) ) return -2;       // a--b--c on line\n  return 0;\n}\n\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n// USE IN THIS PROBLEM\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nbool covered(int sx,int sy,int ex,int ey,int ax,int ay,int bx,int by) {\n  return ax < sx && ay < sy && ex < bx && ey < by;\n}\n\n\ndouble solve() {\n  double r = INT_MAX;\n  REP(i,N) {\n    L l[]={L(P(minx[i],miny[i]),P(maxx[i],miny[i])),\n\t   L(P(maxx[i],miny[i]),P(maxx[i],maxy[i])),\n\t   L(P(maxx[i],maxy[i]),P(minx[i],maxy[i])),\n\t   L(P(minx[i],maxy[i]),P(minx[i],miny[i]))};\n    double mind = INT_MAX;\n    int mini; //min index\n    if(covered(real(sl[0]),imag(sl[0]),real(sl[1]),imag(sl[1]),\n\t       minx[i],miny[i],maxx[i],maxy[i])) return 0.0;\n    REP(j,4) {\n      double dd = distanceSS(l[j],sl);\n      if(LT(dd,mind)) {\n\tmind = dd;\n\tmini = j;\n      }\n    }\n    double r2;\n    //printf(\"mind=%lf\\n\",mind);\n    if(LE(mind,h[i])) { // mind <= h[i]\n      r2=mind;\n    } else {\n      r2=(h[i]*h[i] + mind*mind) / (2*h[i]);\n    }\n    r=min(r,r2);\n    //printf(\"r=%lf\\n\",r);\n  }\n  return r;\n}\n\t\nmain() {\n  while(cin>>N,N) {\n    int sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    sl = L(P(sx,sy),P(ex,ey));\n    REP(i,N)\n      cin>>minx[i]>>miny[i]>>maxx[i]>>maxy[i]>>h[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\n\n////////////////////////////\n// 基本要素 (点, 線分)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL<<60;      // to be set appropriately\nconst DD EPS = 1e-10;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\n/* Point */\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\n/* Line */\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\n\n////////////////////////////\n// 円や直線の交差判定, 距離\n////////////////////////////\n\n/*\n ccw を用いている\n \n P: point\n L: Line\n S: Segment\n \n distancePL は、「点」と「直線」の距離\n distancePS は、「点」と「線分」の距離\n */\n\nint ccw_for_dis(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\nPoint proj(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(const Point &p, const Line &l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(const Point &p, const Line &l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(const Point &p, const Line &s) {\n    return (ccw_for_dis(s[0], s[1], p) == 0);\n}\nbool isinterLL(const Line &l, const Line &m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(const Line &s, const Line &t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw_for_dis(s[0], s[1], t[0]) * ccw_for_dis(s[0], s[1], t[1]) <= 0 &&\n            ccw_for_dis(t[0], t[1], s[0]) * ccw_for_dis(t[0], t[1], s[1]) <= 0);\n}\nDD distancePL(const Point &p, const Line &l) {\n    return abs(p - proj(p, l));\n}\nDD distancePS(const Point &p, const Line &s) {\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nDD distanceLL(const Line &l, const Line &m) {\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nDD distanceSS(const Line &s, const Line &t) {\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\n\n\nint main() {\n    int N;\n    while (cin >> N, N) {\n        double sx, sy, ex, ey; cin >> sx >> sy >> ex >> ey;\n        Line s(Point(sx, sy), Point(ex, ey));\n        double res = 1100;\n        for (int i = 0; i < N; ++i) {\n            double x[2], y[2], h;\n            cin >> x[0] >> y[0] >> x[1] >> y[1] >> h;\n            if (x[0] <= sx && sx <= x[1] && y[0] <= sy && sy <= y[1]) res = 0;\n            if (x[0] <= ex && ex <= x[1] && y[0] <= ey && ey <= y[1]) res = 0;\n            vector<Point> vp = {Point(x[0], y[0]), Point(x[0], y[1]), Point(x[1], y[1]), Point(x[1], y[0])};\n            for (int j = 0; j < 4; ++j) {\n                Line seg(vp[j], vp[(j+1)%4]);\n                double d = distanceSS(s, seg);\n                if (d <= h) res = min(res, d);\n                else res = min(res, (d*d + h*h)/(h*2));\n            }\n        }\n        cout << fixed << setprecision(10) << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nconst double EPS = 1e-9;\ntemplate<typename T>\nT sqr(T a) { return a * a; }\n\nstruct search_point {\n\tdouble x, y;\n\tdouble h;\n\tsearch_point(double x_, double y_, double h_) {\n\t\tx = x_; y = y_; h = h_;\n\t}\n};\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tdouble sx, sy, ex, ey;\n\t\tvector<search_point> v;\n\t\tvector<pair<search_point,search_point> > line;\n\t\tvector<pair<search_point,search_point> > lect;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tdouble R = 10000;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble h;\n\t\t\tcin >> x0 >> y0 >> x1 >> y1 >> h;\n\n\t\t\tif(h < EPS)\n\t\t\t\th = EPS;\n\n\t\t\tv.push_back(search_point(x0, y0, h));\n\t\t\tv.push_back(search_point(x1, y1, h));\n\t\t\tv.push_back(search_point(x0, y1, h));\n\t\t\tv.push_back(search_point(x1, y0, h));\n\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x0, y0, 0), search_point(x1, y0, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x1, y0, 0), search_point(x1, y1, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x1, y1, 0), search_point(x0, y1, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x0, y1, 0), search_point(x0, y0, 0)));\n\n\t\t\tlect.push_back(pair<search_point,search_point>(search_point(x0, y0, 0), search_point(x1, y1, 0)));\n\n\t\t\tif(x0 <= sx && sx <= x1) {\n\t\t\t\tv.push_back(search_point(sx, y0, h));\n\t\t\t\tv.push_back(search_point(sx, y1, h));\n\t\t\t}\n\t\t\tif(y0 <= sy && sy <= y1) {\n\t\t\t\tv.push_back(search_point(x0, sy, h));\n\t\t\t\tv.push_back(search_point(x1, sy, h));\n\t\t\t}\n\t\t\tif(x0 <= ex && ex <= x1) {\n\t\t\t\tv.push_back(search_point(ex, y0, h));\n\t\t\t\tv.push_back(search_point(ex, y1, h));\n\t\t\t}\n\t\t\tif(y0 <= ey && ey <= y1) {\n\t\t\t\tv.push_back(search_point(x0, ey, h));\n\t\t\t\tv.push_back(search_point(x1, ey, h));\n\t\t\t}\n\t\t}\n\n\t\tdouble veclx = (ex - sx);\n\t\tdouble vecly = (ey - sy);\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tdouble d;\n\t\t\tdouble mx, my;\n\t\t\tdouble r;\n\n\t\t\tmx = (v[i].x * sqr(veclx) + v[i].y * veclx * vecly + vecly * (sx * ey - sy * ex)) / (sqr(veclx) + sqr(vecly));\n\t\t\tmy = (v[i].y * sqr(vecly) + v[i].x * vecly * veclx + veclx * (sy * ex - sx * ey)) / (sqr(vecly) + sqr(veclx));\n\t\t\t/*\n\t\t\tif((ey - sy) * mx - (ex - sx) * my + (ex * sy - sx * ey) > EPS) {\n\t\t\t\tcout << \"error\" << \" \" << (sy - ey) * mx - (sx - ex) * my - (ex * sy - sx * ey) << endl;\n\t\t\t\tcout << mx << \",\" << my << endl;\n\t\t\t}\n\t\t\t// */\n\t\t\td = sqrt(sqr(mx - v[i].x) + sqr(my - v[i].y));\n\t\t\tif(mx < min(sx,ex) || max(sx,ex) < mx || my < min(sy,ey) || max(sy,ey) < my) {\n\t\t\t\td = min(sqrt(sqr(sx - v[i].x) + sqr(sy -  v[i].y)), sqrt(sqr(ex - v[i].x) + sqr(ey - v[i].y)));\n\t\t\t}\n\t\t\tr = fabs(sqr(min(v[i].h,d)) + sqr(d)) / (2 * min(v[i].h,d));\n\t\t\t//cout << \"(\" << v[i].x << \", \" << v[i].y << \")\" << endl;\n\t\t\t//cout << \"(\" << mx << \", \" << my << \") : \" << d << \" : \" << r << endl;\n\t\t\tR = min(R, r);\n\t\t}\n\t\tfor(int i = 0; i < line.size(); i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble s, t;\n\t\t\tx0 = line[i].first.x;  y0 = line[i].first.y;\n\t\t\tx1 = line[i].second.x; y1 = line[i].second.y;\n\n\t\t\ts = ((ex - sx) * (y1 - sy) - (ey - sy) * (x1 - sx)) / ((x0 - sx) * (y1 - sy) - (y0 - sy) * (x1 - sx));\n\t\t\tt = ((ex - sx) * (y0 - sy) - (ey - sy) * (x0 - sx)) / ((x1 - sx) * (y0 - sy) - (y1 - sy) * (x0 - sx));\n\n\t\t\tif(s > -EPS && t > -EPS && s + t > 1 - EPS) {\n\t\t\t\tR = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < lect.size(); i++) {\n\t\t\tbool flag0, flag1;\n\t\t\tflag0 = lect[i].first.x < sx && sx < lect[i].second.x && lect[i].first.y < sy && sy < lect[i].second.y;\n\t\t\tflag1 = lect[i].first.x < ex && ex < lect[i].second.x && lect[i].first.y < ey && ey < lect[i].second.y;\n\n\t\t\tif(flag0 | flag1) {\n\t\t\t\tR = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\", R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,p,n) for(int i=p;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define EPS (1e-10)\n#define INF (1e+4)\n#define EQ(a,b) (abs(a-b)<EPS)\n#define PI (acos(-1))\n\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\ndouble dot(const P& a,const P& b){ return (a.X*b.X)+(a.Y*b.Y); }\ndouble cross(const P& a,const P& b){ return (a.X*b.Y)-(a.Y*b.X); }\ndouble rad(double theta){ return (theta/180.0)*PI; }\n\ndouble distance_lp2(const P& a,const P& b,const P& c)\n{\n\tif(dot(b-a,c-a)<EPS) return abs(c-a);\n\tif(dot(a-b,c-b)<EPS) return abs(c-b);\n\treturn abs(cross(b-a,c-a)/abs(b-a));\n}\n\nbool is_intersected_ll2(const P& a1,const P& a2,const P& b1,const P& b2)\n{\n\tif(abs(cross(a2-a1,b2-b1))<EPS) return false;\n\treturn (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<EPS) && (cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<EPS);\n}\n\nbool is_include4(const P& p,const P& lhs,const P& rhs)\n{\n\treturn min(lhs.X,rhs.X)<=p.X && p.X<=max(lhs.X,rhs.X) &&\n\t\t   min(lhs.Y,rhs.Y)<=p.Y && p.Y<=max(lhs.Y,rhs.Y);\n}\n\nbool len3(double d,double r,double h){ return d*d+(r-h)*(r-h)<(r*r); }\n\nbool check(double d1,double d2,double d3,double d4,double h,double r)\n{\n\tif(r<=h){ if(d1<r||d2<r||d3<r||d4<r){ return false; } }\n\telse    { if(len3(d1,r,h)||len3(d2,r,h)||len3(d3,r,h)||len3(d4,r,h)){ return false; } }\n\n\treturn true;\n}\n\n\nP S,G;\n\nint main()\n{\n\tint n;\n\twhile(cin>>n&&n)\n\t{\n\t\tcin>>S.X>>S.Y>>G.X>>G.Y;\n\n\t\tdouble ans = INF;\n\n\t\trep(i,n)\n\t\t{\n\t\t\tdouble h;\n\t\t\tP p1,p2;\n\n\t\t\tcin>>p1.X>>p1.Y>>p2.X>>p2.Y>>h;\n\t\t\tif(ans<EPS){ ans=0; continue; }\n\t\t\t\n\t\t\tbool a = is_intersected_ll2(S,G,p1,P(p1.X,p2.Y));\n\t\t\tbool b = is_intersected_ll2(S,G,p1,P(p2.X,p1.Y));\n\t\t\tbool c = is_intersected_ll2(S,G,p2,P(p1.X,p2.Y));\n\t\t\tbool d = is_intersected_ll2(S,G,p2,P(p2.X,p1.Y));\n\t\t\tbool e = is_include4(S,p1,p2);\n\t\t\tbool f = is_include4(G,p1,p2);\n\n\t\t\tif(a||b||c||c||d||e||f){ ans=0; continue; }\n\n\t\t\tdouble d1 = distance_lp2(S,G,p1);\n\t\t\tdouble d2 = distance_lp2(S,G,p2);\n\t\t\tdouble d3 = distance_lp2(S,G,P(p1.X,p2.Y));\n\t\t\tdouble d4 = distance_lp2(S,G,P(p2.X,p1.Y));\n\n\t\t\tdouble s1 = distance_lp2(p1,P(p1.X,p2.Y),S);\n\t\t\tdouble s2 = distance_lp2(p1,P(p2.X,p1.Y),S);\n\t\t\tdouble s3 = distance_lp2(p2,P(p1.X,p2.Y),S);\n\t\t\tdouble s4 = distance_lp2(p2,P(p2.X,p1.Y),S);\n\n\t\t\tdouble g1 = distance_lp2(p1,P(p1.X,p2.Y),G);\n\t\t\tdouble g2 = distance_lp2(p1,P(p2.X,p1.Y),G);\n\t\t\tdouble g3 = distance_lp2(p2,P(p1.X,p2.Y),G);\n\t\t\tdouble g4 = distance_lp2(p2,P(p2.X,p1.Y),G);\n\n\t\t\tdouble lhs=0,rhs=INF;\n\n\t\t\twhile(abs(rhs-lhs)>EPS)\n\t\t\t{\n\t\t\t\tdouble med = (lhs+rhs)/2.0;\n\t\t\t\tdouble dd = check(d1,d2,d3,d4,h,med);\n\t\t\t\tdouble ss = check(s1,s2,s3,s4,h,med);\n\t\t\t\tdouble gg = check(g1,g2,g3,g4,h,med);\n\n\t\t\t\tif(dd&&ss&&gg){ lhs=med; } else { rhs=med; }\n\t\t\t}\n\n\t\t\tif(rhs<ans) ans=rhs;\n\t\t}\n\n\t\tprintf(\"%0.10lf\\n\",ans);\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nstruct data{ double minx, miny, maxx, maxy, h; };\nint n;\nvector<data> v;\n\ntypedef long double ld;\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nbool check(double r, Line s)\n{\n\tbool ans = true;\n\tREP(i, v.size())\n\t{\n\t\tdata t = v[i];\n\t\tif (s.a.real() - t.minx > -EPS && t.maxx - s.a.real() > -EPS &&\n\t\t\ts.a.imag() - t.miny > -EPS && t.maxy - s.a.imag() > -EPS) ans = false;\n\t\tif (s.b.real() - t.minx > -EPS && t.maxx - s.b.real() > -EPS &&\n\t\t\ts.b.imag() - t.miny > -EPS && t.maxy - s.b.imag() > -EPS) ans = false;\n\t\tPoint ps[4] = { Point(t.maxx, t.maxy), Point(t.maxx, t.miny), Point(t.minx, t.miny), Point(t.minx, t.maxy)};\n\t\tREP(j, 4)\n\t\t{\n\t\t\tLine ts = Line(ps[j], ps[(j + 1) % 4]);\n\t\t\tif (isis_ss(s, ts)) ans = false;\n\t\t\tdouble d = dist_ss(s, ts);\n\t\t\tif (t.h-r>-EPS && d - r < EPS) ans = false;\n\t\t\tdouble dd = sqrt(pow(r - t.h, 2) + d*d);\n\t\t\tif (dd - r < -EPS) ans = false;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\twhile (cin >> n, n)\n\t{\n\t\tdouble sx, sy, ex, ey;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tLine s(sx, sy, ex, ey);\n\t\tv.clear();\n\t\tREP(i, n)\n\t\t{\n\t\t\tdouble a, b, c, d, e;\n\t\t\tcin >> a >> b >> c >> d >> e;\n\t\t\tv.push_back(data{ a, b, c, d, e });\n\t\t}\n\t\tdouble lb = 0, ub = 1000;\n\t\tREP(i, 100)\n\t\t{\n\t\t\tdouble mid = (lb + ub) / 2;\n\t\t\tif (check(mid, s)) lb = mid;\n\t\t\telse ub = mid;\n\t\t}\n\t\tcout << D10 << ub << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  /*  \n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n  */\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n  ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  }\n\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\n\ndouble cal(L a,L b,double h){\n  double d=getDistanceSS(a,b);\n  if(h>d)return d;\n  return (h*h+d*d)/2/h;\n}\n\nint main(){\n  int n;\n\n  while(cin>>n,n){\n    double ans=1e9;\n    P s,e;\n    double minx,maxx,miny,maxy,h;\n    cin>>s.x>>s.y>>e.x>>e.y;\n    for(int i=0;i<n;i++){\n      cin>>minx>>miny>>maxx>>maxy>>h;\n      if(minx<=s.x&&s.x<=maxx&&miny<=s.y&&s.y<=maxy)ans=0;\n      if(minx<=e.x&&e.x<=maxx&&miny<=e.y&&e.y<=maxy)ans=0;\n      ans=min(ans,cal(L(s,e),L(P(minx,miny),P(minx,maxy)),h));\n      ans=min(ans,cal(L(s,e),L(P(minx,maxy),P(maxx,maxy)),h));\n      ans=min(ans,cal(L(s,e),L(P(maxx,maxy),P(maxx,miny)),h));\n      ans=min(ans,cal(L(s,e),L(P(maxx,miny),P(minx,miny)),h));\n    }\n    printf(\"%.8lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\nint n;\nint sx,sy,gx,gy;\nint xa[SIZE],ya[SIZE],xb[SIZE],yb[SIZE],h[SIZE];\n\ntypedef complex<double> P;\n\n// ?????? (dot product)\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product)\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < 1e-8 ) return abs(c-a);\n  if ( dot(a-b, c-b) < 1e-8 ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n/* ?????????????????? */\nbool IntersectionSS(P p1,P p2, P p3, P p4){\n  long long a,b,c,d;\n    \n  //??????(x1,y1,x2,y2) ??¨ ??´???(x3,y3,x4,y4)\n  a=(long long)(p3.real()-p4.real())*(p1.imag()-p3.imag())+\n    (long long)(p3.imag()-p4.imag())*(p3.real()-p1.real());\n  b=(long long)(p3.real()-p4.real())*(p2.imag()-p3.imag())+\n    (long long)(p3.imag()-p4.imag())*(p3.real()-p2.real());\n\n  //??????(x3,y3,x4,y4) ??¨ ??´???(x1,y1,x2,y2)\n  c=(long long)(p1.real()-p2.real())*(p3.imag()-p1.imag())+\n    (long long)(p1.imag()-p2.imag())*(p1.real()-p3.real());\n  d=(long long)(p1.real()-p2.real())*(p4.imag()-p1.imag())+\n    (long long)(p1.imag()-p2.imag())*(p1.real()-p4.real());\n  \n  if((a<0)^(b<0) && (c<0)^(d<0))\n    return true;\n  else\n    return false;\n}\n\nbool check(double r){\n  \n  P l_s = P(sx,sy);\n  P l_g = P(gx,gy);\n  \n  for(int i=0;i<n;i++){\n    P p[4];\n    p[0] = P(xa[i],ya[i]);\n    p[1] = P(xa[i],yb[i]);\n    p[2] = P(xb[i],yb[i]);\n    p[3] = P(xb[i],ya[i]);\n    double H = min((double)h[i],r);\n    double R = sqrt(r*r - (r-H)*(r-H));\n\n    for(int j=0;j<4;j++){\n      double dis = distance_ls_p(l_s, l_g, p[j]);\n      bool is = IntersectionSS(l_s,l_g,p[j],p[(j+1)%4]);\n      bool in = (xa[i] <= sx && sx <= xb[i] && ya[i] <= sy && sy <= yb[i]) ||\n        (xa[i] <= gx && gx <= xb[i] && ya[i] <= gy && gy <= yb[i]);\n      \n      if(dis < R || is || in){\n        return false;\n      }\n    }\n  }\n  \n  for(int i=0;i<n;i++){\n    P p[4];\n    p[0] = P(xa[i],ya[i]);\n    p[1] = P(xa[i],yb[i]);\n    p[2] = P(xb[i],yb[i]);\n    p[3] = P(xb[i],ya[i]);\n    double H = min((double)h[i],r);\n    double R = sqrt(r*r - (r-H)*(r-H));\n\n    for(int j=0;j<4;j++){\n      double dis1 = distance_ls_p(p[j],p[(j+1)%4],l_s);\n      double dis2 = distance_ls_p(p[j],p[(j+1)%4],l_g);\n      \n      if(dis1 < R || dis2 < R){\n        return false;\n      }\n    }\n\n  }\n  \n  return true;\n}\n\nbool solve(){\n  \n  \n  scanf(\"%d\",&n);\n\n  if(n == 0) return false;\n\n  scanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d%d%d%d\",xa+i, ya+i, xb+i, yb+i, h+i);\n  }\n\n  double l=0, r=1000;\n\n  while(r-l > 1e-8){\n    double mid = (l+r)/2;\n\n    if(check(mid)){\n      l = mid;\n    }else{\n      r = mid;\n    }\n  }\n\n  printf(\"%.7lf\\n\",l);\n  \n  return true;\n}\n\nint main(){\n\n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <complex>\nusing namespace std;\n#ifdef DEBUGRUN\n#define log(a) (cerr<<#a\"=\"<<a<<endl)\n#else\n#define log(a) ((void)0)\n#endif\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\ntypedef long long Int;\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\ndouble sq(double a) { return a*a; }\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\nint ccw(const P& a, P b, P c) {\n    b -= a, c -= a;\n    if(cross(b, c)>0) return 1;\n    if(cross(b, c)<0) return -1;\n    if(dot(b, c)<0) return 2;\n    if(norm(b)<norm(c)) return -2;\n    return 0;\n}\nbool crossing(const P& l0, const P& l1, const P& m0, const P& m1) {\n    return ccw(m0, m1, l0)*ccw(m0, m1, l1)<=0\n        && ccw(l0, l1, m0)*ccw(l0, l1, m1)<=0;\n}\nP projection(const P& l0, const P& l1, const P& p) {\n    double t = dot(p-l0, l0-l1) / norm(l0-l1);\n    return l0 + t*(l0-l1);\n}\ndouble distanceSP(const P& s0, const P& s1, const P& p) {\n    const P r(projection(s0, s1, p));\n    if(ccw(s0, s1, r)==0) return abs(r-p);\n    return min(abs(s0-p), abs(s1-p));\n}\ndouble distanceSS(const P& s0, const P& s1, const P& t0, const P& t1) {\n    if(crossing(s0, s1, t0, t1)) return 0;\n    return min(min(distanceSP(s0, s1, t0), distanceSP(s0, s1, t1)),\n               min(distanceSP(t0, t1, s0), distanceSP(t0, t1, s1)));\n}\n\nint n, sx, sy, ex, ey;\nint xa[100], ya[100], xb[100], yb[100], h[100];\nP sp, ep, ps[100][4];\n\nbool check() {\n    rep(i, n) {\n        rep(j, 4) {\n            if(crossing(sp, ep, ps[i][j], ps[i][(j+1)%4])) return false;\n        }\n        if(crossing(sp, ep, ps[i][0], ps[i][2])) return false;\n        if(crossing(sp, ep, ps[i][1], ps[i][3])) return false;\n        if(xa[i]<=sx && sx<=xb[i] && ya[i]<=sy && sy<=yb[i]) return false;\n        if(xa[i]<=ex && ex<=xb[i] && ya[i]<=ey && ey<=yb[i]) return false;\n    }\n    return true;\n}\n\nbool can(double r) {\n    rep(i, n) {\n        const double lim = h[i]>=r ? r : sqrt(sq(r)-sq(r-h[i]));\n        rep(j, 4) {\n            if(distanceSS(sp, ep, ps[i][j], ps[i][(j+1)%4])<lim) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d\", &n);\n        if(n==0) return 0;\n        scanf(\"%d%d%d%d\", &sx, &sy, &ex, &ey);\n        rep(i, n) scanf(\"%d%d%d%d%d\", xa+i, ya+i, xb+i, yb+i, h+i);\n        sp = P(sx, sy);\n        ep = P(ex, ey);\n        rep(i, n) {\n            ps[i][0] = P(xa[i], ya[i]);\n            ps[i][1] = P(xa[i], yb[i]);\n            ps[i][2] = P(xb[i], yb[i]);\n            ps[i][3] = P(xb[i], ya[i]);\n        }\n        double ans = 0;\n        if(check()) {\n            log(true);\n            double l=0, r=1000;\n            rep(_, 200) {\n                const double mid=(l+r)/2;\n                if(can(mid)) l=mid;\n                else r=mid;\n            }\n            ans = l;\n        }\n        printf(\"%.9f\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <limits.h>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define REPD(i,n) for(int i=(int)(n); i-->0;)\n#define REPI(i,a,b) for(int i=(int)(a); i<=(int)(b); i++)\n#define ALL(a) (a).begin(),(a).end()\n#define mp make_pair\n#define fst first\n#define snd second\n\n#define INFTY 1000000000\n#define EPS 1e-9\n#define PI 3.141592653589793\n\n#define INF (INFTY/3)\n\n#define rev(s) (string((s).rbegin(), (s).rend()))\n\ntypedef long long Int;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<double,double> pdd;\n\nvoid debug(vi v){ REP(i,v.size()) cout<<v[i]<<\" \"; cout<<endl; }\n\nint nextInt(){ int t; cin>>t; return t; }\n\n#define ZEROP(x) (fabs(x) < EPS)\n#define EQ(x, y) ZEROP((x) - (y))\n#define LT(x, y) ((x) - (y) <= -EPS) // x < y\n#define LE(x, y) ((x) - (y) < +EPS) // x <= y\n#define SIGN(x) ((x)<-EPS?-1:((x)>EPS?+1:0))\n\ntypedef complex<double> P;\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nnamespace std {\n   bool operator < (const P& a, const P& b) {\n     return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n   }\n}\ndouble cross(const P& a, const P& b) {\n   return imag(conj(a)*b);\n} \ndouble dot(const P& a, const P& b) {\n   return real(conj(a)*b); \n}  \nstruct L : public vector<P> {\n  L() {}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  } \n};  \ntypedef vector<P> G;  \nstruct C {\n   P p; double r;\n   C(const P &p, double r) : p(p), r(r) { }\n}; \n\n\n#define MAXN 50\nint N;\nL sl; // start line\nint minx[MAXN];\nint miny[MAXN];\nint maxx[MAXN];\nint maxy[MAXN];\nint h[MAXN];\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (LT( 0, cross(b, c)) )   return +1;       // counter clockwise\n  if (LT( cross(b, c), 0) )   return -1;       // clockwise\n  if (LT( dot(b, c), 0) )     return +2;       // c--a--b on line\n  if (LT( norm(b), norm(c)) ) return -2;       // a--b--c on line\n  return 0;\n}\n\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n// USE IN THIS PROBLEM\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nbool covered(int sx,int sy,int ex,int ey,int ax,int ay,int bx,int by) {\n  return ax < sx && ay < sy && ex < bx && ey < by;\n}\n\n\ndouble solve() {\n  double r = INT_MAX;\n  REP(i,N) {\n    L l[]={L(P(minx[i],miny[i]),P(maxx[i],miny[i])),\n\t   L(P(maxx[i],miny[i]),P(maxx[i],maxy[i])),\n\t   L(P(maxx[i],maxy[i]),P(minx[i],maxy[i])),\n\t   L(P(minx[i],maxy[i]),P(minx[i],miny[i]))};\n    double mind = INT_MAX;\n    int mini; //min index\n    if(covered(real(sl[0]),imag(sl[0]),real(sl[1]),imag(sl[1]),\n\t       minx[i],miny[i],maxx[i],maxy[i])) return 0.0;\n    REP(j,4) {\n      double dd = distanceSS(l[j],sl);\n      if(LT(dd,mind)) {\n\tmind = dd;\n\tmini = j;\n      }\n    }\n    double r2;\n    //printf(\"mind=%lf\\n\",mind);\n    if(LE(mind,h[i])) { // mind <= h[i]\n      r2=mind;\n    } else {\n      r2=(h[i]*h[i] + mind*mind) / (2*h[i]);\n    }\n    r=min(r,r2);\n    //printf(\"r=%lf\\n\",r);\n  }\n  return r;\n}\n\t\nmain() {\n  while(cin>>N,N) {\n    int sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    sl = L(P(sx,sy),P(ex,ey));\n    REP(i,N)\n      cin>>minx[i]>>miny[i]>>maxx[i]>>maxy[i]>>h[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nusing vec = complex<double>;\nusing line = pair<vec,vec>;\nusing polygon = vector<vec>;\nconst double eps = 0.0000001;\n\ndouble inner_product(vec u,vec v){\n    return real(u*conj(v));\n}\ndouble cross_product(vec u,vec v){\n    return imag(conj(u)*v);\n}\n\nvec projection(line l,vec p){//p???l???????°???±\n    vec s=l.first, t=l.second;\n    double k = inner_product(t-s,p-s)/inner_product(t-s,t-s);\n    return (1.0-k)*s+k*t;\n}\n\nvec reflection(line l,vec p){\n    return 2.0*projection(l,p)-p;\n}\n\nint ccw(vec& a, vec& b, vec& c){\n    vec ab = b-a, ac = c-a;\n    double o = cross_product(ab,ac);\n    if(o>0) return 1; //CCW\n    if(o<0) return -1; //CW\n    if(inner_product(ab,ac)<0){\n        return 2; //C-A-B\n    }else{\n        if(inner_product(ab,ab)<inner_product(ac,ac)){\n            return -2; //A-B-C\n        }else{\n            return 0; //A-C-B\n        }\n    }\n}\n\nbool isIntersect(line l0, line l1){\n    int s = ccw(l0.first,l0.second,l1.first)*ccw(l0.first,l0.second,l1.second);\n    if(s!=0&&s!=-1&&s!=-4) return false;\n    s=ccw(l1.first,l1.second,l0.first)*ccw(l1.first,l1.second,l0.second);\n    if(s!=0&&s!=-1&&s!=-4) return false;\n    else return true;\n}\n\nvec interSection(line l0, line l1){\n    vec s0, t0, s1, t1;\n    tie(s0,t0)=l0; tie(s1,t1)=l1;\n    double k = cross_product(t1-s1,s1-s0)/cross_product(t1-s1,t0-s0);\n    return s0+(t0-s0)*k;\n}\n\ndouble segLength(line l){\n    return abs(l.first-l.second);\n}\n\ndouble distLine2point(line l, vec p){\n    return abs(cross_product(l.second-l.first,p-l.first))/abs(l.second-l.first);\n}\n\ndouble distSeg2Point(line l, vec p){\n    vec x = projection(l,p);\n    double L = segLength(l);\n    if(abs(x-l.first)<L&&abs(x-l.second)<L){\n        return abs(x-p);\n    }else{\n        return min(abs(l.first-p),abs(l.second-p));\n    }\n}\n\ndouble distSeg2Seg(line l1, line l2){\n    if(isIntersect(l1,l2)) return 0;\n    double ret = 1e20;\n    ret = min(ret,distSeg2Point(l1,l2.first));\n    ret = min(ret,distSeg2Point(l1,l2.second));\n    swap(l1,l2);\n    ret = min(ret,distSeg2Point(l1,l2.first));\n    ret = min(ret,distSeg2Point(l1,l2.second));\n    return ret;\n}\n\ndouble area(polygon& g){\n    double S=0;\n    int n=g.size();\n    for(int i=0;i<n;i++){\n        S+=cross_product(g[i],g[(i+1)%n]);\n    }\n    S/=2;\n    return S;\n}\n\npair<vec,vec> cross_point(vec C, double r, line l){\n    vec P1,P2,P,s,t; tie(s,t)=l;\n    P=(t-s)*(inner_product(t-s,C-s)/norm(t-s))+s;\n    P1=P+(t-s)*(sqrt(r*r-norm(P-C))/abs(t-s));\n    P2=P-(t-s)*(sqrt(r*r-norm(P-C))/abs(t-s));\n    if(P1.real()==P2.real()){\n        if(P1.imag()<P2.imag()) return make_pair(P1,P2);\n        else return make_pair(P2,P1);\n    }else{\n        if(P1.real()<P2.real()) return make_pair(P1,P2);\n        else return make_pair(P2,P1);\n    }\n}\n\nvec rotate(vec v, double rad){\n    return v*polar(1.0,rad);\n}\n\npair<vec,vec> cross_point(vec C1, vec C2, double r1, double r2){\n    vec e1,e2,P1,P2;\n    double d=abs(C2-C1);\n    e1=(C2-C1)*(1/d);\n    double theta = acos((r1*r1+norm(C2-C1)-r2*r2)/(2*r1*d));\n    P1=C1+rotate(e1,theta)*r1;\n    P2=C1+rotate(e1,-theta)*r1;\n    if(P1.real()==P2.real()){\n        if(P1.imag()<P2.imag()) return make_pair(P1,P2);\n        else return make_pair(P2,P1);\n    }else{\n        if(P1.real()<P2.real()) return make_pair(P1,P2);\n        else return make_pair(P2,P1);\n    }\n}\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        int sx,sy,ex,ey;\n        cin>>sx>>sy>>ex>>ey;\n        line L(vec(sx,sy),vec(ex,ey));\n        double r=1e8;\n        for(int i=0;i<N;i++){\n            int x,y,X,Y,h;\n            cin>>x>>y>>X>>Y>>h;\n            vec v0(x,y),v1(X,y),v2(x,Y),v3(X,Y);\n            line l0(v0,v1),l1(v1,v3),l2(v3,v2),l3(v2,v0);\n            double d = min({distSeg2Seg(L,l0),distSeg2Seg(L,l1),distSeg2Seg(L,l2),distSeg2Seg(L,l3)});\n            if(x<=min(sx,ex)&&y<=min(sy,ey)&&X>=max(sx,ex)&&Y>=max(sy,ey)) d=0;\n            if(d<1e-5){\n                r=0;\n            }else{\n                if(h>=d){\n                    r=min(r,d);\n                }else{\n                    r=min(r,(h*h+d*d)/(2*h));\n                }\n            }\n        }\n        cout<<r<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <algorithm>\n#include <complex>\n\nusing namespace std;\n\nint sy,sx,ex,ey;\nint n;\n\ntypedef complex<double> P;\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\n// OÏÌvZ\ndouble cross(P a,P b){\n\treturn (a.real()*b.imag() - a.imag()*b.real());\n}\n\n// üªÌð·»è\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n\treturn (cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1) < EPS)\n\t\t&& (cross(b2-b1,a1-b1) * cross(b2-b1,a2-b1) < EPS);\n}\n\n// àÏ\ndouble dot(P a,P b){\n\treturn (a.real()*b.real() + a.imag()*b.imag());\n}\n\n// _a,bðZ_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a,P b,P c){\n\tif(dot(b-a,c-a) < EPS)\n\t\treturn abs(c-a);\n\tif(dot(a-b,c-b) < EPS)\n\t\treturn abs(c-b);\n\treturn abs(cross(b-a,c-a))/abs(b-a);\n}\n\nclass obj{\npublic:\n\tint minx;\n\tint maxx;\n\tint miny;\n\tint maxy;\n\tint h;\n};\n\nvector<obj> objs;\n\nbool check(double R){\n\tfor(int i = 0; i < objs.size(); i++){\n\t\t// X^[gn_ÆI¹n_ªáQ¨ÉÍÜêÄ¢È¢©Ç¤©\n\t\tif(objs[i].minx <= sx && sx <= objs[i].maxx && objs[i].miny <= sy && sy <= objs[i].maxy){\n\t\t\treturn false;\n\t\t}\n\t\tif(objs[i].minx <= ex && ex <= objs[i].maxx && objs[i].miny <= ey && ey <= objs[i].maxy){\n\t\t\treturn false;\n\t\t}\n\n\t\t// Ü¸o[N[wóÌªÉÂ¢Äl¦é\n\t\tdouble r;\n\t\tif(objs[i].h > R+EPS){\n\t\t\t// ÌêÔªL¢ªðp\n\t\t\tr = R;\n\t\t}\n\t\telse{\n\t\t\t// ³É¶½¼aÌªðp\n\t\t\tr = sqrt(R*R - (R-objs[i].h)*(R-objs[i].h));\n\t\t}\n\t\t// üªÌð·»èðpµÄAvZ\n\t//\tdouble lineDel = (double)(sy-ey)/(sx-ex);\n\t\t// PÊxNg\n\t\tP elemV(sy-ey,-(sx-ex));\n\t\t// £\n//\t\tdnnouble dist = abs(elemV);\n\t\telemV = elemV/abs(elemV);\n\t\tP a1 = -r*elemV+P(sx,sy);\n\t\tP a2 = r*elemV+P(sx,sy);\n\t\tP b1 = -r*elemV+P(ex,ey);\n\t\tP b2 = r*elemV+P(ex,ey);\n\n\t\t// SÔ£\n\t\tdouble pointDist = abs(P(sx,sy)-P(ex,ey));\n\t\tpair<P,P> pair1,pair2;\n\t\t// ÇÌ_ÆÇÌ_ªÑÂ­©\n\t\tif(EQ(abs(a1-b1),pointDist)){\n\t\t\tpair1.first = a1;\n\t\t\tpair1.second=b1;\n\t\t\tpair2.first = a2;\n\t\t\tpair2.second=b2;\n\t\t}\n\t\telse{\n\t\t\tpair1.first = a1;\n\t\t\tpair1.second=b2;\n\t\t\tpair2.first = a2;\n\t\t\tpair2.second=b1;\n\t\t}\n\n\t\t// ß½ñÂÌüªÆ¨ÌªÂüªªÚ·é©ðvZ\n\t\tif(is_intersected_ls(pair1.first,pair1.second,P(objs[i].maxx,objs[i].maxy),P(objs[i].maxx,objs[i].miny))){\n\t\t\treturn false;\n\t\t}\n\t\telse if(is_intersected_ls(pair1.first,pair1.second,P(objs[i].maxx,objs[i].miny),P(objs[i].minx,objs[i].miny))){\n\t\t\treturn false;\n\t\t}\n\t\telse if(is_intersected_ls(pair1.first,pair1.second,P(objs[i].minx,objs[i].miny),P(objs[i].minx,objs[i].maxy))){\n\t\t\treturn false;\n\t\t}\n\t\telse if(is_intersected_ls(pair1.first,pair1.second,P(objs[i].maxx,objs[i].maxy),P(objs[i].minx,objs[i].maxy))){\n\t\t\treturn false;\n\t\t}\n\t\telse if(is_intersected_ls(pair2.first,pair2.second,P(objs[i].maxx,objs[i].maxy),P(objs[i].maxx,objs[i].miny))){\n\t\t\treturn false;\n\t\t}\n\t\telse if(is_intersected_ls(pair2.first,pair2.second,P(objs[i].maxx,objs[i].miny),P(objs[i].minx,objs[i].miny))){\n\t\t\treturn false;\n\t\t}\n\t\telse if(is_intersected_ls(pair2.first,pair2.second,P(objs[i].minx,objs[i].miny),P(objs[i].minx,objs[i].maxy))){\n\t\t\treturn false;\n\t\t}\n\t\telse if(is_intersected_ls(pair2.first,pair2.second,P(objs[i].maxx,objs[i].maxy),P(objs[i].minx,objs[i].maxy))){\n\t\t\treturn false;\n\t\t}\n\t\t// É¼[Ì~ÉÂ¢Äl¦é\n\t\t// eüªÆ~ÌSÆÌ£ð¾µAàµ»Ìlªræè¿¢³¯êÎAð·µÄ¢éÆ»è·é\n\t\tif(distance_ls_p(P(objs[i].maxx,objs[i].maxy),P(objs[i].maxx,objs[i].miny),P(sx,sy)) < r+EPS){\n\t\t\treturn false;\n\t\t}\n\t\telse if(distance_ls_p(P(objs[i].maxx,objs[i].miny),P(objs[i].minx,objs[i].miny),P(sx,sy)) < r+EPS){\n\t\t\treturn false;\n\t\t}\n\t\telse if(distance_ls_p(P(objs[i].minx,objs[i].miny),P(objs[i].minx,objs[i].maxy),P(sx,sy)) < r+EPS){\n\t\t\treturn false;\n\t\t}\n\t\telse if(distance_ls_p(P(objs[i].maxx,objs[i].maxy),P(objs[i].minx,objs[i].maxy),P(sx,sy)) < r+EPS){\n\t\t\treturn false;\n\t\t}\n\t\telse if(distance_ls_p(P(objs[i].maxx,objs[i].maxy),P(objs[i].maxx,objs[i].miny),P(ex,ey)) < r+EPS){\n\t\t\treturn false;\n\t\t}\n\t\telse if(distance_ls_p(P(objs[i].maxx,objs[i].miny),P(objs[i].minx,objs[i].miny),P(ex,ey)) < r+EPS){\n\t\t\treturn false;\n\t\t}\n\t\telse if(distance_ls_p(P(objs[i].minx,objs[i].miny),P(objs[i].minx,objs[i].maxy),P(ex,ey)) < r+EPS){\n\t\t\treturn false;\n\t\t}\n\t\telse if(distance_ls_p(P(objs[i].maxx,objs[i].maxy),P(objs[i].minx,objs[i].maxy),P(ex,ey)) < r+EPS){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\n\twhile(cin >> n && n != 0){\n\t\tobjs.clear();\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tobj o;\n\t\t\tcin >> o.minx >> o.miny >> o.maxx >> o.maxy >> o.h;\n\t\t\tobjs.push_back(o);\n\t\t}\n\n\t\tdouble lb = 0.0;\n\t\tdouble ub = 100000000.0;\n\t\t\n\t\twhile(ub - lb >= 0.00001){\n\t\t\tdouble mid = (ub+lb)/2;\n\t\t\tif(!check(mid)){\n\t\t\t\tub = mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t}\n\t\tif(ub < 0.0001){\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%.5f\\n\",ub);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 0\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const {\n\t\t//return y != p.y ? y < p.y : x < p.x; // y?????? -> x??????\n\t\treturn x != p.x ? x < p.x : y < p.y; // x?????? -> y??????\n\t}\n\tbool operator==(const Point &p)const { return equals(x, p.x) && equals(y, p.y); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\n\n//1?¬?\nclass Vector :public Point {\npublic:\n\tusing Point::Point;\n\tVector(const Point &P) { x = P.x; y = P.y; }\n\tVector rotate(double rad) { return Vector(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n};\n\nclass Line {\npublic:\n\tPoint p1, p2;\n\tLine() {}\n\tLine(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\nclass Segment :public Line {\npublic:\n\tusing Line::Line;\n\tSegment(const Line &L) { p1 = L.p1; p2 = L.p2; }\n\tVector vec() { return p2 - p1; }\n};\n\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product ?????§???????????£????????????\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//????????¢??? radian ??? ??? degree\ndouble rad(double deg) { return acos(-1)*deg / 180; }\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\nbool inrange(Point p, double x1, double y1, double x2, double y2) {\n\treturn x1 <= p.x&&p.x <= x2&&y1 <= p.y&&p.y <= y2;\n}\n\n//??´?????????\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) { return is_orthogonal(a1 - a2, b1 - b2); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) { return is_parallel(a1 - a2, b1 - b2); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\nint ccw(Vector a, Vector b) {\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n//(?????????????¶????)\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble get_distance(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble get_distance(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance(Line(s), p);\n}\n//????????¨??????????????¢\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance(s1, s2.p1), get_distance(s1, s2.p2)),\n\t\tmin(get_distance(s2, s1.p1), get_distance(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return get_distance(l, c.c) <= c.r + EPS; }\n//?????¨?????????????????? ??±?????\\????????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint get_cross_point(Segment s1, Segment s2) {\n\tassert(intersect(s1, s2));\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n//??´?????¨??´????????????\n//Point get_cross_point(Line l1, Line l2) {}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n//?????¨????????????\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\nint contains(Circle c, Point p) {\n\tdouble d = get_distance(c.c, p);\n\tif (equals(d, c.r))return ON;\n\tif (d < c.r)return IN;\n\treturn OUT;\n}\n\n//????§???¢?????¢???\ndouble area(Polygon g) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\ta += cross(g[i], g[(i + 1) % g.size()]);\n\treturn a / 2.0;\n}\n\n//?????§????????????????¨??????????\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//???????????????????????????\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) != CLOCKWISE)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) != COUNTER_CLOCKWISE)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//?????????????????????\nPolygon convex_hull_with_points_online(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (up.size() > 1 && (_ccw = ccw(up[up.size() - 2], up[up.size() - 1], p)) != CLOCKWISE &&_ccw != ONLINE_FRONT)\n\t\t\tup.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (down.size() > 1 && (_ccw = ccw(down[down.size() - 2], down[down.size() - 1], p)) != COUNTER_CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tdown.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//???????§???¢??????????????????????????¢\n//calipers https://en.wikipedia.org/wiki/Rotating_calipers\ndouble diameter(Polygon P) {\n\tP = convex_hull(P);\n\tauto mima = minmax_element(P.begin(), P.end());\n\tint I = mima.first - P.begin();\n\tint J = mima.second - P.begin();\n\tdouble maxd = get_distance(P[I], P[J]);\n\n\tint maxi, maxj, i, j;\n\ti = maxi = I;\n\tj = maxj = J;\n\tdo {\n\t\tif (ccw(next(P, i) - P[i], next(P, j) - P[j]) == COUNTER_CLOCKWISE)\n\t\t\tj = (j + 1) % P.size();\n\t\telse\n\t\t\ti = (i + 1) % P.size();\n\t\tif (maxd < get_distance(P[i], P[j])) {\n\t\t\tmaxd = get_distance(P[i], P[j]);\n\t\t\tmaxi = i, maxj = j;\n\t\t}\n\t} while (!(i == I&&j == J));\n\treturn maxd;\n}\n\n//????§???¢???(0,0)???????????¨???????????¢\nPolygon rotate(const Polygon &P, double rad) {\n\tPolygon ret;\n\tfor (auto &p : P)\n\t\tret.emplace_back(p.x*cos(rad) - p.y*sin(rad), p.x*sin(rad) + p.y*cos(rad));\n\treturn ret;\n}\n\n//????§???¢?????????\nPoint center(const Polygon &P) {\n\tPoint ret(0, 0);\n\tfor (auto &p : P)ret = ret + p;\n\tret = ret / P.size();\n\treturn ret;\n}\n\nsigned main() {\n\tcout << fixed << setprecision(8);\n\tfor (int N; cin >> N&&N;) {\n\t\tPoint s, e; cin >> s >> e;\n\t\tvector<Point> bmin(N), bmax(N);\n\t\tvector<double> h(N);\n\t\trep(i, 0, N)\n\t\t\tcin >> bmin[i] >> bmax[i] >> h[i];\n\t\tSegment S(s, e);\n\t\tvector<double> dist(N);\n\t\tdouble ans = INF;\n\t\trep(i, 0, N) {\n\t\t\tPoint a(bmin[i]), c(bmax[i]);\n\t\t\tPoint b(bmin[i].x, bmax[i].y), d(bmax[i].x, bmin[i].y);\n\t\t\tdump(a)dump(b)dump(c)dumpl(d);\n\t\t\tPolygon P = { a,b,c,d };\n\t\t\tif (contains(P, s) ||\n\t\t\t\tcontains(P, e)) {\n\t\t\t\tans = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdist[i] = min({\n\t\t\t\tget_distance(S, Segment(a, b)),\n\t\t\t\tget_distance(S, Segment(b, c)),\n\t\t\t\tget_distance(S, Segment(c, d)),\n\t\t\t\tget_distance(S, Segment(d, a)) });\n\t\t}\n\t\tdumpc(dist);\n\t\tdumpc(h);\n\t\trep(i, 0, N) {\n\t\t\tif (dist[i] > h[i]) {\n\t\t\t\tchmin(ans, (dist[i] * dist[i] + h[i] * h[i]) / (2 * h[i]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchmin(ans, dist[i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct point { double x, y; };\nstruct line { point p, q; };\nstruct rect { point p[4]; line l[4]; };\n\nint N;\ndouble LX[50], LY[50], RX[50], RY[50], H[50];\npoint S, E;\nline c;\nrect o[50];\ndouble d[50];\n\nbool intersect(line l1, line l2) {\n  double ax = l1.p.x, ay = l1.p.y;\n  double bx = l1.q.x, by = l1.q.y;\n  double cx = l2.p.x, cy = l2.p.y;\n  double dx = l2.q.x, dy = l2.q.y;\n  double ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n  double tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n  double tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n  double td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n  return tc * td <= 0 && ta * tb <= 0;\n}\n\ndouble distance(line l, point p) {\n  double x0 = p.x, y0 = p.y;\n  double x1 = l.p.x, y1 = l.p.y;\n  double x2 = l.q.x, y2 = l.q.y;\n  double a = x2 - x1;\n  double b = y2 - y1;\n  double a2 = a * a;\n  double b2 = b * b;\n  double r2 = a2 + b2;\n  double tt = -(a*(x1 - x0) + b*(y1 - y0));\n  if(tt < 0) return sqrt((x1 - x0)*(x1-x0) + (y1 - y0)*(y1-y0));\n  if(tt > r2) return sqrt((x2 - x0)*(x2 - x0) + (y2 - y0)*(y2 - y0));\n  double f1 = a*(y1 - y0) - b*(x1 - x0);\n  return sqrt((f1*f1)/r2);\n}\n\nbool check(double r) {\n  REP(i, 0, N) if(d[i] < sqrt(pow(r, 2) - pow(r - min(r, (double) H[i]), 2))) return false;\n  return true;\n}\n\ndouble solve() {\n  REP(i, 0, N) REP(j, 0, 4) {\n    if(intersect(c, o[i].l[j])) return 0;\n    if(LX[i] <= S.x && S.x <= RX[i] && LY[i] <= S.y && S.y <= RY[i]) return 0;\n    if(LX[i] <= E.x && E.x <= RX[i] && LY[i] <= E.y && E.y <= RY[i]) return 0;\n  }\n\n  REP(i, 0, N) {\n    d[i] = 1e10;\n    REP(j, 0, 4) {\n      d[i] = min(d[i], distance(c, o[i].p[j]));\n      d[i] = min(d[i], distance(o[i].l[j], S));\n      d[i] = min(d[i], distance(o[i].l[j], E));\n    }\n  }\n\n  double low = 0, high = 1005;\n  REP(i, 0, 100) {\n    double mid = (low + high) * 0.5;\n    if(check(mid)) low = mid;\n    else high = mid;\n  }\n  return low;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    cin >> S.x >> S.y >> E.x >> E.y;\n    c = (line) { S, E };\n\n    REP(i, 0, N) {\n      cin >> LX[i] >> LY[i] >> RX[i] >> RY[i] >> H[i];\n      o[i].p[0] = (point) { LX[i], LY[i] };\n      o[i].p[1] = (point) { LX[i], RY[i] };\n      o[i].p[2] = (point) { RX[i], RY[i] };\n      o[i].p[3] = (point) { RX[i], LY[i] };\n      o[i].l[0] = (line) { o[i].p[0], o[i].p[1] };\n      o[i].l[1] = (line) { o[i].p[1], o[i].p[2] };\n      o[i].l[2] = (line) { o[i].p[2], o[i].p[3] };\n      o[i].l[3] = (line) { o[i].p[3], o[i].p[0] };\n    }\n\n    printf(\"%.8lf\\n\", solve());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-10;\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\nint main(){\n  while(true){\n    int n;\n    cin>>n;\n    if(!n)break;\n    double r,r_min = 1000;\n    double sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    P s=P(sx,sy),e=P(ex,ey);\n    for(int i=0;i<n;i++){\n      double x1,y1,x2,y2,h;\n      cin>>x1>>y1>>x2>>y2>>h;\n      P p[4]={ P(x1,y1),P(x2,y1),P(x2,y2),P(x1,y2)};\n      if(is_intersected_ls(s,e,p[0],p[1])\n\t ||is_intersected_ls(s,e,p[1],p[2])\n\t ||is_intersected_ls(s,e,p[2],p[3])\n\t ||is_intersected_ls(s,e,p[3],p[0])\n\t ||(x1<sx&&y1<sy&&ex<x2&&ey<y2)){\n\tr_min = 0;\n      }\n      if(r_min-EPS>0){\n\tdouble l=1000;\n\tfor(int j=0;j<4;j++){\n\t  l = min(l,distance_ls_p(s,e,p[j]));\n\t  l = min(l,distance_ls_p(p[j],p[(j+1)%4],s));\n\t  l = min(l,distance_ls_p(p[j],p[(j+1)%4],e));\n\t}\n\tr = h>l?l:(h*h+l*l)/(2*h);\n\tif(r<r_min)r_min = r;\n      }\n    }\n    printf(\"%.5f\\n\",r_min);\n    //cout<<r_min<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define EPS (1e-10)\ntypedef complex<double> P;\n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\ndouble distance(P p0, P p1, P p2, P p3){\n  double ans = 1e10;\n        ans = min(ans, distance_ls_p(p0, p1, p2));\n        ans = min(ans, distance_ls_p(p0, p1, p3));\n        ans = min(ans, distance_ls_p(p2, p3, p0));\n        ans = min(ans, distance_ls_p(p2, p3, p1));\n        if(is_intersected_ls(p0, p1, p2, p3)) ans = 0.0;\n\t\treturn ans;\n}\n\nint main(){\n  while(true){\n\t\tint n; cin >> n;\n\t\tif(n == 0 )break;\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tP s = P(x,y);\n\t\tcin >> x >> y;\n\t\tP g = P(x,y);\n\t\tvector<P> mins(n), maxs(n);\n\t\tvector<double> h(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\t//if(z == 24)printf(\"%.0f %.0f\",x,y);\n\t\t\tmins[i].real(x); mins[i].imag(y);\n\t\t\tcin >> x >> y;\n\t\t\t//if(z == 24)printf(\" %.0f %.0f\",x,y);\n\t\t\tmaxs[i].real(x); maxs[i].imag(y);\n\t\t\tcin >> h[i];\n\t\t\t//if(z == 24)printf(\" %.0f \\n\",h[i]);\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tfor(int i = 0; i < n;i++){\n\t\t\tdouble d = 1e9;\n\t\t\tP p1 = mins[i], p3 = maxs[i];\n\t\t\tP p2(mins[i].real(), maxs[i].imag());\n\t\t\tP p4(maxs[i].real(), mins[i].imag());\n\t\t\tif(p1.real() < s.real() && s.real() < p3.real() && \n\t\t\t\tp1.imag() < s.imag() && s.imag() < p3.imag()){\n\t\t\t\tans = 0;/*\n\t\t\t\tif(z==24){\n\t\t\t\t\tprintf(\"%.0f %.0f %.0f %.0f\\n\",p1.real(),p1.imag(),p3.real(),p3.imag());\n\t\t\t\t\tcout << \"break\" << endl;}*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, distance(s, g, p1,p2));\n\t\t\td = min(d, distance(s, g, p2,p3));\n\t\t\td = min(d, distance(s, g, p3,p4));\n\t\t\td = min(d, distance(s, g, p4,p1));\n\t\t\tdouble r = (h[i]*h[i]+d*d)/(2*h[i]);\n\t\t\tif(h[i] < d){\n\t\t\t\tans = min(ans, r);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = min(ans, d);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4f\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//二次元幾何ライブラリ\n#include <iostream>\n#include <complex>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define ML make_pair \ntypedef long double D;\ntypedef bool B;\ntypedef complex<D> P;   //点\ntypedef complex<D> V;   //ベクトル\ntypedef pair<P,P>  L;   //直線\ntypedef pair<P,D>  C;   //円\ntypedef vector<P>  Pol; //多角形\n\n//変数名定義\nconst D INF = 1e100;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ntemplate<class T> bool operator==(T a, T b){return abs(a - b )< EPS;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n\n\n\n// ベクトルaの絶対値を求める\n// D Length = abs(a);\n\n// 2点a,b間の距離を求める\n// D Distance = abs(a-b); \n\n// 内積 (Inner Product) : a・b = |a||b|cosθ\nD IP(V a, V b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (Exterior Product) : |a×b| = |a||b|sinθ \nD EP(V a, V b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n// 点の進行方向について\nint ccw(P a, P b, P c) {              //点aと点bが与えられた問いに\n  b -= a; c -= a;\n  if (EP(b, c) > 0)   return +1;      // counter clockwise\n  if (EP(b, c) < 0)   return -1;      // clockwise\n  if (IP(b, c) < 0)     return +2;    // c--a--b on line\n  if (norm(b) < norm(c)) return -2;   // a--b--c on line\n  return 0;                           // a--c--b on line  aとbの線分判定はこれ\n}\n\n\n// 2直線の垂直判定 : a⊥b <=> IP(a, b) = 0\nB IsVecular(L l1, L l2) {\n\treturn IP(l1.first-l1.second, l2.first-l2.second)==0.0;\n}\n\n// 2直線の平行判定 : a//b <=> EP(a, b) = 0\nB IsParallel(L l1, L l2) {\n\treturn EP(l1.first-l1.second, l2.first-l2.second)== 0.0;\n}\n\n// 2線分の交差判定 \nB IIS(L l1, L l2) {\n  return ( EP(l1.second-l1.first, l2.first-l1.first) * EP(l1.second-l1.first, l2.second-l1.first) < EPS ) &&\n         ( EP(l2.second-l2.first, l1.first-l2.first) * EP(l2.second-l2.first, l1.second-l2.first) < EPS );\n}\n\n// 符号付き点と直線の距離 (Distance of Point and Line)  //lの構造 x座標 first<second y座標 first<second 左上 正 右下 負 一致 0\nD  DPL(P p,L l){\n\tV v1=(l.second-l.first);\n\tV v2=(p-l.first);\n\treturn EP(v1,v2)/abs(v1);\n}\n\n// 点と線分の距離 (Distance of Point and Segment)  //lの構造 x座標 first<second y座標 first < second \nD  DPS(P p,L l){\n\tV v1,v2,v3;\n\tv1=l.second-l.first;\n\tv2=p-l.first;\n\tv3=p-l.second;\n\tif(IP (v1,v2) <0)\n\t\treturn abs(p-l.first);\n\telse if(IP(-v1,v3)<0)\n\t\treturn abs(p-l.second);\n\telse\n\t\treturn abs(DPL(p,l));\n}\n\n// 線分と線分の距離 (Distance of Segment and Segment)  //lの構造 x座標 first<second y座標 first < second \nD DSS(L l1,L l2){\n\tif(IIS(l1,l2))\n\t\treturn 0;\n\telse{\n\t\tD tem,tem1,tem2;\n\t\ttem1=min(DPS(l1.first,l2),DPS(l1.second,l2));\n\t\ttem2=min(DPS(l2.first,l1),DPS(l2.second,l1));\n\t\treturn\tmin(tem1,tem2);\n\t}\n}\n\n// 三角形の領域判定 Teritory of Triangle 1が内部 0が境界と外部\nB TT(P p1,P p2,P p3,P p){\n\tL l1,l2,l3;\n\tl1=make_pair(p2,p3);\n\tl2=make_pair(p3,p1);\n\tl3=make_pair(p1,p2);\n\n\tif(sig(DPL(p1,l1))!=sig(DPL(p,l1)))\n\t\treturn false;\n\telse if(sig(DPL(p2,l2))!=sig(DPL(p,l2)))\n\t\treturn false;\n\telse if(sig(DPL(p3,l3))!=sig(DPL(p,l3)))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n//変数名 = 型 代入したいもの\n//example : v1 = V(5.0,-3.0) p1=P(0.0,4.0)\nint main(void){\n\twhile(true){\n\tint N;\n\t\tcin >>N; \n\tif(!N)\n\t\tbreak;\n\tD Block[50][2][2];\n\tD h[50];\n\tP root1,root2;\n\tL root;\n\tD r;\n\tD rmin=INF;\n\tcin >> root1.real() >> root1.imag()>> root2.real() >> root2.imag();\n\trep(i,N)\n\t\tcin >> Block[i][0][0] >> Block[i][0][1] >> Block[i][1][0] >> Block[i][1][1] >>h[i] ;\n\troot=ML(root1,root2);\n\trep(i,N){\n\t\t\tD tem,tem1,tem2;\n\t\t\tP p1,p2,p3,p4;\n\t\t\tp1=P(Block[i][0][0],Block[i][0][1]);\n\t\t\tp2=P(Block[i][1][0],Block[i][0][1]);\n\t\t\tp3=P(Block[i][1][0],Block[i][1][1]);\n\t\t\tp4=P(Block[i][0][0],Block[i][1][1]);\n\t\t\tL la,lb,lc,ld;\n\t\t\tla=ML(p1,p2);\n\t\t\tlb=ML(p2,p3);\n\t\t\tlc=ML(p3,p4);\n\t\t\tld=ML(p4,p1);\n\t\t\tif(p1.real()<root1.real()&&root1.real()<p3.real()&&p1.imag()<root1.imag()&&root1.imag()<p3.imag())\n\t\t\t\ttem=0;\n\t\t\telse {\n\t\t\t\ttem1=min(DSS(root,la),DSS(root,lb));\n\t\t\t\ttem2=min(DSS(root,lc),DSS(root,ld));\n\t\t\t\ttem=min(tem1,tem2);\n\t\t\t}\n\t\t\tif(tem<=h[i])\n\t\t\t\tr=tem;\n\t\t\telse\n\t\t\t\tr=(h[i]+tem*tem/h[i])/2.0;\n\t\t\tif(rmin > r)\n\t\t\t\trmin=r;\n\t}\n\tcout << rmin << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n/* 基本要素 */\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> VP;\nconst double EPS = 1e-8; // 許容誤差^2\nconst double INF = 1e9;\n#define X real()\n#define Y imag()\n// #define LE(n,m) ((n) < (m) + EPS)\n#define LE(n,m) ((n) - (m) < EPS)\n// #define GE(n,m) ((n) + EPS > (m))\n#define GE(n,m) (EPS > (m) - (n))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\n// 外積　cross(a,b) = |a||b|sinθ\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\n// 点の進行方向\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n// 線分と線分\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n  ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(Point a1, Point a2, Point b) {\n  return !ccw(a1, a2, b);\n}\n\n// 点pの直線aへの射影点を返す\nPoint proj(Point a1, Point a2, Point p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\ndouble distSP(Point a1, Point a2, Point p) {\n  Point r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  //= !ccw(a1, a2, r)\n  return min(abs(a1-p), abs(a2-p));\n}\n\ndouble distSS(Point a1, Point a2, Point b1, Point b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n   min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\nPoint read_p(){\n    int x,y;\n    cin >>x >>y;\n    return Point(x,y);\n}\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        Point s = read_p();\n        Point g = read_p();\n\n        VP mn(n), mx(n);\n        vector<int> h(n);\n        rep(i,n){\n            mn[i] = read_p();\n            mx[i] = read_p();\n            cin >>h[i];\n        }\n\n        auto IN = [&](Point p){\n            rep(i,n){\n                if(mn[i].X<=p.X && p.X<=mx[i].X && mn[i].Y<=p.Y && p.Y<=mx[i].Y) return true;\n            }\n            return false;\n        };\n\n        if(IN(s) || IN(g)){\n            printf(\"0\\n\");\n            continue;\n        }\n\n        auto check = [&](double R){\n            rep(i,n){\n                VP v;\n                v.pb(mn[i]);\n                v.pb({mn[i].X, mx[i].Y});\n                v.pb(mx[i]);\n                v.pb({mx[i].X, mn[i].Y});\n\n                double dist = 19191919;\n                rep(j,4){\n                    Point p = v[j], q = v[(j+1)%4];\n                    dist = min(dist, distSS(s,g,p,q));\n                }\n\n                double x = R*R;\n                if(R>h[i]) x -= (R-h[i])*(R-h[i]);\n                x = sqrt(x);\n\n                if(dist<x) return false;\n            }\n            return true;\n        };\n\n        double l=0, r=1000;\n        rep(loop,50){\n            double mid = (l+r)/2;\n            if(check(mid)) l=mid;\n            else r=mid;\n        }\n        printf(\"%.10f\\n\",l);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<complex>\n#include<numeric>\n#include<bitset>\n#define INF 1001001001\n#define OUT 1234567\n#define EPS 1e-8\n#define x first\n#define y second\n\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vint>  vvint;\ntypedef pair<int,int> pint;\ntypedef long long Int;\ntypedef pair<double,double> pt;\ntypedef pair<pair<double,pt>,pair<double,pt> > ans;\n\ndouble pi=3.14159265358979;\ndouble len(pt a){\n\treturn hypot(a.x,a.y);\n}\nint cross(pt a,pt b){\n\treturn (a.x*b.y-a.y*b.x);\n}\nint naiseki(pt a,pt b,pt c){\n\tb.x-=a.x;\n\tb.y-=a.y;\n\tc.x-=a.x;\n\tc.y-=a.y;\n\treturn (b.x*c.x+b.y*c.y);\n}\nint ccw(pt a,pt b,pt c){\n\tb.x-=a.x;\n\tb.y-=a.y;\n\tc.x-=a.x;\n\tc.y-=a.y;\n\tif(cross(b,c)>0) return 1;\n\tif(cross(b,c)<0) return -1;\n\treturn 0;\n}\nint ccw2(pt a,pt b,pt c){\n\tb.x-=a.x;\n\tb.y-=a.y;\n\tc.x-=a.x;\n\tc.y-=a.y;\n\tif((b.x*c.y-b.y*c.x)>0) return 1;\n\tif((b.x*c.y-b.y*c.x)<0) return -1;\n\tif((b.x*c.x+b.y*c.y)<0) return 2;\n\tif(len(b)<len(c)) return -2;\n\treturn 0;\n}\nint kousa(pt s,pt e,pt p,pt q){\n\treturn (ccw(s,e,p)*ccw(s,e,q)<=0 && ccw(p,q,s)*ccw(p,q,e)<=0);\n}\nbool line(pt a,pt b,pt c){\n\tif(ccw2(a,b,c)==-2 || ccw2(c,b,a)==-2) return 1;\n\treturn 0;\n}\ndouble kyori_(pt s,pt e,pt p){\n\te.x-=s.x;\n\te.y-=s.y;\n\tp.x-=s.x;\n\tp.y-=s.y;\n\tif(len(e)<=0) return 0;\n\treturn abs((double)cross(e,p))/len(e);\n}\ndouble kyori(pt s,pt e,pt p,pt q){\n\tdouble ans=INF;\n\tif(naiseki(s,e,p)>0 && naiseki(e,s,p)>0) ans=min(ans,kyori_(s,e,p));\n\tif(naiseki(s,e,q)>0 && naiseki(e,s,q)>0) ans=min(ans,kyori_(s,e,q));\n\tif(naiseki(p,q,s)>0 && naiseki(q,p,s)>0) ans=min(ans,kyori_(p,q,s));\n\tif(naiseki(p,q,e)>0 && naiseki(q,p,e)>0) ans=min(ans,kyori_(p,q,e));\n\tans=min(ans,hypot(p.x-s.x,p.y-s.y));\n\tans=min(ans,hypot(p.x-e.x,p.y-e.y));\n\tans=min(ans,hypot(q.x-s.x,q.y-s.y));\n\tans=min(ans,hypot(q.x-e.x,q.y-e.y));\n\treturn ans;\n}\n\t\t\nint main(){\n\tint n;\n\twhile(cin >> n){\n\t\tif(n==0) break;\n\t\t\n\t\tdouble ans = 1234.5;\n\t\tpt s,e,p,q,r,t;\n\t\tscanf(\"%lf %lf %lf %lf\",&s.x,&s.y,&e.x,&e.y);\n\t\tint h;\n\t\t\n\t\tint i,j;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%lf %lf %lf %lf %d\",&p.x,&p.y,&r.x,&r.y,&h);\n\t\t\tq=pt(p.x,r.y);\n\t\t\tt=pt(r.x,p.y);\n\t\t\t\n\t\t\tif(p.x<=s.x && s.x<=r.x && p.y<=s.y && s.y<=r.y) ans=0;\n\t\t\tif(p.x<=e.x && e.x<=r.x && p.y<=e.y && e.y<=r.y) ans=0;\n\t\t\t\n\t\t\tif(kousa(s,e,p,q)) ans=0;\n\t\t\tif(kousa(s,e,q,r)) ans=0;\n\t\t\tif(kousa(s,e,r,t)) ans=0;\n\t\t\tif(kousa(s,e,t,p)) ans=0;\n\t\t\t\n\t\t\tdouble minl=INF;\n\t\t\tminl=min(minl,kyori(s,e,p,q));\n\t\t\tminl=min(minl,kyori(s,e,q,r));\n\t\t\tminl=min(minl,kyori(s,e,r,t));\n\t\t\tminl=min(minl,kyori(s,e,t,p));\n\t\t\t\n\t\t\tif(minl<(double)h) ans=min(ans,minl);\n\t\t\telse ans=min(ans,(minl*minl+(double)h*h)/(2.0*(double)h));\n//\t\t\tcout << ans << endl;\n\t\t}\n\t\t\n\t\tprintf(\"%.5lf\\n\",ans);\n\t}\n\t\n\treturn 0;\n}\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <math.h>\n#include <complex>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {\n\treturn (conj(a)*b).X;\n}\n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {\n\treturn (conj(a)*b).Y;\n}\n\n// ??????????????????\nint ccw(P a, P b, P c) {\n\tb -= a;  c -= a;\n\tif (cross(b, c) >  EPS) return +1;  // counter clockwise\n\tif (cross(b, c) < -EPS) return -1;  // clockwise\n\tif (dot(b, c)   < -EPS) return +2;  // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n\treturn 0;                          // a--c--b on line or a==c or b==c\n}\n\n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n\treturn a1 + dot(a2 - a1, p - a1) / norm(a2 - a1) * (a2 - a1);\n}\n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n\t\tccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\nbool isecSP(P a1, P a2, P b) {\n\treturn !ccw(a1, a2, b);\n}\n\nD distSP(P a1, P a2, P p) {\n\tP r = proj(a1, a2, p);\n\tif (isecSP(a1, a2, r)) return abs(r - p);\n\treturn min(abs(a1 - p), abs(a2 - p));\n}\nD distSS(P a1, P a2, P b1, P b2) {\n\tif (isecSS(a1, a2, b1, b2)) return 0;\n\treturn min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n\t\t\t   min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\nvector<pair< double, double>> jama;\nbool ds(double r) {\n\tREP(i, jama.size()) {\n\t\tif (r < jama[i].first) {\n\n\t\t}\n\t\telse if (jama[i].first < jama[i].second) {\n\t\t\tif (r > jama[i].first)\n\t\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\tif (r > (jama[i].second*jama[i].second + jama[i].first*jama[i].first) / (2 * jama[i].second))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tdouble sx, sy, gx, gy;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tjama.clear();\n\t\tjama.resize(n);\n\t\tREP(i, n) {\n\t\t\tdouble mi_x, mi_y, ma_x, ma_y, h;\n\t\t\tcin >> mi_x >> mi_y >> ma_x >> ma_y >> h;\n\t\t\tdouble mi = 1e9;\n\t\t\tmi = min(mi, distSS({ sx,sy }, { gx,gy }, { mi_x,mi_y }, {mi_x,ma_y}));\n\t\t\tmi = min(mi, distSS({ sx,sy }, { gx,gy }, { mi_x,ma_y }, { ma_x,ma_y }));\n\t\t\tmi = min(mi, distSS({ sx,sy }, { gx,gy }, { ma_x,ma_y }, { ma_x,mi_y }));\n\t\t\tmi = min(mi, distSS({ sx,sy }, { gx,gy }, { ma_x,mi_y }, { mi_x,mi_y }));\n\t\t\tif (mi_x <= sx&&sx <= ma_x&&mi_y <= sy&&sy <= ma_y)\n\t\t\t\tmi = 0.0;\n\t\t\tif (mi_x <= gx&&gx <= ma_x&&mi_y <= gy&&gy <= ma_y)\n\t\t\t\tmi = 0.0;\n\t\t\tjama[i].first = abs(mi);\n\t\t\tjama[i].second = h;\n\t\t}\n\t\tdouble ans = 0.0;\n\t\tdouble left = 0.0;\n\t\tdouble right = 1000.0;\n\t\tREP(i, 200) {\n\t\t\tif (ds((left + right) / 2))\n\t\t\t\tleft = (left + right) / 2;\n\t\t\telse\n\t\t\t\tright = (left + right) / 2;\n\t\t}\n\t\tprintf(\"%.10lf\\n\",(left + right) / 2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n\nstruct Vector {\n\tint x, y;\n\tdouble length() const { return std::sqrt(x * x + y * y); }\n\tint cross(const Vector& that) const { return x * that.y - y * that.x; }\n\tint dot(const Vector& that) const { return x * that.x + y * that.y; }\n};\nstruct Coordinate {\n\tint x, y;\n\tVector operator-(const Coordinate& that) const { return Vector{ x - that.x, y - that.y }; }\n\tdouble distance_from(const Coordinate& that) const { return ((*this) - that).length(); }\n};\nint sign(const int n) {\n\treturn (n >= 0) ? 1 : -1;\n}\nstruct Line {\n\tCoordinate from, to;\n\tdouble min_distance(const Line& that) const;\n\tdouble min_distance(const Coordinate& that) const;\n\tbool is_cross(const Line& line) const {\n\t\treturn sign((to - from).cross(line.from - from)) * sign((to - from).cross(line.to - from)) <= 0 && sign((line.to - line.from).cross(from - line.from)) * sign((line.to - line.from).cross(to - line.from)) <= 0;\n\t}\n}; \nstruct Block {\n\tint min_x, min_y, max_x, max_y, height;\n\tLine left() const { return Line{ Coordinate{min_x, min_y}, Coordinate{min_x, max_y} }; }\n\tLine right() const { return Line{ Coordinate{max_x, min_y}, Coordinate{max_x, max_y} }; }\n\tLine top() const { return Line{ Coordinate{min_x, max_y}, Coordinate{max_x, max_y} }; }\n\tLine bottom() const { return Line{ Coordinate{min_x, min_y}, Coordinate{max_x, min_y} }; }\n\tbool is_on_line(const Line& line) const { return is_contains(line.from) || is_contains(line.to) || left().is_cross(line) || right().is_cross(line) || top().is_cross(line) || bottom().is_cross(line); }\n\tbool is_contains(const Coordinate& coordinate) const {\n\t\treturn (left().to - left().from).cross(coordinate - left().from) <= 0 &&\n\t\t\t(top().to - top().from).cross(coordinate - top().from) <= 0 &&\n\t\t\t(right().from - right().to).cross(coordinate - right().to) <= 0 &&\n\t\t\t(bottom().from - bottom().to).cross(coordinate - bottom().to) <= 0;\n\t}\n};\ndouble max_radius(const Line line, const Block block) {\n\tif (block.is_on_line(line)) return 0.0;\n\tauto min_distance = std::min({ line.min_distance(block.left()), line.min_distance(block.right()), line.min_distance(block.top()), line.min_distance(block.bottom()) });\n\tif (min_distance <= block.height) return min_distance;\n\telse return (min_distance * min_distance + block.height * block.height) / block.height / 2;\n}\n\nint main() {\n\twhile (true) {\n\t\tint n; std::cin >> n; if (n == 0) break;\n\t\tLine line; std::cin >> line.from.x >> line.from.y >> line.to.x >> line.to.y;\n\t\tdouble radius = DBL_MAX;\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tBlock block; std::cin >> block.min_x >> block.min_y >> block.max_x >> block.max_y >> block.height;\n\t\t\tradius = std::min(max_radius(line, block), radius);\n\t\t}\n\t\tstd::cout << std::setprecision(10) << std::fixed << radius << std::endl;\n\t}\n}\n\ndouble Line::min_distance(const Line& that) const\n{\n\treturn std::min({ min_distance(that.from), min_distance(that.to), that.min_distance(from), that.min_distance(to) });\n}\n\ndouble Line::min_distance(const Coordinate& that) const\n{\n\tauto vec = to - from;\n\tif ((that - from).dot(vec) >= 0 && (that - to).dot(vec) <= 0) {\n\t\treturn std::abs(vec.y * that.x - vec.x * that.y + to.x * from.y - to.y * from.x) / std::sqrt(vec.x * vec.x + vec.y * vec.y);\n\t}\n\telse {\n\t\treturn std::min({ to.distance_from(that), from.distance_from(that) });\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-9;\ntemplate<typename T>\nT sqr(T a) { return a * a; }\n\nstruct search_point {\n\tdouble x, y;\n\tdouble h;\n\tsearch_point(double x_, double y_, double h_) {\n\t\tx = x_; y = y_; h = h_;\n\t}\n};\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tdouble sx, sy, ex, ey;\n\t\tvector<search_point> v;\n\t\tvector<search_point> on_l;\n\t\tvector<pair<search_point, search_point> > lect;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\ton_l.push_back(search_point(sx,sy,0));\n\t\ton_l.push_back(search_point(ex,ey,0));\n\t\tdouble R = 10000;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble h;\n\t\t\tcin >> x0 >> y0 >> x1 >> y1 >> h;\n\n\t\t\tlect.push_back(pair<search_point, search_point>(search_point(x0,y0,h), search_point(x1,y1,h)));\n\n\t\t\tif(h < EPS)\n\t\t\t\th = EPS;\n\n\t\t\tv.push_back(search_point(x0, y0, h));\n\t\t\tv.push_back(search_point(x1, y1, h));\n\t\t\tv.push_back(search_point(x0, y1, h));\n\t\t\tv.push_back(search_point(x1, y0, h));\n\n\t\t\tif(x0 < sx && sx < x1) {\n\t\t\t\tv.push_back(search_point(sx, y0, h));\n\t\t\t\tv.push_back(search_point(sx, y1, h));\n\t\t\t}\n\t\t\tif(y0 < sy && sy < y1) {\n\t\t\t\tv.push_back(search_point(x0, sy, h));\n\t\t\t\tv.push_back(search_point(x1, sy, h));\n\t\t\t}\n\t\t\tif(x0 < ex && ex < x1) {\n\t\t\t\tv.push_back(search_point(ex, y0, h));\n\t\t\t\tv.push_back(search_point(ex, y1, h));\n\t\t\t}\n\t\t\tif(y0 < ey && ey < y1) {\n\t\t\t\tv.push_back(search_point(x0, ey, h));\n\t\t\t\tv.push_back(search_point(x1, ey, h));\n\t\t\t}\n\t\t}\n\n\t\tdouble veclx = (ex - sx);\n\t\tdouble vecly = (ey - sy);\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tdouble d;\n\t\t\tdouble mx, my;\n\t\t\tdouble r;\n\n\t\t\tmx = (v[i].x * sqr(veclx) + v[i].y * veclx * vecly + vecly * (sx * ey - sy * ex)) / (sqr(veclx) + sqr(vecly));\n\t\t\tmy = (v[i].y * sqr(vecly) + v[i].x * vecly * veclx + veclx * (sy * ex - sx * ey)) / (sqr(vecly) + sqr(veclx));\n\t\t\t/*\n\t\t\tif((ey - sy) * mx - (ex - sx) * my + (ex * sy - sx * ey) > EPS) {\n\t\t\t\tcout << \"error\" << \" \" << (sy - ey) * mx - (sx - ex) * my - (ex * sy - sx * ey) << endl;\n\t\t\t\tcout << mx << \",\" << my << endl;\n\t\t\t}\n\t\t\t// */\n\t\t\td = sqrt(sqr(mx - v[i].x) + sqr(my - v[i].y));\n\t\t\tif(mx <= min(sx,ex) - EPS || max(sx,ex) + EPS <= mx || my <= min(sy,ey) - EPS || max(sy,ey) + EPS <= my) {\n\t\t\t\td = min(sqrt(sqr(sx - v[i].x) + sqr(sy -  v[i].y)), sqrt(sqr(ex - v[i].x) + sqr(ey - v[i].y)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\ton_l.push_back(search_point(mx, my, 0));\n\t\t\t}\n\t\t\tr = fabs(sqr(min(v[i].h,d)) + sqr(d)) / (2 * v[i].h);\n\t\t\tR = min(R, r);\n\t\t}\n\n\t\tfor(int i = 0; i < on_l.size(); i++) {\n\t\t\tfor(int j = 0; j < lect.size(); j++) {\n\t\t\t\tif((lect[j].first.x <= on_l[i].x && on_l[i].x <= lect[j].second.x)\n\t\t\t\t\t\t&& (lect[j].first.y <= on_l[i].y && on_l[i].y <= lect[j].second.y)) {\n\t\t\t\t\tR = 0;\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nfail:\n\t\tprintf(\"%.10f\\n\", R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <complex>\n#include <vector>\n\nusing namespace std;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos(-1.0);\n\ntypedef complex<double> Point;\nstruct Line : public vector<Point> {\n  Line(Point a, Point b) { push_back(a), push_back(b); }\n};\n\ninline double cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\ninline double dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -=a;\n  if (cross(b, c) > 0) { return 1; }\n  if (cross(b, c) < 0) { return -1; }\n  if (dot(b, c) < 0) { return 2; }\n  if (norm(b) < norm(c)) { return -2; }\n  return 0;\n}\n\nbool intersectSP(const Line &s, const Point &p) {\n  return abs(s[0] - p) + abs(s[1] - p) - abs(s[0] - s[1]) < EPS;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nPoint projection(const Line &l, const Point p) {\n  double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\n\ndouble distanceSP(const Line &s, const Point &p) {\n  const Point r = projection(s, p);\n  if (intersectSP(s, r)) { return abs(r - p); }\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const Line &s, const Line &t) {\n  if (intersectSS(s, t)) { return 0; }\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\nPoint start, end;\nPoint box[100][4];\ndouble height[100];\n\ninline double square(double x) { return x * x; }\ninline double dist(Line s, Line t, double r, double h) {\n  return sqrt(square(distanceSS(s, t)) + square(r - h));\n}\n\nbool check(int i, int j, double r) {\n  int pj = j;\n  int nj = (j + 1) % 4;\n  Line s(start, end);\n  Line t(box[i][pj], box[i][nj]);\n  if (dist(s, t, r, min(height[i], r)) <= r) { return true; }\n  return false;\n}\n\nbool hit(double r) {\n  REP(i, n) {\n    REP(j, 4) {\n      if (check(i, j, r)) { return true; }\n    }\n  }\n  return false;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    double a, b, c, d, e;\n    scanf(\"%lf %lf %lf %lf\", &a, &b, &c, &d);\n    start = Point(a, b);\n    end = Point(c, d);\n    bool ok = true;\n    REP(i, n) {\n      scanf(\"%lf %lf %lf %lf %lf\", &a, &b, &c, &d, &e);\n      box[i][0] = Point(a, b);\n      box[i][1] = Point(a, d);\n      box[i][2] = Point(c, d);\n      box[i][3] = Point(c, b);\n      height[i] = e;\n      if (start.real() >= a && start.real() <= c && start.imag() >= b && start.imag() <= d) {\n        ok = false;\n      }\n    }\n    if (!ok) {\n      puts(\"0.00000\");\n      continue;\n    }\n    double l = 0.0;\n    double r = 1000.0;\n    REP(iter, 50) {\n      double mid = (l + r) / 2.0;\n      if (hit(mid)) {\n        r = mid;\n      } else {\n        l = mid;\n      }\n    }\n    printf(\"%.5lf\\n\", l);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define endl \"\\n\"\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\n#define rrep(i, a, b) for (auto i = (a); i > (b); --i)\n#define UNIQUE(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\n#ifdef LOCAL_DEFINE\nstruct InitInput\n{\n  InitInput()\n  {\n    FILE *stream1;\n    stream1 = freopen(\"in.txt\", \"r\", stdin);\n    assert(stream1 != nullptr);\n    cerr << \"This problem is not interactive\" << endl;\n  }\n} LOCAL_INPUT;\nstruct LOCAL_OUTPUT\n{\n  LOCAL_OUTPUT()\n  {\n    FILE *stream2;\n    const char *outputfile = \"out.txt\";\n    stream2 = freopen(outputfile, \"w\", stdout);\n    assert(stream2 != nullptr);\n    cerr << \"output [ \" << outputfile << \" ]\" << endl;\n  }\n} /*LOCAL_OUTPUT*/;\n#define show(x) cerr << #x << \" = \" << (x) << \" (line \" << __LINE__ << \")\" << endl\n#define showA(a, n)                                            \\\n  do                                                           \\\n  {                                                            \\\n    for (int _i_t_e_ = 0; _i_t_e_ < (n); _i_t_e_++)            \\\n      cerr << \"(\" << _i_t_e_ << \" = \" << (a)[_i_t_e_] << \") \"; \\\n    cerr << endl;                                              \\\n  } while (0)\n#define showA2(a, n, m)                                                                        \\\n  do                                                                                           \\\n  {                                                                                            \\\n    for (int _i_t_e_ = 0; _i_t_e_ < (n); _i_t_e_++)                                            \\\n    {                                                                                          \\\n      for (int _i_t_e_2 = 0; _i_t_e_2 < (m); _i_t_e_2++)                                       \\\n      {                                                                                        \\\n        cerr << \"(\" << _i_t_e_ << \", \" << _i_t_e_2 << \" = \" << (a)[_i_t_e_][_i_t_e_2] << \") \"; \\\n      }                                                                                        \\\n      cerr << endl;                                                                            \\\n    }                                                                                          \\\n    cerr << endl;                                                                              \\\n  } while (0)\n#else\n#define show(x)\n#define showA(a, n)\n#define showA2(a, n, m)\n#endif\n\nstruct InitAim\n{\n  InitAim()\n  {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(12);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    cerr << \"This problem is not interactive\" << endl;\n#endif\n  }\n} aim_cpo;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconstexpr const int INT_INF = 0x3f3f3f3f;       //1061109567\nconstexpr const ll LL_INF = 0x3f3f3f3f3f3f3f3f; //4557430888798830399\n\ntemplate <typename T>\nbool chmin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T>\nbool chmax(T &a, T b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T>\nvoid ln(T i, T n) { cout << (i == n - 1 ? \"\\n\" : \" \"); }\ntemplate <typename T, typename S>\nostream &operator<<(ostream &out, const pair<T, S> &pair1)\n{\n  out << '(' << pair1.fi << \", \" << pair1.se << ')';\n  return out;\n}\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &vector1)\n{\n  out << '[';\n  for (unsigned int i = 0; i < vector1.size(); i++)\n  {\n    out << vector1[i];\n    if (i == vector1.size() - 1)\n      out << \"]\";\n    else\n      out << \", \";\n  }\n  return out;\n}\n\n// INT\n#define GCD(a, b) __gcd(a, b)\ntemplate <typename T>\nT LCM(T a, T b)\n{\n  return a / GCD(a, b) * b;\n}\ntemplate <typename T>\nT EXTGCD(T a, T b, T &x, T &y)\n{\n  T d = a;\n  if (b != 0)\n  {\n    d = EXTGCD(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n  else\n    x = 1, y = 0;\n  return d;\n}\ntemplate <typename T>\nbool is_prime(T a)\n{\n  for (int i = 2; i * i <= a; i++)\n    if (a % i == 0)\n      return true;\n  return false;\n}\ntemplate <typename T, typename S>\nT Pow(T a, S b)\n{\n  T res = 1, now = a;\n  while (b)\n  {\n    if (b & 1)\n      res *= now;\n    b >>= 1;\n    now *= now;\n  }\n  return res;\n}\n\n// MOD\nll MOD = 1000000000L + 7L;\n#define Madd(a, b) (((a) % MOD) + ((b) % MOD)) % MOD\n#define Mmul(a, b) (((a) % MOD) * ((b) % MOD)) % MOD\n#define Msub(a, b) (((a) % MOD) + MOD - ((b) % MOD)) % MOD\ntemplate <typename T, typename S>\nT ModPow(T a, S b)\n{\n  assert(b >= 0);\n  T res = 1, now = Msub(a, 0);\n  while (b)\n  {\n    if (b & 1)\n      res = Mmul(res, now);\n    b >>= 1;\n    now = Mmul(now, now);\n  }\n  return res;\n}\ntemplate <typename T>\nT ModInverse(T a, T mod, bool prime)\n{ // if mod is prime, \"prime\" is true.\n  if (prime)\n    return ModPow(a, mod - 2);\n  else\n  {\n    T x, y;\n    EXTGCD(a, mod, x, y);\n    return (mod + x % mod) % mod;\n  }\n}\ntemplate <typename T>\nT EulerTotient(T a)\n{\n  vector<pair<int, int>> v;\n  for (T i = 2; i * i <= a; i++)\n  {\n    int cnt = 0;\n    while (a % i == 0)\n    {\n      cnt++;\n      a /= i;\n    }\n    if (cnt != 0)\n      v.emplace_back(i, cnt);\n  }\n  if (a != 1)\n    v.emplace_back(a, 1);\n  //showV(v, (int) v.size());\n  T res = 1;\n  for (int i = 0; i < (int)v.size(); i++)\n  {\n    if (v[i].se == 1)\n    {\n      //res *= v[i].fi - 1;\n      res = Mmul(res, v[i].fi - 1);\n    }\n    else\n    {\n      //res *= Pow(v[i].fi, v[i].se) - Pow(v[i].fi, v[i].se - 1);\n      res = Mmul(res, Msub(ModPow(v[i].fi, v[i].se), ModPow(v[i].fi, v[i].se - 1)));\n    }\n  }\n  return res;\n}\n#define Mdivide(a, b) Mmul(((a) % MOD), (ModInverse((b), MOD, true))) % MOD\nll comb(ll a, ll b)\n{\n  chmin(b, a - b);\n  ll res = 1LL, now = a;\n  for (ll i = 1; i <= b; i++)\n  {\n    res = Mmul(res, now);  //res *= now;\n    res = Mdivide(res, i); // res /= i;\n    now--;\n  }\n  return res;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// TEMPLATE(data structure)\n///////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\nclass BIT\n{\npublic:\n  BIT(int size)\n  {\n    BITTable.assign(++size, 0);\n  }\n  T sum(int k)\n  {\n    T res = 0;\n    for (++k; k > 0; k -= k & -k)\n    {\n      res += BITTable[k];\n    }\n    return res;\n  }\n  T sum(int l, int r)\n  {\n    if (l == 0)\n      return sum(r);\n    return sum(r) - sum(l - 1);\n  }\n  void update(int k, T x)\n  { // b[k] += x;\n    for (++k; k < (int)BITTable.size(); k += k & -k)\n      BITTable[k] += x;\n  }\n\nprivate:\n  vector<T> BITTable;\n};\n\ntemplate <typename T>\nclass IntervalTree\n{\n  using F = function<T(T, T)>;\n\npublic:\n  IntervalTree(int n, const F func, const T init) : func(func), init(init)\n  {\n    size = 1;\n    while ((int)size < n)\n      size <<= 1;\n    table.assign(2 * size, init);\n  }\n  void set(int k, T &x)\n  {\n    table[size + k] = x;\n  }\n  void build()\n  {\n    for (int i = size - 1; i >= 0; --i)\n    {\n      table[i] = func(table[i * 2], table[i * 2 + 1]);\n    }\n  }\n  void update(int k, const T &x)\n  {\n    k += size;\n    table[k] = x;\n    while (k >>= 1)\n    {\n      table[k] = func(table[k * 2], table[k * 2 + 1]);\n    }\n  }\n  T query(int a, int b)\n  {\n    T L = init, R = init;\n    for (a += size, b += size; a < b; a >>= 1, b >>= 1)\n    {\n      if (a & 1)\n        L = func(L, table[a++]);\n      if (b & 1)\n        R = func(table[--b], R);\n    }\n    return func(L, R);\n  }\n  T operator[](const int k) const\n  {\n    return table[k + size];\n  }\n\nprivate:\n  unsigned int size;\n  vector<T> table;\n  const F func;\n  const T init;\n};\n\nclass UnionFind\n{\npublic:\n  explicit UnionFind(int _n) : n(_n)\n  {\n    par.resize(static_cast<unsigned long>(_n));\n    rank.resize(static_cast<unsigned long>(_n));\n    sizes.resize(static_cast<unsigned long>(_n));\n    for (int i = 0; i < _n; i++)\n    {\n      par[i] = i;\n      rank[i] = 0;\n      sizes[i] = 1;\n    }\n  }\n  int find(int a)\n  {\n    if (par[a] == a)\n      return a;\n    return par[a] = find(par[a]);\n  }\n  bool same(int a, int b)\n  {\n    return find(a) == find(b);\n  }\n  void unite(int a, int b)\n  {\n    link(find(a), find(b));\n  }\n  int size(int a)\n  {\n    return sizes[find(a)];\n  }\n  void view()\n  {\n    for (int i = 0; i < n; i++)\n    {\n      cout << \" par\"\n           << \"[\" << i << \"]=\" << par[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    for (int i = 0; i < n; i++)\n    {\n      cout << \"size\"\n           << \"[\" << i << \"]=\" << sizes[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    cout << endl;\n  }\n\nprivate:\n  void link(int a, int b)\n  {\n    if (same(a, b))\n      return;\n    if (rank[a] > rank[b])\n    {\n      par[b] = a;\n      sizes[a] += sizes[b];\n      sizes[b] = 0;\n    }\n    else\n    {\n      par[a] = b;\n      if (rank[a] == rank[b])\n        rank[b]++;\n      sizes[b] += sizes[a];\n      sizes[a] = 0;\n    }\n  }\n  int n;\n  vector<int> par;\n  vector<int> rank;\n  vector<int> sizes;\n};\n\nnamespace geo\n{\n#define IL inline\n#define FOR(i, bg, ed) for (int i = (bg); i < (ed); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\ntypedef double D;\ntypedef bool B;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\nB comp(const P &l, const P &r)\n{\n  return (l.X == r.X) ? l.Y < r.Y : l.X < r.X;\n}\ntypedef pair<P, P> L;  //line\ntypedef pair<P, P> LS; //line segment\ntypedef pair<P, D> C;  //circle\ntypedef vector<P> Poly;\nconst D EPS = 1e-8;\n//Decompotision Macro\n#define DCl(a, b, l) \\\n  P a, b;            \\\n  tie(a, b) = l\n#define DCc(a, b, c) \\\n  P a;               \\\n  D b;               \\\n  tie(a, b) = c\n\n//A dot B\nIL D dot(P a, P b) { return a.X * b.X + a.Y * b.Y; }\n//A cross B\nIL D cross(P a, P b) { return a.X * b.Y - a.Y * b.X; }\nIL D ccw(P a, P b, P c)\n{\n  return cross(b - a, c - a);\n}\n\nIL int sgn(P a, P b, P c)\n{\n  if (cross(b - a, c - a) > EPS)\n    return 1;\n  if (cross(b - a, c - a) < -EPS)\n    return -1;\n  if (dot(b - a, c - a) < -EPS)\n    return 2; // b-a-c\n  if (dot(a - b, c - b) < -EPS)\n    return -2; // a-b-c\n  return 0;\n}\nIL D signed_distance_P_L(P p, L l)\n{\n  DCl(a, b, l);\n  return ccw(a, b, p) / abs(b - a);\n}\n\nIL D distance_P_L(P p, L l)\n{\n  return abs(signed_distance_P_L(p, l));\n}\n\nIL D distance_P_LS(P p, LS ls)\n{\n  DCl(a, b, ls);\n  if (dot(b - a, p - a) < EPS)\n    return abs(p - a);\n  if (dot(a - b, p - b) < EPS)\n    return abs(p - b);\n  return abs(cross(b - a, p - a)) / abs(b - a);\n}\n\nIL B is_L_L(L p, L q)\n{\n  DCl(a, b, p);\n  DCl(c, d, q);\n  return abs(cross(a - b, c - d)) > EPS ||\n         abs(cross(a - b, d - b)) < EPS;\n}\nIL B is_L_LS(L l, LS ls)\n{\n  DCl(a, b, l);\n  DCl(c, d, ls);\n  return ccw(a, b, c) * ccw(a, b, d) < EPS;\n}\nIL B is_LS_LS(LS p, LS q)\n{\n  DCl(a, b, p);\n  DCl(c, d, q);\n  return sgn(a, b, c) * sgn(a, b, d) <= 0 && sgn(c, d, a) * sgn(c, d, b) <= 0;\n}\n\nIL D distance_LS_LS(LS p, LS q)\n{\n  if (is_LS_LS(p, q))\n    return 0;\n  return min({distance_P_LS(p.fi, q),\n              distance_P_LS(p.se, q),\n              distance_P_LS(q.fi, p),\n              distance_P_LS(q.se, p)});\n}\n\n//caution: have to use isintersected_L_L before this function\nIL P cross_L_L(L p, L q)\n{\n  DCl(a, b, p);\n  D d1 = signed_distance_P_L(a, q);\n  D d2 = signed_distance_P_L(b, q);\n  return (a * d2 - b * d1) / (d2 - d1);\n}\n\nIL B is_C_C(C p, C q)\n{\n  DCc(cp, rp, p);\n  DCc(cq, rq, q);\n  D d = abs(cp - cq);\n  return abs(rp - rq) - d < EPS &&\n         rp + rq - d > -EPS;\n}\nIL LS cross_C_C(C p, C q)\n{\n  DCc(cp, rp, p);\n  DCc(cq, rq, q);\n  D d = abs(cp - cq);\n  D rc = (d * d + rp * rp - rq * rq) / (2 * d);\n  D rs = sqrt(rp * rp - rc * rc);\n  P diff = (cq - cp) / d;\n  return {cp + P(rc, rs) * diff, cp + P(rc, -rs) * diff};\n}\nIL Poly convex_hull(Poly p)\n{\n  int n = p.size();\n  Poly res(2 * n);\n  int k = 0, t;\n  sort(ALL(p), comp);\n  REP(i, n)\n  {\n    while (k > 1 && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n      k--;\n    res[k++] = p[i];\n  }\n  t = k;\n  REP(j, n - 1)\n  {\n    int i = n - 2 - j;\n    while (k > t && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n      k--;\n    res[k++] = p[i];\n  }\n  res.resize(k - 1);\n  return res;\n}\nIL B convex_in(Poly &l, P &p)\n{\n  int a = 0, b = l.size(), c;\n  D A, C;\n  P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n  while (b - a > 1)\n  {\n    c = (a + b) / 2;\n    A = cross(l[a] - g, p - l[a]);\n    C = cross(l[c] - g, p - l[c]);\n    if (cross(l[a] - g, l[c] - g) >= 0)\n    {\n      if (A > -EPS && C < -EPS)\n        b = c;\n      else\n        a = c;\n    }\n    else\n    {\n      if (C < -EPS || A > -EPS)\n        b = c;\n      else\n        a = c;\n    }\n  }\n  return (cross(l[b % l.size()] - l[a], p - l[b % l.size()]) > -EPS);\n}\n\n//not necessary?\nIL D convex_area(Poly &l)\n{\n  double res = 0;\n  int n = l.size();\n  FOR(i, 2, n)\n  res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n  return res;\n}\nIL D area(Poly &l)\n{\n  double res = 0;\n  int n = l.size();\n  REP(i, n)\n  res += cross(l[i], l[(i + 1) % n]);\n  return abs(res) / 2.0;\n}\ninline vector<L> tangent_line(C c, P p)\n{\n  vector<L> res;\n  DCc(cp, r, c);\n  P v = p - cp;\n  D dist = abs(v);\n  if (dist - r > -EPS)\n  {\n    double _cos = r / dist;\n    double _sin = sqrt(1.0 - _cos * _cos);\n    v = v * (r / dist);\n    {\n      P e = P(_cos * v.X - _sin * v.Y, _sin * v.X + _cos * v.Y);\n      res.push_back({p, cp + e});\n    }\n    if (dist - r > EPS)\n    {\n      P e = P(_cos * v.X + _sin * v.Y, -_sin * v.X + _cos * v.Y);\n      res.push_back({p, cp + e});\n    }\n  }\n  return res;\n}\nIL vector<L> inner_common_tangent_line(C p, C q)\n{\n  vector<L> res;\n  DCc(Mp, Rp, p);\n  DCc(Mq, Rq, q);\n  D dist = abs(Mp - Mq);\n  if (dist - (Rp + Rq) > -EPS)\n  {\n    P mid = (Mq * Rp + Mp * Rq) / (Rp + Rq);\n    res = tangent_line(p, mid);\n  }\n  return res;\n}\ninline vector<L> outer_common_tangent_line(C p, C q)\n{\n  vector<L> res;\n  DCc(Mp, Rp, p);\n  DCc(Mq, Rq, q);\n  P v = Mp - Mq;\n  D dist = abs(v);\n  if (dist - abs(Rp - Rq) > -EPS)\n  {\n    if (abs(Rp - Rq) < EPS)\n    {\n      P e = v * P(0, 1);\n      e = e / dist;\n      res.pb(L(Mp + e, Mq + e));\n      res.pb(L(Mp - e, Mq - e));\n    }\n    else\n    {\n      P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n      res = tangent_line(p, mid);\n    }\n  }\n  return res;\n}\n\nvector<Poly> decomposition(Poly p)\n{\n  int n = p.size();\n  vector<Poly> res;\n  while (n >= 3)\n  {\n    [&]() {\n      FOR(i, 0, n)\n      {\n        P a = p[i];\n        P b = p[(i + 1) % n];\n        P c = p[(i + 2) % n];\n        if (ccw(a, b, c) < 0)\n          continue;\n        if ([&]() {\n              FOR(j, 3, n)\n              {\n                P d = p[(i + j) % n];\n                if (ccw(a, b, d) > -EPS && ccw(b, c, d) > -EPS && ccw(c, a, d) > -EPS)\n                  return true;\n              }\n              return false;\n            }())\n          continue;\n        Poly nxt;\n        REP(j, n)\n        if ((i + j) % n != (i + 1) % n)\n          nxt.push_back(p[(i + j) % n]);\n        swap(p, nxt);\n        res.push_back({a, b, c});\n        n--;\n        return;\n      }\n    }();\n  }\n  return res;\n}\nint in_triangle(P p, Poly q)\n{\n  REP(i, 3)\n  if (abs(p - q[i]) < EPS)\n    return 3; //on point\n  REP(i, 3)\n  {\n    int s = sgn(q[i], q[(i + 1) % 3], p);\n    if (s != 1)\n    {\n      if (s == 0)\n        return 2; //on line\n      else\n        return 0; // not in\n    }\n  }\n  return 1; // inside triangle\n}\nint in_C(P q, C c)\n{\n  DCc(p, r, c);\n  if (abs(r - abs(p - q)) < EPS)\n    return 2; //on\n  return r - abs(p - q) > -EPS ? 1 : 0;\n}\nint is_triangle_C(Poly t, C c)\n{\n  t = convex_hull(t);\n  DCc(p, r, c);\n  int cnt = 0;\n  REP(i, 3)\n  cnt += (in_C(t[i], c) > 0);\n  if (cnt == 3)\n    return 3; // t in c\n  if (cnt == 0)\n  {\n    double d = distance_P_LS(p, LS(t[2], t[0]));\n    REP(i, 2)\n    d = min(d, distance_P_LS(p, LS(t[i], t[i + 1])));\n    if (r - d > EPS)\n      return 1; //intersect\n    if (in_triangle(p, t))\n      return 2; //c in t\n    else if (r - d < -EPS)\n      return 0; //not intersect\n  }\n  return 1; //intersect\n}\n\n//p must be convex and ccw\nLS diameter(Poly &p)\n{\n  int n = p.size();\n  int is = 0, js = 0;\n  REP(i, n)\n  if (p[i].Y > p[is].Y)\n    is = i;\n  REP(i, n)\n  if (p[i].Y < p[js].Y)\n    js = i;\n  LS res = {p[is], p[js]};\n  {\n    int i = is;\n    int j = js;\n    do\n    {\n      int ni = (i + 1) % n;\n      int nj = (j + 1) % n;\n      if (cross(p[ni] - p[i], p[nj] - p[j]) < EPS)\n        i = ni;\n      else\n        j = nj;\n      if (abs(res.fi - res.se) < abs(p[i] - p[j]))\n        res = LS(p[i], p[j]);\n    } while (i != is || j != js);\n  }\n  return res;\n}\n\nPoly cross_C_L(C c, L v)\n{\n  DCc(p, r, c);\n  DCl(a, b, v);\n  a -= p;\n  b -= p;\n  P u = a - b;\n  u = P(-u.Y, u.X);\n  P x = cross_L_L({a, b}, {P(0, 0), u});\n  D d = abs(x);\n  Poly res;\n  if (d - r > EPS)\n    return res;\n  D y = sqrt(r * r - d * d);\n  res.pb(p + x + (b - a) * y / abs(b - a));\n  //if(d-r>-EPS)return res;\n  res.pb(p + x + (a - b) * y / abs(b - a));\n  return res;\n}\n} // namespace geo\n\n///////////////////////////////////////////////////////////////////////////////////\n// MAIN\n///////////////////////////////////////////////////////////////////////////////////\n// 735134400 約数が1344個ある高度合成数(<= 1e9)\n// 897612484786617600 約数が103680個ある高度合成数(<= 1e18)\n// 苦手分野 重複順列\n// LLの数値をつかう時は最後にLLをつける癖をつけよう\n\nvoid solve(int &n)\n{\n  int sx, sy, ex, ey;\n  cin >> sx >> sy >> ex >> ey;\n  geo::P S(sx, sy), E(ex, ey);\n  geo::LS seg(S, E);\n  vector<geo::LS> v[51];\n  double height[51];\n  for (int i = 0; i < n; i++)\n  {\n    int minx, miny, maxx, maxy, h;\n    cin >> minx >> miny >> maxx >> maxy >> h;\n    geo::LS l1(geo::P(minx, miny), geo::P(minx, maxy)), l2(geo::P(minx, miny), geo::P(maxx, miny)), l3(geo::P(maxx, maxy), geo::P(maxx, miny)), l4(geo::P(maxx, maxy), geo::P(minx, maxy));\n    if (geo::is_LS_LS(l1, seg) || geo::is_LS_LS(l2, seg) || geo::is_LS_LS(l3, seg) || geo::is_LS_LS(l4, seg))\n    {\n      cout << 0 << endl;\n      return;\n    }\n    if (minx <= sx && sx <= maxx && minx <= ex && ex <= maxx && miny <= sy && sy <= maxy && miny <= ey && ey <= maxy)\n    {\n      cout << 0 << endl;\n      return;\n    }\n    v[i].push_back(l1);\n    v[i].push_back(l2);\n    v[i].push_back(l3);\n    v[i].push_back(l4);\n    height[i] = h;\n  }\n  double ok = 0., ng = 1001.;\n  for (int cont = 0; cont < 50; cont++)\n  {\n    double mid = (ok + ng) / 2;\n    auto check = [&](double mid) {\n      for (int i = 0; i < n; i++)\n      {\n        for (int j = 0; j < (int)v[i].size(); j++)\n        {\n          if (height[i] >= mid)\n          {\n            if (geo::distance_LS_LS(seg, v[i][j]) < mid)\n              return false;\n          }\n          else\n          {\n            if (geo::distance_LS_LS(seg, v[i][j]) < sqrt(mid * mid - (mid - height[i]) * (mid - height[i])))\n              return false;\n          }\n        }\n      }\n      return true;\n    };\n    if (check(mid))\n      ok = mid;\n    else\n      ng = mid;\n  }\n  cout << ok << endl;\n}\n\nint n;\n\nint main()\n{\n  while (cin >> n, n)\n  {\n    solve(n);\n  }\n#ifdef LOCAL_DEFINE\n  cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s.\" << endl;\n  show(MOD);\n#endif\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// NOTE\n///////////////////////////////////////////////////////////////////////////////////\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1e-8\n#define INF 1e8\n\ntypedef complex<double> Point;\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tPoint operator / (const Point &p, const double &a){\n\t\treturn Point(real(p)/a, imag(p)/a);\n\t}\n\tPoint operator * (const Point &p, const double &a){\n\t\treturn Point(real(p)*a, imag(p)*a);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn real(a) == real(b) && real(a) == real(b);\n\t}\n}\n\n\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point>{\n\tLine(){}\n\tLine(const Point &a, const Point &b){\n\t\tpush_back(a); push_back(b);\n\t}\n};\nstruct Circle{\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &c, double r):c(c),r(r){}\n};\n\ndouble dot(const Point &a, const Point &b){\n\treturn real(conj(a) * b);\n}\n\ndouble cross(const Point &a, const Point &b){\n\treturn imag(conj(a)*b);\n}\n\nPoint projection(const Line &l, const Point &p){\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t * (l[0]-l[1]);\n}\n\nint ccw(Point a, Point b, Point c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > 0) return +1;\n\tif(cross(b,c) < 0) return -1;\n\tif(dot(b,c) < 0) return +2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\ndouble distancePP(const Point &a, const Point &b){\n\treturn abs(a-b);\n}\n\nbool intersectSS(const Line &s, const Line &t){\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\t\t\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const Line &s, const Point &p){\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1]-s[0]) < EPS;\n}\n\ndouble distanceSP(const Line &s, const Point &p){\n\tconst Point r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r-p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\nbool intersectLL(const Line &l, const Line &m){\n\treturn abs(cross(l[1]-l[0], m[1]-m[0])) > EPS ||\n\t\t\t\t\tabs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n\nbool inPolygon(const Polygon &g, const Point &p){\n\tdouble sum = 0.0;\n\tint n = g.size();\n\tfor(int i = 0; i < g.size(); i++){\n\t\tint j = (i+1)%n;\n\t\tif(intersectSP(Line(g[i], g[j]), p)) return true;\n\t\tsum += arg((g[j]-p)/(g[i]-p));\n\t}\n\treturn abs(sum) > 1;\n}\n\nint main(void){\n\tint N;\n\twhile(cin >> N, N){\n\t\tint miss = 0;\n\t\tdouble sx, sy, ex, ey;\n\t\tvector<Point> ps(N, Point(INF,INF));\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tLine root = Line(Point(sx, sy), Point(ex, ey));\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tdouble ax, ay, bx, by, h;\n\t\t\tdouble d = INF;\n\t\t\tcin >> ax>>ay>>bx>>by>>h;\n\t\t\tPolygon g;\n\t\t\tg.push_back(Point(ax,ay));\n\t\t\tg.push_back(Point(bx,ay));\n\t\t\tg.push_back(Point(bx,by));\n\t\t\tg.push_back(Point(ax,by));\n\t\t\t//内部判定\n\t\t\tif(inPolygon(g, root[0]) || inPolygon(g, root[1])) miss = 1;\n\t\t\t//接触判定\n\t\t\tif(intersectSS(root, Line(Point(ax, ay), Point(bx, ay)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(bx, ay), Point(bx, by)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(bx, by), Point(ax, by)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(ax, by), Point(ax, ay)))) miss = 1;\n\t\t\tif(miss) continue;\n\t\t\t//最小距離\n\t\t\tfor(int j = 0; j < g.size(); j++){\n\t\t\t\td = min(d, distanceSP(root, g[j]));\n\t\t\t}\n\n\t\t\td = min(d, distanceSP(Line(Point(ax, ay), Point(bx, ay)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(ax, ay), Point(bx, ay)), root[1]));\n\n\t\t\td = min(d, distanceSP(Line(Point(bx, ay), Point(bx, by)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(bx, ay), Point(bx, by)), root[1]));\n\n\t\t\td = min(d, distanceSP(Line(Point(bx, by), Point(ax, by)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(bx, by), Point(ax, by)), root[1]));\n\n\t\t\td = min(d, distanceSP(Line(Point(ax, by), Point(ax, ay)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(ax, by), Point(ax, ay)), root[1]));\n\t\t\tps[i] = Point(d, h);\n\t\t}\n\t\tif(miss){\n\t\t\tcout << \"0\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble left = 0, right = 10000;\n\t\tdouble ans = 0;\n\t\twhile(right - left > EPS){\n\t\t\tdouble mid = (left + right) / 2;\n\t\t\tdouble ret = INF;\n\t\t\tfor(int i = 0; i < ps.size(); i++){\n\t\t\t\tret = min(ret, distancePP(Point(0, mid), ps[i]));\n\t\t\t}\n\t\t\tif(ret <= mid + EPS) right = mid;\n\t\t\telse{ ans = mid; left = mid;}\n//\t\t\tprintf(\"%.4lf -> ret:ans = [%.4lf : %.4lf]\\n\", mid, ret, ans);\n\t\t}\n\t\tprintf(\"%.9lf\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\ndouble add(double a, double b) {\n  if (abs(a + b) < EPS * (abs(a) + abs(b))) return 0;\n  return a + b;\n}\ninline int sgn(double a, double b = 0) { return a < b - EPS ? -1 : a > b + EPS ? 1 : 0; }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\ntypedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\nP inputP(){\n  double x,y;\n  cin >> x >> y;\n  return P(x,y);\n}\nnamespace std {\n  bool operator < (const P& a, const P& b) {//x????????????\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool sorty(const P& a, const P& b) {//y????????????\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool same(const P& a, const P& b) {\n    P p = a - b;\n    if(abs(real(p)) < EPS && abs(imag(p)) < EPS){\n      return true;\n    }\n    return false;\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\nint ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0; // a--c--b on line\n}\nclass L{// line\n  public:\n    vector<P> l;\n    P v;\n    L(){};\n    L(const P &a, const P &b) {\n      l.push_back(a); l.push_back(b);\n      v = (b-a);\n    }\n    L(double a,double b,double c,double d){\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n    P& operator[](const int i){\n      return l[i];\n    }\n    void input() {\n      double a, b,c,d;\n      cin >> a >> b >> c >> d;\n      l.clear();\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n};\nclass G {\n  public:\n    vector<P> g;\n    vector<L> l;\n    ll n;\n    G(){};\n    G(int _n):n(_n){\n      double x,y;\n      l.resize(n),g.resize(n);\n      rep(i,n){\n        cin >> x >> y;\n        g[i] = (P(x,y));\n      }\n      rep(i,n){\n        l[i] = L(g[i],g[(i+1)%n]);\n      }\n    }\n    G (vector<P> ps){\n      n = ps.size();\n      g.resize(n),l.resize(n);\n      rep(i,n){\n        g[i] = ps[i];\n      }\n      rep(i,n){\n        l[i] = L(g[i],g[(i+1)%n]);\n      }\n    }\n    P& operator[](int i){\n      return g[i];\n    }\n    void push_back(P p){\n      g.push_back(p);\n    }\n    size_t size(){\n      return g.size();\n    }\n    void resize(int n){\n      g.resize(n),l.resize(n);\n    }\n    friend ostream& operator<<(ostream& os,const G& g){\n      rep(i,g.n){\n        if(i) os << ' ';\n        os << g.g[i] ;\n      }\n      return os;\n    }\n};\nint linejudge(L &ab,L &cd){ //2??´???????????¢???\n  P a = ab[1] - ab[0],b = cd[1] - cd[0];\n  if(abs(cross(a,b)) < EPS){ // Parallel\n    return 2;\n  }\n  else if(abs(dot(a,b)) < EPS){ //Orthogonal\n    return 1;\n  }\n  return 0;\n}\n// L:line,S:segment,P:point\nbool intersectLL( L &l,  L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS( L &l,  L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP( L &l,  P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS( L s,  L t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP( L &s,  P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nbool intersectSG(L l, G g) {\n    int n = g.size();\n    rep(i, n) {\n        if (intersectSS(l, L(curr(g, i), next(g, i)))) {\n            return true;\n        }\n    }\n    return false;\n}\n// L & P intersection\nP projection(L &l,  P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n// L????????????P???????°????\nP reflection(L &l,  P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(L &l,  P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(L &l,  L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(L &l,  L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(L &s,  P &p) {\n  P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(L s,  L t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(P &p, P &q){\n  return abs(p - q) ;\n}\n\ndouble distanceSG(L l, G g) {\n  double d = INF;\n  rep(i, g.size()) {\n    d = min(d, distanceSS(l, L(curr(g, i), next(g, i))));\n  }\n  return d;\n}\n\nbool in(double a,double b,double c){\n  return a <= b && b <= c;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  while(cin >> n,n){\n    L l;\n    l.input();\n    vector<G> rs(n);\n    vector<ll> h(n);\n    bool f = true;\n    rep(i,n){\n      double a,b,c,d;\n      cin >> a >> b >> c >> d >> h[i];\n      rs[i].push_back(P(a,b));\n      rs[i].push_back(P(c,b));\n      rs[i].push_back(P(c,d));\n      rs[i].push_back(P(a,d));\n      if(in(a,real(l[0]),c) && in(b,imag(l[0]),d) && in(a,real(l[1]),c)&& in(b,imag(l[1]),d) ){\n        f = false; \n      } \n    }\n    if(!f){\n      cout << 0 << endl;\n      continue;\n    }\n    auto check = [&](double r){\n      rep(i,n){\n        rep(j,4){\n          double d = distanceSG(l,rs[i]);\n          if(d < r && r < h[i]) return true;\n          else if(h[i] > r - sqrt(r * r - d * d)) return true;\n        }\n      }\n      return false;\n    };\n    double lb = 0,ub = 1001;\n    rep(i,100){\n      double r = (lb+ub)/2;\n      bool f = check(r);\n      if(f){\n        ub = r; \n      }\n      else{\n        lb = r;\n      }\n    }\n    fcout(10) << lb << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-8;\nconst double PI  = acos(-1.0);\n\n#define M INT_MAX\nstruct P{\n  double x;\n  double y;\n\n  P(){\n\tx=M; y=M;\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n\n};\ndouble dot(P a,P b){\n  return (a.x*b.x+a.y*b.y);\n}\n\ndouble cross(P a,P b){\n  return (a.x*b.y-a.y*b.x);\n}\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\ndouble psd(P p , P a , P b){\n  if( dot( b-a , p-a ) < EPS) return fabs(dis(p-a));\n  if( dot( a-b , p-b ) < EPS) return fabs(dis(p-b));\n  return fabs(cross( b-a , p-a )) / fabs(dis(b-a));\n}\n\nbool intersect_s(P a1 , P a2 , P b1 , P b2){\n  return ( cross(a2-a1 , b1-a1)*cross(a2-a1 , b2-a1) < EPS) &&\n\t( cross(b2-b1 , a1-b1)*cross(b2-b1 , a2-b1) < EPS);\n}\n\ndouble dist_s(P p1, P p2, P q1, P q2){\n  if(intersect_s(p1,p2,q1,q2)) return 0;\n  return min(min(psd(p1, q1, q2), psd(p2, q1, q2)),\n\t\t\t min(psd(q1, p1, p2), psd(q2, p1, p2)));\n}\n\nbool isin(P p, P a1, P a2){\n  double mx = min(a1.x, a2.x), Mx = max(a1.x, a2.x);\n  double my = min(a1.y, a2.y), My = max(a1.y, a2.y);\n  return mx <= p.x && p.x <= Mx\n\t&& my <= p.y  && p.y <= My;\n}\n\nint main(){\n  int N;\n  while(cin>>N,N){\n\tP s, e;\n\tvector< vector<P> > ps(N, vector<P>(4));\n\tvector<double> h(N), d(N, 1e+10);\n\tcin >> s.x >> s.y >> e.x >> e.y;\n\tREP(i,N){\n\t  cin >> ps[i][0].x >> ps[i][0].y >> ps[i][2].x >> ps[i][2].y >> h[i];\n\t  ps[i][1].x = ps[i][0].x;\n\t  ps[i][1].y = ps[i][2].y;\n\n\t  ps[i][3].x = ps[i][2].x;\n\t  ps[i][3].y = ps[i][0].y;\n\t}\n\n\tbool ng = false;\n\tREP(i,N){\n\t  if(isin(s, ps[i][0], ps[i][2]) || isin(e, ps[i][0], ps[i][2]))\n\t\tng = true;\n\t  REP(j,4)\n\t\tif(intersect_s(s,e,ps[i][j],ps[i][(j+1)%4]))\n\t\t   ng = true;\n\t}\n\tif(ng){\n\t  cout << 0 << endl;\n\t  continue;\n\t}\n\n\tREP(i,N) REP(j,4){\n\t  d[i] = min(d[i], dist_s(s, e, ps[i][j], ps[i][(j+1)%4]));\n\t}\n\n\tdouble r = 1100.;\n\tREP(j,N){\n\t  if(d[j] < h[j])\n\t\tr = min(r, d[j]);\n\t  else{\n\t\tdouble r_ = (h[j]*h[j] + d[j]*d[j]) / (2.*h[j]);\n\t\tr = min(r, r_);\n\t  }\n\t}\n\n\tcout << fixed << setprecision(6) << r << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nvoid print(Point p);\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tprint(p1);\n\t\t\tprint(p2);\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p2;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n//\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tint x=ccw(s.p1,s.p2,pr);\n\tif(x==0) return d;\n//\tif(x>=-1&&x<=1) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t//\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\tif(ccw(q[0],q[1],r)==0){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t//\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\tif(ccw(p[0],p[1],r)==0){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p1;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(!eq(crossProduct(b,c),0.0)) for(;;);\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n//\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tint x=ccw(s.p1,s.p2,pr);\n//\tif(x>=-1&&x<=1) return d;\n\tif(x==0) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t\tbool flg1=(abs(oneLineCCW(q[0],q[1],r))<=1);\n\t\tbool flg2=ccw(q[0],q[1],r)==0;\n\t\tif(flg1!=flg2) assert(0);\n\t//\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\tif(ccw(q[0],q[1],r)==0){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t\tflg1=abs(oneLineCCW(p[0],p[1],r)<=1);\n\t\tflg2=ccw(p[0],p[1],r);\n\t\tif(flg1!=flg2) assert(0);\n\t//\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\tif(ccw(p[0],p[1],r)==0){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tif(eq(abs(s-t),0.0)) for(;;);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tif(eq(abs(e.p1-e.p2),0.0)) for(;;);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p1;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n//\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tint x=ccw(s.p1,s.p2,pr);\n//\tif(x>=-1&&x<=1) return d;\n\tif(x==0) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t//\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\tif(ccw(q[0],q[1],r)==0){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t//\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\tif(ccw(p[0],p[1],r)==0){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<complex>\n#include<vector>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP start,end;\nP wolf[50][4];\ndouble h[50];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tint W,Z,X,Y;\n\t\tscanf(\"%d%d\",&X,&Y);\n\t\tstart=P(X,Y);\n\t\tscanf(\"%d%d\",&X,&Y);\n\t\tend=P(X,Y);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d%d%d%d%lf\",&X,&Y,&W,&Z,h+i);\n\t\t\twolf[i][0]=P(X,Y);\n\t\t\twolf[i][1]=P(X,Z);\n\t\t\twolf[i][2]=P(W,Z);\n\t\t\twolf[i][3]=P(W,Y);\n\t\t}\n\t\tdouble left=0;\n\t\tdouble right=1000;\n\t\tfor(int i=0;i<100;i++){\n\t\t\tdouble M=(left+right)/2;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tdouble V=M;\n\t\t\t\tif(h[j]<M)V=sqrt(M*M-(M-h[j])*(M-h[j]));\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(distanceSS(L(start,end),L(wolf[j][k],wolf[j][(k+1)%4]))<V)ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)left=M;\n\t\t\telse right=M;\n\t\t}\n\t\tprintf(\"%f\\n\",left);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\n\n////////////////////////////\n// 基本要素 (点, 線分)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL<<60;      // to be set appropriately\nconst DD EPS = 1e-6;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\n/* Point */\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\n/* Line */\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\n\n////////////////////////////\n// 円や直線の交差判定, 距離\n////////////////////////////\n\n/*\n ccw を用いている\n \n P: point\n L: Line\n S: Segment\n \n distancePL は、「点」と「直線」の距離\n distancePS は、「点」と「線分」の距離\n */\n\nint ccw_for_dis(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\nPoint proj(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(const Point &p, const Line &l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(const Point &p, const Line &l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(const Point &p, const Line &s) {\n    return (ccw_for_dis(s[0], s[1], p) == 0);\n}\nbool isinterLL(const Line &l, const Line &m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(const Line &s, const Line &t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw_for_dis(s[0], s[1], t[0]) * ccw_for_dis(s[0], s[1], t[1]) <= 0 &&\n            ccw_for_dis(t[0], t[1], s[0]) * ccw_for_dis(t[0], t[1], s[1]) <= 0);\n}\nDD distancePL(const Point &p, const Line &l) {\n    return abs(p - proj(p, l));\n}\nDD distancePS(const Point &p, const Line &s) {\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nDD distanceLL(const Line &l, const Line &m) {\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nDD distanceSS(const Line &s, const Line &t) {\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\n\n\nint main() {\n    int N;\n    while (cin >> N, N) {\n        double sx, sy, ex, ey; cin >> sx >> sy >> ex >> ey;\n        Line s(Point(sx, sy), Point(ex, ey));\n        double res = 1100;\n        for (int i = 0; i < N; ++i) {\n            double x[2], y[2], h;\n            cin >> x[0] >> y[0] >> x[1] >> y[1] >> h;\n            if (x[0] <= sx && sx <= x[1] && y[0] <= sy && sy <= y[1]) res = 0;\n            if (x[0] <= ex && ex <= x[1] && y[0] <= ey && ey <= y[1]) res = 0;\n            vector<Point> vp = {Point(x[0], y[0]), Point(x[1], y[0]), Point(x[1], y[1]), Point(x[0], y[1])};\n            for (int j = 0; j < 4; ++j) {\n                Line seg(vp[j], vp[(j+1)%4]);\n                double d = distanceSS(s, seg);\n                if (d <= h) res = min(res, d);\n                else res = min(res, (d*d + h*h)/(h*2));\n            }\n        }\n        cout << fixed << setprecision(10) << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <complex>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef complex<double> P;\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L() {}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n};\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    double sx, sy, ex, ey;\n    cin>>sx>>sy>>ex>>ey;\n    double ans = INF;\n    L root = L(P(sx,sy), P(ex,ey));\n    REP(i, N){\n      double mx, my, nx, ny, h;\n      cin>>mx>>my>>nx>>ny>>h;\n      if(mx <= sx && sx <= nx && my <= sy && sy <= ny) ans = 0;\n      L ls[4];\n      ls[0] = L(P(mx,my),P(nx,my));\n      ls[1] = L(P(mx,my),P(mx,ny));\n      ls[2] = L(P(mx,ny),P(nx,ny));\n      ls[3] = L(P(nx,my),P(nx,ny));\n      REP(j, 4){\n        L l = ls[j];\n        double dist = distanceSS(root, l);\n        if(dist == 0) ans = 0;\n        //cout<<l[0]<<\" \"<<l[1]<<\":\"<<dist<<endl;\n        double radian = max((h*h + dist*dist)/(2*h), dist);\n        ans = min(ans, radian);\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-8\n#define equal(a,b) (fabs(a-b) < EPS)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(const Point &p0,const Point &p1,const Point &p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nPoint projection(const Segment &s,const Point &p){\n    Vector b = s.t-s.s;\n    double t = dot(p-s.s,b)/norm(b);\n    return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n    return (ccw(s.s,s.t,p) == 0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n            ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n    Point r = projection(s,p);\n    if(isIntersectSP(s,r)) return abs(r-p);\n    return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment &a,const Segment &b){\n    if(isIntersectSS(a,b)) return 0;\n    return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n           min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nstruct Block{\n    Point a,b;\n    double h;\n    Block(){}\n    Block(Point &a,Point &b,double h) :\n        a(a),b(b),h(h) {}\n};\n\nistream &operator >> (istream &is,Point &p){ \n    return is >> p.x >> p.y;\n}\n\ndouble calc(double a,double b){\n    return sqrt(a*a+b*b);\n}\n\nbool c(double r,Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point a = v[i].a,b = v[i].b;\n        Point c(a.x,b.y),d(b.x,a.y);\n        Segment s1(a,c),s2(a,d),s3(c,b),s4(d,b);\n        double dst[] = {\n            distanceSS(p,s1),distanceSS(p,s2),\n            distanceSS(p,s3),distanceSS(p,s4)\n        };\n \n        if(r < v[i].h){\n            if(!(r < dst[0] && r < dst[1] &&\n                 r < dst[2] && r < dst[3])){\n                return 0;\n            }\n        }else{\n            double nh = r - v[i].h;\n            if(!(r < calc(nh,dst[0]) && r < calc(nh,dst[1]) &&\n                 r < calc(nh,dst[2]) && r < calc(nh,dst[3]))){\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nbool check(Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point a = v[i].a,b = v[i].b;\n        Point c(a.x,b.y),d(b.x,a.y);\n        Segment s1(a,c),s2(a,d),s3(c,b),s4(d,b);\n        if((a.x < p.s.x && p.s.x < b.x &&\n            a.y < p.s.y && p.s.y < b.y) ||\n           (a.x < p.t.x && p.t.x < b.x &&\n            a.y < p.t.y && p.t.y < b.y)){\n            return 1;\n        }\n        if(isIntersectSS(p,s1)) return 1;\n        if(isIntersectSS(p,s2)) return 1;\n        if(isIntersectSS(p,s3)) return 1;\n        if(isIntersectSS(p,s4)) return 1;\n    }\n    return 0;\n}\n\nint main(){\n    int N;\n    while(cin >> N,N){\n        Segment seg;\n        cin >> seg.s >> seg.t;\n        vector<Block> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].a >> v[i].b >> v[i].h;\n        }\n        if(check(seg,v)){\n            cout << 0 << endl;\n            continue;\n        }\n        double l = 0,r = 1001;\n        for(int i = 0 ; i < 100 ; i++){\n            double mid = (l + r) / 2;\n            if(c(mid,seg,v)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n        printf(\"%.10f\\n\",l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <math.h>\n#include <complex>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {\n\treturn (conj(a)*b).X;\n}\n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {\n\treturn (conj(a)*b).Y;\n}\n\n// ??????????????????\nint ccw(P a, P b, P c) {\n\tb -= a;  c -= a;\n\tif (cross(b, c) >  EPS) return +1;  // counter clockwise\n\tif (cross(b, c) < -EPS) return -1;  // clockwise\n\tif (dot(b, c)   < -EPS) return +2;  // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n\treturn 0;                          // a--c--b on line or a==c or b==c\n}\n\n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n\treturn a1 + dot(a2 - a1, p - a1) / norm(a2 - a1) * (a2 - a1);\n}\n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n\t\tccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\nbool isecSP(P a1, P a2, P b) {\n\treturn !ccw(a1, a2, b);\n}\n\nD distSP(P a1, P a2, P p) {\n\tP r = proj(a1, a2, p);\n\tif (isecSP(a1, a2, r)) return abs(r - p);\n\treturn min(abs(a1 - p), abs(a2 - p));\n}\nD distSS(P a1, P a2, P b1, P b2) {\n\tif (isecSS(a1, a2, b1, b2)) return 0;\n\treturn min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n\t\t\t   min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\nvector<pair< double, double>> jama;\nbool ds(double r) {\n\tREP(i, jama.size()) {\n\t\tif (r < jama[i].first) {\n\t\t}\n\t\telse if (jama[i].first < jama[i].second) {\n\t\t\tif (r > jama[i].first)\n\t\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\tif (r > (jama[i].second*jama[i].second + jama[i].first*jama[i].first) / (2 * jama[i].second))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tdouble sx, sy, gx, gy;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tjama.clear();\n\t\tjama.resize(n);\n\t\tREP(i, n) {\n\t\t\tdouble mi_x, mi_y, ma_x, ma_y, h;\n\t\t\tcin >> mi_x >> mi_y >> ma_x >> ma_y >> h;\n\t\t\tdouble mi = 1e9;\n\t\t\tmi = min(mi, distSS({ sx,sy }, { gx,gy }, { mi_x,mi_y }, {mi_x,ma_y}));\n\t\t\tmi = min(mi, distSS({ sx,sy }, { gx,gy }, { mi_x,ma_y }, { ma_x,ma_y }));\n\t\t\tmi = min(mi, distSS({ sx,sy }, { gx,gy }, { ma_x,ma_y }, { ma_x,mi_y }));\n\t\t\tmi = min(mi, distSS({ sx,sy }, { gx,gy }, { ma_x,mi_y }, { mi_x,mi_y }));\n\t\t\tif (mi_x <= sx&&sx <= ma_x&&mi_y <= sy&&sy <= ma_y)\n\t\t\t\tmi = 0.0;\n\t\t\tif (mi_x <= gx&&gx <= ma_x&&mi_y <= gy&&gy <= ma_y)\n\t\t\t\tmi = 0.0;\n\t\t\tjama[i].first = abs(mi);\n\t\t\tjama[i].second = h;\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tREP(i, n)\n\t\t\tif (jama[i].first < jama[i].second)\n\t\t\t\tans = min(ans, jama[i].first);\n\t\t\telse\n\t\t\t\tans = min(ans, (jama[i].second*jama[i].second + jama[i].first*jama[i].first) / (2 * jama[i].second));\n\t\tprintf(\"%.4lf\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//二次元幾何ライブラリ\n#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define ML make_pair \ntypedef long double D;\ntypedef bool B;\ntypedef complex<D> P;   //点\ntypedef complex<D> V;   //ベクトル\ntypedef pair<P,P>  L;   //直線\ntypedef pair<P,D>  C;   //円\ntypedef vector<P>  Pol; //多角形\n\n//変数名定義\nconst D INF = 1e100;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ntemplate<class T> bool operator==(T a, T b){return abs(a - b )< EPS;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n\n\n\n// ベクトルaの絶対値を求める\n// D Length = abs(a);\n\n// 2点a,b間の距離を求める\n// D Distance = abs(a-b); \n\n// 内積 (Inner Product) : a・b = |a||b|cosθ\nD IP(V a, V b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (Exterior Product) : |a×b| = |a||b|sinθ \nD EP(V a, V b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n// 点の進行方向について\nint ccw(P a, P b, P c) {              //点aと点bが与えられた問いに\n  b -= a; c -= a;\n  if (EP(b, c) > 0)   return +1;      // counter clockwise\n  if (EP(b, c) < 0)   return -1;      // clockwise\n  if (IP(b, c) < 0)     return +2;    // c--a--b on line\n  if (norm(b) < norm(c)) return -2;   // a--b--c on line\n  return 0;                           // a--c--b on line  aとbの線分判定はこれ\n}\n\n\n// 2直線の垂直判定 : a⊥b <=> IP(a, b) = 0\nB IsVecular(L l1, L l2) {\n\treturn IP(l1.first-l1.second, l2.first-l2.second)==0.0;\n}\n\n// 2直線の平行判定 : a//b <=> EP(a, b) = 0\nB IsParallel(L l1, L l2) {\n\treturn EP(l1.first-l1.second, l2.first-l2.second)== 0.0;\n}\n\n// 2線分の交差判定 \nB IIS(L l1, L l2) {\n  return ( EP(l1.second-l1.first, l2.first-l1.first) * EP(l1.second-l1.first, l2.second-l1.first) < EPS ) &&\n         ( EP(l2.second-l2.first, l1.first-l2.first) * EP(l2.second-l2.first, l1.second-l2.first) < EPS );\n}\n\n// 符号付き点と直線の距離 (Distance of Point and Line)  //lの構造 x座標 first<second y座標 first<second 左上 正 右下 負 一致 0\nD  DPL(P p,L l){\n\tV v1=(l.second-l.first);\n\tV v2=(p-l.first);\n\treturn EP(v1,v2)/abs(v1);\n}\n\n// 点と線分の距離 (Distance of Point and Segment)  //lの構造 x座標 first<second y座標 first < second \nD  DPS(P p,L l){\n\tV v1,v2,v3;\n\tv1=l.second-l.first;\n\tv2=p-l.first;\n\tv3=p-l.second;\n\tif(IP (v1,v2) <0)\n\t\treturn abs(p-l.first);\n\telse if(IP(-v1,v3)<0)\n\t\treturn abs(p-l.second);\n\telse\n\t\treturn abs(DPL(p,l));\n}\n\n// 線分と線分の距離 (Distance of Segment and Segment)  //lの構造 x座標 first<second y座標 first < second \nD DSS(L l1,L l2){\n\tif(IIS(l1,l2))\n\t\treturn 0;\n\telse{\n\t\tD tem,tem1,tem2;\n\t\ttem1=min(DPS(l1.first,l2),DPS(l1.second,l2));\n\t\ttem2=min(DPS(l2.first,l1),DPS(l2.second,l1));\n\t\treturn\tmin(tem1,tem2);\n\t}\n}\n\n// 三角形の領域判定 Teritory of Triangle 1が内部 0が境界と外部\nB TT(P p1,P p2,P p3,P p){\n\tL l1,l2,l3;\n\tl1=make_pair(p2,p3);\n\tl2=make_pair(p3,p1);\n\tl3=make_pair(p1,p2);\n\n\tif(sig(DPL(p1,l1))!=sig(DPL(p,l1)))\n\t\treturn false;\n\telse if(sig(DPL(p2,l2))!=sig(DPL(p,l2)))\n\t\treturn false;\n\telse if(sig(DPL(p3,l3))!=sig(DPL(p,l3)))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n//変数名 = 型 代入したいもの\n//example : v1 = V(5.0,-3.0) p1=P(0.0,4.0)\nint main(void){\n\twhile(true){\n\tint N;\n\t\tcin >>N; \n\tif(!N)\n\t\tbreak;\n\tD Block[50][2][2];\n\tD h[50];\n\tP root1,root2;\n\tL root;\n\tD r;\n\tD rmin=INF;\n\t\tcin >> root1.real() >> root1.imag()>> root2.real() >> root2.imag();\n\trep(i,N)\n\t\tcin >> Block[i][0][0] >> Block[i][0][1] >> Block[i][1][0] >> Block[i][1][1] >>h[i] ;\n\troot=ML(root1,root2);\n\trep(i,N){\n\t\t\tD tem,tem1,tem2;\n\t\t\tP p1,p2,p3,p4;\n\t\t\tp1=P(Block[i][0][0],Block[i][0][1]);\n\t\t\tp2=P(Block[i][1][0],Block[i][0][1]);\n\t\t\tp3=P(Block[i][1][0],Block[i][1][1]);\n\t\t\tp4=P(Block[i][0][0],Block[i][1][1]);\n\t\t\tL la,lb,lc,ld;\n\t\t\tla=ML(p1,p2);\n\t\t\tlb=ML(p2,p3);\n\t\t\tlc=ML(p3,p4);\n\t\t\tld=ML(p4,p1);\n\t\t\tif(p1.real()<root1.real()&&root1.real()<p3.real()&&p1.imag()<root1.imag()&&root1.imag()<p3.imag())\n\t\t\t\ttem=0;\n\t\t\telse {\n\t\t\t\ttem1=min(DSS(root,la),DSS(root,lb));\n\t\t\t\ttem2=min(DSS(root,lc),DSS(root,ld));\n\t\t\t\ttem=min(tem1,tem2);\n\t\t\t}\n\t\t\tif(tem<=h[i])\n\t\t\t\tr=tem;\n\t\t\telse\n\t\t\t\tr=(h[i]+tem*tem/h[i])/2.0;\n\t\t\tif(rmin > r)\n\t\t\t\trmin=r;\n\t}\n\tcout.precision(10);    \n\tcout <<rmin << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-9;\ntemplate<typename T>\nT sqr(T a) { return a * a; }\n\nstruct search_point {\n\tdouble x, y;\n\tdouble h;\n\tsearch_point(double x_, double y_, double h_) {\n\t\tx = x_; y = y_; h = h_;\n\t}\n};\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tdouble sx, sy, ex, ey;\n\t\tvector<search_point> v;\n\t\tvector<pair<search_point,search_point> > line;\n\t\tvector<pair<search_point,search_point> > lect;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tdouble R = 10000;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble h;\n\t\t\tcin >> x0 >> y0 >> x1 >> y1 >> h;\n\n\t\t\tif(h < EPS)\n\t\t\t\th = EPS;\n\n\t\t\tv.push_back(search_point(x0, y0, h));\n\t\t\tv.push_back(search_point(x1, y1, h));\n\t\t\tv.push_back(search_point(x0, y1, h));\n\t\t\tv.push_back(search_point(x1, y0, h));\n\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x0, y0, 0), search_point(x1, y0, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x1, y0, 0), search_point(x1, y1, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x1, y1, 0), search_point(x0, y1, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x0, y1, 0), search_point(x0, y0, 0)));\n\n\t\t\tlect.push_back(pair<search_point,search_point>(search_point(x0, y0, 0), search_point(x1, y1, 0)));\n\n\t\t\tif(x0 < sx && sx < x1) {\n\t\t\t\tv.push_back(search_point(sx, y0, h));\n\t\t\t\tv.push_back(search_point(sx, y1, h));\n\t\t\t}\n\t\t\tif(y0 < sy && sy < y1) {\n\t\t\t\tv.push_back(search_point(x0, sy, h));\n\t\t\t\tv.push_back(search_point(x1, sy, h));\n\t\t\t}\n\t\t\tif(x0 < ex && ex < x1) {\n\t\t\t\tv.push_back(search_point(ex, y0, h));\n\t\t\t\tv.push_back(search_point(ex, y1, h));\n\t\t\t}\n\t\t\tif(y0 < ey && ey < y1) {\n\t\t\t\tv.push_back(search_point(x0, ey, h));\n\t\t\t\tv.push_back(search_point(x1, ey, h));\n\t\t\t}\n\t\t}\n\n\t\tdouble veclx = (ex - sx);\n\t\tdouble vecly = (ey - sy);\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tdouble d;\n\t\t\tdouble mx, my;\n\t\t\tdouble r;\n\n\t\t\tmx = (v[i].x * sqr(veclx) + v[i].y * veclx * vecly + vecly * (sx * ey - sy * ex)) / (sqr(veclx) + sqr(vecly));\n\t\t\tmy = (v[i].y * sqr(vecly) + v[i].x * vecly * veclx + veclx * (sy * ex - sx * ey)) / (sqr(vecly) + sqr(veclx));\n\t\t\t/*\n\t\t\tif((ey - sy) * mx - (ex - sx) * my + (ex * sy - sx * ey) > EPS) {\n\t\t\t\tcout << \"error\" << \" \" << (sy - ey) * mx - (sx - ex) * my - (ex * sy - sx * ey) << endl;\n\t\t\t\tcout << mx << \",\" << my << endl;\n\t\t\t}\n\t\t\t// */\n\t\t\td = sqrt(sqr(mx - v[i].x) + sqr(my - v[i].y));\n\t\t\tif(mx <= min(sx,ex) || max(sx,ex) <= mx || my <= min(sy,ey) || max(sy,ey) <= my) {\n\t\t\t\td = min(sqrt(sqr(sx - v[i].x) + sqr(sy -  v[i].y)), sqrt(sqr(ex - v[i].x) + sqr(ey - v[i].y)));\n\t\t\t}\n\t\t\tr = fabs(sqr(min(v[i].h,d)) + sqr(d)) / (2 * v[i].h);\n\t\t\tR = min(R, r);\n\t\t}\n\t\tfor(int i = 0; i < line.size(); i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble s, t;\n\t\t\tx0 = line[i].first.x; y0 = line[i].first.y;\n\t\t\tx1 = line[i].second.x; y1 = line[i].second.y;\n\n\t\t\ts = ((ex - sx) * (y1 - sy) - (ey - sy) * (x1 - sx)) / ((x0 - sx) * (y1 - sy) - (y0 - sy) * (x1 - sx));\n\t\t\tt = ((ex - sx) * (y0 - sy) - (ey - sy) * (x0 - sx)) / ((x1 - sx) * (y0 - sy) - (y1 - sy) * (x0 - sx));\n\n\t\t\tif(s > -EPS && t > -EPS && s + t > 1 - EPS) {\n\t\t\t\tR = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < lect.size(); i++) {\n\t\t\tbool flag0, flag1;\n\t\t\tflag0 = lect[i].first.x < sx && sx < lect[i].second.x && lect[i].first.y < sy && sy < lect[i].second.y;\n\t\t\tflag1 = lect[i].first.x < ex && ex < lect[i].second.x && lect[i].first.y < ey && ey < lect[i].second.y;\n\n\t\t\tif(flag0 | flag1)\n\t\t\t\tR = 0;\n\t\t}\n\t\tprintf(\"%.10f\\n\", R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\n#define dame cout << 0 << endl; return;\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n};\n\nL readL() {\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    return L(xa, ya, xb, yb);\n}\n\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nint ccw(P p0, P p1, P p2) {\n    if (cross(p1 - p0, p2 - p0) > 0) return +1; // counter-clockwise\n    if (cross(p1 - p0, p2 - p0) < 0) return -1; // clockwise\n    if (dot(p1 - p0, p2 - p0) < 0) return +2;   // online_back\n    if (dot(p0 - p1, p2 - p1) < 0) return -2;   // online_front\n    return 0;                                   // on_segment\n}\n\n// !! ???????????????????????¨?????? \"<\" !!\nbool intersectSS(L l1, L l2) {\n    return (ccw(l1.a, l1.b, l2.a) * ccw(l1.a, l1.b, l2.b) <= 0 &&\n            ccw(l2.a, l2.b, l1.a) * ccw(l2.a, l2.b, l1.b) <= 0);\n}\n\nbool intersectSG(L l, G g) {\n    int n = g.size();\n    rep(i, n) {\n        if (intersectSS(l, L(here(g, i), next(g, i)))) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n// bool intersectLS(L l, L s) {\n//     return ccw(l.a, l.b, s.a) * ccw(l.a, l.b, s.b) <= 0;\n// }\n//\n// bool intersectLG(L l, G g) {\n//     int n = g.size();\n//     rep(i, n) {\n//         if (intersectLS(l, L(here(g, i), next(g, i)))) {\n//             return true;\n//         }\n//     }\n//     return false;\n// }\n\ndouble distanceLP(L l, P p) {\n    return abs(cross(l.v, p - l.a)) / abs(l.v);\n}\n\ndouble distanceSP(L l, P p) {\n    if (dot(l.v, p - l.a) < 0) return abs(p - l.a);\n    if (dot(-l.v, p - l.b) < 0) return abs(p - l.b);\n    return distanceLP(l, p);\n}\n\ndouble distanceSS(L l1, L l2) {\n    if (intersectSS(l1, l2)) return 0;\n    double d = INF;\n    d = min(d, distanceSP(l1, l2.a));\n    d = min(d, distanceSP(l1, l2.b));\n    d = min(d, distanceSP(l2, l1.a));\n    d = min(d, distanceSP(l2, l1.b));\n    return d;\n}\n\ndouble distanceSG(L l, G g) {\n    double d = INF;\n    rep(i, g.size()) {\n        d = min(d, distanceSS(l, L(here(g, i), next(g, i))));\n    }\n    return d;\n}\n\nbool within(double x, double a, double b) {\n    return a <= x && x <= b;\n}\n\nvoid solve(int n) {\n    double sx, sy, ex, ey;\n    cin >> sx >> sy >> ex >> ey;\n    L seg_ball(sx, sy, ex, ey);\n    vector<G> rect(n);\n    vector<double> h(n);\n\n    rep(i, n) {\n        double minx, miny, maxx, maxy;\n        cin >> minx >> miny >> maxx >> maxy >> h[i];\n        rect[i].emplace_back(minx, miny);\n        rect[i].emplace_back(maxx, miny);\n        rect[i].emplace_back(maxx, maxy);\n        rect[i].emplace_back(minx, maxy);\n\n        if (within(sx, minx, maxx) && within(sy, miny, maxy) && within(ex, minx, maxx) && within(ey, miny, maxy)) {\n            dame;\n        }\n    }\n\n    rep(i, n) {\n        if (intersectSG(seg_ball, rect[i])) {\n            dame;\n        }\n    }\n\n    auto check = [&](double r){\n        rep(i, n) {\n            P p;\n            double d = distanceSG(seg_ball, rect[i]);\n            if (r < h[i]) {\n                if (r > d) return false;\n            } else {\n                if (h[i] > r - sqrt(r*r - d*d)) return false;\n            }\n        }\n        return true;\n    };\n\n    double lb = 0, ub = 1e5;\n    rep(i, 100) {\n        double mid = (lb + ub) / 2;\n        (check(mid) ? lb : ub) = mid;\n    }\n\n    cout << fixed << setprecision(20) << lb << endl;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        solve(n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\n//// definition of point\n#define x(p) real(p)\n#define y(p) imag(p)\n\nconst double eps=1e-10;\nconst double inf=1e12;\nconst double PI=acos(-1);\ntypedef complex<double> P;\n\nnamespace std{\n  bool operator<(const P& a,const P& b){\n    return x(a)==x(b)?y(a)<y(b):x(a)<x(b);\n  }\n}\ndouble cross(const P& a,const P& b){\n  return y(conj(a)*b);\n}\ndouble dot(const P& a,const P& b){\n  return x(conj(a)*b);\n}\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\n//// counter-clockwise\nint ccw(P a,P b,P c) {\n  b=b-a;c=c-a;\n  if(cross(b,c)>0) return +1;       // counter clockwise\n  if(cross(b,c)<0) return -1;       // clockwise\n  if(dot(b,c)<0)   return +2;       // c--a--b on line\n  if(norm(b)<norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//// intersect\nbool intersectLL(const L& l,const L& m){\n  return abs(cross(l[1]-l[0],m[1]-m[0]))>eps||abs(cross(l[1]-l[0],m[0]-l[0]))<eps;\n}\nbool intersectLS(const L& l,const L& s){\n  return cross(l[1]-l[0],s[0]-l[0])*cross(l[1]-l[0],s[1]-l[0])<eps;\n}\nbool intersectLP(const L& l,const P& p){\n  return abs(cross(l[1]-p,l[0]-p))<eps;\n}\nbool intersectSS(const L& s,const L& t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0&&ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\nbool intersectSP(const L& s,const P& p){\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0])<eps;\n}\n\n//// move point\nP projection(const L& l,const P& p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*x(c/b);\n}\nP reflection(const L& l,const P& p) {\n  return p+2.0*(projection(l,p)-p);\n}\nP rotation(const P& a,double r){\n  return P(x(a)*cos(r)-y(a)*sin(r),x(a)*sin(r)+y(a)*cos(r));\n}\n\n//// distance\ndouble distanceLP(const L& l,const P& p) {\n  return abs(p-projection(l,p));\n}\ndouble distanceLL(const L& l,const L& m) {\n  return intersectLL(l,m)?0:distanceLP(l,m[0]);\n}\ndouble distanceLS(const L& l,const L& s) {\n  return intersectLS(l,s)?0:min(distanceLP(l,s[0]),distanceLP(l,s[1]));\n}\ndouble distanceSP(const L& s,const P& p) {\n  const P r=projection(s,p);\n  return intersectSP(s,r)?abs(r-p):min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble distanceSS(const L& s,const L& t) {\n  return intersectSS(s,t)?0:min(min(distanceSP(s,t[0]),distanceSP(s,t[1])),\n                                min(distanceSP(t,s[0]),distanceSP(t,s[1])));\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0)break;\n    double x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    L route(P(x1,y1),P(x2,y2));\n    double res=inf;\n    bool ok=true;\n    rep(i,n){\n      double h;\n      cin>>x1>>y1>>x2>>y2>>h;\n      P p1(x1,y1),p2(x1,y2),p3(x2,y2),p4(x2,y1);\n      double dist=inf;\n      if(intersectSS(route,L(p1,p2))||intersectSS(route,L(p2,p3))||intersectSS(route,L(p3,p4))||intersectSS(route,L(p4,p1))\n        ||(x1<=x(route[0])&&x(route[0])<=x2&&y1<=y(route[0])&&y(route[0])<=y2))ok=false;\n      minch(dist,distanceSS(route,L(p1,p2)));\n      minch(dist,distanceSS(route,L(p2,p3)));\n      minch(dist,distanceSS(route,L(p3,p4)));\n      minch(dist,distanceSS(route,L(p4,p1)));\n      minch(res,max(dist,(h*h+dist*dist)/(2.0*h)));\n    }\n    if(!ok) printf(\"%.10f\\n\",0.0);\n    else printf(\"%.10f\\n\", res);\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 30;\n\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n#define mp make_pair\n\ntypedef bool B;\ntypedef long double D;\ntypedef vector<D> VD;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef pair <P,P> L;\ntypedef vector<L> VL;\ntypedef struct {P c;D r;} C;\ntypedef struct {P c;D a,b;} E; // ?\\???????????????????\ntypedef vector <P> Pol;\n\n// ??????????????????\ninline B cmp_x(const P &a,const P &b){ return (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;}  // base x\ninline B cmp_y(const P &a,const P &b){ return (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;}  // base y\ninline B cmp_a(const P &a,const P &b){ return (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);} // base arg\n\ninline P input(){D x,y;cin >> x >> y; return P(x,y);}\n\n// ?????¬??????\n// verify\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sr(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.second-l.first;}\n\n\n// ???\nD toRagian(D degree){ return degree*pi/180.0;}\nD ang (P p){return arg(p);}\nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base ??????\nP rot (P base, P a, D theta){return base+polar( abs(a-base), arg(a-base)+theta );}\n\n// verify AOJ 2514\nP proj(P b,P p){ return b*ip(b,p)/norm(b);} \nP proj(L l,P p){ return l.first+proj(vec(l),p-l.first);}\nP refl(L l,P p){ return proj(l,p)*D(2.0)-p; }\n\n// ccw \nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, MID = 16, ON=FRONT|BACK|MID };\n\ninline int ccw(P base, P a, P b) {              //???a??¨???b???????????????????????????\n  a -= base; b -= base;\n  if (ep(a, b) > eps)   \t return LEFT;    // counter clockwise\n  if (ep(a, b) < -eps)      return RIGHT;   // clockwise\n  if (ip(a, b) < -eps)      return BACK;    // b--base--a on line\n  if (norm(a) < norm(b)) return FRONT;   // base--a--b on line\n  \t\t\t\t\t\t return MID;      // base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????? ??´???\n\t// ?????¨??´???????????¢\n\t// ?????¨??????????????¢\n\t// ??´?????¨??´???????????¢\n\t\n\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\n// ??????\nP pLL(L a,L b){ return a.first+vec(a)*ep(vec(b),b.first-a.first)/ep(vec(b), vec(a));}\n\n\n// ?????¨??´?????¨????????¢??£???????????????\n\nB iLL(L l1,L l2){ return !ipar(l1,l2);}\nB eqL(L a, L b) {return !iLL(a, b) && ep(vec(a), b.first - a.first)==0;}\nB iLS(L a, L b)  {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <= 0;}\nB iLSs(L a, L b) {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <  0;}\nB iSS(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nB iSSs(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// ?????¨??´?????¨????????¢??£????????¢\n\nD dLP(L l,P p){ return abs( ep(vec(l),p-l.first) )/abs(vec(l));}\nD dSP(L s,P p){\n\tif (sig( ip( vec(s), p - s.first)) <= 0) return abs(p - s.first);\n\tif (sig( ip(-vec(s), p - s.second)) <= 0) return abs(p - s.second);\n\treturn dLP(s,p);\n}\nD dLL(L a,L b){ return iLL(a,b) ? 0 : dLP(a,b.first);}\nD dLS(L a,L b){ return iLS(a,b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));}\nD dSS(L a,L b){ return iSS(a,b) ? 0 : min( min(dSP(a,b.first),dSP(a,b.second)),min(dSP(b,a.first),dSP(b,a.second)));}\n\n\n// ???\n// Verify AOJ 1183\n\nenum RCC{A_IN_B=1,B_IN_A=2,A_ON_B=4,B_ON_A=8,ISC=16,ON_OUT=32,OUT=64,SAME=12,ONS=48 };\n\n\nint rCC(C a,C b){\n\tD d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) res|=OUT;\n\tif(a.r+b.r==d) res|=ON_OUT;\n\tif(abs(a.r-b.r) < d && d < a.r+b.r) res|=ISC;\n\tif(d==b.r-a.r) res|=A_ON_B;\n\tif(d< b.r-a.r) res|=A_IN_B;\n\tif(d==a.r-b.r) res|=B_ON_A;\n\tif(d< a.r-b.r) res|=B_IN_A;\n\treturn res;\n}\n\n//2??????????????????\n// Verify AOJ 1183\n\nVP pCC(C a,C b){\n\tVP res;\n\tint rel=rCC(a,b);\n\tif(rel==SAME){   // Same\n\t\tres.pb(a.c+P(a.r,0));\n\t\tres.pb(a.c+P(-a.r,0));\n\t\tres.pb(a.c+P(0,a.r));\n\t\tres.pb(a.c+P(0,-a.r));\n\t}else if(rel==ISC){         // 2points\n\t\tD d = abs(b.c - a.c);\n\t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n\t\tP e = (b.c - a.c) / abs(b.c - a.c), w = e * P(0, 1) * sqrt(max(a.r * a.r - x * x, (D)0));\n\t\tres.pb(a.c + e * x - w);\n\t\tres.pb(a.c + e * x + w);\t\n\t}else if(rel&ONS){ // 1points\n\t\tD d = abs(b.c - a.c);\n \t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n \t\tP e = (b.c - a.c) / abs(b.c - a.c);\n  \t\tres.pb(a.c + e * x);\n\t}\n\treturn res;\n}\n\n\nVP pCL(C c, L l) {\n\tVP res;\n\tP h = proj(l, c.c);\n\tP e = vec(l) / abs(vec(l)) * sr(c.r * c.r - norm(h - c.c));\n\tres.pb(h - e);\n\tres.pb(h + e);\n\treturn res;\n}\n\n\n// ????????\\???\n// Verify AOJ 2001\n\nL tanC(C c,D t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L(p-d,p+d);\n}\n\n\n// ????????±?????\\???\n// Verify AOJ 2001\n\nVL common_tan(C a,C b){\n\tVL res;\n\tD d=ang(b.c-a.c);\n\tD i=acos((a.r+b.r)/abs(b.c-a.c));\n\tD o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rCC(a,b);\n\n\tif(r==OUT){\t\t//??±????????\\???\n\t\tres.pb(tanC(a,d+i));\n\t\tres.pb(tanC(a,d-i));\n\t}\n\n\tif(r>=ISC){\t\t// ??±????????\\???\n\t\tres.pb(tanC(a,d+o));\n\t\tres.pb(tanC(a,d-o));\n\t}\n\n\tif(r&ONS)\t\t//??\\????????±???????????\\???\n\t\tres.pb(tanC(a,d));\n\n\tif(r==SAME){\n\t\trep(i,5)\n\t\t\tres.pb(tanC(a,i));\n\t}\n\treturn res;\n}\n\n\n// ?\\????\n\n// ????§???¢\n\n// ????§???¢??????????????????(???????§???¢??????)\n//verify AOJ CGL_3-C\nint in_polygon(Pol pol,P p){\n    int n=pol.size();\n    int res=0;\n    rep(i,n){\n        if(ccw(pol[i],pol[(i+1)%n],p)==MID)\n            return 1;\n        if ((pol[i].Y <= p.Y) && (pol[(i+1)%n].Y>p.Y)){\n            D vt=(p.Y-pol[i].Y)/(pol[(i+1)%n].Y-pol[i].Y);\n            D dx=pol[(i+1)%n].X-pol[i].X;\n            if(p.X < pol[i].X + vt*dx)\n                    res++;\n        }else if ((pol[i].Y>p.Y)&&(pol[(i+1)%n].Y<=p.Y)){\n            D vt=(p.Y - pol[i].Y)/(pol[(i+1)%n].Y-pol[i].Y);\n            D dx=pol[(i+1)%n].X-pol[i].X;\n            if(p.X <pol[i].X+vt*dx)\n                res--;\n        }\n    }\n    return res?2:0;\n}\n\n\n// ????§???¢??????????????????(???????§???¢??????)\n// Verify AOJ 2514\n\nbool in_polygon(Pol pol,L s){\n\tVP check;\n\tint n=pol.size();\n\n\trep(i,n){\n\t\tL tar=L(pol[i],pol[(i+1)%n]);\n\t\tif(iSS(s,tar))\n\t\t\tcheck.pb(pLL(s,tar));\n\t}\n\n\tcheck.pb(s.first);\n\tcheck.pb(s.second);\n\tsort(check.begin(),check.end(),cmp_x);\n\tn=check.size();\n\tbool res=true;\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/P(2.0,0.0);\n\t\tif(!in_polygon(pol,m))\n\t\t\tres=false;\n\t}\n\treturn res;\n}\n\n\n// Area\n// Verify AOJ 1100\nD area(Pol pol){\n\tint n=pol.size();\n\tD xx,yy,sum=0.0;\n\trep(i,n){\n\t\txx=pol[i%n].X-pol[(i+1)%n].X;\n\t\tyy=pol[i%n].Y+pol[(i+1)%n].Y;\n\t\tsum+=xx*yy;\n\t}\n\treturn abs(sum/2.0);\n}\n\n// hough T\n// ??¢?????£?????????\n\n\n\n// Convex_hull\n// Verify AOJ 0063\nPol convex_hull(Pol pol){\n\tint n=pol.size();\n\tsort(pol.begin(),pol.end(),cmp_x);\n\tPol res(2*n);\n\tint k=0;\n\t\n\t// down\n\trep(i,n){\n\t\twhile( k>1 && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<=0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile( k>t && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<=0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\nusing Block = tuple<P, P, D>;\n\nint n;\nL line;\nVD h, d;\n\nbool check(D r){\n    rep(i, n){\n        D hh = r - h[i], dist = r;\n        if(hh > eps){\n            dist = sqrt(sqr(r) - sqr(hh));\n        }\n\n        if(dist >= d[i]) return false;\n    }\n\n    return true;\n}\n\nint main(void){\n    for(; cin >> n, n;){\n        P s = input(), t = input();\n        line = L(s, t);\n\n        h = VD(n);\n        d = VD(n, INF);\n        bool ok = true;\n        rep(i, n){\n            P lu = input(), rd = input();\n            cin >> h[i];\n   \n            if(lu.X < s.X and s.X < rd.X and lu.Y < s.Y and s.Y < rd.Y) ok = false;\n            if(lu.X < t.X and t.X < rd.X and lu.Y < t.Y and t.Y < rd.Y) ok = false;\n\n            VL edge = {\n                L(lu, P(rd.X, lu.Y)),\n                L(lu, P(lu.X, rd.Y)),\n                L(rd, P(rd.X, lu.Y)),\n                L(rd, P(lu.X, rd.Y))\n            };\n\n            rep(j, 4){\n                d[i] = min(d[i], dSS(line, edge[j]));\n            }\n            if(d[i] < eps) ok = false;\n        }\n\n        if(not ok){\n            cout << 0 << endl;\n            continue;\n        }\n\n        D lb = 0.0, ub = 1010.0;\n        rep(_, 100){\n            D mid = (lb + ub) / 2.0;\n\n            if(check(mid)){\n                lb = mid;\n            }\n            else {\n                ub = mid;\n            }\n        }\n\n        cout.precision(12);\n        cout << ub << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include <complex>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<int,pair<int,int> > PP;\ntypedef pair<LL,int> LP;\nconst int INF=1<<30;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%d%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(LL *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%lld%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid print_YES_NO(bool answer){cout<<(answer?\"YES\":\"NO\")<<endl;}\nvoid print_Yes_No(bool answer){cout<<(answer?\"Yes\":\"No\")<<endl;}\nvoid print_POSSIBLE_IMPOSSIBLE(bool answer){cout<<(answer?\"POSSIBLE\":\"IMPOSSIBLE\")<<endl;}\n\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nint main(){\n\tint n;\n\tLine la;\n\tLine lt[5];\n\tdouble da,db,dc,dd,de;\n\tint a,b,c,d;\n\tint i,j,k;\n\tint x,y;\n\tdouble s=0;\n\twhile(cin>>n){\n\t\tif(!n)break;\n\t\tcin>>da>>db>>dc>>dd;\n\t\tla.a=Point(da,db),la.b=Point(dc,dd);\n\t\tx=da,y=db;\n\t\ts=1000.0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>da>>db>>dc>>dd>>de;\n\t\t\tlt[0].a=Point(da,db),lt[0].b=Point(da,dd);\n\t\t\tlt[1].a=Point(dc,db),lt[1].b=Point(dc,dd);\n\t\t\tlt[2].a=Point(da,db),lt[2].b=Point(dc,db);\n\t\t\tlt[3].a=Point(da,dd),lt[3].b=Point(dc,dd);\n\t\t\tif(isis_ss(la,lt[0]) || isis_ss(la,lt[1]) ||\n\t\t\tisis_ss(la,lt[2]) || isis_ss(la,lt[3])){\n\t\t\t\ts=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(da<=x && x<=dc && db<=y && y<=dd){\n\t\t\t\ts=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlong double dt[20]={dist_sp(la,Point(da,db)),dist_sp(la,Point(dc,db)),\n\t\t\tdist_sp(la,Point(da,dd)),dist_sp(la,Point(dc,dd)),\n\t\t\tdist_sp(lt[0],la.a),dist_sp(lt[0],la.b),\n\t\t\tdist_sp(lt[1],la.a),dist_sp(lt[1],la.b),\n\t\t\tdist_sp(lt[2],la.a),dist_sp(lt[2],la.b),\n\t\t\tdist_sp(lt[3],la.a),dist_sp(lt[3],la.b)};\n\t\t\tsort(dt,dt+12);\n\t\t\tda=dt[0];\n\t\t\t//cout<<\"da\"<<da<<endl;\n\t\t\tif(da<de)s=min(s,da);\n\t\t\telse s=min(s,(da*da+de*de)/(de*2.0));\n\t\t}\n\t\tcout<<fixed<<setprecision(5)<<s<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\nconst double EPS = 1e-10;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a,make_vector<T>(b,ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\ntypedef complex<double> Point;\ntypedef pair<Point, Point> LS;\n\ndouble cross(const Point &a, const Point &b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\nint is_intersected_ls(\n        const Point &a1, const Point &a2,\n        const Point &b1, const Point &b2)\n{\n    return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS &&\n        cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS;\n}\n\nint is_parallel(\n        const Point &a1, const Point &a2,\n        const Point &b1, const Point &b2)\n{\n    return abs(cross(a1-a2, b1-b2)) < EPS;\n}\n\ndouble distance_l_p(const LS &ls, const Point &c) {\n    Point a = ls.fs, b = ls.sc;\n    if (dot(b-a, c-a) < EPS) return abs(c-a);\n    if (dot(a-b, c-b) < EPS) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\ndouble ls_distance(const LS &a, const LS &b) {\n    bool parallel = is_parallel(a.fs, a.sc, b.fs, b.sc);\n    bool intersect = is_intersected_ls(a.fs, a.sc, b.fs, b.sc);\n\n    if (!parallel && intersect) return 0;\n\n    return min({distance_l_p(a, b.fs),\n            distance_l_p(a, b.sc),\n            distance_l_p(b, a.fs),\n            distance_l_p(b, a.sc)});\n}\n\nint main()\n{\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) {\n            break;\n        }\n\n        Point s, e;\n        {\n            double sx, sy, ex, ey;\n            cin >> sx >> sy >> ex >> ey;\n            s = {sx, sy}; e = {ex, ey};\n        }\n\n        vector<array<Point,4>> rec(n);\n        vector<double> l(n), b(n), r(n), t(n), h(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> l[i] >> b[i] >> r[i] >> t[i] >> h[i];\n            rec[i] = {{{l[i], b[i]}, {l[i], t[i]}, {r[i], t[i]}, {r[i], b[i]}}};\n        }\n\n        vector<double> dist(n, numeric_limits<double>::max());\n        for (int i = 0; i < n; ++i) {\n\n            if (l[i] < s.real() && s.real() < r[i] &&\n                b[i] < s.imag() && s.imag() < t[i]) {\n                dist[i] = 0;\n                continue;\n            }\n\n            for (int k = 0; k < 4; ++k) {\n                Point a = rec[i][k], b = rec[i][(k+1)%4];\n                chmin(dist[i],\n                        ls_distance(LS(a, b), LS(s, e)));\n            }\n        }\n\n        double ans = numeric_limits<double>::max();\n        for (int i = 0; i < n; ++i) {\n            if (h[i] < dist[i]) {\n                chmin(ans, (h[i]*h[i] + dist[i]*dist[i]) / (2*h[i]));\n            } else {\n                chmin(ans, dist[i]);\n            }\n        }\n\n        printf(\"%.7lf\\n\", ans);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<long double> xy;\nlong eps = 1e-10;\nlong double dot_product(xy a,xy b) {return (conj(a)*b).real();}\nlong double cross_product(xy a,xy b) {return (conj(a)*b).imag();}\nlong double dist_lp(xy a1,xy a2,xy p){\n    if(dot_product(a2-a1,p-a1)<eps) return abs(p-a1);\n    if(dot_product(a1-a2,p-a2)<eps) return abs(p-a2);\n    return abs(cross_product(a2-a1,p-a1))/abs(a2-a1);\n}\n\nbool is_online(xy a1,xy a2,xy p){\n    return abs(a1-p)+abs(a2-p)<=abs(a1-a2)+eps;    \n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    if(is_online(a1,a2,b1) || is_online(a1,a2,b2)) return true;\n    if(is_online(b1,b2,a1) || is_online(b1,b2,a2)) return true;\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<-eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<-eps;\n}\n\nlong double dist_ll(xy a1,xy a2,xy b1,xy b2){\n    if(is_intersected(a1,a2,b1,b2)) return 0;\n    return min({dist_lp(a1,a2,b1),dist_lp(a1,a2,b2),dist_lp(b1,b2,a1),dist_lp(b1,b2,a2)\n    ,abs(a1-b1),abs(a1-b2),abs(a2-b1),abs(a2-b2)});   \n}\n\nint N;\nlong double sx,sy,gx,gy,mi_x,mi_y,ma_x,ma_y;\nlong double h;\n\n\nint main(){\n    while(cin>>N && N>0){\n        long double ans = 1e9;\n        cin >> sx >> sy >> gx >> gy;\n        if(sx>gx){\n            swap(sx,sy);\n            swap(gx,gy);\n        }\n        xy s = xy(sx,sy),g = xy(gx,gy);\n        for(int i=1;i<=N;i++){\n            cin >> mi_x >> mi_y >> ma_x >> ma_y >> h;\n            if((mi_x<=sx && sx<=ma_x && mi_y<=sy && sy<=ma_y || \n            mi_x<=gx && gx<=ma_x && mi_y<=gy && gy<=ma_y)) ans = 0;\n            long double d = min({dist_ll(s,g,xy(mi_x,mi_y),xy(mi_x,ma_y)),\n            dist_ll(s,g,xy(mi_x,ma_y),xy(ma_x,ma_y)),\n            dist_ll(s,g,xy(ma_x,ma_y),xy(ma_x,mi_y)),\n            dist_ll(s,g,xy(ma_x,mi_y),xy(mi_x,mi_y))});\n            if(d<=h) ans = min(ans,d);\n            else ans = min(ans,(h*h+d*d)/(2.0*h));\n        }\n        cout << fixed;\n        cout << setprecision(10) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n  \n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    double l=0,r=1111;\n    Point s,e;\n    cin>>s>>e;\n    Segment se=Segment(s,e);\n    Segment ss[n][4],sy[n];\n    double h[n],di[n];\n    for(int i=0;i<n;i++){\n      Point a,b;\n      cin>>a>>b>>h[i];\n      Point c=Point(a.x,b.y),d=Point(b.x,a.y);\n      ss[i][0]=Segment(a,c);\n      ss[i][1]=Segment(a,d);\n      ss[i][2]=Segment(c,b);\n      ss[i][3]=Segment(d,b);\n      di[i]=1e9;\n      for(int j=0;j<4;j++) di[i]=min(di[i],getDistance(se,ss[i][j]));\n      \n      Polygon p(4);\n      p[0]=a;p[1]=b;p[2]=c;p[3]=d;\n      p=andrewScan(p);\n      if(contains(p,s)||contains(p,e)) di[i]=0;\n      \n      //cout<<i<<\":\"<<di[i]<<\" \"<<h[i]<<endl;\n      sy[i]=Segment(Point(di[i],0),Point(di[i],h[i]));\n    }\n    for(int i=0;i<100;i++){\n      double m=(l+r)/2;\n      Point p=Point(0,m);\n      bool f=1;\n      for(int j=0;j<n;j++){\n\tf&=getDistanceSP(sy[j],p)>=m;\n\t//cout<<getDistanceSP(sy[j],p)<<\" \"<<m<<endl;\n      }\n      if(f) l=m;\n      else r=m;\n    }\n    printf(\"%.12f\\n\",l);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-8;\nconst double PI  = acos(-1.0);\n\nstruct P{\n  double x;\n  double y;\n\n  P():x(0),y(0){\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n\n};\ndouble dot(P a,P b){\n  return (a.x*b.x+a.y*b.y);\n}\n\ndouble cross(P a,P b){\n  return (a.x*b.y-a.y*b.x);\n}\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\ndouble psd(P p , P a , P b){\n  if( dot( b-a , p-a ) < EPS) return fabs(dis(p-a));\n  if( dot( a-b , p-b ) < EPS) return fabs(dis(p-b));\n  return fabs(cross( b-a , p-a )) / fabs(dis(b-a));\n}\n\nbool intersect_s(P a1 , P a2 , P b1 , P b2){\n  return ( cross(a2-a1 , b1-a1)*cross(a2-a1 , b2-a1) < 0) &&\n\t( cross(b2-b1 , a1-b1)*cross(b2-b1 , a2-b1) < 0);\n}\n\ndouble dist_s(P p1, P p2, P q1, P q2){\n  if(intersect_s(p1,p2,q1,q2)) return 0;\n  return min(min(psd(p1, q1, q2), psd(p2, q1, q2)),\n\t\t\t min(psd(q1, p1, p2), psd(q2, p1, p2)));\n}\n\nbool isin(P p, P a1, P a2){\n  double mx = min(a1.x, a2.x), Mx = max(a1.x, a2.x);\n  double my = min(a1.y, a2.y), My = max(a1.y, a2.y);\n  return mx <= p.x && p.x <= Mx\n\t&& my <= p.y  && p.y <= My;\n}\n\nint main(){\n  int N;\n  while(cin>>N,N){\n\tP s, e;\n\tvector< vector<P> > ps(N, vector<P>(4));\n\tvector<double> h(N), d(N, 1e+10);\n\tcin >> s.x >> s.y >> e.x >> e.y;\n\tREP(i,N){\n\t  cin >> ps[i][0].x >> ps[i][0].y >> ps[i][2].x >> ps[i][2].y >> h[i];\n\t  ps[i][1].x = ps[i][0].x;\n\t  ps[i][1].y = ps[i][2].y;\n\n\t  ps[i][3].x = ps[i][2].x;\n\t  ps[i][3].y = ps[i][0].y;\n\t}\n\n\tbool ng = false;\n\tREP(i,N){\n\t  if(isin(s, ps[i][0], ps[i][2]) || isin(e, ps[i][0], ps[i][2]))\n\t\tng = true;\n\t  REP(j,4)\n\t\tif(intersect_s(s,e,ps[i][j],ps[i][(j+1)%4]))\n\t\t   ng = true;\n\t}\n\tif(ng){\n\t  cout << 0 << endl;\n\t  continue;\n\t}\n\n\tREP(i,N) REP(j,4){\n\t  d[i] = min(d[i], dist_s(s, e, ps[i][j], ps[i][(j+1)%4]));\n\t}\n\n\tdouble r = 1100.;\n\tREP(j,N){\n\t  if(d[j] < h[j])\n\t\tr = min(r, d[j]);\n\t  else{\n\t\tdouble r_ = (h[j]*h[j] + d[j]*d[j]) / (2.*h[j]);\n\t\tr = min(r, r_);\n\t  }\n\t}\n\n\tcout << fixed << setprecision(6) << r << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// cpp_range (generic range class, very small equivalent of boost::irange)\n// (C) @cielavenir under Boost Software License.\n// note: end position is exclusive.\n\n#include <iterator>\ntemplate<typename T>\nclass range{\npublic:\n\tstruct iterator{\n\t\tconst T a,b;\n\t\tT p;\n\t\tconst long long d; //because T might be unsigned.\n\t\titerator(T _a,T _b,T _p,long long _d=1):a(_a),b(_b),p(_p),d(_d){}\n\n\tpublic:\n\t\ttypedef T value_type;\n\t\ttypedef T& reference;\n\t\ttypedef T* pointer;\n\t\ttypedef std::ptrdiff_t difference_type;\n\t\ttypedef std::random_access_iterator_tag iterator_category;\n\n\t\t//copy\n\t\titerator(const iterator &other):a(other.a),b(other.b),p(other.p),d(other.d){}\n\t\titerator operator=(const iterator &other){return iterator(other.a,other.b,other.p,other.d);}\n\n\t\t//advance\n\t\titerator& operator+=(T n){p+=n*d;return *this;}\n\t\titerator& operator-=(T n){return *this+=(-n);}\n\t\titerator& operator++(){return *this+=1;}\n\t\titerator& operator--(){return *this-=1;}\n\t\titerator operator+(T n) const{return iterator(a,b,p+n*d);}\n\t\titerator operator-(T n) const{return *this+(-n);}\n\n\t\t//difference\n\t\tT operator-(const iterator& other) const{return p-other.p;}\n\n\t\t//equality\n\t\tbool operator==(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p==other.p;}\n\t\tbool operator!=(const iterator& other) const{return !(*this==other);}\n\n\t\t//compare\n\t\tbool operator<(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p*d<other.p*d;}\n\t\tbool operator>(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p*d>other.p*d;}\n\n\t\t//reference\n\t\tconst T& operator*() const{return p;}\n\t};\n\nprivate:\n\tconst T a,b;\n\tT siz;\n\tlong long d;\npublic:\n\trange(T _a,T _b,long long _d=1):a(_a),b(_b){\n\t\td=_d;\n\t\tif(d==0)d=1; //\n\t\tsiz=( (d>0?(b-a):(a-b)) - 1)  / (d>0?d:-d);\n\t}\n\n\tT operator[](T n){return a+n*d;}\n\titerator begin(){return iterator(a,a+d*siz,a,d);}\n\titerator end(){return iterator(a,a+d*siz,a+d*(siz+1),d);}\n\titerator rbegin(){return iterator(b-d*siz,b,b,-1*d);}\n\titerator rend(){return iterator(b-d*siz,b,b-d*(siz+1),-1*d);}\n\tT size(){return siz;}\n};\ntemplate<typename T>\nrange<T> make_range(T a,T b,long long d=1){return range<T>(a,b,d);}\n\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cfloat>\nusing namespace std;\ntypedef double val_t;\ntypedef complex<val_t> P;\ntypedef vector<P> VP;\nconst val_t EPS=1e-9;\n\nval_t cross(const P &a,const P &b){return (conj(a)*b).imag();}\nval_t dot(const P &a,const P &b){return (conj(a)*b).real();}\nP projection(const VP &l,const P &p){\n\tP t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n\treturn l[0]+t*(l[0]-l[1]);\n}\nbool intersectSP(const VP &s,const P &p){\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nval_t distanceSP(const VP &s,const P &p){\n\tP r=projection(s,p);\n\tif(intersectSP(s,r))return abs(r-p);\n\treturn min(abs(s[0]-p),abs(s[1]-p));\n}\nbool intersectSS(const VP &l,const VP &m){\n\tval_t a=cross(l[1]-l[0],m[1]-m[0]);\n\tval_t b=cross(l[1]-l[0],l[1]-m[0]);\n\t//VP pt=abs(a)<EPS ? abs(b)<EPS ? {l[0],l[1],m[0],m[1]} : VP() : {m[0]+b/a*(m[1]-m[0])};\n\tVP pt=vector<VP>{{l[0],l[1],m[0],m[1]},{},{m[0]+b/a*(m[1]-m[0])}}[abs(a)<EPS?abs(b)<EPS?0:1:2];\n\treturn accumulate(pt.begin(),pt.end(),false,[&](bool S,const P &e){\n\t\treturn S||(dot(l[0]-e,l[1]-e)<EPS && dot(m[0]-e,m[1]-e)<EPS);\n\t});\n}\nval_t distanceSS(const VP &s,const VP &t){\n\tif(intersectSS(s,t))return 0;\n\treturn min(\n\t\taccumulate(s.begin(),s.end(),DBL_MAX,[&](val_t S,const P &e){return min(S,distanceSP(t,e));}),\n\t\taccumulate(t.begin(),t.end(),DBL_MAX,[&](val_t S,const P &e){return min(S,distanceSP(s,e));})\n\t);\n}\nint main(){\n\tint n;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tdouble sx,sy,ex,ey;\n\t\tscanf(\"%lf%lf%lf%lf\",&sx,&sy,&ex,&ey);\n\t\tVP s={P(sx,sy),P(ex,ey)};\n\t\tauto ra0=make_range(0,n);\n\t\tprintf(\"%f\\n\",accumulate(ra0.begin(),ra0.end(),DBL_MAX,[&](val_t S,int _)->val_t{\n\t\t\tint f=0;\n\t\t\tdouble x1,y1,x2,y2,h;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf\",&x1,&y1,&x2,&y2,&h);\n\t\t\tVP a;\n\t\t\tfor(auto &x:{x1,x2})for(auto &y:{y1,y2})a.emplace_back(x,y);\n\t\t\tswap(a[2],a[3]);\n\t\t\tauto ra1=make_range(0,4);\n\t\t\tval_t d=accumulate(ra1.begin(),ra1.end(),DBL_MAX,[&](val_t S,int i){\n\t\t\t\tf+=cross(a[i]-s[0],a[(i+1)%4]-s[0])<EPS;\n\t\t\t\treturn min(S,distanceSS(s,{a[i],a[(i+1)%4]}));\n\t\t\t});\n\t\t\treturn min(S,\n\t\t\t\tf==4 ? 0 : //inside\n\t\t\t\td>h ? (h*h+d*d)/h/2 :\n\t\t\t\td\n\t\t\t);\n\t\t}));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-8\n#define equal(a,b) (fabs(a-b) < EPS)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(const Point &p0,const Point &p1,const Point &p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nPoint projection(const Segment &s,const Point &p){\n    Vector b = s.t-s.s;\n    double t = dot(p-s.s,b)/norm(b);\n    return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n    return (ccw(s.s,s.t,p) == 0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n            ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n    Point r = projection(s,p);\n    if(isIntersectSP(s,r)) return abs(r-p);\n    return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment &a,const Segment &b){\n    if(isIntersectSS(a,b)) return 0;\n    return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n           min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nstruct Block{\n    Point a,b;\n    double h;\n    Block(){}\n    Block(Point &a,Point &b,double h) :\n        a(a),b(b),h(h) {}\n};\n\nistream &operator >> (istream &is,Point &p){ \n    return is >> p.x >> p.y;\n}\n\ndouble calc(double a,double b){\n    return sqrt(a*a+b*b);\n}\n\nbool c(double r,Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point a = v[i].a,b = v[i].b;\n        Point c(a.x,b.y),d(b.x,a.y);\n        Segment s1(a,c),s2(a,d),s3(c,b),s4(d,b);\n        double dst[] = {\n            distanceSS(p,s1),distanceSS(p,s2),\n            distanceSS(p,s3),distanceSS(p,s4)\n        };\n \n        if(r < v[i].h){\n            if(!(r < dst[0] && r < dst[1] &&\n                 r < dst[2] && r < dst[3])){\n                return 0;\n            }\n        }else{\n            double nh = r - v[i].h;\n            if(!(r < calc(nh,dst[0]) && r < calc(nh,dst[1]) &&\n                 r < calc(nh,dst[2]) && r < calc(nh,dst[3]))){\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nbool check(Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point a = v[i].a,b = v[i].b;\n        Point c(a.x,b.y),d(b.x,a.y);\n        Segment s1(a,c),s2(a,d),s3(c,b),s4(d,b);\n        if((a.x < p.s.x && p.s.x < b.x &&\n            a.y < p.s.y && p.s.y < b.y) ||\n           (a.x < p.t.x && p.t.x < b.x &&\n            a.y < p.t.y && p.t.y < b.y)){\n            return 1;\n        }\n        if(isIntersectSS(p,s1)) return 1;\n        if(isIntersectSS(p,s2)) return 1;\n        if(isIntersectSS(p,s3)) return 1;\n        if(isIntersectSS(p,s4)) return 1;\n    }\n    return 0;\n}\n\nint main(){\n    int N;\n    while(cin >> N,N){\n        Segment seg;\n        cin >> seg.s >> seg.t;\n        vector<Block> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].a >> v[i].b >> v[i].h;\n        }\n        if(check(seg,v)){\n            cout << 0 << endl;\n            continue;\n        }\n        double l = 0,r = 1001;\n        for(int i = 0 ; i < 100 ; i++){\n            double mid = (l + r) / 2;\n            if(c(mid,seg,v)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n        printf(\"%.10f\\n\",l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <complex>\nusing namespace std;\n#ifdef DEBUGRUN\n#define log(a) (cerr<<#a\"=\"<<a<<endl)\n#else\n#define log(a) ((void)0)\n#endif\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\ntypedef long long Int;\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\ndouble sq(double a) { return a*a; }\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\nint ccw(const P& a, P b, P c) {\n    b -= a, c -= a;\n    if(cross(b, c)>0) return 1;\n    if(cross(b, c)<0) return -1;\n    if(dot(b, c)<0) return 2;\n    if(norm(b)<norm(c)) return -2;\n    return 0;\n}\nbool crossing(const P& l0, const P& l1, const P& m0, const P& m1) {\n    return ccw(m0, m1, l0)*ccw(m0, m1, l1)<=0\n        && ccw(l0, l1, m0)*ccw(l0, l1, m1)<=0;\n}\nP projection(const P& l0, const P& l1, const P& p) {\n    double t = dot(p-l0, l0-l1) / norm(l0-l1);\n    return l0 + t*(l0-l1);\n}\ndouble distanceSP(const P& s0, const P& s1, const P& p) {\n    const P r(projection(s0, s1, p));\n    if(ccw(s0, s1, r)==0) return abs(r-p);\n    return min(abs(s0-p), abs(s1-p));\n}\ndouble distanceSS(const P& s0, const P& s1, const P& t0, const P& t1) {\n    if(crossing(s0, s1, t0, t1)) return 0;\n    return min(min(distanceSP(s0, s1, t0), distanceSP(s0, s1, t1)),\n               min(distanceSP(t0, t1, s0), distanceSP(t0, t1, s1)));\n}\n\nint n, sx, sy, ex, ey;\nint xa[100], ya[100], xb[100], yb[100], h[100];\nP sp, ep, ps[100][4];\n\nbool check() {\n    rep(i, n) {\n        rep(j, 4) {\n            if(crossing(sp, ep, ps[i][j], ps[i][(j+1)%4])) return false;\n        }\n        if(crossing(sp, ep, ps[i][0], ps[i][2])) return false;\n        if(crossing(sp, ep, ps[i][1], ps[i][3])) return false;\n        if(xa[i]<=sx && sx<=xb[i] && ya[i]<=sy && sy<=yb[i]) return false;\n        if(xa[i]<=ex && ex<=xb[i] && ya[i]<=ey && ey<=yb[i]) return false;\n    }\n    return true;\n}\n\nbool can(double r) {\n    rep(i, n) {\n        const double lim = h[i]>=r ? r : sqrt(sq(r)-sq(r-h[i]));\n        rep(j, 4) {\n            if(distanceSS(sp, ep, ps[i][j], ps[i][(j+1)%4])<lim) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d\", &n);\n        if(n==0) return 0;\n        scanf(\"%d%d%d%d\", &sx, &sy, &ex, &ey);\n        rep(i, n) scanf(\"%d%d%d%d%d\", xa+i, ya+i, xb+i, yb+i, h+i);\n        sp = P(sx, sy);\n        ep = P(ex, ey);\n        rep(i, n) {\n            ps[i][0] = P(xa[i], ya[i]);\n            ps[i][1] = P(xa[i], yb[i]);\n            ps[i][2] = P(xb[i], yb[i]);\n            ps[i][3] = P(xb[i], ya[i]);\n        }\n        double ans = 0;\n        if(check()) {\n            log(true);\n            double l=0, r=2000;\n            rep(_, 100) {\n                const double mid=(l+r)/2;\n                if(can(mid)) l=mid;\n                else r=mid;\n            }\n            ans = l;\n        }\n        printf(\"%.9f\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosθ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinθ\n    }\n};\n\ndouble segmentPointDist(const Point& a1, const Point& a2, const Point& p)\n{\n    if((a2-a1).dot(p-a1) < 0)\n        return a1.dist(p);\n    else if((a1-a2).dot(p-a2) < 0)\n        return a2.dist(p);\n    else\n        return abs((a2-a1).cross(p-a1)) / a1.dist(a2);\n}\n\ndouble segmentsDist(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) < -EPS) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) < -EPS))\n        return 0.0;\n\n    double ret = segmentPointDist(a1, a2, b1);\n    ret = min(ret, segmentPointDist(a1, a2, b2));\n    ret = min(ret, segmentPointDist(b1, b2, a1));\n    ret = min(ret, segmentPointDist(b1, b2, a2));\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        Point s, e;\n        cin >> s.x >> s.y >> e.x >> e.y;\n\n        vector<vector<Point> > p(n, vector<Point>(4));\n        vector<double> h(n);\n        double ret = DBL_MAX;\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<2; ++j)\n                cin >> p[i][j*2].x >> p[i][j*2].y;\n            cin >> h[i];\n\n            p[i][1] = Point(p[i][0].y, p[i][2].x);\n            p[i][3] = Point(p[i][2].y, p[i][0].x);\n\n            if(p[i][0].x <= s.x && s.x <= p[i][2].x && p[i][0].y <= s.y && s.y <= p[i][2].y)\n                ret = 0.0;\n        }\n\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<4; ++j){\n                double d = segmentsDist(s, e, p[i][j], p[i][(j+1)%4]);\n                if(d < EPS){\n                    ret = 0.0;\n                }else{\n                    double r = (pow(h[i], 2) + pow(d, 2)) / (2 * h[i]);\n                    ret = min(ret, r);\n                }\n            }\n        }\n\n        printf(\"%.10f\\n\", ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(const Point &p0,const Point &p1,const Point &p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nPoint projection(const Segment &s,const Point &p){\n    Vector b = s.t-s.s;\n    double t = dot(p-s.s,b)/norm(b);\n    return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n    return (ccw(s.s,s.t,p) == 0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n            ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n    Point r = projection(s,p);\n    if(isIntersectSP(s,r)) return abs(r-p);\n    return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment &a,const Segment &b){\n    if(isIntersectSS(a,b)) return 0;\n    return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n           min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nstruct Block{\n    Point a,b;\n    double h;\n    Block(){}\n    Block(Point &a,Point &b,double h) :\n        a(a),b(b),h(h) {}\n};\n\nistream &operator >> (istream &is,Point &p){ \n    return is >> p.x >> p.y;\n}\n\ndouble calc(double a,double b){\n    return sqrt(a*a+b*b);\n}\n\nbool c(double r,Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point c(v[i].a.x,v[i].b.y),d(v[i].b.x,v[i].a.y);\n        Segment s1(v[i].a,c),s2(v[i].a,d),s3(c,v[i].b),s4(d,v[i].b);\n        double dst[] = {\n            distanceSS(p,s1),\n            distanceSS(p,s2),\n            distanceSS(p,s3),\n            distanceSS(p,s4)\n        };\n \n        if(lt(r,v[i].h)){\n            if(!(lt(r,dst[0]) &&\n                 lt(r,dst[1]) &&\n                 lt(r,dst[2]) &&\n                 lt(r,dst[3]))){\n                return false;\n            }\n        }else{\n            double nh = r - v[i].h;\n            if(!(lt(r,calc(nh,dst[0])) &&\n                 lt(r,calc(nh,dst[1])) &&\n                 lt(r,calc(nh,dst[2])) &&\n                 lt(r,calc(nh,dst[3])))){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool check(Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point c(v[i].a.x,v[i].b.y);\n        Point d(v[i].b.x,v[i].a.y);\n        Segment s1(v[i].a,c),s2(v[i].a,d),s3(c,v[i].b),s4(d,v[i].b);\n        if((v[i].a.x <= p.s.x && p.s.x <= v[i].b.x &&\n            v[i].a.y <= p.s.y && p.s.y <= v[i].b.y) ||\n           (v[i].a.x <= p.t.x && p.t.x <= v[i].b.x &&\n            v[i].a.y <= p.t.y && p.t.y <= v[i].b.y)){\n            return true;\n        }\n        if(isIntersectSS(p,s1)) return true;\n        if(isIntersectSS(p,s2)) return true;\n        if(isIntersectSS(p,s3)) return true;\n        if(isIntersectSS(p,s4)) return true;\n    }\n    return false;\n}\n\nint main(){\n    int N;\n    while(cin >> N,N){\n        Point s,e;\n        Segment seg;\n        cin >> seg.s >> seg.t;\n        vector<Block> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].a >> v[i].b >> v[i].h;\n        }\n        if(check(seg,v)){\n            cout << 0 << endl;\n            continue;\n        }\n        double l = 0,r = 1001;\n        for(int i = 0 ; i < 100 ; i++){\n            double mid = (l + r) / 2;\n            if(c(mid,seg,v)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n        printf(\"%.8f\\n\",r);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS 1e-10\n#define EQ(a,b) (abs(a - b) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n//??????\ndouble cross (P a, P b) {return (a.real() * b.imag() - a.imag() * b.real());}\n\n//??????\ndouble dot (P a, P b) {return (a.real() * b.real() + a.imag() * b.imag());}\n\n//??´???\nbool is_orthogonal(P a1, P a2, P b1, P b2) {return EQ( dot(a1 - a2, b1 - b2), 0.0);}\n\n//??????\nbool is_parallel(P a1, P a2, P b1, P b2) {return EQ( cross(a1 - a2, b1 - b2), 0.0);}\n\n//??´??????\nbool is_point_on_vector(P a, P b, P c) {return EQ( cross(a - c, c - b), 0.0);}\n\n//?????????\nbool is_point_on_line (P a, P b, P c) {return (abs(a - c) + abs(c - b) < abs(a - b) + EPS);}\n\n//?§?????????????????????¢????°???°?????\\??????????????§\ndouble angle (P a, P b, P p) {return (acos(dot(a-p,b-p) / (abs(a-p) * abs(b-p))) * 180.0 / M_PI);}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < -EPS );\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool is_intersected_l(P a1, P a2, P b1, P b2) {return !EQ( cross(a1-a2, b1-b2), 0.0 );}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distance_l_p(P a, P b, P c) {return abs(cross(b-a, c-a)) / abs(b-a);}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2 - a1; P b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(P a, P b, P c) {\n    if ( dot(b-a, c-a) < EPS ) return fabs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return fabs(c-b);\n    return fabs(cross(b-a, c-a)) / fabs(b-a);\n}\n\n/***************************************\n *\n * 2??????????????´?????¨??????????????????????????¨?????????\n *\n * a, b ?????´???\n * p    ????????????\n *\n ***************************************/\nP crossNormalVector (P a, P b, P p) {\n    double t = dot(b-a, p-a) / (abs(b-a) * abs(b - a));\n    return a + t * (b - a);\n}\n\ndouble calc (double h, double r) {\n    if (h > r) h = r;\n    return (r * r + h * h) / (2 * h);\n}\n\nint main ()\n{\n    int n;\n    while (cin >> n, n) {\n        double sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        P s(sx, sy), e(ex, ey);\n\n        double res_h = 1000.;\n        while (n--) {\n            // cout << \"Count # \" << n << endl;\n\n            double minx, miny, maxx, maxy;\n            double h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n\n            vector<P> v = { P(minx, miny), P(minx, maxy), P(maxx, maxy), P(maxx, miny)};\n\n            if (minx <= s.real() && s.real() <= maxx && miny <= s.imag() && s.imag() <= maxy) res_h = 0.;\n            if (minx <= e.real() && e.real() <= maxx && miny <= e.imag() && e.imag() <= maxy) res_h = 0.;\n\n            for (int i = 0; i < 4; i++) {\n                int anf = (i + 1) % 4; // , bfr = (i + 4 - 1) % 4;\n                int now = i;\n\n                if (is_intersected_ls(e, s, v[now], v[anf])) res_h = 0.;\n                // if (is_intersected_ls(e, s, v[now], v[bfr])) res_h = 0.;\n\n                // cout << \"DBG > \" << min(v[now].real(), v[anf].real()) << \" \" << max(v[now].real(), v[anf].real()) << endl;\n                // cout << \"      \" << min(v[now].imag(), v[anf].imag()) << \" \" << max(v[now].imag(), v[anf].imag()) << endl;\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[anf], s)));\n                // res_h = min(res_h, calc(h, distance_ls_p(v[now], v[bfr], s)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[anf], e)));\n                // res_h = min(res_h, calc(h, distance_ls_p(v[now], v[bfr], e)));\n                // res_h = min(res_h, calc(h, min(abs(minx - s.real()), abs(maxx - s.real()))));\n                // res_h = min(res_h, calc(h, min(abs(miny - s.imag()), abs(maxy - s.imag()))));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[now])));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[anf])));\n                // res_h = min(res_h, calc(h, distance_ls_p(s, e, v[bfr])));\n            }\n        }\n\n        printf(\"%.4f\\n\", res_h);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define all(X) X.begin(),X.end()\n//#define X first\n//#define Y second\n#define eb emplace_back\n#define pb push_back\n\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<vector<pii>> Graph;\n\nconst double INF=1e10;\nconst double EPS=1e-8;\ninline int sign(double x){ return abs(x) < EPS ? 0 : (x>0 ? 1 : -1 ); }\n\nstruct Point3D{\n\tdouble x, y, z;\n\tPoint3D(): x(0), y(0), z(0) {}\n\tPoint3D(double x, double y, double z): x(x), y(y), z(z) {}\n\tPoint3D operator-() const { return Point3D(-x, -y, -z); }\n\tPoint3D operator+(const Point3D &p) const {\n\t\treturn Point3D(x+p.x, y+p.y, z+p.z);\n\t}\n\tPoint3D operator-(const Point3D &p) const {\n\t\treturn Point3D(x-p.x, y-p.y, z-p.z);\n\t}\n\tPoint3D operator*(const double s) const {\n\t\treturn Point3D( x*s, y*s, z*s );\n\t}\n\tPoint3D operator/(const double s) const {\n\t\treturn Point3D( x/s, y/s, z/s );\n\t}\n};\n\nstruct Line3D {\n\tPoint3D a, b;\n\tLine3D(): a(), b() {}\n\tLine3D(const Point3D &a, const Point3D &b): a(a), b(b) {}\n};\n\ninline double dot(const Point3D &a, const Point3D &b){\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n}\ninline Point3D cross(const Point3D &a, const Point3D &b){\n\treturn Point3D(\n\t\ta.y * b.z - a.z * b.y,\n\t\ta.z * b.x - a.x * b.z,\n\t\ta.x * b.y - a.y * b.x\n\t);\n}\ninline double norm(const Point3D &p){ return dot(p, p); } \ninline double abs(const Point3D &p){ return sqrt(norm(p)); }\ninline Point3D vec(const Line3D &l){ return l.b - l.a; }\n\ninline Point3D projection(const Line3D &l, const Point3D &p){\n\tconst Point3D v = vec(l);\n\treturn l.a + v * (dot(p-l.a, v) / norm(v));\n}\n\ninline bool intersectSP(const Line3D &l, const Point3D &p){\n\tconst Point3D a = p -l.a, b = vec(l);\n\tif(norm(a) < EPS || norm(a - b) < EPS){ return true; }\n\tif(norm(cross(a, b)) > EPS){ return false; }\n\tif(sign(a.x * b.x) < 0){ return false; }\n\tif(sign(a.y * b.y) < 0){ return false; }\n\tif(sign(a.z * b.z) < 0){ return false; }\n\treturn norm(a) < norm(b);\n}\n\ninline double distanceLP(const Line3D &l, const Point3D &p){\n\tconst Point3D q = projection(l,p);\n\treturn abs(p - q);\n}\ninline double distanceSP(const Line3D &l, const Point3D &p){\n\tconst Point3D u = p -l.a;\n\tconst Point3D v = projection(Line3D(Point3D(), vec(l)), u);\n\tif(intersectSP(Line3D(Point3D(), vec(l)), v) ){ return abs(u-v); }\n\treturn sqrt(min(norm(p - l.a), norm(p - l.b)));\n}\n\nnamespace geom {\n\t#define X real()\n\t#define Y imag()\n\t#define at(i) ((*this)[i])\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef long double R;\n\ttypedef complex<R> P;\n\tconst R INF = 1e8;\n\tinline int sig(const R &x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\n\tinline R norm(const P &p) {return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P &a, const P &b) {return (conj(a)*b).X;}\n\tinline R outp(const P &a, const P &b) {return (conj(a)*b).Y;}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv = 0) {\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\n\t\treturn 0;\n\t}\n\tstruct L : public vector<P>{\n\t\tL(const P &p1, const P &p2) {\n\t\t\tthis->pb(p1); this->pb(p2);\n\t\t}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tint online(const P &p) const {return !sig(outp(p-at(0), dir()));}\n\t};\n\tstruct S : public L{\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tint online(const P &p) const {\n\t\t\tif(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n\t\t\treturn !sig(outp(p-at(0), dir())) && inp(p-at(0), dir()) > EPS && inp(p-at(1), -dir()) > EPS;\n\t\t}\n\t};\n\n\tint intersect(const S &s, const S &t) {\n\t\tconst int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\n\t\tconst int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\n\t\treturn (p>0 || q>0) ? FALSE : (!p || !q) ? BORDER : TRUE;\n\t}\n};\nusing namespace geom;\n\nPoint3D pS, pG;\nvector<Point3D> v;\nvector<Line3D> e;\n\nbool solve(double d){\n\tbool res = true;\n\tLine3D L( pS+Point3D(0.0, 0.0, d), pG+Point3D(0.,0., d) );\n\tfor(auto t: v){\n\t\tt.z = min( t.z, d );\n\t\tif( distanceSP( L, t ) - d < EPS ){\n\t\t\tres = false;\n\t\t}\n\t}\n\tfor(auto t: e){\n\t\tt.b.z = t.a.z = min( t.a.z, d );\n\t\tif( distanceSP( t, pS+Point3D(0.0, 0.0, d) ) - d < EPS ){\n\t\t\tres = false;\n\t\t}\n\t\tif( distanceSP( t, pG+Point3D(0.0, 0.0, d) ) - d < EPS ){\n\t\t\tres = false;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint N;\n\twhile(cin>>N, N){\n\t\tv.clear();\n\t\te.clear();\n\t\t\t\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpS = Point3D(x, y, 0.0);\n\t\tcin >> x >> y;\n\t\tpG = Point3D(x, y, 0.0);\n\n\t\tbool zero = false;\n\t\trep(i,N){\n\t\t\tdouble x1, y1, x2, y2, h;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> h;\n\n\t\t\tif( pS.x >= x1 && pS.y >= y1 && pS.x <= x2 && pS.y <= y2 &&\n\t\t\t\tpG.x >= x1 && pG.y >= y1 && pG.x <= x2 && pG.y <= y2 ){\n\t\t\t\tzero = true;\n\t\t\t}\n\n\t\t\tS s[4] = {\n\t\t\t\tS( P(x1,y1), P(x1,y2) ),\n\t\t\t\tS( P(x2,y1), P(x2,y2) ),\n\t\t\t\tS( P(x1,y1), P(x2,y1) ),\n\t\t\t\tS( P(x1,y2), P(x2,y2) )\n\t\t\t};\n\t\t\trep(i,4){\n\t\t\t\tif( intersect( s[i], S(P(pS.x,pS.y), P(pG.x,pG.y)) ) ){\n\t\t\t\t\tzero = true;\n\t\t\t\t}\n\t\t\t\te.eb( \tPoint3D(s[i][0].X, s[i][0].Y, h),\n\t\t\t\t\t\tPoint3D(s[i][1].X, s[i][1].Y, h) );\n\t\t\t}\n\n\t\t\t//v.eb( x1, y1, 0 );\n\t\t\t//v.eb( x1, y2, 0 );\n\t\t\t//v.eb( x2, y1, 0 );\n\t\t\t//v.eb( x2, y2, 0 );\n\t\t\tv.eb( x1, y1, h );\n\t\t\tv.eb( x1, y2, h );\n\t\t\tv.eb( x2, y1, h );\n\t\t\tv.eb( x2, y2, h );\n\t\t}\n\n\t\tif( zero ){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdouble l=0.0, r=1000.0;\n\t\trep(i,100){\n\t\t\tdouble m = (l+r) / 2.0;\n\t\t\tif( solve(m) ){\n\t\t\t\tl = m;\n\t\t\t}else{\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\", l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <limits.h>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define REPD(i,n) for(int i=(int)(n); i-->0;)\n#define REPI(i,a,b) for(int i=(int)(a); i<=(int)(b); i++)\n#define ALL(a) (a).begin(),(a).end()\n#define mp make_pair\n#define fst first\n#define snd second\n\n#define INFTY 1000000000\n#define EPS 1e-9\n#define PI 3.141592653589793\n\n#define INF (INFTY/3)\n\n#define rev(s) (string((s).rbegin(), (s).rend()))\n\ntypedef long long Int;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<double,double> pdd;\n\nvoid debug(vi v){ REP(i,v.size()) cout<<v[i]<<\" \"; cout<<endl; }\n\nint nextInt(){ int t; cin>>t; return t; }\n\n#define ZEROP(x) (fabs(x) < EPS)\n#define EQ(x, y) ZEROP((x) - (y))\n#define LT(x, y) ((x) - (y) <= -EPS) // x < y\n#define LE(x, y) ((x) - (y) < +EPS) // x <= y\n#define SIGN(x) ((x)<-EPS?-1:((x)>EPS?+1:0))\n\ntypedef complex<double> P;\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nnamespace std {\n   bool operator < (const P& a, const P& b) {\n     return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n   }\n}\ndouble cross(const P& a, const P& b) {\n   return imag(conj(a)*b);\n} \ndouble dot(const P& a, const P& b) {\n   return real(conj(a)*b); \n}  \nstruct L : public vector<P> {\n  L() {}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  } \n};  \ntypedef vector<P> G;  \nstruct C {\n   P p; double r;\n   C(const P &p, double r) : p(p), r(r) { }\n}; \n\n\n#define MAXN 50\nint N;\nL sl; // start line\nint minx[MAXN];\nint miny[MAXN];\nint maxx[MAXN];\nint maxy[MAXN];\nint h[MAXN];\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (LT( 0, cross(b, c)) )   return +1;       // counter clockwise\n  if (LT( cross(b, c), 0) )   return -1;       // clockwise\n  if (LT( dot(b, c), 0) )     return +2;       // c--a--b on line\n  if (LT( norm(b), norm(c)) ) return -2;       // a--b--c on line\n  return 0;\n}\n\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n// USE IN THIS PROBLEM\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nbool covered(int sx,int sy,int ex,int ey,int ax,int ay,int bx,int by) {\n  return ax < sx && ay < sy && ex < bx && ey < by;\n}\n\n\ndouble solve() {\n  double r = INT_MAX;\n  REP(i,N) {\n    L l[]={L(P(minx[i],miny[i]),P(maxx[i],miny[i])),\n\t   L(P(maxx[i],miny[i]),P(maxx[i],maxy[i])),\n\t   L(P(maxx[i],maxy[i]),P(minx[i],maxy[i])),\n\t   L(P(minx[i],maxy[i]),P(minx[i],miny[i]))};\n    double mind = INT_MAX;\n    int mini; //min index\n    if(covered(real(sl[0]),imag(sl[0]),real(sl[1]),imag(sl[1]),\n\t       minx[i],miny[i],maxx[i],maxy[i])) return 0.0;\n    REP(j,4) {\n      double dd = distanceSS(l[j],sl);\n      if(LT(dd,mind)) {\n\tmind = dd;\n\tmini = j;\n      }\n    }\n    double r2;\n    //printf(\"mind=%lf\\n\",mind);\n    if(LE(mind,h[i])) { // mind <= h[i]\n      r2=mind;\n    } else {\n      r2=(h[i]*h[i] + mind*mind) / (2*h[i]);\n    }\n    r=min(r,r2);\n    //printf(\"r=%lf\\n\",r);\n  }\n  return r;\n}\n\t\nmain() {\n  while(cin>>N,N) {\n    int sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    sl = L(P(sx,sy),P(ex,ey));\n    REP(i,N)\n      cin>>minx[i]>>miny[i]>>maxx[i]>>maxy[i]>>h[i];\n    printf(\"%.7lf\\n\",solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<long double> xy;\nlong eps = 1e-9;\nlong double dot_product(xy a,xy b) {return (conj(a)*b).real();}\nlong double cross_product(xy a,xy b) {return (conj(a)*b).imag();}\nlong double dist_lp(xy a1,xy a2,xy p){\n    if(dot_product(a2-a1,p-a1)<eps) return abs(p-a1);\n    if(dot_product(a1-a2,p-a2)<eps) return abs(p-a2);\n    return abs(cross_product(a2-a1,p-a1))/abs(a2-a1);\n}\n\nbool is_online(xy a1,xy a2,xy p){\n    return abs(a1-p)+abs(a2-p)<=abs(a1-a2)+eps;    \n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    if(is_online(a1,a2,b1) || is_online(a1,a2,b2)) return true;\n    if(is_online(b1,b2,a1) || is_online(b1,b2,a2)) return true;\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<-eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<-eps;\n}\n\nlong double dist_ll(xy a1,xy a2,xy b1,xy b2){\n    if(is_intersected(a1,a2,b1,b2)) return 0;\n    return min({dist_lp(a1,a2,b1),dist_lp(a1,a2,b2),dist_lp(b1,b2,a1),dist_lp(b1,b2,a2)\n    ,abs(a1-b1),abs(a1-b2),abs(a2-b1),abs(a2-b2)});   \n}\n\nint N;\nlong double sx,sy,gx,gy,mi_x,mi_y,ma_x,ma_y;\nlong double h;\n\n\nint main(){\n    while(cin>>N && N>0){\n        long double ans = 1e9;\n        cin >> sx >> sy >> gx >> gy;\n        xy s = xy(sx,sy),g = xy(gx,gy);\n        for(int i=1;i<=N;i++){\n            cin >> mi_x >> mi_y >> ma_x >> ma_y >> h;\n            if((mi_x<=sx && sx<=ma_x && mi_y<=sy && sy<=ma_y || \n            mi_x<=gx && gx<=ma_x && mi_y<=gy && gy<=ma_y)) ans = 0;\n            long double d = min({dist_ll(s,g,xy(mi_x,mi_y),xy(mi_x,ma_y)),\n            dist_ll(s,g,xy(mi_x,ma_y),xy(ma_x,ma_y)),\n            dist_ll(s,g,xy(ma_x,ma_y),xy(ma_x,mi_y)),\n            dist_ll(s,g,xy(ma_x,mi_y),xy(mi_x,mi_y))});\n            if(d<=h) ans = min(ans,d);\n            else ans = min(ans,(h*h+d*d)/(2.0*h));\n        }\n        cout << fixed;\n        cout << setprecision(10) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std;\n\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\n// 誤差を加味した符号判定\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\n\n// 比較演算子\nnamespace std{\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\n// 内積・外積\ndouble dot(P a, P b){\n    return real(conj(a) * b);\n}\ndouble cross(P a, P b){\n    return imag(conj(a) * b);\n}\n\n// OAとOBのなす符号付き角度 [-pi, pi]\n// example : (1, 0), (0, 1) -> pi/2\ndouble angle(P a, P b){\n    return arg(conj(a) * b);\n}\n\n// aをc中心にb[rad]回転\n// verify : not yet.\nP rotate(P a, double b, P c = P()){\n    return (a - c) * polar(1.0, b) + c;\n}\n\n// 直線ABに対する点Cの位置\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > +EPS)   return +1; // 反時計回り\n    if (cross(b, c) < -EPS)   return -1; // 時計回り\n    if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n    if (norm(b) < norm(c)) return -2; // a--b--c の順番で一直線上\n    return 0;                         // 点が線分ab上にある\n}\n\nenum{ OUT, ON, IN };\nstruct L : public vector<P> {\n    L(){}\n    L(const P& a, const P& b) {\n        push_back(a); push_back(b);\n    }\n    P vector() const {\n        return back() - front();\n    }\n};\n\n// 注意: 端点で交わったり直線が重なったりする場合も交差していると判定する\n\n// 二直線の平行判定\n// verify : aoj0021\nbool paralell(L l, L m){\n    return sign(cross(l.vector(), m.vector())) == 0;\n}\n\n// 二直線の同一判定\nbool equalLL(L l, L m){\n    return sign(cross(l.vector(), m[0] - l[0])) == 0;\n}\n\n// 直線と点の交差判定\nbool iLP(L l, P p) {\n    // 直線lとl[0]からpへの直線が平行\n    return sign(cross(l.vector(), p - l[0])) == 0;\n}\n\n// 線分と点の交差判定(端点の処理に注意)\n// verify : aoj1279\nbool iSP(L s, P p) {\n    return ccw(s[0], s[1], p) == 0;\n}\n\n// 直線と線分の交差判定(線分が重なっている時に注意)\nbool iLS(L l, L s) {\n    // 直線lについて、線分sの端点が異なる側にある\n    return sign(cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0])) <= 0;\n}\n\n// 二つの線分の交差判定(線分が重なっている時や端点の処理に注意)\nbool iSS(L s, L t) {\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n        ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\n\n// 点pから直線lに対する射影\nP proj(L l, P p){\n    double t = dot(p - l[0], l.vector()) / norm(l.vector());\n    return l[0] + t * l.vector();\n}\n\n// 点pの直線lに関する反射\nP refl(L l, P p){\n    return 2.0 * proj(l, p) - p;\n}\n\n// 直線と点の距離\ndouble dLP(L l, P p){\n    // return abs(p - projection(l, p));\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\n\n// 線分と点の距離 ( not verified !!! )\ndouble dSP(L s, P p){\n    if(sign(dot(s.vector(), p - s[0])) <= 0) return abs(p - s[0]);\n    if(sign(dot(-s.vector(), p - s[1])) <= 0) return abs(p - s[1]);\n    return dLP(s, p);\n}\n\n// 直線と直線の距離\ndouble dLL(L l, L m){\n    // 平行でないときは0, 平行のときは垂線の長さ\n    return paralell(l, m) ? dLP(l, m[0]) : 0;\n}\n\n// 直線と線分の距離\ndouble dLS(L l, L s){\n    if(iLS(l, s)) return 0;\n    return min(dLP(l, s[0]), dLP(l, s[1]));\n}\n\n// 線分と線分の距離\ndouble dSS(L s, L t){\n    if(iSS(s, t)) return 0;\n    return min({dSP(s, t[0]), dSP(s, t[1]), dSP(t, s[0]), dSP(t, s[1])});\n}\n\n// 直線と直線の交点\nP pLL(L l, L m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n    if(sign(A) == 0) assert(false); // 直線が交わらない\n    return m[0] + m.vector() * B / A;\n}\n\ntypedef vector<P> Polygon; // 反時計回りを仮定\n\n// Polygonの要素へのアクセス\nP curr(const Polygon& a, int x){ return a[x]; }\nP next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nP prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n// 点が多角形のどこにあるのか判定する\n// verify : aoj0012\nint contains(const Polygon& A, const P& p){\n    // 点pから半直線をひき、辺と交差する回数を数える\n    bool in = false;\n    for(int i = 0; i < A.size(); i++){\n        P a = curr(A, i) - p;\n        P b = next(A, i) - p;\n        if(a.imag() > b.imag()) swap(a, b);\n        // aからbの直線がy=0と交わり、その交点は原点の右側である\n        if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0){ \n            in = !in;\n        }\n        if(sign(cross(a, b)) == 0 && sign(dot(a, b)) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\n// 多角形の面積\n// verify : aoj0079 aoj1100\ndouble area(const Polygon& A) {\n    double res = 0;\n    for(int i = 0; i < A.size(); i++){\n        res += cross(curr(A, i), next(A, i));\n    }\n    return abs(res) / 2.0;\n}\n\n// 凸包\nPolygon convex_hull(vector<P> ps) {\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<P> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){ // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){ // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\nbool is_convex(const Polygon& A){\n    for(int i = 0; i < A.size(); i++){\n        if(ccw(prev(A, i), curr(A, i), next(A, i)) > 0) return false;\n    }\n    return true;\n}\n\n// 凸多角形の直線による切断。直線の左側だけ残す\n// verify : aoj1283\nPolygon convex_cut(const Polygon& A, L l){\n    Polygon B;\n    for(int i = 0; i < A.size(); i++){\n        P a = curr(A, i), b = next(A, i);\n        if(ccw(l[0], l[1], a) != -1) B.push_back(a); //Aが直線lの右側でない\n        if(ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0)\n            B.push_back(pLL(l, L(a, b)));\n    }\n    return B;\n}\n// 垂直二等分線\n// verify: maximamcup2013 D\nL bisector(P a, P b){\n    P mid = (a + b) / 2.0;\n    P vec = (mid - a) * P(0.0, 1.0);\n    return L(mid, mid + vec);\n}\n// 点集合psのうちs番目のボロノイ領域\n// verify: maximamcup2013 D\nPolygon voronoi_cell(Polygon A, const vector<P>& ps, int s){\n    for(int i = 0; i < ps.size(); i++){\n        if(i != s) A = convex_cut(A, bisector(ps[s], ps[i]));\n    }\n    return A;\n}\nstruct Circle {\n    P p;\n    double r;\n    Circle() {}\n    Circle(P p, double r) : p(p), r(r) { }\n};\n\n// 円と点の内外判定\nint contains(const Circle& C, const P& p){\n    double d = abs(C.p - p);\n    if(sign(d - C.r) > 0) return OUT;\n    if(sign(d - C.r) == 0) return ON;\n    return IN;\n}\n\n// 円と線分の交差判定(境界を含む)\n// Verified: AOJ 0129\nbool iCS(const Circle& C, const L& l){\n    int c1 = contains(C, l[0]);\n    int c2 = contains(C, l[1]);\n    if(c1 > c2) swap(c1, c2);\n\n    // (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) の6通り\n    if(c1 == OUT && c2 == IN) return true;\n    if(c1 == IN  && c2 == IN) return false;\n    if(c1 == ON) return true; // (接するとき) \n    double d = dSP(l, C.p);\n    if(sign(d - C.r) < 0) return true;\n    if(sign(d - C.r) == 0) return true; // (接するとき)\n    if(sign(d - C.r) > 0) return false;\n}\n\n// 二つの円の交差判定(接する時を含む)\nbool iCC(const Circle& C, const Circle& D){\n    // 円の中心同士の距離が、半径の和以下であり、半径の差以上である\n    double e = abs(C.p - D.p);\n    return sign(e - (C.r + D.r)) <= 0 && sign(e - abs(C.r - D.r)) >= 0;\n}\n\n// 円と直線の交点\n// verify : aoj2045\nvector<P> pLC(const L &l, const Circle &c) {\n    vector<P> res;\n    P center = proj(l, c.p);\n    double d = abs(center - c.p);\n    double tt = c.r * c.r - d * d;\n    if(tt < 0 && tt > -EPS) tt = 0;\n    if(tt < 0) return res;\n    double t = sqrt(tt);\n    P vect = l.vector();\n    vect /= abs(vect);\n    res.push_back(center - vect * t);\n    if (t > EPS) {\n        res.push_back(center + vect * t);\n    }\n    return res;\n}\n\n// 円と線分の交点\nvector<P> pSC(const L &s, const Circle &c) {\n    vector<P> ret;\n    vector<P> nret = pLC(s, c);\n    for (int i = 0; i < nret.size(); i++) {\n        if (iSP(s, nret[i])) ret.push_back(nret[i]);\n    }\n    return ret;\n}\n\n// 円と円の交点\n// verify : aoj1183\nvector<P> pCC(Circle a, Circle b){\n    vector<P> res;\n\n    double l = abs(b.p - a.p);\n\n    if(sign(l) == 0 && sign(a.r - b.r) == 0) assert(false); // 解が無限に存在する\n    if(sign(l - abs(a.r - b.r)) < 0 || sign(l - (a.r + b.r)) > 0) return res; // 解が存在しない\n\n    double th1 = arg(b.p - a.p);\n    if(sign(l - abs(a.r - b.r)) == 0 || sign(l - (a.r + b.r)) == 0){\n        res.push_back(a.p + polar(a.r, th1));\n    }else {\n        double th2 = acos( (a.r * a.r - b.r * b.r + l * l) / (2 * a.r * l) );\n        res.push_back(a.p + polar(a.r, th1 - th2));\n        res.push_back(a.p + polar(a.r, th1 + th2));\n    }\n    return res;\n}\n\n// 2点を通る半径rの円の中心\n// verify : aoj1132\nvector<P> touching_circle2(P a, P b, double r){\n    vector<P> res;\n\n    double d = abs(b - a);\n    if(d > 2 * r) return res;\n\n    P mid = 0.5 * (a + b);\n    P dir = polar(sqrt(r * r - d * d / 4), arg(b - a) + M_PI / 2);\n    res.push_back(mid + dir);\n    res.push_back(mid - dir);\n    return res;\n}\n\n// 3点を通る円\nCircle touching_circle3(P a, P b, P c){\n    // ２つの垂直二等分線の交点が円の中心\n    P mid_ab = (a + b) / 2.0;\n    L bis_ab(mid_ab, (mid_ab - a) * P(0.0, 1.0));\n    P mid_bc = (b + c) / 2.0;\n    L bis_bc(mid_bc, (mid_bc - b) * P(0.0, 1.0));\n\n    assert(!paralell(bis_ab, bis_bc)); \n\n    P center = pLL(bis_ab, bis_bc);\n    return Circle(center, abs(a - center));\n}\n\n// 円と円の共通部分の面積を求める．\n// ref: nya3j\ndouble cc_area(const Circle& c1, const Circle& c2) {\n    double d = abs(c1.p - c2.p);\n    if (c1.r + c2.r < d + EPS) {\n        return 0.0;\n    } else if (d < abs(c1.r - c2.r) + EPS) {\n        double r = min(c1.r, c2.r); // 元は c1.r >? c2.r だった．\n        return r * r * M_PI;\n    } else {\n        double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n        double theta = acos(rc / c1.r);\n        double phi = acos((d - rc) / c2.r);\n        return c1.r*c1.r*theta + c2.r*c2.r*phi - d*c1.r*sin(theta);\n    }\n}\n// 円の接線 (中心から偏角thの点で接する接線)\n// verified: AOJ 2201 Immortal Jewels \nL circle_tangent(const Circle& C, double th){\n    P p0 = C.p + polar(C.r, th);\n    P p1 = p0 + polar(1.0, th + M_PI / 2);\n    return L(p0, p1);\n}\n\n// 二つの円の共通接線 (Cの中心から接点へのベクトルの偏角を返す)\n// verified: AOJ 2201 Immortal Jewels \n// 参考: http://geom.web.fc2.com/geometry/circle-circle-tangent.html\nvector<double> common_tangents(const Circle& C, const Circle& D){\n    vector<double> res;\n    P v = D.p - C.p;\n    double l = abs(v); // 二円の中心間の距離\n    double a = arg(v); // 二円の中心間の偏角\n    if(sign(l - abs(C.r - D.r)) > 0){\n        // 交わる or 外接 or 離れている\n        // 二つの外側接線\n        double a1 = acos((C.r - D.r) / l);\n        res.push_back(a + a1);\n        res.push_back(a - a1);\n        if(sign(l - (C.r + D.r)) > 0){\n            // 離れている\n            // 二つの内側接線\n            double a2 = acos((C.r + D.r) / l);\n            res.push_back(a + a2);\n            res.push_back(a - a2);\n        }\n    }\n    if((sign(l - abs(C.r - D.r)) == 0 || sign(l - (C.r + D.r)) == 0) && sign(l) != 0){\n        // 内接 or 外接\n        // 一つの接線\n        res.push_back(a);\n    }\n    return res;\n}\n\n// 1点を通る円の接線( pがCの外側にあることが前提条件 )\n// verified : AOJ 2579\nvector<L> tangents_through_point(const Circle& C, const P& p){\n    vector<L> tangents;\n    double d = abs(C.p - p);\n    // d ^ 2 == r ^ 2 + e ^ 2\n    double e = sqrt(d * d - C.r * C.r); // 点pと円の接点の距離\n    // d * sin(th) = r\n    double th = asin(C.r / d);\n    P q1 = p + (C.p - p) * polar(1.0, +th) * e / d;\n    P q2 = p + (C.p - p) * polar(1.0, -th) * e / d;\n    tangents.push_back(L(p, q1));\n    tangents.push_back(L(p, q2));\n    return tangents;\n}\nint main(){\n    int N;\n    while(cin>>N && N){\n        double sx, sy, gx, gy;\n        cin>>sx>>sy>>gx>>gy;\n        P sp(sx, sy);\n        P gp(gx, gy);\n        double ans = 1e8;\n        L route(sp, gp);\n        for(int i = 0; i < N; i++) {\n            double mx, my, nx, ny, h;\n            cin>>mx>>my>>nx>>ny>>h;\n            if(mx <= sx && sx <= nx && my <= sy && sy <= ny) ans = 0;\n            L ls[4];\n            ls[0] = {{mx,my},{nx,my}};\n            ls[1] = {P(mx,my),P(mx,ny)};\n            ls[2] = {P(mx,ny),P(nx,ny)};\n            ls[3] = {{nx, ny}, {nx, my}};\n            for(int j = 0; j < 4; j++) {\n                L l = ls[j];\n                double dist = dSS(route, l);\n                if(dist == 0) ans = 0;\n                double radian;\n                if(dist - EPS < h) radian = dist;\n                else radian = (h*h + dist*dist)/(2*h);\n                ans = min(ans, radian);\n            }\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(const Point &p0,const Point &p1,const Point &p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nPoint projection(const Segment &s,const Point &p){\n    Vector b = s.t-s.s;\n    double t = dot(p-s.s,b)/norm(b);\n    return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n    return (ccw(s.s,s.t,p) == 0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n            ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n    Point r = projection(s,p);\n    if(isIntersectSP(s,r)) return abs(r-p);\n    return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment &a,const Segment &b){\n    if(isIntersectSS(a,b)) return 0;\n    return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n           min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nstruct Block{\n    Point a,b;\n    double h;\n    Block(){}\n    Block(Point &a,Point &b,double h) :\n        a(a),b(b),h(h) {}\n};\n\nistream &operator >> (istream &is,Point &p){ \n    return is >> p.x >> p.y;\n}\n\ndouble calc(double a,double b){\n    return sqrt(a*a+b*b);\n}\n\nbool c(double r,Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point a = v[i].a,b = v[i].b;\n        Point c(a.x,b.y),d(b.x,a.y);\n        Segment s1(a,c),s2(a,d),s3(c,b),s4(d,b);\n        double dst[] = {\n            distanceSS(p,s1),distanceSS(p,s2),\n            distanceSS(p,s3),distanceSS(p,s4)\n        };\n \n        if(r < v[i].h){\n            if(!(r < dst[0] && r < dst[1] &&\n                 r < dst[2] && r < dst[3])){\n                return 0;\n            }\n        }else{\n            double nh = r - v[i].h;\n            if(!(r < calc(nh,dst[0]) && r < calc(nh,dst[1]) &&\n                 r < calc(nh,dst[2]) && r < calc(nh,dst[3]))){\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nbool check(Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point a = v[i].a,b = v[i].b;\n        Point c(a.x,b.y),d(b.x,a.y);\n        Segment s1(a,c),s2(a,d),s3(c,b),s4(d,b);\n        if((a.x < p.s.x && p.s.x < b.x &&\n            a.y < p.s.y && p.s.y < b.y) ||\n           (a.x < p.t.x && p.t.x < b.x &&\n            a.y < p.t.y && p.t.y < b.y)){\n            return 1;\n        }\n\t/*   if(isIntersectSS(p,s1)) return 1;\n        if(isIntersectSS(p,s2)) return 1;\n        if(isIntersectSS(p,s3)) return 1;\n        if(isIntersectSS(p,s4)) return 1;\n\t*/\n    }\n    return 0;\n}\n\nint main(){\n    int N;\n    while(cin >> N,N){\n        Segment seg;\n        cin >> seg.s >> seg.t;\n        vector<Block> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].a >> v[i].b >> v[i].h;\n        }\n        if(check(seg,v)){\n            cout << 0 << endl;\n            continue;\n        }\n        double l = 0,r = 1001;\n        for(int i = 0 ; i < 100 ; i++){\n            double mid = (l + r) / 2;\n            if(c(mid,seg,v)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n        printf(\"%.10f\\n\",l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-9;\ntemplate<typename T>\nT sqr(T a) { return a * a; }\n\nstruct search_point {\n\tdouble x, y;\n\tdouble h;\n\tsearch_point(double x_, double y_, double h_) {\n\t\tx = x_; y = y_; h = h_;\n\t}\n};\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tdouble sx, sy, ex, ey;\n\t\tvector<search_point> v;\n\t\tvector<search_point> on_l;\n\t\tvector<pair<search_point, search_point> > lect;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\ton_l.push_back(search_point(sx,sy,0));\n\t\ton_l.push_back(search_point(ex,ey,0));\n\t\tdouble R = 10000;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble h;\n\t\t\tcin >> x0 >> y0 >> x1 >> y1 >> h;\n\n\t\t\tlect.push_back(pair<search_point, search_point>(search_point(x0,y0,h), search_point(x1,y1,h)));\n\n\t\t\tif(h < EPS)\n\t\t\t\th = EPS;\n\n\t\t\tv.push_back(search_point(x0, y0, h));\n\t\t\tv.push_back(search_point(x1, y1, h));\n\t\t\tv.push_back(search_point(x0, y1, h));\n\t\t\tv.push_back(search_point(x1, y0, h));\n\n\t\t\tif(x0 < sx && sx < x1) {\n\t\t\t\tv.push_back(search_point(sx, y0, h));\n\t\t\t\tv.push_back(search_point(sx, y1, h));\n\t\t\t}\n\t\t\tif(y0 < sy && sy < y1) {\n\t\t\t\tv.push_back(search_point(x0, sy, h));\n\t\t\t\tv.push_back(search_point(x1, sy, h));\n\t\t\t}\n\t\t\tif(x0 < ex && ex < x1) {\n\t\t\t\tv.push_back(search_point(ex, y0, h));\n\t\t\t\tv.push_back(search_point(ex, y1, h));\n\t\t\t}\n\t\t\tif(y0 < ey && ey < y1) {\n\t\t\t\tv.push_back(search_point(x0, ey, h));\n\t\t\t\tv.push_back(search_point(x1, ey, h));\n\t\t\t}\n\t\t}\n\n\t\tdouble veclx = (ex - sx);\n\t\tdouble vecly = (ey - sy);\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tdouble d;\n\t\t\tdouble mx, my;\n\t\t\tdouble r;\n\n\t\t\tmx = (v[i].x * sqr(veclx) + v[i].y * veclx * vecly + vecly * (sx * ey - sy * ex)) / (sqr(veclx) + sqr(vecly));\n\t\t\tmy = (v[i].y * sqr(vecly) + v[i].x * vecly * veclx + veclx * (sy * ex - sx * ey)) / (sqr(vecly) + sqr(veclx));\n\t\t\t/*\n\t\t\tif((ey - sy) * mx - (ex - sx) * my + (ex * sy - sx * ey) > EPS) {\n\t\t\t\tcout << \"error\" << \" \" << (sy - ey) * mx - (sx - ex) * my - (ex * sy - sx * ey) << endl;\n\t\t\t\tcout << mx << \",\" << my << endl;\n\t\t\t}\n\t\t\t// */\n\t\t\td = sqrt(sqr(mx - v[i].x) + sqr(my - v[i].y));\n\t\t\tif(mx <= min(sx,ex) - EPS || max(sx,ex) + EPS <= mx || my <= min(sy,ey) - EPS || max(sy,ey) + EPS <= my) {\n\t\t\t\td = min(sqrt(sqr(sx - v[i].x) + sqr(sy -  v[i].y)), sqrt(sqr(ex - v[i].x) + sqr(ey - v[i].y)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\ton_l.push_back(search_point(mx, my, 0));\n\t\t\t}\n\t\t\tr = fabs(sqr(min(v[i].h,d)) + sqr(d)) / (2 * v[i].h);\n\t\t\tR = min(R, r);\n\t\t}\n\n\t\tfor(int i = 0; i < on_l.size(); i++) {\n\t\t\tfor(int j = 0; j < lect.size(); j++) {\n\t\t\t\tif((lect[j].first.x <= on_l[i].x && on_l[i].x <= lect[j].second.x)\n\t\t\t\t\t\t&& (lect[j].first.y <= on_l[i].y && on_l[i].y <= lect[j].second.y)) {\n\t\t\t\t\tR = 0;\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nfail:\n\t\tprintf(\"%.10f\\n\", R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = max(a, b);\n#define chmin(a, b) a = min(a, b);\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\n\n\nconst double EPS = 1e-10;\ntemplate<class T> bool eq(T a, T b){ return abs(a - b) < EPS; }\n\nclass Point { // ???\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0):x(x), y(y){}\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\tdouble abs() const { return sqrt(norm()); }\n\tdouble norm() const { return x * x + y * y; }\n\t// bool operator < (const Point &p) const { return x != p.x ? x < p.x : y < p.y; }\n\tbool operator < (const Point &p) const { // ??????????¨±???????????????\n\t\treturn x + EPS < p.x || (eq<double>(x, p.x) && y + EPS < p.y);\n\t}\n\tbool operator == (const Point &p) const { return (eq<double>(x, p.x) && eq<double>(y, p.y)); }\n};\nusing Vector = Point;\n\ndouble dot(const Vector& a, const Vector& b) { return a.x * b.x + a.y * b.y; } // ????????????a??¨b?????????\ndouble cross(const Vector& a, const Vector& b) { return a.x * b.y - a.y * b.x; } // ????????????a??¨b?????????\ndouble length2(const Point& a) { return a.norm(); } // ??????????????????2???\ndouble length(const Point& a) { return a.abs(); } // ???????????????\n\nenum ccw_t {\n\tCOUNTER_CLOCKWISE = 1, // p0->p1 ???????¨???????????????????p2\n\tCLOCKWISE = -1, // p0->p1 ????¨???????????????????p2\n\tONLINE_BACK = 2, // p2->p0->p1 ????????§??´????????§p2\n\tONLINE_FRONT = -2, // p0->p1->p2 ????????§??´??????p2\n\tON_SEGMENT = 0, // p0->p2->p1 ????????§??????p0p1??????p2\n};\nccw_t ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif ( cross(a, b) > EPS  )  return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS )  return CLOCKWISE;\n\tif ( dot(a, b) < -EPS )    return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nclass Segment { //??????\npublic:\n\tPoint p1, p2;\n\tSegment(){}\n\tSegment(Point p1, Point p2):p1(p1), p2(p2){}\n};\nusing Line = Segment;\n\n// *** ????????????????????? ***\nbool intersect(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && \n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\nbool intersect(const Segment& s1, const Segment& s2) { // ?????????????????????true\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n//*** ??????????????? ***\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1)), d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t  = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n// *** ?????¢ ***\ndouble getDistance(Point& a, Point& b) { // ???a??¨???b????????¢\n\treturn length(a - b);\n}\ndouble getDistanceLP(Line& l, Point& p) { // ??´???s??¨???p????????¢\n\treturn length(cross(l.p2 - l.p1, p - l.p1) / length(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) { // ??????s??¨???p????????¢\n\tif( dot(s.p2 - s.p1, p - s.p1) < EPS ) return length(p - s.p1);\n\tif( dot(s.p1 - s.p2, p - s.p2) < EPS ) return length(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\ndouble getDistanceSS(Segment s1, Segment s2) {\n\tif( intersect(s1, s2) ) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t   min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nclass Rectangle { // ????????¢\npublic:\n\t// 3 2\n\t// 0 1 (???????¨??????????????????¢??????????????????????????¨)\n\tvector<Point> p; // ?????????????????????????????¨\n\tRectangle(vector<Point>&p):p(p) {\n\t\trep(i, 3) reps(j, i + 1, 4) { //????????????????????????????????§???????????????????\n\t\t\tint cnt = 0;\n\t\t\trep(k, 4) if(k != i && k != j) {\n\t\t\t\tcnt += ccw(p[i], p[j], p[k]) == COUNTER_CLOCKWISE;\n\t\t\t}\n\t\t\tif(cnt == 2) {\n\t\t\t\tswap(p[i + 1], p[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbool intersect(const Segment& s) { // ??????s??¨????????¢????°?????????¨???1??????????????????????????°true\n\t\tbool flag = false;\n\t\trep(i, 4) flag |= ::intersect(s, Segment(p[i], p[(i + 1) % 4]));\n\t\treturn flag;\n\t}\n\tbool contain(const Point& pp) { // ???pp???????????¢????????????????????°(??????????????????)true\n\t\tbool flag = true;\n\t\trep(i, 4) flag &= ccw(p[i], p[(i + 1) % 4], pp) == COUNTER_CLOCKWISE;\n\t\treturn flag;\n\t}\n\tbool contain(const Segment& s) { // ??????s???????????¢????????????????????°(??????????????????)true\n\t\treturn contain(s.p1) && contain(s.p2);\n\t}\n};\n\n\n\nint main(void) {\n\t\n\twhile(1) {\n\t\tint N; scanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tdouble sx, sy, ex, ey; scanf(\"%lf %lf %lf %lf\", &sx, &sy, &ex, &ey);\n\t\tdouble minx[55], miny[55], maxx[55], maxy[55], h[55];\n\t\trep(i, N) scanf(\"%lf %lf %lf %lf %lf\", &minx[i], &miny[i], &maxx[i], &maxy[i], &h[i]);\n\n\t\tSegment L(Point(sx, sy), Point(ex, ey));\n\n\t\tdouble ans = INF;\n\t\trep(i, N) {\n\t\t\tvector<Point> tmp({Point(minx[i], miny[i]), Point(maxx[i], miny[i]), Point(maxx[i], maxy[i]), Point(minx[i], maxy[i])});\n\t\t\tRectangle rec(tmp);\n\t\t\tif(rec.intersect(L) || rec.contain(L)) {\n\t\t\t\tans = 0.0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdouble d = INF;\n\t\t\tchmin(d, getDistanceSS(L, Segment(Point(minx[i], miny[i]), Point(minx[i], maxy[i]))));\n\t\t\tchmin(d, getDistanceSS(L, Segment(Point(minx[i], maxy[i]), Point(maxx[i], maxy[i]))));\n\t\t\tchmin(d, getDistanceSS(L, Segment(Point(maxx[i], maxy[i]), Point(maxx[i], miny[i]))));\n\t\t\tchmin(d, getDistanceSS(L, Segment(Point(maxx[i], miny[i]), Point(minx[i], miny[i]))));\n\n\t\t\tdouble r;\n\t\t\tif(d <= h[i]) r = d;\n\t\t\telse r = (d * d + h[i] * h[i]) / (2 * h[i]);\n\n\t\t\tchmin(ans, r);\n\t\t}\n\t\tprintf(\"%.9f\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > 0) return 1;\n  if(cross(b,c) < 0) return -1;\n  if(dot(b,c) < 0) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n  ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < 0) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < 0) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  }\n\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\n\ndouble cal(L a,L b,double h){\n  double d=getDistanceSS(a,b);\n  if(h>d)return d;\n  return (h*h+d*d)/2/h;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    double ans=1e9;\n    P s,e;\n    double minx,maxx,miny,maxy,h;\n    cin>>s.x>>s.y>>e.x>>e.y;\n    for(int i=0;i<n;i++){\n      cin>>minx>>miny>>maxx>>maxy>>h;\n      if(minx<=s.x&&s.x<=maxx&&miny<=s.y&&s.y<=maxy)ans=0;\n      if(minx<=e.x&&e.x<=maxx&&miny<=e.y&&e.y<=maxy)ans=0;\n      ans=min(ans,cal(L(s,e),L(P(minx,miny),P(minx,maxy)),h));\n      ans=min(ans,cal(L(s,e),L(P(minx,maxy),P(maxx,maxy)),h));\n      ans=min(ans,cal(L(s,e),L(P(maxx,maxy),P(maxx,miny)),h));\n      ans=min(ans,cal(L(s,e),L(P(maxx,miny),P(minx,miny)),h));\n    }\n    printf(\"%.8lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**************** Geometrical Library ****************/\n\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define\tEPS\t1e-9\n\nenum {CCW=1,CW=-1,ON=0};\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy):x(xx),y(yy){}\n};\n\nclass Line:public vector<Point>{\npublic:\n\tLine(const Point &a,const Point &b){\n\t\tpb(a),pb(b);\n\t}\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\nclass Polygon:public vector<Point>{};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &cc,double rr):c(cc),r(rr){}\n};\n\nPoint &operator +=(Point &a,const Point &b){\n\ta.x+=b.x,a.y+=b.y;\n\treturn a;\n}\n\nPoint &operator -=(Point &a,const Point &b){\n\ta.x-=b.x,a.y-=b.y;\n\treturn a;\n}\n\nPoint &operator *=(Point &a,double c){\n\ta.x*=c,a.y*=c;\n\treturn a;\n}\n\nPoint &operator /=(Point &a,double c){\n\ta.x/=c,a.y/=c;\n\treturn a;\n}\n\nPoint operator +(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c+=b;\n}\n\nPoint operator -(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c-=b;\n}\n\nPoint operator *(double c,const Point &a){\n\tPoint b=a;\n\treturn b*=c;\n}\n\nPoint operator /(const Point &a,double c){\n\tPoint b=a;\n\treturn b/=c;\n}\n\nbool operator <(const Point &a,const Point &b){\n\treturn (a.x==b.x)?(a.y<b.y):(a.x<b.x);\n}\n\nbool operator >(const Point &a,const Point &b){\n\treturn b<a;\n}\n\ndouble dot(const Point &a,const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble norm2(const Point &a){\n\treturn dot(a,a);\n}\n\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)\t\treturn CCW;\n\tif(rotdir<-EPS)\t\treturn CW;\n\treturn ON;\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\t// l : ax+by+c=0\n\ta=l[0].y-l[1].y;\n\tb=l[1].x-l[0].x;\n\tc=l[0].x*l[1].y-l[1].x*l[0].y;\n}\n\nPoint perp_foot(const Point &p,const Line &l){\n\tdouble a,b,c;\n\tcalc_abc(l,a,b,c);\n\treturn p-(a*p.x+b*p.y+c)/(a*a+b*b)*Point(a,b);\n}\n\nbool intersect(const Line &l,const Line &m,Point *p=NULL){\n\t// this routine also returns true in case \"M is on L\", etc,.\n\tif(abs(cross(l[1]-l[0],m[1]-m[0]))>EPS\n\t|| abs(cross(l[1]-l[0],m[0]-l[0]))<EPS){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(l,a1,b1,c1);\n\t\t\tcalc_abc(m,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS)\t*p=l[0];\t// l == m\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool intersect(const Segment &s,const Segment &t,Point *p=NULL){\n\tif(max(s[0].x,s[1].x)<min(t[0].x,t[1].x)\n\t|| max(t[0].x,t[1].x)<min(s[0].x,s[1].x)\n\t|| max(s[0].y,s[1].y)<min(t[0].y,t[1].y)\n\t|| max(t[0].y,t[1].y)<min(s[0].y,s[1].y))\treturn false;\n\n\tif(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(s,a1,b1,c1);\n\t\t\tcalc_abc(t,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS){\t// s is parallel to t\n\t\t\t\tPoint q[3]={s[0],s[1],t[0]};\n\t\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\t\tif(dot(q[i]-s[0],q[i]-s[1])<EPS && dot(q[i]-t[0],q[i]-t[1])<EPS){\n\t\t\t\t\t\t*p=q[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**************** Library END ****************/\n\n#include<cstdio>\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tPoint s,g;\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&g.x,&g.y);\n\t\tSegment course(s,g);\n\n\t\tdouble rmin=1e30;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tPoint obj[2];\n\t\t\tint h;\n\t\t\tscanf(\"%lf%lf%lf%lf%d\",&obj[0].x,&obj[0].y,&obj[1].x,&obj[1].y,&h);\n\n\t\t\tbool oncourse=false;\n\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<2;k++){\t// cross course x object\n\t\t\t\tSegment edge(Point(obj[j].x,obj[k].y),Point(obj[k].x,obj[1-j].y));\n\t\t\t\tif(intersect(course,edge)){ oncourse=true; break; }\n\t\t\t}\n\t\t\tfor(int l=0;l<2;l++){\t// course in object\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<2;k++){\n\t\t\t\t\tSegment edge(Point(obj[j].x,obj[k].y),Point(obj[k].x,obj[1-j].y));\n\t\t\t\t\tcnt+=ccw(edge[0],edge[1],course[l]);\n\t\t\t\t}\n\t\t\t\tif(cnt==4*CCW || cnt==4*CW){ oncourse=true; break; }\n\t\t\t}\n\t\t\tif(oncourse){ rmin=0; break; }\n\n\t\t\tdouble d2min=1e30;\n\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<2;k++){\n\t\t\t\tPoint u=Point(obj[j].x,obj[k].y);\n\t\t\t\tPoint v=perp_foot(u,Line(course[0],course[1]));\n\t\t\t\tif(dot(v-course[0],v-course[1])<EPS){\t// v is on course\n\t\t\t\t\tdouble d2=norm2(v-u);\n\t\t\t\t\td2min=min(d2min,d2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<2;k++){\n\t\t\t\t\tSegment edge(Point(obj[j].x,obj[k].y),Point(obj[k].x,obj[1-j].y));\n\t\t\t\t\tPoint v=perp_foot(course[l],Line(edge[0],edge[1]));\n\t\t\t\t\tif(dot(v-edge[0],v-edge[1])<EPS){\n\t\t\t\t\t\tdouble d2=norm2(v-course[l]);\n\t\t\t\t\t\td2min=min(d2min,d2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble r;\n\t\t\tif(h*h<d2min)\tr=(d2min+h*h)/(2*h);\n\t\t\telse\tr=sqrt(d2min);\n\t\t\trmin=min(rmin,r);\n\t\t}\n\n\t\tprintf(\"%f\\n\",rmin);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define EPS (1e-10)\n#define INF 999999999\n#define PI 3.14159265\n\ndouble dot(P a,P b){\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(P a,P b){\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\ndouble distance_ls_p(P a,P b,P c){\n\tif(dot(b-a,c-a) < EPS) return abs(c-a);\n\tif(dot(a-b,c-b) < EPS) return abs(c-b);\n\treturn abs(cross(b-a,c-a)) / abs(b-a);\n}\n\ndouble distance_ls_ls(P a,P b,P c,P d){\n\treturn min(distance_ls_p(a,b,c),\n         min(distance_ls_p(a,b,d),\n         min(distance_ls_p(c,d,a), distance_ls_p(c,d,b) ) ) );\n}\n\nint is_intersected_ls(P a1,P a2,P b1,P b2){\n\treturn ((cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1) < 0) &&\n\t\t\t\t\t(cross(b2-b1,a1-b1) * cross(b2-b1,a2-b1) < 0));\n}\n\nbool sq_contains_ls(P a,P c,P s,P e){\n\treturn a.real() < s.real() + EPS && s.real() < c.real() + EPS &&\n\t\ta.imag() <  s.imag() + EPS && s.imag() < c.imag() + EPS &&\n\t\ta.real() < e.real() + EPS && e.real() < c.real() + EPS &&\n\t\ta.imag() < e.imag() + EPS && e.imag() < c.imag() + EPS;\n}\n\ndouble calcR(double dist,double h){\n\tdouble theta = acos(h / sqrt(h * h + dist * dist));\n\tdouble alpha = PI - 2 * theta;\n\tdouble r = sin(theta) * sqrt(h * h + dist * dist) / sin(alpha);\n\n\treturn r;\n}\n\nint main(void){\n\tint n;\n\n\twhile(cin>>n && n){\n\t\tdouble ans = INF;\n\t\tP s,e;\n\t\tcin>>s.real()>>s.imag()>>e.real()>>e.imag();\n\n\t\twhile(n--){\n\t\t\tP a,b,c,d;\n\t\t\tdouble h;\n\n\t\t\tcin>>a.real()>>a.imag()>>c.real()>>c.imag()>>h;\n\n\t\t\tb = P(c.real(),a.imag());\n\t\t\td = P(a.real(),c.imag());\n\n\t\t\tif(is_intersected_ls(s,e,a,b) || is_intersected_ls(s,e,b,c) || is_intersected_ls(s,e,c,d) || is_intersected_ls(s,e,d,a) || sq_contains_ls(a,c,s,e)){\n\t\t\t\tans = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdouble dist = min(distance_ls_ls(s,e,a,b),min(distance_ls_ls(s,e,b,c),min(distance_ls_ls(s,e,c,d), distance_ls_ls(s,e,d,a))));\n\t\t\t\tdouble r = dist > h ? calcR(dist,h) : dist;\n\t\t\t\tif(r < 1000 + EPS) ans = min(ans,r);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.5lf\\n\",ans==INF?0:ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-10;\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < -EPS );\n}\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\nint main(){\n  int count;\n  while(true){\n    count++;\n    int n;\n    cin>>n;\n    if(!n)break;\n    double r,r_min = 1000;\n    double sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    P s=P(sx,sy),e=P(ex,ey);\n    for(int i=0;i<n;i++){\n      double x1,y1,x2,y2,h;\n      cin>>x1>>y1>>x2>>y2>>h;\n      P p[4]={ P(x1,y1),P(x2,y1),P(x2,y2),P(x1,y2)};\n      if(is_intersected_ls(s,e,p[0],p[1])\n\t ||is_intersected_ls(s,e,p[1],p[2])\n\t ||is_intersected_ls(s,e,p[2],p[3])\n\t ||is_intersected_ls(s,e,p[3],p[0])\n\t ||(x1<min(sx,ex)&&y1<min(sy,ey)&&max(sx,ex)<x2&&max(sy,ey)<y2)){\n\tr_min = 0;\n      }\n      if(r_min-EPS>0){\n\tdouble l=1000;\n\tfor(int j=0;j<4;j++){\n\t  l = min(l,distance_ls_p(s,e,p[j]));\n\t  l = min(l,distance_ls_p(p[j],p[(j+1)%4],s));\n\t  l = min(l,distance_ls_p(p[j],p[(j+1)%4],e));\n\t}\n\tr = h>l?l:(h*h+l*l)/(2*h);\n\tif(r<r_min)r_min = r;\n      }\n    }\n    printf(\"%.4f\\n\",r_min);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define FOR(i,m,n) for(int i=(m);i<(n);i++)\n\nconst double EPS = 1e-6;\ntypedef complex<double> point;\npoint operator*(const point&p, const double &d) {\n\treturn point(real(p)*d, imag(p)*d);\n}\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n//直線or線分\nstruct Line : public vector<point> {\n\tLine(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n//外積\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n//内積\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n//交差判定\nbool intersectLL(const Line &l1, const Line &l2) {\n\treturn abs(cross(l1[1] - l1[0], l2[1] - l2[0])) > EPS || //non-parallel\n\t\tabs(cross(l1[1] - l1[0], l2[0] - l1[0])) < EPS; //same line\n}\nbool intersectLS(const Line &l, const Line &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])* // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const Line &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSS(const Line &s, const Line &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\nbool intersectSP(const Line &s, const point &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; //triangle inequality\n}\n//距離,交点\n//射影 直線lにpから下した垂線との交点\npoint projection(const Line &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[0] - l[1])*t;\n}\n//射影 直線lを対象軸としてpと線対称にある点\npoint reflection(const Line &l, const point &p) {\n\treturn p + (projection(l, p) - p)*2;\n}\ndouble distancePP(const point& a, const point& b) {\n\treturn sqrt(norm(a - b));\n}\ndouble distanceLP(const Line &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const Line&l, const Line &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const Line &l, const Line &s) {\n\tif (intersectLS(l, s))return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const Line &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r))return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const Line &s, const Line &t) {\n\tif (intersectSS(s, t))return 0;\n\treturn min({ distanceSP(s,t[0]),distanceSP(s,t[1]),distanceSP(t,s[0]),distanceSP(t,s[1]) });\n}\npoint crosspoint(const Line &l, const Line &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS&&abs(B) < EPS)return m[0];//same line\n\tif (abs(A) < EPS)assert(false); // Precondition not satisfied\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\ndouble dist(point &p1, point &p2) {\n\treturn abs(p1 - p2);\n}\n\n//円\nstruct Circle {\n\tpoint p; double r;\n\tCircle(const point &p, double r) : p(p), r(r) { }\n};\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n//2点を通る半径Rの円の中心\npair<point, point> get_circle_from_2points(point &p1, point &p2, double R) {\n\tdouble d = dist(p1, p2);\n\tdouble x1 = p1.real(), x2 = p2.real();\n\tdouble y1 = p1.imag(), y2 = p2.imag();\n\tif (p1.imag() == p2.imag()) {\n\t\tdouble x = (x1 + x2) / 2.0;\n\t\tdouble dy = sqrt(R - d * d / 4);\n\t\treturn { { x,y1 + dy },{ x,y1 - dy } };\n\t}\n\telse {\n\t\tdouble m = (x1 - x2) / (y2 - y1);\n\t\tdouble t = sqrt(R*R - d * d / 4);\n\t\tdouble dx = sqrt((t*t) / (m*m + 1));\n\t\tdouble dy = sqrt(t*t - dx * dx);\n\t\tdouble gx = (x1 + x2) / 2;\n\t\tdouble gy = (y1 + y2) / 2;\n\t\tif (m > EPS) {\n\t\t\treturn { { gx + dx,gy + dy },{ gx - dx,gy - dy } };\n\t\t}\n\t\telse {\n\t\t\treturn { { gx + dx,gy - dy },{ gx - dx,gy + dy } };\n\t\t}\n\t}\n}\n//長方形\nstruct Square {\n\tdouble lx, ly, rx, ry;\n\tdouble h;\n\tSquare(double lx_, double ly_, double rx_, double ry_, double h_) :lx(lx_), ly(ly_), rx(rx_), ry(ry_), h(h_) {};\n\tbool include(point &p) {\n\t\treturn p.real()+EPS >= lx && p.real()-EPS <= rx && p.imag()+EPS >= ly && p.imag()-EPS <= ry;\n\t}\n};\n\nclock_t start;\nclock_t end_t;\nvoid solve() {\n\tint N; cin >> N;\n\tif (N == 0)exit(0);\n\tdouble sx, sy, gx, gy;\n\tcin >> sx >> sy >> gx >> gy;\n\tpoint s = { sx,sy };\n\tpoint g = { gx,gy };\n\tvector<Square>Ss;\n\tREP(i, N) {\n\t\tdouble lx, ly, rx, ry, h;\n\t\tcin >> lx >> ly >> rx >> ry >> h;\n\t\tSquare S(lx, ly, rx, ry,h);\n\t\tSs.push_back(S);\n\t}\n\tdouble ok = 0, ng = 1000;\n\tLine sg(s, g);\n\tREP(_, 100) {\n\t\tdouble mid = (ok+ng)/2;\n\t\tdouble r = mid;\n\t\tvector<Square>S = Ss;\n\t\tbool possible = true;\n\t\tvector<double>d;\n\t\tREP(i, N) {\n\t\t\tif (S[i].h < r) {\n\t\t\t\tdouble diff = sqrt(r*r - (r - S[i].h)*(r - S[i].h));\n\t\t\t\td.push_back(diff);\n\t\t\t\t//S[i].lx -= diff;\n\t\t\t\t//S[i].ly -= diff;\n\t\t\t\t//S[i].rx += diff;\n\t\t\t\t//S[i].ry += diff;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble diff = r;\n\t\t\t\td.push_back(diff);\n\t\t\t\t//S[i].lx -= diff;\n\t\t\t\t//S[i].ly -= diff;\n\t\t\t\t//S[i].rx += diff;\n\t\t\t\t//S[i].ry += diff;\n\t\t\t}\n\t\t}\n\t\t//sかgが含まれていたらアウト\n\t\tREP(i, N) {\n\t\t\tif (S[i].include(s))possible = false;\n\t\t\tif (S[i].include(g))possible = false;\n\t\t}\n\t\t//交差判定\n\t\tREP(i, N) {\n\t\t\tvector<point>ps(4);\n\t\t\tps[0] = { S[i].lx,S[i].ly };\n\t\t\tps[1] = { S[i].lx,S[i].ry };\n\t\t\tps[2] = { S[i].rx,S[i].ry };\n\t\t\tps[3] = { S[i].rx,S[i].ly };\n\t\t\tREP(k, 4) {\n\t\t\t\tLine s(ps[k], ps[(k + 1) % 4]);\n\t\t\t\tif (distanceSS(s, sg) <= d[i]) {\n\n\t\t\t\t\t//cout << s[0] << \" \" << s[1] << \" \" << sg[0] <<\" \"<<sg[1] << endl;\n\t\t\t\t\t//cout << \"distance:\" << distanceSS(s, sg) << endl;\n\t\t\t\t\t//cout << \"d:\" << d[i] << endl;\n\t\t\t\t\tpossible = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (possible)ok = mid;\n\t\telse ng = mid;\n\t}\n\tprintf(\"%.10lf\\n\", ok);\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstart = clock();\n\twhile (true)solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\ndouble eps = 1e-8;\n\ndouble add(double a, double b) {\n    if (abs(a+b) < eps * (abs(a)+abs(b))) return 0;\n    return a+b;\n}\n\nbool equal(double a, double b) {\n    return add(a, -b) == 0;\n}\n\nstruct P {\n    double x, y;\n    P() {}\n    P(double x, double y) : x(x), y(y) {}\n    P operator+(P p) const {return P(add(x, p.x), add(y, p.y));}\n    P operator-(P p) const {return P(add(x, -p.x), add(y, -p.y));}\n    P operator*(double d) const {return P(x*d, y*d);}\n    double dot(P p) const {return add(x*p.x, y*p.y);} // ??????\n    double det(P p) const {return add(x*p.y, -y*p.x);} // ??????\n    double dist(P p) const {return sqrt((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y));} // ?????¢\n    void normalize() {double d = sqrt(x*x+y*y); x /= d; y /= d;} // ??£??????\n    bool operator<(const P& rhs) const {\n        if (x != rhs.x) return x < rhs.x;\n        return y < rhs.y;\n    }\n    bool operator==(const P& rhs) const {\n        return equal(x, rhs.x) && equal(y, rhs.y);\n    }\n};\n\n// ??????p1-p2?????????q???????????????????????????\nbool on_seg(P p1, P p2, P q) {\n    return (p1-q).det(p2-q) == 0 && (p1-q).dot(p2-q) <= 0;\n}\n\n// ??´???p1-p2??¨??´???q1-q2??????????????????????????????\nbool parallel(P p1, P p2, P q1, P q2) {\n    P a = p2-p1;\n    P b = q2-q1;\n    return a.det(b) == 0;\n}\n\n// ??´???p1-p2??¨??´???q1-q2?????????\nP intersection(P p1, P p2, P q1, P q2) {\n    return p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\ninline double square(double x) {return x*x;}\n// ??´???p1-p2??¨???q????????¢\ndouble dist(P p1, P p2, P q) {\n    q = q-p1;\n    p2 = p2-p1;\n    return sqrt((q.dot(q)*p2.dot(p2) - square(q.dot(p2))) / p2.dot(p2));\n}\n\n// ??????p1-p2??¨???q????????¢\ndouble distSeg(P p1, P p2, P q) {\n    double d = (q-p1).dot(p2-p1) / p2.dist(p1);\n    if (d < 0) return q.dist(p1);\n    if (d > p2.dist(p1)) return q.dist(p2);\n    return dist(p1, p2, q);\n}\n\n// ??????p1-p2??¨??????q1-q2????????¢\ndouble distSeg(P p1, P p2, P q1, P q2) {\n    if (p1==p2 && q1==q2) return q1.dist(p1);\n    if (p1==p2) return distSeg(q1, q2, p1);\n    if (q1==q2) return distSeg(p1, p2, q1);\n    if (!parallel(p1, p2, q1, q2)) {\n        P r = intersection(p1, p2, q1, q2);\n        if (on_seg(p1, p2, r) && on_seg(q1, q2, r)) return 0;\n    }\n    double ret = min(distSeg(p1, p2, q1), distSeg(p1, p2, q2));\n    ret = min(ret, min(distSeg(q1, q2, p1), distSeg(q1, q2, p2)));\n    return ret;\n}\n\nconst int MAXN = 55;\nint n;\nint sx, sy, gx, gy;\nint minX[MAXN], minY[MAXN], maxX[MAXN], maxY[MAXN], h[MAXN];\ndouble dd[MAXN];\n\nbool ok(double r) {\n    for (int i = 0; i < n; i++) {\n        double d = dd[i];\n        if (r < h[i]) {\n            if (r > d) return false;\n        } else {\n            double atMost = square(r)-square(r-h[i]);\n            if (atMost > d*d) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    while (cin >> n) {\n        if (n==0) break;\n        scanf(\"%d %d %d %d\", &sx, &sy, &gx, &gy);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d %d %d %d\", minX+i, minY+i, maxX+i, maxY+i, h+i);\n        }\n        for (int i = 0; i < n; i++) {\n            double d = 1e9;\n            d = min(d, distSeg(P(sx, sy), P(gx, gy), P(minX[i], minY[i]), P(minX[i], maxY[i])));\n            d = min(d, distSeg(P(sx, sy), P(gx, gy), P(minX[i], minY[i]), P(maxX[i], minY[i])));\n            d = min(d, distSeg(P(sx, sy), P(gx, gy), P(maxX[i], minY[i]), P(maxX[i], maxY[i])));\n            d = min(d, distSeg(P(sx, sy), P(gx, gy), P(minX[i], maxY[i]), P(maxX[i], maxY[i])));\n            dd[i] = d;\n            if (minX[i] <= sx && sx <= maxX[i] && minY[i] <= sy && sy <= maxY[i]) dd[i] = 0;\n            if (minX[i] <= gx && gx <= maxX[i] && minY[i] <= gy && gy <= maxY[i]) dd[i] = 0;\n        }\n        const double dr = 0.001/2;\n        bool finish = false;\n        for (double r = 1000; r > dr; r -= dr) {\n            if (ok(r)) {\n                printf(\"%.5lf\\n\", r);\n                finish = true;\n                break;\n            }\n        }\n        if (!finish) printf(\"0\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(const Point &p0,const Point &p1,const Point &p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nPoint projection(const Segment &s,const Point &p){\n    Vector b = s.t-s.s;\n    double t = dot(p-s.s,b)/norm(b);\n    return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n    return (ccw(s.s,s.t,p) == 0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n            ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n    Point r = projection(s,p);\n    if(isIntersectSP(s,r)) return abs(r-p);\n    return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment &a,const Segment &b){\n    if(isIntersectSS(a,b)) return 0;\n    return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n           min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nstruct Block{\n    Point a,b;\n    double h;\n    Block(){}\n    Block(Point &a,Point &b,double h) :\n        a(a),b(b),h(h) {}\n};\n\nistream &operator >> (istream &is,Point &p){ \n    return is >> p.x >> p.y;\n}\n\ndouble calc(double a,double b){\n    return sqrt(a*a+b*b);\n}\n\nbool c(double r,Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point a = v[i].a,b = v[i].b;\n        Point c(a.x,b.y),d(b.x,a.y);\n        Segment s1(a,c),s2(a,d),s3(c,b),s4(d,b);\n        double dst[] = {\n            distanceSS(p,s1),\n            distanceSS(p,s2),\n            distanceSS(p,s3),\n            distanceSS(p,s4)\n        };\n \n        if(r < v[i].h){\n            if(!(r <= dst[0] &&\n                 r <= dst[1] &&\n                 r <= dst[2] &&\n                 r <= dst[3])){\n                return false;\n            }\n        }else{\n            double nh = r - v[i].h;\n            if(!(r <= calc(nh,dst[0]) &&\n                 r <= calc(nh,dst[1]) &&\n                 r <= calc(nh,dst[2]) &&\n                 r <= calc(nh,dst[3]))){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool check(Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point c(v[i].a.x,v[i].b.y);\n        Point d(v[i].b.x,v[i].a.y);\n        Segment s1(v[i].a,c),s2(v[i].a,d),s3(c,v[i].b),s4(d,v[i].b);\n        if((v[i].a.x <= p.s.x && p.s.x <= v[i].b.x &&\n            v[i].a.y <= p.s.y && p.s.y <= v[i].b.y) ||\n           (v[i].a.x <= p.t.x && p.t.x <= v[i].b.x &&\n            v[i].a.y <= p.t.y && p.t.y <= v[i].b.y)){\n            return true;\n        }\n        if(isIntersectSS(p,s1)) return true;\n        if(isIntersectSS(p,s2)) return true;\n        if(isIntersectSS(p,s3)) return true;\n        if(isIntersectSS(p,s4)) return true;\n    }\n    return false;\n}\n\nint main(){\n    int N;\n    while(cin >> N,N){\n        Point s,e;\n        Segment seg;\n        cin >> seg.s >> seg.t;\n        vector<Block> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].a >> v[i].b >> v[i].h;\n        }\n        if(check(seg,v)){\n            cout << 0 << endl;\n            continue;\n        }\n        double l = 0,r = 1001;\n        for(int i = 0 ; i < 100 ; i++){\n            double mid = (l + r) / 2;\n            if(c(mid,seg,v)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n        printf(\"%.10f\\n\",r);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str(); }\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX / 10;\n\n#include <complex>\ntypedef complex<double> P;\n#define LE(x,y) ((x)-(y)<+EPS)\n\ndouble dot(P a, P b) {\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\n\nint is_point_on_ls(P a, P b, P c) {\n\treturn (abs(a - c) + abs(c - b) < abs(a - b) + EPS);\n}\n\ndouble distance_ls_p(P a, P b, P c) {\n\tif (dot(b - a, c - a) < EPS) return abs(c - a);\n\tif (dot(a - b, c - b) < EPS) return abs(c - b);\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n \nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\tif ((cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < -EPS) &&\n\t\t(cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < -EPS)) {\n\t\treturn true;\n\t}\n\treturn is_point_on_ls(a1, a2, b1) || is_point_on_ls(a1, a2, b2)\n\t\t|| is_point_on_ls(b1, b2, a1) || is_point_on_ls(b1, b2, a2);\n}\n\ndouble distance_ls(P a1, P a2, P b1, P b2) {\n\tif (is_intersected_ls(a1, a2, b1, b2)) return 0.0;\n\treturn min(min(distance_ls_p(a1, a2, b1), distance_ls_p(a1, a2, b2)),\n\t\tmin(distance_ls_p(b1, b2, a1), distance_ls_p(b1, b2, a2)));\n}\n\nstruct block {\n\tint h;\n\tP a, b, c, d;\n\tblock(int minx, int miny, int maxx, int maxy, int h) :\n\t\ta(P(minx, miny)), b(P(maxx, miny)), c(P(maxx, maxy)), d(P(minx, maxy)), h(h) {};\n};\n\ndouble distance_ball_ls(P s, P e, P b1, P b2, int h) {\n\tdouble d = distance_ls(s, e, b1, b2), res = d;\n\tif (!LE(d, h)) {\n\t\tres = ((h*h + d*d) / (2 * h));\n\t}\n\treturn res;\n}\n\ndouble distance_ball_block(P s, P e, block b) {\n\treturn min(min(distance_ball_ls(s, e, b.a, b.b, b.h), distance_ball_ls(s, e, b.b, b.c, b.h)),\n\t\tmin(distance_ball_ls(s, e, b.c, b.d, b.h), distance_ball_ls(s, e, b.d, b.a, b.h)));\n}\n\nbool is_point_in_block(int x, int y, int minx, int miny, int maxx, int maxy) {\n\treturn minx < x && x < maxx && miny < y && y < maxy;\n}\n\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tint sx, sy, ex, ey;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tP s(sx, sy), e(ex, ey);\n\n\t\tint minx, miny, maxx, maxy, h;\n\t\tdouble r = INF;\n\t\tREP(i, N) {\n\t\t\tcin >> minx >> miny >> maxx >> maxy >> h;\n\t\t\tif (is_point_in_block(sx, sy, minx, miny, maxx, maxy) || is_point_in_block(ex, ey, minx, miny, maxx, maxy)) {\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t\tblock b(minx, miny, maxx, maxy, h);\n\t\t\tr = min(r, distance_ball_block(s, e, b));\n\t\t}\n\n\t\tcout << r << endl;;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-10;\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < -EPS );\n}\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\nint main(){\n  int count;\n  while(true){\n    count++;\n    int n;\n    cin>>n;\n    if(!n)break;\n    double r,r_min = 1000;\n    double sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    P s=P(sx,sy),e=P(ex,ey);\n    for(int i=0;i<n;i++){\n      double x1,y1,x2,y2,h;\n      cin>>x1>>y1>>x2>>y2>>h;\n      P p[4]={ P(x1,y1),P(x2,y1),P(x2,y2),P(x1,y2)};\n      if(is_intersected_ls(s,e,p[0],p[1])\n\t ||is_intersected_ls(s,e,p[1],p[2])\n\t ||is_intersected_ls(s,e,p[2],p[3])\n\t ||is_intersected_ls(s,e,p[3],p[0])\n\t ||(x1<min(sx,ex)&&y1<min(sy,ey)&&max(sx,ex)<x2&&max(sy,ey)<y2)){\n\tcout<<x1<<\" \"<<y1<<\" \"<<x2<<\" \"<<y2<<\" \"<<h<<endl;\n\tr_min = 0;\n      }\n      if(r_min-EPS>0){\n\tdouble l=1000;\n\tfor(int j=0;j<4;j++){\n\t  l = min(l,distance_ls_p(s,e,p[j]));\n\t  l = min(l,distance_ls_p(p[j],p[(j+1)%4],s));\n\t  l = min(l,distance_ls_p(p[j],p[(j+1)%4],e));\n\t}\n\tr = h>l?l:(h*h+l*l)/(2*h);\n\tif(r<r_min)r_min = r;\n      }\n    }\n    printf(\"%.4f\\n\",r_min);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define EPS (1e-10)\ntypedef complex<double> P;\n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\ndouble distance(P p0, P p1, P p2, P p3){\n  double ans = 1e10;\n        ans = min(ans, distance_ls_p(p0, p1, p2));\n        ans = min(ans, distance_ls_p(p0, p1, p3));\n        ans = min(ans, distance_ls_p(p2, p3, p0));\n        ans = min(ans, distance_ls_p(p2, p3, p1));\n        if(is_intersected_ls(p0, p1, p2, p3)) ans = 0.0;\n\t\treturn ans;\n}\n\nint main(){\n  while(true){\n\t\tint n; cin >> n;\n\t\tif(n == 0 )break;\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tP s = P(x,y);\n\t\tcin >> x >> y;\n\t\tP g = P(x,y);\n\t\tvector<P> mins(n), maxs(n);\n\t\tvector<double> h(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\t//if(z == 24)printf(\"%.0f %.0f\",x,y);\n\t\t\tmins[i].real(x); mins[i].imag(y);\n\t\t\tcin >> x >> y;\n\t\t\t//if(z == 24)printf(\" %.0f %.0f\",x,y);\n\t\t\tmaxs[i].real(x); maxs[i].imag(y);\n\t\t\tcin >> h[i];\n\t\t\t//if(z == 24)printf(\" %.0f \\n\",h[i]);\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tfor(int i = 0; i < n;i++){\n\t\t\tdouble d = 1e9;\n\t\t\tP p1 = mins[i], p3 = maxs[i];\n\t\t\tP p2(mins[i].real(), maxs[i].imag());\n\t\t\tP p4(maxs[i].real(), mins[i].imag());\n\t\t\tif(p1.real() < s.real() && s.real() < p3.real() && \n\t\t\t\tp1.imag() < s.imag() && s.imag() < p3.imag()){\n\t\t\t\tans = 0;/*\n\t\t\t\tif(z==24){\n\t\t\t\t\tprintf(\"%.0f %.0f %.0f %.0f\\n\",p1.real(),p1.imag(),p3.real(),p3.imag());\n\t\t\t\t\tcout << \"break\" << endl;}*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, distance(s, g, p1,p2));\n\t\t\td = min(d, distance(s, g, p2,p3));\n\t\t\td = min(d, distance(s, g, p3,p4));\n\t\t\td = min(d, distance(s, g, p4,p1));\n\t\t\tdouble r = (h[i]*h[i]+d*d)/(2*h[i]);\n\t\t\tif(h[i] < d){\n\t\t\t\tans = min(ans, r);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = min(ans, d);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4f\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点cが線分a,b上にあるかないか(2)\nint is_point_on_line(P a, P b, P c) {\n // |a-c| + |c-b| <= |a-b| なら線分上\n return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n if (( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS ) &&\n     ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < -EPS ))\n    return true;\n return is_point_on_line(a1, a2, b1) || is_point_on_line(a1, a2, b2) ||\n        is_point_on_line(b1, b2, a1) || is_point_on_line(b1, b2, a2);\n}\n\nstruct block{\n\tint minx,miny,maxx,maxy,h;\n\tP p(int n){\n\t\tswitch(n){\n\t\tcase 0:\n\t\t\treturn P(minx,miny);\n\t\tcase 1:\n\t\t\treturn P(minx,maxy);\n\t\tcase 2:\n\t\t\treturn P(maxx,maxy);\n\t\tcase 3:\n\t\t\treturn P(maxx,miny);\n\t\t}\n\t}\n};\nint main(){\n\tcout.precision(16);\n\tint n;\n\twhile(cin>>n,n){\n\t\tint sx,sy,ex,ey;\n\t\tcin>>sx>>sy>>ex>>ey;\n\t\tvector<block> blocks(n);\n\t\tREP(i,n){\n\t\t\tcin>>blocks[i].minx>>blocks[i].miny>>blocks[i].maxx>>blocks[i].maxy>>blocks[i].h;\n\t\t}\n\t\tdouble ans=INT_MAX;\n\t\tbool itsc=false;\n\t\tREP(i,n){\n\t\t\tREP(j,4){\n\t\t\t\tif(is_intersected_ls(P(sx,sy),P(ex,ey),blocks[i].p(j),blocks[i].p((j+1)%4))){\n\t\t\t\t\titsc=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(sx+EPS>blocks[i].minx&&sx-EPS<blocks[i].maxx&&sy+EPS>blocks[i].miny&&sy-EPS<blocks[i].maxy){\n\t\t\t\t\titsc=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ex+EPS>blocks[i].minx&&ex-EPS<blocks[i].maxx&&ey+EPS>blocks[i].miny&&ey-EPS<blocks[i].maxy){\n\t\t\t\t\titsc=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(itsc){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(itsc){\n\t\t\tcout<<0<<endl;\n\t\t}else{\n\t\t\tREP(i,n){\n\t\t\t\tdouble r=INT_MAX;\n\t\t\t\tREP(j,4){\n\t\t\t\t\tdouble d=distance_ls_p(P(sx,sy),P(ex,ey),blocks[i].p(j));\n\t\t\t\t\tr=min(r,(blocks[i].h*blocks[i].h+d*d)/2/blocks[i].h);\n\t\t\t\t\tdouble ds=distance_ls_p(blocks[i].p(j),blocks[i].p((j+1)%4),P(sx,sy));\n\t\t\t\t\tr=min(r,(blocks[i].h*blocks[i].h+ds*ds)/2/blocks[i].h);\n\t\t\t\t\tdouble de=distance_ls_p(blocks[i].p(j),blocks[i].p((j+1)%4),P(ex,ey));\n\t\t\t\t\tr=min(r,(blocks[i].h*blocks[i].h+de*de)/2/blocks[i].h);\n\t\t\t\t}\n\t\t\t\tif(blocks[i].h>=r){\n\t\t\t\t\tREP(j,4){\n\t\t\t\t\t\tdouble d=distance_ls_p(P(sx,sy),P(ex,ey),blocks[i].p(j));\n\t\t\t\t\t\tr=min(r,d);\n\t\t\t\t\t\tdouble ds=distance_ls_p(blocks[i].p(j),blocks[i].p((j+1)%4),P(sx,sy));\n\t\t\t\t\t\tr=min(r,ds);\n\t\t\t\t\t\tdouble de=distance_ls_p(blocks[i].p(j),blocks[i].p((j+1)%4),P(ex,ey));\n\t\t\t\t\t\tr=min(r,de);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans=min(ans,r);\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\n#define EPS (1e-9)\nusing namespace std;\ntypedef complex<double> point;\n\ndouble dot(point a,point b){return a.x*b.x+a.y*b.y;}\n\ndouble cross(point a,point b){return a.x*b.y-a.y*b.x;}\n\nint ccw(point a,point b,point c){\n  point d=b-a;\n  point e=c-a;\n  if(cross(d,e)>0)return 1;//?????´\n  if(cross(d,e)<0)return -1;//?????´\n  if(dot(d,e)<0)return 2;//onlineback\n  if(abs(d)<abs(e))return -2;//onlinefront\n  return 0;//onsegment\n}\n\n//??´??????????????????\nbool intersection(point a,point b,point c,point d){\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n}\n\n//????????¨???????????¢\ndouble getdistance_sp(point a,point b,point p){\n  if(!(dot(p-a,b-a)>=0&&dot(p-b,a-b)>=0))return min(abs(p-a),abs(p-b));\n  return abs(cross(p-a,b-a)/abs(b-a));\n}\n\n//????????¨??????????????¢\ndouble getdistance_ss(point a,point b,point c,point d){\n  if(intersection(a,b,c,d))return 0;\n  return min(min(getdistance_sp(c,d,a),getdistance_sp(c,d,b)),\n\t     min(getdistance_sp(a,b,c),getdistance_sp(a,b,d)));\n}\n\n//???p??????????§???¢v???(?????´?????????->1,?¢????????????????->2,?????´?????????->3)\nint getstate(vector<point> v,point p){\n  int n=v.size();\n  for(int i=0;i<n;i++){\n    int c=ccw(v[i],v[(i+1)%n],p);\n    if(c==0)return 2;\n    if(c!=1)return 3;\n  }\n  return 1;\n}\n\n//???????§???¢v??¨???p????????¢\ndouble getdistance_pp(vector<point> v,point p){\n  int n=v.size();\n  if(getstate(v,p)!=3)return 0;\n  double r=abs(v[0]-p);\n  for(int i=0;i<n;i++)r=min(r,getdistance_sp(v[i],v[(i+1)%n],p));\n  return r;\n}\n\n//???????§???¢v??¨??????ab????????¢\ndouble getdistance_ps(vector<point> v,point a,point b){\n  int n=v.size();\n  double r=abs(v[0]-a);\n  if(getstate(v,a)!=3||getstate(v,b)!=3)return 0;\n  for(int i=0;i<n;i++){\n    r=min(r,getdistance_ss(v[i],v[(i+1)%n],a,b));\n  }\n  return r;\n}\n\nint main(){\n  int n,h,a,b,c,d;\n  double ans,dis;\n  point s,g;\n  vector<point> v;\n  while(1){\n    cin>>n;\n    if(!n)break;\n    ans=(1e9);\n    cin>>s.x>>s.y>>g.x>>g.y;\n    while(n--){\n      cin>>a>>b>>c>>d>>h;\n      v.push_back(point(a,b));\n      v.push_back(point(c,b));\n      v.push_back(point(c,d));\n      v.push_back(point(a,d));\n      dis=getdistance_ps(v,s,g);\n      if(dis>h)ans=min(ans,(dis*dis+h*h)/(2*h));\n      else ans=min(ans,dis);\n      v.clear();\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define all(x) x.begin(), x.end()\n#define mp make_pair\n#define eb emplace_back \n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pip;\ntypedef vector<int> vi;\nconst int INF = 1000000000;\n\ntypedef complex<double> pt;\ntypedef vector<pt> pol;\nconst double eps = 1e-8;\nstruct line : pol{\n  line(){}\n  line(pt a, pt b){ pb(a); pb(b);}\n};\n\ndouble dot(const pt a, const pt b){\n\treturn real(conj(a) * b);\n}\ndouble crs(const pt a, const pt b){\n  return imag(conj(a) * b);\n}\nint ccw(pt a, pt b, pt c){\n  b-=a; c-=a;\n  if(crs(b,c) > 0) return 1;\n  if(crs(b,c) < 0) return -1;\n  if(dot(b,c) < 0) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\nbool intsp(line s, pt p){\n  return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < eps;\n}\nbool intss(line s, line t){\n  return ccw(s[0],s[1], t[0]) * ccw(s[0],s[1],t[1]) <= 0 &&\n  \t\t\tccw(t[0], t[1],s[0]) * ccw(t[0],t[1],s[1]) <= 0;\n}\npt proj(line l, pt p){\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0] - l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\ndouble distsp(line s, pt p){\n  pt r = proj(s,p);\n  if(intsp(s, r)) return abs(r-p);\n  return min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble distss(line s, line t){\n  if(intss(s,t)) return 0;\n  return min( min(distsp(s,t[0]), distsp(s,t[1])), min(distsp(t,s[0]), distsp(t,s[1])));\n}\n\ntemplate<class T>\nostream& operator<<(ostream &out, const vector<T> &v){\n  out << \"{\";\n  rep(i,v.size()) out << v[i] << \", \";\n  return out << \"}\" << endl;\n}\nint main(){\n  int n;\n  while(cin >> n, n){\n\tpt s,t;\n\tvi h(n);\n\tvector<double> d(n);\n\tint x, y;\n\tcin >> x >> y;\n\ts = pt(x,y);\n\tcin >> x >> y;\n\tt = pt(x,y);\n\tline seg(s,t);\n\trep(i,n){\n\t  int w,z;\n\t  cin >> x >> y >> w >> z >> h[i];\n\t  pt a[4] = {pt(x,y), pt(w,y), pt(w,z),pt(x,z)};\n\t  d[i] = INF;\n\t  rep(j,4) d[i] = min(d[i], distss(seg, line(a[j], a[(j+1)%4])));\n\t}\n\n\tdouble lb = 0, ub = INF;\n\twhile(ub - lb > eps){\n\t  double mid = (lb + ub) / 2;\n\t  bool f = true;\n\t  rep(i,n){\n\t\tdouble m = mid - min((double)h[i],mid);\n\t\tif(mid * mid > d[i] * d[i] + m * m){\n\t\t  f = false;\n\t\t  break;\n\t\t}\n\t  }\n\t  if(f) {\n\t\tlb = mid;\n\t  }else{\n\t\tub = mid;\n\t  }\n\t}\n\n\tcout << fixed << setprecision(10);\n\tcout << lb << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef complex<double> P;\n\nint N;\ndouble sx,sy,ex,ey,mx,my,Mx,My,h;\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint insected(P a1, P a2, P b1, P b2) {\n\tif(fabs(cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1))<EPS){\n\treturn dot(b1-a1,b1-a2)*dot(b2-a1,b2-a2)<EPS;\n\t}\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\ndouble dist(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return\n\tabs(cross(b-a, c-a)) / abs(b-a);\n}\n\nint main(){\n\tFILE *out1157;         // oÍXg[\n  out1157 = fopen(\"out1157\", \"w\");  // t@Cð«ÝpÉI[v(J­)\n  if (out1157 == NULL) {          // I[vÉ¸sµ½ê\n    printf(\"cannot open\\n\");         // G[bZ[WðoµÄ\n    exit(1);                         // ÙíI¹\n  }int cn=0;\n\twhile(cin>>N&&N){\n\t\t//cn++;\n\t\tcin>>sx>>sy>>ex>>ey;//cout<<cn<<endl;if(cn==59)cout<<sx<<\" \"<<sy<<\" \"<<ex<<\" \"<<ey<<endl;\n\t\tP s(sx,sy),e(ex,ey);\n\t\tdouble ans=1e9;\n\t\trep(i,N){\n\t\t\tcin>>mx>>my>>Mx>>My>>h;\n\t\t\tP a(mx,my),b(Mx,my),c(Mx,My),d(mx,My);\n\t\t\tif(mx<=min(sx,ex)&&Mx>=max(sx,ex)&&my<=min(sy,ey)&&My>=max(sy,ey)){ans=0;/*cout<<\"tutumu ans=0\"<<endl;*/}\n\t\t\telse if(insected(s,e,a,b)||insected(s,e,b,c)||insected(s,e,c,d)||insected(s,e,d,a)){ans=0;/*cout<<\"majiwaru ans=0\"<<\" \"<<insected(s,e,a,b)<<\" \"<<insected(s,e,b,c)<<\" \"<<insected(s,e,c,d)<<\" \"<<insected(s,e,d,a)<<endl;*/}\n\t\t\telse{\n\t\t\t\tdouble D=1e9;\n\t\t\t\tif(Mx<=min(sx,ex)){\n\t\t\t\t\tif(my<=sy&&sy<=My)D=min(D,sx-Mx);\n\t\t\t\t\tif(my<=ey&&ey<=My)D=min(D,ex-Mx);\n\t\t\t\t}\n\t\t\t\tif(mx>=max(sx,ex)){\n\t\t\t\t\tif(my<=sy&&sy<=My)D=min(D,mx-sx);\n\t\t\t\t\tif(my<=ey&&ey<=My)D=min(D,mx-ex);\n\t\t\t\t}\n\t\t\t\tif(My<=min(sy,ey)){\n\t\t\t\t\tif(mx<=sx&&sx<=Mx)D=min(D,sy-My);\n\t\t\t\t\tif(mx<=ex&&ex<=Mx)D=min(D,ey-My);\n\t\t\t\t}\n\t\t\t\tif(my>=max(sy,ey)){\n\t\t\t\t\tif(mx<=sx&&sx<=Mx)D=min(D,my-sy);\n\t\t\t\t\tif(mx<=ex&&ex<=Mx)D=min(D,my-ey);\n\t\t\t\t}\n\t\t\t\tD=min(D,min(dist(s,e,a),min(dist(s,e,b),min(dist(s,e,c),dist(s,e,d)))));\n\t\t\t\tif(h>D){ans=min(ans,D);cout<<D<<endl;}\n\t\t\t\telse {/*cout<<\"MIN\"<<ans<<\" \";*/ans=min(ans,(D*D+h*h)/2/h);/*cout<<(D*D+h*h)/2/h<<endl;*/}\n\t\t\t\t//cout<<\"ans\"<<ans<<endl;\n\t\t\t}\n\t\t}\n\t\tfprintf(out1157,\"%.4f\\n\",ans);\n\t}\n\t//fclose(out1157);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v, y, m; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\ndouble g(double x, double y, int _x, int _y) {\n\tdouble dx = x - _x, dy = y - _y;\n\treturn sqrt(dx * dx + dy * dy);\n}\n\ndouble f(double x, double y, int l, int u, int r, int d) {\n\tdouble mini;\n\tbool fx = (x >= l && x <= r), fy = (y >= u && y <= d);\n\tif (fx && fy) mini = 0;\n\tif (fx && !fy) mini = min(abs(y - u), abs(y - d));\n\tif (!fx && fy) mini = min(abs(x - l), abs(x - r));\n\tif (!fx && !fy) mini = DBL_MAX;\n\tmini = min(mini, g(x, y, l, u));\n\tmini = min(mini, g(x, y, l, d));\n\tmini = min(mini, g(x, y, r, u));\n\tmini = min(mini, g(x, y, r, d));\n\treturn mini;\n}\n\nint main() {\n\tfor (;;) {\n\t\tint N, sx, sy, ex, ey;\n\t\tcin >> N >> sx >> sy >> ex >> ey;\n\t\tif (N == 0) break;\n\t\tvector<int> l(N), u(N), r(N), d(N), h(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> l[i] >> u[i] >> r[i] >> d[i] >> h[i];\n\t\tdouble ub = DBL_MAX;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdouble ax = sx, ay = sy, bx = ex, by = ey, mini = DBL_MAX;\n\t\t\tfor (int t = 0; t < 100; t++) {\n\t\t\t\tdouble cx = (ax * 2 + bx) / 3, cy = (ay * 2 + by) / 3;\n\t\t\t\tdouble dx = (ax + bx * 2) / 3, dy = (ay + by * 2) / 3;\n\t\t\t\tdouble cf = f(cx, cy, l[i], u[i], r[i], d[i]);\n\t\t\t\tdouble df = f(dx, dy, l[i], u[i], r[i], d[i]);\n\t\t\t\tif (cf < df) { bx = dx; by = dy; mini = cf; }\n\t\t\t\telse {ax = cx; ay = cy; mini = df; }\n\t\t\t}\n\t\t\tdouble r;\n\t\t\tif (mini <= h[i]) r = mini;\n\t\t\telse r = (h[i] * h[i] + mini * mini) / (h[i] * 2);\n\t\t\tub = min(ub, r);\n\t\t}\n\t\tprintf(\"%.10f\\n\", ub);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\n\n#define EPSILON 1e-9\n\n\nclass point_t;\n\n\nclass vector_t {\npublic:\n  double x;\n  double y;\n  double z;\n  \npublic:\n  vector_t(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) {};\n  \n  vector_t(const point_t& p);\n  \npublic:\n  vector_t operator-() const {\n    return vector_t(-x, -y, -z);\n  };\n  \n  double operator*(const vector_t& v) const {\n    return x * v.x + y * v.y + z * v.z;\n  };\n  \n  vector_t operator*(double a) const {\n    return vector_t(x * a, y * a, z * a);\n  };\n  \n  vector_t operator/(double a) const {\n    return vector_t(x / a, y / a, z / a);\n  };\n  \n  vector_t operator^(const vector_t& v) const {\n    return vector_t(y * v.z - z * v.y,\n                    z * v.x - x * v.z,\n                    x * v.y - y * v.x);\n  };\n    \n  vector_t operator-=(const vector_t& v) {\n    x -= v.x;\n    y -= v.y;\n    z -= v.z;\n    \n    return *this;\n  };\n\npublic:\n  double length() const {\n    return sqrt(*this * *this);\n  };\n\n  vector_t normal() const {\n    return *this / length();\n  };\n};\n\n\nclass point_t {\npublic:\n  double x;\n  double y;\n  double z;\n  double w;\n\npublic:\n  point_t(double x = 0, double y = 0, double z = 0, double w = 1) : x(x), y(y), z(z), w(w) {};\n  \npublic:\n  point_t operator+(const vector_t& v) const {\n    return point_t(x + v.x, y + v.y, z + v.z);\n  };\n\n  vector_t operator-(const point_t& p) const {\n    return vector_t(x - p.x, y - p.y, z - p.z);\n  };\n};\n\n\nvector_t::vector_t(const point_t& p) : x(p.x / p.w), y(p.y / p.w), z(p.z / p.w)\n{\n}\n\n\nclass point_point_squared_distance : public std::unary_function<point_t, double>\n{\npublic:\n  point_point_squared_distance(const point_t& p) : p_(p)\n  {\n  };\n\npublic:\n  double operator()(const point_t& p) const {\n    vector_t v(p - p_);\n\n    return v * v;\n  };\n\nprivate:\n  point_t p_;\n};\n\n\nclass point_segment_squared_distance : public std::unary_function<point_t, double> {\npublic:\n  point_segment_squared_distance(const point_t& p0, const point_t& p1) :\n    p0_(p0), a_(p1 - p0)\n  {\n    aa_ = a_ * a_;\n  };\n\npublic:\n  double operator()(const point_t& p) const {\n    vector_t b(p - p0_);\n\n    double dot = (a_ * b) / aa_;\n\n    if (dot < 0) {\n      return b * b;\n    }\n    else if (dot > 1) {\n      b -= a_;\n\n      return b * b;\n    }\n    else {\n      vector_t area(a_ ^ b);\n\n      return area * area / aa_;\n    }\n  };\n\nprivate:\n  point_t p0_;\n\n  vector_t a_;\n\n  double aa_;\n};\n\n\nclass segment_segment_squared_distance : public std::binary_function<point_t, point_t, double>\n{\npublic:\n  segment_segment_squared_distance(const point_t& p0, const point_t& p1) :\n    p0_(p0), p1_(p1), fn_(p0, p1)\n  {\n  };\n\npublic:\n  double operator()(const point_t& p2, const point_t& p3) const {\n    point_segment_squared_distance fn(p2, p3);\n\n    double d;\n\n    d = std::min(fn_(p2),  fn_(p3));\n    d = std::min(fn (p0_), d); \n    d = std::min(fn (p1_), d); \n\n    return d;\n  };\n\nprivate:\n  point_t p0_;\n  point_t p1_;\n\n  point_segment_squared_distance fn_;\n};\n\nclass segment_segment_distance : public std::binary_function<point_t, point_t, double>\n{\npublic:\n  segment_segment_distance(const point_t& p0, const point_t& p1) : fn_(p0, p1)\n  {\n  };\n\npublic:\n  double operator()(const point_t& p2, const point_t& p3) const {\n    return sqrt(fn_(p2, p3));\n  };\n\nprivate:\n  segment_segment_squared_distance fn_;\n};\n\n\nclass segment_segment_intersect : public std::binary_function<point_t, point_t, bool>\n{\npublic:\n  segment_segment_intersect(const point_t& p0, const point_t& p1) : p0_(p0), p1_(p1)\n  {\n  };\n\npublic:\n  bool operator()(const point_t& p2, const point_t& p3) {\n    bool a = (((p1_ - p0_) ^ (p2  - p0_)).z > -EPSILON);\n    bool b = (((p1_ - p0_) ^ (p3  - p0_)).z > -EPSILON);\n    bool c = (((p3  - p2 ) ^ (p0_ - p2 )).z > -EPSILON);\n    bool d = (((p3  - p2 ) ^ (p1_ - 02 )).z > -EPSILON);\n\n    return (a ^ b) && (c ^ d);\n  };\n\nprivate:\n  point_t p0_;\n  point_t p1_;\n};\n\n\nint main(int argc, char** argv)\n{\n  while (1) {\n    int N;\n\n    std::cin >> N;\n\n    if (N == 0)\n      break;\n\n    point_t s, e;\n\n    std::cin >> s.x >> s.y >> e.x >> e.y;\n\n    std::vector<std::pair<point_t, point_t> > segments;\n    std::vector<double>                       hs;\n    \n    for (int i = 0; i < N; i ++) {\n      point_t pm, pp;\n      double  h;\n\n      std::cin >> pm.x >> pm.y >> pp.x >> pp.y >> h;\n\n      point_t p1(pm.x, pm.y);\n      point_t p2(pp.x, pm.y);\n      point_t p3(pp.x, pp.y);\n      point_t p4(pm.x, pp.y);\n\n      segments.push_back(std::make_pair(p1, p2)); hs.push_back(h);\n      segments.push_back(std::make_pair(p2, p3)); hs.push_back(h);\n      segments.push_back(std::make_pair(p3, p4)); hs.push_back(h);\n      segments.push_back(std::make_pair(p4, p1)); hs.push_back(h);\n    }\n\n    segment_segment_intersect fn1(s, e);\n    segment_segment_distance  fn2(s, e);\n\n    double l = 0, u = 1111;\n\n    for (int i = 0; i < N * 4; i ++)\n      if (fn1(segments[i].first, segments[i].second)) {\n        u = 0;\n\n        break;\n      }\n\n    while (u - l > 1e-12) {\n      double m = (l + u) / 2;\n\n      bool conflict = false;\n\n      for (int i = 0; i < N * 4; i ++) {\n        double d = fn2(segments[i].first, segments[i].second);\n\n        if (d < m)\n          conflict = (m - sqrt(m * m - d * d) < hs[i]);\n\n        if (conflict)\n          break;\n      }\n\n      if (conflict) {\n        u = m;\n      }\n      else {\n        l = m;\n      }\n    }\n\n    std::cout << std::setprecision(13) << (l + u) / 2 << std::endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\ntypedef complex<double> point;\ntypedef pair<point, point> line;\n\n//b??????a??????????????????\ndouble dis(point a, point b){\n  return abs(a - b);\n}\n\n//??????\ndouble dot(point a, point b){\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\n//??????\ndouble cross(point a, point b){\n  return imag(conj(a) * b);\n}\n\n//counter clock wise\nint ccw(point a, point b, point c){\n  if(cross(b - a, c - a) >  eps)return  1;//??????ab????????´\n  if(cross(b - a, c - a) < -eps)return -1;//??????ab????????´\n  if(dot(b - a, c - a) < -eps)return 2;//??´???ab??????a???????????????\n  if(abs(b - a) + eps < abs(c - a))return -2;//??´???ab??????b???????????????\n  return 0;//??´???ab???\n}\n\ndouble line_to_point_dis(line l, point p){\n  return abs(cross(p - l.first, l.second - l.first))/\n    abs(l.second - l.first);\n}\n\ndouble seg_to_point_dis(line l, point p){\n  point a = l.first, b = l.second, c = p;\n  if(dot(b - a, c - a) < eps)return abs(c - a);\n  if(dot(a - b, c - b) < eps)return abs(c - b);\n  return line_to_point_dis(l, p);\n}\n\nbool is_cross(line a, line b){\n  if(ccw(a.first, a.second, b.first) *\n     ccw(a.first, a.second, b.second) <= 0 &&\n     ccw(b.first, b.second, a.first) *\n     ccw(b.first, b.second, a.second) <= 0){\n    return true;\n  }\n  return false;\n}\n\ndouble seg_to_seg_dis(line a, line b){\n  if(is_cross(a, b))return 0;\n  double res = seg_to_point_dis(a, b.first);\n  res = min(res, seg_to_point_dis(a, b.second));\n  res = min(res, seg_to_point_dis(b, a.first));\n  res = min(res, seg_to_point_dis(b, a.second));\n  return res;\n}\n\n\npoint cross_point(line a, line b){\n  double d1 = cross(b.second - b.first,\n                    b.first - a.first);\n  double d2 = cross(b.second - b.first,\n                    a.second - a.first);\n  return a.first + (a.second - a.first) * d1/d2;\n}\n\npair<point, point> norm(point p){\n  return pair<point, point>(p*point(0, 1),\n                            p*point(0, -1));\n}\n\ntypedef struct rectangle{\n  rectangle(){};\n  rectangle(point _a, point _b, int _h){\n    a = _a, b = _b, h = _h;\n    double x[] = {a.real(), a.real(), b.real(), b.real()};\n    double y[] = {a.imag(), b.imag(), b.imag(), a.imag()};\n    for (int i = 0; i < 4; i++) {\n      point u = point(x[i], y[i]),\n        v = point(x[(i+1)%4], y[(i+1)%4]);\n      l.emplace_back(line(u, v));\n    }\n  }\n  point a, b;\n  vector<line> l;\n  double h;\n}rectangle;\n\nvector<rectangle> vr;\n\nbool renge(point a, point b, point c){\n  return (a.real() <= c.real() and c.real() <= b.real() and\n          a.imag() <= c.imag() and c.imag() <= b.imag());\n}\n\nbool is_ok(line l, double h){\n  point s = l.first, e = l.second;\n  for (int i = 0; i < vr.size(); i++) {\n    double mh = min(h, vr[i].h);\n    double dist = 1e9;\n    for (int j = 0; j < 4; j++) {\n      dist = min(dist, seg_to_seg_dis(l, vr[i].l[j]));\n    }\n    double theta = acos((h - mh)/h);\n    double r = h*sin(theta);\n    if(renge(vr[i].a, vr[i].b, s) and\n       renge(vr[i].a, vr[i].b, e))return false;\n    if(r > dist)return false;\n  }\n  return true;\n}\n  \nint main(){\n  int n, sx, sy, ex, ey;\n  while(std::cin >> n, n){\n    vr.clear();\n    std::cin >> sx >> sy >> ex >> ey;\n    point s = point(sx, sy), e = point(ex, ey);\n    for (int i = 0; i < n; i++) {\n      double minx, miny, maxx, maxy, h;\n      std::cin >> minx >> miny >> maxx >> maxy >> h;\n      rectangle r(point(minx, miny), point(maxx, maxy), h);\n      vr.emplace_back(r);\n    }\n    double l = 0, r = 1000, mid = (l + r)/2;\n    for (int i = 0; i < 500; i++) {\n      if(is_ok(line(s, e), mid)){\n        l = mid;\n      }else{\n        r = mid;\n      }\n      mid = (l + r)/2;\n    }\n    if(mid > eps)printf(\"%.10lf\\n\", mid);\n    else std::cout << 0 << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS 1e-10\n#define EQ(a,b) (abs(a - b) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n//外積\ndouble cross (P a, P b) {return (a.real() * b.imag() - a.imag() * b.real());}\n\n//内積\ndouble dot (P a, P b) {return (a.real() * b.real() + a.imag() * b.imag());}\n\n//直行\nbool is_orthogonal(P a1, P a2, P b1, P b2) {return EQ( dot(a1 - a2, b1 - b2), 0.0);}\n\n//平行\nbool is_parallel(P a1, P a2, P b1, P b2) {return EQ( cross(a1 - a2, b1 - b2), 0.0);}\n\n//直線上\nbool is_point_on_vector(P a, P b, P c) {return EQ( cross(a - c, c - b), 0.0);}\n\n//線分上\nbool is_point_on_line (P a, P b, P c) {return (abs(a - c) + abs(c - b) < abs(a - b) + EPS);}\n\n//角度　線分の距離は小数点以下３桁まで\ndouble angle (P a, P b, P p) {return (acos(dot(a-p,b-p) / (abs(a-p) * abs(b-p))) * 180.0 / M_PI);}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_l(P a1, P a2, P b1, P b2) {return !EQ( cross(a1-a2, b1-b2), 0.0 );}\n\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {return abs(cross(b-a, c-a)) / abs(b-a);}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2 - a1; P b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n    if ( dot(b-a, c-a) < EPS ) return fabs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return fabs(c-b);\n    return fabs(cross(b-a, c-a)) / fabs(b-a);\n}\n\n/***************************************\n *\n * 2点を通る直線とある点からの垂線との交点\n *\n * a, b を直線\n * p    をある点\n *\n ***************************************/\nP crossNormalVector (P a, P b, P p) {\n    double t = dot(b-a, p-a) / (abs(b-a) * abs(b - a));\n    return a + t * (b - a);\n}\n\ndouble calc (double h, double r) {\n    if (h > r) h = r;\n    return (r * r + h * h) / (2 * h);\n}\n\nint main ()\n{\n    int n;\n    while (cin >> n, n) {\n        double sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        P s(sx, sy), e(ex, ey);\n\n        double res_h = 100000.;\n        while (n--) {\n            // cout << \"Count # \" << n << endl;\n            \n            double minx, miny, maxx, maxy;\n\n            double h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            vector<P> v = { P(minx, miny), P(minx, maxy), P(maxx, maxy), P(maxx, miny)};\n\n            if (minx <= s.real() && s.real() <= maxx && miny <= s.imag() && s.imag() <= maxy) res_h = 0.;\n            if (minx <= e.real() && e.real() <= maxx && miny <= e.imag() && e.imag() <= maxy) res_h = 0.;\n\n            for (int i = 0; i < 4; i++) {\n                int anf = (i + 1) % 4, bfr = (i + 4 - 1) % 4;\n                int now = i;\n\n                if (is_intersected_ls(e, s, v[now], v[anf])) res_h = 0.;\n                if (is_intersected_ls(e, s, v[now], v[bfr])) res_h = 0.;\n                \n                // cout << \"DBG > \" << min(v[now].real(), v[anf].real()) << \" \" << max(v[now].real(), v[anf].real()) << endl;\n                // cout << \"      \" << min(v[now].imag(), v[anf].imag()) << \" \" << max(v[now].imag(), v[anf].imag()) << endl;\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[anf], s)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[bfr], s)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[anf], e)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[bfr], e)));\n                // res_h = min(res_h, calc(h, min(abs(minx - s.real()), abs(maxx - s.real()))));\n                // res_h = min(res_h, calc(h, min(abs(miny - s.imag()), abs(maxy - s.imag()))));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[now])));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[anf])));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[bfr])));\n            }\n        }\n\n        printf(\"%.6f\\n\", res_h);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n\ntypedef complex<double> P;\ntypedef vector<P> G;\ndouble const inf=1e10;\ndouble const eps=1e-8;\n\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n};\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;\n    if (cross(b, c) < 0)   return -1;\n    if (dot(b, c) < 0)     return +2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\nbool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < eps; // triangle inequality\n}\n\nbool intersectRS(const G &r, const L &l){\n    if(r[0].real()<=l[0].real() && l[0].real()<=r[2].real() &&\n       r[0].imag()<=l[0].imag() && l[0].imag()<=r[2].imag() &&\n       r[0].real()<=l[1].real() && l[1].real()<=r[2].real() &&\n       r[0].imag()<=l[1].imag() && l[1].imag()<=r[2].imag()){\n        return true;\n    }\n    rep(i,4){\n        L m(r[i],r[(i+1)%4]);\n        if(intersectSS(l,m)) return true;\n    }\n    return false;\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nint n;\nL l{0,0};\nvector<G> rs;\nvd hs;\nvvd d;\n\ndouble maxr(P p, G const& rect, double h){\n    double res=inf;\n    rep(i,4){\n        double d=distanceSP({rect[i],rect[(i+1)%4]},p);\n        if(d<h){\n            res=min(res,d);\n        }else{\n            res=min(res,(d*d+h*h)/(2*h));\n        }\n    }\n    // printf(\" %lf\\n\",res);\n    return res;\n}\n\ndouble solve(){\n    double ans=inf;\n    rep(i,n){\n        if(intersectRS(rs[i],l)) return 0;\n        rep(j,4){\n            P prj = projection(l,rs[i][j]);\n            if(!intersectSP(l,prj)) continue;\n            ans=min(ans, maxr(prj,rs[i],hs[i]));\n        }\n        // printf(\" %lf\\n\",ans);\n        ans=min(ans,maxr(l[0],rs[i],hs[i]));\n        ans=min(ans,maxr(l[1],rs[i],hs[i]));\n    }\n    return ans;\n}\n\nint main(){\n    while(cin>>n && n){\n        double sx,sy,ex,ey;\n        cin >> sx>>sy>>ex>>ey;\n        l = L{P(sx,sy),P(ex,ey)};\n        rs.resize(n);\n        hs.resize(n);\n        rep(i,n){\n            double mx,my,Mx,My;\n            cin>>mx>>my>>Mx>>My >> hs[i];\n            rs[i] = {P(mx,my),P(Mx,my),P(Mx,My),P(mx,My)};\n        }\n        printf(\"%.5lf\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/**************** Geometrical Library ****************/\n\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define\tEPS\t1e-9\n\nenum {CCW=1,CW=-1,ON=0};\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy):x(xx),y(yy){}\n};\n\nclass Line:public vector<Point>{\npublic:\n\tLine(const Point &a,const Point &b){\n\t\tpb(a),pb(b);\n\t}\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\nclass Polygon:public vector<Point>{};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &cc,double rr):c(cc),r(rr){}\n};\n\nPoint &operator +=(Point &a,const Point &b){\n\ta.x+=b.x,a.y+=b.y;\n\treturn a;\n}\n\nPoint &operator -=(Point &a,const Point &b){\n\ta.x-=b.x,a.y-=b.y;\n\treturn a;\n}\n\nPoint &operator *=(Point &a,double c){\n\ta.x*=c,a.y*=c;\n\treturn a;\n}\n\nPoint &operator /=(Point &a,double c){\n\ta.x/=c,a.y/=c;\n\treturn a;\n}\n\nPoint operator +(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c+=b;\n}\n\nPoint operator -(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c-=b;\n}\n\nPoint operator *(double c,const Point &a){\n\tPoint b=a;\n\treturn b*=c;\n}\n\nPoint operator /(const Point &a,double c){\n\tPoint b=a;\n\treturn b/=c;\n}\n\nbool operator <(const Point &a,const Point &b){\n\treturn (a.x==b.x)?(a.y<b.y):(a.x<b.x);\n}\n\nbool operator >(const Point &a,const Point &b){\n\treturn b<a;\n}\n\ndouble dot(const Point &a,const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble norm2(const Point &a){\n\treturn dot(a,a);\n}\n\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)\t\treturn CCW;\n\tif(rotdir<-EPS)\t\treturn CW;\n\treturn ON;\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\t// l : ax+by+c=0\n\ta=l[0].y-l[1].y;\n\tb=l[1].x-l[0].x;\n\tc=l[0].x*l[1].y-l[1].x*l[0].y;\n}\n\nPoint perp_foot(const Point &p,const Line &l){\n\tdouble a,b,c;\n\tcalc_abc(l,a,b,c);\n\treturn p-(a*p.x+b*p.y+c)/(a*a+b*b)*Point(a,b);\n}\n\nbool intersect(const Line &l,const Line &m,Point *p=NULL){\n\t// this routine also returns true in case \"M is on L\", etc,.\n\tif(abs(cross(l[1]-l[0],m[1]-m[0]))>EPS\n\t|| abs(cross(l[1]-l[0],m[0]-l[0]))<EPS){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(l,a1,b1,c1);\n\t\t\tcalc_abc(m,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS)\t*p=l[0];\t// l == m\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool intersect(const Segment &s,const Segment &t,Point *p=NULL){\n\tif(max(s[0].x,s[1].x)<min(t[0].x,t[1].x)\n\t|| max(t[0].x,t[1].x)<min(s[0].x,s[1].x)\n\t|| max(s[0].y,s[1].y)<min(t[0].y,t[1].y)\n\t|| max(t[0].y,t[1].y)<min(s[0].y,s[1].y))\treturn false;\n\n\tif(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(s,a1,b1,c1);\n\t\t\tcalc_abc(t,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS){\t// s is parallel to t\n\t\t\t\tPoint q[3]={s[0],s[1],t[0]};\n\t\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\t\tif(dot(q[i]-s[0],q[i]-s[1])<EPS && dot(q[i]-t[0],q[i]-t[1])<EPS){\n\t\t\t\t\t\t*p=q[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**************** Library END ****************/\n\n#include<cstdio>\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint sx,sy,gx,gy;\nif(scanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy)==EOF)break;\n\t\tPoint s(sx,sy),g(gx,gy);\n\t\tSegment course(s,g);\n\n\t\tdouble rmin=1e30;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint ox1,oy1,ox2,oy2,h;\n\t\t\tscanf(\"%d%d%d%d%d\",&ox1,&oy1,&ox2,&oy2,&h);\n\t\t\tPoint obj[2];\n\t\t\tobj[0]=Point(ox1,oy1),obj[1]=Point(ox2,oy2);\n\n\t\t\tbool oncourse=false;\n\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<2;k++){\t// cross course x object\n\t\t\t\tSegment edge(Point(obj[j].x,obj[k].y),Point(obj[k].x,obj[1-j].y));\n\t\t\t\tif(intersect(course,edge)){ oncourse=true; break; }\n\t\t\t}\n\t\t\tfor(int l=0;l<2;l++){\t// course in object\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<2;k++){\n\t\t\t\t\tSegment edge(Point(obj[j].x,obj[k].y),Point(obj[k].x,obj[1-j].y));\n\t\t\t\t\tcnt+=ccw(edge[0],edge[1],course[l]);\n\t\t\t\t}\n\t\t\t\tif(cnt==4*CCW || cnt==4*CW){ oncourse=true; break; }\n\t\t\t}\n\t\t\tif(oncourse){ rmin=0; break; }\n\n\t\t\tdouble d2min=1e30;\n\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<2;k++){\n\t\t\t\tPoint u=Point(obj[j].x,obj[k].y);\n\t\t\t\tPoint v=perp_foot(u,Line(course[0],course[1]));\n\t\t\t\tif(dot(v-course[0],v-course[1])<EPS){\t// v is on course\n\t\t\t\t\tdouble d2=norm2(v-u);\n\t\t\t\t\td2min=min(d2min,d2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<2;k++){\n\t\t\t\t\tSegment edge(Point(obj[j].x,obj[k].y),Point(obj[k].x,obj[1-j].y));\n\t\t\t\t\tPoint v=perp_foot(course[l],Line(edge[0],edge[1]));\n\t\t\t\t\tif(dot(v-edge[0],v-edge[1])<EPS){\n\t\t\t\t\t\tdouble d2=norm2(v-course[l]);\n\t\t\t\t\t\td2min=min(d2min,d2);\n\t\t\t\t\t}\n\n\t\t\t\t\tPoint u=Point(obj[j].x,obj[k].y);\n\t\t\t\t\td2min=min(d2min,norm2(u-course[l]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble r;\n\t\t\tif(h*h<d2min)\tr=(d2min+h*h)/(2*h);\n\t\t\telse\tr=sqrt(d2min);\n\t\t\trmin=min(rmin,r);\n\t\t}\n\n\t\tprintf(\"%f\\n\",rmin);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stdlib.h>\n#include <string.h>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble EPS = 0;\n\ntypedef struct {\n\tP s,e;\n\tdouble h;\n}RECT;\n\nvoid P_cin(P& p){\n\tdouble x,y;\n\tcin >> p.real() >> p.imag();\n}\ndouble dot(P a,P b){ return a.real() * b.real() + a.imag() * b.imag(); }\ndouble cross(P a,P b){ return a.real() * b.imag() - a.imag() * b.real(); } \n\ndouble distance_lp(P& s,P& e,P &p){\n\tif(dot(e-s,p-s) < EPS) return abs(p-s); //_sÆÌ£\n\tif(dot(s-e,p-e) < EPS) return abs(p-e); //_eÆÌ£\n\treturn abs(cross(e-s,p-s)) / abs(e-s); //_Æ¼üÆÌ£\n}\n\nbool is_intersected_ls(P& a1, P& a2, P& b1, P& b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nbool is_contained(P& a,P& b,P& p){\n\treturn (a.real() <= p.real() && p.real() <= b.real()) &&\n\t\t(a.imag() <= p.imag() && p.imag() <= b.imag());\n}\n\ndouble distance_rl(P& a,P& b,P& s,P& e){\n\tif(is_contained(a,b,s) || is_contained(a,b,e))\n\t\treturn 0.0; //R[X©Ìª ÉüÁÄé\n\n\tdouble len = 1e10;\n\tP rectP[] = {a,P(a.real(),b.imag()),b,P(b.real(),a.imag())};\n\tfor(int i = 0; i < 4; i++){\n\t\tif(is_intersected_ls(s,e,rectP[i],rectP[(i+1)%4])) return 0.0; //üªªdÈÁ½I\n\t\tlen = min(len,distance_lp(rectP[i],rectP[(i+1)%4],s));\n\t\tlen = min(len,distance_lp(rectP[i],rectP[(i+1)%4],e));\n\t\tlen = min(len,distance_lp(e,s,rectP[i]));\n\t}\n\n\treturn len;\n}\n\ndouble distance(RECT &r,P& s,P& e){\n\tdouble len = distance_rl(r.s,r.e,s,e);\n\tif(len <= r.h) return len; //cÉ¢\n\treturn (r.h + len * len / r.h) / 2; //cÌûªá¢ÌÅvZ·é\n}\n\nint N;\n\nvoid solve(){\n\n\tP s,e;\n\tP_cin(s);\n\tP_cin(e);\n\n\tvector<RECT> rects(N);\n\tfor(int i = 0; i < N; i++){\n\t\tRECT &r = rects[i];\n\t\tP_cin(r.s);\n\t\tP_cin(r.e);\n\t\tcin >> r.h;\n\t}\n\t\n\tdouble ans = 1e10;\n\tfor(int i = 0; i < N; i++){\n\t\tans = min(ans,distance(rects[i],s,e));\n\t}\n\n\tcout << ans << endl;\n}\n\nint main()\n{\n\twhile(cin >> N,N){\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-8, PI = acos(-1);\n \ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nnamespace Geometory { // Geometory Library\n  struct Point {\n    double x, y;\n    Point(){};\n    Point(double x,double y):x(x),y(y){};\n    Point operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n    Point operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n    Point operator*(const double b) const { return Point(x * b,y * b); }\n    Point operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n    Point operator/(const double b) const { return Point(x / b,y / b); }\n    bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y;}\n    bool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n    double norm(){ return x * x + y * y; }\n    double arg(){ return atan2(x,y); }\n    double abs(){ return sqrt(norm()); }\n    Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n    Point rotate90(){ return Point(-y,x); }\n    friend ostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\n    friend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n  };\n    \n  struct Line {\n    Point a, b;\n    Line(){};\n    Line(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Line& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Line& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Segment {\n    Point a, b;\n    Segment(){};\n    Segment(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Segment& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Segment& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Circle {\n    Point p; double r;\n    Circle(){};\n    Circle(Point p, double r) : p(p),r(r){};\n  };\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n    \n  double cross(const Point& a,const Point& b){\n    return a.x * b.y - a.y * b.x;\n  }\n  double dot(const Point& a,const Point& b){\n    return a.x * b.x + a.y * b.y;\n  }\n    \n  int ccw(const Point& a,Point b,Point c){\n    b = b - a, c = c - a;\n    if(cross(b,c) > EPS)    return +1;  // a ??? b ??§ ???????¨??????????????????? c\n    if(cross(b,c) < -EPS)    return -1; // a ??? b ??§ ????¨??????????????????? c\n    if(dot(b,c) < 0)      return +2;  // c -- a -- b??§?????´??????\n    if(b.norm() < c.norm()) return -2; // a -- b -- c??§?????´??????\n    return 0;  // a -- c -- b??§?????´??????\n  }\n  Point Projection(const Line& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Projection(const Segment& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Reflection(const Line& l, const Point& p){\n    return p + (Projection( l, p) - p) * 2.0;\n  }\n    \n  double Distance( const Line& l,const Point& p) { //OK\n    return (p - Projection( l, p)).abs();\n  }\n    \n  bool Intersect(const Line& l, const Line& m){\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;\n  }\n  bool Intersect(const Line& l, const Segment& s){\n    return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;\n  }\n  bool Intersect(const Line& l, const Point& p){\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n  bool Intersect(const Segment& s, const Segment& t){\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n  bool Intersect(const Segment& s, const Point& p){\n    return ccw(s.a, s.b, p) == 0;\n  }\n  bool Intersect(const Circle& c,const Line& l){\n    return Distance( l, c.p) <= c.r + EPS;\n  }\n  bool Intersect(const Circle& c,const Point& p){\n    return abs( ( p - c.p).abs() - c.r ) < EPS;\n  }\n  int Intersect(const Circle& c, const Segment& l){\n    if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();\n    if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if( d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n    const Point h = Projection( l, c.p);\n    if( dot( l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n  bool Intersect(const Circle& a,const Circle& b){\n    return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n      ( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n  }\n  double Distance(const Segment& s,const Point& p){\n    Point r = Projection(s, p);\n    if ( Intersect( s, r)) return ( r - p).abs();\n    return min( ( s.a - p).abs(), ( s.b - p).abs());\n  }\n  double Distance(const Segment& a,const Segment& b){\n    if(Intersect( a, b)) return 0;\n    return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));\n  }\n  double Distance(const Line& l,const Line& m) {\n    return Intersect( l, m) ? 0 : Distance( l, m.a);\n  }\n  double Distance(const Line& l,const Segment& s) { //OK\n    if (Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n  double Distance(const Point& a,const Point& b){ //OK\n    return ( a - b).abs();\n  }\n  Point Crosspoint(const Segment& l,const Segment& m) { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n  PointPoint Crosspoint(const Circle& c,const Line l){\n    Point hp = Projection( l, c.p), h =  hp - c.p;\n    const double d2 = h.norm();\n    Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n  PointPoint Crosspoint(const Circle& c,const Segment& l) {\n    Line aa = Line( l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n  PointPoint Crosspoint(const Circle& c1,const Circle& c2){ //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n    double h = 2 * S / d;\n    Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();\n    double m = sqrt( c1.r * c1.r - h * h);\n    return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);\n  }\n  bool parallel(const Line& a,const Line& b){\n    return abs(cross( a.b - a.a, b.b - b.a)) < EPS;\n  }\n  bool orthogonal(const Line& a,const Line& b){\n    return abs(dot( a.a - a.b, b.a - b.b)) < EPS;\n  }\n  int Contains(const Polygon& Q,const Point& p){\n    bool in = false;\n    for(int i = 0 ; i < Q.size() ; i++ ){\n      Point a = curr(Q,i) - p, b = next(Q,i) - p;\n      if(a.y > b.y) swap(a,b);\n      if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;\n      if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n  bool Contains(const Circle& c,const Point& p){\n    return ( c.p - p).abs() < c.r + EPS;\n  }\n  double Area2(const Polygon& p){ //OK\n    double A = 0;\n    for (int i = 0; i < p.size(); ++i){\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n  bool IsConvex(const Polygon& p){\n    for(int i = 0; i < p.size(); i++){\n      if(ccw(prev(p,i),curr(p,i),next(p,i)) == -1) return false;\n    }\n    return true;\n  }\n  Polygon Convex_Hull(Polygon& p){\n    int n = p.size(), k = 0;\n    if(n >= 3){\n      sort( p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]){\n        while(k >= 2 && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]){\n        while(k >= t && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize( k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n  double Convex_Diameter(Polygon& p){\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = ( p[is] - p[js]).norm();\n  \n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross( next( p, i) - curr( p, i), next( p, j) - curr( p, j)) >= 0){\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if(( p[i] - p[j]).norm() > maxdis){\n        maxdis = ( p[i] - p[j]).norm();\n        maxi = i; maxj = j;\n      }\n    }  while (i != is || j != js);\n    return maxdis;\n  }\n};\ntypedef Geometory::Point Point;\ntypedef Geometory::Line Line;\ntypedef Geometory::Segment Segment;\ntypedef Geometory::Circle Circle;\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    int sx, sy, tx, ty;\n    double ret = 1e9;\n    Segment data[4];\n\n    cin >> sx >> sy >> tx >> ty;\n    Segment Line = (Segment){Point(sx, sy), Point(tx, ty)};\n    while(N--) {\n      int minx, miny, maxx, maxy, h;\n      cin >> minx >> miny >> maxx >> maxy >> h;\n      data[0] = Segment(Point(minx, miny),Point(maxx, miny));\n      data[1] = Segment(Point(minx, maxy),Point(minx, miny));\n      data[2] = Segment(Point(maxx, maxy),Point(minx, maxy));\n      data[3] = Segment(Point(maxx, maxy),Point(maxx, miny));\n\n      if(minx <= min(sx, tx) && maxx >= max(sx, tx) && miny <= min(sy, ty) && maxy >= max(sy, ty)) {\n        ret = 0;\n      } else {\n        for(int i = 0; i < 4; i++) {\n          double d = Distance(Line, data[i]);\n          if(d <= h) ret = min(ret, d);\n          else ret = min(ret, (d * d + h * h) / (2.0 * h));\n        }\n      }\n    }\n    cout << fixed << setprecision(10) << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\nconst double EPS = 1e-8;\n\n\ntemplate<class T> bool eq(T a, T b) { return abs(a - b) < EPS; }\n// point ??? complex<double> ??§???????????????????????????\n#define CPR const Point&\nstruct Point {\n    using T = double;    \n    T x, y;\n    Point() {}\n    Point(T x, T y):x(x), y(y) {}\n    bool operator == (CPR p) const { return eq(x, p.x) and eq(y, p.y); }\n    bool operator != (CPR p) const { return !(*this == p); }    \n    Point operator + (CPR p) const { return Point(x + p.x, y + p.y); }\n    Point operator - (CPR p) const { return *this + (-p); }\n    // x, y ???\n    bool operator <  (CPR p) const { return !eq(x, p.x) ? x < p.x : y < p.y; }\n    bool operator >  (CPR p) const { return !eq(x, p.x) ? x > p.x : y > p.y; }\n    Point operator - () const { return Point(-x, -y); }\n    Point operator * (T k) const { return Point(x * k, y * k); }\n    Point operator / (T k) const { return Point(x / k, y / k); }\n    friend istream &operator >> (istream& is, Point& p) { return is >> p.x >> p.y;}\n    friend ostream &operator << (ostream& os, CPR p) { return os << \"(\" << p.x << \",\" << p.y << \")\";}\n};\ndouble dot(CPR a, CPR b) { return a.x * b.x + a.y * b.y; }\ndouble cross(CPR a, CPR b) { return a.x * b.y - a.y * b.x; }\ndouble length2(CPR p) { return p.x * p.x + p.y * p.y; }\ndouble length(CPR p) { return sqrt(length2(p)); }\ndouble distance(CPR a, CPR b) { return length(a - b); }\nPoint unit(CPR p) { return p / length(p); }\n\nenum ccw_t {\n    COUNTER_CLOCK_WISE = 1,\n    CLOCK_WISE = -1,\n    STRAIGHT_C_A_B = 2,\n    STRAIGHT_A_B_C = -2,\n    STRAIGHT_A_C_B = 0\n};\n\nccw_t ccw(CPR a, CPR b, CPR c){\n    Point ab = b - a, ac = c - a;\n    if( cross(ab,ac) > EPS ) return COUNTER_CLOCK_WISE; // +1 a-b-c ???????¨???????\n    if( cross(ab,ac) < -EPS ) return CLOCK_WISE;        // -1 a-b-c ????¨???????\n    if( dot(ab,ac) < -EPS ) return STRAIGHT_C_A_B;      // +2 c-a-b\n    if( length2(ab) < length2(ac) )return STRAIGHT_A_B_C;     // -2 a-b-c or a==b\n    return STRAIGHT_A_C_B;                              //  0 a-c-b or b==c or a==c\n}\n\n#define CSR const Segment&\nstruct Segment {\n    Point a, b;\n    Segment(){}\n    Segment(const Point& a, const Point& b):a(a), b(b){}\n    pair<Point,Point> to_pair() const { return make_pair(a,b); }\n    bool operator == (CSR s) const { return to_pair() == s.to_pair();}\n    bool operator != (CSR s) const { return !(*this == s); }\n    friend istream &operator >> (istream& is, Segment &s){ return is >> s.a >> s.b;}\n    friend ostream &operator << (ostream& os, CSR s) { return os << s.a << \"->\" << s.b;}\n};\ndouble length(CSR s) {\n    return distance(s.a, s.b);\n}\nbool contain(CSR s, CPR p) {\n    return ccw(s.a, s.b, p) == 0; // STRAIGHT_A_C_B;\n}\nPoint projection(CSR s, CPR p) {\n    Point v = s.b - s.a;\n    double t = dot(p - s.a, v) / length2(v); // ??????\n    return v * t + s.a;\n}\nPoint closest_point(CSR s, CPR p) {\n    Point pp = projection(s, p);\n    return contain(s, pp) ? pp : distance(s.a, p) < distance(s.b, p) ? s.a : s.b;\n}\ndouble distance(CSR s, CPR p) {\n    if( dot(s.b - s.a ,p - s.a) < EPS ) return distance(p, s.a);\n    if( dot(s.a - s.b ,p - s.b) < EPS ) return distance(p, s.b);\n    return abs(cross(s.b - s.a, p - s.a) / length(s));\n}\nbool intersect(CSR s, CSR t) { // ????????????\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 and ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\nstruct Rectangle {\n    array<Point, 4> p;\n    // order:\n    //     3 2\n    //     0 1\n    Rectangle(const array<Point, 4> &pp):p(pp) {\n        // ????????????????????????????????????\n        rep(i, 3) repeat(j, i + 1, 4) {\n            int cnt = 0;\n            rep(k, 4) if(k != i and k != j){\n                cnt += ccw(p[i], p[j], p[k]) == COUNTER_CLOCK_WISE;\n            }\n            if(cnt == 2) {\n                swap(p[i + 1], p[j]);\n                break;\n            }\n        } \n    }\n    bool intersect(CSR s) {\n        bool res = false;\n        rep(i, 4) res |= ::intersect(s, Segment(p[i], p[(i + 1) % 4]));\n        return res;\n    }\n    bool contain(CPR pp) {\n        bool flg = true;\n        rep(i, 4) flg &= ccw(p[i], p[(i + 1) % 4], pp) == COUNTER_CLOCK_WISE;\n        return flg;\n    }\n    bool contain(CSR s) {\n        return contain(s.a) and contain(s.b);\n    }\n    Point closest_point(CPR pp) {\n        Point res = p[0];\n        rep(i, 4) {\n            Point ppp = ::closest_point(Segment(p[i], p[(i+1)%4]), pp);\n            if(distance(res, pp) > distance(ppp, pp)) res = ppp;\n        }\n        return res;\n    }\n    Point closest_point(CSR s) {\n        Point res = p[0];\n        repeat(i, 1, 4) if(distance(s, res) > distance(s, p[i])) res = p[i];\n        for(Point pp : {s.a, s.b}) {\n            Point ppp = closest_point(pp);\n            if(distance(s, res) > distance(s, ppp)) res = ppp;\n        }\n        return res;\n    }\n};\n\n\nclass Solver {\n  public:\n    Segment S;\n    vector<Point> minP, maxP;\n    vector<double> H;\n    bool solve() {\n\n        int N; cin >> N;\n        if(not N) return false;\n        cin >> S;\n        minP.resize(N);\n        maxP.resize(N);\n        H.resize(N);\n        rep(i, N) cin >> minP[i] >> maxP[i] >> H[i];\n        \n        double max_r = INF;\n\n        rep(i, N) {            \n            Rectangle rect({minP[i], maxP[i], Point(minP[i].x, maxP[i].y), Point(maxP[i].x, minP[i].y)});\n\n            if(rect.intersect(S) or rect.contain(S)) {\n                cout << 0 << endl;\n                return true;\n            }\n\n            double d = distance(S, rect.closest_point(S));\n            double r = (d * d + H[i] * H[i]) / (2 * H[i]);\n            if(r < H[i]) r = d;\n            set_min(max_r, r);\n        }\n\n        cout << max_r << endl;\n        return true;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-8\n#define equal(a,b) (fabs(a-b) < EPS)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(const Point &p0,const Point &p1,const Point &p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nPoint projection(const Segment &s,const Point &p){\n    Vector b = s.t-s.s;\n    double t = dot(p-s.s,b)/norm(b);\n    return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n    return (ccw(s.s,s.t,p) == 0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n            ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n    Point r = projection(s,p);\n    if(isIntersectSP(s,r)) return abs(r-p);\n    return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment &a,const Segment &b){\n    if(isIntersectSS(a,b)) return 0;\n    return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n           min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nstruct Block{\n    Point a,b;\n    double h;\n    Block(){}\n    Block(Point &a,Point &b,double h) :\n        a(a),b(b),h(h) {}\n};\n\nistream &operator >> (istream &is,Point &p){ \n    return is >> p.x >> p.y;\n}\n\ndouble calc(double a,double b){\n    return sqrt(a*a+b*b);\n}\n\nbool c(double r,Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point a = v[i].a,b = v[i].b;\n        Point c(a.x,b.y),d(b.x,a.y);\n        Segment s1(a,c),s2(a,d),s3(c,b),s4(d,b);\n        double dst[] = {\n            distanceSS(p,s1),distanceSS(p,s2),\n            distanceSS(p,s3),distanceSS(p,s4)\n        };\n \n        if(r < v[i].h){\n            if(!(r < dst[0] && r < dst[1] &&\n                 r < dst[2] && r < dst[3])){\n                return 0;\n            }\n        }else{\n            double nh = r - v[i].h;\n            if(!(r < calc(nh,dst[0]) && r < calc(nh,dst[1]) &&\n                 r < calc(nh,dst[2]) && r < calc(nh,dst[3]))){\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nbool check(Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point a = v[i].a,b = v[i].b;\n        Point c(a.x,b.y),d(b.x,a.y);\n        Segment s1(a,c),s2(a,d),s3(c,b),s4(d,b);\n        if((a.x < p.s.x && p.s.x < b.x &&\n            a.y < p.s.y && p.s.y < b.y) ||\n           (a.x < p.t.x && p.t.x < b.x &&\n            a.y < p.t.y && p.t.y < b.y)){\n            return 1;\n        }\n        if(isIntersectSS(p,s1)) return 1;\n        if(isIntersectSS(p,s2)) return 1;\n        if(isIntersectSS(p,s3)) return 1;\n        if(isIntersectSS(p,s4)) return 1;\n    }\n    return 0;\n}\n\nint main(){\n    int N;\n    while(cin >> N,N){\n        Segment seg;\n        cin >> seg.s >> seg.t;\n        vector<Block> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].a >> v[i].b >> v[i].h;\n        }\n        if(check(seg,v)){\n            cout << 0 << endl;\n            continue;\n        }\n        double l = 0,r = 1001;\n        for(int i = 0 ; i < 100 ; i++){\n            double mid = (l + r) / 2;\n            if(c(mid,seg,v)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n        printf(\"%.10f\\n\",l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\ntypedef complex<double> P;\ntypedef vector<P> G;\ndouble const inf=1e10;\ndouble const eps=1e-8;\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n};\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\nbool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < eps; // triangle inequality\n}\n\nbool intersectRS(const G &r, const L &l){\n    if(r[0].real()<=l[0].real() && l[0].real()<=r[2].real() &&\n       r[0].imag()<=l[0].imag() && l[0].imag()<=r[2].imag() &&\n       r[0].real()<=l[1].real() && l[1].real()<=r[2].real() &&\n       r[0].imag()<=l[1].imag() && l[1].imag()<=r[2].imag()){\n        return true;\n    }\n    rep(i,4){\n        L m(r[i],r[(i+1)%4]);\n        if(intersectSS(l,m)) return true;\n    }\n    return false;\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nint n;\nP s,e;\nvector<G> rs;\nvd hs;\nvvd d;\n\ndouble maxr(P p, G const& rect, double h){\n    double res=inf;\n    rep(i,4){\n        double d=distanceSP({rect[i],rect[(i+1)%4]},p);\n        if(d<h){\n            res=min(res,d);\n        }else{\n            res=min(res,(d*d+h*h)/(2*h));\n        }\n    }\n    // printf(\" %lf\\n\",res);\n    return res;\n}\n\ndouble solve(){\n    double ans=inf;\n    L l(s,e);\n    rep(i,n){\n        if(intersectRS(rs[i],l)) return 0;\n        rep(j,4){\n            P prj = projection(l,rs[i][j]);\n            if(!intersectSP(l,prj)) continue;\n            ans=min(ans, maxr(prj,rs[i],hs[i]));\n        }\n        // printf(\" %lf\\n\",ans);\n        ans=min(ans,maxr(s,rs[i],hs[i]));\n        ans=min(ans,maxr(e,rs[i],hs[i]));\n    }\n    return ans;\n}\n\nint main(){\n    while(cin>>n && n){\n        double sx,sy,ex,ey;\n        cin >> sx>>sy>>ex>>ey;\n        s = P(sx,sy);\n        e = P(ex,ey);\n        rs.resize(n);\n        hs.resize(n);\n        rep(i,n){\n            double mx,my,Mx,My;\n            cin>>mx>>my>>Mx>>My >> hs[i];\n            rs[i] = {P(mx,my),P(Mx,my),P(Mx,My),P(mx,My)};\n        }\n        printf(\"%.5lf\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <complex>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef complex<double> P;\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L() {}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n};\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    double sx, sy, ex, ey;\n    cin>>sx>>sy>>ex>>ey;\n    double ans = INF;\n    L root = L(P(sx,sy), P(ex,ey));\n    REP(i, N){\n      double mx, my, nx, ny, h;\n      cin>>mx>>my>>nx>>ny>>h;\n      if(mx <= sx && sx <= nx && my <= sy && sy <= ny) ans = 0;\n      L ls[4];\n      ls[0] = L(P(mx,my),P(nx,my));\n      ls[1] = L(P(mx,my),P(mx,ny));\n      ls[2] = L(P(mx,ny),P(nx,ny));\n      ls[3] = L(P(nx,my),P(nx,ny));\n      REP(j, 4){\n        L l = ls[j];\n        double dist = distanceSS(root, l);\n        if(dist == 0) ans = 0;\n        //cout<<l[0]<<\" \"<<l[1]<<\":\"<<dist<<endl;\n        double radian;\n        if(dist - EPS < h) radian = dist;\n        else radian = (h*h + dist*dist)/(2*h);\n        ans = min(ans, radian);\n      }\n    }\n    printf(\"%.10lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst double EPS = 1e-9;\n\nstruct Point\n{\n\tdouble x, y;\n\n\tPoint() : x( 0 ), y( 0 ) {}\n\tPoint( const double x, const double y ) : x( x ), y( y ) {}\n\tPoint( const Point &a ) : x( a.x ), y( a.y ) {}\n\t\n\tconst Point operator + ( const Point &a ) const\n\t{\n\t\treturn Point( x + a.x, y + a.y );\n\t}\n\n\tPoint& operator += ( const Point &a ) \n\t{\n\t\tx += a.x;\n\t\ty += a.y;\n\n\t\treturn *this;\n\t}\n\n\tconst Point operator - ( const Point &a ) const\n\t{\n\t\treturn Point( x + ( -a.x ), y + ( -a.y ) );\n\t}\n\n\tPoint& operator -= ( const Point &a )\n\t{\n\t\tx -= a.x;\n\t\ty -= a.y;\n\n\t\treturn *this;\n\t}\n\n\tconst Point operator * ( const double a ) const\n\t{\n\t\treturn Point( x * a, y * a );\n\t}\n\n\tPoint& operator *= ( const double a )\n\t{\n\t\tx *= a;\n\t\ty *= a;\n\n\t\treturn *this;\n\t}\n\n\tconst Point operator / ( const double a ) const\n\t{\n\t\treturn Point( x / a, y / a );\n\t}\n\n\tPoint& operator /= ( const double a )\n\t{\n\t\tx /= a;\n\t\ty /= a;\n\n\t\treturn *this;\n\t}\n\n\tbool operator < ( const Point &a ) const\n\t{\n\t\treturn x == a.x ? y < a.y : x < a.x;\n\t}\n\n\tdouble abs() const\n\t{\n\t\treturn sqrt( pow( x, 2. ) + pow( y, 2. ) );\n\t}\n};\n\n// 二点間の距離\ndouble distance( const Point &a, const Point &b )\n{\n\treturn sqrt( pow( a.x - b.x, 2. ) + pow( a.y - b.y, 2. ) );\n}\n\n// 内積（ドット積）\ndouble dot( const Point &a, const Point &b )\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n// 外積（クロス積）\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// 線分 ( p1, p2 ) と点 q の距離\ndouble distance_segment_point( const Point &p1, const Point &p2, const Point q )\n{\n\tif ( EPS < dot( p2 - p1, q - p1 ) && EPS < dot( p1 - p2, q - p2 ) )\n\t{\n\t\treturn abs( cross( p2 - p1, q - p1 ) ) / ( p2 - p1 ).abs();\n\t}\n\telse\n\t{\n\t\treturn min( distance( p1, q ), distance( p2, q ) );\n\t}\n}\n\n// 線分 ( p1, p2 ) に点 q が乗っているか\nbool point_on_segment( const Point &p1, const Point &p2, const Point &q )\n{\n\treturn abs( cross( p1 - q, p2 - q ) ) <= EPS && dot( p1 - q, p2 - q ) <= EPS;\n}\n\n// 直線 ( p1, p2 ) と直線 ( q1, q2 ) の交点\nPoint lines_intersection( const Point &p1, const Point &p2, const Point &q1, const Point &q2 )\n{\n\treturn p1 + ( p2 - p1 ) * ( cross( q2 - q1, q1 - p1 ) / cross( q2 - q1, p2 - p1 ) );\n}\n\n// 線分 ( p1, p2 ) と線分 ( q1, q2 ) が交差するか\nbool segments_intersection( const Point &p1, const Point &p2, const Point &q1, const Point &q2 )\n{\t\t\n\tif ( abs( cross( p1 - p2, q1 - q2 ) ) <= EPS ) // is parallel\n\t{\n\t\treturn point_on_segment( p1, p2, q1 ) ||\n\t\t\t   point_on_segment( p1, p2, q2 ) ||\n\t\t\t   point_on_segment( q1, q2, p1 ) ||\n\t\t\t   point_on_segment( q1, q2, p2 );\n\t}\n\telse\n\t{\n\t\tPoint r( lines_intersection( p1, p2, q1, q2 ) );\n\t\treturn point_on_segment( p1, p2, r ) && point_on_segment( q1, q2, r );\n\t}\n}\n\n// 三角形 ( a, b, c ) の中に点 p があるか\nbool point_in_triangle( const Point &a, const Point &b, const Point &c, const Point &p )\n{\n\tint res = 0;\n\tres += EPS < cross( b - a, p - a ) ? 1 : -1;\n\tres += EPS < cross( c - b, p - b ) ? 1 : -1;\n\tres += EPS < cross( a - c, p - c ) ? 1 : -1;\n\n\tif ( abs( res ) == 3 )\n\t{\n\t\treturn true;\n\t}\n\treturn point_on_segment( a, b, p ) || point_on_segment( b, c, p ) || point_on_segment( c, a, p );\n}\n\ndouble search( const Point &p1, const Point &p2, const Point &q, const int h )\n{\n\tconst double dist = distance_segment_point( p1, p2, q );\n\tif ( dist - EPS <= h )\n\t{\n\t\treturn dist;\n\t}\n\n\tdouble lb = 0, ub = 1000;\n\tREP( i, 0, 100 )\n\t{\n\t\tdouble r = ( lb + ub ) / 2;\n\t\tif ( r <= distance( Point( 0, r ), Point( dist, h ) ) + EPS )\n\t\t{\n\t\t\tlb = r;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tub = r;\n\t\t}\n\t}\n\n\treturn lb;\n}\n\ndouble solve( const int n )\n{\n\tint sx, sy, ex, ey;\n\tcin >> sx >> sy >> ex >> ey;\n\tPoint s( sx, sy ), e( ex, ey );\n\n\tVI hs;\n\tvector< Point > points;\n\tvector< pair<Point,Point> > lines;\n\n\tREP( i, 0, n )\n\t{\n\t\tint x1, y1, x2, y2, h;\n\t\tcin >> x1 >> y1 >> x2 >> y2 >> h;\n\n\t\tpoints.PB( Point( x1, y1 ) );\n\t\tpoints.PB( Point( x2, y2 ) );\n\t\tpoints.PB( Point( x1, y2 ) );\n\t\tpoints.PB( Point( x2, y1 ) );\n\n\t\tlines.PB( MP( Point( x1, y1 ), Point( x1, y2 ) ) );\n\t\tlines.PB( MP( Point( x1, y1 ), Point( x2, y1 ) ) );\n\t\tlines.PB( MP( Point( x2, y2 ), Point( x1, y2 ) ) );\n\t\tlines.PB( MP( Point( x2, y2 ), Point( x2, y1 ) ) );\n\n\t\ths.PB( h );\n\t}\n\n\tREP( i, 0, lines.size() )\n\t{\n\t\tif ( segments_intersection( s, e, lines[i].fst, lines[i].snd ) )\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tREP( i, 0, n )\n\t{\n\t\tif ( point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 2 ], s ) ||\n\t\t\t point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 2 ], e ) ||\n\t\t\t point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 3 ], s ) ||\n\t\t\t point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 3 ], e ) )\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdouble res = 1000;\n\tREP( i, 0, n * 4 )\n\t{\n\t\tres = min( res, search( s, e, points[i], hs[ i / 4 ] ) );\n\t\tres = min( res, search( lines[i].fst, lines[i].snd, s, hs[ i / 4 ] ) );\n\t\tres = min( res, search( lines[i].fst, lines[i].snd, e, hs[ i / 4 ] ) );\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\tcout << setprecision( 4 ) << fixed;\n\n\twhile ( true )\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif ( !n )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << solve( n ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#define _USE_MATH_DEFINES\n#include<cmath>\nusing namespace std;\n\n\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//誤差を考慮して足し算\ndouble add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2次元ベクトル\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator / (double d){\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p){//内積\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){//外積\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tbool equal(P p){\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\n};\n//typedef pair<P,P> Line;\n\n//線分p1-p2上に点qがあるか判定\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//直線p1-p2と直線q1-q2の交点\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*( (q2-q1).det(q1-p1)/(q2-q1).det(p2-p1) );\n}\n\n\n//線分p1-p2と線分q1-q2が交差するか\nbool intersecting(P p1,P p2,P q1,P q2){\n\tif(on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2))return true;\n\tif((p1-p2).det(q1-q2)==0 )return false;//平行\n\tP a=intersection(p1,p2,q1,q2);\n\treturn on_seg(p1,p2,a) && on_seg(q1,q2,a);\n}\n//原点中心回転\nP rotate(P p,double rad){\n\tdouble s=sin(rad),c=cos(rad);\n\treturn P(c*p.x-s*p.y, s*p.x+c*p.y);\n}\n//originを中心に回転\nP rotate(P p,double rad,P origin){\n\treturn origin + rotate(p - origin,rad);\n}\n//二点間の距離\ndouble dist(P p,P q){\n\tp = p-q;\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\n//単位ベクトルに変換\nP to_unit(P p){\n\tdouble d = sqrt(p.x*p.x+p.y*p.y);\n\treturn p/d;\n}\n//円同士の交点を計算\npair<P,P> circle_intersection(double x1,double y1,double r1,double x2,double y2,double r2){\n\tdouble rad = atan2(y2-y1,x2-x1);\n\tx2 -= x1;\n\ty2 -= y1;\n\tP tmp = rotate(P(x2,y2),-rad);\n\tx2 = tmp.x;\n\ty2 = tmp.y;\n\tdouble x = (r1*r1-r2*r2+x2*x2)/(2*x2);\n\tif(abs(r1) < abs(x))return make_pair(P(0,0),P(0,0));//交点なし\n\tdouble y = sqrt(r1*r1-x*x);\n\treturn make_pair( P(x1,y1)+rotate(P(x,y),rad) ,  P(x1,y1)+rotate(P(x,-y),rad) );\n}\n//2点を通る円の中心座標\npair<P,P> circle_on_2P(P p,P q,double r){\n\tif(2*r < dist(p,q))return make_pair(P(0,0),P(0,0));//解なし\n\tif(q.x < p.x)swap(p,q);\n\tq = q - p;\n\tdouble rad = atan2(q.y,q.x);\n\tP tmp = rotate(q,-rad);\n\tdouble x = tmp.x/2;\n\tdouble y = sqrt(4*r*r-tmp.x*tmp.x)/2;\n\treturn make_pair( p+rotate(P(x,y),rad) ,  p+rotate(P(x,-y),rad) );\n}\n//線分と点の距離\ndouble dist_LP(P p1,P p2,P q){\n\tdouble dx,dy;\n\tdx = p1.x-p2.x;\n\tdy = p1.y-p2.y;\n\tdouble d = min(dist(p1,q) ,dist(p2,q));\n\tpair<P,P> normal = make_pair(q+to_unit(P(-dy,dx))*d ,q+to_unit(P(dy,-dx))*d);//法線ベクトル\n\tif(intersecting(p1,p2,normal.first,normal.second)){\n\t\treturn dist(q, intersection(p1,p2,normal.first,normal.second));\n\t}\n\treturn d;\n}\n//線分間の距離\ndouble dist_LL(P p1,P p2,P q1,P q2){\n\tif(intersecting(p1,p2,q1,q2))return 0;\n\treturn min( min(dist_LP(p1,p2,q1),dist_LP(p1,p2,q2))\n\t\t,min(dist_LP(q1,q2,p1),dist_LP(q1,q2,p2)) );\n}\n//ラジアンに変換\ndouble radian(double angle){\n\treturn angle/180.0*M_PI;\n}\n\n\n\nint minx[50],miny[50],maxx[50],maxy[50],h[50];\nint n;\nint sx,sy,ex,ey;\n\nbool in_block(int x,int y,int minx,int miny,int maxx,int maxy){\n\treturn minx<=x&&x<=maxx&&miny<=y&&y<=maxy;\n}\nbool on_line(){//ライン上にブロックがある\n\tP s(sx,sy),e(ex,ey);\n\tfor(int i=0;i<n;i++){\n\t\tP a(minx[i],miny[i]),b(minx[i],maxy[i]),c(maxx[i],miny[i]),d(maxx[i],maxy[i]);\n\t\tif(intersecting(s,e,a,b))return true;\n\t\tif(intersecting(s,e,a,c))return true;\n\t\tif(intersecting(s,e,b,d))return true;\n\t\tif(intersecting(s,e,c,d))return true;\n\t\tif(in_block(sx,sy,minx[i],miny[i],maxx[i],maxy[i]))return true;\n\t\tif(in_block(ex,ey,minx[i],miny[i],maxx[i],maxy[i]))return true;\n\t}\n\treturn false;\n}\ndouble square(double a){\n\treturn a*a;\n}\ndouble min(double a,double b){\n\treturn a<b?a:b;\n}\nbool f(double r){\n\tP s(sx,sy),e(ex,ey);\n\tfor(int i=0;i<n;i++){\n\t\tP a(minx[i],miny[i]),b(minx[i],maxy[i]),c(maxx[i],miny[i]),d(maxx[i],maxy[i]);\n\t\tdouble hei = min(r,h[i]);\n\t\tdouble mind=INF;\n\t\tmind = min(mind,dist_LL(s,e,a,b));\n\t\tmind = min(mind,dist_LL(s,e,a,c));\n\t\tmind = min(mind,dist_LL(s,e,b,d));\n\t\tmind = min(mind,dist_LL(s,e,c,d));\n\t\tdouble di = sqrt(square(mind)+square(r-hei));\n\t\tif(di<r)return false;\n\t}\n\treturn true;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tcin>>sx>>sy>>ex>>ey;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>minx[i]>>miny[i]>>maxx[i]>>maxy[i]>>h[i];\n\t\t}\n\t\tif(on_line()){\n\t\t\tprintf(\"%.4f\\n\",0.0);\n\t\t}else{\n\t\t\tdouble lb=0,ub=1001;\n\t\t\tfor(int i=0;i<25;i++){\n\t\t\t\tdouble m=(lb+ub)/2;\n\t\t\t\tif(f(m))lb=m;\n\t\t\t\telse ub=m;\n\t\t\t}\n\t\t\tprintf(\"%.4f\\n\",lb);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define ef emplace_front\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n\nusing ll = long long;\nusing ull = unsigned long long;\n\ntemplate<typename T, size_t H, size_t W>\nusing matrix = std::array<std::array<T, W>, H>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy[] = {0, -1, 0, 1, -1, 1, -1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline void chmax(T &x, U y){ x = std::max<T>(x, y); }\n\ntemplate<typename T, typename U>\ninline void chmin(T &x, U y){ x = std::min<T>(x, y); }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(c); c.erase(std::unique(std::begin(c), std::end(c))); }\n\n// }}}\n// geometry {{{\nusing Real = long double;\n\nstruct Point {\n\tReal x, y;\n\tPoint(){}\n\tPoint(Real x, Real y): x(x), y(y){}\n\t\n\tconst Point operator + (const Point &r) const {\n\t\treturn Point(x + r.x, y + r.y);\n\t}\n\t\n\tconst Point operator - (const Point &r) const {\n\t\treturn Point(x - r.x, y - r.y);\n\t}\n\t\n\tconst Point operator * (Real r) const {\n\t\treturn Point(x * r, y * r);\n\t}\n\n\tconst Point operator * (const Point &r) const {\n\t\treturn Point(x * r.x - y * r.y, x * r.y + y * r.x);\n\t}\n\t\n\tconst Point operator / (Real r) const {\n\t\treturn Point(x / r, y / r);\n\t}\n\t\n\tPoint& operator += (const Point &r){\n\t\tx += r.x;\n\t\ty += r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator -= (const Point &r){\n\t\tx -= r.x;\n\t\ty -= r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator *= (Real r){\n\t\tx *= r;\n\t\ty *= r;\n\t\treturn *this;\n\t}\n\n\tPoint& operator *= (const Point &r){\n\t\treturn *this = *this * r;\n\t}\n\t\n\tPoint& operator /= (Real r){\n\t\tx /= r;\n\t\ty /= r;\n\t\treturn *this;\n\t}\n\n\tbool operator < (const Point &r) const {\n\t\tif (x != r.x) return x < r.x;\n\t\treturn y < r.y;\n\t}\n};\n\nusing LS = array<Point, 2>;\n\nstruct Line : LS {\n\tLine(){}\n\tLine(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tLine(const LS &r){\n\t\t(*this)[0] = r[0];\n\t\t(*this)[1] = r[1];\n\t}\n};\n\nstruct Segment : LS {\n\tSegment(){}\n\tSegment(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tSegment(const LS &r){\n\t\t(*this)[0] = r[0];\n\t\t(*this)[1] = r[1];\n\t}\n};\n\nstruct Circle {\n\tCircle(){}\n\tCircle(const Point &p, Real r): p(p), r(r){}\n\tPoint p;\n\tReal r;\n};\n\nusing Polygon = vector<Point>;\n\nconst Real PI = acos(Real(-1));\nconst Real EPS = 1e-12;\n\nint sgn(Real a){\n\tif (abs(a) < EPS) return 0;\n\tif (a < 0.0) return -1;\n\treturn 1;\n}\n\nbool eq(Real a, Real b){\n\treturn sgn(a - b) == 0;\n}\n\nbool neq(Real a, Real b){\n\treturn sgn(a - b) != 0;\n}\n\nbool lt(Real a, Real b){\n\treturn sgn(a - b) < 0;\n}\n\nbool leq(Real a, Real b){\n\treturn sgn(a - b) <= 0;\n}\n\nbool gt(Real a, Real b){\n\treturn sgn(a - b) > 0;\n}\n\nbool geq(Real a, Real b){\n\treturn sgn(a - b) >= 0;\n}\n\nReal toRad(Real t){\n\treturn t / 180 * PI;\n}\n\nReal toDeg(Real t){\n\treturn t * 180 / PI;\n}\n\nReal norm(const Point &a){\n\treturn sq(a.x) + sq(a.y);\n}\n\nReal abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nReal arg(const Point &a){\n\treturn atan2(a.y, a.x);\n}\n\nPoint polar(Real r, Real t){\n\treturn Point(cos(t) * r, sin(t) * r);\n}\n\nReal dot(const Point &a, const Point &b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nint ccw(const Point &p1, const Point &p2, const Point &p3){\n\tPoint a = p2 - p1, b = p3 - p1;\n\tif (gt(cross(a, b), 0)) return 1;\n\tif (lt(cross(a, b), 0)) return -1;\n\tif (lt(dot(a, b), 0)) return 2;\n\tif (lt(norm(a), norm(b))) return -2;\n\treturn 0;\n}\n\nbool orthogonal(const LS &l1, const LS &l2){\n\treturn eq(dot(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nbool parallel(const LS &l1, const LS &l2){\n\treturn eq(cross(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nPoint project(const LS &l, const Point &p){\n\tReal r = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * r;\n}\n\nPoint reflect(const LS &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2;\n}\n\nbool intersect(const Line &l1, const Line &l2){\n\tif (!parallel(l1, l2)) return true;\n\treturn eq(cross(l1[1] - l1[0], l2[0] - l1[0]), 0);\n}\n\nbool intersect(const Line &l, const Segment &s){\n\treturn leq(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]), 0);\n}\n\nbool intersect(const Line &l, const Point &p){\n\treturn eq(cross(l[1] - p, l[0] - p), 0);\n}\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n\t       ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\n\nbool intersect(const Segment &s, const Point &p){\n\treturn ccw(s[0], s[1], p) == 0;\n}\n\nReal distance(const Line &l, const Point &p){\n\treturn abs(cross(l[1] - l[0], p - l[0]) / abs(l[1] - l[0]));\n}\n\nReal distance(const Segment &s, const Point &p){\n\tif (dot(s[1] - s[0], p - s[0]) < 0.0) return abs(p - s[0]);\n\tif (dot(s[0] - s[1], p - s[1]) < 0.0) return abs(p - s[1]);\n\treturn distance(Line(s), p);\n}\n\nReal distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min({\n\t\tdistance(s1, s2[0]), distance(s1, s2[1]),\n\t\tdistance(s2, s1[0]), distance(s2, s1[1])\n\t});\n}\n\nPoint crossPoint(const LS &s1, const LS &s2){\n\tReal d1 = abs(cross(s2[1] - s2[0], s1[0] - s2[0]));\n\tReal d2 = abs(cross(s2[1] - s2[0], s1[1] - s2[0]));\n\tReal t = d1 / (d1 + d2);\n\treturn s1[0] + (s1[1] - s1[0]) * t;\n}\n// }}}\n\n\nint n;\nSegment s;\nPolygon g[50];\nReal h[50];\n\nbool ok(Real r)\n{\n\trep(i, n){\n\t\trep(j, 4){\n\t\t\tSegment t(g[i][j], g[i][(j + 1) % 4]);\n\t\t\tReal d = hypot(distance(s, t), max<Real>(r - h[i], 0));\n\t\t\tif (lt(d, r)) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\trep(i, n) g[i] = Polygon(4);\n\t\tcin >> s[0].x >> s[0].y >> s[1].x >> s[1].y;\n\t\trep(i, n){\n\t\t\tReal a[4];\n\t\t\trep(j, 4) cin >> a[j];\n\t\t\tcin >> h[i];\n\t\t\tg[i][0] = Point(a[0], a[1]);\n\t\t\tg[i][1] = Point(a[0], a[3]);\n\t\t\tg[i][2] = Point(a[2], a[3]);\n\t\t\tg[i][3] = Point(a[2], a[1]);\n\t\t}\n\t\t\n\t\tbool f = false;\n\t\trep(i, n){\n\t\t\tbool c = true, d = true;\n\t\t\trep(j, 4){\n\t\t\t\tSegment t(g[i][j], g[i][(j + 1) % 4]);\n\t\t\t\tif (intersect(s, t)) f = true;\n\t\t\t\tif (ccw(t[0], t[1], s[0]) != -1) c = false;\n\t\t\t\tif (ccw(t[0], t[1], s[1]) != -1) d = false;\n\t\t\t}\n\t\t\tif (c | d) f = true;\n\t\t}\n\n\t\tif (f){\n\t\t\tprintf(\"%.20f\\n\", 0.0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tReal lb = 0.0, ub = 1000.0;\n\t\trep(i, 100){\n\t\t\tReal md = (lb + ub) / 2;\n\t\t\t(ok(md) ? lb : ub) = md;\n\t\t}\n\n\t\tprintf(\"%.20Lf\\n\", lb);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\nint n;\nint sx,sy,gx,gy;\nint xa[SIZE],ya[SIZE],xb[SIZE],yb[SIZE],h[SIZE];\n\ntypedef double P_type;\ntypedef complex<P_type> P;\nconst P_type P_eps = 1e-8;\n\n//??????\ndouble dot(P a, P b) {\n  return (a * conj(b)).real();\n}\n\n//??????\ndouble cross(P a, P b) {\n  return (a * conj(b)).imag();\n}\n\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < P_eps ) return abs(c-a);\n  if ( dot(a-b, c-b) < P_eps ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n/* ?????????????????? */\nbool IntersectionSS(P a1, P a2, P b1, P b2){\n    \n  //??????a ??¨ ??´???b\n  P_type a = cross(b1-b2,a1-b1);\n  P_type b = cross(b1-b2,a2-b1);\n  \n  //??????b ??¨ ??´???a\n  P_type c = cross(a1-a2,b1-a1);\n  P_type d = cross(a1-a2,b2-a1);\n  \n  if((a<0)^(b<0) && (c<0)^(d<0))  // T?????????????????? -P_eps\n    return true;\n  else\n    return false;\n}\n\nbool check(double r){\n  \n  P l_s = P(sx,sy);\n  P l_g = P(gx,gy);\n  \n  for(int i=0;i<n;i++){\n    P p[4];\n    p[0] = P(xa[i],ya[i]);\n    p[1] = P(xa[i],yb[i]);\n    p[2] = P(xb[i],yb[i]);\n    p[3] = P(xb[i],ya[i]);\n    double H = min((double)h[i],r);\n    double R = sqrt(r*r - (r-H)*(r-H));\n\n    for(int j=0;j<4;j++){\n      double dis = distance_ls_p(l_s, l_g, p[j]);\n      bool is = IntersectionSS(l_s,l_g,p[j],p[(j+1)%4]);\n      bool in = (xa[i] <= sx && sx <= xb[i] && ya[i] <= sy && sy <= yb[i]) ||\n        (xa[i] <= gx && gx <= xb[i] && ya[i] <= gy && gy <= yb[i]);\n      \n      if(dis < R || is || in){\n        return false;\n      }\n    }\n  }\n  \n  for(int i=0;i<n;i++){\n    P p[4];\n    p[0] = P(xa[i],ya[i]);\n    p[1] = P(xa[i],yb[i]);\n    p[2] = P(xb[i],yb[i]);\n    p[3] = P(xb[i],ya[i]);\n    double H = min((double)h[i],r);\n    double R = sqrt(r*r - (r-H)*(r-H));\n\n    for(int j=0;j<4;j++){\n      double dis1 = distance_ls_p(p[j],p[(j+1)%4],l_s);\n      double dis2 = distance_ls_p(p[j],p[(j+1)%4],l_g);\n      \n      if(dis1 < R || dis2 < R){\n        return false;\n      }\n    }\n\n  }\n  \n  return true;\n}\n\nbool solve(){\n  \n  \n  scanf(\"%d\",&n);\n\n  if(n == 0) return false;\n\n  scanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d%d%d%d\",xa+i, ya+i, xb+i, yb+i, h+i);\n  }\n\n  double l=0, r=1000;\n\n  while(r-l > 1e-8){\n    double mid = (l+r)/2;\n\n    if(check(mid)){\n      l = mid;\n    }else{\n      r = mid;\n    }\n  }\n\n  printf(\"%.7lf\\n\",l);\n  \n  return true;\n}\n\nint main(){\n\n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <bitset>\n#include <deque>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <chrono>\n#include <random>\n#include <tuple>\n#include <utility>\n#include <fstream>\n#include <complex>\n\nlong n;\ntypedef std::complex<double> Com;\n\n//geometric library\n//#include <complex>\n//typedef complex<double> Com;\n//内積\ndouble dot_product(Com a, Com b){\n\treturn (conj(a)*b).real();\n}\n//外積\ndouble cross_product(Com a, Com b){\n\treturn (conj(a)*b).imag();\n}\n//点と直線の距離\ndouble dist_dot_line(Com st, Com en, Com dt){\n    return std::abs(cross_product(dt-st, en-st) / std::abs(en-st));\n}\n//点と線分の距離\ndouble dist_dot_seg(Com st, Com en, Com dt){\n\tif(dot_product(en-st, dt-st) <= 0){\n\t\treturn std::abs(dt-st);\n\t}else if(dot_product(st-en, dt-en) <= 0){\n\t\treturn std::abs(dt-en);\n\t}else{\n\t\treturn dist_dot_line(st, en, dt);\n\t}\n}\n//線分の交差判定\nbool seg_crossing(Com st1, Com en1, Com st2, Com en2){\n\tdouble cross1 = cross_product(en1-st1, st2-st1) * cross_product(en1-st1, en2-st1);\n\tdouble cross2 = cross_product(en2-st2, st1-st2) * cross_product(en2-st2, en1-st2);\n\treturn (cross1 <= 0) && (cross2 <= 0);\n}\n//線分と線分の距離\ndouble dist_seg(Com st1, Com en1, Com st2, Com en2){\n\tif(seg_crossing(st1, en1, st2, en2)){\n\t\treturn 0;\n\t}\n\treturn std::min(std::min(dist_dot_seg(st1, en1, st2), dist_dot_seg(st1, en1, en2)), std::min(dist_dot_seg(st2, en2, st1), dist_dot_seg(st2, en2, en1)));\n}\n\n\nvoid solve(){\n    double ans = 10000;\n    Com s, g;\n    double sx, sy, gx, gy;\n    scanf(\"%lf%lf%lf%lf\", &sx, &sy, &gx, &gy);\n    s = Com(sx, sy);\n    g = Com(gx, gy);\n    for(int i = 0; i < n; i++){\n        double cod[2][2];\n        double height;\n        for(int j = 0; j < 2; j++){\n            for(int k = 0; k < 2; k++){\n                scanf(\"%lf\", &cod[j][k]);\n            }\n        }\n\t\tstd::vector<Com> ver;\n        scanf(\"%lf\", &height);\n        for(int j = 0; j < 2; j++){\n            for(int k = 0; k < 2; k++){\n                ver.push_back(Com(cod[j][0], cod[k][1]));\n            }\n        }\n\t\tver.push_back(ver[0]);\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tdouble d = dist_seg(Com(sx, sy), Com(gx, gy), ver[j], ver[j+1]);\n\t\t\tif(d < height){\n\t\t\t\tans = std::min(ans, d);\n\t\t\t}else{\n\t\t\t\tans = std::min(ans, (height*height + d*d) / (2*height));\n\t\t\t}\n\t\t}\n    }\n    printf(\"%.9lf\\n\", ans);\n}\n\nint main(){\n    while(1){\n        scanf(\"%ld\", &n);\n        if(n == 0){\n            return 0;\n        }\n        solve();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n#define EPS (1e-10)\n\nint SX, SY, TX, TY;\nint N;\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\nbool intersect(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < 0 ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < 0 );\n}\n\ndouble dist(P a, P b, P c) {\n  if (dot(b-a, c-a) < 0) return abs(c-a);\n  if (dot(a-b, c-b) < 0) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble f(double d, double h) {\n  if (h >= d) return d;\n  double lo = d, hi = 1e10;\n  rep(_, 200) {\n    double mid = (lo + hi) / 2;\n    double t = mid / (mid/h - 1);\n    double g = sqrt(t*t - h*h) * (mid/h - 1);\n    if (d >= g) lo = mid;\n    else hi = mid;\n  }\n  return lo;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> N) {\n    if (N == 0) break;\n    cin >> SX >> SY >> TX >> TY;\n    double ans = 1e10;\n    rep(i, N) {\n      int lx, ly, rx, ry, h;\n      cin >> lx >> ly >> rx >> ry >> h;\n      if (intersect(P(SX, SY), P(TX, TY), P(lx, ly), P(lx, ry))) ans = 0;\n      if (intersect(P(SX, SY), P(TX, TY), P(lx, ry), P(rx, ry))) ans = 0;\n      if (intersect(P(SX, SY), P(TX, TY), P(rx, ry), P(rx, ly))) ans = 0;\n      if (intersect(P(SX, SY), P(TX, TY), P(rx, ly), P(lx, ly))) ans = 0;\n      if (lx<=min(SX,TX)&&ly<=min(SY,TY)&&rx>=max(SX,TX)&&ry>=max(SY,TY)) ans = 0;\n      ans = min(ans, f(dist(P(SX, SY), P(TX, TY), P(lx, ly)), h));\n      ans = min(ans, f(dist(P(SX, SY), P(TX, TY), P(lx, ry)), h));\n      ans = min(ans, f(dist(P(SX, SY), P(TX, TY), P(rx, ly)), h));\n      ans = min(ans, f(dist(P(SX, SY), P(TX, TY), P(rx, ry)), h));\n\n      ans = min(ans, f(dist(P(lx, ly), P(lx, ry), P(SX, SY)), h));\n      ans = min(ans, f(dist(P(lx, ry), P(rx, ry), P(SX, SY)), h));\n      ans = min(ans, f(dist(P(rx, ry), P(rx, ly), P(SX, SY)), h));\n      ans = min(ans, f(dist(P(rx, ly), P(lx, ly), P(SX, SY)), h));\n\n      ans = min(ans, f(dist(P(lx, ly), P(lx, ry), P(TX, TY)), h));\n      ans = min(ans, f(dist(P(lx, ry), P(rx, ry), P(TX, TY)), h));\n      ans = min(ans, f(dist(P(rx, ry), P(rx, ly), P(TX, TY)), h));\n      ans = min(ans, f(dist(P(rx, ly), P(lx, ly), P(TX, TY)), h));\n    }\n    cout << fixed << setprecision(20) << ans << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define all(x) x.begin(), x.end()\n#define mp make_pair\n#define eb emplace_back \n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pip;\ntypedef vector<int> vi;\nconst int INF = 1000000000;\n\ntypedef complex<double> pt;\ntypedef vector<pt> pol;\nconst double eps = 1e-8;\nstruct line : pol{\n  line(){}\n  line(pt a, pt b){ pb(a); pb(b);}\n};\n\ndouble dot(const pt a, const pt b){\n\treturn real(conj(a) * b);\n}\ndouble crs(const pt a, const pt b){\n  return imag(conj(a) * b);\n}\nint ccw(pt a, pt b, pt c){\n  b-=a; c-=a;\n  if(crs(b,c) > 0) return 1;\n  if(crs(b,c) < 0) return -1;\n  if(dot(b,c) < 0) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\nbool intsp(line s, pt p){\n  return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < eps;\n}\nbool intss(line s, line t){\n  return ccw(s[0],s[1], t[0]) * ccw(s[0],s[1],t[1]) <= 0 &&\n  \t\t\tccw(t[0], t[1],s[0]) * ccw(t[0],t[1],s[1]) <= 0;\n}\npt proj(line l, pt p){\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0] - l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\ndouble distsp(line s, pt p){\n  pt r = proj(s,p);\n  if(intsp(s, r)) return abs(r-p);\n  return min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble distss(line s, line t){\n  if(intss(s,t)) return 0;\n  return min( min(distsp(s,t[0]), distsp(s,t[1])), min(distsp(t,s[0]), distsp(t,s[1])));\n}\n\ntemplate<class T>\nostream& operator<<(ostream &out, const vector<T> &v){\n  out << \"{\";\n  rep(i,v.size()) out << v[i] << \", \";\n  return out << \"}\" << endl;\n}\nint main(){\n  int n;\n  while(cin >> n, n){\n\tpt s,t;\n\tvi h(n);\n\tvector<double> d(n);\n\tint x, y;\n\tcin >> x >> y;\n\ts = pt(x,y);\n\tcin >> x >> y;\n\tt = pt(x,y);\n\tline seg(s,t);\n\trep(i,n){\n\t  int w,z;\n\t  cin >> x >> y >> w >> z >> h[i];\n\t  pt a[4] = {pt(x,y), pt(w,y), pt(w,z),pt(x,z)};\n\t  d[i] = INF;\n\t  rep(j,4) d[i] = min(d[i], distss(seg, line(a[j], a[(j+1)%4])));\n\t  if(x <= real(s) && y <= imag(s) && real(s) <= w && imag(s) <= z) d[i] = 0;\n\t}\n\n\tdouble lb = 0, ub = INF;\n\twhile(ub - lb > eps){\n\t  double mid = (lb + ub) / 2;\n\t  bool f = true;\n\t  rep(i,n){\n\t\tdouble m = mid - min((double)h[i],mid);\n\t\tif(mid * mid > d[i] * d[i] + m * m){\n\t\t  f = false;\n\t\t  break;\n\t\t}\n\t  }\n\t  if(f) {\n\t\tlb = mid;\n\t  }else{\n\t\tub = mid;\n\t  }\n\t}\n\n\tcout << fixed << setprecision(10);\n\tcout << lb << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define EPS (1e-10)\ntypedef complex<double> P;\n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\ndouble distance(P p0, P p1, P p2, P p3){\n  double ans = 1e10;\n        ans = min(ans, distance_ls_p(p0, p1, p2));\n        ans = min(ans, distance_ls_p(p0, p1, p3));\n        ans = min(ans, distance_ls_p(p2, p3, p0));\n        ans = min(ans, distance_ls_p(p2, p3, p1));\n        if(is_intersected_ls(p0, p1, p2, p3)) ans = 0.0;\n\t\treturn ans;\n}\n\nint main(){\n\twhile(true){\n\t\tint n; cin >> n;\n\t\tif(n == 0 )break;\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tP s = P(x,y);\n\t\tcin >> x >> y;\n\t\tP g = P(x,y);\n\t\tvector<P> mins(n), maxs(n);\n\t\tvector<double> h(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\tmins[i].real(x); mins[i].imag(y);\n\t\t\tcin >> x >> y;\n\t\t\tmaxs[i].real(x); maxs[i].imag(y);\n\t\t\tcin >> h[i];\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tfor(int i = 0; i < n;i++){\n\t\t\tdouble d = 1e9;\n\t\t\tP p1 = mins[i], p3 = maxs[i];\n\t\t\tP p2(mins[i].real(), maxs[i].imag());\n\t\t\tP p4(maxs[i].real(), mins[i].imag());\n\t\t\tif(p1.real() < s.real() && s.real() < p3.real() && \n\t\t\t\tp1.imag() < s.imag() && s.imag() < p3.real()){\n\t\t\t\tans = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, distance(s, g, p1,p2));\n\t\t\td = min(d, distance(s, g, p2,p3));\n\t\t\td = min(d, distance(s, g, p3,p4));\n\t\t\td = min(d, distance(s, g, p4,p1));\n\t\t\tdouble r = (h[i]*h[i]+d*d)/(2*h[i]);\n\t\t\tif(h[i] < d){\n\t\t\t\tans = min(ans, r);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = min(ans, d);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%f\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nint main()\n{\n  int n,a,b,c,d,h;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    cin>>a>>b>>c>>d;\n\n    Segment s(Point(a,b),Point(c,d));\n    double ans=inf;\n\n    for(int i=0;i<n;i++){\n      cin>>a>>b>>c>>d>>h;\n\n      Point A(a,b),B(c,b),C(c,d),D(a,d);\n      double dis=min(min(getDistance(s,Segment(A,B)),getDistance(s,Segment(B,C))),\n                     min(getDistance(s,Segment(C,D)),getDistance(s,Segment(D,A))));\n \n      if( ((a-s.p1.x)<eps && (b-s.p1.y)<eps) && ((a-s.p2.x)<eps && (b-s.p2.y)<eps) &&\n          ((s.p1.x-c)<eps && (s.p1.y-d)<eps) && ((s.p2.x-c)<eps && (s.p2.y-d)<eps))dis=0;\n      if(dis<=h)ans=min(ans,dis);\n      else ans=min(ans,(dis*dis+h*h)/(double)(2*h));\n    }\n    printf(\"%.10f\\n\",ans);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS 1e-10\n#define EQ(a,b) (abs(a - b) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n//外積\ndouble cross (P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n//内積\ndouble dot (P a, P b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//直行\nbool is_orthogonal(P a1, P a2, P b1, P b2) {\n    return EQ( dot(a1 - a2, b1 - b2), 0.0);\n}\n\n//平行\nbool is_parallel(P a1, P a2, P b1, P b2) {\n    return EQ( cross(a1 - a2, b1 - b2), 0.0);\n}\n\n//直線上\nbool is_point_on_vector(P a, P b, P c) {\n    return EQ( cross(a - c, c - b), 0.0);\n}\n\n//線分上\nbool is_point_on_line (P a, P b, P c) {\n    return (abs(a - c) + abs(c - b) < abs(a - b) + EPS);\n}\n\n//角度　線分の距離は小数点以下３桁まで\ndouble angle (P a, P b, P p) {\n    return (acos(dot(a-p,b-p) / (abs(a-p) * abs(b-p))) * 180.0 / M_PI);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_l(P a1, P a2, P b1, P b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2 - a1; P b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n    if ( dot(b-a, c-a) < EPS ) return fabs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return fabs(c-b);\n    return abs(cross(b-a, c-a)) / fabs(b-a);\n}\n\n/***************************************\n *\n * 2点を通る直線とある点からの垂線との交点\n *\n * a, b を直線\n * p    をある点\n *\n ***************************************/\nP crossNormalVector (P a, P b, P p) {\n    double t = dot(b-a, p-a) / (abs(b-a) * abs(b - a));\n    return a + t * (b - a);\n}\n\ndouble calc (double h, double r) {\n    if (h > r) h = r;\n    // cout << \"# \"<< h << \" \" << r << endl;\n    // double x = sqrt(h * h + r * r) / 2.;\n    // double y = x * tan((0.5 * M_PI) - atan((h / r)));\n    // double res = sqrt(x * x + y * y);\n    // cout << r / x << endl;\n    // cout << \"# > \" << x << \" \" << y << endl;\n    // cout << res << endl;\n    return (r * r + h * h) / (2 * h);\n}\n\nint main ()\n{\n    int n;\n    while (cin >> n, n) {\n        double sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        P s(sx, sy), e(ex, ey);\n\n        double res_h = 1000.;\n        while (n--) {\n            // cout << \"Count # \" << n << endl;\n            \n            double minx, miny, maxx, maxy;\n\n            double h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            vector<P> v = { P(minx, miny), P(minx, maxy), P(maxx, maxy), P(maxx, miny)};\n\n            if (minx <= s.real() && s.real() <= maxx && miny <= s.imag() && s.imag() <= maxy) res_h = 0.;\n            if (minx <= e.real() && e.real() <= maxx && miny <= e.imag() && e.imag() <= maxy) res_h = 0.;\n\n            for (int i = 0; i < 4; i++) {\n                int anf = (i + 1) % 4, bfr = (i + 4 - 1) % 4;\n                int now = i;\n\n                if (is_intersected_ls(e, s, v[now], v[anf])) res_h = 0.;\n                if (is_intersected_ls(e, s, v[now], v[bfr])) res_h = 0.;\n                \n                // cout << \"DBG > \" << min(v[now].real(), v[anf].real()) << \" \" << max(v[now].real(), v[anf].real()) << endl;\n                // cout << \"      \" << min(v[now].imag(), v[anf].imag()) << \" \" << max(v[now].imag(), v[anf].imag()) << endl;\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[anf], s)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[bfr], s)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[anf], e)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[bfr], e)));\n                // res_h = min(res_h, calc(h, min(abs(minx - s.real()), abs(maxx - s.real()))));\n                // res_h = min(res_h, calc(h, min(abs(miny - s.imag()), abs(maxy - s.imag()))));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[now])));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[anf])));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[bfr])));\n            }\n        }\n\n        cout << res_h << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-8;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p1;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(!eq(crossProduct(b,c),0.0)) for(;;);\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n//\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tint x=ccw(s.p1,s.p2,pr);\n//\tif(x>=-1&&x<=1) return d;\n\tif(x==0) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t\tbool flg1=(abs(oneLineCCW(q[0],q[1],r))<=1);\n\t\tbool flg2=ccw(q[0],q[1],r)==0;\n\t\tif(flg1!=flg2) assert(0);\n\t//\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\tif(ccw(q[0],q[1],r)==0){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t\tflg1=abs(oneLineCCW(p[0],p[1],r)<=1);\n\t\tflg2=ccw(p[0],p[1],r);\n\t\tif(flg1!=flg2) assert(0);\n\t//\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\tif(ccw(p[0],p[1],r)==0){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tif(eq(abs(s-t),0.0)) for(;;);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tif(eq(abs(e.p1-e.p2),0.0)) for(;;);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define endl \"\\n\"\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\n#define rrep(i, a, b) for (auto i = (a); i > (b); --i)\n#define UNIQUE(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\n#ifdef LOCAL_DEFINE\nstruct InitInput\n{\n  InitInput()\n  {\n    FILE *stream1;\n    stream1 = freopen(\"in.txt\", \"r\", stdin);\n    assert(stream1 != nullptr);\n    cerr << \"This problem is not interactive\" << endl;\n  }\n} LOCAL_INPUT;\nstruct LOCAL_OUTPUT\n{\n  LOCAL_OUTPUT()\n  {\n    FILE *stream2;\n    const char *outputfile = \"out.txt\";\n    stream2 = freopen(outputfile, \"w\", stdout);\n    assert(stream2 != nullptr);\n    cerr << \"output [ \" << outputfile << \" ]\" << endl;\n  }\n} /*LOCAL_OUTPUT*/;\n#define show(x) cerr << #x << \" = \" << (x) << \" (line \" << __LINE__ << \")\" << endl\n#define showA(a, n)                                            \\\n  do                                                           \\\n  {                                                            \\\n    for (int _i_t_e_ = 0; _i_t_e_ < (n); _i_t_e_++)            \\\n      cerr << \"(\" << _i_t_e_ << \" = \" << (a)[_i_t_e_] << \") \"; \\\n    cerr << endl;                                              \\\n  } while (0)\n#define showA2(a, n, m)                                                                        \\\n  do                                                                                           \\\n  {                                                                                            \\\n    for (int _i_t_e_ = 0; _i_t_e_ < (n); _i_t_e_++)                                            \\\n    {                                                                                          \\\n      for (int _i_t_e_2 = 0; _i_t_e_2 < (m); _i_t_e_2++)                                       \\\n      {                                                                                        \\\n        cerr << \"(\" << _i_t_e_ << \", \" << _i_t_e_2 << \" = \" << (a)[_i_t_e_][_i_t_e_2] << \") \"; \\\n      }                                                                                        \\\n      cerr << endl;                                                                            \\\n    }                                                                                          \\\n    cerr << endl;                                                                              \\\n  } while (0)\n#else\n#define show(x)\n#define showA(a, n)\n#define showA2(a, n, m)\n#endif\n\nstruct InitAim\n{\n  InitAim()\n  {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(12);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    cerr << \"This problem is not interactive\" << endl;\n#endif\n  }\n} aim_cpo;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconstexpr const int INT_INF = 0x3f3f3f3f;       //1061109567\nconstexpr const ll LL_INF = 0x3f3f3f3f3f3f3f3f; //4557430888798830399\n\ntemplate <typename T>\nbool chmin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T>\nbool chmax(T &a, T b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T>\nvoid ln(T i, T n) { cout << (i == n - 1 ? \"\\n\" : \" \"); }\ntemplate <typename T, typename S>\nostream &operator<<(ostream &out, const pair<T, S> &pair1)\n{\n  out << '(' << pair1.fi << \", \" << pair1.se << ')';\n  return out;\n}\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &vector1)\n{\n  out << '[';\n  for (unsigned int i = 0; i < vector1.size(); i++)\n  {\n    out << vector1[i];\n    if (i == vector1.size() - 1)\n      out << \"]\";\n    else\n      out << \", \";\n  }\n  return out;\n}\n\n// INT\n#define GCD(a, b) __gcd(a, b)\ntemplate <typename T>\nT LCM(T a, T b)\n{\n  return a / GCD(a, b) * b;\n}\ntemplate <typename T>\nT EXTGCD(T a, T b, T &x, T &y)\n{\n  T d = a;\n  if (b != 0)\n  {\n    d = EXTGCD(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n  else\n    x = 1, y = 0;\n  return d;\n}\ntemplate <typename T>\nbool is_prime(T a)\n{\n  for (int i = 2; i * i <= a; i++)\n    if (a % i == 0)\n      return true;\n  return false;\n}\ntemplate <typename T, typename S>\nT Pow(T a, S b)\n{\n  T res = 1, now = a;\n  while (b)\n  {\n    if (b & 1)\n      res *= now;\n    b >>= 1;\n    now *= now;\n  }\n  return res;\n}\n\n// MOD\nll MOD = 1000000000L + 7L;\n#define Madd(a, b) (((a) % MOD) + ((b) % MOD)) % MOD\n#define Mmul(a, b) (((a) % MOD) * ((b) % MOD)) % MOD\n#define Msub(a, b) (((a) % MOD) + MOD - ((b) % MOD)) % MOD\ntemplate <typename T, typename S>\nT ModPow(T a, S b)\n{\n  assert(b >= 0);\n  T res = 1, now = Msub(a, 0);\n  while (b)\n  {\n    if (b & 1)\n      res = Mmul(res, now);\n    b >>= 1;\n    now = Mmul(now, now);\n  }\n  return res;\n}\ntemplate <typename T>\nT ModInverse(T a, T mod, bool prime)\n{ // if mod is prime, \"prime\" is true.\n  if (prime)\n    return ModPow(a, mod - 2);\n  else\n  {\n    T x, y;\n    EXTGCD(a, mod, x, y);\n    return (mod + x % mod) % mod;\n  }\n}\ntemplate <typename T>\nT EulerTotient(T a)\n{\n  vector<pair<int, int>> v;\n  for (T i = 2; i * i <= a; i++)\n  {\n    int cnt = 0;\n    while (a % i == 0)\n    {\n      cnt++;\n      a /= i;\n    }\n    if (cnt != 0)\n      v.emplace_back(i, cnt);\n  }\n  if (a != 1)\n    v.emplace_back(a, 1);\n  //showV(v, (int) v.size());\n  T res = 1;\n  for (int i = 0; i < (int)v.size(); i++)\n  {\n    if (v[i].se == 1)\n    {\n      //res *= v[i].fi - 1;\n      res = Mmul(res, v[i].fi - 1);\n    }\n    else\n    {\n      //res *= Pow(v[i].fi, v[i].se) - Pow(v[i].fi, v[i].se - 1);\n      res = Mmul(res, Msub(ModPow(v[i].fi, v[i].se), ModPow(v[i].fi, v[i].se - 1)));\n    }\n  }\n  return res;\n}\n#define Mdivide(a, b) Mmul(((a) % MOD), (ModInverse((b), MOD, true))) % MOD\nll comb(ll a, ll b)\n{\n  chmin(b, a - b);\n  ll res = 1LL, now = a;\n  for (ll i = 1; i <= b; i++)\n  {\n    res = Mmul(res, now);  //res *= now;\n    res = Mdivide(res, i); // res /= i;\n    now--;\n  }\n  return res;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// TEMPLATE(data structure)\n///////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\nclass BIT\n{\npublic:\n  BIT(int size)\n  {\n    BITTable.assign(++size, 0);\n  }\n  T sum(int k)\n  {\n    T res = 0;\n    for (++k; k > 0; k -= k & -k)\n    {\n      res += BITTable[k];\n    }\n    return res;\n  }\n  T sum(int l, int r)\n  {\n    if (l == 0)\n      return sum(r);\n    return sum(r) - sum(l - 1);\n  }\n  void update(int k, T x)\n  { // b[k] += x;\n    for (++k; k < (int)BITTable.size(); k += k & -k)\n      BITTable[k] += x;\n  }\n\nprivate:\n  vector<T> BITTable;\n};\n\ntemplate <typename T>\nclass IntervalTree\n{\n  using F = function<T(T, T)>;\n\npublic:\n  IntervalTree(int n, const F func, const T init) : func(func), init(init)\n  {\n    size = 1;\n    while ((int)size < n)\n      size <<= 1;\n    table.assign(2 * size, init);\n  }\n  void set(int k, T &x)\n  {\n    table[size + k] = x;\n  }\n  void build()\n  {\n    for (int i = size - 1; i >= 0; --i)\n    {\n      table[i] = func(table[i * 2], table[i * 2 + 1]);\n    }\n  }\n  void update(int k, const T &x)\n  {\n    k += size;\n    table[k] = x;\n    while (k >>= 1)\n    {\n      table[k] = func(table[k * 2], table[k * 2 + 1]);\n    }\n  }\n  T query(int a, int b)\n  {\n    T L = init, R = init;\n    for (a += size, b += size; a < b; a >>= 1, b >>= 1)\n    {\n      if (a & 1)\n        L = func(L, table[a++]);\n      if (b & 1)\n        R = func(table[--b], R);\n    }\n    return func(L, R);\n  }\n  T operator[](const int k) const\n  {\n    return table[k + size];\n  }\n\nprivate:\n  unsigned int size;\n  vector<T> table;\n  const F func;\n  const T init;\n};\n\nclass UnionFind\n{\npublic:\n  explicit UnionFind(int _n) : n(_n)\n  {\n    par.resize(static_cast<unsigned long>(_n));\n    rank.resize(static_cast<unsigned long>(_n));\n    sizes.resize(static_cast<unsigned long>(_n));\n    for (int i = 0; i < _n; i++)\n    {\n      par[i] = i;\n      rank[i] = 0;\n      sizes[i] = 1;\n    }\n  }\n  int find(int a)\n  {\n    if (par[a] == a)\n      return a;\n    return par[a] = find(par[a]);\n  }\n  bool same(int a, int b)\n  {\n    return find(a) == find(b);\n  }\n  void unite(int a, int b)\n  {\n    link(find(a), find(b));\n  }\n  int size(int a)\n  {\n    return sizes[find(a)];\n  }\n  void view()\n  {\n    for (int i = 0; i < n; i++)\n    {\n      cout << \" par\"\n           << \"[\" << i << \"]=\" << par[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    for (int i = 0; i < n; i++)\n    {\n      cout << \"size\"\n           << \"[\" << i << \"]=\" << sizes[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    cout << endl;\n  }\n\nprivate:\n  void link(int a, int b)\n  {\n    if (same(a, b))\n      return;\n    if (rank[a] > rank[b])\n    {\n      par[b] = a;\n      sizes[a] += sizes[b];\n      sizes[b] = 0;\n    }\n    else\n    {\n      par[a] = b;\n      if (rank[a] == rank[b])\n        rank[b]++;\n      sizes[b] += sizes[a];\n      sizes[a] = 0;\n    }\n  }\n  int n;\n  vector<int> par;\n  vector<int> rank;\n  vector<int> sizes;\n};\n\nnamespace geo\n{\n#define IL inline\ntypedef double D;\ntypedef bool B;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\nB comp(const P &l, const P &r)\n{\n  return (l.X == r.X) ? l.Y < r.Y : l.X < r.X;\n}\ntypedef pair<P, P> L;  //line\ntypedef pair<P, P> LS; //line segment\ntypedef pair<P, D> C;  //circle\ntypedef vector<P> Poly;\nconst D EPS = 1e-8;\n//Decompotision Macro\n#define DCl(a, b, l) \\\n  P a, b;            \\\n  tie(a, b) = l\n#define DCc(a, b, c) \\\n  P a;               \\\n  D b;               \\\n  tie(a, b) = c\n\n//A dot B\nIL D dot(P a, P b) { return a.X * b.X + a.Y * b.Y; }\n//A cross B\nIL D cross(P a, P b) { return a.X * b.Y - a.Y * b.X; }\nIL D ccw(P a, P b, P c)\n{\n  return cross(b - a, c - a);\n}\n\nIL int sgn(P a, P b, P c)\n{\n  if (cross(b - a, c - a) > EPS)\n    return 1;\n  if (cross(b - a, c - a) < -EPS)\n    return -1;\n  if (dot(b - a, c - a) < -EPS)\n    return 2; // b-a-c\n  if (dot(a - b, c - b) < -EPS)\n    return -2; // a-b-c\n  return 0;\n}\nIL D signed_distance_P_L(P p, L l)\n{\n  DCl(a, b, l);\n  return ccw(a, b, p) / abs(b - a);\n}\n\nIL D distance_P_L(P p, L l)\n{\n  return abs(signed_distance_P_L(p, l));\n}\n\nIL D distance_P_LS(P p, LS ls)\n{\n  DCl(a, b, ls);\n  if (dot(b - a, p - a) < EPS)\n    return abs(p - a);\n  if (dot(a - b, p - b) < EPS)\n    return abs(p - b);\n  return abs(cross(b - a, p - a)) / abs(b - a);\n}\n\nIL B is_L_L(L p, L q)\n{\n  DCl(a, b, p);\n  DCl(c, d, q);\n  return abs(cross(a - b, c - d)) > EPS ||\n         abs(cross(a - b, d - b)) < EPS;\n}\nIL B is_L_LS(L l, LS ls)\n{\n  DCl(a, b, l);\n  DCl(c, d, ls);\n  return ccw(a, b, c) * ccw(a, b, d) < EPS;\n}\nIL B is_LS_LS(LS p, LS q)\n{\n  DCl(a, b, p);\n  DCl(c, d, q);\n  return sgn(a, b, c) * sgn(a, b, d) <= 0 && sgn(c, d, a) * sgn(c, d, b) <= 0;\n}\n\nIL D distance_LS_LS(LS p, LS q)\n{\n  if (is_LS_LS(p, q))\n    return 0;\n  return min({distance_P_LS(p.fi, q),\n              distance_P_LS(p.se, q),\n              distance_P_LS(q.fi, p),\n              distance_P_LS(q.se, p)});\n}\n\n//caution: have to use isintersected_L_L before this function\nIL P cross_L_L(L p, L q)\n{\n  DCl(a, b, p);\n  D d1 = signed_distance_P_L(a, q);\n  D d2 = signed_distance_P_L(b, q);\n  return (a * d2 - b * d1) / (d2 - d1);\n}\n\nIL B is_C_C(C p, C q)\n{\n  DCc(cp, rp, p);\n  DCc(cq, rq, q);\n  D d = abs(cp - cq);\n  return abs(rp - rq) - d < EPS &&\n         rp + rq - d > -EPS;\n}\nIL LS cross_C_C(C p, C q)\n{\n  DCc(cp, rp, p);\n  DCc(cq, rq, q);\n  D d = abs(cp - cq);\n  D rc = (d * d + rp * rp - rq * rq) / (2 * d);\n  D rs = sqrt(rp * rp - rc * rc);\n  P diff = (cq - cp) / d;\n  return {cp + P(rc, rs) * diff, cp + P(rc, -rs) * diff};\n}\nIL Poly convex_hull(Poly p)\n{\n  int n = p.size();\n  Poly res(2 * n);\n  int k = 0, t;\n  sort(all(p), comp);\n  rep(i, 0, n)\n  {\n    while (k > 1 && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n      k--;\n    res[k++] = p[i];\n  }\n  t = k;\n  rep(j, 0, n - 1)\n  {\n    int i = n - 2 - j;\n    while (k > t && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n      k--;\n    res[k++] = p[i];\n  }\n  res.resize(k - 1);\n  return res;\n}\nIL B convex_in(Poly &l, P &p)\n{\n  int a = 0, b = l.size(), c;\n  D A, C;\n  P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n  while (b - a > 1)\n  {\n    c = (a + b) / 2;\n    A = cross(l[a] - g, p - l[a]);\n    C = cross(l[c] - g, p - l[c]);\n    if (cross(l[a] - g, l[c] - g) >= 0)\n    {\n      if (A > -EPS && C < -EPS)\n        b = c;\n      else\n        a = c;\n    }\n    else\n    {\n      if (C < -EPS || A > -EPS)\n        b = c;\n      else\n        a = c;\n    }\n  }\n  return (cross(l[b % l.size()] - l[a], p - l[b % l.size()]) > -EPS);\n}\n\n//not necessary?\nIL D convex_area(Poly &l)\n{\n  double res = 0;\n  int n = l.size();\n  rep(i, 2, n)\n      res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n  return res;\n}\nIL D area(Poly &l)\n{\n  double res = 0;\n  int n = l.size();\n  rep(i, 0, n)\n      res += cross(l[i], l[(i + 1) % n]);\n  return abs(res) / 2.0;\n}\ninline vector<L> tangent_line(C c, P p)\n{\n  vector<L> res;\n  DCc(cp, r, c);\n  P v = p - cp;\n  D dist = abs(v);\n  if (dist - r > -EPS)\n  {\n    double _cos = r / dist;\n    double _sin = sqrt(1.0 - _cos * _cos);\n    v = v * (r / dist);\n    {\n      P e = P(_cos * v.X - _sin * v.Y, _sin * v.X + _cos * v.Y);\n      res.push_back({p, cp + e});\n    }\n    if (dist - r > EPS)\n    {\n      P e = P(_cos * v.X + _sin * v.Y, -_sin * v.X + _cos * v.Y);\n      res.push_back({p, cp + e});\n    }\n  }\n  return res;\n}\nIL vector<L> inner_common_tangent_line(C p, C q)\n{\n  vector<L> res;\n  DCc(Mp, Rp, p);\n  DCc(Mq, Rq, q);\n  D dist = abs(Mp - Mq);\n  if (dist - (Rp + Rq) > -EPS)\n  {\n    P mid = (Mq * Rp + Mp * Rq) / (Rp + Rq);\n    res = tangent_line(p, mid);\n  }\n  return res;\n}\ninline vector<L> outer_common_tangent_line(C p, C q)\n{\n  vector<L> res;\n  DCc(Mp, Rp, p);\n  DCc(Mq, Rq, q);\n  P v = Mp - Mq;\n  D dist = abs(v);\n  if (dist - abs(Rp - Rq) > -EPS)\n  {\n    if (abs(Rp - Rq) < EPS)\n    {\n      P e = v * P(0, 1);\n      e = e / dist;\n      res.pb(L(Mp + e, Mq + e));\n      res.pb(L(Mp - e, Mq - e));\n    }\n    else\n    {\n      P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n      res = tangent_line(p, mid);\n    }\n  }\n  return res;\n}\n\nvector<Poly> decomposition(Poly p)\n{\n  int n = p.size();\n  vector<Poly> res;\n  while (n >= 3)\n  {\n    [&]() {\n      rep(i, 0, n)\n      {\n        P a = p[i];\n        P b = p[(i + 1) % n];\n        P c = p[(i + 2) % n];\n        if (ccw(a, b, c) < 0)\n          continue;\n        if ([&]() {\n              rep(j, 3, n)\n              {\n                P d = p[(i + j) % n];\n                if (ccw(a, b, d) > -EPS && ccw(b, c, d) > -EPS && ccw(c, a, d) > -EPS)\n                  return true;\n              }\n              return false;\n            }())\n          continue;\n        Poly nxt;\n        rep(j, 0, n) if ((i + j) % n != (i + 1) % n)\n            nxt.push_back(p[(i + j) % n]);\n        swap(p, nxt);\n        res.push_back({a, b, c});\n        n--;\n        return;\n      }\n    }();\n  }\n  return res;\n}\nint in_triangle(P p, Poly q)\n{\n  rep(i, 0, 3) if (abs(p - q[i]) < EPS) return 3; //on point\n  rep(i, 0, 3)\n  {\n    int s = sgn(q[i], q[(i + 1) % 3], p);\n    if (s != 1)\n    {\n      if (s == 0)\n        return 2; //on line\n      else\n        return 0; // not in\n    }\n  }\n  return 1; // inside triangle\n}\nint in_C(P q, C c)\n{\n  DCc(p, r, c);\n  if (abs(r - abs(p - q)) < EPS)\n    return 2; //on\n  return r - abs(p - q) > -EPS ? 1 : 0;\n}\nint is_triangle_C(Poly t, C c)\n{\n  t = convex_hull(t);\n  DCc(p, r, c);\n  int cnt = 0;\n  rep(i, 0, 3)\n      cnt += (in_C(t[i], c) > 0);\n  if (cnt == 3)\n    return 3; // t in c\n  if (cnt == 0)\n  {\n    double d = distance_P_LS(p, LS(t[2], t[0]));\n    rep(i, 0, 2)\n        d = min(d, distance_P_LS(p, LS(t[i], t[i + 1])));\n    if (r - d > EPS)\n      return 1; //intersect\n    if (in_triangle(p, t))\n      return 2; //c in t\n    else if (r - d < -EPS)\n      return 0; //not intersect\n  }\n  return 1; //intersect\n}\n\n//p must be convex and ccw\nLS diameter(Poly &p)\n{\n  int n = p.size();\n  int is = 0, js = 0;\n  rep(i, 0, n) if (p[i].Y > p[is].Y)\n      is = i;\n  rep(i, 0, n) if (p[i].Y < p[js].Y)\n      js = i;\n  LS res = {p[is], p[js]};\n  {\n    int i = is;\n    int j = js;\n    do\n    {\n      int ni = (i + 1) % n;\n      int nj = (j + 1) % n;\n      if (cross(p[ni] - p[i], p[nj] - p[j]) < EPS)\n        i = ni;\n      else\n        j = nj;\n      if (abs(res.fi - res.se) < abs(p[i] - p[j]))\n        res = LS(p[i], p[j]);\n    } while (i != is || j != js);\n  }\n  return res;\n}\n\nPoly cross_C_L(C c, L v)\n{\n  DCc(p, r, c);\n  DCl(a, b, v);\n  a -= p;\n  b -= p;\n  P u = a - b;\n  u = P(-u.Y, u.X);\n  P x = cross_L_L({a, b}, {P(0, 0), u});\n  D d = abs(x);\n  Poly res;\n  if (d - r > EPS)\n    return res;\n  D y = sqrt(r * r - d * d);\n  res.pb(p + x + (b - a) * y / abs(b - a));\n  //if(d-r>-EPS)return res;\n  res.pb(p + x + (a - b) * y / abs(b - a));\n  return res;\n}\n} // namespace geo\n\n///////////////////////////////////////////////////////////////////////////////////\n// MAIN\n///////////////////////////////////////////////////////////////////////////////////\n// 735134400 約数が1344個ある高度合成数(<= 1e9)\n// 897612484786617600 約数が103680個ある高度合成数(<= 1e18)\n// 苦手分野 重複順列\n// LLの数値をつかう時は最後にLLをつける癖をつけよう\n\nvoid solve(int &n)\n{\n  using namespace geo;\n  int sx, sy, ex, ey;\n  cin >> sx >> sy >> ex >> ey;\n  P S(sx, sy), E(ex, ey);\n  LS seg(S, E);\n  vector<LS> v[51];\n  double height[51];\n  bool is_ok = true;\n  for (int i = 0; i < n; i++)\n  {\n    int minx, miny, maxx, maxy, h;\n    cin >> minx >> miny >> maxx >> maxy >> h;\n    LS l1(P(minx, miny), P(minx, maxy)), l2(P(minx, miny), P(maxx, miny)), l3(P(maxx, maxy), P(maxx, miny)), l4(P(maxx, maxy), P(minx, maxy));\n    if (is_LS_LS(l1, seg) || is_LS_LS(l2, seg) || is_LS_LS(l3, seg) || is_LS_LS(l4, seg))\n    {\n      is_ok = false;\n    }\n    if (minx <= sx && sx <= maxx && minx <= ex && ex <= maxx && miny <= sy && sy <= maxy && miny <= ey && ey <= maxy)\n    {\n      is_ok = false;\n    }\n    v[i].push_back(l1);\n    v[i].push_back(l2);\n    v[i].push_back(l3);\n    v[i].push_back(l4);\n    height[i] = h;\n  }\n  if (!is_ok)\n  {\n    cout << 0 << endl;\n    return;\n  }\n  double ok = 0., ng = 1001.;\n  for (int cont = 0; cont < 50; cont++)\n  {\n    double mid = (ok + ng) / 2;\n    auto check = [&](double mid) {\n      for (int i = 0; i < n; i++)\n      {\n        for (int j = 0; j < (int)v[i].size(); j++)\n        {\n          if (height[i] >= mid)\n          {\n            if (distance_LS_LS(seg, v[i][j]) < mid)\n              return false;\n          }\n          else\n          {\n            if (distance_LS_LS(seg, v[i][j]) < sqrt(mid * mid - (mid - height[i]) * (mid - height[i])))\n              return false;\n          }\n        }\n      }\n      return true;\n    };\n    if (check(mid))\n      ok = mid;\n    else\n      ng = mid;\n  }\n  cout << ok << endl;\n}\n\nint n;\n\nint main()\n{\n  while (cin >> n, n)\n  {\n    solve(n);\n  }\n#ifdef LOCAL_DEFINE\n  cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s.\" << endl;\n  show(MOD);\n#endif\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// NOTE\n///////////////////////////////////////////////////////////////////////////////////\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nclass point2d {\npublic:\n\tdouble x, y;\n\tpoint2d() : x(0), y(0) {};\n\tpoint2d(double x_, double y_) : x(x_), y(y_) {};\n\tbool operator==(const point2d& p) { return x == p.x && y == p.y; }\n\tbool operator!=(const point2d& p) { return x != p.x || y != p.y; }\n\tpoint2d& operator+=(const point2d& p) { x += p.x; y += p.y; return *this; }\n\tpoint2d& operator-=(const point2d& p) { x -= p.x; y -= p.y; return *this; }\n\tpoint2d& operator*=(const double v) { x *= v; y *= v; return *this; }\n\tpoint2d operator+(const point2d& p) const { return point2d(*this) += p; }\n\tpoint2d operator-(const point2d& p) const { return point2d(*this) -= p; }\n\tpoint2d operator*(const double v) const { return point2d(*this) *= v; }\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return std::sqrt(x * x + y * y); }\n\tdouble dot(const point2d& p) { return x * p.x + y * p.y; }\n\tdouble cross(const point2d& p) { return x * p.y - y * p.x; }\n\tint ccw(const point2d& p1, const point2d& p2) {\n\t\t// RETURNS: P0 -> P1 -> P2 IS COLLINEAR --> ((P0, P1, P2) IS CENTER --> (2, -2, 0)), COUNTER-CLOCKWISE --> 1, CLOCKWISE --> -1\n\t\tpoint2d pr1 = p1 - point2d(*this);\n\t\tpoint2d pr2 = p2 - point2d(*this);\n\t\tif (pr1.cross(pr2) != 0) return pr1.cross(pr2) > 0 ? 1 : -1;\n\t\tif (pr1.dot(pr2) < 0) return 2;\n\t\treturn pr1.norm() < pr2.norm() ? -2 : 0;\n\t}\n};\nclass segment2d {\npublic:\n\tpoint2d p1, p2;\n\tsegment2d() : p1(point2d()), p2(point2d()) {};\n\tsegment2d(const point2d& p1_, const point2d& p2_) : p1(p1_), p2(p2_) {};\n\tdouble norm() { return (p1 - p2).norm(); }\n\tdouble abs() { return (p1 - p2).abs(); }\n};\ndouble distance(point2d p, segment2d s) {\n\tdouble d1 = (p - s.p1).norm();\n\tdouble d2 = (p - s.p2).norm();\n\tdouble d0 = s.norm();\n\tif (d0 + d1 < d2 || d0 + d2 < d1) return std::sqrt(std::min(d1, d2));\n\treturn std::abs((p - s.p1).cross(s.p2 - s.p1)) / std::sqrt(d0);\n}\nbool intersect(segment2d s1, segment2d s2) {\n\treturn s1.p1.ccw(s1.p2, s2.p1) * s1.p1.ccw(s1.p2, s2.p2) <= 0 && s2.p1.ccw(s2.p2, s1.p1) * s2.p1.ccw(s2.p2, s1.p2) <= 0;\n}\n\nint N; point2d sx, sy, L[100], R[100], P1[100], P2[100], P3[100], P4[100]; long double h[100];\n\nint main() {\n\twhile (true) {\n\t\tcin >> N; if (N == 0) break;\n\t\tcin >> sx.x >> sx.y >> sy.x >> sy.y;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> L[i].x >> L[i].y >> R[i].x >> R[i].y >> h[i];\n\t\t\tP1[i] = point2d{ L[i].x,L[i].y };\n\t\t\tP2[i] = point2d{ L[i].x,R[i].y };\n\t\t\tP3[i] = point2d{ R[i].x,R[i].y };\n\t\t\tP4[i] = point2d{ R[i].x,L[i].y };\n\t\t}\n\t\tlong double minx = 1e9;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlong double V01 = distance(P1[i], segment2d(sx, sy));\n\t\t\tlong double V02 = distance(P2[i], segment2d(sx, sy));\n\t\t\tlong double V03 = distance(P3[i], segment2d(sx, sy));\n\t\t\tlong double V04 = distance(P4[i], segment2d(sx, sy));\n\t\t\tlong double V05 = distance(sx, segment2d(P1[i], P2[i]));\n\t\t\tlong double V06 = distance(sx, segment2d(P2[i], P3[i]));\n\t\t\tlong double V07 = distance(sx, segment2d(P3[i], P4[i]));\n\t\t\tlong double V08 = distance(sx, segment2d(P4[i], P1[i]));\n\t\t\tlong double V09 = distance(sy, segment2d(P1[i], P2[i]));\n\t\t\tlong double V10 = distance(sy, segment2d(P2[i], P3[i]));\n\t\t\tlong double V11 = distance(sy, segment2d(P3[i], P4[i]));\n\t\t\tlong double V12 = distance(sy, segment2d(P4[i], P1[i]));\n\t\t\tlong double V = min({ V01, V02, V03, V04, V05, V06, V07, V08, V09, V10, V11, V12 });\n\n\t\t\t// 0 になるか判定\n\t\t\tif (L[i].x <= sx.x && sx.x <= R[i].x && L[i].y <= sx.y && sx.y <= R[i].y) V = 0;\n\t\t\tif (L[i].x <= sy.x && sy.x <= R[i].x && L[i].y <= sy.y && sy.y <= R[i].y) V = 0;\n\t\t\tif (intersect(segment2d(sx, sy), segment2d(P1[i], P2[i])) == true) V = 0;\n\t\t\tif (intersect(segment2d(sx, sy), segment2d(P2[i], P3[i])) == true) V = 0;\n\t\t\tif (intersect(segment2d(sx, sy), segment2d(P3[i], P4[i])) == true) V = 0;\n\t\t\tif (intersect(segment2d(sx, sy), segment2d(P4[i], P1[i])) == true) V = 0;\n\n\t\t\tlong double score = 0;\n\t\t\tif (V <= h[i]) score = V;\n\t\t\telse {\n\t\t\t\tscore = V * V / (2.0L * h[i]) + (0.5L * h[i]);\n\t\t\t}\n\t\t\tminx = min(minx, score);\n\t\t}\n\t\tprintf(\"%.12Lf\\n\", minx);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-10;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ndouble dot(P a, P b){ return a.real() * b.real() + a.imag() * b.imag(); }\ndouble cross(P a, P b){ return   a.real() * b.imag() - a.imag() * b.real(); }\n\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1; //???????¨???????\n  if(cross(b,c) < -EPS) return -1; // ????¨???????\n  if(dot(b,c) < -EPS) return 2; // c -- a -- b ????????´???\n  if(norm(b) < norm(c)) return -2; // a -- b -- c ????????´???\n  return 0; // a -- c -- b ????????´????\n}\n\n// ????????¨?????????????????????????????????????????????true???\nbool isIntersect(L s1, L s2){\n  \n  //ccw ??????????????????????????¨, ????????????????????´?????????????????¨??????????????????????????????\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\n\n// ????????¨???????????¢\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  //??´?????¨???????????¢\n}\n\n// ????????¨??????????????¢\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\n/* \n   ???????§???¢???????????????????????????????§???¢????????¨????¢????????????¨???????????????????????? \n   ????????? 0:?????¨ 1:?¢???? 2:?????¨ \n   ???????¨?????????§????????¨??????????????? \n   O(log n) \n*/\nint convex_contains(vector<P> v, P p){ \n  int n = v.size(); \n  P g = (v[0] + v[n/3] + v[2*n/3]) / 3.0; \n  int a = 0, b = n; \n  while(a + 1 < b){ \n    int c = (a + b) / 2; \n    if(cross(v[a] - g, v[c] - g) > 0){ \n      if(cross(v[a]-g, p-g) > 0 && cross(v[c]-g, p-g) < 0) b = c; \n      else a = c; \n    } else { \n      if(cross(v[a]-g, p-g) < 0 && cross(v[c]-g, p-g) > 0) a = c; \n      else b = c; \n    } \n  } \n  b %= n; \n  if(cross(v[a] - p, v[b] - p) < 0) return 0; \n  if(cross(v[a] - p, v[b] - p) > 0) return 2; \n  return 1; \n} \n\nint N;\nL R;\nvector<L> S[4];\nint H[111];\n\ndouble getD(L s,int id){\n  vector<P> ps;\n  for(int j=0;j<4;j++) \n    ps.push_back( S[j][id].first );  \n  if( convex_contains( ps, R.first ) | convex_contains( ps, R.second ) ) return 0.0;\n\n  double ret = 1e100;\n  for(int i=0;i<4;i++)\n    ret = min( ret, getDistanceSS( s, S[i][id] ) );\n  return ret;\n}\n\nbool check( double h ){\n  for(int i=0;i<N;i++){\n    double rh = min((double) H[i], h );\n    double k;\n    if( h < EPS ) k = 0;\n    else\n      k = cos(asin(rh/h-1.0)) * h;\n    //cout << rh << \" \" << h << \" \" << k  << \" > \" << getD(R,i) << endl;\n    if( k+EPS > getD(R,i) ) return false; \n  }\n  return true;\n}\n\nint main(){\n  while( cin >> N && N ){\n    int sx,sy,ex,ey;\n    cin >> sx >> sy >> ex >> ey;\n    R = L(P(sx,sy),P(ex,ey));\n    for(int i=0;i<4;i++) S[i].clear();\n    for(int i=0;i<N;i++){\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2 >> H[i];\n      S[0].push_back( L( P(x1,y1), P(x2,y1) )  );\n      S[1].push_back( L( P(x2,y1), P(x2,y2) )  );\n      S[2].push_back( L( P(x2,y2), P(x1,y2) )  );\n      S[3].push_back( L( P(x1,y2), P(x1,y1) )  );\n    }\n    double st = 0.0, ed = 1000.0;\n    double res = 0.0;\n    while( abs(ed-st) > EPS ){\n      double h = (st+ed)/2.0;\n      if( check(h) ){\n\tst = h;\n\tres = max( res, h );\n      }  else\n\ted = h;\n    }\n    printf(\"%.10lf\\n\",st);\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<complex>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define inf (1<<29)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -inf,double y = -inf): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nstruct Circle\n{\n  Point p;\n  double r;\n  Circle(Point p=Point(),double r=inf):p(p),r(r){}\n};\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n\n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n\nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //polyの最後の要素 = polyの最初の要素 であることが前提\n  \n  //そうでない場合は\n    rep(i,poly.size())\n      if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n    double sum = 0;\n    for(int i=0; i < (int)poly.size() ;i++)\n      {\n        if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n          sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n        else\n          sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n      }\n      return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS); \n}  \n\n\nPoint project(Segment s,Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1 + base*t;\n}\n\ndouble getDistance(Segment s1,Segment s2)\n{\n  if(isIntersect(s1,s2))return 0;\n  return min( min(getDistanceSP(s1,s2.p1), getDistanceSP(s1,s2.p2) ),\n\t      min(getDistanceSP(s2,s1.p1), getDistanceSP(s2,s1.p2) ));\n}\n//-------------------------------\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\nPoint crosspoint(Line l, Line m) {\n  double A = cross(l.p2 - l.p1, m.p2 - m.p1);\n  double B = cross(l.p2 - l.p1, l.p2 - m.p1);\n  if (abs(A) < EPS && abs(B) < EPS) return m.p1; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m.p1 +   (m.p2 - m.p1) * (B / A);\n}\n//------------------------------------------^^^\n\nstruct Obj\n{\n  vector<Point> ps;\n  double h;\n  Obj(Point ps1=Point(),Point ps2=Point(),double h=-inf):h(h)\n  {\n    ps.clear();\n    ps.resize(4);\n    ps[0].x = ps1.x,ps[0].y = ps1.y;\n    ps[1].x = ps1.x,ps[1].y = ps2.y;\n    ps[2].x = ps2.x,ps[2].y = ps2.y;\n    ps[3].x = ps2.x,ps[3].y = ps1.y;\n  }\n};\nint N;\nPoint s,e;\n\nint main()\n{\n\n  while(cin >> N,N)\n    {\n      cin >> s.x >> s.y >> e.x >> e.y;  \n\n      Obj vec;\n      Circle c(s);\n      Segment seg(s,e);\n      rep(i,N)\n\t{\n\t  Point a,b;\n\t  double h;\n\t  cin >> a.x >> a.y >> b.x >> b.y >> h;\n\t  if(c.r == 0)continue;\n\t  vec = Obj(a,b,h);\n\t  rep(j,4)\n\t    {\n\t      if(isIntersect(seg,Segment(vec.ps[j],vec.ps[(j+1)%4])) )\n\t\t{\n\t\t  c.r = 0;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  if(inPolygon(vec.ps,s) || inPolygon(vec.ps,e))\n\t    {\n\t      c.r = 0;\n\t      continue;\n\t    }\n\n\t  rep(j,4)\n\t    {\n\t      double w = distanceSS(seg,Segment(vec.ps[j],vec.ps[(j+1)%4]));\n  //double w = getDistance(seg,Segment(vec.ps[j],vec.ps[(j+1)%4]));\n\t      double dist = (h*h+w*w)/(2.0*h);\n\t      if(!equals(w,h) && w < h)dist = w;\n\n\t      c.r = min(c.r,dist);\n\t    }\n\n\t}\n      cout << setiosflags(ios::fixed) << setprecision(10) << c.r << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst double EPS = 1e-6;\n\nstruct Point\n{\n\tdouble x, y;\n\n\tPoint() : x( 0 ), y( 0 ) {}\n\tPoint( const double x, const double y ) : x( x ), y( y ) {}\n\tPoint( const Point &a ) : x( a.x ), y( a.y ) {}\n\t\n\tconst Point operator + ( const Point &a ) const\n\t{\n\t\treturn Point( x + a.x, y + a.y );\n\t}\n\n\tPoint& operator += ( const Point &a ) \n\t{\n\t\tx += a.x;\n\t\ty += a.y;\n\n\t\treturn *this;\n\t}\n\n\tconst Point operator - ( const Point &a ) const\n\t{\n\t\treturn Point( x + ( -a.x ), y + ( -a.y ) );\n\t}\n\n\tPoint& operator -= ( const Point &a )\n\t{\n\t\tx -= a.x;\n\t\ty -= a.y;\n\n\t\treturn *this;\n\t}\n\n\tconst Point operator * ( const double a ) const\n\t{\n\t\treturn Point( x * a, y * a );\n\t}\n\n\tPoint& operator *= ( const double a )\n\t{\n\t\tx *= a;\n\t\ty *= a;\n\n\t\treturn *this;\n\t}\n\n\tconst Point operator / ( const double a ) const\n\t{\n\t\treturn Point( x / a, y / a );\n\t}\n\n\tPoint& operator /= ( const double a )\n\t{\n\t\tx /= a;\n\t\ty /= a;\n\n\t\treturn *this;\n\t}\n\n\tbool operator < ( const Point &a ) const\n\t{\n\t\treturn x == a.x ? y < a.y : x < a.x;\n\t}\n\n\tdouble abs() const\n\t{\n\t\treturn sqrt( pow( x, 2. ) + pow( y, 2. ) );\n\t}\n};\n\n// 二点間の距離\ndouble distance( const Point &a, const Point &b )\n{\n\treturn sqrt( pow( a.x - b.x, 2. ) + pow( a.y - b.y, 2. ) );\n}\n\n// 内積（ドット積）\ndouble dot( const Point &a, const Point &b )\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n// 外積（クロス積）\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// 線分 ( p1, p2 ) と点 q の距離\ndouble distance_segment_point( const Point &p1, const Point &p2, const Point q )\n{\n\tif ( EPS < dot( p2 - p1, q - p1 ) && EPS < dot( p1 - p2, q - p2 ) )\n\t{\n\t\treturn abs( cross( p2 - p1, q - p1 ) ) / ( p2 - p1 ).abs();\n\t}\n\telse\n\t{\n\t\treturn min( distance( p1, q ), distance( p2, q ) );\n\t}\n}\n\n// 線分 ( p1, p2 ) に点 q が乗っているか\nbool point_on_segment( const Point &p1, const Point &p2, const Point &q )\n{\n\treturn abs( cross( p1 - q, p2 - q ) ) <= EPS && dot( p1 - q, p2 - q ) <= EPS;\n}\n\n// 直線 ( p1, p2 ) と直線 ( q1, q2 ) の交点\nPoint lines_intersection( const Point &p1, const Point &p2, const Point &q1, const Point &q2 )\n{\n\treturn p1 + ( p2 - p1 ) * ( cross( q2 - q1, q1 - p1 ) / cross( q2 - q1, p2 - p1 ) );\n}\n\n// 線分 ( p1, p2 ) と線分 ( q1, q2 ) が交差するか\nbool segments_intersection( const Point &p1, const Point &p2, const Point &q1, const Point &q2 )\n{\t\t\n\tif ( abs( cross( p1 - p2, q1 - q2 ) ) <= EPS ) // is parallel\n\t{\n\t\treturn point_on_segment( p1, p2, q1 ) ||\n\t\t\t   point_on_segment( p1, p2, q2 ) ||\n\t\t\t   point_on_segment( q1, q2, p1 ) ||\n\t\t\t   point_on_segment( q1, q2, p2 );\n\t}\n\telse\n\t{\n\t\tPoint r( lines_intersection( p1, p2, q1, q2 ) );\n\t\treturn point_on_segment( p1, p2, r ) && point_on_segment( q1, q2, r );\n\t}\n}\n\n// 三角形 ( a, b, c ) の中に点 p があるか\nbool point_in_triangle( const Point &a, const Point &b, const Point &c, const Point &p )\n{\n\tint res = 0;\n\tres += EPS < cross( b - a, p - a ) ? 1 : -1;\n\tres += EPS < cross( c - b, p - b ) ? 1 : -1;\n\tres += EPS < cross( a - c, p - c ) ? 1 : -1;\n\n\tif ( abs( res ) == 3 )\n\t{\n\t\treturn true;\n\t}\n\treturn point_on_segment( a, b, p ) || point_on_segment( b, c, p ) || point_on_segment( c, a, p );\n}\n\ndouble search( const Point &p1, const Point &p2, const Point &q, const int h )\n{\n\tconst double dist = distance_segment_point( p1, p2, q );\n\tif ( dist - EPS <= h )\n\t{\n\t\treturn dist;\n\t}\n\n\tdouble lb = 0, ub = 1000;\n\tREP( i, 0, 100 )\n\t{\n\t\tdouble r = ( lb + ub ) / 2;\n\t\tif ( r <= distance( Point( 0, r ), Point( dist, h ) ) + EPS )\n\t\t{\n\t\t\tlb = r;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tub = r;\n\t\t}\n\t}\n\n\treturn lb;\n}\n\ndouble solve( const int n )\n{\n\tint sx, sy, ex, ey;\n\tcin >> sx >> sy >> ex >> ey;\n\tPoint s( sx, sy ), e( ex, ey );\n\n\tVI hs;\n\tvector< Point > points;\n\tvector< pair<Point,Point> > lines;\n\n\tREP( i, 0, n )\n\t{\n\t\tint x1, y1, x2, y2, h;\n\t\tcin >> x1 >> y1 >> x2 >> y2 >> h;\n\n\t\tpoints.PB( Point( x1, y1 ) );\n\t\tpoints.PB( Point( x2, y2 ) );\n\t\tpoints.PB( Point( x1, y2 ) );\n\t\tpoints.PB( Point( x2, y1 ) );\n\n\t\tlines.PB( MP( Point( x1, y1 ), Point( x1, y2 ) ) );\n\t\tlines.PB( MP( Point( x1, y1 ), Point( x2, y1 ) ) );\n\t\tlines.PB( MP( Point( x2, y2 ), Point( x1, y2 ) ) );\n\t\tlines.PB( MP( Point( x2, y2 ), Point( x2, y1 ) ) );\n\n\t\ths.PB( h );\n\t}\n\n\tREP( i, 0, lines.size() )\n\t{\n\t\tif ( segments_intersection( s, e, lines[i].fst, lines[i].snd ) )\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tREP( i, 0, n )\n\t{\n\t\tif ( point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 2 ], s ) ||\n\t\t\t point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 2 ], e ) ||\n\t\t\t point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 3 ], s ) ||\n\t\t\t point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 3 ], e ) )\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdouble res = 1000;\n\tREP( i, 0, n * 4 )\n\t{\n\t\tres = min( res, search( s, e, points[i], hs[ i / 4 ] ) );\n\t\tres = min( res, search( lines[i].fst, lines[i].snd, s, hs[ i / 4 ] ) );\n\t\tres = min( res, search( lines[i].fst, lines[i].snd, e, hs[ i / 4 ] ) );\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\tcout << setprecision( 4 ) << fixed;\n\n\twhile ( true )\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif ( !n )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << solve( n ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\ntypedef double Num;\ntypedef complex<Num> Pt2;\ntypedef vector<Pt2>  Polygon2;\n\nstruct Line2 : public vector<Pt2> {\n\tLine2(Pt2 a, Pt2 b) { push_back(a); push_back(b); }\n};\n\nconst double eps = 1e-10;\nNum  dot  (Pt2 a, Pt2 b) { return (a*conj(b)).real(); }\nNum  cross(Pt2 a, Pt2 b) { return (conj(a)*b).imag(); }\nPt2  vec  (Line2 l)      { return l[1]-l[0]; }\n\nint ccw(Pt2 a, Pt2 b, Pt2 c) {\n\tb-=a; c-=a;\n\tif(cross(b,c) > 0 ) return +1; // ccw\n\tif(cross(b,c) < 0 ) return -1; // cw\n\tif(  dot(b,c) < 0 ) return +2; // cab\n\tif(norm(b)<norm(c)) return -2; // abc\n\treturn 0;                      // acb\n}\n\nint ccw(Line2 s, Pt2 p) {\n\treturn ccw(s[0], s[1], p);\n}\n\nbool intersectSP(Line2 s, Pt2 p) {\n\treturn abs(s[0]-p)+abs(s[1]-p) < abs(s[1]-s[0])+eps;\n}\n\nbool intersectSS(Line2 s, Line2 t) {\n\treturn ccw(s,t[0])*ccw(s,t[1]) <= 0 \n\t    && ccw(t,s[0])*ccw(t,s[1]) <= 0;\n}\n\nPt2 projection(Line2 l, Pt2 p) {\n  double t = dot(p-l[0], vec(l)) / norm(vec(l));\n  return l[0] + t*(vec(l));\n}\n\nPt2 reflection(Line2 l, Pt2 p) {\n\treturn p + 2.0*(projection(l,p) - p);\n}\n\nNum distanceSP(Line2 s, Pt2 p) {\n  Pt2 r = projection(s,p);\n  if(intersectSP(s,r)) return abs(r-p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\nNum distanceSS(Line2 s, Line2 t) {\n  if(intersectSS(s,t)) return 0;\n  return min(min(distanceSP(s,t[0]), distanceSP(s,t[1])),\n             min(distanceSP(t,s[0]), distanceSP(t,s[1])));\n}\n\nbool convex_contains(Polygon2 g, Pt2 p)\n{\n\tfor(int i=0; i<g.size(); i++)\n\t{\n\t\tif(ccw(Line2(g[i],g[(i+1)%g.size()]), p)==-1) return false;\n\t}\n\treturn true;\n}\n\ndouble dist(Line2 s, Line2 t, double h) {\n\tdouble d=distanceSS(s,t);\n\tif(d<=h) return d;\n\treturn (d*d+h*h)/(2*h);\n}\n\n\nint main()\n{\n\tint N;\n\twhile(cin>>N, N)\n\t{\n\t\tNum x1,y1,x2,y2,h;\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tLine2 course(Pt2(x1,y1),Pt2(x2,y2));\n\n\t\tdouble ans=1e10;\n\t\twhile(N--)\n\t\t{\t\t\n\t\t\tcin>>x1>>y1>>x2>>y2>>h;\n\t\t\tPolygon2 g(4);\n\t\t\tg[0]=Pt2(x1,y2); g[3]=Pt2(x2,y2);\n\t\t\tg[1]=Pt2(x1,y1); g[2]=Pt2(x2,y1);\n\n\t\t\tif(convex_contains(g,course[0]) || convex_contains(g,course[1]))\n\t\t\t{\n\t\t\t\tans=0; break;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<g.size(); i++)\n\t\t\t{\n\t\t\t\tans = min(ans, dist(course,Line2(g[i],g[(i+1)%g.size()]),h));\n\t\t\t}\n\t\t}\n\t\tcout.setf(ios::fixed);\n\t\tcout.precision(5);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nbool lessP(const P &l, const P &r) {\n    if (sgn(l.real(), r.real())) return l.real() < r.real();\n    if (sgn(l.imag(), r.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\nR rad2deg(R x) {\n    return x/PI*180;\n}\n\n//?§???????[0, 2*PI)???\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n//?§???????[-PI, PI)???\nR radNorN(R x) {\n    x = radNorP(x);\n    if (x >= PI) x -= 2*PI;\n    return x;\n}\n\n/**\n * radian??§???x???[l, r]?????\\??£????????????????????\\??????\n * 0:OFF\n * 1:IN\n * 2:ON\n */\nbool inR(R l, R r, R x) {\n    l = radNorP(l);\n    r = radNorP(r);\n    x = radNorP(x);\n    if (!sgn(l, x) || !sgn(r, x)) return 2;\n    if (!sgn(l, r)) return 0;\n    if (sgn(l, r) == 1) {\n        if (sgn(l, x) == 1 && sgn(x, r) == 1) return 1;\n    } else {\n        if (sgn(x, r) == 1 || sgn(l, x) == 1) return 1;\n    }\n    return 0;\n}\n\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\ntypedef vector<P> Pol;\n\nstruct C {\n    P p;\n    R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\n\nP cu(Pol p, int i) { \n    int s = p.size();\n    return p[(i%s+s)%s];\n};\n\n//0:P is out 1:P is on line 2:P is in\nint contains(const Pol &pol, P p) {\n    int in = -1;\n    for (int i = 0; i < (int)pol.size(); i++) {\n        P a=cu(pol,i)-p, b=cu(pol,i+1)-p;\n        if (ccw(a, b, P(0, 0)) == 0) return 1;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)) {\n            if (cross(a, b) < 0) in *= -1;\n        }\n    }\n    return in+1;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.x)/abs(vec(l)));\n}\n\n\n//????????¨??????????°??????¢\nR distSP(const L &s, const P &p) {\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return abs(s.x-p);\n    if (ccw(s.y, s.y+s2, p) == -1) return abs(s.y-p);\n    return min(min(abs(s.x-p), abs(s.y-p)), distLP(s, p));\n}\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s.x,s.y,t.x), b = ccw(s.x,s.y,t.y);\n    int c = ccw(t.x,t.y,s.x), d = ccw(t.x,t.y,s.y);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\n\nconst int MN = 55;\nint n;\nL l;\nPol po[MN];\nR he[MN];\n\nbool solve(R md) {\n    vector<C> c;\n    vector<Pol> p;\n    for (int i = 0; i < n; i++) {\n        R di = 0;\n        if (md < he[i]) {\n            di = md;\n        } else {\n            di = ssqrt(md*md - (md-he[i])*(md-he[i]));\n        }\n        for (int j = 0; j < 4; j++) {\n            c.push_back(C(po[i][j], di));\n        }\n        R x1 = po[i][0].real();\n        R y1 = po[i][0].imag();\n        R x2 = po[i][2].real();\n        R y2 = po[i][2].imag();\n        p.push_back(\n            {P(x1-di, y1),\n             P(x2+di, y1),\n             P(x2+di, y2),\n             P(x1-di, y2)});\n        p.push_back(\n            {P(x1, y1-di),\n             P(x2, y1-di),\n             P(x2, y2+di),\n             P(x1, y2+di)});\n    }\n    for (C x: c) {\n        if (distSP(l, x.p) < x.r) return false;\n    }\n    for (Pol x: p) {\n        if (contains(x, l.x)) return false;\n        if (contains(x, l.y)) return false;\n        for (int i = 0; i < 4; i++) {\n            if (insSS(l, L(cu(x, i), cu(x, i+1)))) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    while (true) {\n        cin >> n;\n        if (!n) break;\n        for (int i = 0; i < MN; i++) {\n            po[i].clear();\n        }\n        R sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        l = L( P(sx, sy), P(ex, ey) );\n        for (int i = 0; i < n; i++) {\n            R x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2 >> he[i];\n            po[i].push_back(P(x1, y1));\n            po[i].push_back(P(x2, y1));\n            po[i].push_back(P(x2, y2));\n            po[i].push_back(P(x1, y2));\n        }\n        R l = 0, r = 1000;\n        for (int i = 0; i < 50; i++) {\n            R md = (l+r)/2;\n            if (solve(md)) {\n                l = md;\n            } else {\n                r = md;\n            }\n        }\n        printf(\"%.20Lf\\n\", l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000.0\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef complex<double> P;\n\nint n;\ndouble sx, sy, ex, ey;\ndouble mx[50], my[50], Mx[50], My[50], h[50];\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\ndouble f(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\ndouble fx(double x1, double x2, double y, double z){\n\tdouble r = x1, l = x2, mr, ml;\n\trep(i,50){\n\t\tmr = (r*2+l)/3;\n\t\tml = (r+l*2)/3;\n\t\tif(f(P(sx,sy),P(ex,ey),P(mr,y)) < f(P(sx,sy),P(ex,ey),P(ml,y))){\n\t\t\tl = ml;\n\t\t} else r = mr;\n\t}\n\tdouble ret = f(P(sx,sy),P(ex,ey),P(r,y));\n\treturn sqrt(ret*ret+z*z);\n}\n\ndouble fy(double x, double y1, double y2, double z){\n\tdouble r = y1, l = y2, mr, ml;\n\trep(i,50){\n\t\tmr = (r*2+l)/3;\n\t\tml = (r+l*2)/3;\n\t\tif(f(P(sx,sy),P(ex,ey),P(x,mr)) < f(P(sx,sy),P(ex,ey),P(x,ml))){\n\t\t\tl = ml;\n\t\t} else r = mr;\n\t}\n\tdouble ret = f(P(sx,sy),P(ex,ey),P(x,r));\n\treturn sqrt(ret*ret+z*z);\n}\n\nvoid solve(){\n\tcin >> sx >> sy >> ex >> ey;\n\trep(i,n) cin >> mx[i] >> my[i] >> Mx[i] >> My[i] >> h[i];\n\trep(i,n){\n\t\tif(mx[i]<=sx&&sx<=Mx[i]&&my[i]<=sy&&sy<=My[i]){\n\t\t\tputs(\"0.000\");\n\t\t\treturn;\n\t\t}\n\t\tif(mx[i]<=ex&&ex<=Mx[i]&&my[i]<=ey&&ey<=My[i]){\n\t\t\tputs(\"0.000\");\n\t\t\treturn;\n\t\t}\n\t}\n\tdouble s = 0.0, e = 10000.0, mid;\n\trep(u,50){\n\t\tmid = (s+e)/2;\n\t\tdouble dist = INF;\n\t\trep(i,n){\n\t\t\tdouble z = mid-h[i];\n\t\t\tif(z < 0) z = 0.0;\n\t\t\tdist = min(dist,fx(mx[i],Mx[i],my[i],z));\n\t\t\tdist = min(dist,fx(mx[i],Mx[i],My[i],z));\n\t\t\tdist = min(dist,fy(mx[i],my[i],My[i],z));\n\t\t\tdist = min(dist,fy(Mx[i],my[i],My[i],z));\n\t\t}\n\t\tif(dist < mid){\n\t\t\te = mid;\n\t\t} else s = mid;\n\t}\n\tprintf(\"%.9f\\n\",s);\n}\n\nint main(){\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<double, double> PDD;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nPDD operator-(const PDD &a, const PDD &b) {\n  return PDD(a.fi - b.fi, a.se - b.se);\n}\n\ndouble len(PDD p) {\n  return sqrt(p.fi * p.fi + p.se * p.se);\n}\n\ndouble dot(PDD a, PDD b) {\n  return a.fi * b.fi + a.se * b.se;\n}\n\ndouble cross(PDD a, PDD b) {\n  return a.fi * b.se - a.se * b.fi;\n}\n\ndouble distance(PDD p1, PDD p2, PDD q1, PDD q2) {\n  if (cross(p2 - p1, q1 - p1) * cross(p2 - p1, q2 - p1) < 0 && cross(q2 - q1, p1 - q1) * cross(q2 - q1, p2 - q1) < 0) {\n    return 0;\n  } else {\n    double mini = INF;\n    if (dot(p2 - p1, q1 - p1) < 1e-7) minch(mini, len(q1 - p1));\n    else if (dot(p1 - p2, q1 - p2) < 1e-7) minch(mini, len(q1 - p2));\n    else minch(mini, abs(cross(p2 - p1, q1 - p1)) / len(p2 - p1));\n\n    if (dot(p2 - p1, q2 - p1) < 1e-7) minch(mini, len(q2 - p1));\n    else if (dot(p1 - p2, q2 - p2) < 1e-7) minch(mini, len(q2 - p2));\n    else minch(mini, abs(cross(p2 - p1, q2 - p1)) / len(p2 - p1));\n\n    if (dot(q2 - q1, p1 - q1) < 1e-7) minch(mini, len(p1 - q1));\n    else if (dot(q1 - q2, p1 - q2) < 1e-7) minch(mini, len(p1 - q2));\n    else minch(mini, abs(cross(q2 - q1, p1 - q1)) / len(q2 - q1));\n\n    if (dot(q2 - q1, p2 - q1) < 1e-7) minch(mini, len(p2 - q1));\n    else if (dot(q1 - q2, p2 - q2) < 1e-7) minch(mini, len(p2 - q2));\n    else minch(mini, abs(cross(q2 - q1, p2 - q1)) / len(q2 - q1));\n\n    return mini;\n  }\n}\n\nint main(){\n  int n;\n  while(cin >> n, n) {\n    PDD s, e;\n    cin >> s.fi >> s.se >> e.fi >> e.se;\n    vector<double> v;\n\n    bool ok = true;\n    rep(i, n) {\n      PDD mi, ma;\n      double h;\n      cin >> mi.fi >> mi.se >> ma.fi >> ma.se >> h;\n      double mini = INF;\n      minch(mini, distance(s, e, mi, PDD(ma.fi, mi.se)));\n      minch(mini, distance(s, e, mi, PDD(mi.fi, ma.se)));\n      minch(mini, distance(s, e, ma, PDD(ma.fi, mi.se)));\n      minch(mini, distance(s, e, ma, PDD(mi.fi, ma.se)));\n      minch(mini, distance(s, e, mi, ma));\n      cout << mini << \" \" << h << endl;\n      if (mini == 0) {\n        ok = false;\n        break;\n      } else {\n        if (mini < h) v.pb(mini);\n        else {\n          double high = 10000, low = mini, mid;\n          rep(j, 100) {\n            mid = (high + low) / 2;\n            if ((mid - h) * (mid - h) + mini * mini >= mid * mid) low = mid;\n            else high = mid;\n          }\n          v.pb(low);\n        }\n        cout << v[v.size() - 1] << endl;\n      }\n    }\n\n    if (ok) {\n      sort(all(v));\n      printf(\"%.10f\\n\", v[0]);\n    } else {\n      cout << 0 << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long lint;\n\nconst double EPS = 1e-8;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n\n#define zclear(a) memset((a), 0 ,sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nbool eq(double a, double b) //a == b\n{\n    return (fabs(a - b) <= EPS);\n}\n\nbool neq(double a, double b) //a != b\n{\n    return (!eq(a, b));\n}\n\nbool lt(double a, double b) //a < b\n{\n    return (a - b < -EPS);\n}\n\nbool leq(double a, double b) //a <= b\n{\n    return (lt(a, b) || eq(a, b));\n}\n\nbool gt(double a, double b) //a > b\n{\n    return (a - b > +EPS);\n}\n\nbool geq(double a, double b) //a >= b\n{\n    return (gt(a, b) || eq(a, b));\n}\n\nclass Point{\npublic:\n    double x, y;\n    Point(double x = 0, double y = 0): x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(x * a, y * a);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    Point operator * (const Point &a){\n        return Point(x * a.x - y * a.y, x * a.y + y * a.x);\n    }\n    bool operator < (const Point &p) const {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const Point &p) const {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){return (a.x * a.x + a.y * a.y);}\ndouble abs(Vector a){return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b){return (sqrt(norm(a - b)));}\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\ndouble atan(Vector a){return atan2(a.y, a.x);}\nbool sortX(Point a, Point b){return (a.x != b.x ? lt(a.x, b.x) : lt(a.y, b.y));}\nbool sortY(Point a, Point b){return (a.y != b.y ? lt(a.y, b.y) : lt(a.x, b.x));}\nPoint p;\nbool sortT(Point a, Point b){return (gt(cross(a - p, b - p), 0));}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS) return (+1); //p0, p1, p2 ???????????¨????¨???\n    if (cross(a, b) < -EPS) return (-1);//p0, p1, p2 ????????¨???????\n    if (dot(a, b) < -EPS) return (+2); //p2--p0--p1 ?????????§??????´??????\n    if (norm(a) < norm(b)) return (-2); //p0--p1--p2 ?????????§??????´??????\n    return (0); //p0--p2--p1 ?????????§??????´??????\n}\n\nPolygon normalize(Polygon &v)\n{\n    int pt = 0;\n    for (int i = 1; i < v.size(); i++){\n        if (v[pt].y > v[i].y || (v[pt].y == v[i].y && v[pt].x > v[i].x)){\n            pt = i;\n        }\n    }\n    swap(v[pt], v[0]);\n    p = v[0];\n    sort(v.begin() + 1, v.end(), sortT);\n    return (v);\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n\n    for (int i = 0; i < n; i++){\n      while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < EPS) k--;\n      qs[k++] = ps[i];\n    }\n\n    for (int i = n - 2, t = k; i >= 0; i--){\n      while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < EPS) k--;\n      qs[k++] = ps[i];\n    }\n\n    qs.resize(k - 1);\n    return (qs);\n}\n\ndouble getArea(Polygon t){\n    double ans = 0.0;\n    t = normalize(t);\n    for (unsigned int i = 0; i < t.size(); i++)\n        ans += cross(t[i] , t[(i + 1) % t.size()]);\n    return (fabs(ans) / 2);\n}\n\nbool isIntersectLL(Point p1, Point p2, Point p3, Point p4)\n{\n    return (abs(cross(p2 - p1, p4 - p3)) > EPS ||\n        abs(cross(p2 - p1, p4 - p3)) < EPS);\n}\nbool isIntersectLS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (cross(p2 - p1, p3 - p1) * cross(p2 - p1, p4 - p1) < EPS);\n}\nbool isIntersectLP(Point p1, Point p2, Point p)\n{\n    return (neq(abs(ccw(p1, p2, p)), 1));\n}\nbool isIntersectSS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool isIntersectSP(Point p1, Point p2, Point p)\n{\n    return (eq(ccw(p1, p2, p), 0));\n}\nbool isInsideCP(Point c, double r, Point p)\n{\n    return (leq(abs(c - p), r));\n}\nbool isInsideCC(Point c1, double r1, Point c2, double r2)\n{\n    return (leq(abs(c1 - c2), r1 + r2) && geq(abs(c1 - c2), abs(r1 - r2)));\n}\nbool isInsidePolyP(Polygon gon, Point p)\n{\n    for (int i = 0; i < gon.size(); i++){\n        if (ccw(gon[i], gon[(i + 1) % gon.size()], p) == -1) return (false);\n    }\n    return (true);\n}\n\nPoint projection(Point p1, Point p2, Point p3)\n{\n    double t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n    return (p1 + (p2 - p1) * t);\n}\nPoint reflection(Point p1, Point p2, Point p3)\n{\n    return (p3 + (projection(p1, p2, p3) - p) * 2);\n}\ndouble distanceLP(Point p1, Point p2, Point p)\n{\n    return (abs(p - projection(p1, p2, p)));\n}\ndouble distanceLL(Point l1, Point l2, Point m1, Point m2)\n{\n    return (isIntersectLL(l1, l2, m1, m2) ? 0 : distanceLP(l1, l2, m1));\n}\ndouble distanceLS(Point l1, Point l2, Point s1, Point s2)\n{\n    if (isIntersectLS(l1, l2, s1, s2)) return (0);\n    return (min(distanceLP(l1, l2, s1), distanceLP(l1, l2, s2)));\n}\ndouble distanceSP(Point s1, Point s2, Point p)\n{\n    Point r = projection(s1, s2, p);\n    if (isIntersectSP(s1, s2, r)) return (abs(r - p));\n    return (min(abs(s1 - p), abs(s2 - p)));\n}\ndouble distanceSS(Point s1, Point s2, Point t1, Point t2){\n    if (isIntersectSS(s1, s2, t1, t2)) return (0);\n    return (min(min(distanceSP(s1, s2, t1), distanceSP(s1, s2, t2)),\n            min(distanceSP(t1, t2, s1), distanceSP(t1, t2, s2))));\n}\nPoint interPointLL(Point a1, Point a2, Point b1, Point b2)\n{\n    double d = cross(a2 - a1, b2 - b1);\n    if (abs(d) < EPS) throw \"Segment is Paralell!\";\n    Point a = a2 - a1, b = b2 - b1;\n    double t = cross(b, b1 - a1) / cross(b, a);\n    return (a1 + a * t);\n}\nvector<Point> interPointCC(Point c1, double r1, Point c2, double r2)\n{\n    vector<Point> res;\n    if (abs(c1 - c2) < EPS) return (vector<Point>());\n    double d = abs(c1 - c2);\n    double rc = (d * d + r1 * r1 - r2 * r2) / (2 * d);\n    double rs = sqrt(r1 * r1 - rc * rc);\n    Point diff = (c2 - c1) / d;\n    res.push_back(Point(c1 + diff * Point(rc, rs)));\n    res.push_back(Point(c1 + diff * Point(rc, -rs)));\n    return (res);\n}\nvector<Point> crosspointCL(Point a, double ra, Point b1, Point b2)\n{\n    vector<Point> res;\n    double dist = distanceLP(b1, b2, a);\n    if (leq(dist, ra)){\n        Point s = projection(b1, b2, a);\n        dist = sqrt(ra * ra - dist * dist);\n        Point t = (b2 - b1) / abs(b2 - b1);\n        res.push_back(s + t * dist);\n        res.push_back(s - t * dist);\n    }\n    return (res);\n}\n\nPoint unitVector(Vector t)\n{\n    double u = abs(t);\n    return (Point(t.x / u , t.y / u));\n}\n\nPoint normalVector(Point p, Point a, Point b)\n{\n    Point v = unitVector(b - a);\n    v = cross(v, p - a) > 0 ? Point(v.y, -v.x) : Point(-v.y, v.x);\n    return v * distanceLP(p, a, b);\n}\n\ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n\ndouble getSin(Vector a, Vector b)\n{\n    double t = getCos(a, b);\n    return (sqrt(1.0 - t * t));\n}\n\ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n\nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n\nint main()\n{\n    int n;\n    while (scanf(\"%d\", &n) && n){\n        Point s, e;\n        scanf(\"%lf %lf %lf %lf\", &s.x, &s.y, &e.x, &e.y);\n\n        double ans = 1001001001ll;\n        for (int i = 0; i < n; i++){\n            double minx, miny, maxx, maxy, h;\n            scanf(\"%lf %lf %lf %lf %lf\", &minx, &miny, &maxx, &maxy, &h);\n            Point p1 = Point(minx, miny), p2 = Point(minx, maxy),\n                  p3 = Point(maxx, miny), p4 = Point(maxx, maxy);\n            double dist = min(min(distanceSS(p1, p2, s, e), distanceSS(p3, p4, s, e)),\n                              min(distanceSS(p1, p3, s, e), distanceSS(p2, p4, s, e)));\n            Polygon P;\n            P.push_back(p3); P.push_back(p4); P.push_back(p2); P.push_back(p1);\n            if (isInsidePolyP(P, s) && isInsidePolyP(P, e)) ans = 0;\n            if (dist <= h) ans = min(ans, dist);\n            else {\n                ans = min(ans, 0.5 * (h + dist * dist / h));\n            }\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst double EPS = 1e-9;\n\nstruct Point\n{\n\tdouble x, y;\n\n\tPoint() : x( 0 ), y( 0 ) {}\n\tPoint( const double x, const double y ) : x( x ), y( y ) {}\n\tPoint( const Point &a ) : x( a.x ), y( a.y ) {}\n\t\n\tconst Point operator + ( const Point &a ) const\n\t{\n\t\treturn Point( x + a.x, y + a.y );\n\t}\n\n\tPoint& operator += ( const Point &a ) \n\t{\n\t\tx += a.x;\n\t\ty += a.y;\n\n\t\treturn *this;\n\t}\n\n\tconst Point operator - ( const Point &a ) const\n\t{\n\t\treturn Point( x + ( -a.x ), y + ( -a.y ) );\n\t}\n\n\tPoint& operator -= ( const Point &a )\n\t{\n\t\tx -= a.x;\n\t\ty -= a.y;\n\n\t\treturn *this;\n\t}\n\n\tconst Point operator * ( const double a ) const\n\t{\n\t\treturn Point( x * a, y * a );\n\t}\n\n\tPoint& operator *= ( const double a )\n\t{\n\t\tx *= a;\n\t\ty *= a;\n\n\t\treturn *this;\n\t}\n\n\tconst Point operator / ( const double a ) const\n\t{\n\t\treturn Point( x / a, y / a );\n\t}\n\n\tPoint& operator /= ( const double a )\n\t{\n\t\tx /= a;\n\t\ty /= a;\n\n\t\treturn *this;\n\t}\n\n\tbool operator < ( const Point &a ) const\n\t{\n\t\treturn x == a.x ? y < a.y : x < a.x;\n\t}\n\n\tdouble abs() const\n\t{\n\t\treturn sqrt( pow( x, 2. ) + pow( y, 2. ) );\n\t}\n};\n\n// 二点間の距離\ndouble distance( const Point &a, const Point &b )\n{\n\treturn sqrt( pow( a.x - b.x, 2. ) + pow( a.y - b.y, 2. ) );\n}\n\n// 内積（ドット積）\ndouble dot( const Point &a, const Point &b )\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n// 外積（クロス積）\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// 線分 ( p1, p2 ) と点 q の距離\ndouble distance_segment_point( const Point &p1, const Point &p2, const Point q )\n{\n\tif ( EPS < dot( p2 - p1, q - p1 ) && EPS < dot( p1 - p2, q - p2 ) )\n\t{\n\t\treturn abs( cross( p2 - p1, q - p1 ) ) / ( p2 - p1 ).abs();\n\t}\n\telse\n\t{\n\t\treturn min( distance( p1, q ), distance( p2, q ) );\n\t}\n}\n\n// 線分 ( p1, p2 ) に点 q が乗っているか\nbool point_on_segment( const Point &p1, const Point &p2, const Point &q )\n{\n\treturn abs( cross( p1 - q, p2 - q ) ) <= EPS && dot( p1 - q, p2 - q ) <= EPS;\n}\n\n// 直線 ( p1, p2 ) と直線 ( q1, q2 ) の交点\nPoint lines_intersection( const Point &p1, const Point &p2, const Point &q1, const Point &q2 )\n{\n\treturn p1 + ( p2 - p1 ) * ( cross( q2 - q1, q1 - p1 ) / cross( q2 - q1, p2 - p1 ) );\n}\n\n// 線分 ( p1, p2 ) と線分 ( q1, q2 ) が交差するか\nbool segments_intersection( const Point &p1, const Point &p2, const Point &q1, const Point &q2 )\n{\t\t\n\tif ( abs( cross( p1 - p2, q1 - q2 ) ) <= EPS ) // is parallel\n\t{\n\t\treturn point_on_segment( p1, p2, q1 ) ||\n\t\t\t   point_on_segment( p1, p2, q2 ) ||\n\t\t\t   point_on_segment( q1, q2, p1 ) ||\n\t\t\t   point_on_segment( q1, q2, p2 );\n\t}\n\telse\n\t{\n\t\tPoint r( lines_intersection( p1, p2, q1, q2 ) );\n\t\treturn point_on_segment( p1, p2, r ) && point_on_segment( q1, q2, r );\n\t}\n}\n\n// 三角形 ( a, b, c ) の中に点 p があるか\nbool point_in_triangle( const Point &a, const Point &b, const Point &c, const Point &p )\n{\n\tint res = 0;\n\tres += EPS < cross( b - a, p - a ) ? 1 : -1;\n\tres += EPS < cross( c - b, p - b ) ? 1 : -1;\n\tres += EPS < cross( a - c, p - c ) ? 1 : -1;\n\n\tif ( abs( res ) == 3 )\n\t{\n\t\treturn true;\n\t}\n\treturn point_on_segment( a, b, p ) || point_on_segment( b, c, p ) || point_on_segment( c, a, p );\n}\n\ndouble search( const Point &p1, const Point &p2, const Point &q, const int h )\n{\n\tconst double dist = distance_segment_point( p1, p2, q ) ;\n\tif ( dist <= h )\n\t{\n\t\treturn dist;\n\t}\n\n\tdouble lb = 0, ub = 1000;\n\tREP( i, 0, 100 )\n\t{\n\t\tdouble r = ( lb + ub ) / 2;\n\t\tif ( r < distance( Point( 0, r ), Point( dist, h ) ) )\n\t\t{\n\t\t\tlb = r;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tub = r;\n\t\t}\n\t}\n\n\treturn lb;\n}\n\ndouble solve( const int n )\n{\n\tint sx, sy, ex, ey;\n\tcin >> sx >> sy >> ex >> ey;\n\tPoint s( sx, sy ), e( ex, ey );\n\n\tVI hs;\n\tvector< Point > points;\n\tvector< pair<Point,Point> > lines;\n\n\tREP( i, 0, n )\n\t{\n\t\tint x1, y1, x2, y2, h;\n\t\tcin >> x1 >> y1 >> x2 >> y2 >> h;\n\n\t\tpoints.PB( Point( x1, y1 ) );\n\t\tpoints.PB( Point( x2, y2 ) );\n\t\tpoints.PB( Point( x1, y2 ) );\n\t\tpoints.PB( Point( x2, y1 ) );\n\n\t\tlines.PB( MP( Point( x1, y1 ), Point( x1, y2 ) ) );\n\t\tlines.PB( MP( Point( x1, y2 ), Point( x2, y2 ) ) );\n\t\tlines.PB( MP( Point( x2, y2 ), Point( x2, y1 ) ) );\n\t\tlines.PB( MP( Point( x2, y1 ), Point( x1, y1 ) ) );\n\n\t\ths.PB( h );\n\t}\n\n\tREP( i, 0, lines.size() )\n\t{\n\t\tif ( segments_intersection( s, e, lines[i].fst, lines[i].snd ) )\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tREP( i, 0, n )\n\t{\n\t\tif ( point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 2 ], s ) ||\n\t\t\t point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 3 ], s ) ||\n\t\t\t point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 2 ], e ) ||\n\t\t\t point_in_triangle( points[ i * 4 ], points[ i * 4 + 1 ], points[ i * 4 + 3 ], e ) )\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdouble res = 1000;\n\tREP( i, 0, n )\n\t{\n\t\tREP( j, 0, 4 )\n\t\t{\n\t\t\tconst int idx = i * 4 + j;\n\t\t\tres = min( res, search( s, e, points[ idx ], hs[i] ) );\n\t\t\tres = min( res, search( lines[ idx ].fst, lines[ idx ].snd, s, hs[i] ) );\n\t\t\tres = min( res, search( lines[ idx ].fst, lines[ idx ].snd, e, hs[i] ) );\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\tcout << setprecision( 4 ) << fixed;\n\n\twhile ( true )\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif ( !n )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << solve( n ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stdlib.h>\n#include <string.h>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble EPS = 1e-8;\n\ntypedef struct {\n\tP s,e;\n\tdouble h;\n}RECT;\n\nvoid P_cin(P& p){\n\tdouble x,y;\n\tcin >>p.real() >> p.imag();\n}\ndouble dot(P a,P b){ return a.real() * b.real() + a.imag() * b.imag(); }\ndouble cross(P a,P b){ return a.real() * b.imag() - a.imag() * b.real(); } \n\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\ndouble distance_lp(P& s,P& e,P &p){\n\tif(dot(e-s,p-s) < EPS) return abs(p-s); //_sÆÌ£\n\tif(dot(s-e,p-e) < EPS) return abs(p-e); //_eÆÌ£\n\treturn abs(cross(e-s,p-s)) / abs(e-s); //_Æ¼üÆÌ£\n}\n\nbool is_contained(P& a,P& b,P& p){\n\treturn (a.real() <= p.real() && p.real() <= b.real()) &&\n\t\t(a.imag() <= p.imag() && p.imag() <= b.imag());\n}\n\ndouble distance_rl(P& a,P& b,P& s,P& e){\n\tif(is_contained(a,b,s) || is_contained(a,b,e))\n\t\treturn 0.0; //R[X©Ìª ÉüÁÄé\n\n\tdouble len = 1e10;\n\tP rectP[] = {a,P(a.real(),b.imag()),b,P(b.real(),a.imag())};\n\tfor(int i = 0; i < 4; i++){\n\t\tif(is_intersected_ls(rectP[i],rectP[(i+1)%4],s,e)) return 0.0; //ð·µÄ¢é\n\t\tlen = min(len,distance_lp(rectP[i],rectP[(i+1)%4],s));\n\t\tlen = min(len,distance_lp(rectP[i],rectP[(i+1)%4],e));\n\t\tlen = min(len,distance_lp(e,s,rectP[i]));\n\t}\n\n\treturn len;\n}\n\ndouble distance(RECT &r,P& s,P& e){\n\tdouble len = distance_rl(r.s,r.e,s,e);\n\tif(len <= r.h) return len; //cÉ¢\n\treturn (r.h + len * len / r.h) / 2; //cÌûªá¢ÌÅvZ·é\n}\n\nint N;\n\nvoid solve(){\n\n\tP s,e;\n\tP_cin(s);\n\tP_cin(e);\n\n\tvector<RECT> rects(N);\n\tfor(int i = 0; i < N; i++){\n\t\tRECT &r = rects[i];\n\t\tP_cin(r.s);\n\t\tP_cin(r.e);\n\t\tcin >> r.h;\n\t}\n\t\n\tdouble ans = 1e10;\n\tfor(int i = 0; i < N; i++){\n\t\tans = min(ans,distance(rects[i],s,e));\n\t}\n\n\tcout << ans << endl;\n}\n\nint main()\n{\n\twhile(cin >> N,N){\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                     #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                  \n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                             double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \nbool parareru(Point a,Point b,Point c,Point d){\n\treturn abs(cross(a-b,d-c))<EPS;\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n  return abs(cross(b-a, c-a)) / (b-a).absv();\n}\nbool is_intersected_ls(Segment a,Segment b) {\n\tif(parareru((a.p2-a.p1).x,(a.p2-a.p1).y,(b.p2-a.p1).x,(b.p2-a.p1).y)&&parareru((a.p2-a.p1).x,(a.p2-a.p1).y,(b.p1-a.p1).x,(b.p1-a.p1).y)){\n\t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n\t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n\t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n\t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n\t\treturn false;\n\t}\n  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n}\n\ndouble segment_dis(Segment a,Segment b){\n\tif(is_intersected_ls(a,b))return 0;\n\tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n\tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n\treturn r;\n}\n\n\n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\n\n\nSegment p[210],path;\nPoint pp[210];\nint n;\ndouble h[210];\nbool ch(double r){\n\t\n\tfor(int i=0;i<4*n;i++){\n\t\tdouble t=segment_dis(p[i],path);\n\t\tif(t>=r) continue;\n\t\tif(r-sqrt(r*r-t*t)<=h[i/4])return false;\n\t}\n\treturn true;\n\t\n}\n\n\nsigned main(){\n\n\tint cnt=0;\n\twhile(1){\n\t\t\n\t\tcin>>n;\n\t\tif(n==0) return 0;\ncout<<cnt<<\" \"<<n<<endl;\n\t\t\n\t\tcnt++;\n\t\tcin>>path.p1.x>>path.p1.y>>path.p2.x>>path.p2.y;\n\t\tbool b=false;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble ax,ay,bx,by;\n\t\t\tcin>>ax>>ay>>bx>>by;\n\t\t\tif(ax <= path.p1.x &&path.p1.x<=bx &&ay <= path.p1.y &&path.p1.y<=by){\n\t\t\t\tif(ax <= path.p2.x &&path.p2.x<=bx &&ay <= path.p2.y &&path.p2.y<=by){\n\t\t\t\t\tb=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpp[i*4].x=ax;\n\t\t\tpp[i*4].y=ay;\n\t\t\tpp[1+i*4].x=ax;\n\t\t\tpp[1+i*4].y=by;\n\t\t\tpp[2+i*4].x=bx;\n\t\t\tpp[2+i*4].y=by;\n\t\t\tpp[3+i*4].x=bx;\n\t\t\tpp[3+i*4].y=ay;\n\t\t\t\n\t\t\tp[i*4].p1=pp[i*4];\n\t\t\tp[i*4].p2=pp[1+i*4];\n\t\t\tp[1+i*4].p1=pp[1+i*4];\n\t\t\tp[1+i*4].p2=pp[2+i*4];\n\t\t\tp[2+i*4].p1=pp[2+i*4];\n\t\t\tp[2+i*4].p2=pp[3+i*4];\n\t\t\tp[3+i*4].p1=pp[3+i*4];\n\t\t\tp[3+i*4].p2=pp[i*4];\ncin>>h[i];\n\t\t}\n\t\tfor(int i=0;i<4*n;i++)cout<<i<<\" \"<<segment_dis(p[i],path)<<endl;\n\t\tif(b==1){\n\t\t\tcout<<0<<endl;\n\t\t\t\n\t\t}\n\t\telse{\n\t\tdouble ue=1000.0,sita=0.0,me;\n\t\tfor(int i=0;i<1000;i++){\n\t\t\tme=(ue+sita)/2.0;\n\t\t\tif(ch(me))sita=me;\n\t\t\telse ue=me;\n\t\t}\n\t\tprintf(\"%.10lf\\n\",me);\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nusing Real = double;\nusing Point = complex< Real >;\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r) {\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\n\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool parallel(const Line &a, const Line &b) {\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool orthogonal(const Line &a, const Line &b) {\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nReal distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\nReal distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\nenum {\n  OUT, ON, IN\n};\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvoid merge_segments(vector< Segment > &segs) {\n\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\nReal area2(const Polygon &p) {\n  Real A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\nReal area2(const Polygon &p, const Circle &c) {\n  if(p.size() < 3) return 0.0;\n  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if(eq(f, 0.0)) return ret;\n    if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector< Point > tot{a, u.first, u.second, b};\n    for(int i = 0; i + 1 < tot.size(); i++) {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for(int i = 0; i < p.size(); i++) {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\nReal convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\nReal closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n\n  function< Real(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\nint N;\ndouble sx, sy, ex, ey;\ndouble minx[55], miny[55], maxx[55], maxy[55], h[55];\nPoint points[55][4];\nSegment segments[55][4];\n\nint main() {\n    cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        cin >> N;\n        if(N == 0) break;\n        cin >> sx >> sy >> ex >> ey;\n        Point start(sx, sy);\n        Point goal(ex, ey);\n        Segment course(start, goal);\n        for(int i = 1; i <= N; i++) {\n            cin >> minx[i] >> miny[i] >> maxx[i] >> maxy[i] >> h[i];\n            points[i][0] = Point(minx[i], miny[i]);\n            points[i][1] = Point(minx[i], maxy[i]);\n            points[i][2] = Point(maxx[i], maxy[i]);\n            points[i][3] = Point(maxx[i], miny[i]);\n            for(int k = 0; k <= 3; k++) {\n                segments[i][k] = Segment(points[i][k], points[i][(k+1)%4]);\n            }\n        }\n        double ok = 0.0;\n        double ng = 1000.0;\n        for(int TIME = 1; TIME <= 1000; TIME++) {\n            double mid = (ok + ng) / 2.0;\n            bool clear = true;\n            for(int i = 1; i <= N; i++) {\n                if(minx[i] <= sx + EPS && maxx[i] + EPS >= sx && miny[i] <= sy + EPS && maxy[i] + EPS >= sy) {\n                    clear = false;\n                    //cerr << \"CONTAIN: \" << i << endl;\n                }\n                for(int k = 0; k <= 3; k++) {\n                    if(intersect(course, segments[i][k])) {\n                        //cerr << \"INTERSECT: \" << course << \" and \" << segments[i][k] << endl;\n                        clear = false;\n                    }\n                }\n                //cerr << mid << \" \" << clear << endl;\n                for(int j = 0; j <= 3; j++) {\n                    double dx = distance(course, segments[i][j]);\n                    double dh = 0;\n                    if(h[i] < mid) dh = mid - h[i];\n                    //cerr << course << \" and \" << points[i][j] << endl;\n                    //cerr << dx << \" \" << dh << \" \" << mid << endl;\n                    if(dh * dh + dx * dx <= mid * mid + EPS) {\n                        clear = false;\n                        //cerr << \"FAILRE ON: \" << points[i][j] << endl;\n                        //cerr << mid << \" \" << dx << \" \" << dh << \" \" << h[i] << endl;\n                    }\n                }\n            }\n            if(clear) ok = mid;\n            else ng = mid; \n        }\n        cout << ok << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <bits/stdc++.h>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n// #define EPS 1e-8\n// static const int INF=1<<24;\n\n// #include<bits/stdc++.h>\n// using namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = asin(0.5)*6;\ntypedef complex<double> P;\n\n#define X real()\n#define Y imag()\n\n#define Curr(P,i) P[(i)%P.size()]\n#define Next(P,i) P[(i+1)%P.size()]\n#define Prev(P,i) P[(i+P.size()-1)%P.size()]\n\nnamespace std{\n  bool operator<(const P a,const P b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n//gaiseki\ndouble cross(const P a,const P b){\n  return (conj(a)*b).imag();\n}\n//naiseki\ndouble dot(const P a,const P b){\n  return (conj(a)*b).real();\n}\n// TODO make graph (20)\nint ccw(P a,P b,P c){\n  b-=a;\n  c-=a;\n  if(cross(b,c)>0)    return +1;//counter clockwise\n  if(cross(b,c)<0)    return -1;//clockwise\n  if(dot(b,c)<0)      return +2;// c--a--b\n  if(norm(b)<norm(c)) return -2;// a--b--c\n                      return  0;// a--c--b(or b==c)\n}\n\nstruct L : public vector<P>{\n  L(const P a,const P b){\n    push_back(a),push_back(b);\n  }\n};\ntypedef L S;\ntypedef vector<P> G;\n\nstruct C{\n  P p;double r;\n  C(const P p,double r): p(p),r(r){}\n};\n\n\n\n//直線と点の関係\n//点から線分に垂線を下ろした点\nP projection(L a,P p){\n  double t = dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n  return a[0] + t*(a[0]-a[1]);\n}\n//線対称の点\nP reflection(L a,P p){\n  return p + 2.0 * (projection(a,p)-p);\n}\n\n\n\n\n//交差判定\n//TODO CP(内包) CL CS (0)\nbool isCrossLL(L a,L b){\n  return \n    abs(cross(a[1]-a[0],b[1]-b[0])) > EPS\n    || abs(cross(a[1]-a[0],b[0]-a[0])) < EPS ;\n}\nbool isCrossLS(L a,S b){\n  return \n    cross(a[1]-a[0],b[0]-a[0]) \n    * cross(a[1]-a[0],b[1]-a[0]) < EPS;\n}\nbool isCrossLP(L l,P p){\n  return abs(cross(l[1]-p,l[0]-p)) < EPS;\n}\nbool isCrossSS(S a,S b){\n  return\n    ccw(a[0],a[1],b[0])\n    * ccw(a[0],a[1],b[1]) <= 0\n    &&\n    ccw(b[0],b[1],a[0])\n    * ccw(b[0],b[1],a[1]) <= 0;\n}\nbool isCrossSP(S a,P p){\n  return abs(a[0]-p)+abs(a[1]-p)-abs(a[0]-a[1]) < EPS;\n}\n\n\n// 距離 CP CL CS は(distXP(x,c.p)-c.r)\ndouble distPP(P a,P b){\n  return abs(a-b);\n}\ndouble distLP(L a,P p){\n  return abs(p-projection(a,p));\n}\ndouble distLL(L a,L b){\n  return isCrossLL(a,b) ? 0 : distLP(a,b[0]);\n}\ndouble distLS(L a,S b){\n  return isCrossLS(a,b) ? 0 : min(distLP(a,b[0]),distLP(a,b[1]));\n}\ndouble distSP(S a,P p){\n  const P r = projection(a,p);\n  return isCrossSP(a,r) ? abs(p-r) : min(abs(a[0]-p),abs(a[1]-p));\n}\ndouble distSS(S a,S b){\n  return isCrossSS(a,b)?0:\n    min(\n      min(distSP(a,b[0]),distSP(a,b[1])),\n      min(distSP(b,a[0]),distSP(b,a[1]))\n    );\n}\n\n//円の交差判定\nbool isCrossCP(C a,P p){\n  return abs(a.p-p)-a.r<=EPS;\n}\nbool isCrossCL(C a,L l){\n  return distLP(l,a.p)-a.r<EPS;\n}\ndouble distSP_MAX(S a,P p){\n  return max(abs(a[0]-p),abs(a[1]-p));\n}\nbool isCrossCS(C a,S s){\n  return distSP(s,a.p)-a.r<-EPS&&distSP_MAX(s,a.p)-a.r>+EPS;\n}\nbool isCrossCC(C a,C b){//接してる時は交差\n  return abs(a.p-b.p)-(a.r+b.r) <= EPS;\n}\n\n\n//交差点\n//先に交差判定をすること\nP crossP_LL(L a,L b){\n  double A = cross(a[1]-a[0],b[1]-b[0]);\n  double B = cross(a[1]-a[0],a[1]-b[0]);\n  if(abs(A)<EPS && abs(B)<EPS)return b[0];\n  if(abs(A)<EPS)assert(false);\n  return b[0]+B/A*(b[1]-b[0]);\n}\nvector<P> crossP_CL(C c,L l){\n  P tmp = projection(l,c.p);\n  P e = (l[0]-l[1])/abs(l[0]-l[1]);\n  double h = abs(c.p-tmp)*abs(c.p-tmp);\n  double t = sqrt(c.r*c.r - h*h);\n  if(t<EPS)return {tmp};\n  return {tmp + e*t,tmp - e*t};\n}\nvector<P> crossP_CC(C a,C b){\n  P A = conj(b.p-a.p);\n  P B = (b.r*b.r - a.r*a.r - (b.p-a.p)*conj(b.p-a.p));\n  P C = a.r*a.r*(b.p-a.p);\n  P D = B*B-4.0*A*C;\n  P z1 = (-B+sqrt(D))/(2.0*A)+a.p;\n  P z2 = (-B-sqrt(D))/(2.0*A)+a.p;\n  return {z1,z2};\n}\n\n\n\n//三点->円\nP PPPtoC(P a,P b,P c){\n  P x = 1.0/(conj(b-a));\n  P y = 1.0/(conj(c-a));\n  return (y-x)/( conj(x)*y - x*conj(y) ) + a;\n}\n\n//凸包\nG convex_hull(G ps){\n  int n = ps.size();\n  int k = 0;\n  G ch(2*n);\n  for(int i = 0;i<n;(ch[k++]=ps[i++])){\n    while(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  }\n  for(int i = n-2,t=k+1 ; i>=0 ; ch[k++]=ps[i--]){\n    while(k>=t && ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  }\n  ch.resize(k-1);\n  return ch;\n} \n\n\n//凸性判定\nbool isConvex(G g){\n  for(int i=0; i<g.size();i++){\n    if(ccw(Prev(g,i),Curr(g,i),Next(g,i))>0)return false;\n  }\n}\n\n\n\n//接線\n//TODO check\nvector<L> TLine_CP(C c,P p){\n  P v = c.p - p;\n  double t = asin(abs(c.r)/(abs(v)));\n  P e = v/abs(v) * exp(P(.0,t));\n  P n1 = sqrt(abs(v)*abs(v) - c.r*c.r)*e + p;\n  P n2 = reflection(L(p,c.p),n1);\n  return {L(p,n1),L(p,n2)};\n}\n\n// TLine CC\nvector<L> TLine_CPr(C c,P p,double r){\n  P v = c.p - p;\n  double t = asin(abs(c.r)/(abs(v)));\n  P e = v/abs(v) * exp(P(.0,t));\n  P n1 = sqrt(abs(v)*abs(v) - c.r*c.r)*e + p;\n  P e1 = (n1-c.p)/abs(n1-c.p) * r;\n  P n2 = reflection(L(p,c.p),n1);\n  P e2 = (n2-c.p)/abs(n2-c.p) * r;\n  return {L(p+e1,n1+e1),L(p+e2,n2+e2)};\n}\nvector<L> TLine_CC(C a,C b){\n  //接してる時がヤバイ\n  vector<L> res;\n  if(!isCrossCC(a,b)&&(abs(a.r)>EPS)&&(abs(b.r>EPS))){\n    P tmp = (a.p-b.p)*(b.r)/(a.r+b.r) + b.p;\n    auto t1 = TLine_CP(a,tmp);\n    auto t2 = TLine_CP(b,tmp);\n    res.push_back(L(t1[0][1],t2[0][1]));\n    res.push_back(L(t1[1][1],t2[1][1]));\n  }\n  if(abs(a.r-b.r)<EPS){\n    const auto r = a.r;\n    P e = (a.p-b.p)/abs(a.p-b.p) * exp(P(.0,90.0/180.0*PI));\n    res.push_back(L(a.p+(e*r),b.p+(e*r)));\n    if(abs(r)>=EPS)res.push_back(L(a.p-(e*r),b.p-(e*r)));\n  }else{\n    if(a.r<b.r)swap(a,b);\n    auto t3 = TLine_CPr(C(a.p,a.r-b.r),b.p,b.r);\n    for(auto i:t3){\n      res.push_back(i);\n    }\n  }\n  return res;\n}\n\n\n\n//原点を起点とした回転\nP rotate(P a,double r){\n  return a*exp(P(0.0,r*PI/180.0));\n}\n\n// int main(){\n// }\nbool foo(P a,P b,P c,P d){\n\tP da=a-d,ab=b-a; \n\tP db=b-d,bc=c-b; \n\tP dc=c-d,ca=a-c;\n\tdouble t1=cross(da,ab),t2=cross(db,bc),t3=cross(dc,ca);\n\treturn (t1>0&&t2>0&&t3>0)||(t1<0&&t2<0&&t3<0);\n}\n\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tP s,e;\n\t\tdouble tt1,tt2;\n\t\tcin>>tt1>>tt2;\n\t\ts=P(tt1,tt2);\n\t\tcin>>tt1>>tt2;\n\t\te=P(tt1,tt2);\n\t\tVV(S) vv(n);\n\t\tdouble ans=INF;\n\t\tS a=S(s,e);\n\t\trep(i,n){\n\t\t\tP t1,t2;\n\t\t\t// double tt1,tt2;\n\t\t\tcin>>tt1>>tt2;\n\t\t\tt1=P(tt1,tt2);\n\t\t\tcin>>tt1>>tt2;\n\t\t\tt2=P(tt1,tt2);\n\t\t\tdouble h;\n\t\t\tcin>>h;\n\t\t\t// cout<<t1.X<<\" \"<<t1.Y<<\" \"<<t2.X<<\" \"<<t2.Y<<endl;\n\t\t\tvv[i].PB(S(t1,P(t1.X,t2.Y)));\n\t\t\tvv[i].PB(S(t1,P(t2.X,t1.Y)));\n\t\t\tvv[i].PB(S(t2,P(t1.X,t2.Y)));\n\t\t\tvv[i].PB(S(t2,P(t2.X,t1.Y)));\n\t\t\t//30 -70 90 -30 10\n\t\t\trep(j,vv[i].size()){\n\t\t\t\t// cout<<i<<\" \"<<j<<\" \"<<ans<<endl;\n\t\t\t\tif(isCrossSS(a,vv[i][j])) ans=0;\n\t\t\t\t// cout<<ans<<endl;\n\t\t\t\tif(foo(t1,t2,P(t1.X,t2.Y),s)) ans=0;\n\t\t\t\tif(foo(t1,t2,P(t1.Y,t2.X),s)) ans=0;\n\t\t\t\tdouble t = distSS(a,vv[i][j]);\n\t\t\t\t// cout<<t<<endl;\n\t\t\t\tif(h-t>=-EPS){\n\t\t\t\t\tans=min(ans,t);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tans=min(ans,h/2.0+t*t/2.0/h);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.6lf\\n\",ans);\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-8;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// ベクトル演算\ndouble dot(P a, P b) {return (a.real()*b.real()+a.imag()*b.imag());}\t// 内積\ndouble cross(P a, P b) {return (a.real()*b.imag()-a.imag()*b.real());}\t// 外積\nbool orth(P a1, P a2, P b1, P b2) {return deq(dot(a1-a2,b1-b2),0.0);}\t// 直交\nbool para(P a1, P a2, P b1, P b2) {return deq(cross(a1-a2,b1-b2),0.0);}\t// 平行\nbool pol(P a, P b, P c) {return deq(cross(b-a,c-a),0.0);}\t// 点cが直線ab上にあるかどうか\nbool pols(P a, P b, P c) {return (abs(a-c)+abs(c-b)<abs(a-b)+eps);}\t// 点cが線分ab上にあるかどうか\nbool intls(P a1, P a2, P b1, P b2) {\t// 線分a1a2と線分b1b2の交差判定\n\treturn (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<eps)\n\t\t   && (cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<eps);}\nP pintl(P a1, P a2, P b1, P b2) {\t// 直線a1a2と直線b1b2の交点 (要交差判定)\n\tP a = a2-a1, b = b2-b1;\n\treturn a1+a*cross(b,b1-a1)/cross(b,a);}\nP pintls(P a1, P a2, P b1, P b2) {\t// 線分a1a2と線分b1b2の交点 (〃)\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b,a1-b1)), d2 = abs(cross(b,a2-b1)), t = d1/(d1+d2);\n\treturn a1+(a2-a1)*t;}\ndouble disl(P a, P b, P c) {return abs(cross(b-a,c-a))/abs(b-a);}\t// 点cと直線abとの距離\ndouble disls(P a, P b, P c) {\t// 点cと線分abとの距離\n\tif (dot(b-a,c-a)<eps) return abs(c-a);\n\tif (dot(a-b,c-b)<eps) return abs(c-b);\n\treturn abs(cross(b-a,c-a))/abs(b-a);}\ndouble dislss(P a1, P a2, P b1, P b2) {\t// 線分a1a2と線分b1b2の距離\n\tif (abs(cross(a1-a2,b1-b2))>=eps && intls(a1,a2,b1,b2)) return 0;\n\tdouble a = min(disls(a1,a2,b1),disls(a1,a2,b2)), b = min(disls(b1,b2,a1),disls(b1,b2,a2));\n\treturn min(a,b);}\n\nint n, xl[50], yl[50], xr[50], yr[50], h[50];\ndouble d[50];\nP s, g;\n\nvector<double> res;\n\nbool ok(double r) {\n\trep(i,n) {\n\t\tif (r<=h[i] && d[i]<r) return false;\n\t\telse if (h[i]<r) {\n\t\t\tdouble t = sqrt(d[i]*d[i] + (r-h[i])*(r-h[i]));\n\t\t\tif (t<r) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\tdouble sx, sy, gx, gy;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\ts = P(sx,sy), g = P(gx,gy);\n\t\trep(i,n) {\n\t\t\tcin >> xl[i] >> yl[i] >> xr[i] >> yr[i] >> h[i];\n\t\t\tP p1 = P(xl[i],yl[i]), p2 = P(xr[i],yl[i]), p3 = P(xr[i],yr[i]), p4 = P(xl[i],yr[i]);\n\t\t\tdouble a = min(dislss(p1,p2,s,g), dislss(p2,p3,s,g)), b = min(dislss(p3,p4,s,g), dislss(p4,p1,s,g));\n\t\t\td[i] = min(a,b);\n\t\t}\n\t\tdouble l = 0, r = 1001;\n\t\trep(i,100) {\n\t\t\tdouble m = (l+r)/2;\n\t\t\tif (ok(m)) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tprintf(\"%.14lf\\n\",l);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// cpp_range (generic range class, very small equivalent of boost::irange)\n// (C) @cielavenir under Boost Software License.\n// note: end position is exclusive.\n\n#include <iterator>\ntemplate<typename T>\nclass range{\npublic:\n\tstruct iterator{\n\t\tconst T a,b;\n\t\tT p;\n\t\tconst long long d; //because T might be unsigned.\n\t\titerator(T _a,T _b,T _p,long long _d=1):a(_a),b(_b),p(_p),d(_d){}\n\n\tpublic:\n\t\ttypedef T value_type;\n\t\ttypedef T& reference;\n\t\ttypedef T* pointer;\n\t\ttypedef std::ptrdiff_t difference_type;\n\t\ttypedef std::random_access_iterator_tag iterator_category;\n\n\t\t//copy\n\t\titerator(const iterator &other):a(other.a),b(other.b),p(other.p),d(other.d){}\n\t\titerator operator=(const iterator &other){return iterator(other.a,other.b,other.p,other.d);}\n\n\t\t//advance\n\t\titerator& operator+=(T n){p+=n*d;return *this;}\n\t\titerator& operator-=(T n){return *this+=(-n);}\n\t\titerator& operator++(){return *this+=1;}\n\t\titerator& operator--(){return *this-=1;}\n\t\titerator operator+(T n) const{return iterator(a,b,p+n*d);}\n\t\titerator operator-(T n) const{return *this+(-n);}\n\n\t\t//difference\n\t\tT operator-(const iterator& other) const{return p-other.p;}\n\n\t\t//equality\n\t\tbool operator==(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p==other.p;}\n\t\tbool operator!=(const iterator& other) const{return !(*this==other);}\n\n\t\t//compare\n\t\tbool operator<(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p*d<other.p*d;}\n\t\tbool operator>(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p*d>other.p*d;}\n\n\t\t//reference\n\t\tconst T& operator*() const{return p;}\n\t};\n\nprivate:\n\tconst T a,b;\n\tT siz;\n\tlong long d;\npublic:\n\trange(T _a,T _b,long long _d=1):a(_a),b(_b){\n\t\td=_d;\n\t\td=d==0?1:d; //\n\t\tsiz=( (d>0?(b-a):(a-b)) - 1)  / (d>0?d:-d);\n\t}\n\n\tT operator[](T n){return a+n*d;}\n\titerator begin(){return iterator(a,a+d*siz,a,d);}\n\titerator end(){return iterator(a,a+d*siz,a+d*(siz+1),d);}\n\titerator rbegin(){return iterator(b-d*siz,b,b,-1*d);}\n\titerator rend(){return iterator(b-d*siz,b,b-d*(siz+1),-1*d);}\n\tT size(){return siz;}\n};\ntemplate<typename T>\nrange<T> make_range(T a,T b,long long d=1){return range<T>(a,b,d);}\n\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cfloat>\nusing namespace std;\ntypedef double val_t;\ntypedef complex<val_t> P;\ntypedef vector<P> VP;\nconst val_t EPS=1e-9;\n\nval_t cross(const P &a,const P &b){return (conj(a)*b).imag();}\nval_t dot(const P &a,const P &b){return (conj(a)*b).real();}\nP projection(const VP &l,const P &p){\n\tP t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n\treturn l[0]+t*(l[0]-l[1]);\n}\nbool intersectSP(const VP &s,const P &p){\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nval_t distanceSP(const VP &s,const P &p){\n\tP r=projection(s,p);\n\treturn intersectSP(s,r) ? abs(r-p) : min(abs(s[0]-p),abs(s[1]-p));\n}\nbool intersectSS(const VP &l,const VP &m){\n\tval_t a=cross(l[1]-l[0],m[1]-m[0]);\n\tval_t b=cross(l[1]-l[0],l[1]-m[0]);\n\tVP pt=abs(a)<EPS ? abs(b)<EPS ? VP({l[0],l[1],m[0],m[1]}) : VP() : VP({m[0]+b/a*(m[1]-m[0])});\n\treturn accumulate(pt.begin(),pt.end(),false,[&](bool S,const P &e){\n\t\treturn S||(dot(l[0]-e,l[1]-e)<EPS && dot(m[0]-e,m[1]-e)<EPS);\n\t});\n}\nval_t distanceSS(const VP &s,const VP &t){\n\treturn intersectSS(s,t) ? 0 : min(\n\t\taccumulate(s.begin(),s.end(),DBL_MAX,[&](val_t S,const P &e){return min(S,distanceSP(t,e));}),\n\t\taccumulate(t.begin(),t.end(),DBL_MAX,[&](val_t S,const P &e){return min(S,distanceSP(s,e));})\n\t);\n}\nint main(){\n\tint n;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tdouble sx,sy,ex,ey;\n\t\tscanf(\"%lf%lf%lf%lf\",&sx,&sy,&ex,&ey);\n\t\tVP s={P(sx,sy),P(ex,ey)};\n\t\tauto ra0=make_range(0,n);\n\t\tprintf(\"%f\\n\",accumulate(ra0.begin(),ra0.end(),DBL_MAX,[&](val_t S,int _)->val_t{\n\t\t\tint f=0;\n\t\t\tdouble x1,y1,x2,y2,h;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf\",&x1,&y1,&x2,&y2,&h);\n\t\t\tVP a;\n\t\t\tfor(auto &x:{x1,x2})for(auto &y:{y1,y2})a.emplace_back(x,y);\n\t\t\tswap(a[2],a[3]);\n\t\t\tauto ra1=make_range(0,4);\n\t\t\tval_t d=accumulate(ra1.begin(),ra1.end(),DBL_MAX,[&](val_t S,int i){\n\t\t\t\tf+=cross(a[i]-s[0],a[(i+1)%4]-s[0])<EPS;\n\t\t\t\treturn min(S,distanceSS(s,{a[i],a[(i+1)%4]}));\n\t\t\t});\n\t\t\treturn min(S,\n\t\t\t\tf==4 ? 0 : //inside\n\t\t\t\td>h ? (h*h+d*d)/h/2 :\n\t\t\t\td\n\t\t\t);\n\t\t}));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<complex>\n\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define min_int(a,b) ((a)<(b)?(a):(b))\n#define INF 10000000 //2^31\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\nusing namespace std;\n\nclass Gio{\nprivate:\n\ttypedef complex<double>point;\n\tstruct line{ \n\t\tpoint st, ed;//始点,終点\n\t};\n\tpoint min_p,max_p;\n\tline orig, test;\n\tdouble min_R;//保存用\n\tdouble test_R;//実行用\n\tdouble dot(point a, point b);//内積\n\tdouble cross(point a, point b);//外積\n\npublic:\n\tGio(double sx, double sy,double ex,double ey);\n\tvoid set_p(point* p, double x, double y);\n\tvoid set_line(line* l, point s, point e);\n\tvoid set_testline(double sx, double sy, double ex, double ey);\n\tvoid calc_r(double sx,double sy,double lx,double ly,double h);\n\tdouble get_r();\n\tdouble get_d_pp();//min_pとmax_pの距離を返す\n\tdouble get_d_lp();//min_pとtestの長さを返す\n\tdouble get_d_ll();//origとtestの長さを返す\n\tbool intersect();//origとtestが交差していればtrue\n};\n\nGio::Gio(double sx, double sy, double ex, double ey){\n\tset_p(&min_p, sx, sy);\n\tset_p(&max_p, ex, ey);\n\tset_line(&orig, min_p, max_p);\n\tmin_R = INF;\n}\nvoid Gio::set_p(point *p, double x, double y){\n\tpoint a(x, y);\n\t*p = a;\n}\nvoid Gio::set_line(line* l, point s, point e){\n\tl->st = s;\n\tl->ed=e;\n}\nvoid Gio::set_testline(double sx,double sy,double ex,double ey){\n\tpoint a, b;\n\tset_p(&a, sx, sy); set_p(&b, ex, ey);\n\tset_line(&test, a, b);\n\t//printf(\"%lf,%lf\\n\", test.st.real(), test.st.imag());\n}\ndouble Gio::dot(point a, point b){\n\treturn(a.real()*b.real() + a.imag()*b.imag());\n}\ndouble Gio::cross(point a, point b){\n\treturn(a.real()*b.imag() - a.imag()*b.real());\n}\ndouble Gio::get_d_pp(){ return(abs(max_p - min_p)); }\ndouble Gio::get_d_lp(){\n\tpoint a = test.st;\n\tpoint b = test.ed;\n\tpoint c = min_p;\n\tif (dot(b - a, c - a) < EPS)return(abs(c - a));\n\tif (dot(a - b, c - b) < EPS)return(abs(c - b));\n\treturn(abs(cross(b - a, c - a)) / abs(b - a));\n}\nbool Gio::intersect(){\n\tpoint a = orig.st, b = orig.ed, c = test.st, d = test.ed;\n\treturn((cross(b - a, c - a)*cross(b - a, d - a) < EPS) && (cross(d - c, a - c)*cross(d - c, b - c) < EPS));\n}\n\ndouble Gio::get_d_ll(){\n\tif (intersect())return(0);\n\tpoint a0, a1,b0,b1;\n\ta0 = orig.st;\n\ta1 = orig.ed;\n\tb0 = test.st;\n\tb1 = test.ed;\n\tdouble d1, d2, d3, d4;\n\tmin_p = a0; d1 = get_d_lp();\n\tmin_p = a1; d2 = get_d_lp();\n\tset_line(&test, a0, a1);\n\tmin_p = b0; d3 = get_d_lp();\n\tmin_p = b1; d4 = get_d_lp();\n\td1 = min_int(d1, d2);\n\td2 = min_int(d3, d4);\n\treturn(min_int(d1, d2));\n}\n\nvoid Gio::calc_r(double sx, double sy, double lx, double ly,double h){\n\tdouble d1, d2, d3, d4;\n\tpoint p = orig.st;\n\tif (sx <= p.real() && p.real() <= lx&&sy <= p.imag()&&p.imag() <= ly){\n\t\tmin_R = 0; return;\n\t}\n\n\tset_testline(sx, sy, sx, ly); d1 = get_d_ll();\n\tset_testline(sx, sy, lx, sy); d2 = get_d_ll();\n\tset_testline(sx, ly, lx, ly); d3 = get_d_ll();\n\tset_testline(lx, sy, lx, ly); d4 = get_d_ll();\n\td1 = min_int(min_int(d1, d2), min_int(d3, d4));\n\tif (h >= d1)test_R = d1;\n\telse{\n\t\ttest_R = ((d1*d1 + h*h) / h) / 2;\n\t}\n\tmin_R = min_int(min_R, test_R);\n}\ndouble Gio::get_r(){\n\treturn(min_R);\n}\n\nint b_num;\n\nint main(void){\n\t//Gio g(1, 1, 2, 2);\n\t//g.set_testline(1, 2, 2, 3);\n\t//cout << g.get_d_ll()<<endl;\n\twhile (true){\n\t\tcin >> b_num;\n\t\tif (b_num == 0)return(0);\n\t\tdouble sx, sy, ex, ey,h;\n\t\tcin >> sx >> sy>>ex >> ey;\n\t\tGio g(sx, sy, ex, ey);\n\t\trep(i, 0, b_num){\n\t\t\tcin >> sx >> sy >> ex >> ey>>h;\n\t\t\tg.calc_r(sx, sy, ex, ey, h);\n\t\t}\n\n\t\tprintf(\"%.4lf\\n\", g.get_r());\n\n\t}\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ntypedef vector<P> G;\n\nbool contains(const P p, const G g) {\n  REP(i,g.size())\n    if (ccw(g[i],g[(i+1)%g.size()], p) != -1)\n      return 0;\n  return 1;\n}\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    P s(sx,sy), e(ex,ey);\n    L l(s,e);\n\n    G rect[n];\n    int h[n];\n    bool f = 0;\n    REP(i,n) {\n      int x1,y1,x2,y2;\n      cin>>x1>>y1>>x2>>y2>>h[i];\n      rect[i].push_back(P(x1,y1));\n      rect[i].push_back(P(x1,y2));\n      rect[i].push_back(P(x2,y2));\n      rect[i].push_back(P(x2,y1));\n\n      REP(j,4) {\n        if (intersectSS(l, L(rect[i][j], rect[i][(j+1)%4]))) // R[XãÉubNª éB\n          f = 1;\n      }\n      if (contains(s,rect[i]))  // ubNªR[XðÜÞB\n        f = 1;\n    }\n    if (f) {                    \n      cout << 0 << endl;\n      continue;\n    }\n    double ans = INF;\n\n    // R[XÆubNÌÓÆÌ£ÌÅZðßéB\n    REP(i,n) {\n      REP(j,4) {\n        double d = distanceSS(l, L(rect[i][j], rect[i][(j+1)%4]));\n        ans = min(ans, (d*d+h[i]*h[i])/(2*h[i]));\n      }\n    }\n    printf(\"%.5f\\n\", ans);\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> xy;\ndouble eps = 1e-9;\ndouble dot_product(xy a,xy b) {return (conj(a)*b).real();}\ndouble cross_product(xy a,xy b) {return (conj(a)*b).imag();}\ndouble dist_lp(xy a1,xy a2,xy p){\n    if(dot_product(a2-a1,p-a1)<eps) return abs(p-a1);\n    if(dot_product(a1-a2,p-a2)<eps) return abs(p-a2);\n    return abs(cross_product(a2-a1,p-a1))/abs(a2-a1);\n}\n\nbool is_online(xy a1,xy a2,xy p){\n    return abs(a1-p)+abs(a2-p)<=abs(a1-a2)+eps;    \n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    if(is_online(a1,a2,b1) || is_online(a1,a2,b2)) return true;\n    if(is_online(b1,b2,a1) || is_online(b1,b2,a2)) return true;\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<-eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<-eps;\n}\n\ndouble dist_ll(xy a1,xy a2,xy b1,xy b2){\n    if(is_intersected(a1,a2,b1,b2)) return 0;\n    return min({dist_lp(a1,a2,b1),dist_lp(a1,a2,b2),dist_lp(b1,b2,a1),dist_lp(b1,b2,a2)\n    ,abs(a1-b1),abs(a1-b2),abs(a2-b1),abs(a2-b2)});   \n}\n\nint N;\ndouble sx,sy,gx,gy,mi_x,mi_y,ma_x,ma_y;\ndouble h;\n\n\nint main(){\n    while(cin>>N && N>0){\n        double ans = 1e9;\n        cin >> sx >> sy >> gx >> gy;\n        if(sx>gx){\n            swap(sx,sy);\n            swap(gx,gy);\n        }\n        xy s = xy(sx,sy),g = xy(gx,gy);\n        for(int i=1;i<=N;i++){\n            cin >> mi_x >> mi_y >> ma_x >> ma_y >> h;\n            if((mi_x<=sx && sx<=ma_x && mi_y<=sy && sy<=ma_y || \n            mi_x<=gx && gx<=ma_x && mi_y<=gy && gy<=ma_y)) ans = 0;\n            double d = min({dist_ll(s,g,xy(mi_x,mi_y),xy(mi_x,ma_y)),\n            dist_ll(s,g,xy(mi_x,ma_y),xy(ma_x,ma_y)),\n            dist_ll(s,g,xy(ma_x,ma_y),xy(ma_x,mi_y)),\n            dist_ll(s,g,xy(ma_x,mi_y),xy(mi_x,mi_y))});\n            if(d<=h) ans = min(ans,d);\n            else ans = min(ans,(h*h+d*d)/(2.0*h));\n        }\n        cout << fixed;\n        cout << setprecision(10) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-8;\nconst double PI  = acos(-1.0);\n\nstruct P{\n  double x;\n  double y;\n\n  P():x(0),y(0){\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n\n};\ndouble dot(P a,P b){\n  return (a.x*b.x+a.y*b.y);\n}\n\ndouble cross(P a,P b){\n  return (a.x*b.y-a.y*b.x);\n}\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\ndouble psd(P p , P a , P b){\n  if( dot( b-a , p-a ) < EPS) return fabs(dis(p-a));\n  if( dot( a-b , p-b ) < EPS) return fabs(dis(p-b));\n  return fabs(cross( b-a , p-a )) / fabs(dis(b-a));\n}\n\nbool intersect_s(P a1 , P a2 , P b1 , P b2){\n  return ( cross(a2-a1 , b1-a1)*cross(a2-a1 , b2-a1) < 0) &&\n\t( cross(b2-b1 , a1-b1)*cross(b2-b1 , a2-b1) < 0);\n}\n\ndouble dist_s(P p1, P p2, P q1, P q2){\n  if(intersect_s(p1,p2,q1,q2)) return 0;\n  return min(min(psd(p1, q1, q2), psd(p2, q1, q2)),\n\t\t\t min(psd(q1, p1, p2), psd(q2, p1, p2)));\n}\n\nbool isin(P p, P a1, P a2){\n  double mx = min(a1.x, a2.x), Mx = max(a1.x, a2.x);\n  double my = min(a1.y, a2.y), My = max(a1.y, a2.y);\n  return mx <= p.x && p.x <= Mx\n\t&& my <= p.y  && p.y <= My;\n}\n\nint main(){\n  int N;\n  while(cin>>N,N){\n\tP s, e;\n\tvector< vector<P> > ps(N, vector<P>(4));\n\tvector<double> h(N), d(N, 1e+10);\n\tcin >> s.x >> s.y >> e.x >> e.y;\n\tREP(i,N){\n\t  cin >> ps[i][0].x >> ps[i][0].y >> ps[i][2].x >> ps[i][2].y >> h[i];\n\t  ps[i][1].x = ps[i][0].x;\n\t  ps[i][1].y = ps[i][2].y;\n\n\t  ps[i][3].x = ps[i][2].x;\n\t  ps[i][3].y = ps[i][0].y;\n\t}\n\n\tbool ng = false;\n\tREP(i,N){\n\t  if(isin(s, ps[i][0], ps[i][2]) || isin(e, ps[i][0], ps[i][2]))\n\t\tng = true;\n\t  REP(j,4)\n\t\tif(intersect_s(s,e,ps[i][j],ps[i][(j+1)%4]))\n\t\t   ng = true;\n\t}\n\tif(ng){\n\t  cout << 0 << endl;\n\t  continue;\n\t}\n\n\tREP(i,N) REP(j,4){\n\t  d[i] = min(d[i], dist_s(s, e, ps[i][j], ps[i][(j+1)%4]));\n\t}\n\n\tdouble r = 1100.;\n\tREP(j,N){\n\t  if(d[j] < h[j])\n\t\tr = min(r, d[j]);\n\t  else{\n\t\tdouble r_ = (h[j]*h[j] + d[j]*d[j]) / (2.*h[j]);\n\t\tr = min(r, r_);\n\t  }\n\t}\n\n\tcout << fixed << setprecision(8) << r << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    double l=0,r=1111;\n    Point s,e;\n    cin>>s.x>>s.y>>e.x>>e.y;\n    Segment se=Segment(s,e);\n    Segment ss[n][4],sy[n];\n    double h[n],di[n];\n    for(int i=0;i<n;i++){\n      Point a,b;\n      cin>>a.x>>a.y>>b.x>>b.y>>h[i];\n      Point c=Point(a.x,b.y),d=Point(b.x,a.y);\n      ss[i][0]=Segment(a,c);\n      ss[i][1]=Segment(a,d);\n      ss[i][2]=Segment(c,b);\n      ss[i][3]=Segment(d,b);\n      di[i]=1e9;\n      for(int j=0;j<4;j++) di[i]=min(di[i],getDistance(se,ss[i][j]));\n      \n      Polygon p(4);\n      p[0]=a;p[1]=b;p[2]=c;p[3]=d;\n      p=andrewScan(p);\n      if(contains(p,s)||contains(p,e)) di[i]=0;\n      \n      //cout<<i<<\":\"<<di[i]<<\" \"<<h[i]<<endl;\n      sy[i]=Segment(Point(di[i],0),Point(di[i],h[i]));\n    }\n    for(int i=0;i<100;i++){\n      double m=(l+r)/2;\n      Point p=Point(0,m);\n      bool f=1;\n      for(int j=0;j<n;j++){\n\tf&=getDistanceSP(sy[j],p)>=m;\n\t//cout<<getDistanceSP(sy[j],p)<<\" \"<<m<<endl;\n      }\n      if(f) l=m;\n      else r=m;\n    }\n    printf(\"%.12f\\n\",l);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nvector<Polygon>polys;\nvector<int>hs;\nvector<long double>diss;\n\n\nbool check(const long double rad) {\n\tfor (int i = 0; i < hs.size(); ++i) {\n\t\tif (hs[i] > rad) {\n\t\t\tif (diss[i] < rad)return false;\n\t\t}\n\t\telse {\n\t\t\tlong double needdis = sqrt(rad*rad - (rad - hs[i])*(rad - hs[i]));\n\t\t\tif (diss[i] < needdis)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tcout << fixed << setprecision(22);\n\twhile (1) {\n\t\tint N;\n\t\tcin >> N;\n\t\tif (!N)break;\n\t\tint  sx, sy, gx, gy; cin >>  sx >> sy >> gx >> gy;\n\t\tPoint sp(sx, sy);\n\t\tPoint gp(gx, gy);\n\t\tLine course(sp, gp);\n\t\tpolys.clear();\n\t\ths.clear();\n\t\tdiss.clear();\n\t\tpolys.resize(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint l, u, r, d, h; cin >> l >> u >> r >> d >> h;\n\t\t\tPoint pos[4];\n\t\t\tpos[0] = Point(l, u);\n\t\t\tpos[1] = Point(l, d);\n\t\t\tpos[2] = Point(r, d);\n\t\t\tpos[3] = Point(r, u);\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tpolys[i].emplace_back(pos[j]);\n\t\t\t}\n\t\t\ths.push_back(h);\n\n\t\t\tlong double amindis = 1e9;\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tLine l(polys[i][j], polys[i][(j + 1) % 4]);\n\t\t\t\tamindis = min(amindis, dist_ss(course, l));\n\t\t\t}\n\t\t\tdiss.push_back(amindis);\n\t\t}\n\t\tbool ok=true;\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tLine l(polys[i][j], polys[i][(j + 1) % 4]);\n\t\t\t\tif (isis_ss(course, l)) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (is_in_polygon(polys[i], sp)) {\n\t\t\t\tok = false; break;\n\t\t\t}\n\t\t\tif (is_in_polygon(polys[i], gp)) {\n\t\t\t\tok = false; break;\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\tlong double amin = 0;\n\t\t\tlong double amax = 1e4;\n\t\t\twhile (amin + 1e-9 < amax) {\n\t\t\t\tlong double amid((amin + amax) / 2);\n\t\t\t\tif (check(amid)) {\n\t\t\t\t\tamin = amid;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << amin << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <utility>\nusing namespace std;\nusing P = complex<double>;\nusing L = pair<P,P>;\n#define X real()\n#define Y imag()\nconst double EPS = 1e-10, INF = 1e9;\n\ndouble dot(P a, P b){ return a.X*b.X + a.Y*b.Y; }\ndouble cross(P a, P b){ return a.X*b.Y - a.Y*b.X; }\n\nint ccw(P a, P b, P c){\n  b -= a, c -= a;\n  if(cross(b,c) > +EPS) return +1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return +2;\n  if(norm(b) < norm(c)-EPS) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  P af = a.first, as = a.second, bf = b.first, bs = b.second;\n  return (ccw(af,as,bf)*ccw(af,as,bs) <= 0 and ccw(bf,bs,af)*ccw(bf,bs,as) <= 0);\n}\n\ndouble ps_dist(P a, L s){\n  P sf = s.first, ss = s.second;\n  if(dot(ss-sf,a-sf) >= 0 and dot(sf-ss,a-ss) >= 0)\n    return abs(cross(sf-ss,a-ss))/abs(sf-ss);\n  return min(abs(a-sf),abs(a-ss));\n}\n\ndouble ss_dist(L a, L b){\n  if(is_cross(a,b)) return 0;\n  P af = a.first, as = a.second, bf = b.first, bs = b.second;\n  return min({ps_dist(af,b),ps_dist(as,b),ps_dist(bf,a),ps_dist(bs,a)});\n}\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    P s, t;\n    double x, y;\n    cin >> x >> y;\n    s = P(x,y);\n    cin >> x >> y;\n    t = P(x,y);\n    L l(s,t);\n    //double mi = 0, ma = INF;\n    double ans = 1e3;\n    for(int i = 0; i < N; ++i){\n      double x_[2], y_[2], h;\n      cin >> x_[0] >> y_[0] >> x_[1] >> y_[1] >> h;\n      double d = INF;\n      for(int j = 0; j < 4; ++j){\n        for(int k = 0; k < 4; ++k){\n          double x1 = x_[j%2], y1 = y_[(j/2)%2];\n          double x2 = x_[k%2], y2 = y_[(k/2)%2];\n          d = min(d,ss_dist(l,L(P(x1,y1),P(x2,y2))));\n        }\n      }\n      if(d <= h) ans = min(ans,d);// ma = min(ma,d);\n      else ans = min(ans,(h*h+d*d)/2./h);//mi = max(mi,((h*h+d*d)/2/h));\n    }\n    // if(mi > ma+EPS) ans = 0;\n    // else ans = mi;\n    printf(\"%.12f\\n\",ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n\n#define fr first\n#define sc second\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point,vec;\ntypedef pair<point,point> pp,seg,line;\n\nconst elem pi = 2.0*acos(0.0);\nconst elem eps = 1.0e-12;\nconst elem infty = 1.0e+18;\n\ninline bool eq(elem a, elem b){return abs(b-a) < eps;}\ninline bool leq(elem a, elem b){return eq(a,b) || a < b;}\ninline bool geq(elem a, elem b){return eq(a,b) || a > b;}\ninline bool lt(elem a, elem b){return !eq(a,b) && a < b;}\ninline bool gt(elem a, elem b){return !eq(a,b) && a > b;}\ninline bool ltz(elem a){return lt(a,0);}\ninline bool gtz(elem a){return gt(a,0);}\ninline elem emax(elem a, elem b){return gt(a,b)?a:b;}\ninline elem emin(elem a, elem b){return lt(a,b)?a:b;}\ninline elem dot(point a, point b){return a.real()*b.real() + a.imag()*b.imag();}\ninline elem cross(point a, point b){return a.real()*b.imag()-a.imag()*b.real();}\ninline elem dist_l(line l,point x){ return abs(cross(l.sc-l.fr,x-l.fr))/abs(l.sc-l.fr); }\ninline elem dist_seg(seg s, point x){\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\ninline bool intersected_seg(seg a, seg b){\n  return ( leq( cross(a.sc-a.fr,b.fr-a.fr) * cross(a.sc-a.fr,b.sc-a.fr), 0) &&\n\t   leq( cross(b.sc-b.fr,a.fr-b.fr) * cross(b.sc-b.fr,a.sc-b.fr), 0 ) );\n}\ninline int ccw(point a, point b, point x){\n  b-=a;x-=a;\n  if(gtz(cross(b,x)))return LEFT;\n  if(ltz(cross(b,x)))return RIGHT;\n  if(ltz(dot(b,x)))return BACK;\n  if(abs(b)<abs(x))return FRONT;\n  return OVER;\n}\n\nclass cuboid{\npublic:\n  elem h;\n  elem minx, miny;\n  elem maxx, maxy;\n  point tl,bl,tr,br;\n  cuboid():minx(0),miny(0),\n\t maxx(0),maxy(0),h(0){}\n  cuboid(elem minx, elem miny, elem maxx, elem maxy,elem h):\n    minx(minx),miny(miny),\n    maxx(maxx),maxy(maxy),h(h),\n    tl(minx,maxy),bl(minx,miny),tr(maxx,maxy),br(maxx,miny){}\n  bool intersected_seg(seg l){\n    if( ::intersected_seg(l,seg(tl,tr)) ||\n\t::intersected_seg(l,seg(tl,bl)) ||\n\t::intersected_seg(l,seg(tr,br)) ||\n\t::intersected_seg(l,seg(bl,br)) ) return true;\n    return false;\n  }\n  bool contain_seg(seg l){\n    if( ccw(bl,br,l.fr)&(OVER|LEFT) &&\n\tccw(br,tr,l.fr)&(OVER|LEFT) &&\n\tccw(tr,tl,l.fr)&(OVER|LEFT) &&\n\tccw(tl,bl,l.fr)&(OVER|LEFT)\n\t&&\n\tccw(bl,br,l.sc)&(OVER|LEFT) &&\n\tccw(br,tr,l.sc)&(OVER|LEFT) &&\n\tccw(tr,tl,l.sc)&(OVER|LEFT) &&\n\tccw(tl,bl,l.sc)&(OVER|LEFT) ) return true;\n    return false;\n  }\n  elem getMinimumDistance(seg l){\n    elem ret = infty;\n    ret = emin( ret, dist_seg( l, tl ) );\n    ret = emin( ret, dist_seg( l, tr ) );\n    ret = emin( ret, dist_seg( l, bl ) );\n    ret = emin( ret, dist_seg( l, br ) );\n    ret = emin( ret, dist_seg( seg(tl,tr), l.fr ) );\n    ret = emin( ret, dist_seg( seg(tl,tr), l.sc ) );\n    ret = emin( ret, dist_seg( seg(tl,bl), l.fr ) );\n    ret = emin( ret, dist_seg( seg(tl,bl), l.sc ) );\n    ret = emin( ret, dist_seg( seg(bl,br), l.fr ) );\n    ret = emin( ret, dist_seg( seg(bl,br), l.sc ) );\n    ret = emin( ret, dist_seg( seg(tr,br), l.fr ) );\n    ret = emin( ret, dist_seg( seg(tr,br), l.sc ) );\n    return ret;\n  }\n  elem getRwithSphere(seg l){\n    if(contain_seg(l) || intersected_seg(l))return 0;\n    elem d = getMinimumDistance(l);\n    if(eq(d,0))return 0;\n    if(geq(h,d))return d;\n    elem theta = 2*atan(h/d);\n    elem ret = sqrt( (pow(d,2)+pow(h,2))/(2*(1-cos(theta))) );\n    return ret;\n  }\n};\n\nint main(){\n  while(true){\n    int n;\n    elem ans = infty;\n    elem sx,sy,ex,ey;\n    vector<cuboid> vcubo;\n    scanf(\"%d\",&n);\n    if(n == 0) return 0;\n    scanf(\"%lf%lf%lf%lf\",&sx,&sy,&ex,&ey);\n    point S(sx,sy), E(ex,ey);\n    for(int i = 0; i < n; ++i){\n      elem minx, miny, maxx, maxy, h;\n      scanf(\"%lf%lf%lf%lf%lf\",\n\t    &minx,&miny,&maxx,&maxy,&h);\n      vcubo.push_back( cuboid(minx,miny,maxx,maxy,h) );\n    }\n    for(int i = 0; i < n; ++i){\n      ans = emin( ans, vcubo[i].getRwithSphere( seg(S,E) ) );\n    }\n    printf(\"%.7lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <limit.h>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define REPD(i,n) for(int i=(int)(n); i-->0;)\n#define REPI(i,a,b) for(int i=(int)(a); i<=(int)(b); i++)\n#define ALL(a) (a).begin(),(a).end()\n#define mp make_pair\n#define fst first\n#define snd second\n\n#define INFTY 1000000000\n#define EPS 1e-9\n#define PI 3.141592653589793\n\n#define INF (INFTY/3)\n\n#define rev(s) (string((s).rbegin(), (s).rend()))\n\ntypedef long long Int;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<double,double> pdd;\n\nvoid debug(vi v){ REP(i,v.size()) cout<<v[i]<<\" \"; cout<<endl; }\n\nint nextInt(){ int t; cin>>t; return t; }\n\n#define ZEROP(x) (fabs(x) < EPS)\n#define EQ(x, y) ZEROP((x) - (y))\n#define LT(x, y) ((x) - (y) <= -EPS) // x < y\n#define LE(x, y) ((x) - (y) < +EPS) // x <= y\n#define SIGN(x) ((x)<-EPS?-1:((x)>EPS?+1:0))\n\ntypedef complex<double> P;\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nnamespace std {\n   bool operator < (const P& a, const P& b) {\n     return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n   }\n}\ndouble cross(const P& a, const P& b) {\n   return imag(conj(a)*b);\n} \ndouble dot(const P& a, const P& b) {\n   return real(conj(a)*b); \n}  \nstruct L : public vector<P> {\n  L() {}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  } \n};  \ntypedef vector<P> G;  \nstruct C {\n   P p; double r;\n   C(const P &p, double r) : p(p), r(r) { }\n}; \n\n\n#define MAXN 50\nint N;\nL sl; // start line\nint minx[MAXN];\nint miny[MAXN];\nint maxx[MAXN];\nint maxy[MAXN];\nint h[MAXN];\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (LT( 0, cross(b, c)) )   return +1;       // counter clockwise\n  if (LT( cross(b, c), 0) )   return -1;       // clockwise\n  if (LT( dot(b, c), 0) )     return +2;       // c--a--b on line\n  if (LT( norm(b), norm(c)) ) return -2;       // a--b--c on line\n  return 0;\n}\n\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n// USE IN THIS PROBLEM\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nbool covered(int sx,int sy,int ex,int ey,int ax,int ay,int bx,int by) {\n  return ax < sx && ay < sy && ex < bx && ey < by;\n}\n\n\ndouble solve() {\n  double r = INT_MAX;\n  REP(i,N) {\n    L l[]={L(P(minx[i],miny[i]),P(maxx[i],miny[i])),\n\t   L(P(maxx[i],miny[i]),P(maxx[i],maxy[i])),\n\t   L(P(maxx[i],maxy[i]),P(minx[i],maxy[i])),\n\t   L(P(minx[i],maxy[i]),P(minx[i],miny[i]))};\n    double mind = INT_MAX;\n    int mini; //min index\n    if(covered(real(sl[0]),imag(sl[0]),real(sl[1]),imag(sl[1]),\n\t       minx[i],miny[i],maxx[i],maxy[i])) return 0.0;\n    REP(j,4) {\n      double dd = distanceSS(l[j],sl);\n      if(LT(dd,mind)) {\n\tmind = dd;\n\tmini = j;\n      }\n    }\n    double r2;\n    //printf(\"mind=%lf\\n\",mind);\n    if(LE(mind,h[i])) { // mind <= h[i]\n      r2=mind;\n    } else {\n      r2=(h[i]*h[i] + mind*mind) / (2*h[i]);\n    }\n    r=min(r,r2);\n    //printf(\"r=%lf\\n\",r);\n  }\n  return r;\n}\n\t\nmain() {\n  while(cin>>N,N) {\n    int sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    sl = L(P(sx,sy),P(ex,ey));\n    REP(i,N)\n      cin>>minx[i]>>miny[i]>>maxx[i]>>maxy[i]>>h[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\n// AOJ1183\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187, AOJ1183\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n    const gtype feps = 1e-9;\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -feps\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -feps)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection), AOJ1183(by ip_CL)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& g)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n    {\n        if (ccw(g[(i - 1 + g.size()) % g.size()], g[i], g[(i + 1) % g.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079, AOJ0187\ngtype area(const G& g)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t\ts += cross(g[i], g[(i + 1) % g.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain { OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (intersect_SP(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// a contains b?\n// AOJ0214\nbool contain_GG(const G& a, const G& b)\n{\n    rep(i, b.size())\n        if (contain_GP(a, b[i]) == OUT)\n            return false;\n    return true;\n}\n// AOJ0214\nbool intersect_GG(const G& a, const G& b)\n{\n    rep(i, a.size()) rep(j, b.size())\n        if (intersect_SS(Line(a[i], a[(i + 1) % a.size()]), Line(b[j], b[(j + 1) % b.size()])))\n            return true;\n    return contain_GG(a, b) || contain_GG(b, a);\n}\n\nbool intersect_GS(const G& g, const Seg& s)\n{\n    if (contain_GP(g, s.first) || contain_GP(g, s.second))\n        return true;\n    rep(i, g.size())\n        if (intersect_SS(Seg(g[i], g[(i + 1) % g.size()]), s))\n            return true;\n    return false;\n}\nbool intersect_SG(const Seg& s, const G& g)\n{\n    return intersect_GS(g, s);\n}\n\n// 円\n\n// AOJ0023(feps = 0)\nenum res_pos_CC\n{\n    not_intersect,\n    intersect,\n\n    tangent,\n\n    a_in_b,\n    b_in_a,\n};\nres_pos_CC pos_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nres_contain contain_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(c.p - p);\n    if (d > c.r + feps)\n        return OUT;\n    else if (d < c.r + feps)\n        return IN;\n    else\n        return ON;\n}\n\n// 円周と線分が交わるか\n// AOJ0129\nbool intersect_CS(const Circle& c, const Seg& seg)\n{\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Seg& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\n// AOJ2201\ngtype dist_CL(const Circle& c, const Line& line)\n{\n    return max<gtype>(0, dist_LP(line, c.p) - c.r);\n}\ngtype dist_LC(const Line& line, const Circle& c)\n{\n    return dist_CL(c, line);\n}\n\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    if (pos_CC(a, b) != intersect)\n        return vector<Point>();\n\n    Point ab = b.p - a.p;\n    gtype t = (norm(ab) + a.r*a.r - b.r*b.r) / (2 * abs(ab));\n    Point u = ab / abs(ab);\n    Point q = a.p + t * u;\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - t*t));\n    Point v = Point(0, h) * u;\n\n    vector<Point> res;\n    res.push_back(q + v);\n    if (h > feps)\n        res.push_back(q - v); // 2点\n    return res;\n}\n\n// AOJ1183\nvector<Point> ip_CL(const Circle& c, const Line& line)\n{\n    const gtype feps = 1e-9;\n\n    Point p = projection(line, c.p);\n    Point cp = p - c.p;\n    gtype d = abs(cp);\n    if (d > c.r + feps)\n        return vector<Point>();\n\n    gtype t = sqrt(max<gtype>(0, c.r*c.r - d*d));\n    Point u = line.second - line.first;\n    Point v = u / abs(u) * t;\n\n    vector<Point> res;\n    res.push_back(p + v);\n    if (t > feps)\n        res.push_back(p - v); // 2点\n    return res;\n}\n\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CS(const Circle& c, const Seg& seg)\n{\n    vector<Point> ip = ip_CL(c, seg);\n    vector<Point> res;\n    rep(i, ip.size())\n        if (intersect_SP(seg, ip[i]))\n            res.push_back(ip[i]);\n    return res;\n}\n\n// 点pを通るcの接線\n// AOJ 2201(円が重ならないケースしかない)\nvector<Line> tangent_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-8;\n\n    Point vec = c.p - p;\n    double d = abs(vec);\n    if (d < c.r)\n        return vector<Line>();\n\n    double t = sqrt(max<gtype>(0, d*d - c.r*c.r));\n    Point rota = Point(t / d, c.r / d);\n    rota *= 1; // 線分の長さが0にならないように\n\n    vector<Line> res;\n    res.pb(Line(p, p + vec * rota));\n    if (d > feps)\n        res.push_back(Line(p, p + vec * conj(rota)));\n    return res;\n}\n\n// 共通外接線\n// AOJ 2201(円が重ならないケースしかない)\nvector<Line> tangent_ext_CC(const Circle& a, const Circle& b)\n{\n    if (abs(a.p - b.p) < abs(a.r - b.r))\n        return vector<Line>(); // 内包\n    \n    if (abs(a.r - b.r) > 1e-8)\n    {\n        Point ip = (-a.p * b.r + b.p * a.r) / (a.r - b.r);\n        return tangent_CP(a, ip);        \n    }\n    else\n    {\n        vector<Line> res;\n        Point v = b.p - a.p;\n        v /= abs(v);\n        v *= Point(0, a.r);\n        res.push_back(Line(a.p + v, b.p + v));\n        res.push_back(Line(a.p - v, b.p - v));\n        return res;\n    }\n}\n// 共通内接線\n// AOJ 2201(円が重ならないケースしかない)\nvector<Line> tangent_in_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-8;\n    if (abs(a.p - b.p) < a.r + b.r - feps)\n        return vector<Line>();\n    else\n    {\n        Point ip = (a.p * b.r + b.p * a.r) / (a.r + b.r);\n        return tangent_CP(a, ip);\n    }\n}\n// 共通接線\n// AOJ 2201(円が重ならないケースしかない)\nvector<Line> tangent_CC(const Circle& a, const Circle& b)\n{\n    vector<Line> res;\n    vector<Line> ext = tangent_ext_CC(a, b);\n    vector<Line> in = tangent_in_CC(a, b);\n    rep(i, ext.size())\n        res.pb(ext[i]);\n    rep(i, in.size())\n        res.pb(in[i]);\n    return res;\n}\n\n\n\n\n/////////////////// \nint n;\ndouble dis[55];\ndouble h[55];\nSeg path;\nbool check(double r)\n{\n    rep(i, n)\n    {\n        double z = min(r, h[i]);\n        double s = r - z;\n        double c = sqrt(max<double>(0, r*r - s*s));\n        if (c > dis[i])\n            return false;\n    }\n    return true;\n}\nint main()\n{\n    while (cin >> n, n)\n    {\n        cin >> path.first >> path.second;\n        bool ok = true;\n        rep(i, n)\n        {\n            int x[2], y[2];\n            rep(j, 2)\n                cin >> x[j] >> y[j];\n            cin >> h[i];\n\n            Point p[] = { Point(x[0], y[0]), Point(x[1], y[0]), Point(x[1], y[1]), Point(x[0], y[1]) };\n            dis[i] = 1e60;\n            rep(j, 4)\n            {\n                Seg seg(p[j], p[(j + 1) % 4]);\n                chmin(dis[i], dist_SS(path, seg));\n            }\n            if (intersect_GS(G(p, p + 4), path))\n                ok = false;\n        }\n\n        double low = 0, high = 1e6;\n        if (!ok)\n            goto END;\n        rep(t, 100)\n        {\n            double mid = (low + high) / 2;\n            (check(mid) ? low : high) = mid;\n        }\n    END:\n        printf(\"%.8f\\n\", low);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(const Point &p0,const Point &p1,const Point &p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nPoint projection(const Segment &s,const Point &p){\n    Vector b = s.t-s.s;\n    double t = dot(p-s.s,b)/norm(b);\n    return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n    return (ccw(s.s,s.t,p) == 0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n            ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n    Point r = projection(s,p);\n    if(isIntersectSP(s,r)) return abs(r-p);\n    return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment &a,const Segment &b){\n    if(isIntersectSS(a,b)) return 0;\n    return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n           min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nstruct Block{\n    Point a,b;\n    double h;\n    Block(){}\n    Block(Point &a,Point &b,double h) :\n        a(a),b(b),h(h) {}\n};\n\nistream &operator >> (istream &is,Point &p){ \n    return is >> p.x >> p.y;\n}\n\ndouble calc(double a,double b){\n    return sqrt(a*a+b*b);\n}\n\nbool c(double r,Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point a = v[i].a,b = v[i].b;\n        Point c(a.x,b.y),d(b.x,a.y);\n        Segment s1(a,c),s2(a,d),s3(c,b),s4(d,b);\n        double dst[] = {\n            distanceSS(p,s1),\n            distanceSS(p,s2),\n            distanceSS(p,s3),\n            distanceSS(p,s4)\n        };\n \n        if(r < v[i].h){\n            if(!(r < dst[0] &&\n                 r < dst[1] &&\n                 r < dst[2] &&\n                 r < dst[3])){\n                return false;\n            }\n        }else{\n            double nh = r - v[i].h;\n            if(!(r < calc(nh,dst[0]) &&\n                 r < calc(nh,dst[1]) &&\n                 r < calc(nh,dst[2]) &&\n                 r < calc(nh,dst[3]))){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool check(Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point c(v[i].a.x,v[i].b.y);\n        Point d(v[i].b.x,v[i].a.y);\n        Segment s1(v[i].a,c),s2(v[i].a,d),s3(c,v[i].b),s4(d,v[i].b);\n        if((v[i].a.x <= p.s.x && p.s.x <= v[i].b.x &&\n            v[i].a.y <= p.s.y && p.s.y <= v[i].b.y) ||\n           (v[i].a.x <= p.t.x && p.t.x <= v[i].b.x &&\n            v[i].a.y <= p.t.y && p.t.y <= v[i].b.y)){\n            return true;\n        }\n        if(isIntersectSS(p,s1)) return true;\n        if(isIntersectSS(p,s2)) return true;\n        if(isIntersectSS(p,s3)) return true;\n        if(isIntersectSS(p,s4)) return true;\n    }\n    return false;\n}\n\nint main(){\n    int N;\n    while(cin >> N,N){\n        Point s,e;\n        Segment seg;\n        cin >> seg.s >> seg.t;\n        vector<Block> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].a >> v[i].b >> v[i].h;\n        }\n        if(check(seg,v)){\n            cout << 0 << endl;\n            continue;\n        }\n        double l = 0,r = 1001;\n        for(int i = 0 ; i < 100 ; i++){\n            double mid = (l + r) / 2;\n            if(c(mid,seg,v)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n        printf(\"%.10f\\n\",r);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\n\nnamespace Geometry{\n#define F first\n#define S second\n  typedef long double D;\n  typedef complex<long double> P;\n  typedef pair<P,D> C;\n    \n  const D EPS=1e-9;\n  const D PI=asin(1)*2;\n  const D INF=1e18;\n    \n  static bool comp(const P &p1,const P &p2){\n    if(p1.real()==p2.real()){return p1.imag()<p2.imag();}\n    return p1.real()<p2.real();\n  }\n    \n  static bool comp_y(const P &p1,const P &p2){\n    if(p1.imag()==p2.imag()){return p1.real()<p2.real();}\n    return p1.imag()<p2.imag();\n  }\n    \n  static bool eqls(const P &p1,const P &p2){return abs(p1-p2)<EPS;}\n    \n  D dot(P p1,P p2){return p1.real()*p2.real()+p1.imag()*p2.imag();}\n    \n  D cross(P p1,P p2){return p1.real()*p2.imag()-p1.imag()*p2.real();}\n    \n  P project(P vec,P x){return vec*(x/vec).real();}\n    \n  P project(P p1,P p2,P x){return p1+project(p2-p1,x-p1);}\n    \n  P reflect(P vec,P x){return vec*conj(x/vec);}\n    \n  P reflect(P p1,P p2,P x){return p1+reflect(p2-p1,x-p1);}\n    \n  bool intersectSL(P p1,P p2,P vec){\n    vec/=abs(vec); p1/=vec; p2/=vec;\n    return (p1.imag()<EPS && p2.imag()>-EPS) || (p1.imag()>-EPS && p2.imag()<EPS);\n  }\n    \n  bool intersectSL(P p1,P p2,P p3,P p4){return intersectSL(p1-p4,p2-p4,p3-p4);}\n    \n  bool intersectSS(P p1,P p2,P p3,P p4){\n    if(dot(p2-p1,p3-p1)<-EPS && dot(p2-p1,p4-p1)<-EPS){return false;}\n    if(dot(p1-p2,p3-p2)<-EPS && dot(p1-p2,p4-p2)<-EPS){return false;}\n    return intersectSL(p1,p2,p3,p4) && intersectSL(p3,p4,p1,p2);\n  }\n    \n  D distLP(P vec,P x){return abs((x/vec).imag())*abs(vec);}\n    \n  D distLP(P p1,P p2,P x){return distLP(p2-p1,x-p1);}\n    \n  D distSP(P p1,P p2,P x){\n    if(dot(p2-p1,x-p1)<-EPS){return abs(x-p1);}\n    if(dot(p1-p2,x-p2)<-EPS){return abs(x-p2);}\n    return distLP(p1,p2,x);\n  }\n    \n  D distSS(P p1,P p2,P p3,P p4){\n    if(intersectSS(p1,p2,p3,p4)){return 0.0;}\n    return min({distSP(p1,p2,p3),distSP(p1,p2,p4),\n                distSP(p3,p4,p1),distSP(p3,p4,p2)});\n  }\n    \n  P crosspointLL(P p1,P p2,P vec){\n    if(abs(cross(p2-p1,vec))<EPS){return vec;}\n    return vec*cross(p2-p1,p2)/cross(p2-p1,vec);\n  }\n    \n  P crosspointLL(P p1,P p2,P p3,P p4){\n    return p4+crosspointLL(p1-p4,p2-p4,p3-p4);\n  }\n    \n  P crosspointSS(P p1,P p2,P p3,P p4){\n    if(distSP(p1,p2,p3)<EPS){return p3;}\n    if(distSP(p1,p2,p4)<EPS){return p4;}\n    return crosspointLL(p1,p2,p3,p4);\n  }\n    \n  bool intersectShL(P p1,P p2,P vec){\n    vec/=abs(vec);\n    return intersectSL(p1,p2,vec) &&\n      crosspointLL(p1/vec,p2/vec,vec/vec).real()>-EPS;\n  }\n    \n  bool intersectShL(P p1,P p2,P p3,P p4){\n    return intersectShL(p1-p3,p2-p3,p4-p3);\n  }\n    \n  //1::in,0::on edge,-1::out\n  int contain(const vector<P> &poly,const P &p){\n    vector<P> A={{65537,96847},{-24061,6701},{56369,-86509},{-93763,-78049},{56957,10007}};\n    int s=A.size();\n    vector<bool> cnt(s,false);\n    for(int i=0;i<(int)poly.size();i++){\n      int k=(i+1)%poly.size();\n      if(distSP(poly[i],poly[k],p)<EPS){return 0;}\n      for(int j=0;j<s;j++){\n        if(intersectShL(poly[i],poly[k],p,p+A[j])){cnt[j]=!cnt[j];}\n      }\n    }\n    int in=0;\n    for(int j=0;j<s;j++){if(cnt[j]){in++;}}\n    return in>s/2?1:-1;\n  }\n    \n  vector<P> convexcut(const vector<P> &poly,P p1,P p2){\n    vector<P> ret;\n    for(int i=0;i<(int)poly.size();i++){\n      int j=(i+1)%poly.size();\n      if(cross(p2-p1,poly[i]-p1)>-EPS){ret.push_back(poly[i]);}\n      if(intersectSL(poly[i],poly[j],p1,p2) &&\n         distLP(p1,p2,poly[i])>EPS && distLP(p1,p2,poly[j])>EPS){\n        ret.push_back(crosspointLL(poly[i],poly[j],p1,p2));\n      }\n    }\n    return ret;\n  }\n    \n  D area(const vector<P> &poly){\n    D ans=0;\n    for(int i=2;i<(int)poly.size();i++){\n      ans+=cross(poly[i-1]-poly[0],poly[i]-poly[0]);\n    }\n    return abs(ans)/2;\n  }\n    \n  vector<P> convexhull(vector<P> pts){\n    vector<P> ret;\n    sort(pts.begin(),pts.end(),comp);\n    auto fnc=[&](){\n               for(auto &I:pts){\n                 if(!ret.empty() && abs(I-ret.back())<EPS){continue;}\n                 while(ret.size()>1){\n                   P A=ret.back()-ret[ret.size()-2];\n                   P B=I-ret.back();\n                   if(cross(A,B)<-EPS){ret.pop_back();}\n                   else if(abs(cross(A,B))<EPS && dot(A,B)>EPS){ret.pop_back();}\n                   else{break;}\n                 }\n                 ret.push_back(I);\n               }\n             };\n    fnc();\n    reverse(pts.begin(),pts.end());\n    fnc();\n    if(ret.size()>1 && ret[0]==ret.back()){ret.pop_back();}\n    return ret;\n  }\n    \n  //4::seperate,3::circumscribe,2::intersect,1::inscribe,0::contain,-1::same\n  int intersectCC(C c1,C c2){\n    D d=abs(c1.F-c2.F),r=c1.S+c2.S,dif=abs(c2.S-c1.S);\n    if(d<EPS && dif<EPS){return -1;}\n    if(d-r>EPS){return 4;}\n    if(d-r>-EPS){return 3;}\n    if(d-dif>EPS){return 2;}\n    if(d-dif>-EPS){return 1;}\n    return 0;\n  }\n    \n  vector<P> crosspointLC(P p1,P p2,C c){\n    vector<P> ret;\n    P pr=project(p1,p2,c.F);\n    D d=distLP(p1,p2,c.F);\n    if(d-c.S>EPS){return ret;}\n    if(d-c.S>-EPS){ret.push_back(pr); return ret;}\n    P vec=p2-p1; vec*=sqrt(c.S*c.S-d*d)/abs(vec);\n    ret.push_back(pr-vec);\n    ret.push_back(pr+vec);\n    return ret;\n  }\n    \n  vector<P> crosspointSC(P p1,P p2,C c){\n    vector<P> ret;\n    for(auto &I:crosspointLC(p1,p2,c)){\n      if(distSP(p1,p2,I)<EPS){ret.push_back(I);}\n    }\n    return ret;\n  }\n    \n  vector<P> crosspointCC(C c1,C c2){\n    vector<P> ret;\n    P vec=c2.F-c1.F;\n    D base=(c1.S*c1.S+norm(vec)-c2.S*c2.S)/(2*abs(vec));\n    D h=sqrt(c1.S*c1.S-base*base);\n    vec/=abs(vec);\n    ret.push_back(c1.F+vec*P(base,-h));\n    ret.push_back(c1.F+vec*P(base,h));\n    return ret;\n  }\n    \n  vector<P> tangentCP(C c,P p){\n    return crosspointCC(c,C(p,sqrt(norm(c.F-p)-c.S*c.S)));\n  }\n    \n  vector<pair<P,P>> tangentCC(C c1,C c2){\n    vector<pair<P,P>> ret;\n    P d=c2.F-c1.F;\n    for(D i:{-1,1}){\n      D r=c1.S+c2.S*i;\n      if(intersectCC(c1,c2)>i+1){\n        for(P s:{-1i,1i}){\n          P p=r+s*sqrt(norm(d)-norm(r));\n          ret.push_back({c1.F+d*c1.S/norm(d)*p,c2.F-d*i*c2.S/norm(d)*p});\n        }\n      }\n    }\n    return ret;\n  }\n    \n  D area(const vector<P> &poly,C c){\n    D ret=0;\n    for(int i=0;i<(int)poly.size();i++){\n      P a=poly[i]-c.F,b=poly[(i+1)%poly.size()]-c.F;\n      if(abs(a)<c.S+EPS && abs(b)<c.S+EPS){ret+=cross(a,b);}\n      else{\n        vector<P> A=crosspointSC(a,b,{0,c.S});\n        if(A.empty()){ret+=c.S*c.S*arg(b/a);}\n        else{\n          ret+=(abs(a)<c.S?cross(a,A[0]):c.S*c.S*arg(A[0]/a));\n          ret+=(abs(b)<c.S?cross(A.back(),b):c.S*c.S*arg(b/A.back()));\n          ret+=cross(A[0],A.back());\n        }\n      }\n    }\n    return abs(ret)/2;\n  }\n    \n  //反時計回り\n  D diameter(const vector<P> &poly){\n    D ret=0;\n    ll l=0,r=0,n=poly.size();\n    if(n==2){return abs(poly[0]-poly[1]);}\n    for(int i=0;i<n;i++){\n      if(comp(poly[l],poly[i])){l=i;}\n      if(comp(poly[i],poly[r])){r=i;}\n    }\n    ll sl=r,sr=l;\n    while(sl!=l || sr!=r){\n      ret=max(ret,abs(poly[r]-poly[l]));\n      if(cross(poly[(l+1)%n]-poly[l],poly[(r+1)%n]-poly[r])<0){(++l)%=n;}\n      else{(++r)%=n;}\n    }\n    return ret;\n  }\n    \n  D closestpair(vector<P> pt){\n    sort(pt.begin(),pt.end(),comp);\n    D ret=INF;\n    int N=pt.size();\n    for(int i=1;i<N;i<<=1){\n      for(int j=0;i+j<N;j+=i*2){\n        int m=i+j;\n        vector<P> R;\n        D l=-INF,r=INF;\n        for(int k=j;k<m;k++){l=max(l,pt[k].real());}\n        for(int k=0;m+k<N && k<i;k++){r=min(r,pt[m+k].real());}\n        for(int k=0;m+k<N && k<i;k++){\n          if(pt[m+k].real()-l<ret){R.push_back(pt[m+k]);}\n        }\n        int idx=0;\n        for(int k=j;k<m;k++){\n          if(r-pt[k].real()>ret){continue;}\n          int M=R.size();\n          while(idx<M && pt[k].imag()-R[idx].imag()>ret){idx++;}\n          for(int s=idx;s<M && R[s].imag()-pt[k].imag()<ret;s++){\n            ret=min(ret,abs(R[s]-pt[k]));\n          }\n        }\n        auto ed=(j+i*2<N?pt.begin()+j+2*i:pt.end());\n        inplace_merge(pt.begin()+j,pt.begin()+m,ed,comp_y);\n      }\n    }\n    return ret;\n  }\n    \n  P centerofgravity(const vector<P> &pt){\n    P ret(0,0);\n    D wt=0;\n    for(int i=2;i<(int)pt.size();i++){\n      D w2=cross(pt[i-1]-pt[0],pt[i]-pt[0]);\n      P p=(pt[0]+pt[i-1]+pt[i])/(D)3;\n      wt+=w2;\n      ret+=p*w2;\n    }\n    return ret/wt;\n  }\n    \n  void segment_arrangement(const vector<pair<P,P>> &L,vector<pair<int,int>> &seg,vector<P> &pt){\n    int N=L.size();\n    for(int i=0;i<N;i++){\n      pt.push_back(L[i].F);\n      pt.push_back(L[i].S);\n      for(int j=i+1;j<N;j++){\n        if(intersectSS(L[i].F,L[i].S,L[j].F,L[j].S)){\n          pt.push_back(crosspointSS(L[i].F,L[i].S,L[j].F,L[j].S));\n        }\n      }\n    }\n    auto le=[](P a,P b){return eqls(a,b)?false:comp(a,b);};\n    sort(pt.begin(),pt.end(),le);\n    pt.erase(unique(pt.begin(),pt.end(),eqls),pt.end());\n    for(auto &I:L){\n      vector<pair<D,int>> on;\n      for(int j=0;j<(int)pt.size();j++){\n        if(distSP(I.F,I.S,pt[j])<EPS){\n          on.emplace_back(abs(pt[j]-I.F),j);\n        }\n      }\n      sort(on.begin(),on.end());\n      for(int j=1;j<(int)on.size();j++){\n        seg.emplace_back(on[j-1].S,on[j].S);\n      }\n    }\n    sort(seg.begin(),seg.end());\n    seg.erase(unique(seg.begin(),seg.end()),seg.end());\n  }\n    \n  vector<P> convex_of_segments(const vector<pair<P,P>> &L){\n    vector<pair<int,int>> seg;\n    vector<P> pt;\n    segment_arrangement(L,seg,pt);\n    vector<vector<int>> edge(pt.size());\n    for(auto &I:seg){\n      edge[I.F].push_back(I.S);\n      edge[I.S].push_back(I.F);\n    }\n    vector<P> ret;\n    function<void(int,int)> dfs=\n      [&](int v,int pre){\n        if(pre!=-1 && v==0){return;}\n        ret.push_back(pt[v]);\n        vector<pair<D,int>> nx;\n        for(auto &u:edge[v]){\n          D a=arg((pt[u]-pt[v])/(pre==-1 || eqls(pt[v],pt[pre])?P(1):pt[v]-pt[pre]));\n          if(abs(a+PI)<EPS){a=PI;}\n          nx.emplace_back(a,u);\n        }\n        sort(nx.begin(),nx.end());\n        dfs(nx[0].S,v);\n      };\n    dfs(0,-1);\n    return ret;\n  }\n    \n  istream & operator >> (istream &i,P &p){D x,y; i>>x>>y; p={x,y}; return i;}\n  istream & operator >> (istream &i,C &p){D x,y; i>>x>>y>>p.S; p.F={x,y}; return i;}\n  void Input(P &p){D x,y;cin>>x>>y;p={x,y};}\n};\n\nusing namespace Geometry;\n\n\nint main(){\n  cout<<fixed<<setprecision(12);\n  ll N;\n  while(cin>>N,N){\n  P S,G;\n  Input(S);\n  Input(G);\n  vector<P> A(N);\n  D ans=INF;\n  for(auto &I:A){\n    ll x1,y1,x2,y2,h;\n    cin>>x1>>y1>>x2>>y2>>h;\n    P a1(x1,y1);\n    P a2(x2,y1);\n    P a3(x2,y2);\n    P a4(x1,y2);\n    D dist=distSS(S,G,a1,a2);\n    dist=min(dist,distSS(S,G,a2,a3));\n    dist=min(dist,distSS(S,G,a3,a4));\n    dist=min(dist,distSS(S,G,a4,a1));\n    if(intersectSS(a1,a2,S,G) || intersectSS(a2,a3,S,G) || intersectSS(a3,a4,S,G) || intersectSS(a4,a1,S,G) || contain({a1,a2,a3,a4},S)!=-1){ans=0;}\n    I={dist,(D)h};\n  }\n  auto judge=\n    [&](D r){\n      bool jd=true;\n      for(auto &I:A){\n        if(I.imag()>r){jd&=I.real()>r;}\n        else{jd&=abs(P(0,r)-I)>r;}\n      }\n      return jd;\n    };\n  D lf=0,rg=1e4;\n\n  for(int i=0;i<100;i++){\n    D mid=(lf+rg)/2;\n    if(judge(mid)){lf=mid;}\n    else{rg=mid;}\n  }\n  cout<<min(ans,rg)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-10L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define seg_size 262144LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < 0) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < 0);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist+eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa))/pointer,\n            (aa* target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer};\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\n\nvoid solve(){\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0)return;\n        long double b, c, d, e;\n        cin >> b >> c >> d >> e;\n        Line a{ Point{b,c} ,Point{d,e} };\n        long double ans = 1e18;\n        REP(i, n) {\n            long double x[2], y[2];\n            REP(q, 2) {\n                cin >> x[q] >> y[q];\n            }\n            long double h;\n            cin >> h;\n            REP(q, 2) {\n                REP(j, 2) {\n                    REP(t, 2) {\n                        REP(p, 2) {\n\n                            long double d = Dist_Line_Line(a, Line{ Point{ x[q],y[j] } ,Point{x[t],y[p]} });\n                            if (d <= h) {\n                                ans = min(ans, d);\n                            }\n                            else {\n                                ans = min(ans, (h * h + d * d) / (2.0L * h));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000.0\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\ndouble sx, sy, ex, ey;\ndouble mx[50], my[50], Mx[50], My[50], h[50];\n\ndouble f(double x, double y, double z){\n\tdouble r = 0, l = 1, mr, ml;\n\trep(i,50){\n\t\tmr = (r*2+l)/3;\n\t\tml = (r+l*2)/3;\n\t\tif((sx+(ex-sx)*mr-x)*(sx+(ex-sx)*mr-x)+(sy+(ey-sy)*mr-y)*(sy+(ey-sy)*mr-y) < (sx+(ex-sx)*ml-x)*(sx+(ex-sx)*ml-x)+(sy+(ey-sy)*ml-y)*(sy+(ey-sy)*ml-y)){\n\t\t\tl = ml;\n\t\t} else r = mr;\n\t}\n\treturn sqrt((sx+(ex-sx)*r-x)*(sx+(ex-sx)*r-x)+(sy+(ey-sy)*r-y)*(sy+(ey-sy)*r-y)+z*z);\n}\n\ndouble fx(double x1, double x2, double y, double z){\n\tdouble r = x1, l = x2, mr, ml;\n\trep(i,50){\n\t\tmr = (r*2+l)/3;\n\t\tml = (r+l*2)/3;\n\t\tif(f(mr,y,0) < f(ml,y,0)){\n\t\t\tl = ml;\n\t\t} else r = mr;\n\t}\n\treturn f(r,y,z);\n}\n\ndouble fy(double x, double y1, double y2, double z){\n\tdouble r = y1, l = y2, mr, ml;\n\trep(i,50){\n\t\tmr = (r*2+l)/3;\n\t\tml = (r+l*2)/3;\n\t\tif(f(x,mr,0) < f(x,ml,0)){\n\t\t\tl = ml;\n\t\t} else r = mr;\n\t}\n\treturn f(x,r,z);\n}\n\nvoid solve(){\n\tcin >> sx >> sy >> ex >> ey;\n\trep(i,n) cin >> mx[i] >> my[i] >> Mx[i] >> My[i] >> h[i];\n\trep(i,n){\n\t\tif(mx[i]<=sx&&sx<=Mx[i]&&my[i]<=sy&&sy<=My[i]){\n\t\t\tputs(\"0.000\");\n\t\t\treturn;\n\t\t}\n\t\tif(mx[i]<=ex&&ex<=Mx[i]&&my[i]<=ey&&ey<=My[i]){\n\t\t\tputs(\"0.000\");\n\t\t\treturn;\n\t\t}\n\t}\n\tdouble s = 0.0, e = 10000.0, mid;\n\trep(u,50){\n\t\tmid = (s+e)/2;\n\t\tdouble dist = INF;\n\t\trep(i,n){\n\t\t\tdouble z = mid-h[i];\n\t\t\tif(z < 0) z = 0.0;\n\t\t\tdist = min(dist,fx(mx[i],Mx[i],my[i],z));\n\t\t\tdist = min(dist,fx(mx[i],Mx[i],My[i],z));\n\t\t\tdist = min(dist,fy(mx[i],my[i],My[i],z));\n\t\t\tdist = min(dist,fy(Mx[i],my[i],My[i],z));\n\t\t}\n\t\tif(dist < mid){\n\t\t\te = mid;\n\t\t} else s = mid;\n\t}\n\tprintf(\"%.9f\\n\",s);\n}\n\nint main(){\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-10;\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\nint main(){\n  while(true){\n    int n;\n    cin>>n;\n    if(!n)break;\n    double r,r_min = 1000;\n    double sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    P s=P(sx,sy),e=P(ex,ey);\n    for(int i=0;i<n;i++){\n      double x1,y1,x2,y2,h;\n      cin>>x1>>y1>>x2>>y2>>h;\n      P p[4]={ P(x1,y1),P(x2,y1),P(x2,y2),P(x1,y2)};\n      if(is_intersected_ls(s,e,p[0],p[1])\n\t ||is_intersected_ls(s,e,p[1],p[2])\n\t ||is_intersected_ls(s,e,p[2],p[3])\n\t ||is_intersected_ls(s,e,p[3],p[0])\n\t ||(x1<min(sx,ex)&&y1<min(sy,ey)&&max(sx,ex)<x2&&max(sy,ey)<y2)){\n\tr_min = 0;\n      }\n      if(r_min-EPS>0){\n\tdouble l=1000;\n\tfor(int j=0;j<4;j++){\n\t  l = min(l,distance_ls_p(s,e,p[j]));\n\t  l = min(l,distance_ls_p(p[j],p[(j+1)%4],s));\n\t  l = min(l,distance_ls_p(p[j],p[(j+1)%4],e));\n\t}\n\tr = h>l?l:(h*h+l*l)/(2*h);\n\tif(r<r_min)r_min = r;\n      }\n    }\n    printf(\"%.5f\\n\",r_min);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<double> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bucnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n\nconst ll inf = (ll)1e9;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\ndouble dot_product(pdd a, pdd b, pdd c) {\n\treturn (b.fst - a.fst)*(c.fst - a.fst) + (b.scn - a.scn)*(c.scn - a.scn);\n}\n\ndouble cross_product(pdd a, pdd b, pdd c) {\n\treturn (b.fst - a.fst)*(c.scn - a.scn) - (b.scn - a.scn)*(c.fst - a.fst);\n}\n\ndouble dist(pdd a, pdd b) {\n\treturn sqrt((a.fst - b.fst)*(a.fst - b.fst) + (a.scn - b.scn)*(a.scn - b.scn));\n}\n\ndouble Ldist(pdd s, pdd t, pdd a) {\n\tcompd T(t.fst - s.fst, t.scn - s.scn), A(a.fst - s.fst, a.scn - s.scn);\n\tcompd rot = T / abs(T);\n\tA /= rot;\n\tT /= rot;\n\tif (A.real() < eps)\treturn dist(s, a);\n\tif (T.real() - eps < A.real())\treturn dist(t, a);\n\treturn abs(A.imag());\n}\n\nint main() {\n\twhile (true) {\n\t\tint n;\tcin >> n;\n\t\tif (n == 0)\treturn 0;\n\t\tpdd s, t;\tcin >> s.fst >> s.scn >> t.fst >> t.scn;\n\t\tdouble left = 0, right = 1024;\n\t\trep(i, n) {\n\t\t\tvector<pdd> a(4);\n\t\t\tcin >> a[0].fst >> a[0].scn >> a[2].fst >> a[2].scn;\n\t\t\tdouble h;\tcin >> h;\n\t\t\ta[1] = mp(a[0].fst, a[2].scn);\n\t\t\ta[3] = mp(a[2].fst, a[0].scn);\n\t\t\t//s-t???????????????????????????\n\t\t\tbool is_inside = true;\n\t\t\trep(j, 4) {\n\t\t\t\tif (dot_product(a[j], a[(j + 1) % 4], s) < -eps)\tis_inside = false;\n\t\t\t\tif (dot_product(a[j], a[(j + 1) % 4], t) < -eps)\tis_inside = false;\n\t\t\t}\n\t\t\tif (is_inside)\tright = 0;\n\t\t\tleft = 0;\n\t\t\tright += eps;\n\t\t\trep(k, 30) {\n\t\t\t\tdouble mid = (left + right) / 2.0;\n\t\t\t\tdouble height = mid - min(mid, h);\n\t\t\t\tdouble r = sqrt(mid*mid - height*height);\n\t\t\t\tbool ok = true;\n\t\t\t\trep(j, 4) {\n\t\t\t\t\tif (Ldist(s, t, a[j]) < r + eps)\tok = false;\n\t\t\t\t\tif (Ldist(a[j], a[(j + 1) % 4], t) < r + eps)\tok = false;\n\t\t\t\t\tif (Ldist(a[j], a[(j + 1) % 4], s) < r + eps)\tok = false;\n\t\t\t\t}\n\t\t\t\trep(j, 4) {\n\t\t\t\t\tif (cross_product(s, t, a[j])*cross_product(s, t, a[(j + 1) % 4]) > eps)\tcontinue;\n\t\t\t\t\tif (cross_product(a[j], a[(j + 1) % 4], s)*cross_product(a[j], a[(j + 1) % 4], t) > eps)\tcontinue;\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\tif (ok)\tleft = mid;\n\t\t\t\telse\tright = mid;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.15lf\\n\", left);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n// #define int long long\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000               // 2e9\n#define LLINF 2000000000000000000ll  // 2e18 (llmax:9e18)\n#define fi first\n#define sec second\n#define all(x) (x).begin(), (x).end()\n#define sq(x) ((x) * (x))\n#define dmp(x) cerr << #x << \": \" << x << endl;\n\ntemplate <class T>\nvoid chmin(T &a, const T &b) {\n  if (a > b) a = b;\n}\ntemplate <class T>\nvoid chmax(T &a, const T &b) {\n  if (a < b) a = b;\n}\n\ntemplate <class T>\nusing MaxHeap = priority_queue<T>;\ntemplate <class T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T>\nvector<T> vect(int len, T elem) {\n  return vector<T>(len, elem);\n}\n\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << p.fi << ',' << p.sec;\n  return os;\n}\ntemplate <class T, class U>\nistream &operator>>(istream &is, pair<T, U> &p) {\n  is >> p.fi >> p.sec;\n  return is;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n  for (int i = 0; i < vec.size(); i++) {\n    os << vec[i];\n    if (i + 1 < vec.size()) os << ' ';\n  }\n  return os;\n}\ntemplate <class T>\nistream &operator>>(istream &is, vector<T> &vec) {\n  for (int i = 0; i < vec.size(); i++) is >> vec[i];\n  return is;\n}\nvoid fastio() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cout << fixed << setprecision(20);\n}\n\n#define endl \"\\n\"\n\n// Geometry Library\n// written by okuraofvegetable\n\n#define DOUBLE_INF 1e50\n#define Points vector<Point>\n#define EQ(a, b) (abs((a) - (b)) < eps)\n\ninline double add(double a, double b) {\n  if (abs(a + b) < eps * (abs(a) + abs(b))) return 0;\n  return a + b;\n}\n\n#define Vector Point\nstruct Point {\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  Point operator+(Point p) { return Point(add(x, p.x), add(y, p.y)); }\n  Point operator-(Point p) { return Point(add(x, -p.x), add(y, -p.y)); }\n  Point operator*(double d) { return Point(x * d, y * d); }\n  Point operator/(double d) { return Point(x / d, y / d); }\n  double dot(Point p) { return add(x * p.x, y * p.y); }\n  double det(Point p) { return add(x * p.y, -y * p.x); }\n  double norm() { return sqrt(x * x + y * y); }\n  double norm2() { return x * x + y * y; }\n  double dist(Point p) { return ((*this) - p).norm(); }\n  double dist2(Point p) { return sq(x - p.x) + sq(y - p.y); }\n  double arg() { return atan2(y, x); }              // [-PI,PI]\n  double arg(Vector v) { return v.arg() - arg(); }  // henkaku\n  double angle(Vector v) {                          // [0,PI]\n    return acos(cos(arg(v)));\n  }\n  Vector normalize() { return (*this) * (1.0 / norm()); }\n  Point vert() { return Point(y, -x); }\n\n  // signed area of triange (0,0) (x,y) (p.x,p.y)\n  double area(Point p) { return (x * p.y - p.x * y) / 2.0; }\n  friend istream &operator>>(istream &is, Point &p) {\n    is >> p.x >> p.y;\n    return is;\n  }\n  friend ostream &operator<<(ostream &os, const Point &p) {\n    os << '(' << p.x << ',' << p.y << ')';\n    return os;\n  }\n};\n// direction a -> b -> c\n// verified AOJ CGL_1_C\nenum { COUNTER_CLOCKWISE, CLOCKWISE, ONLINE_BACK, ONLINE_FRONT, ON_SEGMENT };\nPoint divide_rate(Point a, Point b, double A, double B) {\n  assert(!EQ(A + B, 0.0));\n  return (a * B + b * A) * (1.0 / (A + B));\n}\nVector polar(double len, double arg) {\n  return Vector(cos(arg) * len, sin(arg) * len);\n}\nint ccw(Point a, Point b, Point c) {\n  Vector p = b - a;\n  Vector q = c - a;\n  if (p.det(q) > 0.0) return COUNTER_CLOCKWISE;  // counter clockwise\n  if (p.det(q) < 0.0) return CLOCKWISE;          // clockwise\n  if (p.dot(q) < 0.0) return ONLINE_BACK;        // c--a--b online_back\n  if (p.norm() < q.norm()) return ONLINE_FRONT;  // a--b--c online_front\n  return ON_SEGMENT;                             // a--c--b on_segment\n}\nstruct Line {\n  Point a, b;\n  Line() {}\n  Line(Point a, Point b) : a(a), b(b) {}\n  bool on(Point q) { return (a - q).det(b - q) == 0; }\n  // folloing 2 functions verified AOJ CGL_2_A\n  bool is_parallel(Line l) { return (a - b).det(l.a - l.b) == 0; }\n  bool is_orthogonal(Line l) { return (a - b).dot(l.a - l.b) == 0; }\n  Point intersection(Line l) {\n    assert(!is_parallel(l));\n    return a + (b - a) * ((l.b - l.a).det(l.a - a) / (l.b - l.a).det(b - a));\n  }\n  // projection of p to this line\n  // verified AOJ CGL_1_A\n  Point projection(Point p) {\n    return (b - a) * ((b - a).dot(p - a) / (b - a).norm2()) + a;\n  }\n  double distance(Point p) {\n    Point q = projection(p);\n    return p.dist(q);\n  }\n  // reflection point of p onto this line\n  // verified AOJ CGL_1_B\n  Point refl(Point p) {\n    Point proj = projection(p);\n    return p + ((proj - p) * 2.0);\n  }\n  bool left(Point p) {\n    if ((p - a).det(b - a) > 0.0)\n      return true;\n    else\n      return false;\n  }\n  friend istream &operator>>(istream &is, Line &l) {\n    is >> l.a >> l.b;\n    return is;\n  }\n  friend ostream &operator<<(ostream &os, const Line &l) {\n    os << l.a << \" -> \" << l.b;\n    return os;\n  }\n};\nstruct Segment {\n  Point a, b;\n  Segment() {}\n  Segment(Point a, Point b) : a(a), b(b) {}\n  Line line() { return Line(a, b); }\n  bool on(Point q) {\n    return ((a - q).det(b - q) == 0 && (a - q).dot(b - q) <= 0);\n  }\n  // verified AOJ CGL_2_B\n  bool is_intersect(Segment s) {\n    if (line().is_parallel(s.line())) {\n      if (on(s.a) || on(s.b)) return true;\n      if (s.on(a) || s.on(b)) return true;\n      return false;\n    }\n    Point p = line().intersection(s.line());\n    if (on(p) && s.on(p))\n      return true;\n    else\n      return false;\n  }\n  bool is_intersect(Line l) {\n    if (line().is_parallel(l)) {\n      if (l.on(a) || l.on(b))\n        return true;\n      else\n        return false;\n    }\n    Point p = line().intersection(l);\n    if (on(p))\n      return true;\n    else\n      return false;\n  }\n  // following 2 distance functions verified AOJ CGL_2_D\n  double distance(Point p) {\n    double res = DOUBLE_INF;\n    Point q = line().projection(p);\n    if (on(q)) res = min(res, p.dist(q));\n    res = min(res, min(p.dist(a), p.dist(b)));\n    return res;\n  }\n  double distance(Segment s) {\n    if (is_intersect(s)) return 0.0;\n    double res = DOUBLE_INF;\n    res = min(res, s.distance(a));\n    res = min(res, s.distance(b));\n    res = min(res, this->distance(s.a));\n    res = min(res, this->distance(s.b));\n    return res;\n  }\n  friend istream &operator>>(istream &is, Segment &s) {\n    is >> s.a >> s.b;\n    return is;\n  }\n  friend ostream &operator<<(ostream &os, const Segment &s) {\n    os << s.a << \" -> \" << s.b;\n    return os;\n  }\n};\n\n// Polygon\n\ntypedef vector<Point> Polygon;\n// verified AOJ CGL_3_A\n// Polygon don't need to be convex\ndouble area(Polygon &pol) {\n  Points vec;\n  double res = 0.0;\n  int M = pol.size();\n  for (int i = 0; i < M; i++) {\n    res += (pol[i] - pol[0]).area(pol[(i + 1) % M] - pol[0]);\n  }\n  return res;\n}\nbool is_convex(Polygon &pol) {\n  int n = pol.size();\n  for (int i = 0; i < n - 1; i++) {\n    if (ccw(pol[i], pol[i + 1], pol[(i + 2) % n]) == CLOCKWISE) {\n      return false;\n    }\n  }\n  return true;\n}\n// vecrified AOJ CGL_3_C\nenum { OUT, ON, IN };\nint contained(Polygon &pol, Point p) {\n  int n = pol.size();\n  Point outer(1e9, p.y);\n  Segment s = Segment(outer, p);\n  int cnt = 0;\n  for (int i = 0; i < n; i++) {\n    Segment e = Segment(pol[i], pol[(i + 1) % n]);\n    if (e.on(p)) return ON;\n    Vector a = pol[i] - p;\n    Vector b = pol[(i + 1) % n] - p;\n    if (a.y > b.y) swap(a, b);\n    if (a.y <= 0.0 && b.y > 0.0) {\n      if (a.det(b) < 0.0) cnt++;\n    }\n  }\n  if ((cnt & 1) == 1)\n    return IN;\n  else\n    return OUT;\n}\n\nbool solve() {\n  int N;\n  cin >> N;\n  if (N == 0) return false;\n  Segment s;\n  cin >> s;\n  vector<Point> ps;\n  vector<double> hs, ds;\n  bool flag = false;\n  for (int i = 0; i < N; i++) {\n    double ax, ay, bx, by, h;\n    cin >> ax >> ay >> bx >> by >> h;\n    Point a(ax, ay);\n    Point b(ax, by);\n    Point c(bx, by);\n    Point d(bx, ay);\n    Segment ab = Segment(a, b);\n    Segment bc = Segment(b, c);\n    Segment cd = Segment(c, d);\n    Segment da = Segment(d, a);\n    Polygon rect = {a, b, c, d};\n    // block on segment\n    if (s.is_intersect(ab) || s.is_intersect(bc) || s.is_intersect(cd) ||\n        s.is_intersect(da)) {\n      flag = true;\n    }\n    // block which contain segment\n    if (contained(rect, s.a) == IN && contained(rect, s.b) == IN) {\n      flag = true;\n    }\n\n    // nearest from end point\n    {\n      Point q = ab.line().projection(s.a);\n      if (ab.on(q)) {\n        ps.push_back(q);\n        hs.push_back(h);\n      }\n      Point r = ab.line().projection(s.b);\n      if (ab.on(r)) {\n        ps.push_back(r);\n        hs.push_back(h);\n      }\n    }\n    {\n      Point q = bc.line().projection(s.a);\n      if (bc.on(q)) {\n        ps.push_back(q);\n        hs.push_back(h);\n      }\n      Point r = bc.line().projection(s.b);\n      if (bc.on(r)) {\n        ps.push_back(r);\n        hs.push_back(h);\n      }\n    }\n    {\n      Point q = cd.line().projection(s.a);\n      if (cd.on(q)) {\n        ps.push_back(q);\n        hs.push_back(h);\n      }\n      Point r = cd.line().projection(s.b);\n      if (cd.on(r)) {\n        ps.push_back(r);\n        hs.push_back(h);\n      }\n    }\n    {\n      Point q = da.line().projection(s.a);\n      if (da.on(q)) {\n        ps.push_back(q);\n        hs.push_back(h);\n      }\n      Point r = da.line().projection(s.b);\n      if (da.on(r)) {\n        ps.push_back(r);\n        hs.push_back(h);\n      }\n    }\n\n    ps.push_back(a);\n    hs.push_back(h);\n    ps.push_back(b);\n    hs.push_back(h);\n    ps.push_back(c);\n    hs.push_back(h);\n    ps.push_back(d);\n    hs.push_back(h);\n  }\n  if (flag) {\n    cout << 0.0 << endl;\n    return true;\n  }\n  assert(hs.size() == ps.size());\n  // dmp(ps);\n  double l = 0.0, r = 1010.0;\n  auto check = [&](double r) {\n    for (int i = 0; i < ps.size(); i++) {\n      const auto &p = ps[i];\n      double d = s.distance(p);\n      double h = hs[i];\n      if (r > h) {\n        if (r > ((h * h + d * d) / 2.0 / h)) return false;\n      } else {\n        if (r > d) return false;\n      }\n    }\n    return true;\n  };\n  for (int i = 0; i < 50; i++) {\n    double mid = (l + r) / 2.0;\n    if (check(mid))\n      l = mid;\n    else\n      r = mid;\n  }\n  cout << l << endl;\n  return true;\n}\n\nsigned main() {\n  fastio();\n  // solve();\n  // int t; cin >> t; while(t--)solve();\n  while (solve()) {}\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n//#define double long double\nconst double EPS = 1e-8; //問題ごとに変更\nconst double PI = acos(-1);\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\nstruct Point {\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator+(const Point &p)const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point &p)const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a)const { return Point(a * x, a * y); }\n\tPoint operator/(double a)const { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const {\n\t\t//return y != p.y ? y < p.y : x < p.x; //y昇順 -> x昇順\n\t\treturn x != p.x ? x < p.x : y < p.y; //x昇順 -> y昇順\n\t}\n\tbool operator==(const Point &p)const { return equals(x, p.x) && equals(y, p.y); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n};\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << ' ' << p.y; return os; }\n\nstruct Vector :public Point {\n\tusing Point::Point;\n\tVector() {}\n\tVector(const Point &P) { x = P.x; y = P.y; }\n\tVector rotate(double rad) { return Vector(x*cos(rad) - y * sin(rad), x*sin(rad) + y * cos(rad)); }\n\tVector unit() { return *this / abs(); }\n};\n\n//内積 dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//外積 cross product の大きさ（正負あり）\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nstruct Line {\n\tPoint p1, p2;\n\tLine() {}\n\tLine(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\n\nstruct Segment :public Line {\n\tusing Line::Line;\n\tSegment() {}\n\tSegment(const Line &L) { p1 = L.p1; p2 = L.p2; }\n\tVector vec() { return p2 - p1; }\n};\n\nstruct Circle {\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//degree to radian\ndouble rad(double deg) { return PI * deg / 180; }\n//radian to degree\ndouble deg(double rad) { return rad / PI * 180; }\n//偏角 argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//極形式 polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n//2つのベクトルの角度\ndouble angle(Vector a, Vector b) {\n\tdouble lena = a.abs(), lenb = b.abs();\n\tif (lena == 0 || lenb == 0)return 0; //解なし\n\tdouble costheta = dot(a, b) / (lena*lenb);\n\tif (equals(costheta, 1))costheta = 1; //誤差対策\n\tif (equals(costheta, -1))costheta = -1;\n\n\treturn acos(costheta);\n}\n\nbool inrange(Point p, double x1, double y1, double x2, double y2) {\n\treturn x1 <= p.x&&p.x <= x2 && y1 <= p.y&&p.y <= y2;\n}\n\n//直交判定\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//平行判定\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//射影\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n//反射\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//線分(p0,p1)に対するp2の位置関係\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\nint ccw(Vector a, Vector b) {\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//直線と直線の交差判定\nbool intersect(Segment a, Segment b) {\n\tPoint p1 = a.p1, p2 = a.p2, p3 = b.p1, p4 = b.p2;\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n//(交差判定続く)\n\n//2点間の距離\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//直線と点の距離\ndouble get_distance(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//線分と点の距離\ndouble get_distance(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance(Line(s), p);\n}\n//線分と線分の距離\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance(s1, s2.p1), get_distance(s1, s2.p2)),\n\t\tmin(get_distance(s2, s1.p1), get_distance(s2, s1.p2))\n\t);\n}\n\n//円と直線の交差判定\nbool intersect(Circle c, Line l) { return get_distance(l, c.c) <= c.r + EPS; }\n//円と円の交差判定 共通接線の数\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//線分と線分の交点\nPoint get_cross_point(Segment a, Segment b) {\n\tassert(intersect(a, b));\n\tVector base = b.p2 - b.p1;\n\tdouble area1 = abs(cross(base, a.p1 - b.p1));\n\tdouble area2 = abs(cross(base, a.p2 - b.p1));\n\tdouble t = area1 / (area1 + area2);\n\treturn a.p1 + (a.p2 - a.p1)*t;\n}\n\n//円と直線の交点\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n//円と円の交点\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d * d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//点の内包\nenum { OUT = 0, ON, IN };\nint contains(const Polygon &pl, Point p) {\n\tint n = pl.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = pl[i] - p, b = pl[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\nint contains(Circle c, Point p) {\n\tdouble d = get_distance(c.c, p);\n\tif (equals(d, c.r))return ON;\n\tif (d < c.r)return IN;\n\treturn OUT;\n}\n\n//多角形の面積\ndouble area(const Polygon &p) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < p.size(); i++)\n\t\ta += cross(p[i], p[(i + 1) % p.size()]);\n\treturn fabs(a / 2.0);\n}\n\n//凸性判定（反時計回り）\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n//凸包\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//辺上の点を含めない\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) != CLOCKWISE)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) != COUNTER_CLOCKWISE)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); //反時計回りに\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//凸包\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//辺上の点を含む\nPolygon convex_hull_with_points_online(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (up.size() > 1 && (_ccw = ccw(up[up.size() - 2], up[up.size() - 1], p)) != CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tup.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (down.size() > 1 && (_ccw = ccw(down[down.size() - 2], down[down.size() - 1], p)) != COUNTER_CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tdown.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); //反時計回りに\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//凸多角形の最遠頂点対間距離\n//calipers https://en.wikipedia.org/wiki/Rotating_calipers\ndouble diameter(Polygon P) {\n\tP = convex_hull(P);\n\tauto mima = minmax_element(P.begin(), P.end());\n\tint I = mima.first - P.begin();\n\tint J = mima.second - P.begin();\n\tdouble maxd = get_distance(P[I], P[J]);\n\n\tint maxi, maxj, i, j;\n\ti = maxi = I;\n\tj = maxj = J;\n\tdo {\n\t\tif (ccw(next(P, i) - P[i], next(P, j) - P[j]) == COUNTER_CLOCKWISE)\n\t\t\tj = (j + 1) % P.size();\n\t\telse\n\t\t\ti = (i + 1) % P.size();\n\t\tif (maxd < get_distance(P[i], P[j])) {\n\t\t\tmaxd = get_distance(P[i], P[j]);\n\t\t\tmaxi = i, maxj = j;\n\t\t}\n\t} while (!(i == I && j == J));\n\treturn maxd;\n}\n\n//多角形を(0,0)を中心として回転\nPolygon rotate(const Polygon &P, double rad) {\n\tPolygon ret;\n\tfor (auto &p : P)\n\t\tret.emplace_back(p.x*cos(rad) - p.y*sin(rad), p.x*sin(rad) + p.y*cos(rad));\n\treturn ret;\n}\n\n//Heron's formula\ndouble area(double a, double b, double c) {\n\tdouble s = (a + b + c) / 2;\n\treturn sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\n//多角形の重心\nPoint center(const Polygon &P) {\n\tPoint ret(0, 0);\n\tfor (auto &p : P)ret = ret + p;\n\tret = ret / P.size();\n\treturn ret;\n}\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N;\n\twhile (cin >> N, N) {\n\t\tPoint s, e;\n\t\tcin >> s >> e;\n\t\tSegment x(s, e);\n\n\t\tdouble ans = 1e3;\n\t\tloop(N) {\n\t\t\tdouble minx, miny, maxx, maxy;\n\t\t\tcin >> minx >> miny >> maxx >> maxy;\n\t\t\tauto inrange = [&](Point p) {double x = p.x, y = p.y; return minx <= x and x <= maxx and miny <= y and y <= maxy; };\n\t\t\tif (inrange(s) and inrange(e)) {\n\t\t\t\tans = 0;\n\t\t\t}\n\t\t\tvector<Segment>seg;\n\t\t\tseg.eb(Point(minx, miny), Point(minx, maxy));\n\t\t\tseg.eb(Point(minx, miny), Point(maxx, miny));\n\t\t\tseg.eb(Point(maxx, maxy), Point(minx, maxy));\n\t\t\tseg.eb(Point(maxx, maxy), Point(maxx, miny));\n\n\t\t\tdouble h;\n\t\t\tcin >> h;\n\n\t\t\trep(i, 0, 4) {\n\t\t\t\tauto d = get_distance(x, seg[i]);\n\t\t\t\tif (d <= h) {\n\t\t\t\t\tchmin(ans, d);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchmin(ans, (d*d + h * h) / (2 * h));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdump(ans);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define PI acos(-1)\n#define INF (1e9 + 7)\n\nclass Point {\npublic:\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n    Point operator + (Point p) {\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator - (Point p) {\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator * (double c) {\n        return Point(c * x, c * y);\n    }\n    Point operator / (double c) {\n        return Point(x / c, y / c);\n    }\n    bool operator < (const Point &p) {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const Point &p) {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n    bool operator != (const Point &p) {\n        return (fabs(x - p.x) > EPS || fabs(y - p.y) > EPS);\n    }\n\n    double norm() {\n        return (x * x + y * y);\n    }\n    double abs() {\n        return sqrt(norm());\n    }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n    return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b) {\n    return (a.x * b.y - a.y * b.x);\n}\n\ndouble norm(Vector a) {\n    return (a.x * a.x + a.y * a.y);\n}\n\ndouble abs(Vector a) {\n    return sqrt(norm(a));\n}\n\nclass Segment {\npublic:\n    Point p1, p2;\n    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\ndouble distL(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble distS(Segment s, Point p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n    return distL(s, p);\n}\n\nconst int CCW = 1, CW = -1, ONBACK = 2, ONFRONT = -2, ONSEG = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n\n    if (cross(a, b) > EPS) return CCW;\n    if (cross(a, b) < -EPS) return CW;\n    if (dot(a, b) < -EPS) return ONBACK;\n    if (a.norm() < b.norm()) return ONFRONT;\n    return ONSEG;\n}\n\nbool intersect(Point a, Point b, Point c, Point d) {\n    return (ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0);\n}\n\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble distSS(Segment s1, Segment s2) {\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(distS(s1, s2.p1), distS(s1, s2.p2)), min(distS(s2, s1.p1), distS(s2, s1.p2)));\n}\n\nclass Block {\npublic:\n    double lx, ly, rx, ry, h;\n    vector<Segment> seg, diagonal;\n\n    Block(double lx = 0.0, double ly = 0.0, double rx = 0.0, double ry = 0.0, double h  = 0.0) : lx(lx), ly(ly), rx(rx), ry(ry), h(h) {}\n\n    void setSeg() {\n        seg.resize(4);\n        diagonal.resize(2);\n        seg[0] = Segment(Point(lx, ly), Point(lx, ry));\n        seg[1] = Segment(Point(lx, ry), Point(rx, ry));\n        seg[2] = Segment(Point(rx, ry), Point(rx, ly));\n        seg[3] = Segment(Point(rx, ly), Point(lx, ly));\n        diagonal[0] = Segment(Point(lx, ly), Point(rx, ry));\n        diagonal[1] = Segment(Point(lx, ry), Point(rx, ly));\n    }\n};\n\ninline double dst(double r, double h) {\n    if (h >= r) return r;\n    return sqrt(r * r - (r - h) * (r - h));\n}\n\nint N, sx, sy, ex, ey, a, b, c, d, h;\ndouble ans, min_dist, l, r, mid;\nvector<Block> bk;\nSegment road;\n\nint main() {\n\n    while (scanf(\"%d\", &N), N) {\n        bk.resize(N);\n        ans = 1001.0;\n\n        scanf(\"%d%d%d%d\", &sx, &sy, &ex, &ey);\n        road = Segment(Point(sx, sy), Point(ex, ey));\n\n        for (int i = 0; i < N; ++i) {\n            scanf(\"%d%d%d%d%d\", &a, &b, &c, &d, &h);\n            bk[i] = Block(a, b, c, d, h);\n            bk[i].setSeg();\n        }\n\n        for (int i = 0; i < N; ++i) {\n            min_dist = INF;\n            for (int j = 0; j < 4; ++j) {\n                min_dist = min(min_dist, distSS(Segment(Point(sx, sy), Point(ex, ey)), bk[i].seg[j]));\n            }\n\n            if (intersect(bk[i].diagonal[0], road) || intersect(bk[i].diagonal[1], road)) {\n                ans = 0.0;\n                break;\n            }\n\n            //cout << i << \" \" << min_dist << endl;\n            l = 0.0; r = double(ans);\n            while (r - l > EPS) {\n                mid = (l + r) / 2.0;\n                if (min_dist < dst(mid, bk[i].h)) r = mid;\n                else l = mid;\n            }\n\n            //cout << \"l = \" << l << endl;\n\n            if (ans == 1001.0) ans = l;\n            else ans = min(ans, l);\n            //cout << \"d = \" << dst(ans, bk[i].h) << endl;\n            //printf(\"%.20lf\\n\", ans);\n        }\n\n        printf(\"%lf\\n\", ans);\n\n        bk.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\n#define _(_1,_2,_3,N,...)N\n#define pr(...) _(__VA_ARGS__,pr3,pr2,pr1)(__VA_ARGS__)\ntemplate<C T>void pr1(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr2(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr3(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\ndouble dot(P a, P b){return real(conj(a)*b);}\ndouble cross(P a, P b){return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c) {\n  b-=a;c-=a;\n  if(cross(b,c)>EPS)return +1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return +2;\n  if(norm(b)<norm(c))return -2;\n  return 0;\n}\n\nP projection(const L &l, const P &p) {\n  double t=dot(p-l.F,l.F-l.S)/norm(l.F-l.S);\n  return l.F+t*(l.F-l.S);\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s.F,s.S,t.F)*ccw(s.F,s.S,t.S)<=0&&\n    ccw(t.F,t.S,s.F)*ccw(t.F,t.S,s.S)<=0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s.F-p)+abs(s.S-p)-abs(s.S-s.F)<EPS;\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if(intersectSP(s,r)) return abs(r-p);\n  return min(abs(s.F-p),abs(s.S-p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if(intersectSS(s,t))return 0;\n  return min(min(distanceSP(s,t.F),distanceSP(s,t.S)),\n             min(distanceSP(t,s.F),distanceSP(t,s.S)));\n}\n\nvoid Main() {\n  int n;\n  while(R n && n) {\n    double sx,sy,tx,ty;\n    cin >> sx >> sy >> tx >> ty;\n    L b=L(P(sx,sy),P(tx,ty));\n    vector<L> v[n];\n    int h[n];\n    bool f=1;\n    rep(i,n) {\n      double x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2 >> h[i];\n      v[i].pb(L(P(x1,y1),P(x1,y2)));\n      v[i].pb(L(P(x2,y1),P(x2,y2)));\n      v[i].pb(L(P(x1,y1),P(x2,y1)));\n      v[i].pb(L(P(x1,y2),P(x2,y2)));\n      if((x1<=sx&&sx<=x2&&y1<=sy&&sy<=y2)||(x1<=tx&&tx<=x2&&y1<=ty&&ty<=y2))f=0;\n    }\n    if(!f) {\n      pd(0);\n      continue;\n    }\n    double l=0,r=1000;\n    rep(t,100) {\n      double m=(l+r)/2;\n      f=1;\n      rep(i,n) {\n        rep(j,4) {\n          double d=distanceSS(b,v[i][j]);\n          if(m>h[i]) {\n            double c=m-h[i];\n            d=sqrt(d*d+c*c);\n          }\n          if(d<m) f=0;\n        }\n      }\n      if(f) l=m;\n      else r=m;\n    }\n    pd(l);\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) begin(V), end(V)\n#define ALLR(V) rbegin(V), rend(V)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nconst double eps = 1e-6;\nconst long double pi = 3.14159265358979323846264338327950288419716939937510L;\n\nusing Point = complex<double>;\n\nstruct DualPoints : public pair<Point, Point> {\n    using pair<Point, Point>::pair;\n\n    Point& operator [](size_t idx) { return idx == 0 ? first : second; }\n    \n    const Point& operator [](size_t idx) const { return idx == 0 ? first : second; }\n};\n\nstruct get_xy {\n    double &x, &y;\n\n    get_xy(double &x, double &y) : x(x), y(y) { }\n\n    get_xy& operator =(const Point &p) {\n        x = real(p);\n        y = imag(p);\n        return *this;\n    }\n};\n\nstruct Line : public DualPoints {\n    using DualPoints::DualPoints;\n};\n\nstruct Seg : public DualPoints {\n    using DualPoints::DualPoints;\n};\n\ndouble dot(const Point &a, const Point &b) {\n    return (conj(a) * b).real();\n}\n\ndouble cross(const Point &a, const Point &b) {\n    return (conj(a) * b).imag();\n}\n\nenum ccwd {\n    Clock = -1,\n    CoClock = 1,\n    CAB = 2,\n    ABC = -2,\n    ACB = 0,\n};\n\nccwd ccw(Point a, Point b, Point c) {\n    b -= a;\n    c -= a;\n    double p, q;\n    {\n        auto tmp = conj(b) * c;\n        p = tmp.real();\n        q = tmp.imag();\n    }\n    if (0 < q) return CoClock;\n    if (q < 0) return Clock;\n    if (p < 0) return CAB;\n    if (norm(b) < norm(c)) return ABC;\n    return ACB;\n}\n\nbool is_zero(double a) {\n    return abs(a) <= eps;\n}\n\nbool is_parallel(const Line &l1, const Line &l2) {\n    return is_zero(cross(l1[1] - l1[0], l2[1] - l2[0]));\n}\n\nbool is_same_line(Point o, Point a, Point b) {\n    return is_zero(cross(a - o, b - o));\n}\n\nbool intersect(const Line &p, const Line &q) {\n    if (!is_parallel(p, q)) return true;\n    return is_same_line(p[0], p[1], q[1]);\n}\n\nbool intersect(const Line &l, const Seg &s) {\n    double a = cross(l[1] - l[0], s[0] - l[0]);\n    double b = cross(l[1] - l[0], s[1] - l[0]);\n    return a * b < 0;\n}\n\nbool intersect(const Seg &p, const Seg &q) {\n    bool pf = (ccw(p[0], p[1], q[0]) * ccw(p[0], p[1], q[1])) <= 0;\n    bool qf = (ccw(q[0], q[1], p[0]) * ccw(q[0], q[1], p[1])) <= 0;\n    return pf && qf;\n}\n\nbool intersect(const Line &l, const Point &p) {\n    return is_same_line(p, l[0], l[1]);\n}\n\nbool intersect(const Seg &s, const Point &p) {\n    double l1 = abs(s[0] - s[1]);\n    double l2 = abs(s[0] - p);\n    double l3 = abs(s[1] - p);\n    return is_zero(l2 + l3 - l1);\n}\n\n// projection from p to l\nPoint proj(const Line &l, const Point &p) {\n    double mul = dot(p - l[0], l[1] - l[0]) / norm(l[0] - l[1]);  // cos(theta) / (p-l[0]).norm()\n    return l[0] + mul * (l[1] - l[0]);\n}\n\nPoint refl(const Line &l, const Point &p) {\n    Point pr = proj(l, p);\n    return p + (2. * (pr - p));\n}\n\ndouble distance(const Line &l, const Point &p) {\n    return abs(p - proj(l, p));\n}\n\ndouble distance(const Line &p, const Line &q) {\n    if (is_parallel(p, q)) return distance(p, q[0]);\n    return 0;\n}\n\ndouble distance(const Line &l, const Seg &s) {\n    if (intersect(l, s)) return 0;\n    return min(distance(l, s[0]), distance(l, s[1]));\n}\n\ndouble distance(const Seg &s, const Point &p) {\n    Line l(s[0], s[1]);\n    Point pr = proj(l, p);\n    if (intersect(s, pr)) return abs(pr - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distance(const Seg &p, const Seg &q) {\n    if (intersect(p, q)) return 0;\n    return var_min(distance(p, q[0]), distance(p, q[1]),\n                   distance(q, p[0]), distance(q, p[1]));\n}\n\ndouble fix_arg(double arg) {\n    arg += 2 * pi;\n    if (2 * pi <= arg) arg -= 2 * pi;\n    return arg;\n}\n\nbool comp_coclock(const Point &p1, const Point &p2) {\n    return fix_arg(arg(p1)) < fix_arg(arg(p2));\n}\n\nPoint rotate(const Point &p, double arg) {\n    complex<double> r(cos(arg), sin(arg));\n    return p * r;\n}\n\nusing Block = array<Seg, 4>;\n\nbool judge(const Seg &crs, double r, double h, const Seg &seg) {\n    double d = distance(seg, crs);\n    double dz = r - min(r, h);\n    return r * r <= d * d + dz * dz;\n}\n\nbool judge(const Seg &crs, double br, double h, const Block &b) {\n    for (auto &&s : b) if (!judge(crs, br, h, s)) return false;\n    return true;\n}\n\nbool input(V<pair<Block, double>> &blocks, const Seg &crs) {\n    bool ret = true;\n    for (auto &&e : blocks) {\n        double l, r, d, u, h;\n        cin >> l >> d >> r >> u >> h;\n        Point bl[4] = {\n            Point(l, u), Point(r, u),\n            Point(r, d), Point(l, d),\n        };\n        ll idx = 0;\n        for (ll i = 0; i < 4; i++) for (ll j = i + 1; j < 4; j++) {\n            if (j - i == 2) continue;\n            e.first[idx++] = Seg(bl[i], bl[j]);\n        }\n        if (intersect(crs, Seg(bl[0], bl[2])) ||\n            intersect(crs, Seg(bl[1], bl[3]))) ret = false;\n        e.second = h;\n    }\n    return ret;\n}\n\nbool solve() {\n    ll N;\n    cin >> N;\n    if (!N) return false;\n    double sx, sy, ex, ey;\n    cin >> sx >> sy >> ex >> ey;\n    V<pair<Block, double>> blocks(N);\n    Seg crs(Point(sx, sy), Point(ex, ey));\n    if (!input(blocks, crs)) {\n        cout << 0 << endl;\n        return true;\n    }\n    \n    double ok = 0, ng = 1000;\n    for (ll lp = 0; lp < 100; lp++) {\n        double mid = (ok + ng) / 2;\n        bool j = true;\n        for (auto &&e : blocks) j &= judge(crs, mid, e.second, e.first);\n        (j ? ok : ng) = mid;\n    }\n    cout << ok << endl;\n    return true;\n}\n\nint main() {\n    while (solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define f first\n#define s second\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;\n  if (cross(b,c) < -EPS) return -1;\n  if (dot(b,c)   < -EPS) return +2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\nmain(){\n  int n;\n  L ta;\n  while(cin>>n,n){\n    double ll[4],x1[n],x2[n],y1[n],y2[n],h[n],ans=1e9;\n    vector<double>v2;\n    vector<pair<P,P> > v1;\n    rep(i,4)cin>>ll[i];\n    ta=make_pair(P(ll[0],ll[1]),P(ll[2],ll[3]));\n    rep(i,n)cin>>x1[i]>>y1[i]>>x2[i]>>y2[i]>>h[i];\n    rep(i,n){\n      rep(j,4)v2.push_back(h[i]);\n      v1.push_back(make_pair(P(x1[i],y1[i]),P(x2[i],y1[i])));\n      v1.push_back(make_pair(P(x1[i],y1[i]),P(x1[i],y2[i])));\n      v1.push_back(make_pair(P(x2[i],y2[i]),P(x2[i],y1[i])));\n      v1.push_back(make_pair(P(x2[i],y2[i]),P(x1[i],y2[i])));\n      if(x1[i]<ll[0]&&ll[0]<x2[i]&&x1[i]<ll[2]&&ll[2]<x2[i]&&\n        y1[i]<ll[1]&&ll[1]<y2[i]&&y1[i]<ll[3]&&ll[3]<y2[i])ans=0;\n    }\n    rep(i,v1.size()){\n      double x=distSS(ta.f,ta.s,v1[i].f,v1[i].s),y=v2[i],r=1e9,l=0;\n      rep(j,100){\n        double mid=(l+r)/2;\n        if(sqrt(x*x+(mid-y)*(mid-y))<mid)r=mid;\n        else l=mid;\n      }\n      ans=min(ans,l);\n    }\n    rep(i,v1.size()){\n      if(isecSS(ta.f,ta.s,v1[i].f,v1[i].s))ans=0;\n    }\n    printf(\"%.9f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Geometry_Library\n#define ___Geometry_Library\n\n// ------ Includes ------ //\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <algorithm>\n\n// ------ Defines ------ //\ntypedef long double GType;\ntypedef std::complex<GType> Point;\ntypedef std::pair<Point, Point> Segment;\n\n// ------ Constants ------ //\nconst GType EPS = 1.0e-10L;\n\n// ------ Functions Level 1 ------ //\nGType dot(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).real();\n}\nGType cross(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).imag();\n}\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint v1 = p2 - p1, v2 = p3 - p1;\n\tif (cross(v1, v2) > EPS) return +1;\n\tif (cross(v1, v2) < -EPS) return -1;\n\tif (dot(v1, v2) < -EPS) return +2;\n\tif (std::norm(v1) < std::norm(v2)) return -2;\n\treturn 0;\n}\n\n// ------ Functions Level 2 ------ //\nbool intersect(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(cross(s1.second - p1, s1.first - p1)) < EPS;\n\treturn (std::abs(s1.first - p1) + std::abs(s1.second - p1) - std::abs(s1.second - s1.first)) < EPS;\n}\nbool intersect(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (!segflag) return cross(s1.second - s1.first, s2.first - s1.first) * cross(s1.second - s1.first, s2.second - s1.first) < EPS;\n\treturn (ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) <= 0 && ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) <= 0);\n}\nPoint projection(const Segment& s1, const Point& p1) {\n\tGType mul = dot(p1 - s1.first, s1.first - s1.second) / norm(s1.first - s1.second);\n\treturn s1.first + (s1.first - s1.second) * mul;\n}\nPoint reflection(const Segment& s1, const Point& p1) {\n\treturn p1 + (projection(s1, p1) - p1) * (GType)(2);\n}\nGType distance(const Point& p1, const Point& p2) {\n\treturn std::abs(p2 - p1);\n}\nGType distance(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(p1 - projection(s1, p1));\n\tconst Point p2 = projection(s1, p1);\n\tif (intersect(s1, p2, true)) return std::abs(p2 - p1);\n\treturn std::min(std::abs(s1.first - p1), std::abs(s1.second - p1));\n}\nGType distance(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (intersect(s1, s2, segflag)) return 0;\n\tif (!segflag) return std::min(distance(s1, s2.first, false), distance(s1, s2.second, false));\n\treturn std::min({ distance(s1, s2.first, true), distance(s1, s2.second, true), distance(s2, s1.first, true), distance(s2, s1.second, true) });\n}\n\n// ------ Functions Level 3 ------ //\nint contain(std::vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tPoint a = v[i] - p, b = v[(i + 1 != v.size() ? i + 1 : 0)] - p;\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() <= EPS && EPS < b.imag() && cross(a, b) < -EPS) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n#endif\n\n#include <vector>\n#include <iomanip>\n#include <iostream>\nusing namespace std;\nint n, sx, sy, ex, ey, xa[55], ya[55], xb[55], yb[55], h[55];\nint main() {\n\twhile (cin >> n, n) {\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tfor (int i = 0; i < n; i++) cin >> xa[i] >> ya[i] >> xb[i] >> yb[i] >> h[i];\n\t\tvector<vector<Point> > v(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tv[i] = { Point(xa[i], ya[i]), Point(xa[i], yb[i]), Point(xb[i], yb[i]), Point(xb[i], ya[i]) };\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 1; i < 20000; i++) {\n\t\t\tPoint pt(sx + (ex - sx) * i / 20000.0, sy + (ey - sy) * i / 20000.0);\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (contain(v[j], pt)) flag = false;\n\t\t\t}\n\t\t}\n\t\tif (!flag) cout << 0 << endl;\n\t\telse {\n\t\t\tdouble ret = 1.0e+9;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tdouble dist = distance(Segment(Point(sx, sy), Point(ex, ey)), Segment(v[i][j], v[i][(j + 1) & 3]), true);\n\t\t\t\t\tdouble r = 0.5 * (h[i] + dist * dist / h[i]);\n\t\t\t\t\tret = min(ret, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << fixed << setprecision(15) << ret << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<array>\n#include<cassert>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\ntypedef double Real;\n\nconst Real EPS = 1e-8;\n\nint sign(Real d){\n\treturn d > EPS ? 1 : d < -EPS ? -1 : 0;\n}\n\nstruct Point{\n\tReal x,y;\t\n\texplicit Point(Real x_ = 0,Real y_ = 0):x(x_),y(y_){}\n\tPoint operator+(const Point &p) const {return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p) const {return Point(x-p.x,y-p.y);}\n\tPoint operator*(Real s) const {return Point(x*s,y*s);}\n\tPoint operator/(Real s) const {return Point(x/s,y/s);}\n\tbool operator<(const Point &p) const{return sign(x-p.x) == -1 || (sign(x-p.x) == 0 && sign(y-p.y) == -1);}\n\tbool operator==(const Point &p) const{return sign(x-p.x) == 0 && sign(y-p.y) == 0;}\n\n};\n\nistream &operator>>(istream &is,Point &p){return is >> p.x >> p.y;}//??\\???????°???????\nostream &operator<<(ostream &os ,const Point &p){return os << '(' << p.x << \", \" << p.y << ')';}//??????????°???????\n\nstruct Segment : public array<Point,2>{\n\tSegment(const Point &a,const Point &b){\tat(0) = a; at(1) = b;}\n};\n\nstruct Line : public array<Point,2>{\n\tLine(const Point &a,const Point &b){at(0) = a; at(1) = b;}\n};\n\nstruct Circle{\n\tPoint c;\n\tReal r;\n\n\tCircle(const Point &c_, Real r_):c(c_),r(r_){}\n};\n\ntypedef vector<Point> Polygon;\n\nPoint rotate90(const Point &p){\n\treturn Point(-p.y,p.x);\n}\n\nPoint rotate(const Point &p,Real theta){\n\tconst Real s = sin(theta),c = cos(theta);\n\treturn Point(c*p.x-s*p.y,s*p.x+c*p.y);\n}\n\nReal angle(const Point &p){\n\treturn atan2(p.y,p.x);\n}\n\nReal dot(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.x+a.y*b.y;\n}\n\nReal cross(const Point &a,const Point &b){ //??????????????????\n\treturn a.x*b.y-a.y*b.x;\n}\n\n\nReal norm(const Point &p){\n\treturn p.x*p.x+p.y*p.y;\n}\n\nReal abs(const Point &p){\n\treturn sqrt(norm(p));\n}\n\nenum { CCW=1,CW=-1,BACK=2,FRONT=-2,ON=0 };\nint ccw(const Point &a,const Point &b,const Point &c){\n\tconst Point p = b-a;\n\tconst Point q = c-a;\n\tconst int sgn = sign(cross(p,q));\n\t\n\tif(sgn == 1) return CCW;\n\tif(sgn == -1) return CW;\n\tif(sign(dot(p,q)) == -1) return BACK;\n\tif(sign(norm(p) - norm(q)) == -1) return FRONT;\n\treturn ON;\n}\n\nPoint project(const Line &l,const Point &p){ //?°???±\n\tReal t = dot(p-l[0], l[1]-l[0]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\n\nPoint refrect(const Line &l,const Point &p){ //????°?\n\tconst Point c = project(l,p);\n\treturn c+(c-p);\n}\n\nbool intersect(const Segment &a,const Segment &b){\n\treturn ccw(a[0],a[1],b[0])*ccw(a[0],a[1],b[1]) <= 0\n\t\t&& ccw(b[0],b[1],a[0])*ccw(b[0],b[1],a[1]) <= 0;\n}\n\nbool intersect(const Segment &s,const Point &p){\n\treturn ccw(s[0],s[1],p) == ON;\n}\n\nbool intersect(const Line &l,const Segment &s){\n\treturn sign(cross(l[1]-l[0],s[0]-l[0])) * cross(l[1]-l[0],s[1]-l[0]) <= 0;\n}\n\nbool intersect(const Line &l,const Point &p){\n\treturn abs(ccw(l[0],l[1],p)) != 1;\n}\n\nbool intersect(const Line &a,const Line &b){ //????????????\n\treturn sign(cross(a[1]-a[0],b[1]-b[0])) != 0\n\t\t||\tsign(cross(a[1]-a[0],b[1]-a[0]) == 0);\n}\n\nReal dist(const Point &a,const Point &b){\n\treturn abs(a-b);\t\n}\n\nReal dist(const Line &l,const Point &p){\n\tconst Point a = l[1]-l[0];\n\tconst Point b = p-l[0];\n\treturn abs(cross(a,b))/abs(a);\n}\n\nReal dist(const Line &l,const Segment &s){\n\tif(intersect(l,s)) return 0;\n\treturn min(dist(l,s[0]),dist(l,s[1]));\n}\n\nReal dist(const Line &a,const Line &b){\n\tif(intersect(a,b)) return 0;\n\treturn dist(a,b[0]);\n}\n\nReal dist(const Segment &s,const Point &p){\n\tif(sign(dot(s[1]-s[0],p-s[0]))==-1) return dist(s[0],p);\n\tif(sign(dot(s[0]-s[1],p-s[1]))==-1) return dist(s[1],p);\n\treturn dist(Line(s[0],s[1]),p);\n}\n\nReal dist(const Segment &a,const Segment &b){\n\tif(intersect(a,b)) return 0;\n\treturn min({dist(a,b[0]),dist(a,b[1]),dist(b,a[0]),dist(b,a[1])});\n}\n\nbool intersect(const Circle &a,const Circle &b){\n\treturn sign(dist(a.c,b.c)-(a.r+b.r)) <=0\n\t\t\t&& sign(dist(a.c,b.c)-abs(a.r-b.r)) >= 0;\n}\n\nbool intersect(const Circle &c,const Segment &s){\n\treturn sign(dist(s,c.c)-c.r)<=0;\n}\n\nbool intersect(const Circle &c,const Line &l){\n\treturn sign(dist(l,c.c)-c.r)<=0;\n}\n\nbool contain(const Circle &c,const Point &p){\n\treturn sign(dist(c.c,p)-c.r) <=0;\n}\n\nbool contain(const Polygon &P,const Point &p){\n\tbool res = false;\n\n\tfor(int i=0;i<P.size();++i){\n\t\tPoint v1=P[i]-p;\n\t\tPoint v2=P[(i+1)%P.size()]-p;\n\t\tif(v1.y>v2.y) swap(v1,v2);\n\n\t\tif(sign(cross(v1,v2))==0&&sign(dot(v1,v2))<=0){\n\t\t\treturn true;//on edge \n\t\t}\n\t\tif(sign(v1.y)<=0&&sign(v2.y)==1&&sign(cross(v1,v2))==1){\n\t\t\tres=!res;\n\t\t}\n\t}\n\treturn res;\n}\n\nPoint crosspoint(const Line &a,const Line &b){\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1]-a[0],b[1]-b[0]);\n\tif(sign(crs) == 0) return a[0];\n\treturn b[0]+(b[1]-b[0])*(cross(a[1]-a[0],a[1]-b[0])/crs);\n}\n\n\n//??¬??¢?????????????????¨?????°?????????????????????Intersect?????????\nPoint crosspoint(const Segment &a,const Segment &b){\n\tassert(intersect(a,b));\n\tconst Real crs = cross(a[1]-a[0],b[1]-b[0]);\n\tif(sign(crs)==0){\n\t\tif(intersect(a,b[0])) return b[0];\n\t\tif(intersect(a,b[1])) return b[1];\n\t\tif(intersect(b,a[0])) return a[0];\n\t\treturn a[1];\n\t}\n\treturn b[0]+(b[1]-b[0])*(cross(a[1]-a[0],a[1]-b[0])/crs);\n}\n\nvector<Point> crosspoint(const Circle &c,const Line &l){\n\tconst Point p = project(l,c.c);\n\tconst Real h = dist(p,c.c);\n\n\tvector<Point> res;\n\tif(sign(h-c.r)==1){\n\t\t//nothing\n\t}else if(sign(h-c.r)==0){\n\t\tres.emplace_back(p);\t\n\t}else{\n\t\tconst Real b = sqrt(c.r*c.r-h*h);\n\t\tconst Point e = (l[1]-l[0])/abs(l[1]-l[0]);\n\t\tres.emplace_back(p+e*b);\n\t\tres.emplace_back(p-e*b);\n\t}\n\treturn res;\n}\n\nvector<Point> crosspoint(const Circle &a,const Circle &b){\n\tif(!intersect(a,b)) return vector<Point>();\n\n\tvector<Point> res;\n\tconst Real d = dist(a.c,b.c);\n\n\tif(sign(d-(a.r+b.r))==0){\n\t\tconst Point v = b.c - a.c;\n\t\tres.emplace_back(a.c + (v * (a.r /abs(v))));\n\t}else{\n\t\tconst Real theta = acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\t\tconst Real phi = angle(b.c-a.c);\n\t\tres.emplace_back(a.c+rotate(Point(a.r,0),phi+theta));\n\t\tres.emplace_back(a.c+rotate(Point(a.r,0),phi-theta));\n\t}\n\treturn res;\n}\n\nReal area(const Polygon &P){\n\tReal res = 0.0;\n\tfor(int i=0;i<P.size();++i){\n\t\tres+=cross(P[i],P[(i+1)%P.size()]);\n\t}\n\treturn abs(res) * 0.5;\n}\n\nReal height[51];\nReal mindist[51];\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\twhile(1){\n\t\tint N;\n\t\tPoint sp,ep;\n\t\tcin >> N;\n\t\tif(N==0) break;\t\n\t\tcin >> sp >> ep;\n\n\t\tvector<Polygon> lects(N);\n\t\tfill_n((Real *)mindist,sizeof(mindist)/sizeof(Real),1e9);\n\t\trep(i,N){\t\n\t\t\tPoint minP,maxP;\n\t\t\tcin >> minP >> maxP >> height[i];\n\t\t\tlects[i].push_back(minP);\t\n\t\t\tlects[i].push_back(Point(maxP.x,minP.y));\n\t\t\tlects[i].push_back(maxP);\n\t\t\tlects[i].push_back(Point(minP.x,maxP.y));\t\n\t\t}\t\n\n\t\trep(i,N){\n\t\t\trep(j,4){\n\t\t\t\tmindist[i]=min(mindist[i],dist(Segment(sp,ep),Segment(lects[i][j],lects[i][(j+1)%4])));\t\n\t\t\t}\n\t\t}\n\n\t\tReal ans=1e9;\n\t\t\n\t\trep(i,N){\n\t\t\tif(mindist[i]>height[i]) ans=min(ans,((height[i]*height[i])+(mindist[i]*mindist[i]))/(2*height[i]));\n\t\t\telse ans=min(ans,mindist[i]);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\n\t}\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\nconst double EPS = 1e-10;\n\n// 2点間の距離\ndouble dis(Point a, Point b){\n\treturn abs(a - b);\n}\n// 内積 |a||b|cosθ\ndouble dot(Point a, Point b){\n\t// return a.real() * b.real() + a.imag() * b.imag();\n\treturn (conj(a) * b).real();\n}\n// 外積、符号付面積の２倍　|a||b|sinθ\ndouble cross(Point a, Point b){\n\t// return a.real() * b.imag() - a.imag() * b.real();\n\treturn (conj(a) * b).imag();\n}\n// 点の位置関係　2点a,bから見た点cの位置関係\nint ccw(Point a, Point b, Point c){\n    // COUNTER_CLOCKWISE\n    if(cross(b - a, c - a) > EPS) return 1;\n    // CLOCKWISE\n    if(cross(b - a, c - a) < -EPS) return -1;\n    // ONLINE_BACK\n    if(dot(b - a, c - a) < -EPS) return 2;\n    // ONLINE_FRONT\n    if(abs(b - a) + EPS < abs(c - a)) return -2;\n    // ON_SEGMENT\n    return 0;\n}\n// 点と直線の距離\ndouble line_to_point_dis(Line l, Point p){\n    Point a = l.first, b = l.second, c = p;\n    return fabs(cross(c - a, b - a)) / fabs(abs(b - a));\n}\n// 点と線分の距離\ndouble seg_to_point_dis(Line l, Point p){\n    Point a = l.first, b = l.second, c = p;\n    if(dot(b - a, c - a) < EPS) return abs(c - a);\n    if(dot(a - b, c - b) < EPS) return abs(c - b);\n    return line_to_point_dis(l, p);\n}\n// 線分の交差判定\nbool is_cross(Line a, Line b){\n    if(ccw(a.first, a.second, b.first) * ccw(a.first, a.second, b.second) <= 0 && ccw(b.first, b.second, a.first) * ccw(b.first, b.second, a.second) <= 0){\n        return true;\n    }\n    return false;\n}\n\nint n;\ndouble h[51];\nPoint p[51][4];\nLine se;\n\nbool calc(double r){\n    rep(i, 0, n){\n        rep(j, 0, 4){\n            double dist = seg_to_point_dis(se, p[i][j]);\n            if(h[i] >= r){\n                if(dist < r) return false;\n            }else{\n                double x = sqrt(pow(dist, 2) + pow(r - h[i], 2));\n                if(x < r) return false;\n            }\n            Line tmp = {p[i][j], p[i][(j + 1) % 4]};\n            double dist2 = seg_to_point_dis(tmp, se.first);\n            if(h[i] >= r){\n                if(dist2 < r) return false;\n            }else{\n                double x = sqrt(pow(dist2, 2) + pow(r - h[i], 2));\n                if(x < r) return false;\n            }\n            double dist3 = seg_to_point_dis(tmp, se.second);\n            if(h[i] >= r){\n                if(dist3 < r) return false;\n            }else{\n                double x = sqrt(pow(dist3, 2) + pow(r - h[i], 2));\n                if(x < r) return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool isInside(Point p1, Point p2, Point x){\n    if(p1.real() <= x.real() && x.real() <= p2.real() && p1.imag() <= x.imag() && x.imag() <= p2.imag()) return true;\n    return false;\n}\n\nint main(){\n    while(cin >> n, n){\n        double sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        se = {{sx, sy}, {ex, ey}};\n        bool f = true;        \n        rep(i, 0, n){\n            double x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2 >> h[i];\n            p[i][0] = {x1, y1};\n            p[i][1] = {x1, y2};\n            p[i][2] = {x2, y2};\n            p[i][3] = {x2, y1};\n            if(isInside({x1, y1}, {x2, y2}, se.first)) f = false;\n            if(isInside({x1, y1}, {x2, y2}, se.second)) f = false;\n        }\n        rep(i, 0, n){\n            rep(j, 0, 4){\n                Line tmp = {p[i][j], p[i][(j + 1) % 4]};\n                if(is_cross(se, tmp)) f = false;\n            }\n        }\n        if(f == false){\n            cout << 0.0000 << endl;\n            continue;\n        }\n        double r = 1000.0, l = 0.0;\n        while(r - l > 0.00001){\n            double mid = (l + r) / 2.0;\n            if(calc(mid)) l = mid;\n            else r = mid;\n        }\n        printf(\"%.10f\\n\", l);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <complex>\nusing namespace std;\n#ifdef DEBUGRUN\n#define log(a) (cerr<<#a\"=\"<<a<<endl)\n#else\n#define log(a) ((void)0)\n#endif\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\ntypedef long long Int;\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\ndouble sq(double a) { return a*a; }\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\nint ccw(const P& a, P b, P c) {\n    b -= a, c -= a;\n    if(cross(b, c)>0) return 1;\n    if(cross(b, c)<0) return -1;\n    if(dot(b, c)<0) return 2;\n    if(norm(b)<norm(c)) return -2;\n    return 0;\n}\nbool crossing(const P& l0, const P& l1, const P& m0, const P& m1) {\n    return ccw(m0, m1, l0)*ccw(m0, m1, l1)<=0\n        && ccw(l0, l1, m0)*ccw(l0, l1, m1)<=0;\n}\nP projection(const P& l0, const P& l1, const P& p) {\n    double t = dot(p-l0, l0-l1) / norm(l0-l1);\n    return l0 + t*(l0-l1);\n}\ndouble distanceSP(const P& s0, const P& s1, const P& p) {\n    const P r(projection(s0, s1, p));\n    if(ccw(s0, s1, r)==0) return abs(r-p);\n    return min(abs(s0-p), abs(s1-p));\n}\ndouble distanceSS(const P& s0, const P& s1, const P& t0, const P& t1) {\n    if(crossing(s0, s1, t0, t1)) return 0;\n    return min(min(distanceSP(s0, s1, t0), distanceSP(s0, s1, t1)),\n               min(distanceSP(t0, t1, s0), distanceSP(t0, t1, s1)));\n}\n\nint n;\ndouble sx, sy, ex, ey;\ndouble xa[100], ya[100], xb[100], yb[100], h[100];\nP sp, ep, ps[100][4];\n\nbool check() {\n    rep(i, n) {\n        rep(j, 4) {\n            if(crossing(sp, ep, ps[i][j], ps[i][(j+1)%4])) return false;\n        }\n        if(crossing(sp, ep, ps[i][0], ps[i][2])) return false;\n        if(crossing(sp, ep, ps[i][1], ps[i][3])) return false;\n        if(xa[i]<=sx && sx<=xb[i] && ya[i]<=sy && sy<=yb[i]) return false;\n        if(xa[i]<=ex && ex<=xb[i] && ya[i]<=ey && ey<=yb[i]) return false;\n    }\n    return true;\n}\n\nbool can(double r) {\n    rep(i, n) {\n        const double lim = h[i]>=r ? r : sqrt(sq(r)-sq(r-h[i]));\n        rep(j, 4) {\n            if(distanceSS(sp, ep, ps[i][j], ps[i][(j+1)%4])<lim) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d\", &n);\n        if(n==0) return 0;\n        scanf(\"%lf%lf%lf%lf\", &sx, &sy, &ex, &ey);\n        rep(i, n) scanf(\"%lf%lf%lf%lf%lf\", xa+i, ya+i, xb+i, yb+i, h+i);\n        sp = P(sx, sy);\n        ep = P(ex, ey);\n        rep(i, n) {\n            ps[i][0] = P(xa[i], ya[i]);\n            ps[i][1] = P(xa[i], yb[i]);\n            ps[i][2] = P(xb[i], yb[i]);\n            ps[i][3] = P(xb[i], ya[i]);\n        }\n        double ans = 0;\n        if(check()) {\n            log(true);\n            double l=0, r=1000;\n            rep(_, 200) {\n                const double mid=(l+r)/2;\n                if(can(mid)) l=mid;\n                else r=mid;\n            }\n            ans = l;\n        }\n        printf(\"%.9f\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef complex<double> P;\n\nint N;\ndouble sx,sy,ex,ey,mx,my,Mx,My,h;\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint insected(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\ndouble dist(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\nint main(){\n\twhile(cin>>N&&N){\n\t\tcin>>sx>>sy>>ex>>ey;\n\t\tP s(sx,sy),e(ex,ey);\n\t\tdouble ans=1e9;\n\t\trep(i,N){\n\t\t\tcin>>mx>>my>>Mx>>My>>h;\n\t\t\tP a(mx,my),b(Mx,my),c(Mx,My),d(mx,My);\n\t\t\tif(mx<=min(sx,ex)&&Mx>=max(sx,ex)&&my<=min(sy,ey)&&My>=max(sy,ey))ans=0;\n\t\t\tif(insected(s,e,a,b)||insected(s,e,b,c)||insected(s,e,c,d)||insected(s,e,d,a))ans=0;\n\t\t\telse{\n\t\t\t\tdouble D=1e9;\n\t\t\t\tif(Mx<=min(sx,ex)){\n\t\t\t\t\tif(my<=sy&&sy<=My)D=min(D,sx-Mx);\n\t\t\t\t\tif(my<=ey&&ey<=My)D=min(D,ex-Mx);\n\t\t\t\t}\n\t\t\t\tif(mx>=max(sx,ex)){\n\t\t\t\t\tif(my<=sy&&sy<=My)D=min(D,mx-sx);\n\t\t\t\t\tif(my<=ey&&ey<=My)D=min(D,mx-ex);\n\t\t\t\t}\n\t\t\t\tif(My<=min(sy,ey)){\n\t\t\t\t\tif(mx<=sx&&sx<=Mx)D=min(D,sy-My);\n\t\t\t\t\tif(mx<=ex&&ex<=Mx)D=min(D,ey-My);\n\t\t\t\t}\n\t\t\t\tif(my>=max(sy,ey)){\n\t\t\t\t\tif(mx<=sx&&sx<=Mx)D=min(D,my-sy);\n\t\t\t\t\tif(mx<=ex&&ex<=Mx)D=min(D,my-ey);\n\t\t\t\t}\n\t\t\t\tD=min(D,min(dist(s,e,a),min(dist(s,e,b),min(dist(s,e,c),dist(s,e,d)))));\n\t\t\t\tif(h>D)ans=min(ans,D);\n\t\t\t\telse ans=min(ans,(D*D+h*h)/2/h);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4f\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cos慮\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sin慮\n    }\n};\n\ndouble segmentPointDist(const Point& a1, const Point& a2, const Point& p)\n{\n    if((a2-a1).dot(p-a1) < 0)\n        return a1.dist(p);\n    else if((a1-a2).dot(p-a2) < 0)\n        return a2.dist(p);\n    else\n        return abs((a2-a1).cross(p-a1)) / a1.dist(a2);\n}\n\ndouble segmentsDist(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) < -EPS) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) < -EPS))\n        return 0.0;\n\n    double ret = segmentPointDist(a1, a2, b1);\n    ret = min(ret, segmentPointDist(a1, a2, b2));\n    ret = min(ret, segmentPointDist(b1, b2, a1));\n    ret = min(ret, segmentPointDist(b1, b2, a2));\n    return ret;\n}\n\nbool convexContain(const vector<Point>& cp, const Point& p)\n{\n    int n = cp.size();\n    bool ret1 = true;\n    bool ret2 = true;\n    for(int i=0; i<n; ++i){\n        double a = (cp[(i+1)%n] - cp[i]).cross(p - cp[i]);\n        if(a < -EPS)\n            ret1 = false;\n        if(a > EPS)\n            ret2 = false;\n    }\n    return ret1 || ret2;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        Point s, e;\n        cin >> s.x >> s.y >> e.x >> e.y;\n\n        vector<vector<Point> > p(n, vector<Point>(4));\n        vector<double> h(n);\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<2; ++j)\n                cin >> p[i][j*2].x >> p[i][j*2].y;\n            p[i][1] = Point(p[i][0].y, p[i][2].x);\n            p[i][3] = Point(p[i][2].y, p[i][0].x);\n            cin >> h[i];\n        }\n\n        double ret = DBL_MAX;\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<4; ++j){\n                double d = segmentsDist(s, e, p[i][j], p[i][(j+1)%4]);\n                if(d < EPS){\n                    ret = 0.0;\n                }else{\n                    double r = (pow(h[i], 2) + pow(d, 2)) / (2 * h[i]);\n                    ret = min(ret, r);\n                }\n            }\n            if(convexContain(p[i], s))\n                ret = 0.0;\n        }\n\n        printf(\"%.10f\\n\", ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst double EPS = 1e-8;\n\nusing R = long double;\nusing P = complex<R>;\nusing L = pair<P,P>;\nusing G = vector<P>;\nstruct C {\n  P c; R r;\n  C() {}\n  C(const P &a, const R &b) : c(a), r(b) {}\n};\nstruct S : public L {\n  S() {}\n  S(const P &a, const P &b) : L(a,b) {}\n};\n\ninline int sgn(const R& r) { return (r>EPS) - (r<-EPS); }\ninline R dot(const P& a, const P& b) {\n  return real(a)*real(b) + imag(a)*imag(b);\n}\ninline R det(const P& a, const P& b) {\n  return real(a)*imag(b) - imag(a)*real(b);\n}\ninline P vec(const L& l) {return l.second - l.first;}\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn sgn(real(a-b)) ? real(a-b) < 0 : sgn(imag(a-b)) < 0;\n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn sgn(real(a-b)) == 0 && sgn(imag(a-b)) == 0;\n\t}\n  bool cmp_y (const P& a, const P& b) {\n    return sgn(imag(a-b)) ? imag(a-b) < 0 : sgn(real(a-b)) < 0;\n  }\n}\n\n// P,L,Sについて入力\ninline istream& operator>>(istream& is, P& p) {\n  R x, y;\n  is >> x >> y;\n  p = P(x, y);\n  return is;\n}\ninline istream& operator>>(istream& is, L& l) {\n  P a, b;\n  is >> a >> b;\n  l = L(a, b);\n  return is;\n}\ninline istream& operator>>(istream& is, S& s) {\n  P a, b;\n  is >> a >> b;\n  s = S(a, b);\n  return is;\n}\n\n// 射影\nP inline projection(const L &l, const P &p) {\n  R t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\n// 反射\nP inline reflection(const L &l, const P &p) {\n  return p + (R)2 * (projection(l, p) - p);\n}\n\n// 線分abから見たcの位置\nenum CCW{LEFT=1, RIGHT=2, BACK=4, FRONT=8, ON_SEG=16};\nint ccw(P a, P b, P c) {\n\tP p = (c-a)/(b-a);\n\tif(sgn(imag(p)) > 0) return LEFT;\n\tif(sgn(imag(p)) < 0) return RIGHT;\n\tif(sgn(real(p)) < 0) return BACK;\n\tif(sgn(real(p)-1) > 0) return FRONT;\n\treturn ON_SEG;\n}\n\n// 垂直,平行\ninline bool vertical(L a, L b) {return sgn(dot(vec(a), vec(b))) == 0;}\ninline bool parallel(L a, L b) {return sgn(det(vec(a), vec(b))) == 0;}\ninline bool eal(L a, L b) {return vertical(a,b) && parallel(a,b);}\n\n// 交差判定\ntemplate<bool strict=false> inline bool intersect(const L&l1, const L&l2) {\n  if(strict) return sgn(det(vec(l1),vec(l2))) != 0;\n  return sgn(det(vec(l1),vec(l2))) != 0 || l1 == l2;\n}\ntemplate<bool strict=false> inline bool intersect(const L&l, const S&s) {\n  if(strict) det(s.first, vec(l)) * det(s.second, vec(l)) < 0;\n  return det(s.first, vec(l)) * det(s.second, vec(l)) <= 0;\n}\ntemplate<bool strict=false> inline bool intersect(const S&s1, const S&s2) {\n  int ccw1 = ccw(s1.first, s1.second, s2.first) | ccw(s1.first, s1.second, s2.second);\n  int ccw2 = ccw(s2.first, s2.second, s1.first) | ccw(s2.first, s2.second, s1.second);\n  if(strict) return (ccw1 & ccw2) == (LEFT | RIGHT);\n  return (ccw1 & ccw2) == (LEFT | RIGHT) || ((ccw1 | ccw2) & ON_SEG);\n}\ntemplate<bool strict=false> inline bool intersect(const S&s, const P&p) {\n  return ccw(s.first, s.second, p) == ON_SEG;\n}\ntemplate<bool strict=false> inline bool intersect(const L&l, const P&p) {\n  return ccw(l.first, l.second, p) == ON_SEG ||\n          ccw(l.first, l.second, p) == FRONT ||\n          ccw(l.first, l.second, p) == BACK;\n}\nint intersect(const C& a, const C& b) {\n\tR dist = sqrt(norm(a.c-b.c)), r1 = a.r + b.r, r2 = abs(a.r - b.r);\n\tif(sgn(r1-dist) < 0)  return 4;\t// 円が離れている\n\tif(sgn(r1-dist) == 0) return 3;\t// 外接\n\tif(sgn(r2-dist) < 0 && sgn(dist-r1) < 0) return 2; // 交差\n\tif(sgn(dist-r2) == 0) return 1; // 内接\n\treturn 0;\t// 内部に含む\n}\n\n// 距離\nR dist(const S& s, const P& p) {\n  P q = projection(s, p);\n  if(sgn(dot(s.second-s.first, p-s.first)) <= 0) q = s.first;\n  if(sgn(dot(s.first-s.second, p-s.second)) <= 0) q = s.second;\n  return abs(p-q);\n}\nR dist(const S& a, const S& b) {\n  if(intersect(a, b)) return 0;\n  return min({dist(a, b.first), dist(a, b.second), dist(b, a.first), dist(b, a.second)});\n}\nR dist(const L& l, const P& p) {\n  P q = projection(l, p);\n  return abs(p-q);\n}\n\n// 交点 交差判定を先にすること!!!\ninline P crosspoint(const L& l1, const L& l2) {\n  R ratio = det(vec(l2), l2.first-l1.first)/det(vec(l2),vec(l1));\n  return l1.first + vec(l1)*ratio;\n}\n// ToDo:そもそも交差しないとき\nvector<P> crosspoint(C c, L l) {\n\tR d = dist(l, c.c), r = c.r;\n\tP m = projection(l, c.c);\n\tP x = sqrt(r*r-d*d)*vec(l)/abs(vec(l));\n\tvector<P> ret(2,m);\n\tret[0] -= x; ret[1] += x;\n\tif(ret[1] < ret[0]) swap(ret[0], ret[1]);\n\treturn ret;\n}\nvector<P> crosspoint(C a, C b) {\n\tR d = abs(a.c-b.c);\n\tR t = (a.r*a.r-b.r*b.r+d*d)/2/d, h = sqrt(a.r*a.r-t*t);\n\tP m = t/abs(b.c-a.c)*(b.c-a.c)+a.c;\n  auto n_vector = [&](P p) -> P { return P(-p.imag(), p.real())/abs(p); };\n\tP n = n_vector(a.c-b.c);\n\tvector<P> ret(2, m);\n\tret[0] -= h*n; ret[1] += h*n;\n\tif(ret[1] < ret[0]) swap(ret[0], ret[1]);\n\treturn ret;\n}\n\n// 面積 頂点が反時計回りに並んでいること\nR area(const G& pol) {\n  R ret = 0.0;\n  REP(i, pol.size()) ret += det(pol[i], pol[(i+1)%pol.size()]);\n  return (ret/2.0);\n}\n\n// 凸性の判定\nbool isConvex(const G& pol) {\n  REP(i, pol.size()) {\n    if(sgn(det(pol[(i+1)%pol.size()]-pol[i], pol[(i+2)%pol.size()]-pol[i])) < 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// 多角形と点の内包\n// 2→in 1→on 0→out\nint inPolygon(const G& pol, const P& p) {\n  bool in = false;\n  for (int i = 0; i < pol.size(); ++i) {\n  \tP a = pol[i] - p, b = pol[(i+1)%pol.size()] - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b) && sgn(det(a, b)) < 0) {\n      in = !in;\n    }\n    if (sgn(det(a, b)) == 0 && sgn(dot(a, b)) <= 0) return 1;\n  }\n  return in ? 2 : 0;\n}\n\n// 凸包 3点が一直線上に並ぶときに注意\n// 凸包のうち一番左にある頂点の中で一番下の頂点から時計回り\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  G r(2*n);\n  for(int i=0; i<n; i++){\n    while(k>1 && sgn(det(r[k-1]-r[k-2], ps[i]-r[k-2])) < 0) k--;\n    r[k++] = ps[i];\n  }\n  for(int i=n-2,t=k; i>=0; i--){\n    while(k>t && sgn(det(r[k-1]-r[k-2], ps[i]-r[k-2])) < 0) k--;\n    r[k++] = ps[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\n/*\n3点が与えられたときに円を求める\n返り値は{中心のx座標、y座標、半径}\n3点が直線上に並んでいるときは{0, 0, -1}を返す\nToDo:見直す\n*/\nC calcCircle(R x1, R y1, R x2, R y2, R x3, R y3) {\n  R ox, oy, a, b, c, d;\n  R r1, r2, r3;\n\n  a = x2 - x1; b = y2 - y1; c = x3 - x1; d = y3 - y1;\n  R cx, cy, r;\n  if ((a && d) || (b && c)) {\n    ox = x1 + (d*(a*a + b*b) - b*(c*c + d*d)) / (a*d - b*c) / 2;\n    if (b) oy = (a*(x1+x2-ox-ox) + b*(y1+y2)) / b/2;\n    else oy = (c*(x1+x3-ox-ox) + d*(y1+y3)) / d/2;\n    r1 = sqrt((ox-x1) * (ox-x1) + (oy-y1) * (oy-y1));\n    r2 = sqrt((ox-x2) * (ox-x2) + (oy-y2) * (oy-y2));\n    r3 = sqrt((ox-x3) * (ox-x3) + (oy-y3) * (oy-y3));\n    cx = ox;\n    cy = oy;\n    r = (r1+r2+r3) / 3;\n    return {P{cx, cy}, r};\n  }\n\n  return {P{0, 0}, -1};\n}\n\n// 2点p1, p2を通り、半径がrの円を2つ返す\nvector<C> calcCircle(P p1, P p2, R r) {\n\t// 存在しない\n\tif(abs(p1-p2) > 2*r) return {};\n\tP p3 = {(p1.real()+p2.real())/2, (p1.imag()+p2.imag())/2};\n\tR l = abs(p1-p3);\n\tP p1p2 = p2-p1;\n\tR a = p1p2.real(), b = p1p2.imag();\n\tR dx1 = b*sqrt((r*r-l*l)/(a*a+b*b)), dy1 = a*sqrt((r*r-l*l)/(a*a+b*b));\n\treturn {{{p3.real()+dx1, p3.imag()-dy1}, r}, {{p3.real()-dx1, p3.imag()+dy1}, r}};\n}\n\nP p1[55], p2[55];\nR d[55], h[55];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    S s;\n    cin >> s;\n    REP(i, n) cin >> p1[i] >> p2[i] >> h[i];\n\n    REP(i, n) {\n      d[i] = INF;\n      S tmp = S(p1[i], P{p1[i].real(), p2[i].imag()});\n      chmin(d[i], dist(s, tmp));\n      tmp = S(P{p1[i].real(), p2[i].imag()}, p2[i]);\n      chmin(d[i], dist(s, tmp));\n      tmp = S(p2[i], P{p2[i].real(), p1[i].imag()});\n      chmin(d[i], dist(s, tmp));\n      tmp = S(P{p2[i].real(), p1[i].imag()}, p1[i]);\n      chmin(d[i], dist(s, tmp));\n      if(p1[i].real() <= s.first.real() && s.first.real() <= p2[i].real()\n        && p1[i].imag() <= s.first.imag() && s.first.imag() <= p2[i].imag()) {\n        d[i] = 0;\n      }\n      if(p1[i].real() <= s.second.real() && s.second.real() <= p2[i].real()\n        && p1[i].imag() <= s.second.imag() && s.second.imag() <= p2[i].imag()) {\n        d[i] = 0;\n      }\n    }\n\n    auto check = [&](R r) -> bool {\n      REP(i, n) {\n        if(r < h[i]) {\n          if(r > d[i]) return false;\n        } else {\n          R tmp = r*r - (r-h[i])*(r-h[i]);\n          if(tmp > d[i]*d[i]) return false;\n        }\n      }\n      return true;\n    };\n\n    bool flag = false;\n    const R dr = 0.001/2;\n    for(R r = 1000; r >= 0; r -= dr) {\n      if(check(r)) {\n        cout << fixed << setprecision(9) << r << endl;\n        flag = true;\n        break;\n      }\n    }\n\n    if(!flag) cout << 0 << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//二次元幾何ライブラリ\n#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define ML make_pair \ntypedef long double D;\ntypedef bool B;\ntypedef complex<D> P;   //点\ntypedef complex<D> V;   //ベクトル\ntypedef pair<P,P>  L;   //直線\ntypedef pair<P,D>  C;   //円\ntypedef vector<P>  Pol; //多角形\n\n//変数名定義\nconst D INF = 1e100;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ntemplate<class T> bool operator==(T a, T b){return abs(a - b )< EPS;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n\n\n\n// ベクトルaの絶対値を求める\n// D Length = abs(a);\n\n// 2点a,b間の距離を求める\n// D Distance = abs(a-b); \n\n// 内積 (Inner Product) : a・b = |a||b|cosθ\nD IP(V a, V b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (Exterior Product) : |a×b| = |a||b|sinθ \nD EP(V a, V b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n// 点の進行方向について\nint ccw(P a, P b, P c) {              //点aと点bが与えられた問いに\n  b -= a; c -= a;\n  if (EP(b, c) > 0)   return +1;      // counter clockwise\n  if (EP(b, c) < 0)   return -1;      // clockwise\n  if (IP(b, c) < 0)     return +2;    // c--a--b on line\n  if (norm(b) < norm(c)) return -2;   // a--b--c on line\n  return 0;                           // a--c--b on line  aとbの線分判定はこれ\n}\n\n\n// 2直線の垂直判定 : a⊥b <=> IP(a, b) = 0\nB IsVecular(L l1, L l2) {\n\treturn IP(l1.first-l1.second, l2.first-l2.second)==0.0;\n}\n\n// 2直線の平行判定 : a//b <=> EP(a, b) = 0\nB IsParallel(L l1, L l2) {\n\treturn EP(l1.first-l1.second, l2.first-l2.second)== 0.0;\n}\n\n// 2線分の交差判定 \nB IIS(L l1, L l2) {\n  return ( EP(l1.second-l1.first, l2.first-l1.first) * EP(l1.second-l1.first, l2.second-l1.first) < EPS ) &&\n         ( EP(l2.second-l2.first, l1.first-l2.first) * EP(l2.second-l2.first, l1.second-l2.first) < EPS );\n}\n\n// 符号付き点と直線の距離 (Distance of Point and Line)  //lの構造 x座標 first<second y座標 first<second 左上 正 右下 負 一致 0\nD  DPL(P p,L l){\n\tV v1=(l.second-l.first);\n\tV v2=(p-l.first);\n\treturn EP(v1,v2)/abs(v1);\n}\n\n// 点と線分の距離 (Distance of Point and Segment)  //lの構造 x座標 first<second y座標 first < second \nD  DPS(P p,L l){\n\tV v1,v2,v3;\n\tv1=l.second-l.first;\n\tv2=p-l.first;\n\tv3=p-l.second;\n\tif(IP (v1,v2) <0)\n\t\treturn abs(p-l.first);\n\telse if(IP(-v1,v3)<0)\n\t\treturn abs(p-l.second);\n\telse\n\t\treturn abs(DPL(p,l));\n}\n\n// 線分と線分の距離 (Distance of Segment and Segment)  //lの構造 x座標 first<second y座標 first < second \nD DSS(L l1,L l2){\n\tif(IIS(l1,l2))\n\t\treturn 0;\n\telse{\n\t\tD tem,tem1,tem2;\n\t\ttem1=min(DPS(l1.first,l2),DPS(l1.second,l2));\n\t\ttem2=min(DPS(l2.first,l1),DPS(l2.second,l1));\n\t\treturn\tmin(tem1,tem2);\n\t}\n}\n\n// 三角形の領域判定 Teritory of Triangle 1が内部 0が境界と外部\nB TT(P p1,P p2,P p3,P p){\n\tL l1,l2,l3;\n\tl1=make_pair(p2,p3);\n\tl2=make_pair(p3,p1);\n\tl3=make_pair(p1,p2);\n\n\tif(sig(DPL(p1,l1))!=sig(DPL(p,l1)))\n\t\treturn false;\n\telse if(sig(DPL(p2,l2))!=sig(DPL(p,l2)))\n\t\treturn false;\n\telse if(sig(DPL(p3,l3))!=sig(DPL(p,l3)))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n//変数名 = 型 代入したいもの\n//example : v1 = V(5.0,-3.0) p1=P(0.0,4.0)\nint main(void){\n\twhile(true){\n\tint N;\n\t\tcin >>N; \n\tif(!N)\n\t\tbreak;\n\tD Block[50][2][2];\n\tD h[50];\n\tP root1,root2;\n\tL root;\n\tD r;\n\tD rmin=INF;\n\t\tcin >> root1.real() >> root1.imag() >> root2.real() >> root2.imag();\n\trep(i,N)\n\t\tcin >>Block[i][0][0] >>Block[i][0][1] >> Block[i][1][0] >> Block[i][1][1] >>h[i] ;\n\troot=ML(root1,root2);\n\trep(i,N){\n\t\t\tD tem,tem1,tem2;\n\t\t\tP p1,p2,p3,p4;\n\t\t\tp1=P(Block[i][0][0],Block[i][0][1]);\n\t\t\tp2=P(Block[i][1][0],Block[i][0][1]);\n\t\t\tp3=P(Block[i][1][0],Block[i][1][1]);\n\t\t\tp4=P(Block[i][0][0],Block[i][1][1]);\n\t\t\tL la,lb,lc,ld;\n\t\t\tla=ML(p1,p2);\n\t\t\tlb=ML(p2,p3);\n\t\t\tlc=ML(p3,p4);\n\t\t\tld=ML(p4,p1);\n\t\t\tif(p1.real()<root1.real()&&root1.real()<p3.real()&&p1.imag()<root1.imag()&&root1.imag()<p3.imag())\n\t\t\t\ttem=0;\n\t\t\telse {\n\t\t\t\ttem1=min(DSS(root,la),DSS(root,lb));\n\t\t\t\ttem2=min(DSS(root,lc),DSS(root,ld));\n\t\t\t\ttem=min(tem1,tem2);\n\t\t\t}\n\t\t\tif(tem<=h[i])\n\t\t\t\tr=tem;\n\t\t\telse\n\t\t\t\tr=(h[i]+tem*tem/h[i])/2.0;\n\t\t\tif(rmin > r)\n\t\t\t\trmin=r;\n\t}\n    cout << fixed << rmin << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Geometry_Library\n#define ___Geometry_Library\n\n// ------ Includes ------ //\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <algorithm>\n\n// ------ Defines ------ //\ntypedef long double GType;\ntypedef std::complex<GType> Point;\ntypedef std::pair<Point, Point> Segment;\n\n// ------ Constants ------ //\nconst GType EPS = 1.0e-10L;\n\n// ------ Functions Level 1 ------ //\nGType dot(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).real();\n}\nGType cross(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).imag();\n}\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint v1 = p2 - p1, v2 = p3 - p1;\n\tif (cross(v1, v2) > EPS) return +1;\n\tif (cross(v1, v2) < -EPS) return -1;\n\tif (dot(v1, v2) < -EPS) return +2;\n\tif (std::norm(v1) < std::norm(v2)) return -2;\n\treturn 0;\n}\n\n// ------ Functions Level 2 ------ //\nbool intersect(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(cross(s1.second - p1, s1.first - p1)) < EPS;\n\treturn (std::abs(s1.first - p1) + std::abs(s1.second - p1) - std::abs(s1.second - s1.first)) < EPS;\n}\nbool intersect(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (!segflag) return cross(s1.second - s1.first, s2.first - s1.first) * cross(s1.second - s1.first, s2.second - s1.first) < EPS;\n\treturn (ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) <= 0 && ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) <= 0);\n}\nPoint projection(const Segment& s1, const Point& p1) {\n\tGType mul = dot(p1 - s1.first, s1.first - s1.second) / norm(s1.first - s1.second);\n\treturn s1.first + (s1.first - s1.second) * mul;\n}\nPoint reflection(const Segment& s1, const Point& p1) {\n\treturn p1 + (projection(s1, p1) - p1) * (GType)(2);\n}\nGType distance(const Point& p1, const Point& p2) {\n\treturn std::abs(p2 - p1);\n}\nGType distance(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(p1 - projection(s1, p1));\n\tconst Point p2 = projection(s1, p1);\n\tif (intersect(s1, p2, true)) return std::abs(p2 - p1);\n\treturn std::min(std::abs(s1.first - p1), std::abs(s1.second - p1));\n}\nGType distance(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (intersect(s1, s2, segflag)) return 0;\n\tif (!segflag) return std::min(distance(s1, s2.first, false), distance(s1, s2.second, false));\n\treturn std::min({ distance(s1, s2.first, true), distance(s1, s2.second, true), distance(s2, s1.first, true), distance(s2, s1.second, true) });\n}\n\n// ------ Functions Level 3 ------ //\nint contain(std::vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tPoint a = v[i] - p, b = v[(i + 1 != v.size() ? i + 1 : 0)] - p;\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() <= EPS && EPS < b.imag() && cross(a, b) < -EPS) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n#endif\n\n#include <vector>\n#include <iomanip>\n#include <iostream>\nusing namespace std;\nint n, sx, sy, ex, ey, xa[55], ya[55], xb[55], yb[55], h[55];\nint main() {\n\twhile (cin >> n, n) {\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tfor (int i = 0; i < n; i++) cin >> xa[i] >> ya[i] >> xb[i] >> yb[i] >> h[i];\n\t\tvector<vector<Point> > v(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tv[i] = { Point(xa[i], ya[i]), Point(xa[i], yb[i]), Point(xb[i], yb[i]), Point(xb[i], ya[i]) };\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 1; i < 20000; i++) {\n\t\t\tdouble tx = sx + (ex - sx) * i / 20000.0, ty = sy + (ey - sy) * i / 20000.0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (xa[j] <= tx && tx <= xb[j] && ya[j] <= ty && ty <= yb[j]) flag = false;\n\t\t\t}\n\t\t}\n\t\tif (!flag) cout << 0 << endl;\n\t\telse {\n\t\t\tdouble ret = 1.0e+9;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tdouble dist = distance(Segment(Point(sx, sy), Point(ex, ey)), Segment(v[i][j], v[i][(j + 1) & 3]), true);\n\t\t\t\t\tdouble r = 0.5 * (h[i] + dist * dist / h[i]);\n\t\t\t\t\tret = min(ret, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << fixed << setprecision(15) << ret << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<complex>\n\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define min_int(a,b) ((a)<(b)?(a):(b))\n#define INF 10000 //2^31\n#define EPS (1e-9)\n#define EQ(a,b) (abs((a)-(b))<EPS)\nusing namespace std;\n\nclass Gio{\nprivate:\n\ttypedef complex<double>point;\n\tstruct line{ \n\t\tpoint st, ed;//始点,終点\n\t};\n\tpoint min_p,max_p;\n\tline orig, test;\n\tdouble min_R;//保存用\n\tdouble test_R;//実行用\n\tdouble dot(point a, point b);//内積\n\tdouble cross(point a, point b);//外積\n\npublic:\n\tGio(double sx, double sy,double ex,double ey);\n\tvoid set_p(point* p, double x, double y);\n\tvoid set_line(line* l, point s, point e);\n\tvoid set_testline(double sx, double sy, double ex, double ey);\n\tvoid calc_r(double sx,double sy,double lx,double ly,double h);\n\tdouble get_r();\n\tdouble get_d_pp();//min_pとmax_pの距離を返す\n\tdouble get_d_lp();//min_pとtestの長さを返す\n\tdouble get_d_ll();//origとtestの長さを返す\n\tbool intersect();//origとtestが交差していればtrue\n};\n\nGio::Gio(double sx, double sy, double ex, double ey){\n\tset_p(&min_p, sx, sy);\n\tset_p(&max_p, ex, ey);\n\tset_line(&orig, min_p, max_p);\n\tmin_R = INF;\n}\nvoid Gio::set_p(point *p, double x, double y){\n\tpoint a(x, y);\n\t*p = a;\n}\nvoid Gio::set_line(line* l, point s, point e){\n\tl->st = s;\n\tl->ed=e;\n}\nvoid Gio::set_testline(double sx,double sy,double ex,double ey){\n\tpoint a, b;\n\tset_p(&a, sx, sy); set_p(&b, ex, ey);\n\tset_line(&test, a, b);\n\t//printf(\"%lf,%lf\\n\", test.st.real(), test.st.imag());\n}\ndouble Gio::dot(point a, point b){\n\treturn(a.real()*b.real() + a.imag()*b.imag());\n}\ndouble Gio::cross(point a, point b){\n\treturn(a.real()*b.imag() - a.imag()*b.real());\n}\ndouble Gio::get_d_pp(){ return(abs(max_p - min_p)); }\ndouble Gio::get_d_lp(){\n\tpoint a = test.st;\n\tpoint b = test.ed;\n\tpoint c = min_p;\n\tif (abs(dot(b - a, c - a)) < EPS)return(abs(c - a));\n\tif (abs(dot(a - b, c - b)) < EPS)return(abs(c - b));\n\treturn(abs(cross(b - a, c - a)) / abs(b - a));\n}\nbool Gio::intersect(){\n\tpoint a = orig.st, b = orig.ed, c = test.st, d = test.ed;\n\treturn(abs((cross(b - a, c - a)*cross(b - a, d - a)) < EPS) && abs((cross(d - c, a - c)*cross(d - c, b - c)) < EPS));\n}\n\ndouble Gio::get_d_ll(){\n\tif (intersect())return(0);\n\tpoint a0, a1,b0,b1;\n\ta0 = orig.st;\n\ta1 = orig.ed;\n\tb0 = test.st;\n\tb1 = test.ed;\n\tdouble d1, d2, d3, d4;\n\tmin_p = a0; d1 = get_d_lp();\n\tmin_p = a1; d2 = get_d_lp();\n\tset_line(&test, a0, a1);\n\tmin_p = b0; d3 = get_d_lp();\n\tmin_p = b1; d4 = get_d_lp();\n\td1 = min_int(d1, d2);\n\td2 = min_int(d3, d4);\n\treturn(min_int(d1, d2));\n}\n\nvoid Gio::calc_r(double sx, double sy, double lx, double ly,double h){\n\tdouble d1, d2, d3, d4;\n\tpoint p = orig.st;\n\tif (sx <= p.real() && p.real() <= lx&&sy <= p.imag()&&p.imag() <= ly){\n\t\tmin_R = 0; return;\n\t}\n\n\tset_testline(sx, sy, sx, ly); d1 = get_d_ll();\n\tset_testline(sx, sy, lx, sy); d2 = get_d_ll();\n\tset_testline(sx, ly, lx, ly); d3 = get_d_ll();\n\tset_testline(lx, sy, lx, ly); d4 = get_d_ll();\n\td1 = min_int(min_int(d1, d2), min_int(d3, d4));\n\tif (h >= d1)test_R = d1;\n\telse{\n\t\ttest_R = ((d1*d1 + h*h) / h) / 2;\n\t}\n\tmin_R = min_int(min_R, test_R);\n}\ndouble Gio::get_r(){\n\treturn(min_R);\n}\n\nint b_num;\n\n\n\nint main(void){\n\t//Gio g(1, 1, 2, 2);\n\t//g.set_testline(1, 2, 2, 3);\n\t//cout << g.get_d_ll()<<endl;\n\twhile (true){\n\t\tcin >> b_num;\n\t\tif (b_num == 0)return(0);\n\t\tdouble sx, sy, ex, ey,h;\n\t\tcin >> sx >> sy>>ex >> ey;\n\t\tGio g(sx, sy, ex, ey);\n\t\trep(i, 0, b_num){\n\t\t\tcin >> sx >> sy >> ex >> ey>>h;\n\t\t\tg.calc_r(sx, sy, ex, ey, h);\n\t\t}\n\n\t\tprintf(\"%.6lf\\n\", g.get_r());\n\n\t}\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\nbool is(P a,P b,P c,P d){\n  return cr(a-b,c-b)*cr(a-b,d-b)<=0&&cr(c-d,a-d)*cr(c-d,b-d)<=0;\n}\n\ndouble dt(P a,P b,P c,P d){\n  P p[4]={a,b,c,d};\n  double m=1<<30;\n  for(int i=0;i<2;i++){\n    for(int j=0;j<2;j++){\n      m=min(m,abs(p[i]-p[j+2]));\n    }\n  }\n  for(int i=0;i<2;i++){\n    swap(p[0],p[2]);\n    swap(p[1],p[3]);\n    for(int j=0;j<2;j++){\n      if(dot(p[2+j]-p[0],p[1]-p[0])*dot(p[2+j]-p[1],p[0]-p[1])>0){\n\tm=min(m,fabs(cr(p[2+j]-p[0],p[1]-p[0]))/abs(p[1]-p[0]));\n      }\n    }\n  }\n  //  cout<<a<<' '<<b<<' '<<c<<' '<<d<<' '<<m<<endl;\n  return m;\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    int sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    P s=P(sx,sy),e=P(ex,ey);\n    int ix[50],iy[50],ax[50],ay[50],h[50];\n    P ll[50],hl[50],hh[50],lh[50];\n    bool on=false;\n    for(int i=0;i<n;i++){\n      cin>>ix[i]>>iy[i]>>ax[i]>>ay[i]>>h[i];\n      ll[i]=P(ix[i],iy[i]);\n      hl[i]=P(ax[i],iy[i]);\n      hh[i]=P(ax[i],ay[i]);\n      lh[i]=P(ix[i],ay[i]);\n      on|=is(s,e,ll[i],hl[i])|is(s,e,hl[i],hh[i])|is(s,e,hh[i],lh[i])|is(s,e,lh[i],ll[i]);\n      on|=ix[i]<=min(sx,ex)&&max(sx,ex)<=ax[i]&&iy[i]<=min(sy,ey)&&max(sy,sy)<=ay[i];\n    }\n    if(on){\n      cout<<0<<endl;\n    }else{\n      double m=1<<30;\n      for(int i=0;i<n;i++){\n\tP *p[4]={ll+i,hl+i,hh+i,lh+i};\n\tfor(int j=0;j<4;j++){\n\t  double d=dt(*p[j],*p[(j+1)%4],e,s);\n\t  if(d<h[i]){\n\t    m=min(m,(double)h[i]);\n\t  }else{\n\t    m=min(m,(d*d+h[i]*h[i])/2/h[i]);\n\t  }\n\t}\n      }\n      cout<<fixed<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P complex<double>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nusing namespace std;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nint main() {\n  int N;\n  while(cin >>N && N){\n    double sx, sy, ex, ey; cin >>sx >>sy >>ex >>ey;\n    L route = L(P(sx, sy), P(ex, ey));\n    double ans = INF;\n    REP(n, N){\n      double minx, miny, maxx, maxy, h; cin >>minx >>miny >>maxx >>maxy >>h;\n      vector<L> l;\n      l.push_back(L(P(maxx, maxy), P(minx, maxy)));\n      l.push_back(L(P(maxx, maxy), P(maxx, miny)));\n      l.push_back(L(P(minx, miny), P(maxx, miny)));\n      l.push_back(L(P(minx, maxy), P(minx, miny)));\n      if(minx <= min(sx, ex) && maxx >= max(sx, ex) && miny <= min(sy, ey) && maxy >= max(sy, ey)) ans = 0.0;\n      REP(i, 4){\n        if(intersectSS(route, l[i])) ans = 0.0;\n        double d = distanceSS(route, l[i]);\n        double r = (d * d + h * h) / (2 * h);\n        if(h > d) r = d;\n        ans = min(ans, r);\n      }\n    }\n    printf(\"%.9lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000.0\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\ndouble sx, sy, ex, ey;\ndouble mx[50], my[50], Mx[50], My[50], h[50];\n\ndouble f(double x, double y, double z){\n\tdouble r = 0, l = 1, mr, ml;\n\trep(i,30){\n\t\tmr = (r*2+l)/3;\n\t\tml = (r+l*2)/3;\n\t\tif((sx+(ex-sx)*mr-x)*(sx+(ex-sx)*mr-x)+(sy+(ey-sy)*mr-y)*(sy+(ey-sy)*mr-y) < (sx+(ex-sx)*ml-x)*(sx+(ex-sx)*ml-x)+(sy+(ey-sy)*ml-y)*(sy+(ey-sy)*ml-y)){\n\t\t\tl = ml;\n\t\t} else r = mr;\n\t}\n\treturn sqrt((sx+(ex-sx)*r-x)*(sx+(ex-sx)*r-x)+(sy+(ey-sy)*r-y)*(sy+(ey-sy)*r-y)+z*z);\n}\n\ndouble fx(double x1, double x2, double y, double z){\n\tdouble r = x1, l = x2, mr, ml;\n\trep(i,30){\n\t\tmr = (r*2+l)/3;\n\t\tml = (r+l*2)/3;\n\t\tif(f(mr,y,0) < f(ml,y,0)){\n\t\t\tl = ml;\n\t\t} else r = mr;\n\t}\n\treturn f(r,y,z);\n}\n\ndouble fy(double x, double y1, double y2, double z){\n\tdouble r = y1, l = y2, mr, ml;\n\trep(i,30){\n\t\tmr = (r*2+l)/3;\n\t\tml = (r+l*2)/3;\n\t\tif(f(x,mr,0) < f(x,ml,0)){\n\t\t\tl = ml;\n\t\t} else r = mr;\n\t}\n\treturn f(x,r,z);\n}\n\nvoid solve(){\n\tcin >> sx >> sy >> ex >> ey;\n\trep(i,n) cin >> mx[i] >> my[i] >> Mx[i] >> My[i] >> h[i];\n\trep(i,n){\n\t\tif(mx[i]<=sx&&sx<=Mx[i]&&my[i]<=sy&&sy<=My[i]){\n\t\t\tputs(\"0.000\");\n\t\t\treturn;\n\t\t}\n\t\tif(mx[i]<=ex&&ex<=Mx[i]&&my[i]<=ey&&ey<=My[i]){\n\t\t\tputs(\"0.000\");\n\t\t\treturn;\n\t\t}\n\t}\n\tdouble s = 0.0, e = 10000.0, mid;\n\trep(u,30){\n\t\tmid = (s+e)/2;\n\t\tdouble dist = INF;\n\t\trep(i,n){\n\t\t\tdouble z = mid-h[i];\n\t\t\tif(z < 0) z = 0.0;\n\t\t\tdist = min(dist,fx(mx[i],Mx[i],my[i],z));\n\t\t\tdist = min(dist,fx(mx[i],Mx[i],My[i],z));\n\t\t\tdist = min(dist,fy(mx[i],my[i],My[i],z));\n\t\t\tdist = min(dist,fy(Mx[i],my[i],My[i],z));\n\t\t}\n\t\tif(dist < mid){\n\t\t\te = mid;\n\t\t} else s = mid;\n\t}\n\tprintf(\"%.9f\\n\",s);\n}\n\nint main(){\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e9)\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(P a, P b, P c){\n  if(cross(b-a,c-a) > EPS) return 1;\n  if(cross(b-a,c-a) < -EPS) return -1;\n  if(dot(b-a,c-a) < EPS) return 2;\n  if(abs(b-a) + EPS < abs(c-a)) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\ndouble p_to_s_dist(P a, L s){\n  if(dot(s.second-s.first,a-s.first) >= 0 && dot(s.first-s.second,a-s.second) >= 0){\n    return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n  }\n  return min(abs(a-s.first), abs(a-s.second));\n}\n\ndouble s_to_s_dist(L a, L b){\n  if(is_cross(a,b)) return 0;\n  return min(min(p_to_s_dist(a.first,b),p_to_s_dist(a.second,b)),\n\t     min(p_to_s_dist(b.first,a),p_to_s_dist(b.second,a)));\n}\n\nint main(){\n  int N;\n  double h, d, x[2], y[2];\n  while(cin >> N, N){\n    vector<P> V;\n    cin >> x[0] >> y[0] >> x[1] >> y[1];\n    P s = P(x[0],y[0]), e = P(x[1],y[1]);\n    L c = L(s,e);\n    for(int i = 0; i < N; ++i){\n      cin >> x[0] >> y[0] >> x[1] >> y[1] >> h;\n      L edge[4];\n      for(int j = 0; j < 4; ++j){\n\tedge[j] = L(P(x[j/2],y[j%2]),P(x[((j+1)/2)%2],y[(j+1)%2]));\n      }\n      d = 100000;\n      for(int j = 0; j < 4; ++j){\n\td = min(d, s_to_s_dist(c, edge[j]));\n      }\n      V.push_back(P(d,h));\n    }\n    sort(V.begin(), V.end());\n    double ub = 100000, lb = 0, r = ub/2;\n    for(int t = 0; t < 10000; ++t){\n      r = (ub+lb)/2;\n      bool f = true;\n      for(int i = 0; i < N; ++i){\n\tif((V[i].X < EPS) || ((r > norm(V[i])/2/V[i].Y) && (r > V[i].X))){\n\t  f = false;\n\t  break;\n\t}\n      }\n      if(f) lb = r;\n      else ub = r;\n    }\n    printf(\"%.10lf\\n\", r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define EPS (1e-10)\ntypedef complex<double> P;\n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\ndouble distance(P p0, P p1, P p2, P p3){\n  double ans = 1e10;\n        ans = min(ans, distance_ls_p(p0, p1, p2));\n        ans = min(ans, distance_ls_p(p0, p1, p3));\n        ans = min(ans, distance_ls_p(p2, p3, p0));\n        ans = min(ans, distance_ls_p(p2, p3, p1));\n        if(is_intersected_ls(p0, p1, p2, p3)) ans = 0.0;\n\t\treturn ans;\n}\n\nint main(){\n  while(true){\n\t\tint n; cin >> n;\n\t\tif(n == 0 )break;\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tP s = P(x,y);\n\t\tcin >> x >> y;\n\t\tP g = P(x,y);\n\t\tvector<P> mins(n), maxs(n);\n\t\tvector<double> h(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\t//if(z == 24)printf(\"%.0f %.0f\",x,y);\n\t\t\tmins[i].real(x); mins[i].imag(y);\n\t\t\tcin >> x >> y;\n\t\t\t//if(z == 24)printf(\" %.0f %.0f\",x,y);\n\t\t\tmaxs[i].real(x); maxs[i].imag(y);\n\t\t\tcin >> h[i];\n\t\t\t//if(z == 24)printf(\" %.0f \\n\",h[i]);\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tfor(int i = 0; i < n;i++){\n\t\t\tdouble d = 1e9;\n\t\t\tP p1 = mins[i], p3 = maxs[i];\n\t\t\tP p2(mins[i].real(), maxs[i].imag());\n\t\t\tP p4(maxs[i].real(), mins[i].imag());\n\t\t\tif(p1.real() < s.real() && s.real() < p3.real() && \n\t\t\t\tp1.imag() < s.imag() && s.imag() < p3.imag()){\n\t\t\t\tans = 0;/*\n\t\t\t\tif(z==24){\n\t\t\t\t\tprintf(\"%.0f %.0f %.0f %.0f\\n\",p1.real(),p1.imag(),p3.real(),p3.imag());\n\t\t\t\t\tcout << \"break\" << endl;}*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, distance(s, g, p1,p2));\n\t\t\td = min(d, distance(s, g, p2,p3));\n\t\t\td = min(d, distance(s, g, p3,p4));\n\t\t\td = min(d, distance(s, g, p4,p1));\n\t\t\tdouble r = (h[i]*h[i]+d*d)/(2*h[i]);\n\t\t\tif(h[i] < d){\n\t\t\t\tans = min(ans, r);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = min(ans, d);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4f\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nconst double EPS = 1e-10;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(const Point& a = Point(),const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(const Point& a = Point(), const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return ABOVE;\n    if(v1.cross(v2) < -EPS) return UNDER;\n    if(v1.dot(v2) < -EPS) return BACKWARD;\n    if(v2.norm() - v1.norm() > EPS) return FORWARD;\n    return ON;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source().distance(p);\n    double b = target().distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = s.source().ccw(s.target(), source()) * s.source().ccw(s.target(), target()) <= EPS;\n    bool b = source().ccw(target(), s.source()) * source().ccw(target(), s.target()) <= EPS;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\n\ndouble max_radius(Segment& course, vector<Point>& block, double h) {\n    double result = 1e10;\n\n    vector<Segment> edge;\n    for(int i = 0; i < block.size(); ++i) edge.push_back(Segment(block[i], block[(i + 1) % block.size()]));\n\n    for(auto& e: edge) {\n        if(e.intersect(course)) return 0.0;\n    }\n    for(auto& point: block) {\n        double d = point.distance(course);\n        result = min(result, d > h ? (h * h + d * d) / (2.0 * h) : d);\n    }\n    for(auto& e: edge) for(auto& point: {course.target(), course.source()}) {\n        double d = point.distance(e);\n        result = min(result, d > h ? (h * h + d * d) / (2.0 * h) : d);\n    }\n\n    return result;\n}\n\nint main () {\n    int N;\n    while(cin >> N, N) {\n        double answer = 1e10;\n        double sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        Segment course(Point(sx, sy), Point(ex, ey));\n        for(int i = 0; i < N; ++i) {\n            double minx, miny, maxx, maxy, h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            vector<Point> block;\n            block.push_back(Point(minx, miny));\n            block.push_back(Point(minx, maxy));\n            block.push_back(Point(maxx, miny));\n            block.push_back(Point(maxx, maxy));\n            answer = min(answer, max_radius(course, block, h));\n        }\n        cout << answer << endl;\n    }\n};"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1e-8\n#define INF 1e8\n\ntypedef complex<double> Point;\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tPoint operator / (const Point &p, const double &a){\n\t\treturn Point(real(p)/a, imag(p)/a);\n\t}\n\tPoint operator * (const Point &p, const double &a){\n\t\treturn Point(real(p)*a, imag(p)*a);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn real(a) == real(b) && real(a) == real(b);\n\t}\n}\n\n\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point>{\n\tLine(){}\n\tLine(const Point &a, const Point &b){\n\t\tpush_back(a); push_back(b);\n\t}\n};\nstruct Circle{\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &c, double r):c(c),r(r){}\n};\n\ndouble dot(const Point &a, const Point &b){\n\treturn real(conj(a) * b);\n}\n\ndouble cross(const Point &a, const Point &b){\n\treturn imag(conj(a)*b);\n}\n\nPoint projection(const Line &l, const Point &p){\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t * (l[0]-l[1]);\n}\n\nint ccw(Point a, Point b, Point c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > 0) return +1;\n\tif(cross(b,c) < 0) return -1;\n\tif(dot(b,c) < 0) return +2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\ndouble distancePP(const Point &a, const Point &b){\n\treturn abs(a-b);\n}\n\nbool intersectSS(const Line &s, const Line &t){\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\t\t\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const Line &s, const Point &p){\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1]-s[0]) < EPS;\n}\n\ndouble distanceSP(const Line &s, const Point &p){\n\tconst Point r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r-p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\nbool intersectLL(const Line &l, const Line &m){\n\treturn abs(cross(l[1]-l[0], m[1]-m[0])) > EPS ||\n\t\t\t\t\tabs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n\nbool inPolygon(const Polygon &g, const Point &p){\n\tdouble sum = 0.0;\n\tint n = g.size();\n\tfor(int i = 0; i < g.size(); i++){\n\t\tint j = (i+1)%n;\n\t\tif(intersectSP(Line(g[i], g[j]), p)) return true;\n\t\tsum += arg((g[j]-p)/(g[i]-p));\n\t}\n\treturn abs(sum) > 1;\n}\n\nint main(void){\n\tint N;\n\twhile(cin >> N, N){\n\t\tint miss = 0;\n\t\tdouble sx, sy, ex, ey;\n\t\tvector<Point> ps(N, Point(INF,INF));\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tLine root = Line(Point(sx, sy), Point(ex, ey));\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tdouble ax, ay, bx, by, h;\n\t\t\tdouble d = INF;\n\t\t\tcin >> ax>>ay>>bx>>by>>h;\n\t\t\tPolygon g;\n\t\t\tg.push_back(Point(ax,ay));\n\t\t\tg.push_back(Point(bx,ay));\n\t\t\tg.push_back(Point(bx,by));\n\t\t\tg.push_back(Point(ax,by));\n\t\t\t//内部判定\n\t\t\tif(inPolygon(g, root[0]) && inPolygon(g, root[1])) miss = 1;\n\t\t\t//接触判定\n\t\t\tif(intersectSS(root, Line(Point(ax, ay), Point(bx, ay)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(bx, ay), Point(bx, by)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(bx, by), Point(ax, by)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(ax, by), Point(ax, ay)))) miss = 1;\n\t\t\tif(miss) break;\n\t\t\t\n\t\t\t//最小距離\n\t\t\td = min(d, distanceSP(root, Point(ax, ay)));\n\t\t\td = min(d, distanceSP(root, Point(bx, by)));\n\t\t\td = min(d, distanceSP(root, Point(ax, by)));\n\t\t\td = min(d, distanceSP(root, Point(bx, ay)));\n\n\t\t\td = min(d, distanceSP(Line(Point(ax, ay), Point(bx, ay)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(ax, ay), Point(bx, ay)), root[1]));\n\n\t\t\td = min(d, distanceSP(Line(Point(bx, ay), Point(bx, by)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(bx, ay), Point(bx, by)), root[1]));\n\n\t\t\td = min(d, distanceSP(Line(Point(bx, by), Point(ax, by)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(bx, by), Point(ax, by)), root[1]));\n\n\t\t\td = min(d, distanceSP(Line(Point(ax, by), Point(ax, ay)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(ax, by), Point(ax, ay)), root[1]));\n\t\t\tps[i] = Point(d, h);\n\t\t}\n\t\tif(miss){\n\t\t\tcout << \"0\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble left = 0, right = 10000;\n\t\tdouble ans = 0;\n\t\twhile(right - left > EPS){\n\t\t\tdouble mid = (left + right) / 2;\n\t\t\tdouble ret = INF;\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tret = min(ret, distancePP(Point(0, mid), ps[i]));\n\t\t\t}\n\t\t\tif(ret <= mid + EPS) right = mid;\n\t\t\telse ans = ret, left = mid;\n//\t\t\tprintf(\"%.4lf -> ret:ans = [%.4lf : %.4lf]\\n\", mid, ret, ans);\n\t\t}\n\t\tprintf(\"%.9lf\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n\n#define fr first\n#define sc second\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point,vec;\ntypedef pair<point,point> pp,seg,line;\n\nconst elem pi = 2.0*acos(0.0);\nconst elem eps = 1.0e-12;\nconst elem infty = 1.0e+18;\n\ninline bool eq(elem a, elem b){return abs(b-a) < eps;}\ninline bool leq(elem a, elem b){return eq(a,b) || a < b;}\ninline bool geq(elem a, elem b){return eq(a,b) || a > b;}\ninline bool lt(elem a, elem b){return !eq(a,b) && a < b;}\ninline bool gt(elem a, elem b){return !eq(a,b) && a > b;}\ninline bool ltz(elem a){return lt(a,0);}\ninline bool gtz(elem a){return gt(a,0);}\ninline elem emax(elem a, elem b){return gt(a,b)?a:b;}\ninline elem emin(elem a, elem b){return lt(a,b)?a:b;}\ninline elem dot(point a, point b){return a.real()*b.real() + a.imag()*b.imag();}\ninline elem cross(point a, point b){return a.real()*b.imag()-a.imag()*b.real();}\ninline elem dist_l(line l,point x){ return abs(cross(l.sc-l.fr,x-l.fr))/abs(l.sc-l.fr); }\ninline elem dist_seg(seg s, point x){\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\ninline bool intersected_seg(seg a, seg b){\n  return ( leq( cross(a.sc-a.fr,b.fr-a.fr) * cross(a.sc-a.fr,b.sc-a.fr), 0) &&\n\t   leq( cross(b.sc-b.fr,a.fr-b.fr) * cross(b.sc-b.fr,a.sc-b.fr), 0 ) );\n}\ninline int ccw(point a, point b, point x){\n  b-=a;x-=a;\n  if(gtz(cross(b,x)))return LEFT;\n  if(ltz(cross(b,x)))return RIGHT;\n  if(ltz(dot(b,x)))return BACK;\n  if(abs(b)<abs(x))return FRONT;\n  return OVER;\n}\n\nclass cuboid{\npublic:\n  elem h;\n  elem minx, miny;\n  elem maxx, maxy;\n  point tl,bl,tr,br;\n  cuboid():minx(0),miny(0),\n\t maxx(0),maxy(0),h(0){}\n  cuboid(elem minx, elem miny, elem maxx, elem maxy,elem h):\n    minx(minx),miny(miny),\n    maxx(maxx),maxy(maxy),h(h),\n    tl(minx,maxy),bl(minx,miny),tr(maxx,maxy),br(maxx,miny){}\n  bool intersected_seg(seg l){\n    if( ::intersected_seg(l,seg(tl,tr)) ||\n\t::intersected_seg(l,seg(tl,bl)) ||\n\t::intersected_seg(l,seg(tr,br)) ||\n\t::intersected_seg(l,seg(bl,br)) ) return true;\n    return false;\n  }\n  bool contain_seg(seg l){\n    if( ccw(bl,br,l.fr)&(OVER|LEFT) &&\n\tccw(br,tr,l.fr)&(OVER|LEFT) &&\n\tccw(tr,tl,l.fr)&(OVER|LEFT) &&\n\tccw(tl,bl,l.fr)&(OVER|LEFT)\n\t&&\n\tccw(bl,br,l.sc)&(OVER|LEFT) &&\n\tccw(br,tr,l.sc)&(OVER|LEFT) &&\n\tccw(tr,tl,l.sc)&(OVER|LEFT) &&\n\tccw(tl,bl,l.sc)&(OVER|LEFT) ) return true;\n    return false;\n  }\n  elem getMinimumDistance(seg l){\n    elem ret = infty;\n    ret = emin( ret, dist_seg( l, tl ) );\n    ret = emin( ret, dist_seg( l, tr ) );\n    ret = emin( ret, dist_seg( l, bl ) );\n    ret = emin( ret, dist_seg( l, br ) );\n    ret = emin( ret, dist_seg( seg(tl,tr), l.fr ) );\n    ret = emin( ret, dist_seg( seg(tl,tr), l.sc ) );\n    ret = emin( ret, dist_seg( seg(tl,bl), l.fr ) );\n    ret = emin( ret, dist_seg( seg(tl,bl), l.sc ) );\n    ret = emin( ret, dist_seg( seg(bl,br), l.fr ) );\n    ret = emin( ret, dist_seg( seg(bl,br), l.sc ) );\n    ret = emin( ret, dist_seg( seg(tr,br), l.fr ) );\n    ret = emin( ret, dist_seg( seg(tr,br), l.sc ) );\n    return ret;\n  }\n  elem getRwithSphere(seg l){\n    if(contain_seg(l) || intersected_seg(l))return 0;\n    elem d = getMinimumDistance(l);\n    if(eq(d,0))return 0;\n    elem theta = 2*atan(h/d);\n    if(gt(theta,pi/2))theta=pi/2;\n    elem ret = sqrt( (pow(d,2)+pow(h,2))/(2*(1-cos(theta))) );\n    return ret;\n  }\n};\n\nint main(){\n  while(true){\n    int n;\n    elem ans = infty;\n    elem sx,sy,ex,ey;\n    vector<cuboid> vcubo;\n    scanf(\"%d\",&n);\n    if(n == 0) return 0;\n    scanf(\"%lf%lf%lf%lf\",&sx,&sy,&ex,&ey);\n    point S(sx,sy), E(ex,ey);\n    for(int i = 0; i < n; ++i){\n      elem minx, miny, maxx, maxy, h;\n      scanf(\"%lf%lf%lf%lf%lf\",\n\t    &minx,&miny,&maxx,&maxy,&h);\n      vcubo.push_back( cuboid(minx,miny,maxx,maxy,h) );\n    }\n    for(int i = 0; i < n; ++i){\n      ans = emin( ans, vcubo[i].getRwithSphere( seg(S,E) ) );\n    }\n    printf(\"%.7lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\nconst double inf = 1.0 / 0.0;\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nnamespace CCW {\n  enum { COUNTER_CLOCKWISE = 1, CLOCKWISE = -1,\n         ONLINE_BACK = 2, ONLINE_FRONT = -2,\n         ONSEGMENT = 0 };\n}\n\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > eps) return CCW::COUNTER_CLOCKWISE;\n  if(cross(a, b) < -eps) return CCW::CLOCKWISE;\n  if(dot(a, b) < -eps) return CCW::ONLINE_BACK;\n  if(norm(b)-norm(a) > eps) return CCW::ONLINE_FRONT;\n  return CCW::ONSEGMENT;\n}\n\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n           ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return abs(cross(s2 - s1, p - s1)/abs(s2 - s1));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\ndouble getDistance(P a1, P a2, P b1, P b2) {\n  if(isIntersect(a1,a2,b1,b2)) return 0.0;\n  return min(min(getDistanceSP(a1,a2,b1), getDistanceSP(a1,a2,b2)),\n             min(getDistanceSP(b1,b2,a1), getDistanceSP(b1,b2,a2)));\n}\n\nint main() {\n  for (int N; cin >> N && N; ) {\n    P s, t;\n    cin >> s.real() >> s.imag() >> t.real() >> t.imag();\n    vector<P> a(N), b(N);\n    vector<double> h(N);\n    for (int i = 0; i < N; ++i) {\n      cin >> a[i].real() >> a[i].imag()\n          >> b[i].real() >> b[i].imag()\n          >> h[i];\n    }\n\n    double res = inf;\n    for (int i = 0; i < N; ++i) {\n      if (a[i].real() <= s.real() && s.real() <= b[i].real() &&\n          a[i].imag() <= s.imag() && s.imag() <= b[i].imag()) {\n        res = 0;\n        break;\n      }\n      if (a[i].real() <= t.real() && t.real() <= b[i].real() &&\n          a[i].imag() <= t.imag() && t.imag() <= b[i].imag()) {\n        res = 0;\n        break;\n      }\n      double d = getDistance(s, t,\n                             P(a[i].real(), a[i].imag()),\n                             P(b[i].real(), a[i].imag()));\n      d = min(d, getDistance(s, t,\n                             P(a[i].real(), b[i].imag()),\n                             P(b[i].real(), b[i].imag())));\n      d = min(d, getDistance(s, t,\n                             P(a[i].real(), a[i].imag()),\n                             P(a[i].real(), b[i].imag())));\n      d = min(d, getDistance(s, t,\n                             P(b[i].real(), a[i].imag()),\n                             P(b[i].real(), b[i].imag())));\n      if (d <= h[i]) {\n        res = min(res, d);\n      } else {\n        res = min(res, (d*d + h[i]*h[i]) / (2*h[i]));\n      }\n    }\n    printf(\"%.10f\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ld = long double;\nusing Point = complex<ld>;\n\nstruct Line{\n    Point a, b;\n    Line (Point a, Point b) : a(a), b(b) {}\n    Line () : Line(Point(), Point()) {}\n};\n\nstruct Circle{\n    Point p;\n    ld r;\n    Circle (Point p, ld r) : p(p), r(r) {}\n    Circle () : Circle(Point(),0.0) {}\n};\n\nconstexpr ld eps=1e-9, pi=acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nnamespace Geometry{\n    bool eq(ld a, ld b){\n        return abs(a-b) < eps;\n    }\n    //内積\n    ld dot(Point a, Point b){\n        return real(conj(a) * b);\n    }\n    //外積\n    ld cross(Point a, Point b){\n        return imag(conj(a) * b);\n    }\n    //3点の位置関係\n    int ccw (Point a, Point b, Point c) {\n        b -= a; c -= a;\n        if (cross(b, c) > eps) return 1;//a,b,cで反時計周り\n        if (cross(b, c) < -eps) return -1;//a,b,cで時計周り\n        if (dot(b, c) < 0) return 2;//c,a,bで直線\n        if (norm(b) < norm(c)) return -2;//a,b,cで直線\n        return 0;//a,c,bで直線\n    }\n\n//====================================================\n    Point inputPoint(){\n        ld x, y;\n        cin>>x>>y;\n        return Point(x, y);\n    }\n    //2直線の交差判定\n    bool isCrossed_ll(Line l, Line m){\n        return !eq(cross(l.b-l.a, m.b-m.a), 0);\n    }\n    //直線と線分の交差判定\n    bool isCrossed_ls(Line l, Line s){\n        return isCrossed_ll(l, s) && \n            cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps;\n    }\n    //線分と線分の交差判定\n    bool isCrossed_ss(Line s, Line t){\n        return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n            ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n    }\n    //点が直線上にあるか\n    bool isON_l(Line l, Point p){\n        return abs(cross(l.b-p, l.a-p)) < eps;\n    }\n    //点が線分上にあるか\n    bool isON_s(Line s, Point p){\n        return abs(s.a-p)+abs(s.b-p)-abs(s.b-s.a) < eps;\n    }\n\n    //点から直線への垂線の足\n    Point foot(Line l, Point p){\n        ld t = dot(p-l.a,l.a-l.b)/norm(l.a-l.b);\n        return l.a+t*(l.a-l.b);\n    }\n    //直線と直線の交点\n    Point intersection_ll(Line l, Line m){\n        Point lv=l.b-l.a, mv=m.b-m.a;\n        assert(cross(lv,mv)!=0);//平行\n        return l.a+lv*cross(mv,m.a-l.a)/cross(mv,lv);\n    }\n    //線分と線分の交点\n    Point intersection_ss(Line s, Line t){\n        assert(isCrossed_ll(s, t));\n        return intersection_ll(s,t);\n    }\n\n    //点と直線の距離\n    ld dist_lp(Line l, Point p) {\n        return abs(p - foot(l, p));\n    }\n    //直線と直線の距離\n    ld dist_ll(Line l, Line m){\n        return isCrossed_ll(l, m)?0:dist_lp(l, m.a);\n    }\n    //直線と線分の距離\n    ld dist_ls(Line l, Line s){\n        return isCrossed_ls(l, s)?0:min(dist_lp(l, s.a), dist_lp(l, s.b));\n    }\n    //線分と点の距離\n    ld dist_sp (Line s, Point p) {\n        Point r = foot(s, p);\n        return isON_s(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n    }\n    //線分と線分の距離\n    ld dist_ss (Line s, Line t) {\n        if (isCrossed_ss(s, t)) return 0;\n        return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n    }\n    //円と円の交点\n    \n};\n\nint main(){\n    int n;\n    using namespace Geometry;\n    while(cin>>n,n){\n        Point s=inputPoint();\n        Point e=inputPoint();\n        Line l{s,e};\n        ld ans=1e9;\n        for(int i=0;i<n;++i){\n            Point p[2];\n            p[0]=inputPoint();\n            p[1]=inputPoint();\n            if(s.real()>=p[0].real() && s.real()<=p[1].real()){\n                if(p[0].imag() <= s.imag() && s.imag() <= p[1].imag())ans=0.0;\n            }\n            if(e.real()>=p[0].real() && e.real()<=p[1].real()){\n                if(p[0].imag() <= e.imag() && e.imag() <= p[1].imag())ans=0.0;\n            }\n            ld h;\n            cin>>h;\n            for(int j=0;j<2;++j){\n                for(int k=0;k<2;++k){\n                    Line m;\n                    if(k)m={Point(p[j].real(),p[j].imag()),Point(p[j].real(),p[1-j].imag())};\n                    else m={Point(p[j].real(),p[j].imag()),Point(p[1-j].real(),p[j].imag())};\n                    if(isCrossed_ss(l,m)){\n                        ans=0.0;\n                    }else{\n                        ld d=dist_ss(l,m);\n                        if(d - h > eps){\n                            Point o(0,0),c(d,h);\n                            Line q{o,Point(0,1)};\n                            Line z{Point(d/2.0,h/2.0),Point(d/2.0+1,h/2.0-d/h)};\n                            Point g=intersection_ll(q,z);\n                            ans=min(ans,g.imag());\n                        }else{\n                            ans=min(ans,d);\n                        }\n                    }\n                }\n            }\n        }\n        BREAK:\n        cout<<fixed;\n        cout<<setprecision(6)<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ninline double sq(double x) { return x * x; }\n\nstruct point {\n    double x, y, z;\n    point() {}\n    point(double x, double y, double z): x(x), y(y), z(z) {}\n    point operator + (const point& o) const { return point(x+o.x, y+o.y, z+o.z); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y, z-o.z); }\n    point operator * (const double a) const { return point(x*a,   y*a,   z*a); }\n};\n\ndouble fabs(point p) { return sqrt(sq(p.x) + sq(p.y) + sq(p.z)); }\ndouble dist(point p, point q) { return fabs(p - q); }\ndouble dot(point p, point q) { return p.x*q.x + p.y*q.y + p.z*q.z; }\npoint cross(point p, point q) {\n    return point(\n        p.y*q.z - p.z*q.y,\n        p.z*q.x - p.x*q.z,\n        p.x*q.y - p.y*q.x\n    );\n}\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\ndouble dist_point_line(point p, line l) {\n    if (dot(l.b - l.a, p - l.a) >= 0 && dot(l.a - l.b, p - l.b) >= 0) {\n        point h = l.a + (l.b - l.a) * (dot(l.b - l.a, p - l.a) / sq(fabs(l.b - l.a)));\n        return dist(p, h);\n    }\n\n    return min(dist(p, l.a), dist(p, l.b));\n}\n\nint N; double Sx, Sy, Ex, Ey;\nvector<vector<point>> rects;\nvector<line> vs;\n\ndouble solve() {\n    line c(point(Sx, Sy, 0), point(Ex, Ey, 0));\n    for (vector<point> r : rects) {\n        for (int i = 0; i < r.size(); ++i) {\n            for (int j = i+1; j < r.size(); ++j) {\n                double c1 = cross(c.b - c.a, r[i] - c.a).z * cross(c.b - c.a, r[j] - c.a).z;\n                double c2 = cross(r[j] - r[i], c.a - r[i]).z * cross(r[j] - r[i], c.b - r[i]).z;\n                if (c1 <= 0 && c2 <= 0)\n                    return 0;\n            }\n        }\n    }\n\n    double l = 0, r = 1050;\n    for (int g = 0; g < 100; ++g) {\n        double m = (l + r) / 2;\n\n        line c(point(Sx, Sy, m), point(Ex, Ey, m));\n\n        bool ok = true;\n        for (line p : vs) {\n            if (dist_point_line(p.a, c) <= m || dist_point_line(p.b, c) <= m)\n                ok = false;\n            if (dist_point_line(c.a, p) <= m || dist_point_line(c.b, p) <= m)\n                ok = false;\n            if (m < p.a.z) p.a.z = p.b.z = m;\n            if (dist_point_line(p.a, c) <= m || dist_point_line(p.b, c) <= m)\n                ok = false;\n            if (dist_point_line(c.a, p) <= m || dist_point_line(c.b, p) <= m)\n                ok = false;\n        }\n\n        (ok ? l : r) = m;\n    }\n\n    return (l + r) / 2;\n}\n\nint main(void) {\n    cout << fixed << setprecision(5);\n    while (true) {\n        cin >> N; if (N == 0) break;\n        cin >> Sx >> Sy >> Ex >> Ey;\n        vs.clear();\n        rects.clear();\n        for (int i = 0; i < N; ++i) {\n            double minx, miny, maxx, maxy, h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            vs.emplace_back(point(minx, miny, h), point(minx, maxy, h));\n            vs.emplace_back(point(minx, miny, h), point(maxx, miny, h));\n            vs.emplace_back(point(minx, maxy, h), point(maxx, maxy, h));\n            vs.emplace_back(point(maxx, miny, h), point(maxx, maxy, h));\n\n            vector<point> vv;\n            vv.emplace_back(minx, miny, h);\n            vv.emplace_back(minx, maxy, h);\n            vv.emplace_back(maxx, miny, h);\n            vv.emplace_back(maxx, maxy, h);\n            rects.push_back(vv);\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// cpp_range (generic range class, very small equivalent of boost::irange)\n// (C) @cielavenir under Boost Software License.\n// note: end position is exclusive.\n\n#include <iterator>\ntemplate<typename T>\nclass range{\npublic:\n\tstruct iterator{\n\t\tconst T a,b;\n\t\tT p;\n\t\tconst long long d; //because T might be unsigned.\n\t\titerator(T _a,T _b,T _p,long long _d=1):a(_a),b(_b),p(_p),d(_d){}\n\n\tpublic:\n\t\ttypedef T value_type;\n\t\ttypedef T& reference;\n\t\ttypedef T* pointer;\n\t\ttypedef std::ptrdiff_t difference_type;\n\t\ttypedef std::random_access_iterator_tag iterator_category;\n\n\t\t//copy\n\t\titerator(const iterator &other):a(other.a),b(other.b),p(other.p),d(other.d){}\n\t\titerator operator=(const iterator &other){return iterator(other.a,other.b,other.p,other.d);}\n\n\t\t//advance\n\t\titerator& operator+=(T n){p+=n*d;return *this;}\n\t\titerator& operator-=(T n){return *this+=(-n);}\n\t\titerator& operator++(){return *this+=1;}\n\t\titerator& operator--(){return *this-=1;}\n\t\titerator operator+(T n) const{return iterator(a,b,p+n*d);}\n\t\titerator operator-(T n) const{return *this+(-n);}\n\n\t\t//difference\n\t\tT operator-(const iterator& other) const{return p-other.p;}\n\n\t\t//equality\n\t\tbool operator==(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p==other.p;}\n\t\tbool operator!=(const iterator& other) const{return !(*this==other);}\n\n\t\t//compare\n\t\tbool operator<(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p*d<other.p*d;}\n\t\tbool operator>(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p*d>other.p*d;}\n\n\t\t//reference\n\t\tconst T& operator*() const{return p;}\n\t};\n\nprivate:\n\tconst T a,b;\n\tT siz;\n\tlong long d;\npublic:\n\trange(T _a,T _b,long long _d=1):a(_a),b(_b){\n\t\td=_d;\n\t\td=d==0?1:d; //\n\t\tsiz=( (d>0?(b-a):(a-b)) - 1)  / (d>0?d:-d);\n\t}\n\n\tT operator[](T n){return a+n*d;}\n\titerator begin(){return iterator(a,a+d*siz,a,d);}\n\titerator end(){return iterator(a,a+d*siz,a+d*(siz+1),d);}\n\titerator rbegin(){return iterator(b-d*siz,b,b,-1*d);}\n\titerator rend(){return iterator(b-d*siz,b,b-d*(siz+1),-1*d);}\n\tT size(){return siz;}\n};\ntemplate<typename T>\nrange<T> make_range(T a,T b,long long d=1){return range<T>(a,b,d);}\n\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cfloat>\nusing namespace std;\ntypedef double val_t;\ntypedef complex<val_t> P;\ntypedef vector<P> VP;\nconst val_t EPS=1e-9;\n\nval_t cross(const P &a,const P &b){return (conj(a)*b).imag();}\nval_t dot(const P &a,const P &b){return (conj(a)*b).real();}\nP projection(const VP &l,const P &p){\n\tP t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n\treturn l[0]+t*(l[0]-l[1]);\n}\nbool intersectSP(const VP &s,const P &p){\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nval_t distanceSP(const VP &s,const P &p){\n\tP r=projection(s,p);\n\treturn intersectSP(s,r) ? abs(r-p) : min(abs(s[0]-p),abs(s[1]-p));\n}\nbool intersectSS(const VP &l,const VP &m){\n\tval_t a=cross(l[1]-l[0],m[1]-m[0]);\n\tval_t b=cross(l[1]-l[0],l[1]-m[0]);\n\t//VP pt=abs(a)<EPS ? abs(b)<EPS ? {l[0],l[1],m[0],m[1]} : VP() : {m[0]+b/a*(m[1]-m[0])};\n\tVP pt=vector<VP>{{l[0],l[1],m[0],m[1]},{},{m[0]+b/a*(m[1]-m[0])}}[abs(a)<EPS?abs(b)<EPS?0:1:2];\n\treturn accumulate(pt.begin(),pt.end(),false,[&](bool S,const P &e){\n\t\treturn S||(dot(l[0]-e,l[1]-e)<EPS && dot(m[0]-e,m[1]-e)<EPS);\n\t});\n}\nval_t distanceSS(const VP &s,const VP &t){\n\treturn intersectSS(s,t)) ? 0 : min(\n\t\taccumulate(s.begin(),s.end(),DBL_MAX,[&](val_t S,const P &e){return min(S,distanceSP(t,e));}),\n\t\taccumulate(t.begin(),t.end(),DBL_MAX,[&](val_t S,const P &e){return min(S,distanceSP(s,e));})\n\t);\n}\nint main(){\n\tint n;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tdouble sx,sy,ex,ey;\n\t\tscanf(\"%lf%lf%lf%lf\",&sx,&sy,&ex,&ey);\n\t\tVP s={P(sx,sy),P(ex,ey)};\n\t\tauto ra0=make_range(0,n);\n\t\tprintf(\"%f\\n\",accumulate(ra0.begin(),ra0.end(),DBL_MAX,[&](val_t S,int _)->val_t{\n\t\t\tint f=0;\n\t\t\tdouble x1,y1,x2,y2,h;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf\",&x1,&y1,&x2,&y2,&h);\n\t\t\tVP a;\n\t\t\tfor(auto &x:{x1,x2})for(auto &y:{y1,y2})a.emplace_back(x,y);\n\t\t\tswap(a[2],a[3]);\n\t\t\tauto ra1=make_range(0,4);\n\t\t\tval_t d=accumulate(ra1.begin(),ra1.end(),DBL_MAX,[&](val_t S,int i){\n\t\t\t\tf+=cross(a[i]-s[0],a[(i+1)%4]-s[0])<EPS;\n\t\t\t\treturn min(S,distanceSS(s,{a[i],a[(i+1)%4]}));\n\t\t\t});\n\t\t\treturn min(S,\n\t\t\t\tf==4 ? 0 : //inside\n\t\t\t\td>h ? (h*h+d*d)/h/2 :\n\t\t\t\td\n\t\t\t);\n\t\t}));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > 0) return 1;\n  if(cross(b,c) < 0) return -1;\n  if(dot(b,c) < 0) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n  ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < 0) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < 0) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  }\n\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\n\ndouble cal(L a,L b,double h){\n  double d=getDistanceSS(a,b);\n  if(h>d)return d;\n  return (h*h+d*d)/2/h;\n}\n\nint main(){\n  int n;\n\n  while(cin>>n,n){\n    double ans=1e9;\n    P s,e;\n    double minx,maxx,miny,maxy,h;\n    cin>>s.x>>s.y>>e.x>>e.y;\n    for(int i=0;i<n;i++){\n      cin>>minx>>miny>>maxx>>maxy>>h;\n      if(minx<=s.x&&s.x<=maxx&&miny<=s.y&&s.y<=maxy)ans=0;\n      if(minx<=e.x&&e.x<=maxx&&miny<=e.y&&e.y<=maxy)ans=0;\n      ans=min(ans,cal(L(s,e),L(P(minx,miny),P(minx,maxy)),h));\n      ans=min(ans,cal(L(s,e),L(P(minx,maxy),P(maxx,maxy)),h));\n      ans=min(ans,cal(L(s,e),L(P(maxx,maxy),P(maxx,miny)),h));\n      ans=min(ans,cal(L(s,e),L(P(maxx,miny),P(minx,miny)),h));\n    }\n    printf(\"%.8lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ninline double sq(double x) { return x * x; }\n\nstruct point {\n    double x, y, z;\n    point() {}\n    point(double x, double y, double z): x(x), y(y), z(z) {}\n    point operator + (const point& o) const { return point(x+o.x, y+o.y, z+o.z); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y, z-o.z); }\n    point operator * (const double a) const { return point(x*a,   y*a,   z*a); }\n};\n\ndouble fabs(point p) { return sqrt(sq(p.x) + sq(p.y) + sq(p.z)); }\ndouble dist(point p, point q) { return fabs(p - q); }\ndouble dot(point p, point q) { return p.x*q.x + p.y*q.y + p.z*q.z; }\npoint cross(point p, point q) {\n    return point(\n        p.y*q.z - p.z*q.y,\n        p.z*q.x - p.x*q.z,\n        p.x*q.y - p.y*q.x\n    );\n}\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\ndouble dist_point_line(point p, line l) {\n    if (dot(l.b - l.a, p - l.a) >= 0 && dot(l.a - l.b, p - l.b) >= 0) {\n        point h = l.a + (l.b - l.a) * (dot(l.b - l.a, p - l.a) / sq(fabs(l.b - l.a)));\n        return dist(p, h);\n    }\n\n    return min(dist(p, l.a), dist(p, l.b));\n}\n\nint N; double Sx, Sy, Ex, Ey;\nvector<vector<point>> rects;\nvector<line> vs;\n\ndouble solve() {\n    line c(point(Sx, Sy, 0), point(Ex, Ey, 0));\n    for (vector<point> r : rects) {\n        for (int i = 0; i < r.size(); ++i) {\n            for (int j = i+1; j < r.size(); ++j) {\n                double c1 = cross(c.b - c.a, r[i] - c.a).z * cross(c.b - c.a, r[j] - c.a).z;\n                double c2 = cross(r[j] - r[i], c.a - r[i]).z * cross(r[j] - r[i], c.b - r[i]).z;\n                if (c1 < 0 && c2 < 0) {\n                    return 0;\n                } else if (c1 * c2 == 0) {\n                    double d1 = dist_point_line(r[i], c);  \n                    double d2 = dist_point_line(r[j], c);  \n                    double d3 = dist_point_line(c.a, line(r[i], r[j]));  \n                    double d4 = dist_point_line(c.b, line(r[i], r[j]));  \n                    if (min({d1, d2, d3, d4}) == 0) {\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n\n    double l = 0, r = 1050;\n    for (int g = 0; g < 100; ++g) {\n        double m = (l + r) / 2;\n\n        line c(point(Sx, Sy, m), point(Ex, Ey, m));\n\n        bool ok = true;\n        for (line p : vs) {\n            if (dist_point_line(p.a, c) <= m || dist_point_line(p.b, c) <= m)\n                ok = false;\n            if (dist_point_line(c.a, p) <= m || dist_point_line(c.b, p) <= m)\n                ok = false;\n            if (m < p.a.z) p.a.z = p.b.z = m;\n            if (dist_point_line(p.a, c) <= m || dist_point_line(p.b, c) <= m)\n                ok = false;\n            if (dist_point_line(c.a, p) <= m || dist_point_line(c.b, p) <= m)\n                ok = false;\n        }\n\n        (ok ? l : r) = m;\n    }\n\n    return (l + r) / 2;\n}\n\nint main(void) {\n    cout << fixed << setprecision(4);\n    while (true) {\n        cin >> N; if (N == 0) break;\n        cin >> Sx >> Sy >> Ex >> Ey;\n        vs.clear();\n        rects.clear();\n        for (int i = 0; i < N; ++i) {\n            double minx, miny, maxx, maxy, h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            vs.emplace_back(point(minx, miny, h), point(minx, maxy, h));\n            vs.emplace_back(point(minx, miny, h), point(maxx, miny, h));\n            vs.emplace_back(point(minx, maxy, h), point(maxx, maxy, h));\n            vs.emplace_back(point(maxx, miny, h), point(maxx, maxy, h));\n\n            vector<point> vv;\n            vv.emplace_back(minx, miny, h);\n            vv.emplace_back(minx, maxy, h);\n            vv.emplace_back(maxx, miny, h);\n            vv.emplace_back(maxx, maxy, h);\n            rects.push_back(vv);\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<double, double> PDD;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nPDD operator-(const PDD &a, const PDD &b) {\n  return PDD(a.fi - b.fi, a.se - b.se);\n}\n\ndouble len(PDD p) {\n  return sqrt(p.fi * p.fi + p.se * p.se);\n}\n\ndouble dot(PDD a, PDD b) {\n  return a.fi * b.fi + a.se * b.se;\n}\n\ndouble cross(PDD a, PDD b) {\n  return a.fi * b.se - a.se * b.fi;\n}\n\ndouble distance(PDD p1, PDD p2, PDD q1, PDD q2) {\n  if (cross(p2 - p1, q1 - p1) * cross(p2 - p1, q2 - p1) < 0 && cross(q2 - q1, p1 - q1) * cross(q2 - q1, p2 - q1) < 0) {\n    return 0;\n  } else {\n    double mini = INF;\n    if (dot(p2 - p1, q1 - p1) < 1e-7) minch(mini, len(q1 - p1));\n    else if (dot(p1 - p2, q1 - p2) < 1e-7) minch(mini, len(q1 - p2));\n    else minch(mini, abs(cross(p2 - p1, q1 - p1)) / len(p2 - p1));\n\n    if (dot(p2 - p1, q2 - p1) < 1e-7) minch(mini, len(q2 - p1));\n    else if (dot(p1 - p2, q2 - p2) < 1e-7) minch(mini, len(q2 - p2));\n    else minch(mini, abs(cross(p2 - p1, q2 - p1)) / len(p2 - p1));\n\n    if (dot(q2 - q1, p1 - q1) < 1e-7) minch(mini, len(p1 - q1));\n    else if (dot(q1 - q2, p1 - q2) < 1e-7) minch(mini, len(p1 - q2));\n    else minch(mini, abs(cross(q2 - q1, p1 - q1)) / len(q2 - q1));\n\n    if (dot(q2 - q1, p2 - q1) < 1e-7) minch(mini, len(p2 - q1));\n    else if (dot(q1 - q2, p2 - q2) < 1e-7) minch(mini, len(p2 - q2));\n    else minch(mini, abs(cross(q2 - q1, p2 - q1)) / len(q2 - q1));\n\n    return mini;\n  }\n}\n\nint main(){\n  int n;\n  while(cin >> n, n) {\n    PDD s, e;\n    cin >> s.fi >> s.se >> e.fi >> e.se;\n\n    double ans = INF;\n    bool ok = true;\n    rep(i, n) {\n      PDD mi, ma;\n      double h;\n      cin >> mi.fi >> mi.se >> ma.fi >> ma.se >> h;\n      double mini = INF;\n      minch(mini, distance(s, e, mi, PDD(ma.fi, mi.se)));\n      minch(mini, distance(s, e, mi, PDD(mi.fi, ma.se)));\n      minch(mini, distance(s, e, ma, PDD(ma.fi, mi.se)));\n      minch(mini, distance(s, e, ma, PDD(mi.fi, ma.se)));\n      minch(mini, distance(s, e, mi, ma));\n\n      if (mini < h) {\n        minch(ans, mini);\n      } else {\n        double high = 1000, low = mini, mid;\n        rep(j, 100) {\n          mid = (high + low) / 2;\n          if ((mid - h) * (mid - h) + mini * mini >= mid * mid) low = mid;\n          else high = mid;\n        }\n        minch(ans, low);\n      }\n    }\n\n    printf(\"%.10f\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = max(a, b);\n#define chmin(a, b) a = min(a, b);\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\n\nconst double EPS = 1e-10;\ntemplate<class T> bool eq(T a, T b){ return abs(a - b) < EPS; }\n\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0):x(x), y(y){}\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\tdouble abs() const { return sqrt(norm()); }\n\tdouble norm() const { return x * x + y * y; }\n\tbool operator < (const Point &p) const { return x != p.x ? p.x : y < p.y; }\n\tbool operator == (const Point &p) const { return (eq<double>(x, p.x) && eq<double>(y, p.y)); }\n};\nusing Vector = Point;\n\ndouble dot(const Vector& a, const Vector& b) { return a.x * b.x + a.y * b.y; } // ????????????a??¨b?????????\ndouble cross(const Vector& a, const Vector& b) { return a.x * b.y - a.y * b.x; } // ????????????a??¨b?????????\ndouble length2(const Point& a) { return a.norm(); } // ??????????????????2???\n// double length(const Point& a) { return a.abs(); } // ???????????????\ndouble length(Point a) {\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\n\nenum ccw_t {\n\tCOUNTER_CLOCKWISE = 1, // p0->p1 ???????¨???????????????????p2\n\tCLOCKWISE = -1, // p0->p1 ????¨???????????????????p2\n\tONLINE_BACK = 2, // p2->p0->p1 ????????§??´????????§p2\n\tONLINE_FRONT = -2, // p0->p1->p2 ????????§??´??????p2\n\tON_SEGMENT = 0, // p0->p2->p1 ????????§??????p0p1??????p2\n};\nccw_t ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif ( cross(a, b) > EPS  )  return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS )  return CLOCKWISE;\n\tif ( dot(a, b) < -EPS )    return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(){}\n\tSegment(Point p1, Point p2):p1(p1), p2(p2){}\n};\nusing Line = Segment;\n\n// *** ????????????????????? ***\nbool intersect(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && \n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\nbool intersect(const Segment& s1, const Segment& s2) { \n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// *** ?????¢ ***\ndouble getDistance(Point& a, Point& b) { // ???a??¨???b????????¢\n\treturn length(a - b);\n}\ndouble getDistanceLP(Line& l, Point& p) { // ??´???s??¨???p????????¢\n\treturn length(cross(l.p2 - l.p1, p - l.p1) / length(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) { // ??????s??¨???p????????¢\n\tif( dot(s.p2 - s.p1, p - s.p1) < EPS ) return length(p - s.p1);\n\tif( dot(s.p1 - s.p2, p - s.p2) < EPS ) return length(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\ndouble getDistanceSS(Segment s1, Segment s2) {\n\tif( intersect(s1, s2) ) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t   min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nclass Rectangle { // ????????¢\npublic:\n\t// 3 2\n\t// 0 1 (???????¨??????????????????¢??????????????????????????¨)\n\tvector<Point> p; // ?????????????????????????????¨\n\tRectangle(vector<Point>&p):p(p) {\n\t\trep(i, 3) reps(j, i + 1, 4) { //????????????????????????????????§???????????????????\n\t\t\tint cnt = 0;\n\t\t\trep(k, 4) if(k != i && k != j) {\n\t\t\t\tcnt += ccw(p[i], p[j], p[k]) == COUNTER_CLOCKWISE;\n\t\t\t}\n\t\t\tif(cnt == 2) {\n\t\t\t\tswap(p[i + 1], p[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbool intersect(const Segment& s) { // ??????s??¨????????¢????°?????????¨???1??????????????????????????°true\n\t\tbool flag = false;\n\t\trep(i, 4) flag |= ::intersect(s, Segment(p[i], p[(i + 1) % 4]));\n\t\treturn flag;\n\t}\n\tbool contain(const Point& pp) { // ???pp???????????¢????????????????????°(??????????????????)true\n\t\tbool flag = true;\n\t\trep(i, 4) flag &= ccw(p[i], p[(i + 1) % 4], pp) == COUNTER_CLOCKWISE;\n\t\treturn flag;\n\t}\n\tbool contain(const Segment& s) { // ??????s???????????¢????????????????????°(??????????????????)true\n\t\treturn contain(s.p1) && contain(s.p2);\n\t}\n};\n\n\n\nint main(void) {\n\t\n\twhile(1) {\n\t\tint N; scanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tdouble sx, sy, ex, ey; scanf(\"%lf %lf %lf %lf\", &sx, &sy, &ex, &ey);\n\t\tdouble minx[55], miny[55], maxx[55], maxy[55], h[55];\n\t\trep(i, N) scanf(\"%lf %lf %lf %lf %lf\", &minx[i], &miny[i], &maxx[i], &maxy[i], &h[i]);\n\n\t\tSegment L(Point(sx, sy), Point(ex, ey));\n\n\t\tdouble ans = INF;\n\t\trep(i, N) {\n\t\t\t//???????¨???????????????????\n\t\n\t\t\tvector<Point> tmp({Point(minx[i], miny[i]), Point(maxx[i], miny[i]), Point(maxx[i], maxy[i]), Point(minx[i], maxy[i])});\n\t\t\tRectangle rec(tmp);\n\t\t\tif(rec.intersect(L) || rec.contain(L)) {\n\t\t\t\tans = 0.0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdouble d = INF;\n\t\t\t// chmin(d, getDistanceSP(L, Point(minx[i], miny[i])));\n\t\t\tchmin(d, getDistanceSS(L, Segment(Point(minx[i], miny[i]), Point(minx[i], maxy[i]))));\n\t\t\t// cout << d << endl;\n\t\t\t// chmin(d, getDistanceSP(L, Point(maxx[i], miny[i])));\n\t\t\tchmin(d, getDistanceSS(L, Segment(Point(minx[i], maxy[i]), Point(maxx[i], maxy[i]))));\n\n\t\t\t// cout << d << endl;\n\t\t\t// chmin(d, getDistanceSP(L, Point(maxx[i], maxy[i])));\n\t\t\tchmin(d, getDistanceSS(L, Segment(Point(maxx[i], maxy[i]), Point(maxx[i], miny[i]))));\n\n\t\t\t// cout << d << endl;\n\t\t\t// chmin(d, getDistanceSP(L, Point(minx[i], maxy[i])));\n\t\t\tchmin(d, getDistanceSS(L, Segment(Point(maxx[i], miny[i]), Point(minx[i], miny[i]))));\n\n\t\t\t// cout << d << endl;\n\n\t\t\t// double r;\n\t\t\t// if(d <= h[i]) r = d;\n\t\t\t// else r = (d * d + h[i] * h[i]) / (2 * h[i]);\n\n\t\t\tdouble r = (d * d + h[i] * h[i]) / (2 * h[i]);\n\t\t\tif(r < h[i]) r = d;\n\n\t\t\tchmin(ans, r);\n\t\t}\n\t\tprintf(\"%.9f\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <cfloat>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1e-9 //許容される誤差の程度\n\ntypedef complex<double> point;\ntypedef vector<point> polygon;\ntypedef pair<point, point> seg;\n\ndouble dot(point va, point vb){\n\treturn real(va) * real(vb) + imag(va) * imag(vb);\n}\n\ndouble cross(point va, point vb){\n\treturn real(va) * imag(vb) - imag(va) * real(vb);\n}\n\n//直線と点の距離\ndouble distance_l_p(point a, point b, point c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n//線分と点の距離\ndouble distance_ls_p(point a, point b, point c){\n\tif( dot(b - a, c - a) <= 0.0 ) return abs(c - a);\n\tif( dot(a - b, c - b) <= 0.0 ) return abs(c - b);\n\treturn distance_l_p(a, b, c);\n}\n\n//多角形と点の内包判定。\n//AOJ 0143などで使用。\nbool contains(polygon plg, point pt){\n\tint cnt = 0;\n\tdouble y = imag(pt);\n\n\tfor(int i = 0; i < plg.size(); ++i){\n\t\tint j = (i + 1 == plg.size() ? 0: i + 1);\n\n\t\tif( distance_ls_p(plg[i], plg[j], pt) <= EPS ){\n\t\t\treturn true;\n\t\t}\n\n\t\tdouble dyi = imag(plg[i]) - y;\n\t\tdouble dyj = y - imag(plg[j]);\n\t\tdouble tx = (dyi * real(plg[j]) + dyj * real(plg[i])) / (dyi + dyj);\n\n\t\tif(imag(plg[i]) >= y && imag(plg[j]) < y){\n\t\t\tif( tx < real(pt) ) ++cnt;\n\t\t}\n\t\telse if(imag(plg[i]) < y && imag(plg[j]) >= y){\n\t\t\tif( tx < real(pt) ) ++cnt;\n\t\t}\n\t}\n\t\n\treturn (cnt % 2 != 0);\n}\n\n//線分同士の交点判定。\n//交点による線分1の内分比を返す。\n//交点は (1.0-t)*pa1 + t*pa2 で求められる。\n//戻り値が0なら交点はpa1、戻り値が1なら交点はpa2に一致。\n//交点がないときはDBL_MAXでも返しておく。\n//AOJ 2003で類似のものを使用。\n//そこそこ短くて便利なので一応入れてみたけど、要らないかも。\n//なお、4点が同一直線上にある場合には正確に判定できない。\ndouble intersectSS2(point pa1, point pa2, point pb1, point pb2){\n\tpoint da12 = pa2 - pa1;\n\tpoint db21 = pb1 - pb2;\n\tpoint dab1 = pb1 - pa1;\n\n\tdouble D = cross(da12, db21);\t//符号に注意\n\n\tif(abs(D) > EPS){\n\t\tdouble t = cross(dab1, db21) / D;\n\t\tdouble s = cross(da12, dab1) / D;\n\t\t\n\t\tif( (-EPS < t && t < 1.0 + EPS) && (-EPS < s && s < 1.0 + EPS) ){\n\t\t\treturn t;\t//前半は交点が線分1に含まれるか、後半は線分2に含まれるかどうか\n\t\t}\n\t}\n\treturn DBL_MAX;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の距離\n//（交差している場合の距離は0）\ndouble distance_ls_ls(point a1, point a2, point b1, point b2)\n{\n\tif( intersectSS2(a1, a2, b1, b2) == DBL_MAX)\n\t\treturn min( min(distance_ls_p(a1, a2, b1), distance_ls_p(a1, a2, b2)),\n\t\t\t\t\tmin(distance_ls_p(b1, b2, a1), distance_ls_p(b1, b2, a2)) );\n\telse\n\t\treturn 0;\n}\n\ndouble solve(int N, point start, point goal, vector<polygon> blocks, vector<double> heights){\n\t\n\tvector<double> maxrad;\n\t\n\tfor(int i = 0; i < N; i++)\n\t\tif( contains(blocks[i], start) && contains(blocks[i], goal) )\n\t\t\treturn 0;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\t\n\t\tdouble mindis = 1e9;\n\t\t\n\t\tfor(int j = 0; j < 4; j++)\n\t\t\tmindis = min(mindis, distance_ls_ls(start, goal, blocks[i][j], blocks[i][(j+1)%4]));\n\t\t\n\t\tif( mindis > heights[i] )\n\t\t\tmaxrad.push_back( (mindis*mindis + heights[i]*heights[i])/(2*heights[i]) );\n\t\telse\n\t\t\tmaxrad.push_back(mindis);\n\t}\n\t\n\tdouble res = 1e9;\n\t\n\tfor(int i = 0; i < N; i++)\n\t\tres = min(res, maxrad[i]);\n\t\t\n\treturn res;\n}\n\nint main(){\n\n\tint N;\n\t\n\twhile( cin >> N, N ){\n\t\tdouble ax, ay, bx, by, h;\n\t\tpoint start, goal;\n\t\tvector<polygon> blocks;\n\t\tvector<double> heights;\n\t\t\n\t\tblocks.resize(N);\n\t\t\n\t\tcin >> ax >> ay >> bx >> by;\t\n\t\tstart.real() = ax;\tstart.imag() = ay;\n\t\tgoal.real() = bx;\tgoal.imag() = by;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> ax >> ay >> bx >> by >> h;\n\t\t\t\n\t\t\tblocks[i].push_back(point(ax, ay));\n\t\t\tblocks[i].push_back(point(bx, ay));\n\t\t\tblocks[i].push_back(point(bx, by));\n\t\t\tblocks[i].push_back(point(ax, by));\n\t\t\theights.push_back(h);\n\t\t}\n\t\t\n\t\tcout << solve(N, start, goal, blocks, heights) << endl;\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS 1e-10\n#define EQ(a,b) (abs(a - b) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n//??????\ndouble cross (P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n//??????\ndouble dot (P a, P b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//??´???\nbool is_orthogonal(P a1, P a2, P b1, P b2) {\n    return EQ( dot(a1 - a2, b1 - b2), 0.0);\n}\n\n//??????\nbool is_parallel(P a1, P a2, P b1, P b2) {\n    return EQ( cross(a1 - a2, b1 - b2), 0.0);\n}\n\n//??´??????\nbool is_point_on_vector(P a, P b, P c) {\n    return EQ( cross(a - c, c - b), 0.0);\n}\n\n//?????????\nbool is_point_on_line (P a, P b, P c) {\n    return (abs(a - c) + abs(c - b) < abs(a - b) + EPS);\n}\n\n//?§?????????????????????¢????°???°?????\\??????????????§\ndouble angle (P a, P b, P p) {\n    return (acos(dot(a-p,b-p) / (abs(a-p) * abs(b-p))) * 180.0 / M_PI);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool is_intersected_l(P a1, P a2, P b1, P b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distance_l_p(P a, P b, P c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2 - a1; P b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(P a, P b, P c) {\n    if ( dot(b-a, c-a) < EPS ) return fabs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return fabs(c-b);\n    return abs(cross(b-a, c-a)) / fabs(b-a);\n}\n\n/***************************************\n *\n * 2??????????????´?????¨??????????????????????????¨?????????\n *\n * a, b ?????´???\n * p    ????????????\n *\n ***************************************/\nP crossNormalVector (P a, P b, P p) {\n    double t = dot(b-a, p-a) / (abs(b-a) * abs(b - a));\n    return a + t * (b - a);\n}\n\ndouble calc (double h, double r) {\n    if (h > r) h = r;\n    // cout << \"# \"<< h << \" \" << r << endl;\n    double x = sqrt(h * h + r * r) / 2.;\n    double y = x * tan((0.5 * M_PI) - atan((h / r)));\n    double res = sqrt(x * x + y * y);\n    // cout << r / x << endl;\n    // cout << \"# > \" << x << \" \" << y << endl;\n    // cout << res << endl;\n    return res;\n}\n\nint main ()\n{\n    int n;\n    while (cin >> n, n) {\n        double sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        P s(sx, sy), e(ex, ey);\n\n        double res_h = 1000.;\n        while (n--) {\n            // cout << \"Count # \" << n << endl;\n\n            double minx, miny, maxx, maxy;\n\n            double h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            vector<P> v = { P(minx, miny), P(minx, maxy), P(maxx, maxy), P(maxx, miny)};\n\n            if (minx <= s.real() && s.real() <= maxx && miny <= s.imag() && s.imag() <= maxy) res_h = 0.;\n            if (minx <= e.real() && e.real() <= maxx && miny <= e.imag() && e.imag() <= maxy) res_h = 0.;\n\n            for (int i = 0; i < 4; i++) {\n                int anf = (i + 1) % 4, bfr = (i + 4 - 1) % 4;\n                int now = i;\n\n                if (is_intersected_ls(e, s, v[now], v[anf])) res_h = 0.;\n                if (is_intersected_ls(e, s, v[now], v[bfr])) res_h = 0.;\n\n                // cout << \"DBG > \" << min(v[now].real(), v[anf].real()) << \" \" << max(v[now].real(), v[anf].real()) << endl;\n                // cout << \"      \" << min(v[now].imag(), v[anf].imag()) << \" \" << max(v[now].imag(), v[anf].imag()) << endl;\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[anf], s)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[bfr], s)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[anf], e)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[bfr], e)));\n                // res_h = min(res_h, calc(h, min(abs(minx - s.real()), abs(maxx - s.real()))));\n                // res_h = min(res_h, calc(h, min(abs(miny - s.imag()), abs(maxy - s.imag()))));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[now])));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[anf])));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[bfr])));\n            }\n        }\n\n        cout << res_h << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ACM-ICPCà\\I2008 E. åÊ]ªµ\n\n#include <iostream>\n#include <complex>\n#include <stdio.h>\n\nusing namespace std;\n\ntypedef complex<double> P;\ndouble EPS = 1e-8;\n\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\n\ndouble dist(P la, P lb, P p){\n\tif(dot(lb-la,p-la)<EPS) return abs(p-la);\n\tif(dot(la-lb,p-lb)<EPS) return abs(p-lb);\n\treturn abs(cross(lb-la,p-la)) / abs(lb-la);\n}\n\nbool crossLine(P la, P lb, P ma, P mb){\n\treturn cross(lb-la,ma-la)*cross(lb-la,mb-la)<0&&\n\t\tcross(mb-ma,la-ma)*cross(mb-ma,lb-ma)<0;\n}\n\ndouble distSquare(P la, P lb, double ma, double mb, double Ma, double Mb){\n\tP L[2]; L[0] = la, L[1] = lb;\n\tP M[4]; M[0] = P(ma,mb); M[1] = P(Ma,mb); M[2] = P(Ma,Mb); M[3] = P(ma,Mb);\n\tdouble a = dist(L[0], L[1], M[0]);\n\tfor(int i=1;i<4;i++){\n\t\tdouble b = dist(L[0], L[1], M[i]);\n\t\tif(a>b) a = b;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tdouble b = dist(M[i],M[(i+1)%4],L[j]);\n\t\t\tif(a>b) a = b;\n\t\t}\n\t}\n\treturn a;\n}\n\nbool rightup(P a, P b){\n\treturn real(a)<real(b)&&imag(a)<imag(b);\n}\n\nbool crossSquare(P la, P lb, double ma, double mb, double Ma, double Mb){\n\tif(crossLine(la,lb,P(ma,mb),P(Ma,mb))) return true;\n\tif(crossLine(la,lb,P(ma,mb),P(ma,Mb))) return true;\n\tif(crossLine(la,lb,P(Ma,mb),P(Ma,Mb))) return true;\n\tif(crossLine(la,lb,P(ma,Mb),P(Ma,Mb))) return true;\n\tif(rightup(P(ma,mb),la)&&rightup(la,P(Ma,Mb))\n\t\t&&rightup(P(ma,mb),lb)&&rightup(lb,P(Ma,Mb))) return true;\n\treturn false;\n}\n\nint main(){\n\tint N;\n\tP a, b;\n\tint mx[50], my[50], Mx[50], My[50], h[50];\n\twhile(cin >> N, N){\n\t\tint sx, sy, ex, ey; cin >> sx >> sy >> ex >> ey;\n\t\ta = P(sx,sy); b = P(ex,ey);\n\t\tfor(int i=0;i<N;i++)\n\t\t\tcin >> mx[i] >> my[i] >> Mx[i] >> My[i] >> h[i];\n\t\tbool flag = false;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(crossSquare(a, b, mx[i], my[i], Mx[i], My[i])){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag) { cout << 0 << endl; continue; }\n\t\tdouble r = 10000;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tdouble d = distSquare(a,b,mx[i],my[i],Mx[i],My[i]);\n\t\t\tif(d<h[i]) { if(d<r) r = d; }\n\t\t\telse    {\n\t\t\t\tdouble tmp = (d*d+h[i]*h[i])/(2*h[i]);\n\t\t\t\tif(tmp<r) r = tmp;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8lf\\n\", r);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XYツ催?標\n#define X real()\n#define Y imag()\n\n// * ツ点ツづ個表ツ個サ\ntypedef complex<double> P;\n\n// * ツ仰鳴容ツつキツづゥツ古ォツ債キツε?\nconst double EPS = 1e-10;\n// * Infinity\nconst double INF = 1e12;\n// * ツ円ツ偲シツ猟ヲ\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> ツづ個渉?渉伉づーツ津ィツ義ツつキツづゥ\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 2ツ湘ヲツつキツづゥ\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2ツ点ツ甘板づ個仰猟猟」\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2ツづつづ個スツカツδ可ーツつェツ督卍つオツつ「ツつゥツづ?つ、ツつゥ\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2ツづつづ個ベツクツトツδ仰つェツ督卍つオツつ「ツつゥツづ?つ、ツつゥ\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ツベツクツトツδ蟻ツづ個単ツ暗環ベツクツトツδ仰づーツ仰?づ淞づゥ\nP unit(P a) {\n\treturn a / abs(a);\n}\n\n// ツベツクツトツδ蟻ツづ個法ツ静シツベツクツトツδ仰づーツ仰?づ淞づゥ\nvector<P> normal(P a) {\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ツベツクツトツδ?a ツづ個単ツ暗環法ツ静シツベツクツトツδ仰づーツ仰?づ淞づゥ\nvector<P> normal_unit(P a) {\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// * ツ禿?静?(dot product) : aツ・b = |a||b|cosツδヲ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * ツ外ツ静?(cross product) : aツ×b = |a||b|sinツδヲ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// CCW : ツ板スツ篠楪計ツ嘉アツづィ (Counter Clock Wise)\n// CW : ツ篠楪計ツ嘉アツづィ (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3ツ点ツつェツづ?つソツづァツ嘉アツづィツづ?つ?づゥツつゥツ陛板つキ, 3ツ点ツつェ1ツ陳シツ静シツづ可湘ヲツづ?づ?つ「ツづゥツづ?つォツづ?ON ツづーツ陛板つキ\nint ccw(const P &a, P b, P c) {\n    b-=a, c-=a;\n    if( cross(b,c) >  EPS ) return CCW; // CCW : ツ板スツ篠楪計ツ嘉アツづィ\n    if( cross(b,c) < -EPS ) return CW;  // CW : ツ篠楪計ツ嘉アツづィ\n    if(dot(b, c) < -EPS )   return +2;  // c--a--b on line\n    if(dot(b, b) + EPS < dot(c, c) ) return -2; // a--b--c on line ???\n    return ON;\n}\n\n// ツδ可ジツアツδ督つゥツづァツ度ツ青板づ鳴陛渉環キツつオツづ?陛板つキ\ndouble to_deg(double rad) {\n\treturn rad * 180.0 / PI;\n}\n\n// ツ度ツ青板つゥツづァツδ可ジツアツδ督づ可陛渉環キツつオツづ?陛板つキ\ndouble to_rad(double deg) {\n\treturn deg * PI / 180.0;\n}\n\n// ツ個エツ点ツづーツ篠イツづ可点 p ツづーツ角ツ度 a (ツδ可ジツアツδ?ツつセツつッツ嘉アツ転ツつウツつケツつスツ点ツづーツ陛板つキ\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// ツ点 a ツづーツ篠イツづ可点 b ツづーツ角ツ度 a (ツδ可ジツアツδ?ツつセツつッツ嘉アツ転ツつウツつケツつスツ点ツづーツ陛板つキ\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// ツ点 a ツつゥツづァ ツ点 b ツづ鳴づ個角ツ度ツづーツ陛板つキ [0,2ツε讃\ndouble dir(P a, P b) {\n\tP p = a - b;\n\tdouble angle = atan2( p.Y , p.X );\n\tif( p.X < 0 ) angle += PI;\n\tif( angle < 0 ) angle += 2.0 * PI;\n\treturn angle;\n}\n\n// ツ静シツ閉ェツクツδ可ス\nstruct Segment{\n    P a, b;\n    Segment(P a_, P b_){\n        a = a_; b = b_;\n    }\n    // ツ点 p ツづ?静シツ閉ェツづ個仰猟猟」ツづーツ陛板つキ.\n    double distance(P p){\n        if( dot(b-a,p-a) < EPS ) return abs(p-a);\n        if( dot(a-b,p-b) < EPS ) return abs(p-b);\n        return abs( cross(b-a,p-a) ) / abs(b-a) ;\n    }\n    // ツ静シツ閉ェ s ツづ?古ーツ債キツつオツづ?つ「ツづゥツつゥツづ?つ、ツつゥツづーツ陛板つキ.\n    bool is_intersection(const Segment& s){\n        return ( ccw(a, b, s.a)   * ccw(a, b, s.b) <= 0 && \n                 ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0 );\n    }\n    // ツ点 p ツつェツ静シツ閉ェツ湘」ツづ可つ?づゥツつゥツづ?つ、ツつゥ\n    bool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n    // ツ静シツ閉ェツづ?静シツ閉ェツづ個仰猟猟」\n    double distance(Segment s) {\n        if( is_intersection(s) ) return 0.0;\n        return min( min(distance(s.a), distance(s.b)), min(s.distance(a), s.distance(b)) );\n    }\n    // ツデツバツッツグツ出ツ療?\n    void print(){\n        printf(\"line(%f,%f,%f,%f);\\n\", a.X ,a.Y, b.X, b.Y );\n    }\n};\n\n// ツ陳シツ静シツづ個表ツ個サ ((*this)[0]) ツづ?((*this)[1]) ツづーツ津環づゥツ陳シツ静シ\nstruct Line : public vector<P> {\n\tLine(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tLine(vector<P> v){\n\t\tpush_back(v[0]); push_back(v[1]);\n\t}\n\tLine(){}\n\t// 2ツ陳シツ静シツづ個陳シツ古ーツ板サツ津ィ\n\tbool orthogonal(const Line& l) {\n\t\treturn equal( dot( (*this)[0] - (*this)[1] , l[0] - l[1] ) , 0.0 );\n\t}\n\t// 2ツ陳シツ静シツづ個閉スツ行ツ板サツ津ィ\n\tbool parallel(const Line& l) {\n\t\treturn equal( cross( (*this)[0] - (*this)[1] , l[0] - l[1] ), 0.0 );\n\t}\n\t// ツ点 p ツつェツ陳シツ静シツ湘」ツづ可湘ヲツづ?づ?つ「ツづゥツつゥ\n\tbool contain(P p) {\n\t\treturn equal( cross( (*this)[1] - (*this)[0] , p - (*this)[0] ) , 0.0 );\n\t}\n\t// ツ陳シツ静シツづ?点 p ツづ個仰猟猟」\n\tdouble distance(P a) {\n\t\tP p1 = (*this)[0];\n\t\tP p2 = (*this)[1];\n\t\treturn abs( cross( p2 - p1 , a - p1) ) / abs(p2 - p1);\n\t}\n\t// ツ陳シツ静シツづ個古ーツ債キツ板サツ津ィ\n\tbool is_intersection(const Line& l) {\n\t\treturn !equal( cross( (*this)[0] - (*this)[1], l[0] - l[1] ) , 0.0 );\n\t}\n\t// ツ陳シツ静シツづ個古ーツ債キツ板サツ津ィツづ?古ーツ点ツ計ツ算\n\tbool intersection(Line l, P& p) {\n\t\tbool result = this->is_intersection( l );\n\t\tif( result ) {\n\t\t\tP a = (*this)[1] - (*this)[0];\n\t\t\tP b = l[1] - l[0];\n\t\t\tp = (*this)[0] + a * cross(b, l[0] - (*this)[0]) / cross(b, a);\n\t\t}else {\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// ツ点 (*this)[0] ツつゥツづァ ツ点 (*this)[1] ツづ鳴づ個角ツ度ツづーツ陛板つキ [0,2ツε讃\n\tdouble get_dir() {\n\t\tP p = (*this)[0] - (*this)[1];\n\t\tdouble angle = atan2( p.Y , p.X );\n\t\tif( p.X < 0 ) angle += PI;\n\t\tif( angle < 0 ) angle += 2.0 * PI;\n\t\treturn angle;\n\t}\n};\n\n// ツ円ツづ個表ツ個サ\nstruct Circle{\n\t// ツ円ツづ個陳?心\n\tP p;\n\t// ツ円ツづ個板シツ径\n\tdouble r;\n\t// ツコツδ督スツトツδ可クツタツづ?渉可甘コツ可サ\n\tCircle(P p_, double r_) { p = p_; r = r_; }\n\t// ツ円ツづ個姪環静?\n\tdouble get_area() { return r * r * PI; }\n\t// ツ円ツ偲シ\n\tdouble circumference() { return 2.0 * r * PI; }\n\t// ツ点 a ツつェツ円ツづ個禿?閉板づ可つ?づゥツつゥツづ?つ、ツつゥ\n\tbool is_inside(P a) { return ( dist(a,p) <= r ); }\n\t// ツ点 a ツつェツ円ツ偲シツ湘」ツづ可つ?づゥツつゥツづ?つ、ツつゥ\n\tbool on_boundary(P a) { return equal( dist(a,p) , r ); }\n\t// ツ角ツ度 [a,b] ツづ個古環づ個陳キツつウツづーツ陛板つキ (a,bツづ債δ可ジツアツδ?\n\tdouble arc(double a, double b) {\n\t\twhile( a > b ) b += 2.0 * PI;\n\t\treturn r * (b - a);\n\t}\n\t// ツ円ツ偲シツ湘」ツづ個点 a,b ツづ個古環づ個陳キツつウツづーツ陛板つキ. \n\t// (ツ円ツ偲シツ湘」ツづ個点ツづ?づ按つ「ツづ?つォツづ? ツ円ツづ個陳?心 p ツづ?点 a ツづーツ個仰づアツづ?古ーツ債キツつキツづゥツ点ツづーツ点 a ツづ?つキツづゥ.ツ点 b ツづ?督ッツ様) \n\tdouble arc(P a, P b){\n\t\tP p1 = a - p;\n\t\tdouble angle1 = atan2( p1.Y , p1.X );\n\t\tif( p1.X < 0 ) angle1 += PI;\n\t\tif( angle1 < 0 ) angle1 += 2.0 * PI;\n\t\tP p2 = b - p;\n\t\tdouble angle2 = atan2( p2.Y , p2.X );\n\t\tif( p2.X < 0 ) angle2 += PI;\n\t\tif( angle2 < 0 ) angle2 += 2.0 * PI;\n\t\treturn this->arc( angle1 , angle2 );\n\t}\n\t// ツ角ツ度 [a,b] ツづ個静ョツ形ツづ個姪環静渉づーツ陛板つキ (a,bツづ債δ可ジツアツδ?\n\tdouble sector(double a, double b) {\n\t\twhile( a > b ) b += 2.0 * PI;\n\t\treturn 0.5 * r * r * (b - a);\n\t}\n\t// ツ円ツ偲シツ湘」ツづ個点 a,b ツづ?円ツづ個陳?心 p ツつゥツづァツづ按づゥツ静ョツ形ツづ個姪環静渉づーツ陛板つキ. \n\t// (ツ円ツ偲シツ湘」ツづ個点ツづ?づ按つ「ツづ?つォツづ? ツ円ツづ個陳?心 p ツづ?点 a ツづーツ個仰づアツづ?古ーツ債キツつキツづゥツ点ツづーツ点 a ツづ?つキツづゥ.ツ点 b ツづ?督ッツ様) \n\tdouble sector(P a, P b){\n\t\tP p1 = a - p;\n\t\tdouble angle1 = atan2( p1.Y , p1.X );\n\t\tif( p1.X < 0 ) angle1 += PI;\n\t\tif( angle1 < 0 ) angle1 += 2.0 * PI;\n\t\tP p2 = b - p;\n\t\tdouble angle2 = atan2( p2.Y , p2.X );\n\t\tif( p2.X < 0 ) angle2 += PI;\n\t\tif( angle2 < 0 ) angle2 += 2.0 * PI;\n\t\treturn this->sector( angle1 , angle2 );\n\t}\n\t// ツ陳シツ静シツづ?円ツづ個仰猟猟」 (ツ円ツづ個陳?心ツづ個点ツづ?陳シツ静シツづ個仰猟猟」 - ツ円ツづ個板シツ径)\n\tdouble distance(Line l){\n\t\treturn l.distance( p ) - r;\n\t}\n\t// ツ点 a ツづーツ津環づゥツ静堋静シツづーツ陛板つキ.\n\tpair<Line,Line> tangent(P a) {\n\t\tpair<Line,Line> pl;\n\t\tif( this->on_boundary( a ) ) { // ツ点 a ツつェツ円ツ偲シツ湘」ツづ可つ?づゥツづ?つォ\n\t\t\tLine l( normal(a - p) ); // ツ法ツ静シツベツクツトツδ?\n\t\t\tl[0] += a;\n\t\t\tl[1] += a;\n\t\t\tpl.first = pl.second = l ;\n\t\t\treturn pl;\n\t\t}else if( !this->is_inside(a) ) { // ツ点 a ツつェツ円ツづ個外ツ堕、ツづ可つ?づゥツづ?つォ\n\t\t\tdouble xp = a.X - p.X;\n\t\t\tdouble yp = a.Y - p.Y;\n\t\t\tdouble A = sqrt( sq(xp) + sq(yp) - sq(r) );\n\t\t\tdouble B = sq(xp) + sq(yp);\n\t\t\tP p1( r * (xp * r + yp * A) / B , r * (yp * r - xp * A) / B );\n\t\t\tP p2( r * (xp * r - yp * A) / B , r * (yp * r + xp * A) / B );\n\t\t\tpl.first = Line( a , p1+p );\n\t\t\tpl.second = Line( a , p2+p );\n\t\t}else{ // ツ点 a ツつェツ円ツづ個禿?堕、ツづ可つ?づゥツづ?つォ\n\t\t\tpl.first = pl.second = Line(INF_P,INF_P);\n\t\t}\n\t\treturn pl;\n\t}\n\t// ツ督卍つオツつ「ツつゥツづ?つ、ツつゥ\n\tbool operator==(const Circle& c) { return (p == c.p && r == c.r) ; };\n\t// 2ツづつづ個円ツづ個暗環置ツ甘鳴係\n\t// 2 ツづつづ個円ツつェツ猟」ツづェツづ?つ「ツづゥ => 0\n\t// 2 ツづつづ個円ツつェツ外ツ静堋つキツづゥ   => 1\n\t// 2 ツづつづ個円ツつェツ古ーツづュツづゥ     => 2\n\t// 2 ツづつづ個円ツつェツ禿?静堋つキツづゥ    => 3 (2ツづつづ個円ツつェツ督卍つオツつ「ツづ?つォツづ債禿?静?\n\t// ツ円ツつェツ甘慊づ慊づェツづ?つ「ツづゥ       => 4\n\tint is_pos(const Circle& c) {\n\t\tdouble d = abs(p - c.p);\n\t\tif( r + c.r + EPS < d ) { // ツ猟」ツづェツづ?つ「ツづゥ\n\t\t\treturn 0;\n\t\t}else if( equal( r + c.r , d ) ) { // ツ外ツ静堋つキツづゥ\n\t\t\treturn 1;\n\t\t}else if( equal( fabs(r-c.r) , d ) ) { // ツ禿?静堋つキツづゥ\n\t\t\treturn 3;\n\t\t}else if( d < fabs(r-c.r) ) { // ツ甘慊づ慊づェツづゥ\n\t\t\treturn 4;\n\t\t}else { // ツ古ーツづュツづゥ\t\n\t\t\treturn 2;\n\t\t}\n\t}\n\t// ツ円ツづ?陳シツ静シツづ個古ーツづュツづゥツ点ツづーツ陛板つキ\n\tpair<P,P> intersection(Line l) {\n\t\tpair<P,P> pp;\n\t\tif( this->distance(l) > EPS ) { // ツ円ツづ?陳シツ静シツづ個古ーツ点ツつェツづ按つ「ツづ?つォ\t\n\t\t\tpp.first = pp.second = INF_P;\n\t\t}else { // ツ円ツづ?陳シツ静シツづ個古ーツ点ツつェツつ?づゥツづ?つォ\n\t\t\tdouble d = l.distance( p );\n\t\t\tdouble angle = -l.get_dir();\n\t\t\t// ツ点 l[0] ツづーツ篠イツづ可点 l[1] ツづ?円ツづ個陳?心ツづーツ嘉アツ転\n\t\t\tP lp = rot2( l[0] , l[1] , angle );\n\t\t\tP cp = rot2( l[0] , p    , angle );\n\t\t\tdouble x1 = cp.X - sqrt( sq(r) - sq(d) );\n\t\t\tdouble x2 = cp.X + sqrt( sq(r) - sq(d) );\n\t\t\tP p1(x1,l[0].Y);\n\t\t\tP p2(x2,l[0].Y);\n\t\t\t// ツ嘉アツ転ツつオツづ?個ウツづ可姪淞つキ\n\t\t\tp1 = rot2( l[0] , p1 , -angle );\n\t\t\tp2 = rot2( l[0] , p2 , -angle );\n\t\t\tpp.first = p1;\n\t\t\tpp.second = p2;\n\t\t}\n\t\treturn pp;\n\t}\n\t// ツデツバツッツグツ出ツ療?\n\tvoid print() { printf(\"circle(%f,%f,%f); \\n\", p.X, p.Y, r ); }\n};\n\n\nint main(){\n\tint N;\n\twhile( cin >> N , N ){\n\t\tint sx, sy, ex, ey;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tP S(sx,sy), E(ex,ey);\n\t\tSegment SE( S , E );\n\t\t\n\t\tbool flag = false;\n\t\tvector<Segment> v;\n\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\tint min_x, min_y, max_x, max_y, h;\n\t\t\tcin >> min_x >> min_y >> max_x >> max_y >> h;\n\t\t\tSegment s1( P(min_x,min_y) , P(min_x,max_y) );\n\t\t\tSegment s2( P(min_x,min_y) , P(max_x,min_y) );\n\t\t\tSegment s3( P(min_x,max_y) , P(max_x,max_y) );\n\t\t\tSegment s4( P(max_x,min_y) , P(max_x,max_y) );\n\t\t\tif( min_x <= sx && sx <= max_x && min_y <= sy && sy <= max_y ){\n\t\t\t\tflag = true;\n\t\t\t}else if( min_x <= ex && ex <= max_x && min_y <= ey && ey <= max_y ){\n\t\t\t\tflag = true;\n\t\t\t}else if( SE.is_intersection(s1) || SE.is_intersection(s2) ){\n\t\t\t\tflag = true;\n\t\t\t}else if( SE.is_intersection(s3) || SE.is_intersection(s4) ){\n\t\t\t\tflag = true;\n\t\t\t}else if( !flag ){\n\t\t\t\tdouble d = min( SE.distance(s1), SE.distance(s2) );\n\t\t\t\td = min( d , min( SE.distance(s3), SE.distance(s4) ) );\n\t\t\t\tP p1(d,0);\n\t\t\t\tP p2(d,h);\n\t\t\t\tv.push_back( Segment(p1,p2) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( flag ){\n\t\t\tcout << 0 << endl;\n\t\t}else{\n\t\t\tdouble low=0, high=1000, mid;\n\t\t\tfor(int i=0 ; i < 100 ; i++ ){\n\t\t\t\tmid = (low+high) / 2.0;\n\t\t\t\tCircle c( P(0,mid) , mid );\n\t\t\t\tbool flag = false;\n\t\t\t\tfor(int j=0 ; j < v.size() ; j++ ){\n\t\t\t\t\tLine l( v[j].a , v[j].b );\n\t\t\t\t\tpair<P,P> pp = c.intersection( l );\n\t\t\t\t\tif( pp.first == pp.second ) continue;\n\t\t\t\t\tif( v[j].contain( pp.first ) || v[j].contain( pp.second ) ){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( flag ){\n\t\t\t\t\thigh = mid;\n\t\t\t\t}else{\n\t\t\t\t\tlow = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%.8f\\n\", mid);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-9;\ntemplate<typename T>\nT sqr(T a) { return a * a; }\n\nstruct search_point {\n\tdouble x, y;\n\tdouble h;\n\tsearch_point(double x_, double y_, double h_) {\n\t\tx = x_; y = y_; h = h_;\n\t}\n};\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tdouble sx, sy, ex, ey;\n\t\tvector<search_point> v;\n\t\tvector<pair<search_point,search_point> > line;\n\t\tvector<pair<search_point,search_point> > lect;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tdouble R = 10000;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble h;\n\t\t\tcin >> x0 >> y0 >> x1 >> y1 >> h;\n\n\t\t\tif(h < EPS)\n\t\t\t\th = EPS;\n\n\t\t\tv.push_back(search_point(x0, y0, h));\n\t\t\tv.push_back(search_point(x1, y1, h));\n\t\t\tv.push_back(search_point(x0, y1, h));\n\t\t\tv.push_back(search_point(x1, y0, h));\n\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x0, y0, 0), search_point(x1, y0, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x1, y0, 0), search_point(x1, y1, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x1, y1, 0), search_point(x0, y1, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x0, y1, 0), search_point(x0, y0, 0)));\n\n\t\t\tlect.push_back(pair<search_point,search_point>(search_point(x0, y0, 0), search_point(x1, y1, 0)));\n\n\t\t\tif(x0 < sx && sx < x1) {\n\t\t\t\tv.push_back(search_point(sx, y0, h));\n\t\t\t\tv.push_back(search_point(sx, y1, h));\n\t\t\t}\n\t\t\tif(y0 < sy && sy < y1) {\n\t\t\t\tv.push_back(search_point(x0, sy, h));\n\t\t\t\tv.push_back(search_point(x1, sy, h));\n\t\t\t}\n\t\t\tif(x0 < ex && ex < x1) {\n\t\t\t\tv.push_back(search_point(ex, y0, h));\n\t\t\t\tv.push_back(search_point(ex, y1, h));\n\t\t\t}\n\t\t\tif(y0 < ey && ey < y1) {\n\t\t\t\tv.push_back(search_point(x0, ey, h));\n\t\t\t\tv.push_back(search_point(x1, ey, h));\n\t\t\t}\n\t\t}\n\n\t\tdouble veclx = (ex - sx);\n\t\tdouble vecly = (ey - sy);\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tdouble d;\n\t\t\tdouble mx, my;\n\t\t\tdouble r;\n\n\t\t\tmx = (v[i].x * sqr(veclx) + v[i].y * veclx * vecly + vecly * (sx * ey - sy * ex)) / (sqr(veclx) + sqr(vecly));\n\t\t\tmy = (v[i].y * sqr(vecly) + v[i].x * vecly * veclx + veclx * (sy * ex - sx * ey)) / (sqr(vecly) + sqr(veclx));\n\t\t\t/*\n\t\t\tif((ey - sy) * mx - (ex - sx) * my + (ex * sy - sx * ey) > EPS) {\n\t\t\t\tcout << \"error\" << \" \" << (sy - ey) * mx - (sx - ex) * my - (ex * sy - sx * ey) << endl;\n\t\t\t\tcout << mx << \",\" << my << endl;\n\t\t\t}\n\t\t\t// */\n\t\t\td = sqrt(sqr(mx - v[i].x) + sqr(my - v[i].y));\n\t\t\tif(mx <= min(sx,ex) - EPS || max(sx,ex) + EPS <= mx || my <= min(sy,ey) - EPS || max(sy,ey) + EPS <= my) {\n\t\t\t\td = min(sqrt(sqr(sx - v[i].x) + sqr(sy -  v[i].y)), sqrt(sqr(ex - v[i].x) + sqr(ey - v[i].y)));\n\t\t\t}\n\t\t\tr = fabs(sqr(min(v[i].h,d)) + sqr(d)) / (2 * v[i].h);\n\t\t\tR = min(R, r);\n\t\t}\n\t\tfor(int i = 0; i < line.size(); i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble s, t;\n\t\t\tx0 = line[i].first.x; y0 = line[i].first.y;\n\t\t\tx1 = line[i].second.x; y1 = line[i].second.y;\n\n\t\t\ts = ((ex - sx) * (y1 - sy) - (ey - sy) * (x1 - sx)) / ((x0 - sx) * (y1 - sy) - (y0 - sy) * (x1 - sx));\n\t\t\tt = ((ex - sx) * (y0 - sy) - (ey - sy) * (x0 - sx)) / ((x1 - sx) * (y0 - sy) - (y1 - sy) * (x0 - sx));\n\n\t\t\tif(s > 0 && t > 0 && s + t >= 1)\n\t\t\t\tR = 0;\n\t\t}\n\t\tfor(int i = 0; i < lect.size(); i++) {\n\t\t\tbool flag0, flag1;\n\t\t\tflag0 = lect[i].first.x < sx && sx < lect[i].second.x && lect[i].first.y < sy && sy < lect[i].second.y;\n\t\t\tflag1 = lect[i].first.x < ex && ex < lect[i].second.x && lect[i].first.y < ey && ey < lect[i].second.y;\n\n\t\t\tif(flag0 | flag1)\n\t\t\t\tR = 0;\n\t\t}\n\t\tprintf(\"%.10f\\n\", R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> C;\nconst ld EPS = 1e-10;\n#define cx real()\n#define cy imag()\n\nll n, sx, sy, ex, ey;\nll x1[100], y[100], x2[100], y2[100], h[100];\nC s, e;\n\nld dot(C a, C b) { return a.cx * b.cx + a.cy * b.cy; }\nld det(C a, C b) { return a.cx * b.cy - a.cy * b.cx; }\nld distanceLineSegmentAndPoint(C a, C b, C c) {\n  if (dot(b-a, c-a) < EPS) return abs(c-a);\n  if (dot(a-b, c-b) < EPS) return abs(c-b);\n  return abs(det(b-a, c-a)) / abs(b-a);\n}\nC intersectionLine(C a1, C a2, C b1, C b2) {\n  C a = a2 - a1, b = b2 - b1;\n  return a1 + a * det(b, b1 - a1) / det(b, a);\n}\nbool isPointOnLineSegment(C a, C b, C c) { return abs(a-c) + abs(c-b) - abs(a-b) < EPS; }\n\nbool check(ld x) {\n  //printf(\"\\n\");\n  for (ll i = 0; i < n; i++) {\n    C c[4];\n    c[0] = C(x1[i], y[i]);\n    c[1] = C(x2[i], y[i]);\n    c[2] = C(x2[i], y2[i]);\n    c[3] = C(x1[i], y2[i]);\n    ld len = 1e10;\n    for (ll j = 0; j < 4; j++) len = min(len, distanceLineSegmentAndPoint(s, e, c[j]));\n    for (ll j = 0; j < 4; j++) len = min(len, distanceLineSegmentAndPoint(c[j], c[(j+1)%4], s));\n    for (ll j = 0; j < 4; j++) len = min(len, distanceLineSegmentAndPoint(c[j], c[(j+1)%4], e));\n    //printf(\"!\");\n    if (x - len < -EPS) continue;\n    ld y = sqrt(x * x - len * len);\n    //printf(\"x: %Lf, len: %Lf, y: %Lf, h: %lld\\n\", x, len, y, h[i]);\n    if (y + h[i] - x > -EPS) return false;\n  }\n  //printf(\"ok\\n\");\n  return true;\n}\n\nint main() {\n  while (scanf(\"%lld\", &n), n) {\n    scanf(\"%lld%lld%lld%lld\", &sx, &sy, &ex, &ey);\n    s = C(sx, sy);\n    e = C(ex, ey);\n    for (ll i = 0; i < n; i++) scanf(\"%lld%lld%lld%lld%lld\", &x1[i], &y[i], &x2[i], &y2[i], &h[i]);\n    bool flag = false;\n    for (ll i = 0; i < n; i++) {\n      if (x1[i] <= sx && sx <= x2[i] &&\n          x1[i] <= ex && ex <= x2[i] &&\n          y[i] <= sy && sy <= y2[i] &&\n          y[i] <= ey && ey <= y2[i]) flag = true, i = n;\n      C c[4];\n      c[0] = C(x1[i], y[i]);\n      c[1] = C(x2[i], y[i]);\n      c[2] = C(x2[i], y2[i]);\n      c[3] = C(x1[i], y2[i]);\n      for (ll j = 0; j < 4; j++) {\n        C temp = intersectionLine(s, e, c[j], c[(j+1)%4]);\n        //printf(\"%Lf, %Lf\\n\", c[j].cx, c[j].cy);\n        //printf(\"%Lf, %Lf\\n\", c[(j+1)%4].cx, c[(j+1)%4].cy);\n        //printf(\">%Lf, %Lf\\n\", temp.cx, temp.cy);\n        if (isPointOnLineSegment(s, e, temp) && isPointOnLineSegment(c[j], c[(j+1)%4], temp)) {\n          flag = true;\n          i = n;\n          break;\n        }\n      }\n    }\n    if (flag) {\n      printf(\"0\\n\");\n      continue;\n    }\n    ld lb = 0.0, ub = 1000.0;\n    while (ub - lb > EPS) {\n      ld mid = (lb + ub) / 2;\n      if (check(mid)) lb = mid;\n      else ub = mid;\n    }\n    printf(\"%Lf\\n\", lb);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ninline double sq(double x) { return x * x; }\n\nstruct point {\n    double x, y, z;\n    point() {}\n    point(double x, double y, double z): x(x), y(y), z(z) {}\n    point operator + (const point& o) const { return point(x+o.x, y+o.y, z+o.z); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y, z-o.z); }\n    point operator * (const double a) const { return point(x*a,   y*a,   z*a); }\n};\n\ndouble fabs(point p) { return sqrt(sq(p.x) + sq(p.y) + sq(p.z)); }\ndouble dist(point p, point q) { return fabs(p - q); }\ndouble dot(point p, point q) { return p.x*q.x + p.y*q.y + p.z*q.z; }\npoint cross(point p, point q) {\n    return point(\n        p.y*q.z - p.z*q.y,\n        p.z*q.x - p.x*q.z,\n        p.x*q.y - p.y*q.x\n    );\n}\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\ndouble dist_point_line(point p, line l) {\n    if (dot(l.b - l.a, p - l.a) >= 0 && dot(l.a - l.b, p - l.b) >= 0) {\n        point h = l.a + (l.b - l.a) * (dot(l.b - l.a, p - l.a) / sq(fabs(l.b - l.a)));\n        return dist(p, h);\n    }\n\n    return min(dist(p, l.a), dist(p, l.b));\n}\n\nint N; double Sx, Sy, Ex, Ey;\nvector<line> vs;\n\ndouble solve() {\n    double l = 0, r = 1050;\n    for (int g = 0; g < 70; ++g) {\n        double m = (l + r) / 2;\n\n        line c(point(Sx, Sy, m), point(Ex, Ey, m));\n        line c0 = c; c0.a.z = c0.b.z = 0;\n\n        bool ok = true;\n        for (line p : vs) {\n            if (m < p.a.z) p.a.z = p.b.z = m;\n            if (dist_point_line(p.a, c) <= m || dist_point_line(p.b, c) <= m)\n                ok = false;\n\n            p.a.z = p.b.z = 0;\n            if (cross(c0.b-c0.a, p.a-c0.a).z * cross(c0.b-c0.a, p.b-c0.a).z <= 0 &&\n                cross(p.b-p.a, c0.a-p.a).z * cross(p.b-p.a, c0.b-p.a).z <= 0)\n                return 0;\n        }\n\n        (ok ? l : r) = m;\n    }\n\n    return (l + r) / 2;\n}\n\nint main(void) {\n    cout << fixed << setprecision(20);\n    while (true) {\n        cin >> N; if (N == 0) break;\n        cin >> Sx >> Sy >> Ex >> Ey;\n        vs.clear();\n        for (int i = 0; i < N; ++i) {\n            double minx, miny, maxx, maxy, h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            minx = max(minx, min(maxx, min(Sx, Ex)));\n            miny = max(miny, min(maxy, min(Sy, Ey)));\n            maxx = min(maxx, max(minx, max(Sx, Ex)));\n            maxy = min(maxy, max(miny, max(Sy, Ey)));\n            vs.emplace_back(point(minx, miny, h), point(minx, maxy, h));\n            vs.emplace_back(point(minx, miny, h), point(maxx, miny, h));\n            vs.emplace_back(point(minx, maxy, h), point(maxx, maxy, h));\n            vs.emplace_back(point(maxx, miny, h), point(maxx, maxy, h));\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tL to(pin(),pin());\n\t\tvector<G> g(n);\n\t\tvd he(n);\n\t\trep(i,n){\n\t\t\tdouble a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d>>he[i];\n\t\t\tg[i].pb(P(a,b));\n\t\t\tg[i].pb(P(c,b));\n\t\t\tg[i].pb(P(c,d));\n\t\t\tg[i].pb(P(a,d));\n\t\t}\n\t\tdouble out=inf;\n\t\trep(i,n){\n\t\t\tif(inconvex(g[i],to[0])||inconvex(g[i],to[1]))out=0;\n\t\t\tdouble mi=inf;\n\t\t\tmi=min(mi,distanceSS(to,L(g[i][0],g[i][1])));\n\t\t\tmi=min(mi,distanceSS(to,L(g[i][1],g[i][2])));\n\t\t\tmi=min(mi,distanceSS(to,L(g[i][2],g[i][3])));\n\t\t\tmi=min(mi,distanceSS(to,L(g[i][3],g[i][0])));\n\t\t\tif(mi<he[i]){\n\t\t\t\tout=min(out,mi);\n\t\t\t}else{\n\t\t\t\tout=min(out,(mi*mi+he[i]*he[i])/2/he[i]);\n\t\t\t}\n\t\t}\n\t\tcout<<shosu(9)<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1e-8\n#define INF 1e8\n\ntypedef complex<double> Point;\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tPoint operator / (const Point &p, const double &a){\n\t\treturn Point(real(p)/a, imag(p)/a);\n\t}\n\tPoint operator * (const Point &p, const double &a){\n\t\treturn Point(real(p)*a, imag(p)*a);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn real(a) == real(b) && real(a) == real(b);\n\t}\n}\n\n\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point>{\n\tLine(){}\n\tLine(const Point &a, const Point &b){\n\t\tpush_back(a); push_back(b);\n\t}\n};\nstruct Circle{\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &c, double r):c(c),r(r){}\n};\n\ndouble dot(const Point &a, const Point &b){\n\treturn real(conj(a) * b);\n}\n\ndouble cross(const Point &a, const Point &b){\n\treturn imag(conj(a)*b);\n}\n\nPoint projection(const Line &l, const Point &p){\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t * (l[0]-l[1]);\n}\n\nint ccw(Point a, Point b, Point c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > 0) return +1;\n\tif(cross(b,c) < 0) return -1;\n\tif(dot(b,c) < 0) return +2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\ndouble distancePP(const Point &a, const Point &b){\n\treturn abs(a-b);\n}\n\nbool intersectSS(const Line &s, const Line &t){\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\t\t\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const Line &s, const Point &p){\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1]-s[0]) < EPS;\n}\n\ndouble distanceSP(const Line &s, const Point &p){\n\tconst Point r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r-p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\nbool intersectLL(const Line &l, const Line &m){\n\treturn abs(cross(l[1]-l[0], m[1]-m[0])) > EPS ||\n\t\t\t\t\tabs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n\nbool inPolygon(const Polygon &g, const Point &p){\n\tdouble sum = 0.0;\n\tint n = g.size();\n\tfor(int i = 0; i < g.size(); i++){\n\t\tint j = (i+1)%n;\n\t\tif(intersectSP(Line(g[i], g[j]), p)) return true;\n\t\tsum += arg((g[j]-p)/(g[i]-p));\n\t}\n\treturn abs(sum) > 1;\n}\n\nint main(void){\n\tint N;\n\tvector<Point> ps;\n\twhile(cin >> N, N){\n\t\tint miss = 0;\n\t\tdouble sx, sy, ex, ey;\n//\t\tvector<Point> ps(N, Point(INF,INF));\n\t\tps.clear();\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tLine root = Line(Point(sx, sy), Point(ex, ey));\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tdouble ax, ay, bx, by, h;\n\t\t\tdouble d = INF;\n\t\t\tcin >> ax>>ay>>bx>>by>>h;\n\t\t\tPolygon g;\n\t\t\tg.push_back(Point(ax,ay));\n\t\t\tg.push_back(Point(bx,ay));\n\t\t\tg.push_back(Point(bx,by));\n\t\t\tg.push_back(Point(ax,by));\n\t\t\t//内部判定\n\t\t\tif(inPolygon(g, root[0]) && inPolygon(g, root[1])) miss = 1;\n\t\t\t//接触判定\n\t\t\tif(intersectSS(root, Line(Point(ax, ay), Point(bx, ay)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(bx, ay), Point(bx, by)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(bx, by), Point(ax, by)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(ax, by), Point(ax, ay)))) miss = 1;\n\t\t\t\n\t\t\t//最小距離\n\t\t\td = min(d, distanceSP(root, Point(ax, ay)));\n\t\t\td = min(d, distanceSP(root, Point(bx, by)));\n\t\t\td = min(d, distanceSP(root, Point(ax, by)));\n\t\t\td = min(d, distanceSP(root, Point(bx, ay)));\n\n\t\t\td = min(d, distanceSP(Line(Point(ax, ay), Point(bx, ay)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(ax, ay), Point(bx, ay)), root[1]));\n\n\t\t\td = min(d, distanceSP(Line(Point(bx, ay), Point(bx, by)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(bx, ay), Point(bx, by)), root[1]));\n\n\t\t\td = min(d, distanceSP(Line(Point(bx, by), Point(ax, by)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(bx, by), Point(ax, by)), root[1]));\n\n\t\t\td = min(d, distanceSP(Line(Point(ax, by), Point(ax, ay)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(ax, by), Point(ax, ay)), root[1]));\n//\t\t\tps[i] = Point(d, h);\n\t\t\tps.push_back(Point(d, h));\n\t\t}\n\n\t\tif(miss){\n\t\t\tcout << \"0\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble left = 0, right = 10000;\n\t\tdouble ans = 0;\n\t\twhile(right - left > EPS){\n\t\t\tdouble mid = (left + right) / 2;\n\t\t\tdouble ret = INF;\n\t\t\tfor(int i = 0; i < ps.size(); i++){\n\t\t\t\tret = min(ret, distancePP(Point(0, mid), ps[i]));\n\t\t\t}\n\t\t\tif(ret <= mid + EPS) right = mid;\n\t\t\telse ans = ret, left = mid;\n//\t\t\tprintf(\"%.4lf -> ret:ans = [%.4lf : %.4lf]\\n\", mid, ret, ans);\n\t\t}\n\t\tprintf(\"%.9lf\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P complex<double>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nusing namespace std;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nint main() {\n\n  // 通過する線をLとする。\n  // 全ての辺について、距離を求め、その最小が答えとなる。\n\n  int N;\n  while(cin >>N && N){\n    double sx, sy, ex, ey; cin >>sx >>sy >>ex >>ey;\n    L route = L(P(sx, sy), P(ex, ey));\n    double ans = INF;\n    REP(n, N){\n      double minx, miny, maxx, maxy, h; cin >>minx >>miny >>maxx >>maxy >>h;\n      vector<L> l;\n      l.push_back(L(P(maxx, maxy), P(minx, maxy)));\n      l.push_back(L(P(maxx, maxy), P(maxx, miny)));\n      l.push_back(L(P(minx, miny), P(maxx, miny)));\n      l.push_back(L(P(minx, maxy), P(minx, miny)));\n      if(minx < min(sx, ex) && maxx > max(sx, ex) && miny < min(sy, ey) && maxy > max(sy, ey)) ans = 0.0;\n      REP(i, 4){\n        if(intersectSS(route, l[i])) ans = 0.0;\n        double d = distanceSS(route, l[i]);\n        ans = min(ans, (d * d + h * h) / (2 * h));\n      }\n    }\n    printf(\"%.9lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\nbool is(P a,P b,P c,P d){\n  return (a.real()<=d.real())==(c.real()<=b.real())\n    &&(a.imag()<=d.imag())==(c.imag()<=b.imag())\n    &&cr(a-b,c-b)*cr(a-b,d-b)<=0&&cr(c-d,a-d)*cr(c-d,b-d)<=0;\n}\n\ndouble dt(P a,P b,P c,P d){\n  P p[4]={a,b,c,d};\n  double m=1<<30;\n  for(int i=0;i<2;i++){\n    for(int j=0;j<2;j++){\n      m=min(m,abs(p[i]-p[j+2]));\n    }\n  }\n  for(int i=0;i<2;i++){\n    swap(p[0],p[2]);\n    swap(p[1],p[3]);\n    for(int j=0;j<2;j++){\n      if(dot(p[2+j]-p[0],p[1]-p[0])*dot(p[2+j]-p[1],p[0]-p[1])>0){\n\tm=min(m,fabs(cr(p[2+j]-p[0],p[1]-p[0]))/abs(p[1]-p[0]));\n      }\n    }\n  }\n  //  cout<<a<<' '<<b<<' '<<c<<' '<<d<<' '<<m<<endl;\n  return m;\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    int sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    P s=P(sx,sy),e=P(ex,ey);\n    int ix[50],iy[50],ax[50],ay[50],h[50];\n    P ll[50],hl[50],hh[50],lh[50];\n    bool on=false;\n    for(int i=0;i<n;i++){\n      cin>>ix[i]>>iy[i]>>ax[i]>>ay[i]>>h[i];\n      ll[i]=P(ix[i],iy[i]);\n      hl[i]=P(ax[i],iy[i]);\n      hh[i]=P(ax[i],ay[i]);\n      lh[i]=P(ix[i],ay[i]);\n      on|=is(s,e,ll[i],hl[i])|is(s,e,hl[i],hh[i])|is(s,e,hh[i],lh[i])|is(s,e,lh[i],ll[i]);\n      on|=ix[i]<=min(sx,ex)&&max(sx,ex)<=ax[i]&&iy[i]<=min(sy,ey)&&max(sy,sy)<=ay[i];\n    }\n    if(on){\n      cout<<0<<endl;\n    }else{\n      double m=1<<30;\n      for(int i=0;i<n;i++){\n\tP *p[4]={ll+i,hl+i,hh+i,lh+i};\n\tfor(int j=0;j<4;j++){\n\t  double d=dt(*p[j],*p[(j+1)%4],e,s);\n\t  if(d<h[i]){\n\t    m=min(m,(double)h[i]);\n\t  }else{\n\t    m=min(m,(d*d+h[i]*h[i])/2/h[i]);\n\t  }\n\t}\n      }\n      cout<<fixed<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef complex<double> P;\n\nint N;\ndouble sx,sy,ex,ey,mx,my,Mx,My,h;\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint insected(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\ndouble dist(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\nint main(){\n\twhile(cin>>N&&N){\n\t\tcin>>sx>>sy>>ex>>ey;\n\t\tP s(sx,sy),e(ex,ey);\n\t\tdouble ans=1e9;\n\t\trep(i,N){\n\t\t\tcin>>mx>>my>>Mx>>My>>h;\n\t\t\tP a(mx,my),b(Mx,my),c(Mx,My),d(mx,My);\n\t\t\tif(mx<=min(sx,ex)&&Mx>=max(sx,ex)&&my<=min(sy,ey)&&My>=max(sy,ey))ans=0;\n\t\t\tif(insected(s,e,a,b)||insected(s,e,b,c)||insected(s,e,c,d)||insected(s,e,d,a))ans=0;\n\t\t\telse{\n\t\t\t\tdouble D;\n\t\t\t\tif(Mx<=min(sx,ex))D=min(sx,ex)-Mx;\n\t\t\t\telse if(mx>=max(sx,ex))D=mx-max(sx,ex);\n\t\t\t\telse if(My<=min(sy,ey))D=min(sy,ey)-My;\n\t\t\t\telse if(my>=max(sy,ey))D=my-max(sy,ey);\n\t\t\t\telse D=min(dist(s,e,a),min(dist(s,e,b),min(dist(s,e,c),dist(s,e,d))));\n\t\t\t\tif(h>D)ans=min(ans,D);\n\t\t\t\telse ans=min(ans,(D*D+h*h)/2/h);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4f\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <complex>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\ntypedef vector<P> Poly;\n\n#define x real()\n#define y imag()\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\n\ninline bool near(const P& p,const P& q){ return abs(p-q)<EPS;}\n\ndouble dot(const P& p,const P& q){ return p.x*q.x+p.y*q.y;}\ndouble det(const P& p,const P& q){ return p.x*q.y-p.y*q.x;}\n\nenum LPposit{\n  P_CD = -2, //counter direction\n  P_CW = -1, //clock wise\n  P_OS = 0, //on segment\n  P_CCW = 1, //counter clock wise\n  P_D = 2 //direction\n};\n\ninline double ccw_b(const P& p,const P& q,const P& r){  return det(q-p,r-p);}\n\nLPposit ccw(const P& p, const P& q, const P& r){\n  double c = ccw_b(p,q,r);\n  if(c<-EPS) return P_CW;\n  if(c>EPS) return P_CCW;\n  if(dot(q-p,r-p)<-EPS) return P_CD;\n  if(dot(p-q,r-q)<-EPS) return P_D;\n  return P_OS;\n}\n\ninline double Sabs(const L& l){ return abs(l.first-l.second);}\ninline double LPdist(const L& l,const P& p){ return abs(ccw_b(l.first,l.second,p))/Sabs(l);}\n\ninline double SPdist(L l,P p){\n  double a = abs(l.first-p);\n  double b = abs(l.second-p);\n  double c = Sabs(l);\n  if(b*b+c*c>a*a && a*a+c*c>b*b) return LPdist(l,p);\n  return min(a,b);\n}\n\nbool crossS(const L& p,const L& q){\n  return\n    ccw(p.first,p.second,q.first)*ccw(p.first,p.second,q.second)<=0 &&\n    ccw(q.first,q.second,p.first)*ccw(q.first,q.second,p.second)<=0;\n}\n\ndouble SSdist(const L& a,const L& b){\n  if(crossS(a,b)) return 0;\n  double tmp = min(SPdist(a,b.first),SPdist(a,b.second));\n  return min(tmp, min(SPdist(b,a.first), SPdist(b,a.second)));\n}\n\nP intersect(const L& p,const L& q){\n  P vp = p.second-p.first;\n  P vq = q.second-q.first;\n  P c(det(vp,p.first), det(vq,q.first));\n  return P(det(c, P(vp.x, vq.x)), det(c, P(vp.y, vq.y))) / det(vp, vq);\n}\n\ndouble area(const Poly& p){\n  double ret = 0;\n  int n = p.size();\n  for(int i=0;i<n;++i) ret+=det(p[i],p[(i+1)%n]);\n  return abs(ret)/2;\n}\n\n/* ?????¨??´???????????? */\nvector<P> CLintersect(const L& l,const C& c){\n  vector<P> ret;\n  double di = LPdist(l,c.first);\n  double r = c.second;\n  if(di+EPS > r) return ret;\n  P v = l.second-l.first;\n  v/=abs(v);\n  P rv = v*P(0,1);\n  rv*=di;\n  if(LPdist(l,c.first+rv) > di+EPS) rv=-rv;\n  v*=sqrt(r*r-di*di);\n  ret.push_back(c.first+rv-v);\n  ret.push_back(c.first+rv+v);\n  return ret;\n}\n\n//circle, segment\nvector<P> CSintersect(const L& l,const C& c){\n  vector<P> u = CLintersect(l,c);\n  vector<P> ret;\n  for(int i=0;i<u.size();++i){\n    if(l.first.x <= u[i].x && u[i].x<=l.second.x &&\n       l.first.y <= u[i].y && u[i].y<=l.second.y)\n      ret.push_back(u[i]);\n  }\n  return ret;\n}\n\nvector<P> CCintersect(C c,C d){\n  vector<P> ret;\n  const double dist = abs(c.first-d.first);\n  const double cr = c.second;\n  const double dr = d.second;\n\n  if(dist > cr+dr) return ret;\n  if(dist < abs(cr-dr)) return ret;\n\n  const double s = (cr+dr+dist)/2;\n  const double area = sqrt(s*(s-cr)*(s-dr)*(s-dist));\n  const double h = 2*area/dist;\n\n  P v = d.first - c.first; v/=abs(v);\n  const P m = c.first+sqrt(cr*cr-h*h)*v;\n  const P n = v*P(0,1);\n\n  ret.push_back(m+n*h);\n  ret.push_back(m-n*h);\n  return ret;\n}\n\n/* ?????? */\nnamespace std{\n  bool operator < (const P& a,const P& b){\n    return a.x!=b.x?a.x<b.x : a.y<b.y;\n  }\n}\nPoly convexHull(vector<P> ps){\n  int n = ps.size();\n  sort(ps.begin(),ps.end());\n  Poly ret(2*n);\n  int m=0;\n  for(int i=0;i<n;++i){\n    while(m>=2 && ccw(ret[m-2],ret[m-1],ps[i])<0) --m;\n    ret[m++] = ps[i];\n  }\n  int t = m;\n  for(int i=n-2;i>=0;--i){\n    while(m>=t && ccw(ret[m-2], ret[m-1], ps[i])<0) --m;\n    ret[m++] = ps[i];\n  }\n\n  ret.resize(m-1);\n  return ret;\n}\n\n/* ???????§???¢????????¨?????? O(log n)*/\n/* ?????????????????¨??????1  ?¢?????????????2  ?????¨??????0?????????*/\nint inConvex(const Poly& ps, P p){\n  int n = ps.size();\n  P g = (ps[0]+ps[n/3]+ps[n*2/3])/3.0;\n  if(g==p) return 1;\n  P gp = p-g;\n  int l = 0, r = n;\n  while(l+1<r){\n    int mid = (l+r)/2;\n    P gl = ps[l]-g;\n    P gm = ps[mid]-g;\n    if(det(gl,gm)>0){\n      if(det(gl,gp)>=0 && det(gm,gp)<=0) r=mid;\n      else l = mid;\n    }\n    else{\n      if(det(gl,gp)<=0 && det(gm,gp)>=0) l=mid;\n      else r = mid;\n    }\n  }\n  r%=n;\n  double cr = det(ps[l]-p,ps[r]-p);\n  if(cr==0) return 2;\n  if(cr<0) return 0;\n  return 1;\n}\n\ndouble dst(L crs,double s,double t,double u,double v){\n  vector<P> pos;\n  pos.push_back(P(s,t));\n  pos.push_back(P(s,v));\n  pos.push_back(P(u,t));\n  pos.push_back(P(u,v));\n  double ret = 1000;\n  for(int i=0;i<4;++i)\n    ret = min(ret,SSdist(crs,L(pos[i],pos[(i+1)%4])));\n  return ret;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    double sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    L crs = L(P(sx,sy),P(ex,ey));\n    double R = 1000;\n    for(int i=0;i<n;++i){\n      double s,t,u,v,h;\n      cin >> s >> t >> u >> v >> h;\n      double d = dst(crs,s,t,u,v);\n      double r = (h>=d)?d:((d*d+h*h)/2/h);\n      R = min(R,r);\n    }\n    cout << R << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n#define inf 1.0e9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\tvec2d tmp;\n\t\ttmp.x = this->x + ope.x;\n\t\ttmp.y = this->y + ope.y;\n\t\treturn tmp;\n\t}\n\tvec2d operator-(vec2d ope){\n\t\tvec2d tmp;\n\t\ttmp.x = this->x - ope.x;\n\t\ttmp.y = this->y - ope.y;\n\t\treturn tmp;\n\t}\n\tvec2d operator*(double t){\n\t\tvec2d tmp;\n\t\ttmp.x = this->x * t;\n\t\ttmp.y = this->y * t;\n\t\treturn tmp;\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn x*ope.x + y*ope.y;\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn x*ope.y - y*ope.x;\n\t}\n};\n\nint N;\ndouble sx, sy, ex, ey;\ndouble x1[55], y_1[55], x2[55], y2[55], h[55];\n\nbool onL(vec2d p, vec2d q, vec2d c)\n{\n\treturn ( (c-p).cross(q-p) == 0 && (c-p).dot(q-p) * (c-q).dot(p-q) >= 0);\n}\n\ndouble distPP(vec2d p, vec2d q)\n{\n\treturn sqrt((p-q).dot(p-q));\n}\n\ndouble distLP(vec2d p, vec2d q, vec2d c)\n{\n\tif((c-p).dot(q-p) < 0) return distPP(p, c);\n\tif((c-q).dot(p-q) < 0) return distPP(q, c);\n\t\n\treturn fabs((c-p).cross(q-p) / distPP(p, q));\n}\n\ndouble distLL(vec2d p, vec2d q, vec2d s, vec2d t)\n{\n\tif((q-p).cross(t-s) == 0){\n\t\tif(onL(p, q, s) || onL(p, q, t) || onL(s, t, p) || onL(s, t, q)) return 0.0;\n\t}\n\telse{\n\t\tdouble T = (s-p).cross(t-s) / (q-p).cross(t-s);\n\t\tvec2d c = p + (q-p)*T;\n\t\tif(onL(p, q, c) && onL(s, t, c)) return 0.0;\n\t}\n\t\n\tdouble d = inf;\n\td = min( d, distLP(p, q, s) );\n\td = min( d, distLP(p, q, t) );\n\td = min( d, distLP(s, t, p) );\n\td = min( d, distLP(s, t, q) );\n\t\n\treturn d;\n}\n\nbool check(double R)\n{\n\tdouble lim;\n\tvec2d s(sx, sy), e(ex, ey), p, q;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tif(h[i] >= R) lim = R;\n\t\telse lim = sqrt(2*h[i]*R - h[i]*h[i]);\n\t\t\n\t\tif(distLL(s, e, vec2d(x1[i], y_1[i]), vec2d(x1[i], y2[i]) ) <= lim) return false;\n\t\tif(distLL(s, e, vec2d(x1[i], y2[i]), vec2d(x2[i], y2[i]) ) <= lim) return false;\n\t\tif(distLL(s, e, vec2d(x2[i], y2[i]), vec2d(x2[i], y_1[i]) ) <= lim) return false;\n\t\tif(distLL(s, e, vec2d(x2[i], y_1[i]), vec2d(x1[i], y_1[i]) ) <= lim) return false;\n\t}\n\treturn true;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\t\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x1[i] >> y_1[i] >> x2[i] >> y2[i] >> h[i];\n\t\t}\n\t\t\n\t\tdouble ub = 1000.0, lb = 0.0, mid;\n\t\twhile(ub - lb > 1.0e-9){\n\t\t\tmid = (ub + lb) * 0.5;\n\t\t\tif(check(mid)) lb = mid;\n\t\t\telse ub = mid;\n\t\t}\n\t\tmid = (ub + lb) * 0.5;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(sx >= x1[i] && sx <= x2[i] && sy >= y_1[i] && sy <= y2[i]){\n\t\t\t\tmid = 0.0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.8f\\n\", mid);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Geometry_Library\n#define ___Geometry_Library\n\n// ------ Includes ------ //\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <algorithm>\n\n// ------ Defines ------ //\ntypedef long double GType;\ntypedef std::complex<GType> Point;\ntypedef std::pair<Point, Point> Segment;\n\n// ------ Constants ------ //\nconst GType EPS = 1.0e-10L;\n\n// ------ Functions Level 1 ------ //\nGType dot(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).real();\n}\nGType cross(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).imag();\n}\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint v1 = p2 - p1, v2 = p3 - p1;\n\tif (cross(v1, v2) > EPS) return +1;\n\tif (cross(v1, v2) < -EPS) return -1;\n\tif (dot(v1, v2) < -EPS) return +2;\n\tif (std::norm(v1) < std::norm(v2)) return -2;\n\treturn 0;\n}\n\n// ------ Functions Level 2 ------ //\nbool intersect(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(cross(s1.second - p1, s1.first - p1)) < EPS;\n\treturn (std::abs(s1.first - p1) + std::abs(s1.second - p1) - std::abs(s1.second - s1.first)) < EPS;\n}\nbool intersect(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (!segflag) return cross(s1.second - s1.first, s2.first - s1.first) * cross(s1.second - s1.first, s2.second - s1.first) < EPS;\n\treturn (ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) <= 0 && ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) <= 0);\n}\nPoint projection(const Segment& s1, const Point& p1) {\n\tGType mul = dot(p1 - s1.first, s1.first - s1.second) / norm(s1.first - s1.second);\n\treturn s1.first + (s1.first - s1.second) * mul;\n}\nPoint reflection(const Segment& s1, const Point& p1) {\n\treturn p1 + (projection(s1, p1) - p1) * (GType)(2);\n}\nGType distance(const Point& p1, const Point& p2) {\n\treturn std::abs(p2 - p1);\n}\nGType distance(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(p1 - projection(s1, p1));\n\tconst Point p2 = projection(s1, p1);\n\tif (intersect(s1, p2, true)) return std::abs(p2 - p1);\n\treturn std::min(std::abs(s1.first - p1), std::abs(s1.second - p1));\n}\nGType distance(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (intersect(s1, s2, segflag)) return 0;\n\tif (!segflag) return std::min(distance(s1, s2.first, false), distance(s1, s2.second, false));\n\treturn std::min({ distance(s1, s2.first, true), distance(s1, s2.second, true), distance(s2, s1.first, true), distance(s2, s1.second, true) });\n}\n\n// ------ Functions Level 3 ------ //\nint contain(std::vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tPoint a = v[i] - p, b = v[(i + 1 != v.size() ? i + 1 : 0)] - p;\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() <= EPS && EPS < b.imag() && cross(a, b) < -EPS) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n#endif\n\n#include <vector>\n#include <iomanip>\n#include <iostream>\nusing namespace std;\nint n, sx, sy, ex, ey, xa[55], ya[55], xb[55], yb[55], h[55];\nint main() {\n\twhile (cin >> n, n) {\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tfor (int i = 0; i < n; i++) cin >> xa[i] >> ya[i] >> xb[i] >> yb[i] >> h[i];\n\t\tvector<vector<Point> > v(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tv[i] = { Point(xa[i], ya[i]), Point(xa[i], yb[i]), Point(xb[i], yb[i]), Point(xb[i], ya[i]) };\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 1; i < 100000; i++) {\n\t\t\tPoint pt(sx + (ex - sx) * i / 100000.0, sy + (ey - sy) * i / 100000.0);\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (contain(v[j], pt)) flag = false;\n\t\t\t}\n\t\t}\n\t\tif (!flag) cout << 0 << endl;\n\t\telse {\n\t\t\tdouble ret = 1.0e+9;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tdouble dist = distance(Segment(Point(sx, sy), Point(ex, ey)), Segment(v[i][j], v[i][(j + 1) & 3]), true);\n\t\t\t\t\tdouble r = 0.5 * (h[i] + dist * dist / h[i]);\n\t\t\t\t\tret = min(ret, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << fixed << setprecision(15) << ret << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble EPS = 1e-9;\ntypedef complex<double> P;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nP A[100],B[100];\ndouble H[100];\nP s,e;\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\n\nint N;\n\nbool f(double R){\n\tfor(int i = 0 ; i < N ; i++){\n\t\tdouble h = min(R,H[i]);\n\t\tP a = A[i];\n\t\tP b = P(B[i].real(),A[i].imag());\n\t\tP c = B[i];\n\t\tP d = P(A[i].real(),B[i].imag());\n\t\tL l[] = {L(a,b),L(b,c),L(c,d),L(d,a)};\n\t\tfor(int j = 0 ; j < 4 ; j++){\n\t\t\tdouble rd = sqrt(R*R-(h-R)*(h-R));\n\t\t\tif( distanceSS(L(s,e),l[j]) < rd ){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\nint main(){\n\twhile( cin >> N and N > 0 ){\n\t\t\n\t\ts = in();\n\t\te = in();\n\t\tbool ff = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tA[i] = in();\n\t\t\tB[i] = in();\n\t\t\tcin >> H[i];\n\t\t\tif( A[i].real() <= s.real() and s.real() <= B[i].real()\n\t\t\t\tand  A[i].imag() <= s.imag() and s.imag() <= B[i].imag() \n\t\t\tor A[i].real() <= e.real() and e.real() <= B[i].real()\n\t\t\t\tand  A[i].imag() <= e.imag() and e.imag() <= B[i].imag() ){\n\t\t\t\tff = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ff){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdouble l = 0, r = 100000;\n\t\tfor(int i = 0 ; i < 128 ; i++){\n\t\t\tdouble m = (l+r) / 2;\n\t\t\tif( f(m) ){\n\t\t\t\tl = m;\n\t\t\t}else{\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\",l);\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double INF=1e77;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n};\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\nenum {CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n\tT rdir=cross(b-a,c-a);\n\tif(rdir>0) return CCW;\n\tif(rdir<0) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\nbool intersect(const segment<T> &S1,const segment<T> &S2){\n\tif(max(S1.a.x,S1.b.x)<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\nT dist2(const point<T> &a,const point<T> &b){\n\treturn (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n\tif(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n\tif(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n\treturn (double)cross(S.b-S.a,p-S.a)*cross(S.b-S.a,p-S.a)/dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n\tif(intersect(S1,S2)) return 0;\n\treturn sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n\t\t\t\t\tmin(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tpoint<int> s,t;\n\t\tscanf(\"%d%d%d%d\",&s.x,&s.y,&t.x,&t.y);\n\n\t\tdouble r=INF;\n\t\twhile(n--){\n\t\t\tint x1,y1,x2,y2,h; scanf(\"%d%d%d%d%d\",&x1,&y1,&x2,&y2,&h);\n\t\t\tpoint<int> a={x1,y1},b={x2,y1},c={x2,y2},d={x1,y2};\n\n\t\t\tif(x1<=min(s.x,t.x) && max(s.x,t.x)<=x2\n\t\t\t&& y1<=min(s.y,t.y) && max(s.y,t.y)<=y2) r=0; // ツ板?つェツ静シツ閉ェツづーツ閉「ツづ?づ?つ「ツづゥ\n\n\t\t\t// ツ板?づ個暗ェツ氾板凝淞つ「ツづ?つアツづォツつゥツづァツ静シツ閉ェツづ慊づ?づ個催?短ツ仰猟猟」\n\t\t\tdouble l=INF;\n\t\t\tl=min(l,dist((segment<int>){s,t},(segment<int>){a,b}));\n\t\t\tl=min(l,dist((segment<int>){s,t},(segment<int>){b,c}));\n\t\t\tl=min(l,dist((segment<int>){s,t},(segment<int>){c,d}));\n\t\t\tl=min(l,dist((segment<int>){s,t},(segment<int>){d,a}));\n\n\t\t\tif(l<h) r=min(r,l);\n\t\t\telse    r=min(r,(l*l+h*h)/(2*h));\n\t\t}\n\n\t\tprintf(\"%.9f\\n\",r);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p1;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n//\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tint x=ccw(s.p1,s.p2,pr);\n//\tif(x>=-1&&x<=1) return d;\n\tif(x==0) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t//\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\tif(ccw(q[0],q[1],r)==0){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t//\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\tif(ccw(p[0],p[1],r)==0){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (eq(a, b) || lt(a, b))\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isOrthogonal(Vector a, Vector b) {\n  return eq(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\ndouble getAngle(Point a, Point b, Point c) {\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\nVector getAngleBisectorVector(Point a, Point b, Point c) {\n  Vector v = a - b, w = c - b;\n  v = v / abs(v), w = w / abs(w);\n  Vector u = v + w;\n  return u / abs(u);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2) {\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\nLine getPerpendicularBisector(Point p1, Point p2) {\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\nvector<Vector> getNormalLineVector(Line l) {\n  vector<Vector> vs;\n  Vector v = l.p2 - l.p1, p = v / abs(v);\n  vs.emplace_back(-p.y, p.x);\n  vs.emplace_back(p.y, p.x);\n  return vs;\n}\nvector<Line> getTranslation(Line l, double d) {\n  vector<Vector> nlv = getNormalLineVector(l);\n  vector<Line> nl;\n  nl.emplace_back(l.p1 + nlv[0]*d, l.p2 + nlv[0]*d);\n  nl.emplace_back(l.p1 + nlv[1]*d, l.p2 + nlv[1]*d);\n  return nl;\n}\n\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n  // assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n  double base = sqrt(c.r*c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n  // assert(intersect(c1, c2));\n  double d = abs(c1.c - c2.c);\n  double a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2*c1.r*d));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\ntypedef vector<Point> Polygon;\n\ndouble getArea(Polygon p) {\n  double ret = 0.0;\n  for(int i = 0; i < (int)p.size(); i++) {\n    ret += cross(p[i], p[(i+1)%p.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n\n#define IN_POLYGON  2\n#define ON_POLYGON  1\n#define OUT_POLYGON 0\nint contains(Polygon g, Point p) {\n  int n = g.size();\n  bool x = false;\n  for(int i = 0; i < n; i++) {\n    Point a = g[i] - p, b = g[(i+1) % n] - p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON_POLYGON;\n    if(a.y > b.y) swap(a, b);\n    if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? IN_POLYGON : OUT_POLYGON);\n}\n\nPolygon convexHull(Polygon ps) {\n  int N = ps.size(), j = 0;\n  Polygon pg(N*2);\n\n  sort(ps.begin(), ps.end(), [](Point p1, Point p2) -> bool {\n      return p1.y != p2.y ? lt(p1.y, p2.y) : lt(p1.x, p2.x); });\n  for(int i = 0; i < N; i++, j++) {\n    while(j >= 2 && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2; i >= 0; i--, j++) {\n    while(j >= k && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n\nPolygon convexCut(Polygon s, Line l) {\n  Polygon t;\n  for(int i = 0; i < (int)s.size(); i++) {\n    Point a = s[i], b = s[(i+1)%s.size()];\n    if(ccw(l.p1, l.p2, a) != -1) t.push_back(a);\n    if(ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0) {\n      t.push_back(getCrossPointLL(Line(a, b), l));\n    }\n  }\n  return t;\n}\n\nbool mergeIfAble(Segment &s1, Segment s2) {\n  if(abs(cross(s1.p2 - s1.p1, s2.p2 - s2.p1)) > EPS) return false;\n  if(ccw(s1.p1, s2.p1, s1.p2) == COUNTER_CLOCKWISE ||\n     ccw(s1.p1, s2.p1, s1.p2) == CLOCKWISE) return false;\n  if(ccw(s1.p1, s1.p2, s2.p1) == ONLINE_FRONT ||\n     ccw(s2.p1, s2.p2, s1.p1) == ONLINE_FRONT) return false;\n  s1 = Segment(min(s1.p1, s2.p1), max(s1.p2, s2.p2));\n  return true;\n}\nvoid mergeSegments(vector<Segment>& segs) {\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].p2 < segs[i].p1) swap(segs[i].p1, segs[i].p2);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i+1; j < segs.size(); j++) {\n      if(mergeIfAble(segs[i], segs[j])) {\n\tsegs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nstruct edge {\n  int to;\n  double cost;\n  edge(){}\n  edge(int to, double cost):to(to), cost(cost){}\n\n  bool operator < (const edge& e) const {\n    return lt(cost, e.cost);\n  }\n};\ntypedef vector< vector<edge> > Graph;\n\nGraph segmentArrangement(vector<Segment>& segs, vector<Point>& ps) {\n  for(int i = 0; i < segs.size(); i++) {\n    ps.push_back(segs[i].p1);\n    ps.push_back(segs[i].p2);\n    for(int j = i+1; j < segs.size(); j++) {\n      if(intersect(segs[i], segs[j])) ps.push_back(getCrossPoint(segs[i], segs[j]));\n    }\n  }\n  sort(ps.begin(), ps.end());\n  ps.erase(unique(ps.begin(), ps.end()), ps.end());\n  Graph graph(ps.size());\n  for(int i = 0; i < segs.size(); i++) {\n    vector< pair<double, int> > ls;\n    for(int j = 0; j < ps.size(); j++) {\n      if(intersect(segs[i], ps[j])) {\n\tls.emplace_back(getDistanceSP(segs[i], ps[j]), j);\n      }\n    }\n    sort(ls.begin(), ls.end());\n    for(int j = 0; j+1 < ls.size(); j++) {\n      int u = ls[j].second, v = ls[j+1].second;\n      graph[u].emplace_back(v, getDistance(ps[u], ps[v]));\n      graph[v].emplace_back(u, getDistance(ps[u], ps[v]));\n    }\n  }\n  return graph;\n}\n\nint N;\nSegment course;\nPoint mn[55], mx[55];\ndouble h[55];\n\nbool collision(int idx) {\n  Point a = mn[idx];\n  Point b = Point(mx[idx].x, mn[idx].y);\n  Point c = mx[idx];\n  Point d = Point(mn[idx].x, mx[idx].y);\n  if(intersect(course, Segment(a, b))) return true;\n  if(intersect(course, Segment(b, c))) return true;\n  if(intersect(course, Segment(c, d))) return true;\n  if(intersect(course, Segment(d, a))) return true;\n  Polygon g{a, b, c, d};\n  return contains(g, course.p1) || contains(g, course.p2);\n}\n\ndouble distance(int idx) {\n  double res = 1e9;\n  if(collision(idx)) return 0;\n  Point a = mn[idx];\n  Point b = Point(mx[idx].x, mn[idx].y);\n  Point c = mx[idx];\n  Point d = Point(mn[idx].x, mx[idx].y);\n  res = min(res, getDistance(course, Segment(a, b)));\n  res = min(res, getDistance(course, Segment(b, c)));\n  res = min(res, getDistance(course, Segment(c, d)));\n  res = min(res, getDistance(course, Segment(d, a)));\n  if(h[idx] < res) res = (res*res + h[idx]*h[idx]) / (2.0*h[idx]);\n  return res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N, N) {\n    cin >> course.p1.x >> course.p1.y >> course.p2.x >> course.p2.y;\n    rep(i, N) cin >> mn[i].x >> mn[i].y >> mx[i].x >> mx[i].y >> h[i];\n    double ans = 1e9;\n    rep(i, N) ans = min(ans, distance(i));\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nconst double EPS=1e-10;\nbool eq(double a,double b){return abs(a-b)<EPS;}\nstruct Point{\n\tdouble x,y;\n\tPoint(double x_=0,double y_=0):x(x_),y(y_){}\n\tPoint operator-()const{return Point(-x,-y);}\n\tPoint operator+(const Point&p)const{return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point&p)const{return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k)const{return Point(x*k,y*k);}\n\tPoint operator/(const double k)const{return Point(x/k,y/k);}\n\tbool operator<(const Point&p)const{return eq(x,p.x)?y<p.y:x<p.x;}\n\tbool operator==(const Point&p)const{return eq(x,p.x)&&eq(y,p.y);}\n};\nistream&operator>>(istream&is,Point&p){return is>>p.x>>p.y;}\nostream&operator<<(ostream&os,const Point&p){return os<<fixed<<setprecision(9)<<p.x<<' '<<p.y;}\nstruct Line{\n\tPoint p1,p2;\n\tLine(Point p1_=Point(),Point p2_=Point()):p1(p1_),p2(p2_){}\n};\nstruct Segment:Line{\n\tSegment(Point p1_=Point(),Point p2_=Point()):Line(p1_,p2_){}\n};\nstruct Circle{\n\tPoint o;\n\tdouble r;\n\tCircle(Point o_=Point(),double r_=0):o(o_),r(r_){}\n};\nusing Polygon=vector<Point>;\n//function list begin\nPoint vec(const Line&);\ndouble norm(const Point&);\ndouble norm(const Line&);\ndouble abs(const Point&);\ndouble abs(const Line&);\ndouble arg(const Point&);\ndouble arg(const Line&);\ndouble arg(const Point&,const Point&,const Point&);//a->b->c\ndouble dot(const Point&,const Point&);\ndouble cross(const Point&,const Point&);\nPoint polar(const double,const double);\nPoint rotate(const Point&,const double);\nenum{ONLINE_FRONT=-2,CLOCKWISE=-1,ON_SEGMENT=0,COUNTER_CLOCKWISE=1,ONLINE_BACK=2};\nint ccw(const Point&,const Point&,const Point&);\nint ccw(const Line&,const Point&);\nbool orthogonal(const Point&,const Point&);\nbool orthogonal(const Line&,const Line&);\nbool parallel(const Point&,const Point&);\nbool parallel(const Line&,const Line&);\nbool intersect(const Line&,const Point&);\nbool intersect(const Line&,const Line&);\nbool intersect(const Segment&,const Point&);\nbool intersect(const Segment&,const Segment&);\nbool intersect(const Line&,const Segment&);\nbool intersect(const Segment&,const Line&);\nbool intersect(const Circle&,const Point&);\nint intersect(const Circle&,const Line&);//count contacts\nint intersect(const Circle&,const Segment&);\nint intersect(const Circle&,const Circle&);\ndouble distance(const Point&,const Point&);\ndouble distance(const Line&,const Point&);\ndouble distance(const Line&,const Line&);\ndouble distance(const Segment&,const Point&);\ndouble distance(const Segment&,const Segment&);\ndouble distance(const Line&,const Segment&);\ndouble distance(const Segment&,const Line&);\ndouble distance(const Circle&,const Point&);\ndouble distance(const Circle&,const Line&);\ndouble distance(const Circle&,const Segment&);\ndouble distance(const Circle&,const Circle&);\nPoint projection(const Line&,const Point&);\nPoint reflection(const Line&,const Point&);\nPoint crosspoint(const Line&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Segment&);\npair<Point,Point>crosspoint(const Circle&,const Circle&);\npair<Point,Point>tangent(const Circle&,const Point&);\nvector<Line>tangent(const Circle&,const Circle&);\nbool is_convex(const Polygon&);\nPolygon convex_full(Polygon,bool=false);\nenum{OUT,ON,IN};\nint contain(const Polygon&,const Point&);\nint contain(const Circle&,const Point&);\nint contain(const Circle&,const Segment&);\nPolygon convex_cut(const Polygon&,const Line&);\ndouble diameter(Polygon);\ndouble area(const Polygon&);\ndouble area(const Polygon&,const Line&);\ndouble area(const Polygon&,const Circle&);\n//function list end\nPoint vec(const Line&s){return s.p2-s.p1;}\ndouble norm(const Point&p){return p.x*p.x+p.y*p.y;}\ndouble norm(const Line&s){return norm(vec(s));}\ndouble abs(const Point&p){return hypot(p.x,p.y);}\ndouble abs(const Line&s){return abs(vec(s));}\ndouble arg(const Point&p){return atan2(p.y,p.x);}\ndouble arg(const Line&s){return arg(vec(s));}\ndouble arg(const Point&a,const Point&b,const Point&c){\n\tdouble A=arg(b-a),B=arg(c-b);\n\tdouble theta=abs(A-B);\n\treturn min(theta,2*M_PI-theta);\n}\ndouble dot(const Point&a,const Point&b){return a.x*b.x+a.y*b.y;}\ndouble cross(const Point&a,const Point&b){return a.x*b.y-a.y*b.x;}\nPoint polar(const double r,const double theta){return Point(cos(theta),sin(theta))*r;}\nPoint rotate(const Point&p,const double theta){\n\treturn Point(p.x*cos(theta)-p.y*sin(theta),p.x*sin(theta)+p.y*cos(theta));\n}\nint ccw(const Point&a,const Point&b,const Point&c){\n\tPoint p=b-a,q=c-a;\n\treturn cross(p,q)>EPS?COUNTER_CLOCKWISE\n\t\t:cross(p,q)<-EPS?CLOCKWISE\n\t\t:dot(p,q)<0?ONLINE_BACK\n\t\t:norm(p)<norm(q)?ONLINE_FRONT\n\t\t:ON_SEGMENT;\n}\nint ccw(const Line&s,const Point&p){return ccw(s.p1,s.p2,p);}\nbool orthogonal(const Point&a,const Point&b){return eq(dot(a,b),0);}\nbool orthogonal(const Line&s,const Line&t){return orthogonal(vec(s),vec(t));}\nbool parallel(const Point&a,const Point&b){return eq(cross(a,b),0);}\nbool parallel(const Line&s,const Line&t){return parallel(vec(s),vec(t));}\nbool intersect(const Line&s,const Point&p){return eq(cross(vec(s),p-s.p1),0);}\nbool intersect(const Line&s,const Line&t){return !parallel(s,t)||intersect(s,t.p1);}\nbool intersect(const Segment&s,const Point&p){return ccw(s,p)==ON_SEGMENT;}\nbool intersect(const Segment&s,const Segment&t){\n\treturn ccw(s,t.p1)*ccw(s,t.p2)<=0&&ccw(t,s.p1)*ccw(t,s.p2)<=0;\n}\nbool intersect(const Line&s,const Segment&t){\n\treturn cross(vec(s),t.p1-s.p1)*cross(vec(s),t.p2-s.p1)<EPS;\n}\nbool intersect(const Segment&s,const Line&t){return intersect(t,s);}\nbool intersect(const Circle&c,const Point&p){return eq(distance(c.o,p),c.r);}\nint intersect(const Circle&c,const Line&s){\n\tdouble d=distance(s,c.o);\n\treturn eq(d,c.r)?1:d<c.r?2:0;\n}\nint intersect(const Circle&c,const Segment&s){\n\tPoint h=projection(s,c.o);\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn distance(c.o,h)>c.r+EPS?0\n\t\t:d1<c.r-EPS&&d2<c.r-EPS?0\n\t\t:d1<c.r-EPS&&d2>c.r-EPS||d1>c.r-EPS&&d2<c.r-EPS?1\n\t\t:intersect(s,h)?eq(distance(c.o,h),c.r)?1:2\n\t\t:0;\n}\nint intersect(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\treturn eq(d,a.r+b.r)?3:d>a.r+b.r?4:eq(d,abs(a.r-b.r))?1:d>abs(a.r-b.r)?2:0;\n}\ndouble distance(const Point&a,const Point&b){return abs(a-b);}\ndouble distance(const Line&s,const Point&p){return distance(p,projection(s,p));}\ndouble distance(const Line&s,const Line&t){return intersect(s,t)?0:distance(s,t.p1);}\ndouble distance(const Segment&s,const Point&p){\n\treturn distance(p,\n\t\tdot(vec(s),p-s.p1)<0?s.p1\n\t\t:dot(-vec(s),p-s.p2)<0?s.p2\n\t\t:projection(s,p)\n\t);\n}\ndouble distance(const Segment&s,const Segment&t){\n\treturn intersect(s,t)?0:min({\n\t\tdistance(s,t.p1),distance(s,t.p2),\n\t\tdistance(t,s.p1),distance(t,s.p2)\n\t});\n}\ndouble distance(const Line&s,const Segment&t){\n\treturn intersect(s,t)?0:min(distance(s,t.p1),distance(s,t.p2));\n}\ndouble distance(const Segment&s,const Line&t){return distance(t,s);}\ndouble distance(const Circle&c,const Point&p){return abs(distance(c.o,p)-c.r);}\ndouble distance(const Circle&c,const Line&s){return max(distance(s,c.o)-c.r,0.);}\ndouble distance(const Circle&c,const Segment&s){\n\treturn intersect(c,s)?0\n\t\t:contain(c,s)?c.r-max(distance(c.o,s.p1),distance(c.o,s.p2))\n\t\t:distance(s,c.o)-c.r;\n}\ndouble distance(const Circle&a,const Circle&b){return max(distance(a.o,b.o)-a.r-b.r,0.);}\nPoint projection(const Line&s,const Point&p){\n\treturn s.p1+vec(s)*dot(p-s.p1,vec(s))/norm(s);\n}\nPoint reflection(const Line&s,const Point&p){return projection(s,p)*2-p;}\nPoint crosspoint(const Line&s,const Line&t){\n\tdouble d1=abs(cross(vec(s),t.p1-s.p1));\n\tdouble d2=abs(cross(vec(s),t.p2-s.p1));\n\treturn t.p1+vec(t)*(d1/(d1+d2));\n}\npair<Point,Point>crosspoint(const Circle&c,const Line&s){\n\tPoint h=projection(s,c.o);\n\tPoint e=vec(s)/abs(s)*sqrt(c.r*c.r-norm(h-c.o));\n\treturn minmax(h-e,h+e);\n}\npair<Point,Point>crosspoint(const Circle&c,const Segment&s){\n\tpair<Point,Point>p=crosspoint(c,Line(s));\n\treturn intersect(c,s)==2?p\n\t\t:intersect(s,p.first)?make_pair(p.first,p.first)\n\t\t:make_pair(p.second,p.second);\n}\npair<Point,Point>crosspoint(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\tdouble alpha=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble theta=arg(b.o-a.o);\n\treturn minmax(a.o+polar(a.r,theta+alpha),a.o+polar(a.r,theta-alpha));\n}\npair<Point,Point>tangent(const Circle&c,const Point&p){\n\treturn crosspoint(c,Circle(p,sqrt(norm(c.o-p)-c.r*c.r)));\n}\nvector<Line>tangent(const Circle&a,const Circle&b){\n\tvector<Line>ret;\n\tdouble g=distance(a.o,b.o);\n\tif(eq(g,0))return ret;\n\tPoint u=(b.o-a.o)/g;\n\tPoint v=rotate(u,M_PI/2);\n\tfor(int s:{-1,1}){\n\t\tdouble h=(a.r+b.r*s)/g;\n\t\tif(eq(h*h,1))ret.emplace_back(a.o+(h>0?u:-u)*a.r,a.o+(h>0?u:-u)*a.r+v);\n\t\telse if(1-h*h>0){\n\t\t\tPoint U=u*h,V=v*sqrt(1-h*h);\n\t\t\tret.emplace_back(a.o+(U+V)*a.r,b.o-(U+V)*b.r*s);\n\t\t\tret.emplace_back(a.o+(U-V)*a.r,b.o-(U-V)*b.r*s);\n\t\t}\n\t}\n\treturn ret;\n}\nbool is_convex(const Polygon&P){\n\tfor(int i=0;i<P.size();i++)\n\t\tif(ccw(P[i],P[(i+1)%P.size()],P[(i+2)%P.size()])==CLOCKWISE)return false;\n\treturn true;\n}\nPolygon convex_full(Polygon P,bool ONSEG){\n\tif(P.size()<=2)return P;\n\tsort(P.begin(),P.end());\n\tPolygon ret(2*P.size());\n\tint k=0,t;\n\tif(ONSEG){\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)==CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])==CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\telse{\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\tret.resize(k-1);\n\tint mi=0;\n\tfor(int i=1;i<k-1;i++)\n\t\tif(eq(ret[mi].y,ret[i].y)?ret[mi].x>ret[i].x:ret[mi].y>ret[i].y)mi=i;\n\trotate(ret.begin(),ret.begin()+mi,ret.end());\n\treturn ret;\n}\nint contain(const Polygon&P,const Point&p){\n\tbool in=false;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(intersect(s,p))return ON;\n\t\telse{\n\t\t\tPoint a=s.p1-p,b=s.p2-p;\n\t\t\tif(a.y>b.y)swap(a,b);\n\t\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)in=!in;\n\t\t}\n\t}\n\treturn in?IN:OUT;\n}\nint contain(const Circle&c,const Point&p){\n\tdouble d=distance(c.o,p);\n\treturn eq(d,c.r)?ON:d<c.r?IN:OUT;\n}\nint contain(const Circle&c,const Segment&s){\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn d1<c.r+EPS&&d2<c.r+EPS?eq(d1,c.r)||eq(d2,c.r)?ON:IN:OUT;\n}\nPolygon convex_cut(const Polygon&P,const Line&s){\n\tPolygon ret;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment t(P[i],P[(i+1)%P.size()]);\n\t\tif(ccw(s,t.p1)!=CLOCKWISE)ret.push_back(t.p1);\n\t\tif(!parallel(s,t)&&!intersect(s,t.p1)\n\t\t\t&&!intersect(s,t.p2)&&intersect(s,t))ret.push_back(crosspoint(s,t));\n\t}\n\treturn ret;\n}\ndouble diameter(Polygon P){\n\tif(!is_convex(P))P=convex_full(P);\n\tint mi=0,Mi=0;\n\tfor(int i=1;i<P.size();i++){\n\t\tif(P[i].x<P[mi].x)mi=i;\n\t\tif(P[i].x>P[Mi].x)Mi=i;\n\t}\n\tdouble ret=0;\n\tint sm=mi,sM=Mi;\n\twhile(mi!=sM||Mi!=sm){\n\t\tret=max(ret,norm(P[mi]-P[Mi]));\n\t\tif(cross(P[(mi+1)%P.size()]-P[mi],P[(Mi+1)%P.size()]-P[Mi])<0)mi=(mi+1)%P.size();\n\t\telse Mi=(Mi+1)%P.size();\n\t}\n\treturn sqrt(ret);\n}\ndouble area(const Polygon&P){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)ret+=cross(P[i],P[(i+1)%P.size()]);\n\treturn ret/2;\n}\ndouble area(const Polygon&P,const Line&s){return area(convex_cut(P,s));}\ndouble area(const Polygon&P,const Circle&c){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)\n\t{\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(contain(c,s))ret+=cross(s.p1-c.o,s.p2-c.o);\n\t\telse if(!intersect(c,s)){\n\t\t\tdouble a=arg(s.p2-c.o)-arg(s.p1-c.o);\n\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\tret+=c.r*c.r*a;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Point,Point>p=crosspoint(c,s);\n\t\t\tPoint tmp[4]={s.p1,p.first,p.second,s.p2};\n\t\t\tif(intersect(c,Segment(s.p1,p.first))==2)swap(tmp[1],tmp[2]);\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tSegment t(tmp[j],tmp[j+1]);\n\t\t\t\tif(contain(c,t))ret+=cross(t.p1-c.o,t.p2-c.o);\n\t\t\t\telse{\n\t\t\t\t\tdouble a=arg(t.p2-c.o)-arg(t.p1-c.o);\n\t\t\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\t\t\tret+=c.r*c.r*a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret/2;\n}\nint N;\ndouble calc(double X,double H)\n{\n\tdouble L=X,R=1e4;\n\tfor(int i=0;i<50;i++)\n\t{\n\t\tdouble M=L/2+R/2;\n\t\tif(M-sqrt(M*M-X*X)>=H)L=M;\n\t\telse R=M;\n\t}\n\treturn L;\n}\nmain()\n{\n\twhile(cin>>N,N)\n\t{\n\t\tSegment s;\n\t\tcin>>s.p1>>s.p2;\n\t\tdouble ans=1e150;\n\t\tfor(;N--;)\n\t\t{\n\t\t\tPoint a,b,c,d;\n\t\t\tdouble H;\n\t\t\tcin>>a>>b>>H;\n\t\t\tc.x=a.x;c.y=b.y;\n\t\t\td.x=b.x;d.y=a.y;\n\t\t\tPoint A[4]={a,b,c,d};\n\t\t\tdouble X=1e150;\n\t\t\tfor(int i=0;i<4;i++)for(int j=i+1;j<4;j++)\n\t\t\t{\n\t\t\t\tX=min(X,distance(s,Segment(A[i],A[j])));\n\t\t\t}\n\t\t\tans=min(ans,calc(X,H));\n\t\t}\n\t\tcout<<fixed<<setprecision(9)<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fs first\n#define sc second\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\nint n,sx,sy,tx,ty,xx1[50],yy1[50],x2[50],y2[50],h[50];\ndouble eps=1e-8;\ninline D dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ninline D cro(P a,P b){\n\treturn imag(conj(a)*b);\n}\ninline int ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\tif(abs(abs(a-c)+abs(c-b)-abs(a-b))<eps) return 0;\n\tif(abs(abs(a-b)+abs(b-c)-abs(a-c))<eps) return -2;\n\tif(abs(abs(c-a)+abs(a-b)-abs(c-b))<eps) return 2;\n}\ninline P perp(L l,P p){\n\tD t=dot(p-l.fs,l.fs-l.sc)/norm(l.fs-l.sc);\n\treturn l.fs+t*(l.fs-l.sc);\n}\ninline bool iSP(L s,P p){\n\treturn abs(abs(s.fs-p)+abs(p-s.sc)-abs(s.fs-s.sc))<eps;\n}\ninline bool iSS(L a,L b){\n\treturn ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0 && ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0;\n}\ninline D dSP(L s,P p){\n\tP q=perp(s,p);\n\treturn iSP(s,q) ? abs(p-q) : min(abs(p-s.fs),abs(p-s.sc));\n}\ninline D dSS(L a,L b){\n\tif(iSS(a,b)) return 0;\n\treturn min(min(dSP(a,b.fs),dSP(a,b.sc)),min(dSP(b,a.fs),dSP(b,a.sc)));\n}\nL otama;\nbool ok(double r){\n//\tcout << r << endl;\n\tbool ok=true;\n\trep(i,n){\n//\t\tcout << i << endl;\n\t\tdouble hi=min(r,(double)h[i]),dis=sqrt(2*r*hi-hi*hi);\n/*\t\tcout << sx << \" \" << sy << \"   \" << tx << \" \" << ty << endl;\n\t\tcout << xx1[i] << \" \" << yy1[i] << \"   \" << xx1[i] << \" \" << y2[i] << endl; \n\t\tcout << dSS(otama,L(P(xx1[i],yy1[i]),P(xx1[i],y2[i]))) << endl;\n\t\tcout << dSS(otama,L(P(xx1[i],y2[i]),P(x2[i],y2[i]))) << endl;\n\t\tcout << dSS(otama,L(P(x2[i],y2[i]),P(x2[i],yy1[i]))) << endl;\n\t\tcout << dSS(otama,L(P(x2[i],yy1[i]),P(xx1[i],yy1[i]))) << endl;*/\n\t\tif(dSS(otama,L(P(xx1[i],yy1[i]),P(xx1[i],y2[i])))<dis) ok=false;\n\t\tif(dSS(otama,L(P(xx1[i],y2[i]),P(x2[i],y2[i])))<dis) ok=false;\n\t\tif(dSS(otama,L(P(x2[i],y2[i]),P(x2[i],yy1[i])))<dis) ok=false;\n\t\tif(dSS(otama,L(P(x2[i],yy1[i]),P(xx1[i],yy1[i])))<dis) ok=false;\n\t\tif(xx1[i]<sx && sx<x2[i] && yy1[i]<sy && sy<y2[i]) ok=false;\n\t}\n\treturn ok;\n}\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tcin >> sx >> sy >> tx >> ty;\n\t\totama=L(P(sx,sy),P(tx,ty));\n\t\trep(i,n) cin >> xx1[i] >> yy1[i] >> x2[i] >> y2[i] >> h[i];\n\t\tdouble ub=1000,lb=0;\n\t\twhile(ub-lb>1e-5){\n\t\t\tdouble m=(ub+lb)/2;\n\t\t\tif(ok(m)) lb=m;\n\t\t\telse ub=m;\n\t\t}\n\t\tprintf(\"%.6f\\n\",ub);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ninline double sq(double x) { return x * x; }\n\nstruct point {\n    double x, y, z;\n    point() {}\n    point(double x, double y, double z): x(x), y(y), z(z) {}\n    point operator + (const point& o) const { return point(x+o.x, y+o.y, z+o.z); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y, z-o.z); }\n    point operator * (const double a) const { return point(x*a,   y*a,   z*a); }\n};\n\ndouble fabs(point p) { return sqrt(sq(p.x) + sq(p.y) + sq(p.z)); }\ndouble dist(point p, point q) { return fabs(p - q); }\ndouble dot(point p, point q) { return p.x*q.x + p.y*q.y + p.z*q.z; }\npoint cross(point p, point q) {\n    return point(\n        p.y*q.z - p.z*q.y,\n        p.z*q.x - p.x*q.z,\n        p.x*q.y - p.y*q.x\n    );\n}\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\ndouble dist_point_line(point p, line l) {\n    if (dot(l.b - l.a, p - l.a) >= 0 && dot(l.a - l.b, p - l.b) >= 0) {\n        point h = l.a + (l.b - l.a) * (dot(l.b - l.a, p - l.a) / sq(fabs(l.b - l.a)));\n        return dist(p, h);\n    }\n\n    return min(dist(p, l.a), dist(p, l.b));\n}\n\nint N; double Sx, Sy, Ex, Ey;\nvector<vector<point>> rects;\nvector<line> vs;\n\ndouble solve() {\n    line c(point(Sx, Sy, 0), point(Ex, Ey, 0));\n    for (vector<point> r : rects) {\n        for (int i = 0; i < r.size(); ++i) {\n            for (int j = i+1; j < r.size(); ++j) {\n                double c1 = cross(c.b - c.a, r[i] - c.a).z * cross(c.b - c.a, r[j] - c.a).z;\n                double c2 = cross(r[j] - r[i], c.a - r[i]).z * cross(r[j] - r[i], c.b - r[i]).z;\n                if (c1 <= 0 && c2 <= 0)\n                    return 0;\n            }\n        }\n    }\n\n    double l = 0, r = 1050;\n    for (int g = 0; g < 100; ++g) {\n        double m = (l + r) / 2;\n\n        line c(point(Sx, Sy, m), point(Ex, Ey, m));\n\n        bool ok = true;\n        for (line p : vs) {\n            if (dist_point_line(p.a, c) <= m || dist_point_line(p.b, c) <= m)\n                ok = false;\n            if (dist_point_line(c.a, p) <= m || dist_point_line(c.b, p) <= m)\n                ok = false;\n            if (m < p.a.z) p.a.z = p.b.z = m;\n            if (dist_point_line(p.a, c) <= m || dist_point_line(p.b, c) <= m)\n                ok = false;\n            if (dist_point_line(c.a, p) <= m || dist_point_line(c.b, p) <= m)\n                ok = false;\n        }\n\n        (ok ? l : r) = m;\n    }\n\n    return (l + r) / 2;\n}\n\nint main(void) {\n    cout << fixed << setprecision(10);\n    while (true) {\n        cin >> N; if (N == 0) break;\n        cin >> Sx >> Sy >> Ex >> Ey;\n        vs.clear();\n        rects.clear();\n        for (int i = 0; i < N; ++i) {\n            double minx, miny, maxx, maxy, h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            vs.emplace_back(point(minx, miny, h), point(minx, maxy, h));\n            vs.emplace_back(point(minx, miny, h), point(maxx, miny, h));\n            vs.emplace_back(point(minx, maxy, h), point(maxx, maxy, h));\n            vs.emplace_back(point(maxx, miny, h), point(maxx, maxy, h));\n\n            vector<point> vv;\n            vv.emplace_back(minx, miny, h);\n            vv.emplace_back(minx, maxy, h);\n            vv.emplace_back(maxx, miny, h);\n            vv.emplace_back(maxx, maxy, h);\n            rects.push_back(vv);\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <bits/stdc++.h>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n// #define EPS 1e-8\n// static const int INF=1<<24;\n\n// #include<bits/stdc++.h>\n// using namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = asin(0.5)*6;\ntypedef complex<double> P;\n\n#define X real()\n#define Y imag()\n\n#define Curr(P,i) P[(i)%P.size()]\n#define Next(P,i) P[(i+1)%P.size()]\n#define Prev(P,i) P[(i+P.size()-1)%P.size()]\n\nnamespace std{\n  bool operator<(const P a,const P b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n//gaiseki\ndouble cross(const P a,const P b){\n  return (conj(a)*b).imag();\n}\n//naiseki\ndouble dot(const P a,const P b){\n  return (conj(a)*b).real();\n}\n// TODO make graph (20)\nint ccw(P a,P b,P c){\n  b-=a;\n  c-=a;\n  if(cross(b,c)>0)    return +1;//counter clockwise\n  if(cross(b,c)<0)    return -1;//clockwise\n  if(dot(b,c)<0)      return +2;// c--a--b\n  if(norm(b)<norm(c)) return -2;// a--b--c\n                      return  0;// a--c--b(or b==c)\n}\n\nstruct L : public vector<P>{\n  L(const P a,const P b){\n    push_back(a),push_back(b);\n  }\n};\ntypedef L S;\ntypedef vector<P> G;\n\nstruct C{\n  P p;double r;\n  C(const P p,double r): p(p),r(r){}\n};\n\n\n\n//直線と点の関係\n//点から線分に垂線を下ろした点\nP projection(L a,P p){\n  double t = dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n  return a[0] + t*(a[0]-a[1]);\n}\n//線対称の点\nP reflection(L a,P p){\n  return p + 2.0 * (projection(a,p)-p);\n}\n\n\n\n\n//交差判定\n//TODO CP(内包) CL CS (0)\nbool isCrossLL(L a,L b){\n  return \n    abs(cross(a[1]-a[0],b[1]-b[0])) > EPS\n    || abs(cross(a[1]-a[0],b[0]-a[0])) < EPS ;\n}\nbool isCrossLS(L a,S b){\n  return \n    cross(a[1]-a[0],b[0]-a[0]) \n    * cross(a[1]-a[0],b[1]-a[0]) < EPS;\n}\nbool isCrossLP(L l,P p){\n  return abs(cross(l[1]-p,l[0]-p)) < EPS;\n}\nbool isCrossSS(S a,S b){\n  return\n    ccw(a[0],a[1],b[0])\n    * ccw(a[0],a[1],b[1]) <= 0\n    &&\n    ccw(b[0],b[1],a[0])\n    * ccw(b[0],b[1],a[1]) <= 0;\n}\nbool isCrossSP(S a,P p){\n  return abs(a[0]-p)+abs(a[1]-p)-abs(a[0]-a[1]) < EPS;\n}\n\n\n// 距離 CP CL CS は(distXP(x,c.p)-c.r)\ndouble distPP(P a,P b){\n  return abs(a-b);\n}\ndouble distLP(L a,P p){\n  return abs(p-projection(a,p));\n}\ndouble distLL(L a,L b){\n  return isCrossLL(a,b) ? 0 : distLP(a,b[0]);\n}\ndouble distLS(L a,S b){\n  return isCrossLS(a,b) ? 0 : min(distLP(a,b[0]),distLP(a,b[1]));\n}\ndouble distSP(S a,P p){\n  const P r = projection(a,p);\n  return isCrossSP(a,r) ? abs(p-r) : min(abs(a[0]-p),abs(a[1]-p));\n}\ndouble distSS(S a,S b){\n  return isCrossSS(a,b)?0:\n    min(\n      min(distSP(a,b[0]),distSP(a,b[1])),\n      min(distSP(b,a[0]),distSP(b,a[1]))\n    );\n}\n\n//円の交差判定\nbool isCrossCP(C a,P p){\n  return abs(a.p-p)-a.r<=EPS;\n}\nbool isCrossCL(C a,L l){\n  return distLP(l,a.p)-a.r<EPS;\n}\ndouble distSP_MAX(S a,P p){\n  return max(abs(a[0]-p),abs(a[1]-p));\n}\nbool isCrossCS(C a,S s){\n  return distSP(s,a.p)-a.r<-EPS&&distSP_MAX(s,a.p)-a.r>+EPS;\n}\nbool isCrossCC(C a,C b){//接してる時は交差\n  return abs(a.p-b.p)-(a.r+b.r) <= EPS;\n}\n\n\n//交差点\n//先に交差判定をすること\nP crossP_LL(L a,L b){\n  double A = cross(a[1]-a[0],b[1]-b[0]);\n  double B = cross(a[1]-a[0],a[1]-b[0]);\n  if(abs(A)<EPS && abs(B)<EPS)return b[0];\n  if(abs(A)<EPS)assert(false);\n  return b[0]+B/A*(b[1]-b[0]);\n}\nvector<P> crossP_CL(C c,L l){\n  P tmp = projection(l,c.p);\n  P e = (l[0]-l[1])/abs(l[0]-l[1]);\n  double h = abs(c.p-tmp)*abs(c.p-tmp);\n  double t = sqrt(c.r*c.r - h*h);\n  if(t<EPS)return {tmp};\n  return {tmp + e*t,tmp - e*t};\n}\nvector<P> crossP_CC(C a,C b){\n  P A = conj(b.p-a.p);\n  P B = (b.r*b.r - a.r*a.r - (b.p-a.p)*conj(b.p-a.p));\n  P C = a.r*a.r*(b.p-a.p);\n  P D = B*B-4.0*A*C;\n  P z1 = (-B+sqrt(D))/(2.0*A)+a.p;\n  P z2 = (-B-sqrt(D))/(2.0*A)+a.p;\n  return {z1,z2};\n}\n\n\n\n//三点->円\nP PPPtoC(P a,P b,P c){\n  P x = 1.0/(conj(b-a));\n  P y = 1.0/(conj(c-a));\n  return (y-x)/( conj(x)*y - x*conj(y) ) + a;\n}\n\n//凸包\nG convex_hull(G ps){\n  int n = ps.size();\n  int k = 0;\n  G ch(2*n);\n  for(int i = 0;i<n;(ch[k++]=ps[i++])){\n    while(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  }\n  for(int i = n-2,t=k+1 ; i>=0 ; ch[k++]=ps[i--]){\n    while(k>=t && ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  }\n  ch.resize(k-1);\n  return ch;\n} \n\n\n//凸性判定\nbool isConvex(G g){\n  for(int i=0; i<g.size();i++){\n    if(ccw(Prev(g,i),Curr(g,i),Next(g,i))>0)return false;\n  }\n}\n\n\n\n//接線\n//TODO check\nvector<L> TLine_CP(C c,P p){\n  P v = c.p - p;\n  double t = asin(abs(c.r)/(abs(v)));\n  P e = v/abs(v) * exp(P(.0,t));\n  P n1 = sqrt(abs(v)*abs(v) - c.r*c.r)*e + p;\n  P n2 = reflection(L(p,c.p),n1);\n  return {L(p,n1),L(p,n2)};\n}\n\n// TLine CC\nvector<L> TLine_CPr(C c,P p,double r){\n  P v = c.p - p;\n  double t = asin(abs(c.r)/(abs(v)));\n  P e = v/abs(v) * exp(P(.0,t));\n  P n1 = sqrt(abs(v)*abs(v) - c.r*c.r)*e + p;\n  P e1 = (n1-c.p)/abs(n1-c.p) * r;\n  P n2 = reflection(L(p,c.p),n1);\n  P e2 = (n2-c.p)/abs(n2-c.p) * r;\n  return {L(p+e1,n1+e1),L(p+e2,n2+e2)};\n}\nvector<L> TLine_CC(C a,C b){\n  //接してる時がヤバイ\n  vector<L> res;\n  if(!isCrossCC(a,b)&&(abs(a.r)>EPS)&&(abs(b.r>EPS))){\n    P tmp = (a.p-b.p)*(b.r)/(a.r+b.r) + b.p;\n    auto t1 = TLine_CP(a,tmp);\n    auto t2 = TLine_CP(b,tmp);\n    res.push_back(L(t1[0][1],t2[0][1]));\n    res.push_back(L(t1[1][1],t2[1][1]));\n  }\n  if(abs(a.r-b.r)<EPS){\n    const auto r = a.r;\n    P e = (a.p-b.p)/abs(a.p-b.p) * exp(P(.0,90.0/180.0*PI));\n    res.push_back(L(a.p+(e*r),b.p+(e*r)));\n    if(abs(r)>=EPS)res.push_back(L(a.p-(e*r),b.p-(e*r)));\n  }else{\n    if(a.r<b.r)swap(a,b);\n    auto t3 = TLine_CPr(C(a.p,a.r-b.r),b.p,b.r);\n    for(auto i:t3){\n      res.push_back(i);\n    }\n  }\n  return res;\n}\n\n\n\n//原点を起点とした回転\nP rotate(P a,double r){\n  return a*exp(P(0.0,r*PI/180.0));\n}\n\n// int main(){\n// }\nbool foo(P a,P b,P c,P d){\n\tP da=a-d,ab=b-a; \n\tP db=b-d,bc=c-b; \n\tP dc=c-d,ca=a-c;\n\tdouble t1=cross(da,ab),t2=cross(db,bc),t3=cross(dc,ca);\n\treturn (t1>0&&t2>0&&t3>0)||(t1<0&&t2<0&&t3<0);\n}\n\nvoid mainmain(){\n\tint n;\n\tint cnt=1;\n\twhile(cin>>n,n){\n\t\tP s,e;\n\t\tdouble tt1,tt2;\n\t\tcin>>tt1>>tt2;\n\t\ts=P(tt1,tt2);\n\t\tcin>>tt1>>tt2;\n\t\te=P(tt1,tt2);\n\t\tVV(S) vv(n);\n\t\tdouble ans=INF;\n\t\tS a=S(s,e);\n\t\trep(i,n){\n\t\t\tP t1,t2;\n\t\t\t// double tt1,tt2;\n\t\t\tcin>>tt1>>tt2;\n\t\t\tt1=P(tt1,tt2);\n\t\t\tcin>>tt1>>tt2;\n\t\t\tt2=P(tt1,tt2);\n\t\t\tdouble h;\n\t\t\tcin>>h;\n\t\t\t// cout<<t1.X<<\" \"<<t1.Y<<\" \"<<t2.X<<\" \"<<t2.Y<<endl;\n\t\t\tvv[i].PB(S(t1,P(t1.X,t2.Y)));\n\t\t\tvv[i].PB(S(t1,P(t2.X,t1.Y)));\n\t\t\tvv[i].PB(S(t2,P(t1.X,t2.Y)));\n\t\t\tvv[i].PB(S(t2,P(t2.X,t1.Y)));\n\t\t\t//30 -70 90 -30 10\n\t\t\trep(j,vv[i].size()){\n\t\t\t\t// cout<<i<<\" \"<<j<<\" \"<<ans<<endl;\n\t\t\t\tif(isCrossSS(a,vv[i][j])){\n\t\t\t\t\tans=0;\n\t\t\t\t\t// cout<<i<<\" \"<<j<<endl;\n\t\t\t\t\t// puts(\"a1\");\n\t\t\t\t}\n\t\t\t\tif(foo(t1,t2,P(t1.X,t2.Y),s)){\n\t\t\t\t\tans=0;\n\t\t\t\t\t// puts(\"a2\");\n\n\t\t\t\t}\n\t\t\t\tif(foo(t1,t2,P(t2.X,t1.Y),s)){\n\t\t\t\t\tans=0;\n\t\t\t\t\t// puts(\"a3\");\n\t\t\t\t}\n\t\t\t\tdouble t = distSS(a,vv[i][j]);\n\t\t\t\t// cout<<t<<endl;\n\t\t\t\tif(h-t>=-EPS){\n\t\t\t\t\tans=min(ans,t);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tans=min(ans,h/2.0+t*t/2.0/h);\n\t\t\t\t}\n\t\t\t\t// if(ans!=0) cout<<i<<\" \"<<ans<<\" \"<<t1.X<<endl;\n\t\t\t}\n\t\t}\n\t\t// if(cnt==37) cout<<\"aaaaaaaaaaaaaaaa   \"<<n<<\" \"<<s.X<<endl;\n\t\tcnt++;\n\t\tprintf(\"%.4lf\\n\",ans);\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <sstream>\n#include <complex>\nusing namespace std;\n\n#define REP(i,a,n) for(i=a; i<n; i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define foreach(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); it++)\n#define EPS 1e-8\n\ntypedef complex<double> P;\n\nint n, h[55];\ndouble dist[55];\nconst double inf = 9999999999.9;\n\n\n/*\n  sin = d/b\n  |b|sin = d\n  a X b = |a||b|sin\n  |d| = aXb / |a|\n */\n\ndouble dot(const P& a, const P& b){\n    return (a.real()*b.real() + a.imag()*b.imag());\n}\ndouble cross(const P& a, const P& b){\n    return (a.real()*b.imag() - a.imag()*b.real());\n}\n\n// üªabÆ_cÆÌÅZ£\ndouble lpdist(const P& a, const P& b, const P& c){\n    if( dot(b-a, c-a) < 0.0 ) return abs(c-a);\n    if( dot(a-b, c-b) < 0.0 ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// üªseÆüªabÆÌÅZ£\ndouble lldist(const P& s, const P& e, const P& a, const P& b){\n    double d = inf;\n    // üªseÆ_a,bÆÌ£ðßé\n    d = min(d, lpdist(s,e,a));\n    d = min(d, lpdist(s,e,b));\n\n    // üªabÆ_s,eÆÌ£ðßé\n    d = min(d, lpdist(a,b,s));\n    d = min(d, lpdist(a,b,e));\n    return d;\n}\n\n// üªÌ[_ªubNàÉ¶Ý·é©\nbool inside(const P& s, const P& e, int ix, int iy, int ax, int ay){\n    return ((ix <= s.real() && s.real() <= ax && iy <= s.imag() && s.imag() <= ay) ||\n            (ix <= e.real() && e.real() <= ax && iy <= e.imag() && e.imag() <= ay));\n}\n\n// üªseÆüªabªð·µÄ¢é©\nbool llcr(const P& s, const P& e, const P& a, const P& b){\n    return ( (cross(s-e, a-e) * cross(s-e,b-e) < EPS) &&\n             (cross(a-b, s-b) * cross(a-b,e-b) < EPS) );\n}\n\n// ¼arÅS[Å«é©\ndouble sqr(double x){ return x*x; }\n\nbool f(double r){\n    int i;\n    rep(i,n){\n        if( r > (double)h[i] ){\n            if( r*r >= sqr(dist[i]) + sqr(r - (double)h[i]) ) return false;\n        }\n        else{\n            if( dist[i] <= r ) return false;\n        }\n    }\n    return true;\n}\n\n\nint main(){\n    int i,j,k;\n    int ix, iy, ax, ay;\n    P s,e;\n\n    while( cin >> n, n ){\n        bool no = false;\n\n        cin >> s.real() >> s.imag() >> e.real() >> e.imag();\n        rep(i,n){\n            cin >> ix >> iy >> ax >> ay >> h[i];\n            P a(ix,iy), b(ax,ay), c(ix,ay), d(ax,iy);\n            dist[i] = min(min(lldist(s,e,a,c), lldist(s,e,a,d)),\n                          min(lldist(s,e,b,c), lldist(s,e,b,d)));\n\n            if( inside(s,e,ix,iy,ax,ay) ||\n                (llcr(s,e,a,c) || llcr(s,e,a,d) || llcr(s,e,b,c) || llcr(s,e,b,d)) ) no = true;\n        } \n\n        if( no ){\n            printf(\"%lf\\n\",0.0);\n            continue;\n        }\n\n        double l = 0.0, r = 1000.0;\n        rep(i,60){\n            double mid = (l + r) / 2.0;\n            //printf(\"l = %lf,  r = %lf,  mid = %lf\\n\",l,r,mid);\n            if( f(mid) ){\n                l = mid;\n            }\n            else{\n                r = mid;\n            }\n        }\n        printf(\"%lf\\n\",l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> xy;\ndouble eps = 1e-9;\ndouble dot_product(xy a,xy b) {return (conj(a)*b).real();}\ndouble cross_product(xy a,xy b) {return (conj(a)*b).imag();}\n\ndouble dist_lp(xy a1,xy a2,xy p){\n    if(dot_product(a2-a1,p-a1)<eps) return abs(p-a1);\n    if(dot_product(a1-a2,p-a2)<eps) return abs(p-a2);\n    return abs(cross_product(a2-a1,p-a1))/abs(a2-a1);\n}\n\nbool is_online(xy a1,xy a2,xy p){\n    return abs(a1-p)+abs(a2-p)<=abs(a1-a2)+eps;    \n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    if(is_online(a1,a2,b1) || is_online(a1,a2,b2)) return true;\n    if(is_online(b1,b2,a1) || is_online(b1,b2,a2)) return true;\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<-eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<-eps;\n}\n\ndouble dist_ll(xy a1,xy a2,xy b1,xy b2){\n    if(is_intersected(a1,a2,b1,b2)) return 0;\n    return min({dist_lp(a1,a2,b1),dist_lp(a1,a2,b2),dist_lp(b1,b2,a1),dist_lp(b1,b2,a2)\n    ,abs(a1-b1),abs(a1-b2),abs(a2-b1),abs(a2-b2)});   \n}\n\nint N;\ndouble sx,sy,gx,gy,mi_x,mi_y,ma_x,ma_y;\ndouble h;\n\n\nint main(){\n    while(cin>>N && N>0){\n        double ans = 1e9;\n        cin >> sx >> sy >> gx >> gy;\n        if(sx>gx){\n            swap(sx,sy);\n            swap(gx,gy);\n        }\n        xy s = xy(sx,sy),g = xy(gx,gy);\n        for(int i=1;i<=N;i++){\n            cin >> mi_x >> mi_y >> ma_x >> ma_y >> h;\n            if((mi_x<=sx && sx<=ma_x && mi_y<=sy && sy<=ma_y) || \n            (mi_x<=gx && gx<=ma_x && mi_y<=gy && gy<=ma_y)) ans = 0;\n            double d = min({dist_ll(s,g,xy(mi_x,mi_y),xy(mi_x,ma_y)),\n            dist_ll(s,g,xy(mi_x,ma_y),xy(ma_x,ma_y)),\n            dist_ll(s,g,xy(ma_x,ma_y),xy(ma_x,mi_y)),\n            dist_ll(s,g,xy(ma_x,mi_y),xy(mi_x,mi_y))});\n            if(d<=h) ans = min(ans,d);\n            else ans = min(ans,(h*h+d*d)/h);\n        }\n        cout << fixed;\n        cout << setprecision(10) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  //return !ccw(a1, a2, b);\n   return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n#define F first\n#define S second\ntypedef pair<L,D>PP;\nint main(){\n  int n;\n  D a1,a2,a3,a4,a5;\n  while(cin>>n,n){\n    L st;\n    D ans=1e15;\n    vector<PP>v;\n    cin>>a1>>a2>>a3>>a4;\n    st=L(P(a1,a2),P(a3,a4));\n    rep(i,n){\n      cin>>a1>>a2>>a3>>a4>>a5;\n      v.push_back(PP(L(P(a1,a4),P(a3,a4)),a5));\n      v.push_back(PP(L(P(a1,a2),P(a3,a2)),a5));\n      v.push_back(PP(L(P(a3,a2),P(a3,a4)),a5));\n      v.push_back(PP(L(P(a1,a2),P(a1,a4)),a5));\n      if(ccw(P(a1,a2),P(a1,a4),st.F)==ccw(P(a1,a4),P(a3,a4),st.F)&&ccw(P(a3,a4),P(a3,a2),st.F)==ccw(P(a3,a2),P(a1,a2),st.F)&&ccw(P(a1,a4),P(a3,a4),st.F)==ccw(P(a3,a4),P(a3,a2),st.F))ans=0;\n      if(ccw(P(a1,a2),P(a1,a4),st.S)==ccw(P(a1,a4),P(a3,a4),st.S)&&ccw(P(a3,a4),P(a3,a2),st.S)==ccw(P(a3,a2),P(a1,a2),st.S)&&ccw(P(a1,a4),P(a3,a4),st.S)==ccw(P(a3,a4),P(a3,a2),st.S))ans=0;\n    }\n    rep(i,v.size()){\n      D dist=distSS(v[i].F.F,v[i].F.S,st.F,st.S);\n      if(dist<=v[i].S)ans=min(ans,dist);\n      else ans=min(ans,(dist*dist+v[i].S*v[i].S)/(2*v[i].S));\n    }\n    printf(\"%.9f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <complex>\n#define REP(i,n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\nconst double EPS = 1e-8;\n// ?????°????¬??????¢??°\ninline int signum(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\n// ???\ntypedef complex<double> P;\n// ??????????????´????????´???\nstruct L { P pos, dir; };\n// ????§???¢\ntypedef vector<P> G;\n// ???\nstruct C { P p; double r; };\n\n// ??????????????????????????????????¨??????????\ninline double inp(const P& a, const P& b) {\n\treturn (conj(a)*b).real();\n}\n\n// ??????????????????????????????????¨??????????\ninline double outp(const P& a, const P& b) {\n\treturn (conj(a)*b).imag();\n}\n\n// ????????????p???????????????b????°???±??????????????????????¨??????????\ninline P proj(const P& p, const P& b) {\n\treturn b*inp(p, b) / norm(b);\n}\n\n// ???p????????´???l??????????????????????¶???¨?????????????¨??????????\ninline P perf(const L& l, const P& p) {\n\tL m = { l.pos - p, l.dir };\n\treturn (p + (m.pos - proj(m.pos, m.dir)));\n}\n\ninline int ccw(const P& p, const P& r, const P& s) {\n\tP a(r - p), b(s - p);\n\tint sgn = signum(outp(a, b));\n\tif(sgn != 0)\n\t\treturn sgn;\n\tif(a.real()*b.real() < -EPS || a.imag()*b.imag() < -EPS)\n\t\treturn -1;\n\tif(norm(a) < norm(b) - EPS)\n\t\treturn 1;\n\treturn 0;\n}\n\nbool ss_intersects(const L& s, const L& t) {\n\treturn (ccw(s.pos, s.pos + s.dir, t.pos) *\n\t\tccw(s.pos, s.pos + s.dir, t.pos + t.dir) <= 0 &&\n\t\tccw(t.pos, t.pos + t.dir, s.pos) *\n\t\tccw(t.pos, t.pos + t.dir, s.pos + s.dir) <= 0);\n}\n\ndouble sp_distance(const L& s, const P& p) {\n\tconst P r = perf(s, p);\n\tconst double pos = ((r - s.pos) / s.dir).real();\n\tif(-EPS <= pos && pos <= 1 + EPS)\n\t\treturn abs(r - p);\n\treturn min(abs(s.pos - p),\n\t\tabs(s.pos + s.dir - p));\n}\n\ndouble ss_distance(const L& s, const L& t) {\n\tif(ss_intersects(s, t))\n\t\treturn 0;\n\tdouble d = min(sp_distance(s, t.pos), sp_distance(s, t.pos + t.dir));\n\td = min(d, sp_distance(t, s.pos));\n\td = min(d, sp_distance(t, s.pos + s.dir));\n\treturn d;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tdouble sx, sy, ex, ey;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tL line = L{ P(sx, sy), P(ex - sx, ey - sy) };\n\t\tvector< vector<P> > g(N);\n\t\tvector<double> h;\n\n\t\tbool flag = false;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x1, y1, x2, y2, hh;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> hh;\n\t\t\tif(x1 <= sx && sx <= x2 && y1 <= sy && sy <= y2) flag = true;\n\t\t\tg[i].push_back(P(x1, y1));\n\t\t\tg[i].push_back(P(x2, y1));\n\t\t\tg[i].push_back(P(x2, y2));\n\t\t\tg[i].push_back(P(x1, y2));\n\t\t\th.push_back(hh);\n\t\t}\n\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\tif(ss_intersects(L{ g[i][j], g[i][(j + 1) % 4] - g[i][j] }, line)) {\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdouble ok = 0, ng = 1000;\n\t\tfor(int loop = 0; loop < 100; loop++) {\n\t\t\tdouble r = (ok + ng) / 2;\n\t\t\tdouble t = 1e8;\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\t\tdouble sp = sp_distance(line, g[i][j]);\n\t\t\t\t\tdouble ss = ss_distance(line, L{ g[i][j], g[i][(j + 1) % 4] - g[i][j] });\n\t\t\t\t\tif(r > h[i]) {\n\t\t\t\t\t\tdouble l1 = sqrt(sp * sp + (h[i] - r) * (h[i] - r));\n\t\t\t\t\t\tdouble l2 = sqrt(ss * ss + (h[i] - r) * (h[i] - r));\n\t\t\t\t\t\tt = min(t, l1);\n\t\t\t\t\t\tt = min(t, l2);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tt = min(t, sp);\n\t\t\t\t\t\tt = min(t, ss);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(r < t) ok = r;\n\t\t\telse ng = r;\n\t\t}\n\n\t\tcout << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nconst double INF = 1<<29;\nconst double EPS = 1e-8;\n\nstruct Vec { double x, y, z; };\nVec operator+(const Vec& a, const Vec& b) {\n    return { a.x + b.x, a.y + b.y, a.z + b.z };\n}\nVec operator-(const Vec& a, const Vec& b) {\n    return { a.x - b.x, a.y - b.y, a.z - b.z };\n}\nVec operator*(const Vec& v, double n) {\n    return { v.x * n, v.y * n, v.z * n };\n}\ndouble operator*(const Vec& a, const Vec& b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\ndouble abs(const Vec& v) {\n    return pow(v * v, 0.5);\n}\n\ndouble dist_l2p(Vec a, Vec b, Vec p) {\n    Vec l = (b - a) * (1.0 / abs(b - a));\n    double len = l * (p - a);\n    if (len < 0) return abs(a - p);\n    if (len > abs(b - a)) return abs(b - p);\n    return abs((l * len) - (p - a));\n}\n\ndouble dist_l2l(Vec a1, Vec a2, Vec b1, Vec b2) {\n    double l = 0, r = 1;\n    while (l + EPS < r) {\n        double m = (l + r) / 2;\n        double v1 = dist_l2p(a1, a2, b1 + ((b2 - b1) * m));\n        double v2 = dist_l2p(a1, a2, b1 + ((b2 - b1) * (m + EPS)));\n        if (v1 < v2) r = m;\n        else l = m;\n    }\n    return dist_l2p(a1, a2, b1 + ((b2 - b1) * l));\n}\n\ndouble dist(Vec s, Vec t, Vec a, Vec b, double h) {\n    double d = dist_l2l(s, t, a, b);\n    if (d < h) return d;\n    a.z = h, b.z = h;\n    double l = d, r = 2000;\n    while (l + EPS < r) {\n        double m = (l + r) / 2;\n        s.z = m, t.z = m;\n        if (m < dist_l2l(s, t, a, b)) l = m;\n        else r = m;\n    }\n    return l;\n}\n\nint main()\n{\n    while (1) {\n        int n; cin >> n;\n        if (!n) break;\n        Vec s, t;\n        cin >> s.x >> s.y >> t.x >> t.y;\n        s.z = 0, t.z = 0;\n        double ans = INF;\n        while (n--) {\n            Vec a, b, c, d;\n            double h;\n            cin >> a.x >> a.y >> c.x >> c.y >> h;\n            b.x = a.x, b.y = c.y, d.x = c.x, d.y = a.y;\n            a.z = b.z = c.z = d.z = 0;\n            if (a.x < min(s.x, t.x) && a.y < min(s.y, t.y) && c.x > max(s.x, t.x) && c.y > max(s.y, t.y)) ans = 0;\n            ans = min(ans, dist(s, t, a, b, h));\n            ans = min(ans, dist(s, t, b, c, h));\n            ans = min(ans, dist(s, t, c, d, h));\n            ans = min(ans, dist(s, t, d, a, h));\n        }\n        cout << setprecision(8) << fixed << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double の切り替え cmathの関数はオーバーロードに対応しているので問題ない\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//誤差\n#define EQ(a,b) (abs((a)-(b)) < EPS)//２つの実数が等しいか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//２つのベクトルが等しいか\n#define ft first\n#define sd second\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){//内積ok\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){//外積ok\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nbool is_orthogonal(Line a,Line b){//2直線の直行判定ok\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2直線の並行判定ok\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n//////////////射影と反射\nPoint projection(Line l,Point p){//射影を求めるok\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//反射を求めるok\n    return p + (R)2.0 * (projection(l,p) - p);\n}\n\n\n\n////////////////////交差判定\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a→bで反時計周りに折れてb→c\n    if(cross(b,c) < -EPS) return -1;//a→bで時計周りに折れてb→c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(absじゃなくて二乗するのは差が出やすいから?)\n    return 0;//a--c--bまたはb==c\n}\n\nbool is_intersection_ll(Line l,Line m){//２つの直線が交わるかok\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //平行でない\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //平行だが同じ線\n}\n\nbool is_intersection_ls(Line l,Line s){//直線lと線分sが交わるか\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//直線lと点pが交わるか\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//２つの線分が交わるかok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//線分と点の交差判定 三角不等式の利用\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n\nbool intersection_cc(Circle c1,Circle c2){//２つの円の交差判定ok\n    return abs(c1.ft - c2.ft) - (c1.sd + c2.sd) < -EPS;\n}\n\n/*bool is_p_along_s(Point p,Line s) {//点が線分に沿った場所にあるか？\n    Point q = reflection(s,p);\n    return is_intersection_ss(Line(q,p),s) ;\n}*/\n\n\n/////////////距離\nR dis_lp(Line l,Point p){//直線lと点pの距離ok\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//２つの直線の距離\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//直線lと線分sの距離\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//線分sと点pの距離ok\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//２つの線分の距離ok\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n//////////////交点(交差する保証してないときは交差判定してからつかってね)\n\nPoint intersection_ll(Line l,Line m){//交差判定してるなら線分にも使えるok\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//同じ線\n    //if(abs(A) < EPS)assert(false);//並行で交点なし\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ２つの円の交点をLineに入れて返す(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))を満たす必要があるok\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ではオーバーロードが可能であるため、sqrt または float 型を受け取る long double のオーバーロードを呼び出すことができます。 C プログラムでは、sqrt は常に double を受け取って返します。\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\n/////////////////////////polygon\n\n#define currP(P,i) P[(i) % P.size()]//今の頂点\n#define nextP(P,i) P[((i) + 1)%P.size()]//次の頂点\n\nint is_contains_p_in_Poly(Poly po,Point p){//点が多角形の内部(1)、境界(-1)、外部(0)のどこにあるかを判定ok\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(EQ(cross(a,b),0.0) && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nbool is_intersection_Ps(Poly po,Line s) {//多角形と線分が交差するか\n    if(is_contains_p_in_Poly(po,s.ft) != 0 || is_contains_p_in_Poly(po,s.sd) != 0) {\n        return true;\n    }\n    REP(i,po.size()) {\n        if(is_intersection_ss(Line(currP(po,i),nextP(po,i)),Line(s))) {\n            return true;\n        }\n    }\n    return false;\n}\n\nR area2(Poly po){//多角形の面積の二倍を求めるok\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n\n\n\n///////////////////////////凸\n\nbool comp_complex_real(Point a,Point b){//x→yの辞書順ok\n    if(EQ(a.real(),b.real()))\n        return b.imag() - a.imag() > EPS;\n    return b.real() - a.real() > EPS;\n}\n\nPoly convex_hull(Poly ps){//凸包ok\n    int n = ps.size(),k = 0;\n    sort(ps.begin(),ps.end(),comp_complex_real);\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0 && ccw(ch[k - 2],ch[k - 1],ps[i]) > -2) --k;//３つ目の条件は180度を含むときのみ必要\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0 && ccw(ch[k - 2],ch[k - 1],ps[i]) > -2) --k;//上に同じ\n    ch.resize(k - 1);\n    return ch;\n}\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){//凸性判定時計回り反時計周りに対応\n    bool cl = false,ccl = false;\n    for(int i = 0;i < P.size();++i){\n        int c = ccw(prevP(P,i),currP(P,i),nextP(P,i));\n        if(c == -2)continue;//180度を含むときのみ　360度も含むときはc == -2 || c == 0\n        if(c == 1)ccl = true;\n        else if(c == 2)cl = true;\n        else return false;\n    }\n    return !(cl && ccl);\n}\n\nPoint s,e;\nPoly recs[100];\nint h[100];\nint n;\nconst R INF = 1e10;\n\nbool C(R x) {\n\n    Line l = Line(s,e);\n\n    for(int i = 0;i < n;i++) {\n        auto rec = recs[i];\n\n        R mind = INF;\n\n        for(auto p : rec) {\n            mind = min(dis_sp(l,p),mind);\n        }\n\n        REP(i,rec.size()) {\n            Line a = Line(rec[i],rec[(i+1)%rec.size()]);\n            mind = min(dis_sp(a,s),mind);\n            mind = min(dis_sp(a,e),mind);\n        }\n\n        if(mind > x) {\n            continue;\n        }\n        \n        R h2 = x - sqrt(x * x - mind * mind);\n\n        if(h2 < h[i])\n            return false;\n    }\n    return true;\n}\n\nint main(){\n    while(true) {\n        cin  >> n;\n        if(n == 0)break;\n\n        int sx,sy,ex,ey;\n        cin >> sx >> sy >> ex >> ey;\n        s = Point(sx,sy);\n        e = Point(ex,ey);\n        Line l = Line(s,e);\n\n        REP(i,n) {\n            int x[2],y[2];\n\n            cin >> x[0] >> y[0] >> x[1] >> y[1] >> h[i];\n\n            recs[i].clear();\n            recs[i].pb(Point(x[0],y[0]));\n            recs[i].pb(Point(x[0],y[1]));\n            recs[i].pb(Point(x[1],y[1]));\n            recs[i].pb(Point(x[1],y[0]));\n\n        }\n        bool f = false;\n        for(int i = 0;i < n;i++) {\n            auto rec = recs[i];\n            if(is_intersection_Ps(rec,l)) {\n                printf(\"0 \\n\");\n                f = true;\n                break;\n            }\n        }\n        if(f) continue;\n\n        R lb = 0,ub = 1000;\n        while(ub - lb > 1e-12) {\n            R mid = (ub + lb) / 2;\n            if(C(mid)) {\n                lb = mid;\n            }else {\n                ub = mid;\n            }\n        }\n        printf(\"%.12f\\n\",ub);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std;\n\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\n// 誤差を加味した符号判定\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\n\n// 比較演算子\nnamespace std{\n    bool operator < (const Point& a, const Point& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\n// 内積・外積\ndouble dot(Point a, Point b){\n    return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\n\n// OAとOBのなす符号付き角度 [-pi, pi]\n// example : (1, 0), (0, 1) -> pi/2\ndouble angle(Point a, Point b){\n    return arg(conj(a) * b);\n}\n\n// aをc中心にb[rad]回転\n// verify : not yet.\nPoint rotate(Point a, double b, Point c = Point()){\n    return (a - c) * polar(1.0, b) + c;\n}\n\n// 直線ABに対する点Cの位置\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > +EPS)   return +1; // 反時計回り\n    if (cross(b, c) < -EPS)   return -1; // 時計回り\n    if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n    if (norm(b) < norm(c)) return -2; // a--b--c の順番で一直線上\n    return 0;                         // 点が線分ab上にある\n}\n\nenum{ OUT, ON, IN };\nstruct Line : public vector<Point> {\n    Line(){}\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\n\n// 注意: 端点で交わったり直線が重なったりする場合も交差していると判定する\n\n// 二直線の平行判定\n// verify : aoj0021\nbool paralell(Line l, Line m){\n    return sign(cross(l.vector(), m.vector())) == 0;\n}\n\n// 二直線の同一判定\nbool equalLL(Line l, Line m){\n    return sign(cross(l.vector(), m[0] - l[0])) == 0;\n}\n\n// 直線と点の交差判定\nbool iLP(Line l, Point p) {\n    // 直線lとl[0]からpへの直線が平行\n    return sign(cross(l.vector(), p - l[0])) == 0;\n}\n\n// 線分と点の交差判定(端点の処理に注意)\n// verify : aoj1279\nbool iSP(Line s, Point p) {\n    return ccw(s[0], s[1], p) == 0;\n}\n\n// 直線と線分の交差判定(線分が重なっている時に注意)\nbool iLS(Line l, Line s) {\n    // 直線lについて、線分sの端点が異なる側にある\n    return sign(cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0])) <= 0;\n}\n\n// 二つの線分の交差判定(線分が重なっている時や端点の処理に注意)\nbool iSS(Line s, Line t) {\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n        ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\n\n// 点pから直線lに対する射影\nPoint proj(Line l, Point p){\n    double t = dot(p - l[0], l.vector()) / norm(l.vector());\n    return l[0] + t * l.vector();\n}\n\n// 点pの直線lに関する反射\nPoint refl(Line l, Point p){\n    return 2.0 * proj(l, p) - p;\n}\n\n// 直線と点の距離\ndouble dLP(Line l, Point p){\n    // return abs(p - projection(l, p));\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\n\n// 線分と点の距離 ( not verified !!! )\ndouble dSP(Line s, Point p){\n    if(sign(dot(s.vector(), p - s[0])) <= 0) return abs(p - s[0]);\n    if(sign(dot(-s.vector(), p - s[1])) <= 0) return abs(p - s[1]);\n    return dLP(s, p);\n}\n\n// 直線と直線の距離\ndouble dLL(Line l, Line m){\n    // 平行でないときは0, 平行のときは垂線の長さ\n    return paralell(l, m) ? dLP(l, m[0]) : 0;\n}\n\n// 直線と線分の距離\ndouble dLS(Line l, Line s){\n    if(iLS(l, s)) return 0;\n    return min(dLP(l, s[0]), dLP(l, s[1]));\n}\n\n// 線分と線分の距離\ndouble dSS(Line s, Line t){\n    if(iSS(s, t)) return 0;\n    return min({dSP(s, t[0]), dSP(s, t[1]), dSP(t, s[0]), dSP(t, s[1])});\n}\n\n// 直線と直線の交点\nPoint pLL(Line l, Line m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n    if(sign(A) == 0) assert(false); // 直線が交わらない\n    return m[0] + m.vector() * B / A;\n}\n\ntypedef vector<Point> Polygon; // 反時計回りを仮定\n\n// Polygonの要素へのアクセス\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n// 点が多角形のどこにあるのか判定する\n// verify : aoj0012\nint contains(const Polygon& P, const Point& p){\n    // 点pから半直線をひき、辺と交差する回数を数える\n    bool in = false;\n    for(int i = 0; i < P.size(); i++){\n        Point a = curr(P, i) - p;\n        Point b = next(P, i) - p;\n        if(a.imag() > b.imag()) swap(a, b);\n        // aからbの直線がy=0と交わり、その交点は原点の右側である\n        if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0){ \n            in = !in;\n        }\n        if(sign(cross(a, b)) == 0 && sign(dot(a, b)) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\n// 多角形の面積\n// verify : aoj0079 aoj1100\ndouble area(const Polygon& P) {\n    double A = 0;\n    for(int i = 0; i < P.size(); i++){\n        A += cross(curr(P, i), next(P, i));\n    }\n    return abs(A) / 2.0;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<Point> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){ // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){ // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\nbool is_convex(const Polygon& P){\n    for(int i = 0; i < P.size(); i++){\n        if(ccw(prev(P, i), curr(P, i), next(P, i)) > 0) return false;\n    }\n    return true;\n}\n\n// 凸多角形の直線による切断。直線の左側だけ残す\n// verify : aoj1283\nPolygon convex_cut(const Polygon& P, Line l){\n    Polygon Q;\n    for(int i = 0; i < P.size(); i++){\n        Point A = curr(P, i), B = next(P, i);\n        if(ccw(l[0], l[1], A) != -1) Q.push_back(A); //Aが直線lの右側でない\n        if(ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0)\n            Q.push_back(pLL(l, Line(A, B)));\n    }\n    return Q;\n}\n// 垂直二等分線\n// verify: maximamcup2013 D\nLine bisector(Point a, Point b){\n    Point mid = (a + b) / 2.0;\n    Point vec = (mid - a) * Point(0.0, 1.0);\n    return Line(mid, mid + vec);\n}\n// 点集合psのうちs番目のボロノイ領域\n// verify: maximamcup2013 D\nPolygon voronoi_cell(Polygon P, const vector<Point>& ps, int s){\n    for(int i = 0; i < ps.size(); i++){\n        if(i != s) P = convex_cut(P, bisector(ps[s], ps[i]));\n    }\n    return P;\n}\nstruct Circle {\n    Point p;\n    double r;\n    Circle() {}\n    Circle(Point p, double r) : p(p), r(r) { }\n};\n\n// 円と点の内外判定\nint contains(const Circle& C, const Point& p){\n    double d = abs(C.p - p);\n    if(sign(d - C.r) > 0) return OUT;\n    if(sign(d - C.r) == 0) return ON;\n    return IN;\n}\n\n// 円と線分の交差判定(境界を含む)\n// Verified: AOJ 0129\nbool iCS(const Circle& C, const Line& l){\n    int c1 = contains(C, l[0]);\n    int c2 = contains(C, l[1]);\n    if(c1 > c2) swap(c1, c2);\n\n    // (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) の6通り\n    if(c1 == OUT && c2 == IN) return true;\n    if(c1 == IN  && c2 == IN) return false;\n    if(c1 == ON) return true; // (接するとき) \n    double d = dSP(l, C.p);\n    if(sign(d - C.r) < 0) return true;\n    if(sign(d - C.r) == 0) return true; // (接するとき)\n    if(sign(d - C.r) > 0) return false;\n}\n\n// 二つの円の交差判定(接する時を含む)\nbool iCC(const Circle& C, const Circle& D){\n    // 円の中心同士の距離が、半径の和以下であり、半径の差以上である\n    double e = abs(C.p - D.p);\n    return sign(e - (C.r + D.r)) <= 0 && sign(e - abs(C.r - D.r)) >= 0;\n}\n\n// 円と直線の交点\n// verify : aoj2045\nvector<Point> pLC(const Line &l, const Circle &c) {\n    vector<Point> res;\n    Point center = proj(l, c.p);\n    double d = abs(center - c.p);\n    double tt = c.r * c.r - d * d;\n    if(tt < 0 && tt > -EPS) tt = 0;\n    if(tt < 0) return res;\n    double t = sqrt(tt);\n    Point vect = l.vector();\n    vect /= abs(vect);\n    res.push_back(center - vect * t);\n    if (t > EPS) {\n        res.push_back(center + vect * t);\n    }\n    return res;\n}\n\n// 円と線分の交点\nvector<Point> pSC(const Line &s, const Circle &c) {\n    vector<Point> ret;\n    vector<Point> nret = pLC(s, c);\n    for (int i = 0; i < nret.size(); i++) {\n        if (iSP(s, nret[i])) ret.push_back(nret[i]);\n    }\n    return ret;\n}\n\n// 円と円の交点\n// verify : aoj1183\nvector<Point> pCC(Circle a, Circle b){\n    vector<Point> res;\n\n    double l = abs(b.p - a.p);\n\n    if(sign(l) == 0 && sign(a.r - b.r) == 0) assert(false); // 解が無限に存在する\n    if(sign(l - abs(a.r - b.r)) < 0 || sign(l - (a.r + b.r)) > 0) return res; // 解が存在しない\n\n    double th1 = arg(b.p - a.p);\n    if(sign(l - abs(a.r - b.r)) == 0 || sign(l - (a.r + b.r)) == 0){\n        res.push_back(a.p + polar(a.r, th1));\n    }else {\n        double th2 = acos( (a.r * a.r - b.r * b.r + l * l) / (2 * a.r * l) );\n        res.push_back(a.p + polar(a.r, th1 - th2));\n        res.push_back(a.p + polar(a.r, th1 + th2));\n    }\n    return res;\n}\n\n// 2点を通る半径rの円の中心\n// verify : aoj1132\nvector<Point> touching_circle2(Point a, Point b, double r){\n    vector<Point> res;\n\n    double d = abs(b - a);\n    if(d > 2 * r) return res;\n\n    Point mid = 0.5 * (a + b);\n    Point dir = polar(sqrt(r * r - d * d / 4), arg(b - a) + M_PI / 2);\n    res.push_back(mid + dir);\n    res.push_back(mid - dir);\n    return res;\n}\n\n// 3点を通る円\nCircle touching_circle3(Point a, Point b, Point c){\n    // ２つの垂直二等分線の交点が円の中心\n    Point mid_ab = (a + b) / 2.0;\n    Line bis_ab(mid_ab, (mid_ab - a) * Point(0.0, 1.0));\n    Point mid_bc = (b + c) / 2.0;\n    Line bis_bc(mid_bc, (mid_bc - b) * Point(0.0, 1.0));\n\n    assert(!paralell(bis_ab, bis_bc)); \n\n    Point center = pLL(bis_ab, bis_bc);\n    return Circle(center, abs(a - center));\n}\n\n// 円と円の共通部分の面積を求める．\n// ref: nya3j\ndouble cc_area(const Circle& c1, const Circle& c2) {\n    double d = abs(c1.p - c2.p);\n    if (c1.r + c2.r < d + EPS) {\n        return 0.0;\n    } else if (d < abs(c1.r - c2.r) + EPS) {\n        double r = min(c1.r, c2.r); // 元は c1.r >? c2.r だった．\n        return r * r * M_PI;\n    } else {\n        double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n        double theta = acos(rc / c1.r);\n        double phi = acos((d - rc) / c2.r);\n        return c1.r*c1.r*theta + c2.r*c2.r*phi - d*c1.r*sin(theta);\n    }\n}\n// 円の接線 (中心から偏角thの点で接する接線)\n// verified: AOJ 2201 Immortal Jewels \nLine circle_tangent(const Circle& C, double th){\n    Point p0 = C.p + polar(C.r, th);\n    Point p1 = p0 + polar(1.0, th + M_PI / 2);\n    return Line(p0, p1);\n}\n\n// 二つの円の共通接線 (Cの中心から接点へのベクトルの偏角を返す)\n// verified: AOJ 2201 Immortal Jewels \n// 参考: http://geom.web.fc2.com/geometry/circle-circle-tangent.html\nvector<double> common_tangents(const Circle& C, const Circle& D){\n    vector<double> res;\n    Point v = D.p - C.p;\n    double l = abs(v); // 二円の中心間の距離\n    double a = arg(v); // 二円の中心間の偏角\n    if(sign(l - abs(C.r - D.r)) > 0){\n        // 交わる or 外接 or 離れている\n        // 二つの外側接線\n        double a1 = acos((C.r - D.r) / l);\n        res.push_back(a + a1);\n        res.push_back(a - a1);\n        if(sign(l - (C.r + D.r)) > 0){\n            // 離れている\n            // 二つの内側接線\n            double a2 = acos((C.r + D.r) / l);\n            res.push_back(a + a2);\n            res.push_back(a - a2);\n        }\n    }\n    if((sign(l - abs(C.r - D.r)) == 0 || sign(l - (C.r + D.r)) == 0) && sign(l) != 0){\n        // 内接 or 外接\n        // 一つの接線\n        res.push_back(a);\n    }\n    return res;\n}\n\n// 1点を通る円の接線( pがCの外側にあることが前提条件 )\n// verified : AOJ 2579\nvector<Line> tangents_through_point(const Circle& C, const Point& p){\n    vector<Line> tangents;\n    double d = abs(C.p - p);\n    // d ^ 2 == r ^ 2 + e ^ 2\n    double e = sqrt(d * d - C.r * C.r); // 点pと円の接点の距離\n    // d * sin(th) = r\n    double th = asin(C.r / d);\n    Point q1 = p + (C.p - p) * polar(1.0, +th) * e / d;\n    Point q2 = p + (C.p - p) * polar(1.0, -th) * e / d;\n    tangents.push_back(Line(p, q1));\n    tangents.push_back(Line(p, q2));\n    return tangents;\n}\nint main(){\n    int N;\n    while(cin>>N && N){\n        double sx, sy, gx, gy;\n        cin>>sx>>sy>>gx>>gy;\n        Point sp(sx, sy);\n        Point gp(gx, gy);\n        double ans = 1e8;\n        Line route(sp, gp);\n        for(int i = 0; i < N; i++) {\n            double mx, my, nx, ny, h;\n            cin>>mx>>my>>nx>>ny>>h;\n            if(mx <= sx && sx <= nx && my <= sy && sy <= ny) ans = 0;\n            Line ls[4];\n            ls[0] = Line(Point(mx,my),Point(nx,my));\n            ls[1] = Line(Point(mx,my),Point(mx,ny));\n            ls[2] = Line(Point(mx,ny),Point(nx,ny));\n            ls[3] = Line(Point(nx,my),Point(nx,ny));\n            for(int j = 0; j < 4; j++) {\n                Line l = ls[j];\n                double dist = dSS(route, l);\n                if(dist == 0) ans = 0;\n                double radian;\n                if(dist - EPS < h) radian = dist;\n                else radian = (h*h + dist*dist)/(2*h);\n                ans = min(ans, radian);\n            }\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline point rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\ninline point rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ninline double angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ninline double abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ninline double norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ninline double cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ninline point projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\ninline bool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\ninline bool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ninline bool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline bool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\ninline bool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ninline double dist(const line& l, const point& p) {\n\treturn abs(cross((l.b - l.a), (p - l.a))) / abs(l.b - l.a);\n//\treturn abs(p - projection(l, p));\n}\n\ninline double dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ninline double dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ninline double dist(const segment& s, const point& p) {\n\tif(dot((s.b - s.a), (p - s.a)) < 0) return abs(p - s.a);\n\tif(dot((s.a - s.b), (p - s.b)) < 0) return abs(p - s.b);\n\treturn dist(line(s.a, s.b), p);\n\t\t\t\t\t\t\t\t\t\t\t\t   \n\n\n//\tconst point tmp = projection(line(s.a, s.b), p);\n//\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ninline double dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\ninline double dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ninline point crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn m.a + (m.b - m.a) * cross(l.b - l.a, l.a - m.a) * (1.0 / tmp);\n}\n\ninline point crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\n//先に，intersectを用いて交差判定を行うこと\ninline vector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ninline double areaTriangle(point a, point b, const point& c) {\n\ta = a - c;\n\tb = b - c;\n\treturn fabs(a.x * b.y - b.x * a.y) / 2.0;\n}\n\ninline double area(const polygon& p) {\n\tconst int num = p.size();\n\tif(num < 3)\n\t\treturn 0;\n\n\tif(num == 3)\n\t\treturn areaTriangle(p[0], p[1], p[2]);\n\n\tdouble res = cross(p[num - 1], p[0]);\n\tfor(int i = 1; i < num; ++i)\n\t\tres += cross(p[i - 1], p[i]);\n\n\treturn res * 0.5;\n}\n\n// L.aからL.bの方向を見た場合に，点aが左側に来る．\ninline line bisector(const point& a, const point& b) {\n\treturn line(point((a.x - a.y + b.x + b.y) / 2.0, (a.y + a.x + b.y - b.x) / 2.0),\n\t\t\t\tpoint((a.x + a.y + b.x - b.y) / 2.0, (a.y - a.x + b.y + b.x) / 2.0));\n}\n\n// L.aからL.bを向いた時の左側を残して切断する．\ninline polygon convex_cut(const polygon& p, const line& l) {\n\tconst int num = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < num; ++i) {\n\t\tconst int next = (i + 1) % num;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1)\n\t\t\tres.push_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0)\n\t\t\tres.push_back(crosspoint(l, line(p[i], p[next])));\n\t}\n\n\treturn res;\n}\n\nvector<point> tangent(const circle& c, const point& p) {\n\tconst double x = norm(p - c.c);\n\tdouble d = x - c.r * c.r;\n\tif(d < -EPS) return vector<point>();\n\td = max(d, 0.0);\n\tconst point q1 = (p - c.c) * (c.r * c.r / x);\n\tconst point q2 = rotate90((p - c.c) * (-c.r * sqrt(d) / x));\n\tvector<point> res;\n\tres.push_back(c.c + q1 - q2);\n\tres.push_back(c.c + q1 + q2);\n\treturn res;\n}\n\nvector<line> tangent(const circle &a, const circle& b) {\n\tvector<line> res;\n\tif(abs(a.r - b.r) < EPS) {\n\t\tpoint dir = b.c - a.c;\n\t\tdir = rotate90(dir * (a.r / abs(dir)));\n\t\tres.push_back(line(a.c + dir, b.c + dir));\n\t\tres.push_back(line(a.c - dir, b.c - dir));\n\t}\n\telse {\n\t\tpoint p = a.c * (-b.r) + b.c * a.r;\n\t\tp = p * (1.0 / (a.r - b.r));\n\t\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\t\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\t\tres.push_back(line(ps[i], qs[i]));\n\t}\n\n\tpoint p = a.c * b.r + b.c * a.r;\n\tp = p * (1.0 / (a.r + b.r));\n\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\tres.push_back(line(ps[i], qs[i]));\n\n\treturn res;\n}\n\nconst int MAX_N = 50;\nconst double INF = 2000;\nint n;\ndouble d[MAX_N];\nint h[MAX_N];\n\ndouble square(double x) {\n\treturn x * x;\n}\n\nbool check(double r) {\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(d[i] < sqrt(square(r) - square(r - min<double>(r, h[i]))))\n\t\t\treturn false;\n\n\t\tcontinue;\n\n\t\tif(h[i] >= r) {\n\t\t\tif(d[i] < r)\n\t\t\t\treturn false;\n\t\t}\n\n\t\telse {\n\t\t\tconst double a = r - h[i];\n\t\t\tif(d[i] * d[i] + a * a < r * r)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\twhile(scanf(\"%d\", &n), n) {\n\t\tint sx, sy, ex, ey;\n\t\tscanf(\"%d %d %d %d\", &sx, &sy, &ex, &ey);\n\n\t\tsegment course(point(sx, sy), point(ex, ey));\n\n\t\tfill(d, d + n, INF);\n\t\tbool on = false;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint minX, minY, maxX, maxY;\n\t\t\tscanf(\"%d %d %d %d %d\", &minX, &minY, &maxX, &maxY, &h[i]);\n\n\t\t\tvector<point> points;\n\t\t\tpoints.reserve(4);\n\t\t\tpoints.push_back(point(minX, minY));\n\t\t\tpoints.push_back(point(minX, maxY));\n\t\t\tpoints.push_back(point(maxX, maxY));\n\t\t\tpoints.push_back(point(maxX, minY));\n\n\t\t\tif(minX <= sx && sx <= maxX && minY <= sy && sy <= maxY\n\t\t\t   || minX <= ex && ex <= maxX && minY <= ey && ey <= maxY) {\n\t\t\t\ton = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\n\t\t\tfor(int j = 0; j < 4; ++j) {\n\t\t\t\tconst segment edge(points[j], points[(j + 1) % 4]);\n\t\t\t\tif(intersect(course, edge)) {\n\t\t\t\t\ton = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchmin(d[i], dist(course, edge));\n\t\t\t}\n\t\t}\n\n\t\tif(on) {\n\t\t\tputs(\"0.0000\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tdouble low = 0.0, high = 1000.0;\n\t\tfor(int i = 0; i < 100; ++i) {\n\t\t\tconst double mid = (low + high) / 2;\n\t\t\tif(check(mid))\n\t\t\t\tlow = mid;\n\n\t\t\telse\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\tprintf(\"%.4lf\\n\", low);\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <algorithm>\n#include <complex>\n\nusing namespace std;\n\nint sy,sx,ex,ey;\nint n;\n\ntypedef complex<double> P;\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\n// OÏÌvZ\ndouble cross(P a,P b){\n\treturn (a.real()*b.imag() - a.imag()*b.real());\n}\n\n// üªÌð·»è\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n\treturn (cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1) < EPS)\n\t\t&& (cross(b2-b1,a1-b1) * cross(b2-b1,a2-b1) < EPS);\n}\n\n// àÏ\ndouble dot(P a,P b){\n\treturn (a.real()*b.real() + a.imag()*b.imag());\n}\n\n// _a,bðZ_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a,P b,P c){\n\tif(dot(b-a,c-a) < EPS)\n\t\treturn abs(c-a);\n\tif(dot(a-b,c-b) < EPS)\n\t\treturn abs(c-b);\n\treturn abs(cross(b-a,c-a))/abs(b-a);\n}\n\nclass obj{\npublic:\n\tint minx;\n\tint maxx;\n\tint miny;\n\tint maxy;\n\tint h;\n};\n\nvector<obj> objs;\n\nbool check(double R){\n\tfor(int i = 0; i < objs.size(); i++){\n\t\t// X^[gn_ÆI¹n_ªáQ¨ÉÍÜêÄ¢È¢©Ç¤©\n\t\tif(objs[i].minx <= sx && sx <= objs[i].maxx && objs[i].miny <= sy && sy <= objs[i].maxy){\n\t\t\treturn false;\n\t\t}\n\t\tif(objs[i].minx <= ex && ex <= objs[i].maxx && objs[i].miny <= ey && ey <= objs[i].maxy){\n\t\t\treturn false;\n\t\t}\n\n\t\t// Ü¸o[N[wóÌªÉÂ¢Äl¦é\n\t\tdouble r;\n\t\tif(objs[i].h > R+EPS){\n\t\t\t// ÌêÔªL¢ªðp\n\t\t\tr = R;\n\t\t}\n\t\telse{\n\t\t\t// ³É¶½¼aÌªðp\n\t\t\tr = sqrt(R*R - (R-objs[i].h)*(R-objs[i].h));\n\t\t}\n\t\t// üªÌð·»èðpµÄAvZ\n\n\n\t\t// PÊxNg\n\t\tP elemV(sy-ey,-(sx-ex));\n\t\telemV = elemV/abs(elemV);\n\t\tP a1 = -r*elemV+P(sx,sy);\n\t\tP a2 = r*elemV+P(sx,sy);\n\t\tP b1 = -r*elemV+P(ex,ey);\n\t\tP b2 = r*elemV+P(ex,ey);\n\n\t\t// SÔ£\n\t\tdouble pointDist = abs(P(sx,sy)-P(ex,ey));\n\t\tpair<P,P> pair1,pair2;\n\t\t// ÇÌ_ÆÇÌ_ªÑÂ­©\n\t\tif(EQ(abs(a1-b1),pointDist)){\n\t\t\tpair1.first = a1;\n\t\t\tpair1.second=b1;\n\t\t\tpair2.first = a2;\n\t\t\tpair2.second=b2;\n\t\t}\n\t\telse{\n\t\t\tpair1.first = a1;\n\t\t\tpair1.second=b2;\n\t\t\tpair2.first = a2;\n\t\t\tpair2.second=b1;\n\t\t}\n\n\t\t// ß½ñÂÌüªÌÔÉáQ¨ª¶Ý·é©Ç¤©\n\t\tdouble minX = min(min(pair1.first.real(),pair1.second.real()),min(pair2.first.real(),pair2.second.real()));\n\t\tdouble maxX = max(max(pair1.first.real(),pair1.second.real()),max(pair2.first.real(),pair2.second.real()));\n\t\tdouble minY = min(min(pair1.first.imag(),pair1.second.imag()),min(pair2.first.imag(),pair2.second.imag()));\n\t\tdouble maxY = max(max(pair1.first.imag(),pair1.second.imag()),max(pair2.first.imag(),pair2.second.imag()));\n\n\t\tif(objs[i].minx >= minX && objs[i].maxx <= maxX && objs[i].miny >= minY && objs[i].maxy <= maxY){\n\t\t\treturn false;\n\t\t}\n\n\t\t// ß½ñÂÌüªÆ¨ÌªÂüªªÚ·é©ðvZ\n\t\tif(is_intersected_ls(pair1.first,pair1.second,P(objs[i].maxx,objs[i].maxy),P(objs[i].maxx,objs[i].miny))){\n\t\t\treturn false;\n\t\t}\n\t\telse if(is_intersected_ls(pair1.first,pair1.second,P(objs[i].maxx,objs[i].miny),P(objs[i].minx,objs[i].miny))){\n\t\t\treturn false;\n\t\t}\n\t\telse if(is_intersected_ls(pair1.first,pair1.second,P(objs[i].minx,objs[i].miny),P(objs[i].minx,objs[i].maxy))){\n\t\t\treturn false;\n\t\t}\n\t\telse if(is_intersected_ls(pair1.first,pair1.second,P(objs[i].maxx,objs[i].maxy),P(objs[i].minx,objs[i].maxy))){\n\t\t\treturn false;\n\t\t}\n\t\telse if(is_intersected_ls(pair2.first,pair2.second,P(objs[i].maxx,objs[i].maxy),P(objs[i].maxx,objs[i].miny))){\n\t\t\treturn false;\n\t\t}\n\t\telse if(is_intersected_ls(pair2.first,pair2.second,P(objs[i].maxx,objs[i].miny),P(objs[i].minx,objs[i].miny))){\n\t\t\treturn false;\n\t\t}\n\t\telse if(is_intersected_ls(pair2.first,pair2.second,P(objs[i].minx,objs[i].miny),P(objs[i].minx,objs[i].maxy))){\n\t\t\treturn false;\n\t\t}\n\t\telse if(is_intersected_ls(pair2.first,pair2.second,P(objs[i].maxx,objs[i].maxy),P(objs[i].minx,objs[i].maxy))){\n\t\t\treturn false;\n\t\t}\n\t\t// É¼[Ì~ÉÂ¢Äl¦é\n\t\t// eüªÆ~ÌSÆÌ£ð¾µAàµ»Ìlªræè¿¢³¯êÎAð·µÄ¢éÆ»è·é\n\t\tif(distance_ls_p(P(objs[i].maxx,objs[i].maxy),P(objs[i].maxx,objs[i].miny),P(sx,sy)) < r+EPS){\n\t\t\treturn false;\n\t\t}\n\t\telse if(distance_ls_p(P(objs[i].maxx,objs[i].miny),P(objs[i].minx,objs[i].miny),P(sx,sy)) < r+EPS){\n\t\t\treturn false;\n\t\t}\n\t\telse if(distance_ls_p(P(objs[i].minx,objs[i].miny),P(objs[i].minx,objs[i].maxy),P(sx,sy)) < r+EPS){\n\t\t\treturn false;\n\t\t}\n\t\telse if(distance_ls_p(P(objs[i].maxx,objs[i].maxy),P(objs[i].minx,objs[i].maxy),P(sx,sy)) < r+EPS){\n\t\t\treturn false;\n\t\t}\n\t\telse if(distance_ls_p(P(objs[i].maxx,objs[i].maxy),P(objs[i].maxx,objs[i].miny),P(ex,ey)) < r+EPS){\n\t\t\treturn false;\n\t\t}\n\t\telse if(distance_ls_p(P(objs[i].maxx,objs[i].miny),P(objs[i].minx,objs[i].miny),P(ex,ey)) < r+EPS){\n\t\t\treturn false;\n\t\t}\n\t\telse if(distance_ls_p(P(objs[i].minx,objs[i].miny),P(objs[i].minx,objs[i].maxy),P(ex,ey)) < r+EPS){\n\t\t\treturn false;\n\t\t}\n\t\telse if(distance_ls_p(P(objs[i].maxx,objs[i].maxy),P(objs[i].minx,objs[i].maxy),P(ex,ey)) < r+EPS){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\n\twhile(cin >> n && n != 0){\n\t\tobjs.clear();\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tobj o;\n\t\t\tcin >> o.minx >> o.miny >> o.maxx >> o.maxy >> o.h;\n\t\t\tobjs.push_back(o);\n\t\t}\n\n\t\tdouble lb = 0.0;\n\t\tdouble ub = 100000000.0;\n\t\t\n\t\twhile(ub - lb >= 0.00001){\n\t\t\tdouble mid = (ub+lb)/2;\n\t\t\tif(!check(mid)){\n\t\t\t\tub = mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t}\n\t\tif(ub < 0.0001){\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%.5f\\n\",ub);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-3)\ntypedef complex<double> P;\n\ndouble dot(P a, P b) { return a.real() * b.real() + a.imag() * b.imag(); }\n\ndouble cross(P a, P b) { return a.real() * b.imag() - a.imag() * b.real(); }\n\ndouble distance(P s1, P s2, P p) {\n  if (dot(s2 - s1, p - s1) < EPS) return abs(p - s1);\n  if (dot(s1 - s2, p - s2) < EPS) return abs(p - s2);\n  return abs(cross(s2 - s1, p - s1)) / abs(s2 - s1);\n}\n\nbool is_intersected(P a1, P a2, P b1, P b2) {\n  return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS &&\n         cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS;\n}\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    int sx, sy, ex, ey;\n    cin >> sx >> sy >> ex >> ey;\n    P s(sx, sy), e(ex, ey);\n    double m = 1e3;\n    for (int i = 0; i < n; i++) {\n      int minx, miny, maxx, maxy, h;\n      cin >> minx >> miny >> maxx >> maxy >> h;\n      vector<P> v = {P(minx, miny), P(minx, maxy), P(maxx, miny), P(maxx, maxy)};\n      double d = 1e3;\n      for (auto p1 : v) {\n        for (auto p2 : v) {\n          if (is_intersected(s, e, p1, p2)) d = 0;\n        }\n      }\n      for (auto p1 : v) {\n        d = min(d, distance(s, e, p1));\n        for (auto p2 : v) {\n          if (!(abs(p2 - p1) < EPS)) {\n            d = min(d, distance(p1, p2, s));\n            d = min(d, distance(p1, p2, e));\n          }\n        }\n        m = min(m, d < h ? d : (d * d + h * h) / (2 * h));\n      }\n    }\n    cout << fixed << setprecision(3) << m << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n#define EPS (1e-10)\n\nint SX, SY, TX, TY;\nint N;\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\nbool intersect(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\ndouble dist(P a, P b, P c) {\n  if (dot(b-a, c-a) < 0) return abs(c-a);\n  if (dot(a-b, c-b) < 0) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble f(double d, double h) {\n  if (h >= d) return d;\n  double lo = d, hi = 1e10;\n  rep(_, 200) {\n    double mid = (lo + hi) / 2;\n    double t = mid / (mid/h - 1);\n    double g = sqrt(t*t - h*h) * (mid/h - 1);\n    if (d >= g) lo = mid;\n    else hi = mid;\n  }\n  return lo;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> N) {\n    if (N == 0) break;\n    cin >> SX >> SY >> TX >> TY;\n    double ans = 1e10;\n    rep(i, N) {\n      int lx, ly, rx, ry, h;\n      cin >> lx >> ly >> rx >> ry >> h;\n      if (intersect(P(SX, SY), P(TX, TY), P(lx, ly), P(lx, ry))) ans = 0;\n      if (intersect(P(SX, SY), P(TX, TY), P(lx, ry), P(rx, ry))) ans = 0;\n      if (intersect(P(SX, SY), P(TX, TY), P(rx, ry), P(rx, ly))) ans = 0;\n      if (intersect(P(SX, SY), P(TX, TY), P(rx, ly), P(lx, ly))) ans = 0;\n      if (lx<=SX&&ly<=SY&&rx>=TX&&ry>=TY) ans = 0;\n      if(ans==0)break;\n      ans = min(ans, f(dist(P(SX, SY), P(TX, TY), P(lx, ly)), h));\n      ans = min(ans, f(dist(P(SX, SY), P(TX, TY), P(lx, ry)), h));\n      ans = min(ans, f(dist(P(SX, SY), P(TX, TY), P(rx, ly)), h));\n      ans = min(ans, f(dist(P(SX, SY), P(TX, TY), P(rx, ry)), h));\n\n      ans = min(ans, f(dist(P(lx, ly), P(lx, ry), P(SX, SY)), h));\n      ans = min(ans, f(dist(P(lx, ry), P(rx, ry), P(SX, SY)), h));\n      ans = min(ans, f(dist(P(rx, ry), P(rx, ly), P(SX, SY)), h));\n      ans = min(ans, f(dist(P(rx, ly), P(lx, ly), P(SX, SY)), h));\n\n      ans = min(ans, f(dist(P(lx, ly), P(lx, ry), P(TX, TY)), h));\n      ans = min(ans, f(dist(P(lx, ry), P(rx, ry), P(TX, TY)), h));\n      ans = min(ans, f(dist(P(rx, ry), P(rx, ly), P(TX, TY)), h));\n      ans = min(ans, f(dist(P(rx, ly), P(lx, ly), P(TX, TY)), h));\n    }\n    cout << fixed << setprecision(20) << ans << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-8;\n\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\ninline int ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(cross(b,c) > EPS)return 1;\n  if(cross(b,c) < -EPS)return -1;\n  if(dot(b,c) < -EPS)return 2;\n  if(abs(b)+EPS < abs(c))return -2;\n  return 0;\n}\n\ninline D seg_p_dis(L a, P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\ninline bool is_cp(L a, L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline D seg_seg_dis(L a, L b){\n  D res = 1e10;\n  res = min(res, seg_p_dis(a,b.fs));\n  res = min(res, seg_p_dis(a,b.sc));\n  res = min(res, seg_p_dis(b,a.fs));\n  res = min(res, seg_p_dis(b,a.sc));\n  return res;\n}\n\ninline bool isCross(L a, Poly p){\n  int n = p.size();\n  rep(i,n){\n    if(is_cp(a, L(p[i],p[(i+1)%n])))return true;\n  }\n  return false;\n}\n\ninline bool isIn(L a, Poly p){\n  P x = a.fs;\n  rep(i,p.size())if(ccw(p[i],p[(i+1)%p.size()],x) == -1)return false;\n  return true;\n}\n\nint main(){\n  int n;\n  while(cin >> n){\n    if(n==0)break;\n    L line;\n    {\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      line = L(P(x1,y1),P(x2,y2));\n    }\n\n    vector<Poly> obj(n);\n    vector<D> h(n);\n\n    rep(i,n){\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2 >> h[i];\n      obj[i].push_back(P(x1,y1));\n      obj[i].push_back(P(x2,y1));\n      obj[i].push_back(P(x2,y2));\n      obj[i].push_back(P(x1,y2));\n    }\n\n    bool f = false;\n    rep(i,n){\n      if(isCross(line,obj[i]) || isIn(line,obj[i])){\n\tf = true;\n      }\n    }\n    if(f){\n      cout << fixed << setprecision(5) << 0 << endl;\n      continue;\n    }\n\n    D l = 0, r = 1000;\n    rep(azu,100){\n      D mid = (l+r)/2;\n      \n      bool f = true;\n      rep(i,n){\n\tD dis = 1e10;\n\trep(j,4){\n\t  dis = min(dis, seg_seg_dis(line, L(obj[i][j],obj[i][(j+1)%4])));\n\t}\n\tif(h[i] < mid){\n\t  if(sqrt(dis*dis + (mid-h[i])*(mid-h[i])) < mid)f = false;\n\t}else{\n\t  if(dis < mid)f = false;\n\t}\n\tif(!f)break;\n      }\n\n      if(f)l = mid;\n      else r = mid;\n    }\n    cout << fixed << setprecision(5) << l << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<double, double> PDD;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nPDD operator-(const PDD &a, const PDD &b) {\n  return PDD(a.fi - b.fi, a.se - b.se);\n}\n\ndouble len(PDD p) {\n  return sqrt(p.fi * p.fi + p.se * p.se);\n}\n\ndouble dot(PDD a, PDD b) {\n  return a.fi * b.fi + a.se * b.se;\n}\n\ndouble cross(PDD a, PDD b) {\n  return a.fi * b.se - a.se * b.fi;\n}\n\ndouble distance(PDD p1, PDD p2, PDD q1, PDD q2) {\n  if (cross(p2 - p1, q1 - p1) * cross(p2 - p1, q2 - p1) < 0 && cross(q2 - q1, p1 - q1) * cross(q2 - q1, p2 - q1) < 0) {\n    return 0;\n  } else {\n    double mini = INF;\n    if (dot(p2 - p1, q1 - p1) < 1e-7) minch(mini, len(q1 - p1));\n    else if (dot(p1 - p2, q1 - p2) < 1e-7) minch(mini, len(q1 - p2));\n    else minch(mini, abs(cross(p2 - p1, q1 - p1)) / len(p2 - p1));\n\n    if (dot(p2 - p1, q2 - p1) < 1e-7) minch(mini, len(q2 - p1));\n    else if (dot(p1 - p2, q2 - p2) < 1e-7) minch(mini, len(q2 - p2));\n    else minch(mini, abs(cross(p2 - p1, q2 - p1)) / len(p2 - p1));\n\n    if (dot(q2 - q1, p1 - q1) < 1e-7) minch(mini, len(p1 - q1));\n    else if (dot(q1 - q2, p1 - q2) < 1e-7) minch(mini, len(p1 - q2));\n    else minch(mini, abs(cross(q2 - q1, p1 - q1)) / len(q2 - q1));\n\n    if (dot(q2 - q1, p2 - q1) < 1e-7) minch(mini, len(p2 - q1));\n    else if (dot(q1 - q2, p2 - q2) < 1e-7) minch(mini, len(p2 - q2));\n    else minch(mini, abs(cross(q2 - q1, p2 - q1)) / len(q2 - q1));\n\n    return mini;\n  }\n}\n\nint main(){\n  int n;\n  while(cin >> n, n) {\n    PDD s, e;\n    cin >> s.fi >> s.se >> e.fi >> e.se;\n    vector<double> v;\n\n    bool ok = true;\n    rep(i, n) {\n      PDD mi, ma;\n      double h;\n      cin >> mi.fi >> mi.se >> ma.fi >> ma.se >> h;\n      double mini = INF;\n      minch(mini, distance(s, e, mi, PDD(ma.fi, mi.se)));\n      minch(mini, distance(s, e, mi, PDD(mi.fi, ma.se)));\n      minch(mini, distance(s, e, ma, PDD(ma.fi, mi.se)));\n      minch(mini, distance(s, e, ma, PDD(mi.fi, ma.se)));\n      minch(mini, distance(s, e, mi, ma));\n      if (mini == 0) {\n        ok = false;\n        break;\n      } else {\n        if (mini < h) v.pb(mini);\n        else {\n          double high = 10000, low = mini, mid;\n          rep(j, 100) {\n            mid = (high + low) / 2;\n            if ((mid - h) * (mid - h) + mini * mini >= mid * mid) low = mid;\n            else high = mid;\n          }\n          v.pb(low);\n        }\n      }\n    }\n\n    if (ok) {\n      sort(all(v));\n      printf(\"%.10f\\n\", v[0]);\n    } else {\n      cout << 0 << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//二次元幾何ライブラリ\n#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define ML make_pair \ntypedef double D;\ntypedef bool B;\ntypedef complex<D> P;   //点\ntypedef complex<D> V;   //ベクトル\ntypedef pair<P,P>  L;   //直線\ntypedef pair<P,D>  C;   //円\ntypedef vector<P>  Pol; //多角形\n\n//変数名定義\nconst D INF = 1e100;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ntemplate<class T> bool operator==(T a, T b){return abs(a - b )< EPS;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n\n\n\n// ベクトルaの絶対値を求める\n// D Length = abs(a);\n\n// 2点a,b間の距離を求める\n// D Distance = abs(a-b); \n\n// 内積 (Inner Product) : a・b = |a||b|cosθ\nD IP(V a, V b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (Exterior Product) : |a×b| = |a||b|sinθ \nD EP(V a, V b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n// 点の進行方向について\nint ccw(P a, P b, P c) {              //点aと点bが与えられた問いに\n  b -= a; c -= a;\n  if (EP(b, c) > 0)   return +1;      // counter clockwise\n  if (EP(b, c) < 0)   return -1;      // clockwise\n  if (IP(b, c) < 0)     return +2;    // c--a--b on line\n  if (norm(b) < norm(c)) return -2;   // a--b--c on line\n  return 0;                           // a--c--b on line  aとbの線分判定はこれ\n}\n\n\n// 2直線の垂直判定 : a⊥b <=> IP(a, b) = 0\nB IsVecular(L l1, L l2) {\n\treturn IP(l1.first-l1.second, l2.first-l2.second)==0.0;\n}\n\n// 2直線の平行判定 : a//b <=> EP(a, b) = 0\nB IsParallel(L l1, L l2) {\n\treturn EP(l1.first-l1.second, l2.first-l2.second)== 0.0;\n}\n\n// 2線分の交差判定 \nB IIS(L l1, L l2) {\n  return ( EP(l1.second-l1.first, l2.first-l1.first) * EP(l1.second-l1.first, l2.second-l1.first) < EPS ) &&\n         ( EP(l2.second-l2.first, l1.first-l2.first) * EP(l2.second-l2.first, l1.second-l2.first) < EPS );\n}\n\n// 符号付き点と直線の距離 (Distance of Point and Line)  //lの構造 x座標 first<second y座標 first<second 左上 正 右下 負 一致 0\nD  DPL(P p,L l){\n\tV v1=(l.second-l.first);\n\tV v2=(p-l.first);\n\treturn EP(v1,v2)/abs(v1);\n}\n\n// 点と線分の距離 (Distance of Point and Segment)  //lの構造 x座標 first<second y座標 first < second \nD  DPS(P p,L l){\n\tV v1,v2,v3;\n\tv1=l.second-l.first;\n\tv2=p-l.first;\n\tv3=p-l.second;\n\tif(IP (v1,v2) <0)\n\t\treturn abs(p-l.first);\n\telse if(IP(-v1,v3)<0)\n\t\treturn abs(p-l.second);\n\telse\n\t\treturn abs(DPL(p,l));\n}\n\n// 線分と線分の距離 (Distance of Segment and Segment)  //lの構造 x座標 first<second y座標 first < second \nD DSS(L l1,L l2){\n\tif(IIS(l1,l2))\n\t\treturn 0;\n\telse{\n\t\tD tem,tem1,tem2;\n\t\ttem1=min(DPS(l1.first,l2),DPS(l1.second,l2));\n\t\ttem2=min(DPS(l2.first,l1),DPS(l2.second,l1));\n\t\treturn\tmin(tem1,tem2);\n\t}\n}\n\n// 三角形の領域判定 Teritory of Triangle 1が内部 0が境界と外部\nB TT(P p1,P p2,P p3,P p){\n\tL l1,l2,l3;\n\tl1=make_pair(p2,p3);\n\tl2=make_pair(p3,p1);\n\tl3=make_pair(p1,p2);\n\n\tif(sig(DPL(p1,l1))!=sig(DPL(p,l1)))\n\t\treturn false;\n\telse if(sig(DPL(p2,l2))!=sig(DPL(p,l2)))\n\t\treturn false;\n\telse if(sig(DPL(p3,l3))!=sig(DPL(p,l3)))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n//変数名 = 型 代入したいもの\n//example : v1 = V(5.0,-3.0) p1=P(0.0,4.0)\nint main(void){\n\twhile(true){\n\tint N;\n\t\tcin >>N; \n\tif(!N)\n\t\tbreak;\n\tD Block[50][2][2];\n\tD h[50];\n\tP root1,root2;\n\tL root;\n\tD r;\n\tD rmin=INF;\n\t\tcin >> root1.real() >> root1.imag() >> root2.real() >> root2.imag();\n\trep(i,N)\n\t\tcin >>Block[i][0][0] >>Block[i][0][1] >> Block[i][1][0] >> Block[i][1][1] >>h[i] ;\n\troot=ML(root1,root2);\n\trep(i,N){\n\t\t\tD tem,tem1,tem2;\n\t\t\tP p1,p2,p3,p4;\n\t\t\tp1=P(Block[i][0][0],Block[i][0][1]);\n\t\t\tp2=P(Block[i][1][0],Block[i][0][1]);\n\t\t\tp3=P(Block[i][1][0],Block[i][1][1]);\n\t\t\tp4=P(Block[i][0][0],Block[i][1][1]);\n\t\t\tL la,lb,lc,ld;\n\t\t\tla=ML(p1,p2);\n\t\t\tlb=ML(p2,p3);\n\t\t\tlc=ML(p3,p4);\n\t\t\tld=ML(p4,p1);\n\t\t\tif(p1.real()<root1.real()&&root1.real()<p3.real()&&p1.imag()<root1.imag()&&root1.imag()<p3.imag())\n\t\t\t\ttem=0;\n\t\t\telse {\n\t\t\t\ttem1=min(DSS(root,la),DSS(root,lb));\n\t\t\t\ttem2=min(DSS(root,lc),DSS(root,ld));\n\t\t\t\ttem=min(tem1,tem2);\n\t\t\t}\n\t\t\tif(tem<=h[i])\n\t\t\t\tr=tem;\n\t\t\telse\n\t\t\t\tr=(h[i]+tem*tem/h[i])/2.0;\n\t\t\tif(rmin > r)\n\t\t\t\trmin=r;\n\t}\n\tprintf(\"%.4lf\\n\",rmin);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<double, double> PDD;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nPDD operator-(const PDD &a, const PDD &b) {\n  return PDD(a.fi - b.fi, a.se - b.se);\n}\n\ndouble len(PDD p) {\n  return sqrt(p.fi * p.fi + p.se * p.se);\n}\n\ndouble dot(PDD a, PDD b) {\n  return a.fi * b.fi + a.se * b.se;\n}\n\ndouble cross(PDD a, PDD b) {\n  return a.fi * b.se - a.se * b.fi;\n}\n\ndouble distance(PDD p1, PDD p2, PDD q1, PDD q2) {\n  if (cross(p2 - p1, q1 - p1) * cross(p2 - p1, q2 - p1) < 0 && cross(q2 - q1, p1 - q1) * cross(q2 - q1, p2 - q1) < 0) {\n    return 0;\n  } else {\n    double mini = INF;\n    if (dot(p2 - p1, q1 - p1) < 1e-7) minch(mini, len(q1 - p1));\n    else if (dot(p1 - p2, q1 - p2) < 1e-7) minch(mini, len(q1 - p2));\n    else minch(mini, abs(cross(p2 - p1, q1 - p1)) / len(p2 - p1));\n\n    if (dot(p2 - p1, q2 - p1) < 1e-7) minch(mini, len(q2 - p1));\n    else if (dot(p1 - p2, q2 - p2) < 1e-7) minch(mini, len(q2 - p2));\n    else minch(mini, abs(cross(p2 - p1, q2 - p1)) / len(p2 - p1));\n\n    if (dot(q2 - q1, p1 - q1) < 1e-7) minch(mini, len(p1 - q1));\n    else if (dot(q1 - q2, p1 - q2) < 1e-7) minch(mini, len(p1 - q2));\n    else minch(mini, abs(cross(q2 - q1, p1 - q1)) / len(q2 - q1));\n\n    if (dot(q2 - q1, p2 - q1) < 1e-7) minch(mini, len(p2 - q1));\n    else if (dot(q1 - q2, p2 - q2) < 1e-7) minch(mini, len(p2 - q2));\n    else minch(mini, abs(cross(q2 - q1, p2 - q1)) / len(q2 - q1));\n\n    return mini;\n  }\n}\n\nint main(){\n  int n;\n  while(cin >> n, n) {\n    PDD s, e;\n    cin >> s.fi >> s.se >> e.fi >> e.se;\n\n    double ans = INF;\n    bool ok = true;\n    rep(i, n) {\n      PDD mi, ma;\n      double h;\n      cin >> mi.fi >> mi.se >> ma.fi >> ma.se >> h;\n      double mini = INF;\n      minch(mini, distance(s, e, mi, PDD(ma.fi, mi.se)));\n      minch(mini, distance(s, e, mi, PDD(mi.fi, ma.se)));\n      minch(mini, distance(s, e, ma, PDD(ma.fi, mi.se)));\n      minch(mini, distance(s, e, ma, PDD(mi.fi, ma.se)));\n      minch(mini, distance(s, e, mi, ma));\n      if (mini == 0) {\n        ok = false;\n        break;\n      } else {\n        if (mini < h) {\n          minch(ans, mini);\n        } else {\n          double high = 1000, low = mini, mid;\n          rep(j, 100) {\n            mid = (high + low) / 2;\n            if ((mid - h) * (mid - h) + mini * mini >= mid * mid) low = mid;\n            else high = mid;\n          }\n          minch(ans, low);\n        }\n      }\n    }\n\n    if (ok) {\n      printf(\"%.10f\\n\", ans);\n    } else {\n      printf(\"0\");\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nconst double EPS = 1e-9;\ntemplate<typename T>\nT sqr(T a) { return a * a; }\n\nstruct search_point {\n\tdouble x, y;\n\tdouble h;\n\tsearch_point(double x_, double y_, double h_) {\n\t\tx = x_; y = y_; h = h_;\n\t}\n};\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tdouble sx, sy, ex, ey;\n\t\tvector<search_point> v;\n\t\tvector<pair<search_point,search_point> > line;\n\t\tvector<pair<search_point,search_point> > lect;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tdouble R = 10000;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble h;\n\t\t\tcin >> x0 >> y0 >> x1 >> y1 >> h;\n\n\t\t\tif(h < EPS)\n\t\t\t\th = EPS;\n\n\t\t\tv.push_back(search_point(x0, y0, h));\n\t\t\tv.push_back(search_point(x1, y1, h));\n\t\t\tv.push_back(search_point(x0, y1, h));\n\t\t\tv.push_back(search_point(x1, y0, h));\n\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x0, y0, 0), search_point(x1, y0, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x1, y0, 0), search_point(x1, y1, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x1, y1, 0), search_point(x0, y1, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x0, y1, 0), search_point(x0, y0, 0)));\n\n\t\t\tlect.push_back(pair<search_point,search_point>(search_point(x0, y0, 0), search_point(x1, y1, 0)));\n\n\t\t\tif(x0 <= sx && sx <= x1) {\n\t\t\t\tv.push_back(search_point(sx, y0, h));\n\t\t\t\tv.push_back(search_point(sx, y1, h));\n\t\t\t}\n\t\t\tif(y0 <= sy && sy <= y1) {\n\t\t\t\tv.push_back(search_point(x0, sy, h));\n\t\t\t\tv.push_back(search_point(x1, sy, h));\n\t\t\t}\n\t\t\tif(x0 <= ex && ex <= x1) {\n\t\t\t\tv.push_back(search_point(ex, y0, h));\n\t\t\t\tv.push_back(search_point(ex, y1, h));\n\t\t\t}\n\t\t\tif(y0 <= ey && ey <= y1) {\n\t\t\t\tv.push_back(search_point(x0, ey, h));\n\t\t\t\tv.push_back(search_point(x1, ey, h));\n\t\t\t}\n\t\t}\n\n\t\tdouble veclx = (ex - sx);\n\t\tdouble vecly = (ey - sy);\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tdouble d;\n\t\t\tdouble mx, my;\n\t\t\tdouble r;\n\n\t\t\tmx = (v[i].x * sqr(veclx) + v[i].y * veclx * vecly + vecly * (sx * ey - sy * ex)) / (sqr(veclx) + sqr(vecly));\n\t\t\tmy = (v[i].y * sqr(vecly) + v[i].x * vecly * veclx + veclx * (sy * ex - sx * ey)) / (sqr(vecly) + sqr(veclx));\n\t\t\t/*\n\t\t\tif((ey - sy) * mx - (ex - sx) * my + (ex * sy - sx * ey) > EPS) {\n\t\t\t\tcout << \"error\" << \" \" << (sy - ey) * mx - (sx - ex) * my - (ex * sy - sx * ey) << endl;\n\t\t\t\tcout << mx << \",\" << my << endl;\n\t\t\t}\n\t\t\t// */\n\t\t\td = sqrt(sqr(mx - v[i].x) + sqr(my - v[i].y));\n\t\t\tif(mx <= min(sx,ex) || max(sx,ex) <= mx || my <= min(sy,ey) || max(sy,ey) <= my) {\n\t\t\t\td = min(sqrt(sqr(sx - v[i].x) + sqr(sy -  v[i].y)), sqrt(sqr(ex - v[i].x) + sqr(ey - v[i].y)));\n\t\t\t}\n\t\t\tr = fabs(sqr(min(v[i].h,d)) + sqr(d)) / (2 * v[i].h);\n\t\t\tR = min(R, r);\n\t\t}\n\t\tfor(int i = 0; i < line.size(); i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble s, t;\n\t\t\tx0 = line[i].first.x;  y0 = line[i].first.y;\n\t\t\tx1 = line[i].second.x; y1 = line[i].second.y;\n\n\t\t\ts = ((ex - sx) * (y1 - sy) - (ey - sy) * (x1 - sx)) / ((x0 - sx) * (y1 - sy) - (y0 - sy) * (x1 - sx));\n\t\t\tt = ((ex - sx) * (y0 - sy) - (ey - sy) * (x0 - sx)) / ((x1 - sx) * (y0 - sy) - (y1 - sy) * (x0 - sx));\n\n\t\t\tif(s > -EPS && t > -EPS && s + t > 1 - EPS) {\n\t\t\t\tif(isinf(s) | isinf(t))\n\t\t\t\t\texit(1);\n\t\t\t\tR = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < lect.size(); i++) {\n\t\t\tbool flag0, flag1;\n\t\t\tflag0 = lect[i].first.x < sx && sx < lect[i].second.x && lect[i].first.y < sy && sy < lect[i].second.y;\n\t\t\tflag1 = lect[i].first.x < ex && ex < lect[i].second.x && lect[i].first.y < ey && ey < lect[i].second.y;\n\n\t\t\tif(flag0 | flag1) {\n\t\t\t\tR = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\", R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//二次元幾何ライブラリ\n#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define ML make_pair \ntypedef double D;\ntypedef bool B;\ntypedef complex<D> P;   //点\ntypedef complex<D> V;   //ベクトル\ntypedef pair<P,P>  L;   //直線\ntypedef pair<P,D>  C;   //円\ntypedef vector<P>  Pol; //多角形\n\n//変数名定義\nconst D INF = 1e100;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ntemplate<class T> bool operator==(T a, T b){return abs(a - b )< EPS;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n\n\n\n// ベクトルaの絶対値を求める\n// D Length = abs(a);\n\n// 2点a,b間の距離を求める\n// D Distance = abs(a-b); \n\n// 内積 (Inner Product) : a・b = |a||b|cosθ\nD IP(V a, V b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (Exterior Product) : |a×b| = |a||b|sinθ \nD EP(V a, V b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n// 点の進行方向について\nint ccw(P a, P b, P c) {              //点aと点bが与えられた問いに\n  b -= a; c -= a;\n  if (EP(b, c) > 0)   return +1;      // counter clockwise\n  if (EP(b, c) < 0)   return -1;      // clockwise\n  if (IP(b, c) < 0)     return +2;    // c--a--b on line\n  if (norm(b) < norm(c)) return -2;   // a--b--c on line\n  return 0;                           // a--c--b on line  aとbの線分判定はこれ\n}\n\n\n// 2直線の垂直判定 : a⊥b <=> IP(a, b) = 0\nB IsVecular(L l1, L l2) {\n\treturn IP(l1.first-l1.second, l2.first-l2.second)==0.0;\n}\n\n// 2直線の平行判定 : a//b <=> EP(a, b) = 0\nB IsParallel(L l1, L l2) {\n\treturn EP(l1.first-l1.second, l2.first-l2.second)== 0.0;\n}\n\n// 2線分の交差判定 \nB IIS(L l1, L l2) {\n  return ( EP(l1.second-l1.first, l2.first-l1.first) * EP(l1.second-l1.first, l2.second-l1.first) < -EPS ) &&\n         ( EP(l2.second-l2.first, l1.first-l2.first) * EP(l2.second-l2.first, l1.second-l2.first) < -EPS );\n}\n\n// 符号付き点と直線の距離 (Distance of Point and Line)  //lの構造 x座標 first<second y座標 first<second 左上 正 右下 負 一致 0\nD  DPL(P p,L l){\n\tV v1=(l.second-l.first);\n\tV v2=(p-l.first);\n\treturn EP(v1,v2)/abs(v1);\n}\n\n// 点と線分の距離 (Distance of Point and Segment)  //lの構造 x座標 first<second y座標 first < second \nD  DPS(P p,L l){\n\tV v1,v2,v3;\n\tv1=l.second-l.first;\n\tv2=p-l.first;\n\tv3=p-l.second;\n\tif(IP (v1,v2) <0)\n\t\treturn abs(p-l.first);\n\telse if(IP(-v1,v3)<0)\n\t\treturn abs(p-l.second);\n\telse\n\t\treturn abs(DPL(p,l));\n}\n\n// 線分と線分の距離 (Distance of Segment and Segment)  //lの構造 x座標 first<second y座標 first < second \nD DSS(L l1,L l2){\n\tif(IIS(l1,l2))\n\t\treturn 0;\n\telse{\n\t\tD tem,tem1,tem2;\n\t\ttem1=min(DPS(l1.first,l2),DPS(l1.second,l2));\n\t\ttem2=min(DPS(l2.first,l1),DPS(l2.second,l1));\n\t\treturn\tmin(tem1,tem2);\n\t}\n}\n\n// 三角形の領域判定 Teritory of Triangle 1が内部 0が境界と外部\nB TT(P p1,P p2,P p3,P p){\n\tL l1,l2,l3;\n\tl1=make_pair(p2,p3);\n\tl2=make_pair(p3,p1);\n\tl3=make_pair(p1,p2);\n\n\tif(sig(DPL(p1,l1))!=sig(DPL(p,l1)))\n\t\treturn false;\n\telse if(sig(DPL(p2,l2))!=sig(DPL(p,l2)))\n\t\treturn false;\n\telse if(sig(DPL(p3,l3))!=sig(DPL(p,l3)))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n//変数名 = 型 代入したいもの\n//example : v1 = V(5.0,-3.0) p1=P(0.0,4.0)\nint main(void){\n\twhile(true){\n\tint N;\n\t\tcin >>N; \n\tif(!N)\n\t\tbreak;\n\tD Block[50][2][2];\n\tD h[50];\n\tP root1,root2;\n\tL root;\n\tD r;\n\tD rmin=INF;\n\t\tcin >> root1.real() >> root1.imag() >> root2.real() >> root2.imag();\n\trep(i,N)\n\t\tcin >>Block[i][0][0] >>Block[i][0][1] >> Block[i][1][0] >> Block[i][1][1] >>h[i] ;\n\troot=ML(root1,root2);\n\trep(i,N){\n\t\t\tD tem,tem1,tem2;\n\t\t\tP p1,p2,p3,p4;\n\t\t\tp1=P(Block[i][0][0],Block[i][0][1]);\n\t\t\tp2=P(Block[i][1][0],Block[i][0][1]);\n\t\t\tp3=P(Block[i][1][0],Block[i][1][1]);\n\t\t\tp4=P(Block[i][0][0],Block[i][1][1]);\n\t\t\tL la,lb,lc,ld;\n\t\t\tla=ML(p1,p2);\n\t\t\tlb=ML(p2,p3);\n\t\t\tlc=ML(p3,p4);\n\t\t\tld=ML(p4,p1);\n\t\t\tif(p1.real()<root1.real()&&root1.real()<p3.real()&&p1.imag()<root1.imag()&&root1.imag()<p3.imag())\n\t\t\t\ttem=0;\n\t\t\telse {\n\t\t\t\ttem1=min(DSS(root,la),DSS(root,lb));\n\t\t\t\ttem2=min(DSS(root,lc),DSS(root,ld));\n\t\t\t\ttem=min(tem1,tem2);\n\t\t\t}\n\t\t\tif(tem<=h[i])\n\t\t\t\tr=tem;\n\t\t\telse\n\t\t\t\tr=(h[i]+tem*tem/h[i])/2.0;\n\t\t\tif(rmin > r)\n\t\t\t\trmin=r;\n\t}\n    cout << fixed << rmin << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-10;\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\nint main(){\n  while(true){\n    int n;\n    cin>>n;\n    if(!n)break;\n    double r,r_min = 1000;\n    double sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    P s=P(sx,sy),e=P(ex,ey);\n    for(int i=0;i<n;i++){\n      double x1,y1,x2,y2,h;\n      cin>>x1>>y1>>x2>>y2>>h;\n      P p[4]={ P(x1,y1),P(x2,y1),P(x2,y2),P(x1,y2)};\n      if(is_intersected_ls(s,e,p[0],p[1])\n\t ||is_intersected_ls(s,e,p[1],p[2])\n\t ||is_intersected_ls(s,e,p[2],p[3])\n\t ||is_intersected_ls(s,e,p[3],p[0])\n\t ||(x1<min(sx,ex)&&y1<min(sy,ey)&&max(sx,ex)<x2&&max(sy,ey)<y2)){\n\tr_min = 0;\n      }\n      if(r_min-EPS>0){\n\tdouble l=1000;\n\tfor(int j=0;j<4;j++){\n\t  l = min(l,distance_ls_p(s,e,p[j]));\n\t  l = min(l,distance_ls_p(p[j],p[(j+1)%4],s));\n\t  l = min(l,distance_ls_p(p[j],p[(j+1)%4],e));\n\t}\n\tr = h>l?l:(h*h+l*l)/(2*h);\n\tif(r<r_min)r_min = r;\n      }\n    }\n    printf(\"%.5f\\n\",r_min);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lint;\n\nconst double EPS = 1e-8;\n\nclass Point{\npublic:\n    double x, y;\n    Point(double x = 0, double y = 0): x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(x * a, y * a);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    Point operator * (const Point &a){\n        return Point(x * a.x - y * a.y, x * a.y + y * a.x);\n    }\n    bool operator < (const Point &p) const {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const Point &p) const {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a){return (a.x * a.x + a.y * a.y);}\ndouble abs(Vector a){return (sqrt(norm(a)));}\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS) return (+1);\n    if (cross(a, b) < -EPS) return (-1);\n    if (dot(a, b) < -EPS) return (+2);\n    if (norm(a) < norm(b)) return (-2);\n    return (0);\n}\n\nbool isIntersectSP(Point p1, Point p2, Point p)\n{\n    return (ccw(p1, p2, p) == 0);\n}\n\nbool isIntersectSS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nPoint projection(Point p1, Point p2, Point p3)\n{\n    double t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n    return (p1 + (p2 - p1) * t);\n}\n\ndouble distanceSP(Point s1, Point s2, Point p)\n{\n    Point r = projection(s1, s2, p);\n    if (isIntersectSP(s1, s2, r)) return (abs(r - p));\n    return (min(abs(s1 - p), abs(s2 - p)));\n}\n\ndouble distanceSS(Point s1, Point s2, Point t1, Point t2){\n    if (isIntersectSS(s1, s2, t1, t2)) return (0);\n    return (min(min(distanceSP(s1, s2, t1), distanceSP(s1, s2, t2)),\n            min(distanceSP(t1, t2, s1), distanceSP(t1, t2, s2))));\n}\n\nint main()\n{\n    int n;\n    while (scanf(\"%d\", &n) && n){\n        Point s, e;\n        scanf(\"%lf %lf %lf %lf\", &s.x, &s.y, &e.x, &e.y);\n\n        double ans = 1001001001ll;\n        for (int i = 0; i < n; i++){\n            double minx, miny, maxx, maxy, h;\n            scanf(\"%lf %lf %lf %lf %lf\", &minx, &miny, &maxx, &maxy, &h);\n            Point p1 = Point(minx, miny), p2 = Point(minx, maxy),\n                  p3 = Point(maxx, miny), p4 = Point(maxx, maxy);\n            double dist = min(min(distanceSS(p1, p2, s, e), distanceSS(p3, p4, s, e)),\n                              min(distanceSS(p1, p3, s, e), distanceSS(p2, p4, s, e)));\n\n            if ((minx <= min(s.x, e.x) && max(s.x, e.x) <= maxx &&\n                 miny <= min(s.y, e.y) && max(s.y, e.y) <= maxy)) ans = 0;\n            if (dist <= h) ans = min(ans, dist);\n            else {\n                ans = min(ans, 0.5 * (h + dist * dist / h));\n            }\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<complex>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define inf (1<<29)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -inf,double y = -inf): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nstruct Circle\n{\n  Point p;\n  double r;\n  Circle(Point p=Point(),double r=inf):p(p),r(r){}\n};\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n\n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n\nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //polyの最後の要素 = polyの最初の要素 であることが前提\n  \n  //そうでない場合は\n    rep(i,poly.size())\n      if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n    double sum = 0;\n    for(int i=0; i < (int)poly.size() ;i++)\n      {\n        if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n          sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n        else\n          sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n      }\n      return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS); \n}  \n\n\nPoint project(Segment s,Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1 + base*t;\n}\n\ndouble getDistance(Segment s1,Segment s2)\n{\n  if(isIntersect(s1,s2))return 0;\n  return min( min(getDistanceSP(s1,s2.p1), getDistanceSP(s1,s2.p2) ),\n\t      min(getDistanceSP(s2,s1.p1), getDistanceSP(s2,s1.p2) ));\n}\n\nstruct Obj\n{\n  vector<Point> ps;\n  double h;\n  Obj(Point ps1=Point(),Point ps2=Point(),double h=-inf):h(h)\n  {\n    ps.clear();\n    ps.resize(4);\n    ps[0].x = ps1.x,ps[0].y = ps1.y;\n    ps[1].x = ps1.x,ps[1].y = ps2.y;\n    ps[2].x = ps2.x,ps[2].y = ps2.y;\n    ps[3].x = ps2.x,ps[3].y = ps1.y;\n  }\n};\nint N;\nPoint s,e;\n\nint main()\n{\n \n  while(cin >> N,N)\n    {\n      cin >> s.x >> s.y >> e.x >> e.y;   \n      Obj vec;\n      Circle c(s);\n      Segment seg(s,e);\n      rep(i,N)\n\t{\n\t  Point a,b;\n\t  double h;\n\t  cin >> a.x >> a.y >> b.x >> b.y >> h;\n\t  if(c.r == 0)continue;\n\t  vec = Obj(a,b,h);\n\t  rep(j,4)\n\t    {\n\t      if(isIntersect(seg,Segment(vec.ps[j],vec.ps[(j+1)%4])) )\n\t\t{\n\t\t  c.r = 0;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  if(inPolygon(vec.ps,s) || inPolygon(vec.ps,e))\n\t    {\n\t      c.r = 0;\n\t      break;\n\t    }\n\n\t  rep(j,4)\n\t    {\n\t      /*\n\t      Point p = project(line,vec[i].ps[j]);\n\t      cout << \"on point = \" << p.x << \",\" << p.y << endl;\n\t      c.p = p;\n\t      */\n\t      double w = getDistance(seg,Segment(vec.ps[j],vec.ps[(j+1)%4]));\n\t      //cout << \"w = \"<< w << endl;\n\t      //if(equals(w,h) || w < h)continue;\n\t   \n\t      double dist = (h*h+w*w)/(2.0*h);\n\t      //cout <<\"the distance is \" << dist << endl; \n\t      c.r = min(c.r,dist);\n\t      //cout << \"c.r = \" << c.r << endl;\n\t    }\n\t  \n\n\t  \n\t  //cout << endl;\n\t}\n      cout << setiosflags(ios::fixed) << setprecision(10) << c.r << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(const Point &p0,const Point &p1,const Point &p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nPoint projection(const Segment &s,const Point &p){\n    Vector b = s.t-s.s;\n    double t = dot(p-s.s,b)/norm(b);\n    return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n    return (ccw(s.s,s.t,p) == 0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n            ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n    Point r = projection(s,p);\n    if(isIntersectSP(s,r)) return abs(r-p);\n    return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment &a,const Segment &b){\n    if(isIntersectSS(a,b)) return 0;\n    return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n           min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nstruct Block{\n    Point a,b;\n    double h;\n    Block(){}\n    Block(Point &a,Point &b,double h) :\n        a(a),b(b),h(h) {}\n};\n\nistream &operator >> (istream &is,Point &p){ \n    return is >> p.x >> p.y;\n}\n\ndouble calc(double a,double b){\n    return sqrt(a*a+b*b);\n}\n\nbool c(double r,Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point a = v[i].a,b = v[i].b;\n        Point c(a.x,b.y),d(b.x,a.y);\n        Segment s1(a,c),s2(a,d),s3(c,b),s4(d,b);\n        double dst[] = {\n            distanceSS(p,s1),distanceSS(p,s2),\n            distanceSS(p,s3),distanceSS(p,s4)\n        };\n \n        if(r <= v[i].h){\n            if(!(r < dst[0] && r < dst[1] &&\n                 r < dst[2] && r < dst[3])){\n                return 0;\n            }\n        }else{\n            double nh = r - v[i].h;\n            if(!(r < calc(nh,dst[0]) && r < calc(nh,dst[1]) &&\n                 r < calc(nh,dst[2]) && r < calc(nh,dst[3]))){\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nbool check(Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point c(v[i].a.x,v[i].b.y);\n        Point d(v[i].b.x,v[i].a.y);\n        Segment s1(v[i].a,c),s2(v[i].a,d),s3(c,v[i].b),s4(d,v[i].b);\n        if((v[i].a.x <= p.s.x && p.s.x <= v[i].b.x &&\n            v[i].a.y <= p.s.y && p.s.y <= v[i].b.y) ||\n           (v[i].a.x <= p.t.x && p.t.x <= v[i].b.x &&\n            v[i].a.y <= p.t.y && p.t.y <= v[i].b.y)){\n            return 1;\n        }\n        if(isIntersectSS(p,s1)) return 1;\n        if(isIntersectSS(p,s2)) return 1;\n        if(isIntersectSS(p,s3)) return 1;\n        if(isIntersectSS(p,s4)) return 1;\n    }\n    return 0;\n}\n\nint main(){\n    int N;\n    while(cin >> N,N){\n        Point s,e;\n        Segment seg;\n        cin >> seg.s >> seg.t;\n        vector<Block> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].a >> v[i].b >> v[i].h;\n        }\n        if(check(seg,v)){\n            cout << 0 << endl;\n            continue;\n        }\n        double l = 0,r = 1001;\n        for(int i = 0 ; i < 100 ; i++){\n            double mid = (l + r) / 2;\n            if(c(mid,seg,v)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n        printf(\"%.10f\\n\",l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\ndouble EPS = 1e-8;\n\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\n\ndouble dist(P la, P lb, P p){\n\tif(dot(lb-la,p-la)<EPS) return abs(p-la);\n\tif(dot(la-lb,p-lb)<EPS) return abs(p-lb);\n\treturn abs(cross(lb-la,p-la)) / abs(lb-la);\n}\n\nbool crossLine(P la, P lb, P ma, P mb){\n\treturn cross(lb-la,ma-la)*cross(lb-la,mb-la)<0&&\n\t\tcross(mb-ma,la-ma)*cross(mb-ma,lb-ma)<0;\n}\n\ndouble distSquare(P la, P lb, double ma, double mb, double Ma, double Mb){\n\tP L[2]; L[0] = la, L[1] = lb;\n\tP M[4]; M[0] = P(ma,mb); M[1] = P(Ma,mb); M[2] = P(Ma,Mb); M[3] = P(ma,Mb);\n\tdouble a = dist(L[0], L[1], M[0]);\n\tfor(int i=1;i<4;i++){\n\t\tdouble b = dist(L[0], L[1], M[i]);\n\t\tif(a>b) a = b;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tdouble b = dist(M[i],M[(i+1)%4],L[j]);\n\t\t\tif(a>b) a = b;\n\t\t}\n\t}\n\treturn a;\n}\n\nbool rightup(P a, P b){\n\treturn real(a)<real(b)&&imag(a)<imag(b);\n}\n\nbool crossSquare(P la, P lb, double ma, double mb, double Ma, double Mb){\n\tif(crossLine(la,lb,P(ma,mb),P(Ma,mb))) return true;\n\tif(crossLine(la,lb,P(ma,mb),P(ma,Mb))) return true;\n\tif(crossLine(la,lb,P(Ma,mb),P(Ma,Mb))) return true;\n\tif(crossLine(la,lb,P(ma,Mb),P(Ma,Mb))) return true;\n\tif(rightup(P(ma,mb),la)&&rightup(la,P(Ma,Mb))\n\t\t&&rightup(P(ma,mb),lb)&&rightup(lb,P(Ma,Mb))) return true;\n\treturn false;\n}\n\nint main(){\n\tint N;\n\tP a, b;\n\tint mx[50], my[50], Mx[50], My[50], h[50];\n\twhile(cin >> N){\n\t\tif(!N) break;\n\t\tint sx, sy, ex, ey; cin >> sx >> sy >> ex >> ey;\n\t\ta = P(sx,sy); b = P(ex,ey);\n\t\tfor(int i=0;i<N;i++)\n\t\t\tcin >> mx[i] >> my[i] >> Mx[i] >> My[i] >> h[i];\n\t\tbool flag = false;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(crossSquare(a, b, mx[i], my[i], Mx[i], My[i])){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag) { cout << 0 << endl; continue; }\n\t\tdouble r = 10000;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tdouble d = distSquare(a,b,mx[i],my[i],Mx[i],My[i]);\n\t\t\tif(d<h[i]) { if(d<r) r = d; }\n\t\t\telse    {\n\t\t\t\tdouble tmp = (d*d+h[i]*h[i])/(2*h[i]);\n\t\t\t\tif(tmp<r) r = tmp;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8lf\\n\", r);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<double> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bucnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n\nconst ll inf = (ll)1e9;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\ndouble dot_product(compd a, compd b, compd c) {\n\tcompd s = b - a, t = c - a;\n\treturn s.real()*t.real() + s.imag()*t.imag();\n}\n\ndouble cross_product(compd a, compd b, compd c) {\n\tcompd s = b - a, t = c - a;\n\treturn s.real()*t.imag() - s.imag()*t.real();\n}\n\ndouble dist(compd a, compd b) {\n\treturn sqrt((a.real() - b.real())*(a.real() - b.real()) + (a.imag() - b.imag())*(a.imag() - b.imag()));\n}\n\ndouble Ldist(compd s, compd t, compd p) {\n\tcompd l = t - s;\tp -= s;\n\tcompd rot = abs(l) / l;\n\tl *= rot;\tp *= rot;\n\tif (p.real() < eps)\treturn dist(0, p);\n\tif (l.real() - eps < p.real())\treturn dist(l, p);\n\treturn abs(p.imag());\n}\n\ncompd getCompd() {\n\tdouble a, b;\tcin >> a >> b;\n\treturn compd(a, b);\n}\n\nint main() {\n\twhile (true) {\n\t\tint n;\tcin >> n;\n\t\tif (n == 0)\tbreak;\n\t\tcompd s = getCompd(), t = getCompd();\n\t\tdouble left = 0, right = 1024;\n\t\trep(i, n) {\n\t\t\tvector<compd> a(4);\n\t\t\ta[0] = getCompd();\ta[2] = getCompd();\n\t\t\ta[1] = compd(a[0].real(), a[2].imag());\n\t\t\ta[3] = compd(a[2].real(), a[0].imag());\n\t\t\tdouble h;\tcin >> h;\n\t\t\tleft = 0;\n\t\t\tright += eps;\n\t\t\t//?????????????????????????????????\n\t\t\tbool is_inside = true;\n\t\t\trep(j, 4) {\n\t\t\t\tis_inside &= (dot_product(a[j], a[(j + 1) % 4], s) > eps);\n\t\t\t\tis_inside &= (dot_product(a[j], a[(j + 1) % 4], t) > eps);\n\t\t\t}\n\t\t\tif (is_inside)\tright = 0;\n\t\t\t//?????????????????????????????????\n\t\t\tbool crossed = false;\n\t\t\trep(j, 4) {\n\t\t\t\tif (cross_product(s, t, a[j])*cross_product(s, t, a[(j + 1) % 4]) > -eps)\tcontinue;\n\t\t\t\tif (cross_product(a[j], a[(j + 1) % 4], s)*cross_product(a[j], a[(j + 1) % 4], t) > -eps)\tcontinue;\n\t\t\t\tcrossed = true;\n\t\t\t}\n\t\t\tif (crossed)\tright = 0;\n\t\t\trep(j, 30) {\n\t\t\t\tdouble mid = (left + right) / 2.0;\n\t\t\t\tdouble height = mid - min(mid, h);\n\t\t\t\tdouble r = sqrt(mid*mid - height*height);\n\t\t\t\tbool ok = true;\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tok &= (Ldist(s, t, a[k]) > r + eps);\n\t\t\t\t\tok &= (Ldist(a[k], a[(k + 1) % 4], s) > r + eps);\n\t\t\t\t\tok &= (Ldist(a[k], a[(k + 1) % 4], t) > r + eps);\n\t\t\t\t}\n\t\t\t\tif (ok)\tleft = mid;\n\t\t\t\telse\tright = mid;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.15lf\\n\", left + eps);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <limits.h>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define REPD(i,n) for(int i=(int)(n); i-->0;)\n#define REPI(i,a,b) for(int i=(int)(a); i<=(int)(b); i++)\n#define ALL(a) (a).begin(),(a).end()\n#define mp make_pair\n#define fst first\n#define snd second\n\n#define INFTY 1000000000\n#define EPS 1e-9\n#define PI 3.141592653589793\n\n#define INF (INFTY/3)\n\n#define rev(s) (string((s).rbegin(), (s).rend()))\n\ntypedef long long Int;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<double,double> pdd;\n\nvoid debug(vi v){ REP(i,v.size()) cout<<v[i]<<\" \"; cout<<endl; }\n\nint nextInt(){ int t; cin>>t; return t; }\n\n#define ZEROP(x) (fabs(x) < EPS)\n#define EQ(x, y) ZEROP((x) - (y))\n#define LT(x, y) ((x) - (y) <= -EPS) // x < y\n#define LE(x, y) ((x) - (y) < +EPS) // x <= y\n#define SIGN(x) ((x)<-EPS?-1:((x)>EPS?+1:0))\n\ntypedef complex<double> P;\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nnamespace std {\n   bool operator < (const P& a, const P& b) {\n     return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n   }\n}\ndouble cross(const P& a, const P& b) {\n   return imag(conj(a)*b); \n} \ndouble dot(const P& a, const P& b) {\n   return real(conj(a)*b); \n}  \nstruct L : public vector<P> {\n  L() {}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  } \n};  \ntypedef vector<P> G;  \nstruct C {\n   P p; double r;\n   C(const P &p, double r) : p(p), r(r) { }\n}; \n\n\n#define MAXN 50\nint N;\nL sl; // start line\nint minx[MAXN];\nint miny[MAXN];\nint maxx[MAXN];\nint maxy[MAXN];\nint h[MAXN];\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (LT( 0, cross(b, c)) )   return +1;       // counter clockwise\n  if (LT( cross(b, c), 0) )   return -1;       // clockwise\n  if (LT( dot(b, c), 0) )     return +2;       // c--a--b on line\n  if (LT( norm(b), norm(c)) ) return -2;       // a--b--c on line\n  return 0;\n}\n\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n// USE IN THIS PROBLEM\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nbool covered(int sx,int sy,int ex,int ey,int ax,int ay,int bx,int by) {\n  return (ax <= sx && sx <= bx && ay <= sy && sy <= by) ||\n    (ax <= ex && ex <= bx && ay <= ey && ey <= by);\n}\n\n\ndouble solve() {\n  double r = INT_MAX;\n  REP(i,N) {\n    L l[]={L(P(minx[i],miny[i]),P(maxx[i],miny[i])),\n\t   L(P(maxx[i],miny[i]),P(maxx[i],maxy[i])),\n\t   L(P(maxx[i],maxy[i]),P(minx[i],maxy[i])),\n\t   L(P(minx[i],maxy[i]),P(minx[i],miny[i]))};\n    double mind = INT_MAX;\n    int mini; //min index\n    if(covered(real(sl[0]),imag(sl[0]),real(sl[1]),imag(sl[1]),\n\t       minx[i],miny[i],maxx[i],maxy[i])) return 0.0;\n    REP(j,4) {\n      if(intersectSS(l[j],sl)) return 0.0;\n      double dd = distanceSS(l[j],sl);\n      if(LT(dd,mind)) {\n\tmind = dd;\n\tmini = j;\n      }\n    }\n    double r2;\n    //printf(\"mind=%lf\\n\",mind);\n    if(LE(mind,h[i])) { // mind <= h[i]\n      r2=mind;\n    } else {\n      r2=(h[i]*h[i] + mind*mind) / (2*h[i]);\n    }\n    r=min(r,r2);\n    //printf(\"r=%lf\\n\",r);\n  }\n  return r;\n}\n\t\nmain() {\n  while(cin>>N,N) {\n    int sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    sl = L(P(sx,sy),P(ex,ey));\n    REP(i,N)\n      cin>>minx[i]>>miny[i]>>maxx[i]>>maxy[i]>>h[i];\n    printf(\"%.4lf\\n\",solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e9)\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(P a, P b, P c){\n  if(cross(b-a,c-a) > EPS) return 1;\n  if(cross(b-a,c-a) < -EPS) return -1;\n  if(dot(b-a,c-a) < EPS) return 2;\n  if(abs(b-a) + EPS < abs(c-a)) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\ndouble p_to_s_dist(P a, L s){\n  if(dot(s.second-s.first,a-s.first) >= 0 && dot(s.first-s.second,a-s.second) >= 0){\n    return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n  }\n  return min(abs(a-s.first), abs(a-s.second));\n}\n\ndouble s_to_s_dist(L a, L b){\n  if(is_cross(a,b)) return 0;\n  return min(min(p_to_s_dist(a.first,b),p_to_s_dist(a.second,b)),\n\t     min(p_to_s_dist(b.first,a),p_to_s_dist(b.second,a)));\n}\n\nint main(){\n  int N;\n  double h, d, x[2], y[2];\n  while(cin >> N, N){\n    vector<P> V;\n    cin >> x[0] >> y[0] >> x[1] >> y[1];\n    P s = P(x[0],y[0]), e = P(x[1],y[1]);\n    L c = L(s,e);\n    for(int i = 0; i < N; ++i){\n      cin >> x[0] >> y[0] >> x[1] >> y[1] >> h;\n      L edge[4];\n      for(int j = 0; j < 4; ++j){\n\tedge[j] = L(P(x[j/2],y[j%2]),P(x[((j+1)/2)%2],y[(j+1)%2]));\n      }\n      d = 100000;\n      for(int j = 0; j < 4; ++j){\n\td = min(d, s_to_s_dist(c, edge[j]));\n      }\n      V.push_back(P(d,h));\n    }\n    sort(V.begin(), V.end());\n    /*\n    if(abs(V[0].X) < EPS){\n      cout << 0 << endl;\n      continue;\n    }\n    */\n    double ub = 100000, lb = 0, r = ub/2;\n    for(int t = 0; t < 1000000; ++t){\n      r = (ub+lb)/2;\n      bool f = true;\n      for(int i = 0; i < N; ++i){\n\tif((V[i].X < EPS) || ((r > norm(V[i])/2/V[i].Y) && (r > V[i].X))){\n\t  f = false;\n\t  break;\n\t}\n      }\n      if(f) lb = r;\n      else ub = r;\n    }\n    printf(\"%.10lf\\n\", r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\ncomplex<double>sz,ez;\ndouble mnx[55],mny[55],mxx[55],mxy[55],h[55];\n\ntypedef complex<double> pt;\ntypedef pair<pt,pt> L;\ntypedef vector<P> poly;\nconst double EPS = 1e-9;\n#define x real()\n#define y imag()\n\nbool eq(double a,double b){\n  return (-EPS < a-b && a-b < EPS);\n}\ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\n//線分a-b とc の距離\ndouble dist_lp(pt a,pt b,pt c){\n\t//senbun a-b to c no dist\n\tif(dot(a-b,c-b) <= 0.0) return abs(c-b);\n\tif(dot(b-a,c-a) <= 0.0) return abs(c-a);\n\treturn abs(cross(b-a,c-a)) / abs(b-a);\n}\n//線分が交わる?\nbool intersect(pt a,pt b,pt c,pt d){\n\treturn (ccw(a,b,c)*ccw(a,b,d) <= 0 && ccw(c,d,a)*ccw(c,d,b) <= 0);\n}\n//線分a-b と 線分c-d の距離\ndouble min_dist_ll(pt a,pt b,pt c,pt d){\n\tif(intersect(a,b,c,d) == true) return 0.0;\n\tdouble ret = 1e18;\n\tret = min(ret,dist_lp(a,b,c));\n\tret = min(ret,dist_lp(a,b,d));\n\tret = min(ret,dist_lp(c,d,a));\n\tret = min(ret,dist_lp(c,d,b));\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0) return 0;\n\t\tdouble sa,sb,ea,eb;\n\t\tscanf(\"%lf%lf%lf%lf\",&sa,&sb,&ea,&eb);\n\t\tsz = complex<double>(sa,sb);\n\t\tez = complex<double>(ea,eb);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf%lf\",&mnx[i],&mny[i],&mxx[i],&mxy[i],&h[i]);\n\t\t}\n\t\tdouble lb = 0.0,ub = 100000.0;\n\t\trep(i,114){\n\t\t\tdouble mid = (lb+ub)/2;\n\t\t\trep(i,n){\n\t\t\t\tdouble mn = 1e18;\n\t\t\t\tmn = min(mn, min_dist_ll(sz,ez,pt(mnx[i],mny[i]),pt(mnx[i],mxy[i])));\n\t\t\t\tmn = min(mn, min_dist_ll(sz,ez,pt(mxx[i],mny[i]),pt(mxx[i],mxy[i])));\n\t\t\t\tmn = min(mn, min_dist_ll(sz,ez,pt(mxx[i],mny[i]),pt(mnx[i],mny[i])));\n\t\t\t\tmn = min(mn, min_dist_ll(sz,ez,pt(mxx[i],mxy[i]),pt(mnx[i],mxy[i])));\n\t\t\t\tif(mnx[i] <= sz.x && sz.x <= mxx[i] && mny[i] <= sz.y && sz.y <= mxy[i]) mn = 0.0;\n\t\t\t\tdouble r;\n\t\t\t\tif(mid <= h[i]){\n\t\t\t\t\tr = mid;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tr = sqrt(mid*mid-(mid-h[i])*(mid-h[i]));\n\t\t\t\t}\n\t\t\t\tif(mn < r){\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlb = mid; continue;\n\t\t\tfail:; ub = mid;\n\t\t}\n\t\tprintf(\"%.12f\\n\",lb);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/**************** Geometrical Library ****************/\n\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define\tEPS\t1e-9\n\nenum {CCW=1,CW=-1,ON=0};\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy):x(xx),y(yy){}\n};\n\nclass Line:public vector<Point>{\npublic:\n\tLine(const Point &a,const Point &b){\n\t\tpb(a),pb(b);\n\t}\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\nclass Polygon:public vector<Point>{};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &cc,double rr):c(cc),r(rr){}\n};\n\nPoint &operator +=(Point &a,const Point &b){\n\ta.x+=b.x,a.y+=b.y;\n\treturn a;\n}\n\nPoint &operator -=(Point &a,const Point &b){\n\ta.x-=b.x,a.y-=b.y;\n\treturn a;\n}\n\nPoint &operator *=(Point &a,double c){\n\ta.x*=c,a.y*=c;\n\treturn a;\n}\n\nPoint &operator /=(Point &a,double c){\n\ta.x/=c,a.y/=c;\n\treturn a;\n}\n\nPoint operator +(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c+=b;\n}\n\nPoint operator -(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c-=b;\n}\n\nPoint operator *(double c,const Point &a){\n\tPoint b=a;\n\treturn b*=c;\n}\n\nPoint operator /(const Point &a,double c){\n\tPoint b=a;\n\treturn b/=c;\n}\n\nbool operator <(const Point &a,const Point &b){\n\treturn (a.x==b.x)?(a.y<b.y):(a.x<b.x);\n}\n\nbool operator >(const Point &a,const Point &b){\n\treturn b<a;\n}\n\ndouble dot(const Point &a,const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble norm2(const Point &a){\n\treturn dot(a,a);\n}\n\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)\t\treturn CCW;\n\tif(rotdir<-EPS)\t\treturn CW;\n\treturn ON;\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\t// l : ax+by+c=0\n\ta=l[0].y-l[1].y;\n\tb=l[1].x-l[0].x;\n\tc=l[0].x*l[1].y-l[1].x*l[0].y;\n}\n\nPoint perp_foot(const Point &p,const Line &l){\n\tdouble a,b,c;\n\tcalc_abc(l,a,b,c);\n\treturn p-(a*p.x+b*p.y+c)/(a*a+b*b)*Point(a,b);\n}\n\nbool intersect(const Line &l,const Line &m,Point *p=NULL){\n\t// this routine also returns true in case \"M is on L\", etc,.\n\tif(abs(cross(l[1]-l[0],m[1]-m[0]))>EPS\n\t|| abs(cross(l[1]-l[0],m[0]-l[0]))<EPS){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(l,a1,b1,c1);\n\t\t\tcalc_abc(m,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS)\t*p=l[0];\t// l == m\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool intersect(const Segment &s,const Segment &t,Point *p=NULL){\n\tif(max(s[0].x,s[1].x)<min(t[0].x,t[1].x)\n\t|| max(t[0].x,t[1].x)<min(s[0].x,s[1].x)\n\t|| max(s[0].y,s[1].y)<min(t[0].y,t[1].y)\n\t|| max(t[0].y,t[1].y)<min(s[0].y,s[1].y))\treturn false;\n\n\tif(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(s,a1,b1,c1);\n\t\t\tcalc_abc(t,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS){\t// s is parallel to t\n\t\t\t\tPoint q[3]={s[0],s[1],t[0]};\n\t\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\t\tif(dot(q[i]-s[0],q[i]-s[1])<EPS && dot(q[i]-t[0],q[i]-t[1])<EPS){\n\t\t\t\t\t\t*p=q[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**************** Library END ****************/\n\n#include<cstdio>\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tPoint s,g;\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&g.x,&g.y);\n\t\tSegment course(s,g);\nif(s.x==g.x&&s.y==g.y)break;\n\t\tdouble rmin=1e30;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tPoint obj[2];\n\t\t\tint h;\n\t\t\tscanf(\"%lf%lf%lf%lf%d\",&obj[0].x,&obj[0].y,&obj[1].x,&obj[1].y,&h);\n\n\t\t\tbool oncourse=false;\n\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<2;k++){\t// cross course x object\n\t\t\t\tSegment edge(Point(obj[j].x,obj[k].y),Point(obj[k].x,obj[1-j].y));\n\t\t\t\tif(intersect(course,edge)){ oncourse=true; break; }\n\t\t\t}\n\t\t\tfor(int l=0;l<2;l++){\t// course in object\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<2;k++){\n\t\t\t\t\tSegment edge(Point(obj[j].x,obj[k].y),Point(obj[k].x,obj[1-j].y));\n\t\t\t\t\tcnt+=ccw(edge[0],edge[1],course[l]);\n\t\t\t\t}\n\t\t\t\tif(cnt==4*CCW || cnt==4*CW){ oncourse=true; break; }\n\t\t\t}\n\t\t\tif(oncourse){ rmin=0; break; }\n\n\t\t\tdouble d2min=1e30;\n\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<2;k++){\n\t\t\t\tPoint u=Point(obj[j].x,obj[k].y);\n\t\t\t\tPoint v=perp_foot(u,Line(course[0],course[1]));\n\t\t\t\tif(dot(v-course[0],v-course[1])<EPS){\t// v is on course\n\t\t\t\t\tdouble d2=norm2(v-u);\n\t\t\t\t\td2min=min(d2min,d2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<2;k++){\n\t\t\t\t\tSegment edge(Point(obj[j].x,obj[k].y),Point(obj[k].x,obj[1-j].y));\n\t\t\t\t\tPoint v=perp_foot(course[l],Line(edge[0],edge[1]));\n\t\t\t\t\tif(dot(v-edge[0],v-edge[1])<EPS){\n\t\t\t\t\t\tdouble d2=norm2(v-course[l]);\n\t\t\t\t\t\td2min=min(d2min,d2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble r;\n\t\t\tif(h*h<d2min)\tr=(d2min+h*h)/(2*h);\n\t\t\telse\tr=sqrt(d2min);\n\t\t\trmin=min(rmin,r);\n\t\t}\n\n\t\tprintf(\"%f\\n\",rmin);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\nbool is(P a,P b,P c,P d){\n  return cr(a-b,c-b)*cr(a-b,d-b)<=0&&cr(c-d,a-d)*cr(c-d,b-d)<=0;\n}\n\ndouble dt(P a,P b,P c,P d){\n  P p[4]={a,b,c,d};\n  double m=1<<30;\n  for(int i=0;i<2;i++){\n    for(int j=0;j<2;j++){\n      m=min(m,abs(p[i]-p[j+2]));\n    }\n  }\n  for(int i=0;i<2;i++){\n    swap(p[0],p[2]);\n    swap(p[1],p[3]);\n    for(int j=0;j<2;j++){\n      if(dot(p[2+j]-p[0],p[1]-p[0])*dot(p[2+j]-p[1],p[0]-p[1])>0){\n\tm=min(m,fabs(cr(p[2+j]-p[0],p[1]-p[0]))/abs(p[1]-p[0]));\n      }\n    }\n  }\n  //  cout<<a<<' '<<b<<' '<<c<<' '<<d<<' '<<m<<endl;\n  return m;\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    int sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    P s=P(sx,sy),e=P(ex,ey);\n    int ix[50],iy[50],ax[50],ay[50],h[50];\n    P ll[50],hl[50],hh[50],lh[50];\n    bool on=false;\n    for(int i=0;i<n;i++){\n      cin>>ix[i]>>iy[i]>>ax[i]>>ay[i]>>h[i];\n      ll[i]=P(ix[i],iy[i]);\n      hl[i]=P(ax[i],iy[i]);\n      hh[i]=P(ax[i],ay[i]);\n      lh[i]=P(ix[i],ay[i]);\n      on|=is(s,e,ll[i],hl[i])|is(s,e,hl[i],hh[i])|is(s,e,hh[i],lh[i])|is(s,e,lh[i],ll[i]);\n      on|=ix[i]<=min(sx,ex)&&max(sx,ey)<=ax[i]&&iy[i]<=min(sy,ey)&&max(sy,sy)<=ay[i];\n    }\n    if(on){\n      cout<<0<<endl;\n    }else{\n      double m=1<<30;\n      for(int i=0;i<n;i++){\n\tP *p[4]={ll+i,hl+i,hh+i,lh+i};\n\tfor(int j=0;j<4;j++){\n\t  double d=dt(*p[j],*p[(j+1)%4],e,s);\n\t  if(d<h[i]){\n\t    m=min(m,(double)h[i]);\n\t  }else{\n\t    m=min(m,(d*d+h[i]*h[i])/2/h[i]);\n\t  }\n\t}\n      }\n      cout<<fixed<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> xy;\ndouble eps = 1e-9;\ndouble dot_product(xy a,xy b) {return (conj(a)*b).real();}\ndouble cross_product(xy a,xy b) {return (conj(a)*b).imag();}\ndouble dist_lp(xy a1,xy a2,xy p){\n    if(dot_product(a2-a1,p-a1)<eps) return abs(p-a1);\n    if(dot_product(a1-a2,p-a2)<eps) return abs(p-a2);\n    return abs(cross_product(a2-a1,p-a1))/abs(a2-a1);\n}\n\nbool is_online(xy a1,xy a2,xy p){\n    return abs(a1-p)+abs(a2-p)<=abs(a1-a2)+eps;    \n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    if(is_online(a1,a2,b1) || is_online(a1,a2,b2)) return true;\n    if(is_online(b1,b2,a1) || is_online(b1,b2,a2)) return true;\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<-eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<-eps;\n}\n\ndouble dist_ll(xy a1,xy a2,xy b1,xy b2){\n    if(is_intersected(a1,a2,b1,b2)) return 0;\n    return min({dist_lp(a1,a2,b1),dist_lp(a1,a2,b2),dist_lp(b1,b2,a1),dist_lp(b1,b2,a1)\n    ,abs(a1-b1),abs(a1-b2),abs(a2-b1),abs(a2-b2)});   \n}\n\nint N;\ndouble sx,sy,gx,gy,mi_x,mi_y,ma_x,ma_y;\ndouble h;\n\n\nint main(){\n    while(cin>>N && N>0){\n        double ans = 1e9;\n        cin >> sx >> sy >> gx >> gy;\n        if(sx>gx){\n            swap(sx,sy);\n            swap(gx,gy);\n        }\n        xy s = xy(sx,sy),g = xy(gx,gy);\n        for(int i=1;i<=N;i++){\n            cin >> mi_x >> mi_y >> ma_x >> ma_y >> h;\n            if(mi_x<=sx && sx<=ma_x && mi_y<=sy && sy<=ma_y && \n            mi_x<=gx && gx<=ma_x && mi_y<=gy && gy<=ma_y) ans = 0;\n            double d = min({dist_ll(s,g,xy(mi_x,mi_y),xy(mi_x,ma_y)),\n            dist_ll(s,g,xy(mi_x,ma_y),xy(ma_x,ma_y)),\n            dist_ll(s,g,xy(ma_x,ma_y),xy(ma_x,mi_y)),\n            dist_ll(s,g,xy(ma_x,mi_y),xy(mi_x,mi_y))});\n            if(d<=h) ans = min(ans,d);\n            else ans = min(ans,(1.0*h*h+d*d)/(2.0*h));\n        }\n        cout << fixed;\n        cout << setprecision(10) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n\n#define fr first\n#define sc second\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point,vec;\ntypedef pair<point,point> pp,seg,line;\n\nconst elem eps = 1.0e-10;\nconst elem infty = 1.0e+18;\n\ninline bool eq(elem a, elem b){return abs(b-a) < eps;}\ninline bool leq(elem a, elem b){return eq(a,b) || a < b;}\ninline bool geq(elem a, elem b){return eq(a,b) || a > b;}\ninline bool lt(elem a, elem b){return !eq(a,b) && a < b;}\ninline bool gt(elem a, elem b){return !eq(a,b) && a > b;}\ninline bool ltz(elem a){return lt(a,0);}\ninline bool gtz(elem a){return gt(a,0);}\ninline elem emax(elem a, elem b){return gt(a,b)?a:b;}\ninline elem emin(elem a, elem b){return lt(a,b)?a:b;}\ninline elem dot(point a, point b){return a.real()*b.real() + a.imag()*b.imag();}\ninline elem cross(point a, point b){return a.real()*b.imag()-a.imag()*b.real();}\ninline elem dist_l(line l,point x){ return abs(cross(l.sc-l.fr,x-l.fr))/abs(l.sc-l.fr); }\ninline elem dist_seg(seg s, point x){\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\ninline bool intersected_seg(seg a, seg b){\n  return ( leq( cross(a.sc-a.fr,b.fr-a.fr) * cross(a.sc-a.fr,b.sc-a.fr), 0) &&\n\t   leq( cross(b.sc-b.fr,a.fr-b.fr) * cross(b.sc-b.fr,a.sc-b.fr), 0 ) );\n}\ninline int ccw(point a, point b, point x){\n  b-=a;x-=a;\n  if(gtz(cross(b,x)))return LEFT;\n  if(ltz(cross(b,x)))return RIGHT;\n  if(ltz(dot(b,x)))return BACK;\n  if(abs(b)<abs(x))return FRONT;\n  return OVER;\n}\n\nclass cuboid{\npublic:\n  elem h;\n  elem minx, miny;\n  elem maxx, maxy;\n  point tl,bl,tr,br;\n  cuboid():minx(0),miny(0),\n\t maxx(0),maxy(0),h(0){}\n  cuboid(elem minx, elem miny, elem maxx, elem maxy,elem h):\n    minx(minx),miny(miny),\n    maxx(maxx),maxy(maxy),h(h),\n    tl(minx,maxy),bl(minx,miny),tr(maxx,maxy),br(maxx,miny){}\n  bool intersected_seg(seg l){\n    if( ::intersected_seg(l,seg(tl,tr)) ||\n\t::intersected_seg(l,seg(tl,bl)) ||\n\t::intersected_seg(l,seg(tr,br)) ||\n\t::intersected_seg(l,seg(bl,br)) ) return true;\n    return false;\n  }\n  bool contain_seg(seg l){\n    if( ccw(bl,br,l.fr)&(OVER|LEFT) &&\n\tccw(br,tr,l.fr)&(OVER|LEFT) &&\n\tccw(tr,tl,l.fr)&(OVER|LEFT) &&\n\tccw(tl,bl,l.fr)&(OVER|LEFT)\n\t&&\n\tccw(bl,br,l.fr)&(OVER|LEFT) &&\n\tccw(br,tr,l.fr)&(OVER|LEFT) &&\n\tccw(tr,tl,l.fr)&(OVER|LEFT) &&\n\tccw(tl,bl,l.fr)&(OVER|LEFT) ) return true;\n    return false;\n  }\n  elem getMinimumDistance(seg l){\n    elem ret = infty;\n    ret = emin( ret, dist_seg( l, tl ) );\n    ret = emin( ret, dist_seg( l, tr ) );\n    ret = emin( ret, dist_seg( l, bl ) );\n    ret = emin( ret, dist_seg( l, br ) );\n    ret = emin( ret, dist_seg( seg(tl,tr), l.fr ) );\n    ret = emin( ret, dist_seg( seg(tl,tr), l.sc ) );\n    ret = emin( ret, dist_seg( seg(tl,bl), l.fr ) );\n    ret = emin( ret, dist_seg( seg(tl,bl), l.sc ) );\n    ret = emin( ret, dist_seg( seg(bl,br), l.fr ) );\n    ret = emin( ret, dist_seg( seg(bl,br), l.sc ) );\n    ret = emin( ret, dist_seg( seg(tr,br), l.fr ) );\n    ret = emin( ret, dist_seg( seg(tr,br), l.sc ) );\n    return ret;\n  }\n  elem getRwithSphere(seg l){\n    if(contain_seg(l) || intersected_seg(l))return 0;\n    elem d = getMinimumDistance(l);\n    if(eq(d,0))return 0;\n    elem theta = 2*atan(h/d);\n    elem ret = sqrt( (pow(d,2)+pow(h,2))/(2*(1-cos(theta))) );\n    return ret;\n  }\n};\n\nint main(){\n  while(true){\n    int n;\n    elem ans = infty;\n    elem sx,sy,ex,ey;\n    vector<cuboid> vcubo;\n    scanf(\"%d\",&n);\n    if(n == 0) return 0;\n    scanf(\"%lf%lf%lf%lf\",&sx,&sy,&ex,&ey);\n    point S(sx,sy), E(ex,ey);\n    for(int i = 0; i < n; ++i){\n      elem minx, miny, maxx, maxy, h;\n      scanf(\"%lf%lf%lf%lf%lf\",\n\t    &minx,&miny,&maxx,&maxy,&h);\n      vcubo.push_back( cuboid(minx,miny,maxx,maxy,h) );\n    }\n    for(int i = 0; i < n; ++i){\n      ans = emin( ans, vcubo[i].getRwithSphere( seg(S,E) ) );\n    }\n    printf(\"%.7lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nvoid print(Point p);\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tprint(p1);\n\t\t\tprint(p2);\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p1;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n//\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tint x=ccw(s.p1,s.p2,pr);\n\tif(x==0) return d;\n//\tif(x>=-1&&x<=1) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t//\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\tif(ccw(q[0],q[1],r)==0){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t//\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\tif(ccw(p[0],p[1],r)==0){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define EPS (1e-10)\ntypedef complex<double> P;\n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\ndouble distance(P p0, P p1, P p2, P p3){\n  double ans = 1e10;\n        ans = min(ans, distance_ls_p(p0, p1, p2));\n        ans = min(ans, distance_ls_p(p0, p1, p3));\n        ans = min(ans, distance_ls_p(p2, p3, p0));\n        ans = min(ans, distance_ls_p(p2, p3, p1));\n        if(is_intersected_ls(p0, p1, p2, p3)) ans = 0.0;\n\t\treturn ans;\n}\n\nint main(){\n\tfor(int z = 0; z < 26; z++){\n\t\tint n; cin >> n;\n\t\tif(n == 0 )break;\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tP s = P(x,y);\n\t\tif(z == 24)printf(\"%.0f %.0f\",x,y);\n\t\tcin >> x >> y;\n\t\tif(z == 24)printf(\" %.0f %.0f\\n\",x,y);\n\t\tP g = P(x,y);\n\t\tvector<P> mins(n), maxs(n);\n\t\tvector<double> h(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\t//if(z == 24)printf(\"%.0f %.0f\",x,y);\n\t\t\tmins[i].real(x); mins[i].imag(y);\n\t\t\tcin >> x >> y;\n\t\t\t//if(z == 24)printf(\" %.0f %.0f\",x,y);\n\t\t\tmaxs[i].real(x); maxs[i].imag(y);\n\t\t\tcin >> h[i];\n\t\t\t//if(z == 24)printf(\" %.0f \\n\",h[i]);\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tfor(int i = 0; i < n;i++){\n\t\t\tdouble d = 1e9;\n\t\t\tP p1 = mins[i], p3 = maxs[i];\n\t\t\tP p2(mins[i].real(), maxs[i].imag());\n\t\t\tP p4(maxs[i].real(), mins[i].imag());\n\t\t\tif(p1.real() < s.real() && s.real() < p3.real() && \n\t\t\t\tp1.imag() < s.imag() && s.imag() < p3.imag()){\n\t\t\t\tans = 0;/*\n\t\t\t\tif(z==24){\n\t\t\t\t\tprintf(\"%.0f %.0f %.0f %.0f\\n\",p1.real(),p1.imag(),p3.real(),p3.imag());\n\t\t\t\t\tcout << \"break\" << endl;}*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, distance(s, g, p1,p2));\n\t\t\td = min(d, distance(s, g, p2,p3));\n\t\t\td = min(d, distance(s, g, p3,p4));\n\t\t\td = min(d, distance(s, g, p4,p1));\n\t\t\tdouble r = (h[i]*h[i]+d*d)/(2*h[i]);\n\t\t\tif(h[i] < d){\n\t\t\t\tans = min(ans, r);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = min(ans, d);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%f\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <tuple>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nusing vec = complex<double>;\nusing line = pair<vec,vec>;\nusing polygon = vector<vec>;\nconst double eps = 0.0000001;\n\ndouble inner_product(vec u,vec v){\n    return real(u*conj(v));\n}\ndouble cross_product(vec u,vec v){\n    return imag(conj(u)*v);\n}\n\nvec projection(line l,vec p){//p???l???????°???±\n    vec s=l.first, t=l.second;\n    double k = inner_product(t-s,p-s)/inner_product(t-s,t-s);\n    return (1.0-k)*s+k*t;\n}\n\nvec reflection(line l,vec p){\n    return 2.0*projection(l,p)-p;\n}\n\nint ccw(vec& a, vec& b, vec& c){\n    vec ab = b-a, ac = c-a;\n    double o = cross_product(ab,ac);\n    if(o>0) return 1; //CCW\n    if(o<0) return -1; //CW\n    if(inner_product(ab,ac)<0){\n        return 2; //C-A-B\n    }else{\n        if(inner_product(ab,ab)<inner_product(ac,ac)){\n            return -2; //A-B-C\n        }else{\n            return 0; //A-C-B\n        }\n    }\n}\n\nbool isIntersect(line l0, line l1){\n    int s = ccw(l0.first,l0.second,l1.first)*ccw(l0.first,l0.second,l1.second);\n    if(s!=0&&s!=-1&&s!=-4) return false;\n    s=ccw(l1.first,l1.second,l0.first)*ccw(l1.first,l1.second,l0.second);\n    if(s!=0&&s!=-1&&s!=-4) return false;\n    else return true;\n}\n\nvec interSection(line l0, line l1){\n    vec s0, t0, s1, t1;\n    tie(s0,t0)=l0; tie(s1,t1)=l1;\n    double k = cross_product(t1-s1,s1-s0)/cross_product(t1-s1,t0-s0);\n    return s0+(t0-s0)*k;\n}\n\ndouble segLength(line l){\n    return abs(l.first-l.second);\n}\n\ndouble distLine2point(line l, vec p){\n    return abs(cross_product(l.second-l.first,p-l.first))/abs(l.second-l.first);\n}\n\ndouble distSeg2Point(line l, vec p){\n    vec x = projection(l,p);\n    double L = segLength(l);\n    if(abs(x-l.first)<L&&abs(x-l.second)<L){\n        return abs(x-p);\n    }else{\n        return min(abs(l.first-p),abs(l.second-p));\n    }\n}\n\ndouble distSeg2Seg(line l1, line l2){\n    if(isIntersect(l1,l2)) return 0;\n    double ret = 1e20;\n    ret = min(ret,distSeg2Point(l1,l2.first));\n    ret = min(ret,distSeg2Point(l1,l2.second));\n    swap(l1,l2);\n    ret = min(ret,distSeg2Point(l1,l2.first));\n    ret = min(ret,distSeg2Point(l1,l2.second));\n    return ret;\n}\n\ndouble area(polygon& g){\n    double S=0;\n    int n=g.size();\n    for(int i=0;i<n;i++){\n        S+=cross_product(g[i],g[(i+1)%n]);\n    }\n    S/=2;\n    return S;\n}\n\npair<vec,vec> cross_point(vec C, double r, line l){\n    vec P1,P2,P,s,t; tie(s,t)=l;\n    P=(t-s)*(inner_product(t-s,C-s)/norm(t-s))+s;\n    P1=P+(t-s)*(sqrt(r*r-norm(P-C))/abs(t-s));\n    P2=P-(t-s)*(sqrt(r*r-norm(P-C))/abs(t-s));\n    if(P1.real()==P2.real()){\n        if(P1.imag()<P2.imag()) return make_pair(P1,P2);\n        else return make_pair(P2,P1);\n    }else{\n        if(P1.real()<P2.real()) return make_pair(P1,P2);\n        else return make_pair(P2,P1);\n    }\n}\n\nvec rotate(vec v, double rad){\n    return v*polar(1.0,rad);\n}\n\npair<vec,vec> cross_point(vec C1, vec C2, double r1, double r2){\n    vec e1,e2,P1,P2;\n    double d=abs(C2-C1);\n    e1=(C2-C1)*(1/d);\n    double theta = acos((r1*r1+norm(C2-C1)-r2*r2)/(2*r1*d));\n    P1=C1+rotate(e1,theta)*r1;\n    P2=C1+rotate(e1,-theta)*r1;\n    if(P1.real()==P2.real()){\n        if(P1.imag()<P2.imag()) return make_pair(P1,P2);\n        else return make_pair(P2,P1);\n    }else{\n        if(P1.real()<P2.real()) return make_pair(P1,P2);\n        else return make_pair(P2,P1);\n    }\n}\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        int sx,sy,ex,ey;\n        cin>>sx>>sy>>ex>>ey;\n        line L(vec(sx,sy),vec(ex,ey));\n        double r=1e8;\n        for(int i=0;i<N;i++){\n            int x,y,X,Y,h;\n            cin>>x>>y>>X>>Y>>h;\n            vec v0(x,y),v1(X,y),v2(x,Y),v3(X,Y);\n            line l0(v0,v1),l1(v1,v3),l2(v3,v2),l3(v2,v0);\n            double d = min({distSeg2Seg(L,l0),distSeg2Seg(L,l1),distSeg2Seg(L,l2),distSeg2Seg(L,l3)});\n            if(x<=min(sx,ex)&&y<=min(sy,ey)&&X>=max(sx,ex)&&Y>=max(sy,ey)) d=0;\n            if(d<1e-5){\n                r=0;\n            }else{\n                if(h>=d){\n                    r=min(r,d);\n                }else{\n                    r=min(r,(h*h+d*d)/(2*h));\n                }\n            }\n        }\n        cout<<r<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\ndouble eps = 1e-8;\n\ndouble add(double a, double b) {\n    if (abs(a+b) < eps * (abs(a)+abs(b))) return 0;\n    return a+b;\n}\n\nbool equal(double a, double b) {\n    return add(a, -b) == 0;\n}\n\nstruct P {\n    double x, y;\n    P() {}\n    P(double x, double y) : x(x), y(y) {}\n    P operator+(P p) const {return P(add(x, p.x), add(y, p.y));}\n    P operator-(P p) const {return P(add(x, -p.x), add(y, -p.y));}\n    P operator*(double d) const {return P(x*d, y*d);}\n    double dot(P p) const {return add(x*p.x, y*p.y);} // ??????\n    double det(P p) const {return add(x*p.y, -y*p.x);} // ??????\n    double dist(P p) const {return sqrt((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y));} // ?????¢\n    void normalize() {double d = sqrt(x*x+y*y); x /= d; y /= d;} // ??£??????\n    bool operator<(const P& rhs) const {\n        if (x != rhs.x) return x < rhs.x;\n        return y < rhs.y;\n    }\n    bool operator==(const P& rhs) const {\n        return equal(x, rhs.x) && equal(y, rhs.y);\n    }\n};\n\n// ??????p1-p2?????????q???????????????????????????\nbool on_seg(P p1, P p2, P q) {\n    return (p1-q).det(p2-q) == 0 && (p1-q).dot(p2-q) <= 0;\n}\n\n// ??´???p1-p2??¨??´???q1-q2??????????????????????????????\nbool parallel(P p1, P p2, P q1, P q2) {\n    P a = p2-p1;\n    P b = q2-q1;\n    return a.det(b) == 0;\n}\n\n// ??´???p1-p2??¨??´???q1-q2?????????\nP intersection(P p1, P p2, P q1, P q2) {\n    return p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\ninline double square(double x) {return x*x;}\n// ??´???p1-p2??¨???q????????¢\ndouble dist(P p1, P p2, P q) {\n    q = q-p1;\n    p2 = p2-p1;\n    return sqrt((q.dot(q)*p2.dot(p2) - square(q.dot(p2))) / p2.dot(p2));\n}\n\n// ??????p1-p2??¨???q????????¢\ndouble distSeg(P p1, P p2, P q) {\n    double d = (q-p1).dot(p2-p1) / p2.dist(p1);\n    if (d < 0) return q.dist(p1);\n    if (d > p2.dist(p1)) return q.dist(p2);\n    return dist(p1, p2, q);\n}\n\n// ??????p1-p2??¨??????q1-q2????????¢\ndouble distSeg(P p1, P p2, P q1, P q2) {\n    if (p1==p2 && q1==q2) return q1.dist(p1);\n    if (p1==p2) return distSeg(q1, q2, p1);\n    if (q1==q2) return distSeg(p1, p2, q1);\n    if (!parallel(p1, p2, q1, q2)) {\n        P r = intersection(p1, p2, q1, q2);\n        if (on_seg(p1, p2, r) && on_seg(q1, q2, r)) return 0;\n    }\n    double ret = min(distSeg(p1, p2, q1), distSeg(p1, p2, q2));\n    ret = min(ret, min(distSeg(q1, q2, p1), distSeg(q1, q2, p2)));\n    return ret;\n}\n\nconst int MAXN = 55;\nint n;\nint sx, sy, gx, gy;\nint minX[MAXN], minY[MAXN], maxX[MAXN], maxY[MAXN], h[MAXN];\ndouble dd[MAXN];\n\nbool ok(double r) {\n    for (int i = 0; i < n; i++) {\n        double d = dd[i];\n        if (r < h[i]) {\n            if (r > d) return false;\n        } else {\n            double atMost = square(r)-square(r-h[i]);\n            if (atMost > d*d) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    while (cin >> n) {\n        if (n==0) break;\n        scanf(\"%d %d %d %d\", &sx, &sy, &gx, &gy);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d %d %d %d\", minX+i, minY+i, maxX+i, maxY+i, h+i);\n        }\n        for (int i = 0; i < n; i++) {\n            double d = 1e9;\n            d = min(d, distSeg(P(sx, sy), P(gx, gy), P(minX[i], minY[i]), P(minX[i], maxY[i])));\n            d = min(d, distSeg(P(sx, sy), P(gx, gy), P(minX[i], minY[i]), P(maxX[i], minY[i])));\n            d = min(d, distSeg(P(sx, sy), P(gx, gy), P(maxX[i], minY[i]), P(maxX[i], maxY[i])));\n            d = min(d, distSeg(P(sx, sy), P(gx, gy), P(minX[i], maxY[i]), P(maxX[i], maxY[i])));\n            dd[i] = d;\n            if (minX[i] <= sx && sx <= maxX[i] && minY[i] <= sy && sy <= maxY[i]) dd[i] = 0;\n            if (minX[i] <= gx && gx <= maxX[i] && minY[i] <= gy && gy <= maxY[i]) dd[i] = 0;\n        }\n        const double dr = 0.001;\n        bool finish = false;\n        for (double r = 1000; r > dr; r -= dr) {\n            if (ok(r)) {\n                printf(\"%.5lf\\n\", r);\n                finish = true;\n                break;\n            }\n        }\n        if (!finish) printf(\"0\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> xy;\ndouble eps = 1e-6;\ndouble dot_product(xy a,xy b) {return (conj(a)*b).real();}\ndouble cross_product(xy a,xy b) {return (conj(a)*b).imag();}\ndouble dist_lp(xy a1,xy a2,xy p){\n    if(dot_product(a2-a1,p-a1)<eps) return abs(p-a1);\n    if(dot_product(a1-a2,p-a2)<eps) return abs(p-a2);\n    return abs(cross_product(a2-a1,p-a1))/abs(a2-a1);\n}\n\nbool is_online(xy a1,xy a2,xy p){\n    return abs(a1-p)+abs(a2-p)<=abs(a1-a2)+eps;    \n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    if(is_online(a1,a2,b1) || is_online(a1,a2,b2)) return true;\n    if(is_online(b1,b2,a1) || is_online(b1,b2,a2)) return true;\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<-eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<-eps;\n}\n\ndouble dist_ll(xy a1,xy a2,xy b1,xy b2){\n    if(is_intersected(a1,a2,b1,b2)) return 0;\n    return min({dist_lp(a1,a2,b1),dist_lp(a1,a2,b2),dist_lp(b1,b2,a1),dist_lp(b1,b2,a2)\n    ,abs(a1-b1),abs(a1-b2),abs(a2-b1),abs(a2-b2)});   \n}\n\nint N;\ndouble sx,sy,gx,gy,mi_x,mi_y,ma_x,ma_y;\ndouble h;\n\n\nint main(){\n    while(cin>>N && N>0){\n        double ans = 1e9;\n        cin >> sx >> sy >> gx >> gy;\n        if(sx>gx){\n            swap(sx,sy);\n            swap(gx,gy);\n        }\n        xy s = xy(sx,sy),g = xy(gx,gy);\n        for(int i=1;i<=N;i++){\n            cin >> mi_x >> mi_y >> ma_x >> ma_y >> h;\n            if((mi_x<=sx && sx<=ma_x && mi_y<=sy && sy<=ma_y || \n            mi_x<=gx && gx<=ma_x && mi_y<=gy && gy<=ma_y)) ans = 0;\n            double d = min({dist_ll(s,g,xy(mi_x,mi_y),xy(mi_x,ma_y)),\n            dist_ll(s,g,xy(mi_x,ma_y),xy(ma_x,ma_y)),\n            dist_ll(s,g,xy(ma_x,ma_y),xy(ma_x,mi_y)),\n            dist_ll(s,g,xy(ma_x,mi_y),xy(mi_x,mi_y))});\n            if(d<=h) ans = min(ans,d);\n            else ans = min(ans,(h*h+d*d)/(2.0*h));\n        }\n        cout << fixed;\n        cout << setprecision(10) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tdouble calc(Line2D.Double line, double x, double y, double h) {\n\t\tdouble d1 = line.ptSegDist(x, y);\n\t\tdouble d2 = (d1 * d1 + h * h) / (2 * h);\n\t\treturn Math.max(d1, d2);\n\t}\n\t\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint N = in.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tint sx = in.nextInt(), sy = in.nextInt(), ex = in.nextInt(), ey = in.nextInt();\n\t\t\tLine2D.Double line = new Line2D.Double(sx, sy, ex, ey);\n\t\t\t\n\t\t\tdouble rmax = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint minx = in.nextInt(), miny = in.nextInt();\n\t\t\t\tint maxx = in.nextInt(), maxy = in.nextInt();\n\t\t\t\tint h = in.nextInt();\n\t\t\t\t\n\t\t\t\tRectangle2D.Double rect = \n\t\t\t\t\t\tnew Rectangle2D.Double(minx, miny, maxx - minx, maxy - miny);\n\t\t\t\tif (line.intersectsLine(minx, miny, minx, maxy)) rmax = 0;\n\t\t\t\tif (line.intersectsLine(minx, miny, maxx, miny)) rmax = 0;\n\t\t\t\tif (line.intersectsLine(maxx, maxy, minx, maxy)) rmax = 0;\n\t\t\t\tif (line.intersectsLine(maxx, maxy, maxx, miny)) rmax = 0;\n\t\t\t\tif (rect.contains(sx, sy)) rmax = 0;\n\t\t\t\tif (rect.contains(ex, ey)) rmax = 0;\n\t\t\t\t\n\t\t\t\trmax = Math.min(rmax, calc(line, minx, miny, h));\n\t\t\t\trmax = Math.min(rmax, calc(line, minx, maxy, h));\n\t\t\t\trmax = Math.min(rmax, calc(line, maxx, miny, h));\n\t\t\t\trmax = Math.min(rmax, calc(line, maxx, maxy, h));\n\t\t\t\tif (minx <= sx && sx <= maxx) {\n\t\t\t\t\trmax = Math.min(rmax, calc(line, sx, miny, h));\n\t\t\t\t\trmax = Math.min(rmax, calc(line, sx, maxy, h));\n\t\t\t\t}\n\t\t\t\tif (miny <= sy && sy <= maxy) {\n\t\t\t\t\trmax = Math.min(rmax, calc(line, minx, sy, h));\n\t\t\t\t\trmax = Math.min(rmax, calc(line, maxx, sy, h));\n\t\t\t\t}\n\t\t\t\tif (minx <= ex && ex <= maxx) {\n\t\t\t\t\trmax = Math.min(rmax, calc(line, ex, miny, h));\n\t\t\t\t\trmax = Math.min(rmax, calc(line, ex, maxy, h));\n\t\t\t\t}\n\t\t\t\tif (miny <= ey && ey <= maxy) {\n\t\t\t\t\trmax = Math.min(rmax, calc(line, minx, ey, h));\n\t\t\t\t\trmax = Math.min(rmax, calc(line, maxx, ey, h));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(rmax);\n\t\t}\n\t}\t\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\nconst double eps = 1e-8;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nusing Real = double;\nusing Point = complex< Real >;\nconst Real EPS = 1e-8, PI = acos(-1);\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  return os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\nReal radian_to_degree(Real r) {\n  return (r * 180.0 / PI);\n}\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\nstruct Line {\n  Point a, b;\n  Line() = default;\n  Line(Point a, Point b) : a(a), b(b) {}\n  Line(Real A, Real B, Real C)\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\nstruct Segment : Line {\n  Segment() = default;\n  Segment(Point a, Point b) : Line(a, b) {}\n};\nstruct Circle {\n  Point p;\n  Real r;\n  Circle() = default;\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;\n  if(cross(b, c) < -EPS) return -1;\n  if(dot(b, c) < 0) return +2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\nbool parallel(const Line &a, const Line &b) {\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\nbool orthogonal(const Line &a, const Line &b) {\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\nbool intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\nReal distance(const Line &l, const Point &p);\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\nReal distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\nReal distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\nReal distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\nReal distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\nenum {\n  OUT, ON, IN\n};\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nvoid merge_segments(vector< Segment > &segs) {\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\nReal area(const Polygon &p) {\n  Real A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A * 0.5;\n}\nReal area(const Polygon &p, const Circle &c) {\n  if(p.size() < 3) return 0.0;\n  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if(eq(f, 0.0)) return ret;\n    if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector< Point > tot{a, u.first, u.second, b};\n    for(int i = 0; i + 1 < tot.size(); i++) {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for(int i = 0; i < p.size(); i++) {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\nReal convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\nReal closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n  const Real INF = 1e18;\n  function< Real(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\nbool bs(double mid, Segment s1, const vector<pair<int, Segment>> &v) {\n  bool res = true;\n  for(int i=0;i<(int)(v.size());++i) {\n    int h = v[i].first;\n    Segment s2 = v[i].second;\n    double dist = distance(s1, s2);\n    if(h > mid - EPS) {\n      res &= dist > mid;\n    } else {\n      res &= dist > sqrt((2*mid - h) * h);\n    }\n  }\n  return res;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    double sx, sy, ex, ey; cin >> sx >> sy >> ex >> ey;\n    Segment s(Point(sx, sy), Point(ex, ey));\n    vector<pair<int, Segment>> v;\n    bool ok = true;\n    for(int i=0;i<n;++i) {\n      int x1, y1, x2, y2, h; cin >> x1 >> y1 >> x2 >> y2 >> h;\n      if(x1 - EPS <= sx && sx <= x2 + EPS &&\n          y1 - EPS <= sy && sy <= y2 + EPS &&\n          x1 - EPS <= ex && ex <= x2 + EPS &&\n          y1 - EPS <= ey && ey <= y2 + EPS) {\n        ok = false;\n        break;\n      }\n      Point p1(x1, y1), p2(x1, y2), p3(x2, y1), p4(x2, y2);\n      Segment s1(p1, p2), s2(p1, p3), s3(p2, p4), s4(p3, p4);\n      v.emplace_back(make_pair(h, s1));\n      v.emplace_back(make_pair(h, s2));\n      v.emplace_back(make_pair(h, s3));\n      v.emplace_back(make_pair(h, s4));\n    }\n    if(!ok) {\n      cout << 0 << endl;\n      continue;\n    }\n    double l = 0, r = 1000;\n    while(r - l > EPS) {\n      double mid = (l + r) / 2;\n      if(bs(mid, s, v)) {\n        l = mid;\n      } else {\n        r = mid;\n      }\n    }\n    cout << l << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ninline double sq(double x) { return x * x; }\n\nstruct point {\n    double x, y, z;\n    point() {}\n    point(double x, double y, double z): x(x), y(y), z(z) {}\n    point operator + (const point& o) const { return point(x+o.x, y+o.y, z+o.z); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y, z-o.z); }\n    point operator * (const double a) const { return point(x*a,   y*a,   z*a); }\n};\n\ndouble fabs(point p) { return sqrt(sq(p.x) + sq(p.y) + sq(p.z)); }\ndouble dist(point p, point q) { return fabs(p - q); }\ndouble dot(point p, point q) { return p.x*q.x + p.y*q.y + p.z*q.z; }\npoint cross(point p, point q) {\n    return point(\n        p.y*q.z - p.z*q.y,\n        p.z*q.x - p.x*q.z,\n        p.x*q.y - p.y*q.x\n    );\n}\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\ndouble dist_point_line(point p, line l) {\n    if (dot(l.b - l.a, p - l.a) >= 0 && dot(l.a - l.b, p - l.b) >= 0) {\n        point h = l.a + (l.b - l.a) * (dot(l.b - l.a, p - l.a) / sq(fabs(l.b - l.a)));\n        return dist(p, h);\n    }\n\n    return min(dist(p, l.a), dist(p, l.b));\n}\n\nint N; double Sx, Sy, Ex, Ey;\nvector<vector<point>> rects;\nvector<line> vs;\n\ndouble solve() {\n    line c(point(Sx, Sy, 0), point(Ex, Ey, 0));\n    for (vector<point> r : rects) {\n        for (int i = 0; i < r.size(); ++i) {\n            for (int j = i+1; j < r.size(); ++j) {\n                double c1 = cross(c.b - c.a, r[i] - c.a).z * cross(c.b - c.a, r[j] - c.a).z;\n                double c2 = cross(r[j] - r[i], c.a - r[i]).z * cross(r[j] - r[i], c.b - r[i]).z;\n                if (c1 < 0 && c2 < 0) {\n                    return 0;\n                } else if (c1 * c2 == 0) {\n                    double d1 = dist_point_line(r[i], c);  \n                    double d2 = dist_point_line(r[j], c);  \n                    double d3 = dist_point_line(c.a, line(r[i], r[j]));  \n                    double d4 = dist_point_line(c.b, line(r[i], r[j]));  \n                    if (fabs(min({d1, d2, d3, d4})) < 1e-8) {\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n\n    double l = 0, r = 1050;\n    for (int g = 0; g < 100; ++g) {\n        double m = (l + r) / 2;\n\n        line c(point(Sx, Sy, m), point(Ex, Ey, m));\n\n        bool ok = true;\n        for (line p : vs) {\n            if (dist_point_line(p.a, c) <= m || dist_point_line(p.b, c) <= m)\n                ok = false;\n            if (dist_point_line(c.a, p) <= m || dist_point_line(c.b, p) <= m)\n                ok = false;\n            if (m < p.a.z) p.a.z = p.b.z = m;\n            if (dist_point_line(p.a, c) <= m || dist_point_line(p.b, c) <= m)\n                ok = false;\n            if (dist_point_line(c.a, p) <= m || dist_point_line(c.b, p) <= m)\n                ok = false;\n        }\n\n        (ok ? l : r) = m;\n    }\n\n    return (l + r) / 2;\n}\n\nint main(void) {\n    cout << fixed << setprecision(4);\n    while (true) {\n        cin >> N; if (N == 0) break;\n        cin >> Sx >> Sy >> Ex >> Ey;\n        vs.clear();\n        rects.clear();\n        for (int i = 0; i < N; ++i) {\n            double minx, miny, maxx, maxy, h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            vs.emplace_back(point(minx, miny, h), point(minx, maxy, h));\n            vs.emplace_back(point(minx, miny, h), point(maxx, miny, h));\n            vs.emplace_back(point(minx, maxy, h), point(maxx, maxy, h));\n            vs.emplace_back(point(maxx, miny, h), point(maxx, maxy, h));\n\n            vector<point> vv;\n            vv.emplace_back(minx, miny, h);\n            vv.emplace_back(minx, maxy, h);\n            vv.emplace_back(maxx, miny, h);\n            vv.emplace_back(maxx, maxy, h);\n            rects.push_back(vv);\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nconst double eps=1e-10;\ndouble add(double a,double b){\n    if(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n    return a+b;\n}\n\ntypedef pair<double,double> P;\nP operator+(const P& x,const P& y){\n    return {add(x.first,y.first),add(x.second,y.second)};\n}\n\nP operator-(const P& x,const P& y){\n    return {add(x.first,-y.first),add(x.second,-y.second)};\n\n}\n\nP operator*(const P& x,const double& y){\n    return {x.first*y,x.second*y};\n}\ndouble dot(P x,P y){\n    return add(x.first*y.first,x.second*y.second);\n\n\n}\n\ndouble det(P x,P y){\n    return add(x.first*y.second,-x.second*y.first);\n}\n\nbool onseg(P p1,P p2,P q){\n    return det(p1-q,p2-q)==0 &&dot(p1-q,p2-q)<=0; \n}\n\nP intersection(P p1,P p2,P q1,P q2){\n    return p1+(p2-p1)*(det(q2-q1,q1-p1)/det(q2-q1,p2-p1));\n}\n\nbool cross(P p1,P p2,P q1,P q2){\n    if(det(p1-p2,q1-q2)==0)return onseg(p1,p2,q1)||onseg(p1,p2,q2)||onseg(q1,q2,p1)||onseg(q1,q2,p2);\n    P ret=intersection(p1,p2,q1,q2);\n    return onseg(p1,p2,ret)&&onseg(q1,q2,ret);\n}\n\ndouble dist(P p1,P p2,P q){\n    if(dot(q-p1,p2-p1)<=0)return sqrt(dot(q-p1,q-p1));\n    if(dot(q-p2,p1-p2)<=0)return sqrt(dot(q-p2,q-p2));\n    P d=p1-p2;\n    P ret=q+P{d.second,-d.first};\n    P h=intersection(p1, p2, q, ret);\n    return sqrt(dot(q-h,q-h));\n}\n\nint main(){\n    int n;\n    while(cin>>n,n!=0){\n        P s,t;\n        cin>>s.first>>s.second>>t.first>>t.second;\n        double ans=1000;\n        rep(i,n){\n            P a[4];\n            double h;\n            cin>>a[0].first>>a[0].second>>a[2].first>>a[2].second>>h;\n            a[1]={a[0].first,a[2].second};\n            a[3]={a[2].first,a[0].second};\n            if(a[0].first<s.first&&s.first<a[2].first&&a[0].first<t.first&&t.first<a[2].first&&a[0].second<s.second&&s.second<a[2].second&&a[0].second<t.second&&t.second<a[2].second)ans=0;\n            rep(i,4)if(cross(s,t,a[i],a[(i+1)%4]))ans=0;\n            rep(i,4){\n                double d=dist(s,t,a[i]);\n                if(d<h)ans=min(ans,d);\n                else ans=min(ans,(h*h+d*d)/2/h);\n            }\n            rep(i,4){\n                double d=min(dist(a[i],a[(i+1)%4],s),dist(a[i],a[(i+1)%4],s));\n                if(d<h)ans=min(ans,d);\n                else ans=min(ans,(h*h+d*d)/2/h);\n            }\n        }\n        cout<<fixed<<setprecision(6)<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\ndouble inf = 1e9;\nstruct point{\n    double x,y;\n    point(){}\n    point(double x,double y):x(x),y(y){}\n    point operator + (point p){return point(x+p.x,y+p.y); }\n    point operator - (point p){return point(x-p.x,y-p.y); }\n    point operator * (double k ){ return point(x*k,y*k); }\n    double norm() { return x*x + y* y;}\n    double abs() { return sqrt(norm());}\n    void make() { cin>>x>>y;}\n};\nstruct line{\n    point s,t;\n    line(){}\n    line(point s,point t):s(s),t(t){}\n    void make(){ s.make(),t.make();}\n};\ndouble abs(point p){return p.abs();}\n\ndouble dot(point a,point b){return a.x*b.x+a.y*b.y;}\ndouble cross(point a,point b){return a.x*b.y-a.y*b.x;}\nint ccw(point p0,point p1,point p2){\n    point a = p1-p0;\n    point b = p2-p0;\n    if( cross(a,b) > EPS) return 1;\n    if( cross(a,b) < -EPS) return -1;\n    if( dot(a,b) < -EPS) return 2;\n    if(a.norm() < b.norm() )return -1;\n    return 0;\n}\nbool intersect(point p0,point p1,point p2,point p3){\n    return (ccw(p0,p1,p2) *ccw(p0,p1,p3)<=0 && ccw(p2,p3,p0)*ccw(p2,p3,p1)<=0 ); \n}\nbool intersect(line l1,line l2){\n    return intersect(l1.s,l1.t,l2.s,l2.t); \n}\ndouble distancelp(line l,point p){ return abs( cross(l.t-l.s,p-l.s) / (l.t-l.s).abs() ); }\ndouble distance(line l,point p){\n    if(dot(l.t-l.s,p-l.s) < 0.0) return abs(p-l.s);\n    if(dot(l.s-l.t,p-l.t) < 0.0) return abs(p-l.t);\n    return distancelp(l,p);\n}\ndouble distance(line l1,line l2){\n    if(intersect(l1,l2)) return 0.0;\n    return min( min(distance(l1,l2.s)   , distance(l1,l2.t)) , min(distance(l2,l1.s),distance(l2,l1.t) ) );\n}\nbool check(line l,double r){\n    point o = point(0,r);\n   // cout<<r<<' '<<distance(l,o)<<endl;\n    if( distance(l,o) >= r) return true;\n    return false;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin>>n;\n        if(n==0)break;\n        line l;\n        l.make();\n        vector<double> d(n,inf);\n        vector<double> h(n);\n        for(int i=0;i<n;i++){\n            //cout<<i<<endl;\n            double mx,my,Mx,My;\n            point a,b,c,dd;\n            a.make();\n            b.make();\n            mx = min(a.x,b.x),Mx = max(a.x,b.x),my = min(a.y,b.y),My = max(a.y,b.y);\n            c = point(a.x,b.y);\n            dd = point(b.x,a.y);\n            cin>>h[i];\n            d[i] = min( distance(line(a,c) , l) , d[i]);\n            d[i] = min( distance(line(a,dd) , l) , d[i]); \n            d[i] = min( distance(line(b,c) , l) , d[i]); \n            d[i] = min( distance(line(b,dd) , l) , d[i]); \n\n            if(mx<= l.s.x && l.s.x <= Mx && my<=l.s.y && l.s.y<=My ) d[i] = 0;\n            if(mx<=l.t.x && l.t.x <= Mx && my <= l.t.y && l.t.y <=My )d[i] = 0;\n        }\n        vector<line> ls(n);\n        //for(int i=0;i<n;i++)cout<<d[i]<<endl;\n        double up = inf, low = 0;\n        for(int i=0; i<n;i++) ls[i] = line(point(d[i],0.0),point(d[i],h[i]));\n        while( up-low > EPS){\n            double mid = (low + up)/2;\n            bool flag = true;\n            point o = point(0,mid);\n            for(int i=0;i<n;i++){\n                if(!check(ls[i],mid)){\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                low = mid;\n               // cout<<\"true\"<<endl;\n            }else{\n                up = mid;\n            }\n        }\n        printf(\"%0.10lf\\n\",(low+up)/2);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(const Point &p0,const Point &p1,const Point &p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nPoint projection(const Segment &s,const Point &p){\n    Vector b = s.t-s.s;\n    double t = dot(p-s.s,b)/norm(b);\n    return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n    return (ccw(s.s,s.t,p) == 0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n            ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n    Point r = projection(s,p);\n    if(isIntersectSP(s,r)) return abs(r-p);\n    return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment &a,const Segment &b){\n    if(isIntersectSS(a,b)) return 0;\n    return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n           min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nstruct Block{\n    Point a,b;\n    double h;\n    Block(){}\n    Block(Point &a,Point &b,double h) :\n        a(a),b(b),h(h) {}\n};\n\nistream &operator >> (istream &is,Point &p){ \n    return is >> p.x >> p.y;\n}\n\ndouble calc(double a,double b){\n    return sqrt(a*a+b*b);\n}\n\nbool c(double r,Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point c(v[i].a.x,v[i].b.y),d(v[i].b.x,v[i].a.y);\n        Segment s1(v[i].a,c),s2(v[i].a,d),s3(c,v[i].b),s4(d,v[i].b);\n        double dst[] = {\n            distanceSS(p,s1),\n            distanceSS(p,s2),\n            distanceSS(p,s3),\n            distanceSS(p,s4)\n        };\n \n        if(lt(r,v[i].h)){\n            if(!(lt(r,dst[0]) &&\n                 lt(r,dst[1]) &&\n                 lt(r,dst[2]) &&\n                 lt(r,dst[3]))){\n                return false;\n            }\n        }else{\n            double nh = r - v[i].h;\n            if(!(lt(r,calc(nh,dst[0])) &&\n                 lt(r,calc(nh,dst[1])) &&\n                 lt(r,calc(nh,dst[2])) &&\n                 lt(r,calc(nh,dst[3])))){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool check(Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point c(v[i].a.x,v[i].b.y);\n        Point d(v[i].b.x,v[i].a.y);\n        Segment s1(v[i].a,c),s2(v[i].a,d),s3(c,v[i].b),s4(d,v[i].b);\n        if((v[i].a.x <= p.s.x && p.s.x <= v[i].b.x &&\n            v[i].a.y <= p.s.y && p.s.y <= v[i].b.y) ||\n           (v[i].a.x <= p.t.x && p.t.x <= v[i].b.x &&\n            v[i].a.y <= p.t.y && p.t.y <= v[i].b.y)){\n            return true;\n        }\n        if(isIntersectSS(p,s1)) return true;\n        if(isIntersectSS(p,s2)) return true;\n        if(isIntersectSS(p,s3)) return true;\n        if(isIntersectSS(p,s4)) return true;\n    }\n    return false;\n}\n\nint main(){\n    int N;\n    while(cin >> N,N){\n        Point s,e;\n        Segment seg;\n        cin >> seg.s >> seg.t;\n        vector<Block> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].a >> v[i].b >> v[i].h;\n        }\n        if(check(seg,v)){\n            cout << 0 << endl;\n            continue;\n        }\n        double l = 0,r = 10000001;\n        for(int i = 0 ; i < 100 ; i++){\n            double mid = (l + r) / 2;\n            if(c(mid,seg,v)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n\tprintf(\"%.10f\\n\",r);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define MOD_TYPE 1\n\n#pragma region Macros\n#include <bits/stdc++.h>\nusing namespace std;\n/*\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\nusing multiInt = boost::multiprecision::cpp_int;\nusing lld = boost::multiprecision::cpp_dec_float_100;\n*/\n/*\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n*/\nusing ll = long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pld = pair<ld, ld>;\ntemplate <typename Q_type>\nusing smaller_queue = priority_queue<Q_type, vector<Q_type>, greater<Q_type>>;\n\nconstexpr ll MOD = (MOD_TYPE == 1 ? (ll)(1e9 + 7) : 998244353);\n//constexpr ll MOD = 1;\nconstexpr int INF = (int)1e9;\nconstexpr ll LINF = (ll)4e18;\nconstexpr double PI = acos(-1.0);\nconstexpr double EPS = 1e-8;\nconstexpr int Dx[] = {0, 0, -1, 1, -1, 1, -1, 1, 0};\nconstexpr int Dy[] = {1, -1, 0, 0, -1, -1, 1, 1, 0};\n\n#define REP(i, m, n) for (ll i = m; i < (ll)(n); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define REPI(i, m, n) for (int i = m; i < (int)(n); ++i)\n#define repi(i, n) REPI(i, 0, n)\n#define MP make_pair\n#define MT make_tuple\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\") << \"\\n\"\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\") << \"\\n\"\n#define possible(n) cout << ((n) ? \"possible\" : \"impossible\") << \"\\n\"\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\") << \"\\n\"\n#define Yay(n) cout << ((n) ? \"Yay!\" : \":(\") << \"\\n\"\n#define all(v) v.begin(), v.end()\n#define NP(v) next_permutation(all(v))\n#define dbg(x) cerr << #x << \":\" << x << \"\\n\";\n\ninline void init_main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(30) << setiosflags(ios::fixed);\n}\ntemplate <typename T>\ninline bool chmin(T &a, T b)\n{\n  if (a > b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <typename T>\ninline bool chmax(T &a, T b)\n{\n  if (a < b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ninline ll CEIL(ll a, ll b)\n{\n  return (a + b - 1) / b;\n}\ntemplate <typename A, size_t N, typename T>\ninline void Fill(A (&array)[N], const T &val)\n{\n  fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T, typename U>\nconstexpr ostream &operator<<(ostream &os, pair<T, U> &p) noexcept\n{\n  os << p.first << \" \" << p.second;\n  return os;\n}\n#pragma endregion\n\nusing Real = double;\nusing Point = complex<Real>;\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d)\n{\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p)\n{\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p)\n{\n  return os << fixed << setprecision(20) << p.real() << \" \" << p.imag();\n}\n\n// 点 p を反時計回りに theta 回転\nPoint rotate(Real theta, const Point &p)\n{\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r)\n{\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d)\n{\n  return (d * PI / 180.0);\n}\n\n// a-b-c の角度のうち小さい方を返す\nReal get_angle(const Point &a, const Point &b, const Point &c)\n{\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta)\n    swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std\n{\nbool operator<(const Point &a, const Point &b)\n{\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nstruct Line\n{\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if (eq(A, 0))\n      a = Point(0, C / B), b = Point(1, C / B);\n    else if (eq(B, 0))\n      b = Point(C / A, 0), b = Point(C / A, 1);\n    else\n      a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p)\n  {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a)\n  {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line\n{\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle\n{\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector<Point>;\nusing Polygon = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\n\nReal cross(const Point &a, const Point &b)\n{\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b)\n{\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\n// 点の回転方向\nint ccw(const Point &a, Point b, Point c)\n{\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS)\n    return +1; // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS)\n    return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0)\n    return +2; // \"ONLINE_BACK\"\n  if (norm(b) < norm(c))\n    return -2; // \"ONLINE_FRONT\"\n  return 0;    // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\n// 平行判定\nbool parallel(const Line &a, const Line &b)\n{\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\n// 垂直判定\nbool orthogonal(const Line &a, const Line &b)\n{\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\n// 射影\n// 直線 l に p から垂線を引いた交点を求める\nPoint projection(const Line &l, const Point &p)\n{\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p)\n{\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\n// 反射\n// 直線 l を対称軸として点 p  と線対称にある点を求める\nPoint reflection(const Line &l, const Point &p)\n{\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool intersect(const Line &l, const Point &p)\n{\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m)\n{\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p)\n{\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s)\n{\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nReal distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l)\n{\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p)\n{\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t)\n{\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l)\n{\n  if (norm(projection(l, c.p) - c.p) - c.r * c.r > EPS)\n    return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS)\n    return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS)\n    return 1;\n  const Point h = projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0)\n    return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2)\n{\n  if (c1.r < c2.r)\n    swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if (c1.r + c2.r < d)\n    return 4;\n  if (eq(c1.r + c2.r, d))\n    return 3;\n  if (c1.r - c2.r < d)\n    return 2;\n  if (eq(c1.r - c2.r, d))\n    return 1;\n  return 0;\n}\n\nReal distance(const Point &a, const Point &b)\n{\n  return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p)\n{\n  return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m)\n{\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p)\n{\n  Point r = projection(s, p);\n  if (intersect(s, r))\n    return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b)\n{\n  if (intersect(a, b))\n    return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s)\n{\n  if (intersect(l, s))\n    return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m)\n{\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if (eq(abs(A), 0.0) && eq(abs(B), 0.0))\n    return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m)\n{\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair<Point, Point> crosspoint(const Circle &c, const Line l)\n{\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if (eq(distance(l, c.p), c.r))\n    return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair<Point, Point> crosspoint(const Circle &c, const Segment &l)\n{\n  Line aa = Line(l.a, l.b);\n  if (intersect(c, l) == 2)\n    return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair<Point, Point> crosspoint(const Circle &c1, const Circle &c2)\n{\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\n// 点 p を通る円 c の接線\npair<Point, Point> tangent(const Circle &c1, const Point &p2)\n{\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\n// 円 c1, c2 の共通接線\nLines tangent(Circle c1, Circle c2)\n{\n  Lines ret;\n  if (c1.r < c2.r)\n    swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if (eq(g, 0))\n    return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for (int s : {-1, 1})\n  {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if (eq(1 - h * h, 0))\n    {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    }\n    else if (1 - h * h > 0)\n    {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\n// 凸性判定\nbool is_convex(const Polygon &p)\n{\n  int n = (int)p.size();\n  for (int i = 0; i < n; i++)\n  {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1)\n      return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\n// 凸包\nPolygon convex_hull(Polygon &p)\n{\n  int n = (int)p.size(), k = 0;\n  if (n <= 2)\n    return p;\n  sort(p.begin(), p.end());\n  vector<Point> ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = p[i++])\n  {\n    while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS)\n      --k;\n  }\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--])\n  {\n    while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS)\n      --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\n// 多角形と点の包含判定\nenum\n{\n  OUT,\n  ON,\n  IN\n};\n\nint contains(const Polygon &Q, const Point &p)\n{\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++)\n  {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag())\n      swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0)\n      in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0)\n      return ON;\n  }\n  return in ? IN : OUT;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\n// 線分の重複除去\nvoid merge_segments(vector<Segment> &segs)\n{\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS)\n      return false;\n    if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1)\n      return false;\n    if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2)\n      return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n\n  for (int i = 0; i < segs.size(); i++)\n  {\n    if (segs[i].b < segs[i].a)\n      swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++)\n  {\n    for (int j = i + 1; j < segs.size(); j++)\n    {\n      if (merge_if_able(segs[i], segs[j]))\n      {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\n// 線分アレンジメント\n// 任意の2線分の交点を頂点としたグラフを構築する\nvector<vector<int>> segment_arrangement(vector<Segment> &segs, vector<Point> &ps)\n{\n  vector<vector<int>> g;\n  int N = (int)segs.size();\n  for (int i = 0; i < N; i++)\n  {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++)\n    {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0)\n        continue;\n      if (intersect(segs[i], segs[j]))\n      {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++)\n  {\n    vector<int> vec;\n    for (int j = 0; j < M; j++)\n    {\n      if (intersect(segs[i], ps[j]))\n      {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++)\n    {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\n// 凸多角形の切断\n// 直線 l.a-l.b で切断しその左側にできる凸多角形を返す\nPolygon convex_cut(const Polygon &U, Line l)\n{\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++)\n  {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1)\n      ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0)\n    {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\n// 多角形の面積\nReal area(const Polygon &p)\n{\n  Real A = 0;\n  for (int i = 0; i < p.size(); ++i)\n  {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A * 0.5;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\n// 円と多角形の共通部分の面積\nReal area(const Polygon &p, const Circle &c)\n{\n  if (p.size() < 3)\n    return 0.0;\n  function<Real(Circle, Point, Point)> cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if (eq(f, 0.0))\n      return ret;\n    if (max(abs(va), abs(vb)) < c.r + EPS)\n      return f;\n    if (distance(Segment(a, b), c.p) > c.r - EPS)\n      return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector<Point> tot{a, u.first, u.second, b};\n    for (int i = 0; i + 1 < tot.size(); i++)\n    {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for (int i = 0; i < p.size(); i++)\n  {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\n// 凸多角形の直径(最遠頂点対間距離)\nReal convex_diameter(const Polygon &p)\n{\n  int N = (int)p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < N; i++)\n  {\n    if (p[i].imag() > p[is].imag())\n      is = i;\n    if (p[i].imag() < p[js].imag())\n      js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do\n  {\n    if (cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0)\n    {\n      j = (j + 1) % N;\n    }\n    else\n    {\n      i = (i + 1) % N;\n    }\n    if (norm(p[i] - p[j]) > maxdis)\n    {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\n// 最近点対\nReal closest_pair(Points ps)\n{\n  if (ps.size() <= 1)\n    throw(0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector<Point> beet(ps.size());\n  const Real INF = 1e18;\n\n  function<Real(int, int)> rec = [&](int left, int right) {\n    if (right - left <= 1)\n      return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for (int i = left; i < right; i++)\n    {\n      if (abs(real(ps[i]) - x) >= ret)\n        continue;\n      for (int j = 0; j < ptr; j++)\n      {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if (imag(luz) >= ret)\n          break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int)ps.size());\n}\n\nvoid solve()\n{\n  int n;\n  cin >> n;\n  if (n == 0)\n    exit(0);\n  Point s, e;\n  cin >> s >> e;\n  Segment se(s, e);\n  vector<Real> d(n, INF);\n  vector<Real> h(n);\n  bool zero = false;\n  rep(i, n)\n  {\n    Real x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2 >> h[i];\n    Point p[4];\n    p[0] = Point(x1, y1);\n    p[1] = Point(x2, y1);\n    p[2] = Point(x2, y2);\n    p[3] = Point(x1, y2);\n    Segment sg[4];\n    rep(i, 4) sg[i] = Segment(p[i], p[(i + 1) % 4]);\n    rep(j, 4) chmin(d[i], distance(se, sg[j]));\n    if (fabs(d[i]) < EPS)\n      zero = true;\n    Polygon poly = {p[0], p[1], p[2], p[3], p[0]};\n    if (contains(poly, s))\n      zero = true;\n  }\n  if (zero)\n  {\n    cout << 0.0 << \"\\n\";\n    return;\n  }\n  auto simulate = [&](Real r) {\n    Circle c(Point(0, r), r);\n    rep(i, n)\n    {\n      Segment sg(Point(d[i], 0), Point(d[i], h[i]));\n      if (intersect(c, sg))\n        return false;\n    }\n    return true;\n  };\n\n  Real lo = 0.0, hi = 1000.0;\n  rep(si, 100)\n  {\n    Real mi = (lo + hi) / 2.0;\n    if (simulate(mi))\n      lo = mi;\n    else\n      hi = mi;\n  }\n  cout << lo << \"\\n\";\n}\n\nint main()\n{\n  init_main();\n\n  while (1)\n  {\n    solve();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<complex>\n\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define min_int(a,b) ((a)<(b)?(a):(b))\n#define INF 10000000 //2^31\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\nusing namespace std;\n\nclass Gio{\nprivate:\n\ttypedef complex<double>point;\n\tstruct line{ \n\t\tpoint st, ed;//始点,終点\n\t};\n\tpoint min_p,max_p;\n\tline orig, test;\n\tdouble min_R;//保存用\n\tdouble test_R;//実行用\n\tdouble dot(point a, point b);//内積\n\tdouble cross(point a, point b);//外積\n\npublic:\n\tGio(double sx, double sy,double ex,double ey);\n\tvoid set_p(point* p, double x, double y);\n\tvoid set_line(line* l, point s, point e);\n\tvoid set_testline(double sx, double sy, double ex, double ey);\n\tvoid calc_r(double sx,double sy,double lx,double ly,double h);\n\tdouble get_r();\n\tdouble get_d_pp();//min_pとmax_pの距離を返す\n\tdouble get_d_lp();//min_pとtestの長さを返す\n\tdouble get_d_ll();//origとtestの長さを返す\n\tbool intersect();//origとtestが交差していればtrue\n};\n\nGio::Gio(double sx, double sy, double ex, double ey){\n\tset_p(&min_p, sx, sy);\n\tset_p(&max_p, ex, ey);\n\tset_line(&orig, min_p, max_p);\n\tmin_R = INF;\n}\nvoid Gio::set_p(point *p, double x, double y){\n\tpoint a(x, y);\n\t*p = a;\n}\nvoid Gio::set_line(line* l, point s, point e){\n\tl->st = s;\n\tl->ed=e;\n}\nvoid Gio::set_testline(double sx,double sy,double ex,double ey){\n\tpoint a, b;\n\tset_p(&a, sx, sy); set_p(&b, ex, ey);\n\tset_line(&test, a, b);\n\t//printf(\"%lf,%lf\\n\", test.st.real(), test.st.imag());\n}\ndouble Gio::dot(point a, point b){\n\treturn(a.real()*b.real() + a.imag()*b.imag());\n}\ndouble Gio::cross(point a, point b){\n\treturn(a.real()*b.imag() - a.imag()*b.real());\n}\ndouble Gio::get_d_pp(){ return(abs(max_p - min_p)); }\ndouble Gio::get_d_lp(){\n\tpoint a = test.st;\n\tpoint b = test.ed;\n\tpoint c = min_p;\n\tif (dot(b - a, c - a) < EPS)return(abs(c - a));\n\tif (dot(a - b, c - b) < EPS)return(abs(c - b));\n\treturn(abs(cross(b - a, c - a)) / abs(b - a));\n}\nbool Gio::intersect(){\n\tpoint a = orig.st, b = orig.ed, c = test.st, d = test.ed;\n\treturn((cross(b - a, c - a)*cross(b - a, d - a) < EPS) && (cross(d - c, a - c)*cross(d - c, b - c) < EPS));\n}\n\ndouble Gio::get_d_ll(){\n\tif (intersect())return(0);\n\tpoint a0, a1,b0,b1;\n\ta0 = orig.st;\n\ta1 = orig.ed;\n\tb0 = test.st;\n\tb1 = test.ed;\n\tdouble d1, d2, d3, d4;\n\tmin_p = a0; d1 = get_d_lp();\n\tmin_p = a1; d2 = get_d_lp();\n\tset_line(&test, a0, a1);\n\tmin_p = b0; d3 = get_d_lp();\n\tmin_p = b1; d4 = get_d_lp();\n\td1 = min_int(d1, d2);\n\td2 = min_int(d3, d4);\n\treturn(min_int(d1, d2));\n}\n\nvoid Gio::calc_r(double sx, double sy, double lx, double ly,double h){\n\tdouble d1, d2, d3, d4;\n\tpoint p = orig.st;\n\tif (sx <= p.real() && p.real() <= lx&&sy <= p.imag()&&p.imag() <= ly){\n\t\tmin_R = 0; return;\n\t}\n\n\tset_testline(sx, sy, sx, ly); d1 = get_d_ll();\n\tset_testline(sx, sy, lx, sy); d2 = get_d_ll();\n\tset_testline(sx, ly, lx, ly); d3 = get_d_ll();\n\tset_testline(lx, sy, lx, ly); d4 = get_d_ll();\n\td1 = min_int(min_int(d1, d2), min_int(d3, d4));\n\tif (h >= d1)test_R = d1;\n\telse{\n\t\ttest_R = ((d1*d1 + h*h) / h) / 2;\n\t}\n\tmin_R = min_int(min_R, test_R);\n}\ndouble Gio::get_r(){\n\treturn(min_R);\n}\n\nint b_num;\n\nint main(void){\n\t//Gio g(1, 1, 2, 2);\n\t//g.set_testline(1, 2, 2, 3);\n\t//cout << g.get_d_ll()<<endl;\n\twhile (true){\n\t\tcin >> b_num;\n\t\tif (b_num == 0)return(0);\n\t\tdouble sx, sy, ex, ey,h;\n\t\tcin >> sx >> sy>>ex >> ey;\n\t\tGio g(sx, sy, ex, ey);\n\t\trep(i, 0, b_num){\n\t\t\tcin >> sx >> sy >> ex >> ey>>h;\n\t\t\tg.calc_r(sx, sy, ex, ey, h);\n\t\t}\n\n\t\tprintf(\"%.10lf\\n\", g.get_r());\n\n\t}\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS 1e-10\n#define EQ(a,b) (abs(a - b) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n//外積\ndouble cross (P a, P b) {return (a.real() * b.imag() - a.imag() * b.real());}\n\n//内積\ndouble dot (P a, P b) {return (a.real() * b.real() + a.imag() * b.imag());}\n\n//直行\nbool is_orthogonal(P a1, P a2, P b1, P b2) {return EQ( dot(a1 - a2, b1 - b2), 0.0);}\n\n//平行\nbool is_parallel(P a1, P a2, P b1, P b2) {return EQ( cross(a1 - a2, b1 - b2), 0.0);}\n\n//直線上\nbool is_point_on_vector(P a, P b, P c) {return EQ( cross(a - c, c - b), 0.0);}\n\n//線分上\nbool is_point_on_line (P a, P b, P c) {return (abs(a - c) + abs(c - b) < abs(a - b) + EPS);}\n\n//角度　線分の距離は小数点以下３桁まで\ndouble angle (P a, P b, P p) {return (acos(dot(a-p,b-p) / (abs(a-p) * abs(b-p))) * 180.0 / M_PI);}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_l(P a1, P a2, P b1, P b2) {return !EQ( cross(a1-a2, b1-b2), 0.0 );}\n\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {return abs(cross(b-a, c-a)) / abs(b-a);}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2 - a1; P b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n    if ( dot(b-a, c-a) < EPS ) return fabs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return fabs(c-b);\n    return fabs(cross(b-a, c-a)) / fabs(b-a);\n}\n\n/***************************************\n *\n * 2点を通る直線とある点からの垂線との交点\n *\n * a, b を直線\n * p    をある点\n *\n ***************************************/\nP crossNormalVector (P a, P b, P p) {\n    double t = dot(b-a, p-a) / (abs(b-a) * abs(b - a));\n    return a + t * (b - a);\n}\n\ndouble calc (double h, double r) {\n    if (h > r) h = r;\n    return (r * r + h * h) / (2 * h);\n}\n\nint main ()\n{\n    int n;\n    while (cin >> n, n) {\n        double sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        P s(sx, sy), e(ex, ey);\n\n        double res_h = 100000.;\n        while (n--) {\n            // cout << \"Count # \" << n << endl;\n            \n            double minx, miny, maxx, maxy;\n\n            double h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            vector<P> v = { P(minx, miny), P(minx, maxy), P(maxx, maxy), P(maxx, miny)};\n\n            if (minx <= s.real() && s.real() <= maxx && miny <= s.imag() && s.imag() <= maxy) res_h = 0.;\n            if (minx <= e.real() && e.real() <= maxx && miny <= e.imag() && e.imag() <= maxy) res_h = 0.;\n\n            for (int i = 0; i < 4; i++) {\n                int anf = (i + 1) % 4, bfr = (i + 4 - 1) % 4;\n                int now = i;\n\n                if (is_intersected_ls(e, s, v[now], v[anf])) res_h = 0.;\n                if (is_intersected_ls(e, s, v[now], v[bfr])) res_h = 0.;\n                \n                // cout << \"DBG > \" << min(v[now].real(), v[anf].real()) << \" \" << max(v[now].real(), v[anf].real()) << endl;\n                // cout << \"      \" << min(v[now].imag(), v[anf].imag()) << \" \" << max(v[now].imag(), v[anf].imag()) << endl;\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[anf], s)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[bfr], s)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[anf], e)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[bfr], e)));\n                // res_h = min(res_h, calc(h, min(abs(minx - s.real()), abs(maxx - s.real()))));\n                // res_h = min(res_h, calc(h, min(abs(miny - s.imag()), abs(maxy - s.imag()))));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[now])));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[anf])));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[bfr])));\n            }\n        }\n\n        printf(\"%.4f\\n\", res_h);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**************** Geometrical Library ****************/\n\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define\tEPS\t1e-9\n\nenum {CCW=1,CW=-1,ON=0};\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy):x(xx),y(yy){}\n};\n\nclass Line:public vector<Point>{\npublic:\n\tLine(const Point &a,const Point &b){\n\t\tpb(a),pb(b);\n\t}\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\nclass Polygon:public vector<Point>{};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &cc,double rr):c(cc),r(rr){}\n};\n\nPoint &operator +=(Point &a,const Point &b){\n\ta.x+=b.x,a.y+=b.y;\n\treturn a;\n}\n\nPoint &operator -=(Point &a,const Point &b){\n\ta.x-=b.x,a.y-=b.y;\n\treturn a;\n}\n\nPoint &operator *=(Point &a,double c){\n\ta.x*=c,a.y*=c;\n\treturn a;\n}\n\nPoint &operator /=(Point &a,double c){\n\ta.x/=c,a.y/=c;\n\treturn a;\n}\n\nPoint operator +(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c+=b;\n}\n\nPoint operator -(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c-=b;\n}\n\nPoint operator *(double c,const Point &a){\n\tPoint b=a;\n\treturn b*=c;\n}\n\nPoint operator /(const Point &a,double c){\n\tPoint b=a;\n\treturn b/=c;\n}\n\nbool operator <(const Point &a,const Point &b){\n\treturn (a.x==b.x)?(a.y<b.y):(a.x<b.x);\n}\n\nbool operator >(const Point &a,const Point &b){\n\treturn b<a;\n}\n\ndouble dot(const Point &a,const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble norm2(const Point &a){\n\treturn dot(a,a);\n}\n\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)\t\treturn CCW;\n\tif(rotdir<-EPS)\t\treturn CW;\n\treturn ON;\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\t// l : ax+by+c=0\n\ta=l[0].y-l[1].y;\n\tb=l[1].x-l[0].x;\n\tc=l[0].x*l[1].y-l[1].x*l[0].y;\n}\n\nPoint perp_foot(const Point &p,const Line &l){\n\tdouble a,b,c;\n\tcalc_abc(l,a,b,c);\n\treturn p-(a*p.x+b*p.y+c)/(a*a+b*b)*Point(a,b);\n}\n\nbool intersect(const Line &l,const Line &m,Point *p=NULL){\n\t// this routine also returns true in case \"M is on L\", etc,.\n\tif(abs(cross(l[1]-l[0],m[1]-m[0]))>EPS\n\t|| abs(cross(l[1]-l[0],m[0]-l[0]))<EPS){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(l,a1,b1,c1);\n\t\t\tcalc_abc(m,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS)\t*p=l[0];\t// l == m\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool intersect(const Segment &s,const Segment &t,Point *p=NULL){\n\tif(max(s[0].x,s[1].x)<min(t[0].x,t[1].x)\n\t|| max(t[0].x,t[1].x)<min(s[0].x,s[1].x)\n\t|| max(s[0].y,s[1].y)<min(t[0].y,t[1].y)\n\t|| max(t[0].y,t[1].y)<min(s[0].y,s[1].y))\treturn false;\n\n\tif(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(s,a1,b1,c1);\n\t\t\tcalc_abc(t,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS){\t// s is parallel to t\n\t\t\t\tPoint q[3]={s[0],s[1],t[0]};\n\t\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\t\tif(dot(q[i]-s[0],q[i]-s[1])<EPS && dot(q[i]-t[0],q[i]-t[1])<EPS){\n\t\t\t\t\t\t*p=q[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**************** Library END ****************/\n\n#include<cstdio>\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint sx,sy,gx,gy;\n\t\tif(scanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy)==EOF)break;\n\t\tPoint s(sx,sy),g(gx,gy);\n\t\tSegment course(s,g);\n\n\t\tdouble rmin=1e30;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint ox1,oy1,ox2,oy2,h;\n\t\t\tscanf(\"%d%d%d%d%d\",&ox1,&oy1,&ox2,&oy2,&h);\n\t\t\tPoint obj[2];\n\t\t\tobj[0]=Point(ox1,oy1),obj[1]=Point(ox2,oy2);\n\n\t\t\tbool oncourse=false;\n\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<2;k++){\t// cross course x object\n\t\t\t\tSegment edge(Point(obj[j].x,obj[k].y),Point(obj[k].x,obj[1-j].y));\n\t\t\t\tif(intersect(course,edge)){ oncourse=true; break; }\n\t\t\t}\n\t\t\tfor(int l=0;l<2;l++){\t// course in object\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<2;k++){\n\t\t\t\t\tSegment edge(Point(obj[j].x,obj[k].y),Point(obj[k].x,obj[1-j].y));\n\t\t\t\t\tcnt+=ccw(edge[0],edge[1],course[l]);\n\t\t\t\t}\n\t\t\t\tif(cnt==4*CCW || cnt==4*CW){ oncourse=true; break; }\n\t\t\t}\n\t\t\tif(oncourse){ rmin=0; break; }\n\n\t\t\tdouble d2min=1e30;\n\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<2;k++){\n\t\t\t\tPoint u=Point(obj[j].x,obj[k].y);\n\t\t\t\tPoint v=perp_foot(u,Line(course[0],course[1]));\n\t\t\t\tif(dot(v-course[0],v-course[1])<EPS){\t// v is on course\n\t\t\t\t\tdouble d2=norm2(v-u);\n\t\t\t\t\td2min=min(d2min,d2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<2;k++){\n\t\t\t\t\tSegment edge(Point(obj[j].x,obj[k].y),Point(obj[k].x,obj[1-j].y));\n\t\t\t\t\tPoint v=perp_foot(course[l],Line(edge[0],edge[1]));\n\t\t\t\t\tif(dot(v-edge[0],v-edge[1])<EPS){\n\t\t\t\t\t\tdouble d2=norm2(v-course[l]);\n\t\t\t\t\t\td2min=min(d2min,d2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble r;\n\t\t\tif(h*h<d2min)\tr=(d2min+h*h)/(2*h);\n\t\t\telse\tr=sqrt(d2min);\n\t\t\trmin=min(rmin,r);\n\t\t}\n\n\t\tprintf(\"%f\\n\",rmin);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<complex>\n\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define min_int(a,b) ((a)<(b)?(a):(b))\n#define INF 10000000 //2^31\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\nusing namespace std;\n\nclass Gio{\nprivate:\n\ttypedef complex<double>point;\n\tstruct line{ \n\t\tpoint st, ed;//始点,終点\n\t};\n\tpoint min_p,max_p;\n\tline orig, test;\n\tdouble min_R;//保存用\n\tdouble test_R;//実行用\n\tdouble dot(point a, point b);//内積\n\tdouble cross(point a, point b);//外積\n\npublic:\n\tGio(double sx, double sy,double ex,double ey);\n\tvoid set_p(point* p, double x, double y);\n\tvoid set_line(line* l, point s, point e);\n\tvoid set_testline(double sx, double sy, double ex, double ey);\n\tvoid calc_r(double sx,double sy,double lx,double ly,double h);\n\tdouble get_r();\n\tdouble get_d_pp();//min_pとmax_pの距離を返す\n\tdouble get_d_lp();//min_pとtestの長さを返す\n\tdouble get_d_ll();//origとtestの長さを返す\n\tbool intersect();//origとtestが交差していればtrue\n};\n\nGio::Gio(double sx, double sy, double ex, double ey){\n\tset_p(&min_p, sx, sy);\n\tset_p(&max_p, ex, ey);\n\tset_line(&orig, min_p, max_p);\n\tmin_R = INF;\n}\nvoid Gio::set_p(point *p, double x, double y){\n\tpoint a(x, y);\n\t*p = a;\n}\nvoid Gio::set_line(line* l, point s, point e){\n\tl->st = s;\n\tl->ed=e;\n}\nvoid Gio::set_testline(double sx,double sy,double ex,double ey){\n\tpoint a, b;\n\tset_p(&a, sx, sy); set_p(&b, ex, ey);\n\tset_line(&test, a, b);\n\t//printf(\"%lf,%lf\\n\", test.st.real(), test.st.imag());\n}\ndouble Gio::dot(point a, point b){\n\treturn(a.real()*b.real() + a.imag()*b.imag());\n}\ndouble Gio::cross(point a, point b){\n\treturn(a.real()*b.imag() - a.imag()*b.real());\n}\ndouble Gio::get_d_pp(){ return(abs(max_p - min_p)); }\ndouble Gio::get_d_lp(){\n\tpoint a = test.st;\n\tpoint b = test.ed;\n\tpoint c = min_p;\n\tif (dot(b - a, c - a) < EPS)return(abs(c - a));\n\tif (dot(a - b, c - b) < EPS)return(abs(c - b));\n\treturn(abs(cross(b - a, c - a)) / abs(b - a));\n}\nbool Gio::intersect(){\n\tpoint a = orig.st, b = orig.ed, c = test.st, d = test.ed;\n\treturn((cross(b - a, c - a)*cross(b - a, d - a) < EPS) && (cross(d - c, a - c)*cross(d - c, b - c) < EPS));\n}\n\ndouble Gio::get_d_ll(){\n\tif (intersect())return(0);\n\tpoint a0, a1,b0,b1;\n\ta0 = orig.st;\n\ta1 = orig.ed;\n\tb0 = test.st;\n\tb1 = test.ed;\n\tdouble d1, d2, d3, d4;\n\tmin_p = a0; d1 = get_d_lp();\n\tmin_p = a1; d2 = get_d_lp();\n\tset_line(&test, a0, a1);\n\tmin_p = b0; d3 = get_d_lp();\n\tmin_p = b1; d4 = get_d_lp();\n\td1 = min_int(d1, d2);\n\td2 = min_int(d3, d4);\n\treturn(min_int(d1, d2));\n}\n\nvoid Gio::calc_r(double sx, double sy, double lx, double ly,double h){\n\tdouble d1, d2, d3, d4;\n\tpoint p = orig.st;\n\tif (sx <= p.real() && p.real() <= lx&&sy <= p.imag()&&p.imag() <= ly){\n\t\tmin_R = 0; return;\n\t}\n\n\tset_testline(sx, sy, sx, ly); d1 = get_d_ll();\n\tset_testline(sx, sy, lx, sy); d2 = get_d_ll();\n\tset_testline(sx, ly, lx, ly); d3 = get_d_ll();\n\tset_testline(lx, sy, lx, ly); d4 = get_d_ll();\n\td1 = min_int(min_int(d1, d2), min_int(d3, d4));\n\tif (h >= d1)test_R = d1;\n\telse{\n\t\ttest_R = ((d1*d1 + h*h) / h) / 2;\n\t}\n\tmin_R = min_int(min_R, test_R);\n}\ndouble Gio::get_r(){\n\treturn(min_R);\n}\n\nint b_num;\n\n\n\nint main(void){\n\t//Gio g(1, 1, 2, 2);\n\t//g.set_testline(1, 2, 2, 3);\n\t//cout << g.get_d_ll()<<endl;\n\twhile (true){\n\t\tcin >> b_num;\n\t\tif (b_num == 0)return(0);\n\t\tdouble sx, sy, ex, ey,h;\n\t\tcin >> sx >> sy>>ex >> ey;\n\t\tGio g(sx, sy, ex, ey);\n\t\trep(i, 0, b_num){\n\t\t\tcin >> sx >> sy >> ex >> ey>>h;\n\t\t\tg.calc_r(sx, sy, ex, ey, h);\n\t\t}\n\n\t\tprintf(\"%.10lf\\n\", g.get_r());\n\n\t}\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000.0\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\ndouble sx, sy, ex, ey;\ndouble mx[50], my[50], Mx[50], My[50], h[50];\n\ndouble f(double x, double y){\n\tdouble r = 0, l = 1, mr, ml;\n\trep(i,30){\n\t\tmr = (r*2+l)/3;\n\t\tml = (r+l*2)/3;\n\t\tif((sx+(ex-sx)*mr-x)*(sx+(ex-sx)*mr-x)+(sy+(ey-sy)*mr-y)*(sy+(ey-sy)*mr-y) < (sx+(ex-sx)*ml-x)*(sx+(ex-sx)*ml-x)+(sy+(ey-sy)*ml-y)*(sy+(ey-sy)*ml-y)){\n\t\t\tl = ml;\n\t\t} else r = mr;\n\t}\n\treturn (sx+(ex-sx)*r-x)*(sx+(ex-sx)*r-x)+(sy+(ey-sy)*r-y)*(sy+(ey-sy)*r-y);\n}\n\ndouble F(double x, double y, double z){\n\tdouble r = 0, l = 1, mr, ml;\n\trep(i,30){\n\t\tmr = (r*2+l)/3;\n\t\tml = (r+l*2)/3;\n\t\tif((sx+(ex-sx)*mr-x)*(sx+(ex-sx)*mr-x)+(sy+(ey-sy)*mr-y)*(sy+(ey-sy)*mr-y) < (sx+(ex-sx)*ml-x)*(sx+(ex-sx)*ml-x)+(sy+(ey-sy)*ml-y)*(sy+(ey-sy)*ml-y)){\n\t\t\tl = ml;\n\t\t} else r = mr;\n\t}\n\treturn sqrt((sx+(ex-sx)*r-x)*(sx+(ex-sx)*r-x)+(sy+(ey-sy)*r-y)*(sy+(ey-sy)*r-y)+z*z);\n}\n\ndouble fx(double x1, double x2, double y, double z){\n\tdouble r = x1, l = x2, mr, ml;\n\trep(i,30){\n\t\tmr = (r*2+l)/3;\n\t\tml = (r+l*2)/3;\n\t\tif(f(mr,y) < f(ml,y)){\n\t\t\tl = ml;\n\t\t} else r = mr;\n\t}\n\treturn F(r,y,z);\n}\n\ndouble fy(double x, double y1, double y2, double z){\n\tdouble r = y1, l = y2, mr, ml;\n\trep(i,30){\n\t\tmr = (r*2+l)/3;\n\t\tml = (r+l*2)/3;\n\t\tif(f(x,mr) < f(x,ml)){\n\t\t\tl = ml;\n\t\t} else r = mr;\n\t}\n\treturn F(x,r,z);\n}\n\nvoid solve(){\n\tcin >> sx >> sy >> ex >> ey;\n\trep(i,n) cin >> mx[i] >> my[i] >> Mx[i] >> My[i] >> h[i];\n\trep(i,n){\n\t\tif(mx[i]<=sx&&sx<=Mx[i]&&my[i]<=sy&&sy<=My[i]){\n\t\t\tputs(\"0.000\");\n\t\t\treturn;\n\t\t}\n\t\tif(mx[i]<=ex&&ex<=Mx[i]&&my[i]<=ey&&ey<=My[i]){\n\t\t\tputs(\"0.000\");\n\t\t\treturn;\n\t\t}\n\t}\n\tdouble s = 0.0, e = 10000.0, mid;\n\trep(u,30){\n\t\tmid = (s+e)/2;\n\t\tdouble dist = INF;\n\t\trep(i,n){\n\t\t\tdouble z = mid-h[i];\n\t\t\tif(z < 0) z = 0.0;\n\t\t\tdist = min(dist,fx(mx[i],Mx[i],my[i],z));\n\t\t\tdist = min(dist,fx(mx[i],Mx[i],My[i],z));\n\t\t\tdist = min(dist,fy(mx[i],my[i],My[i],z));\n\t\t\tdist = min(dist,fy(Mx[i],my[i],My[i],z));\n\t\t}\n\t\tif(dist < mid){\n\t\t\te = mid;\n\t\t} else s = mid;\n\t}\n\tprintf(\"%.9f\\n\",s);\n}\n\nint main(){\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-8, PI = acos(-1);\n \ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nnamespace Geometory { // Geometory Library\n  struct Point {\n    double x, y;\n    Point(){};\n    Point(double x,double y):x(x),y(y){};\n    Point operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n    Point operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n    Point operator*(const double b) const { return Point(x * b,y * b); }\n    Point operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n    Point operator/(const double b) const { return Point(x / b,y / b); }\n    bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y;}\n    bool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n    double norm(){ return x * x + y * y; }\n    double arg(){ return atan2(x,y); }\n    double abs(){ return sqrt(norm()); }\n    Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n    Point rotate90(){ return Point(-y,x); }\n    friend ostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\n    friend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n  };\n    \n  struct Line {\n    Point a, b;\n    Line(){};\n    Line(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Line& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Line& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Segment {\n    Point a, b;\n    Segment(){};\n    Segment(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Segment& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Segment& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Circle {\n    Point p; double r;\n    Circle(){};\n    Circle(Point p, double r) : p(p),r(r){};\n  };\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n    \n  double cross(const Point& a,const Point& b){\n    return a.x * b.y - a.y * b.x;\n  }\n  double dot(const Point& a,const Point& b){\n    return a.x * b.x + a.y * b.y;\n  }\n    \n  int ccw(const Point& a,Point b,Point c){\n    b = b - a, c = c - a;\n    if(cross(b,c) > EPS)    return +1;  // a ??? b ??§ ???????¨??????????????????? c\n    if(cross(b,c) < -EPS)    return -1; // a ??? b ??§ ????¨??????????????????? c\n    if(dot(b,c) < 0)      return +2;  // c -- a -- b??§?????´??????\n    if(b.norm() < c.norm()) return -2; // a -- b -- c??§?????´??????\n    return 0;  // a -- c -- b??§?????´??????\n  }\n  Point Projection(const Line& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Projection(const Segment& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Reflection(const Line& l, const Point& p){\n    return p + (Projection( l, p) - p) * 2.0;\n  }\n    \n  double Distance( const Line& l,const Point& p) { //OK\n    return (p - Projection( l, p)).abs();\n  }\n    \n  bool Intersect(const Line& l, const Line& m){\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;\n  }\n  bool Intersect(const Line& l, const Segment& s){\n    return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;\n  }\n  bool Intersect(const Line& l, const Point& p){\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n  bool Intersect(const Segment& s, const Segment& t){\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n  bool Intersect(const Segment& s, const Point& p){\n    return ccw(s.a, s.b, p) == 0;\n  }\n  bool Intersect(const Circle& c,const Line& l){\n    return Distance( l, c.p) <= c.r + EPS;\n  }\n  bool Intersect(const Circle& c,const Point& p){\n    return abs( ( p - c.p).abs() - c.r ) < EPS;\n  }\n  int Intersect(const Circle& c, const Segment& l){\n    if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();\n    if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if( d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n    const Point h = Projection( l, c.p);\n    if( dot( l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n  bool Intersect(const Circle& a,const Circle& b){\n    return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n      ( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n  }\n  double Distance(const Segment& s,const Point& p){\n    Point r = Projection(s, p);\n    if ( Intersect( s, r)) return ( r - p).abs();\n    return min( ( s.a - p).abs(), ( s.b - p).abs());\n  }\n  double Distance(const Segment& a,const Segment& b){\n    if(Intersect( a, b)) return 0;\n    return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));\n  }\n  double Distance(const Line& l,const Line& m) {\n    return Intersect( l, m) ? 0 : Distance( l, m.a);\n  }\n  double Distance(const Line& l,const Segment& s) { //OK\n    if (Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n  double Distance(const Point& a,const Point& b){ //OK\n    return ( a - b).abs();\n  }\n  Point Crosspoint(const Segment& l,const Segment& m) { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n  PointPoint Crosspoint(const Circle& c,const Line l){\n    Point hp = Projection( l, c.p), h =  hp - c.p;\n    const double d2 = h.norm();\n    Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n  PointPoint Crosspoint(const Circle& c,const Segment& l) {\n    Line aa = Line( l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n  PointPoint Crosspoint(const Circle& c1,const Circle& c2){ //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n    double h = 2 * S / d;\n    Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();\n    double m = sqrt( c1.r * c1.r - h * h);\n    return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);\n  }\n  bool parallel(const Line& a,const Line& b){\n    return abs(cross( a.b - a.a, b.b - b.a)) < EPS;\n  }\n  bool orthogonal(const Line& a,const Line& b){\n    return abs(dot( a.a - a.b, b.a - b.b)) < EPS;\n  }\n  int Contains(const Polygon& Q,const Point& p){\n    bool in = false;\n    for(int i = 0 ; i < Q.size() ; i++ ){\n      Point a = curr(Q,i) - p, b = next(Q,i) - p;\n      if(a.y > b.y) swap(a,b);\n      if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;\n      if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n  bool Contains(const Circle& c,const Point& p){\n    return ( c.p - p).abs() < c.r + EPS;\n  }\n  double Area2(const Polygon& p){ //OK\n    double A = 0;\n    for (int i = 0; i < p.size(); ++i){\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n  bool IsConvex(const Polygon& p){\n    for(int i = 0; i < p.size(); i++){\n      if(ccw(prev(p,i),curr(p,i),next(p,i)) == -1) return false;\n    }\n    return true;\n  }\n  Polygon Convex_Hull(Polygon& p){\n    int n = p.size(), k = 0;\n    if(n >= 3){\n      sort( p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]){\n        while(k >= 2 && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]){\n        while(k >= t && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize( k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n  double Convex_Diameter(Polygon& p){\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = ( p[is] - p[js]).norm();\n  \n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross( next( p, i) - curr( p, i), next( p, j) - curr( p, j)) >= 0){\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if(( p[i] - p[j]).norm() > maxdis){\n        maxdis = ( p[i] - p[j]).norm();\n        maxi = i; maxj = j;\n      }\n    }  while (i != is || j != js);\n    return maxdis;\n  }\n};\ntypedef Geometory::Point Point;\ntypedef Geometory::Line Line;\ntypedef Geometory::Segment Segment;\ntypedef Geometory::Circle Circle;\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    int sx, sy, tx, ty;\n    double ret = 1e9;\n    Segment data[4];\n\n    cin >> sx >> sy >> tx >> ty;\n    Segment Line = (Segment){Point(sx, sy), Point(tx, ty)};\n    while(N--) {\n      int minx, miny, maxx, maxy, h;\n      cin >> minx >> miny >> maxx >> maxy >> h;\n      data[0] = (Segment){(Point){minx, miny},(Point){maxx, miny}};\n      data[1] = (Segment){(Point){minx, maxy},(Point){minx, miny}};\n      data[2] = (Segment){(Point){maxx, maxy},(Point){minx, maxy}};\n      data[3] = (Segment){(Point){maxx, maxy},(Point){maxx, miny}};\n\n      if(minx <= min(sx, tx) && maxx >= max(sx, tx) && miny <= min(sy, ty) && maxy >= max(sy, ty)) {\n        ret = 0;\n      } else {\n        for(int i = 0; i < 4; i++) {\n          double d = Distance(Line, data[i]);\n          if(d <= h) ret = min(ret, d);\n          else ret = min(ret, (d * d + h * h) / (2.0 * h));\n        }\n      }\n    }\n    cout << fixed << setprecision(10) << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1e-8\n#define INF 1e8\n\ntypedef complex<double> Point;\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tPoint operator / (const Point &p, const double &a){\n\t\treturn Point(real(p)/a, imag(p)/a);\n\t}\n\tPoint operator * (const Point &p, const double &a){\n\t\treturn Point(real(p)*a, imag(p)*a);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn real(a) == real(b) && real(a) == real(b);\n\t}\n}\n\n\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point>{\n\tLine(){}\n\tLine(const Point &a, const Point &b){\n\t\tpush_back(a); push_back(b);\n\t}\n};\nstruct Circle{\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &c, double r):c(c),r(r){}\n};\n\ndouble dot(const Point &a, const Point &b){\n\treturn real(conj(a) * b);\n}\n\ndouble cross(const Point &a, const Point &b){\n\treturn imag(conj(a)*b);\n}\n\nPoint projection(const Line &l, const Point &p){\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t * (l[0]-l[1]);\n}\n\nint ccw(Point a, Point b, Point c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > 0) return +1;\n\tif(cross(b,c) < 0) return -1;\n\tif(dot(b,c) < 0) return +2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\ndouble distancePP(const Point &a, const Point &b){\n\treturn abs(a-b);\n}\n\nbool intersectSS(const Line &s, const Line &t){\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\t\t\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const Line &s, const Point &p){\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1]-s[0]) < EPS;\n}\n\ndouble distanceSP(const Line &s, const Point &p){\n\tconst Point r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r-p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\nbool intersectLL(const Line &l, const Line &m){\n\treturn abs(cross(l[1]-l[0], m[1]-m[0])) > EPS ||\n\t\t\t\t\tabs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n\nbool inPolygon(const Polygon &g, const Point &p){\n\tdouble sum = 0.0;\n\tint n = g.size();\n\tfor(int i = 0; i < g.size(); i++){\n\t\tint j = (i+1)%n;\n\t\tif(intersectSP(Line(g[i], g[j]), p)) return true;\n\t\tsum += arg((g[j]-p)/(g[i]-p));\n\t}\n\treturn abs(sum) > 1;\n}\n\nint main(void){\n\tint N;\n\twhile(cin >> N, N){\n\t\tint miss = 0;\n\t\tdouble sx, sy, ex, ey;\n\t\tvector<Point> ps(N, Point(INF,INF));\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tLine root = Line(Point(sx, sy), Point(ex, ey));\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tdouble ax, ay, bx, by, h;\n\t\t\tdouble d = INF;\n\t\t\tcin >> ax>>ay>>bx>>by>>h;\n\t\t\tPolygon g;\n\t\t\tg.push_back(Point(ax,ay));\n\t\t\tg.push_back(Point(bx,ay));\n\t\t\tg.push_back(Point(bx,by));\n\t\t\tg.push_back(Point(ax,by));\n\t\t\t//内部判定\n\t\t\tif(inPolygon(g, root[0]) || inPolygon(g, root[1])) miss = 1;\n\t\t\t//接触判定\n\t\t\tif(intersectSS(root, Line(Point(ax, ay), Point(bx, ay)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(bx, ay), Point(bx, by)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(bx, by), Point(ax, by)))) miss = 1;\n\t\t\tif(intersectSS(root, Line(Point(ax, by), Point(ax, ay)))) miss = 1;\n\t\t\tif(miss) continue;\n\t\t\t//最小距離\n\t\t\tfor(int j = 0; j < g.size(); j++){\n\t\t\t\td = min(d, distanceSP(root, g[j]));\n\t\t\t}\n\n\t\t\td = min(d, distanceSP(Line(Point(ax, ay), Point(bx, ay)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(ax, ay), Point(bx, ay)), root[1]));\n\n\t\t\td = min(d, distanceSP(Line(Point(bx, ay), Point(bx, by)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(bx, ay), Point(bx, by)), root[1]));\n\n\t\t\td = min(d, distanceSP(Line(Point(bx, by), Point(ax, by)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(bx, by), Point(ax, by)), root[1]));\n\n\t\t\td = min(d, distanceSP(Line(Point(ax, by), Point(ax, ay)), root[0]));\n\t\t\td = min(d, distanceSP(Line(Point(ax, by), Point(ax, ay)), root[1]));\n\t\t\tps[i] = Point(d, h);\n\t\t}\n\t\tif(miss){\n\t\t\tcout << \"0\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble left = 0, right = 10000;\n\t\tdouble ans = 0;\n\t\twhile(right - left > EPS){\n\t\t\tdouble mid = (left + right) / 2;\n\t\t\tdouble ret = INF;\n\t\t\tfor(int i = 0; i < ps.size(); i++){\n\t\t\t\tif(imag(ps[i]) <= mid){\n\t\t\t\t\tret = min(ret, distancePP(Point(0, mid), ps[i]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tret = min(ret, real(ps[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ret <= mid + EPS) right = mid;\n\t\t\telse{ ans = mid; left = mid;}\n//\t\t\tprintf(\"%.4lf -> ret:ans = [%.4lf : %.4lf]\\n\", mid, ret, ans);\n\t\t}\n\t\tprintf(\"%.9lf\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nvoid print(Point p);\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tprint(p1);\n\t\t\tprint(p2);\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p2;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n//\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tint x=ccw(s.p1,s.p2,pr);\n\tif(x==0) return d;\n//\tif(x>=-1&&x<=1) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t//\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\tif(ccw(q[0],q[1],r)==0){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t//\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\tif(ccw(p[0],p[1],r)==0){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p2;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n//\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tint x=ccw(s.p1,s.p2,pr);\n//\tif(x>=-1&&x<=1) return d;\n\tif(x==0) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t//\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\tif(ccw(q[0],q[1],r)==0){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t//\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\tif(ccw(p[0],p[1],r)==0){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nvoid print(Point p);\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tprint(p1);\n\t\t\tprint(p2);\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p2;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tif(x>=-1&&x<=1) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\nint n;\nint sx,sy,gx,gy;\nint xa[SIZE],ya[SIZE],xb[SIZE],yb[SIZE],h[SIZE];\n\ntypedef complex<double> P;\n\n//??????\ndouble dot(P a, P b) {\n  return (a * conj(b)).real();\n}\n\n//??????\ndouble cross(P a, P b) {\n  return (a * conj(b)).imag();\n}\n\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < 1e-8 ) return abs(c-a);\n  if ( dot(a-b, c-b) < 1e-8 ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n/* ?????????????????? */\nbool IntersectionSS(P p1,P p2, P p3, P p4){\n  long long a,b,c,d;\n    \n  //??????(x1,y1,x2,y2) ??¨ ??´???(x3,y3,x4,y4)\n  a=(long long)(p3.real()-p4.real())*(p1.imag()-p3.imag())+\n    (long long)(p3.imag()-p4.imag())*(p3.real()-p1.real());\n  b=(long long)(p3.real()-p4.real())*(p2.imag()-p3.imag())+\n    (long long)(p3.imag()-p4.imag())*(p3.real()-p2.real());\n\n  //??????(x3,y3,x4,y4) ??¨ ??´???(x1,y1,x2,y2)\n  c=(long long)(p1.real()-p2.real())*(p3.imag()-p1.imag())+\n    (long long)(p1.imag()-p2.imag())*(p1.real()-p3.real());\n  d=(long long)(p1.real()-p2.real())*(p4.imag()-p1.imag())+\n    (long long)(p1.imag()-p2.imag())*(p1.real()-p4.real());\n  \n  if((a<0)^(b<0) && (c<0)^(d<0))\n    return true;\n  else\n    return false;\n}\n\nbool check(double r){\n  \n  P l_s = P(sx,sy);\n  P l_g = P(gx,gy);\n  \n  for(int i=0;i<n;i++){\n    P p[4];\n    p[0] = P(xa[i],ya[i]);\n    p[1] = P(xa[i],yb[i]);\n    p[2] = P(xb[i],yb[i]);\n    p[3] = P(xb[i],ya[i]);\n    double H = min((double)h[i],r);\n    double R = sqrt(r*r - (r-H)*(r-H));\n\n    for(int j=0;j<4;j++){\n      double dis = distance_ls_p(l_s, l_g, p[j]);\n      bool is = IntersectionSS(l_s,l_g,p[j],p[(j+1)%4]);\n      bool in = (xa[i] <= sx && sx <= xb[i] && ya[i] <= sy && sy <= yb[i]) ||\n        (xa[i] <= gx && gx <= xb[i] && ya[i] <= gy && gy <= yb[i]);\n      \n      if(dis < R || is || in){\n        return false;\n      }\n    }\n  }\n  \n  for(int i=0;i<n;i++){\n    P p[4];\n    p[0] = P(xa[i],ya[i]);\n    p[1] = P(xa[i],yb[i]);\n    p[2] = P(xb[i],yb[i]);\n    p[3] = P(xb[i],ya[i]);\n    double H = min((double)h[i],r);\n    double R = sqrt(r*r - (r-H)*(r-H));\n\n    for(int j=0;j<4;j++){\n      double dis1 = distance_ls_p(p[j],p[(j+1)%4],l_s);\n      double dis2 = distance_ls_p(p[j],p[(j+1)%4],l_g);\n      \n      if(dis1 < R || dis2 < R){\n        return false;\n      }\n    }\n\n  }\n  \n  return true;\n}\n\nbool solve(){\n  \n  \n  scanf(\"%d\",&n);\n\n  if(n == 0) return false;\n\n  scanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d%d%d%d\",xa+i, ya+i, xb+i, yb+i, h+i);\n  }\n\n  double l=0, r=1000;\n\n  while(r-l > 1e-8){\n    double mid = (l+r)/2;\n\n    if(check(mid)){\n      l = mid;\n    }else{\n      r = mid;\n    }\n  }\n\n  printf(\"%.7lf\\n\",l);\n  \n  return true;\n}\n\nint main(){\n\n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\ndouble EPS=1e-10;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\n\nstruct Block{\n\tint minx;\n\tint maxx;\n\tint miny;\n\tint maxy;\n\tint h;\n\tBlock(){}\n\tBlock(int minx_,int miny_,int maxx_,int maxy_,int h_){\n\t\tminx=minx_;\n\t\tminy=miny_;\n\t\tmaxx=maxx_;\n\t\tmaxy=maxy_;\n\t\th=h_;\n\t}\n};\nint sy,sx,ey,ex;\nBlock blocks[101];\n\ntypedef complex<double> P;\n\ndouble dot(P a,P b){\n\treturn (a.real()*b.real()+a.imag()*b.imag());\n}\ndouble cross(P a,P b){\n\treturn (a.real()*b.imag()-a.imag()*b.real());\n}\n\nbool isInPolygon(vector<P> &points,P s){\n\tif(points.size()==1)return false;\n\tvector<P> v;\n\tfor(int i=0;i<points.size();i++)v.push_back(points[i]-s);\n\tint sign=0;\n\tfor(int i=1;i<=v.size();i++){\n\t\tint prv=(i-1+v.size())%v.size();\n\t\tint cur=i%v.size();\n\t\tdouble c=cross(v[prv],v[cur]);\n\t\tif(EQ(c,0))continue;\n\t\telse if(sign==0){\n\t\t\tif(c>0)sign=1;\n\t\t\telse sign=-1;\n\t\t}\n\t\telse{\n\t\t\tif(sign==-1&&c>0)return false;\n\t\t\telse if(sign==1&&c<0)return false;\n\t\t}\n\t}\n\treturn true;\n}\n// ツ静シツ閉ェツづ?点ツづ個仰猟猟」\ndouble distance_ls_p(P a,P b,P c){\n\tif(dot(b-a,c-a)<EPS)return abs(c-a);\n\tif(dot(a-b,c-b)<EPS)return abs(c-b);\n\treturn abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool isTouchingCircleAndRec(P cp,double r,int bid){\n\tvector<pair<P,P> > lines;\n\tvector<P> v;\n\tv.push_back(P(blocks[bid].minx,blocks[bid].miny));\n\tv.push_back(P(blocks[bid].minx,blocks[bid].maxy));\n\tv.push_back(P(blocks[bid].maxx,blocks[bid].maxy));\n\tv.push_back(P(blocks[bid].maxx,blocks[bid].miny));\n\tfor(int i=0;i<4;i++)\n\t\tlines.push_back(make_pair(v[i],v[(i+1)%4]));\n\t// 4dot\n\tfor(int i=0;i<4;i++){\n\t\tdouble dist=abs(v[i]-cp);\n\t\tif(!(EQ(dist,r)||dist>r))\n\t\t\treturn true;\n\t}\n\t// 4line\n\tfor(int i=0;i<lines.size();i++){\n\t\tdouble dist=distance_ls_p(lines[i].first,lines[i].second,cp);\n\t\tif(!(EQ(dist,r)||dist>r))\n\t\t\treturn true;\n\t}\n\t// inside \n\tif(isInPolygon(v,cp))return true;\n\treturn false;\n}\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n\tif(abs(cross(a2-a1,b2-b1))<EPS)return 0;\n\treturn (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<EPS)\n\t\t&&(cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<EPS);\n}\nstruct Rec{\n\tvector<P> p;\n};\nbool isTouchRectangle(Rec &a,Rec &b){\n\tfor(int i=0;i<4;i++)if(isInPolygon(b.p,a.p[i]))return true;\n\tfor(int i=0;i<4;i++)if(isInPolygon(a.p,b.p[i]))return true;\n\tfor(int i=0;i<4;i++){\n\t\tint curi=i;\n\t\tint prvi=(i+3)%4;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint curj=j;\n\t\t\tint prvj=(j+3)%4;\n\t\t\tif(is_intersected_ls(a.p[curi],a.p[prvi],b.p[curj],b.p[prvj]))return true;\n\t\t}\n\t}\n\treturn false;\n}\nP roundPoint(P p,double a){\n\treturn P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\nconst double PI=acos(-1.0);\nint N;\n\nbool check(double R){\n\t//R=29;\n\tfor(int i=0;i<N;i++){\n\t\tdouble d=sqrt(R*R-(R-blocks[i].h)*(R-blocks[i].h));\n\t\tif(R<=blocks[i].h)d=R;\n\t\tif(isTouchingCircleAndRec(P(sx,sy),d,i))\n\t\t\treturn false;\n\t\tif(isTouchingCircleAndRec(P(ex,ey),d,i))\n\t\t\treturn false;\n\t\tvector<P> v;\n\t\tint bid=i;\n\t\tv.push_back(P(blocks[bid].minx,blocks[bid].miny));\n\t\tv.push_back(P(blocks[bid].minx,blocks[bid].maxy));\n\t\tv.push_back(P(blocks[bid].maxx,blocks[bid].maxy));\n\t\tv.push_back(P(blocks[bid].maxx,blocks[bid].miny));\n\t\tP e1=P(sx,sy)-P(ex,ey);e1/=abs(e1);e1*=d;\n\t\tP e2=P(ex,ey)-P(sx,sy);e2/=abs(e2);e2*=d;\n\t\tvector<P> v2;\n\t\tP a1=roundPoint(e1,PI/2)+P(sx,sy);\n\t\tP a2=roundPoint(e2,3*PI/2)+P(ex,ey);\n\t\tv2.push_back(a1);v2.push_back(a2);\n\t\tP a3=roundPoint(e1,3*PI/2)+P(sx,sy);\n\t\tP a4=roundPoint(e2,PI/2)+P(ex,ey);\n\t\tv2.push_back(a4);v2.push_back(a3);\n\t\tRec r1;r1.p=v;\n\t\tRec r2;r2.p=v2;\n\t\tif(isTouchRectangle(r1,r2))return false;\n\t}\n\treturn true;\n}\n\nvoid solve(){\n\twhile(cin>>N&&N){\n\t\tcin>>sx>>sy>>ex>>ey;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tint minx,miny,maxx,maxy,h;\n\t\t\tcin>>minx>>miny>>maxx>>maxy>>h;\n\t\t\tblocks[i]=Block(minx,miny,maxx,maxy,h);\n\t\t}\n\t\tdouble ub=1000000000;\n\t\tdouble lb=0;\n\t\tfor(int i=0;i<200;i++){\n\t\t\tdouble mid=(ub+lb)/2;\n\t\t\tif(check(mid))lb=mid;\n\t\t\telse ub=mid;\n\t\t}\n\t\tif(EQ(ub,0))cout<<0<<endl;\n\t\telse\n\t\t\tprintf(\"%.10f\\n\",ub);\n\t}\n}\n\nint main(){\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//二次元幾何ライブラリ\n#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define ML make_pair \ntypedef long double D;\ntypedef bool B;\ntypedef complex<D> P;   //点\ntypedef complex<D> V;   //ベクトル\ntypedef pair<P,P>  L;   //直線\ntypedef pair<P,D>  C;   //円\ntypedef vector<P>  Pol; //多角形\n\n//変数名定義\nconst D INF = 1e100;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ntemplate<class T> bool operator==(T a, T b){return abs(a - b )< EPS;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n\n\n\n// ベクトルaの絶対値を求める\n// D Length = abs(a);\n\n// 2点a,b間の距離を求める\n// D Distance = abs(a-b); \n\n// 内積 (Inner Product) : a・b = |a||b|cosθ\nD IP(V a, V b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (Exterior Product) : |a×b| = |a||b|sinθ \nD EP(V a, V b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n// 点の進行方向について\nint ccw(P a, P b, P c) {              //点aと点bが与えられた問いに\n  b -= a; c -= a;\n  if (EP(b, c) > 0)   return +1;      // counter clockwise\n  if (EP(b, c) < 0)   return -1;      // clockwise\n  if (IP(b, c) < 0)     return +2;    // c--a--b on line\n  if (norm(b) < norm(c)) return -2;   // a--b--c on line\n  return 0;                           // a--c--b on line  aとbの線分判定はこれ\n}\n\n\n// 2直線の垂直判定 : a⊥b <=> IP(a, b) = 0\nB IsVecular(L l1, L l2) {\n\treturn IP(l1.first-l1.second, l2.first-l2.second)==0.0;\n}\n\n// 2直線の平行判定 : a//b <=> EP(a, b) = 0\nB IsParallel(L l1, L l2) {\n\treturn EP(l1.first-l1.second, l2.first-l2.second)== 0.0;\n}\n\n// 2線分の交差判定 \nB IIS(L l1, L l2) {\n  return ( EP(l1.second-l1.first, l2.first-l1.first) * EP(l1.second-l1.first, l2.second-l1.first) < EPS ) &&\n         ( EP(l2.second-l2.first, l1.first-l2.first) * EP(l2.second-l2.first, l1.second-l2.first) < EPS );\n}\n\n// 符号付き点と直線の距離 (Distance of Point and Line)  //lの構造 x座標 first<second y座標 first<second 左上 正 右下 負 一致 0\nD  DPL(P p,L l){\n\tV v1=(l.second-l.first);\n\tV v2=(p-l.first);\n\treturn EP(v1,v2)/abs(v1);\n}\n\n// 点と線分の距離 (Distance of Point and Segment)  //lの構造 x座標 first<second y座標 first < second \nD  DPS(P p,L l){\n\tV v1,v2,v3;\n\tv1=l.second-l.first;\n\tv2=p-l.first;\n\tv3=p-l.second;\n\tif(IP (v1,v2) <0)\n\t\treturn abs(p-l.first);\n\telse if(IP(-v1,v3)<0)\n\t\treturn abs(p-l.second);\n\telse\n\t\treturn abs(DPL(p,l));\n}\n\n// 線分と線分の距離 (Distance of Segment and Segment)  //lの構造 x座標 first<second y座標 first < second \nD DSS(L l1,L l2){\n\tif(IIS(l1,l2))\n\t\treturn 0;\n\telse{\n\t\tD tem,tem1,tem2;\n\t\ttem1=min(DPS(l1.first,l2),DPS(l1.second,l2));\n\t\ttem2=min(DPS(l2.first,l1),DPS(l2.second,l1));\n\t\treturn\tmin(tem1,tem2);\n\t}\n}\n\n// 三角形の領域判定 Teritory of Triangle 1が内部 0が境界と外部\nB TT(P p1,P p2,P p3,P p){\n\tL l1,l2,l3;\n\tl1=make_pair(p2,p3);\n\tl2=make_pair(p3,p1);\n\tl3=make_pair(p1,p2);\n\n\tif(sig(DPL(p1,l1))!=sig(DPL(p,l1)))\n\t\treturn false;\n\telse if(sig(DPL(p2,l2))!=sig(DPL(p,l2)))\n\t\treturn false;\n\telse if(sig(DPL(p3,l3))!=sig(DPL(p,l3)))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n//変数名 = 型 代入したいもの\n//example : v1 = V(5.0,-3.0) p1=P(0.0,4.0)\nint main(void){\n\twhile(true){\n\tint N;\n\t\tcin >>N; \n\tif(!N)\n\t\tbreak;\n\tD Block[50][2][2];\n\tD h[50];\n\tP root1,root2;\n\tL root;\n\tD r;\n\tD rmin=INF;\n\t\tcin >> root1.real() >> root1.imag() >> root2.real() >> root2.imag();\n\trep(i,N)\n\t\tcin >>Block[i][0][0] >>Block[i][0][1] >> Block[i][1][0] >> Block[i][1][1] >>h[i] ;\n\troot=ML(root1,root2);\n\trep(i,N){\n\t\t\tD tem,tem1,tem2;\n\t\t\tP p1,p2,p3,p4;\n\t\t\tp1=P(Block[i][0][0],Block[i][0][1]);\n\t\t\tp2=P(Block[i][1][0],Block[i][0][1]);\n\t\t\tp3=P(Block[i][1][0],Block[i][1][1]);\n\t\t\tp4=P(Block[i][0][0],Block[i][1][1]);\n\t\t\tL la,lb,lc,ld;\n\t\t\tla=ML(p1,p2);\n\t\t\tlb=ML(p2,p3);\n\t\t\tlc=ML(p3,p4);\n\t\t\tld=ML(p4,p1);\n\t\t\tif(p1.real()<root1.real()&&root1.real()<p3.real()&&p1.imag()<root1.imag()&&root1.imag()<p3.imag())\n\t\t\t\ttem=0;\n\t\t\telse {\n\t\t\t\ttem1=min(DSS(root,la),DSS(root,lb));\n\t\t\t\ttem2=min(DSS(root,lc),DSS(root,ld));\n\t\t\t\ttem=min(tem1,tem2);\n\t\t\t}\n\t\t\tif(tem<=h[i])\n\t\t\t\tr=tem;\n\t\t\telse\n\t\t\t\tr=(h[i]+tem*tem/h[i])/2.0;\n\t\t\tif(rmin > r)\n\t\t\t\trmin=r;\n\t}\n    cout << fixed << rmin << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nvector<Polygon>polys;\nvector<int>hs;\nvector<long double>diss;\n\n\nbool check(const long double rad) {\n\tfor (int i = 0; i < hs.size(); ++i) {\n\t\tif (hs[i] > rad) {\n\t\t\tif (diss[i] < rad)return false;\n\t\t}\n\t\telse {\n\t\t\tlong double needdis = sqrt(rad*rad - (rad - hs[i])*(rad - hs[i]));\n\t\t\tif (diss[i] < needdis)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tcout << fixed << setprecision(22);\n\twhile (1) {\n\t\tint N;\n\t\tcin >> N;\n\t\tif (!N)break;\n\t\tint  sx, sy, gx, gy; cin >>  sx >> sy >> gx >> gy;\n\t\tPoint sp(sx, sy);\n\t\tPoint gp(gx, gy);\n\t\tLine course(sp, gp);\n\t\tpolys.clear();\n\t\ths.clear();\n\t\tdiss.clear();\n\t\tpolys.resize(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint l, u, r, d, h; cin >> l >> u >> r >> d >> h;\n\t\t\tPoint pos[4];\n\t\t\tpos[0] = Point(l, u);\n\t\t\tpos[1] = Point(l, d);\n\t\t\tpos[2] = Point(r, d);\n\t\t\tpos[3] = Point(r, u);\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tpolys[i].emplace_back(pos[j]);\n\t\t\t}\n\t\t\ths.push_back(h);\n\n\t\t\tlong double amindis = 1e9;\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tLine l(polys[i][j], polys[i][(j + 1) % 4]);\n\t\t\t\tamindis = min(amindis, dist_ss(course, l));\n\t\t\t}\n\t\t\tdiss.push_back(amindis);\n\t\t}\n\t\tbool ok=true;\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tLine l(polys[i][j], polys[i][(j + 1) % 4]);\n\t\t\t\tif (isis_ss(course, l)) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (is_in_polygon(polys[i], sp)) {\n\t\t\t\tok = false; break;\n\t\t\t}\n\t\t\tif (is_in_polygon(polys[i], gp)) {\n\t\t\t\tok = false; break;\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\tlong double amin = 0;\n\t\t\tlong double amax = 1e4;\n\t\t\twhile (amin + 1e-9 < amax) {\n\t\t\t\tlong double amid((amin + amax) / 2);\n\t\t\t\tif (check(amid)) {\n\t\t\t\t\tamin = amid;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << amin << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n#define F first\n#define S second\ntypedef pair<L,D>PP;\nint main(){\n  int n;\n  D a1,a2,a3,a4,a5;\n  while(cin>>n,n){\n    L st;\n    D ans=1e15;\n    vector<PP>v;\n    cin>>a1>>a2>>a3>>a4;\n    st=L(P(a1,a2),P(a3,a4));\n    rep(i,n){\n      cin>>a1>>a2>>a3>>a4>>a5;\n      v.push_back(PP(L(P(a1,a4),P(a3,a4)),a5));\n      v.push_back(PP(L(P(a1,a2),P(a3,a2)),a5));\n      v.push_back(PP(L(P(a3,a2),P(a3,a4)),a5));\n      v.push_back(PP(L(P(a1,a2),P(a1,a4)),a5));\n      if(ccw(P(a1,a2),P(a1,a4),st.F)==ccw(P(a1,a4),P(a3,a4),st.F)&&ccw(P(a3,a4),P(a3,a2),st.F)==ccw(P(a3,a2),P(a1,a2),st.F)&&ccw(P(a1,a4),P(a3,a4),st.F)==ccw(P(a3,a4),P(a3,a2),st.F))ans=0;\n      if(ccw(P(a1,a2),P(a1,a4),st.S)==ccw(P(a1,a4),P(a3,a4),st.S)&&ccw(P(a3,a4),P(a3,a2),st.S)==ccw(P(a3,a2),P(a1,a2),st.S)&&ccw(P(a1,a4),P(a3,a4),st.S)==ccw(P(a3,a4),P(a3,a2),st.S))ans=0;\n    }\n    rep(i,v.size()){\n      D dist=distSS(v[i].F.F,v[i].F.S,st.F,st.S);\n      if(dist<=v[i].S)ans=min(ans,dist);\n      else ans=min(ans,(dist*dist+v[i].S*v[i].S)/(2*v[i].S));\n    }\n    printf(\"%.9f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                     #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                  \n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                             double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \nbool parareru(Point a,Point b,Point c,Point d){\n//\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n\treturn abs(cross(a-b,d-c))<EPS;\n}\ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n  return abs(cross(b-a, c-a)) / (b-a).absv();\n}\nbool is_intersected_ls(Segment a,Segment b) {\n\tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n//\t\tcout<<\"sss\"<<endl;\n\t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n\t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n\t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n\t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n\t\treturn false;\n\t}\n  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n}\n\ndouble segment_dis(Segment a,Segment b){\n\tif(is_intersected_ls(a,b))return 0;\n\tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n\tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n\treturn r;\n}\n\n\n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\n\n\nSegment p[210],path;\nPoint pp[210];\nint n;\ndouble h[210];\nbool ch(double r){\n\t\n\tfor(int i=0;i<4*n;i++){\n\t\tdouble t=segment_dis(p[i],path);\n\t\tif(t>=r) continue;\n\t\tif(r-sqrt(r*r-t*t)<=h[i/4])return false;\n\t}\n\treturn true;\n\t\n}\n\n\nsigned main(){\n\n\tint cnt=0;\n\twhile(1){\n\t\t\n\t\tcin>>n;\n\t\tif(n==0) return 0;\n//cout<<cnt<<\" \"<<n<<endl;\n\t\t\n\t\tcnt++;\n\t\tcin>>path.p1.x>>path.p1.y>>path.p2.x>>path.p2.y;\n\t\tbool b=false;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble ax,ay,bx,by;\n\t\t\tcin>>ax>>ay>>bx>>by;\n\t\t\tif(ax <= path.p1.x &&path.p1.x<=bx &&ay <= path.p1.y &&path.p1.y<=by){\n\t\t\t\tif(ax <= path.p2.x &&path.p2.x<=bx &&ay <= path.p2.y &&path.p2.y<=by){\n\t\t\t\t\tb=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpp[i*4].x=ax;\n\t\t\tpp[i*4].y=ay;\n\t\t\tpp[1+i*4].x=ax;\n\t\t\tpp[1+i*4].y=by;\n\t\t\tpp[2+i*4].x=bx;\n\t\t\tpp[2+i*4].y=by;\n\t\t\tpp[3+i*4].x=bx;\n\t\t\tpp[3+i*4].y=ay;\n\t\t\t\n\t\t\tp[i*4].p1=pp[i*4];\n\t\t\tp[i*4].p2=pp[1+i*4];\n\t\t\tp[1+i*4].p1=pp[1+i*4];\n\t\t\tp[1+i*4].p2=pp[2+i*4];\n\t\t\tp[2+i*4].p1=pp[2+i*4];\n\t\t\tp[2+i*4].p2=pp[3+i*4];\n\t\t\tp[3+i*4].p1=pp[3+i*4];\n\t\t\tp[3+i*4].p2=pp[i*4];\ncin>>h[i];\n\t\t}\n\t//\tfor(int i=0;i<4*n;i++)cout<<i<<\" \"<<segment_dis(p[i],path)<<endl;\n\t\tif(b==1){\n\t\t\tcout<<0<<endl;\n\t\t\t\n\t\t}\n\t\telse{\n\t\tdouble ue=1000.0,sita=0.0,me;\n\t\tfor(int i=0;i<1000;i++){\n\t\t\tme=(ue+sita)/2.0;\n\t\t\tif(ch(me))sita=me;\n\t\t\telse ue=me;\n\t\t}\n\t\tprintf(\"%.10lf\\n\",me);\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing CP = complex<long double>;\n#define X real()\n#define Y imag()\nconst long double PI = acos(-1);\nconst long double EPS = 1e-10;\n// conj(x) : complex conjugate,(0,1)->(0,-1)\n// abs(x) : dist between(0,0) and x\n// norm(x) : abs(x) * abs(x)\n// arg(x) : argment\nlong double dot(CP a, CP b) { return (a * conj(b)).X; }\nlong double cross(CP a, CP b) { return (a * conj(b)).Y; }\nlong double corner(CP a, CP b) {\n  //[0,pi]\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nCP intersection(CP a, CP b, CP c, CP d) {\n  return a + (b - a) * (cross(d - c, c - a) /\n                        cross(d - c, b - a));\n}\n\nbool on_seg(CP a, CP b, CP p) {\n  // if not use end point, dot(a - p, b - p) < 0\n  return abs(cross(a - p, b - p)) <= 1e-10 &&\n         dot(a - p, b - p) <= 0;\n}\n\n// crossing lines? (a,b) and (c,d)\nbool iscross(CP a, CP b, CP c, CP d) {\n  // parallel\n  if(abs(cross(a - b, c - d)) <= 1e-10) {\n    return on_seg(a, b, c) || on_seg(a, b, d) ||\n           on_seg(c, d, a) || on_seg(c, d, b);\n  }\n  CP isp = intersection(a, b, c, d);\n  return on_seg(a, b, isp) && on_seg(c, d, isp);\n}\n\nlong double distLP(CP a, CP b, CP p) {\n  return abs(cross(b - a, p - a) / abs(b - a));\n}\n\n// segmentver.\nlong double distSP(CP a, CP b, CP p) {\n  if(dot(b - a, p - a) < 0) return abs(p - a);\n  if(dot(a - b, p - b) < 0) return abs(p - b);\n  return distLP(a, b, p);\n}\n\nlong double distSS(CP a, CP b, CP c, CP d) {\n  long double res = 1e18;\n  res = min(res, distSP(a, b, c));\n  res = min(res, distSP(a, b, d));\n  res = min(res, distSP(c, d, a));\n  res = min(res, distSP(c, d, b));\n  return res;\n}\n\nlong long n;\nlong double res = 1e18;\nCP s, t;\n\nint main() {\n  cout << fixed << setprecision(10);\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    long double a, b, c, d, h, dist;\n    cin >> a >> b >> c >> d;\n    s = CP(a, b);\n    t = CP(c, d);\n    res = 1e18;\n    for(int i = 0; i < n; ++i) {\n      cin >> a >> b >> c >> d >> h;\n      if(iscross(s, t, CP(a, b), CP(c, d)) ||\n         iscross(s, t, CP(a, d), CP(c, b)))\n        res = 0;\n      dist = 1e18;\n      dist = min(dist, distSS(s, t, CP(a, b), CP(c, b)));\n      dist = min(dist, distSS(s, t, CP(a, b), CP(a, d)));\n      dist = min(dist, distSS(s, t, CP(c, b), CP(c, d)));\n      dist = min(dist, distSS(s, t, CP(a, d), CP(c, d)));\n      if(dist <= h)\n        res = min(res, dist);\n      else\n        res = min(res, (h * h + dist * dist) / (2 * h));\n    }\n\n    cout << res << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef complex<double> P;\n\nint N;\ndouble sx,sy,ex,ey,mx,my,Mx,My,h;\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint insected(P a1, P a2, P b1, P b2) {\n\tif(fabs(cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1))<EPS){\n\treturn dot(b1-a1,b1-a2)*dot(b2-a1,b2-a2)<EPS;\n\t}\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\ndouble dist(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return\n\tabs(cross(b-a, c-a)) / abs(b-a);\n}\n\nint main(){\n\t/*FILE *out1157;         // oÍXg[\n  out1157 = fopen(\"out1157\", \"w\");  // t@Cð«ÝpÉI[v(J­)\n  if (out1157 == NULL) {          // I[vÉ¸sµ½ê\n    printf(\"cannot open\\n\");         // G[bZ[WðoµÄ\n    exit(1);                         // ÙíI¹\n  }int cn=0;*/\n\twhile(cin>>N&&N){\n\t\t//cn++;\n\t\tcin>>sx>>sy>>ex>>ey;//cout<<cn<<endl;if(cn==59)cout<<sx<<\" \"<<sy<<\" \"<<ex<<\" \"<<ey<<endl;\n\t\tP s(sx,sy),e(ex,ey);\n\t\tdouble ans=1e9;\n\t\trep(i,N){\n\t\t\tcin>>mx>>my>>Mx>>My>>h;\n\t\t\tP a(mx,my),b(Mx,my),c(Mx,My),d(mx,My);\n\t\t\tif(mx<=min(sx,ex)&&Mx>=max(sx,ex)&&my<=min(sy,ey)&&My>=max(sy,ey)){ans=0;/*cout<<\"tutumu ans=0\"<<endl;*/}\n\t\t\telse if(insected(s,e,a,b)||insected(s,e,b,c)||insected(s,e,c,d)||insected(s,e,d,a)){ans=0;/*cout<<\"majiwaru ans=0\"<<\" \"<<insected(s,e,a,b)<<\" \"<<insected(s,e,b,c)<<\" \"<<insected(s,e,c,d)<<\" \"<<insected(s,e,d,a)<<endl;*/}\n\t\t\telse{\n\t\t\t\tdouble D=1e9;\n\t\t\t\tif(Mx<=min(sx,ex)){\n\t\t\t\t\tif(my<=sy&&sy<=My)D=min(D,sx-Mx);\n\t\t\t\t\tif(my<=ey&&ey<=My)D=min(D,ex-Mx);\n\t\t\t\t}\n\t\t\t\tif(mx>=max(sx,ex)){\n\t\t\t\t\tif(my<=sy&&sy<=My)D=min(D,mx-sx);\n\t\t\t\t\tif(my<=ey&&ey<=My)D=min(D,mx-ex);\n\t\t\t\t}\n\t\t\t\tif(My<=min(sy,ey)){\n\t\t\t\t\tif(mx<=sx&&sx<=Mx)D=min(D,sy-My);\n\t\t\t\t\tif(mx<=ex&&ex<=Mx)D=min(D,ey-My);\n\t\t\t\t}\n\t\t\t\tif(my>=max(sy,ey)){\n\t\t\t\t\tif(mx<=sx&&sx<=Mx)D=min(D,my-sy);\n\t\t\t\t\tif(mx<=ex&&ex<=Mx)D=min(D,my-ey);\n\t\t\t\t}\n\t\t\t\tD=min(D,min(dist(s,e,a),min(dist(s,e,b),min(dist(s,e,c),dist(s,e,d)))));\n\t\t\t\tif(h>D){ans=min(ans,D);/*cout<<D<<endl;*/}\n\t\t\t\telse {/*cout<<\"MIN\"<<ans<<\" \";*/ans=min(ans,(D*D+h*h)/2/h);/*cout<<(D*D+h*h)/2/h<<endl;*/}\n\t\t\t\t//cout<<\"ans\"<<ans<<endl;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4f\\n\",ans);\n\t}\n\t//fclose(out1157);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\n//// definition of point\n#define x(p) real(p)\n#define y(p) imag(p)\n\nconst double eps=1e-10;\nconst double inf=1e12;\nconst double PI=acos(-1);\ntypedef complex<double> P;\n\nnamespace std{\n  bool operator<(const P& a,const P& b){\n    return x(a)==x(b)?y(a)<y(b):x(a)<x(b);\n  }\n}\ndouble cross(const P& a,const P& b){\n  return y(conj(a)*b);\n}\ndouble dot(const P& a,const P& b){\n  return x(conj(a)*b);\n}\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\n//// counter-clockwise\nint ccw(P a,P b,P c) {\n  b=b-a;c=c-a;\n  if(cross(b,c)>0) return +1;       // counter clockwise\n  if(cross(b,c)<0) return -1;       // clockwise\n  if(dot(b,c)<0)   return +2;       // c--a--b on line\n  if(norm(b)<norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//// intersect\nbool intersectLL(const L& l,const L& m){\n  return abs(cross(l[1]-l[0],m[1]-m[0]))>eps||abs(cross(l[1]-l[0],m[0]-l[0]))<eps;\n}\nbool intersectLS(const L& l,const L& s){\n  return cross(l[1]-l[0],s[0]-l[0])*cross(l[1]-l[0],s[1]-l[0])<eps;\n}\nbool intersectLP(const L& l,const P& p){\n  return abs(cross(l[1]-p,l[0]-p))<eps;\n}\nbool intersectSS(const L& s,const L& t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0&&ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\nbool intersectSP(const L& s,const P& p){\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0])<eps;\n}\n\n//// move point\nP projection(const L& l,const P& p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*x(c/b);\n}\nP reflection(const L& l,const P& p) {\n  return p+2.0*(projection(l,p)-p);\n}\nP rotation(const P& a,double r){\n  return P(x(a)*cos(r)-y(a)*sin(r),x(a)*sin(r)+y(a)*cos(r));\n}\n\n//// distance\ndouble distanceLP(const L& l,const P& p) {\n  return abs(p-projection(l,p));\n}\ndouble distanceLL(const L& l,const L& m) {\n  return intersectLL(l,m)?0:distanceLP(l,m[0]);\n}\ndouble distanceLS(const L& l,const L& s) {\n  return intersectLS(l,s)?0:min(distanceLP(l,s[0]),distanceLP(l,s[1]));\n}\ndouble distanceSP(const L& s,const P& p) {\n  const P r=projection(s,p);\n  return intersectSP(s,r)?abs(r-p):min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble distanceSS(const L& s,const L& t) {\n  return intersectSS(s,t)?0:min(min(distanceSP(s,t[0]),distanceSP(s,t[1])),\n                                min(distanceSP(t,s[0]),distanceSP(t,s[1])));\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0)break;\n    double x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    L route(P(x1,y1),P(x2,y2));\n    double res=inf;\n    bool ok=true;\n    rep(i,n){\n      double h;\n      cin>>x1>>y1>>x2>>y2>>h;\n      P p1(x1,y1),p2(x1,y2),p3(x2,y2),p4(x2,y1);\n      double dist=inf;\n      if(intersectSS(route,L(p1,p2))||intersectSS(route,L(p2,p3))||intersectSS(route,L(p3,p4))||intersectSS(route,L(p4,p1))\n        ||(x1<=x(route[0])&&x(route[0])<=x2&&y1<=y(route[0])&&y(route[0])<=y2))ok=false;\n      minch(dist,distanceSS(route,L(p1,p2)));\n      minch(dist,distanceSS(route,L(p2,p3)));\n      minch(dist,distanceSS(route,L(p3,p4)));\n      minch(dist,distanceSS(route,L(p4,p1)));\n      double ns;\n      if(h>dist+eps){\n        ns=dist;\n      }else{\n        ns=(h*h+dist*dist)/(2.0*h);\n      }\n      minch(res,ns);\n    }\n    if(!ok) printf(\"%.10f\\n\",0.0);\n    else printf(\"%.10f\\n\", res);\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\nstatic const double pi = 3.141592653589793;\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-6;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n\nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // 線分上に存在\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n\nD distSB(P p0, P p1, P pb1, P pb2, P pb3, P pb4) {//線分と長方形の距離うちがわに入ると0\n\tif(inConvex(p0, {pb1, pb2, pb3, pb4}) > 0 or inConvex(p1, {pb1, pb2, pb3, pb4}) > 0) return 0;\n\tD d = 1e30;\n\td = min(d, distSS(p0, p1, pb1, pb2));\n\td = min(d, distSS(p0, p1, pb2, pb3));\n\td = min(d, distSS(p0, p1, pb3, pb4));\n\td = min(d, distSS(p0, p1, pb4, pb1));\n\treturn d;\n}\n\nint main() {\n\t\n\t/*ifstream in(\"Ain.txt\");\n\tcin.rdbuf(in.rdbuf());\n\tofstream ofs(\"Aout.txt\");\n\tcout.rdbuf(ofs.rdbuf());\n\t*/\n\tcout << setprecision(20);\n\tint N;\n\tdouble sx,sy,ex,ey,x1,x2,y1,y2,h,r;\n\twhile(cin >> N, N) {\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tD ans = 1e30;\n\t\tP p0 = P(sx, sy);\n\t\tP p1 = P(ex, ey);\n\t\trep(n, N) {\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> h;\n\t\t\tP pb1 = P(x1, y1);\n\t\t\tP pb2 = P(x1, y2);\n\t\t\tP pb3 = P(x2, y2);\n\t\t\tP pb4 = P(x2, y1);\n\t\t\tD d = distSB(p0, p1, pb1, pb2, pb3, pb4);\n\t\t\tif (d <= h) {\n\t\t\t\tr = d;\n\t\t\t} else {\n\t\t\t\tr = (h * h + d * d) / (2 * h);\n\t\t\t}\n\t\t\tans = min(ans, r);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <cfloat>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1e-9 //許容される誤差の程度\n\ntypedef complex<double> point;\ntypedef vector<point> polygon;\ntypedef pair<point, point> seg;\n\ndouble dot(point va, point vb){\n\treturn real(va) * real(vb) + imag(va) * imag(vb);\n}\n\ndouble cross(point va, point vb){\n\treturn real(va) * imag(vb) - imag(va) * real(vb);\n}\n\n//直線と点の距離\ndouble distance_l_p(point a, point b, point c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n//線分と点の距離\ndouble distance_ls_p(point a, point b, point c){\n\tif( dot(b - a, c - a) <= 0.0 ) return abs(c - a);\n\tif( dot(a - b, c - b) <= 0.0 ) return abs(c - b);\n\treturn distance_l_p(a, b, c);\n}\n\n//多角形と点の内包判定。\n//AOJ 0143などで使用。\nbool contains(polygon plg, point pt){\n\tint cnt = 0;\n\tdouble y = imag(pt);\n\n\tfor(int i = 0; i < plg.size(); ++i){\n\t\tint j = (i + 1 == plg.size() ? 0: i + 1);\n\n\t\tif( distance_ls_p(plg[i], plg[j], pt) <= EPS ){\n\t\t\treturn true;\n\t\t}\n\n\t\tdouble dyi = imag(plg[i]) - y;\n\t\tdouble dyj = y - imag(plg[j]);\n\t\tdouble tx = (dyi * real(plg[j]) + dyj * real(plg[i])) / (dyi + dyj);\n\n\t\tif(imag(plg[i]) >= y && imag(plg[j]) < y){\n\t\t\tif( tx < real(pt) ) ++cnt;\n\t\t}\n\t\telse if(imag(plg[i]) < y && imag(plg[j]) >= y){\n\t\t\tif( tx < real(pt) ) ++cnt;\n\t\t}\n\t}\n\t\n\treturn (cnt % 2 != 0);\n}\n\n//線分同士の交点判定。\n//交点による線分1の内分比を返す。\n//交点は (1.0-t)*pa1 + t*pa2 で求められる。\n//戻り値が0なら交点はpa1、戻り値が1なら交点はpa2に一致。\n//交点がないときはDBL_MAXでも返しておく。\n//AOJ 2003で類似のものを使用。\n//そこそこ短くて便利なので一応入れてみたけど、要らないかも。\n//なお、4点が同一直線上にある場合には正確に判定できない。\ndouble intersectSS2(point pa1, point pa2, point pb1, point pb2){\n\tpoint da12 = pa2 - pa1;\n\tpoint db21 = pb1 - pb2;\n\tpoint dab1 = pb1 - pa1;\n\n\tdouble D = cross(da12, db21);\t//符号に注意\n\n\tif(abs(D) > EPS){\n\t\tdouble t = cross(dab1, db21) / D;\n\t\tdouble s = cross(da12, dab1) / D;\n\t\t\n\t\tif( (-EPS < t && t < 1.0 + EPS) && (-EPS < s && s < 1.0 + EPS) ){\n\t\t\treturn t;\t//前半は交点が線分1に含まれるか、後半は線分2に含まれるかどうか\n\t\t}\n\t}\n\treturn DBL_MAX;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の距離\n//（交差している場合の距離は0）\ndouble distance_ls_ls(point a1, point a2, point b1, point b2)\n{\n\tif( intersectSS2(a1, a2, b1, b2) == DBL_MAX)\n\t\treturn min( min(distance_ls_p(a1, a2, b1), distance_ls_p(a1, a2, b2)),\n\t\t\t\t\tmin(distance_ls_p(b1, b2, a1), distance_ls_p(b1, b2, a2)) );\n\telse\n\t\treturn 0;\n}\n\ndouble solve(int N, point start, point goal, vector<polygon> blocks, vector<double> heights){\n\t\n\tvector<double> maxrad;\n\t\n//\tfor(int i = 0; i < N; i++)\n//\t\tif( contains(blocks[i], start) && contains(blocks[i], goal) )\n//\t\t\treturn 0;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\t\n\t\tdouble mindis = 1e9;\n\t\t\n\t\tfor(int j = 0; j < 4; j++)\n\t\t\tmindis = min(mindis, distance_ls_ls(start, goal, blocks[i][j], blocks[i][(j+1)%4]));//長方形の四辺で最もコースの線分に近いものを探す\n\t\t\n\t\tif( mindis > heights[i] )\n\t\t\tmaxrad.push_back( (mindis*mindis + heights[i]*heights[i])/(2*heights[i]) );// d^2 + (r-h)^2 = r^2\n\t\telse\n\t\t\tmaxrad.push_back(mindis);//球の半径が壁の高さより小さくなる場合\n\t}\n\t\n\tdouble res = 1e9;\n\t\n\tfor(int i = 0; i < N; i++)\n\t\tres = min(res, maxrad[i]);\n\t\t\n\treturn res;\n}\n\nint main(){\n\n\tint N;\n\t\n\twhile( cin >> N, N ){\n\t\tdouble ax, ay, bx, by, h;\n\t\tpoint start, goal;\n\t\tvector<polygon> blocks;\n\t\tvector<double> heights;\n\t\t\n\t\tblocks.resize(N);\n\t\t\n\t\tcin >> ax >> ay >> bx >> by;\t\n\t\tstart.real() = ax;\tstart.imag() = ay;\n\t\tgoal.real() = bx;\tgoal.imag() = by;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> ax >> ay >> bx >> by >> h;\n\t\t\t\n\t\t\tblocks[i].push_back(point(ax, ay));\n\t\t\tblocks[i].push_back(point(bx, ay));\n\t\t\tblocks[i].push_back(point(bx, by));\n\t\t\tblocks[i].push_back(point(ax, by));\n\t\t\theights.push_back(h);\n\t\t}\n\t\t\n\t\tcout << solve(N, start, goal, blocks, heights) << endl;\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n\ntypedef double D;\ntypedef complex<D> P;\n\nconst D EPS = 1e-8;\n\nnamespace std{\n    bool operator<(const P &a, const P &b){\n        return real(a) == real(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n}\n\nD dot(P x, P y){return real(conj(x) * y);}\nD cross(P x, P y) {return imag(conj(x) * y);}\n\ntypedef pair<P, P> L;\nint ccw(P a, P b, P c) {\n    b -= a, c -= a;\n    if (cross(b, c) > EPS) return 1;\n    if (cross(b, c) < -EPS) return -1;\n    if (dot(b, c) < -EPS) return 2;\n    if (abs(b) < abs(c)) return -2;\n    return 0;\n}\nD seg_p_dis(L a, P x) {\n    if (dot(a.sc - a.fs, x - a.fs) < EPS) return abs(x - a.fs);\n    if (dot(a.fs - a.sc, x - a.sc) < EPS) return abs(x - a.sc);\n    return abs(cross(a.sc - a.fs, x - a.fs) / abs(a.sc - a.fs));\n}\nD seg_seg_dis(L a, L b) {\n    D res = 1e10;\n    res = min(res, seg_p_dis(a, b.fs));\n    res = min(res, seg_p_dis(a, b.sc));\n    res = min(res, seg_p_dis(b, a.fs));\n    res = min(res, seg_p_dis(b, a.sc));\n    return res;\n}\nbool is_cp(L a, L b) {\n    if (ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n        if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n    return false;\n}\n\nbool ok(D r, const vector<D> &d, const vector<D> &h) {\n    for (int i = 0; i < d.size(); i++) {\n        if (d[i] < r && h[i] > r) return false;\n        if (abs(P(d[i], h[i]) - P(0, r)) < r) return false;\n    }\n    return true;\n}\n\nint main() {\n    int N;\n    while (cin >> N, N) {\n        D sx, sy, ex, ey; cin >> sx >> sy >> ex >> ey;\n        P start{sx, sy}, end{ex, ey};\n        L route{start, end};\n\n        vector<D> d(N, 1e9), h(N, 1e9);\n        for (int i = 0; i < N; i++) {\n            D minx, miny, maxx, maxy;\n            cin >> minx >> miny >> maxx >> maxy >> h[i];\n            P top[] = { {minx, miny}, {minx, maxy}, {maxx, miny}, {maxx, maxy} };\n            if ((minx <= sx && sx <= maxx && miny <= sy && sy <= maxy) ||\n                    (minx <= ex && ex <= maxx && miny <= ey && ey <= maxy)) {\n                d[i] = 0;\n                continue;\n            }\n\n            L lines[] = {{top[0], top[1]}, {top[0], top[2]}, {top[3], top[1]}, {top[3], top[2]}};\n            for (auto line : lines) {\n                if (is_cp(line, route)) {\n                    d[i] = 0;\n                    break;\n                }\n                d[i] = min(d[i], seg_seg_dis(route, line));\n            }\n        }\n\n        D left = 0, right = 1000;\n        while(right - left > 1e-8) {\n            D mid = (right + left) / 2;\n            (ok(mid, d, h) ? left : right) = mid;\n        }\n        cout << left << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\nusing Coordinate = double;\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\nconst double EPS = 1e-8;\n\n\nbool eq(Coordinate a, Coordinate b) { return abs(a - b) < EPS; }\n\nstruct Point {\n    Coordinate x,y;\n    Point():x(0),y(0){}\n    Point(Coordinate x,Coordinate y):x(x),y(y){}\n    pair<Coordinate,Coordinate> to_pair() const { return make_pair(x,y); }\n    bool operator == (const Point &a) const { return eq(x, a.x) && eq(y, a.y); }\n    bool operator != (const Point &a) const { return !(*this == a); }\n    \n    Point operator + (const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator - (const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator - () const { return Point(-x, -y); }\n    Point& operator += (const Point& p) { x += p.x; y += p.y; return *this; }\n    Point& operator -= (const Point& p) { x -= p.x; y -= p.y; return *this; }\n    // ???????????¨ x, y???\n    bool operator <  (const Point &a) const { return x < a.x && y < a.y; }\n    bool operator <= (const Point &a) const { return *this == a || *this < a;}\n    bool operator >  (const Point &a) const { return !(*this <= a); }\n    bool operator >= (const Point &a) const { return !(*this < a); }\n};\ntemplate<typename T> Point operator * (T k, const Point &p) { return Point(k * p.x, k * p.y); }\ntemplate<typename T> Point operator / (const Point &p, T k) { return Point(p.x / k, p.y / k); }\ndouble dot(const Point &a, const Point &b) { return a.x * b.x + a.y * b.y; }\ndouble cross(const Point &a, const Point &b) { return a.x * b.y - a.y * b.x; }\ndouble norm(const Point& a) { return sqrt( dot(a, a) ); }\n\nistream &operator >> (istream& is, Point& p){ return is >> p.x >> p.y;}\nostream &operator << (ostream& os, const Point& p){ return os << \"(\" << p.x << \",\" << p.y << \")\";}\n\ndouble distance(const Point& a, const Point& b) { return norm(a - b); }\n\nenum class ccw_t {\n    COUNTER_CLOCK_WISE = 1,\n    CLOCK_WISE = -1,\n    STRAIGHT_C_A_B = 2,\n    STRAIGHT_A_B_C = -2,\n    STRAIGHT_A_C_B = 0\n};\n\n\nccw_t ccw(const Point &a, const Point &b, const Point &c){\n    Point ab = b - a;\n    Point ac = c - a;\n    if( cross(ab,ac) > 0 ) return ccw_t::COUNTER_CLOCK_WISE;//a-b-c ???????¨???????\n    if( cross(ab,ac) < 0 ) return ccw_t::CLOCK_WISE;        //a-b-c ????¨???????\n    if( dot(ab,ac) < 0 ) return ccw_t::STRAIGHT_C_A_B;      //c-a-b\n    if( norm(ab) < norm(ac) )return ccw_t::STRAIGHT_A_B_C;  //a-b-c or a==b\n    return ccw_t::STRAIGHT_A_C_B;                           //a-c-b or b==c or a==c\n}\n\n\nstruct Segment{\n    Point a, b;\n    Segment(){}\n    Segment(const Point& a, const Point& b):a(a), b(b){}\n    pair<Point,Point> to_pair() const { return make_pair(a,b); }\n    bool operator == (const Segment& s) const { return to_pair() == s.to_pair();}\n    bool operator != (const Segment& s) const { return to_pair() != s.to_pair();}\n\n    bool on_line(const Point &p) const {\n        return ccw(a, b, p) == ccw_t::STRAIGHT_A_C_B;\n    }\n    Point closest_point(const Point &p) const {\n        Point pp = projection(p);\n        if(on_line(pp)) return pp;        \n        return distance(a, p) < distance(b, p) ? a : b;\n    }\n    Point projection(const Point &p) const {\n        // cerr << a << b << p << endl;\n        double t = dot(p - a, b - a) / norm(b - a);\n        // cerr << t << endl;\n        Point ret = t * (b - a) / norm(b - a);\n        // cerr << ret  << ret + a << endl;\n        return ret + a;\n    }\n};\nistream &operator >> (istream& is, Segment& s){ return is >> s.a >> s.b;}\nostream &operator << (ostream& os, Segment& s){ return os << s.a << \"->\" << s.b;}\n\ndouble distance( const Segment &s , const Point &p){\n    if( dot( s.b - s.a , p - s.a ) < EPS ) return norm( p - s.a );\n    if( dot( s.a - s.b , p - s.b ) < EPS ) return norm( p - s.b );\n    return abs(cross( s.b - s.a , p - s.a ) / norm( s.b - s.a ));\n}\n\nbool does_intersect(const Segment &a, const Segment &b){\n    return (int)ccw(a.a, a.b, b.a) * (int)ccw(a.a, a.b, b.b) <= 0 &&\n            (int)ccw(b.a, b.b, a.a) * (int)ccw(b.a, b.b, a.b) <= 0;\n}\n\n\n\nstruct Rectangle {\n    array<Point, 4> p;\n    // order:\n    //     3 2\n    //     0 1\n    Rectangle(const array<Point, 4> &pp):p(pp) {\n        rep(i, 3) {            \n            repeat(j, i + 1, 4) {\n                int cnt = 0;\n                rep(k, 4) if(k != i and k != j){\n                    cnt += ccw(p[i], p[j], p[k]) == ccw_t::COUNTER_CLOCK_WISE;\n                }\n                if(cnt == 2) {\n                    swap(p[i + 1], p[j]);\n                    break;\n                }\n            } \n        }\n    }\n    bool intersect(const Segment &s) const {\n        bool res = false;\n        rep(i, 4) res |= does_intersect(s, Segment(p[i], p[(i + 1) % 4]));\n        return res;\n    }\n    bool contain(const Point &pp) const {\n        bool flg = true;\n        rep(i, 4) flg &= ccw(p[i], p[(i + 1) % 4], pp) == ccw_t::COUNTER_CLOCK_WISE;\n        return flg;\n    }\n    bool contain(const Segment &s) const {\n        return contain(s.a) and contain(s.b);\n    }\n    Point closest_point(const Point &pp) const {\n        Point res = p[0];\n        rep(i, 4) {\n            Segment s = Segment(p[i], p[(i+1)%4]);\n            Point ppp = s.closest_point(pp);\n            if(distance(res, pp) > distance(ppp, pp)) res = ppp;\n        }\n        return res;\n    }\n    Point closest_point(const Segment &s) const {\n        Point res = p[0];\n        repeat(i, 1, 4) if(distance(s, res) > distance(s, p[i])) res = p[i];\n        for(Point pp : {s.a, s.b}) {\n            Point ppp = closest_point(pp);\n            if(distance(s, res) > distance(s, ppp)) res = ppp;\n        }\n        return res;\n    }\n};\n\n\nclass Solver {\n  public:\n    Segment S;\n    vector<Point> minP, maxP;\n    vector<double> H;\n    bool solve() {\n\n        int N; cin >> N;\n        if(not N) return false;\n        cin >> S;\n        minP.resize(N);\n        maxP.resize(N);\n        H.resize(N);\n        rep(i, N) cin >> minP[i] >> maxP[i] >> H[i];\n        \n        double max_r = INF;\n\n        rep(i, N) {            \n            Rectangle rect({minP[i], maxP[i], Point(minP[i].x, maxP[i].y), Point(maxP[i].x, minP[i].y)});\n\n            // check cross or contain\n            if(rect.intersect(S) or rect.contain(S)) {\n                cout << 0 << endl;\n                return true;\n            }\n\n            rep(i, 4) {\n                Segment s(rect.p[i], rect.p[(i+1)%4]);\n                Point p1 = s.projection(S.a);\n                Point p2 = s.projection(S.b);\n            }\n\n            Point closest = rect.closest_point(S);\n            double d = distance(S, closest);\n            double r = (d * d + H[i] * H[i]) / (2 * H[i]);\n            if(r < H[i]) r = d;\n            set_min(max_r, r);\n        }\n\n        cout << max_r << endl;\n        return true;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <utility>\n#define maxn 55\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nstruct Point{\n\tdouble x,y;\n\tPoint(double x = 0.0,double y = 0.0): x(x),y(y) {}\n\tPoint operator + (Point p){\n\t\treturn Point(x + p.x,y + p.y);\n\t}\n\tPoint operator - (Point p){\n\t\treturn Point(x - p.x,y - p.y);\n\t}\n\tPoint operator * (double lambda){\n\t\treturn Point(x * lambda,y * lambda);\n\t}\n\tPoint operator / (double lambda){\n\t\treturn Point(x / lambda,y / lambda);\n\t}\n\tPoint operator - (){\n\t\treturn Point(-x,-y);\n\t}\n\tdouble norm(){\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs_(){\n\t\treturn sqrt(norm());\n\t}\n\tbool operator == (const Point &p)const\n\t{\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n\tbool operator < (const Point &p)const\n\t{\n\t\tif(abs(x - p.x) < EPS) return y < p.y;\n\t\telse return x < p.x;\n\t}\n};\ntypedef Point Vector;\nstruct Segment{\n\tPoint p1,p2;\n\tSegment(Point p1 = Point(),Point p2 = Point()): p1(p1),p2(p2) {}\n};\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\ndouble dot(Vector a,Vector b){ return a.x * b.x + a.y * b.y; }\ndouble det(Vector a,Vector b){ return a.x * b.y - a.y * b.x; }\nstruct Obstacle{\n\tdouble minx,miny,maxx,maxy;\n\tdouble h;\n};\nint ccw(Point p,Segment l){\n\tif(det(l.p2 - l.p1,p - l.p1) > EPS) return 1;\n\tif(det(l.p2 - l.p1,p - l.p1) < -EPS) return -1;\n\tif(dot(l.p2 - l.p1,p - l.p1) < -EPS) return 2;\n\tif((l.p2 - l.p1).norm() < (p - l.p1).norm()) return -2;\n\treturn 0;\n}\nbool cross(Segment s1,Segment s2){\n\treturn ccw(s1.p1,s2) * ccw(s1.p2,s2) <= 0 && ccw(s2.p1,s1) * ccw(s2.p2,s1) <= 0;\n}\ndouble dis2(Point p,Segment s){//dis ^ 2.\n\tif(dot(p - s.p1,s.p2 - s.p1) < -EPS) return (p - s.p1).norm();\n\tif(dot(p - s.p2,s.p1 - s.p2) < -EPS) return (p - s.p2).norm();\n\tdouble tmp = abs(det(p - s.p1,s.p2 - s.p1));\n\treturn tmp * tmp / (s.p2 - s.p1).norm();\n}\ndouble dis(double r,Segment s,Segment t,double h){\n\tif(cross(s,t)) return 0.0;\n\tdouble hori2 = min(min(dis2(s.p1,t),dis2(s.p2,t)),min(dis2(t.p1,s),dis2(t.p2,s)));\n\tif(r <= h) return sqrt(hori2);\n\treturn sqrt(hori2 + (r - h) * (r - h));\n}\ndouble dis(double r,Segment s,Obstacle a){\n\tif(a.minx < s.p1.x + EPS && s.p1.x < a.maxx + EPS && a.miny < s.p1.y + EPS && s.p1.y < a.maxy + EPS) return 0.0;\n\tdouble res = 1e9;\n\tres = min(res,dis(r,s,Segment(Point(a.minx,a.miny),Point(a.minx,a.maxy)),a.h));\n\tres = min(res,dis(r,s,Segment(Point(a.minx,a.miny),Point(a.maxx,a.miny)),a.h));\n\tres = min(res,dis(r,s,Segment(Point(a.minx,a.maxy),Point(a.maxx,a.maxy)),a.h));\n\tres = min(res,dis(r,s,Segment(Point(a.maxx,a.miny),Point(a.maxx,a.maxy)),a.h));\n\treturn res;\n}\nObstacle rec[maxn];\nSegment s;\nint n;\nbool check(double x){\n\tfor(int i=1;i<=n;i++){\n\t\tif(dis(x,s,rec[i]) < x - EPS) return false;\n\t}\n\treturn true;\n}\nint main(){\n\twhile(~scanf(\"%d\",&n) && n){\n\t\tscanf(\"%lf%lf%lf%lf\",&s.p1.x,&s.p1.y,&s.p2.x,&s.p2.y);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf%lf\",&rec[i].minx,&rec[i].miny,&rec[i].maxx,&rec[i].maxy,&rec[i].h);\n\t\t}\n\t\tdouble lb = 0.0,rb = 5e4;\n\t\tfor(int i=1;i<=35;i++){\n\t\t\tdouble mid = (lb + rb) / 2;\n\t\t\tif(check(mid)) lb = mid;\n\t\t\telse rb = mid;\n\t\t}\n\t\tprintf(\"%.5f\\n\",lb);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-7;\nconst double PI  = acos(-1.0);\n\n#define M INT_MAX\nstruct P{\n  double x;\n  double y;\n\n  P(){\n\tx=M; y=M;\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n\n};\ndouble dot(P a,P b){\n  return (a.x*b.x+a.y*b.y);\n}\n\ndouble cross(P a,P b){\n  return (a.x*b.y-a.y*b.x);\n}\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\ndouble psd(P p , P a , P b){\n  if( dot( b-a , p-a ) < EPS) return fabs(dis(p-a));\n  if( dot( a-b , p-b ) < EPS) return fabs(dis(p-b));\n  return fabs(cross( b-a , p-a )) / fabs(dis(b-a));\n}\n\nbool intersect_s(P a1 , P a2 , P b1 , P b2){\n  return ( cross(a2-a1 , b1-a1)*cross(a2-a1 , b2-a1) < EPS) &&\n\t( cross(b2-b1 , a1-b1)*cross(b2-b1 , a2-b1) < EPS);\n}\n\nbool isin(P p, P a1, P a2){\n  double mx = min(a1.x, a2.x), Mx = max(a1.x, a2.x);\n  double my = min(a1.y, a2.y), My = max(a1.y, a2.y);\n  return mx <= p.x - EPS && p.x <= Mx - EPS\n\t&& my <= p.y - EPS && p.y <= My - EPS;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tP s, e;\n\tvector< vector<P> > ps(N, vector<P>(4));\n\tvector<double> h(N), d(N, M);\n\tcin >> s.x >> s.y >> e.x >> e.y;\n\tREP(i,N)\n\t  cin >> ps[i][0].x >> ps[i][0].y >> ps[i][2].x >> ps[i][2].y >> h[i];\n\tREP(i,N){\n\t  ps[i][1].x = ps[i][0].x;\n\t  ps[i][1].y = ps[i][2].y;\n\n\t  ps[i][3].x = ps[i][2].x;\n\t  ps[i][3].y = ps[i][0].y;\n\t}\n\n\tREP(i,N) REP(j,4){\n\t  d[i] = min(d[i], psd(ps[i][j], s, e));\n\t  d[i] = min(d[i], psd(s, ps[i][j], ps[i][(j+1)%4]));\n\t  d[i] = min(d[i], psd(e, ps[i][j], ps[i][(j+1)%4]));\n\t}\n\n\tdouble r_lb = 0., r_ub = 1000.;\n\tREP(i,N) REP(j,4){\n\t  if(intersect_s(s,e,ps[i][j],ps[i][(j+1)%4]))\n\t\tr_ub = 0.;\n\t  if(isin(s, ps[i][0], ps[i][2]) || isin(e, ps[i][0], ps[i][2]))\n\t\tr_ub = 0.;\n\t}\n\n\tREP(i,100){\n\t  bool flag = true;\n\t  double r = (r_lb + r_ub) / 2.;\n\t  REP(j,N){\n\t\tif(d[j] > r) continue;\n\t\tif(h[j] >= r || d[j]*d[j]+h[j]*h[j] - 2*r*h[j] < -EPS){\n\t\t  flag = false;\n\t\t  break;\n\t\t}\n\t  }\n\n\t  if(flag) r_lb = r;\n\t  else r_ub = r;\n\t}\n\n\tcout << fixed << setprecision(6) << r_lb << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define INF 1e9\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\nconst double EPS = 1e-9;\n\ndouble dot(Point a, Point b) {\n    return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(Point a, Point b) {\n    return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(Point a, Point b, Point c) {\n    b -= a;  c -= a;\n    if (cross(b,c) >  EPS) return +1;  // counter clockwise\n    if (cross(b,c) < -EPS) return -1;  // clockwise\n    if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n    return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isecSP(Point a1, Point a2, Point b) {\n    return !ccw(a1, a2, b);\n}\n\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n    return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n           ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\nPoint proj(Point a1, Point a2, Point p) {\n    return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\ndouble distSP(Point a1, Point a2, Point p) {\n    Point r = proj(a1, a2, p);\n    if (isecSP(a1, a2, r)) return abs(r-p);\n    return min(abs(a1-p), abs(a2-p));\n}\n\ndouble distSS(Point a1, Point a2, Point b1, Point b2) {\n    if (isecSS(a1, a2, b1, b2)) return 0;\n    return min({\n        distSP(a1, a2, b1),\n        distSP(a1, a2, b2),\n        distSP(b1, b2, a1),\n        distSP(b1, b2, a2)});\n}\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        double sx,sy,gx,gy;\n        cin>>sx>>sy>>gx>>gy;\n        Point s(sx,sy);\n        Point g(gx,gy);\n        vector<double> d(n,INF), h(n);\n        rep(i,n){\n            double x[2],y[2];\n            cin>>x[0]>>y[0]>>x[1]>>y[1]>>h[i];\n            VP p;\n            rep(xx,2)rep(yy,2){\n                p.push_back(Point(x[xx],y[yy]));\n            }\n            rep(j,4){\n                d[i] = min(d[i],distSS(s,g,p[j],p[(j+1)%4]));\n            }\n        }\n\n        double l = 0, r = 1000;\n        rep(_,100){\n            double m = (l+r)/2;\n            bool ok = true;\n            rep(i,n){\n                if(pow(max(m-h[i],0.0),2)+pow(d[i],2) < pow(m,2)){\n                    ok = false;\n                }\n            }\n            if(ok) l = m;\n            else r = m;\n        }\n        printf(\"%.6f\\n\",l);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n/////////////////\n// 2D geometry //\n/////////////////\n \n// 2D geometry basic //\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\n#define X real\n#define Y imag\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(){};\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n  double R(double h){\n    return sqrt(max(r*r-h*h,0.0));\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n///////////////////\n// 線と点の距離　//\n///////////////////\n\n// 点に最も近い線上の点 //\nP projection(const L &l, const P &p){\n  double t = dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n//　直線と点の距離\ndouble distanceLP(const L &l,const P &p){\n  return abs(p-projection(l,p));\n}\n\n// 線分と点の内包判定\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n// 線分と点の距離 //\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n// 線分同士の交差判定 //\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//\n// solve\n//\n\nstruct B{\n  double x1,y1,x2,y2;\n  int h;\n  bool inter(L l){\n    return ((x1<=l[0].X()&&l[0].X()<=x2)&&(y1<=l[0].Y()&&l[0].Y()<=y2))\n            ||((x1<=l[1].X()&&l[1].X()<=x2)&&(y1<=l[1].Y()&&l[1].Y()<=y2));\n  }\n};\n\nL line;\nvector<B> b;\nvoid init(){\n  line.clear();\n  b.clear();\n}\nbool input(){\n  int n;\n  cin>>n;\n  if(n==0)return false;\n  double tmp[4];\n  cin>>tmp[0]>>tmp[1]>>tmp[2]>>tmp[3];\n  line = L(P(tmp[0],tmp[1]),P(tmp[2],tmp[3]));\n  for(int i=0;i<n;i++){\n    int h;\n    cin>>tmp[0]>>tmp[1]>>tmp[2]>>tmp[3]>>h;\n    b.push_back(B{tmp[0],tmp[1],tmp[2],tmp[3],h});\n  }\n  return true;\n}\n\ndouble getR(double dist,double h){\n  if(dist<h)return dist;\n  double res = (dist*dist-h*h)/(2*h) + h;\n  return res;\n}\ndouble notouchR(B b){\n  const vector<L> bl = {\n    L(P(b.x1,b.y1),P(b.x1,b.y2)),\n    L(P(b.x1,b.y2),P(b.x2,b.y2)),\n    L(P(b.x2,b.y2),P(b.x2,b.y1)),\n    L(P(b.x2,b.y1),P(b.x1,b.y1))\n  };\n  const vector<P> bp ={\n    P(b.x1,b.y1),\n    P(b.x1,b.y2),\n    P(b.x2,b.y1),\n    P(b.x2,b.y2),\n  };\n  if(b.inter(line))return 0;\n  for(auto i:bl)if(intersectSS(line,i))return 0;\n\n\n  double dist = 1000000;\n  for(auto i:bl){\n    dist = min(dist,distanceSP(i,line[0]));\n    dist = min(dist,distanceSP(i,line[1]));\n  }\n  for(auto i:bp){\n    dist = min(dist,distanceSP(line,i));\n  }\n  return getR(dist,b.h);\n}\n\n\ndouble solve(){\n  double ans = 10000;\n  for(int i=0;i<b.size();i++){\n    ans = min(notouchR(b[i]),ans);\n  }\n  return ans;\n}\n\n\nint main(){\n  while(init(),input()){\n    cout<<fixed<<setprecision(20)<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-9;\n\nstruct Point\n{\n  int x, y;\n  Point(){}\n  Point(int x, int y):x(x), y(y){}\n  Point operator+(const Point& p) const\n  {\n    return Point(x + p.x, y + p.y);\n  }\n  Point operator-(const Point& p) const\n  {\n    return Point(x - p.x, y - p.y);\n  }\n  int norm()\n  {\n    return(x * x + y * y);\n  }\n  double abs()\n  {\n    return(sqrt(norm()));\n  }\n};\nstruct Segment\n{\n  Point p1, p2;\n};\n\nint Cross(Point& a, Point& b)    // ?????????????????????\n{\n  return(a.x * b.y - a.y * b.x);\n}\nint Dot(Point& a, Point &b)      // ?????????????????????\n{\n  return(a.x * b.x + a.y * b.y);\n}\nint CCW(Point& a, Point b, Point c)\n{\n  b = b - a, c = c - a;\n  if(Cross(b, c) > EPS) return(1);\n  if(Cross(b, c) < -EPS) return(-1);\n  if(Dot(b, c) < 0) return(2);\n  if(b.norm() < c.norm()) return(-2);\n  return(0);\n}\nbool Intersect(Segment& a, Segment& b)   // ????????¨?????????????????????\n{\n  return(CCW(a.p1, a.p2, b.p1) * CCW(a.p1, a.p2, b.p2) <= 0 &&\n         CCW(b.p1, b.p2, a.p1) * CCW(b.p1, b.p2, a.p2) <= 0);\n}\ndouble Distance(Segment& s, Point& c)    // ????????¨?????¨????????¢\n{\n  Point a = s.p1, b = s.p2;\n  Point nx = b - a, ny = c - a, tx = a - b, ty = c - b;\n  if(Dot(nx, ny) <= 0) return(ny.abs());\n  if(Dot(tx, ty) <= 0) return(ty.abs());\n  return(fabs(Cross(nx, ny)) / nx.abs());\n}\n\ndouble Distance(Segment& a, Segment& b)  // ????????¨??????????????¢\n{\n  if(Intersect(a, b)) return(0.0);\n  return min(min(Distance(a, b.p1), Distance(a, b.p2)),\n             min(Distance(b, a.p1), Distance(b, a.p2)));\n}\n\n\n\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    int sx, sy, tx, ty;\n    double ret = 1e9;\n    Segment data[4];\n\n    cin >> sx >> sy >> tx >> ty;\n    Segment Line = (Segment){Point(sx, sy), Point(tx, ty)};\n    for(int i = 0; i < N; i++) {\n      int minx, miny, maxx, maxy, h;\n      cin >> minx >> miny >> maxx >> maxy >> h;\n      data[0] = (Segment){(Point){minx, miny},(Point){maxx, miny}};\n      data[1] = (Segment){(Point){minx, maxy},(Point){minx, miny}};\n      data[2] = (Segment){(Point){maxx, maxy},(Point){minx, maxy}};\n      data[3] = (Segment){(Point){maxx, maxy},(Point){maxx, miny}};\n\n      if(minx <= sx && maxx >= tx && miny <= ty && maxy >= ty) {\n        ret = 0;\n      } else {\n        for(int i = 0; i < 4; i++) {\n          double d = Distance(Line, data[i]);\n          if(d <= h) ret = min(ret, d);\n          else ret = min(ret, (d * d + h * h) / (2.0 * h));\n        }\n      }\n    }\n    cout << fixed << setprecision(10) << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define EPS (1e-10)\ntypedef complex<double> P;\n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\ndouble distance(P p0, P p1, P p2, P p3){\n  double ans = 1e10;\n        ans = min(ans, distance_ls_p(p0, p1, p2));\n        ans = min(ans, distance_ls_p(p0, p1, p3));\n        ans = min(ans, distance_ls_p(p2, p3, p0));\n        ans = min(ans, distance_ls_p(p2, p3, p1));\n        if(is_intersected_ls(p0, p1, p2, p3)) ans = 0.0;\n\t\treturn ans;\n}\n\nint main(){\n\twhile(true){\n\t\tint n; cin >> n;\n\t\tif(n == 0 )break;\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tP s = P(x,y);\n\t\tcin >> x >> y;\n\t\tP g = P(x,y);\n\t\tvector<P> mins(n), maxs(n);\n\t\tvector<double> h(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\tmins[i].real(x); mins[i].imag(y);\n\t\t\tcin >> x >> y;\n\t\t\tmaxs[i].real(x); maxs[i].imag(y);\n\t\t\tcin >> h[i];\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tfor(int i = 0; i < n;i++){\n\t\t\tdouble d = 1e9;\n\t\t\tP p1 = mins[i], p3 = maxs[i];\n\t\t\tP p2(mins[i].real(), maxs[i].imag());\n\t\t\tP p4(maxs[i].real(), mins[i].imag());\n\t\t\tif(p1.real() < s.real() && s.real() < p3.real() && \n\t\t\t\tp1.imag() < s.imag() && s.imag() < p3.real()){\n\t\t\t\tans = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, distance(s, g, p1,p2));\n\t\t\td = min(d, distance(s, g, p2,p3));\n\t\t\td = min(d, distance(s, g, p3,p4));\n\t\t\td = min(d, distance(s, g, p4,p1));\n\t\t\tdouble r = (h[i]*h[i]+d*d)/(2*h[i]);\n\t\t\tif(h[i] < d){\n\t\t\t\tans = min(ans, r);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = min(ans, d);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%f\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define PI acos(-1)\n#define INF (1e9 + 7)\n\nclass Point {\npublic:\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n    Point operator + (Point p) {\n        return Point(x + p.x, y + p.y);\n    }\n    Point operator - (Point p) {\n        return Point(x - p.x, y - p.y);\n    }\n    Point operator * (double c) {\n        return Point(c * x, c * y);\n    }\n    Point operator / (double c) {\n        return Point(x / c, y / c);\n    }\n    bool operator < (const Point &p) {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const Point &p) {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n    bool operator != (const Point &p) {\n        return (fabs(x - p.x) > EPS || fabs(y - p.y) > EPS);\n    }\n\n    double norm() {\n        return (x * x + y * y);\n    }\n    double abs() {\n        return sqrt(norm());\n    }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n    return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b) {\n    return (a.x * b.y - a.y * b.x);\n}\n\ndouble norm(Vector a) {\n    return (a.x * a.x + a.y * a.y);\n}\n\ndouble abs(Vector a) {\n    return sqrt(norm(a));\n}\n\nclass Segment {\npublic:\n    Point p1, p2;\n    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\ndouble distL(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble distS(Segment s, Point p) {\n    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n    return distL(s, p);\n}\n\nconst int CCW = 1, CW = -1, ONBACK = 2, ONFRONT = -2, ONSEG = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n\n    if (cross(a, b) > EPS) return CCW;\n    if (cross(a, b) < -EPS) return CW;\n    if (dot(a, b) < -EPS) return ONBACK;\n    if (a.norm() < b.norm()) return ONFRONT;\n    return ONSEG;\n}\n\nbool intersect(Point a, Point b, Point c, Point d) {\n    return (ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0);\n}\n\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble distSS(Segment s1, Segment s2) {\n    if (intersect(s1, s2)) return 0.0;\n    return min(min(distS(s1, s2.p1), distS(s1, s2.p2)), min(distS(s2, s1.p1), distS(s2, s1.p2)));\n}\n\nclass Block {\npublic:\n    double lx, ly, rx, ry, h;\n    vector<Segment> seg, diagonal;\n\n    Block(double lx = 0.0, double ly = 0.0, double rx = 0.0, double ry = 0.0, double h  = 0.0) : lx(lx), ly(ly), rx(rx), ry(ry), h(h) {}\n\n    void setSeg() {\n        seg.resize(4);\n        diagonal.resize(2);\n        seg[0] = Segment(Point(lx, ly), Point(lx, ry));\n        seg[1] = Segment(Point(lx, ry), Point(rx, ry));\n        seg[2] = Segment(Point(rx, ry), Point(rx, ly));\n        seg[3] = Segment(Point(rx, ly), Point(lx, ly));\n        diagonal[0] = Segment(Point(lx, ly), Point(rx, ry));\n        diagonal[1] = Segment(Point(lx, ry), Point(rx, ly));\n    }\n};\n\ninline double dst(double r, double h) {\n    if ((r * r - (r - h) * (r - h)) < 0.0) return r;\n    return sqrt(r * r - (r - h) * (r - h));\n}\n\nint N, sx, sy, ex, ey, a, b, c, d, h;\ndouble ans, min_dist, l, r, mid;\nvector<Block> bk;\nSegment road;\n\nint main() {\n\n    while (scanf(\"%d\", &N), N) {\n        bk.resize(N);\n        ans = 1001.0;\n\n        scanf(\"%d%d%d%d\", &sx, &sy, &ex, &ey);\n        road = Segment(Point(sx, sy), Point(ex, ey));\n\n        for (int i = 0; i < N; ++i) {\n            scanf(\"%d%d%d%d%d\", &a, &b, &c, &d, &h);\n            bk[i] = Block(a, b, c, d, h);\n            bk[i].setSeg();\n        }\n\n        for (int i = 0; i < N; ++i) {\n            min_dist = INF;\n            for (int j = 0; j < 4; ++j) {\n                min_dist = min(min_dist, distSS(Segment(Point(sx, sy), Point(ex, ey)), bk[i].seg[j]));\n            }\n\n            if (intersect(bk[i].diagonal[0], road) || intersect(bk[i].diagonal[1], road)) {\n                ans = 0.0;\n                break;\n            }\n\n            //cout << i << \" \" << min_dist << endl;\n            l = 0.0; r = double(ans);\n            while (r - l > EPS) {\n                mid = (l + r) / 2.0;\n                if (min_dist < dst(mid, bk[i].h)) r = mid;\n                else l = mid;\n            }\n\n            //cout << \"l = \" << l << endl;\n\n            if (ans == 1001.0) ans = l;\n            else ans = min(ans, l);\n            //cout << \"d = \" << dst(ans, bk[i].h) << endl;\n            //printf(\"%.20lf\\n\", ans);\n        }\n\n        printf(\"%.10lf\\n\", ans);\n\n        bk.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\nnamespace std{\n\tbool operator < (const xy_t &a, const xy_t &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\ndouble cross(const xy_t &a, const xy_t &b){\n\treturn imag(conj(a) * b);\n}\n\ndouble dot(const xy_t &a, const xy_t &b){\n\treturn real(conj(a)*b);\n}\n\nxy_t projection(const line &l, const xy_t &p){\n\tdouble t = dot(l.second - l.first, p - l.first) / norm(l.second - l.first);\n\treturn l.first + t * (l.second - l.first);\n}\n\nint ccw(xy_t a, xy_t b, xy_t c){\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0) return 1;\n\tif(cross(b, c) < 0) return -1;\n\tif(dot(b, c) < 0) return +2;\n\tif(norm(b) < norm(c) ) return -2;\n\treturn 0;\n}\n\nbool intersectSP(const line &s, const xy_t &p){\n\treturn abs(s.first - p) + abs(s.second - p) - abs(s.second - s.first) < EPS;\n}\n\nbool intersectSS(const line &s, const line &t){\n\treturn ccw(s.first, s.second, t.first) * ccw(s.first, s.second, t.second) <= 0 &&\n\t\tccw(t.first, t.second, s.first) * ccw(t.first, t.second, s.second) <= 0;\n}\n\n\ndouble distanceSP(const line &s, const xy_t p){\n\txy_t r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s.first - p), abs(s.second - p));\n}\n\ndouble distanceSS(const line &s, const line &t){\n\tif(intersectSS(s, t)) return 0.0;\n\treturn min(min(distanceSP(s, t.first), distanceSP(s, t.second)),\n\t\tmin(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\n\nxy_t crosspoint(const line &l, const line &m){\n\tdouble a = cross(l.second - l.first, m.second - m.first);\n\tdouble b = cross(l.second - l.first, l.second - m.first);\n\tif(abs(a) < EPS && abs(b) < EPS) return m.first;\n\tif(abs(a) < EPS) assert(false);\n\treturn m.first + b / a * (m.second - m.first);\n}\n\nint n;\nline ls[300];\ndouble height[300];\nline l;\n\nbool C(double r){\n\tfor(int i = 0; i < n * 4; i++){\n\t\tdouble d = distanceSS(ls[i], l);\n\t\tdouble dis = (height[i] < r) ? sqrt(r * r - (r - height[i]) * (r - height[i])) : r;\n\t\tif(dis > d) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(cin >> n && n){\n\t\tdouble sx, sy, ex, ey;\n\t\tdouble minx, miny, maxx, maxy, h;\n\t\tbool ok = true;\n\t\tcin >>sx >> sy >> ex >> ey;\n\t\tl = line(xy_t(sx, sy), xy_t(ex, ey));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> minx >> miny >> maxx >> maxy >> h;\n\t\t\tif(minx < min(sx, ex) && max(sx, ex) < maxx && miny < min(sy, ey) && max(sy, ey) < maxy) ok = false;\n\t\t\tls[i*4] = line(xy_t(minx, miny), xy_t(minx, maxy));\n\t\t\tls[i*4+1] = line(xy_t(minx, maxy), xy_t(maxx, maxy));\n\t\t\tls[i*4+2] = line(xy_t(maxx, maxy), xy_t(maxx, miny));\n\t\t\tls[i*4+3] = line(xy_t(maxx, miny), xy_t(minx, miny));\n\t\t\tfor(int j = 0; j < 4; j++) height[i*4+j] = h;\n\t\t}\n\t\tdouble ub = 1000;\n\t\tdouble lb = 0;\n\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tdouble mb = (ub + lb) / 2;\n\t\t\tif(C(mb)) lb = mb;\n\t\t\telse ub = mb;\n\t\t}\n\t\tif(ok) cout << fixed << setprecision(9) << lb << endl;\n\t\telse cout << 0.0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <iostream>\n\nusing namespace std;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\ntypedef long double ld;\nconst ld EPS=1e-10;\n\nstruct Point{\n\tPoint(ld x,ld y):x(x), y(y){}\n\tPoint(){}\n\tld x,y;\n};\n\nPoint operator+(const Point &a, const Point &b){\n\treturn Point(a.x+b.x, a.y+b.y);\n}\n\nPoint operator-(const Point &a, const Point &b){\n\treturn Point(a.x-b.x, a.y-b.y);\n}\n\nPoint operator*(const Point &a, const ld b){\n\treturn Point(a.x*b, a.y*b);\n}\n\nld cross(const Point &a, const Point &b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nld dot(const Point &a, const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\nld norm(const Point &a){\n\treturn dot(a,a);\n}\n\nld abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nstruct Line:vector<Point>{\n\tLine(Point a = Point(0,0), Point b = Point(0,0)){\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n};\n\nint ccw(Point a, Point b, Point c){\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b,c) > EPS) return 1;\n\tif(cross(b,c) < -EPS) return -1;\n\tif(dot(b,c) < 0) return 2;\n\tif(norm(b)<norm(c)) return -2;\n\treturn 0;\n}\n\nbool is_intersect_SS(const Line &s, const Line &t){\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nbool is_intersect_SP(const Line &l, const Point &p){\n\treturn ccw(l[0],l[1],p)==0;\n}\n\nPoint projection(const Line &l, const Point &p){\n\tld t = dot(p-l[0],l[1]-l[0])/norm(l[0]-l[1]);\n\treturn l[0]+(l[1]-l[0])*t;\n}\n\nld distance_SP(const Line &s, const Point &p){\n\tconst Point r = projection(s,p);\n\tif(is_intersect_SP(s,r))return abs(r-p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\nld distance_SS(const Line &s, const Line &t){\n\tif(is_intersect_SS(s,t)) return 0;\n\treturn min(min(distance_SP(s,t[0]),distance_SP(s,t[1])),min(distance_SP(t,s[0]),distance_SP(t, s[1])));\n}\n\nbool lt(ld x, ld y){\n\treturn x < y+EPS;\n}\n\nint n;\nLine L;\nLine data[100];\nint H[100];\n\nld Max;\n\nvoid input(){\n\tint w, x, y, z;\n\tMax = 1e10;\n\tscanf(\"%d%d%d%d\", &w, &x, &y, &z);\n\tL = Line(Point(w,x), Point(y,z));\n\tfor(int i = 0 ; i< n;i++){\n\t\tscanf(\"%d%d%d%d%d\", &w, &x, &y, &z, &H[i]);\n\t\tdata[i] = Line(Point(w,x), Point(y,z));\n\t}\n}\n\nvoid process(){\n\tld minX = min(L[0].x, L[1].x);\n\tld minY = min(L[0].y, L[1].y);\n\tld maxX = max(L[0].x, L[1].x);\n\tld maxY = max(L[0].y, L[1].y);\n\t//Check rect & line\n\tfor(int i = 0; i < n;i++){\n\t\tif(is_intersect_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][0].x, data[i][1].y))) ||\n\t\t\tis_intersect_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][1].x, data[i][0].y))) ||\n\t\t\tis_intersect_SS(L, Line(Point(data[i][0].x, data[i][1].y), Point(data[i][1].x, data[i][1].y))) ||\n\t\t\tis_intersect_SS(L, Line(Point(data[i][1].x, data[i][0].y), Point(data[i][1].x, data[i][1].y)))) {\n\t\t\tprintf(\"0.0000\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif(lt(data[i][0].x , minX) && lt(data[i][0].y , minY) && lt(maxX , data[i][1].x) && lt(maxY , data[i][1].y)) {\n\t\t\tprintf(\"0.0000\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t//get r;\n\tfor(int i = 0; i < n; i++) {\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][0].x, data[i][1].y)));\n\t\t\tif(lt(d, H[i])) {\n\t\t\t\tif(lt(d, Max)) Max = d;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\t\tif(lt(r, Max)) Max = r;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][1].x, data[i][0].y)));\n\t\t\tif(lt(d, H[i])) {\n\t\t\t\tif(lt(d, Max)) Max = d;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\t\tif(lt(r,Max)) Max = r;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][0].x, data[i][1].y), Point(data[i][1].x, data[i][1].y)));\n\t\t\tif(lt(d, H[i])) {\n\t\t\t\tif(lt(d, Max)) Max = d;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\t\tif(lt(r,Max)) Max = r;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][1].x, data[i][0].y), Point(data[i][1].x, data[i][1].y)));\n\t\t\tif(lt(d, H[i])) {\n\t\t\t\tif(lt(d, Max)) Max = d;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\t\tif(lt(r,Max)) Max = r;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.4llf\\n\", Max);\n}\n\nint main() {\n\twhile(true){\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tinput();\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<complex>\n#include<vector>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP start,end;\nP wolf[50][4];\ndouble h[50];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tint W,Z,X,Y;\n\t\tscanf(\"%d%d\",&X,&Y);\n\t\tstart=P(X,Y);\n\t\tscanf(\"%d%d\",&X,&Y);\n\t\tend=P(X,Y);\n\t\tdouble left=0;\n\t\tdouble right=1000;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d%d%d%d%lf\",&X,&Y,&W,&Z,h+i);\n\t\t\tif((real(start)-X)*(real(start)-W)<=0&&(imag(start)-Y)*(imag(start)-Z)<=0)right=0;\n\t\t\twolf[i][0]=P(X,Y);\n\t\t\twolf[i][1]=P(X,Z);\n\t\t\twolf[i][2]=P(W,Z);\n\t\t\twolf[i][3]=P(W,Y);\n\t\t}\n\t\tfor(int i=0;i<100;i++){\n\t\t\tdouble M=(left+right)/2;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tdouble V=M;\n\t\t\t\tif(h[j]<M)V=sqrt(M*M-(M-h[j])*(M-h[j]));\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(distanceSS(L(start,end),L(wolf[j][k],wolf[j][(k+1)%4]))<V)ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)left=M;\n\t\t\telse right=M;\n\t\t}\n\t\tprintf(\"%f\\n\",left);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e5;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 1;\nstatic const int CCW_ONLINE_FRONT = 1;\nstatic const int CCW_ON_SEGMENT = 1;\n\nstruct Point {\n  double x, y;\n  Point() {}  \n  Point(double x, double y) :x(x), y(y){}\n  Point operator-(Point p) { return Point(x-p.x, y-p.y); }\n  double norm() { return x*x+y*y; }\n  double abs() { return sqrt(norm()); }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n  Point p1, p2;\n  Segment() {}\n  Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nbool intersectSS(Point p1, Point p2, Point p3, Point p4);\nbool intersectSS(Segment s1, Segment s2);\n\ndouble norm(Vector a) {\n  return a.x*a.x+a.y*a.y;  \n}\n\ndouble abs(Vector a) {\n  return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b) {\n  return a.x*b.x+a.y*b.y;  \n}\n\ndouble cross(Vector a, Vector b) {\n  return a.x*b.y-a.y*b.x;  \n}\n\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if ( cross(a, b) > EPS ) return CCW_COUNTER_CLOCKWISE;\n  if ( cross(a, b) < -EPS ) return CCW_CLOCKWISE;\n  if ( dot(a, b) < -EPS ) return CCW_ONLINE_BACK;\n  if ( a.norm() < b.norm() ) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT; \n}\n\nbool intersectSS(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0 );\n}\n\nbool intersectSS(Segment s1, Segment s2) {\n  return intersectSS(s1.p1, s1.p2, s2.p1, s2.p2);  \n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2-l.p1, p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n  if ( dot(s.p2-s.p1, p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if ( dot(s.p1-s.p2, p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s, p);  \n}\n\ndouble getDistanceSS(Segment s1, Segment s2) {\n  if ( intersectSS(s1, s2) ) return 0.0;  \n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p1)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p1)));\t\t \n}\n\nint main() {\n  int N;\n  while ( cin >> N, N ) {\n    Point s, e;\n    cin >> s.x >> s.y >> e.x >> e.y;\n\n    vector<double> h(N);\n    vector<Point> b1(N), b2(N);    \n    for ( int i = 0; i < N; i++ ) {\n      cin >> b1[i].x >> b1[i].y >> b2[i].x >> b2[i].y;\n      cin >> h[i];      \n    }\n\n    double ans = (double)100000.0;\n    Segment se(s, e);    \n    for ( int i = 0; i < N; i++ ) {\n      //cout << ans << endl;\n      Point p1 = b1[i], p2(b1[i].x, b2[i].y), p3 = b2[i], p4(b2[i].x, b1[i].y);      \n      Segment s1(p1, p2), s2(p2, p3), s3(p3, p4), s4(p4, p1);\n      double l = (double)100000.0;\n      if ( min(b1[i].x, b2[i].x) <= s.x && s.x <= max(b1[i].x, b2[i].x) &&\n\t   min(b1[i].y, b2[i].y) <= s.y && s.y <= max(b1[i].y, b2[i].y) ) {\n\tans = 0;\t\n      }\n      if ( min(b1[i].x, b2[i].x) <= e.x && e.x <= max(b1[i].x, b2[i].x) &&\n\t   min(b1[i].y, b2[i].y) <= e.y && e.y <= max(b1[i].y, b2[i].y) ) {\n\tans = 0;\t\n      }\n      l = min(l, getDistanceSS(se, s1));\n      l = min(l, getDistanceSS(se, s2));\n      l = min(l, getDistanceSS(se, s3));\n      l = min(l, getDistanceSS(se, s4));\n      if ( l <= (double)h[i] ) ans = min(ans, l);\n      else ans = min(ans, (l*l+h[i]*h[i])/h[i]/2);      \n    }\n\n    cout << fixed << setprecision(10) << ans << endl;  \n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing msi = map<string, int>;\nusing mii = map<int, int>;\nusing psi = pair<string, int>;\nusing pii = pair<int, int>;\nusing vlai = valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF (ll)1E9\n#define EPS 1E-9\n#define MOD 1000000007\n#define PI 3.1415926535897932384\n\ntemplate <class T>ostream &operator<<(std::ostream &o, const vector<T> &v)\n{\n\trep(i, v.size()) {\n\t\to << (i > 0 ? \" \" : \"\") << v[i];\n\t}\n\treturn o;\n}\n\n//int dx[]={1,1,1,0,-1,-1,-1,0},dy[8]={1,0,-1,-1,-1,0,1,1,1};\n\n//constexpr ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ntypedef double D; \ntypedef complex<D> P;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n\treturn (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n\treturn (conj(a)*b).Y;\n}\n\n// 点の進行方向\nint ccw(P a, P b, P c) {\n\tb -= a;  c -= a;\n\tif (cross(b, c) >  EPS) return +1;  // counter clockwise\n\tif (cross(b, c) < -EPS) return -1;  // clockwise\n\tif (dot(b, c)   < -EPS) return +2;  // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n\treturn 0;                          // a--c--b on line or a==c or b==c\n}\n\n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n\n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n\treturn abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n\n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n\treturn !isecLP(a2 - a1, b2 - b1, 0) || isecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n\treturn cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS;\n}\n\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n\t\tccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n\treturn !ccw(a1, a2, b);\n}\n\n\n/* 距離　各直線・線分は縮退してはならない */\n\n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n\treturn a1 + dot(a2 - a1, p - a1) / norm(a2 - a1) * (a2 - a1);\n}\n\n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n\treturn 2.0*proj(a1, a2, p) - p;\n}\n\nD distLP(P a1, P a2, P p) {\n\treturn abs(proj(a1, a2, p) - p);\n}\n\nD distLL(P a1, P a2, P b1, P b2) {\n\treturn isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n\nD distLS(P a1, P a2, P b1, P b2) {\n\treturn isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n\nD distSP(P a1, P a2, P p) {\n\tP r = proj(a1, a2, p);\n\tif (isecSP(a1, a2, r)) return abs(r - p);\n\treturn min(abs(a1 - p), abs(a2 - p));\n}\n\nD distSS(P a1, P a2, P b1, P b2) {\n\tif (isecSS(a1, a2, b1, b2)) return 0;\n\treturn min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n\t\tmin(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\n// 2直線の交点\nP crosspointLL(P a1, P a2, P b1, P b2) {\n\tD d1 = cross(b2 - b1, b1 - a1);\n\tD d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n\tif (EQ(d2, 0)) throw \"kouten ga nai\";   // 交点がない\n\treturn a1 + d1 / d2 * (a2 - a1);\n}\n\n\n\nvoid solve(int n) {\n\tdouble ans = 100000;\n\tdouble sx, sy, ex, ey;\n\tvector<double> in(4), h(n) ,d(n,100000);\n\tcomplex<double> s, e, vec;\n\tvector<vector<complex<double>>> dat(n, vector<complex<double>>(4));\n\tcin >> sx >> sy >> ex >> ey;\n\ts = { sx,sy }; e = { ex,ey };\n\tvec =  e - s ;\n\tbool sw = false;\n\trep(i, n) {\n\t\tcin >> in[0] >> in[1] >> in[2] >> in[3] >> h[i];\n\t\trep(j, 4) {\n\t\t\tcomplex<double> c = {in[(j/2)*2],in[(j%2)*2+1]};\n\t\t\tdat[i][j] = c;\n\t\t}\n\t\tif (in[0] <= sx&&sx <= in[2] &&\n\t\t\tin[0] <= ex&&ex <= in[2] &&\n\t\t\tin[1] <= sy&&sy <= in[3] &&\n\t\t\tin[1] <= ey&&ey <= in[3]\n\t\t\t)sw = true;\n\t}\n\tif (sw) {\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\trep(i, n) {\n\t\tdouble dist;\n\t\tdist = distSS(dat[i][0], dat[i][1], s, e);\n\t\td[i] = min(d[i], dist);\n\t\tdist = distSS(dat[i][0], dat[i][2], s, e);\n\t\td[i] = min(d[i], dist);\n\t\tdist = distSS(dat[i][1], dat[i][3], s, e);\n\t\td[i] = min(d[i], dist);\n\t\tdist = distSS(dat[i][2], dat[i][3], s, e);\n\t\td[i] = min(d[i], dist);\n\t}\n\t//cout << d << endl;\n\trep(i, n) {\n\t\tdouble r;\n\t\tif (d[i] <= h[i])r = d[i];\n\t\telse {\n\t\t\tr=(h[i] * h[i] + d[i] * d[i]) / (2 * h[i]);\n\t\t}\n\t\tans = min(ans, r);\n\t}\n\tcout << ans << endl;\n\n}\n\nint main(void) {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tsolve(n);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n\treturn p + P(2,0) * (projection(l, p) - p);\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool inner(int x,int X,int y,int Y,int a,int b)\n{\n\treturn x<=a&&a<=X&&y<=b&&b<=Y;\n}\n\nint main()\n{\n\tint n,sx,sy,ex,ey;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tscanf(\"%d%d%d%d\",&sx,&sy,&ex,&ey);\n\t\tL s(P(sx,sy),P(ex,ey));\n\t\tvector<L> l(4,L(P(0,0),P(0,0)));\n\t\t\n\t\tdouble ans=INF;\n\t\trep(i,n)\n\t\t{\n\t\t\tint x,X,y,Y,h; scanf(\"%d%d%d%d%d\",&x,&y,&X,&Y,&h);\n\t\t\tif(inner(x,X,y,Y,sx,sy)||inner(x,X,y,Y,sx,sy))ans=0;\n\t\t\t\n\t\t\tl[0]=L(P(x,y),P(X,y)); l[1]=L(P(x,y),P(x,Y));\n\t\t\tl[2]=L(P(X,y),P(X,Y)); l[3]=L(P(x,Y),P(X,Y));\n\t\t\trep(j,4)\n\t\t\t{\n\t\t\t\tdouble d=distanceSS(s,l[j]);\n\t\t\t\tdouble r=(h*h+d*d)/(2*h);\n\t\t\t\tif(r>=h)ans=min(ans,r);\n\t\t\t\telse ans=min(ans,d);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <sstream>\n#include <complex>\nusing namespace std;\n\n#define REP(i,a,n) for(i=a; i<n; i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define foreach(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); it++)\n#define EPS 1e-8\n\ntypedef complex<double> P;\n\nint n, h[55];\ndouble dist[55];\nconst double inf = 9999999999.9;\n\n\n/*\n  sin = d/b\n  |b|sin = d\n  a X b = |a||b|sin\n  |d| = aXb / |a|\n */\n\ndouble dot(const P& a, const P& b){\n    return (a.real()*b.real() + a.imag()*b.imag());\n}\ndouble cross(const P& a, const P& b){\n    return (a.real()*b.imag() - a.imag()*b.real());\n}\n\n// üªabÆ_cÆÌÅZ£\ndouble lpdist(const P& a, const P& b, const P& c){\n    if( dot(b-a, c-a) < 0.0 ) return abs(c-a);\n    if( dot(a-b, c-b) < 0.0 ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// üªseÆüªabÆÌÅZ£\ndouble lldist(const P& s, const P& e, const P& a, const P& b){\n    double d = inf;\n    // üªseÆ_a,bÆÌ£ðßé\n    d = min(d, lpdist(s,e,a));\n    d = min(d, lpdist(s,e,b));\n\n    // üªabÆ_s,eÆÌ£ðßé\n    d = min(d, lpdist(a,b,s));\n    d = min(d, lpdist(a,b,e));\n    return d;\n}\n\n// üªÌ[_ªubNàÉ¶Ý·é©\nbool inside(const P& s, const P& e, int ix, int iy, int ax, int ay){\n    return ((ix <= s.real() && s.real() <= ax && iy <= s.imag() && s.imag() <= ay) ||\n            (ix <= e.real() && e.real() <= ax && iy <= e.imag() && e.imag() <= ay));\n}\n\n// üªseÆüªabªð·µÄ¢é©\nbool llcr(const P& s, const P& e, const P& a, const P& b){\n    return ( (cross(s-e, a-e) * cross(s-e,b-e) < 0.0) &&\n             (cross(a-b, s-b) * cross(a-b,e-b) < 0.0) );\n}\n\n// ¼arÅS[Å«é©\ndouble sqr(double x){ return x*x; }\n\nbool f(double r){\n    int i;\n    rep(i,n){\n        if( r > (double)h[i] ){\n            if( r*r >= sqr(dist[i]) + sqr(r - (double)h[i]) ) return false;\n        }\n        else{\n            if( dist[i] <= r ) return false;\n        }\n    }\n    return true;\n}\n\n\nint main(){\n    int i,j,k;\n    int ix, iy, ax, ay;\n    P s,e;\n\n    while( cin >> n, n ){\n        bool no = false;\n\n        cin >> s.real() >> s.imag() >> e.real() >> e.imag();\n        rep(i,n){\n            cin >> ix >> iy >> ax >> ay >> h[i];\n            P a(ix,iy), b(ax,ay), c(ix,ay), d(ax,iy);\n            dist[i] = min(min(lldist(s,e,a,c), lldist(s,e,a,d)),\n                          min(lldist(s,e,b,c), lldist(s,e,b,d)));\n\n            if( inside(s,e,ix,iy,ax,ay) ||\n                (llcr(s,e,a,c) || llcr(s,e,a,d) || llcr(s,e,b,c) || llcr(s,e,b,d)) ) no = true;\n        } \n\n        if( no ){\n            printf(\"%lf\\n\",0.0);\n            continue;\n        }\n\n        double l = 0.0, r = 1000.0;\n        rep(i,60){\n            double mid = (l + r) / 2.0;\n            //printf(\"l = %lf,  r = %lf,  mid = %lf\\n\",l,r,mid);\n            if( f(mid) ){\n                l = mid;\n            }\n            else{\n                r = mid;\n            }\n        }\n        printf(\"%lf\\n\",l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nusing Point = complex<double>;\nconst double EPS = 1e-8;\n#define X real()\n#define Y imag()\nnamespace std {\n  bool operator<(const Point a, const Point b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\n// ?????? dot(a,b) = |a||b|cos??\ndouble dot(Point a, Point b){ return a.X*b.X + a.Y*b.Y; }\n// ?????? cross(a,b) = |a||b|sin??\ndouble cross(Point a, Point b){ return a.X*b.Y - a.Y*b.X; }\n\n// AB ???????????? AC???????????????????????????\nint ccw(Point a, Point b, Point c){\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // ccw\n  if (cross(b,c) < -EPS) return -1;  // ccw\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isecSP(Point a1, Point a2, Point b){\n  return !ccw(a1, a2, b);\n}\nbool isecSS(Point a1, Point a2, Point b1, Point b2){\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 && ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// ???p?????´???a1-a2???????°???±???\nPoint proj(Point a1, Point a2, Point p){\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\ndouble distLP(Point a1, Point a2, Point p){\n  return abs(proj(a1, a2, p) - p);\n}\n\ndouble distSP(Point a1, Point a2, Point p){\n  Point r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n\ndouble distSS(Point a1, Point a2, Point b1, Point b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)), min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\n\nint main(){\n  int n;\n  while(cin>>n, n){\n    double sx,sy,tx,ty;\n    cin>>sx>>sy>>tx>>ty;\n    Point s(sx,sy), t(tx,ty);\n\n    auto calc = [&](Point p1, Point p2, double h){\n      double d = distSS(s, t, p1, p2);\n      if(d <= h) return d;\n      else return (h*h + d*d)/2.0/h;\n    };\n\n    double ans = 123456789;\n    rep(_,n){\n      double x[2],y[2],h;\n      cin>>x[0]>>y[0]>>x[1]>>y[1]>>h;\n      if(isecSS(s, t, Point(x[0],y[0]), Point(x[1],y[1])) ||\n         isecSS(s, t, Point(x[0],y[1]), Point(x[1],y[0])) ){\n        ans = 0;\n        continue;\n      }\n      vector<Point> v;\n      rep(i,2)rep(j,2) v.pb(Point(x[i],y[j]));\n      swap(v[2],v[3]);\n      v.pb(v[0]);\n\n      rep(i,4){\n        ans = min(ans, calc(v[i], v[i+1], h));\n      }\n    }\n\n    printf(\"%.9f\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ninline double sq(double x) { return x * x; }\n\nstruct point {\n    double x, y, z;\n    point() {}\n    point(double x, double y, double z): x(x), y(y), z(z) {}\n    point operator + (const point& o) const { return point(x+o.x, y+o.y, z+o.z); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y, z-o.z); }\n    point operator * (const double a) const { return point(x*a,   y*a,   z*a); }\n};\n\ndouble fabs(point p) { return sqrt(sq(p.x) + sq(p.y) + sq(p.z)); }\ndouble dist(point p, point q) { return fabs(p - q); }\ndouble dot(point p, point q) { return p.x*q.x + p.y*q.y + p.z*q.z; }\npoint cross(point p, point q) {\n    return point(\n        p.y*q.z - p.z*q.y,\n        p.z*q.x - p.x*q.z,\n        p.x*q.y - p.y*q.x\n    );\n}\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\ndouble dist_point_line(point p, line l) {\n    if (dot(l.b - l.a, p - l.a) >= 0 && dot(l.a - l.b, p - l.b) >= 0) {\n        point h = l.a + (l.b - l.a) * (dot(l.b - l.a, p - l.a) / sq(fabs(l.b - l.a)));\n        return dist(p, h);\n    }\n\n    return min(dist(p, l.a), dist(p, l.b));\n}\n\nint N; double Sx, Sy, Ex, Ey;\nvector<vector<point>> rects;\nvector<line> vs;\n\ndouble solve() {\n    line c(point(Sx, Sy, 0), point(Ex, Ey, 0));\n    for (vector<point> r : rects) {\n        for (int i = 0; i < 4; ++i) {\n            for (int j = i+1; j < 4; ++j) {\n                double c1 = cross(c.b - c.a, r[i] - c.a).z * cross(c.b - c.a, r[j] - c.a).z;\n                double c2 = cross(r[j] - r[i], c.a - r[i]).z * cross(r[j] - r[i], c.b - r[i]).z;\n                if (c1 <= 0 && c2 <= 0)\n                    return 0;\n            }\n        }\n    }\n\n    double l = 0, r = 1050;\n    for (int g = 0; g < 100; ++g) {\n        double m = (l + r) / 2;\n\n        line c(point(Sx, Sy, m), point(Ex, Ey, m));\n\n        bool ok = true;\n        for (line p : vs) {\n            if (m < p.a.z) p.a.z = p.b.z = m;\n            if (dist_point_line(p.a, c) <= m || dist_point_line(p.b, c) <= m)\n                ok = false;\n\n            if (dist_point_line(c.a, p) <= m || dist_point_line(c.b, p) <= m)\n                ok = false;\n\n            double c1 = cross(c.b - c.a, p.a - c.a).z * cross(c.b - c.a, p.b - c.a).z;\n            double c2 = cross(p.b - p.a, c.a - p.a).z * cross(p.b - p.a, c.b - p.a).z;\n\n            if (c1 <= 0 && c2 <= 0)\n                ok = false;\n        }\n\n        (ok ? l : r) = m;\n    }\n\n    return (l + r) / 2;\n}\n\nint main(void) {\n    cout << fixed << setprecision(10);\n    while (true) {\n        cin >> N; if (N == 0) break;\n        cin >> Sx >> Sy >> Ex >> Ey;\n        vs.clear();\n        rects.clear();\n        for (int i = 0; i < N; ++i) {\n            double minx, miny, maxx, maxy, h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            vs.emplace_back(point(minx, miny, h), point(minx, maxy, h));\n            vs.emplace_back(point(minx, miny, h), point(maxx, miny, h));\n            vs.emplace_back(point(minx, maxy, h), point(maxx, maxy, h));\n            vs.emplace_back(point(maxx, miny, h), point(maxx, maxy, h));\n\n            vector<point> vv;\n            vv.emplace_back(minx, miny, h);\n            vv.emplace_back(minx, maxy, h);\n            vv.emplace_back(maxx, miny, h);\n            vv.emplace_back(maxx, maxy, h);\n            rects.push_back(vv);\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-7;\nconst double PI  = acos(-1.0);\n\n#define M INT_MAX\nstruct P{\n  double x;\n  double y;\n\n  P(){\n\tx=M; y=M;\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n\n};\ndouble dot(P a,P b){\n  return (a.x*b.x+a.y*b.y);\n}\n\ndouble cross(P a,P b){\n  return (a.x*b.y-a.y*b.x);\n}\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\ndouble psd(P p , P a , P b){\n  if( dot( b-a , p-a ) < EPS) return fabs(dis(p-a));\n  if( dot( a-b , p-b ) < EPS) return fabs(dis(p-b));\n  return fabs(cross( b-a , p-a )) / fabs(dis(b-a));\n}\n\nbool intersect_s(P a1 , P a2 , P b1 , P b2){\n  return ( cross(a2-a1 , b1-a1)*cross(a2-a1 , b2-a1) < EPS) &&\n\t( cross(b2-b1 , a1-b1)*cross(b2-b1 , a2-b1) < EPS);\n}\n\nbool isin(P p, P a1, P a2){\n  double mx = min(a1.x, a2.x), Mx = max(a1.x, a2.x);\n  double my = min(a1.y, a2.y), My = max(a1.y, a2.y);\n  return mx < p.x && p.x < Mx\n\t&& my < p.y  && p.y < My;\n}\n\nint main(){\n  int N;\n  while(cin>>N,N){\n\tP s, e;\n\tvector< vector<P> > ps(N, vector<P>(4));\n\tvector<double> h(N), d(N, M);\n\tcin >> s.x >> s.y >> e.x >> e.y;\n\tREP(i,N)\n\t  cin >> ps[i][0].x >> ps[i][0].y >> ps[i][2].x >> ps[i][2].y >> h[i];\n\tREP(i,N){\n\t  ps[i][1].x = ps[i][0].x;\n\t  ps[i][1].y = ps[i][2].y;\n\n\t  ps[i][3].x = ps[i][2].x;\n\t  ps[i][3].y = ps[i][0].y;\n\t}\n\n\tREP(i,N) REP(j,4){\n\t  d[i] = min(d[i], dis(ps[i][j] - s));\n\t  d[i] = min(d[i], dis(ps[i][j] - e));\n\t  d[i] = min(d[i], psd(ps[i][j], s, e));\n\t  d[i] = min(d[i], psd(s, ps[i][j], ps[i][(j+1)%4]));\n\t  d[i] = min(d[i], psd(e, ps[i][j], ps[i][(j+1)%4]));\n\t}\n\n\tdouble r_lb = 0., r_ub = 1000.;\n\tREP(i,N) REP(j,4){\n\t  if(intersect_s(s,e,ps[i][j],ps[i][(j+1)%4]))\n\t\tr_ub = 0.;\n\t  if(isin(s, ps[i][0], ps[i][2]) || isin(e, ps[i][0], ps[i][2]))\n\t\tr_ub = 0.;\n\t}\n\n\tREP(i,100){\n\t  bool flag = true;\n\t  double r = (r_lb + r_ub) / 2.;\n\t  REP(j,N){\n\t\tif(r < d[j]) continue;\n\t\tif(r < h[j] || d[j]*d[j]+h[j]*h[j] - 2*r*h[j] < 0){\n\t\t  flag = false;\n\t\t  break;\n\t\t}\n\t  }\n\n\t  if(flag) r_lb = r;\n\t  else r_ub = r;\n\t}\n\n\tcout << fixed << setprecision(6) << r_lb << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing msi = map<string, int>;\nusing mii = map<int, int>;\nusing psi = pair<string, int>;\nusing pii = pair<int, int>;\nusing vlai = valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF (ll)1E9\n#define EPS 1E-9\n#define MOD 1000000007\n#define PI 3.1415926535897932384\n\ntemplate <class T>ostream &operator<<(std::ostream &o, const vector<T> &v)\n{\n\trep(i, v.size()) {\n\t\to << (i > 0 ? \" \" : \"\") << v[i];\n\t}\n\treturn o;\n}\n\n//int dx[]={1,1,1,0,-1,-1,-1,0},dy[8]={1,0,-1,-1,-1,0,1,1,1};\n\n//constexpr ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ntypedef double D; \ntypedef complex<D> P;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n\treturn (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n\treturn (conj(a)*b).Y;\n}\n\n// 点の進行方向\nint ccw(P a, P b, P c) {\n\tb -= a;  c -= a;\n\tif (cross(b, c) >  EPS) return +1;  // counter clockwise\n\tif (cross(b, c) < -EPS) return -1;  // clockwise\n\tif (dot(b, c)   < -EPS) return +2;  // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n\treturn 0;                          // a--c--b on line or a==c or b==c\n}\n\n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n\n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n\treturn abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n\n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n\treturn !isecLP(a2 - a1, b2 - b1, 0) || isecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n\treturn cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS;\n}\n\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n\t\tccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n\treturn !ccw(a1, a2, b);\n}\n\n\n/* 距離　各直線・線分は縮退してはならない */\n\n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n\treturn a1 + dot(a2 - a1, p - a1) / norm(a2 - a1) * (a2 - a1);\n}\n\n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n\treturn 2.0*proj(a1, a2, p) - p;\n}\n\nD distLP(P a1, P a2, P p) {\n\treturn abs(proj(a1, a2, p) - p);\n}\n\nD distLL(P a1, P a2, P b1, P b2) {\n\treturn isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n\nD distLS(P a1, P a2, P b1, P b2) {\n\treturn isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n\nD distSP(P a1, P a2, P p) {\n\tP r = proj(a1, a2, p);\n\tif (isecSP(a1, a2, r)) return abs(r - p);\n\treturn min(abs(a1 - p), abs(a2 - p));\n}\n\nD distSS(P a1, P a2, P b1, P b2) {\n\tif (isecSS(a1, a2, b1, b2)) return 0;\n\treturn min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n\t\tmin(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\n// 2直線の交点\nP crosspointLL(P a1, P a2, P b1, P b2) {\n\tD d1 = cross(b2 - b1, b1 - a1);\n\tD d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n\tif (EQ(d2, 0)) throw \"kouten ga nai\";   // 交点がない\n\treturn a1 + d1 / d2 * (a2 - a1);\n}\n\n\n\nvoid solve(int n) {\n\tdouble ans = 100000;\n\tdouble sx, sy, ex, ey;\n\tvector<double> in(4), h(n) ,d(n,100000);\n\tcomplex<double> s, e, vec;\n\tvector<vector<complex<double>>> dat(n, vector<complex<double>>(4));\n\tcin >> sx >> sy >> ex >> ey;\n\ts = { sx,sy }; e = { ex,ey };\n\tvec =  e - s ;\n\tbool sw = false;\n\trep(i, n) {\n\t\tcin >> in[0] >> in[1] >> in[2] >> in[3] >> h[i];\n\t\trep(j, 4) {\n\t\t\tcomplex<double> c = {in[(j/2)*2],in[(j%2)*2+1]};\n\t\t\tdat[i][j] = c;\n\t\t}\n\t\tif (in[0] <= sx&&sx <= in[2] &&\n\t\t\tin[0] <= ex&&ex <= in[2] &&\n\t\t\tin[1] <= sy&&sy <= in[3] &&\n\t\t\tin[1] <= ey&&ey <= in[3]\n\t\t\t)sw = true;\n\t}\n\tif (sw) {\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\trep(i, n) {\n\t\tdouble dist;\n\t\tdist = distSS(dat[i][0], dat[i][1], s, e);\n\t\td[i] = min(d[i], dist);\n\t\tdist = distSS(dat[i][0], dat[i][2], s, e);\n\t\td[i] = min(d[i], dist);\n\t\tdist = distSS(dat[i][1], dat[i][3], s, e);\n\t\td[i] = min(d[i], dist);\n\t\tdist = distSS(dat[i][2], dat[i][3], s, e);\n\t\td[i] = min(d[i], dist);\n\t}\n\t//cout << d << endl;\n\trep(i, n) {\n\t\tdouble r;\n\t\tif (d[i] <= h[i])r = d[i];\n\t\telse {\n\t\t\tr=(h[i] * h[i] + d[i] * d[i]) / (2 * h[i]);\n\t\t}\n\t\tans = min(ans, r);\n\t}\n\tcout << setprecision(15) <<ans << endl;\n\n}\n\nint main(void) {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tsolve(n);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ndouble add(double a,double b){\n\tif(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{\n\tdouble x,y;\n\tP() {}\n\tP(double x,double y) : x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tdouble norm(){\n\t\treturn sqrt(x*x+y*y);\n\t}\n\tdouble norm2(){\n\t\treturn x*x+y*y;\n\t}\n\tdouble dist2(P p){\n\t\treturn sq(x-p.x)+sq(y-p.y);\n\t}\n\tP vert(){\n\t\treturn P(y,-x);\n\t}\n\tvoid dump(){\n\t\tprintf(\"%.12f %.12f\\n\",x,y);\n\t\treturn;\n\t}\n};\nint N;\nP s,e;\nP v[5][55];\ndouble sx,sy,ex,ey;\ndouble minx[55],miny[55],maxx[55],maxy[55],h[55];\nbool check(){\n\tfor(int i=0;i<N;i++){\n\t\tdouble a = minx[i];\n\t\tdouble b = maxx[i];\n\t\tdouble c = miny[i];\n\t\tdouble d = maxy[i];\n\t\tif(a<=sx&&sx<=b&&c<=sy&&sy<=d&&a<=ex&&ex<=b&&c<=ey&&ey<=d)return true;\n\t\tP t1 = v[1][i]-s;\n\t\tP t2 = v[2][i]-s;\n\t\tP t3 = v[3][i]-s;\n\t\tP t4 = v[4][i]-s;\n\t\tif((sx-a)*(ex-a)<=0&&(e-s).det(t1)*(e-s).det(t4)<=0.0)return true;\n\t\tif((sx-b)*(ex-b)<=0&&(e-s).det(t2)*(e-s).det(t3)<=0.0)return true;\n\t\tif((sy-c)*(ey-c)<=0&&(e-s).det(t1)*(e-s).det(t2)<=0.0)return true;\n\t\tif((sx-d)*(ex-d)<=0&&(e-s).det(t3)*(e-s).det(t4)<=0.0)return true;\n\t}\n\treturn false;\n}\ndouble func(double x,double height){\n\tif(x<height)return x;\n\telse return (sq(height)+sq(x))/(2.0*height);\n}\nint solve(){\n\tscanf(\"%d\",&N);\n\tif(N==0)return 1;\n\tscanf(\"%lf %lf %lf %lf\",&sx,&sy,&ex,&ey);\n\ts = P(sx,sy); e = P(ex,ey);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%lf %lf %lf %lf %lf\",&minx[i],&miny[i],&maxx[i],&maxy[i],&h[i]);\n\t\tdouble a = minx[i], b = maxx[i], c = miny[i], d = maxy[i];\n\t\tv[1][i]=P(a,c);\n\t\tv[2][i]=P(b,c);\n\t\tv[3][i]=P(b,d);\n\t\tv[4][i]=P(a,d);\n\t}\n\tif(check()){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tdouble ans = 1145.141919;\n\tfor(int i=0;i<N;i++){\n\t\tif(minx[i]<=sx&&sx<=maxx[i]){\n\t\t\tans = min(ans,func(abs(sy-miny[i]),h[i]));\n\t\t\tans = min(ans,func(abs(sy-maxy[i]),h[i]));\n\t\t}\n\t\tif(miny[i]<=sy&&sy<=maxy[i]){\n\t\t\tans = min(ans,func(abs(sx-minx[i]),h[i]));\n\t\t\tans = min(ans,func(abs(sx-maxx[i]),h[i]));\n\t\t}\n\t\tif(minx[i]<=ex&&ex<=maxx[i]){\n\t\t\tans = min(ans,func(abs(ey-miny[i]),h[i]));\n\t\t\tans = min(ans,func(abs(ey-maxy[i]),h[i]));\n\t\t}\n\t\tif(miny[i]<=ey&&ey<=maxy[i]){\n\t\t\tans = min(ans,func(abs(ex-minx[i]),h[i]));\n\t\t\tans = min(ans,func(abs(ex-maxx[i]),h[i]));\n\t\t}\n\t\tfor(int j=1;j<=4;j++){\n\t\t\tP a = v[j][i]-s;\n\t\t\tP b = e-s;\n\t\t\tdouble Sa = a.norm();\n\t\t\tans = min(ans,func(Sa,h[i]));\n\t\t\tdouble D = a.dot(b);\n\t\t\tdouble Sb2 = b.norm2();\n\t\t\tif(!(D>=0.0&&D<=Sb2))continue;\n\t\t\tdouble x = (a-b*(D/Sb2)).norm();\n\t\t\tans = min(ans,func(x,h[i]));\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",ans);\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<complex>\n\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define min_int(a,b) ((a)<(b)?(a):(b))\n#define INF 10000000 //2^31\n#define EPS (1e-9)\n#define EQ(a,b) (abs((a)-(b))<EPS)\nusing namespace std;\n\nclass Gio{\nprivate:\n\ttypedef complex<double>point;\n\tstruct line{ \n\t\tpoint st, ed;//始点,終点\n\t};\n\tpoint min_p,max_p;\n\tline orig, test;\n\tdouble min_R;//保存用\n\tdouble test_R;//実行用\n\tdouble dot(point a, point b);//内積\n\tdouble cross(point a, point b);//外積\n\npublic:\n\tGio(double sx, double sy,double ex,double ey);\n\tvoid set_p(point* p, double x, double y);\n\tvoid set_line(line* l, point s, point e);\n\tvoid set_testline(double sx, double sy, double ex, double ey);\n\tvoid calc_r(double sx,double sy,double lx,double ly,double h);\n\tdouble get_r();\n\tdouble get_d_pp();//min_pとmax_pの距離を返す\n\tdouble get_d_lp();//min_pとtestの長さを返す\n\tdouble get_d_ll();//origとtestの長さを返す\n\tbool intersect();//origとtestが交差していればtrue\n};\n\nGio::Gio(double sx, double sy, double ex, double ey){\n\tset_p(&min_p, sx, sy);\n\tset_p(&max_p, ex, ey);\n\tset_line(&orig, min_p, max_p);\n\tmin_R = INF;\n}\nvoid Gio::set_p(point *p, double x, double y){\n\tpoint a(x, y);\n\t*p = a;\n}\nvoid Gio::set_line(line* l, point s, point e){\n\tl->st = s;\n\tl->ed=e;\n}\nvoid Gio::set_testline(double sx,double sy,double ex,double ey){\n\tpoint a, b;\n\tset_p(&a, sx, sy); set_p(&b, ex, ey);\n\tset_line(&test, a, b);\n\t//printf(\"%lf,%lf\\n\", test.st.real(), test.st.imag());\n}\ndouble Gio::dot(point a, point b){\n\treturn(a.real()*b.real() + a.imag()*b.imag());\n}\ndouble Gio::cross(point a, point b){\n\treturn(a.real()*b.imag() - a.imag()*b.real());\n}\ndouble Gio::get_d_pp(){ return(abs(max_p - min_p)); }\ndouble Gio::get_d_lp(){\n\tpoint a = test.st;\n\tpoint b = test.ed;\n\tpoint c = min_p;\n\tif (dot(b - a, c - a) < EPS)return(abs(c - a));\n\tif (dot(a - b, c - b) < EPS)return(abs(c - b));\n\treturn(abs(cross(b - a, c - a)) / abs(b - a));\n}\nbool Gio::intersect(){\n\tpoint a = orig.st, b = orig.ed, c = test.st, d = test.ed;\n\treturn(abs((cross(b - a, c - a)*cross(b - a, d - a)) < EPS) && abs((cross(d - c, a - c)*cross(d - c, b - c)) < EPS));\n}\n\ndouble Gio::get_d_ll(){\n\tif (intersect())return(0);\n\tpoint a0, a1,b0,b1;\n\ta0 = orig.st;\n\ta1 = orig.ed;\n\tb0 = test.st;\n\tb1 = test.ed;\n\tdouble d1, d2, d3, d4;\n\tmin_p = a0; d1 = get_d_lp();\n\tmin_p = a1; d2 = get_d_lp();\n\tset_line(&test, a0, a1);\n\tmin_p = b0; d3 = get_d_lp();\n\tmin_p = b1; d4 = get_d_lp();\n\td1 = min_int(d1, d2);\n\td2 = min_int(d3, d4);\n\treturn(min_int(d1, d2));\n}\n\nvoid Gio::calc_r(double sx, double sy, double lx, double ly,double h){\n\tdouble d1, d2, d3, d4;\n\tpoint p = orig.st;\n\tif (sx <= p.real() && p.real() <= lx&&sy <= p.imag()&&p.imag() <= ly){\n\t\tmin_R = 0; return;\n\t}\n\n\tset_testline(sx, sy, sx, ly); d1 = get_d_ll();\n\tset_testline(sx, sy, lx, sy); d2 = get_d_ll();\n\tset_testline(sx, ly, lx, ly); d3 = get_d_ll();\n\tset_testline(lx, sy, lx, ly); d4 = get_d_ll();\n\td1 = min_int(min_int(d1, d2), min_int(d3, d4));\n\tif (h >= d1)test_R = d1;\n\telse{\n\t\ttest_R = ((d1*d1 + h*h) / h) / 2;\n\t}\n\tmin_R = min_int(min_R, test_R);\n}\ndouble Gio::get_r(){\n\treturn(min_R);\n}\n\nint b_num;\n\n\n\nint main(void){\n\t//Gio g(1, 1, 2, 2);\n\t//g.set_testline(1, 2, 2, 3);\n\t//cout << g.get_d_ll()<<endl;\n\twhile (true){\n\t\tcin >> b_num;\n\t\tif (b_num == 0)return(0);\n\t\tdouble sx, sy, ex, ey,h;\n\t\tcin >> sx >> sy>>ex >> ey;\n\t\tGio g(sx, sy, ex, ey);\n\t\trep(i, 0, b_num){\n\t\t\tcin >> sx >> sy >> ex >> ey>>h;\n\t\t\tg.calc_r(sx, sy, ex, ey, h);\n\t\t}\n\n\t\tprintf(\"%.10lf\\n\", g.get_r());\n\n\t}\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\n#define EPS (1e-9)\nusing namespace std;\ntypedef complex<double> point;\n\ndouble dot(point a,point b){return a.x*b.x+a.y+b.y;}\ndouble cross(point a,point b){return a.x*b.y-a.y*b.x;}\n\nint ccw(point a,point b,point c){\n  point d=b-a;\n  point e=c-a;\n  if(cross(d,e)>0)return 1;\n  if(cross(d,e)<0)return -1;\n  if(dot(d,e)<0)return 2;\n  if(abs(d)<abs(e))return -2;\n  return 0;\n}\n\nbool intersection(point a,point b,point c,point d){\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n}\n\ndouble getDistance(point a,point b,point p){\n  if(dot(b-a,p-a)<-EPS) return abs(p-a);\n  if(dot(a-b,p-b)<-EPS) return abs(p-b);\n  return abs(cross(b-a,p-a)/abs(b-a));\n}\n\nint main(){\n  int n,h,a,b,c,d;\n  double ans,dis;\n  point s,g;\n  while(1){\n    cin>>n;\n    if(!n)break;\n    ans=(1e9);\n    cin>>s.x>>s.y>>g.x>>g.y;\n    while(n--){\n      cin>>a>>b>>c>>d>>h;\n      if(intersection(s,g,point(a,b),point(c,b)))ans=0;\n      if(intersection(s,g,point(a,b),point(a,d)))ans=0;\n      if(intersection(s,g,point(c,d),point(c,b)))ans=0;\n      if(intersection(s,g,point(c,d),point(a,d)))ans=0;\n      dis=getDistance(s,g,point(a,b));\n      dis=min(dis,getDistance(s,g,point(c,d)));\n      dis=min(dis,getDistance(s,g,point(c,b)));\n      dis=min(dis,getDistance(s,g,point(a,d)));\n      if(dis>h)ans=min(ans,(dis*dis+h*h)/(2*h));\n      else ans=min(ans,dis);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n#include<complex>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nconst double EPS=1e-7; //うまくいかなかったらゆるめる\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C {\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n  C(){;}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b) {\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b) {\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\nvoid printP(const P &p){\n  cout << shosu(10) << p.real() << \" \" << p.imag() << endl;\n}\n\nvoid printL(const L &l) {\n  \tcout << shosu(10) << l[0].real() << \" \" << l[0].imag() << \" \" << l[1].real() << \" \" << l[1].imag() << endl;\n}\n\nvoid printG(const G &g) {\n  for(int i = 0; i < g.size(); i++){\n    cout << shosu(10) << g[i].real() << \" \" << g[i].imag() << endl;\n  }\n}\n\nP inP(){\n  double x,y;\n//  scanf(\"%lf,%lf\", &x, &y);\n  cin >> x >> y;\n  P p(x,y);\n  return p;\n}\n\nL inL(){\n  P p1 = inP();\n  P p2 = inP();\n  L l(p1,p2);\n  return l;\n}\n\ndouble dot(P a,P b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b) {\n  return imag(conj(a)*b);\n}\n\nP projection(const L &l, const P &p) { //pの直線l上の射影の点\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nint ccw(P a, P b, P c) { //3点の関係性\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\nbool intersectSP(const L &s, const P &p) { //直線と点の交差判定\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // 三角不等式\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\ndouble distanceSP(const L &s, const P &p) {//直線と点との距離\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {//2線分の距離\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nbool intersectSL(const L &s, const L &l){\n    return cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]) < EPS;\n}\n\n\n\ndouble distanceGL(const G &g, const L &l){//凸多角形と直線の距離\n    double ret = LINF;\n    int n = g.size();\n    rep(i,n){\n        L l2(g[i],g[(i+1)%n]);\n        ret = min(ret, distanceSS(l2,l));\n    }\n    return ret;\n}\n\nint inconvex(const G& g, const P& p) { //多角形と点の関係\n\tbool in = false;\n\tint n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tP a = g[i%n] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif(imag(a) > imag(b)) swap(a, b);\n\t\tif(imag(a) < EPS && 0 < imag(b))if(cross(a,b) < 0)in = !in;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;//ON\n\t}\n\treturn in ? 2 : 0;//IN : OUT;\n}\n\nsigned main(void) {\n    int n;\n    while(cin >> n,n){\n        L l = inL();\n        vector<double> h(n),d(n);\n        rep(i,n){\n            int minx,miny,maxx,maxy;\n            cin >> minx >> miny >> maxx >> maxy >> h[i];\n            G g(4);\n            P a(minx,miny),b(minx,maxy),c(maxx,maxy),e(maxx,miny);\n            g[0] = a, g[1] = b, g[2] = c, g[3] = e;\n            if(inconvex(g,l[0]) || inconvex(g,l[1]))d[i] = 0;\n            else d[i] = distanceGL(g,l);\n        }\n        //rep(i,n)cout << shosu(10) << h[i] << \" \" << d[i] << endl;\n\n        double ok = 0, ng = 1005;\n        while(abs(ok - ng) > EPS){\n            double mid = (ok + ng)/2;\n            bool c = true;\n            rep(i,n){\n                if(h[i] >= mid){\n                    if(d[i] < mid)c = false;\n                }else{\n                    if(mid*mid > (mid-h[i])*(mid-h[i]) + d[i]*d[i])c = false;\n                }\n            }\n            if(c) ok = mid;\n            else ng = mid;\n        }\n        cout << shosu(10) << ok << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cxxabi.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    ((ll)1ll<60)\n#define INF     ((int)1<<30)\n#define EPS     (1e-3)\n#define MOD     (1000000007)\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool b=1;for(auto s:t)os<<(exchange(b,0)||strlen(abi::__cxa_demangle(typeid(S).name(),0,0,0))>20?\"\":\" \")<<s;return os<<endl;}\n\nusing D=double;\nusing P=complex<double>;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n\nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\nconstexpr bool inner(double l, double r, double v){\n    return min(l,r)<=v and v<=max(l,r);\n}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint n;\n\twhile(cin>>n,n){\n\t    double ax,ay,bx,by;\n\t\tcin>>ax>>ay>>bx>>by;\n\t\tP s(ax,ay),g(bx,by);\n\n\t\tdouble ans=1e9;\n\t\trep(i,n){\n    \t\tvector<P> r;\n    \t\tint h;\n\t\t    cin>>ax>>ay>>bx>>by>>h;\n\t\t    r={P(ax,ay),P(ax,by),P(bx,by),P(bx,ay)};\n\t\t    double dist=1e9;\n            if(inner(ax,bx,s.X) and inner(ax,bx,g.X) and inner(ay,by,s.Y) and inner(ay,by,g.Y)) dist=0;\n\t\t    rep(i,4){\n\t\t        dist=min(dist,distSS(s,g,r[i],r[(i+3)%4]));\n\t\t        if(isecSS(s,g,r[i],r[(i+3)%4]))dist=0;\n\t\t    }\n\t\t    if(LE(dist,h)) ans=min(ans,dist);\n\t\t    else ans=min(ans,(h*h+dist*dist)/2/h);\n\t\t}\n\t\tcout.precision(4);\n\t\tcout<<fixed<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n\n#define fr first\n#define sc second\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point,vec;\ntypedef pair<point,point> pp,seg,line;\n\nconst elem eps = 1.0e-10;\nconst elem infty = 1.0e+18;\n\ninline bool eq(elem a, elem b){return abs(b-a) < eps;}\ninline bool leq(elem a, elem b){return eq(a,b) || a < b;}\ninline bool geq(elem a, elem b){return eq(a,b) || a > b;}\ninline bool lt(elem a, elem b){return !eq(a,b) && a < b;}\ninline bool gt(elem a, elem b){return !eq(a,b) && a > b;}\ninline bool ltz(elem a){return lt(a,0);}\ninline bool gtz(elem a){return gt(a,0);}\ninline elem emax(elem a, elem b){return gt(a,b)?a:b;}\ninline elem emin(elem a, elem b){return lt(a,b)?a:b;}\ninline elem dot(point a, point b){return a.real()*b.real() + a.imag()*b.imag();}\ninline elem cross(point a, point b){return a.real()*b.imag()-a.imag()*b.real();}\ninline elem dist_l(line l,point x){ return abs(cross(l.sc-l.fr,x-l.fr))/abs(l.sc-l.fr); }\ninline elem dist_seg(seg s, point x){\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\ninline bool intersected_seg(seg a, seg b){\n  return ( leq( cross(a.sc-a.fr,b.fr-a.fr) * cross(a.sc-a.fr,b.sc-a.fr), 0) &&\n\t   leq( cross(b.sc-b.fr,a.fr-b.fr) * cross(b.sc-b.fr,a.sc-b.fr), 0 ) );\n}\ninline int ccw(point a, point b, point x){\n  b-=a;x-=a;\n  if(gtz(cross(b,x)))return LEFT;\n  if(ltz(cross(b,x)))return RIGHT;\n  if(ltz(dot(b,x)))return BACK;\n  if(abs(b)<abs(x))return FRONT;\n  return OVER;\n}\n\nclass cuboid{\npublic:\n  elem h;\n  elem minx, miny;\n  elem maxx, maxy;\n  point tl,bl,tr,br;\n  cuboid():minx(0),miny(0),\n\t maxx(0),maxy(0),h(0){}\n  cuboid(elem minx, elem miny, elem maxx, elem maxy,elem h):\n    minx(minx),miny(miny),\n    maxx(maxx),maxy(maxy),h(h),\n    tl(minx,maxy),bl(minx,miny),tr(maxx,maxy),br(maxx,miny){}\n  bool intersected_seg(seg l){\n    if( ::intersected_seg(l,seg(tl,tr)) ||\n\t::intersected_seg(l,seg(tl,bl)) ||\n\t::intersected_seg(l,seg(tr,br)) ||\n\t::intersected_seg(l,seg(bl,br)) ) return true;\n    return false;\n  }\n  bool contain_seg(seg l){\n    if( ccw(bl,br,l.fr)&(OVER|LEFT) &&\n\tccw(br,tr,l.fr)&(OVER|LEFT) &&\n\tccw(tr,tl,l.fr)&(OVER|LEFT) &&\n\tccw(tl,bl,l.fr)&(OVER|LEFT)\n\t&&\n\tccw(bl,br,l.sc)&(OVER|LEFT) &&\n\tccw(br,tr,l.sc)&(OVER|LEFT) &&\n\tccw(tr,tl,l.sc)&(OVER|LEFT) &&\n\tccw(tl,bl,l.sc)&(OVER|LEFT) ) return true;\n    return false;\n  }\n  elem getMinimumDistance(seg l){\n    elem ret = infty;\n    ret = emin( ret, dist_seg( l, tl ) );\n    ret = emin( ret, dist_seg( l, tr ) );\n    ret = emin( ret, dist_seg( l, bl ) );\n    ret = emin( ret, dist_seg( l, br ) );\n    ret = emin( ret, dist_seg( seg(tl,tr), l.fr ) );\n    ret = emin( ret, dist_seg( seg(tl,tr), l.sc ) );\n    ret = emin( ret, dist_seg( seg(tl,bl), l.fr ) );\n    ret = emin( ret, dist_seg( seg(tl,bl), l.sc ) );\n    ret = emin( ret, dist_seg( seg(bl,br), l.fr ) );\n    ret = emin( ret, dist_seg( seg(bl,br), l.sc ) );\n    ret = emin( ret, dist_seg( seg(tr,br), l.fr ) );\n    ret = emin( ret, dist_seg( seg(tr,br), l.sc ) );\n    return ret;\n  }\n  elem getRwithSphere(seg l){\n    if(contain_seg(l) || intersected_seg(l))return 0;\n    elem d = getMinimumDistance(l);\n    if(eq(d,0))return 0;\n    elem theta = 2*atan(h/d);\n    elem ret = sqrt( (pow(d,2)+pow(h,2))/(2*(1-cos(theta))) );\n    return ret;\n  }\n};\n\nint main(){\n  while(true){\n    int n;\n    elem ans = infty;\n    elem sx,sy,ex,ey;\n    vector<cuboid> vcubo;\n    scanf(\"%d\",&n);\n    if(n == 0) return 0;\n    scanf(\"%lf%lf%lf%lf\",&sx,&sy,&ex,&ey);\n    point S(sx,sy), E(ex,ey);\n    for(int i = 0; i < n; ++i){\n      elem minx, miny, maxx, maxy, h;\n      scanf(\"%lf%lf%lf%lf%lf\",\n\t    &minx,&miny,&maxx,&maxy,&h);\n      vcubo.push_back( cuboid(minx,miny,maxx,maxy,h) );\n    }\n    for(int i = 0; i < n; ++i){\n      ans = emin( ans, vcubo[i].getRwithSphere( seg(S,E) ) );\n    }\n    printf(\"%.7lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\nusing namespace std;\n#define EPS (1e-8)\n#define INF (1e8)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n\nclass Point{\npublic:\n  double x, y;  \n  Point (double x = 0, double y = 0): x(x), y(y){}\n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n};\ndouble norm(Point a){ return a.x*a.x + a.y*a.y; }\ndouble abs(Point a){ return sqrt(norm(a)); }\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble getDistanceLP(Point s1,Point s2,Point p){\n  return abs(cross(s2-s1,p-s1)/abs(s2-s1));\n}\ndouble getDistanceSP(Point s1,Point s2,Point p){\n  if(dot(s2-s1,p-s1)<0.0)return abs(p-s1);\n  if(dot(s1-s2,p-s2)<0.0)return abs(p-s2);\n  return getDistanceLP(s1,s2,p);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw( Point p0, Point p1, Point p2 ){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n  if ( cross(a, b) < -EPS ) return CLOCKWISE;\n  if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n  if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersectSS(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n\ndouble getDistanceSS(Point s1,Point s2,Point t1,Point t2){\n  if(isIntersectSS(s1,s2,t1,t2))return 0.0;\n  return min(min(getDistanceSP(s1,s2,t1),getDistanceSP(s1,s2,t2)),\n\t     min(getDistanceSP(t1,t2,s1),getDistanceSP(t1,t2,s2)));\n}\n\nbool isOn(Point p,vector<Point> t){\n  int size=t.size();\n  for(int i=0;i<(int)t.size();i++)\n    if(ccw(t[i],t[(i+1)%size],p)==COUNTER_CLOCKWISE)\n      return false;\n  return true;\n}\n\ndouble getD(Point s1,Point s2,vector<Point> t){\n  if(isOn(s1,t)||isOn(s2,t))return 0;\n  double res=INF;\n  int size=t.size();\n  for(int i=0;i<size;i++)\n    res=min(res,getDistanceSS(s1,s2,t[i],t[(i+1)%size]));\n  return res;\n}\n\ndouble calc(double dist,double h){\n  if(dist<h)return dist;\n  else return(dist*dist+h*h)/2.0/h;\n}\n\nint main(){\n  int n;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    Point si,ti;\n    double ans=INF;\n    cin>>si.x>>si.y>>ti.x>>ti.y;\n    for(int i=0;i<n;i++){\n      vector<Point> t(4);\n      double h,dist,a,b,c,d;\n      cin>>a>>b>>c>>d>>h;\n      t[0]=Point(a,b);\n      t[1]=Point(a,d);\n      t[2]=Point(c,d);\n      t[3]=Point(c,b);\n      for(int j=0;j<4;j++){\n\tdist=getD(si,ti,t);\n\t//printf(\"%.8f %.8f %.8f\\n\",dist,h,calc(dist,h));\n\tans=min(ans,calc(dist,h));\n      }\n    }\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Geometry_Library\n#define ___Geometry_Library\n\n// ------ Includes ------ //\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <algorithm>\n\n// ------ Defines ------ //\ntypedef long double GType;\ntypedef std::complex<GType> Point;\ntypedef std::pair<Point, Point> Segment;\n\n// ------ Constants ------ //\nconst GType EPS = 1.0e-10L;\n\n// ------ Functions Level 1 ------ //\nGType dot(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).real();\n}\nGType cross(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).imag();\n}\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint v1 = p2 - p1, v2 = p3 - p1;\n\tif (cross(v1, v2) > EPS) return +1;\n\tif (cross(v1, v2) < -EPS) return -1;\n\tif (dot(v1, v2) < -EPS) return +2;\n\tif (std::norm(v1) < std::norm(v2)) return -2;\n\treturn 0;\n}\n\n// ------ Functions Level 2 ------ //\nbool intersect(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(cross(s1.second - p1, s1.first - p1)) < EPS;\n\treturn (std::abs(s1.first - p1) + std::abs(s1.second - p1) - std::abs(s1.second - s1.first)) < EPS;\n}\nbool intersect(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (!segflag) return cross(s1.second - s1.first, s2.first - s1.first) * cross(s1.second - s1.first, s2.second - s1.first) < EPS;\n\treturn (ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) <= 0 && ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) <= 0);\n}\nPoint projection(const Segment& s1, const Point& p1) {\n\tGType mul = dot(p1 - s1.first, s1.first - s1.second) / norm(s1.first - s1.second);\n\treturn s1.first + (s1.first - s1.second) * mul;\n}\nPoint reflection(const Segment& s1, const Point& p1) {\n\treturn p1 + (projection(s1, p1) - p1) * (GType)(2);\n}\nGType distance(const Point& p1, const Point& p2) {\n\treturn std::abs(p2 - p1);\n}\nGType distance(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(p1 - projection(s1, p1));\n\tconst Point p2 = projection(s1, p1);\n\tif (intersect(s1, p2, true)) return std::abs(p2 - p1);\n\treturn std::min(std::abs(s1.first - p1), std::abs(s1.second - p1));\n}\nGType distance(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (intersect(s1, s2, segflag)) return 0;\n\tif (!segflag) return std::min(distance(s1, s2.first, false), distance(s1, s2.second, false));\n\treturn std::min({ distance(s1, s2.first, true), distance(s1, s2.second, true), distance(s2, s1.first, true), distance(s2, s1.second, true) });\n}\n\n// ------ Functions Level 3 ------ //\nint contain(std::vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tPoint a = v[i] - p, b = v[(i + 1 != v.size() ? i + 1 : 0)] - p;\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() <= EPS && EPS < b.imag() && cross(a, b) < -EPS) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n#endif\n\n#include <vector>\n#include <iomanip>\n#include <iostream>\nusing namespace std;\nint n, sx, sy, ex, ey, xa[55], ya[55], xb[55], yb[55], h[55];\nint main() {\n\twhile (cin >> n, n) {\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tfor (int i = 0; i < n; i++) cin >> xa[i] >> ya[i] >> xb[i] >> yb[i] >> h[i];\n\t\tvector<vector<Point> > v(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tv[i] = { Point(xa[i], ya[i]), Point(xa[i], yb[i]), Point(xb[i], yb[i]), Point(xb[i], ya[i]) };\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 1; i < 20000; i++) {\n\t\t\tPoint pt(sx + (ex - sx) * i / 100000.0, sy + (ey - sy) * i / 100000.0);\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (contain(v[j], pt)) flag = false;\n\t\t\t}\n\t\t}\n\t\tif (!flag) cout << 0 << endl;\n\t\telse {\n\t\t\tdouble ret = 1.0e+9;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tdouble dist = distance(Segment(Point(sx, sy), Point(ex, ey)), Segment(v[i][j], v[i][(j + 1) & 3]), true);\n\t\t\t\t\tdouble r = 0.5 * (h[i] + dist * dist / h[i]);\n\t\t\t\t\tret = min(ret, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << fixed << setprecision(15) << ret << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  \n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  }\n\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\n\ndouble cal(L a,L b,double h){\n  double d=getDistanceSS(a,b);\n  if(h>d)return d;\n  return (h*h+d*d)/2/h;\n}\n\nint main(){\n  int n;\n\n  while(cin>>n,n){\n    double ans=1e9;\n    P s,e;\n    double minx,maxx,miny,maxy,h;\n    cin>>s.x>>s.y>>e.x>>e.y;\n    for(int i=0;i<n;i++){\n      cin>>minx>>miny>>maxx>>maxy>>h;\n      if(minx<=s.x&&s.x<=maxx&&miny<=s.y&&s.y<=maxy)ans=0;\n      if(minx<=e.x&&e.x<=maxx&&miny<=e.y&&e.y<=maxy)ans=0;\n      ans=min(ans,cal(L(s,e),L(P(minx,miny),P(minx,maxy)),h));\n      ans=min(ans,cal(L(s,e),L(P(minx,maxy),P(maxx,maxy)),h));\n      ans=min(ans,cal(L(s,e),L(P(maxx,maxy),P(maxx,miny)),h));\n      ans=min(ans,cal(L(s,e),L(P(maxx,miny),P(minx,miny)),h));\n    }\n    printf(\"%.8lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tdouble min_x,min_y,max_x,max_y,h;\n};\n\nint N;\nInfo info[50];\ndouble start_x,start_y,end_x,end_y;\n\nstruct Point{\n\tdouble x,y;\n};\n\ntypedef Point Vector;\n\nstruct Segment{\n\tvoid set(double x1,double y1,double x2,double y2){\n\t\tp1.x = x1;\n\t\tp1.y = y1;\n\t\tp2.x = x2;\n\t\tp2.y = y2;\n\t}\n\tPoint p1,p2;\n};\n\ntypedef Segment Line;\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\nPoint calc_minus(Point a,Point b){\n\tPoint ret;\n\n\tret.x = a.x-b.x;\n\tret.y = a.y-b.y;\n\n\treturn ret;\n}\n\ndouble calc_len(Vector a){\n\treturn sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble getDistanceLP(Line l,Point p){\n\treturn fabs(cross(calc_minus(l.p2,l.p1),calc_minus(p,l.p1))/calc_len(calc_minus(l.p2,l.p1)));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n\tif(dot(calc_minus(s.p2,s.p1),calc_minus(p,s.p1)) < 0.0)return calc_len(calc_minus(p,s.p1));\n\tif(dot(calc_minus(s.p1,s.p2),calc_minus(p,s.p2)) < 0.0)return calc_len(calc_minus(p,s.p2));\n\treturn getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n\treturn min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t\t\tmin(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nvoid solve(){\n\n\tscanf(\"%lf %lf %lf %lf\",&start_x,&start_y,&end_x,&end_y);\n\n\tSegment base_seg;\n\tbase_seg.set(start_x,start_y,end_x,end_y);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf %lf %lf\",&info[i].min_x,&info[i].min_y,&info[i].max_x,&info[i].max_y,&info[i].h);\n\t}\n\n\tdouble R = 1000.0;\n\n\tSegment A,B,C,D;\n\tdouble tmp_dist;\n\n\tfor(int i = 0; i < N; i++){\n\t\tif((func(start_x,start_y,end_x,end_y,info[i].min_x,info[i].min_y)*func(start_x,start_y,end_x,end_y,info[i].min_x,info[i].max_y) <= 0 &&\n\t\t\t\tfunc(info[i].min_x,info[i].min_y,info[i].min_x,info[i].max_y,start_x,start_y) * func(info[i].min_x,info[i].min_y,info[i].min_x,info[i].max_y,end_x,end_y) <= 0) ||\n\t\t\t\t(func(start_x,start_y,end_x,end_y,info[i].min_x,info[i].max_y)*func(start_x,start_y,end_x,end_y,info[i].max_x,info[i].max_y) <= 0 &&\n\t\t\t\tfunc(info[i].min_x,info[i].max_y,info[i].max_x,info[i].max_y,start_x,start_y) * func(info[i].min_x,info[i].min_y,info[i].max_x,info[i].max_y,end_x,end_y) <= 0) ||\n\t\t\t\t(func(start_x,start_y,end_x,end_y,info[i].max_x,info[i].max_y)*func(start_x,start_y,end_x,end_y,info[i].max_x,info[i].min_y) <= 0 &&\n\t\t\t\tfunc(info[i].max_x,info[i].max_y,info[i].max_x,info[i].min_y,start_x,start_y) * func(info[i].max_x,info[i].max_y,info[i].max_x,info[i].min_y,end_x,end_y) <= 0) ||\n\t\t\t\t(func(start_x,start_y,end_x,end_y,info[i].max_x,info[i].min_y)*func(start_x,start_y,end_x,end_y,info[i].min_x,info[i].min_y) <= 0 &&\n\t\t\t\tfunc(info[i].max_x,info[i].min_y,info[i].min_x,info[i].min_y,start_x,start_y) * func(info[i].max_x,info[i].min_y,info[i].min_x,info[i].min_y,end_x,end_y) <= 0)){\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn;\n\t\t}else{\n\n\t\t\tA.set(info[i].min_x,info[i].min_y,info[i].min_x,info[i].max_y);\n\t\t\tB.set(info[i].min_x,info[i].max_y,info[i].max_x,info[i].max_y);\n\t\t\tC.set(info[i].max_x,info[i].max_y,info[i].max_x,info[i].min_y);\n\t\t\tD.set(info[i].max_x,info[i].min_y,info[i].min_x,info[i].min_y);\n\n\t\t\ttmp_dist = min(min(getDistance(base_seg,A),getDistance(base_seg,B)),min(getDistance(base_seg,C),getDistance(base_seg,D)));\n\n\t\t\tif(info[i].h < tmp_dist){\n\t\t\t\tR = min(R,(info[i].h*info[i].h+tmp_dist*tmp_dist)/(2*info[i].h));\n\t\t\t}else{\n\t\t\t\tR = min(R,tmp_dist);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.10lf\\n\",R);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<double> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bucnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n\nconst ll inf = (ll)1e9;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\ndouble dot_product(pdd a, pdd b, pdd c) {\n\treturn (b.fst - a.fst)*(c.fst - a.fst) + (b.scn - a.scn)*(c.scn - a.scn);\n}\n\ndouble cross_product(pdd a, pdd b, pdd c) {\n\treturn (b.fst - a.fst)*(c.scn - a.scn) - (b.scn - a.scn)*(c.fst - a.fst);\n}\n\ndouble dist(pdd a, pdd b) {\n\treturn sqrt((a.fst - b.fst)*(a.fst - b.fst) + (a.scn - b.scn)*(a.scn - b.scn));\n}\n\ndouble Ldist(pdd s, pdd t, pdd a) {\n\tcompd T(t.fst - s.fst, t.scn - s.scn), A(a.fst - s.fst, a.scn - s.scn);\n\tcompd rot = T / abs(T);\n\tA /= rot;\n\tT /= rot;\n\tif (A.real() < eps)\treturn dist(s, a);\n\tif (T.real() - eps < A.real())\treturn dist(t, a);\n\treturn abs(A.imag());\n}\n\nint main() {\n\twhile (true) {\n\t\tint n;\tcin >> n;\n\t\tif (n == 0)\treturn 0;\n\t\tpdd s, t;\tcin >> s.fst >> s.scn >> t.fst >> t.scn;\n\t\tdouble left = 0, right = 1024;\n\t\trep(i, n) {\n\t\t\tvector<pdd> a(4);\n\t\t\tcin >> a[0].fst >> a[0].scn >> a[2].fst >> a[2].scn;\n\t\t\tdouble h;\tcin >> h;\n\t\t\ta[1] = mp(a[0].fst, a[2].scn);\n\t\t\ta[3] = mp(a[2].fst, a[0].scn);\n\t\t\t//s-t???????????????????????????\n\t\t\tbool is_inside = true;\n\t\t\trep(j, 4) {\n\t\t\t\tif (dot_product(a[j], a[(j + 1) % 4], s) < -eps)\tis_inside = false;\n\t\t\t\tif (dot_product(a[j], a[(j + 1) % 4], t) < -eps)\tis_inside = false;\n\t\t\t}\n\t\t\tif (is_inside)\tright = 0;\n\t\t\tleft = 0;\n\t\t\trep(k, 30) {\n\t\t\t\tdouble mid = (left + right) / 2.0;\n\t\t\t\tdouble height = mid - min(mid, h);\n\t\t\t\tdouble r = sqrt(mid*mid - height*height);\n\t\t\t\tbool ok = true;\n\t\t\t\trep(j, 4) {\n\t\t\t\t\tif (Ldist(s, t, a[j]) < r + eps)\tok = false;\n\t\t\t\t\tif (Ldist(a[j], a[(j + 1) % 4], t) < r + eps)\tok = false;\n\t\t\t\t\tif (Ldist(a[j], a[(j + 1) % 4], s) < r + eps)\tok = false;\n\t\t\t\t}\n\t\t\t\trep(j, 4) {\n\t\t\t\t\tif (cross_product(s, t, a[j])*cross_product(s, t, a[(j + 1) % 4]) > eps)\tcontinue;\n\t\t\t\t\tif (cross_product(a[j], a[(j + 1) % 4], s)*cross_product(a[j], a[(j + 1) % 4], t) > eps)\tcontinue;\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\tif (ok)\tleft = mid;\n\t\t\t\telse\tright = mid;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.15lf\\n\", left);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <limits.h>\n\nusing namespace std;\n\n#define ZEROP(x) (fabs(x) < EPS)\n#define EQ(x, y) ZEROP((x) - (y))\n#define LT(x, y) ((x) - (y) <= -EPS) // x < y\n#define LE(x, y) ((x) - (y) < +EPS) // x <= y\n#define SIGN(x) ((x)<-EPS?-1:((x)>EPS?+1:0))\n\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define REPD(i,n) for(int i=(int)(n); i-->0;)\n#define REPI(i,a,b) for(int i=(int)(a); i<=(int)(b); i++)\n#define ALL(a) (a).begin(),(a).end()\n#define mp make_pair\n#define fst first\n#define snd second\n\n#define INFTY 1000000000\n#define EPS 1e-9\n#define PI 3.141592653589793\n\n#define INF (INFTY/3)\n\n#define rev(s) (string((s).rbegin(), (s).rend()))\n\ntypedef long long Int;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<double,double> pdd;\n\nvoid debug(vi v){ REP(i,v.size()) cout<<v[i]<<\" \"; cout<<endl; }\n\nint nextInt(){ int t; cin>>t; return t; } // DæÊÉCðÂ¯Äg¤±Æ\n\ntypedef complex<double> P;\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nnamespace std {\n   bool operator < (const P& a, const P& b) {\n     return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n   }\n}\ndouble cross(const P& a, const P& b) {\n   return imag(conj(a)*b); //OÏu~vÌå«³Dü«ÍL=[u,v]ÉÎµÄCu©çvÖÌEË¶\n} \ndouble dot(const P& a, const P& b) {\n   return real(conj(a)*b); \n}  \nstruct L : public vector<P> {\n  L() {}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  } \n};  \ntypedef vector<P> G;  \nstruct C {\n   P p; double r;\n   C(const P &p, double r) : p(p), r(r) { }\n}; \n\n\n#define MAXN 50\nint N;\nL sl; // start line\nint minx[MAXN];\nint miny[MAXN];\nint maxx[MAXN];\nint maxy[MAXN];\nint h[MAXN];\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (LT( 0, cross(b, c)) )   return +1;       // counter clockwise\n  if (LT( cross(b, c), 0) )   return -1;       // clockwise\n  if (LT( dot(b, c), 0) )     return +2;       // c--a--b on line\n  if (LT( norm(b), norm(c)) ) return -2;       // a--b--c on line\n  return 0;\n}\n\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n// USE IN THIS PROBLEM\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nbool covered(int sx,int sy,int ex,int ey,int ax,int ay,int bx,int by) {\n  return ax < sx && ay < sy && ex < bx && ey < by;\n}\n\n\ndouble solve() {\n  double r = INT_MAX;\n  REP(i,N) {\n    L l[]={L(P(minx[i],miny[i]),P(maxx[i],miny[i])),\n\t   L(P(maxx[i],miny[i]),P(maxx[i],maxy[i])),\n\t   L(P(maxx[i],maxy[i]),P(minx[i],maxy[i])),\n\t   L(P(minx[i],maxy[i]),P(minx[i],miny[i]))};\n    double mind = INT_MAX;\n    int mini; //min index\n    if(covered(real(sl[0]),imag(sl[0]),real(sl[1]),imag(sl[1]),\n\t       minx[i],miny[i],maxx[i],maxy[i])) return 0.0;\n    REP(j,4) {\n      if(intersectSS(l[j],sl)) return 0.0;\n      double dd = distanceSS(l[j],sl);\n      if(LT(dd,mind)) {\n\tmind = dd;\n\tmini = j;\n      }\n    }\n    double r2;\n    //printf(\"mind=%lf\\n\",mind);\n    if(LE(mind,h[i])) { // mind <= h[i]\n      r2=mind;\n    } else {\n      r2=(h[i]*h[i] + mind*mind) / (2*h[i]);\n    }\n    r=min(r,r2);\n    //printf(\"r=%lf\\n\",r);\n  }\n  return r;\n}\n\t\nmain() {\n  while(cin>>N,N) {\n    int sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    sl = L(P(sx,sy),P(ex,ey));\n    REP(i,N)\n      cin>>minx[i]>>miny[i]>>maxx[i]>>maxy[i]>>h[i];\n    printf(\"%.7lf\\n\",solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000009;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP; bool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n//線分\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n//円\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n//3点の位置関係\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < -eps)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\n//2直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n//直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < eps);\n}\n//点が直線上に存在するか\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n//点が線分上に存在するか\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n//線分と線分の交差判定\nbool isis_ss(Line s,Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\tld t1 = (real(s.a) - real(s.b))*(imag(t.a) - imag(s.a)) + (imag(s.a) - imag(s.b))*(real(s.a) - real(t.a));\n\tld t2 = (real(s.a) - real(s.b))*(imag(t.b) - imag(s.a)) + (imag(s.a) - imag(s.b))*(real(s.a) - real(t.b));\n\tld t3 = (real(t.a) - real(t.b))*(imag(s.a) - imag(t.a)) + (imag(t.a) - imag(t.b))*(real(t.a) - real(s.a));\n\tld t4 = (real(t.a) - real(t.b))*(imag(s.b) - imag(t.a)) + (imag(t.a) - imag(t.b))*(real(t.a) - real(s.b));\n\treturn t1 * t2 < -eps && t3*t4 < -eps;\n}\n//点から直線への垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n//直線と直線の交点\n//平行な２直線に対しては使うな！！！！\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n//直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n//直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n//線分と直線の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n//線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\n//線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\nint n;\nld d[50],h[50];\nld ten[4]; Point loc[4];\nLine road;\nld sx, sy, gx, gy;\nvoid make_point() {\n\tloc[0] = { ten[0],ten[1] };\n\tloc[1] = { ten[2],ten[1] };\n\tloc[2] = { ten[2],ten[3] };\n\tloc[3] = { ten[0],ten[3] };\n}\nbool not_on_line() {\n\tif (ten[0] <= min(sx,gx) && ten[1] <= min(sy,gy) && ten[2] >= max(gx,sx) && ten[3] >= max(sy,gy))return false;\n\trep(i, 4) {\n\t\tLine now = { loc[i],loc[(i + 1) % 4] };\n\t\tif (isis_ss(road, now))return false;\n\t}\n\treturn true;\n}\nint main(){\n\tcout << fixed << setprecision(5);\n\twhile (cin >> n, n) {\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\troad = { {sx,sy},{gx,gy} };\n\t\tbool valid = true;\n\t\tld out = mod;\n\t\trep(i, n) {\n\t\t\trep(j, 4) {\n\t\t\t\tcin >> ten[j];\n\t\t\t}\n\t\t\tcin >> h[i];\n\t\t\tmake_point();\n\t\t\tif (!not_on_line())valid = false;\n\t\t\td[i] = mod;\n\t\t\trep(j, 4) {\n\t\t\t\td[i] = min(d[i], dist_ss(road, {loc[j],loc[(j+1)%4]}));\n\t\t\t}\n\t\t\tif (d[i] < h[i]) {\n\t\t\t\tout = min(out, d[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout = min(out, (h[i] * h[i] + d[i] * d[i]) / (ld)(2 * h[i]));\n\t\t\t}\n\t\t\t/*cout << d[i] << \" \"<<h[i]<<endl;\n\t\t\tcout << out << endl;\n\t\t\tcout << (h[i] * h[i] + d[i] * d[i]) / (ld)(2 * h[i]) << endl;*/\n\t\t}\n\t\tif (!valid)cout << 0 << endl;\n\t\telse cout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<long double> xy;\nlong eps = 1e-9;\nlong double dot_product(xy a,xy b) {return (conj(a)*b).real();}\nlong double cross_product(xy a,xy b) {return (conj(a)*b).imag();}\nlong double dist_lp(xy a1,xy a2,xy p){\n    if(dot_product(a2-a1,p-a1)<eps) return abs(p-a1);\n    if(dot_product(a1-a2,p-a2)<eps) return abs(p-a2);\n    return abs(cross_product(a2-a1,p-a1))/abs(a2-a1);\n}\n\nbool is_online(xy a1,xy a2,xy p){\n    return abs(a1-p)+abs(a2-p)<=abs(a1-a2)+eps;    \n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    if(is_online(a1,a2,b1) || is_online(a1,a2,b2)) return true;\n    if(is_online(b1,b2,a1) || is_online(b1,b2,a2)) return true;\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<-eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<-eps;\n}\n\nlong double dist_ll(xy a1,xy a2,xy b1,xy b2){\n    if(is_intersected(a1,a2,b1,b2)) return 0;\n    return min({dist_lp(a1,a2,b1),dist_lp(a1,a2,b2),dist_lp(b1,b2,a1),dist_lp(b1,b2,a2)\n    ,abs(a1-b1),abs(a1-b2),abs(a2-b1),abs(a2-b2)});   \n}\n\nint N;\nlong double sx,sy,gx,gy,mi_x,mi_y,ma_x,ma_y;\nlong double h;\n\n\nint main(){\n    while(cin>>N && N>0){\n        long double ans = 1e9;\n        cin >> sx >> sy >> gx >> gy;\n/*        if(sx>gx){\n            swap(sx,sy);\n            swap(gx,gy);\n        }\n*/        xy s = xy(sx,sy),g = xy(gx,gy);\n        for(int i=1;i<=N;i++){\n            cin >> mi_x >> mi_y >> ma_x >> ma_y >> h;\n            if((mi_x<=sx && sx<=ma_x && mi_y<=sy && sy<=ma_y || \n            mi_x<=gx && gx<=ma_x && mi_y<=gy && gy<=ma_y)) ans = 0;\n            long double d = min({dist_ll(s,g,xy(mi_x,mi_y),xy(mi_x,ma_y)),\n            dist_ll(s,g,xy(mi_x,ma_y),xy(ma_x,ma_y)),\n            dist_ll(s,g,xy(ma_x,ma_y),xy(ma_x,mi_y)),\n            dist_ll(s,g,xy(ma_x,mi_y),xy(mi_x,mi_y))});\n            if(d<=h) ans = min(ans,d);\n            else ans = min(ans,(h*h+d*d)/(2.0*h));\n        }\n        cout << fixed;\n        cout << setprecision(10) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nstruct data{ double minx, miny, maxx, maxy, h; };\nint n;\nvector<data> v;\n\ntypedef long double ld;\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nbool check(double r, Line s)\n{\n\tbool ans = true;\n\tREP(i, v.size())\n\t{\n\t\tdata t = v[i];\n\t\tif (s.a.real() - t.minx > -EPS && t.maxx - s.a.real() > -EPS &&\n\t\t\ts.a.imag() - t.miny > -EPS && t.maxy - s.a.imag() > -EPS) ans = false;\n\t\tif (s.b.real() - t.minx > -EPS && t.maxx - s.b.real() > -EPS &&\n\t\t\ts.b.imag() - t.miny > -EPS && t.maxy - s.b.imag() > -EPS) ans = false;\n\t\tPoint ps[4] = { Point(t.maxx, t.maxy), Point(t.maxx, t.miny), Point(t.minx, t.miny), Point(t.minx, t.maxy)};\n\t\tREP(j, 4)\n\t\t{\n\t\t\tLine ts = Line(ps[j], ps[(j + 1) % 4]);\n\t\t\tif (isis_ss(s, ts)) ans = false;\n\t\t\tdouble d = dist_ss(s, ts);\n\t\t\tdouble dd = sqrt(pow(r - t.h, 2) + d*d);\n\t\t\tif (dd - r < -EPS) ans = false;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\twhile (cin >> n, n)\n\t{\n\t\tdouble sx, sy, ex, ey;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tLine s(sx, sy, ex, ey);\n\t\tv.clear();\n\t\tREP(i, n)\n\t\t{\n\t\t\tdouble a, b, c, d, e;\n\t\t\tcin >> a >> b >> c >> d >> e;\n\t\t\tv.push_back(data{ a, b, c, d, e });\n\t\t}\n\t\tdouble lb = 0, ub = 1000;\n\t\tREP(i, 100)\n\t\t{\n\t\t\tdouble mid = (lb + ub) / 2;\n\t\t\tif (check(mid, s)) lb = mid;\n\t\t\telse ub = mid;\n\t\t}\n\t\tcout << D10 << ub << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n#define tmp template<class t>\n\ntmp void chmax(t&a,t b){if(a<b)a=b;}\ntmp void chmin(t&a,t b){if(a>b)a=b;}\n\ntmp using vc=vector<t>;\ntmp using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntmp ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\ntmp void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll read(){ll i;cin>>i;return i;}\n\nusing ld=long double;\nusing cm=complex<ld>;\n#define x real()\n#define y imag()\nconst ld eps=1e-7;\nint sgn(ld a){return a<-eps?-1:(a>eps?1:0);}\nauto cmcmp=[](const cm&a,const cm&b){\n\tif(sgn(a.x-b.x))return a.x<b.x;\n\telse return sgn(a.y-b.y)<0;\n};\nld dot(cm a,cm b){return a.x*b.x+a.y*b.y;}\nld crs(cm a,cm b){return a.x*b.y-a.y*b.x;}\nint ccw(cm a,cm b){return sgn(crs(a,b));}\nint ccw(cm a,cm b,cm c){return ccw(b-a,c-a);}\n//AOJ1183\nint qeq(ld a,ld b,ld c,ld&d,ld&e){\n\tld f=b*b-4*a*c;\n\tif(sgn(f)<0)return 0;\n\tld g=sqrt(max(f,ld(0)));\n\td=(-b+g)/(2*a);\n\te=(-b-g)/(2*a);\n\treturn sgn(f)+1;\n}\n//(-2)[a,-1](0)[b,1](2)\nint bet(cm a,cm b,cm c){\n\tcm d=b-a;\n\tld e=dot(d,c-a);\n\tif(sgn(e)<=0)return sgn(e)-1;\n\treturn sgn(e-norm(d))+1;\n}\nld tri2(cm a,cm b,cm c){\n\treturn crs(b-a,c-a);\n}\n//AOJ0153\n//0-no,1-edge,2-in\nint cont(cm a,cm b,cm c,cm d){\n\tif(ccw(a,b,c)==-1)\n\t\tswap(b,c);\n\treturn min({ccw(a,b,d),ccw(b,c,d),ccw(c,a,d)})+1;\n}\n//AOJ1183\n//arg between ab\n//assume given lengths are valid\nld arg(ld a,ld b,ld c){\n\treturn acos(min(max((a*a+b*b-c*c)/(2*a*b),ld(-1)),ld(1)));\n}\n\nusing ln=pair<cm,cm>;\ncm dir(ln a){return a.b-a.a;}\ncm eval(ln a,ld b){return a.a+dir(a)*b;}\ncm proj(ln a,cm b){\n\tcm c=dir(a);\n\treturn a.a+c*dot(c,b-a.a)/norm(c);\n}\ncm refl(ln a,cm b){\n\treturn ld(2)*proj(a,b)-b;\n}\n//AOJ0153\nld dsp(ln a,cm b){\n\tcm c=proj(a,b);\n\tif(abs(bet(a.a,a.b,c))<=1)return abs(b-c);\n\treturn min(abs(b-a.a),abs(b-a.b));\n}\nint ccw(ln a,cm b){return ccw(a.a,a.b,b);}\n//AOJ1157\n//0-no,1-yes(endpoint),2-yes(innner),3-overelap\nint iss(ln a,ln b){\n\tint c1=ccw(a.a,a.b,b.a),c2=ccw(a.a,a.b,b.b);\n\tint d1=ccw(b.a,b.b,a.a),d2=ccw(b.a,b.b,a.b);\n\tif(c1||c2||d1||d2)return 1-max(c1*c2,d1*d2);\n\tint f=bet(a.a,a.b,b.a),g=bet(a.a,a.b,b.b);\n\tif(max(f,g)==-2||min(f,g)==2)return 0;\n\treturn 3;\n}\n//AOJ1157\nld dss(ln a,ln b){\n\tif(iss(a,b))return 0;\n\treturn min({dsp(a,b.a),dsp(a,b.b),dsp(b,a.a),dsp(b,a.b)});\n}\n\ncm readcm(){\n\tld a,b;\n\tcin>>a>>b;\n\treturn cm(a,b);\n}\n\nld readld(){\n\tld a;\n\tcin>>a;\n\treturn a;\n}\n\nsigned main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(4);\n\twhile(1){\n\t\tint n=read();\n\t\tif(n==0)break;\n\t\tld sx=read(),sy=read();\n\t\tld tx=read(),ty=read();\n\t\tln st{cm(sx,sy),cm(tx,ty)};\n\t\tvc<pair<ln,ld>> a;\n\t\tld mn=1e9;\n\t\trep(i,n){\n\t\t\tld x1=read(),y1=read();\n\t\t\tld x2=read(),y2=read();\n\t\t\tld h=read();\n\t\t\tcm b(x1,y1);\n\t\t\tcm c(x1,y2);\n\t\t\tcm d(x2,y2);\n\t\t\tcm e(x2,y1);\n\t\t\ta.eb(ln{b,c},h);\n\t\t\ta.eb(ln{c,d},h);\n\t\t\ta.eb(ln{d,e},h);\n\t\t\ta.eb(ln{e,b},h);\n\t\t\tif(cont(b,c,d,st.a)||cont(b,c,d,st.b)||cont(d,e,b,st.a)||cont(d,e,b,st.b))\n\t\t\t\tmn=0;\n\t\t}\n\t\tfor(auto w:a){\n\t\t\tld b=dss(w.a,st);\n\t\t\tld c=w.b;\n\t\t\tchmin(mn,(b*b+c*c)/(2*c));\n\t\t\tif(c>=b)\n\t\t\t\tchmin(mn,b);\n\t\t}\n\t\tcout<<mn<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\n// point\ntypedef double T;\ntypedef pair<T,T> P;\n\n// difference\nP operator-(const P& lhs, const P& rhs)\n{\n\treturn P(lhs.first-rhs.first,lhs.second-rhs.second);\n}\n\nP operator+(const P& lhs, const P& rhs)\n{\n\treturn P(lhs.first+rhs.first, lhs.second+rhs.second);\n}\n\n// scalar product\nP operator*(T t, P p){\n\treturn P(t*p.first,t*p.second);\n}\n\n// outer product\nT Cross(const P& lhs, const P& rhs)\n{\n\treturn lhs.first*rhs.second-lhs.second*rhs.first;\n}\n\n// inner product \nT Dot(const P& lhs, const P& rhs)\n{\n\treturn lhs.first*rhs.first+lhs.second*rhs.second;\n}\n\n// square of distance\nT Dist2(const P& lhs, const P& rhs){\n\treturn Dot(lhs-rhs,lhs-rhs);\n}\n\n// b is on segment a c\nbool onSegment(P a, P b, P c){\n\tP v=c-a;\n\tP w=b-a;\n\treturn Cross(v,w)==0 && 0<=Dot(v,w)&&Dot(v,w)<=Dot(v,v);\n}\n\n\n// intersection of segments\nbool Intersects(P s0, P e0, P s1, P e1)\n{\n\tP a=s1-s0;\n\tP v=e0-s0;\n\tP w=s1-e1;\n\tT det=Cross(v,w);\n\tT t0=w.second*a.first-w.first*a.second;\n\tT t1=-v.second*a.first+v.first*a.second;\n\tif (det<0){\n\t\tif (det <= t0 && det <= t1 && t0 <= 0 && t1 <= 0){\n\t\t\treturn true;\n\t\t}\n\t}\n\telse if (det > 0)\n\t{\n\t\tif (0 <= t0 && 0 <= t1 && t0 <= det && t1 <= det){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn onSegment(s0,s1,e0) ||\n\t\tonSegment(s0,e1,e0)||\n\t\tonSegment(s1,s0,e1)||\n\t\tonSegment(s1,e0,e1);\n}\n\n// intersection of line\nbool IntersectParam(P s0, P e0, P s1, P e1, T& t0, T& t1)\n{\n\tP a=s1-s0;\n\tP v=e0-s0;\n\tP w=s1-e1;\n\tT det=Cross(v,w);\n\tif(det == 0){\n\t\treturn false;\n\t}\n\tt0=Cross(a,w)/det;\n\tt1=Cross(v,a)/det;\n\treturn true;\n}\n\nP Interpolate(P s, P e, T t)\n{\n\treturn (1-t)*s+t*e;\n}\n\n// intersection of polygons\nbool Intersects(vector<P>& lhs, vector<P>& rhs)\n{\n\tfor(int i=1;i<lhs.size();i++){\n\t\tfor (int j=1;j<rhs.size();j++){\n\t\t\tif (Intersects(lhs[i],lhs[i-1],rhs[j],rhs[j-1])){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool IsInside(vector<P>& ps, P p)\n{\n\tint count=0;\n\tfor(int i=1;i<ps.size();i++){\n\t\tP a=ps[i-1];\n\t\tP b=ps[i];\n\t\tif(min(a.first,b.first)<=p.first&&p.first<max(a.first,b.first))\n\t\t{\n\t\t\tT c=Cross(p-a,b-a);\n\t\t\tif(c==0){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(c<0){\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\telse if (a.first==p.first&&b.first==p.first)\n\t\t{\n\t\t\tif(min(a.second,b.second)<=p.first&&p.first<=max(a.second,b.second))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count!=0;\n}\n\nbool IntersectSegmentCircle(P s, P e, P c, T r)\n{\n\ts=s-c;\n\te=e-c;\n\tif(Dot(s,s)<r*r||Dot(e,e)<r*r){\n\t\treturn true;\n\t}\n\n\tP v=P(0,0)-s;\n\tdouble cr=Cross(e-s,v);\n\tdouble se=Dist2(e,s);\n\tif(cr*cr<se*r*r){\n\t\tif(0<=Dot(e-s,v)&&Dot(e-s,v)<=Dot(e-s,e-s))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nP s,e;\nP rot; \ndouble ps[50][2][2];\ndouble h[50];\nint N;\nbool intersects(double r,int a)\n{\n\tdouble offset;\n\tif(r>h[a])\n\t{\n\t\toffset=sqrt(r*r-(r-h[a])*(r-h[a]));\n\t}\n\telse\n\t{\n\t\toffset=r;\n\t}\n\n\tvector<P> poly;\n\tpoly.push_back(P(ps[a][0][0],ps[a][0][1]));\n\tpoly.push_back(P(ps[a][1][0],ps[a][0][1]));\n\tpoly.push_back(P(ps[a][1][0],ps[a][1][1]));\n\tpoly.push_back(P(ps[a][0][0],ps[a][1][1]));\n\tpoly.push_back(P(ps[a][0][0],ps[a][0][1]));\n\n\tvector<P> poly2;\n\tpoly2.push_back(s+offset*rot);\n\tpoly2.push_back(e+offset*rot);\n\tpoly2.push_back(e-offset*rot);\n\tpoly2.push_back(s-offset*rot);\n\tpoly2.push_back(s+offset*rot);\n\n\tif(Intersects(poly,poly2))\n\t{\n\t\treturn true;\n\t}\n\tP mid=0.5*(poly[0]+poly[2]);\n\tP mid2=0.5*(poly2[0]+poly2[2]);\n\tif(IsInside(poly,mid2)||IsInside(poly2,mid))\n\t{\n\t\treturn true;\n\t}\n\n\tfor(int i=1;i<=4;i++){\n\t\tif(IntersectSegmentCircle(poly[i],poly[i-1],s,offset))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif(IntersectSegmentCircle(poly[i],poly[i-1],e,offset))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid exec()\n{\n\tcin >> N;\n\tif(N==0)exit(0);\n\tcin >> s.first >> s.second >> e.first >> e.second;\n\tdouble len=sqrt(Dist2(s,e));\n\trot=P((s.second-e.second)/len,(e.first-s.first)/len);\n\tfor(int i=0;i<N;i++){\n\t\tcin >> ps[i][0][0] >> ps[i][0][1] >> ps[i][1][0] >> ps[i][1][1] >> h[i];\n\t}\n\tdouble low=0;\n\tdouble hi=1000;\n\twhile(low+0.001<hi)\n\t{\n\t\tdouble mid=(low+hi)/2;\n\t\tbool ng=false;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(intersects(mid,i))\n\t\t\t{\n\t\t\t\tng=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ng){\n\t\t\thi=mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlow=mid;\n\t\t}\n\t}\n\tcout << (low+hi)/2 << endl;\n}\nint main(int argc, char** argv) {\n\twhile(1)exec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n\nusing namespace std;\nstatic const double EPS = 1e-6;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nstruct Point {\n  double x;\n  double y;\n  double z;\n  Point() {;}\n  Point(double x, double y, double z) : x(x), y(y), z(z) {;}\n};\n\nint n;\nPoint start, end;\nPoint box[100][4];\n\ninline double square(double x) { return x * x; }\ninline double dist(double x1, double y1, double z1, double x2, double y2, double z2) {\n  return sqrt(square(x1 - x2) + square(y1 - y2) + square(z1 - z2));\n}\n\ndouble ts2(double x, double y, double z) {\n  double lx = start.x;\n  double ly = start.y;\n  double rx = end.x;\n  double ry = end.y;\n  double r = start.z;\n  REP(iter, 30) {\n    double mlx = (lx * 2 + rx) / 3.0;\n    double mly = (ly * 2 + ry) / 3.0;\n    double mrx = (lx + rx * 2) / 3.0;\n    double mry = (ly + ry * 2) / 3.0;\n    double mlans = dist(x, y, z, mlx, mly, r);\n    double mrans = dist(x, y, z, mrx, mry, r);\n    if (mlans < r || mrans < r) {\n      return 0.0;\n    }\n    if (mlans < mrans) {\n      rx = mrx; ry = mry;\n    } else {\n      lx = mlx; ly = mly;\n    }\n  }\n  return dist(lx, ly, r, x, y, z);\n}\n\nbool ts1(int i, int j, double h) {\n  int pj = j; int nj = (j + 1) % 4;\n  double lx = box[i][pj].x;\n  double ly = box[i][pj].y;\n  double rx = box[i][nj].x;\n  double ry = box[i][nj].y;\n  double z = min(box[i][0].z, h);\n  REP(iter, 30) {\n    double mlx = (lx * 2 + rx) / 3.0;\n    double mly = (ly * 2 + ry) / 3.0;\n    double mrx = (lx + rx * 2) / 3.0;\n    double mry = (ly + ry * 2) / 3.0;\n    double mlans = ts2(mlx, mly, z);\n    double mrans = ts2(mrx, mry, z);\n    if (mlans < h || mrans < h) {\n      return true;\n    }\n    if (mlans < mrans) {\n      rx = mrx; ry = mry;\n    } else {\n      lx = mlx; ly = mly;\n    }\n  }\n  return false;\n}\n\nbool hit(double h) {\n  start.z = h;\n  end.z = h;\n  REP(i, n) {\n    REP(j, 4) {\n      if (ts1(i, j, h)) { return true; }\n    }\n  }\n  return false;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    double a, b, c, d, e;\n    scanf(\"%lf %lf %lf %lf\", &a, &b, &c, &d);\n    start = Point(a, b, 10000);\n    end = Point(c, d, 10000);\n    bool ok = true;\n    REP(i, n) {\n      scanf(\"%lf %lf %lf %lf %lf\", &a, &b, &c, &d, &e);\n      box[i][0] = Point(a, b, e);\n      box[i][1] = Point(a, d, e);\n      box[i][2] = Point(c, d, e);\n      box[i][3] = Point(c, b, e);\n      if (start.x >= a && start.x <= c && start.y >= b && start.y <= d) {\n        ok = false;\n      }\n    }\n    if (!ok) {\n      puts(\"0.00000\");\n      continue;\n    }\n    double l = 0.0;\n    double r = 1000.0;\n    while (r - l > EPS) {\n      double mid = (l + r) / 2.0;\n      if (hit(mid)) {\n        r = mid;\n      } else {\n        l = mid;\n      }\n    }\n    printf(\"%.5lf\\n\", l);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = max(a, b);\n#define chmin(a, b) a = min(a, b);\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\n\nconst double EPS = 1e-10;\ntemplate<class T> bool eq(T a, T b){ return abs(a - b) < EPS; }\n\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0):x(x), y(y){}\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\tdouble abs() const { return sqrt(norm()); }\n\tdouble norm() const { return x * x + y * y; }\n\tbool operator < (const Point &p) const { return x != p.x ? p.x : y < p.y; }\n\tbool operator == (const Point &p) const { return (eq<double>(x, p.x) && eq<double>(y, p.y)); }\n};\nusing Vector = Point;\n\ndouble dot(const Vector& a, const Vector& b) { return a.x * b.x + a.y * b.y; } // ????????????a??¨b?????????\ndouble cross(const Vector& a, const Vector& b) { return a.x * b.y - a.y * b.x; } // ????????????a??¨b?????????\ndouble length2(const Point& a) { return a.norm(); } // ??????????????????2???\n// double length(const Point& a) { return a.abs(); } // ???????????????\ndouble length(Point a) {\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\n\nenum ccw_t {\n\tCOUNTER_CLOCKWISE = 1, // p0->p1 ???????¨???????????????????p2\n\tCLOCKWISE = -1, // p0->p1 ????¨???????????????????p2\n\tONLINE_BACK = 2, // p2->p0->p1 ????????§??´????????§p2\n\tONLINE_FRONT = -2, // p0->p1->p2 ????????§??´??????p2\n\tON_SEGMENT = 0, // p0->p2->p1 ????????§??????p0p1??????p2\n};\nccw_t ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif ( cross(a, b) > EPS  )  return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS )  return CLOCKWISE;\n\tif ( dot(a, b) < -EPS )    return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(){}\n\tSegment(Point p1, Point p2):p1(p1), p2(p2){}\n};\nusing Line = Segment;\n\n// *** ????????????????????? ***\nbool intersect(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && \n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\nbool intersect(const Segment& s1, const Segment& s2) { \n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// *** ?????¢ ***\ndouble getDistance(Point& a, Point& b) { // ???a??¨???b????????¢\n\treturn length(a - b);\n}\ndouble getDistanceLP(Line& l, Point& p) { // ??´???s??¨???p????????¢\n\treturn length(cross(l.p2 - l.p1, p - l.p1) / length(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) { // ??????s??¨???p????????¢\n\tif( dot(s.p2 - s.p1, p - s.p1) < EPS ) return length(p - s.p1);\n\tif( dot(s.p1 - s.p2, p - s.p2) < EPS ) return length(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\ndouble getDistanceSS(Segment s1, Segment s2) {\n\tif( intersect(s1, s2) ) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t   min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nclass Rectangle { // ????????¢\npublic:\n\t// 3 2\n\t// 0 1 (???????¨??????????????????¢??????????????????????????¨)\n\tvector<Point> p; // ?????????????????????????????¨\n\tRectangle(vector<Point>&p):p(p) {\n\t\trep(i, 3) reps(j, i + 1, 4) { //????????????????????????????????§???????????????????\n\t\t\tint cnt = 0;\n\t\t\trep(k, 4) if(k != i && k != j) {\n\t\t\t\tcnt += ccw(p[i], p[j], p[k]) == COUNTER_CLOCKWISE;\n\t\t\t}\n\t\t\tif(cnt == 2) {\n\t\t\t\tswap(p[i + 1], p[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbool intersect(const Segment& s) { // ??????s??¨????????¢????°?????????¨???1??????????????????????????°true\n\t\tbool flag = false;\n\t\trep(i, 4) flag |= ::intersect(s, Segment(p[i], p[(i + 1) % 4]));\n\t\treturn flag;\n\t}\n\tbool contain(const Point& pp) { // ???pp???????????¢????????????????????°(??????????????????)true\n\t\tbool flag = true;\n\t\trep(i, 4) flag &= ccw(p[i], p[(i + 1) % 4], pp) == COUNTER_CLOCKWISE;\n\t\treturn flag;\n\t}\n\tbool contain(const Segment& s) { // ??????s???????????¢????????????????????°(??????????????????)true\n\t\treturn contain(s.p1) && contain(s.p2);\n\t}\n};\n\n\n\nint main(void) {\n\t\n\twhile(1) {\n\t\tint N; scanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tdouble sx, sy, ex, ey; scanf(\"%lf %lf %lf %lf\", &sx, &sy, &ex, &ey);\n\t\tdouble minx[55], miny[55], maxx[55], maxy[55], h[55];\n\t\trep(i, N) scanf(\"%lf %lf %lf %lf %lf\", &minx[i], &miny[i], &maxx[i], &maxy[i], &h[i]);\n\n\t\tSegment L(Point(sx, sy), Point(ex, ey));\n\n\t\tdouble ans = INF;\n\t\trep(i, N) {\n\t\t\tvector<Point> tmp({Point(minx[i], miny[i]), Point(maxx[i], miny[i]), Point(maxx[i], maxy[i]), Point(minx[i], maxy[i])});\n\t\t\tRectangle rec(tmp);\n\t\t\tif(rec.intersect(L) || rec.contain(L)) {\n\t\t\t\tans = 0.0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdouble d = INF;\n\t\t\tchmin(d, getDistanceSS(L, Segment(Point(minx[i], miny[i]), Point(minx[i], maxy[i]))));\n\t\t\tchmin(d, getDistanceSS(L, Segment(Point(minx[i], maxy[i]), Point(maxx[i], maxy[i]))));\n\t\t\tchmin(d, getDistanceSS(L, Segment(Point(maxx[i], maxy[i]), Point(maxx[i], miny[i]))));\n\t\t\tchmin(d, getDistanceSS(L, Segment(Point(maxx[i], miny[i]), Point(minx[i], miny[i]))));\n\n\t\t\tdouble r;\n\t\t\tif(d <= h[i]) r = d;\n\t\t\telse r = (d * d + h[i] * h[i]) / (2 * h[i]);\n\n\t\t\tchmin(ans, r);\n\t\t}\n\t\tprintf(\"%.9f\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#define REP(i, a, n) for(int i =(a); i < (n); i++)\nusing namespace std;\n\nstruct point { int x, y; };\nstruct line { point p, q; };\nstruct rect { point p[4]; line l[4]; };\n\nint N, LX[50], LY[50], RX[50], RY[50], H[50];\npoint S, E;\nline c;\nrect o[50];\ndouble d[50];\n\nbool intersect(line l1, line l2) {\n  double ax = l1.p.x, ay = l1.p.y;\n  double bx = l1.q.x, by = l1.q.y;\n  double cx = l2.p.x, cy = l2.p.y;\n  double dx = l2.q.x, dy = l2.q.y;\n  double ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n  double tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n  double tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n  double td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n  return tc * td <= 0 && ta * tb <= 0;\n}\n\ndouble distance(line l, point p) {\n  double x0 = p.x, y0 = p.y;\n  double x1 = l.p.x, y1 = l.p.y;\n  double x2 = l.q.x, y2 = l.q.y;\n  double a = x2 - x1;\n  double b = y2 - y1;\n  double a2 = a * a;\n  double b2 = b * b;\n  double r2 = a2 + b2;\n  double tt = -(a*(x1 - x0) + b*(y1 - y0));\n  if(tt < 0) return sqrt((x1 - x0)*(x1-x0) + (y1 - y0)*(y1-y0));\n  if(tt > r2) return sqrt((x2 - x0)*(x2 - x0) + (y2 - y0)*(y2 - y0));\n  double f1 = a*(y1 - y0) - b*(x1 - x0);\n  return sqrt((f1*f1)/r2);\n}\n\nbool check(double r) {\n  REP(i, 0, N) if(d[i] < sqrt(pow(r, 2) - pow(r - min(r, (double) H[i]), 2))) return false;\n  return true;\n}\n\ndouble solve() {\n  REP(i, 0, N) REP(j, 0, 4) {\n    if(intersect(c, o[i].l[j])) return 0;\n    if(LX[i] <= S.x && S.x <= RX[i] && LY[i] <= S.y && S.y <= RY[i]) return 0;\n    if(LX[i] <= E.x && E.x <= RX[i] && LY[i] <= E.y && E.y <= RY[i]) return 0;\n  }\n\n  REP(i, 0, N) {\n    d[i] = 1e10;\n    REP(j, 0, 4) {\n      d[i] = min(d[i], distance(c, o[i].p[j]));\n      d[i] = min(d[i], distance(o[i].l[j], S));\n      d[i] = min(d[i], distance(o[i].l[j], E));\n    }\n  }\n\n  double low = 0, high = 1005;\n  REP(i, 0, 100) {\n    double mid = (low + high) * 0.5;\n    if(check(mid)) low = mid;\n    else high = mid;\n  }\n  return low;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    cin >> S.x >> S.y >> E.x >> E.y;\n    c = (line) { S, E };\n\n    REP(i, 0, N) {\n      cin >> LX[i] >> LY[i] >> RX[i] >> RY[i] >> H[i];\n      o[i].p[0] = (point) { LX[i], LY[i] };\n      o[i].p[1] = (point) { LX[i], RY[i] };\n      o[i].p[2] = (point) { RX[i], RY[i] };\n      o[i].p[3] = (point) { RX[i], LY[i] };\n      o[i].l[0] = (line) { o[i].p[0], o[i].p[1] };\n      o[i].l[1] = (line) { o[i].p[1], o[i].p[2] };\n      o[i].l[2] = (line) { o[i].p[2], o[i].p[3] };\n      o[i].l[3] = (line) { o[i].p[3], o[i].p[0] };\n    }\n\n    printf(\"%.8lf\\n\", solve());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef complex<double> C;\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nbool eq(C c1,C c2)\n{\n  return (eq(c1.real(),c2.real()) && eq(c1.imag(),c2.imag()));\n}\n\n//?????¶??????sqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return  arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return  imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return  real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n//??´???????????????????????????(????????´??????True)\nbool intersectLL(const L &l, const L &m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//??´?????¨?????????????????????(????????±??????????????¨??????)\nbool intersectLS(const L &l, const L &s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//??´?????¨????????????(??±???)??????\nbool intersectLP(const L &l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//??????????????????????????????(????????±??????????????¨??????)\nbool intersectSS(const L &s, const L &t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//????????¨????????????(??±???)??????\nbool intersectSP(const L &s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//???p?????´???l???????°???±\nC projection(const L &l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//???p?????´???l????????¨??????????§°?§????\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//?????¨??´???????????¢\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//??´?????¨??´???????????¢\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//??´?????¨??????????????¢\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//????????¨???????????¢\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//????????¨??????????????¢\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n//??´???????????????????????????\nC crosspointLL(const L &l, const L &m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//?????¨??´????????????\ndouble gettime(C c1,C c2)\n{\n  return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//?????¨??´????????????\nvector<C> crosspointCL(C c1,double r1,L l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n//?????¨???????????????\nvector<C> crosspointCS(C c1,double r1,L s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(eq(abs(s[1]-s[0]),abs(s[0]-tmp[i])+abs(s[1]-tmp[i]))){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//?????????????????????\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n  C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n  C d = b*b-4.0*a*c;\n  C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n  return L(z1, z2);\n}\n//?????¨????§???¢?????±?????¨????????¢???\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\ndouble getcrossarea(vector<C> t,C c1,double r1)\n{\n    int n=t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//??????????±???????\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//?????§??????\nbool isconvex(const vector<C> &ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//????§???¢?????¢???\ndouble area(const vector<C> &ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//???????§???¢?????´?????§???????????????????????´????????¢\nvector<C> convex_cut(const vector<C> &ps, const L &l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//??????????§???¢???????????????????????????(0??????????????????,1?????????,2???????????????)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//???????§???¢?????´???????±???????(?????£????????????)\n//maxi,maxj?????????????????¨??????\ndouble convex_diameter(const vector<C> &ps)\n{\n    const int n = ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\n//????????????????±???????\ndouble closest_pair(C *a, int n)\n{\n    if(n<=1) return INF;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\ndouble compute_shortest(C *a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2??????????????¢????????????(????????????2??????????????±?????\\????????°)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//?????????????????\\???????????????????????\\???\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//????????????????????\\???\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //??????????????¨??????????????´???\n    if(eq(s,t)){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2????????±????????\\???????±???????\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2????????±????????\\???????±???????\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2????????±?????\\???????±???????(?????´??????????????????????????????????????\\???)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nbool possible(const L &l1,const vector<L>* vec,int n,double r,vector<int>& h)\n{\n    bool flag = true;\n    rep(i,n){\n        double mn = INF;\n        rep(j,vec[i].size()){\n            mn = min(mn,distanceSS(l1,vec[i][j]));\n        }\n        if(mn < r){\n            if(r - sqrt(r*r - mn*mn) < h[i]){\n                flag = false;\n                break;\n            }\n        }\n    }\n    return flag;\n}\n\nint main()\n{\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        int sx,sy,ex,ey;\n        cin >> sx >> sy >> ex >> ey;\n        L l1 = L(C(sx,sy),C(ex,ey));\n        vector<int> h(51);\n        vector<C> con[51];\n        vector<L> l[51];\n        bool flag = false;\n        rep(i,n){\n            int a,b,c,d;\n            cin >> a >> b >> c >> d >> h[i];\n            l[i].pb(L(C(a,b),C(a,d)));\n            l[i].pb(L(C(a,b),C(c,b)));\n            l[i].pb(L(C(a,d),C(c,d)));\n            l[i].pb(L(C(c,b),C(c,d)));\n            con[i].pb(C(a,b)),con[i].pb(C(a,d)),con[i].pb(C(c,b)),con[i].pb(C(c,d));\n            if(contains(con[i],l1[0]) || contains(con[i],l1[1])){\n                flag = true;\n                cout << \"0\\n\";\n                break;\n            }\n        }\n        if(flag){\n            continue;\n        }\n        double low = 0;\n        double high = 1001;\n        while(1){\n            double mid = (low+high)/2;\n            if(abs(mid-low) < EPS){\n                printf(\"%.10f\\n\",mid);\n                break;\n            }\n            if(possible(l1,l,n,mid,h)){\n                low = mid;\n            }else{\n                high = mid;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\n// テ・ツ?・テ・ツ環崚」ツつケテ」ツδ暗」ツδェテ」ツδシテ」ツδ?」ツ?凝」ツつ嘉・ツョツ淌ヲツ閉ーテ、ツコツ古」ツ?、テ」ツつ津」ツ?ィテ」ツ?」テ」ツ?ヲ Point テ」ツ?ク\nistream& operator >> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\n// テ・ツ??ァツゥツ催ッツシツ暗」ツδ嘉」ツδε」ツδ暗ァツゥツ催ッツシツ?\ndouble dot( const Point &a, const Point &b )\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\n\n// テ・ツ、ツ姪ァツゥツ催ッツシツ暗」ツつッテ」ツδュテ」ツつケテァツゥツ催ッツシツ?\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\n// テァツ崢エテァツキツ?( p1, p2 ) テ」ツ?ィテァツつケ q テ」ツ?ョティツキツ敕ゥツ崢「\ndouble distance_line_point( const Point &p1, const Point &p2, const Point &q )\n{\n\treturn abs( cross( p2 - p1, q - p1 ) ) / abs( ( p2 - p1 ) );\n}\n\n// テァツキツ堙・ツ按?( p1, p2 ) テ」ツ?ィテァツつケ q テ」ツ?ョティツキツ敕ゥツ崢「\ndouble distance_segment_point( const Point &p1, const Point &p2, const Point q )\n{\n\tif ( EPS < dot( p2 - p1, q - p1 ) && EPS < dot( p1 - p2, q - p2 ) ) // テ・ツ楪づァツキツ堙」ツ?古、ツコツ、テ」ツつ湘」ツつ?\n\t{\n\t\treturn distance_line_point( p1, p2, q );\n\t}\n\telse\n\t{\n\t\treturn min( abs( p1 - q ), abs( p2 - q ) );\n\t}\n}\n\n// テァツキツ堙・ツ按?( p1, p2 ) テ」ツ?ォテァツつケ q テ」ツ?古、ツケツ療」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝」ツ??\nbool segment_point_intersect( const Point &p1, const Point &p2, const Point &q )\n{\n\t// テァツォツッテァツつケテ」ツ?凝」ツつ嘉」ツ?ョ q テ」ツ?クテ」ツ?ョテ」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツ?ョテ・ツ、ツ姪ァツゥツ催」ツ??0 テ「ツ??テァツォツッテァツつケテ」ツ?凝」ツつ嘉」ツ?ョテ」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツ?古、ツクツヲティツ。ツ?テ「ツ??テァツ崢エテァツキツ?( p1, p2 ) テ」ツ?ォテァツつケ q テ」ツ?古、ツケツ療」ツつ?\n\t// q テ」ツ?凝」ツつ嘉ァツォツッテァツつケテ」ツ?クテ」ツ?ョテ」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツ?ョテ・ツ??ァツゥツ催」ツ??0 テ、ツサツ・テ、ツクツ?テ「ツ??テァツつケ p テ」ツ??p1, p2 テ」ツ?ョテ・ツ??・ツ?エテ」ツ?ォテ」ツ?づ」ツつ?\n\treturn abs( cross( p1 - q, p2 - q ) ) <= EPS && dot( p1 - q, p2 - q ) <= EPS;\n}\n\n// テァツ崢エテァツキツ?( p1, p2 ) テ」ツ?ィテァツ崢エテァツキツ?( q1, q2 ) テ」ツ?ョテ、ツコツ、テァツつケ\nPoint lines_intersection( const Point &p1, const Point &p2, const Point &q1, const Point &q2 )\n{\n\treturn p1 + ( p2 - p1 ) * ( cross( q2 - q1, q1 - p1 ) / cross( q2 - q1, p2 - p1 ) );\n}\n\n// テァツキツ堙・ツ按?( p1, p2 ) テ」ツ?ィテァツキツ堙・ツ按?( q1, q2 ) テ」ツ?古、ツコツ、テ・ツキツョテ」ツ?凖」ツつ凝」ツ??\nbool segments_intersect( const Point &p1, const Point &p2, const Point &q1, const Point &q2 )\n{\t\t\n\tif ( abs( cross( p1 - p2, q1 - q2 ) ) <= EPS ) // テ、ツコツ古ァツ崢エテァツキツ堙」ツ?古、ツクツヲティツ。ツ古」ツ?ェテ・ツ?エテ・ツ青?\n\t{\n\t\t// テァツ可?ヲツ鳴ケテ」ツ?ョテァツキツ堙・ツ按?」ツ?ォテ、ツサツ姪ヲツ鳴ケテ」ツ?ョテァツォツッテァツつケテ」ツ?古、ツケツ療」ツつ凝」ツ??\n\t\treturn segment_point_intersect( p1, p2, q1 ) ||\n\t\t\t   segment_point_intersect( p1, p2, q2 ) ||\n\t\t\t   segment_point_intersect( q1, q2, p1 ) ||\n\t\t\t   segment_point_intersect( q1, q2, p2 );\n\t}\n\telse\n\t{\n\t\t// テ、ツコツ古ァツ崢エテァツキツ堙」ツ?ョテ、ツコツ、テァツつケテ」ツ?古、ツクツ。テヲツ鳴ケテ」ツ?ョテァツキツ堙・ツ按?」ツ?ォテ、ツケツ療」ツつ凝」ツ??\n\t\tPoint r( lines_intersection( p1, p2, q1, q2 ) );\n\t\treturn segment_point_intersect( p1, p2, r ) && segment_point_intersect( q1, q2, r );\n\t}\n}\n\ndouble maxRadius( const Point &s, const Point &g, const Point &p, const double h )\n{\n\tconst double dist_ground = distance_segment_point( s, g, p );\n\n\tif ( dist_ground - EPS <= h )\n\t{\n\t\treturn dist_ground;\n\t}\n\n\tdouble lb = 0, ub = 1000;\n\tconst Point top = Point( dist_ground, h );\n\tREP( times, 0, 1000 )\n\t{\n\t\tconst double mid = ( lb + ub ) / 2;\n\t\tconst Point center = Point( 0, mid );\n\n\t\tif ( abs( center - top ) < mid - EPS )\n\t\t{\n\t\t\tub = mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlb = mid;\n\t\t}\n\t}\n\n\treturn lb;\n}\n\ndouble solve( const Point &s, const Point &g, const vector<Point> &pmin, const vector<Point> &pmax, const vector<double> &hs )\n{\n\tconst int N = pmin.size();\n\tvector< vector<Point> > ps( N );\n\tREP( i, 0, N )\n\t{\n\t\tps[i].PB( Point( pmin[i].real(), pmin[i].imag() ) );\n\t\tps[i].PB( Point( pmax[i].real(), pmin[i].imag() ) );\n\t\tps[i].PB( Point( pmax[i].real(), pmax[i].imag() ) );\n\t\tps[i].PB( Point( pmin[i].real(), pmax[i].imag() ) );\n\t}\n\n\t// テァツオツ古ィツキツッテ」ツ?ョテ、ツクツ甘」ツ?ォテ」ツδ姪」ツδュテ」ツδε」ツつッ\n\tREP( i, 0, N )\n\t{\n\t\tREP( j, 0, 4 )\n\t\t{\n\t\t\tif ( segments_intersect( s, g, ps[i][j], ps[i][ ( j + 1 ) % 4 ] ) )\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// テ・ツァツ凝ァツつケテ」ツδサテァツオツづァツつケテ」ツ?古」ツδ姪」ツδュテ」ツδε」ツつッテ」ツ?ョテ、ツクツ?\n\t{\n\t\tvector<Point> sg;\n\t\tsg.PB( s );\n\t\tsg.PB( g );\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tREP( j, 0, 2 )\n\t\t\t{\n\t\t\t\tif ( pmin[i].real() - EPS <= sg[j].real() && sg[j].real() <= pmax[i].real() + EPS && \n\t\t\t\t\t\tpmin[i].imag() - EPS <= sg[j].imag() && sg[j].imag() <= pmax[i].imag() + EPS )\n\t\t\t\t{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble res = 1000;\n\tREP( i, 0, N )\n\t{\n\t\tREP( j, 0, 4 )\n\t\t{\n\t\t\tres = min( res, maxRadius( s, g, ps[i][j], hs[i] ) );\n\t\t\tres = min( res, maxRadius( ps[i][j], ps[i][ ( j + 1 ) % 4 ], s, hs[i] ) );\n\t\t\tres = min( res, maxRadius( ps[i][j], ps[i][ ( j + 1 ) % 4 ], g, hs[i] ) );\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\tcout << setprecision( 8 ) << fixed;\n\n\tfor ( int n; cin >> n, n; )\n\t{\n\t\tPoint s, g;\n\t\tcin >> s >> g;\n\n\t\tvector<Point> pmin( n ), pmax( n );\n\t\tvector<double> hs( n );\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tcin >> pmin[i] >> pmax[i] >> hs[i];\n\t\t}\n\n\t\tcout << solve( s, g, pmin, pmax, hs ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n\n#define X() real()\n#define Y() imag()\n#define x(p) (p).X()\n#define y(p) (p).Y()\n#define SZ(P) (int)(P.size())\n#define curr(P, i) P[(i)%SZ(P)]\n#define next(P, i) P[(i+1)%SZ(P)]\n#define prev(P, i) P[(i+SZ(P)-1)%SZ(P)]?´\n\nusing D = double;\nusing P = complex<D>;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return x(a) != x(b) ? x(a) < x(b) : y(a) < y(b);\n  }\n}\nD dot(const P& a, const P& b) {\n  return x(conj(a)*b);\n}\nD cross(const P& a, const P& b) {\n  return y(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a;\n  c -= a;\n  if(cross(b, c) > 0) return +1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return +2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nstruct L : public vector<P> {\n  L() {}\n  L(const P& a, const P& b) {\n    push_back(a);\n    push_back(b);\n  }\n};\n\nconst D EPS = 1e-8;\n\n\n\nbool interSP(const L& l, const P& p) {\n  return abs(l[0]-p) + abs(l[1]-p) - abs(l[0]-l[1]) < EPS;\n}\nbool interSS(const L& s, const L& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\nP proj(const L& s, const P& p) {\n  P v = s[0] - s[1];\n  D t = dot(p-s[0], v) / norm(v);\n  return s[0] + t*v;\n}\nD distSP(const L& s, const P& p) {\n  P r = proj(s, p);\n  if(interSP(s, r)) return abs(r-p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\nD distSS(const L& s, const L& t) {\n  if(interSS(s, t)) return 0.0;\n  return min({distSP(s, t[0]), distSP(s, t[1]), distSP(t, s[0]), distSP(t, s[1])});\n}\nusing G = vector<P>;\nstruct C{\n  P p;\n  D r;\n};\nbool include(const C& c, const P& p) {\n  return abs(c.p - p) < c.r - EPS;\n}\nbool isContain(const G& g, const P& p) {\n  bool in = false;\n  rep(i, g.size()) {\n    P a = curr(g, i) - p, b = next(g, i) - p;\n    if(y(a) > y(b)) swap(a, b);\n    if(y(a) <= 0 && 0 < y(b)) {\n      if(cross(a, b) < 0) in = !in;\n    }\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return true;\n  }\n  return in;\n}\n\nint main() {\n  cout << fixed << setprecision(20);\n  int n;\n  while(cin >> n && n) {\n    L l;\n    {\n      D xa, ya, xb, yb;\n      cin >> xa >> ya >> xb >> yb;\n      l = L{P{xa, ya}, P{xb, yb}};\n    }\n    const D INF = 1e18;\n    vector<D> d, h;\n    bool flag = true;\n    rep(i, n) {\n      D xa, ya, xb, yb, hh;\n      cin >> xa >> ya >> xb >> yb >> hh;\n      G g;\n      g.push_back({xa, ya});\n      g.push_back({xa, yb});\n      g.push_back({xb, yb});\n      g.push_back({xb, ya});\n      reverse(g.begin(), g.end());\n      if(isContain(g, l[0]) || isContain(g, l[1])) flag = false;\n      D dist = 1e18;\n      rep(i, 4) {\n\tdist = min(dist, distSS(l, L{curr(g, i), next(g, i)}));\n\tif(interSS(l, L{curr(g, i), next(g, i)})) {\n\t  flag = false;\n\t}\n      }\n      d.push_back(dist);\n      h.push_back(hh);\n    }\n    if(!flag) {\n      cout << 0 << endl;\n      continue;\n    } \n    D ans = 1e18;\n    rep(i, n) {\n      if(d[i] < h[i]) ans = min(ans, d[i]);\n      else ans = min(ans, (d[i]*d[i]+h[i]*h[i])/(2.0*h[i]));\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\nint n;\nint sx,sy,gx,gy;\nint xa[SIZE],ya[SIZE],xb[SIZE],yb[SIZE],h[SIZE];\n\ntypedef double P_type;\ntypedef complex<P_type> P;\nconst P_type P_eps = 1e-8;\n\n//??????\ndouble dot(P a, P b) {\n  return (a * conj(b)).real();\n}\n\n//??????\ndouble cross(P a, P b) {\n  return (a * conj(b)).imag();\n}\n\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < P_eps ) return abs(c-a);\n  if ( dot(a-b, c-b) < P_eps ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n/* ?????????????????? */\nbool IntersectionSS(P a1, P a2, P b1, P b2){\n    \n  //??????a ??¨ ??´???b\n  P_type a = cross(b1-b2,a1-b1);\n  P_type b = cross(b1-b2,a2-b1);\n  \n  //??????b ??¨ ??´???a\n  P_type c = cross(a1-a2,b1-a1);\n  P_type d = cross(a1-a2,b2-a1);\n  \n  if(a*b < -P_eps && c*d < -P_eps) // T?????????????????? -P_eps\n    return true;\n  else\n    return false;\n}\n\nbool check(double r){\n  \n  P l_s = P(sx,sy);\n  P l_g = P(gx,gy);\n  \n  for(int i=0;i<n;i++){\n    P p[4];\n    p[0] = P(xa[i],ya[i]);\n    p[1] = P(xa[i],yb[i]);\n    p[2] = P(xb[i],yb[i]);\n    p[3] = P(xb[i],ya[i]);\n    double H = min((double)h[i],r);\n    double R = sqrt(r*r - (r-H)*(r-H));\n\n    for(int j=0;j<4;j++){\n      double dis = distance_ls_p(l_s, l_g, p[j]);\n      bool is = IntersectionSS(l_s,l_g,p[j],p[(j+1)%4]);\n      bool in = (xa[i] <= sx && sx <= xb[i] && ya[i] <= sy && sy <= yb[i]) ||\n        (xa[i] <= gx && gx <= xb[i] && ya[i] <= gy && gy <= yb[i]);\n      \n      if(dis < R || is || in){\n        return false;\n      }\n    }\n  }\n  \n  for(int i=0;i<n;i++){\n    P p[4];\n    p[0] = P(xa[i],ya[i]);\n    p[1] = P(xa[i],yb[i]);\n    p[2] = P(xb[i],yb[i]);\n    p[3] = P(xb[i],ya[i]);\n    double H = min((double)h[i],r);\n    double R = sqrt(r*r - (r-H)*(r-H));\n\n    for(int j=0;j<4;j++){\n      double dis1 = distance_ls_p(p[j],p[(j+1)%4],l_s);\n      double dis2 = distance_ls_p(p[j],p[(j+1)%4],l_g);\n      \n      if(dis1 < R || dis2 < R){\n        return false;\n      }\n    }\n\n  }\n  \n  return true;\n}\n\nbool solve(){\n  \n  \n  scanf(\"%d\",&n);\n\n  if(n == 0) return false;\n\n  scanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d%d%d%d\",xa+i, ya+i, xb+i, yb+i, h+i);\n  }\n\n  double l=0, r=1000;\n\n  while(r-l > 1e-8){\n    double mid = (l+r)/2;\n\n    if(check(mid)){\n      l = mid;\n    }else{\n      r = mid;\n    }\n  }\n\n  printf(\"%.7lf\\n\",l);\n  \n  return true;\n}\n\nint main(){\n\n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\nconst int INF = 1 << 30;\nconst double EPS = 1e-8;\n\ntemplate<class T> bool eq(T a, T b) { return abs(a - b) < EPS; }\n#define CPR const Point&\nusing Point = complex<double>;\n#define X(a) real(a)\n#define Y(a) imag(a)\nistream &operator >> (istream& is, Point& p) { double a, b; is >> a >> b; p.X(a); p.Y(b); return is; }\n\ndouble dot(CPR a, CPR b) { return a.X() * b.X() + a.Y() * b.Y(); }\ndouble cross(CPR a, CPR b) { return a.X() * b.Y() - a.Y() * b.X(); }\ndouble length2(CPR p) { return p.X() * p.X() + p.Y() * p.Y(); }\ndouble length(CPR p) { return sqrt(length2(p)); }\ndouble distance(CPR a, CPR b) { return length(a - b); }\nPoint unit(CPR p) { return p / length(p); }\n\nenum ccw_t {\n    COUNTER_CLOCK_WISE = 1,\n    CLOCK_WISE = -1,\n    STRAIGHT_C_A_B = 2,\n    STRAIGHT_A_B_C = -2,\n    STRAIGHT_A_C_B = 0\n};\n\nccw_t ccw(CPR a, CPR b, CPR c){\n    Point ab = b - a, ac = c - a;\n    if( cross(ab,ac) > EPS ) return COUNTER_CLOCK_WISE; // +1 a-b-c ???????¨???????\n    if( cross(ab,ac) < -EPS ) return CLOCK_WISE;        // -1 a-b-c ????¨???????\n    if( dot(ab,ac) < -EPS ) return STRAIGHT_C_A_B;      // +2 c-a-b\n    if( length2(ab) < length2(ac) )return STRAIGHT_A_B_C;     // -2 a-b-c or a==b\n    return STRAIGHT_A_C_B;                              //  0 a-c-b or b==c or a==c\n}\n\n#define CSR const Segment&\nstruct Segment {\n    Point a, b;\n    Segment(){}\n    Segment(const Point& a, const Point& b):a(a), b(b){}\n    pair<Point,Point> to_pair() const { return make_pair(a,b); }\n    bool operator == (CSR s) const { return to_pair() == s.to_pair();}\n    bool operator != (CSR s) const { return !(*this == s); }\n    friend istream &operator >> (istream& is, Segment &s){ return is >> s.a >> s.b;}\n    friend ostream &operator << (ostream& os, CSR s) { return os << s.a << \"->\" << s.b;}\n};\ndouble length(CSR s) { return distance(s.a, s.b); }\nbool contain(CSR s, CPR p) {\n    return ccw(s.a, s.b, p) == 0; // STRAIGHT_A_C_B;\n}\nPoint projection(CSR s, CPR p) {\n    Point v = s.b - s.a;\n    double t = dot(p - s.a, v) / length2(v); // ??????\n    return v * t + s.a;\n}\nPoint closest_point(CSR s, CPR p) {\n    Point pp = projection(s, p);\n    return contain(s, pp) ? pp : distance(s.a, p) < distance(s.b, p) ? s.a : s.b;\n}\ndouble distance(CSR s, CPR p) {\n    if( dot(s.b - s.a ,p - s.a) < EPS ) return distance(p, s.a);\n    if( dot(s.a - s.b ,p - s.b) < EPS ) return distance(p, s.b);\n    return abs(cross(s.b - s.a, p - s.a) / length(s));\n}\nbool intersect(CSR s, CSR t) { // ????????????\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 and ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\nstruct Rectangle {\n    array<Point, 4> p;\n    // order:\n    //     3 2\n    //     0 1\n    Rectangle(const array<Point, 4> &pp):p(pp) {\n        // ????????????????????????????????????\n        rep(i, 3) repeat(j, i + 1, 4) {\n            int cnt = 0;\n            rep(k, 4) if(k != i and k != j){\n                cnt += ccw(p[i], p[j], p[k]) == COUNTER_CLOCK_WISE;\n            }\n            if(cnt == 2) {\n                swap(p[i + 1], p[j]);\n                break;\n            }\n        } \n    }\n    bool intersect(CSR s) {\n        bool res = false;\n        rep(i, 4) res |= ::intersect(s, Segment(p[i], p[(i + 1) % 4]));\n        return res;\n    }\n    bool contain(CPR pp) {\n        bool flg = true;\n        rep(i, 4) flg &= ccw(p[i], p[(i + 1) % 4], pp) == COUNTER_CLOCK_WISE;\n        return flg;\n    }\n    bool contain(CSR s) {\n        return contain(s.a) and contain(s.b);\n    }\n    Point closest_point(CPR pp) {\n        Point res = p[0];\n        rep(i, 4) {\n            Point ppp = ::closest_point(Segment(p[i], p[(i+1)%4]), pp);\n            if(distance(res, pp) > distance(ppp, pp)) res = ppp;\n        }\n        return res;\n    }\n    Point closest_point(CSR s) {\n        Point res = p[0];\n        repeat(i, 1, 4) if(distance(s, res) > distance(s, p[i])) res = p[i];\n        for(Point pp : {s.a, s.b}) {\n            Point ppp = closest_point(pp);\n            if(distance(s, res) > distance(s, ppp)) res = ppp;\n        }\n        return res;\n    }\n};\n\n\nclass Solver {\n  public:\n    Segment S;\n    vector<Point> minP, maxP;\n    vector<double> H;\n    bool solve() {\n\n        int N; cin >> N;\n        if(not N) return false;\n        cin >> S;\n        minP.resize(N);\n        maxP.resize(N);\n        H.resize(N);\n        rep(i, N) cin >> minP[i] >> maxP[i] >> H[i];\n        \n        double max_r = INF;\n\n        rep(i, N) {            \n            Rectangle rect({minP[i], maxP[i], Point(minP[i].X(), maxP[i].Y()), Point(maxP[i].X(), minP[i].Y())});\n\n            if(rect.intersect(S) or rect.contain(S)) {\n                cout << 0 << endl;\n                return true;\n            }\n\n            double d = distance(S, rect.closest_point(S));\n            double r = (d * d + H[i] * H[i]) / (2 * H[i]);\n            if(r < H[i]) r = d;\n            set_min(max_r, r);\n        }\n\n        cout << max_r << endl;\n        return true;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\npair<double,double> relv(pair<double,double> a,pair<double,double> b)\n{\n  return make_pair(a.first-b.first,a.second-b.second);\n}\ndouble dot(pair<double,double> va,pair<double,double> vb)\n{\n  return va.first*vb.first+va.second*vb.second;\n}\ndouble cross(pair<double,double> va,pair<double,double> vb)\n{\n  return va.first*vb.second-va.second*vb.first;\n}\ndouble norm(pair<double,double> va){\n  return sqrt(va.first*va.first+va.second*va.second);\n}\ndouble dpseg(pair<double,double> p,pair<double,double> a,pair<double,double> b)\n{\n  if(dot(relv(p,a),relv(b,a))>0 && dot(relv(p,b),relv(a,b))>0)\n    return abs(cross(relv(p,a),relv(b,a))/norm(relv(b,a)));\n  else return min(norm(relv(p,a)),norm(relv(p,b)));\n}\ndouble dvec(pair<double,double> v,pair<double,double> a,pair<double,double> b)\n{\n  return v.first*(a.first-b.first)-v.second*(a.second-b.second);\n}\ndouble dsegseg(pair<double,double> a,pair<double,double> b,pair<double,double> c,pair<double,double> d)\n{\n  double answer=1e+9;\n  if(cross(relv(a,b),relv(a,c))*cross(relv(a,b),relv(a,d)) < 0 &&\n     cross(relv(c,d),relv(c,a))*cross(relv(c,d),relv(c,b)) < 0) return 0.0;\n  //cout << c.first << ' ' << c.second << ' ' << d.first << ' ' << d.second << endl;\n  answer=min(answer,dpseg(a,c,d));\n  answer=min(answer,dpseg(b,c,d));\n  answer=min(answer,dpseg(c,a,b));\n  answer=min(answer,dpseg(d,a,b));\n  //cout << answer << endl;\n  return answer;\n}\ndouble calr(double h,double d)\n{\n  double r;\n  if(h>=d) r=d;\n  else r=(h*h+d*d)/h/2;\n  //cout << h << ' ' << d << ' ' << r << endl;\n  return r;\n}\nint main(void)\n{\n  cout << fixed << setprecision(10) << endl;\n  for(;;){\n    int n;\n    cin >> n;\n    if(!n) return 0;\n    int sx,sy,ex,ey;\n    cin >> sx >> sy >> ex >> ey;\n    pair<double,double> s,e;\n    s=make_pair(sx,sy),e=make_pair(ex,ey);\n    double answer=1e+9;\n    REP(i,n){\n      int l,u,r,b,h;\n      cin >> l >> u >> r >> b >> h;\n      if(l<=sx&&sx<=r&&u<=sy&&sy<=b) answer=0.0;\n      answer=min(answer,calr(h,dsegseg(s,e,make_pair(l,u),make_pair(r,u))));\n      answer=min(answer,calr(h,dsegseg(s,e,make_pair(l,b),make_pair(r,b))));\n      answer=min(answer,calr(h,dsegseg(s,e,make_pair(l,u),make_pair(l,b))));\n      answer=min(answer,calr(h,dsegseg(s,e,make_pair(r,u),make_pair(r,b))));\n\n      \n    }\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// cpp_range (generic range class, very small equivalent of boost::irange)\n// (C) @cielavenir under Boost Software License.\n// note: end position is exclusive.\n\n#include <iterator>\ntemplate<typename T>\nclass range{\npublic:\n\tstruct iterator{\n\t\tconst T a,b;\n\t\tT p;\n\t\tconst long long d; //because T might be unsigned.\n\t\titerator(T _a,T _b,T _p,long long _d=1):a(_a),b(_b),p(_p),d(_d){}\n\n\tpublic:\n\t\ttypedef T value_type;\n\t\ttypedef T& reference;\n\t\ttypedef T* pointer;\n\t\ttypedef std::ptrdiff_t difference_type;\n\t\ttypedef std::random_access_iterator_tag iterator_category;\n\n\t\t//copy\n\t\titerator(const iterator &other):a(other.a),b(other.b),p(other.p),d(other.d){}\n\t\titerator operator=(const iterator &other){return iterator(other.a,other.b,other.p,other.d);}\n\n\t\t//advance\n\t\titerator& operator+=(T n){p+=n*d;return *this;}\n\t\titerator& operator-=(T n){return *this+=(-n);}\n\t\titerator& operator++(){return *this+=1;}\n\t\titerator& operator--(){return *this-=1;}\n\t\titerator operator+(T n) const{return iterator(a,b,p+n*d);}\n\t\titerator operator-(T n) const{return *this+(-n);}\n\n\t\t//difference\n\t\tT operator-(const iterator& other) const{return p-other.p;}\n\n\t\t//equality\n\t\tbool operator==(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p==other.p;}\n\t\tbool operator!=(const iterator& other) const{return !(*this==other);}\n\n\t\t//compare\n\t\tbool operator<(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p*d<other.p*d;}\n\t\tbool operator>(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p*d>other.p*d;}\n\n\t\t//reference\n\t\tconst T& operator*() const{return p;}\n\t};\n\nprivate:\n\tconst T a,b;\n\tT siz;\n\tlong long d;\npublic:\n\trange(T _a,T _b,long long _d=1):a(_a),b(_b){\n\t\td=_d;\n\t\td=d==0?1:d; //\n\t\tsiz=( (d>0?(b-a):(a-b)) - 1)  / (d>0?d:-d);\n\t}\n\n\tT operator[](T n){return a+n*d;}\n\titerator begin(){return iterator(a,a+d*siz,a,d);}\n\titerator end(){return iterator(a,a+d*siz,a+d*(siz+1),d);}\n\titerator rbegin(){return iterator(b-d*siz,b,b,-1*d);}\n\titerator rend(){return iterator(b-d*siz,b,b-d*(siz+1),-1*d);}\n\tT size(){return siz;}\n};\ntemplate<typename T>\nrange<T> make_range(T a,T b,long long d=1){return range<T>(a,b,d);}\n\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cfloat>\nusing namespace std;\ntypedef double val_t;\ntypedef complex<val_t> P;\ntypedef vector<P> VP;\nconst val_t EPS=1e-9;\n\nval_t cross(const P &a,const P &b){return (conj(a)*b).imag();}\nval_t dot(const P &a,const P &b){return (conj(a)*b).real();}\nP projection(const VP &l,const P &p){\n\tP t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n\treturn l[0]+t*(l[0]-l[1]);\n}\nbool intersectSP(const VP &s,const P &p){\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nval_t distanceSP(const VP &s,const P &p){\n\tP r=projection(s,p);\n\treturn intersectSP(s,r) ? abs(r-p) : min(abs(s[0]-p),abs(s[1]-p));\n}\nbool intersectSS(const VP &l,const VP &m){\n\tval_t a=cross(l[1]-l[0],m[1]-m[0]);\n\tval_t b=cross(l[1]-l[0],l[1]-m[0]);\n\tVP pt=a.abs<EPS ? b.abs<EPS ? VP({l[0],l[1],m[0],m[1]}) : VP() : VP({m[0]+b/a*(m[1]-m[0])});\n\treturn accumulate(pt.begin(),pt.end(),false,[&](bool S,const P &e){\n\t\treturn S||(dot(l[0]-e,l[1]-e)<EPS && dot(m[0]-e,m[1]-e)<EPS);\n\t});\n}\nval_t distanceSS(const VP &s,const VP &t){\n\treturn intersectSS(s,t) ? 0 : min(\n\t\taccumulate(s.begin(),s.end(),DBL_MAX,[&](val_t S,const P &e){return min(S,distanceSP(t,e));}),\n\t\taccumulate(t.begin(),t.end(),DBL_MAX,[&](val_t S,const P &e){return min(S,distanceSP(s,e));})\n\t);\n}\nint main(){\n\tint n;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tdouble sx,sy,ex,ey;\n\t\tscanf(\"%lf%lf%lf%lf\",&sx,&sy,&ex,&ey);\n\t\tVP s={P(sx,sy),P(ex,ey)};\n\t\tauto ra0=make_range(0,n);\n\t\tprintf(\"%f\\n\",accumulate(ra0.begin(),ra0.end(),DBL_MAX,[&](val_t S,int _)->val_t{\n\t\t\tint f=0;\n\t\t\tdouble x1,y1,x2,y2,h;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf\",&x1,&y1,&x2,&y2,&h);\n\t\t\tVP a;\n\t\t\tfor(auto &x:{x1,x2})for(auto &y:{y1,y2})a.emplace_back(x,y);\n\t\t\tswap(a[2],a[3]);\n\t\t\tauto ra1=make_range(0,4);\n\t\t\tval_t d=accumulate(ra1.begin(),ra1.end(),DBL_MAX,[&](val_t S,int i){\n\t\t\t\tf+=cross(a[i]-s[0],a[(i+1)%4]-s[0])<EPS;\n\t\t\t\treturn min(S,distanceSS(s,{a[i],a[(i+1)%4]}));\n\t\t\t});\n\t\t\treturn min(S,\n\t\t\t\tf==4 ? 0 : //inside\n\t\t\t\td>h ? (h*h+d*d)/h/2 :\n\t\t\t\td\n\t\t\t);\n\t\t}));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing uInt = long long unsigned int;\nusing Double = long double;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//edit\nnamespace Geometory {\n    const double EPS = 1e-10;\n\n    inline bool equals(double a, double b) {\n        return fabs(a - b) < EPS;\n    }\n\n    struct Point {\n        double x, y;\n\n        Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n        Point operator+(const Point &p) {\n            return Point(x + p.x, y + p.y);\n        }\n\n        Point operator-(const Point &p) {\n            return Point(x - p.x, y - p.y);\n        }\n\n        Point operator*(const double k) {\n            return Point(x * k, y * k);\n        }\n\n        Point operator/(const double k) {\n            return Point(x / k, y / k);\n        }\n\n        double norm() const {\n            return x * x + y * y;\n        }\n\n        double abs() const {\n            return sqrt(norm());\n        }\n\n        double dot(Point p) {\n            return x * p.x + y * p.y;\n        }\n\n        double cross(Point p) {\n            return x * p.y - y * p.x;\n        }\n\n        bool operator<(const Point &p) const {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator==(const Point &p) const {\n            return equals(x, p.x) && equals(y, p.y);\n//            return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n        }\n\n\n    };\n\n    using Vector = Point;\n\n    struct Segment {\n        Point p1, p2;\n\n        Segment() {}\n\n        Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n\n        Segment(double x1, double y1, double x2, double y2) : p1(x1, y1), p2(x2, y2) {}\n    };\n\n    using Line = Segment;\n\n\n    double norm(Vector p) {\n        return p.x * p.x + p.y * p.y;\n    }\n\n    double abs(Vector a) {\n        return sqrt(norm(a));\n    }\n\n    double dot(Vector a, Vector b) {\n        return a.dot(b);\n    }\n\n    double cross(Vector a, Vector b) {\n        return a.cross(b);\n    }\n\n    //直行判定\n    bool is_orthogonal(Vector a, Vector b) {\n        return equals(dot(a, b), 0.0);\n    }\n\n    bool is_orthogonal(Point a1, Point a2, Point b1, Point b2) {\n        return is_orthogonal(a1 - a2, b1 - b2);\n    }\n\n    bool is_orthogonal(Segment s1, Segment s2) {\n        return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n    }\n\n    //平行判定\n    bool is_parallel(Vector a, Vector b) {\n        return equals(cross(a, b), 0.0);\n    }\n\n    bool is_parallel(Point a1, Point a2, Point b1, Point b2) {\n        return is_parallel(a1 - a2, b1 - b2);\n    }\n\n    bool is_parallel(Segment s1, Segment s2) {\n        return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n    }\n\n    //反時計回り\n    static const int CCW = 1; // Counter Clockwise\n    static const int CW = -1; // Clockwise\n    static const int OB = 2; // Online Back\n    static const int OF = -2; // Online Front\n    static const int OS = 0; // On Segment\n\n    // p0を中心としたとき、p2は{反時計回り、時計回り、p2->p0->p1で同一直線上、p0->p1->p2で直線上、p2がp0p1線分上} (後ろの3つの説明は雑)\n    int ccw(Point p0, Point p1, Point p2) {\n        Vector a = p1 - p0;\n        Vector b = p2 - p0;\n        if (cross(a, b) > EPS) return CCW;\n        if (cross(a, b) < -EPS) return CW;\n        if (dot(a, b) < -EPS) return OB;\n        if (a.norm() < b.norm()) return OF;\n\n        return OS;\n    }\n\n    //交差判定\n    bool is_intersect(Point p1, Point p2, Point p3, Point p4) {\n        return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n               ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n    }\n\n    //交差判定\n    bool is_intersect(Segment s1, Segment s2) {\n        return is_intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n    }\n\n    //射影を求める\n    //pからsに垂直に線を引いたときの座標を返す\n    Point project(Segment s, Point p) {\n        Vector base = s.p2 - s.p1;\n        double r = dot(p - s.p1, base) / norm(base);\n        return s.p1 + base * r;\n    }\n\n    // 反射\n    // pを線分sを対称軸として線対称の位置にある点を求める。\n    Point reflect(Segment s, Point p) {\n//        return p + (project(s, p) - p) * 2;\n        return project(s, p) * 2 - p;\n    }\n\n\n    //距離シリーズ\n    //2点間の距離\n    double get_distance(Point a, Point b) {\n        return abs(a - b);\n    }\n\n    // 直線lと点pの距離\n    double get_distanceLP(Line l, Point p) {\n        return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n    }\n\n    // 線分sと点pの距離\n    double get_distanceSP(Segment s, Point p) {\n        if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n        if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n        return get_distanceLP(s, p);\n    }\n\n    //線分と線分の距離\n    double get_distance(Segment s1, Segment s2) {\n        if (is_intersect(s1, s2)) return 0.0;\n        return min({get_distanceSP(s1, s2.p1),\n                    get_distanceSP(s1, s2.p2),\n                    get_distanceSP(s2, s1.p1),\n                    get_distanceSP(s2, s1.p2),\n                   });\n    }\n\n    // 線分と線分の交点\n    Point get_cross_point(Segment s1, Segment s2) {\n//        Vector base = s2.p2 - s2.p1;\n//        double d1 = abs(cross(base, s1.p1 - s2.p1));\n//        double d2 = abs(cross(base, s1.p2 - s2.p1));\n//\n//        double t = d1 / (d1 + d2);\n//        return s1.p1 + (s1.p2 - s1.p1) * t;\n\n        double d1 = cross(s2.p2 - s2.p1, s2.p1 - s1.p1);\n        double d2 = cross(s2.p2 - s2.p1, s1.p2 - s1.p1);\n        if (equals(d1, 0) && equals(d2, 0)) return s1.p1;\n        if (equals(d2, 0)) throw \"no cross point\";\n\n        return s1.p1 + (s1.p2 - s1.p1) * d1 / d2;\n    }\n\n    struct Circle {\n        Point c;\n        double r;\n\n        Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n    };\n\n    //円と線分の交差判定\n    bool is_intersect(Circle c, Line l) {\n        double d = get_distanceLP(l, c.c);\n        return d - c.r < EPS;\n    }\n\n    bool is_intersect(Circle c1, Circle c2) {\n        double d = get_distance(c1.c, c2.c);\n        return d - (c1.r + c2.r) < EPS;\n    }\n\n    //円と線分の交点\n    pair<Point, Point> get_cross_points(Circle c, Line l) {\n//        assert(is_intersect(c, l));\n        if (!is_intersect(c, l)) exit(-1);\n        Vector pr = project(l, c.c);\n        Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n        double base = sqrt(c.r * c.r - norm(pr - c.c));\n        return make_pair(pr + e * base, pr - e * base);\n    }\n\n    double arg(Vector p) {\n        return atan2(p.y, p.x);\n    }\n\n    Vector polar(double a, double r) {\n        return Point(cos(r) * a, sin(r) * a);\n    }\n\n    pair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n        assert(is_intersect(c1, c2));\n        double d = abs(c1.c - c2.c);\n        double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n        double t = arg(c2.c - c1.c);\n        return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n    }\n\n    using Polygon = vector<Point>;\n\n    static const int OUT = 0;\n    static const int ON = 1;\n    static const int IN = 2;\n\n    // 点pが多角形gにあるかを判定\n    // 計算量はO(|g|)\n    int contains(Polygon g, Point p) {\n        int n = g.size();\n        bool x = false;\n        for (int i = 0; i < n; ++i) {\n            Point a = g[i] - p, b = g[(i + 1) % n] - p;\n            if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n            if (a.y > b.y) swap(a, b);\n            if (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n        }\n        return x ? IN : OUT;\n    }\n\n    // 点集合sの凸集合を求める。\n    // Andrew's Algorithmを使用\n    // 計算量はO(|s|log(|s|))\n    Polygon get_convex_hull(Polygon s) {\n        if (s.size() < 3) return s;\n        Polygon u, l;\n        sort(s.begin(), s.end());\n\n        u.push_back(s[0]);\n        u.push_back(s[1]);\n        l.push_back(s[s.size() - 1]);\n        l.push_back(s[s.size() - 2]);\n\n        //凸包の上部\n        for (int i = 2; i < s.size(); ++i) {\n            for (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) == CCW; --n) {\n                u.pop_back();\n            }\n            u.push_back(s[i]);\n        }\n\n        //凸包の下部\n        for (int i = s.size() - 3; i >= 0; --i) {\n            for (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) == CCW; --n) {\n                l.pop_back();\n            }\n            l.push_back(s[i]);\n        }\n        reverse(l.begin(), l.end());\n        for (int i = u.size() - 2; i >= 1; --i) l.push_back(u[i]);\n\n        return l;\n    }\n\n    //多角形gの面積を求める\n    double get_area(Polygon g) {\n        int n = g.size();\n        double ret = 0.0;\n        for (int i = 0; i < n; ++i) {\n            Point a = g[i], b = g[(i + 1) % n];\n            double add = (b.y - a.y) * (a.x + b.x) / 2;\n            ret += add;\n        }\n\n        return fabs(ret);\n    }\n\n    std::ostream &operator<<(std::ostream &os, const Point &p) {\n//        os << \"(\" << p.x << \", \" << p.y << \")\";\n        os << \"\" << p.x << \" \" << p.y << \"\";\n        return os;\n    }\n\n};\n\nusing namespace Geometory;\n\nclass Solve {\npublic:\n    Int N;\n    Double sx, sy, ex, ey;\n    vector<Double> A, B, C, D, H; // minx, miny, maxx, maxy\n\n    Double calc_r(Double d, Double h) {\n\n        auto check = [&](Double r) -> bool {\n            if (r < d || equals(r, d)) {\n                return true;\n            }\n            if (h > r) {\n                return false;\n            }\n\n//            Double left = (r - h) * (r - h);\n//            Double right = h * h - d * d;\n//            return left > right || equals(left, right);\n\n            Double c = r - sqrt(r * r - d * d);\n            return c > h || equals(c, h);\n        };\n\n        Double ok = 0.0, ng = 10000;\n        rep(_, 0, 100) {\n            Double mid = (ok + ng) / 2;\n            if (check(mid)) {\n                ok = mid;\n            } else {\n                ng = mid;\n            }\n        }\n\n        return ok;\n    }\n\n    Double calc(Int n) {\n        // ブロックnと交差しないためには最大で何センチ?\n        Double x[] = {A[n], C[n], C[n], A[n], A[n]};\n        Double y[] = {B[n], B[n], D[n], D[n], B[n]};\n        Double ret = 10000.;\n\n        for (int k = 0; k < 4; ++k) {\n            Segment s(sx, sy, ex, ey);\n            Segment s2(x[k], y[k], x[k + 1], y[k + 1]);\n//            Point p(x[k], y[k]);\n\n//            Point f = project(s, p);//射影された点\n//            Double d = get_distance(p, f);\n//\n//            if (ccw(Point(sx, sy), f, Point(ex, ey)) == OS) {\n//                Double tmp = calc_r()\n//            }\n\n            Double d = get_distance(s, s2);\n            Double h = H[n];\n            Double tmp = calc_r(d, h);\n            chmin(ret, tmp);\n\n\n        }\n\n        return ret;\n    }\n\n    bool is_zero() {\n        for (int i = 0; i < N; ++i) {\n            Double x[] = {A[i], C[i], C[i], A[i], A[i]};\n            Double y[] = {B[i], B[i], D[i], D[i], B[i]};\n\n            for (int k = 0; k < 4; ++k) {\n                Segment s1(sx, sy, ex, ey);\n                Segment s2(x[k], y[k], x[k + 1], y[k + 1]);\n                if (is_intersect(s1, s2)) {\n                    return true;\n                }\n            }\n\n            vector<Point> polygon;\n            for (int k = 0; k < 4; ++k) {\n                polygon.push_back(Point(x[k], y[k]));\n            }\n\n            if (contains(polygon, Point(sx, sy))) {\n                return true;\n            }\n            if (contains(polygon, Point(ex, ey))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    bool solve() {\n        cin >> N;\n        if (N == 0) return false;\n\n        cin >> sx >> sy >> ex >> ey;\n\n        rep(i, 0, N) {\n            Double a, b, c, d, h;\n            cin >> a >> b >> c >> d >> h;\n            A.push_back(a);\n            B.push_back(b);\n            C.push_back(c);\n            D.push_back(d);\n            H.push_back(h);\n        }\n\n        if (is_zero()) {\n            cout << \"0\" << endl;\n            return true;\n        }\n\n        Double ans = 10000.;\n\n        for (int i = 0; i < N; ++i) {\n            Double tmp = calc(i);\n            chmin(ans, tmp);\n        }\n\n\n        cout << ans << endl;\n\n        return true;\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    while (Solve().solve());\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std;\n\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\n// 誤差を加味した符号判定\nint sign(double a){\n    if(a > EPS) return +1;\n    if(a < -EPS) return -1;\n    return 0;\n}\n\n// 比較演算子\nnamespace std{\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\n// 内積・外積\ndouble dot(P a, P b){\n    return real(conj(a) * b);\n}\ndouble cross(P a, P b){\n    return imag(conj(a) * b);\n}\n\n// OAとOBのなす符号付き角度 [-pi, pi]\n// example : (1, 0), (0, 1) -> pi/2\ndouble angle(P a, P b){\n    return arg(conj(a) * b);\n}\n\n// aをc中心にb[rad]回転\n// verify : not yet.\nP rotate(P a, double b, P c = P()){\n    return (a - c) * polar(1.0, b) + c;\n}\n\n// 直線ABに対する点Cの位置\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > +EPS)   return +1; // 反時計回り\n    if (cross(b, c) < -EPS)   return -1; // 時計回り\n    if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n    if (norm(b) < norm(c)) return -2; // a--b--c の順番で一直線上\n    return 0;                         // 点が線分ab上にある\n}\n\nenum{ OUT, ON, IN };\nstruct L : public vector<P> {\n    L(){}\n    L(const P& a, const P& b) {\n        push_back(a); push_back(b);\n    }\n    P vector() const {\n        return back() - front();\n    }\n};\n\n// 注意: 端点で交わったり直線が重なったりする場合も交差していると判定する\n\n// 二直線の平行判定\n// verify : aoj0021\nbool paralell(L l, L m){\n    return sign(cross(l.vector(), m.vector())) == 0;\n}\n\n// 二直線の同一判定\nbool equalLL(L l, L m){\n    return sign(cross(l.vector(), m[0] - l[0])) == 0;\n}\n\n// 直線と点の交差判定\nbool iLP(L l, P p) {\n    // 直線lとl[0]からpへの直線が平行\n    return sign(cross(l.vector(), p - l[0])) == 0;\n}\n\n// 線分と点の交差判定(端点の処理に注意)\n// verify : aoj1279\nbool iSP(L s, P p) {\n    return ccw(s[0], s[1], p) == 0;\n}\n\n// 直線と線分の交差判定(線分が重なっている時に注意)\nbool iLS(L l, L s) {\n    // 直線lについて、線分sの端点が異なる側にある\n    return sign(cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0])) <= 0;\n}\n\n// 二つの線分の交差判定(線分が重なっている時や端点の処理に注意)\nbool iSS(L s, L t) {\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n        ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\n\n// 点pから直線lに対する射影\nP proj(L l, P p){\n    double t = dot(p - l[0], l.vector()) / norm(l.vector());\n    return l[0] + t * l.vector();\n}\n\n// 点pの直線lに関する反射\nP refl(L l, P p){\n    return 2.0 * proj(l, p) - p;\n}\n\n// 直線と点の距離\ndouble dLP(L l, P p){\n    // return abs(p - projection(l, p));\n    return abs(cross(l.vector(), p - l[0])) / abs(l.vector());\n}\n\n// 線分と点の距離 ( not verified !!! )\ndouble dSP(L s, P p){\n    if(sign(dot(s.vector(), p - s[0])) <= 0) return abs(p - s[0]);\n    if(sign(dot(-s.vector(), p - s[1])) <= 0) return abs(p - s[1]);\n    return dLP(s, p);\n}\n\n// 直線と直線の距離\ndouble dLL(L l, L m){\n    // 平行でないときは0, 平行のときは垂線の長さ\n    return paralell(l, m) ? dLP(l, m[0]) : 0;\n}\n\n// 直線と線分の距離\ndouble dLS(L l, L s){\n    if(iLS(l, s)) return 0;\n    return min(dLP(l, s[0]), dLP(l, s[1]));\n}\n\n// 線分と線分の距離\ndouble dSS(L s, L t){\n    if(iSS(s, t)) return 0;\n    return min({dSP(s, t[0]), dSP(s, t[1]), dSP(t, s[0]), dSP(t, s[1])});\n}\n\n// 直線と直線の交点\nP pLL(L l, L m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n    if(sign(A) == 0) assert(false); // 直線が交わらない\n    return m[0] + m.vector() * B / A;\n}\n\ntypedef vector<P> Polygon; // 反時計回りを仮定\n\n// Polygonの要素へのアクセス\nP curr(const Polygon& a, int x){ return a[x]; }\nP next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nP prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n// 点が多角形のどこにあるのか判定する\n// verify : aoj0012\nint contains(const Polygon& A, const P& p){\n    // 点pから半直線をひき、辺と交差する回数を数える\n    bool in = false;\n    for(int i = 0; i < A.size(); i++){\n        P a = curr(A, i) - p;\n        P b = next(A, i) - p;\n        if(a.imag() > b.imag()) swap(a, b);\n        // aからbの直線がy=0と交わり、その交点は原点の右側である\n        if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0){ \n            in = !in;\n        }\n        if(sign(cross(a, b)) == 0 && sign(dot(a, b)) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\n// 多角形の面積\n// verify : aoj0079 aoj1100\ndouble area(const Polygon& A) {\n    double res = 0;\n    for(int i = 0; i < A.size(); i++){\n        res += cross(curr(A, i), next(A, i));\n    }\n    return abs(res) / 2.0;\n}\n\n// 凸包\nPolygon convex_hull(vector<P> ps) {\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<P> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){ // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){ // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\nbool is_convex(const Polygon& A){\n    for(int i = 0; i < A.size(); i++){\n        if(ccw(prev(A, i), curr(A, i), next(A, i)) > 0) return false;\n    }\n    return true;\n}\n\n// 凸多角形の直線による切断。直線の左側だけ残す\n// verify : aoj1283\nPolygon convex_cut(const Polygon& A, L l){\n    Polygon B;\n    for(int i = 0; i < A.size(); i++){\n        P a = curr(A, i), b = next(A, i);\n        if(ccw(l[0], l[1], a) != -1) B.push_back(a); //Aが直線lの右側でない\n        if(ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0)\n            B.push_back(pLL(l, L(a, b)));\n    }\n    return B;\n}\n// 垂直二等分線\n// verify: maximamcup2013 D\nL bisector(P a, P b){\n    P mid = (a + b) / 2.0;\n    P vec = (mid - a) * P(0.0, 1.0);\n    return L(mid, mid + vec);\n}\n// 点集合psのうちs番目のボロノイ領域\n// verify: maximamcup2013 D\nPolygon voronoi_cell(Polygon A, const vector<P>& ps, int s){\n    for(int i = 0; i < ps.size(); i++){\n        if(i != s) A = convex_cut(A, bisector(ps[s], ps[i]));\n    }\n    return A;\n}\nstruct Circle {\n    P p;\n    double r;\n    Circle() {}\n    Circle(P p, double r) : p(p), r(r) { }\n};\n\n// 円と点の内外判定\nint contains(const Circle& C, const P& p){\n    double d = abs(C.p - p);\n    if(sign(d - C.r) > 0) return OUT;\n    if(sign(d - C.r) == 0) return ON;\n    return IN;\n}\n\n// 円と線分の交差判定(境界を含む)\n// Verified: AOJ 0129\nbool iCS(const Circle& C, const L& l){\n    int c1 = contains(C, l[0]);\n    int c2 = contains(C, l[1]);\n    if(c1 > c2) swap(c1, c2);\n\n    // (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) の6通り\n    if(c1 == OUT && c2 == IN) return true;\n    if(c1 == IN  && c2 == IN) return false;\n    if(c1 == ON) return true; // (接するとき) \n    double d = dSP(l, C.p);\n    if(sign(d - C.r) < 0) return true;\n    if(sign(d - C.r) == 0) return true; // (接するとき)\n    if(sign(d - C.r) > 0) return false;\n}\n\n// 二つの円の交差判定(接する時を含む)\nbool iCC(const Circle& C, const Circle& D){\n    // 円の中心同士の距離が、半径の和以下であり、半径の差以上である\n    double e = abs(C.p - D.p);\n    return sign(e - (C.r + D.r)) <= 0 && sign(e - abs(C.r - D.r)) >= 0;\n}\n\n// 円と直線の交点\n// verify : aoj2045\nvector<P> pLC(const L &l, const Circle &c) {\n    vector<P> res;\n    P center = proj(l, c.p);\n    double d = abs(center - c.p);\n    double tt = c.r * c.r - d * d;\n    if(tt < 0 && tt > -EPS) tt = 0;\n    if(tt < 0) return res;\n    double t = sqrt(tt);\n    P vect = l.vector();\n    vect /= abs(vect);\n    res.push_back(center - vect * t);\n    if (t > EPS) {\n        res.push_back(center + vect * t);\n    }\n    return res;\n}\n\n// 円と線分の交点\nvector<P> pSC(const L &s, const Circle &c) {\n    vector<P> ret;\n    vector<P> nret = pLC(s, c);\n    for (int i = 0; i < nret.size(); i++) {\n        if (iSP(s, nret[i])) ret.push_back(nret[i]);\n    }\n    return ret;\n}\n\n// 円と円の交点\n// verify : aoj1183\nvector<P> pCC(Circle a, Circle b){\n    vector<P> res;\n\n    double l = abs(b.p - a.p);\n\n    if(sign(l) == 0 && sign(a.r - b.r) == 0) assert(false); // 解が無限に存在する\n    if(sign(l - abs(a.r - b.r)) < 0 || sign(l - (a.r + b.r)) > 0) return res; // 解が存在しない\n\n    double th1 = arg(b.p - a.p);\n    if(sign(l - abs(a.r - b.r)) == 0 || sign(l - (a.r + b.r)) == 0){\n        res.push_back(a.p + polar(a.r, th1));\n    }else {\n        double th2 = acos( (a.r * a.r - b.r * b.r + l * l) / (2 * a.r * l) );\n        res.push_back(a.p + polar(a.r, th1 - th2));\n        res.push_back(a.p + polar(a.r, th1 + th2));\n    }\n    return res;\n}\n\n// 2点を通る半径rの円の中心\n// verify : aoj1132\nvector<P> touching_circle2(P a, P b, double r){\n    vector<P> res;\n\n    double d = abs(b - a);\n    if(d > 2 * r) return res;\n\n    P mid = 0.5 * (a + b);\n    P dir = polar(sqrt(r * r - d * d / 4), arg(b - a) + M_PI / 2);\n    res.push_back(mid + dir);\n    res.push_back(mid - dir);\n    return res;\n}\n\n// 3点を通る円\nCircle touching_circle3(P a, P b, P c){\n    // ２つの垂直二等分線の交点が円の中心\n    P mid_ab = (a + b) / 2.0;\n    L bis_ab(mid_ab, (mid_ab - a) * P(0.0, 1.0));\n    P mid_bc = (b + c) / 2.0;\n    L bis_bc(mid_bc, (mid_bc - b) * P(0.0, 1.0));\n\n    assert(!paralell(bis_ab, bis_bc)); \n\n    P center = pLL(bis_ab, bis_bc);\n    return Circle(center, abs(a - center));\n}\n\n// 円と円の共通部分の面積を求める．\n// ref: nya3j\ndouble cc_area(const Circle& c1, const Circle& c2) {\n    double d = abs(c1.p - c2.p);\n    if (c1.r + c2.r < d + EPS) {\n        return 0.0;\n    } else if (d < abs(c1.r - c2.r) + EPS) {\n        double r = min(c1.r, c2.r); // 元は c1.r >? c2.r だった．\n        return r * r * M_PI;\n    } else {\n        double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n        double theta = acos(rc / c1.r);\n        double phi = acos((d - rc) / c2.r);\n        return c1.r*c1.r*theta + c2.r*c2.r*phi - d*c1.r*sin(theta);\n    }\n}\n// 円の接線 (中心から偏角thの点で接する接線)\n// verified: AOJ 2201 Immortal Jewels \nL circle_tangent(const Circle& C, double th){\n    P p0 = C.p + polar(C.r, th);\n    P p1 = p0 + polar(1.0, th + M_PI / 2);\n    return L(p0, p1);\n}\n\n// 二つの円の共通接線 (Cの中心から接点へのベクトルの偏角を返す)\n// verified: AOJ 2201 Immortal Jewels \n// 参考: http://geom.web.fc2.com/geometry/circle-circle-tangent.html\nvector<double> common_tangents(const Circle& C, const Circle& D){\n    vector<double> res;\n    P v = D.p - C.p;\n    double l = abs(v); // 二円の中心間の距離\n    double a = arg(v); // 二円の中心間の偏角\n    if(sign(l - abs(C.r - D.r)) > 0){\n        // 交わる or 外接 or 離れている\n        // 二つの外側接線\n        double a1 = acos((C.r - D.r) / l);\n        res.push_back(a + a1);\n        res.push_back(a - a1);\n        if(sign(l - (C.r + D.r)) > 0){\n            // 離れている\n            // 二つの内側接線\n            double a2 = acos((C.r + D.r) / l);\n            res.push_back(a + a2);\n            res.push_back(a - a2);\n        }\n    }\n    if((sign(l - abs(C.r - D.r)) == 0 || sign(l - (C.r + D.r)) == 0) && sign(l) != 0){\n        // 内接 or 外接\n        // 一つの接線\n        res.push_back(a);\n    }\n    return res;\n}\n\n// 1点を通る円の接線( pがCの外側にあることが前提条件 )\n// verified : AOJ 2579\nvector<L> tangents_through_point(const Circle& C, const P& p){\n    vector<L> tangents;\n    double d = abs(C.p - p);\n    // d ^ 2 == r ^ 2 + e ^ 2\n    double e = sqrt(d * d - C.r * C.r); // 点pと円の接点の距離\n    // d * sin(th) = r\n    double th = asin(C.r / d);\n    P q1 = p + (C.p - p) * polar(1.0, +th) * e / d;\n    P q2 = p + (C.p - p) * polar(1.0, -th) * e / d;\n    tangents.push_back(L(p, q1));\n    tangents.push_back(L(p, q2));\n    return tangents;\n}\nint main(){\n    int N;\n    while(cin>>N && N){\n        double sx, sy, gx, gy;\n        cin>>sx>>sy>>gx>>gy;\n        P sp(sx, sy);\n        P gp(gx, gy);\n        double ans = 1e8;\n        L route(sp, gp);\n        for(int i = 0; i < N; i++) {\n            double mx, my, nx, ny, h;\n            cin>>mx>>my>>nx>>ny>>h;\n            if(mx <= sx && sx <= nx && my <= sy && sy <= ny) ans = 0;\n            L ls[4];\n            ls[0] = {{mx, my}, {nx, my}};\n            ls[1] = {{mx, my}, {mx, ny}};\n            ls[2] = {{mx, ny}, {nx, ny}};\n            ls[3] = {{nx, ny}, {nx, my}};\n            for(int j = 0; j < 4; j++) {\n                L l = ls[j];\n                double dist = dSS(route, l);\n                if(dist == 0) ans = 0;\n                double radian;\n                if(dist - EPS < h) radian = dist;\n                else radian = (h*h + dist*dist)/(2*h);\n                ans = min(ans, radian);\n            }\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <iostream>\n\nusing namespace std;\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\ntypedef long double ld;\nconst ld EPS=1e-9;\n\nstruct Point{\n\tPoint(ld x,ld y):x(x), y(y){}\n\tPoint(){}\n\tld x,y;\n};\n\nPoint operator+(const Point &a, const Point &b){\n\treturn Point(a.x+b.x, a.y+b.y);\n}\n\nPoint operator-(const Point &a, const Point &b){\n\treturn Point(a.x-b.x, a.y-b.y);\n}\n\nPoint operator*(const Point &a, const ld b){\n\treturn Point(a.x*b, a.y*b);\n}\n\nld cross(const Point &a, const Point &b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nld dot(const Point &a, const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\nld norm(const Point &a){\n\treturn dot(a,a);\n}\n\nld abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nstruct Line:vector<Point>{\n\tLine(Point a = Point(0,0), Point b = Point(0,0)){\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n};\n\nint ccw(Point a, Point b, Point c){\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b,c) > EPS) return 1;\n\tif(cross(b,c) < -EPS) return -1;\n\tif(dot(b,c) < 0) return 2;\n\tif(norm(b)<norm(c)) return -2;\n\treturn 0;\n}\n\nbool is_intersect_SS(const Line &s, const Line &t){\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nbool is_intersect_SP(const Line &l, const Point &p){\n\treturn ccw(l[0],l[1],p)==0;\n}\n\nPoint projection(const Line &l, const Point &p){\n\tld t = dot(p-l[0],l[1]-l[0])/norm(l[0]-l[1]);\n\treturn l[0]+(l[1]-l[0])*t;\n}\n\nld distance_SP(const Line &s, const Point &p){\n\tconst Point r = projection(s,p);\n\tif(is_intersect_SP(s,r))return abs(r-p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\nld distance_SS(const Line &s, const Line &t){\n\tif(is_intersect_SS(s,t)) return 0;\n\treturn min(min(distance_SP(s,t[0]),distance_SP(s,t[1])),min(distance_SP(t,s[0]),distance_SP(t, s[1])));\n}\n\nbool lt(ld x, ld y){\n\treturn x - y < EPS;\n}\n\nint n;\nLine L;\nLine data[100];\nint H[100];\n\nld Max;\n\nvoid input(){\n\tint w, x, y, z;\n\tMax = 1e10;\n\tscanf(\"%d%d%d%d\", &w, &x, &y, &z);\n\tL = Line(Point(w,x), Point(y,z));\n\tfor(int i = 0 ; i< n;i++){\n\t\tscanf(\"%d%d%d%d%d\", &w, &x, &y, &z, &H[i]);\n\t\tdata[i] = Line(Point(w,x), Point(y,z));\n\t}\n}\n\nvoid process(){\n\tld minX = min(L[0].x, L[1].x);\n\tld minY = min(L[0].y, L[1].y);\n\tld maxX = max(L[0].x, L[1].x);\n\tld maxY = max(L[0].y, L[1].y);\n\t//Check rect & line\n\tfor(int i = 0; i < n;i++){\n\t\tif(is_intersect_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][0].x, data[i][1].y))) ||\n\t\t\tis_intersect_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][1].x, data[i][0].y))) ||\n\t\t\tis_intersect_SS(L, Line(Point(data[i][0].x, data[i][1].y), Point(data[i][1].x, data[i][1].y))) ||\n\t\t\tis_intersect_SS(L, Line(Point(data[i][1].x, data[i][0].y), Point(data[i][1].x, data[i][1].y)))) {\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif(lt(data[i][0].x , minX) && lt(data[i][0].y , minY) && lt(maxX , data[i][1].x) && lt(maxY , data[i][1].y)) {\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t//get r;\n\tfor(int i = 0; i < n; i++) {\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][0].x, data[i][1].y)));\n\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\tif(lt(r, Max)) Max = r;\n\t\t}\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][0].x, data[i][0].y), Point(data[i][1].x, data[i][0].y)));\n\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\tif(lt(r,Max)) Max = r;\n\t\t}\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][0].x, data[i][1].y), Point(data[i][1].x, data[i][1].y)));\n\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\tif(lt(r,Max)) Max = r;\n\t\t}\n\t\t{\n\t\t\tld d = distance_SS(L, Line(Point(data[i][1].x, data[i][0].y), Point(data[i][1].x, data[i][1].y)));\n\t\t\tld r = ((ld)(H[i]*H[i]) + (ld)(d*d))/((ld)2.0*H[i]);\n\t\t\tif(lt(r,Max)) Max = r;\n\t\t}\n\t}\n\tprintf(\"%lf\\n\", Max);\n}\n\nint main() {\n\twhile(true){\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tinput();\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> P;\nconst int MAX_N = 59;\nint N;\ndouble SX, SY, GX, GY;\ndouble minx[MAX_N], maxx[MAX_N], miny[MAX_N], maxy[MAX_N], hs[MAX_N], ds[MAX_N];\nP S, G;\n\nconst double EPS = 1e-12;\n\ndouble sq(double x){ return x*x; }\n\n//??????\ndouble dot(complex<double> l, complex<double> r){\n    return real(conj(l)*r);\n    //return l.real()*r.real() + l.imag()*r.imag();\n}\n\n//??????\ndouble cross(complex<double> l, complex<double> r){\n    return imag(conj(l)*r);\n    // return l.real()*r.imag() - l.imag()*r.real();\n}\n\n//???????¨???????\nbool ccw(complex<double> l, complex<double> r){\n    double a = cross(l, r);\n    if(a == 0)\n        //???????????´????????????????????£?????????????¨???????\n        return false;\n    else\n        return a > 0;\n}\n\n\n//???p??¨??´???(s, e)????????¢\ndouble disLP(complex<double> s, complex<double> e, complex<double> p){\n    return abs(cross(e-s,p-s))/abs(e-s);\n}\n\n//???p??¨??????(s, e)????????¢\ndouble disSP(complex<double> s, complex<double> e, complex<double> p){\n    if(dot(e-s, p-s)<=0)\n        return abs(p-s);\n    if(dot(s-e, p-e)<=0)\n        return abs(p-e);\n    return disLP(s, e, p);\n}\n    \nbool crsSS(complex<double> s1, complex<double> e1, complex<double> s2, complex<double> e2){\n    return (ccw(e1-s1, s2-s1)^ccw(e1-s1, e2-s1)) && (ccw(e2-s2, s1-s2)^ccw(e2-s2, e1-s2));\n}\n\n\nbool init(){\n    for(int i=0; i<N; i++){\n        if(crsSS(S,G,P(minx[i],miny[i]),P(minx[i],maxy[i])) ||\n           crsSS(S,G,P(minx[i],miny[i]),P(maxx[i],miny[i])) ||\n           crsSS(S,G,P(maxx[i],maxy[i]),P(minx[i],maxy[i])) ||\n           crsSS(S,G,P(maxx[i],maxy[i]),P(maxx[i],miny[i]))){\n            return false;\n        }\n        if(minx[i] <= SX && SX <= maxx[i] && miny[i] <= SY && SY <= maxy[i]){\n            return false;\n        }\n        if(minx[i] <= GX && GX <= maxx[i] && miny[i] <= GY && GY <= maxy[i]){\n            return false;\n        }\n    }\n    \n    for(int i=0; i<N; i++){\n        ds[i] = 1e10;\n        ds[i] = min(ds[i], disSP(S,G,P(minx[i],miny[i])));\n        ds[i] = min(ds[i], disSP(S,G,P(minx[i],maxy[i])));\n        ds[i] = min(ds[i], disSP(S,G,P(maxx[i],miny[i])));\n        ds[i] = min(ds[i], disSP(S,G,P(maxx[i],maxy[i])));\n        \n        ds[i] = min(ds[i], disSP(P(minx[i],miny[i]),P(minx[i],maxy[i]),S));\n        ds[i] = min(ds[i], disSP(P(minx[i],miny[i]),P(maxx[i],miny[i]),S));\n        ds[i] = min(ds[i], disSP(P(maxx[i],maxy[i]),P(minx[i],maxy[i]),S));\n        ds[i] = min(ds[i], disSP(P(maxx[i],maxy[i]),P(maxx[i],miny[i]),S));\n        \n        ds[i] = min(ds[i], disSP(P(minx[i],miny[i]),P(minx[i],maxy[i]),G));\n        ds[i] = min(ds[i], disSP(P(minx[i],miny[i]),P(maxx[i],miny[i]),G));\n        ds[i] = min(ds[i], disSP(P(maxx[i],maxy[i]),P(minx[i],maxy[i]),G));\n        ds[i] = min(ds[i], disSP(P(maxx[i],maxy[i]),P(maxx[i],miny[i]),G));\n    }\n    \n    return true;\n}\n\nbool check(double r){\n    for(int i=0; i<N; i++){\n        if(ds[i] < sqrt(sq(r) - sq(r-min(r,hs[i])))){\n            return false;\n        }\n    }\n    return true;\n}\n\ndouble solve(){\n    if(!init()){\n        return 0;\n    }\n    double low = 0.0, high = 1009;\n    for(int i=0; i<100; i++){\n        double mid = (low + high)*0.5;\n        if(check(mid)) low = mid;\n        else high = mid;\n    }\n    return low;\n}\n\nint main(){\n    while(scanf(\"%d\",&N),N){\n        scanf(\"%lf%lf%lf%lf\",&SX,&SY,&GX,&GY);\n        S = P(SX,SY); G = P(GX,GY);\n        for(int i=0; i<N; i++){\n            scanf(\"%lf%lf%lf%lf%lf\",minx+i,miny+i,maxx+i,maxy+i,hs+i);\n        }\n        printf(\"%.7f\\n\",solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bucnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n\nconst ll inf = (ll)1e9;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\ndouble dot_product(compd a, compd b, compd c) {\n\tcompd s = b - a, t = c - a;\n\treturn s.real()*t.real() + s.imag()*t.imag();\n}\n\ndouble cross_product(compd a, compd b, compd c) {\n\tcompd s = b - a, t = c - a;\n\treturn s.real()*t.imag() - s.imag()*t.real();\n}\n\ndouble dist(compd a, compd b) {\n\treturn sqrt((a.real() - b.real())*(a.real() - b.real()) + (a.imag() - b.imag())*(a.imag() - b.imag()));\n}\n\ndouble Ldist(compd s, compd t, compd p) {\n\tcompd l = t - s;\tp -= s;\n\tcompd rot = abs(l) / l;\n\tl *= rot;\tp *= rot;\n\tif (p.real() < eps)\treturn dist(0, p);\n\tif (l.real() - eps < p.real())\treturn dist(l, p);\n\treturn abs(p.imag());\n}\n\ncompd getCompd() {\n\tdouble a, b;\tcin >> a >> b;\n\treturn compd(a, b);\n}\n\nint main() {\n\twhile (true) {\n\t\tint n;\tcin >> n;\n\t\tif (n == 0)\tbreak;\n\t\tcompd s = getCompd(), t = getCompd();\n\t\tld left = 0, right = 1024;\n\t\trep(i, n) {\n\t\t\tvector<compd> a(4);\n\t\t\ta[0] = getCompd();\ta[2] = getCompd();\n\t\t\ta[1] = compd(a[0].real(), a[2].imag());\n\t\t\ta[3] = compd(a[2].real(), a[0].imag());\n\t\t\tdouble h;\tcin >> h;\n\t\t\tleft = 0;\n\t\t\tright += eps;\n\t\t\t//?????????????????????????????????\n\t\t\tbool is_inside = true;\n\t\t\trep(j, 4) {\n\t\t\t\tis_inside &= (dot_product(a[j], a[(j + 1) % 4], s) > eps);\n\t\t\t\tis_inside &= (dot_product(a[j], a[(j + 1) % 4], t) > eps);\n\t\t\t}\n\t\t\tif (is_inside)\tright = 0;\n\t\t\t//?????????????????????????????????\n\t\t\tbool crossed = false;\n\t\t\trep(j, 4) {\n\t\t\t\tif (cross_product(s, t, a[j])*cross_product(s, t, a[(j + 1) % 4]) > -eps)\tcontinue;\n\t\t\t\tif (cross_product(a[j], a[(j + 1) % 4], s)*cross_product(a[j], a[(j + 1) % 4], t) > -eps)\tcontinue;\n\t\t\t\tcrossed = true;\n\t\t\t}\n\t\t\tif (crossed)\tright = 0;\n\t\t\trep(j, 100) {\n\t\t\t\tdouble mid = (left + right) / 2.0;\n\t\t\t\tdouble height = mid - min(mid, h);\n\t\t\t\tdouble r = sqrt(mid*mid - height*height);\n\t\t\t\tbool ok = true;\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tok &= (Ldist(s, t, a[k]) > r + eps);\n\t\t\t\t\tok &= (Ldist(a[k], a[(k + 1) % 4], s) > r + eps);\n\t\t\t\t\tok &= (Ldist(a[k], a[(k + 1) % 4], t) > r + eps);\n\t\t\t\t}\n\t\t\t\tif (ok)\tleft = mid;\n\t\t\t\telse\tright = mid;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.15Lf\\n\", left + eps);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\nstruct pos{\n\tdouble x,y;\n\tdouble norm,norm2;\n\tpos tov(pos a){\n\t\treturn (a-(*this));\n\t}\n\tpos operator+(pos a)const{\n\t\tpos res=a;\n\t\tres.x+=x; res.y+=y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos operator-(pos a)const{\n\t\tpos res=(*this);\n\t\tres.x-=a.x; res.y-=a.y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos scalar(double a){\n\t\tpos res=(*this);\n\t\tres.x*=a; res.y*=a;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tdouble dot(pos a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tdouble cross(pos a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tpos(double ix,double iy){\n\t\tx=ix; y=iy;\n\t\tnorm2=x*x+y*y;\n\t\tnorm=sqrt(norm2);\n\t}\n\tpos(){}\n\tstring str(){\n\t\tchar ns[50];\n\t\tsprintf(ns,\"(%lf %lf)\",x,y);\n\t\treturn\tstring(ns);\n\t}\n\tstatic pos polar(double r,double t){\n\t\treturn pos(r*cos(t),r*sin(t));\n\t}\n};\n\nstruct line{\n\tpos p,q;\n\tpos vec;\n\tstring str(){\n\t\treturn (\"(\"+p.str()+\"-\"+q.str()+\")\");\n\t}\n\tbool iscross(line a){\n\t\tdouble da,db;\n\t\tda=vec.cross( p.tov(a.p) );\n\t\tdb=vec.cross( p.tov(a.q) );\n\t\tif(da*db>=0)return false;\n\t\tda=a.vec.cross( a.p.tov(p) );\n\t\tdb=a.vec.cross( a.p.tov(q) );\n\t\treturn (da*db<0);\n\t}\n\tline(pos ip,pos iq){\n\t\tp=ip; q=iq;\n\t\tvec=p.tov(q);\n\t}\n\tline(){}\n\tdouble dist(pos a){\n\t\tif(p.tov(a).dot( p.tov(q) )<0)return p.tov(a).norm;\n\t\tif(q.tov(a).dot( q.tov(p) )<0)return q.tov(a).norm;\n\t\treturn abs(vec.cross(p.tov(a))/vec.norm);\n\t}\n\tdouble dist(line a){\n\t\tif(iscross(a))return 0;\n\t\treturn min( min(dist(a.p),dist(a.q)) , min(a.dist(this->p),a.dist(this->q)));\n\t}\n};\n\ndouble lowofcos_getcos(double a,double b,double c){\n\treturn ((a*a+b*b-c*c)/(2*a*b));\n}\n\nstruct circle{\n\tpos p;\n\tdouble r;\n\t\n\tline getintersection(circle a){\n\t\tpos cv=p.tov(a.p);\n\t\tdouble br=atan2(cv.y,cv.x);\n\t\tdouble dr=acos(lowofcos_getcos( r, cv.norm, a.r));\n\t\t\n\t\tpos p1= p+pos::polar(r,br+dr);\n\t\tpos p2= p+pos::polar(r,br-dr);\n\t\t\n\t\treturn line(p1,p2);\n\t}\n\tcircle(pos ip,double ir){\n\t\tp=ip; r=ir;\n\t}\n\tcircle(){}\n};\n\nstruct polygon{\n\tvector<pos> ps;\n\tpolygon(){}\n\tdouble area(){\n\t\tdouble res=0;\n\t\trep(i,ps.size()){\n\t\t\tpos no=ps[i],to=ps[(i+1)%ps.size()];\n\t\t\tres+=(no.x+to.x)*(no.y-to.y);\n\t\t}\n\t\treturn abs(res)/2;\n\t}\n\tpolygon(pos a,pos b){\n\t\tps.push_back(a);\n\t\tps.push_back(pos(a.x,b.y));\n\t\tps.push_back(b);\n\t\tps.push_back(pos(b.x,a.y));\n\t}\n\tline gete(int a){\n\t\treturn line(ps[a],ps[(a+1)%ps.size()]);\n\t}\n\tbool isin(pos a){\n\t\t//????????¢??????\n\t\tif((a.x-ps[0].x)*(a.x-ps[2].x)>0)return false;\n\t\tif((a.y-ps[0].y)*(a.y-ps[2].y)>0)return false;\n\t\treturn true;\n\t}\n};\n\n\nint main(void){\n\tfor(;;){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tpos a,b;\n\t\tscanf(\"%lf%lf%lf%lf\",&a.x,&a.y,&b.x,&b.y);\n\t\tline tama(a,b);\n\t\tdouble ans=10000;\n\t\trep(i,n){\n\t\t\tscanf(\"%lf%lf%lf%lf\",&a.x,&a.y,&b.x,&b.y);\n\t\t\tdouble nh;\n\t\t\tscanf(\"%lf\",&nh);\n\t\t\tpolygon pl(a,b);\n\t\t\trep(j,4){\n\t\t\t\tline ne=pl.gete(j);\n\t\t\t\tdouble nd=ne.dist(tama);\n\t\t\t\t//printf(\"%d %d %s %s %lf %lf\\n\",i,j,ne.str().c_str(),tama.str().c_str(),nd,nh);\n\t\t\t\tif(nh>=nd)ans=min(ans,nd);\n\t\t\t\telse ans=min(ans,(nd*nd+nh*nh)/(2*nh));\n\t\t\t}\n\t\t\tif(pl.isin(tama.p) || pl.isin(tama.q))ans=0;\n\t\t}\n\t\t\n\t\tprintf(\"%lf\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <bits/stdc++.h>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n// #define EPS 1e-8\n// static const int INF=1<<24;\n\n// #include<bits/stdc++.h>\n// using namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = asin(0.5)*6;\ntypedef complex<double> P;\n\n#define X real()\n#define Y imag()\n\n#define Curr(P,i) P[(i)%P.size()]\n#define Next(P,i) P[(i+1)%P.size()]\n#define Prev(P,i) P[(i+P.size()-1)%P.size()]\n\nnamespace std{\n  bool operator<(const P a,const P b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n//gaiseki\ndouble cross(const P a,const P b){\n  return (conj(a)*b).imag();\n}\n//naiseki\ndouble dot(const P a,const P b){\n  return (conj(a)*b).real();\n}\n// TODO make graph (20)\nint ccw(P a,P b,P c){\n  b-=a;\n  c-=a;\n  if(cross(b,c)>0)    return +1;//counter clockwise\n  if(cross(b,c)<0)    return -1;//clockwise\n  if(dot(b,c)<0)      return +2;// c--a--b\n  if(norm(b)<norm(c)) return -2;// a--b--c\n                      return  0;// a--c--b(or b==c)\n}\n\nstruct L : public vector<P>{\n  L(const P a,const P b){\n    push_back(a),push_back(b);\n  }\n};\ntypedef L S;\ntypedef vector<P> G;\n\nstruct C{\n  P p;double r;\n  C(const P p,double r): p(p),r(r){}\n};\n\n\n\n//直線と点の関係\n//点から線分に垂線を下ろした点\nP projection(L a,P p){\n  double t = dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n  return a[0] + t*(a[0]-a[1]);\n}\n//線対称の点\nP reflection(L a,P p){\n  return p + 2.0 * (projection(a,p)-p);\n}\n\n\n\n\n//交差判定\n//TODO CP(内包) CL CS (0)\nbool isCrossLL(L a,L b){\n  return \n    abs(cross(a[1]-a[0],b[1]-b[0])) > EPS\n    || abs(cross(a[1]-a[0],b[0]-a[0])) < EPS ;\n}\nbool isCrossLS(L a,S b){\n  return \n    cross(a[1]-a[0],b[0]-a[0]) \n    * cross(a[1]-a[0],b[1]-a[0]) < EPS;\n}\nbool isCrossLP(L l,P p){\n  return abs(cross(l[1]-p,l[0]-p)) < EPS;\n}\nbool isCrossSS(S a,S b){\n  return\n    ccw(a[0],a[1],b[0])\n    * ccw(a[0],a[1],b[1]) <= 0\n    &&\n    ccw(b[0],b[1],a[0])\n    * ccw(b[0],b[1],a[1]) <= 0;\n}\nbool isCrossSP(S a,P p){\n  return abs(a[0]-p)+abs(a[1]-p)-abs(a[0]-a[1]) < EPS;\n}\n\n\n// 距離 CP CL CS は(distXP(x,c.p)-c.r)\ndouble distPP(P a,P b){\n  return abs(a-b);\n}\ndouble distLP(L a,P p){\n  return abs(p-projection(a,p));\n}\ndouble distLL(L a,L b){\n  return isCrossLL(a,b) ? 0 : distLP(a,b[0]);\n}\ndouble distLS(L a,S b){\n  return isCrossLS(a,b) ? 0 : min(distLP(a,b[0]),distLP(a,b[1]));\n}\ndouble distSP(S a,P p){\n  const P r = projection(a,p);\n  return isCrossSP(a,r) ? abs(p-r) : min(abs(a[0]-p),abs(a[1]-p));\n}\ndouble distSS(S a,S b){\n  return isCrossSS(a,b)?0:\n    min(\n      min(distSP(a,b[0]),distSP(a,b[1])),\n      min(distSP(b,a[0]),distSP(b,a[1]))\n    );\n}\n\n//円の交差判定\nbool isCrossCP(C a,P p){\n  return abs(a.p-p)-a.r<=EPS;\n}\nbool isCrossCL(C a,L l){\n  return distLP(l,a.p)-a.r<EPS;\n}\ndouble distSP_MAX(S a,P p){\n  return max(abs(a[0]-p),abs(a[1]-p));\n}\nbool isCrossCS(C a,S s){\n  return distSP(s,a.p)-a.r<-EPS&&distSP_MAX(s,a.p)-a.r>+EPS;\n}\nbool isCrossCC(C a,C b){//接してる時は交差\n  return abs(a.p-b.p)-(a.r+b.r) <= EPS;\n}\n\n\n//交差点\n//先に交差判定をすること\nP crossP_LL(L a,L b){\n  double A = cross(a[1]-a[0],b[1]-b[0]);\n  double B = cross(a[1]-a[0],a[1]-b[0]);\n  if(abs(A)<EPS && abs(B)<EPS)return b[0];\n  if(abs(A)<EPS)assert(false);\n  return b[0]+B/A*(b[1]-b[0]);\n}\nvector<P> crossP_CL(C c,L l){\n  P tmp = projection(l,c.p);\n  P e = (l[0]-l[1])/abs(l[0]-l[1]);\n  double h = abs(c.p-tmp)*abs(c.p-tmp);\n  double t = sqrt(c.r*c.r - h*h);\n  if(t<EPS)return {tmp};\n  return {tmp + e*t,tmp - e*t};\n}\nvector<P> crossP_CC(C a,C b){\n  P A = conj(b.p-a.p);\n  P B = (b.r*b.r - a.r*a.r - (b.p-a.p)*conj(b.p-a.p));\n  P C = a.r*a.r*(b.p-a.p);\n  P D = B*B-4.0*A*C;\n  P z1 = (-B+sqrt(D))/(2.0*A)+a.p;\n  P z2 = (-B-sqrt(D))/(2.0*A)+a.p;\n  return {z1,z2};\n}\n\n\n\n//三点->円\nP PPPtoC(P a,P b,P c){\n  P x = 1.0/(conj(b-a));\n  P y = 1.0/(conj(c-a));\n  return (y-x)/( conj(x)*y - x*conj(y) ) + a;\n}\n\n//凸包\nG convex_hull(G ps){\n  int n = ps.size();\n  int k = 0;\n  G ch(2*n);\n  for(int i = 0;i<n;(ch[k++]=ps[i++])){\n    while(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  }\n  for(int i = n-2,t=k+1 ; i>=0 ; ch[k++]=ps[i--]){\n    while(k>=t && ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  }\n  ch.resize(k-1);\n  return ch;\n} \n\n\n//凸性判定\nbool isConvex(G g){\n  for(int i=0; i<g.size();i++){\n    if(ccw(Prev(g,i),Curr(g,i),Next(g,i))>0)return false;\n  }\n}\n\n\n\n//接線\n//TODO check\nvector<L> TLine_CP(C c,P p){\n  P v = c.p - p;\n  double t = asin(abs(c.r)/(abs(v)));\n  P e = v/abs(v) * exp(P(.0,t));\n  P n1 = sqrt(abs(v)*abs(v) - c.r*c.r)*e + p;\n  P n2 = reflection(L(p,c.p),n1);\n  return {L(p,n1),L(p,n2)};\n}\n\n// TLine CC\nvector<L> TLine_CPr(C c,P p,double r){\n  P v = c.p - p;\n  double t = asin(abs(c.r)/(abs(v)));\n  P e = v/abs(v) * exp(P(.0,t));\n  P n1 = sqrt(abs(v)*abs(v) - c.r*c.r)*e + p;\n  P e1 = (n1-c.p)/abs(n1-c.p) * r;\n  P n2 = reflection(L(p,c.p),n1);\n  P e2 = (n2-c.p)/abs(n2-c.p) * r;\n  return {L(p+e1,n1+e1),L(p+e2,n2+e2)};\n}\nvector<L> TLine_CC(C a,C b){\n  //接してる時がヤバイ\n  vector<L> res;\n  if(!isCrossCC(a,b)&&(abs(a.r)>EPS)&&(abs(b.r>EPS))){\n    P tmp = (a.p-b.p)*(b.r)/(a.r+b.r) + b.p;\n    auto t1 = TLine_CP(a,tmp);\n    auto t2 = TLine_CP(b,tmp);\n    res.push_back(L(t1[0][1],t2[0][1]));\n    res.push_back(L(t1[1][1],t2[1][1]));\n  }\n  if(abs(a.r-b.r)<EPS){\n    const auto r = a.r;\n    P e = (a.p-b.p)/abs(a.p-b.p) * exp(P(.0,90.0/180.0*PI));\n    res.push_back(L(a.p+(e*r),b.p+(e*r)));\n    if(abs(r)>=EPS)res.push_back(L(a.p-(e*r),b.p-(e*r)));\n  }else{\n    if(a.r<b.r)swap(a,b);\n    auto t3 = TLine_CPr(C(a.p,a.r-b.r),b.p,b.r);\n    for(auto i:t3){\n      res.push_back(i);\n    }\n  }\n  return res;\n}\n\n\n\n//原点を起点とした回転\nP rotate(P a,double r){\n  return a*exp(P(0.0,r*PI/180.0));\n}\n\n// int main(){\n// }\nbool foo(P a,P b,P c,P d){\n\tP da=a-d,ab=b-a; \n\tP db=b-d,bc=c-b; \n\tP dc=c-d,ca=a-c;\n\tdouble t1=cross(da,ab),t2=cross(db,bc),t3=cross(dc,ca);\n\treturn (t1>0&&t2>0&&t3>0)||(t1<0&&t2<0&&t3<0);\n}\n\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tP s,e;\n\t\tdouble tt1,tt2;\n\t\tcin>>tt1>>tt2;\n\t\ts=P(tt1,tt2);\n\t\tcin>>tt1>>tt2;\n\t\te=P(tt1,tt2);\n\t\tVV(S) vv(n);\n\t\tdouble ans=INF;\n\t\tS a=S(s,e);\n\t\trep(i,n){\n\t\t\tP t1,t2;\n\t\t\t// double tt1,tt2;\n\t\t\tcin>>tt1>>tt2;\n\t\t\tt1=P(tt1,tt2);\n\t\t\tcin>>tt1>>tt2;\n\t\t\tt2=P(tt1,tt2);\n\t\t\tdouble h;\n\t\t\tcin>>h;\n\t\t\t// cout<<t1.X<<\" \"<<t1.Y<<\" \"<<t2.X<<\" \"<<t2.Y<<endl;\n\t\t\tvv[i].PB(S(t1,P(t1.X,t2.Y)));\n\t\t\tvv[i].PB(S(t1,P(t2.X,t1.Y)));\n\t\t\tvv[i].PB(S(t2,P(t1.X,t2.Y)));\n\t\t\tvv[i].PB(S(t2,P(t2.X,t1.Y)));\n\t\t\t//30 -70 90 -30 10\n\t\t\trep(j,vv[i].size()){\n\t\t\t\t// cout<<i<<\" \"<<j<<\" \"<<ans<<endl;\n\t\t\t\tif(isCrossSS(a,vv[i][j])) ans=0;\n\t\t\t\t// cout<<ans<<endl;\n\t\t\t\tif(foo(t1,t2,P(t1.X,t2.Y),s)) ans=0;\n\t\t\t\tif(foo(t1,t2,P(t1.Y,t2.X),s)) ans=0;\n\t\t\t\tdouble t = distSS(a,vv[i][j]);\n\t\t\t\t// cout<<t<<endl;\n\t\t\t\tif(h-t>=-EPS){\n\t\t\t\t\tans=min(ans,t);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tans=min(ans,h/2.0+t*t/2.0/h);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4lf\\n\",ans);\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\ntypedef double Num;\ntypedef complex<Num> Pt2;\ntypedef vector<Pt2>  Polygon2;\n\nstruct Line2 : public vector<Pt2> {\n\tLine2(Pt2 a, Pt2 b) { push_back(a); push_back(b); }\n};\n\nconst double eps = 1e-10;\nNum  dot  (Pt2 a, Pt2 b) { return (a*conj(b)).real(); }\nNum  cross(Pt2 a, Pt2 b) { return (conj(a)*b).imag(); }\nPt2  vec  (Line2 l)      { return l[1]-l[0]; }\n\nint ccw(Pt2 a, Pt2 b, Pt2 c) {\n\tb-=a; c-=a;\n\tif(cross(b,c) > 0 ) return +1; // ccw\n\tif(cross(b,c) < 0 ) return -1; // cw\n\tif(  dot(b,c) < 0 ) return +2; // cab\n\tif(norm(b)<norm(c)) return -2; // abc\n\treturn 0;                      // acb\n}\n\nint ccw(Line2 s, Pt2 p) {\n\treturn ccw(s[0], s[1], p);\n}\n\nbool intersectSP(Line2 s, Pt2 p) {\n\treturn abs(s[0]-p)+abs(s[1]-p) < abs(s[1]-s[0])+eps;\n}\n\nbool intersectSS(Line2 s, Line2 t) {\n\treturn ccw(s,t[0])*ccw(s,t[1]) <= 0 \n\t    && ccw(t,s[0])*ccw(t,s[1]) <= 0;\n}\n\nPt2 projection(Line2 l, Pt2 p) {\n  double t = dot(p-l[0], vec(l)) / norm(vec(l));\n  return l[0] + t*(vec(l));\n}\n\nPt2 reflection(Line2 l, Pt2 p) {\n\treturn p + 2.0*(projection(l,p) - p);\n}\n\nNum distanceSP(Line2 s, Pt2 p) {\n  Pt2 r = projection(s,p);\n  if(intersectSP(s,r)) return abs(r-p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\nNum distanceSS(Line2 s, Line2 t) {\n  if(intersectSS(s,t)) return 0;\n  return min(min(distanceSP(s,t[0]), distanceSP(s,t[1])),\n             min(distanceSP(t,s[0]), distanceSP(t,s[1])));\n}\n\nbool convex_contains(Polygon2 g, Pt2 p)\n{\n\tfor(int i=0; i<g.size(); i++)\n\t{\n\t\tif(ccw(Line2(g[i],g[(i+1)%g.size()]), p)) return false;\n\t}\n\treturn true;\n}\n\ndouble dist(Line2 s, Line2 t, double h) {\n\tdouble d=distanceSS(s,t);\n\tif(d<=h) return d;\n\treturn (d*d+h*h)/(2*h);\n}\n\n\nint main()\n{\n\tint N;\n\twhile(cin>>N, N)\n\t{\n\t\tNum x1,y1,x2,y2,h;\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tLine2 course(Pt2(x1,y1),Pt2(x2,y2));\n\n\t\tdouble ans=1e10;\n\t\twhile(N--)\n\t\t{\t\t\n\t\t\tcin>>x1>>y1>>x2>>y2>>h;\n\t\t\tPolygon2 g(4);\n\t\t\tg[0]=Pt2(x1,y1); g[3]=Pt2(x2,y1);\n\t\t\tg[1]=Pt2(x1,y2); g[2]=Pt2(x2,y2);\n\n\t\t\tif(convex_contains(g,course[0]) && convex_contains(g,course[0]))\n\t\t\t{\n\t\t\t\tans=0; break;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<g.size(); i++)\n\t\t\t{\n\t\t\t\tans = min(ans, dist(course,Line2(g[i],g[(i+1)%g.size()]),h));\n\t\t\t}\n\t\t}\n\t\tcout.setf(ios::fixed);\n\t\tcout.precision(5);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n#define M INT_MAX\nstruct P{\n  double x;\n  double y;\n\n  P(){\n\tx=M; y=M;\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n\n};\ndouble dot(P a,P b){\n  return (a.x*b.x+a.y*b.y);\n}\n\ndouble cross(P a,P b){\n  return (a.x*b.y-a.y*b.x);\n}\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\ndouble psd(P p , P a , P b){\n  if( dot( b-a , p-a ) < EPS) return fabs(dis(p-a));\n  if( dot( a-b , p-b ) < EPS) return fabs(dis(p-b));\n  return fabs(cross( b-a , p-a )) / fabs(dis(b-a));\n}\n\nbool intersect_s(P a1 , P a2 , P b1 , P b2){\n  return ( cross(a2-a1 , b1-a1)*cross(a2-a1 , b2-a1) < EPS) &&\n\t( cross(b2-b1 , a1-b1)*cross(b2-b1 , a2-b1) < EPS);\n}\n\ndouble dist_s(P p1, P p2, P q1, P q2){\n  if(intersect_s(p1,p2,q1,q2)) return 0;\n  return min(min(psd(p1, q1, q2), psd(p2, q1, q2)),\n\t\t\t min(psd(q1, p1, p2), psd(q2, p1, p2)));\n}\n\nbool isin(P p, P a1, P a2){\n  double mx = min(a1.x, a2.x), Mx = max(a1.x, a2.x);\n  double my = min(a1.y, a2.y), My = max(a1.y, a2.y);\n  return mx < p.x && p.x < Mx\n\t&& my < p.y  && p.y < My;\n}\n\nint main(){\n  int N;\n  while(cin>>N,N){\n\tP s, e;\n\tvector< vector<P> > ps(N, vector<P>(4));\n\tvector<double> h(N), d(N, M);\n\tcin >> s.x >> s.y >> e.x >> e.y;\n\tREP(i,N){\n\t  cin >> ps[i][0].x >> ps[i][0].y >> ps[i][2].x >> ps[i][2].y >> h[i];\n\t  ps[i][1].x = ps[i][0].x;\n\t  ps[i][1].y = ps[i][2].y;\n\n\t  ps[i][3].x = ps[i][2].x;\n\t  ps[i][3].y = ps[i][0].y;\n\t}\n\n\tbool ng = false;\n\tREP(i,N){\n\t  if(isin(s, ps[i][0], ps[i][2]) || isin(e, ps[i][0], ps[i][2]))\n\t\tng = true;\n\t  REP(j,4)\n\t\tif(intersect_s(s,e,ps[i][j],ps[i][(j+1)%4]))\n\t\t   ng = true;\n\t}\n\tif(ng){\n\t  cout << 0 << endl;\n\t  continue;\n\t}\n\n\tREP(i,N) REP(j,4){\n\t  d[i] = min(d[i], dist_s(s, e, ps[i][j], ps[i][(j+1)%4]));\n\t}\n\n\tdouble r_lb = 0., r_ub = 1100.;\n\n\tREP(i,100){\n\t  bool flag = true;\n\t  double r = (r_lb + r_ub) / 2.;\n\t  REP(j,N){\n\t\tif(d[j] < sqrt(r*r - (r-min(r, h[j]))*(r-min(r, h[j])))){\n\t\t  flag = false;\n\t\t  break;\n\t\t}\n\t  }\n\n\t  if(flag) r_lb = r;\n\t  else r_ub = r;\n\t}\n\n\tcout << fixed << setprecision(6) << r_lb << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define FOR(i,s,e) for(int(i)=(s);(i) < (e);(i)++)\n#define debug(x) cout << #x << \": \" << x << endl\nconst int INF = 1e9;\nconst ll LINF = 1e16;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(),nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N;\n\tLine st;\n\tvector<Line> lines;\n\tvector<int> Hs;\n\twhile (cin >> N,N) {\n\t\tint sx, sy, ex, ey;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tst = Line(Point(sx, sy), Point(ex, ey));\n\t\tlines.clear();\n\t\tHs.clear();\n\n\t\tbool kousa = false;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint minx, miny, maxx, maxy, h;\n\t\t\tcin >> minx >> miny >> maxx >> maxy >> h;\n\n\t\t\tif (minx <= min(sx, ex) && miny <= min(sy, ey) && max(sx, ex) <= maxx && max(sy, ey) <= maxy) {\n\t\t\t\tkousa = true;\n\t\t\t}\n\n\t\t\tlines.push_back(Line(Point(minx, miny), Point(minx, maxy)));\n\t\t\tlines.push_back(Line(Point(minx, miny), Point(maxx, miny)));\n\t\t\tlines.push_back(Line(Point(minx, maxy), Point(maxx, maxy)));\n\t\t\tlines.push_back(Line(Point(maxx, miny), Point(maxx, maxy)));\n\t\t\tfor (int j = 0; j < 4; j++) Hs.push_back(h);\n\t\t}\n\t\tif (kousa) { cout << 0 << endl; continue; }\n\n\t\tbool f = false;\n\n\t\tld ans = 1000;\n\t\tfor (int i = 0; i < lines.size(); i++) {\n\t\t\tld dic = dist_ss(st, lines[i]);\n\t\t\tif (dic < eps) { cout << 0 << endl; f = true; break; }\n\n\t\t\tld l = 0, r = 1000;\n\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\tld  mid = (l + r) / 2;\n\t\t\t\tPoint tyusin(0, mid);\n\t\t\t\tLine tyo_takasa(Point(dic, 0), Point(dic, Hs[i]));\n\n\t\t\t\tld r_dic = dist_sp(tyo_takasa, tyusin);\n\t\t\t\tif (mid - r_dic >eps) {\n\t\t\t\t\tr = mid;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tl = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min((ld)ans, l);\n\t\t}\n\t\tif (f) continue;\n\t\tcout << setprecision(10) <<  ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-9,INF=114514;    // 許容誤差。問題によって変える\ntypedef complex<double> P;  // Point\n#define X real()\n#define Y imag()\nnamespace std{\n    bool operator<(const P p1, const P p2){\n        return p1.X != p2.X ? p1.X < p2.X : p1.Y < p2.Y;\n    }\n    P operator+(const P p1, const P p2) { return P(p1.X + p2.X, p1.Y + p2.Y); }\n    P operator-(const P p1, const P p2) { return P(p1.X - p2.X, p1.Y - p2.Y); }\n    P operator*(const P p, double k) { return P(p.X * k, p.Y * k); }\n    P operator/(const P p, double k) { return P(p.X / k, p.Y / k); }\n}\n\ndouble norm(P &p1, P &p2){\n    return (p1.X - p2.X) * (p1.X - p2.X) + (p1.Y - p2.Y) * (p1.Y - p2.Y);\n}\n\n//Segment/L\nstruct Segment{\n    P p1, p2;\n    Segment() {}\n    Segment(P p1, P p2) : p1(p1), p2(p2) {}\n};\ntypedef Segment L;\n\n//外積cross(a,b) = |a||b|sinθ=a1b2-a2b1\ndouble cross(const P &a, const P &b){\n    return (conj(a) * b).Y;\n}\n//内積dot(a,b) = |a||b|cosθ=a1b1+a2b2\ndouble dot(const P &a, const P &b){\n    return (conj(a) * b).X;\n}\n\nP Projection(L l, P p){\n    P base = l.p2 - l.p1;                        //始点\n    double r = dot(p - l.p1, base) / norm(base); //線分に対する倍率の計算\n    return l.p1 + base * r;\n}\n//位置関係判定(線分abを軸にcがどちら側にあるか)\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a; //aからの向きを考える\n    if (cross(b, c) > EPS)\n        return +1; //clockwise\n    else if (cross(b, c) < -EPS)\n        return -1; //counter clockwise\n    else if (dot(b, c) < -EPS)\n        return +2; //c-a-b\n    else if (norm(b) < norm(c))\n        return -2; //a-b-c\n    else\n        return 0; //他\n}\n\n//Intersection Determination\nbool intersectSS(const L &s, const L &t){\n    return ccw(s.p1, s.p2, t.p1) * ccw(s.p1, s.p2, t.p2) <= 0 &&\n           ccw(t.p1, t.p2, s.p1) * ccw(t.p1, t.p2, s.p2) <= 0;\n}\nbool intersectSP(const L &s, const P &p){\n    return abs(s.p1 - p) + abs(s.p2 - p) - abs(s.p2 - s.p1) < EPS; // triangle inequality\n}\ndouble distanceSP(const L &s, const P &p){\n    const P r = Projection(s, p);\n    if (intersectSP(s, r))\n        return abs(r - p);\n    return min(abs(s.p1 - p), abs(s.p2 - p));\n}\ndouble distanceSS(const L &s, const L &t){\n    if (intersectSS(s, t))\n        return 0;\n    return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n               min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\n\nint main(){\n    int N;\n    while(cin>>N and N){\n        double ans = INF;\n        double sx, sy, ex, ey;\n        cin>> sx >> sy >> ex >> ey;\n        P sp = P(sx, sy), ep = P(ex, ey);\n        L root = L(sp, ep);\n        for (int i = 0; i < N;i++){\n            double x1,x2,y1,y2,h;\n            cin>>x1>>y1>>x2>>y2>>h;\n            P pt1=P(x1,y1),pt2=P(x2,y2),pt3=P(x1,y2),pt4=P(x2,y1);\n            L h1=L(pt1,pt4),h2=L(pt4,pt2),h3=L(pt2,pt3),h4=L(pt3,pt1);\n            if(x1<min(sx,ex) and x2>max(sx,ex) and y1<min(sy,ey) and y2>max(sy,ey))\n                ans = 0;\n            double d=min({distanceSS(root,h1),distanceSS(root,h2),distanceSS(root,h3),distanceSS(root,h4)});\n            if(h<=d){\n                ans = min(ans, (h * h + d * d) / (2 * h));\n            }else{\n                ans = min(ans, d);\n            }\n        }\n        printf(\"%lf\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//二次元幾何ライブラリ\n#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define ML make_pair \ntypedef long double D;\ntypedef bool B;\ntypedef complex<D> P;   //点\ntypedef complex<D> V;   //ベクトル\ntypedef pair<P,P>  L;   //直線\ntypedef pair<P,D>  C;   //円\ntypedef vector<P>  Pol; //多角形\n\n//変数名定義\nconst D INF = 1e100;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ntemplate<class T> bool operator==(T a, T b){return abs(a - b )< EPS;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n\n\n\n// ベクトルaの絶対値を求める\n// D Length = abs(a);\n\n// 2点a,b間の距離を求める\n// D Distance = abs(a-b); \n\n// 内積 (Inner Product) : a・b = |a||b|cosθ\nD IP(V a, V b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (Exterior Product) : |a×b| = |a||b|sinθ \nD EP(V a, V b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n// 点の進行方向について\nint ccw(P a, P b, P c) {              //点aと点bが与えられた問いに\n  b -= a; c -= a;\n  if (EP(b, c) > 0)   return +1;      // counter clockwise\n  if (EP(b, c) < 0)   return -1;      // clockwise\n  if (IP(b, c) < 0)     return +2;    // c--a--b on line\n  if (norm(b) < norm(c)) return -2;   // a--b--c on line\n  return 0;                           // a--c--b on line  aとbの線分判定はこれ\n}\n\n\n// 2直線の垂直判定 : a⊥b <=> IP(a, b) = 0\nB IsVecular(L l1, L l2) {\n\treturn IP(l1.first-l1.second, l2.first-l2.second)==0.0;\n}\n\n// 2直線の平行判定 : a//b <=> EP(a, b) = 0\nB IsParallel(L l1, L l2) {\n\treturn EP(l1.first-l1.second, l2.first-l2.second)== 0.0;\n}\n\n// 2線分の交差判定 \nB IIS(L l1, L l2) {\n  return ( EP(l1.second-l1.first, l2.first-l1.first) * EP(l1.second-l1.first, l2.second-l1.first) < EPS ) &&\n         ( EP(l2.second-l2.first, l1.first-l2.first) * EP(l2.second-l2.first, l1.second-l2.first) < EPS );\n}\n\n// 符号付き点と直線の距離 (Distance of Point and Line)  //lの構造 x座標 first<second y座標 first<second 左上 正 右下 負 一致 0\nD  DPL(P p,L l){\n\tV v1=(l.second-l.first);\n\tV v2=(p-l.first);\n\treturn EP(v1,v2)/abs(v1);\n}\n\n// 点と線分の距離 (Distance of Point and Segment)  //lの構造 x座標 first<second y座標 first < second \nD  DPS(P p,L l){\n\tV v1,v2,v3;\n\tv1=l.second-l.first;\n\tv2=p-l.first;\n\tv3=p-l.second;\n\tif(IP (v1,v2) <0)\n\t\treturn abs(p-l.first);\n\telse if(IP(-v1,v3)<0)\n\t\treturn abs(p-l.second);\n\telse\n\t\treturn abs(DPL(p,l));\n}\n\n// 線分と線分の距離 (Distance of Segment and Segment)  //lの構造 x座標 first<second y座標 first < second \nD DSS(L l1,L l2){\n\tif(IIS(l1,l2))\n\t\treturn 0;\n\telse{\n\t\tD tem,tem1,tem2;\n\t\ttem1=min(DPS(l1.first,l2),DPS(l1.second,l2));\n\t\ttem2=min(DPS(l2.first,l1),DPS(l2.second,l1));\n\t\treturn\tmin(tem1,tem2);\n\t}\n}\n\n// 三角形の領域判定 Teritory of Triangle 1が内部 0が境界と外部\nB TT(P p1,P p2,P p3,P p){\n\tL l1,l2,l3;\n\tl1=make_pair(p2,p3);\n\tl2=make_pair(p3,p1);\n\tl3=make_pair(p1,p2);\n\n\tif(sig(DPL(p1,l1))!=sig(DPL(p,l1)))\n\t\treturn false;\n\telse if(sig(DPL(p2,l2))!=sig(DPL(p,l2)))\n\t\treturn false;\n\telse if(sig(DPL(p3,l3))!=sig(DPL(p,l3)))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n//変数名 = 型 代入したいもの\n//example : v1 = V(5.0,-3.0) p1=P(0.0,4.0)\nint main(void){\n\twhile(true){\n\tint N;\n\t\tcin >>N; \n\tif(!N)\n\t\tbreak;\n\tD Block[50][2][2];\n\tD h[50];\n\tP root1,root2;\n\tL root;\n\tD r;\n\tD rmin=INF;\n\t\tcin >> root1.real() >> root1.imag() >> root2.real() >> root2.imag();\n\trep(i,N)\n\t\tcin >>Block[i][0][0] >>Block[i][0][1] >> Block[i][1][0] >> Block[i][1][1] >>h[i] ;\n\troot=ML(root1,root2);\n\trep(i,N){\n\t\t\tD tem,tem1,tem2;\n\t\t\tP p1,p2,p3,p4;\n\t\t\tp1=P(Block[i][0][0],Block[i][0][1]);\n\t\t\tp2=P(Block[i][1][0],Block[i][0][1]);\n\t\t\tp3=P(Block[i][1][0],Block[i][1][1]);\n\t\t\tp4=P(Block[i][0][0],Block[i][1][1]);\n\t\t\tL la,lb,lc,ld;\n\t\t\tla=ML(p1,p2);\n\t\t\tlb=ML(p2,p3);\n\t\t\tlc=ML(p3,p4);\n\t\t\tld=ML(p4,p1);\n\t\t\tif(p1.real()<root1.real()&&root1.real()<p3.real()&&p1.imag()<root1.imag()&&root1.imag()<p3.imag())\n\t\t\t\ttem=0;\n\t\t\telse {\n\t\t\t\ttem1=min(DSS(root,la),DSS(root,lb));\n\t\t\t\ttem2=min(DSS(root,lc),DSS(root,ld));\n\t\t\t\ttem=min(tem1,tem2);\n\t\t\t}\n\t\t\tif(tem<=h[i])\n\t\t\t\tr=tem;\n\t\t\telse\n\t\t\t\tr=(h[i]+tem*tem/h[i])/2.0;\n\t\t\tif(rmin > r)\n\t\t\t\trmin=r;\n\t}\n    cout << fixed << rmin << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define EPS (1e-10)\ntypedef complex<double> P;\n//実数同士の比較\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n \n//二つのベクトルが等しいかどうか\nbool EQV(P a, P b){\n    return (EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()));\n}\n \n//内積\ndouble dot(P a, P b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n//外積\ndouble cross(P a, P b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n// 点cが線分a,b上にあるかないか(3)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n \n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n \n//図を思い出す\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n \n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n \n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\ndouble distance(P p0, P p1, P p2, P p3){\n  double ans = 1e10;\n        ans = min(ans, distance_ls_p(p0, p1, p2));\n        ans = min(ans, distance_ls_p(p0, p1, p3));\n        ans = min(ans, distance_ls_p(p2, p3, p0));\n        ans = min(ans, distance_ls_p(p2, p3, p1));\n        if(is_intersected_ls(p0, p1, p2, p3)) ans = 0.0;\n\t\treturn ans;\n}\n\nint main(){\n\tfor(int z = 0; z < 26; z++){\n\t\tint n; cin >> n;\n\t\tif(n == 0 )break;\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tP s = P(x,y);\n\t\tcin >> x >> y;\n\t\tP g = P(x,y);\n\t\tvector<P> mins(n), maxs(n);\n\t\tvector<double> h(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x >> y;\n\t\t\t//if(z == 24)printf(\"%.0f %.0f\",x,y);\n\t\t\tmins[i].real(x); mins[i].imag(y);\n\t\t\tcin >> x >> y;\n\t\t\t//if(z == 24)printf(\" %.0f %.0f\",x,y);\n\t\t\tmaxs[i].real(x); maxs[i].imag(y);\n\t\t\tcin >> h[i];\n\t\t\t//if(z == 24)printf(\" %.0f \\n\",h[i]);\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tfor(int i = 0; i < n;i++){\n\t\t\tdouble d = 1e9;\n\t\t\tP p1 = mins[i], p3 = maxs[i];\n\t\t\tP p2(mins[i].real(), maxs[i].imag());\n\t\t\tP p4(maxs[i].real(), mins[i].imag());\n\t\t\tif(p1.real() < s.real() && s.real() < p3.real() && \n\t\t\t\tp1.imag() < s.imag() && s.imag() < p3.imag()){\n\t\t\t\tans = 0;/*\n\t\t\t\tif(z==24){\n\t\t\t\t\tprintf(\"%.0f %.0f %.0f %.0f\\n\",p1.real(),p1.imag(),p3.real(),p3.imag());\n\t\t\t\t\tcout << \"break\" << endl;}*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, distance(s, g, p1,p2));\n\t\t\td = min(d, distance(s, g, p2,p3));\n\t\t\td = min(d, distance(s, g, p3,p4));\n\t\t\td = min(d, distance(s, g, p4,p1));\n\t\t\tdouble r = (h[i]*h[i]+d*d)/(2*h[i]);\n\t\t\tif(h[i] < d){\n\t\t\t\tans = min(ans, r);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = min(ans, d);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4f\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst double EPS = 1e-8;\n\nusing R = double;\nusing P = complex<R>;\nusing L = pair<P,P>;\nusing G = vector<P>;\nstruct C {\n  P c; R r;\n  C() {}\n  C(const P &a, const R &b) : c(a), r(b) {}\n};\nstruct S : public L {\n  S() {}\n  S(const P &a, const P &b) : L(a,b) {}\n};\n\ninline int sgn(const R& r) { return (r>EPS) - (r<-EPS); }\ninline R dot(const P& a, const P& b) {\n  return real(a)*real(b) + imag(a)*imag(b);\n}\ninline R det(const P& a, const P& b) {\n  return real(a)*imag(b) - imag(a)*real(b);\n}\ninline P vec(const L& l) {return l.second - l.first;}\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn sgn(real(a-b)) ? real(a-b) < 0 : sgn(imag(a-b)) < 0;\n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn sgn(real(a-b)) == 0 && sgn(imag(a-b)) == 0;\n\t}\n  bool cmp_y (const P& a, const P& b) {\n    return sgn(imag(a-b)) ? imag(a-b) < 0 : sgn(real(a-b)) < 0;\n  }\n}\n\n// P,L,Sについて入力\ninline istream& operator>>(istream& is, P& p) {\n  R x, y;\n  is >> x >> y;\n  p = P(x, y);\n  return is;\n}\ninline istream& operator>>(istream& is, L& l) {\n  P a, b;\n  is >> a >> b;\n  l = L(a, b);\n  return is;\n}\ninline istream& operator>>(istream& is, S& s) {\n  P a, b;\n  is >> a >> b;\n  s = S(a, b);\n  return is;\n}\n\n// 射影\nP inline projection(const L &l, const P &p) {\n  R t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\n// 反射\nP inline reflection(const L &l, const P &p) {\n  return p + (R)2 * (projection(l, p) - p);\n}\n\n// 線分abから見たcの位置\nenum CCW{LEFT=1, RIGHT=2, BACK=4, FRONT=8, ON_SEG=16};\nint ccw(P a, P b, P c) {\n\tP p = (c-a)/(b-a);\n\tif(sgn(imag(p)) > 0) return LEFT;\n\tif(sgn(imag(p)) < 0) return RIGHT;\n\tif(sgn(real(p)) < 0) return BACK;\n\tif(sgn(real(p)-1) > 0) return FRONT;\n\treturn ON_SEG;\n}\n\n// 垂直,平行\ninline bool vertical(L a, L b) {return sgn(dot(vec(a), vec(b))) == 0;}\ninline bool parallel(L a, L b) {return sgn(det(vec(a), vec(b))) == 0;}\ninline bool eal(L a, L b) {return vertical(a,b) && parallel(a,b);}\n\n// 交差判定\ntemplate<bool strict=false> inline bool intersect(const L&l1, const L&l2) {\n  if(strict) return sgn(det(vec(l1),vec(l2))) != 0;\n  return sgn(det(vec(l1),vec(l2))) != 0 || l1 == l2;\n}\ntemplate<bool strict=false> inline bool intersect(const L&l, const S&s) {\n  if(strict) det(s.first, vec(l)) * det(s.second, vec(l)) < 0;\n  return det(s.first, vec(l)) * det(s.second, vec(l)) <= 0;\n}\ntemplate<bool strict=false> inline bool intersect(const S&s1, const S&s2) {\n  int ccw1 = ccw(s1.first, s1.second, s2.first) | ccw(s1.first, s1.second, s2.second);\n  int ccw2 = ccw(s2.first, s2.second, s1.first) | ccw(s2.first, s2.second, s1.second);\n  if(strict) return (ccw1 & ccw2) == (LEFT | RIGHT);\n  return (ccw1 & ccw2) == (LEFT | RIGHT) || ((ccw1 | ccw2) & ON_SEG);\n}\ntemplate<bool strict=false> inline bool intersect(const S&s, const P&p) {\n  return ccw(s.first, s.second, p) == ON_SEG;\n}\ntemplate<bool strict=false> inline bool intersect(const L&l, const P&p) {\n  return ccw(l.first, l.second, p) == ON_SEG ||\n          ccw(l.first, l.second, p) == FRONT ||\n          ccw(l.first, l.second, p) == BACK;\n}\nint intersect(const C& a, const C& b) {\n\tR dist = sqrt(norm(a.c-b.c)), r1 = a.r + b.r, r2 = abs(a.r - b.r);\n\tif(sgn(r1-dist) < 0)  return 4;\t// 円が離れている\n\tif(sgn(r1-dist) == 0) return 3;\t// 外接\n\tif(sgn(r2-dist) < 0 && sgn(dist-r1) < 0) return 2; // 交差\n\tif(sgn(dist-r2) == 0) return 1; // 内接\n\treturn 0;\t// 内部に含む\n}\n\n// 距離\nR dist(const S& s, const P& p) {\n  P q = projection(s, p);\n  if(sgn(dot(s.second-s.first, p-s.first)) <= 0) q = s.first;\n  if(sgn(dot(s.first-s.second, p-s.second)) <= 0) q = s.second;\n  return abs(p-q);\n}\nR dist(const S& a, const S& b) {\n  if(intersect(a, b)) return 0;\n  return min({dist(a, b.first), dist(a, b.second), dist(b, a.first), dist(b, a.second)});\n}\nR dist(const L& l, const P& p) {\n  P q = projection(l, p);\n  return abs(p-q);\n}\n\n// 交点 交差判定を先にすること!!!\ninline P crosspoint(const L& l1, const L& l2) {\n  R ratio = det(vec(l2), l2.first-l1.first)/det(vec(l2),vec(l1));\n  return l1.first + vec(l1)*ratio;\n}\n// ToDo:そもそも交差しないとき\nvector<P> crosspoint(C c, L l) {\n\tR d = dist(l, c.c), r = c.r;\n\tP m = projection(l, c.c);\n\tP x = sqrt(r*r-d*d)*vec(l)/abs(vec(l));\n\tvector<P> ret(2,m);\n\tret[0] -= x; ret[1] += x;\n\tif(ret[1] < ret[0]) swap(ret[0], ret[1]);\n\treturn ret;\n}\nvector<P> crosspoint(C a, C b) {\n\tR d = abs(a.c-b.c);\n\tR t = (a.r*a.r-b.r*b.r+d*d)/2/d, h = sqrt(a.r*a.r-t*t);\n\tP m = t/abs(b.c-a.c)*(b.c-a.c)+a.c;\n  auto n_vector = [&](P p) -> P { return P(-p.imag(), p.real())/abs(p); };\n\tP n = n_vector(a.c-b.c);\n\tvector<P> ret(2, m);\n\tret[0] -= h*n; ret[1] += h*n;\n\tif(ret[1] < ret[0]) swap(ret[0], ret[1]);\n\treturn ret;\n}\n\n// 面積 頂点が反時計回りに並んでいること\nR area(const G& pol) {\n  R ret = 0.0;\n  REP(i, pol.size()) ret += det(pol[i], pol[(i+1)%pol.size()]);\n  return (ret/2.0);\n}\n\n// 凸性の判定\nbool isConvex(const G& pol) {\n  REP(i, pol.size()) {\n    if(sgn(det(pol[(i+1)%pol.size()]-pol[i], pol[(i+2)%pol.size()]-pol[i])) < 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// 多角形と点の内包\n// 2→in 1→on 0→out\nint inPolygon(const G& pol, const P& p) {\n  bool in = false;\n  for (int i = 0; i < pol.size(); ++i) {\n  \tP a = pol[i] - p, b = pol[(i+1)%pol.size()] - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b) && sgn(det(a, b)) < 0) {\n      in = !in;\n    }\n    if (sgn(det(a, b)) == 0 && sgn(dot(a, b)) <= 0) return 1;\n  }\n  return in ? 2 : 0;\n}\n\n// 凸包 3点が一直線上に並ぶときに注意\n// 凸包のうち一番左にある頂点の中で一番下の頂点から時計回り\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  G r(2*n);\n  for(int i=0; i<n; i++){\n    while(k>1 && sgn(det(r[k-1]-r[k-2], ps[i]-r[k-2])) < 0) k--;\n    r[k++] = ps[i];\n  }\n  for(int i=n-2,t=k; i>=0; i--){\n    while(k>t && sgn(det(r[k-1]-r[k-2], ps[i]-r[k-2])) < 0) k--;\n    r[k++] = ps[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\n/*\n3点が与えられたときに円を求める\n返り値は{中心のx座標、y座標、半径}\n3点が直線上に並んでいるときは{0, 0, -1}を返す\nToDo:見直す\n*/\nC calcCircle(R x1, R y1, R x2, R y2, R x3, R y3) {\n  R ox, oy, a, b, c, d;\n  R r1, r2, r3;\n\n  a = x2 - x1; b = y2 - y1; c = x3 - x1; d = y3 - y1;\n  R cx, cy, r;\n  if ((a && d) || (b && c)) {\n    ox = x1 + (d*(a*a + b*b) - b*(c*c + d*d)) / (a*d - b*c) / 2;\n    if (b) oy = (a*(x1+x2-ox-ox) + b*(y1+y2)) / b/2;\n    else oy = (c*(x1+x3-ox-ox) + d*(y1+y3)) / d/2;\n    r1 = sqrt((ox-x1) * (ox-x1) + (oy-y1) * (oy-y1));\n    r2 = sqrt((ox-x2) * (ox-x2) + (oy-y2) * (oy-y2));\n    r3 = sqrt((ox-x3) * (ox-x3) + (oy-y3) * (oy-y3));\n    cx = ox;\n    cy = oy;\n    r = (r1+r2+r3) / 3;\n    return {P{cx, cy}, r};\n  }\n\n  return {P{0, 0}, -1};\n}\n\n// 2点p1, p2を通り、半径がrの円を2つ返す\nvector<C> calcCircle(P p1, P p2, R r) {\n\t// 存在しない\n\tif(abs(p1-p2) > 2*r) return {};\n\tP p3 = {(p1.real()+p2.real())/2, (p1.imag()+p2.imag())/2};\n\tR l = abs(p1-p3);\n\tP p1p2 = p2-p1;\n\tR a = p1p2.real(), b = p1p2.imag();\n\tR dx1 = b*sqrt((r*r-l*l)/(a*a+b*b)), dy1 = a*sqrt((r*r-l*l)/(a*a+b*b));\n\treturn {{{p3.real()+dx1, p3.imag()-dy1}, r}, {{p3.real()-dx1, p3.imag()+dy1}, r}};\n}\n\nP p1[55], p2[55];\nR d[55], h[55];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    S s;\n    cin >> s;\n    REP(i, n) cin >> p1[i] >> p2[i] >> h[i];\n\n    REP(i, n) {\n      d[i] = INF;\n      S tmp = S(p1[i], P{p1[i].real(), p2[i].imag()});\n      chmin(d[i], dist(s, tmp));\n      tmp = S(P{p1[i].real(), p2[i].imag()}, p2[i]);\n      chmin(d[i], dist(s, tmp));\n      tmp = S(p2[i], P{p2[i].real(), p1[i].imag()});\n      chmin(d[i], dist(s, tmp));\n      tmp = S(P{p2[i].real(), p1[i].imag()}, p1[i]);\n      chmin(d[i], dist(s, tmp));\n      if(p1[i].real() <= s.first.real() && s.first.real() <= p2[i].real()\n        && p1[i].imag() <= s.first.imag() && s.first.imag() <= p2[i].imag()) {\n        d[i] = 0;\n      }\n      if(p1[i].real() <= s.second.real() && s.second.real() <= p2[i].real()\n        && p1[i].imag() <= s.second.imag() && s.second.imag() <= p2[i].imag()) {\n        d[i] = 0;\n      }\n    }\n\n    auto check = [&](R r) -> bool {\n      REP(i, n) {\n        if(r < h[i]) {\n          if(r > d[i]) return false;\n        } else {\n          R tmp = r*r - (r-h[i])*(r-h[i]);\n          if(tmp > d[i]*d[i]) return false;\n        }\n      }\n      return true;\n    };\n\n    bool flag = false;\n    const R dr = 0.001/2;\n    for(R r = 1000; r >= 0; r -= dr) {\n      if(check(r)) {\n        cout << fixed << setprecision(9) << r << endl;\n        flag = true;\n        break;\n      }\n    }\n\n    if(!flag) cout << 0 << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#define REP(i,n) for(int i = 0;i < (n);i++)\nconst double EPS = 1e-10;\nconst double INF = 1e+10;\nusing namespace std;\n\nstruct Point{\n    double x,y;\n    Point operator - (const Point& p){return Point{x-p.x, y-p.y};}\n};\n\nstruct Segment{\n    Point p1,p2;\n};\n\n\n\nint N;\nSegment square[51][4];\nPoint squarep[51][4];\nSegment course;\ndouble height[51];\ndouble norm(Point a){return a.x*a.x + a.y*a.y;}\ndouble abs(Point a){return sqrt(norm(a));}\n\ndouble dot(Point a, Point b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Point a, Point b){\n    return a.x * b.y - a.y * b.x;\n}\n\nint ccw(Point c, Point a, Point b){\n    b = b - a;\n    a = a - c;\n    if(cross(a,b) > EPS)return 1;\n    if(cross(a,b) < -EPS)return -1;\n    if(dot(a,b) < -EPS) return 2;\n    if(norm(a) < norm(b)) return -2;\n    return 0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0;\n}\n\ndouble gdSP(Segment s, Point p){\n    if(dot(s.p2 - s.p1, p - s.p1) < -EPS) return abs(p-s.p1);\n    if(dot(s.p1 - s.p2, p - s.p2) < -EPS) return abs(p-s.p2);\n    return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n\ndouble getdist(Segment s1, Segment s2){\n    if(intersect(s1.p1, s1.p2, s2.p1, s2.p2)) return 0.0;\n    return min(min(gdSP(s1, s2.p1),gdSP(s1,s2.p2)), min(gdSP(s2,s1.p1), gdSP(s2,s1.p2)));\n}\n\nbool contains(int i, Point p){\n    bool x = false;\n    REP(j,4){\n        Point a = squarep[i][j] - p, b = squarep[i][(j+1)%4] - p;\n        if(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return true;\n        if(a.y > b.y) swap(a,b);\n        if(a.y < EPS && EPS < b.y && cross(a,b) >EPS)x = !x;\n    }\n    return x;\n}\n\nbool cangoal(double r){\n    REP(i,N){\n        //????????????????????????\n        if(contains(i, course.p1) || contains(i, course.p2)) return false;\n        \n        double coursedist = INF;\n        REP(j,4){\n            coursedist = min(getdist(course, square[i][j]), coursedist);\n        }\n        double balldist;\n        if(height[i] < r){\n            balldist = sqrt(2*r*height[i] - height[i]*height[i]);\n        }else{\n            balldist = r;\n        }\n        if(coursedist < balldist) return false;\n    }\n    return true;\n}\n\nint main(){\n    while(cin >> N,N){\n        double sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        course = Segment{Point{sx, sy}, Point{ex, ey} };\n        REP(i,N){\n            double x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2 >> height[i];\n            REP(d,4){\n                squarep[i][d] = Point{x1, y1};\n                if(d & 1){\n                    square[i][d] = Segment{Point{x1, y1}, Point{x1, y2} };\n                    swap(x1,x2);\n                }else{\n                    square[i][d] = Segment{Point{x1, y1}, Point{x2, y1} };\n                    swap(y1,y2);\n                }\n            }\n        }\n        double l = 0.0, r = 1001.0;\n        for(int ct = 0;ct < 100;ct++){\n            double mid = (l + r)/2;\n            if(cangoal(mid)) l = mid;\n            else r = mid;\n        }\n        if(l < EPS)cout << 0 << endl;\n        else cout << fixed << setprecision(8) << l << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p1;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n//\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tint x=ccw(s.p1,s.p2,pr);\n//\tif(x>=-1&&x<=1) return d;\n\tif(x==0) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t//\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\tif(ccw(q[0],q[1],r)==0){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t//\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\tif(ccw(p[0],p[1],r)==0){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e5;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 1;\nstatic const int CCW_ONLINE_FRONT = 1;\nstatic const int CCW_ON_SEGMENT = 1;\n\nstruct Point {\n  double x, y;\n  Point() {}  \n  Point(double x, double y) :x(x), y(y){}\n  Point operator-(Point p) { return Point(x-p.x, y-p.y); }\n  double norm() { return x*x+y*y; }\n  double abs() { return sqrt(norm()); }\n};\n\ntypedef Point Vector;\n\nstruct Segment {\n  Point p1, p2;\n  Segment() {}\n  Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nbool intersectSS(Point p1, Point p2, Point p3, Point p4);\nbool intersectSS(Segment s1, Segment s2);\n\ndouble norm(Vector a) {\n  return a.x*a.x+a.y*a.y;  \n}\n\ndouble abs(Vector a) {\n  return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b) {\n  return a.x*b.x+a.y*b.y;  \n}\n\ndouble cross(Vector a, Vector b) {\n  return a.x*b.y-a.y*b.x;  \n}\n\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if ( cross(a, b) > EPS ) return CCW_COUNTER_CLOCKWISE;\n  if ( cross(a, b) < -EPS ) return CCW_CLOCKWISE;\n  if ( dot(a, b) < -EPS ) return CCW_ONLINE_BACK;\n  if ( a.norm() < b.norm() ) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT; \n}\n\nbool intersectSS(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0 );\n}\n\nbool intersectSS(Segment s1, Segment s2) {\n  return intersectSS(s1.p1, s1.p2, s2.p1, s2.p2);  \n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2-l.p1, p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n  if ( dot(s.p2-s.p1, p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if ( dot(s.p1-s.p2, p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s, p);  \n}\n\ndouble getDistanceSS(Segment s1, Segment s2) {\n  if ( intersectSS(s1, s2) ) return 0.0;  \n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p1)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p1)));\t\t \n}\n\nint main() {\n  int N;\n  while ( cin >> N, N ) {\n    Point s, e;\n    cin >> s.x >> s.y >> e.x >> e.y;\n\n    vector<double> h(N);\n    vector<Point> b1(N), b2(N);    \n    for ( int i = 0; i < N; i++ ) {\n      cin >> b1[i].x >> b1[i].y >> b2[i].x >> b2[i].y;\n      cin >> h[i];      \n    }\n\n    double ans = (double)100000.0;\n    Segment se(s, e);    \n    for ( int i = 0; i < N; i++ ) {\n      //cout << ans << endl;\n      Point p1 = b1[i], p2(b1[i].x, b2[i].y), p3 = b2[i], p4(b2[i].x, b1[i].y);      \n      Segment s1(p1, p2), s2(p2, p3), s3(p3, p4), s4(p4, p1);\n      double l = (double)100000.0;\n      if ( min(b1[i].x, b2[i].x) <= s.x && s.x <= max(b1[i].x, b2[i].x) &&\n\t   min(b1[i].y, b2[i].y) <= s.y && s.y <= max(b1[i].y, b2[i].y) ) {\n\tans = 0;\t\n      }\n      if ( min(b1[i].x, b2[i].x) <= e.x && e.x <= max(b1[i].x, b2[i].x) &&\n\t   min(b1[i].y, b2[i].y) <= e.y && e.y <= max(b1[i].y, b2[i].y) ) {\n\tans = 0;\t\n      }\n      l = min(l, getDistanceSS(se, s1));\n      l = min(l, getDistanceSS(se, s2));\n      l = min(l, getDistanceSS(se, s3));\n      l = min(l, getDistanceSS(se, s4));\n      if ( l <= (double)h[i] ) ans = min(ans, l);\n      else ans = min(ans, (l*l+h[i]*h[i])/h[i]/2);      \n    }\n\n    cout << fixed << setprecision(10) << ans << endl;  \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// cpp_range (generic range class, very small equivalent of boost::irange)\n// (C) @cielavenir under Boost Software License.\n// note: end position is exclusive.\n\n#include <iterator>\ntemplate<typename T>\nclass range{\npublic:\n\tstruct iterator{\n\t\tconst T a,b;\n\t\tT p;\n\t\tconst long long d; //because T might be unsigned.\n\t\titerator(T _a,T _b,T _p,long long _d=1):a(_a),b(_b),p(_p),d(_d){}\n\n\tpublic:\n\t\ttypedef T value_type;\n\t\ttypedef T& reference;\n\t\ttypedef T* pointer;\n\t\ttypedef std::ptrdiff_t difference_type;\n\t\ttypedef std::random_access_iterator_tag iterator_category;\n\n\t\t//copy\n\t\titerator(const iterator &other):a(other.a),b(other.b),p(other.p),d(other.d){}\n\t\titerator operator=(const iterator &other){return iterator(other.a,other.b,other.p,other.d);}\n\n\t\t//advance\n\t\titerator& operator+=(T n){p+=n*d;return *this;}\n\t\titerator& operator-=(T n){return *this+=(-n);}\n\t\titerator& operator++(){return *this+=1;}\n\t\titerator& operator--(){return *this-=1;}\n\t\titerator operator+(T n) const{return iterator(a,b,p+n*d);}\n\t\titerator operator-(T n) const{return *this+(-n);}\n\n\t\t//difference\n\t\tT operator-(const iterator& other) const{return p-other.p;}\n\n\t\t//equality\n\t\tbool operator==(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p==other.p;}\n\t\tbool operator!=(const iterator& other) const{return !(*this==other);}\n\n\t\t//compare\n\t\tbool operator<(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p*d<other.p*d;}\n\t\tbool operator>(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p*d>other.p*d;}\n\n\t\t//reference\n\t\tconst T& operator*() const{return p;}\n\t};\n\nprivate:\n\tconst T a,b;\n\tT siz;\n\tlong long d;\npublic:\n\trange(T _a,T _b,long long _d=1):a(_a),b(_b){\n\t\td=_d;\n\t\td=d==0?1:d; //\n\t\tsiz=( (d>0?(b-a):(a-b)) - 1)  / (d>0?d:-d);\n\t}\n\n\tT operator[](T n){return a+n*d;}\n\titerator begin(){return iterator(a,a+d*siz,a,d);}\n\titerator end(){return iterator(a,a+d*siz,a+d*(siz+1),d);}\n\titerator rbegin(){return iterator(b-d*siz,b,b,-1*d);}\n\titerator rend(){return iterator(b-d*siz,b,b-d*(siz+1),-1*d);}\n\tT size(){return siz;}\n};\ntemplate<typename T>\nrange<T> make_range(T a,T b,long long d=1){return range<T>(a,b,d);}\n\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cfloat>\nusing namespace std;\ntypedef double val_t;\ntypedef complex<val_t> P;\ntypedef vector<P> VP;\nconst val_t EPS=1e-9;\n\nval_t cross(const P &a,const P &b){return (conj(a)*b).imag();}\nval_t dot(const P &a,const P &b){return (conj(a)*b).real();}\nP projection(const VP &l,const P &p){\n\tP t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n\treturn l[0]+t*(l[0]-l[1]);\n}\nbool intersectSP(const VP &s,const P &p){\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nval_t distanceSP(const VP &s,const P &p){\n\tP r=projection(s,p);\n\treturn intersectSP(s,r) ? abs(r-p) : min(abs(s[0]-p),abs(s[1]-p));\n}\nbool intersectSS(const VP &l,const VP &m){\n\tval_t a=cross(l[1]-l[0],m[1]-m[0]);\n\tval_t b=cross(l[1]-l[0],l[1]-m[0]);\n\t//VP pt=abs(a)<EPS ? abs(b)<EPS ? {l[0],l[1],m[0],m[1]} : VP() : {m[0]+b/a*(m[1]-m[0])};\n\tVP pt=vector<VP>{{l[0],l[1],m[0],m[1]},{},{m[0]+b/a*(m[1]-m[0])}}[abs(a)<EPS?abs(b)<EPS?0:1:2];\n\treturn accumulate(pt.begin(),pt.end(),false,[&](bool S,const P &e){\n\t\treturn S||(dot(l[0]-e,l[1]-e)<EPS && dot(m[0]-e,m[1]-e)<EPS);\n\t});\n}\nval_t distanceSS(const VP &s,const VP &t){\n\treturn intersectSS(s,t) ? 0 : min(\n\t\taccumulate(s.begin(),s.end(),DBL_MAX,[&](val_t S,const P &e){return min(S,distanceSP(t,e));}),\n\t\taccumulate(t.begin(),t.end(),DBL_MAX,[&](val_t S,const P &e){return min(S,distanceSP(s,e));})\n\t);\n}\nint main(){\n\tint n;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tdouble sx,sy,ex,ey;\n\t\tscanf(\"%lf%lf%lf%lf\",&sx,&sy,&ex,&ey);\n\t\tVP s={P(sx,sy),P(ex,ey)};\n\t\tauto ra0=make_range(0,n);\n\t\tprintf(\"%f\\n\",accumulate(ra0.begin(),ra0.end(),DBL_MAX,[&](val_t S,int _)->val_t{\n\t\t\tint f=0;\n\t\t\tdouble x1,y1,x2,y2,h;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf\",&x1,&y1,&x2,&y2,&h);\n\t\t\tVP a;\n\t\t\tfor(auto &x:{x1,x2})for(auto &y:{y1,y2})a.emplace_back(x,y);\n\t\t\tswap(a[2],a[3]);\n\t\t\tauto ra1=make_range(0,4);\n\t\t\tval_t d=accumulate(ra1.begin(),ra1.end(),DBL_MAX,[&](val_t S,int i){\n\t\t\t\tf+=cross(a[i]-s[0],a[(i+1)%4]-s[0])<EPS;\n\t\t\t\treturn min(S,distanceSS(s,{a[i],a[(i+1)%4]}));\n\t\t\t});\n\t\t\treturn min(S,\n\t\t\t\tf==4 ? 0 : //inside\n\t\t\t\td>h ? (h*h+d*d)/h/2 :\n\t\t\t\td\n\t\t\t);\n\t\t}));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <complex>\nusing namespace std;\n#ifdef DEBUGRUN\n#define log(a) (cerr<<#a\"=\"<<a<<endl)\n#else\n#define log(a) ((void)0)\n#endif\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\ntypedef long long Int;\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\ndouble sq(double a) { return a*a; }\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\nint ccw(const P& a, P b, P c) {\n    b -= a, c -= a;\n    if(cross(b, c)>0) return 1;\n    if(cross(b, c)<0) return -1;\n    if(dot(b, c)<0) return 2;\n    if(norm(b)<norm(c)) return -2;\n    return 0;\n}\nbool crossing(const P& l0, const P& l1, const P& m0, const P& m1) {\n    return ccw(m0, m1, l0)*ccw(m0, m1, l1)<=0\n        && ccw(l0, l1, m0)*ccw(l0, l1, m1)<=0;\n}\nP projection(const P& l0, const P& l1, const P& p) {\n    double t = dot(p-l0, l0-l1) / norm(l0-l1);\n    return l0 + t*(l0-l1);\n}\ndouble distanceSP(const P& s0, const P& s1, const P& p) {\n    const P r(projection(s0, s1, p));\n    if(ccw(s0, s1, r)==0) return abs(r-p);\n    return min(abs(s0-p), abs(s1-p));\n}\ndouble distanceSS(const P& s0, const P& s1, const P& t0, const P& t1) {\n    if(crossing(s0, s1, t0, t1)) return 0;\n    return min(min(distanceSP(s0, s1, t0), distanceSP(s0, s1, t1)),\n               min(distanceSP(t0, t1, s0), distanceSP(t0, t1, s1)));\n}\n\nint n, sx, sy, ex, ey;\nint xa[100], ya[100], xb[100], yb[100], h[100];\nP sp, ep, ps[100][4];\n\nbool check() {\n    rep(i, n) {\n        rep(j, 4) {\n            if(crossing(sp, ep, ps[i][j], ps[i][(j+1)%4])) return false;\n        }\n        if(xa[i]<=sx && sx<=xb[i] && ya[i]<=sy && sy<=yb[i]) return false;\n        if(xa[i]<=ex && ex<=xb[i] && ya[i]<=ey && ey<=yb[i]) return false;\n    }\n    return true;\n}\n\ndouble calc(int i) {\n    double ans = 20000;\n    rep(j, 4) {\n        const double d = distanceSS(sp, ep, ps[i][j], ps[i][(j+1)%4]);\n        ans = min(ans, d>h[i] ? (sq(h[i])+sq(d))/(2*h[i]) : d);\n    }\n    return ans;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d\", &n);\n        if(n==0) return 0;\n        scanf(\"%d%d%d%d\", &sx, &sy, &ex, &ey);\n        rep(i, n) scanf(\"%d%d%d%d%d\", xa+i, ya+i, xb+i, yb+i, h+i);\n        sp = P(sx, sy);\n        ep = P(ex, ey);\n        rep(i, n) {\n            ps[i][0] = P(xa[i], ya[i]);\n            ps[i][1] = P(xa[i], yb[i]);\n            ps[i][2] = P(xb[i], yb[i]);\n            ps[i][3] = P(xb[i], ya[i]);\n        }\n        double ans = 0;\n        if(check()) {\n            ans = 2000;\n            rep(i, n) ans = min(ans, calc(i));\n        }\n        printf(\"%.9f\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-3)\ntypedef complex<double> P;\n\ndouble dot(P a, P b) { return a.real() * b.real() + a.imag() * b.imag(); }\n\ndouble cross(P a, P b) { return a.real() * b.imag() - a.imag() * b.real(); }\n\ndouble distance(P s1, P s2, P p) {\n  if (dot(s2 - s1, p - s1) < EPS) return abs(p - s1);\n  if (dot(s1 - s2, p - s2) < EPS) return abs(p - s2);\n  return abs(cross(s2 - s1, p - s1)) / abs(s2 - s1);\n}\n\nbool is_intersected(P a1, P a2, P b1, P b2) {\n  return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < -EPS &&\n         cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < -EPS;\n}\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    int sx, sy, ex, ey;\n    cin >> sx >> sy >> ex >> ey;\n    P s(sx, sy), e(ex, ey);\n    double m = 1e3;\n    for (int i = 0; i < n; i++) {\n      int minx, miny, maxx, maxy, h;\n      cin >> minx >> miny >> maxx >> maxy >> h;\n      vector<P> v = {P(minx, miny), P(minx, maxy), P(maxx, miny), P(maxx, maxy)};\n      double d = 1e3;\n      for (auto p1 : v) {\n        for (auto p2 : v) {\n          if (abs(p2 - p1) < EPS) {\n            continue;\n          }\n          if (is_intersected(s, e, p1, p2)) {\n            d = 0;\n          }\n        }\n      }\n      for (auto p1 : v) {\n        d = min(d, distance(s, e, p1));\n        for (auto p2 : v) {\n          d = min(d, distance(p1, p2, s));\n          d = min(d, distance(p1, p2, e));\n        }\n        m = min(m, d < h ? d : (d * d + h * h) / (2 * h));\n      }\n    }\n    cout << fixed << setprecision(4) << m << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-9;\ntemplate<typename T>\nT sqr(T a) { return a * a; }\n\nstruct search_point {\n\tdouble x, y;\n\tdouble h;\n\tsearch_point(double x_, double y_, double h_) {\n\t\tx = x_; y = y_; h = h_;\n\t}\n};\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tdouble sx, sy, ex, ey;\n\t\tvector<search_point> v;\n\t\tvector<pair<search_point,search_point> > line;\n\t\tvector<pair<search_point,search_point> > lect;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tdouble R = 10000;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble h;\n\t\t\tcin >> x0 >> y0 >> x1 >> y1 >> h;\n\n\t\t\tif(h < EPS)\n\t\t\t\th = EPS;\n\n\t\t\tv.push_back(search_point(x0, y0, h));\n\t\t\tv.push_back(search_point(x1, y1, h));\n\t\t\tv.push_back(search_point(x0, y1, h));\n\t\t\tv.push_back(search_point(x1, y0, h));\n\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x0, y0, 0), search_point(x1, y0, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x1, y0, 0), search_point(x1, y1, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x1, y1, 0), search_point(x0, y1, 0)));\n\t\t\tline.push_back(pair<search_point,search_point>(search_point(x0, y1, 0), search_point(x0, y0, 0)));\n\n\t\t\tlect.push_back(pair<search_point,search_point>(search_point(x0, y0, 0), search_point(x1, y1, 0)));\n\n\t\t\tif(x0 <= sx && sx <= x1) {\n\t\t\t\tv.push_back(search_point(sx, y0, h));\n\t\t\t\tv.push_back(search_point(sx, y1, h));\n\t\t\t}\n\t\t\tif(y0 <= sy && sy <= y1) {\n\t\t\t\tv.push_back(search_point(x0, sy, h));\n\t\t\t\tv.push_back(search_point(x1, sy, h));\n\t\t\t}\n\t\t\tif(x0 <= ex && ex <= x1) {\n\t\t\t\tv.push_back(search_point(ex, y0, h));\n\t\t\t\tv.push_back(search_point(ex, y1, h));\n\t\t\t}\n\t\t\tif(y0 <= ey && ey <= y1) {\n\t\t\t\tv.push_back(search_point(x0, ey, h));\n\t\t\t\tv.push_back(search_point(x1, ey, h));\n\t\t\t}\n\t\t}\n\n\t\tdouble veclx = (ex - sx);\n\t\tdouble vecly = (ey - sy);\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tdouble d;\n\t\t\tdouble mx, my;\n\t\t\tdouble r;\n\n\t\t\tmx = (v[i].x * sqr(veclx) + v[i].y * veclx * vecly + vecly * (sx * ey - sy * ex)) / (sqr(veclx) + sqr(vecly));\n\t\t\tmy = (v[i].y * sqr(vecly) + v[i].x * vecly * veclx + veclx * (sy * ex - sx * ey)) / (sqr(vecly) + sqr(veclx));\n\t\t\t/*\n\t\t\tif((ey - sy) * mx - (ex - sx) * my + (ex * sy - sx * ey) > EPS) {\n\t\t\t\tcout << \"error\" << \" \" << (sy - ey) * mx - (sx - ex) * my - (ex * sy - sx * ey) << endl;\n\t\t\t\tcout << mx << \",\" << my << endl;\n\t\t\t}\n\t\t\t// */\n\t\t\td = sqrt(sqr(mx - v[i].x) + sqr(my - v[i].y));\n\t\t\tif(mx <= min(sx,ex) || max(sx,ex) <= mx || my <= min(sy,ey) || max(sy,ey) <= my) {\n\t\t\t\td = min(sqrt(sqr(sx - v[i].x) + sqr(sy -  v[i].y)), sqrt(sqr(ex - v[i].x) + sqr(ey - v[i].y)));\n\t\t\t}\n\t\t\tr = fabs(sqr(min(v[i].h,d)) + sqr(d)) / (2 * v[i].h);\n\t\t\tR = min(R, r);\n\t\t}\n\t\tfor(int i = 0; i < line.size(); i++) {\n\t\t\tdouble x0, y0, x1, y1;\n\t\t\tdouble s, t;\n\t\t\tx0 = line[i].first.x; y0 = line[i].first.y;\n\t\t\tx1 = line[i].second.x; y1 = line[i].second.y;\n\n\t\t\ts = ((ex - sx) * (y1 - sy) - (ey - sy) * (x1 - sx)) / ((x0 - sx) * (y1 - sy) - (y0 - sy) * (x1 - sx));\n\t\t\tt = ((ex - sx) * (y0 - sy) - (ey - sy) * (x0 - sx)) / ((x1 - sx) * (y0 - sy) - (y1 - sy) * (x0 - sx));\n\n\t\t\tif(s > -EPS && t > -EPS && s + t > 1 - EPS) {\n\t\t\t\tif(isnan(s) | isnan(s))\n\t\t\t\t\texit(1);\n\t\t\t\tR = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < lect.size(); i++) {\n\t\t\tbool flag0, flag1;\n\t\t\tflag0 = lect[i].first.x < sx && sx < lect[i].second.x && lect[i].first.y < sy && sy < lect[i].second.y;\n\t\t\tflag1 = lect[i].first.x < ex && ex < lect[i].second.x && lect[i].first.y < ey && ey < lect[i].second.y;\n\n\t\t\tif(flag0 | flag1)\n\t\t\t\tR = 0;\n\t\t}\n\t\tprintf(\"%.10f\\n\", R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nvoid print(Point p);\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tprint(p1);\n\t\t\tprint(p2);\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p2;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tif(x>=-1&&x<=1) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Geometry_Library\n#define ___Geometry_Library\n\n// ------ Includes ------ //\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <algorithm>\n\n// ------ Defines ------ //\ntypedef long double GType;\ntypedef std::complex<GType> Point;\ntypedef std::pair<Point, Point> Segment;\n\n// ------ Constants ------ //\nconst GType EPS = 1.0e-10L;\n\n// ------ Functions Level 1 ------ //\nGType dot(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).real();\n}\nGType cross(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).imag();\n}\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint v1 = p2 - p1, v2 = p3 - p1;\n\tif (cross(v1, v2) > EPS) return +1;\n\tif (cross(v1, v2) < -EPS) return -1;\n\tif (dot(v1, v2) < -EPS) return +2;\n\tif (std::norm(v1) < std::norm(v2)) return -2;\n\treturn 0;\n}\n\n// ------ Functions Level 2 ------ //\nbool intersect(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(cross(s1.second - p1, s1.first - p1)) < EPS;\n\treturn (std::abs(s1.first - p1) + std::abs(s1.second - p1) - std::abs(s1.second - s1.first)) < EPS;\n}\nbool intersect(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (!segflag) return cross(s1.second - s1.first, s2.first - s1.first) * cross(s1.second - s1.first, s2.second - s1.first) < EPS;\n\treturn (ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) <= 0 && ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) <= 0);\n}\nPoint projection(const Segment& s1, const Point& p1) {\n\tGType mul = dot(p1 - s1.first, s1.first - s1.second) / norm(s1.first - s1.second);\n\treturn s1.first + (s1.first - s1.second) * mul;\n}\nPoint reflection(const Segment& s1, const Point& p1) {\n\treturn p1 + (projection(s1, p1) - p1) * (GType)(2);\n}\nGType distance(const Point& p1, const Point& p2) {\n\treturn std::abs(p2 - p1);\n}\nGType distance(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(p1 - projection(s1, p1));\n\tconst Point p2 = projection(s1, p1);\n\tif (intersect(s1, p2, true)) return std::abs(p2 - p1);\n\treturn std::min(std::abs(s1.first - p1), std::abs(s1.second - p1));\n}\nGType distance(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (intersect(s1, s2, segflag)) return 0;\n\tif (!segflag) return std::min(distance(s1, s2.first, false), distance(s1, s2.second, false));\n\treturn std::min({ distance(s1, s2.first, true), distance(s1, s2.second, true), distance(s2, s1.first, true), distance(s2, s1.second, true) });\n}\n\n#endif\n\n#include <vector>\n#include <iomanip>\n#include <iostream>\nusing namespace std;\nint n, sx, sy, ex, ey, xa[55], ya[55], xb[55], yb[55], h[55];\nint main() {\n\twhile (cin >> n, n) {\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tfor (int i = 0; i < n; i++) cin >> xa[i] >> ya[i] >> xb[i] >> yb[i] >> h[i];\n\t\tvector<vector<Point> > v(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tv[i] = { Point(xa[i], ya[i]), Point(xa[i], yb[i]), Point(xb[i], yb[i]), Point(xb[i], ya[i]) };\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tif (intersect(Segment(Point(sx, sy), Point(ex, ey)), Segment(v[i][j], v[i][(j + 1) & 3]), true)) flag = false;\n\t\t\t}\n\t\t\tif (xa[i] <= sx && sx <= xb[i] && ya[i] <= sy && sy <= yb[i]) flag = false;\n\t\t\tif (xa[i] <= ex && ex <= xb[i] && ya[i] <= sy && sy <= yb[i]) flag = false;\n\t\t}\n\t\tif (!flag) cout << 0 << endl;\n\t\telse {\n\t\t\tdouble ret = 1.0e+9;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tdouble dist = distance(Segment(Point(sx, sy), Point(ex, ey)), Segment(v[i][j], v[i][(j + 1) & 3]), true);\n\t\t\t\t\tdouble r = 0.5 * (h[i] + dist * dist / h[i]);\n\t\t\t\t\tret = min(ret, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << fixed << setprecision(15) << ret << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {\n return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点cが線分a,b上にあるかないか(2)\nint is_point_on_line(P a, P b, P c) {\n // |a-c| + |c-b| <= |a-b| なら線分上\n return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n if (( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS ) &&\n     ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < -EPS ))\n    return true;\n return is_point_on_line(a1, a2, b1) || is_point_on_line(a1, a2, b2) ||\n        is_point_on_line(b1, b2, a1) || is_point_on_line(b1, b2, a2);\n}\n\nstruct block{\n\tint minx,miny,maxx,maxy,h;\n\tP p(int n){\n\t\tswitch(n){\n\t\tcase 0:\n\t\t\treturn P(minx,miny);\n\t\tcase 1:\n\t\t\treturn P(minx,maxy);\n\t\tcase 2:\n\t\t\treturn P(maxx,maxy);\n\t\tcase 3:\n\t\t\treturn P(maxx,miny);\n\t\t}\n\t}\n};\nint main(){\n\tcout.precision(16);\n\tint n;\n\twhile(cin>>n,n){\n\t\tint sx,sy,ex,ey;\n\t\tcin>>sx>>sy>>ex>>ey;\n\t\tvector<block> blocks(n);\n\t\tREP(i,n){\n\t\t\tcin>>blocks[i].minx>>blocks[i].miny>>blocks[i].maxx>>blocks[i].maxy>>blocks[i].h;\n\t\t}\n\t\tdouble ans=INT_MAX;\n\t\tbool itsc=false;\n\t\tREP(i,n){\n\t\t\tREP(j,4){\n\t\t\t\tif(is_intersected_ls(P(sx,sy),P(ex,ey),blocks[i].p(j),blocks[i].p((j+1)%4))){\n\t\t\t\t\titsc=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(sx+EPS>blocks[i].minx&&sx-EPS<blocks[i].maxx&&sy+EPS>blocks[i].miny&&sy-EPS<blocks[i].maxy){\n\t\t\t\t\titsc=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ex+EPS>blocks[i].minx&&ex-EPS<blocks[i].maxx&&ey+EPS>blocks[i].miny&&ey-EPS<blocks[i].maxy){\n\t\t\t\t\titsc=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(itsc){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(itsc){\n\t\t\tcout<<0<<endl;\n\t\t}else{\n\t\t\tREP(i,n){\n\t\t\t\tdouble r=INT_MAX;\n\t\t\t\tREP(j,4){\n\t\t\t\t\tdouble d=distance_l_p(P(sx,sy),P(ex,ey),blocks[i].p(j));\n\t\t\t\t\tr=min(r,(blocks[i].h*blocks[i].h+d*d)/2/blocks[i].h);\n\t\t\t\t\tdouble ds=distance_ls_p(blocks[i].p(j),blocks[i].p((j+1)%4),P(sx,sy));\n\t\t\t\t\tr=min(r,(blocks[i].h*blocks[i].h+ds*ds)/2/blocks[i].h);\n\t\t\t\t\tdouble de=distance_ls_p(blocks[i].p(j),blocks[i].p((j+1)%4),P(ex,ey));\n\t\t\t\t\tr=min(r,(blocks[i].h*blocks[i].h+de*de)/2/blocks[i].h);\n\t\t\t\t}\n\t\t\t\tif(blocks[i].h>=r){\n\t\t\t\t\tREP(j,4){\n\t\t\t\t\t\tdouble d=distance_l_p(P(sx,sy),P(ex,ey),blocks[i].p(j));\n\t\t\t\t\t\tr=min(r,d);\n\t\t\t\t\t\tdouble ds=distance_ls_p(blocks[i].p(j),blocks[i].p((j+1)%4),P(sx,sy));\n\t\t\t\t\t\tr=min(r,ds);\n\t\t\t\t\t\tdouble de=distance_ls_p(blocks[i].p(j),blocks[i].p((j+1)%4),P(ex,ey));\n\t\t\t\t\t\tr=min(r,de);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans=min(ans,r);\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\n// constants and eps-considered operators\n\nconst double eps = 1e-8; // choose carefully!\nconst double pi = acos(-1.0);\n\ninline bool lt(double a, double b) { return a < b - eps; }\ninline bool gt(double a, double b) { return lt(b, a); }\ninline bool le(double a, double b) { return !lt(b, a); }\ninline bool ge(double a, double b) { return !lt(a, b); }\ninline bool ne(double a, double b) { return lt(a, b) or lt(b, a); }\ninline bool eq(double a, double b) { return !ne(a, b); }\n\n// points and lines\n\ntypedef complex<double> point;\n\ninline double dot(point a, point b)   { return real(conj(a) * b); }\ninline double cross(point a, point b) { return imag(conj(a) * b); }\n\nstruct line {\n    point a, b;\n    line(point a, point b) : a(a), b(b) {}\n};\n\n/*\n *  Here is what ccw(a, b, c) returns:\n *\n *          1\n *  ------------------\n *    2 |a  0  b| -2\n *  ------------------\n *         -1\n *\n *  Note: we can implement intersectPS(p, s) as !ccw(s.a, s.b, p).\n */\nint ccw(point a, point b, point c) {\n    b -= a, c -= a;\n    if (gt(cross(b, c), 0.0)) return +1;\n    if (lt(cross(b, c), 0.0)) return -1;\n    if (lt(dot(b, c), 0.0))   return +2; // c -- a -- b\n    if (lt(norm(b), norm(c))) return -2; // a -- b -- c\n    return 0;\n}\nbool intersectLS(const line& l, const line& s) {\n    return ccw(l.a, l.b, s.a) * ccw(l.a, l.b, s.b) <= 0;\n}\nbool intersectSS(const line& s, const line& t) {\n    return intersectLS(s, t) and intersectLS(t, s);\n}\n\npoint proj(const line& l, point p) {\n    double t = dot(l.b - l.a, p - l.a) / norm(l.b - l.a);\n    return l.a + t * (l.b - l.a);\n}\ndouble distancePS(point p, const line& s) {\n    point h = proj(s, p);\n    return ccw(s.a, s.b, h) ? min(abs(s.a - p), abs(s.b - p)) : abs(h - p);\n}\ndouble distanceSS(line &s, line &t) {\n    return intersectSS(s, t) ? 0.0 :\n        min(min(distancePS(s.a, t), distancePS(s.b, t)),\n            min(distancePS(t.a, s), distancePS(t.b, s)));\n}\n\nint n;\npoint s, e;\nvector<point> a;\nvector<double> h;\n\npoint in() { double x, y; cin >> x >> y; return point(x, y); }\n\nvoid input()\n{\n    a.clear(), h.clear();\n\n    s = in(), e = in();\n    rep(i, n) {\n        double ax, ay, bx, by, tmp;\n        cin >> ax >> ay >> bx >> by >> tmp;\n        a.pb(point(ax, ay));\n        a.pb(point(ax, by));\n        a.pb(point(bx, by));\n        a.pb(point(bx, ay));\n        h.pb(tmp);\n    }\n}\n\nbool check()\n{\n    line l(s, e);\n    rep(i, n) rep(j, 4) {\n        line w(a[4 * i + j], a[4 * i + (j + 1) % 4]);\n        if (intersectSS(l, w)) return false;\n    }\n\n    return true;\n}\n\ndouble f(double h, double d)\n{\n    if (h >= d) return d;\n\n    return (h * h + d * d) / (2 * h);\n}\n\ndouble solve()\n{\n    if (not check()) return 0.0;\n\n    line l(s, e);\n\n    double ans = 1000.0;\n    rep(i, n) rep(j, 4) {\n        line w(a[4 * i + j], a[4 * i + (j + 1) % 4]);\n        // cout << w.a << ' ' << w.b << endl;\n        ans = min(ans, f(h[i], distanceSS(w, l)));\n\n        double mx = real(a[4 * i]);\n        double my = imag(a[4 * i]);\n        double Mx = real(a[4 * i + 2]);\n        double My = imag(a[4 * i + 2]);\n        if (mx <= real(s) and real(s) <= Mx and my <= imag(s) and imag(s) <= My) ans = 0.0;\n        if (mx <= real(e) and real(e) <= Mx and my <= imag(e) and imag(e) <= My) ans = 0.0;\n    }\n    return ans;\n}\n\nint main()\n{\n    while (cin >> n and n) {\n        input();\n        printf(\"%.11f\\n\", solve());\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS 1e-10\n#define EQ(a,b) (abs(a - b) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n//??????\ndouble cross (P a, P b) {return (a.real() * b.imag() - a.imag() * b.real());}\n\n//??????\ndouble dot (P a, P b) {return (a.real() * b.real() + a.imag() * b.imag());}\n\n//??´???\nbool is_orthogonal(P a1, P a2, P b1, P b2) {return EQ( dot(a1 - a2, b1 - b2), 0.0);}\n\n//??????\nbool is_parallel(P a1, P a2, P b1, P b2) {return EQ( cross(a1 - a2, b1 - b2), 0.0);}\n\n//??´??????\nbool is_point_on_vector(P a, P b, P c) {return EQ( cross(a - c, c - b), 0.0);}\n\n//?????????\nbool is_point_on_line (P a, P b, P c) {return (abs(a - c) + abs(c - b) < abs(a - b) + EPS);}\n\n//?§?????????????????????¢????°???°?????\\??????????????§\ndouble angle (P a, P b, P p) {return (acos(dot(a-p,b-p) / (abs(a-p) * abs(b-p))) * 180.0 / M_PI);}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool is_intersected_l(P a1, P a2, P b1, P b2) {return !EQ( cross(a1-a2, b1-b2), 0.0 );}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distance_l_p(P a, P b, P c) {return abs(cross(b-a, c-a)) / abs(b-a);}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2 - a1; P b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(P a, P b, P c) {\n    if ( dot(b-a, c-a) < -EPS ) return fabs(c-a);\n    if ( dot(a-b, c-b) < -EPS ) return fabs(c-b);\n    return fabs(cross(b-a, c-a)) / fabs(b-a);\n}\n\n/***************************************\n *\n * 2??????????????´?????¨??????????????????????????¨?????????\n *\n * a, b ?????´???\n * p    ????????????\n *\n ***************************************/\nP crossNormalVector (P a, P b, P p) {\n    double t = dot(b-a, p-a) / (abs(b-a) * abs(b - a));\n    return a + t * (b - a);\n}\n\ndouble calc (double h, double r) {\n    if (h > r) h = r;\n    return (r * r + h * h) / (2 * h);\n}\n\nint main ()\n{\n    int n;\n    while (cin >> n, n) {\n        double sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        P s(sx, sy), e(ex, ey);\n\n        double res_h = 1000.;\n        while (n--) {\n            // cout << \"Count # \" << n << endl;\n\n            double minx, miny, maxx, maxy;\n            double h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n\n            vector<P> v = { P(minx, miny), P(minx, maxy), P(maxx, maxy), P(maxx, miny)};\n\n            if (minx <= s.real() && s.real() <= maxx && miny <= s.imag() && s.imag() <= maxy) res_h = 0.;\n            if (minx <= e.real() && e.real() <= maxx && miny <= e.imag() && e.imag() <= maxy) res_h = 0.;\n\n            for (int i = 0; i < 4; i++) {\n                int anf = (i + 1) % 4; // , bfr = (i + 4 - 1) % 4;\n                int now = i;\n\n                if (is_intersected_ls(e, s, v[now], v[anf])) res_h = 0.;\n                // if (is_intersected_ls(e, s, v[now], v[bfr])) res_h = 0.;\n\n                // cout << \"DBG > \" << min(v[now].real(), v[anf].real()) << \" \" << max(v[now].real(), v[anf].real()) << endl;\n                // cout << \"      \" << min(v[now].imag(), v[anf].imag()) << \" \" << max(v[now].imag(), v[anf].imag()) << endl;\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[anf], s)));\n                // res_h = min(res_h, calc(h, distance_ls_p(v[now], v[bfr], s)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[anf], e)));\n                // res_h = min(res_h, calc(h, distance_ls_p(v[now], v[bfr], e)));\n                // res_h = min(res_h, calc(h, min(abs(minx - s.real()), abs(maxx - s.real()))));\n                // res_h = min(res_h, calc(h, min(abs(miny - s.imag()), abs(maxy - s.imag()))));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[now])));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[anf])));\n                // res_h = min(res_h, calc(h, distance_ls_p(s, e, v[bfr])));\n            }\n        }\n\n        printf(\"%.4f\\n\", res_h);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define REPD(i,n) for(int i=(int)(n); i-->0;)\n#define REPI(i,a,b) for(int i=(int)(a); i<=(int)(b); i++)\n#define ALL(a) (a).begin(),(a).end()\n#define mp make_pair\n#define fst first\n#define snd second\n\n#define INFTY 1000000000\n#define EPS 1e-9\n#define PI 3.141592653589793\n\n#define INF (INFTY/3)\n\n#define rev(s) (string((s).rbegin(), (s).rend()))\n\ntypedef long long Int;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<double,double> pdd;\n\nvoid debug(vi v){ REP(i,v.size()) cout<<v[i]<<\" \"; cout<<endl; }\n\nint nextInt(){ int t; cin>>t; return t; }\n\n#define ZEROP(x) (fabs(x) < EPS)\n#define EQ(x, y) ZEROP((x) - (y))\n#define LT(x, y) ((x) - (y) <= -EPS) // x < y\n#define LE(x, y) ((x) - (y) < +EPS) // x <= y\n#define SIGN(x) ((x)<-EPS?-1:((x)>EPS?+1:0))\n\ntypedef complex<double> P;\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nnamespace std {\n   bool operator < (const P& a, const P& b) {\n     return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n   }\n}\ndouble cross(const P& a, const P& b) {\n   return imag(conj(a)*b);\n} \ndouble dot(const P& a, const P& b) {\n   return real(conj(a)*b); \n}  \nstruct L : public vector<P> {\n  L() {}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  } \n};  \ntypedef vector<P> G;  \nstruct C {\n   P p; double r;\n   C(const P &p, double r) : p(p), r(r) { }\n}; \n\n\n#define MAXN 50\nint N;\nL sl; // start line\nint minx[MAXN];\nint miny[MAXN];\nint maxx[MAXN];\nint maxy[MAXN];\nint h[MAXN];\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (LT( 0, cross(b, c)) )   return +1;       // counter clockwise\n  if (LT( cross(b, c), 0) )   return -1;       // clockwise\n  if (LT( dot(b, c), 0) )     return +2;       // c--a--b on line\n  if (LT( norm(b), norm(c)) ) return -2;       // a--b--c on line\n  return 0;\n}\n\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n// USE IN THIS PROBLEM\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nbool covered(int sx,int sy,int ex,int ey,int ax,int ay,int bx,int by) {\n  return ax < sx && ay < sy && ex < bx && ey < by;\n}\n\n\ndouble solve() {\n  double r = INT_MAX;\n  REP(i,N) {\n    L l[]={L(P(minx[i],miny[i]),P(maxx[i],miny[i])),\n\t   L(P(maxx[i],miny[i]),P(maxx[i],maxy[i])),\n\t   L(P(maxx[i],maxy[i]),P(minx[i],maxy[i])),\n\t   L(P(minx[i],maxy[i]),P(minx[i],miny[i]))};\n    double mind = INT_MAX;\n    int mini; //min index\n    if(covered(real(sl[0]),imag(sl[0]),real(sl[1]),imag(sl[1]),\n\t       minx[i],miny[i],maxx[i],maxy[i])) return 0.0;\n    REP(j,4) {\n      double dd = distanceSS(l[j],sl);\n      if(LT(dd,mind)) {\n\tmind = dd;\n\tmini = j;\n      }\n    }\n    double r2;\n    //printf(\"mind=%lf\\n\",mind);\n    if(LE(mind,h[i])) { // mind <= h[i]\n      r2=mind;\n    } else {\n      r2=(h[i]*h[i] + mind*mind) / (2*h[i]);\n    }\n    r=min(r,r2);\n    //printf(\"r=%lf\\n\",r);\n  }\n  return r;\n}\n\t\nmain() {\n  while(cin>>N,N) {\n    int sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    sl = L(P(sx,sy),P(ex,ey));\n    REP(i,N)\n      cin>>minx[i]>>miny[i]>>maxx[i]>>maxy[i]>>h[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace Geometry{\n    using namespace std;\n    using ld=long double;\n    using Point=complex<ld>;\n\n    struct Line{\n        Point a,b;\n    };\n\n    struct Circle{\n        Point p;\n        ld r;\n    };\n    const ld EPS=1e-6;\n    inline bool EQ(Point a,Point b){return abs(a-b)<EPS;}\n    ld dot(Point a,Point b){return real(a)*real(b)+imag(a)*imag(b);}\n    ld cross(Point a,Point b){return real(a)*imag(b)-imag(a)*real(b);}\n\n    const int CCW=1;\n    const int CW=-1;\n    const int BAC=2;\n    const int ACB=-2;\n    const int ABC=0;\n    int ccw(Point a,Point b,Point c){\n        b-=a,c-=a;\n        if(cross(b,c)>EPS) return CCW; // counter clockwise\n        if(cross(b,c)<-EPS) return CW; //clockwise\n        if(dot(b,c)<-EPS) return BAC; //b-a-c\n        if(abs(b)<abs(c)) return ACB; //a-c-b\n        return ABC; //a-b-c (abs(b)>abs(c))\n    }\n\n    bool isis_ss(Line x,Line y){\n        return ccw(x.a,x.b,y.a)*ccw(x.a,x.b,y.b)<=0 && ccw(y.a,y.b,x.a)*ccw(y.a,y.b,x.b)<=0;\n    }\n\n    ld dist_lp(Line l,Point p){\n        Point x=l.b-l.a;\n        Point y=p-l.a;\n        return abs(cross(x,y))/abs(x);\n    }\n\n    ld dist_sp(Line l,Point p){\n        if(dot(p-l.a,l.b-l.a)<EPS) return abs(p-l.a);\n        if(dot(p-l.b,l.a-l.b)<EPS) return abs(p-l.b);\n        return dist_lp(l,p);\n    }\n\n    ld dist_ss(Line x,Line y){\n        if(isis_ss(x,y)) return 0;\n        ld a=min(dist_sp(x,y.a),dist_sp(x,y.b));\n        ld b=min(dist_sp(y,x.a),dist_sp(y,x.b));\n        return min(a,b);\n    }\n}\nusing namespace Geometry;\n\nconst ld INF=1000;\n\nld solve(int n){\n    Point s,e;\n    ld sx,sy,ex,ey;\n    cin>>sx>>sy>>ex>>ey;\n    s={sx,sy},e={ex,ey};\n    Line cource={s,e};\n    ld xmin=min(sx,ex);\n    ld xmax=max(sx,ex);\n    ld ymin=min(sy,ey);\n    ld ymax=max(sy,ey);\n    ld res=INF;\n    for(int i=0;i<n;i++){\n        ld x[2];\n        ld y[2];\n        ld h;\n        cin>>x[0]>>y[0]>>x[1]>>y[1]>>h;\n        if(x[0]<=xmin && xmax<=x[1] && y[0]<=ymin && ymax<=y[1]){\n            res=0;\n        }\n        for(int ix=0;ix<2;ix++){\n            for(int iy=0;iy<2;iy++){\n                Point p={x[ix],y[iy]};\n                Point p0={x[(ix+1)&1],y[iy]};\n                Point p1={x[ix],y[(iy+1)&1]};\n                Line l[2]={Line{p,p0},Line{p,p1}};\n                for(int k=0;k<2;k++){\n                    ld d=dist_ss(cource,l[k]);\n                    ld r=(h*h+d*d)/(2*h);\n                    if(r<h){                        \n                        r=d;\n                    }              \n                    res=min(res,r);\n                }\n                \n            }\n        }\n    }\n    return res;\n}\nint main(){\n    int n;\n    cout<<setprecision(10)<<fixed;\n    while(cin>>n,n){\n        cout<<solve(n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                     #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                  \n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                             double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                     \ndouble distance_ls_p(Point a, Point b, Point c) {\n  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n  return abs(cross(b-a, c-a)) / (b-a).absv();\n}\nbool is_intersected_ls(Segment a,Segment b) {\n  return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n}\n\ndouble segment_dis(Segment a,Segment b){\n\tif(is_intersected_ls(a,b))return 0;\n\tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n\tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n\tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n\treturn r;\n}\n\n\n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\n\n\nSegment p[210],path;\nPoint pp[210];\nint n;\ndouble h[210];\nbool ch(double r){\n\t\n\tfor(int i=0;i<4*n;i++){\n\t\tdouble t=segment_dis(p[i],path);\n\t\tif(t>=r) continue;\n\t\tif(r-sqrt(r*r-t*t)<h[i/4])return false;\n\t}\n\treturn true;\n\t\n}\n\n\nsigned main(){\n\n\t\n\twhile(1){\n\t\t\n\t\tcin>>n;\n\t\tif(n==0) return 0;\n\n\t\t\n\t\t\n\t\tcin>>path.p1.x>>path.p1.y>>path.p2.x>>path.p2.y;\n\t\tbool b=false;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble ax,ay,bx,by;\n\t\t\tcin>>ax>>ay>>bx>>by;\n\t\t\tif(ax <= path.p1.x &&path.p1.x<=bx &&ay <= path.p1.y &&path.p1.y<=by){\n\t\t\t\tif(ax <= path.p2.x &&path.p2.x<=bx &&ay <= path.p2.y &&path.p2.y<=by){\n\t\t\t\t\tb=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpp[i*4].x=ax;\n\t\t\tpp[i*4].y=ay;\n\t\t\tpp[1+i*4].x=ax;\n\t\t\tpp[1+i*4].y=by;\n\t\t\tpp[2+i*4].x=bx;\n\t\t\tpp[2+i*4].y=by;\n\t\t\tpp[3+i*4].x=bx;\n\t\t\tpp[3+i*4].y=ay;\n\t\t\t\n\t\t\tp[i*4].p1=pp[i*4];\n\t\t\tp[i*4].p2=pp[1+i*4];\n\t\t\tp[1+i*4].p1=pp[1+i*4];\n\t\t\tp[1+i*4].p2=pp[2+i*4];\n\t\t\tp[2+i*4].p1=pp[2+i*4];\n\t\t\tp[2+i*4].p2=pp[3+i*4];\n\t\t\tp[3+i*4].p1=pp[3+i*4];\n\t\t\tp[3+i*4].p2=pp[i*4];\ncin>>h[i];\n\t\t}\n\t\tif(b==1){\n\t\t\tcout<<0<<endl;\n\t\t\t\n\t\t}\n\t\telse{\n\t\tdouble ue=1000.0,sita=0.0,me;\n\t\tfor(int i=0;i<1000;i++){\n\t\t\tme=(ue+sita)/2.0;\n\t\t\tif(ch(me))sita=me;\n\t\t\telse ue=me;\n\t\t}\n\t\tprintf(\"%.10lf\\n\",me);\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Geometry_Library\n#define ___Geometry_Library\n\n// ------ Includes ------ //\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <algorithm>\n\n// ------ Defines ------ //\ntypedef long double GType;\ntypedef std::complex<GType> Point;\ntypedef std::pair<Point, Point> Segment;\n\n// ------ Constants ------ //\nconst GType EPS = 1.0e-10L;\n\n// ------ Functions Level 1 ------ //\nGType dot(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).real();\n}\nGType cross(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).imag();\n}\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint v1 = p2 - p1, v2 = p3 - p1;\n\tif (cross(v1, v2) > EPS) return +1;\n\tif (cross(v1, v2) < -EPS) return -1;\n\tif (dot(v1, v2) < -EPS) return +2;\n\tif (std::norm(v1) < std::norm(v2)) return -2;\n\treturn 0;\n}\n\n// ------ Functions Level 2 ------ //\nbool intersect(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(cross(s1.second - p1, s1.first - p1)) < EPS;\n\treturn (std::abs(s1.first - p1) + std::abs(s1.second - p1) - std::abs(s1.second - s1.first)) < EPS;\n}\nbool intersect(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (!segflag) return cross(s1.second - s1.first, s2.first - s1.first) * cross(s1.second - s1.first, s2.second - s1.first) < EPS;\n\treturn (ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) <= 0 && ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) <= 0);\n}\nPoint projection(const Segment& s1, const Point& p1) {\n\tGType mul = dot(p1 - s1.first, s1.first - s1.second) / norm(s1.first - s1.second);\n\treturn s1.first + (s1.first - s1.second) * mul;\n}\nPoint reflection(const Segment& s1, const Point& p1) {\n\treturn p1 + (projection(s1, p1) - p1) * (GType)(2);\n}\nGType distance(const Point& p1, const Point& p2) {\n\treturn std::abs(p2 - p1);\n}\nGType distance(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(p1 - projection(s1, p1));\n\tconst Point p2 = projection(s1, p1);\n\tif (intersect(s1, p2, true)) return std::abs(p2 - p1);\n\treturn std::min(std::abs(s1.first - p1), std::abs(s1.second - p1));\n}\nGType distance(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (intersect(s1, s2, segflag)) return 0;\n\tif (!segflag) return std::min(distance(s1, s2.first, false), distance(s1, s2.second, false));\n\treturn std::min({ distance(s1, s2.first, true), distance(s1, s2.second, true), distance(s2, s1.first, true), distance(s2, s1.second, true) });\n}\n\n#endif\n\n#include <vector>\n#include <iomanip>\n#include <iostream>\nusing namespace std;\nint n, sx, sy, ex, ey, xa[55], ya[55], xb[55], yb[55], h[55];\nint main() {\n\twhile (cin >> n, n) {\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tfor (int i = 0; i < n; i++) cin >> xa[i] >> ya[i] >> xb[i] >> yb[i] >> h[i];\n\t\tvector<vector<Point> > v(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tv[i] = { Point(xa[i], ya[i]), Point(xa[i], yb[i]), Point(xb[i], yb[i]), Point(xb[i], ya[i]) };\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tif (intersect(Segment(Point(sx, sy), Point(ex, ey)), Segment(v[i][j], v[i][(j + 1) & 3]), true)) flag = false;\n\t\t\t}\n\t\t\tif (xa[i] <= sx && sx <= xb[i] && ya[i] <= sy && sy <= yb[i]) flag = false;\n\t\t\tif (xa[i] <= ex && ex <= xb[i] && ya[i] <= sy && sy <= yb[i]) flag = false;\n\t\t}\n\t\tif (!flag) cout << 0 << endl;\n\t\telse {\n\t\t\tdouble ret = 1.0e+9;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tdouble dist = distance(Segment(Point(sx, sy), Point(ex, ey)), Segment(v[i][j], v[i][(j + 1) & 3]), true);\n\t\t\t\t\tdouble r = 0.5 * (h[i] + dist * dist / h[i]);\n\t\t\t\t\tif (h[i] >= dist) r = dist;\n\t\t\t\t\tret = min(ret, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << fixed << setprecision(15) << ret << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define INF 1e14\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\ndouble dot(Point a, Point b) {\n    return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(Point a, Point b) {\n    return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(Point a, Point b, Point c) {\n    b -= a;  c -= a;\n    if (cross(b,c) >  EPS) return +1;  // counter clockwise\n    if (cross(b,c) < -EPS) return -1;  // clockwise\n    if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n    return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isecSP(Point a1, Point a2, Point b) {\n    return !ccw(a1, a2, b);\n}\n\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n    return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n           ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\nPoint proj(Point a1, Point a2, Point p) {\n    return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\ndouble distSP(Point a1, Point a2, Point p) {\n    Point r = proj(a1, a2, p);\n    if (isecSP(a1, a2, r)) return abs(r-p);\n    return min(abs(a1-p), abs(a2-p));\n}\n\ndouble distSS(Point a1, Point a2, Point b1, Point b2) {\n    if (isecSS(a1, a2, b1, b2)) return 0;\n    return min({\n        distSP(a1, a2, b1),\n        distSP(a1, a2, b2),\n        distSP(b1, b2, a1),\n        distSP(b1, b2, a2)});\n}\n\nbool inPolygon(Point p,VP& ps){\n    int n = ps.size();\n    double sumAngle=0;\n    rep(i,n){\n        double t = arg(ps[(i+1)%n]-p)-arg(ps[i]-p);\n        while(t > +PI) t-=2*PI;\n        while(t < -PI) t+=2*PI;\n        sumAngle += t;\n    }\n    return (abs(sumAngle) > 0.1);\n}\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        double sx,sy,ex,ey;\n        cin>>sx>>sy>>ex>>ey;\n        Point s(sx,sy);\n        Point e(ex,ey);\n        vector<double> d(n,INF), h(n);\n        bool ng = false;\n        rep(i,n){\n            double x[2],y[2];\n            cin>>x[0]>>y[0]>>x[1]>>y[1]>>h[i];\n            VP p;\n            rep(yy,2)rep(xx,2){\n                p.push_back(Point(x[xx],y[yy]));\n            }\n            swap(p[2],p[3]);\n            if(inPolygon(s,p) || inPolygon(e,p)){\n                ng = true;\n            }\n            rep(j,4){\n                assert(ccw(p[(j+3)%4],p[j],p[(j+1)%4]) == 1);\n                d[i] = min(d[i],distSS(s,e,p[j],p[(j+1)%4]));\n            }\n        }\n        if(ng){\n            cout<<\"0.0000\"<<endl;\n            continue;\n        }\n\n        double l = 0, r = 1000;\n        rep(_,100){\n            double R = (l+r)/2;\n            bool ok = true;\n            rep(i,n){\n                if(sqrt(pow(max(R-h[i],0.0),2) + pow(d[i],2)) < R){\n                    ok = false;\n                }\n            }\n            if(ok) l = R;\n            else   r = R;\n        }\n        printf(\"%.4f\\n\",l);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//二次元幾何ライブラリ\n#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define ML make_pair \ntypedef long double D;\ntypedef bool B;\ntypedef complex<D> P;   //点\ntypedef complex<D> V;   //ベクトル\ntypedef pair<P,P>  L;   //直線\ntypedef pair<P,D>  C;   //円\ntypedef vector<P>  Pol; //多角形\n\n//変数名定義\nconst D INF = 1e100;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ntemplate<class T> bool operator==(T a, T b){return abs(a - b )< EPS;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n\n\n\n// ベクトルaの絶対値を求める\n// D Length = abs(a);\n\n// 2点a,b間の距離を求める\n// D Distance = abs(a-b); \n\n// 内積 (Inner Product) : a・b = |a||b|cosθ\nD IP(V a, V b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (Exterior Product) : |a×b| = |a||b|sinθ \nD EP(V a, V b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n// 点の進行方向について\nint ccw(P a, P b, P c) {              //点aと点bが与えられた問いに\n  b -= a; c -= a;\n  if (EP(b, c) > 0)   return +1;      // counter clockwise\n  if (EP(b, c) < 0)   return -1;      // clockwise\n  if (IP(b, c) < 0)     return +2;    // c--a--b on line\n  if (norm(b) < norm(c)) return -2;   // a--b--c on line\n  return 0;                           // a--c--b on line  aとbの線分判定はこれ\n}\n\n\n// 2直線の垂直判定 : a⊥b <=> IP(a, b) = 0\nB IsVecular(L l1, L l2) {\n\treturn IP(l1.first-l1.second, l2.first-l2.second)==0.0;\n}\n\n// 2直線の平行判定 : a//b <=> EP(a, b) = 0\nB IsParallel(L l1, L l2) {\n\treturn EP(l1.first-l1.second, l2.first-l2.second)== 0.0;\n}\n\n// 2線分の交差判定 \nB IIS(L l1, L l2) {\n  return ( EP(l1.second-l1.first, l2.first-l1.first) * EP(l1.second-l1.first, l2.second-l1.first) < EPS ) &&\n         ( EP(l2.second-l2.first, l1.first-l2.first) * EP(l2.second-l2.first, l1.second-l2.first) < EPS );\n}\n\n// 符号付き点と直線の距離 (Distance of Point and Line)  //lの構造 x座標 first<second y座標 first<second 左上 正 右下 負 一致 0\nD  DPL(P p,L l){\n\tV v1=(l.second-l.first);\n\tV v2=(p-l.first);\n\treturn EP(v1,v2)/abs(v1);\n}\n\n// 点と線分の距離 (Distance of Point and Segment)  //lの構造 x座標 first<second y座標 first < second \nD  DPS(P p,L l){\n\tV v1,v2,v3;\n\tv1=l.second-l.first;\n\tv2=p-l.first;\n\tv3=p-l.second;\n\tif(IP (v1,v2) <0)\n\t\treturn abs(p-l.first);\n\telse if(IP(-v1,v3)<0)\n\t\treturn abs(p-l.second);\n\telse\n\t\treturn abs(DPL(p,l));\n}\n\n// 線分と線分の距離 (Distance of Segment and Segment)  //lの構造 x座標 first<second y座標 first < second \nD DSS(L l1,L l2){\n\tif(IIS(l1,l2))\n\t\treturn 0;\n\telse{\n\t\tD tem,tem1,tem2;\n\t\ttem1=min(DPS(l1.first,l2),DPS(l1.second,l2));\n\t\ttem2=min(DPS(l2.first,l1),DPS(l2.second,l1));\n\t\treturn\tmin(tem1,tem2);\n\t}\n}\n\n// 三角形の領域判定 Teritory of Triangle 1が内部 0が境界と外部\nB TT(P p1,P p2,P p3,P p){\n\tL l1,l2,l3;\n\tl1=make_pair(p2,p3);\n\tl2=make_pair(p3,p1);\n\tl3=make_pair(p1,p2);\n\n\tif(sig(DPL(p1,l1))!=sig(DPL(p,l1)))\n\t\treturn false;\n\telse if(sig(DPL(p2,l2))!=sig(DPL(p,l2)))\n\t\treturn false;\n\telse if(sig(DPL(p3,l3))!=sig(DPL(p,l3)))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n//変数名 = 型 代入したいもの\n//example : v1 = V(5.0,-3.0) p1=P(0.0,4.0)\nint main(void){\n\twhile(true){\n\tint N;\n\t\tcin >>N; \n\tif(!N)\n\t\tbreak;\n\tD Block[50][2][2];\n\tD h[50];\n\tP root1,root2;\n\tL root;\n\tD r;\n\tD rmin=INF;\n\t\tcin >> root1.real() >> root1.imag() >> root2.real() >> root2.imag();\n\trep(i,N)\n\t\tcin >>Block[i][0][0] >>Block[i][0][1] >> Block[i][1][0] >> Block[i][1][1] >>h[i] ;\n\troot=ML(root1,root2);\n\trep(i,N){\n\t\t\tD tem,tem1,tem2;\n\t\t\tP p1,p2,p3,p4;\n\t\t\tp1=P(Block[i][0][0],Block[i][0][1]);\n\t\t\tp2=P(Block[i][1][0],Block[i][0][1]);\n\t\t\tp3=P(Block[i][1][0],Block[i][1][1]);\n\t\t\tp4=P(Block[i][0][0],Block[i][1][1]);\n\t\t\tL la,lb,lc,ld;\n\t\t\tla=ML(p1,p2);\n\t\t\tlb=ML(p2,p3);\n\t\t\tlc=ML(p3,p4);\n\t\t\tld=ML(p4,p1);\n\t\t\tif(p1.real()<root1.real()&&root1.real()<p3.real()&&p1.imag()<root1.imag()&&root1.imag()<p3.imag())\n\t\t\t\ttem=0;\n\t\t\telse {\n\t\t\t\ttem1=min(DSS(root,la),DSS(root,lb));\n\t\t\t\ttem2=min(DSS(root,lc),DSS(root,ld));\n\t\t\t\ttem=min(tem1,tem2);\n\t\t\t}\n\t\t\tif(tem<=h[i])\n\t\t\t\tr=tem;\n\t\t\telse\n\t\t\t\tr=(h[i]+tem*tem/h[i])/2.0;\n\t\t\tif(rmin > r)\n\t\t\t\trmin=r;\n\t}\n    cout << fixed << rmin << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nbool lessP(const P &l, const P &r) {\n    if (sgn(l.real(), r.real())) return l.real() < r.real();\n    if (sgn(l.imag(), r.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\nR rad2deg(R x) {\n    return x/PI*180;\n}\n\n//?§???????[0, 2*PI)???\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n//?§???????[-PI, PI)???\nR radNorN(R x) {\n    x = radNorP(x);\n    if (x >= PI) x -= 2*PI;\n    return x;\n}\n\n/**\n * radian??§???x???[l, r]?????\\??£????????????????????\\??????\n * 0:OFF\n * 1:IN\n * 2:ON\n */\nbool inR(R l, R r, R x) {\n    l = radNorP(l);\n    r = radNorP(r);\n    x = radNorP(x);\n    if (!sgn(l, x) || !sgn(r, x)) return 2;\n    if (!sgn(l, r)) return 0;\n    if (sgn(l, r) == 1) {\n        if (sgn(l, x) == 1 && sgn(x, r) == 1) return 1;\n    } else {\n        if (sgn(x, r) == 1 || sgn(l, x) == 1) return 1;\n    }\n    return 0;\n}\n\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\ntypedef vector<P> Pol;\n\nstruct C {\n    P p;\n    R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\n\nP cu(Pol p, int i) { \n    int s = p.size();\n    return p[(i%s+s)%s];\n};\n\n//0:P is out 1:P is on line 2:P is in\nint contains(const Pol &pol, P p) {\n    int in = -1;\n    for (int i = 0; i < (int)pol.size(); i++) {\n        P a=cu(pol,i)-p, b=cu(pol,i+1)-p;\n        if (ccw(a, b, P(0, 0)) == 0) return 1;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)) {\n            if (cross(a, b) < 0) in *= -1;\n        }\n    }\n    return in+1;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.x)/abs(vec(l)));\n}\n\n\n//????????¨??????????°??????¢\nR distSP(const L &s, const P &p) {\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return abs(s.x-p);\n    if (ccw(s.y, s.y+s2, p) == -1) return abs(s.y-p);\n    return min(min(abs(s.x-p), abs(s.y-p)), distLP(s, p));\n}\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s.x,s.y,t.x), b = ccw(s.x,s.y,t.y);\n    int c = ccw(t.x,t.y,s.x), d = ccw(t.x,t.y,s.y);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\n\nconst int MN = 55;\nint n;\nL l;\nPol po[MN];\nR he[MN];\n\nbool solve(R md) {\n    vector<C> c;\n    vector<Pol> p;\n    for (int i = 0; i < n; i++) {\n        R di = 0;\n        if (md < he[i]) {\n            di = md;\n        } else {\n            di = ssqrt(md*md - (md-he[i])*(md-he[i]));\n        }\n        for (int j = 0; j < 4; j++) {\n            c.push_back(C(po[i][j], di));\n        }\n        R x1 = po[i][0].real();\n        R y1 = po[i][0].imag();\n        R x2 = po[i][2].real();\n        R y2 = po[i][2].imag();\n        p.push_back(\n            {P(x1-di, y1),\n             P(x2+di, y1),\n             P(x2+di, y2),\n             P(x1-di, y2)});\n        p.push_back(\n            {P(x1, y1-di),\n             P(x2, y1-di),\n             P(x2, y2+di),\n             P(x1, y2+di)});\n    }\n    for (C x: c) {\n        if (distSP(l, x.p) < x.r) return false;\n    }\n    for (Pol x: p) {\n        if (contains(x, l.x)) return false;\n        if (contains(x, l.y)) return false;\n        for (int i = 0; i < 4; i++) {\n            if (insSS(l, L(cu(x, i), cu(x, i+1)))) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    while (true) {\n        cin >> n;\n        if (!n) break;\n        for (int i = 0; i < MN; i++) {\n            po[i].clear();\n        }\n        R sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        l = L( P(sx, sy), P(ex, ey) );\n        for (int i = 0; i < n; i++) {\n            R x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2 >> he[i];\n            po[i].push_back(P(x1, y1));\n            po[i].push_back(P(x2, y1));\n            po[i].push_back(P(x2, y2));\n            po[i].push_back(P(x1, y2));\n        }\n        R l = 0, r = 1000;\n        for (int i = 0; i < 200; i++) {\n            R md = (l+r)/2;\n            if (solve(md)) {\n                l = md;\n            } else {\n                r = md;\n            }\n        }\n        printf(\"%.20Lf\\n\", l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-8;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// ベクトル演算\ndouble dot(P a, P b) {return (a.real()*b.real()+a.imag()*b.imag());}\t// 内積\ndouble cross(P a, P b) {return (a.real()*b.imag()-a.imag()*b.real());}\t// 外積\nbool orth(P a1, P a2, P b1, P b2) {return deq(dot(a1-a2,b1-b2),0.0);}\t// 直交\nbool para(P a1, P a2, P b1, P b2) {return deq(cross(a1-a2,b1-b2),0.0);}\t// 平行\nbool pol(P a, P b, P c) {return deq(cross(b-a,c-a),0.0);}\t// 点cが直線ab上にあるかどうか\nbool pols(P a, P b, P c) {return (abs(a-c)+abs(c-b)<abs(a-b)+eps);}\t// 点cが線分ab上にあるかどうか\nbool intls(P a1, P a2, P b1, P b2) {\t// 線分a1a2と線分b1b2の交差判定\n\treturn (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<eps)\n\t\t   && (cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<eps);}\nP pintl(P a1, P a2, P b1, P b2) {\t// 直線a1a2と直線b1b2の交点 (要交差判定)\n\tP a = a2-a1, b = b2-b1;\n\treturn a1+a*cross(b,b1-a1)/cross(b,a);}\nP pintls(P a1, P a2, P b1, P b2) {\t// 線分a1a2と線分b1b2の交点 (〃)\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b,a1-b1)), d2 = abs(cross(b,a2-b1)), t = d1/(d1+d2);\n\treturn a1+(a2-a1)*t;}\ndouble disl(P a, P b, P c) {return abs(cross(b-a,c-a))/abs(b-a);}\t// 点cと直線abとの距離\ndouble disls(P a, P b, P c) {\t// 点cと線分abとの距離\n\tif (dot(b-a,c-a)<eps) return abs(c-a);\n\tif (dot(a-b,c-b)<eps) return abs(c-b);\n\treturn abs(cross(b-a,c-a))/abs(b-a);}\ndouble dislss(P a1, P a2, P b1, P b2) {\t// 線分a1a2と線分b1b2の距離\n\tif (intls(a1,a2,b1,b2)) return 0;\n\tdouble a = min(disls(a1,a2,b1),disls(a1,a2,b2)), b = min(disls(b1,b2,a1),disls(b1,b2,a2));\n\treturn min(a,b);}\n\nint n, xl[50], yl[50], xr[50], yr[50], h[50];\ndouble d[50];\nP s, g;\n\nbool ok(double r) {\n\trep(i,n) {\n\t\tif (r<=h[i] && d[i]<r) return false;\n\t\telse if (h[i]<r) {\n\t\t\tdouble t = sqrt(d[i]*d[i] + (r-h[i])*(r-h[i]));\n\t\t\tif (t<r) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\tdouble sx, sy, gx, gy;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\ts = P(sx,sy), g = P(gx,gy);\n\t\trep(i,n) {\n\t\t\tcin >> xl[i] >> yl[i] >> xr[i] >> yr[i] >> h[i];\n\t\t\tP p1 = P(xl[i],yl[i]), p2 = P(xr[i],yl[i]), p3 = P(xr[i],yr[i]), p4 = P(xl[i],yr[i]);\n\t\t\tdouble a = min(dislss(p1,p2,s,g), dislss(p2,p3,s,g)), b = min(dislss(p3,p4,s,g), dislss(p4,p1,s,g));\n\t\t\td[i] = min(a,b);\n\t\t\tif (intls(p1,p3,s,g) || intls(p2,p4,s,g)) d[i] = 0;\n\t\t}\n\t\tdouble l = 0, r = 1001;\n\t\trep(i,100) {\n\t\t\tdouble m = (l+r)/2;\n\t\t\tif (ok(m)) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tprintf(\"%.14lf\\n\",l);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <complex>\nusing namespace std;\n#ifdef DEBUGRUN\n#define log(a) (cerr<<#a\"=\"<<a<<endl)\n#else\n#define log(a) ((void)0)\n#endif\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\ntypedef long long Int;\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\ndouble sq(double a) { return a*a; }\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\nint ccw(const P& a, P b, P c) {\n    b -= a, c -= a;\n    if(cross(b, c)>0) return 1;\n    if(cross(b, c)<0) return -1;\n    if(dot(b, c)<0) return 2;\n    if(norm(b)<norm(c)) return -2;\n    return 0;\n}\nbool crossing(const P& l0, const P& l1, const P& m0, const P& m1) {\n    return ccw(m0, m1, l0)*ccw(m0, m1, l1)<=0\n        && ccw(l0, l1, m0)*ccw(l0, l1, m1)<=0;\n}\nP projection(const P& l0, const P& l1, const P& p) {\n    double t = dot(p-l0, l0-l1) / norm(l0-l1);\n    return l0 + t*(l0-l1);\n}\ndouble distanceSP(const P& s0, const P& s1, const P& p) {\n    const P r(projection(s0, s1, p));\n    if(ccw(s0, s1, r)==0) return abs(r-p);\n    return min(abs(s0-p), abs(s1-p));\n}\n\nint n, sx, sy, ex, ey;\nint xa[100], ya[100], xb[100], yb[100], h[100];\nP sp, ep, ps[100][4];\n\nbool check() {\n    rep(i, n) {\n        rep(j, 4) {\n            if(crossing(sp, ep, ps[i][j], ps[i][(j+1)%4])) return false;\n        }\n        if(xa[i]<=sx && sx<=xb[i] && ya[i]<=sy && sy<=yb[i]) return false;\n        if(xa[i]<=ex && ex<=xb[i] && ya[i]<=ey && ey<=yb[i]) return false;\n    }\n    return true;\n}\n\nbool can(double r) {\n    rep(i, n) {\n        const double lim = h[i]>=r ? r : sqrt(sq(r)-sq(r-h[i]));\n        rep(j, 4) if(distanceSP(sp, ep, ps[i][j])<lim) return false;\n        if(crossing(sp, ep, ps[i][0]+P(-lim, 0), ps[i][1]+P(-lim, 0))) return false;\n        if(crossing(sp, ep, ps[i][1]+P(0, lim), ps[i][2]+P(0, lim))) return false;\n        if(crossing(sp, ep, ps[i][2]+P(lim, 0), ps[i][3]+P(lim, 0))) return false;\n        if(crossing(sp, ep, ps[i][3]+P(0, -lim), ps[i][0]+P(0, -lim))) return false;\n    }\n    return true;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d\", &n);\n        if(n==0) return 0;\n        scanf(\"%d%d%d%d\", &sx, &sy, &ex, &ey);\n        rep(i, n) scanf(\"%d%d%d%d%d\", xa+i, ya+i, xb+i, yb+i, h+i);\n        sp = P(sx, sy);\n        ep = P(ex, ey);\n        rep(i, n) {\n            ps[i][0] = P(xa[i], ya[i]);\n            ps[i][1] = P(xa[i], yb[i]);\n            ps[i][2] = P(xb[i], yb[i]);\n            ps[i][3] = P(xb[i], ya[i]);\n        }\n        double ans = 0;\n        if(check()) {\n            log(true);\n            double l=0, r=2000;\n            rep(_, 100) {\n                const double mid=(l+r)/2;\n                if(can(mid)) l=mid;\n                else r=mid;\n            }\n            ans = l;\n        }\n        printf(\"%.6f\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cassert>\n\nusing namespace std;\n\ndouble eps=1e-9;\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntemplate<class T> int sgn(T r){\n\treturn eq(r,0.0)?0:(r>0?1:-1);\n}\n\nvoid print(Point p);\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n\tCircle(Point c,double r):center(c),r(r){}\n\tCircle(){}\n};\n\nstruct Line{\n\tdouble a,b,c;//ax+by=c\n\tLine(){}\n\tLine(double a,double b,double c):a(a),b(b),c(c){}\n\tLine(Point p1,Point p2){//not verified\n\t\tif(eq(abs(p1-p2),0.0)){\n\t\t\tprint(p1);\n\t\t\tprint(p2);\n\t\t\tfprintf(stderr,\"called Line for same points\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tdouble x1=p1.real(),y1=p1.imag();\n\t\tdouble x2=p2.real(),y2=p2.imag();\n\t\ta=y2-y1;\n\t\tb=-(x2-x1);\n\t\tc=x1*y2-x2*y1;\n\t}\n};\n\nvoid print(Point p){\n\tif(isnan(p.real())||isnan(p.imag())){\n\t\tprintf(\"NaN Point\\n\");\n\t\treturn;\n\t}\n\tprintf(\"(%f,%f)\\n\",p.real(),p.imag());\n}\n\ndouble pointsDistance(Point p1,Point p2){/*abs(p1-p2)と書いてよい*/\n\tdouble dx=p1.real()-p2.real();\n\tdouble dy=p1.imag()-p2.imag();\n\treturn sqrt(dx*dx+dy*dy);\n}\n\ndouble linePointDistance(Line l,Point p){\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tdouble num=abs(a*x+b*y-c);\n\tdouble den=sqrt(a*a+b*b);\n\treturn num/den;\n}\n\nVector basisVector(Vector v){\n\tif(eq(v.real(),0.0)&&eq(v.imag(),0.0)) return v;\n\treturn v/sqrt(norm(v));\n}\n\nPoint linePointProjection(Line l,Point p){\n\tdouble dx=l.a,dy=l.b;\n\tdouble a=l.a,b=l.b,c=l.c;\n\tdouble x=p.real(),y=p.imag();\n\tVector ba=basisVector(Vector(dx,dy));\n\tdouble num=a*x+b*y-c;\n\tdouble den=sqrt(a*a+b*b);\n\tVector v=ba*(-num/den);\n\treturn p+v;\n}\n\nvector<Point> circleLineIntersection(Circle c,Line l){\n\tvector<Point> res;\n\tPoint p=linePointProjection(l,c.center);\n\tdouble d=linePointDistance(l,c.center);\n\tint s=sgn(d-c.r);\n\tif(s==1){\n\t\treturn res;//empty\n\t}else if(s==0){\n\t\tres.push_back(p);\n\t\treturn res;\n\t}else{\n\t\tdouble r=c.r;\n\t\tdouble t=sqrt(r*r-d*d);\n\t\tVector e=basisVector(Vector(l.b,-l.a));\n\t\tres.push_back(p+t*e);\n\t\tres.push_back(p-t*e);\n\t\treturn res;\n\t}\n}\n\nvector<Point> circlesIntersection(Circle c1,Circle c2){/*一致するとき処理できない*/\n\tif(eq(c1.center.real(),c2.center.real())&&eq(c1.center.imag(),c2.center.imag())&&\n\t\teq(c1.r,c2.r)){\n\t\t\t\tPoint p=Point(NAN,NAN);\n\t\t\t\tvector<Point> v;\n\t\t\t\tv.push_back(p);\n\t\t\t\treturn v;\n\t}\n\tdouble d=pointsDistance(c1.center,c2.center);\n\tdouble r1=c1.r,r2=c2.r;\n\tdouble dif=max(r1,r2)-min(r1,r2);\n\tdouble sum=r1+r2;\n\tif(sgn(d-sum)==1||sgn(dif-d)==1){//d>sum||dif>d\n\t\tvector<Point> v;\n\t\treturn v;\n\t}\n\tdouble x1=c1.center.real(),y1=c1.center.imag();\n\tdouble x2=c2.center.real(),y2=c2.center.imag();\n\tLine l=Line(-x1*2+x2*2,-y1*2+y2*2,r1*r1-r2*r2-(x1*x1-x2*x2)-(y1*y1-y2*y2));\n\treturn circleLineIntersection(c1,l);\n}\n\ndouble det(double a,double b,double c,double d){\n\treturn a*d-b*c;\n}\n\nPoint linesIntersection(Line l1,Line l2){/*平行の時は常にNAN*/\n\tdouble a=l1.a,b=l1.b,c=l1.c;\n\tdouble d=l2.a,e=l2.b,f=l2.c;\n\tdouble den=det(a,b,d,e);\n\tdouble numx=det(c,b,f,e);\n\tdouble numy=det(a,c,d,f);\n\tif(eq(den,0.0)){\n\t\treturn Point(NAN,NAN);\n\t}\n\treturn Point(numx/den,numy/den);\n}\n\n//circlesIntersection verify AOJ1190 ICPC Domestic 2013 Balloon\n\ndouble crossProduct(Vector a,Vector b){\n\treturn (conj(a)*b).imag();\n}\n\ndouble dotProduct(Vector a,Vector b){\n\treturn (conj(a)*b).real();\n}\n\nint ccw(Point p1,Point p2,Point p3){\n\t/*p1,p2,p3はすべて異なると仮定\n\tそうでない場合の戻り値は不定\n\tではなく\n\tp1!=p2と仮定*/\n\tVector b=p2-p1;\n\tVector c=p3-p2;\n\tint s=sgn(crossProduct(b,c));\n\tif(s==1) return 1;//counterclockwise\n\tif(s==-1) return -1;//clockwise\n\tint t=sgn(dotProduct(b,c));\n\tif(t==-1) return 2;//3--1--2\n\tint u=sgn(norm(b)-norm(c));\n\tif(eq(norm(c),0.0)) return 0;//1==3\n\tif(u==-1) return -2;//1--2--3\n\treturn 0;//1--3--2 or 2==3\n}\n\nstruct Segment{\n\tPoint p1,p2;\n\tLine l;\n\tSegment(){}\n\tSegment(Point p1,Point p2):p1(p1),p2(p2){\n\t\tl=Line(p1,p2);\n\t}\n};\n\nint oneLineCCW(Point p1,Point p2,Point p3){\n\t/*p1!=p2かつp1,p2,p3は一直線上と仮定*/\n\t/*それ以外の時の戻り値は不定*/\n\tVector b=p2-p1,c=p3-p1;\n\tif(sgn(dotProduct(b,c))==-1) return 2;//p3--p1--p2\n\tif(eq(abs(p1-p3),0.0)) return 1;//p1==p3--p2\n\tint s=sgn(norm(b)-norm(c));\n\tif(s==1) return 0;//p1--p3--p2\n\tif(s==0) return -1;//p1--p3==p2\n\telse return -2;//p1--p2--p3\n}\n\ndouble pointSegmentDistance(Point p,Segment s){\n\tLine l=s.l;\n\tdouble d=linePointDistance(l,p);\n\tPoint pr=linePointProjection(l,p);\n\tint x=oneLineCCW(s.p1,s.p2,pr);\n\tif(x>=-1&&x<=1) return d;\n\tdouble a=abs(s.p1-p);\n\tdouble b=abs(s.p2-p);\n\treturn min(a,b);\n}\n\nbool segmentsIntersect(Segment s1,Segment s2){\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\treturn ccw(p[0],p[1],q[0])*ccw(p[0],p[1],q[1])<=0&&\n\t\tccw(q[0],q[1],p[0])*ccw(q[0],q[1],p[1])<=0;\n}\n\ndouble segmentsDistance(Segment s1,Segment s2){\n\tbool flg=segmentsIntersect(s1,s2);\n\tif(flg) return 0;\n\tPoint p[2],q[2];\n\tp[0]=s1.p1,p[1]=s1.p2;\n\tq[0]=s2.p1,q[1]=s2.p2;\n\tdouble res=-1;\n\tfor(int k=0;k<2;k++){\n\t\tPoint r=linePointProjection(s2.l,p[k]);\n\t\tif(abs(oneLineCCW(q[0],q[1],r))<=1){\n\t\t\tdouble tmp=abs(r-p[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t\tr=linePointProjection(s1.l,q[k]);\n\t\tif(abs(oneLineCCW(p[0],p[1],r))<=1){\n\t\t\tdouble tmp=abs(r-q[k]);\n\t\t\tif(res<0||tmp<res) res=tmp;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tdouble tmp=abs(p[i]-q[j]);\n\t\tif(res<0||tmp<res) res=tmp;\n\t}\n\treturn res;\n}\n\n//segmentsDistance verified aoj cgl_2 d Distance\n\nPoint inputPoint(){\n\tdouble x,y;\n\tscanf(\"%lf%lf\",&x,&y);\n\treturn Point(x,y);\n}\n\nstruct Rect{\n\tdouble mx,my,Mx,My;\n\tRect(){}\n\tRect(double x1,double y1,double x2,double y2){\n\t\tmx=x1,my=y1,Mx=x2,My=y2;\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n\tRect(Point p1,Point p2){\n\t\tmx=p1.real(),my=p1.imag();\n\t\tMx=p2.real(),My=p2.imag();\n\t\tif(mx>Mx) swap(mx,Mx);\n\t\tif(my>My) swap(my,My);\n\t}\n};\n\nbool inRect(Rect r,Point p){//strictly inside\n\tdouble x=p.real(),y=p.imag();\n\treturn sgn(x-r.mx)==1&&sgn(r.Mx-x)==1&&sgn(y-r.my)==1&&sgn(r.My-y)==1;\n}\n\ndouble getR(double d,double h){\n\tif(h>d) return d;\n\treturn (h*h+d*d)/(h*2);\n}\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0) break;\n\t\tPoint s=inputPoint();\n\t\tPoint t=inputPoint();\n\t\tSegment course=Segment(s,t);\n\t\tdouble ans=-1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tPoint ps[4];\n\t\t\tps[0]=inputPoint();\n\t\t\tps[2]=inputPoint();\n\t\t\tRect r=Rect(ps[0],ps[2]);\n\t\t\tif(inRect(r,s)||inRect(r,t)){\n\t\t\t\tans=0;\n\t\t\t}\n\t\t\tdouble h;\n\t\t\tscanf(\"%lf\",&h);\n\t\t\tps[1]=Point(ps[2].real(),ps[0].imag());\n\t\t\tps[3]=Point(ps[0].real(),ps[2].imag());\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tSegment e=Segment(ps[j],ps[(j+1)%4]);\n\t\t\t\tdouble d=segmentsDistance(e,course);\n\t\t\t\tdouble curR=getR(d,h);\n\t\t\t\tif(ans<0||ans>curR) ans=curR;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<complex>\n#include<numeric>\n#include<bitset>\n#define INF 1001001001\n#define OUT 1234567\n#define EPS 1e-8\n#define x first\n#define y second\n\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vint>  vvint;\ntypedef pair<int,int> pint;\ntypedef long long Int;\ntypedef pair<double,double> pt;\ntypedef pair<pair<double,pt>,pair<double,pt> > ans;\n\ndouble pi=3.14159265358979;\ndouble len(pt a){\n\treturn hypot(a.x,a.y);\n}\nint cross(pt a,pt b){\n\treturn (a.x*b.y-a.y*b.x);\n}\nint naiseki(pt a,pt b,pt c){\n\tb.x-=a.x;\n\tb.y-=a.y;\n\tc.x-=a.x;\n\tc.y-=a.y;\n\treturn (b.x*c.x+b.y*c.y);\n}\nint ccw(pt a,pt b,pt c){\n\tb.x-=a.x;\n\tb.y-=a.y;\n\tc.x-=a.x;\n\tc.y-=a.y;\n\tif(cross(b,c)>0) return 1;\n\tif(cross(b,c)<0) return -1;\n\treturn 0;\n}\nint ccw2(pt a,pt b,pt c){\n\tb.x-=a.x;\n\tb.y-=a.y;\n\tc.x-=a.x;\n\tc.y-=a.y;\n\tif((b.x*c.y-b.y*c.x)>0) return 1;\n\tif((b.x*c.y-b.y*c.x)<0) return -1;\n\tif((b.x*c.x+b.y*c.y)<0) return 2;\n\tif(len(b)<len(c)) return -2;\n\treturn 0;\n}\nint kousa(pt s,pt e,pt p,pt q){\n\tif(ccw(s,e,p)==0 && ccw(p,q,s)==0) return 0;\n\treturn (ccw(s,e,p)*ccw(s,e,q)<=0 && ccw(p,q,s)*ccw(p,q,e)<=0);\n}\nbool line(pt a,pt b,pt c){\n\tif(ccw2(a,b,c)==-2 || ccw2(c,b,a)==-2) return 1;\n\treturn 0;\n}\ndouble kyori_(pt s,pt e,pt p){\n\te.x-=s.x;\n\te.y-=s.y;\n\tp.x-=s.x;\n\tp.y-=s.y;\n\tif(len(e)<=0) return 0;\n\treturn abs((double)cross(e,p))/len(e);\n}\ndouble kyori(pt s,pt e,pt p,pt q){\n\tdouble ans=INF;\n\tif(naiseki(s,e,p)>0 && naiseki(e,s,p)>0) ans=min(ans,kyori_(s,e,p));\n\tif(naiseki(s,e,q)>0 && naiseki(e,s,q)>0) ans=min(ans,kyori_(s,e,q));\n\tif(naiseki(p,q,s)>0 && naiseki(q,p,s)>0) ans=min(ans,kyori_(p,q,s));\n\tif(naiseki(p,q,e)>0 && naiseki(q,p,e)>0) ans=min(ans,kyori_(p,q,e));\n\tans=min(ans,hypot(p.x-s.x,p.y-s.y));\n\tans=min(ans,hypot(p.x-e.x,p.y-e.y));\n\tans=min(ans,hypot(q.x-s.x,q.y-s.y));\n\tans=min(ans,hypot(q.x-e.x,q.y-e.y));\n\treturn ans;\n}\n\t\t\nint main(){\n\tint n;\n\twhile(cin >> n){\n\t\tif(n==0) break;\n\t\t\n\t\tdouble ans = 1234.5;\n\t\tpt s,e,p,q,r,t;\n\t\tscanf(\"%lf %lf %lf %lf\",&s.x,&s.y,&e.x,&e.y);\n\t\tint h;\n\t\t\n\t\tint i,j;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%lf %lf %lf %lf %d\",&p.x,&p.y,&r.x,&r.y,&h);\n\t\t\tq=pt(p.x,r.y);\n\t\t\tt=pt(r.x,p.y);\n\t\t\t\n\t\t\tif(p.x<=s.x && s.x<=r.x && p.y<=s.y && s.y<=r.y) ans=0;\n\t\t\tif(p.x<=e.x && e.x<=r.x && p.y<=e.y && e.y<=r.y) ans=0;\n\t\t\t\n\t\t\tif(kousa(s,e,p,q)) ans=0;\n\t\t\tif(kousa(s,e,q,r)) ans=0;\n\t\t\tif(kousa(s,e,r,t)) ans=0;\n\t\t\tif(kousa(s,e,t,p)) ans=0;\n\t\t\t\n\t\t\tdouble minl=INF;\n\t\t\tminl=min(minl,kyori(s,e,p,q));\n\t\t\tminl=min(minl,kyori(s,e,q,r));\n\t\t\tminl=min(minl,kyori(s,e,r,t));\n\t\t\tminl=min(minl,kyori(s,e,t,p));\n\t\t\t\n\t\t\tif(minl<(double)h) ans=min(ans,minl);\n\t\t\telse ans=min(ans,(minl*minl+(double)h*h)/(2.0*(double)h));\n//\t\t\tcout << ans << endl;\n\t\t}\n\t\t\n\t\tprintf(\"%.5lf\\n\",ans);\n\t}\n\t\n\treturn 0;\n}\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ninline double sq(double x) { return x * x; }\n\nstruct point {\n    double x, y, z;\n    point() {}\n    point(double x, double y, double z): x(x), y(y), z(z) {}\n    point operator + (const point& o) const { return point(x+o.x, y+o.y, z+o.z); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y, z-o.z); }\n    point operator * (const double a) const { return point(x*a,   y*a,   z*a); }\n};\n\ndouble fabs(point p) { return sqrt(sq(p.x) + sq(p.y) + sq(p.z)); }\ndouble dist(point p, point q) { return fabs(p - q); }\ndouble dot(point p, point q) { return p.x*q.x + p.y*q.y + p.z*q.z; }\npoint cross(point p, point q) {\n    return point(\n        p.y*q.z - p.z*q.y,\n        p.z*q.x - p.x*q.z,\n        p.x*q.y - p.y*q.x\n    );\n}\n\nstruct line {\n    point a, b;\n    line() {}\n    line(point a, point b): a(a), b(b) {}\n};\n\ndouble dist_point_line(point p, line l) {\n    if (dot(l.b - l.a, p - l.a) >= 0 && dot(l.a - l.b, p - l.b) >= 0) {\n        point h = l.a + (l.b - l.a) * (dot(l.b - l.a, p - l.a) / sq(fabs(l.b - l.a)));\n        return dist(p, h);\n    }\n\n    return min(dist(p, l.a), dist(p, l.b));\n}\n\nint N; double Sx, Sy, Ex, Ey;\nvector<vector<point>> rects;\nvector<line> vs;\n\ndouble solve() {\n    line c(point(Sx, Sy, 0), point(Ex, Ey, 0));\n    for (vector<point> r : rects) {\n        for (int i = 0; i < 4; ++i) {\n            for (int j = i+1; j < 4; ++j) {\n                double c1 = cross(c.b - c.a, r[i] - c.a).z * cross(c.b - c.a, r[j] - c.a).z;\n                double c2 = cross(r[j] - r[i], c.a - r[i]).z * cross(r[j] - r[i], c.b - r[i]).z;\n                if (c1 <= 0 && c2 <= 0)\n                    return 0;\n            }\n        }\n    }\n\n    double l = 0, r = 1050;\n    for (int g = 0; g < 100; ++g) {\n        double m = (l + r) / 2;\n\n        line c(point(Sx, Sy, m), point(Ex, Ey, m));\n\n        bool ok = true;\n        for (line p : vs) {\n            if (m < p.a.z) p.a.z = p.b.z = m;\n            if (dist_point_line(p.a, c) <= m || dist_point_line(p.b, c) <= m)\n                ok = false;\n\n            if (dist_point_line(c.a, p) <= m || dist_point_line(c.b, p) <= m)\n                ok = false;\n\n            double c1 = cross(c.b - c.a, p.a - c.a).z * cross(c.b - c.a, p.b - c.a).z;\n            double c2 = cross(p.b - p.a, c.a - p.a).z * cross(p.b - p.a, c.b - p.a).z;\n\n            if (c1 <= 0 && c2 <= 0)\n                ok = false;\n        }\n\n        (ok ? l : r) = m;\n    }\n\n    return (l + r) / 2;\n}\n\nint main(void) {\n    cout << fixed << setprecision(10);\n    while (true) {\n        cin >> N; if (N == 0) break;\n        cin >> Sx >> Sy >> Ex >> Ey;\n        vs.clear();\n        for (int i = 0; i < N; ++i) {\n            double minx, miny, maxx, maxy, h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            vs.emplace_back(point(minx, miny, h), point(minx, maxy, h));\n            vs.emplace_back(point(minx, miny, h), point(maxx, miny, h));\n            vs.emplace_back(point(minx, maxy, h), point(maxx, maxy, h));\n            vs.emplace_back(point(maxx, miny, h), point(maxx, maxy, h));\n\n            vector<point> vv;\n            vv.emplace_back(minx, miny, h);\n            vv.emplace_back(minx, maxy, h);\n            vv.emplace_back(maxx, miny, h);\n            vv.emplace_back(maxx, maxy, h);\n            rects.push_back(vv);\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n\n#define fr first\n#define sc second\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point,vec;\ntypedef pair<point,point> pp,seg,line;\n\nconst elem pi = 2.0*acos(0.0);\nconst elem eps = 1.0e-12;\nconst elem infty = 1.0e+18;\n\ninline bool eq(elem a, elem b){return abs(b-a) < eps;}\ninline bool leq(elem a, elem b){return eq(a,b) || a < b;}\ninline bool geq(elem a, elem b){return eq(a,b) || a > b;}\ninline bool lt(elem a, elem b){return !eq(a,b) && a < b;}\ninline bool gt(elem a, elem b){return !eq(a,b) && a > b;}\ninline bool ltz(elem a){return lt(a,0);}\ninline bool gtz(elem a){return gt(a,0);}\ninline elem emax(elem a, elem b){return gt(a,b)?a:b;}\ninline elem emin(elem a, elem b){return lt(a,b)?a:b;}\ninline elem dot(point a, point b){return a.real()*b.real() + a.imag()*b.imag();}\ninline elem cross(point a, point b){return a.real()*b.imag()-a.imag()*b.real();}\ninline elem dist_l(line l,point x){ return abs(cross(l.sc-l.fr,x-l.fr))/abs(l.sc-l.fr); }\ninline elem dist_seg(seg s, point x){\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\ninline int ccw(point a, point b, point x){\n  b-=a;x-=a;\n  if(gtz(cross(b,x)))return LEFT;\n  if(ltz(cross(b,x)))return RIGHT;\n  if(ltz(dot(b,x)))return BACK;\n  if(abs(b)<abs(x))return FRONT;\n  return OVER;\n}\ninline bool intersected_seg(seg a, seg b){\n  if( ccw(a.fr,a.sc,b.fr)&OVER || ccw(a.fr,a.sc,b.sc)&OVER ) return true;\n  \n  return\n    ( ccw(a.fr,a.sc,b.fr) | ccw(a.fr,a.sc,b.sc) ) == (LEFT|RIGHT) &&\n    ( ccw(b.fr,b.sc,a.fr) | ccw(b.fr,b.sc,a.sc) ) == (LEFT|RIGHT) ;\n  return ( leq( cross(a.sc-a.fr,b.fr-a.fr) * cross(a.sc-a.fr,b.sc-a.fr), 0 ) &&\n\t   leq( cross(b.sc-b.fr,a.fr-b.fr) * cross(b.sc-b.fr,a.sc-b.fr), 0 ) );\n}\n\nclass cuboid{\npublic:\n  elem h;\n  elem minx, miny;\n  elem maxx, maxy;\n  point tl,bl,tr,br;\n  cuboid():minx(0),miny(0),\n\t maxx(0),maxy(0),h(0){}\n  cuboid(elem minx, elem miny, elem maxx, elem maxy,elem h):\n    minx(minx),miny(miny),\n    maxx(maxx),maxy(maxy),h(h),\n    tl(minx,maxy),bl(minx,miny),tr(maxx,maxy),br(maxx,miny){}\n  bool intersected_seg(seg l){\n    /*\n      cout << \" INTERSECTED_SEG : \" << endl;\n      cout << ::intersected_seg(l,seg(tl,tr)) << endl;\n      cout << ::intersected_seg(l,seg(tl,bl)) << endl;\n      cout << ::intersected_seg(l,seg(tr,br)) << endl;\n      cout << ::intersected_seg(l,seg(bl,br)) << endl;\n    */\n    if( ::intersected_seg(l,seg(tl,tr)) ||\n\t::intersected_seg(l,seg(tl,bl)) ||\n\t::intersected_seg(l,seg(tr,br)) ||\n\t::intersected_seg(l,seg(bl,br)) ) return true;\n    return false;\n  }\n  bool contain_seg(seg l){\n    if( ccw(bl,br,l.fr)&(OVER|LEFT) &&\n\tccw(br,tr,l.fr)&(OVER|LEFT) &&\n\tccw(tr,tl,l.fr)&(OVER|LEFT) &&\n\tccw(tl,bl,l.fr)&(OVER|LEFT)\n\t&&\n\tccw(bl,br,l.sc)&(OVER|LEFT) &&\n\tccw(br,tr,l.sc)&(OVER|LEFT) &&\n\tccw(tr,tl,l.sc)&(OVER|LEFT) &&\n\tccw(tl,bl,l.sc)&(OVER|LEFT) ) return true;\n    return false;\n  }\n  elem getMinimumDistance(seg l){\n    elem ret = infty;\n    ret = emin( ret, dist_seg( l, tl ) );\n    ret = emin( ret, dist_seg( l, tr ) );\n    ret = emin( ret, dist_seg( l, bl ) );\n    ret = emin( ret, dist_seg( l, br ) );\n    ret = emin( ret, dist_seg( seg(tl,tr), l.fr ) );\n    ret = emin( ret, dist_seg( seg(tl,tr), l.sc ) );\n    ret = emin( ret, dist_seg( seg(tl,bl), l.fr ) );\n    ret = emin( ret, dist_seg( seg(tl,bl), l.sc ) );\n    ret = emin( ret, dist_seg( seg(bl,br), l.fr ) );\n    ret = emin( ret, dist_seg( seg(bl,br), l.sc ) );\n    ret = emin( ret, dist_seg( seg(tr,br), l.fr ) );\n    ret = emin( ret, dist_seg( seg(tr,br), l.sc ) );\n    return ret;\n  }\n  elem getRwithSphere(seg l){\n    //cout <<\"CONTAINS : \"<<contain_seg(l)<<endl;\n    //cout <<\"INTERSECTED : \" <<intersected_seg(l)<<endl;\n    if(contain_seg(l) || intersected_seg(l))return 0;\n    elem d = getMinimumDistance(l);\n    //cout << \" MIN D : \" << d << endl;\n    if(eq(d,0))return 0;\n    if(geq(h,d))return d;\n    elem theta = 2*atan(h/d);\n    elem ret = sqrt( (pow(d,2)+pow(h,2))/(2*(1-cos(theta))) );\n    return ret;\n  }\n};\n\nint main(){\n  //cout << intersected_seg( seg(point(10,0),point(0,0)), seg(point(10,5),point(0,5)) ) << endl;\n  //return 0;\n  while(true){\n    int n;\n    elem ans = infty;\n    elem sx,sy,ex,ey;\n    vector<cuboid> vcubo;\n    scanf(\"%d\",&n);\n    if(n == 0) return 0;\n    scanf(\"%lf%lf%lf%lf\",&sx,&sy,&ex,&ey);\n    point S(sx,sy), E(ex,ey);\n    for(int i = 0; i < n; ++i){\n      elem minx, miny, maxx, maxy, h;\n      scanf(\"%lf%lf%lf%lf%lf\",\n\t    &minx,&miny,&maxx,&maxy,&h);\n      vcubo.push_back( cuboid(minx,miny,maxx,maxy,h) );\n    }\n    for(int i = 0; i < n; ++i){\n      ans = emin( ans, vcubo[i].getRwithSphere( seg(S,E) ) );\n    }\n    printf(\"%.7lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> xy;\ndouble eps = 1e-9;\ndouble dot_product(xy a,xy b) {return (conj(a)*b).real();}\ndouble cross_product(xy a,xy b) {return (conj(a)*b).imag();}\ndouble dist_lp(xy a1,xy a2,xy p){\n    if(dot_product(a2-a1,p-a1)<eps) return abs(p-a1);\n    if(dot_product(a1-a2,p-a2)<eps) return abs(p-a2);\n    return abs(cross_product(a2-a1,p-a1))/abs(a2-a1);\n}\n\nbool is_online(xy a1,xy a2,xy p){\n    return abs(a1-p)+abs(a2-p)<=abs(a1-a2)+eps;    \n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    if(is_online(a1,a2,b1) || is_online(a1,a2,b2)) return true;\n    if(is_online(b1,b2,a1) || is_online(b1,b2,a2)) return true;\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<-eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<-eps;\n}\n\ndouble dist_ll(xy a1,xy a2,xy b1,xy b2){\n    if(is_intersected(a1,a2,b1,b2)) return 0;\n    return min({dist_lp(a1,a2,b1),dist_lp(a1,a2,b2),dist_lp(b1,b2,a1),dist_lp(b1,b2,a2)\n    ,abs(a1-b1),abs(a1-b2),abs(a2-b1),abs(a2-b2)});   \n}\n\nint N;\ndouble sx,sy,gx,gy,mi_x,mi_y,ma_x,ma_y;\ndouble h;\n\n\nint main(){\n    while(cin>>N && N>0){\n        double ans = 1e9;\n        cin >> sx >> sy >> gx >> gy;\n        if(sx>gx){\n            swap(sx,sy);\n            swap(gx,gy);\n        }\n        xy s = xy(sx,sy),g = xy(gx,gy);\n        for(int i=1;i<=N;i++){\n            cin >> mi_x >> mi_y >> ma_x >> ma_y >> h;\n            if(mi_x<=sx && sx<=ma_x && mi_y<=sy && sy<=ma_y && \n            mi_x<=gx && gx<=ma_x && mi_y<=gy && gy<=ma_y) ans = 0;\n            double d = min({dist_ll(s,g,xy(mi_x,mi_y),xy(mi_x,ma_y)),\n            dist_ll(s,g,xy(mi_x,ma_y),xy(ma_x,ma_y)),\n            dist_ll(s,g,xy(ma_x,ma_y),xy(ma_x,mi_y)),\n            dist_ll(s,g,xy(ma_x,mi_y),xy(mi_x,mi_y))});\n            if(d<=h) ans = min(ans,d);\n            else ans = min(ans,(h*h+d*d)/h);\n        }\n        cout << fixed;\n        cout << setprecision(10) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-7;\nconst double PI  = acos(-1.0);\n\n#define M INT_MAX\nstruct P{\n  double x;\n  double y;\n\n  P(){\n\tx=M; y=M;\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n\n};\ndouble dot(P a,P b){\n  return (a.x*b.x+a.y*b.y);\n}\n\ndouble cross(P a,P b){\n  return (a.x*b.y-a.y*b.x);\n}\ndouble dis(P t){\n  return sqrt(t.x*t.x+t.y*t.y);\n}\ndouble psd(P p , P a , P b){\n  if( dot( b-a , p-a ) < EPS) return fabs(dis(p-a));\n  if( dot( a-b , p-b ) < EPS) return fabs(dis(p-b));\n  return fabs(cross( b-a , p-a )) / fabs(dis(b-a));\n}\n\ndouble dist_s(P p1, P p2, P q1, P q2){\n  if(cross(p2-p1, q1-p1) * cross(p2-p1, q2-p1) < 0\n\t && cross(q2-q1, p1-q1) * cross(q2-q1, p2-q1) < 0) return 0;\n  return min(min(psd(p1, q1, q2), psd(p2, q1, q2)),\n\t\t\t min(psd(q1, p1, p2), psd(q2, p1, p2)));\n}\n\nbool intersect_s(P a1 , P a2 , P b1 , P b2){\n  return ( cross(a2-a1 , b1-a1)*cross(a2-a1 , b2-a1) < EPS) &&\n\t( cross(b2-b1 , a1-b1)*cross(b2-b1 , a2-b1) < EPS);\n}\n\nbool isin(P p, P a1, P a2){\n  double mx = min(a1.x, a2.x), Mx = max(a1.x, a2.x);\n  double my = min(a1.y, a2.y), My = max(a1.y, a2.y);\n  return mx < p.x && p.x < Mx\n\t&& my < p.y  && p.y < My;\n}\n\nint main(){\n  int N;\n  while(cin>>N,N){\n\tP s, e;\n\tvector< vector<P> > ps(N, vector<P>(4));\n\tvector<double> h(N), d(N, M);\n\tcin >> s.x >> s.y >> e.x >> e.y;\n\tREP(i,N)\n\t  cin >> ps[i][0].x >> ps[i][0].y >> ps[i][2].x >> ps[i][2].y >> h[i];\n\tREP(i,N){\n\t  ps[i][1].x = ps[i][0].x;\n\t  ps[i][1].y = ps[i][2].y;\n\n\t  ps[i][3].x = ps[i][2].x;\n\t  ps[i][3].y = ps[i][0].y;\n\t}\n\n\tbool ng = false;\n\tREP(i,N) REP(j,4)\n\t  if(intersect_s(s,e,ps[i][j],ps[i][(j+1)%4])\n\t\t || isin(s, ps[i][0], ps[i][2]) || isin(e, ps[i][0], ps[i][2]))\n\t\tng = true;\n\tif(ng){\n\t  cout << 0 << endl;\n\t  continue;\n\t}\n\n\tREP(i,N) REP(j,4){\n\t  d[i] = min(d[i], dist_s(s, e, ps[i][j], ps[i][(j+1)%4]));\n\t}\n\n\tdouble r_lb = 0., r_ub = 1000.;\n\n\tREP(i,100){\n\t  bool flag = true;\n\t  double r = (r_lb + r_ub) / 2.;\n\t  REP(j,N){\n\t\tif(r < d[j]) continue;\n\t\tif(r < h[j] || d[j]*d[j]+h[j]*h[j] - 2*r*h[j] < 0){\n\t\t  flag = false;\n\t\t  break;\n\t\t}\n\t  }\n\n\t  if(flag) r_lb = r;\n\t  else r_ub = r;\n\t}\n\n\tcout << fixed << setprecision(6) << r_lb << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\n#define dame cout << 0 << endl; return;\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nint ccw(P p0, P p1, P p2) {\n    if (cross(p1 - p0, p2 - p0) > 0) return +1; // counter-clockwise\n    if (cross(p1 - p0, p2 - p0) < 0) return -1; // clockwise\n    if (dot(p1 - p0, p2 - p0) < 0) return +2;   // online_back\n    if (dot(p0 - p1, p2 - p1) < 0) return -2;   // online_front\n    return 0;                                   // on_segment\n}\n\nbool intersectSS(L l1, L l2) {\n    return (ccw(l1.a, l1.b, l2.a) * ccw(l1.a, l1.b, l2.b) <= 0 &&\n            ccw(l2.a, l2.b, l1.a) * ccw(l2.a, l2.b, l1.b) <= 0);\n}\n\nbool intersectSG(L l, G g) {\n    int n = g.size();\n    rep(i, n) {\n        if (intersectSS(l, L(here(g, i), next(g, i)))) {\n            return true;\n        }\n    }\n    return false;\n}\n\ndouble distanceLP(L l, P p) {\n    return abs(cross(l.v, p - l.a)) / abs(l.v);\n}\n\ndouble distanceSP(L l, P p) {\n    if (dot(l.v, p - l.a) < 0) return abs(p - l.a);\n    if (dot(-l.v, p - l.b) < 0) return abs(p - l.b);\n    return distanceLP(l, p);\n}\n\ndouble distanceSS(L l1, L l2) {\n    if (intersectSS(l1, l2)) return 0;\n    double d = INF;\n    d = min(d, distanceSP(l1, l2.a));\n    d = min(d, distanceSP(l1, l2.b));\n    d = min(d, distanceSP(l2, l1.a));\n    d = min(d, distanceSP(l2, l1.b));\n    return d;\n}\n\ndouble distanceSG(L l, G g) {\n    double d = INF;\n    rep(i, g.size()) {\n        d = min(d, distanceSS(l, L(here(g, i), next(g, i))));\n    }\n    return d;\n}\n\nbool within(double x, double a, double b) {\n    return a <= x && x <= b;\n}\n\nvoid solve(int n) {\n    double sx, sy, ex, ey;\n    cin >> sx >> sy >> ex >> ey;\n    L seg_ball(sx, sy, ex, ey);\n    vector<G> rect(n);\n    vector<double> h(n);\n\n    rep(i, n) {\n        double minx, miny, maxx, maxy;\n        cin >> minx >> miny >> maxx >> maxy >> h[i];\n        rect[i].emplace_back(minx, miny);\n        rect[i].emplace_back(maxx, miny);\n        rect[i].emplace_back(maxx, maxy);\n        rect[i].emplace_back(minx, maxy);\n\n        if (within(sx, minx, maxx) && within(sy, miny, maxy) && within(ex, minx, maxx) && within(ey, miny, maxy)) {\n            dame;\n        }\n    }\n\n    rep(i, n) {\n        if (intersectSG(seg_ball, rect[i])) {\n            dame;\n        }\n    }\n\n    auto check = [&](double r){\n        rep(i, n) {\n            P p;\n            double d = distanceSG(seg_ball, rect[i]);\n            if (r < h[i]) {\n                if (r > d) return false;\n            } else {\n                if (h[i] > r - sqrt(r*r - d*d)) return false;\n            }\n        }\n        return true;\n    };\n\n    double lb = 0, ub = 1e5;\n    rep(i, 100) {\n        double mid = (lb + ub) / 2;\n        (check(mid) ? lb : ub) = mid;\n    }\n\n    cout << fixed << setprecision(20) << lb << endl;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        solve(n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-10;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 点座標のデバッグ出力\nvoid print(P p) {\n\tcout << \"point\" << p << \";\" << endl;\n}\n\n// * 2乗する\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ベクトルaの単位ベクトルを求める\nP unit(P a) {\n\treturn a / abs(a);\n}\n\n// ベクトルaの法線ベクトルを求める\nvector<P> normal(P a) {\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a) {\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// 原点を軸に点 p を角度 a (ラジアン)だけ回転させた点を返す\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// 点 a を軸に点 b を角度 a (ラジアン)だけ回転させた点を返す\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n\tb-=a, c-=a;\n\tdouble rotdir = cross(b,c);\n\tif( rotdir >  EPS ) return CCW;\n\tif( rotdir < -EPS ) return CW;\n\treturn ON;\n}\n\n\n// 線分の表現\nstruct Segment{\n\t// 点 a, b を端点とする線分\n\tP a, b;\n\t// コンストラクタで初期化\n\tSegment(P a_, P b_) {\n\t\t// x 座標の小さいほうの点を 点 a とする. (不要なときはこの1行を削除すること!!!)\n\t\tif( b_ < a_ ) swap(a_,b_);\n\t\ta = a_; b = b_;\n\t}\n\t// 線分の長さを返す\n\tdouble length() { return abs(a-b); }\n\t// 中点を返す\n\tP mid() { return P( (a.X+b.X)/2.0 , (a.Y+b.Y)/2.0 ); }\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と点 p の距離\n\tdouble distance(P p) {\n\t\tif( dot(b-a, p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b, p-b) < EPS ) return abs(p-b);\n\t\treturn abs(cross(b-a, p-a)) / abs(b-a);\n\t}\n\t// 線分の交差判定\n\tbool is_intersection(const Segment& s) {\n\t\treturn ( cross(b-a, s.a-a) * cross(b-a, s.b-a) < EPS ) &&\n\t\t\t   ( cross(s.b-s.a, a-s.a) * cross(s.b-s.a, b-s.a) < EPS );\n\t}\n\t// 線分の交差判定と交点計算\n\tbool intersection(Segment s, P& p) {\n\t\tbool result = is_intersection( s );\n\t\tif( result ) {\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) ) {\n\t\t\t\t\tp = s.a;\n\t\t\t\t}else if( this->contain(s.b) ) {\n\t\t\t\t\tp = s.b;\n\t\t\t\t}else if( s.contain( a ) ) {\n\t\t\t\t\tp = a;\n\t\t\t\t}else if( s.contain( b ) ) {\n\t\t\t\t\tp = b;\n\t\t\t\t}else {\n\t\t\t\t\tp = INF_P;\n\t\t\t\t}\n\t\t\t}else if( abs(d1) < EPS ) {\n\t\t\t\tp = INF_P;\n\t\t\t}else {\n\t\t\t\tdouble t = d1 / (d1 + d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t}\n\t\t}else{\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// 線分と線分の距離\n\tdouble distance(Segment s) {\n\t\tif( this->is_intersection( s ) ) { // 交差するとき\t\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) || this->contain(s.b) ) {\n\t\t\t\t\treturn 0.0;\n\t\t\t\t}else if( s.contain( a ) || s.contain( b ) ) {\n\t\t\t\t\treturn 0.0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t}\n\t\tdouble A = this->distance(s.a);\n\t\tdouble B = this->distance(s.b);\n\t\tdouble C = s.distance( (*this).a );\n\t\tdouble D = s.distance( (*this).b );\n\t\treturn min( min(A,B) , min(C,D) );\n\t}\n\t// デバッグ出力\n\tvoid print() { printf(\"line(%f,%f,%f,%f); \\n\", a.X, a.Y, b.X, b.Y ); }\n};\n// Segment の順序を定義 (x座標の小さい端点で比較)\nbool operator < (const Segment& s1, const Segment& s2) { return s1.a < s2.a; }\n\n// 直線の表現 ((*this)[0]) と ((*this)[1]) を通る直線\nstruct Line : public vector<P> {\n\tLine(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tLine(vector<P> v){\n\t\tpush_back(v[0]); push_back(v[1]);\n\t}\n\tLine(){}\n\t// 2直線の直交判定\n\tbool orthogonal(const Line& l) {\n\t\treturn equal( dot( (*this)[0] - (*this)[1] , l[0] - l[1] ) , 0.0 );\n\t}\n\t// 2直線の平行判定\n\tbool parallel(const Line& l) {\n\t\treturn equal( cross( (*this)[0] - (*this)[1] , l[0] - l[1] ), 0.0 );\n\t}\n\t// 点 p が直線上に乗っているか\n\tbool contain(P p) {\n\t\treturn equal( cross( (*this)[1] - (*this)[0] , p - (*this)[0] ) , 0.0 );\n\t}\n\t// 直線と点 p の距離\n\tdouble distance(P a) {\n\t\tP p1 = (*this)[0];\n\t\tP p2 = (*this)[1];\n\t\treturn abs( cross( p2 - p1 , a - p1) ) / abs(p2 - p1);\n\t}\n\t// 点 (*this)[0] から 点 (*this)[1] への角度を返す [0,2π]\n\tdouble get_dir() {\n\t\tP p = (*this)[0] - (*this)[1];\n\t\tdouble angle = atan2( p.Y , p.X );\n\t\tif( p.X < 0 ) angle += PI;\n\t\tif( angle < 0 ) angle += 2.0 * PI;\n\t\treturn angle;\n\t}\n\t// 直線の交差判定\n\tbool is_intersection(const Line& l) {\n\t\treturn !equal( cross( (*this)[0] - (*this)[1], l[0] - l[1] ) , 0.0 );\n\t}\n\t// 直線の交差判定と交点計算\n\tbool intersection(Line l, P& p) {\n\t\tbool result = this->is_intersection( l );\n\t\tif( result ) {\n\t\t\tP a = (*this)[1] - (*this)[0];\n\t\t\tP b = l[1] - l[0];\n\t\t\tp = (*this)[0] + a * cross(b, l[0] - (*this)[0]) / cross(b, a);\n\t\t}else {\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t// デバッグ出力\n\tvoid print() {\n\t\tP p1 = (*this)[0];\n\t\tP p2 = (*this)[1];\n\t\tdouble dx = p1.X - p2.X;\n\t\tdouble dy = p1.Y - p2.Y;\n\t\t::print( p1 );\n\t\t::print( p2 );\n\t\tp1.X += 100 * dx;\n\t\tp1.Y += 100 * dy;\n\t\tp2.X -= 100 * dx;\n\t\tp2.Y -= 100 * dy;\n\t\tSegment s( p1 , p2 );\n\t\ts.print();\n\t}\n};\n\n// 円の表現\nstruct Circle{\n\t// 円の中心\n\tP p;\n\t// 円の半径\n\tdouble r;\n\t// コンストラクタで初期化\n\tCircle(P p_, double r_) { p = p_; r = r_; }\n\t// 円の面積\n\tdouble get_area() { return r * r * PI; }\n\t// 円周\n\tdouble circumference() { return 2.0 * r * PI; }\n\t// 点 a が円の内部にあるかどうか\n\tbool is_inside(P a) { return ( dist(a,p) <= r ); }\n\t// 点 a が円周上にあるかどうか\n\tbool on_boundary(P a) { return equal( dist(a,p) , r ); }\n\t\n\t// 直線と円の距離 (円の中心の点と直線の距離 - 円の半径)\n\tdouble distance(Line l){\n\t\treturn l.distance( p ) - r;\n\t}\n\t// 等しいかどうか\n\tbool operator==(const Circle& c) { return (p == c.p && r == c.r) ; };\n\t// 2つの円の位置関係\n\t// 2 つの円が離れている => 0\n\t// 2 つの円が外接する   => 1\n\t// 2 つの円が交わる     => 2\n\t// 2 つの円が内接する    => 3 (2つの円が等しいときは内接)\n\t// 円が含まれている       => 4\n\tint is_pos(const Circle& c) {\n\t\tdouble d = abs(p - c.p);\n\t\tif( r + c.r + EPS < d ) { // 離れている\n\t\t\treturn 0;\n\t\t}else if( equal( r + c.r , d ) ) { // 外接する\n\t\t\treturn 1;\n\t\t}else if( equal( fabs(r-c.r) , d ) ) { // 内接する\n\t\t\treturn 3;\n\t\t}else if( d < fabs(r-c.r) ) { // 含まれる\n\t\t\treturn 4;\n\t\t}else { // 交わる\t\n\t\t\treturn 2;\n\t\t}\n\t}\n\t// 円と直線の交わる点を返す\n\tpair<P,P> intersection(Line l) {\n\t\tpair<P,P> pp;\n\t\tif( this->distance(l) > EPS ) { // 円と直線の交点がないとき\t\n\t\t\tpp.first = pp.second = INF_P;\n\t\t}else { // 円と直線の交点があるとき\n\t\t\tdouble d = l.distance( p );\n\t\t\tdouble angle = -l.get_dir();\n\t\t\t// 点 l[0] を軸に点 l[1] と円の中心を回転\n\t\t\tP lp = rot2( l[0] , l[1] , angle );\n\t\t\tP cp = rot2( l[0] , p    , angle );\n\t\t\tdouble x1 = cp.X - sqrt( sq(r) - sq(d) );\n\t\t\tdouble x2 = cp.X + sqrt( sq(r) - sq(d) );\n\t\t\tP p1(x1,l[0].Y);\n\t\t\tP p2(x2,l[0].Y);\n\t\t\t// 回転して元に戻す\n\t\t\tp1 = rot2( l[0] , p1 , -angle );\n\t\t\tp2 = rot2( l[0] , p2 , -angle );\n\t\t\tpp.first = p1;\n\t\t\tpp.second = p2;\n\t\t}\n\t\treturn pp;\n\t}\n\t// デバッグ出力\n\tvoid print() { printf(\"circle(%f,%f,%f); \\n\", p.X, p.Y, r ); }\n};\n\nstruct Rect{\n\tint x1, y1, x2, y2, h;\n\tRect(int x1_, int y1_, int x2_, int y2_, int h_){\n\t\tx1 = x1_; y1 = y1_; x2 = x2_; y2 = y2_; h = h_;\n\t};\n};\n\nint main(){\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint sx, sy, ex, ey;\n\t\tdouble ans = 0;\n\t\tcin >> sx >> sy >> ex >> ey;\n\t\tSegment s( P(sx,sy) , P(ex,ey) );\n\t\t\n\t\tvector<Rect> v;\n\t\tvector<Segment> vs;\n\t\tbool NA_flag = false;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint min_x, min_y, max_x, max_y, h;\n\t\t\tcin >> min_x >> min_y >> max_x >> max_y >> h;\n\t\t\t\n\t\t\t// p1, p2, p3, p4 は i 番目の長方形の座標を表す.\n\t\t\tP p1(min_x,min_y), p2(min_x,max_y), p3(max_x,min_y), p4(max_x,max_y);\n\t\t\t// s1, s2, s3, s4 は i 番目の長方形の辺(=線分)を表す.\n\t\t\tSegment s1(p1,p2), s2(p1,p3), s3(p2,p4), s4(p3,p4);\n\t\t\t// スタートからゴールまでの線分と交差する長方形があるかどうか調べる\n\t\t\tif( s.is_intersection(s1) || s.is_intersection(s2) ){\n\t\t\t\tNA_flag = true;\n\t\t\t}else if( s.is_intersection(s1) || s.is_intersection(s2) ){\n\t\t\t\tNA_flag = true;\n\t\t\t}else if( min_x <= sx && sx <= max_x && min_y <= sy && sy <= max_y ){\n\t\t\t\tNA_flag = true;\n\t\t\t}else if( min_x <= ex && ex <= max_x && min_y <= ey && ey <= max_y ){\n\t\t\t\tNA_flag = true;\n\t\t\t}\n\t\t\t\n\t\t\t// d は 長方形と線分 s との距離\n\t\t\tdouble d = min( s.distance(p1) , s.distance(p2) );\n\t\t\td = min( d , min( s.distance(p3) , s.distance(p4) ) );\n\t\t\td = min( d , min( s.distance(s1) , s.distance(s2) ) );\n\t\t\td = min( d , min( s.distance(s3) , s.distance(s4) ) );\n\t\t\t\n\t\t\t// 真横からみた座標に 辺の追加\n\t\t\tvs.push_back( Segment( P(d,0) , P(d,h) ) );\n\t\t\t\n\t\t\tv.push_back( Rect( min_x, min_y, max_x, max_y, h ) );\n\t\t}\n\t\tif( NA_flag ){\n\t\t\tcout << 0 << endl;\n\t\t}else{\n\t\t\tdouble low=0.0, high=1000.0,mid=500.0;\n\t\t\t// 適当に二分探索\n\t\t\tfor(int i=0 ; i < 100 ; i++ ){\n\t\t\t\tmid = (low+high) / 2.0;\n\t\t\t\tCircle c( P(0,mid) , mid );\n\t\t\t\tbool flag = false;\n\t\t\t\tfor(int i=0 ; i < vs.size() ; i++ ){\n\t\t\t\t\tLine l( vs[i].a , vs[i].b );\n\t\t\t\t\tpair<P,P> pp = c.intersection( l );\n\t\t\t\t\t\n\t\t\t\t\tif( pp.first == INF_P || pp.first == pp.second ){ // 交差しない\n\t\t\t\t\t}else{\n\t\t\t\t\t\tP p1 = pp.first;\n\t\t\t\t\t\tP p2 = pp.second;\n\t\t\t\t\t\t// 円と線分が交差するとき\n\t\t\t\t\t\tif( vs[i].contain(p1) || vs[i].contain(p2) ){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( flag ){ // 交差するとき\n\t\t\t\t\thigh = mid;\n\t\t\t\t}else{ // 交差しないとき\n\t\t\t\t\tlow = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = mid;\n\t\t\t// cout << ans << endl;\n\t\t\tprintf(\"%.6f\\n\", ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <complex>\nusing namespace std;\n#ifdef DEBUGRUN\n#define log(a) (cerr<<#a\"=\"<<a<<endl)\n#else\n#define log(a) ((void)0)\n#endif\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\ntypedef long long Int;\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\ndouble sq(double a) { return a*a; }\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\nint ccw(const P& a, P b, P c) {\n    b -= a, c -= a;\n    if(cross(b, c)>0) return 1;\n    if(cross(b, c)<0) return -1;\n    if(dot(b, c)<0) return 2;\n    if(norm(b)<norm(c)) return -2;\n    return 0;\n}\nbool crossing(const P& l0, const P& l1, const P& m0, const P& m1) {\n    return ccw(m0, m1, l0)*ccw(m0, m1, l1)<=0\n        && ccw(l0, l1, m0)*ccw(l0, l1, m1)<=0;\n}\nP projection(const P& l0, const P& l1, const P& p) {\n    double t = dot(p-l0, l0-l1) / norm(l0-l1);\n    return l0 + t*(l0-l1);\n}\ndouble distanceSP(const P& s0, const P& s1, const P& p) {\n    const P r(projection(s0, s1, p));\n    if(ccw(s0, s1, r)==0) return abs(r-p);\n    return min(abs(s0-p), abs(s1-p));\n}\ndouble distanceSS(const P& s0, const P& s1, const P& t0, const P& t1) {\n    if(crossing(s0, s1, t0, t1)) return 0;\n    return min(min(distanceSP(s0, s1, t0), distanceSP(s0, s1, t1)),\n               min(distanceSP(t0, t1, s0), distanceSP(t0, t1, s1)));\n}\n\nint n, sx, sy, ex, ey;\nint xa[100], ya[100], xb[100], yb[100], h[100];\nP sp, ep, ps[100][4];\n\nbool check() {\n    rep(i, n) {\n        rep(j, 4) {\n            if(crossing(sp, ep, ps[i][j], ps[i][(j+1)%4])) return false;\n        }\n        if(xa[i]<=sx && sx<=xb[i] && ya[i]<=sy && sy<=yb[i]) return false;\n        if(xa[i]<=ex && ex<=xb[i] && ya[i]<=ey && ey<=yb[i]) return false;\n    }\n    return true;\n}\n\nbool can(double r) {\n    rep(i, n) {\n        const double lim = h[i]>=r ? r : sqrt(sq(r)-sq(r-h[i]));\n        rep(j, 4) {\n            if(distanceSS(sp, ep, ps[i][j], ps[i][(j+1)%4])<lim) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d\", &n);\n        if(n==0) return 0;\n        scanf(\"%d%d%d%d\", &sx, &sy, &ex, &ey);\n        rep(i, n) scanf(\"%d%d%d%d%d\", xa+i, ya+i, xb+i, yb+i, h+i);\n        sp = P(sx, sy);\n        ep = P(ex, ey);\n        rep(i, n) {\n            ps[i][0] = P(xa[i], ya[i]);\n            ps[i][1] = P(xa[i], yb[i]);\n            ps[i][2] = P(xb[i], yb[i]);\n            ps[i][3] = P(xb[i], ya[i]);\n        }\n        double ans = 0;\n        if(check()) {\n            log(true);\n            double l=0, r=2000;\n            rep(_, 100) {\n                const double mid=(l+r)/2;\n                if(can(mid)) l=mid;\n                else r=mid;\n            }\n            ans = l;\n        }\n        printf(\"%.6f\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<long double> xy;\nlong eps = 1e-6;\nlong double dot_product(xy a,xy b) {return (conj(a)*b).real();}\nlong double cross_product(xy a,xy b) {return (conj(a)*b).imag();}\nlong double dist_lp(xy a1,xy a2,xy p){\n    if(dot_product(a2-a1,p-a1)<eps) return abs(p-a1);\n    if(dot_product(a1-a2,p-a2)<eps) return abs(p-a2);\n    return abs(cross_product(a2-a1,p-a1))/abs(a2-a1);\n}\n\nbool is_online(xy a1,xy a2,xy p){\n    return abs(a1-p)+abs(a2-p)<=abs(a1-a2)+eps;    \n}\n\nbool is_intersected(xy a1, xy a2, xy b1, xy b2){\n    if(is_online(a1,a2,b1) || is_online(a1,a2,b2)) return true;\n    if(is_online(b1,b2,a1) || is_online(b1,b2,a2)) return true;\n    return (cross_product(a2-a1,b1-a1)*cross_product(a2-a1,b2-a1)<-eps) && \n    (cross_product(b2-b1,a1-b1)*cross_product(b2-b1,a2-b1))<-eps;\n}\n\nlong double dist_ll(xy a1,xy a2,xy b1,xy b2){\n    if(is_intersected(a1,a2,b1,b2)) return 0;\n    return min({dist_lp(a1,a2,b1),dist_lp(a1,a2,b2),dist_lp(b1,b2,a1),dist_lp(b1,b2,a2)\n    ,abs(a1-b1),abs(a1-b2),abs(a2-b1),abs(a2-b2)});   \n}\n\nint N;\nlong double sx,sy,gx,gy,mi_x,mi_y,ma_x,ma_y;\nlong double h;\n\n\nint main(){\n    while(cin>>N && N>0){\n        long double ans = 1e9;\n        cin >> sx >> sy >> gx >> gy;\n        if(sx>gx){\n            swap(sx,sy);\n            swap(gx,gy);\n        }\n        xy s = xy(sx,sy),g = xy(gx,gy);\n        for(int i=1;i<=N;i++){\n            cin >> mi_x >> mi_y >> ma_x >> ma_y >> h;\n            if((mi_x<=sx && sx<=ma_x && mi_y<=sy && sy<=ma_y || \n            mi_x<=gx && gx<=ma_x && mi_y<=gy && gy<=ma_y)) ans = 0;\n            long double d = min({dist_ll(s,g,xy(mi_x,mi_y),xy(mi_x,ma_y)),\n            dist_ll(s,g,xy(mi_x,ma_y),xy(ma_x,ma_y)),\n            dist_ll(s,g,xy(ma_x,ma_y),xy(ma_x,mi_y)),\n            dist_ll(s,g,xy(ma_x,mi_y),xy(mi_x,mi_y))});\n            if(d<=h) ans = min(ans,d);\n            else ans = min(ans,(h*h+d*d)/(2.0*h));\n        }\n        cout << fixed;\n        cout << setprecision(10) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n\n\n\n\n\n\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL() {}\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\nP projection(const L &l, const P &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\n\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\ntypedef vector<P> G;\n\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n\tbool in = false;\n\tfor (int i = 0; i < g.size(); ++i) {\n\t\tP a = curr(g, i) - p, b = next(g, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n\n\n\n\n\n\nint N;\nL line;\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\tdouble x, y, xx, yy, h;\n\twhile (cin >> N)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tcin >> x >> y; P s(x, y);\n\t\tcin >> x >> y; P t(x, y);\n\t\tline = L(s, t);\n\n\t\tdouble ans = 1000;\n\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tcin >> x >> y >> xx >> yy >> h;\n\n\t\t\tG poly;\n\t\t\tpoly.push_back(P(x, yy));\n\t\t\tpoly.push_back(P(x, y));\n\t\t\tpoly.push_back(P(xx, y));\n\t\t\tpoly.push_back(P(xx, yy));\n\n\t\t\tif (contains(poly, line[0]) == IN && contains(poly, line[1]) == IN)\n\t\t\t{\n\t\t\t\tans = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdouble d = 1000;\n\t\t\td = min(d, distanceSS(line, L(P(x, y), P(x, yy))));\n\t\t\td = min(d, distanceSS(line, L(P(x, yy), P(xx, yy))));\n\t\t\td = min(d, distanceSS(line, L(P(xx, yy), P(xx, y))));\n\t\t\td = min(d, distanceSS(line, L(P(xx, y), P(x, y))));\n\n\t\t\tif (d < EPS)\n\t\t\t{\n\t\t\t\tans = 0;\n\t\t\t}\n\t\t\telse if (d <= h + EPS)\n\t\t\t{\n\t\t\t\tans = min(ans, d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdouble r = (h * h + d * d) / (2.0 * h);\n\t\t\t\tans = min(ans, r);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.10f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// cpp_range (generic range class, very small equivalent of boost::irange)\n// (C) @cielavenir under Boost Software License.\n// note: end position is exclusive.\n\n#include <iterator>\ntemplate<typename T>\nclass range{\npublic:\n\tstruct iterator{\n\t\tconst T a,b;\n\t\tT p;\n\t\tconst long long d; //because T might be unsigned.\n\t\titerator(T _a,T _b,T _p,long long _d=1):a(_a),b(_b),p(_p),d(_d){}\n\n\tpublic:\n\t\ttypedef T value_type;\n\t\ttypedef T& reference;\n\t\ttypedef T* pointer;\n\t\ttypedef std::ptrdiff_t difference_type;\n\t\ttypedef std::random_access_iterator_tag iterator_category;\n\n\t\t//copy\n\t\titerator(const iterator &other):a(other.a),b(other.b),p(other.p),d(other.d){}\n\t\titerator operator=(const iterator &other){return iterator(other.a,other.b,other.p,other.d);}\n\n\t\t//advance\n\t\titerator& operator+=(T n){p+=n*d;return *this;}\n\t\titerator& operator-=(T n){return *this+=(-n);}\n\t\titerator& operator++(){return *this+=1;}\n\t\titerator& operator--(){return *this-=1;}\n\t\titerator operator+(T n) const{return iterator(a,b,p+n*d);}\n\t\titerator operator-(T n) const{return *this+(-n);}\n\n\t\t//difference\n\t\tT operator-(const iterator& other) const{return p-other.p;}\n\n\t\t//equality\n\t\tbool operator==(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p==other.p;}\n\t\tbool operator!=(const iterator& other) const{return !(*this==other);}\n\n\t\t//compare\n\t\tbool operator<(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p*d<other.p*d;}\n\t\tbool operator>(const iterator& other) const{return a==other.a && b==other.b && d==other.d && p*d>other.p*d;}\n\n\t\t//reference\n\t\tconst T& operator*() const{return p;}\n\t};\n\nprivate:\n\tconst T a,b;\n\tT siz;\n\tlong long d;\npublic:\n\trange(T _a,T _b,long long _d=1):a(_a),b(_b){\n\t\td=_d;\n\t\tif(d==0)d=1; //\n\t\tsiz=( (d>0?(b-a):(a-b)) - 1)  / (d>0?d:-d);\n\t}\n\n\tT operator[](T n){return a+n*d;}\n\titerator begin(){return iterator(a,a+d*siz,a,d);}\n\titerator end(){return iterator(a,a+d*siz,a+d*(siz+1),d);}\n\titerator rbegin(){return iterator(b-d*siz,b,b,-1*d);}\n\titerator rend(){return iterator(b-d*siz,b,b-d*(siz+1),-1*d);}\n\tT size(){return siz;}\n};\ntemplate<typename T>\nrange<T> make_range(T a,T b,long long d=1){return range<T>(a,b,d);}\n\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cfloat>\nusing namespace std;\ntypedef double val_t;\ntypedef complex<val_t> P;\ntypedef vector<P> VP;\nconst val_t EPS=1e-9;\n\nval_t cross(const P &a,const P &b){return (conj(a)*b).imag();}\nval_t dot(const P &a,const P &b){return (conj(a)*b).real();}\nP projection(const VP &l,const P &p){\n\tP t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n\treturn l[0]+t*(l[0]-l[1]);\n}\nbool intersectSP(const VP &s,const P &p){\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nval_t distanceSP(const VP &s,const P &p){\n\tP r=projection(s,p);\n\tif(intersectSP(s,r))return abs(r-p);\n\treturn min(abs(s[0]-p),abs(s[1]-p));\n}\nbool intersectSS(const VP &l,const VP &m){\n\tval_t a=cross(l[1]-l[0],m[1]-m[0]);\n\tval_t b=cross(l[1]-l[0],l[1]-m[0]);\n\t//VP pt=abs(a)<EPS ? abs(b)<EPS ? {l[0],l[1],m[0],m[1]} : VP() : {m[0]+b/a*(m[1]-m[0])};\n\tVP pt=vector<VP>{{l[0],l[1],m[0],m[1]},{},{m[0]+b/a*(m[1]-m[0])}}[abs(a)<EPS?abs(b)<EPS?0:1:2];\n\treturn accumulate(pt.begin(),pt.end(),false,[&](bool S,const P &e){\n\t\treturn S||(dot(l[0]-e,l[1]-e)<EPS && dot(m[0]-e,m[1]-e)<EPS);\n\t});\n}\nval_t distanceSS(const VP &s,const VP &t){\n\tif(intersectSS(s,t))return 0;\n\treturn min(\n\t\taccumulate(s.begin(),s.end(),DBL_MAX,[&](val_t S,const P &e){return min(S,distanceSP(t,e));}),\n\t\taccumulate(t.begin(),t.end(),DBL_MAX,[&](val_t S,const P &e){return min(S,distanceSP(s,e));})\n\t);\n}\nint main(){\n\tint n;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tdouble sx,sy,ex,ey;\n\t\tscanf(\"%lf%lf%lf%lf\",&sx,&sy,&ex,&ey);\n\t\tVP s={P(sx,sy),P(ex,ey)};\n\t\tauto ra0=make_range(0,n);\n\t\tprintf(\"%f\\n\",accumulate(ra0.begin(),ra0.end(),DBL_MAX,[&](val_t S,int _)->val_t{\n\t\t\tint f=0;\n\t\t\tdouble x1,y1,x2,y2,h;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf\",&x1,&y1,&x2,&y2,&h);\n\t\t\tVP a;\n\t\t\tfor(auto &x:{x1,x2})for(auto &y:{y1,y2})a.emplace_back(x,y);\n\t\t\tswap(a[2],a[3]);\n\t\t\tauto ra1=make_range(0,4);\n\t\t\tval_t d=accumulate(ra1.begin(),ra1.end(),DBL_MAX,[&](val_t S,int i){\n\t\t\t\tf+=cross(a[i]-s[0],a[(i+1)%4]-s[0])<EPS;\n\t\t\t\treturn min(S,distanceSS(s,{a[i],a[(i+1)%4]}));\n\t\t\t});\n\t\t\treturn min(S,\n\t\t\t\tf==4 ? 0 : //inside\n\t\t\t\td>h ? (h*h+d*d)/h/2 :\n\t\t\t\td\n\t\t\t);\n\t\t}));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  /*  \n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n  ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );*/\n}\n\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  }\n\ndouble getDistanceSS(L s1, L s2){\n  if(isIntersect(s1,s2)) return 0.0;\n  return min( min(getDistanceSP(s1, s2.first), getDistanceSP(s1, s2.second)),\n              min(getDistanceSP(s2, s1.first), getDistanceSP(s2, s1.second)));\n}\n\n\ndouble cal(L a,L b,double h){\n  double d=getDistanceSS(a,b);\n  if(h>d)return d;\n  return (h*h+d*d)/2/h;\n}\n\nint main(){\n  int n;\n\n  while(cin>>n,n){\n    double ans=1e9;\n    P s,e;\n    double minx,maxx,miny,maxy,h;\n    cin>>s.x>>s.y>>e.x>>e.y;\n    for(int i=0;i<n;i++){\n      cin>>minx>>miny>>maxx>>maxy>>h;\n      if(minx<=s.x&&s.x<=maxx&&miny<=s.y&&s.y<=maxy)ans=0;\n      if(minx<=e.x&&e.x<=maxx&&miny<=e.y&&e.y<=maxy)ans=0;\n      ans=min(ans,cal(L(s,e),L(P(minx,miny),P(minx,maxy)),h));\n      ans=min(ans,cal(L(s,e),L(P(minx,maxy),P(maxx,maxy)),h));\n      ans=min(ans,cal(L(s,e),L(P(maxx,maxy),P(maxx,miny)),h));\n      ans=min(ans,cal(L(s,e),L(P(maxx,miny),P(minx,miny)),h));\n    }\n    printf(\"%.8lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nconst int    INF = 1000000000;\nconst ll     MOD = 1000000007LL;\nconst double EPS = 1E-10;\n\ntemplate<typename T> T add(T x, T y){ if(abs(x+y) < EPS*(abs(x)+abs(y))) return 0; return x + y; }\ntemplate<typename T> inline bool semieq(T x, T y){ return abs(x - y) < EPS; }\ntemplate<typename T> inline bool semige(T x, T y){ return y - x < -EPS; }\ntemplate<typename T> inline bool semile(T x, T y){ return x - y < -EPS; }\n\n\nstruct Point : public complex<double>\n{\npublic:\n  Point(const double x = 0.0, const double y = 0.0) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\nint ccw(Point a, Point b, Point c)\n{\n  b -= a;\n  c -= a;\n  if(b.det(c) > 0.0)    return  1;         // counter clockwise\n  if(b.det(c) < 0.0)    return -1;         // clockwise\n  if(b.dot(c) < 0.0)    return  2;         // c--a--b on line\n  if(norm(b) < norm(c)) return -2;         // a--b--c on line\n  return 0;\n}\n\n\nstruct Line : public vector<Point>\n{\npublic:\n  Line(){ }\n  Line(Point P, Point Q){ this->pb(P);  this->pb(Q); }\n  Line(double px, double py, double qx, double qy){ this->pb(Point(px, py));  this->pb(Point(qx, qy)); }\n};\ntypedef Line Segment;\n\nstruct Circle : Point\n{\nprivate:\n  Point p;\n  double r;\n\npublic:\n  Circle() : p(Point(0.0, 0.0)), r(0.0) {}\n  Circle(Point p, double r) : p(p), r(r) {}\n  Circle(double x, double y, double r) : p(Point(x, y)), r(r) {}\n  inline Point center(){ return this->p; }\n  inline double radius(){ return this->r; }\n};\n\ninline Point projectionOfLP(Line L, Point P){return L[0]+(Point(P-L[0])).dot(L[0]-L[1])/norm(L[0]-L[1])*(L[0]-L[1]);}\ninline Point reflectionOfLP(Line L, Point P){return P+2.0*(projectionOfLP(L, P)-P);}\ninline bool intersectionDeterminationOfLL(Line L, Line M){return abs(Point(L[1]-L[0]).det(M[1]-M[0]))>EPS||abs(Point(L[1]-L[0]).det(M[0]-L[0]))<EPS;}\ninline bool intersectionDeterminationOfLS(Line L, Segment S){return(Point(L[1]-L[0]).det(S[0]-L[0]))\n*(Point(L[1]-L[0]).det(S[1]-L[0]))<EPS;}\ninline bool intersectionDeterminationOfLP(Line L, Point P){return abs(Point(L[1]-P).det(L[0]-P))<EPS;}\ninline bool intersectionDeterminationOfSS(Segment S, Segment T){return ccw(S[0],S[1],T[0])*ccw(S[0],S[1],T[1])<=0&&ccw(T[0],T[1],S[0])*ccw(T[0],T[1],S[1])<=0;}\ninline bool intersectionDeterminationOfSP(Segment S, Point P){return abs(S[0]-P)+abs(S[1]-P)-abs(S[1]-S[0])<EPS;}\ninline double distanceOfLP(Line L, Point P){return abs(P-projectionOfLP(L,P));}\ninline double distanceOfLL(Line L, Line M){return intersectionDeterminationOfLL(L,M)?0.0:distanceOfLP(L,M[0]);}\ninline double distanceOfLS(Line L, Segment S){return intersectionDeterminationOfLS(L,S)?0.0:min(distanceOfLP(L,S[0]),distanceOfLP(L,S[1]));}\ninline double distanceOfSP(Segment S, Point P){Point r=projectionOfLP(S,P);return intersectionDeterminationOfSP(S,r)?abs(r-P):min(abs(S[0]-P),abs(S[1]-P));}\ninline double distanceOfSS(Segment S, Segment T){return intersectionDeterminationOfSS(S,T)?0.0:min(min(distanceOfSP(S,T[0]),distanceOfSP(S,T[1])),min(distanceOfSP(T,S[0]),distanceOfSP(T,S[1])));}\nPoint intersectionOfLL(Line L, Line M)\n{\n  double A = Point(L[1]-L[0]).det(M[1]-M[0]);\n  double B = Point(L[1]-L[0]).det(L[1]-M[0]);\n  if(abs(A)<EPS && abs(B)<EPS) return M[0];    // same line\n  if(abs(A)<EPS) assert(false);\n  return M[0] + B / A * (M[1] - M[0]);\n}\ninline bool onLine(Point P, Line L){return semieq(Point(L[0]-P).det(L[1]-P),0.0);}\ninline bool onSegment(Point P, Segment S){return semieq(Point(S[0]-P).det(S[1]-P),0.0)&&!semige(Point(S[0]-P).dot(S[1]-P),0.0);}\n\n\nint N, M;\ndouble sx, sy, ex, ey;\ndouble ax, ay, bx, by;\ndouble h[55];\nvector<vector<Point> > P;\nint main(int argc, char *argv[])\n{\n  while(cin >> N, N){\n    cin >> sx >> sy >> ex >> ey;\n    Segment S(sx, sy, ex, ey);\n    P.clear();\n    rep(i, N){\n      cin >> ax >> ay >> bx >> by >> h[i];\n      vector<Point> t;\n      t.pb(Point(ax, ay));\n      t.pb(Point(ax, by));\n      t.pb(Point(bx, ay));\n      t.pb(Point(bx, by));\n      P.pb(t);\n    }\n    double res = INF;\n    rep(i, N){\n      bool ok = true;\n      rep(j, 4){\n        double d = distanceOfSS(S, Segment(P[i][j], P[i][(j + 1) % 4]));\n        if(!semige(d, h[i])) minup(res, d);\n        else minup(res, (h[i] * h[i] + d * d) / (2.0 * h[i]));\n        ok &= !intersectionDeterminationOfSS(S, Segment(P[i][j], P[i][(j + 1) % 4]));\n      }\n      if(!ok){\n        res = 0.0;\n        break;\n      }\n    }\n    printf(\"%.15f\\n\", res);\n  }\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Ryo Kamoi\n// #define DEBUG\n\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint INF = 1000000000;\n\nstruct rect {\n  pdd points[4]; double h;\n};\n\nstruct linear {\n  double a, b, c;\n};\n\nint n;\ndouble sx, sy, ex, ey;\npdd normal;\nlinear course;\n\nvector<rect> rects;\n\ndouble eps = 0.0000000001;\n\nlinear points2line(pdd p1, pdd p2) {\n  linear line;\n  if (abs(p1.first - p2.first) < eps) {\n    line.a = 1.0;\n    line.b = 0.0;\n    line.c = -p1.first;\n    return line;\n  }\n\n  line.a = -(p1.second - p2.second) / (p1.first - p2.first);\n  line.b = 1.0;\n  line.c = - (line.a * p1.first + line.b * p1.second);\n  return line;\n}\n\npdd intersect(linear l1, linear l2) {\n  if (abs(l1.a) < eps && abs(l2.a) < eps) {\n    return pdd((double)INF, (double)INF);\n  }\n  if (abs(l1.b) < eps && abs(l2.b) < eps) {\n    return pdd((double)INF, (double)INF);\n  }\n  if (abs(l1.a) < eps && abs(l2.b) < eps) {\n    return pdd(-l2.c/l2.a, -l1.c/l1.b);\n  }\n  if (abs(l2.a) < eps && abs(l1.b) < eps) {\n    return pdd(-l1.c/l1.a, -l2.c/l2.b);\n  }\n\n  double x=0, y=0;\n  if (abs(l2.a) < eps) {\n    y = -(l2.c / l2.b);\n    x = -(l1.b * y + l1.c) / l1.a;\n  } else {\n    x = -(l2.c / l2.a);\n    y = -(l1.a * x + l1.c) / l1.b;\n  }\n\n  return pdd(x, y);\n}\n\ndouble l2norm(pdd p) {\n  return sqrt(p.first*p.first + p.second*p.second);\n}\n\nbool on_the_line(rect r) {\n  double seg_maxx = max(sx, ex);\n  double seg_maxy = max(sy, ey);\n  double seg_minx = min(sx, ex);\n  double seg_miny = min(sy, ey);\n  if (seg_maxx<r.points[0].first && seg_maxy<r.points[0].second &&\n      seg_minx>r.points[2].first && seg_miny>r.points[2].second) {\n    return true;\n  }\n\n  REP(i, 4){\n    linear l = points2line(r.points[i], r.points[(i+1)%4]);\n    pdd ip = intersect(course, l);\n\n    if (abs(l.a) < eps) {\n      double ux = max(r.points[i].first, r.points[(i+1)%4].first);\n      double lx = min(r.points[i].first, r.points[(i+1)%4].first);\n      if (ip.first <= ux && ip.first >= lx) {\n        if (ip.second <= max(sy, ey)+eps\n            && ip.second >= min(sy, ey)-eps) {\n          return true;\n        }\n      }\n    } else {\n      double uy = max(r.points[i].second, r.points[(i+1)%4].second);\n      double ly = min(r.points[i].second, r.points[(i+1)%4].second);\n      if (ip.second <= uy && ip.second >= ly) {\n        if (ip.first <= max(sx, ex)+eps\n           && ip.first >= min(sx, ex)-eps) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\ndouble euclid_dist(pdd p1, pdd p2) {\n  pdd p = pdd(p1.first - p2.first, p1.second - p2.second);\n  return l2norm(p);\n}\n\ndouble dist2rad(double dist, double height) {\n  if (dist < height) {\n    return dist;\n  }\n  return (pow(dist, 2) + pow(height, 2)) / (2*height);\n}\n\ndouble inner(pdd p1, pdd p2) {\n  return p1.first * p2.first + p1.second * p2.second;\n}\n\nbool on_lineseg(pdd p, pdd start, pdd end) {\n  pdd linseg = pdd(end.first-start.first, end.second-start.second);\n  pdd pvec = pdd(p.first-start.first, p.second-start.second);\n  double projection = inner(linseg, pvec) / pow(l2norm(linseg), 2);\n  return (projection < 1.0 && projection > 0.0);\n}\n\ndouble linedist(pdd p) {\n  return abs(course.a * p.first + course.b * p.second + course.c) /\n    sqrt(course.a*course.a + course.b*course.b);\n}\n\ndouble recrad(rect r) {\n  double dist = (double)INF;\n\n  REP(i, 4) {\n    pdd p = r.points[i];\n    if (!on_lineseg(p, pdd(sx, sy), pdd(ex, ey))) {\n#ifdef DEBUG\n      cout << \"not on line seg\" << p.first << \" \" << p.second << endl;\n#endif\n      dist = min(dist, euclid_dist(p, pdd(sx, sy)));\n      dist = min(dist, euclid_dist(p, pdd(ex, ey)));\n#ifdef DEBUG\n      cout << dist << endl;\n#endif\n      if (on_lineseg(pdd(sx, sy), p, r.points[(i+1)%4])) { \n        if (i%2==0) {\n          dist = min(dist, abs(p.first - sx));\n        } else {\n          dist = min(dist, abs(p.second - sy));\n        }\n      }\n      if (on_lineseg(pdd(ex, ey), p, r.points[(i+1)%4])) { \n        if (i%2==0) {\n          dist = min(dist, abs(p.first - ex));\n        } else {\n          dist = min(dist, abs(p.second - ey));\n        }\n      }\n    } else {\n      dist = min(dist, linedist(p));\n    }\n  }\n#ifdef DEBUG\n  cout << dist << \" \" << dist2rad(dist, r.h) << endl;\n#endif\n  return dist2rad(dist, r.h);\n}\n\nint main(){\n  while(1) {\n    cin >> n;\n    if (n==0) break;\n\n    cin >> sx >> sy >> ex >> ey;\n    double nx = ey-sy;\n    double ny = -(ex-sx);\n    double norm = l2norm(pdd(nx, ny));\n    nx = nx / norm;\n    ny = ny / norm;\n    normal = pdd(nx, ny);\n    course = points2line(pdd(sx, sy), pdd(ex, ey));\n\n#ifdef DEBUG\n    cout << nx << \" \" << ny << endl;\n    cout << course.a << \" \" << course.b << \" \" << course.c << endl;\n#endif\n\n    rects = vector<rect>();\n    REP(i, n) {\n      double minx, miny, maxx, maxy, h;\n      cin >> minx >> miny >> maxx >> maxy >> h;\n      rect r;\n      r.points[0] = pdd(maxx, maxy);\n      r.points[1] = pdd(maxx, miny);\n      r.points[2] = pdd(minx, miny);\n      r.points[3] = pdd(minx, maxy);\n      r.h = h;\n      rects.push_back(r);\n    }\n    \n    double rad = (double)INF;\n    REP(i, rects.size()) {\n      if (on_the_line(rects[i])) {\n        rad = 0.0;\n#ifdef DEBUG\n        cout << i << \" on line\" << endl;\n#endif\n        break;\n      }\n\n      rad = min(rad, recrad(rects[i]));\n    }\n\n    printf(\"%.10lf\\n\", rad);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(const Point &p0,const Point &p1,const Point &p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nPoint projection(const Segment &s,const Point &p){\n    Vector b = s.t-s.s;\n    double t = dot(p-s.s,b)/norm(b);\n    return s.s+b*t;\n}\n\nbool isIntersectSP(const Segment &s,const Point &p){\n    return (ccw(s.s,s.t,p) == 0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n            ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\ndouble distanceSP(const Segment &s,const Point &p){\n    Point r = projection(s,p);\n    if(isIntersectSP(s,r)) return abs(r-p);\n    return min(abs(s.s-p),abs(s.t-p));\n}\n\ndouble distanceSS(const Segment &a,const Segment &b){\n    if(isIntersectSS(a,b)) return 0;\n    return min(min(distanceSP(a,b.s),distanceSP(a,b.t)),\n           min(distanceSP(b,a.s),distanceSP(b,a.t)));\n}\n\nstruct Block{\n    Point a,b;\n    double h;\n    Block(){}\n    Block(Point &a,Point &b,double h) :\n        a(a),b(b),h(h) {}\n};\n\nistream &operator >> (istream &is,Point &p){ \n    return is >> p.x >> p.y;\n}\n\ndouble calc(double a,double b){\n    return sqrt(a*a+b*b);\n}\n\nbool c(double r,Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point c(v[i].a.x,v[i].b.y),d(v[i].b.x,v[i].a.y);\n        Segment s1(v[i].a,c),s2(v[i].a,d),s3(c,v[i].b),s4(d,v[i].b);\n        double dst[] = {\n            distanceSS(p,s1),\n            distanceSS(p,s2),\n            distanceSS(p,s3),\n            distanceSS(p,s4)\n        };\n \n        if(lt(r,v[i].h)){\n            if(!(lt(r,dst[0]) &&\n                 lt(r,dst[1]) &&\n                 lt(r,dst[2]) &&\n                 lt(r,dst[3]))){\n                return false;\n            }\n        }else{\n            double nh = r - v[i].h;\n            if(!(lt(r,calc(nh,dst[0])) &&\n                 lt(r,calc(nh,dst[1])) &&\n                 lt(r,calc(nh,dst[2])) &&\n                 lt(r,calc(nh,dst[3])))){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool check(Segment &p,vector<Block> &v){\n    for(int i = 0 ; i < (int)v.size() ; i++){\n        Point c(v[i].a.x,v[i].b.y);\n        Point d(v[i].b.x,v[i].a.y);\n        Segment s1(v[i].a,c),s2(v[i].a,d),s3(c,v[i].b),s4(d,v[i].b);\n        if((v[i].a.x <= p.s.x && p.s.x <= v[i].b.x &&\n            v[i].a.y <= p.s.y && p.s.y <= v[i].b.y) ||\n           (v[i].a.x <= p.t.x && p.t.x <= v[i].b.x &&\n            v[i].a.y <= p.t.y && p.t.y <= v[i].b.y)){\n            return true;\n        }\n        if(isIntersectSS(p,s1)) return true;\n        if(isIntersectSS(p,s2)) return true;\n        if(isIntersectSS(p,s3)) return true;\n        if(isIntersectSS(p,s4)) return true;\n    }\n    return false;\n}\n\nint main(){\n    int N;\n    while(cin >> N,N){\n        Point s,e;\n        Segment seg;\n        cin >> seg.s >> seg.t;\n        vector<Block> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i].a >> v[i].b >> v[i].h;\n        }\n        if(check(seg,v)){\n            cout << 0 << endl;\n            continue;\n        }\n        double l = 0,r = 10001;\n        for(int i = 0 ; i < 100 ; i++){\n            double mid = (l + r) / 2;\n            if(c(mid,seg,v)){\n                l = mid;\n            }else{\n                r = mid;\n            }\n        }\n\tprintf(\"%.10f\\n\",r);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n\n\n\n\n//線分x線分交差判定\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\n//線分x点交差判定\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\n//点の直線への射影\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\n//線分と点の距離\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n//線分と線分の距離\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nint i,j,t;\n\nmain(){\n\tint N,i,j;\n\twhile(cin>>N, N){\n\t\tdouble x1,y1,x2,y2,h,Min = 1e6;\n\t\tP S,E;\n\t\tcin >> x1>>y1>>x2>>y2;\n\t\tS = P(x1, y1);\n\t\tE = P(x2, y2);\n\t\tfor(i=0;i<N;i++){\n\t\t\tcin >> x1>>y1>>x2>>y2>>h;\n\t\t\tP p1 = P(x1,y1);\n\t\t\tP p2 = P(x1,y2);\n\t\t\tP p3 = P(x2,y1);\n\t\t\tP p4 = P(x2,y2);\n\t\t\tdouble l = distanceSS(L(p1, p2), L(S, E));\n\t\t\tif(distanceSS(L(p2, p4), L(S, E)) < l) l = distanceSS(L(p2, p4), L(S, E));\n\t\t\tif(distanceSS(L(p3, p4), L(S, E)) < l) l = distanceSS(L(p3, p4), L(S, E));\n\t\t\tif(distanceSS(L(p1, p3), L(S, E)) < l) l = distanceSS(L(p1, p3), L(S, E));\n\t\t\tdouble a;\n\t\t\tif(l < h) a = l;\n\t\t\telse{\n\t\t\t\ta = (h*h+l*l)/(2*h);\n\t\t\t}\n\t\t\tif(x1 < real(S) && y1 < imag(S) && real(S) < x2 && imag(S) < y2) a = 0;\n\t\t\tMin = min(Min, a);\n\t\t}\n\t\tprintf(\"%.4lf\\n\", Min);\n\t}\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\nnamespace Ps{\n\tconst double EPS = 1e-8;\n\tconst double INF = 1e12;\n\n\ttypedef complex<double> P;\n\t#define X(a) (real(a))\n\t#define Y(a) (imag(a))\n\t\n\t// a×b\n\tdouble cross(const P& a,const P& b){\n\t\treturn imag(conj(a)*b);\n\t}\n\t// a・b\n\tdouble dot(const P&a,const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n\n\t int ccw(const P& a,P b,P c){\n\t\tb -= a; c -= a;\n\t\t  if (cross(b,c) > 0)   return +1;       // counter clockwise\n\t\t  if (cross(b,c) < 0)   return -1;       // clockwise\n\t\t  if (dot(b,c) < 0)     return +2;       // c--a--b on line\n\t\t  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n\t\t  return 0;\n\t  }\n\n}\nusing namespace Ps;\n\nnamespace Ls{\n\tstruct L : public vector<P> {\n\t  L(const P &a, const P &b) {\n\t    push_back(a); push_back(b);\n\t  }\n\t};\n\tbool isIntersectSS(const L &s, const L &t) {\n\t  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n\t}\n\tbool isIntersectSP(const L &s, const P &p) {\n\t  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n\t}\n\t//直線へ射影した時の点\n\tP projection(const L &l, const P &p) {\n\t  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\t  return l[0] + t*(l[0]-l[1]);\n\t}\n\tdouble distanceSP(const L &s, const P &p) {\n\t  const P r = projection(s, p);\n\t  if (isIntersectSP(s, r)) return abs(r - p);\n\t  return min(abs(s[0] - p), abs(s[1] - p));\n\t}\n\tdouble distanceSS(const L &s, const L &t) {\n\t  if (isIntersectSS(s, t)) return 0;\n\t  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n\t}\n}\nusing namespace Ls;\n\nnamespace Polys{\n\ttypedef vector<P> Poly,ConvexPoly;\n\t#define prev(as, i) as[(i-1+as.size())%as.size()]\n\t#define curr(as, i)  as[i]\n\t#define next(as, i) as[(i+1)%as.size()]\n\n\t// verified by ACAC005 C\n\t// http://judge.u-aizu.ac.jp/onlinejudge/creview.jsp?rid=899277&cid=ACAC005\n\tenum { OUT, ON, IN };\n\tint contains(const Poly& ps, const P& p) {\n\t  \tbool in = false;\n\t  \tREP(i,ps.size()){\n\t\t\tP a = curr(ps,i) - p, b = next(ps,i) - p;\n\t\t\tif (Y(a) > Y(b)) swap(a, b);\n\t\t\tif (Y(a) <= 0 && 0 < Y(b))\n\t \t\tif (cross(a, b) < 0) in = !in;\n\t    \t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t  \t}\n\t\treturn in ? IN : OUT;\n\t}\n}\n\nusing namespace Polys;\n\nclass Main{\n\tpublic:\n\n\tint N;\n\tvector<P> ps;\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){\n\t\t\tcin >> N;if(N==0)break;\n\t\t\tdouble sx,sy,ex,ey;cin >> sx >> sy >> ex >> ey;\n\t\t\tL l=L(P(sx,sy),P(ex,ey));\n\t\t\t\n\t\t\tvector<Poly> ps(N,Poly(4));\n\t\t\tvector<double> hs(N);\n\t\t\tREP(i,N){\n\t\t\t\tdouble mx,my,Mx,My,h;cin >> mx>>my >> Mx >> My >> h;\n\t\t\t\tps[i][0]=P(mx,my);ps[i][1]=P(Mx,my);ps[i][2]=P(Mx,My);ps[i][3]=P(mx,My);\n\t\t\t\ths[i]=h;\n\t\t\t}\n\n\t\t\tdouble lr=0,rr=1e16;\n\n\t\t\t//包含チェック\n\t\t\tREP(i,N)if(contains(ps[i],l[0]) || contains(ps[i],l[1]))rr=0;\n\n\t\t\twhile(rr-lr>1e-9){\n\t\t\t\tdouble mr=(lr+rr)/2;\n\n\t\t\t\tbool ok=true;\n\t\t\t\tREP(i,N){\n\t\t\t\t\t// P\n\t\t\t\t\tREP(j,4){\n\t\t\t\t\t\tdouble d=distanceSP(l,ps[i][j]);\n\t\t\t\t\t\tif(mr<d)continue;\n\t\t\t\t\t\tif(mr-sqrt(mr*mr-d*d)<=hs[i])ok=false;\n\t\t\t\t\t}\n\t\t\t\t\t// L\n\t\t\t\t\tREP(j,4){\n\t\t\t\t\t\tdouble d=distanceSS(l,L(ps[i][j],ps[i][(j+1)%4]));\n\t\t\t\t\t\tif(mr<d)continue;\n\t\t\t\t\t\tif(mr-sqrt(mr*mr-d*d)<=hs[i])ok=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok)lr=mr;\n\t\t\t\telse rr=mr;\n\t\t\t}\n\t\t\tcout << lr <<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-9;\ntypedef complex<double> P;\n\nstruct L : public vector<P>{ L(const P &a,const P &b){ push_back(a); push_back(b); } };\n\ndouble cross(const P&a,const P &b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P&a,const P &b){\n\treturn real(conj(a)*b);\n}\n\nint ccw(P a,P b,P c){\n\tb -= a; c-= a;\n\tif( cross(b,c) > 0 ) return +1;\n\tif( cross(b,c) < 0 ) return -1;\n\tif( dot(b,c) < 0 ) return +2;\n\tif( norm(b) < norm(c) ) return -2;\n\treturn 0;\n}\nbool intersectSS(const L&s,const L&t){\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0]) * ccw(t[0],t[1],s[1]) <= 0;\n}\nP projection(const L &l,const P&p){\n\tdouble t = dot(p-l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t * (l[0]-l[1]);\n}\nbool intersectSP(const L&s,const P&p){ return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; }\n\ndouble distanceSP(const L&s,const P&p){\n\tP r = projection(s,p);\n\tif( intersectSP(s,r) ) return abs(r-p);\n\treturn min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble distanceSS(const L &s,const L&t){\n\tif( intersectSS(s,t) ) return 0;\n\treturn min(min(distanceSP(s,t[0]),distanceSP(s,t[1])),min(distanceSP(t,s[0]),distanceSP(t,s[1])));\n}\n\nP in(){\n\tdouble a,b;\n\tcin >> a >> b;\n\treturn P(a,b);\n}\nint main(){\n\tint n;\n\twhile( cin >> n && n ){\n\t\tP s = in();\n\t\tP g = in();\n\t\tbool allOk = 1;\n\t\tvector< pair<double,double> > lim;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x1,y1,x2,y2;\n\t\t\tdouble h;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> h;\n\t\t\tvector<P> p = {P(x1,y1),P(x2,y1),P(x2,y2),P(x1,y2)};\n\t\t\tdouble sub = 1e9;\n\t\t\tint flagS = 0;\n\t\t\tint flagG = 0;\n\t\t\tfor(int j = 0 ; j < p.size() ; j++){\n\t\t\t\tP a = p[j];\n\t\t\t\tP b = p[(j+1)%p.size()];\n\t\t\t\tif( ccw(a,b,s) > 0 ) flagS++;\n\t\t\t\tif( ccw(a,b,g) > 0 ) flagG++;\n\t\t\t\tsub = min(distanceSS(L(a,b),L(s,g)),sub);\n\t\t\t}\n\t\t\tif(flagS == 4 || flagG == 4) allOk = 0;\n\t\t\tlim.push_back(make_pair(h,sub));\n\t\t\t//cout << h << \" \" << sub << endl;\n\t\t}\n\t\tdouble l = 0 , r = 1000000;\n\t\tfor(int _ = 0 ; _ < 128 ; _++){\n\t\t\tdouble R = (l+r) / 2;\n\t\t\tbool flag = 1;\n\t\t\tfor(int j = 0 ; j < lim.size() ; j++){\n\t\t\t\tdouble h = min(R,lim[j].first);\n\t\t\t\tdouble d = R*R-(R-h)*(R-h);\n\t\t\t\td = sqrt(d);\n\t\t\t\tif( lim[j].second < d ) flag = 0;\n\t\t\t\t\n\t\t\t}\n\t\t\tif( allOk && flag ) l = R;\n\t\t\telse r = R;\n\t\t}\n\t\tprintf(\"%.10lf\\n\",l);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define EPS 1e-10\ntypedef struct{\n    double x; double y;\n}Point;\nint n;\nint h[50];\nPoint s,e,ll[50],ul[50],ur[50],lr[50];\n\nint change(int x){\n    if(x>0) return 1;\n    else if(x<0) return -1;\n    else return 0;\n}\nint intersect(Point a,Point b,Point c,Point d){//交差\n    int ta=(c.x-d.x)*(a.y-c.y)+(c.y-d.y)*(c.x-a.x);\n    int tb=(c.x-d.x)*(b.y-c.y)+(c.y-d.y)*(c.x-b.x);\n    int tc=(a.x-b.x)*(c.y-a.y)+(a.y-b.y)*(a.x-c.x);\n    int td=(a.x-b.x)*(d.y-a.y)+(a.y-b.y)*(a.x-d.x);\n    //オーバーフロー\n    ta=change(ta); tb=change(tb); tc=change(tc); td=change(td);\n    return ta*tb<0 && tc*td<0;\n    \n}\ndouble PtoQ(Point p1, Point p2) {\n    return sqrt((p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y));\n}\n//ベクトル外積\ndouble cross_vector(Point vl, Point vr) {\n    return vl.x * vr.y - vl.y * vr.x;\n}\n\n//点Pと線(AB)の距離\ndouble PtoAB(Point P,Point A,Point B ){\n    double a=B.x-A.x;\n    double b=B.y-A.y;\n    double a2=a*a;\n    double b2=b*b;\n    double r2=a2+b2;\n    double tt=-(a*(A.x-P.x)+b*(A.y-P.y));\n    if(tt<0){\n        return sqrt((A.x-P.x)*(A.x-P.x)+(A.y-P.y)*(A.y-P.y));\n    }\n    if( tt > r2 ) {\n        return sqrt((B.x-P.x)*(B.x-P.x) + (B.y-P.y)*(B.y-P.y));\n    }\n    double f1 = a*(A.y-P.y)-b*(A.x-P.x);\n    return sqrt((f1*f1)/r2);\n}\ndouble linetoline(double min,Point a,Point b){//2線分の距離\n    double tmp;\n    if(min>(tmp=PtoAB(a,s,e))) min=tmp;\n    if(min>(tmp=PtoAB(b,s,e))) min=tmp;\n    if(min>(tmp=PtoAB(s,a,b))) min=tmp;\n    if(min>(tmp=PtoAB(e,a,b))) min=tmp;\n    return min;\n}\ndouble distance(int i){//ブロック-直線間\n    double tmp,min=1e10;\n    if(min>(tmp=linetoline(min,ll[i],ul[i]))) min=tmp;\n    if(min>(tmp=linetoline(min,ul[i],ur[i]))) min=tmp;\n    if(min>(tmp=linetoline(min,ur[i],lr[i]))) min=tmp;\n    if(min>(tmp=linetoline(min,lr[i],ll[i]))) min=tmp;\n    //printf(\"min:%f\\n\",min);\n    return min;\n}\ndouble cal(double x,double h){\n    return (x*x+h*h)/(2.0*h);\n}\nint main(void){\n    while(1){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        scanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&e.x,&e.y);\n        /*if(s.x>e.x){\n         Point tmp=s; s=e; e=tmp;\n         }*/\n        double a,b,c,d;\n        for(int i=0;i<n;i++){\n            scanf(\"%lf%lf%lf%lf%d\",&a,&b,&c,&d,&h[i]);\n            ll[i].x=a; ll[i].y=b; ul[i].x=a; ul[i].y=d;\n            ur[i].x=c; ur[i].y=d; lr[i].x=c; lr[i].y=b;\n        }\n        int flag=0;\n        for(int i=0;i<n;i++){//交差判定\n            if(intersect(s,e,ll[i],ul[i])||intersect(s,e,ul[i],ur[i])||\n               intersect(s,e,ur[i],lr[i])||intersect(s,e,lr[i],ll[i])){\n                flag=1; break;\n            }\n            else if((ll[i].x<s.x&&s.x<ur[i].x&&\n                    ll[i].y<s.y&&s.y<ur[i].y)||\n                    (ll[i].x<e.x&&e.x<ur[i].x&&\n                    ll[i].y<e.y&&e.y<ur[i].y)){//内側\n                flag=2; break;\n            }\n        }\n        if(flag) printf(\"0.0000\\n\");\n        else{\n            double min=1e10,tmp;\n            for(int i=0;i<n;i++){\n                tmp=distance(i);\n                if(tmp<h[i]){\n                    if(min>tmp) min=tmp;\n                }\n                else{\n                    if(min>cal(tmp,h[i])) min=cal(tmp,h[i]);\n                }\n            }\n            printf(\"%.4f\\n\",min);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "// Aizu 1157: Roll-A-Big-Ball\n// 2017.9.15 bal4u@uu\n\n#include <stdio.h>\n#include <math.h>\n\n#define INF 1e8\n\ntypedef struct { long long x, y; } PP;\ntypedef struct { long long x[5], y[5], h; } BK;\nBK blk[52];\nPP sg[2];\n\nint isPointonSegment(long long x, long long y, long long x1, long long y1, long long x2, long long y2)\n{\n    long long d;\n    if (x1 > x2) d = x1, x1 = x2, x2 = d;\n    if (y1 > y2) d = y1, y1 = y2, y2 = d;\n    return (x1 <= x && x <= x2 && y1 <= y && y <= y2 &&\n           (y-y1)*(x2-x1) == (y2-y1)*(x-x1));\n}\n\nint crossSegments(long long x11, long long y11, long long x12, long long y12,\n                  long long x21, long long y21, long long x22, long long y22)\n{\n    long long s11, s12, s21, s22;\n    int r = 0;\n\n    s11 = (x22-x21) * (y11-y21) + (y22-y21) * (x21-x11);\n    s12 = (x22-x21) * (y12-y21) + (y22-y21) * (x21-x12);\n    s21 = (x12-x11) * (y21-y11) + (y12-y11) * (x11-x21);\n    s22 = (x12-x11) * (y22-y11) + (y12-y11) * (x11-x22);\n    if      (s11 == 0) { if (r == 0) r = isPointonSegment(x11, y11, x21, y21, x22, y22);}\n    else if (s12 == 0) { if (r == 0) r = isPointonSegment(x12, y12, x21, y21, x22, y22);}\n    else if (s21 == 0) { if (r == 0) r = isPointonSegment(x21, y21, x11, y11, x12, y12);}\n    else if (s22 == 0) { if (r == 0) r = isPointonSegment(x22, y22, x11, y11, x12, y12);}\n    else {\n        r = ((s11 <= 0 && s12 >= 0) || (s11 >= 0 && s12 <= 0)) &&\n            ((s21 <= 0 && s22 >= 0) || (s21 >= 0 && s22 <= 0));\n    }\n    return r;\n}\n\nint insidePolygon(long long x, long long y, long long *xx, long long *yy)\n{\n\tlong long i, j, k;\n\tlong long sa, sb;\n\n\tk = 0;\n\tfor (i = 1, j = 2; j < 4; i++, j++) {\n\t    sa = (xx[i]-xx[k]) * (y    -yy[k]) + (yy[i]-yy[k]) * (xx[k]-x    );\n\t\tsb = (xx[i]-xx[k]) * (yy[j]-yy[k]) + (yy[i]-yy[k]) * (xx[k]-xx[j]);\n\t\tif (sa*sb <= 0) continue;\n\n\t\tsa = (xx[j]-xx[i]) * (y    -yy[i]) + (yy[j]-yy[i]) * (xx[i]-x    );\n\t\tsb = (xx[j]-xx[i]) * (yy[k]-yy[i]) + (yy[j]-yy[i]) * (xx[i]-xx[k]);\n\t\tif (sa*sb <= 0) continue;\n\n\t    sa = (xx[k]-xx[j]) * (y    -yy[j]) + (yy[k]-yy[j]) * (xx[j]-x    );\n\t\tsb = (xx[k]-xx[j]) * (yy[i]-yy[j]) + (yy[k]-yy[j]) * (xx[j]-xx[i]);\n\t\tif (sa*sb <= 0) continue;\n\t    return 1;\n\t}\n\treturn 0;\n}\n\ndouble point2point(long long x1, long long y1, long long x2, long long y2)\n{\n\tlong long dx, dy;\n\n\tdx = x2 - x1, dy = y2 - y1;\n\treturn sqrt((double)(dx * dx + dy * dy));\n}\n\ndouble point2line(long long x, long long y, long long sx, long long sy,\n\t\t\t\t  long long ex, long long ey, int *onseg)\n{\n   long long us, ub;\n   double xx, yy;\n \n   us = ( x - sx) * (ex - sx) + ( y - sy) * (ey - sy);\n   ub = (ex - sx) * (ex - sx) + (ey - sy) * (ey - sy);\n \n   /* closest point falls within the line segment */\n   *onseg = (us >= 0 && us <= ub);\n\n   if      (us == 0)  xx = (double)sx, yy = (double)sy; \n   else if (us == ub) xx = (double)ex, yy = (double)ey;\n   else {\n      xx = sx + (ex - sx) * (double)us / (double)ub;\n      yy = sy + (ey - sy) * (double)us / (double)ub;\n   }\n   return sqrt((x - xx)*(x - xx) + (y - yy)*(y - yy));\n}\n\nint main()\n{\n\tint n, i, j, k, onseg;\n\tdouble dist, t, r, ans;\n\n\twhile (scanf(\"%d\", &n) && n) {\n\t\tscanf(\"%lld%lld%lld%lld\", &sg[0].x, &sg[0].y, &sg[1].x, &sg[1].y);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tlong long x1, y1, x2, y2;\n\t\t\tscanf(\"%lld%lld%lld%lld%lld\", &x1, &y1, &x2, &y2, &blk[i].h);\n\t\t\tblk[i].x[0] = x1, blk[i].y[0] = y1,\tblk[i].x[1] = x2, blk[i].y[1] = y1,\n\t\t\tblk[i].x[2] = x2, blk[i].y[2] = y2, blk[i].x[3] = x1, blk[i].y[3] = y2,\n\t\t\tblk[i].x[4] = x1, blk[i].y[4] = y1;\n\t\t}\n\t\tans = INF;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tdist = INF;\n\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\tif (crossSegments(sg[0].x, sg[0].y, sg[1].x, sg[1].y, \n\t\t\t\t\tblk[i].x[j], blk[i].y[j], blk[i].x[j+1], blk[i].y[j+1])) goto NG;\n\t\t\tfor (k = 0; k < 2; k++)\n\t\t\t\tif (insidePolygon(sg[k].x, sg[k].y, blk[i].x, blk[i].y)) goto NG;\n\n\t\t\tfor (k = 0; k < 2; k++) for (j = 0; j < 4; j++) {\n\t\t\t\tt = point2line(sg[k].x, sg[k].y,\n\t\t\t\t\tblk[i].x[j], blk[i].y[j], blk[i].x[j+1], blk[i].y[j+1], &onseg);\n\t\t\t\tif (onseg && t < dist) dist = t;\n\t\t\t}\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tt = point2line(blk[i].x[j], blk[i].y[j], sg[0].x, sg[0].y, sg[1].x, sg[1].y, &onseg);\n\t\t\t\tif (onseg && t < dist) dist = t;\n\t\t\t}\n\t\t\tfor (k = 0; k < 2; k++) for (j = 0; j < 4; j++) {\n\t\t\t\tt = point2point(sg[k].x, sg[k].y, blk[i].x[j], blk[i].y[j]);\n\t\t\t\tif (t < dist) dist = t;\n\t\t\t}\n\t\t\tif (dist <= blk[i].h) r = dist;\n\t\t\telse r = (blk[i].h*blk[i].h + dist*dist)/(2*blk[i].h);\n\t\t\tif (r < ans) ans = r;\n\t\t}\n\t\tprintf(\"%.8lf\\n\", ans);\n\t\tcontinue;\nNG:\t\tputs(\"0\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint sx = in.nextInt();\n\t\t\tint sy = in.nextInt();\n\t\t\tint ex = in.nextInt();\n\t\t\tint ey = in.nextInt();\n\t\t\tPos s = new Pos(sx, sy);\n\t\t\tPos e = new Pos(ex, ey);\n\t\t\tArrayList<Pos> list = new ArrayList<Pos>();\n\t\t\tboolean zero = false;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint lx = in.nextInt();\n\t\t\t\tint ly = in.nextInt();\n\t\t\t\tint rx = in.nextInt();\n\t\t\t\tint ry = in.nextInt();\n\t\t\t\tint h = in.nextInt();\n\t\t\t\tif(zero) continue;\n\t\t\t\tPos[] p = {\n\t\t\t\t\t\tnew Pos(lx, ly),\n\t\t\t\t\t\tnew Pos(lx, ry),\n\t\t\t\t\t\tnew Pos(rx, ry),\n\t\t\t\t\t\tnew Pos(rx, ly),\n\t\t\t\t};\n\t\t\t\tdouble minLen = 100000000;\n\t\t\t\tdouble sign = 0;\n\t\t\t\tboolean inter = true;\n\t\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t\tif(cross(p[j], p[(j+1)%4], s, e)){\n\t\t\t\t\t\tzero = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdouble l = Math.abs(dist(s, e, p[j]));\n\t\t\t\t\tl = Math.min(l, Math.abs(sign = dist(p[j], p[(j+1)%4], s)));\n\t\t\t\t\tl = Math.min(l, Math.abs(dist(p[j], p[(j+1)%4], e)));\n\t\t\t\t\tminLen = Math.min(minLen, l);\n\t\t\t\t\tif(sign < 0 || minLen == 0) inter = false;\n\t\t\t\t}\n\t\t\t\tif(inter) zero = true;\n\t\t\t\tlist.add(new Pos(minLen, h));\n\t\t\t}\n\t\t\tif(zero){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.println(binarySearch(list));\n\t\t}\n\t}\n\t\n\tpublic static final int times = 5000;\n\tpublic static double binarySearch(ArrayList<Pos> list){\n\t\tdouble max = 1000;\n\t\tdouble min = 0;\n\t\tdouble mid = 0;\n\t\tfor(int i=0; i<times; i++){\n\t\t\tmid = (max+min)/2;\n\t\t\tif(check(mid, list)){\n\t\t\t\tmin = mid;\n\t\t\t}else{\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\t\n\tpublic static boolean check(double r, ArrayList<Pos> list){\n\t\tfor(Pos p: list){\n\t\t\tdouble h = p.y;\n\t\t\tif(h > r) h = r;\n\t\t\tPos o = new Pos(0, r);\n\t\t\tif(o.dist2(p) < r*r) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static double triarea(Pos a, Pos b, Pos c){\n\t\tdouble dx1 = b.x - a.x;\n\t\tdouble dy1 = b.y - a.y;\n\t\tdouble dx2 = c.x - a.x;\n\t\tdouble dy2 = c.y - a.y;\n\t\treturn dx1*dy2 - dx2*dy1;\n\t}\n\t\n\tpublic static boolean cross(Pos a1, Pos a2, Pos b1, Pos b2){\n\t\treturn triarea(a1, a2, b1)*triarea(a1, a2, b2) <= 0\n\t\t\t\t&& triarea(b1, b2, a1)*triarea(b1, b2, a2) <= 0;\n\t}\n\t\n\tpublic static double dist(Pos a, Pos b, Pos c){\n\t\t// a->b ??¨ c??¨????????¢\n\t\tif(dot(b.x-a.x, b.y-a.y, c.x-a.x, c.y-a.y) <= 0)\n\t\t\treturn Math.sqrt(a.dist2(c));\n\t\tif(dot(a.x-b.x, a.y-b.y, c.x-b.x, c.y-b.y) <= 0)\n\t\t\treturn Math.sqrt(b.dist2(c));\n\t\treturn triarea(a, b, c)/Math.sqrt(a.dist2(b));\n\t}\n\t\n\tpublic static double dot(double x, double y, double x1, double y2){\n\t\treturn x*x1 + y*y2;\n\t}\n\t\n\tpublic static double dot(Pos a, Pos b){\n\t\treturn a.x*b.x + a.y*b.y;\n\t}\n}\n\nclass Pos{\n\tdouble x, y;\n\tpublic Pos(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic double dist2(Pos p){\n\t\treturn (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static double EPS = 1e-9;\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint sx = in.nextInt();\n\t\t\tint sy = in.nextInt();\n\t\t\tint ex = in.nextInt();\n\t\t\tint ey = in.nextInt();\n\t\t\tPos s = new Pos(sx, sy);\n\t\t\tPos e = new Pos(ex, ey);\n\t\t\tArrayList<Pos> list = new ArrayList<Pos>();\n\t\t\tboolean zero = false;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint lx = in.nextInt();\n\t\t\t\tint ly = in.nextInt();\n\t\t\t\tint rx = in.nextInt();\n\t\t\t\tint ry = in.nextInt();\n\t\t\t\tint h = in.nextInt();\n\t\t\t\tif(zero) continue;\n\t\t\t\tPos[] p = {\n\t\t\t\t\t\tnew Pos(lx, ly),\n\t\t\t\t\t\tnew Pos(lx, ry),\n\t\t\t\t\t\tnew Pos(rx, ry),\n\t\t\t\t\t\tnew Pos(rx, ly),\n\t\t\t\t};\n\t\t\t\tdouble minLen = 100000000;\n\t\t\t\tdouble sign = 0;\n\t\t\t\tboolean inter = true;\n\t\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t\tif(cross(p[j], p[(j+1)%4], s, e)){\n\t\t\t\t\t\tzero = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdouble l = Math.abs(dist(s, e, p[j]));\n\t\t\t\t\tl = Math.min(l, Math.abs(sign = dist(p[j], p[(j+1)%4], s)));\n\t\t\t\t\tl = Math.min(l, Math.abs(dist(p[j], p[(j+1)%4], e)));\n\t\t\t\t\t\n\t\t\t\t\tminLen = Math.min(minLen, l);\n\t\t\t\t\tif(sign > 0) inter = false;\n\t\t\t\t}\n\t\t\t\tif(inter || minLen < EPS) zero = true;\n\t\t\t\tlist.add(new Pos(minLen, h));\n\t\t\t\t\n\t\t\t}\n\t\t\tif(zero){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.println(binarySearch(list));\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n\tpublic static final int times = 5000;\n\tpublic static double binarySearch(ArrayList<Pos> list){\n\t\tdouble max = 1000;\n\t\tdouble min = 0;\n\t\tdouble mid = 0;\n\t\tfor(int i=0; i<times; i++){\n\t\t\tmid = (max+min)/2;\n\t\t\tif(check(mid, list)){\n\t\t\t\tmin = mid;\n\t\t\t}else{\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\t\n\tpublic static boolean check(double r, ArrayList<Pos> list){\n\t\tfor(Pos p: list){\n\t\t\tdouble h = p.y;\n\t\t\tif(h > r) h = r;\n\t\t\tPos o = new Pos(0, r);\n\t\t\tif(o.dist2(p, h) < r*r) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static double triarea(Pos a, Pos b, Pos c){\n\t\tdouble dx1 = b.x - a.x;\n\t\tdouble dy1 = b.y - a.y;\n\t\tdouble dx2 = c.x - a.x;\n\t\tdouble dy2 = c.y - a.y;\n\t\treturn dx1*dy2 - dx2*dy1;\n\t}\n\t\n\tpublic static boolean cross(Pos a1, Pos a2, Pos b1, Pos b2){\n\t\tif(cross(a1.x-a2.x, a1.y-a2.y, b1.x-b2.x, b1.y-b2.y)==0\n\t\t\t\t&& cross(a1.x-a2.x, a1.y-a2.y, a1.x-b2.x, a1.y-b2.y)==0){\n\t\t\tif(Math.abs(a1.dist2(b1)+a2.dist2(b1) - a1.dist2(a2)) < EPS\n\t\t\t\t\t|| Math.abs(a1.dist2(b2)+a2.dist2(b2) - a1.dist2(a2)) < EPS){\n\t\t\t\treturn true;\n\t\t\t}else return false;\n\t\t}\n\t\treturn triarea(a1, a2, b1)*triarea(a1, a2, b2) <= 0\n\t\t\t\t&& triarea(b1, b2, a1)*triarea(b1, b2, a2) <= 0;\n\t}\n\t\n\tpublic static double cross(double x1, double y1, double x2, double y2){\n\t\treturn x1*y2 - x2*y1;\n\t}\n\t\n\tpublic static double dist(Pos a, Pos b, Pos c){\n\t\t// a->b ??¨ c??¨????????¢\n\t\tif(dot(b.x-a.x, b.y-a.y, c.x-a.x, c.y-a.y) < EPS)\n\t\t\treturn Math.sqrt(a.dist2(c));\n\t\tif(dot(a.x-b.x, a.y-b.y, c.x-b.x, c.y-b.y) < EPS)\n\t\t\treturn Math.sqrt(b.dist2(c));\n\t\treturn triarea(a, b, c)/Math.sqrt(a.dist2(b));\n\t}\n\t\n\tpublic static double dot(double x, double y, double x1, double y2){\n\t\treturn x*x1 + y*y2;\n\t}\n\t\n\tpublic static double dot(Pos a, Pos b){\n\t\treturn a.x*b.x + a.y*b.y;\n\t}\n}\n\nclass Pos{\n\tdouble x, y;\n\tpublic Pos(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic double dist2(Pos p){\n\t\treturn (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n\t}\n\t\n\tpublic double dist2(Pos p, double h){\n\t\treturn (x-p.x)*(x-p.x) + (y-h)*(y-h);\n\t}\n}\n//\n//class Stage extends Drawable{\n//\tPos[][] rect;\n//\tPos[] use;\n//\tPos s, e;\n//\tpublic Stage(Pos[][] rect, Pos s, Pos e, Pos[] use) {\n//\t\tthis.rect = rect;\n//\t\tthis.s = s;\n//\t\tthis.e = e;\n//\t\tthis.use = use;\n//\t}\n//\t\n//\t@Override\n//\tpublic void draw(Graphics g) {\n//\t\tg.setColor(Color.WHITE);\n//\t\tfor(int i=0; i<rect.length; i++){\n//\t\t\tfor(int j=0; j<rect[i].length; j++){\n//\t\t\t\tPos p1 = rect[i][j];\n//\t\t\t\tPos p2 = rect[i][(j+1)%rect[i].length];\n////\t\t\t\tg.fillOval(p(p1.x), p(p1.y), 5, 5);\n//\t\t\t\tg.drawLine(px(p1.x), py(p1.y), px(p2.x), py(p2.y));\n//\t\t\t}\n//\t\t}\n//\t\tg.drawLine(px(s.x), py(s.y), px(e.x), py(e.y));\n//\t\tg.setColor(Color.CYAN);\n//\t\tfor(int i=0; i<use.length; i++){\n//\t\t\tPos p1 = use[i];\n//\t\t\tg.fillOval(px(p1.x), py(p1.y), 2, 2);\n//\t\t}\n//\t}\n//}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Roll-A-Big-Ball\npublic class Main{\n\n\tdouble EPS = 1.0e-8;\n\tdouble norm(Point p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\tdouble inp(Point p1, Point p2) {\n\t\treturn p1.x*p2.x + p1.y*p2.y;\n\t}\n\tdouble extp(Point p1, Point p2) {\n\t\treturn p1.x*p2.y - p2.x*p1.y;\n\t}\n\tPoint sub(Point p1, Point p2) {\n\t\treturn new Point(p1.x-p2.x, p1.y-p2.y);\n\t}\n\tPoint proj(Line l, Point p) {\n\t\tdouble t = inp(sub(p, l.s), sub(l.s, l.t)) / Math.pow(norm(sub(l.s, l.t)),2);\n\t\tPoint tp = sub(l.s, l.t);\n\t\treturn new Point(l.s.x + t*tp.x, l.s.y + t*tp.y);\n\t}\n\tint ccw(Point a, Point b, Point c) {\n\t\tPoint p = sub(b, a);\n\t\tPoint q = sub(c, a);\n\t\tif(extp(p, q) > EPS) return 1;\t\t// counter clockwise\n\t\tif(extp(p, q) < -EPS)return -1;\t\t// clockwise\n\t\tif(inp(p, q) < -EPS) return 2;\t\t// c--a--b on line\n\t\tif(Math.abs(norm(p) - norm(q)) < EPS) return -2;\t// a--b--c on line\n\t\treturn 0;\t\t\t\t// a--c--b(or a--c=b) on line \n\t}\n\tboolean intersectSS(Line s, Line t) {\n\t\treturn ccw(s.s,s.t,t.s)*ccw(s.s,s.t,t.t) <= 0 &&\n\t\t       ccw(t.s,t.t,s.s)*ccw(t.s,t.t,s.t) <= 0;\n\t}\n\tboolean intersectSP(Line s, Point p) {\n\t\treturn ccw(s.s, s.t, p) == 0;\n\t}\n\tdouble distanceSP(Line s, Point p) {\n\t\tPoint r = proj(s, p);\n\t\tif (intersectSP(s, r)) return norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.s, p)), norm(sub(s.t, p)));\n\t}\n\tdouble distanceSS(Line s, Line t) {\n\t\tif (intersectSS(s, t)) return 0;\n\t\treturn Math.min(Math.min(distanceSP(s, t.s), distanceSP(s, t.t)),\n\t            Math.min(distanceSP(t, s.s), distanceSP(t, s.t)));\n\t}\n\tclass Point {\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic Point(double x_, double y_) {\n\t\t\tx = x_; y=y_;\n\t\t}\n\t}\n\tclass Line {\n\t\tpublic Point s,t;\n\t\tpublic Line(Point s_, Point t_) {\n\t\t\ts = s_; t = t_;\n\t\t}\n\t}\n\tboolean in(Point p, Point[] v){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tPoint v1 = sub(v[(i+1)%4], v[i]);\n\t\t\tPoint v2 = sub(p, v[i]);\n\t\t\tif(extp(v1, v2)<=EPS)return false;\n\t\t}\n\t\treturn true;\n\t}\n\tdouble dist(Point s, Point t, Point[] v){\n\t\tdouble res = 1<<29;\n\t\tLine line = new Line(s, t);\n\t\tLine rev = new Line(t, s);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tLine l = new Line(v[i], v[(i+1)%4]);\n\t\t\tLine rl = new Line(v[(i+1)%4], v[i]);\n\t\t\tdouble d = Math.max(distanceSS(line, l), Math.max(distanceSS(rev, l), Math.max(distanceSS(line, rl), distanceSS(rev, rl))));\n//\t\t\tSystem.out.println(\"I:\"+i+\" Dist:\"+d);\n\t\t\tres = Math.min(res, d);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tPoint start = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tPoint end = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tPoint[][] p = new Point[n][4];\n\t\t\tdouble R = 1000;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();\n\t\t\t\tdouble h = sc.nextDouble();\n\t\t\t\tp[i][0] = new Point(x1, y1);\n\t\t\t\tp[i][1] = new Point(x2, y1);\n\t\t\t\tp[i][2] = new Point(x2, y2);\n\t\t\t\tp[i][3] = new Point(x1, y2);\n\t\t\t\tif(in(start, p[i])||in(end, p[i])){\n\t\t\t\t\tR = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble d = dist(start, end, p[i]);\n//\t\t\t\t\tSystem.out.println(\"D:\" + d + \" Val:\" + (h<=d?((d*d+h*h)/2/h):d));\n\t\t\t\t\tif(h<d)R = Math.min(R, (d*d+h*h)/2/h);\n\t\t\t\t\telse R = Math.min(R, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.7f\\n\", R);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Roll-A-Big-Ball\npublic class Main{\n\n\tdouble EPS = 1.0e-8;\n\tdouble norm(Point p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\tdouble inp(Point p1, Point p2) {\n\t\treturn p1.x*p2.x + p1.y*p2.y;\n\t}\n\tdouble extp(Point p1, Point p2) {\n\t\treturn p1.x*p2.y - p2.x*p1.y;\n\t}\n\tPoint sub(Point p1, Point p2) {\n\t\treturn new Point(p1.x-p2.x, p1.y-p2.y);\n\t}\n\tPoint proj(Line l, Point p) {\n\t\tdouble t = inp(sub(p, l.s), sub(l.s, l.t)) / Math.pow(norm(sub(l.s, l.t)),2);\n\t\tPoint tp = sub(l.s, l.t);\n\t\treturn new Point(l.s.x + t*tp.x, l.s.y + t*tp.y);\n\t}\n\tint ccw(Point a, Point b, Point c) {\n\t\tPoint p = sub(b, a);\n\t\tPoint q = sub(c, a);\n\t\tif(extp(p, q) > EPS) return 1;\t\t// counter clockwise\n\t\tif(extp(p, q) < -EPS)return -1;\t\t// clockwise\n\t\tif(inp(p, q) < -EPS) return 2;\t\t// c--a--b on line\n\t\tif(Math.abs(norm(p) - norm(q)) < EPS) return -2;\t// a--b--c on line\n\t\treturn 0;\t\t\t\t// a--c--b(or a--c=b) on line \n\t}\n\tboolean intersectSS(Line s, Line t) {\n\t\treturn ccw(s.s,s.t,t.s)*ccw(s.s,s.t,t.t) <= 0 &&\n\t\t       ccw(t.s,t.t,s.s)*ccw(t.s,t.t,s.t) <= 0;\n\t}\n\tboolean intersectSP(Line s, Point p) {\n\t\treturn ccw(s.s, s.t, p) == 0;\n\t}\n\tdouble distanceSP(Line s, Point p) {\n\t\tPoint r = proj(s, p);\n\t\tif (intersectSP(s, r)) return norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.s, p)), norm(sub(s.t, p)));\n\t}\n\tdouble distanceSS(Line s, Line t) {\n\t\tif (intersectSS(s, t)) return 0;\n\t\treturn Math.min(Math.min(distanceSP(s, t.s), distanceSP(s, t.t)),\n\t            Math.min(distanceSP(t, s.s), distanceSP(t, s.t)));\n\t}\n\tclass Point {\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic Point(double x_, double y_) {\n\t\t\tx = x_; y=y_;\n\t\t}\n\t}\n\tclass Line {\n\t\tpublic Point s,t;\n\t\tpublic Line(Point s_, Point t_) {\n\t\t\ts = s_; t = t_;\n\t\t}\n\t}\n\tboolean in(Point p, Point[] v){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tPoint v1 = sub(v[(i+1)%4], v[i]);\n\t\t\tPoint v2 = sub(p, v[i]);\n\t\t\tif(extp(v1, v2)<=EPS)return false;\n\t\t}\n\t\treturn true;\n\t}\n\tdouble dist(Point s, Point t, Point[] v){\n\t\tdouble res = 1<<29;\n\t\tLine line = new Line(s, t);\n\t\tLine rev = new Line(t, s);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tLine l = new Line(v[i], v[(i+1)%4]);\n\t\t\tLine rl = new Line(v[(i+1)%4], v[i]);\n\t\t\tdouble d = Math.max(distanceSS(line, l), Math.max(distanceSS(rev, l), Math.max(distanceSS(line, rl), distanceSS(rev, rl))));\n\t\t\td = Math.max(d, Math.max(distanceSS(l, line), Math.max(distanceSS(l, rev), Math.max(distanceSS(rl, line), distanceSS(rl, rev)))));\n//\t\t\tSystem.out.println(\"I:\"+i+\" Dist:\"+d);\n\t\t\tres = Math.min(res, d);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tPoint start = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tPoint end = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tPoint[][] p = new Point[n][4];\n\t\t\tdouble R = 1000;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();\n\t\t\t\tdouble h = sc.nextDouble();\n\t\t\t\tp[i][0] = new Point(x1, y1);\n\t\t\t\tp[i][1] = new Point(x2, y1);\n\t\t\t\tp[i][2] = new Point(x2, y2);\n\t\t\t\tp[i][3] = new Point(x1, y2);\n\t\t\t\tif(in(start, p[i])||in(end, p[i])){\n\t\t\t\t\tR = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble d = dist(start, end, p[i]);\n//\t\t\t\t\tSystem.out.println(\"D:\" + d + \" Val:\" + (h<=d?((d*d+h*h)/2/h):d));\n\t\t\t\t\tif(h<d)R = Math.min(R, (d*d+h*h)/2/h);\n\t\t\t\t\telse R = Math.min(R, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.7f\\n\", R);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint sx = in.nextInt();\n\t\t\tint sy = in.nextInt();\n\t\t\tint ex = in.nextInt();\n\t\t\tint ey = in.nextInt();\n\t\t\tPos s = new Pos(sx, sy);\n\t\t\tPos e = new Pos(ex, ey);\n\t\t\tdouble len = Math.sqrt(s.dist2(e));\n\t\t\tArrayList<Pos> list = new ArrayList<Pos>();\n\t\t\tboolean zero = false;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint lx = in.nextInt();\n\t\t\t\tint ly = in.nextInt();\n\t\t\t\tint rx = in.nextInt();\n\t\t\t\tint ry = in.nextInt();\n\t\t\t\tint h = in.nextInt();\n\t\t\t\tif(zero) continue;\n\t\t\t\tPos[] p = {\n\t\t\t\t\t\tnew Pos(lx, ly),\n\t\t\t\t\t\tnew Pos(lx, ry),\n\t\t\t\t\t\tnew Pos(rx, ry),\n\t\t\t\t\t\tnew Pos(rx, ly),\n\t\t\t\t};\n\t\t\t\tdouble minLen = 100000000;\n\t\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t\tif(cross(p[j], p[(j+1)%4], s, e)){\n\t\t\t\t\t\tzero = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdouble l = Math.abs(dist(s, e, p[j]));\n\t\t\t\t\tl = Math.min(l, Math.abs(dist(p[j], p[(j+1)%4], s)));\n\t\t\t\t\tl = Math.min(l, Math.abs(dist(p[j], p[(j+1)%4], e)));\n\t\t\t\t\tminLen = Math.min(minLen, l);\n\t\t\t\t}\n\t\t\t\tif(cross(p[0], p[2], s, e) || cross(p[1], p[3], s, e))\n\t\t\t\t\tzero = true;\n\t\t\t\tlist.add(new Pos(minLen, h));\n\t\t\t}\n\t\t\tif(zero){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.println(binarySearch(list));\n\t\t}\n\t}\n\t\n\tpublic static final int times = 1000;\n\tpublic static double binarySearch(ArrayList<Pos> list){\n\t\tdouble max = 1000;\n\t\tdouble min = 0;\n\t\tdouble mid = 0;\n\t\tfor(int i=0; i<times; i++){\n\t\t\tmid = (max+min)/2;\n\t\t\tif(check(mid, list)){\n\t\t\t\tmin = mid;\n\t\t\t}else{\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\t\n\tpublic static boolean check(double r, ArrayList<Pos> list){\n\t\tfor(Pos p: list){\n\t\t\tdouble h = p.y;\n\t\t\tif(h > r) h = r;\n\t\t\tPos o = new Pos(0, r);\n\t\t\tif(o.dist2(p) < r*r) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static double triarea(Pos a, Pos b, Pos c){\n\t\tdouble dx1 = b.x - a.x;\n\t\tdouble dy1 = b.y - a.y;\n\t\tdouble dx2 = c.x - a.x;\n\t\tdouble dy2 = c.y - a.y;\n\t\treturn dx1*dy2 - dx2*dy1;\n\t}\n\t\n\tpublic static boolean cross(Pos a1, Pos a2, Pos b1, Pos b2){\n\t\treturn triarea(a1, a2, b1)*triarea(a1, a2, b2) <= 0\n\t\t\t\t&& triarea(b1, b2, a1)*triarea(b1, b2, a2) <= 0;\n\t}\n\t\n\tpublic static double dist(Pos a, Pos b, Pos c){\n\t\t// a->b ??¨ c??¨????????¢\n\t\tif(dot(b.x-a.x, b.y-a.y, c.x-a.x, c.y-a.y) <= 0)\n\t\t\treturn Math.sqrt(a.dist2(c));\n\t\tif(dot(a.x-b.x, a.y-b.y, c.x-b.x, c.y-b.y) <= 0)\n\t\t\treturn Math.sqrt(b.dist2(c));\n\t\treturn triarea(a, b, c)/Math.sqrt(a.dist2(b));\n\t}\n\t\n\tpublic static double dot(double x, double y, double x1, double y2){\n\t\treturn x*x1 + y*y2;\n\t}\n\t\n\tpublic static double dot(Pos a, Pos b){\n\t\treturn a.x*b.x + a.y*b.y;\n\t}\n}\n\nclass Pos{\n\tdouble x, y;\n\tpublic Pos(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic double dist2(Pos p){\n\t\treturn (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\t\n\t\t\tif(N == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int start_x = sc.nextInt();\n\t\t\tfinal int start_y = sc.nextInt();\n\t\t\tfinal int end_x = sc.nextInt();\n\t\t\tfinal int end_y = sc.nextInt();\n\t\t\t\n\t\t\tPoint2D start = new Point2D(start_x, start_y);\n\t\t\tPoint2D end = new Point2D(end_x, end_y);\n\t\t\t\n\t\t\tdouble[] dist = new double[N];\n\t\t\tdouble[] high = new double[N];\n\t\t\t\n\t\t\tfinal int seg_box_min_x = Math.min(start_x, end_x);\n\t\t\tfinal int seg_box_max_x = Math.max(start_x, end_x);\n\t\t\tfinal int seg_box_min_y = Math.min(start_y, end_y);\n\t\t\tfinal int seg_box_max_y = Math.max(start_y, end_y);\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfinal int minx = sc.nextInt();\n\t\t\t\tfinal int miny = sc.nextInt();\n\t\t\t\tfinal int maxx = sc.nextInt();\n\t\t\t\tfinal int maxy = sc.nextInt();\n\t\t\t\tfinal int h = sc.nextInt();\n\t\t\t\t\n\t\t\t\tPoint2D[] box = new Point2D[]{\n\t\t\t\t\t\tnew Point2D(minx, miny),\n\t\t\t\t\t\tnew Point2D(maxx, miny),\n\t\t\t\t\t\tnew Point2D(maxx, maxy),\n\t\t\t\t\t\tnew Point2D(minx, maxy),\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tdouble d = Double.MAX_VALUE;\n\t\t\t\tif(maxx >= seg_box_max_x && maxy >= seg_box_max_y && minx <= seg_box_min_x && miny <= seg_box_min_y){\n\t\t\t\t\td = 0;\n\t\t\t\t}\n\t\t\t\tfor(int pos = 0; pos < box.length; pos++){\n\t\t\t\t\tint next = (pos + 1) % box.length;\n\t\t\t\t\t\n\t\t\t\t\td = Math.min(d, Point2D.ss_dist(box[pos], box[next], start, end));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//System.out.println(d + \" \" + h);\n\t\t\t\t\n\t\t\t\tdist[i] = d;\n\t\t\t\thigh[i] = h;\n\t\t\t}\n\t\t\t\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(dist[i] < high[i]){\n\t\t\t\t\tmin = Math.min(min, dist[i]);\n\t\t\t\t}else{\n\t\t\t\t\tmin = Math.min(min, (dist[i] * dist[i] + high[i] * high[i]) / (2 * high[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\n\tpublic static final double EPS = 1e-9;\n\n\tpublic Point2D(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic Point2D(Point2D point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\n\tpublic String toString() {\n\t\treturn x + \",\" + y;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (o instanceof Point2D) {\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\tif (this.x - EPS < another.x && this.x + EPS > another.x\n\t\t\t\t\t&& this.y - EPS < another.y && this.y + EPS > another.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\n\t\t\t// return this.x == another.x && this.y == another.y;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic Point2D add(double x, double y) {\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\n\tpublic Point2D sub(double x, double y) {\n\t\treturn add(-x, -y);\n\t}\n\n\tpublic Point2D add(Point2D another) {\n\t\treturn add(another.x, another.y);\n\t}\n\n\tpublic Point2D sub(Point2D another) {\n\t\treturn sub(another.x, another.y);\n\t}\n\n\tpublic Point2D mul(double d) {\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\n\tpublic Point2D div(double d) {\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\n\tpublic double dot(double x, double y) {\n\t\treturn this.x * x + this.y * y;\n\t}\n\n\tpublic double dot(Point2D another) {\n\t\treturn dot(another.x, another.y);\n\t}\n\n\tpublic double cross(double x, double y) {\n\t\treturn this.x * y - this.y * x;\n\t}\n\n\tpublic double cross(Point2D another) {\n\t\treturn cross(another.x, another.y);\n\t}\n\n\tpublic double dist(double x, double y) {\n\t\treturn Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n\t\t\t\t* (this.y - y));\n\t}\n\n\tpublic double dist(Point2D another) {\n\t\treturn dist(another.x, another.y);\n\t}\n\n\tpublic double dist_o() {\n\t\treturn dist(0, 0);\n\t}\n\n\tpublic Point2D unit() {\n\t\treturn div(dist_o());\n\t}\n\n\tpublic boolean pol(Point2D start, Point2D end) {\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\n\tpublic boolean pos(Point2D start, Point2D end) {\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\n\tpublic double pld(Point2D start, Point2D end) {\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))\n\t\t\t\t/ end.sub(start).dist_o());\n\t}\n\n\tpublic double psd(Point2D start, Point2D end) {\n\t\tif (end.sub(start).dot(this.sub(start)) < EPS) {\n\t\t\treturn this.dist(start);\n\t\t} else if (start.sub(end).dot(this.sub(end)) < EPS) {\n\t\t\treturn this.dist(end);\n\t\t} else {\n\t\t\treturn Math.abs(end.sub(start).cross(this.sub(start)) / end.dist(start));\n\t\t}\n\t}\n\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n\t\t\t\t&& (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n\t}\n\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n\t\t\tdouble r2) {\n\t\tdouble dis = p1.dist(p2);\n\n\t\tif (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n\t\t\treturn new Point2D[0]; // same\n\t\t}\n\n\t\tif (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis + EPS > r1 + r2) {\n\t\t\treturn new Point2D[0]; // out\n\t\t}\n\n\t\tdouble dis_m = Math.abs(r1 - r2);\n\n\t\tif (dis_m + EPS > dis && dis_m - EPS < dis) {\n\t\t\tPoint2D tmp = null;\n\t\t\tif (r1 > r2) {\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t} else {\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\n\t\t\tdouble min = Math.min(r1, r2);\n\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis_m + EPS > dis) {\n\t\t\treturn new Point2D[0]; // inner\n\t\t} else {\n\t\t\tPoint2D ret[] = new Point2D[2];\n\n\t\t\tdouble theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n\t\t\t\t\t/ (2 * dis * r1));\n\t\t\tdouble a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n\t\t\tret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a + theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a - theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n\t\t\tPoint2D ans[]) {\n\t\tif (c.pld(start, end) > r + EPS)\n\t\t\treturn;\n\t\tPoint2D v = end.sub(start).unit();\n\t\tdouble delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n\t\t\t\t- start.dist(c) * start.dist(c) + r * r;\n\t\tdouble t = -v.dot(start.sub(c));\n\t\tdouble s = Math.sqrt(delta);\n\t\tans[0] = start.add(v.mul(t + s));\n\t\tans[1] = start.add(v.mul(t + s));\n\t}\n\n\tpublic static double ss_dist(Point2D start1, Point2D end1, Point2D start2, Point2D end2){\n\t\tif(Point2D.intersect_s(start1, end1, start2, end2)){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn Math.min(Math.min(Math.min(start1.psd(start2, end2), end1.psd(start2, end2)), start2.psd(start1, end1)), end2.psd(start1, end1));\n\t\t}\n\t}\n\t\n\tpublic Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n\t\tPoint2D v = b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n\t\t\t\t(-1) * v.y, v.x);\n\t\treturn v.mul(p.pld(a, b));\n\t}\n\n\tpublic double area(Point2D a, Point2D b, Point2D c) {\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Roll-A-Big-Ball\npublic class Main{\n\nfinal double EPS = 1e-8;\n\t\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\t//Segment a-b Point p\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\t//Segment a-b Segment s-t\n\tdouble dist(double[] a, double[] b, double[] s, double[] t){\n\t\tif(crossing(a, b, s, t))return 0;\n\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))));\n\t}\n\t\n\tdouble[] S, T;\n\tdouble[][][] p;\n\t\n\tboolean in(int k){\n\t\tdouble area = norm(p[k][0], p[k][1])*norm(p[k][1], p[k][2]);\n\t\tdouble s = 0;\n\t\tfor(int i=0;i<4;i++)s+=area(p[k][i], p[k][(i+1)%4], S);\n\t\treturn Math.abs(area-s)<EPS;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tS = new double[]{sc.nextDouble(), sc.nextDouble()}; T = new double[]{sc.nextDouble(), sc.nextDouble()};\n\t\t\tp = new double[n][4][2];\n\t\t\tdouble[] h = new double[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble x1 = sc.nextDouble(), y1 = sc.nextDouble(), x2 = sc.nextDouble(), y2 = sc.nextDouble();\n\t\t\t\th[i] = sc.nextDouble();\n\t\t\t\tp[i][0] = new double[]{x1, y1};\n\t\t\t\tp[i][1] = new double[]{x2, y1};\n\t\t\t\tp[i][2] = new double[]{x2, y2};\n\t\t\t\tp[i][3] = new double[]{x1, y2};\n\t\t\t}\n\t\t\tdouble R = 1000;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(in(i)){\n\t\t\t\t\tR = 0; break;\n\t\t\t\t}\n\t\t\t\tdouble d = 1<<29;\n\t\t\t\tfor(int j=0;j<4;j++)d = Math.min(d, dist(S, T, p[i][j], p[i][(j+1)%4]));\n\t\t\t\tif(h[i]<d)R = Math.min(R, (h[i]*h[i]+d*d)/2/h[i]);\n\t\t\t\telse R = Math.min(R, d);\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.6f\\n\", R);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint sx = in.nextInt();\n\t\t\tint sy = in.nextInt();\n\t\t\tint ex = in.nextInt();\n\t\t\tint ey = in.nextInt();\n\t\t\tPos s = new Pos(sx, sy);\n\t\t\tPos e = new Pos(ex, ey);\n\t\t\tdouble len = Math.sqrt(s.dist2(e));\n\t\t\tArrayList<Pos> list = new ArrayList<Pos>();\n\t\t\tboolean zero = false;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint lx = in.nextInt();\n\t\t\t\tint ly = in.nextInt();\n\t\t\t\tint rx = in.nextInt();\n\t\t\t\tint ry = in.nextInt();\n\t\t\t\tint h = in.nextInt();\n\t\t\t\tif(zero) continue;\n\t\t\t\tPos[] p = {\n\t\t\t\t\t\tnew Pos(lx, ly),\n\t\t\t\t\t\tnew Pos(lx, ry),\n\t\t\t\t\t\tnew Pos(rx, ry),\n\t\t\t\t\t\tnew Pos(rx, ly),\n\t\t\t\t};\n\t\t\t\tdouble minLen = 100000000;\n\t\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t\tif(cross(p[j], p[(j+1)%4], s, e)){\n\t\t\t\t\t\tzero = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdouble l = Math.abs(dist(s, e, p[j]));\n\t\t\t\t\tl = Math.min(l, Math.abs(dist(p[j], p[(j+1)%4], s)));\n\t\t\t\t\tl = Math.min(l, Math.abs(dist(p[j], p[(j+1)%4], e)));\n\t\t\t\t\tminLen = Math.min(minLen, l);\n\t\t\t\t}\n\t\t\t\tif(cross(p[0], p[2], s, e) || cross(p[1], p[3], s, e))\n\t\t\t\t\tzero = true;\n\t\t\t\tlist.add(new Pos(minLen, h));\n\t\t\t}\n\t\t\tif(zero){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.println(binarySearch(list));\n\t\t}\n\t}\n\t\n\tpublic static final int times = 5000;\n\tpublic static double binarySearch(ArrayList<Pos> list){\n\t\tdouble max = 1000;\n\t\tdouble min = 0;\n\t\tdouble mid = 0;\n\t\tfor(int i=0; i<times; i++){\n\t\t\tmid = (max+min)/2;\n\t\t\tif(check(mid, list)){\n\t\t\t\tmin = mid;\n\t\t\t}else{\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\t\n\tpublic static boolean check(double r, ArrayList<Pos> list){\n\t\tfor(Pos p: list){\n\t\t\tdouble h = p.y;\n\t\t\tif(h > r) h = r;\n\t\t\tPos o = new Pos(0, r);\n\t\t\tif(o.dist2(p) < r*r) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static double triarea(Pos a, Pos b, Pos c){\n\t\tdouble dx1 = b.x - a.x;\n\t\tdouble dy1 = b.y - a.y;\n\t\tdouble dx2 = c.x - a.x;\n\t\tdouble dy2 = c.y - a.y;\n\t\treturn dx1*dy2 - dx2*dy1;\n\t}\n\t\n\tpublic static boolean cross(Pos a1, Pos a2, Pos b1, Pos b2){\n\t\treturn triarea(a1, a2, b1)*triarea(a1, a2, b2) <= 0\n\t\t\t\t&& triarea(b1, b2, a1)*triarea(b1, b2, a2) <= 0;\n\t}\n\t\n\tpublic static double dist(Pos a, Pos b, Pos c){\n\t\t// a->b ??¨ c??¨????????¢\n\t\tif(dot(b.x-a.x, b.y-a.y, c.x-a.x, c.y-a.y) <= 0)\n\t\t\treturn Math.sqrt(a.dist2(c));\n\t\tif(dot(a.x-b.x, a.y-b.y, c.x-b.x, c.y-b.y) <= 0)\n\t\t\treturn Math.sqrt(b.dist2(c));\n\t\treturn triarea(a, b, c)/Math.sqrt(a.dist2(b));\n\t}\n\t\n\tpublic static double dot(double x, double y, double x1, double y2){\n\t\treturn x*x1 + y*y2;\n\t}\n\t\n\tpublic static double dot(Pos a, Pos b){\n\t\treturn a.x*b.x + a.y*b.y;\n\t}\n}\n\nclass Pos{\n\tdouble x, y;\n\tpublic Pos(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic double dist2(Pos p){\n\t\treturn (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Roll-A-Big-Ball\npublic class Main{\n\nfinal double EPS = 1e-8;\n\t\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<0;\n\t}\n\t//Segment a-b Point p\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\t//Segment a-b Segment s-t\n\tdouble dist(double[] a, double[] b, double[] s, double[] t){\n\t\tif(crossing(a, b, s, t))return 0;\n\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))));\n\t}\n\t\n\tdouble[] S, T;\n\tdouble[][][] p;\n\t\n\tboolean in(int k){\n\t\tdouble area = norm(p[k][0], p[k][1])*norm(p[k][1], p[k][2]);\n\t\tdouble s = 0;\n\t\tfor(int i=0;i<4;i++)s+=area(p[k][i], p[k][(i+1)%4], S);\n\t\treturn Math.abs(area-s)<EPS;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tS = new double[]{sc.nextDouble(), sc.nextDouble()}; T = new double[]{sc.nextDouble(), sc.nextDouble()};\n\t\t\tp = new double[n][4][2];\n\t\t\tdouble[] h = new double[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble x1 = sc.nextDouble(), y1 = sc.nextDouble(), x2 = sc.nextDouble(), y2 = sc.nextDouble();\n\t\t\t\th[i] = sc.nextDouble();\n\t\t\t\tp[i][0] = new double[]{x1, y1};\n\t\t\t\tp[i][1] = new double[]{x2, y1};\n\t\t\t\tp[i][2] = new double[]{x2, y2};\n\t\t\t\tp[i][3] = new double[]{x1, y2};\n\t\t\t}\n\t\t\tdouble R = 1000;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(in(i)){\n\t\t\t\t\tR = 0; break;\n\t\t\t\t}\n\t\t\t\tdouble d = 1<<29;\n\t\t\t\tfor(int j=0;j<4;j++)d = Math.min(d, dist(S, T, p[i][j], p[i][(j+1)%4]));\n\t\t\t\tif(h[i]<d)R = Math.min(R, (h[i]*h[i]+d*d)/2/h[i]);\n\t\t\t\telse R = Math.min(R, d);\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.6f\\n\", R);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.util.*;\n\npublic class Main {\n\tfinal double EPS = 1.0e-08;\n\t\n\tprivate double getR(double dis, int h){\n\t\tif(dis > (double) h)\n\t\t\treturn (double)(dis * dis + h * h) / (2 * h);\n\t\telse\n\t\t\treturn dis;\n\t}\n\t\n\tprivate double getD(Point2D a,Point2D b,Point2D c){\n\t\tPoint2D ba = getV(b, a);\n\t\tPoint2D ca = getV(c, a);\n\t\tPoint2D ab = getV(a, b);\n\t\tPoint2D cb = getV(c, b);\n\t\tdouble result;\n\t\tif(getDot(ba, ca) < EPS)\n\t\t\tresult = a.distance(c);\n\t\telse if(getDot(ab,cb) < EPS)\n\t\t\tresult = c.distance(b);\n\t\telse{\n\t\t\tresult = Math.abs(getCross(ba,ca)) / b.distance(a);\n\t\t\t//System.out.print(\"A = \" + result + \" \");\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate Point2D getV(Point2D a, Point2D b){\n\t\tPoint2D ab = new Point2D.Double(a.getX() - b.getX(), a.getY() - b.getY());\n\t\treturn ab;\n\t}\n\tprivate double getDot(Point2D a, Point2D b){\n\t\treturn (a.getX() * b.getX() + a.getY() * b.getY());\n\t}\n\t\n\tprivate double getCross(Point2D a, Point2D b){\n\t\treturn (a.getX() * b.getY() - a.getY() * b.getX());\n\t}\n\t\n\tprivate boolean check(Point2D p1, Point2D p2,Point2D p3){\n\t\tboolean flg1 = p1.getX() - p3.getX() <= EPS;\n\t\tboolean flg2 = p3.getX() - p2.getX() <= EPS;\n\t\tboolean flg3 = p1.getX() - p3.getX() <= EPS;\n\t\tboolean flg4 = p3.getY() - p2.getY() <= EPS;\n\t\tif(flg1 && flg2 && flg3 && flg4){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0 )\tbreak;\n\t\t\tint sx = sc.nextInt();\n\t\t\tint sy = sc.nextInt();\n\t\t\tint ex = sc.nextInt();\n\t\t\tint ey = sc.nextInt();\n\t\t\tPoint2D cp1 = new Point2D.Double((double) sx, (double) sy);\n\t\t\tPoint2D cp2 = new Point2D.Double((double) ex, (double) ey);\n\t\t\tLine2D  cLine = new Line2D.Double(cp1, cp2);\n\t\t\tdouble ansR = 1001.0;\n\t\t\tint [] input = new int[4];\n\t\t\tfor(int i =0; i < n; i++){\n\t\t\t\tfor(int j =0; j < 4; j++){\n\t\t\t\t\tinput[j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tint h = sc.nextInt();\n\t\t\t\tPoint2D [] pList = new Point2D[4];\n\t\t\t\tpList[0]= new Point2D.Double(input[0], input[1]);\n\t\t\t\tpList[1]= new Point2D.Double(input[0], input[3]);\n\t\t\t\tpList[2]= new Point2D.Double(input[2], input[3]);\n\t\t\t\tpList[3]= new Point2D.Double(input[2], input[1]);\n\t\t\t\tdouble minDis = 10001.0;\n\t\t\t\tfor(int j =0; j < 4; j++){\n\t\t\t\t\tLine2D nowLine = new Line2D.Double(pList[j], pList[(j+1)%4]);\n\t\t\t\t\tdouble result;\n\t\t\t\t\tif(nowLine.intersectsLine(cLine)){\n\t\t\t\t\t\tresult = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(check(pList[0], pList[2], cp1) && check(pList[0], pList[2], cp2)){\n\t\t\t\t\t\tresult = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdouble result1 = getD(pList[j], pList[(j+1) % 4] , cp1);\n\t\t\t\t\t\tdouble result2 = getD(pList[j] , pList[(j+1)%4], cp2);\n\t\t\t\t\t\tdouble result3 = getD(cp1, cp2, pList[j]);\n\t\t\t\t\t\t//System.out.println(result1 + \" res1  res2 \" + result2 + \" res3 \" +result3);\n\t\t\t\t\t\t//System.out.println(pList[j].toString());\n\t\t\t\t\t\tresult = Math.min(result1, Math.min(result2, result3));\n\t\t\t\t\t}\n\t\t\t\t\t//System.out.println(result + \" result  minDis \" + minDis);\n\t\t\t\t\tminDis = Math.min(minDis, result);\n\t\t\t\t}\n\t\t\t\t//calc R\n\t\t\t\tdouble resultR = getR(minDis, h);\n\t\t\t\t//System.out.println(minDis + \" mindis resultR \"+ resultR+\" ans \" + ansR);\n\t\t\t\tansR = Math.min(ansR, resultR);\n\t\t\t}\n\t\t\t//System.out.print(\"ANS=\");\n\t\t\tSystem.out.printf(\"%1.10f\\n\",ansR);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.io.*;\n\npublic class Main{\n\tint INF = 1 << 24;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint sx = sc.nextInt();\n\t\t\tint sy = sc.nextInt();\n\t\t\tint gx = sc.nextInt();\n\t\t\tint gy = sc.nextInt();\n\t\t\tLine2D route = new Line2D.Double(sx, sy, gx, gy);\n\t\t\tPoint2D [][] rect = new Point2D[n][4];\n\t\t\tint [] hlist = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\thlist[i] = sc.nextInt();\n\t\t\t\trect[i][0] = new Point2D.Double(x1, y1);\n\t\t\t\trect[i][1] = new Point2D.Double(x2, y1);\n\t\t\t\trect[i][2] = new Point2D.Double(x2, y2);\n\t\t\t\trect[i][3] = new Point2D.Double(x1, y2);\n\t\t\t}\n\t\t\t\n\t\t\tdouble ans = INF;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\n\t\t\t\tboolean isIntersect = false;\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tLine2D nowline = new Line2D.Double(rect[i][j], rect[i][(j + 1) % 4]);\n\t\t\t\t\tif(route.intersectsLine(nowline)){\n\t\t\t\t\t\tisIntersect = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(isIntersect || isN(route, rect[i])){\n\t\t\t\t\tans = 0.0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdouble mindis = INF;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tLine2D nowline = new Line2D.Double(rect[i][j], rect[i][(j + 1) % 4]);\n\t\t\t\t\tdouble nowdis = distanceSS(route, nowline);\n\t\t\t\t\tmindis = Math.min(mindis, nowdis);\n\t\t\t\t}\n\t\t\t\tif(hlist[i] >= mindis){\n\t\t\t\t\tans = Math.min(ans, mindis);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble r = (double)(hlist[i] * hlist[i] + mindis * mindis) / (2 * hlist[i]);\n\t\t\t\t\tans = Math.min(ans, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\t\n\t}\n\tprivate boolean isN(Line2D route, Point2D[] rect) {\n\t\tif(rect[0].getX() <= route.getX1() && rect[0].getY() <= route.getY1() &&\n\t\t\t\trect[2].getX() >= route.getX1() && rect[2].getY() >= route.getY1()){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tprivate double distanceSS(Line2D l, Line2D m){\n\t\tdouble ans = 0.0;\n\t\tif(! l.intersectsLine(m)){\n\t\t\tdouble res1 = l.ptSegDist(m.getP1());\n\t\t\tdouble res2 = l.ptSegDist(m.getP2());\n\t\t\tdouble res3 = m.ptSegDist(l.getP1());\n\t\t\tdouble res4 = m.ptSegDist(l.getP2());\n\t\t\tans = Math.min(Math.min(res1, res2), Math.min(res3, res4));\n\t\t}\n\t\treturn ans;\n\t}\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.awt.geom.Line2D.Double;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1157();\n\t}\n\t\n\tclass AOJ1157{\n\t\tAOJ1157(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tif(n==0)\tbreak;\n\t\t\t\tsolve(n);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int n){\n\t\t\tLine2D.Double l=new Line2D.Double(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tdouble ans=100000;\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tint x1=sc.nextInt(),y1=sc.nextInt(),x2=sc.nextInt(),y2=sc.nextInt(),h=sc.nextInt();\n\t\t\t\tif(x1<=l.getX1()&&l.getX1()<=x2 && x1<=l.getX2()&&l.getX2()<=x2 && y1<=l.getY1()&&l.getY1()<=y2 && y1<=l.getY2()&&l.getY2()<=y2)\tans=0;\n\t\t\t\tif(ans<=0)\tcontinue;\n\t\t\t\tLine2D.Double[] rec=new Line2D.Double[4];\n\t\t\t\trec[0]=new Line2D.Double(x1,y1,x2,y1);\n\t\t\t\trec[1]=new Line2D.Double(x1,y1,x1,y2);\n\t\t\t\trec[2]=new Line2D.Double(x2,y2,x2,y1);\n\t\t\t\trec[3]=new Line2D.Double(x2,y2,x1,y2);\n\t\t\t\tdouble d = 100000;\n\t\t\t\tfor(int j=0; j<4; ++j)\td=min(d,segSegDist(rec[j], l));\n\t\t\t\tans=min(ans, (d==0? 0: (d<=h? d: ((d*d+h*h)/(2*h))) ));\n//\t\t\t\tSystem.out.println(\"d:\"+d+\" h:\"+h+\" r:\"+ ((d*d+h*h)/2*h)+\" ans:\"+ans);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tdouble segSegDist(Line2D l1,Line2D l2){\n\t\t\treturn l1.intersectsLine(l2)? 0 :Math.min(Math.min(l1.ptSegDist(l2.getP1()), l1.ptSegDist(l2.getP2())) , Math.min(l2.ptSegDist(l1.getP1()), l2.ptSegDist(l1.getP2())));\n\t\t}\n\t\tString lineToStr(Line2D l){\n\t\t\treturn \"Line2D \"+l.getP1()+\"-\"+l.getP2();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-4;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Tyokuhoutai {\n    ArrayList<LineSegment> list;\n    int h;\n\n    Tyokuhoutai(int minx, int miny, int maxx, int maxy, int h) {\n      list = new ArrayList<>();\n      list.add(new LineSegment(minx, miny, maxx, miny));\n      list.add(new LineSegment(maxx, miny, maxx, maxy));\n      list.add(new LineSegment(maxx, maxy, minx, maxy));\n      list.add(new LineSegment(minx, maxy, minx, miny));\n      this.h = h;\n    }\n\n    double dist(LineSegment atom) {\n      if (isIn(atom.x1, atom.y1) || isIn(atom.x2, atom.y2)) {\n        return 0;\n      }\n      double min = Double.MAX_VALUE;\n      for (LineSegment l : list) {\n        min = Math.min(min, atom.distance(l));\n      }\n      return min;\n    }\n\n    boolean isIn(double x, double y) {\n      boolean flag = true;\n      for (LineSegment l : list) {\n        double ax = l.x2 - l.x1;\n        double ay = l.y2 - l.y1;\n        double bx = x - l.x1;\n        double by = y - l.y1;\n        double gaiseki = ax * by - ay * bx;\n        flag &= gaiseki > 0;\n      }\n      return flag;\n    }\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int sx, sy, ex, ey;\n      sx = ni();\n      sy = ni();\n      ex = ni();\n      ey = ni();\n      LineSegment atom = new LineSegment(sx, sy, ex, ey);\n      double min = Double.MAX_VALUE;\n      for (int i = 0; i < n; ++i) {\n        int minx, miny, maxx, maxy, h;\n        minx = ni();\n        miny = ni();\n        maxx = ni();\n        maxy = ni();\n        h = ni();\n        Tyokuhoutai t = new Tyokuhoutai(minx, miny, maxx, maxy, h);\n        double d = t.dist(atom);\n        if (h >= d) {\n          min = Math.min(min, d);\n        } else {\n          double left = 0;\n          double right = 1000 + EPS;\n          while (right - left > EPS) {\n            double r = (left + right) / 2;\n            boolean flag = GeomUtils.abs(d, h - r) <= r;\n            if (flag) {\n              right = r;\n            } else {\n              left = r;\n            }\n          }\n          min = Math.min(min, right);\n        }\n      }\n      System.out.println(min);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Roll-A-Big-Ball\npublic class Main{\n\n\tdouble EPS = 1.0e-8;\n\tdouble norm(Point p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\tdouble inp(Point p1, Point p2) {\n\t\treturn p1.x*p2.x + p1.y*p2.y;\n\t}\n\tdouble extp(Point p1, Point p2) {\n\t\treturn p1.x*p2.y - p2.x*p1.y;\n\t}\n\tPoint sub(Point p1, Point p2) {\n\t\treturn new Point(p1.x-p2.x, p1.y-p2.y);\n\t}\n\tPoint proj(Line l, Point p) {\n\t\tdouble t = inp(sub(p, l.s), sub(l.s, l.t)) / Math.pow(norm(sub(l.s, l.t)),2);\n\t\tPoint tp = sub(l.s, l.t);\n\t\treturn new Point(l.s.x + t*tp.x, l.s.y + t*tp.y);\n\t}\n\tint ccw(Point a, Point b, Point c) {\n\t\tPoint p = sub(b, a);\n\t\tPoint q = sub(c, a);\n\t\tif(extp(p, q) > EPS) return 1;\t\t// counter clockwise\n\t\tif(extp(p, q) < -EPS)return -1;\t\t// clockwise\n\t\tif(inp(p, q) < -EPS) return 2;\t\t// c--a--b on line\n\t\tif(Math.abs(norm(p) - norm(q)) < EPS) return -2;\t// a--b--c on line\n\t\treturn 0;\t\t\t\t// a--c--b(or a--c=b) on line \n\t}\n\tboolean intersectSS(Line s, Line t) {\n\t\treturn ccw(s.s,s.t,t.s)*ccw(s.s,s.t,t.t) <= 0 &&\n\t\t       ccw(t.s,t.t,s.s)*ccw(t.s,t.t,s.t) <= 0;\n\t}\n\tboolean intersectSP(Line s, Point p) {\n\t\treturn ccw(s.s, s.t, p) == 0;\n\t}\n\tdouble distanceSP(Line s, Point p) {\n\t\tPoint r = proj(s, p);\n\t\tif (intersectSP(s, r)) return norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.s, p)), norm(sub(s.t, p)));\n\t}\n\tdouble distanceSS(Line s, Line t) {\n\t\tif (intersectSS(s, t)) return 0;\n\t\treturn Math.min(Math.min(distanceSP(s, t.s), distanceSP(s, t.t)),\n\t            Math.min(distanceSP(t, s.s), distanceSP(t, s.t)));\n\t}\n\tclass Point {\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic Point(double x_, double y_) {\n\t\t\tx = x_; y=y_;\n\t\t}\n\t}\n\tclass Line {\n\t\tpublic Point s,t;\n\t\tpublic Line(Point s_, Point t_) {\n\t\t\ts = s_; t = t_;\n\t\t}\n\t}\n\tboolean in(Point p, Point[] v){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tPoint v1 = sub(v[(i+1)%4], v[i]);\n\t\t\tPoint v2 = sub(p, v[i]);\n\t\t\tif(extp(v1, v2)<0)return false;\n\t\t}\n\t\treturn true;\n\t}\n\tdouble dist(Point s, Point t, Point[] v){\n\t\tdouble res = Double.MAX_VALUE;\n\t\tLine line = new Line(s, t);\n\t\tLine rev = new Line(t, s);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tLine l = new Line(v[i], v[(i+1)%4]);\n\t\t\tLine rl = new Line(v[(i+1)%4], v[i]);\n\t\t\tdouble d = Math.max(distanceSS(line, l), Math.max(distanceSS(rev, l), Math.max(distanceSS(line, rl), distanceSS(rev, rl))));\n\t\t\td = Math.max(d, Math.max(distanceSS(l, line), Math.max(distanceSS(l, rev), Math.max(distanceSS(rl, line), distanceSS(rl, rev)))));\n//\t\t\tSystem.out.println(\"I:\"+i+\" Dist:\"+d);\n\t\t\tres = Math.min(res, d);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tPoint start = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tPoint end = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tPoint[][] p = new Point[n][4];\n\t\t\tdouble R = 1000;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();\n\t\t\t\tdouble h = sc.nextDouble();\n\t\t\t\tp[i][0] = new Point(x1, y1);\n\t\t\t\tp[i][1] = new Point(x2, y1);\n\t\t\t\tp[i][2] = new Point(x2, y2);\n\t\t\t\tp[i][3] = new Point(x1, y2);\n\t\t\t\tif(in(start, p[i])||in(end, p[i])){\n\t\t\t\t\tR = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble d = dist(start, end, p[i]);\n//\t\t\t\t\tSystem.out.println(\"D:\" + d + \" Val:\" + (h<=d?((d*d+h*h)/2/h):d));\n\t\t\t\t\tif(h<d)R = Math.min(R, (d*d+h*h)/2/h);\n\t\t\t\t\telse R = Math.min(R, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.7f\\n\", R);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tdouble calc(Line2D.Double line, double x, double y, double h) {\n\t\tdouble d1 = line.ptSegDist(x, y);\n\t\tdouble d2 = (d1 * d1 + h * h) / (2 * h);\n\t\treturn Math.max(d1, d2);\n\t}\n\t\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint N = in.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tint sx = in.nextInt(), sy = in.nextInt(), ex = in.nextInt(), ey = in.nextInt();\n\t\t\tLine2D.Double line = new Line2D.Double(sx, sy, ex, ey);\n\t\t\t\n\t\t\tdouble rmax = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint minx = in.nextInt(), miny = in.nextInt();\n\t\t\t\tint maxx = in.nextInt(), maxy = in.nextInt();\n\t\t\t\tint h = in.nextInt();\n\t\t\t\t\n\t\t\t\tRectangle2D.Double rect = \n\t\t\t\t\t\tnew Rectangle2D.Double(minx, miny, maxx - minx, maxy - miny);\n\t\t\t\tif (line.intersectsLine(minx, miny, minx, maxy)) rmax = 0;\n\t\t\t\tif (line.intersectsLine(minx, miny, maxx, miny)) rmax = 0;\n\t\t\t\tif (line.intersectsLine(maxx, maxy, minx, maxy)) rmax = 0;\n\t\t\t\tif (line.intersectsLine(maxx, maxy, maxx, miny)) rmax = 0;\n\t\t\t\tif (rect.contains(sx, sy)) rmax = 0;\n\t\t\t\tif (rect.contains(ex, ey)) rmax = 0;\n\t\t\t\t\n\t\t\t\trmax = Math.min(rmax, calc(line, minx, miny, h));\n\t\t\t\trmax = Math.min(rmax, calc(line, minx, maxy, h));\n\t\t\t\trmax = Math.min(rmax, calc(line, maxx, miny, h));\n\t\t\t\trmax = Math.min(rmax, calc(line, maxx, maxy, h));\n\t\t\t\tif (minx <= sx && sx <= maxx) {\n\t\t\t\t\trmax = Math.min(rmax, calc(line, sx, miny, h));\n\t\t\t\t\trmax = Math.min(rmax, calc(line, sx, maxy, h));\n\t\t\t\t}\n\t\t\t\tif (miny <= sy && sy <= maxy) {\n\t\t\t\t\trmax = Math.min(rmax, calc(line, minx, sy, h));\n\t\t\t\t\trmax = Math.min(rmax, calc(line, maxx, sy, h));\n\t\t\t\t}\n\t\t\t\tif (minx <= ex && ex <= maxx) {\n\t\t\t\t\trmax = Math.min(rmax, calc(line, ex, miny, h));\n\t\t\t\t\trmax = Math.min(rmax, calc(line, ex, maxy, h));\n\t\t\t\t}\n\t\t\t\tif (miny <= ey && ey <= maxy) {\n\t\t\t\t\trmax = Math.min(rmax, calc(line, minx, ey, h));\n\t\t\t\t\trmax = Math.min(rmax, calc(line, maxx, ey, h));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.5f\\n\", rmax);\n\t\t}\n\t}\t\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*; \n \npublic class Main\n{\n\tpublic static void main(String args[]) throws Exception{\n\t\tnew Main().run();\n\t}\n\n\tint w,h;\n\t\n\tpublic void run()\n\t{\n\t\tint i,j,k,l;\n\t\tScanner cin=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint N = cin.nextInt();\n\t\t\tif(N==0) break;\n\t\t\tdouble sx,sy,ex,ey;\n\t\t\tsx = cin.nextDouble();\n\t\t\tsy = cin.nextDouble();\n\t\t\tex = cin.nextDouble();\n\t\t\tey = cin.nextDouble();\n\t\t\tdouble h[] = new double[N];\n\t\t\tdouble mindist[] = new double[N];\n\t\t\tdouble res = 999999999;\n\t\t\tfor(i=0;i<N;i++){\n\t\t\t\tdouble minx, maxx, miny, maxy;\n\t\t\t\tminx = cin.nextDouble();\n\t\t\t\tminy = cin.nextDouble();\n\t\t\t\tmaxx = cin.nextDouble();\n\t\t\t\tmaxy = cin.nextDouble();\n\t\t\t\th[i] = cin.nextDouble();\n\t\t\t\tmindist[i] = res;\n\t\t\t\tdouble hi = 1;\n\t\t\t\tdouble low = 0;\n\t\t\t\tdouble nowdist = 0;\n\t\t\t\tfor(l=0;l<200;l++){\n\t\t\t\t\tdouble left = (low+low+hi) /3;\n\t\t\t\t\tdouble right = (low + hi + hi) / 3;\n\t\t\t\t\tdouble lx = sx * left + ex * (1-left);\n\t\t\t\t\tdouble ly = sy * left + ey * (1-left);\n\t\t\t\t\tdouble rx = sx * right + ex * (1-right);\n\t\t\t\t\tdouble ry = sy * right + ey * (1-right);\n\t\t\t\t\t\n\t\t\t\t\tdouble ldist = dist(minx,miny, maxx, maxy,lx,ly);\n\t\t\t\t\tdouble rdist = dist(minx,miny, maxx, maxy,rx,ry);\n\t\t\t\t\tif(ldist<rdist){\n\t\t\t\t\t\thi = right;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlow = left;\n\t\t\t\t\t}\n\t\t\t\t\tnowdist = ldist;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmindist[i] = Math.min(mindist[i], nowdist);\n\t\t\t}\n\n\t\t\tdouble hh = 100000;\n\t\t\tdouble ll = 0;\n\t\t\tfor(l=0;l<200;l++){\n\t\t\t\tdouble mid = (hh + ll) / 2;\n\t\t\t\tboolean flag = false;\n\t\t\t\tfor(i=0;i<N;i++){\n\t\t\t\t\tdouble need = mindist[i];\n\t\t\t\t\tif(mid<h[i]){\n\t\t\t\t\t\tneed -= mid;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tneed -= Math.sqrt(mid * mid - (mid-h[i]) * (mid-h[i]));\n\t\t\t\t\t}\n\t\t\t\t\t//System.out.println(need);\n\t\t\t\t\tif(need<0) flag= true;\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\thh = mid;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tll = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = ll;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\tdouble dist(double minx, double miny,double maxx, double maxy, double bx, double by){\n\t\tboolean flagx = false;\n\t\tboolean flagy = false;\n\t\tif(bx>=minx && bx<=maxx) flagx = true;\n\t\tif(by>=miny && by<=maxy) flagy = true;\n\t\tif(flagx && flagy) return 0;\n\t\telse if(flagx) return Math.min(dist(bx,miny,bx,by), dist(bx,maxy,bx,by));\n\t\telse if(flagy) return Math.min(dist(minx,by,bx,by), dist(maxx,by,bx,by));\n\t\treturn Math.min(\n\t\t\t\tMath.min(dist(minx,miny,bx,by), dist(minx,maxy,bx,by)),\n\t\t\t\tMath.min(dist(maxx,miny,bx,by), dist(maxx,maxy,bx,by))\n\t\t\t\t);\n\t}\n\t\n\t\n\tdouble dist(double ax, double ay,double bx, double by){\n\t\t\n\t\treturn Math.sqrt((ax-bx)*(ax-bx) + (ay-by)*(ay-by));\n\t}\n\t\n\tboolean ok(int y, int x){\n\t\treturn x>=0 && y>=0 && x<w && y<h;\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint sx = in.nextInt();\n\t\t\tint sy = in.nextInt();\n\t\t\tint ex = in.nextInt();\n\t\t\tint ey = in.nextInt();\n\t\t\tPos s = new Pos(sx, sy);\n\t\t\tPos e = new Pos(ex, ey);\n\t\t\tArrayList<Pos> list = new ArrayList<Pos>();\n\t\t\tboolean zero = false;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint lx = in.nextInt();\n\t\t\t\tint ly = in.nextInt();\n\t\t\t\tint rx = in.nextInt();\n\t\t\t\tint ry = in.nextInt();\n\t\t\t\tint h = in.nextInt();\n\t\t\t\tif(zero) continue;\n\t\t\t\tPos[] p = {\n\t\t\t\t\t\tnew Pos(lx, ly),\n\t\t\t\t\t\tnew Pos(lx, ry),\n\t\t\t\t\t\tnew Pos(rx, ry),\n\t\t\t\t\t\tnew Pos(rx, ly),\n\t\t\t\t};\n\t\t\t\tdouble minLen = 100000000;\n\t\t\t\tdouble sign = 0;\n\t\t\t\tboolean inter = true;\n\t\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t\tif(cross(p[j], p[(j+1)%4], s, e)){\n\t\t\t\t\t\tzero = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdouble l = Math.abs(dist(s, e, p[j]));\n\t\t\t\t\tl = Math.min(l, Math.abs(sign = dist(p[j], p[(j+1)%4], s)));\n\t\t\t\t\tl = Math.min(l, Math.abs(dist(p[j], p[(j+1)%4], e)));\n\t\t\t\t\tminLen = Math.min(minLen, l);\n\t\t\t\t\tif(sign > 0) inter = false;\n\t\t\t\t}\n\t\t\t\tif(inter) zero = true;\n\t\t\t\tlist.add(new Pos(minLen, h));\n\t\t\t}\n\t\t\tif(zero){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.println(binarySearch(list));\n\t\t}\n\t}\n\t\n\tpublic static final int times = 5000;\n\tpublic static double binarySearch(ArrayList<Pos> list){\n\t\tdouble max = 1000;\n\t\tdouble min = 0;\n\t\tdouble mid = 0;\n\t\tfor(int i=0; i<times; i++){\n\t\t\tmid = (max+min)/2;\n\t\t\tif(check(mid, list)){\n\t\t\t\tmin = mid;\n\t\t\t}else{\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\t\n\tpublic static boolean check(double r, ArrayList<Pos> list){\n\t\tfor(Pos p: list){\n\t\t\tdouble h = p.y;\n\t\t\tif(h > r) h = r;\n\t\t\tPos o = new Pos(0, r);\n\t\t\tif(o.dist2(p) < r*r) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static double triarea(Pos a, Pos b, Pos c){\n\t\tdouble dx1 = b.x - a.x;\n\t\tdouble dy1 = b.y - a.y;\n\t\tdouble dx2 = c.x - a.x;\n\t\tdouble dy2 = c.y - a.y;\n\t\treturn dx1*dy2 - dx2*dy1;\n\t}\n\t\n\tpublic static boolean cross(Pos a1, Pos a2, Pos b1, Pos b2){\n\t\treturn triarea(a1, a2, b1)*triarea(a1, a2, b2) <= 0\n\t\t\t\t&& triarea(b1, b2, a1)*triarea(b1, b2, a2) <= 0;\n\t}\n\t\n\tpublic static double dist(Pos a, Pos b, Pos c){\n\t\t// a->b ??¨ c??¨????????¢\n\t\tif(dot(b.x-a.x, b.y-a.y, c.x-a.x, c.y-a.y) <= 0)\n\t\t\treturn Math.sqrt(a.dist2(c));\n\t\tif(dot(a.x-b.x, a.y-b.y, c.x-b.x, c.y-b.y) <= 0)\n\t\t\treturn Math.sqrt(b.dist2(c));\n\t\treturn triarea(a, b, c)/Math.sqrt(a.dist2(b));\n\t}\n\t\n\tpublic static double dot(double x, double y, double x1, double y2){\n\t\treturn x*x1 + y*y2;\n\t}\n\t\n\tpublic static double dot(Pos a, Pos b){\n\t\treturn a.x*b.x + a.y*b.y;\n\t}\n}\n\nclass Pos{\n\tdouble x, y;\n\tpublic Pos(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic double dist2(Pos p){\n\t\treturn (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\t\n\t\t\tif(N == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int start_x = sc.nextInt();\n\t\t\tfinal int start_y = sc.nextInt();\n\t\t\tfinal int end_x = sc.nextInt();\n\t\t\tfinal int end_y = sc.nextInt();\n\t\t\t\n\t\t\tPoint2D start = new Point2D(start_x, start_y);\n\t\t\tPoint2D end = new Point2D(end_x, end_y);\n\t\t\t\n\t\t\tdouble[] dist = new double[N];\n\t\t\tdouble[] high = new double[N];\n\t\t\t\n\t\t\tfinal int seg_box_min_x = Math.min(start_x, end_x);\n\t\t\tfinal int seg_box_max_x = Math.max(start_x, end_x);\n\t\t\tfinal int seg_box_min_y = Math.min(start_y, end_y);\n\t\t\tfinal int seg_box_max_y = Math.max(start_y, end_y);\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfinal int minx = sc.nextInt();\n\t\t\t\tfinal int miny = sc.nextInt();\n\t\t\t\tfinal int maxx = sc.nextInt();\n\t\t\t\tfinal int maxy = sc.nextInt();\n\t\t\t\tfinal int h = sc.nextInt();\n\t\t\t\t\n\t\t\t\tPoint2D[] box = new Point2D[]{\n\t\t\t\t\t\tnew Point2D(minx, miny),\n\t\t\t\t\t\tnew Point2D(maxx, miny),\n\t\t\t\t\t\tnew Point2D(maxx, maxy),\n\t\t\t\t\t\tnew Point2D(minx, maxy),\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tdouble d = Double.MAX_VALUE;\n\t\t\t\tif(maxx > seg_box_max_x && maxy > seg_box_max_y && minx < seg_box_min_x && miny < seg_box_min_y){\n\t\t\t\t\td = 0;\n\t\t\t\t\t//System.out.println(\"hit\");\n\t\t\t\t}else{\n\t\t\t\t\tfor(int pos = 0; pos < box.length; pos++){\n\t\t\t\t\t\tint next = (pos + 1) % box.length;\n\t\t\t\t\t\td = Math.min(d, Point2D.ss_dist(box[pos], box[next], start, end));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(d + \" \" + h);\n\t\t\t\t\n\t\t\t\tdist[i] = d;\n\t\t\t\thigh[i] = h;\n\t\t\t}\n\t\t\t\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(dist[i] < high[i]){\n\t\t\t\t\tmin = Math.min(min, dist[i]);\n\t\t\t\t}else{\n\t\t\t\t\tmin = Math.min(min, (dist[i] * dist[i] + high[i] * high[i]) / (2 * high[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.printf(\"%.4f\\n\", min);\n\t\t}\n\t}\n\n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\n\tpublic static final double EPS = 1e-9;\n\n\tpublic Point2D(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic Point2D(Point2D point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\n\tpublic String toString() {\n\t\treturn x + \",\" + y;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (o instanceof Point2D) {\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\t\n\t\t\tif(Point2D.eq(this.x, another.x) && Point2D.eq(this.y, another.y)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic Point2D add(double x, double y) {\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\n\tpublic Point2D sub(double x, double y) {\n\t\treturn add(-x, -y);\n\t}\n\n\tpublic Point2D add(Point2D another) {\n\t\treturn add(another.x, another.y);\n\t}\n\n\tpublic Point2D sub(Point2D another) {\n\t\treturn sub(another.x, another.y);\n\t}\n\n\tpublic Point2D mul(double d) {\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\n\tpublic Point2D div(double d) {\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\n\tpublic double dot(double x, double y) {\n\t\treturn this.x * x + this.y * y;\n\t}\n\n\tpublic double dot(Point2D another) {\n\t\treturn dot(another.x, another.y);\n\t}\n\n\tpublic double cross(double x, double y) {\n\t\treturn this.x * y - this.y * x;\n\t}\n\n\tpublic double cross(Point2D another) {\n\t\treturn cross(another.x, another.y);\n\t}\n\n\tpublic double dist(double x, double y) {\n\t\treturn Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n\t\t\t\t* (this.y - y));\n\t}\n\n\tpublic double dist(Point2D another) {\n\t\treturn dist(another.x, another.y);\n\t}\n\n\tpublic double dist_o() {\n\t\treturn dist(0, 0);\n\t}\n\n\tpublic Point2D unit() {\n\t\treturn div(dist_o());\n\t}\n\n\tpublic boolean pol(Point2D start, Point2D end) {\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\n\tpublic boolean pos(Point2D start, Point2D end) {\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\n\tpublic double pld(Point2D start, Point2D end) {\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))\n\t\t\t\t/ end.sub(start).dist_o());\n\t}\n\n\tpublic double psd(Point2D start, Point2D end) {\n\t\tif (end.sub(start).dot(this.sub(start)) < EPS) {\n\t\t\treturn this.dist(start);\n\t\t} else if (start.sub(end).dot(this.sub(end)) < EPS) {\n\t\t\treturn this.dist(end);\n\t\t} else {\n\t\t\treturn Math.abs(end.sub(start).cross(this.sub(start)) / end.dist(start));\n\t\t}\n\t}\n\t\n\tpublic static int signum(double x){\n\t\treturn Math.abs(x) < EPS ? 0 : x > 0 ? 1 : -1;\n\t}\n\t\n\tpublic static boolean eq(double x, double y){\n\t\treturn signum(x - y) == 0;\n\t}\n\t\n\tpublic static int ccw(Point2D p, Point2D r, Point2D s){\n\t\tPoint2D a = r.sub(p);\n\t\tPoint2D b = s.sub(p);\n\t\t\n\t\tfinal int sgn = Point2D.signum(a.cross(b));\n\t\tif(sgn != 0){\n\t\t\treturn sgn;\n\t\t}else if(a.x * b.x < -EPS && a.y * b.y < -EPS){\n\t\t\treturn -1;\n\t\t}else if(a.dist_o() < b.dist_o() - EPS){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn (Point2D.ccw(a1, a2, b1) * Point2D.ccw(a1, a2, b2) <= 0)\n\t\t\t\t&& (Point2D.ccw(b1, b2, a1) * Point2D.ccw(b1, b2, a2) <= 0);\n\t}\n\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n\t\t\tdouble r2) {\n\t\tdouble dis = p1.dist(p2);\n\n\t\tif (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n\t\t\treturn new Point2D[0]; // same\n\t\t}\n\n\t\tif (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis + EPS > r1 + r2) {\n\t\t\treturn new Point2D[0]; // out\n\t\t}\n\n\t\tdouble dis_m = Math.abs(r1 - r2);\n\n\t\tif (dis_m + EPS > dis && dis_m - EPS < dis) {\n\t\t\tPoint2D tmp = null;\n\t\t\tif (r1 > r2) {\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t} else {\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\n\t\t\tdouble min = Math.min(r1, r2);\n\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis_m + EPS > dis) {\n\t\t\treturn new Point2D[0]; // inner\n\t\t} else {\n\t\t\tPoint2D ret[] = new Point2D[2];\n\n\t\t\tdouble theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n\t\t\t\t\t/ (2 * dis * r1));\n\t\t\tdouble a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n\t\t\tret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a + theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a - theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tpublic static double ss_dist(Point2D start1, Point2D end1, Point2D start2, Point2D end2){\n\t\tif(Point2D.intersect_s(start1, end1, start2, end2)){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn Math.min(Math.min(Math.min(start1.psd(start2, end2), end1.psd(start2, end2)), start2.psd(start1, end1)), end2.psd(start1, end1));\n\t\t}\n\t}\n\t\n\tpublic void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n\t\t\tPoint2D ans[]) {\n\t\tif (c.pld(start, end) > r + EPS)\n\t\t\treturn;\n\t\tPoint2D v = end.sub(start).unit();\n\t\tdouble delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n\t\t\t\t- start.dist(c) * start.dist(c) + r * r;\n\t\tdouble t = -v.dot(start.sub(c));\n\t\tdouble s = Math.sqrt(delta);\n\t\tans[0] = start.add(v.mul(t + s));\n\t\tans[1] = start.add(v.mul(t + s));\n\t}\n\n\tpublic Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n\t\tPoint2D v = b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n\t\t\t\t(-1) * v.y, v.x);\n\t\treturn v.mul(p.pld(a, b));\n\t}\n\n\tpublic double area(Point2D a, Point2D b, Point2D c) {\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static double EPS = 1e-9;\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint sx = in.nextInt();\n\t\t\tint sy = in.nextInt();\n\t\t\tint ex = in.nextInt();\n\t\t\tint ey = in.nextInt();\n\t\t\tPos s = new Pos(sx, sy);\n\t\t\tPos e = new Pos(ex, ey);\n\t\t\tArrayList<Pos> list = new ArrayList<Pos>();\n\t\t\tboolean zero = false;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint lx = in.nextInt();\n\t\t\t\tint ly = in.nextInt();\n\t\t\t\tint rx = in.nextInt();\n\t\t\t\tint ry = in.nextInt();\n\t\t\t\tint h = in.nextInt();\n\t\t\t\tif(zero) continue;\n\t\t\t\tPos[] p = {\n\t\t\t\t\t\tnew Pos(lx, ly),\n\t\t\t\t\t\tnew Pos(lx, ry),\n\t\t\t\t\t\tnew Pos(rx, ry),\n\t\t\t\t\t\tnew Pos(rx, ly),\n\t\t\t\t};\n\t\t\t\tdouble minLen = 100000000;\n\t\t\t\tdouble sign = 0;\n\t\t\t\tboolean inter = true;\n\t\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t\tif(cross(p[j], p[(j+1)%4], s, e)){\n\t\t\t\t\t\tzero = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdouble l = Math.abs(dist(s, e, p[j]));\n\t\t\t\t\tl = Math.min(l, Math.abs(sign = dist(p[j], p[(j+1)%4], s)));\n\t\t\t\t\tl = Math.min(l, Math.abs(dist(p[j], p[(j+1)%4], e)));\n\t\t\t\t\tminLen = Math.min(minLen, l);\n\t\t\t\t\tif(sign > 0) inter = false;\n\t\t\t\t}\n\t\t\t\tif(inter || minLen < EPS) zero = true;\n\t\t\t\tlist.add(new Pos(minLen, h));\n\t\t\t}\n\t\t\tif(zero){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.println(binarySearch(list));\n\t\t}\n\t}\n\t\n\tpublic static final int times = 5000;\n\tpublic static double binarySearch(ArrayList<Pos> list){\n\t\tdouble max = 1000;\n\t\tdouble min = 0;\n\t\tdouble mid = 0;\n\t\tfor(int i=0; i<times; i++){\n\t\t\tmid = (max+min)/2;\n\t\t\tif(check(mid, list)){\n\t\t\t\tmin = mid;\n\t\t\t}else{\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\t\n\tpublic static boolean check(double r, ArrayList<Pos> list){\n\t\tfor(Pos p: list){\n\t\t\tdouble h = p.y;\n\t\t\tif(h > r) h = r;\n\t\t\tPos o = new Pos(0, r);\n\t\t\tif(o.dist2(p, h) < r*r) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static double triarea(Pos a, Pos b, Pos c){\n\t\tdouble dx1 = b.x - a.x;\n\t\tdouble dy1 = b.y - a.y;\n\t\tdouble dx2 = c.x - a.x;\n\t\tdouble dy2 = c.y - a.y;\n\t\treturn dx1*dy2 - dx2*dy1;\n\t}\n\t\n\tpublic static boolean cross(Pos a1, Pos a2, Pos b1, Pos b2){\n\t\treturn triarea(a1, a2, b1)*triarea(a1, a2, b2) < EPS\n\t\t\t\t&& triarea(b1, b2, a1)*triarea(b1, b2, a2) < EPS;\n\t}\n\t\n\tpublic static double dist(Pos a, Pos b, Pos c){\n\t\t// a->b ??¨ c??¨????????¢\n\t\tif(dot(b.x-a.x, b.y-a.y, c.x-a.x, c.y-a.y) < EPS)\n\t\t\treturn Math.sqrt(a.dist2(c));\n\t\tif(dot(a.x-b.x, a.y-b.y, c.x-b.x, c.y-b.y) < EPS)\n\t\t\treturn Math.sqrt(b.dist2(c));\n\t\treturn triarea(a, b, c)/Math.sqrt(a.dist2(b));\n\t}\n\t\n\tpublic static double dot(double x, double y, double x1, double y2){\n\t\treturn x*x1 + y*y2;\n\t}\n\t\n\tpublic static double dot(Pos a, Pos b){\n\t\treturn a.x*b.x + a.y*b.y;\n\t}\n}\n\nclass Pos{\n\tdouble x, y;\n\tpublic Pos(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic double dist2(Pos p){\n\t\treturn (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n\t}\n\t\n\tpublic double dist2(Pos p, double h){\n\t\treturn (x-p.x)*(x-p.x) + (y-h)*(y-h);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-10;\n\tP s, g;\n\tint n;\n\tdouble[] ds;\n\tdouble[] h;\n\t\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\ts = new P(sc.nextDouble(), sc.nextDouble());\n\t\t\tg = new P(sc.nextDouble(), sc.nextDouble());\n\t\t\t\n\t\t\th = new double[n];\n\t\t\tds = new double[n];\n\t\t\t\n\t\t\tfor(int c=0;c<n;c++) {\n\t\t\t\tint[][] p = new int[2][2];\n\t\t\t\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++) p[i][j] = sc.nextInt();\n\t\t\t\t\n\t\t\t\tds[c] = INF;\n\t\t\t\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++) {\n\t\t\t\t\tdouble tmp = disSP(s, g, new P(p[i][0], p[j][1]));\n\t\t\t\t\tds[c] = min(tmp, ds[c]);\n//\t\t\t\t\tdebug(ds);\n\t\t\t\t\ttmp = disSP ( new P(p[i][0], p[j][1]), new P(p[i][0], p[(j+1)%2][1]), s );\n\t\t\t\t\tds[c] = min(tmp, ds[c]);\n\t\t\t\t\t\n\t\t\t\t\ttmp = disSP ( new P(p[i][0], p[j][1]), new P(p[(i+1)%2][0], p[j][1]), s );\n\t\t\t\t\tds[c] = min(tmp, ds[c]);\n\t\t\t\t\t\n\t\t\t\t\ttmp = disSP ( new P(p[i][0], p[j][1]), new P(p[i][0], p[(j+1)%2][1]), g );\n\t\t\t\t\tds[c] = min(tmp, ds[c]);\n\t\t\t\t\t\n\t\t\t\t\ttmp = disSP ( new P(p[i][0], p[j][1]), new P(p[(i+1)%2][0], p[j][1]), g );\n\t\t\t\t\tds[c] = min(tmp, ds[c]);\n//\t\t\t\t\tdebug(ds);\n\t\t\t\t\t\n\t\t\t\t\tif( cross(new P(p[i][0], p[j][1]), new P(p[(i+1)%2][0], p[j][1]), s, g) ) ds[c] = 0;\n\t\t\t\t\tif( cross(new P(p[i][0], p[j][1]), new P(p[i][0], p[(j+1)%2][1]), s, g) ) ds[c] = 0;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( p[0][0] < min(s.x, g.x) && p[0][1] < min(s.y, g.y) && p[1][0] > max(s.x, g.x) && p[1][1] > max(s.y, g.y) )\n\t\t\t\t\tds[c] = 0;\n\t\t\t\t\n\t\t\t\th[c] = sc.nextDouble();\n\t\t\t}\n\t\t\t\n\t\t\tdouble l = 0 , r = 1000;\n//\t\t\t\n//\t\t\tdebug(ds);\n\t\t\t\n\t\t\twhile( l - EPS < r ) {\n\t\t\t\tdouble c = (l+r) / 2;\n\t\t\t\tif( r-l < EPS ) break;\n\t\t\t\tif(isHit(c)) r = c;\n\t\t\t\telse l = c;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.printf(\"%.5f\\n\", l);\n\t\t}\n\t}\n\t\n\tboolean isHit(double r) {\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tdouble htmp = min(h[i], r);\n\t\t\tdouble d2 = ds[i] * ds[i];\n\t\t\tif( d2 < EPS ) d2 = 0;\n\t\t\tdouble dh = (r - htmp);\n\t\t\tdh *= dh;\n\t\t\tif( dh < EPS ) dh = 0;\n\t\t\t\n\t\t\td2 += dh;\n\t\t\td2 = sqrt(d2);\n\t\t\t\n//\t\t\tdebug( d2, r );\n\t\t\tif( d2 + EPS < r ) return true; \n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tdouble disSP(P p1, P p2, P q) {\n\t\tif( p2.sub(p1).dot(q.sub(p1)) < EPS ) return q.sub(p1).d();\n\t\tif( p1.sub(p2).dot(q.sub(p2)) < EPS ) return q.sub(p2).d();\n\t\treturn disLP(p1, p2, q);\n\t}\n\t\n\tdouble disLP(P p1, P p2, P q) {\n\t\treturn abs(p1.sub(p2).det(q.sub(p2))) / p1.sub(p2).d();\n\t}\n\t\n\tboolean cross(P p1, P p2, P q1, P q2) {\n\t\tdouble a1 = p1.sub(p2).det(p1.sub(q1));\n\t\tdouble a2 = p1.sub(p2).det(p1.sub(q2));\n\t\tdouble b1 = q1.sub(q2).det(q1.sub(p1));\n\t\tdouble b2 = q1.sub(q2).det(q1.sub(p2));\n\t\treturn a1 * a2 < EPS && b1 * b2 < EPS;\n\t}\n\t\n\tclass P {\n\t\tdouble x, y;\n\t\tP(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tP add(P p) {\n\t\t\treturn new P(x+p.x, y+p.y);\n\t\t}\n\t\t\n\t\tP sub(P p) {\n\t\t\treturn new P(x-p.x, y-p.y);\n\t\t}\n\t\t\n\t\tdouble dot(P p) {\n\t\t\treturn x*p.x + y*p.y;\n\t\t}\n\t\t\n\t\tdouble det(P p) {\n\t\t\treturn x*p.y - y*p.x;\n\t\t}\n\t\t\n\t\tdouble d() {\n\t\t\tdouble d = sqrt(x*x + y*y);\n\t\t\tif( d < EPS ) return 0;\n\t\t\treturn d;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.awt.geom.Line2D.Double;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tdouble sx = sc.nextDouble();\n\t\t\tdouble sy = sc.nextDouble();\n\t\t\tdouble ex = sc.nextDouble();\n\t\t\tdouble ey = sc.nextDouble();\n\t\t\t\n\t\t\tLine2D.Double se = new Line2D.Double(sx,sy,ex,ey);\n\t\t\tLine2D.Double[] q = new Line2D.Double[4];\n\t\t\tPoint2D.Double[] p = new Point2D.Double[4];\n\t\t\tdouble ans = Integer.MAX_VALUE;\n\t\t\tboolean flag = false;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble minx = sc.nextDouble();\n\t\t\t\tdouble miny = sc.nextDouble();\n\t\t\t\tdouble maxx = sc.nextDouble();\n\t\t\t\tdouble maxy = sc.nextDouble();\n\t\t\t\tdouble h = sc.nextDouble();\n\t\t\t\tif(flag==false){\n\t\t\t\t\tp[0] = new Point2D.Double(minx,miny);\n\t\t\t\t\tp[1] = new Point2D.Double(maxx,miny);\n\t\t\t\t\tp[2] = new Point2D.Double(maxx,maxy);\n\t\t\t\t\tp[3] = new Point2D.Double(minx,maxy);\n\t\t\t\t\tq[0] = new Line2D.Double(p[0],p[1]);\n\t\t\t\t\tq[1] = new Line2D.Double(p[1],p[2]);\n\t\t\t\t\tq[2] = new Line2D.Double(p[2],p[3]);\n\t\t\t\t\tq[3] = new Line2D.Double(p[3],p[0]);\n\t\t\t\t\t\n\t\t\t\t\tif(minx<=sx && sx<=maxx && miny<=sy && sy<=maxy && minx<=ex && ex<=maxx && miny<=ey && ey<=maxy) flag = true;\n\t\t\t\t\tdouble min = Integer.MAX_VALUE;\n\t\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\t\tif(se.intersectsLine(q[j])==true) flag = true;\n\t\t\t\t\t\tmin = Math.min(min, se.ptSegDist(p[j]));\n\t\t\t\t\t\tmin = Math.min(min, q[j].ptSegDist(sx,sy));\n\t\t\t\t\t\tmin = Math.min(min, q[j].ptSegDist(ex,ey));\n\t\t\t\t\t}\n\t\t\t\t\tif(h>min) ans = Math.min(ans, min);\n\t\t\t\t\telse ans = Math.min(ans, (min*min+h*h)/(2*h));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(flag==true) System.out.println(0);\n\t\t\telse System.out.println(ans);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Roll-A-Big-Ball\npublic class Main{\n\nfinal double EPS = 1e-8;\n\t\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(Math.abs(cross(sub(b, a), sub(t, s)))<EPS){\n\t\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))))<EPS;\n\t\t}\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<0;\n\t}\n\t//Segment a-b Point p\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\t//Segment a-b Segment s-t\n\tdouble dist(double[] a, double[] b, double[] s, double[] t){\n\t\tif(crossing(a, b, s, t))return 0;\n\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))));\n\t}\n\t\n\tdouble[] S, T;\n\tdouble[][][] p;\n\t\n\tboolean in(int k){\n\t\tdouble area = norm(p[k][0], p[k][1])*norm(p[k][1], p[k][2]);\n\t\tdouble s = 0;\n\t\tfor(int i=0;i<4;i++)s+=area(p[k][i], p[k][(i+1)%4], S);\n\t\treturn Math.abs(area-s)<EPS;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tS = new double[]{sc.nextDouble(), sc.nextDouble()}; T = new double[]{sc.nextDouble(), sc.nextDouble()};\n\t\t\tp = new double[n][4][2];\n\t\t\tdouble[] h = new double[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble x1 = sc.nextDouble(), y1 = sc.nextDouble(), x2 = sc.nextDouble(), y2 = sc.nextDouble();\n\t\t\t\th[i] = sc.nextDouble();\n\t\t\t\tp[i][0] = new double[]{x1, y1};\n\t\t\t\tp[i][1] = new double[]{x2, y1};\n\t\t\t\tp[i][2] = new double[]{x2, y2};\n\t\t\t\tp[i][3] = new double[]{x1, y2};\n//\t\t\t\tfor(int j=0;j<4;j++){\n//\t\t\t\t\tSystem.out.println(crossing(S, T, p[i][j], p[i][(j+1)%4]));\n//\t\t\t\t\tSystem.out.println(dist(S, T, p[i][j], p[i][(j+1)%4]));\n//\t\t\t\t}\n\t\t\t}\n\t\t\tdouble R = 1000;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(in(i)){\n\t\t\t\t\tR = 0; break;\n\t\t\t\t}\n\t\t\t\tdouble d = 1<<29;\n\t\t\t\tfor(int j=0;j<4;j++)d = Math.min(d, dist(S, T, p[i][j], p[i][(j+1)%4]));\n\t\t\t\tif(h[i]<d)R = Math.min(R, (h[i]*h[i]+d*d)/2/h[i]);\n\t\t\t\telse R = Math.min(R, d);\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.6f\\n\", R);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint sx = in.nextInt();\n\t\t\tint sy = in.nextInt();\n\t\t\tint ex = in.nextInt();\n\t\t\tint ey = in.nextInt();\n\t\t\tPos s = new Pos(sx, sy);\n\t\t\tPos e = new Pos(ex, ey);\n\t\t\tArrayList<Pos> list = new ArrayList<Pos>();\n\t\t\tboolean zero = false;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint lx = in.nextInt();\n\t\t\t\tint ly = in.nextInt();\n\t\t\t\tint rx = in.nextInt();\n\t\t\t\tint ry = in.nextInt();\n\t\t\t\tint h = in.nextInt();\n\t\t\t\tif(zero) continue;\n\t\t\t\tPos[] p = {\n\t\t\t\t\t\tnew Pos(lx, ly),\n\t\t\t\t\t\tnew Pos(lx, ry),\n\t\t\t\t\t\tnew Pos(rx, ry),\n\t\t\t\t\t\tnew Pos(rx, ly),\n\t\t\t\t};\n\t\t\t\tdouble minLen = 100000000;\n\t\t\t\tdouble sign = 0;\n\t\t\t\tboolean inter = true;\n\t\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t\tif(cross(p[j], p[(j+1)%4], s, e)){\n\t\t\t\t\t\tzero = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdouble l = Math.abs(dist(s, e, p[j]));\n\t\t\t\t\tl = Math.min(l, Math.abs(sign = dist(p[j], p[(j+1)%4], s)));\n\t\t\t\t\tl = Math.min(l, Math.abs(dist(p[j], p[(j+1)%4], e)));\n\t\t\t\t\tminLen = Math.min(minLen, l);\n\t\t\t\t\tif(sign > 0 || minLen == 0) inter = false;\n\t\t\t\t}\n\t\t\t\tif(inter) zero = true;\n\t\t\t\tlist.add(new Pos(minLen, h));\n\t\t\t}\n\t\t\tif(zero){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.println(binarySearch(list));\n\t\t}\n\t}\n\t\n\tpublic static final int times = 5000;\n\tpublic static double binarySearch(ArrayList<Pos> list){\n\t\tdouble max = 1000;\n\t\tdouble min = 0;\n\t\tdouble mid = 0;\n\t\tfor(int i=0; i<times; i++){\n\t\t\tmid = (max+min)/2;\n\t\t\tif(check(mid, list)){\n\t\t\t\tmin = mid;\n\t\t\t}else{\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\t\n\tpublic static boolean check(double r, ArrayList<Pos> list){\n\t\tfor(Pos p: list){\n\t\t\tdouble h = p.y;\n\t\t\tif(h > r) h = r;\n\t\t\tPos o = new Pos(0, r);\n\t\t\tif(o.dist2(p) < r*r) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static double triarea(Pos a, Pos b, Pos c){\n\t\tdouble dx1 = b.x - a.x;\n\t\tdouble dy1 = b.y - a.y;\n\t\tdouble dx2 = c.x - a.x;\n\t\tdouble dy2 = c.y - a.y;\n\t\treturn dx1*dy2 - dx2*dy1;\n\t}\n\t\n\tpublic static boolean cross(Pos a1, Pos a2, Pos b1, Pos b2){\n\t\treturn triarea(a1, a2, b1)*triarea(a1, a2, b2) <= 0\n\t\t\t\t&& triarea(b1, b2, a1)*triarea(b1, b2, a2) <= 0;\n\t}\n\t\n\tpublic static double dist(Pos a, Pos b, Pos c){\n\t\t// a->b ??¨ c??¨????????¢\n\t\tif(dot(b.x-a.x, b.y-a.y, c.x-a.x, c.y-a.y) <= 0)\n\t\t\treturn Math.sqrt(a.dist2(c));\n\t\tif(dot(a.x-b.x, a.y-b.y, c.x-b.x, c.y-b.y) <= 0)\n\t\t\treturn Math.sqrt(b.dist2(c));\n\t\treturn triarea(a, b, c)/Math.sqrt(a.dist2(b));\n\t}\n\t\n\tpublic static double dot(double x, double y, double x1, double y2){\n\t\treturn x*x1 + y*y2;\n\t}\n\t\n\tpublic static double dot(Pos a, Pos b){\n\t\treturn a.x*b.x + a.y*b.y;\n\t}\n}\n\nclass Pos{\n\tdouble x, y;\n\tpublic Pos(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic double dist2(Pos p){\n\t\treturn (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-10;\n\tP s, g;\n\tint n;\n\tdouble[] ds;\n\tdouble[] h;\n\t\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\ts = new P(sc.nextDouble(), sc.nextDouble());\n\t\t\tg = new P(sc.nextDouble(), sc.nextDouble());\n\t\t\t\n\t\t\th = new double[n];\n\t\t\tds = new double[n];\n\t\t\t\n\t\t\tfor(int c=0;c<n;c++) {\n\t\t\t\tint[][] p = new int[2][2];\n\t\t\t\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++) p[i][j] = sc.nextInt();\n\t\t\t\t\n\t\t\t\tds[c] = INF;\n\t\t\t\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++) {\n\t\t\t\t\tdouble tmp = disSP(s, g, new P(p[i][0], p[j][1]));\n\t\t\t\t\tds[c] = min(tmp, ds[c]);\n//\t\t\t\t\tdebug(ds);\n\t\t\t\t\ttmp = disSP ( new P(p[i][0], p[j][1]), new P(p[i][0], p[(j+1)%2][1]), s );\n\t\t\t\t\tds[c] = min(tmp, ds[c]);\n\t\t\t\t\t\n\t\t\t\t\ttmp = disSP ( new P(p[i][0], p[j][1]), new P(p[(i+1)%2][0], p[j][1]), s );\n\t\t\t\t\tds[c] = min(tmp, ds[c]);\n\t\t\t\t\t\n\t\t\t\t\ttmp = disSP ( new P(p[i][0], p[j][1]), new P(p[i][0], p[(j+1)%2][1]), g );\n\t\t\t\t\tds[c] = min(tmp, ds[c]);\n\t\t\t\t\t\n\t\t\t\t\ttmp = disSP ( new P(p[i][0], p[j][1]), new P(p[(i+1)%2][0], p[j][1]), g );\n\t\t\t\t\tds[c] = min(tmp, ds[c]);\n//\t\t\t\t\tdebug(ds);\n\t\t\t\t\t\n\t\t\t\t\tif( cross(new P(p[i][0], p[j][1]), new P(p[(i+1)%2][0], p[j][1]), s, g) ) ds[c] = 0;\n\t\t\t\t\tif( cross(new P(p[i][0], p[j][1]), new P(p[i][0], p[(j+1)%2][1]), s, g) ) ds[c] = 0;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( p[0][0] < min(s.x, g.x) && p[0][1] < min(s.y, g.y) && p[1][0] > max(s.x, g.x) && p[1][1] > max(s.y, g.y) )\n\t\t\t\t\tds[c] = 0;\n\t\t\t\t\n\t\t\t\th[c] = sc.nextDouble();\n\t\t\t}\n\t\t\t\n\t\t\tdouble l = 0 , r = 1000;\n//\t\t\t\n//\t\t\tdebug(ds);\n\t\t\t\n\t\t\twhile( l - EPS < r ) {\n\t\t\t\tdouble c = (l+r) / 2;\n\t\t\t\tif( r-l < EPS ) break;\n\t\t\t\tif(isHit(c)) r = c;\n\t\t\t\telse l = c;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.printf(\"%.5f\\n\", l);\n\t\t}\n\t}\n\t\n\tboolean isHit(double r) {\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tdouble htmp = min(h[i], r);\n\t\t\tdouble d2 = ds[i] * ds[i];\n\t\t\tif( d2 < EPS ) d2 = 0;\n\t\t\tdouble dh = (r - htmp);\n\t\t\tdh *= dh;\n\t\t\tif( dh < EPS ) dh = 0;\n\t\t\t\n\t\t\td2 += dh;\n\t\t\td2 = sqrt(d2);\n\t\t\t\n//\t\t\tdebug( d2, r );\n\t\t\tif( d2 + EPS < r ) return true; \n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tdouble disSP(P p1, P p2, P q) {\n\t\tif( p2.sub(p1).dot(q.sub(p1)) < EPS ) return q.sub(p1).d();\n\t\tif( p1.sub(p2).dot(q.sub(p2)) < EPS ) return q.sub(p2).d();\n\t\treturn disLP(p1, p2, q);\n\t}\n\t\n\tdouble disLP(P p1, P p2, P q) {\n\t\treturn abs(p1.sub(p2).det(q.sub(p2))) / p1.sub(p2).d();\n\t}\n\t\n\tboolean cross(P p1, P p2, P q1, P q2) {\n\t\treturn ccw(p1, p2, q1) * ccw(p1, p2, q2) <= 0 &&\n\t\t\tccw(q1, q2, p1) * ccw(q1, q2, p2) <= 0;\n\t}\n\t\n\tint ccw (P a, P b, P c) {\n\t\tP s = b.sub(a);\n\t\tP t = c.sub(a);\n\t\tif( s.det(t) > EPS ) return 1;\n\t\tif( s.det(t) < -EPS ) return -1;\n\t\tif( s.dot(t) < -EPS ) return 2;\n\t\tif( s.dot(s) + EPS < t.dot(t) ) return -2;\n\t\treturn 0;\n\t}\n\t\n\tclass P {\n\t\tdouble x, y;\n\t\tP(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tP add(P p) {\n\t\t\treturn new P(x+p.x, y+p.y);\n\t\t}\n\t\t\n\t\tP sub(P p) {\n\t\t\treturn new P(x-p.x, y-p.y);\n\t\t}\n\t\t\n\t\tdouble dot(P p) {\n\t\t\treturn x*p.x + y*p.y;\n\t\t}\n\t\t\n\t\tdouble det(P p) {\n\t\t\treturn x*p.y - y*p.x;\n\t\t}\n\t\t\n\t\tdouble d() {\n\t\t\tdouble d = sqrt(x*x + y*y);\n\t\t\tif( d < EPS ) return 0;\n\t\t\treturn d;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint sx = in.nextInt();\n\t\t\tint sy = in.nextInt();\n\t\t\tint ex = in.nextInt();\n\t\t\tint ey = in.nextInt();\n\t\t\tPos s = new Pos(sx, sy);\n\t\t\tPos e = new Pos(ex, ey);\n\t\t\tArrayList<Pos> list = new ArrayList<Pos>();\n\t\t\tboolean zero = false;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint lx = in.nextInt();\n\t\t\t\tint ly = in.nextInt();\n\t\t\t\tint rx = in.nextInt();\n\t\t\t\tint ry = in.nextInt();\n\t\t\t\tint h = in.nextInt();\n\t\t\t\tif(zero) continue;\n\t\t\t\tPos[] p = {\n\t\t\t\t\t\tnew Pos(lx, ly),\n\t\t\t\t\t\tnew Pos(lx, ry),\n\t\t\t\t\t\tnew Pos(rx, ry),\n\t\t\t\t\t\tnew Pos(rx, ly),\n\t\t\t\t};\n\t\t\t\tdouble minLen = 100000000;\n\t\t\t\tdouble sign = 0;\n\t\t\t\tboolean inter = true;\n\t\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t\tif(cross(p[j], p[(j+1)%4], s, e)){\n\t\t\t\t\t\tzero = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdouble l = Math.abs(dist(s, e, p[j]));\n\t\t\t\t\tl = Math.min(l, Math.abs(sign = dist(p[j], p[(j+1)%4], s)));\n\t\t\t\t\tl = Math.min(l, Math.abs(dist(p[j], p[(j+1)%4], e)));\n\t\t\t\t\tminLen = Math.min(minLen, l);\n\t\t\t\t\tif(sign > 0) inter = false;\n\t\t\t\t}\n\t\t\t\tif(inter || minLen == 0) zero = true;\n\t\t\t\tlist.add(new Pos(minLen, h));\n\t\t\t}\n\t\t\tif(zero){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.println(binarySearch(list));\n\t\t}\n\t}\n\t\n\tpublic static final int times = 5000;\n\tpublic static double binarySearch(ArrayList<Pos> list){\n\t\tdouble max = 1000;\n\t\tdouble min = 0;\n\t\tdouble mid = 0;\n\t\tfor(int i=0; i<times; i++){\n\t\t\tmid = (max+min)/2;\n\t\t\tif(check(mid, list)){\n\t\t\t\tmin = mid;\n\t\t\t}else{\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\t\n\tpublic static boolean check(double r, ArrayList<Pos> list){\n\t\tfor(Pos p: list){\n\t\t\tdouble h = p.y;\n\t\t\tif(h > r) h = r;\n\t\t\tPos o = new Pos(0, r);\n\t\t\tif(o.dist2(p) < r*r) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static double triarea(Pos a, Pos b, Pos c){\n\t\tdouble dx1 = b.x - a.x;\n\t\tdouble dy1 = b.y - a.y;\n\t\tdouble dx2 = c.x - a.x;\n\t\tdouble dy2 = c.y - a.y;\n\t\treturn dx1*dy2 - dx2*dy1;\n\t}\n\t\n\tpublic static boolean cross(Pos a1, Pos a2, Pos b1, Pos b2){\n\t\treturn triarea(a1, a2, b1)*triarea(a1, a2, b2) <= 0\n\t\t\t\t&& triarea(b1, b2, a1)*triarea(b1, b2, a2) <= 0;\n\t}\n\t\n\tpublic static double dist(Pos a, Pos b, Pos c){\n\t\t// a->b ??¨ c??¨????????¢\n\t\tif(dot(b.x-a.x, b.y-a.y, c.x-a.x, c.y-a.y) <= 0)\n\t\t\treturn Math.sqrt(a.dist2(c));\n\t\tif(dot(a.x-b.x, a.y-b.y, c.x-b.x, c.y-b.y) <= 0)\n\t\t\treturn Math.sqrt(b.dist2(c));\n\t\treturn triarea(a, b, c)/Math.sqrt(a.dist2(b));\n\t}\n\t\n\tpublic static double dot(double x, double y, double x1, double y2){\n\t\treturn x*x1 + y*y2;\n\t}\n\t\n\tpublic static double dot(Pos a, Pos b){\n\t\treturn a.x*b.x + a.y*b.y;\n\t}\n}\n\nclass Pos{\n\tdouble x, y;\n\tpublic Pos(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic double dist2(Pos p){\n\t\treturn (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": " \nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tdouble calc(Line2D.Double line, double x, double y, double h) {\n\t\tdouble d1 = line.ptSegDist(x, y);\n\t\tdouble d2 = (d1 * d1 + h * h) / (2 * h);\n\t\treturn d1 <= h ? d1 : d2;\n\t}\n\t\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint N = in.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tint sx = in.nextInt(), sy = in.nextInt(), ex = in.nextInt(), ey = in.nextInt();\n\t\t\tLine2D.Double line = new Line2D.Double(sx, sy, ex, ey);\n\t\t\t\n\t\t\tdouble rmax = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint minx = in.nextInt(), miny = in.nextInt();\n\t\t\t\tint maxx = in.nextInt(), maxy = in.nextInt();\n\t\t\t\tint h = in.nextInt();\n\t\t\t\t\n\t\t\t\tRectangle2D.Double rect = \n\t\t\t\t\t\tnew Rectangle2D.Double(minx, miny, maxx - minx, maxy - miny);\n\t\t\t\tif (line.intersectsLine(minx, miny, minx, maxy)) rmax = 0;\n\t\t\t\tif (line.intersectsLine(minx, miny, maxx, miny)) rmax = 0;\n\t\t\t\tif (line.intersectsLine(maxx, maxy, minx, maxy)) rmax = 0;\n\t\t\t\tif (line.intersectsLine(maxx, maxy, maxx, miny)) rmax = 0;\n\t\t\t\tif (rect.contains(sx, sy)) rmax = 0;\n\t\t\t\tif (rect.contains(ex, ey)) rmax = 0;\n\n\t\t\t\trmax = Math.min(rmax, calc(line, minx, miny, h));\n\t\t\t\trmax = Math.min(rmax, calc(line, minx, maxy, h));\n\t\t\t\trmax = Math.min(rmax, calc(line, maxx, miny, h));\n\t\t\t\trmax = Math.min(rmax, calc(line, maxx, maxy, h));\n\t\t\t\tif (minx <= sx && sx <= maxx) {\n\t\t\t\t\trmax = Math.min(rmax, calc(line, sx, miny, h));\n\t\t\t\t\trmax = Math.min(rmax, calc(line, sx, maxy, h));\n\t\t\t\t}\n\t\t\t\tif (miny <= sy && sy <= maxy) {\n\t\t\t\t\trmax = Math.min(rmax, calc(line, minx, sy, h));\n\t\t\t\t\trmax = Math.min(rmax, calc(line, maxx, sy, h));\n\t\t\t\t}\n\t\t\t\tif (minx <= ex && ex <= maxx) {\n\t\t\t\t\trmax = Math.min(rmax, calc(line, ex, miny, h));\n\t\t\t\t\trmax = Math.min(rmax, calc(line, ex, maxy, h));\n\t\t\t\t}\n\t\t\t\tif (miny <= ey && ey <= maxy) {\n\t\t\t\t\trmax = Math.min(rmax, calc(line, minx, ey, h));\n\t\t\t\t\trmax = Math.min(rmax, calc(line, maxx, ey, h));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.5f\\n\", rmax);\n\t\t}\n\t}\t\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tdouble calc(Line2D.Double line, double x, double y, double h) {\n\t\tdouble d1 = line.ptSegDist(x, y);\n\t\tdouble d2 = (d1 * d1 + h * h) / (2 * h);\n\t\treturn Math.max(d1, d2);\n\t}\n\t\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint N = in.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tint sx = in.nextInt(), sy = in.nextInt(), ex = in.nextInt(), ey = in.nextInt();\n\t\t\tLine2D.Double line = new Line2D.Double(sx, sy, ex, ey);\n\t\t\t\n\t\t\tdouble rmax = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint minx = in.nextInt(), miny = in.nextInt();\n\t\t\t\tint maxx = in.nextInt(), maxy = in.nextInt();\n\t\t\t\tint h = in.nextInt();\n\t\t\t\t\n\t\t\t\tRectangle2D.Double rect = \n\t\t\t\t\t\tnew Rectangle2D.Double(minx, miny, maxx - minx, maxy - miny);\n\t\t\t\tif (line.intersectsLine(minx, miny, minx, maxy)) rmax = 0;\n\t\t\t\tif (line.intersectsLine(minx, miny, maxx, miny)) rmax = 0;\n\t\t\t\tif (line.intersectsLine(maxx, maxy, minx, maxy)) rmax = 0;\n\t\t\t\tif (line.intersectsLine(maxx, maxy, maxx, miny)) rmax = 0;\n\t\t\t\tif (rect.contains(sx, sy)) rmax = 0;\n\t\t\t\tif (rect.contains(ex, ey)) rmax = 0;\n\t\t\t\t\n\t\t\t\trmax = Math.min(rmax, calc(line, minx, miny, h));\n\t\t\t\trmax = Math.min(rmax, calc(line, minx, maxy, h));\n\t\t\t\trmax = Math.min(rmax, calc(line, maxx, miny, h));\n\t\t\t\trmax = Math.min(rmax, calc(line, maxx, maxy, h));\n\t\t\t\tif (minx <= sx && sx <= maxx) {\n\t\t\t\t\trmax = Math.min(rmax, calc(line, sx, miny, h));\n\t\t\t\t\trmax = Math.min(rmax, calc(line, sx, maxy, h));\n\t\t\t\t}\n\t\t\t\tif (miny <= sy && sy <= maxy) {\n\t\t\t\t\trmax = Math.min(rmax, calc(line, minx, sy, h));\n\t\t\t\t\trmax = Math.min(rmax, calc(line, maxx, sy, h));\n\t\t\t\t}\n\t\t\t\tif (minx <= ex && ex <= maxx) {\n\t\t\t\t\trmax = Math.min(rmax, calc(line, ex, miny, h));\n\t\t\t\t\trmax = Math.min(rmax, calc(line, ex, maxy, h));\n\t\t\t\t}\n\t\t\t\tif (miny <= ey && ey <= maxy) {\n\t\t\t\t\trmax = Math.min(rmax, calc(line, minx, ey, h));\n\t\t\t\t\trmax = Math.min(rmax, calc(line, maxx, ey, h));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(rmax);\n\t\t}\n\t}\t\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS 1e-10\n#define EQ(a,b) (abs(a - b) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n//外積\ndouble cross (P a, P b) {return (a.real() * b.imag() - a.imag() * b.real());}\n\n//内積\ndouble dot (P a, P b) {return (a.real() * b.real() + a.imag() * b.imag());}\n\n//直行\nbool is_orthogonal(P a1, P a2, P b1, P b2) {return EQ( dot(a1 - a2, b1 - b2), 0.0);}\n\n//平行\nbool is_parallel(P a1, P a2, P b1, P b2) {return EQ( cross(a1 - a2, b1 - b2), 0.0);}\n\n//直線上\nbool is_point_on_vector(P a, P b, P c) {return EQ( cross(a - c, c - b), 0.0);}\n\n//線分上\nbool is_point_on_line (P a, P b, P c) {return (abs(a - c) + abs(c - b) < abs(a - b) + EPS);}\n\n//角度　線分の距離は小数点以下３桁まで\ndouble angle (P a, P b, P p) {return (acos(dot(a-p,b-p) / (abs(a-p) * abs(b-p))) * 180.0 / M_PI);}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_l(P a1, P a2, P b1, P b2) {return !EQ( cross(a1-a2, b1-b2), 0.0 );}\n\n// 点a,bを通る直線と点cとの距離\ndouble distance_l_p(P a, P b, P c) {return abs(cross(b-a, c-a)) / abs(b-a);}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2 - a1; P b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n    if ( dot(b-a, c-a) < EPS ) return fabs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return fabs(c-b);\n    return fabs(cross(b-a, c-a)) / fabs(b-a);\n}\n\n/***************************************\n *\n * 2点を通る直線とある点からの垂線との交点\n *\n * a, b を直線\n * p    をある点\n *\n ***************************************/\nP crossNormalVector (P a, P b, P p) {\n    double t = dot(b-a, p-a) / (abs(b-a) * abs(b - a));\n    return a + t * (b - a);\n}\n\ndouble calc (double h, double r) {\n    if (h > r) h = r;\n    return (r * r + h * h) / (2 * h);\n}\n\nint main ()\n{\n    int n;\n    while (cin >> n, n) {\n        double sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        P s(sx, sy), e(ex, ey);\n\n        double res_h = 100000.;\n        while (n--) {\n            // cout << \"Count # \" << n << endl;\n            \n            double minx, miny, maxx, maxy;\n\n            double h;\n            cin >> minx >> miny >> maxx >> maxy >> h;\n            vector<P> v = { P(minx, miny), P(minx, maxy), P(maxx, maxy), P(maxx, miny)};\n\n            if (minx <= s.real() && s.real() <= maxx && miny <= s.imag() && s.imag() <= maxy) res_h = 0.;\n            if (minx <= e.real() && e.real() <= maxx && miny <= e.imag() && e.imag() <= maxy) res_h = 0.;\n\n            for (int i = 0; i < 4; i++) {\n                int anf = (i + 1) % 4, bfr = (i + 4 - 1) % 4;\n                int now = i;\n\n                if (is_intersected_ls(e, s, v[now], v[anf])) res_h = 0.;\n                if (is_intersected_ls(e, s, v[now], v[bfr])) res_h = 0.;\n                \n                // cout << \"DBG > \" << min(v[now].real(), v[anf].real()) << \" \" << max(v[now].real(), v[anf].real()) << endl;\n                // cout << \"      \" << min(v[now].imag(), v[anf].imag()) << \" \" << max(v[now].imag(), v[anf].imag()) << endl;\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[anf], s)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[bfr], s)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[anf], e)));\n                res_h = min(res_h, calc(h, distance_ls_p(v[now], v[bfr], e)));\n                // res_h = min(res_h, calc(h, min(abs(minx - s.real()), abs(maxx - s.real()))));\n                // res_h = min(res_h, calc(h, min(abs(miny - s.imag()), abs(maxy - s.imag()))));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[now])));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[anf])));\n                res_h = min(res_h, calc(h, distance_ls_p(s, e, v[bfr])));\n            }\n        }\n\n        printf(\"%.4f\\n\", res_h);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "Ruby",
    "code": "class Line\n\tinclude Math\n\n\tdef self.through_two_points(x1, y1, x2, y2)\n\t\ta = y1 - y2\n\t\tb = x2 - x1\n\t\tc = a * x1 + b * y1\n\t\tnew(a, b, c, x1, y1, x2, y2)\n\tend\n\n\tdef parallel?(l)\n\t\t@a * l.b == @b * l.a\n\tend\n\n\tdef cross?(l)\n\t\treturn false if parallel?(l)\n\t\t(@a * l.x1 + @b * l.y1 - @c) * (@a * l.x2 + @b * l.y2 - @c) <= 0 &&\n\t\t(l.a * @x1 + l.b * @y1 - l.c) * (l.a * @x2 + l.b * @y2 - l.c) <= 0\n\tend\n\n\tdef dist(x, y)\n\t\ta = hypot(@x1 - x, @y1 - y)\n\t\tb = hypot(@x2 - x, @y2 - y)\n\t\tc = hypot(@x1 - @x2, @y1 - @y2)\n\t\treturn a if a*a + c*c < b*b\n\t\treturn b if b*b + c*c < a*a\n\t\t(@a * x + @b * y - @c).abs / sqrt(@a ** 2 + @b ** 2)\n\tend\n\n\tprivate_class_method :new\n\n\tdef initialize(*args)\n\t\t@a, @b, @c, @x1, @y1, @x2, @y2 = args\t\n\t\tif @a < 0\n\t\t\t@a *= -1\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\telsif @a == 0 && @b < 0\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\tend\n\tend\n\n\tattr_reader :a, :b, :c, :x1, :y1, :x2, :y2\nend\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\txs, ys, xe, ye = gets.split.map(&:to_i)\n\tcourse = Line.through_two_points(xs, ys, xe, ye)\n\tblocks = (1..n).map {gets.split.map(&:to_i)}\n\trs = blocks.map do |x1, y1, x2, y2, h|\n\t\tnext 0 if x1 <= xs && xs <= x2 && y1 <= ys && ys <= y2\n\t\tnext 0 if x1 <= xe && xe <= x2 && y1 <= ye && ye <= y2\n\n\t\tl = Line.through_two_points(x1, y1, x1, y2)\n\t\tnext 0 if l.cross?(course)\n\t\tr = Line.through_two_points(x2, y1, x2, y2)\n\t\tnext 0 if r.cross?(course)\n\t\tb = Line.through_two_points(x1, y1, x2, y1)\n\t\tnext 0 if b.cross?(course)\n\t\tt = Line.through_two_points(x1, y2, x2, y2)\n\t\tif t.cross?(course)\n\t\t\tp course\n\t\t\tp t\n\t\t\tnext 0\n\t\tend\n\n\t\tds = [\n\t\t\tcourse.dist(x1, y1),\n\t\t\tcourse.dist(x1, y2),\n\t\t\tcourse.dist(x2, y1),\n\t\t\tcourse.dist(x2, y2),\n\t\t\tl.dist(course.x1, course.y1),\n\t\t\tr.dist(course.x1, course.y1),\n\t\t\tb.dist(course.x1, course.y1),\n\t\t\tt.dist(course.x1, course.y1),\n\t\t\tl.dist(course.x2, course.y2),\n\t\t\tr.dist(course.x2, course.y2),\n\t\t\tb.dist(course.x2, course.y2),\n\t\t\tt.dist(course.x2, course.y2),\n\t\t]\n\n\t\trs = ds.map do |d|\n\t\t\tif d < h\n\t\t\t\td\n\t\t\telse\n\t\t\t\t(d * d / h + h) / 2\n\t\t\tend\n\t\tend\n\t\t\n\t\trs.min\n\tend\n\tp rs.min\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\n#\n# 1157.rb: Roll-A-Big-Ball\n#\n\n### constant\n\nINF = Float::INFINITY\n\n### subroutines\n\ndef i_prod(vx0, vy0, vx1, vy1)\n  vx0 * vx1 + vy0 * vy1\nend\n\ndef o_prod(vx0, vy0, vx1, vy1)\n  vx0 * vy1 - vy0 * vx1\nend\n\ndef d2_p_seg(px, py, x0, y0, x1, y1)\n  dx01 = x1 - x0\n  dy01 = y1 - y0\n  dx0p = px - x0\n  dy0p = py - y0\n  dx1p = px - x1\n  dy1p = py - y1\n\n  return (dx0p ** 2 + dy0p ** 2) if i_prod(dx01, dy01, dx0p, dy0p) <= 0.0\n  return (dx1p ** 2 + dy1p ** 2) if i_prod(-dx01, -dy01, dx1p, dy1p) <= 0.0\n  o_prod(dx01, dy01, dx0p, dy0p) ** 2 / (dx01 ** 2 + dy01 ** 2)\nend\n\ndef cross_segs?(ax0, ay0, ax1, ay1, bx0, by0, bx1, by1)\n  dax = ax1 - ax0\n  day = ay1 - ay0\n  dbx = bx1 - bx0\n  dby = by1 - by0\n\n  (o_prod(dax, day, bx0 - ax0, by0 - ay0) *\n   o_prod(dax, day, bx1 - ax0, by1 - ay0) <= 0.0 &&\n   o_prod(dbx, dby, ax0 - bx0, ay0 - by0) *\n   o_prod(dbx, dby, ax1 - bx0, ay1 - by0) <= 0.0)\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  sx, sy, ex, ey = gets.split.map(&:to_f)\n  #p [sx, sy, ex, ey]\n\n  rects = n.times.map{gets.split.map(&:to_f)}\n  #p rects\n\n  min_r2 = INF\n\n  rects.each do |minxi, minyi, maxxi, maxyi, hi|\n    pts = [[minxi, minyi], [maxxi, minyi], [maxxi, maxyi], [minxi, maxyi]]\n\n    incl = true\n    min_d2 = INF\n\n    for i in (0...4)\n      j = (i + 1) % 4\n\n      xi, yi = pts[i]\n      xj, yj = pts[j]\n\n      if incl\n        if o_prod(xj - xi, yj - yi, sx - xi, sy - yi) < 0.0 ||\n            o_prod(xj - xi, yj - yi, ex - xi, ey - yi) < 0.0\n          incl = false\n        end\n      end\n\n      if cross_segs?(sx, sy, ex, ey, xi, yi, xj, yj)\n        min_d2 = 0.0\n        break\n      end\n\n      min_d2 = [min_d2,\n                d2_p_seg(sx, sy, xi, yi, xj, yj),\n                d2_p_seg(ex, ey, xi, yi, xj, yj),\n                d2_p_seg(xi, yi, sx, sy, ex, ey),\n                d2_p_seg(xj, yj, sx, sy, ex, ey)].min\n      break if min_d2 == 0.0\n    end\n\n    if incl || min_d2 == 0.0\n      min_r2 = 0.0\n      break\n    end\n\n    r2 = 0.0\n    h2 = hi ** 2\n\n    if min_d2 <= h2\n      r2 = min_d2\n    else\n      r2 = ((min_d2 + h2) / (2 * hi)) ** 2\n    end\n\n    min_r2 = r2 if min_r2 > r2\n  end\n\n  puts Math.sqrt(min_r2)\nend"
  },
  {
    "language": "Ruby",
    "code": "class Line\n\tinclude Math\n\n\tdef self.through_two_points(x1, y1, x2, y2)\n\t\ta = y1 - y2\n\t\tb = x2 - x1\n\t\tc = a * x1 + b * y1\n\t\tnew(a, b, c, x1, y1, x2, y2)\n\tend\n\n\tdef cross?(l)\n\t\t(@a * l.x1 + @b * l.y1 - @c) * (@a * l.x2 + @b * l.y2 - @c) <= 0 &&\n\t\t(l.a * @x1 + l.b * @y1 - l.c) * (l.a * @x2 + l.b * @y2 - l.c) <= 0\n\tend\n\n\tdef dist(x, y)\n\t\ta = hypot(@x1 - x, @y1 - y)\n\t\tb = hypot(@x2 - x, @y2 - y)\n\t\tc = hypot(@x1 - @x2, @y1 - @y2)\n\t\treturn a if a*a + c*c < b*b\n\t\treturn b if b*b + c*c < a*a\n\t\t(@a * x + @b * y - @c).abs / sqrt(@a ** 2 + @b ** 2)\n\tend\n\n\tprivate_class_method :new\n\n\tdef initialize(*args)\n\t\t@a, @b, @c, @x1, @y1, @x2, @y2 = args\t\n\t\tif @a < 0\n\t\t\t@a *= -1\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\telsif @a == 0 && @b < 0\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\tend\n\tend\n\n\tattr_reader :a, :b, :c, :x1, :y1, :x2, :y2\nend\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\txs, ys, xe, ye = gets.split.map(&:to_i)\n\tcourse = Line.through_two_points(xs, ys, xe, ye)\n\tblocks = (1..n).map {gets.split.map(&:to_i)}\n\trs = blocks.map do |x1, y1, x2, y2, h|\n\t\tnext 0 if x1 <= xs && xs <= x2 && y1 <= ys && ys <= y2\n\t\tnext 0 if x2 <= xs && xs <= x2 && y2 <= ys && ys <= y2\n\n\t\tl = Line.through_two_points(x1, y1, x1, y2)\n\t\tnext 0 if l.cross?(course)\n\t\tr = Line.through_two_points(x2, y1, x2, y2)\n\t\tnext 0 if r.cross?(course)\n\t\td = Line.through_two_points(x1, y1, x2, y1)\n\t\tnext 0 if d.cross?(course)\n\t\tu = Line.through_two_points(x1, y2, x2, y2)\n\t\tnext 0 if u.cross?(course)\n\n\t\tds = [\n\t\t\tcourse.dist(x1, y1),\n\t\t\tcourse.dist(x1, y2),\n\t\t\tcourse.dist(x2, y1),\n\t\t\tcourse.dist(x2, y2),\n\t\t\tl.dist(course.x1, course.y1),\n\t\t\tr.dist(course.x1, course.y1),\n\t\t\td.dist(course.x1, course.y1),\n\t\t\tu.dist(course.x1, course.y1),\n\t\t\tl.dist(course.x2, course.y2),\n\t\t\tr.dist(course.x2, course.y2),\n\t\t\td.dist(course.x2, course.y2),\n\t\t\tu.dist(course.x2, course.y2),\n\t\t]\n\n\t\trs = ds.map do |d|\n\t\t\tif d < h\n\t\t\t\td\n\t\t\telse\n\t\t\t\t(d * d / h + h) / 2\n\t\t\tend\n\t\tend\n\t\trs.min\n\tend\n\tp rs.min\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\n#\n# 1157.rb: Roll-A-Big-Ball\n#\n\n### constant\n\nINF = Float::INFINITY\n\n### subroutines\n\ndef i_prod(vx0, vy0, vx1, vy1)\n  vx0 * vx1 + vy0 * vy1\nend\n\ndef o_prod(vx0, vy0, vx1, vy1)\n  vx0 * vy1 - vy0 * vx1\nend\n\ndef d2_p_seg(px, py, x0, y0, x1, y1)\n  dx01 = x1 - x0\n  dy01 = y1 - y0\n  dx0p = px - x0\n  dy0p = py - y0\n  dx1p = px - x1\n  dy1p = py - y1\n\n  return (dx0p ** 2 + dy0p ** 2) if i_prod(dx01, dy01, dx0p, dy0p) <= 0.0\n  return (dx1p ** 2 + dy1p ** 2) if i_prod(-dx01, -dy01, dx1p, dy1p) <= 0.0\n  o_prod(dx01, dy01, dx0p, dy0p) ** 2 / (dx01 ** 2 + dy01 ** 2)\nend\n\ndef cross_segs?(ax0, ay0, ax1, ay1, bx0, by0, bx1, by1)\n  dax = ax1 - ax0\n  day = ay1 - ay0\n  dbx = bx1 - bx0\n  dby = by1 - by0\n\n  if o_prod(dax, day, dbx, dby) == 0.0\n    if ay0 * (ax1 - bx0) + ay1 * (bx0 - ax0) * by0 * (ax0 - ax1) == 0.0 &&\n        (i_prod(bx0 - ax0, by0 - ay0, bx1 - ax0, by1 - ax0) <= 0.0 ||\n         i_prod(bx0 - ax1, by0 - ay1, bx1 - ax1, by1 - ax1) <= 0.0 ||\n         i_prod(ax0 - bx0, ay0 - by0, ax1 - bx0, ay1 - bx0) <= 0.0 ||\n         i_prod(ax0 - bx1, ay0 - by1, ax1 - bx1, ay1 - bx1) <= 0.0)\n      return true\n    end\n    return false\n  end\n\n  (o_prod(dax, day, bx0 - ax0, by0 - ay0) *\n   o_prod(dax, day, bx1 - ax0, by1 - ay0) <= 0.0 &&\n   o_prod(dbx, dby, ax0 - bx0, ay0 - by0) *\n   o_prod(dbx, dby, ax1 - bx0, ay1 - by0) <= 0.0)\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  sx, sy, ex, ey = gets.split.map(&:to_f)\n  #p [sx, sy, ex, ey]\n\n  rects = n.times.map{gets.split.map(&:to_f)}\n  #p rects\n\n  min_r2 = INF\n\n  rects.each do |minxi, minyi, maxxi, maxyi, hi|\n    #p [minxi, minyi, maxxi, maxyi, hi]\n\n    pts = [[minxi, minyi], [maxxi, minyi], [maxxi, maxyi], [minxi, maxyi]]\n\n    incl = true\n    min_d2 = INF\n\n    for i in (0...4)\n      j = (i + 1) % 4\n\n      xi, yi = pts[i]\n      xj, yj = pts[j]\n\n      if incl\n        if o_prod(xj - xi, yj - yi, sx - xi, sy - yi) < 0.0 ||\n            o_prod(xj - xi, yj - yi, ex - xi, ey - yi) < 0.0\n          incl = false\n        end\n      end\n\n      if cross_segs?(sx, sy, ex, ey, xi, yi, xj, yj)\n        #p ['cross_segs?', sx, sy, ex, ey, xi, yi, xj, yj]\n        min_d2 = 0.0\n        break\n      end\n\n      min_d2 = [min_d2,\n                d2_p_seg(sx, sy, xi, yi, xj, yj),\n                d2_p_seg(ex, ey, xi, yi, xj, yj),\n                d2_p_seg(xi, yi, sx, sy, ex, ey),\n                d2_p_seg(xj, yj, sx, sy, ex, ey)].min\n      break if min_d2 == 0.0\n    end\n\n    #p [incl, min_d2]\n    if incl || min_d2 == 0.0\n      min_r2 = 0.0\n      break\n    end\n\n    r2 = 0.0\n    h2 = hi ** 2\n\n    if min_d2 <= h2\n      r2 = min_d2\n    else\n      r2 = ((min_d2 + h2) / (2 * hi)) ** 2\n    end\n\n    min_r2 = r2 if min_r2 > r2\n    #p [r2, min_r2]\n  end\n\n  puts Math.sqrt(min_r2)\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nEPS=1e-9\ndef cross(a,b) (a.conj*b).imag end\ndef dot(a,b) (a.conj*b).real end\ndef projection(l,p)\n\tt=dot(p-l[0],l[0]-l[1])/(l[0]-l[1]).abs2\n\tl[0]+t*(l[0]-l[1])\nend\ndef intersectSP(s,p)\n\t(s[0]-p).abs+(s[1]-p).abs-(s[1]-s[0]).abs < EPS # triangle inequality\nend\ndef distanceSP(s,p)\n\tr=projection(s,p)\n\treturn (r-p).abs if intersectSP(s,r)\n\t[(s[0]-p).abs,(s[1]-p).abs].min\nend\ndef distanceSS(s,t)\n\treturn 0 if intersectSS(s,t)\n\t[s.map{|e|distanceSP(t,e)}.min,t.map{|e|distanceSP(s,e)}.min].min\nend\ndef intersectSS(l,m)\n\ta=cross(l[1]-l[0],m[1]-m[0])\n\tb=cross(l[1]-l[0],l[1]-m[0])\n\tpt=a.abs<EPS ? b.abs<EPS ? [l[0],l[1],m[0],m[1]] : [] : [m[0]+b/a*(m[1]-m[0])]\n\tpt.any?{|e|\n\t\tdot(l[0]-e,l[1]-e)<EPS && dot(m[0]-e,m[1]-e)<EPS\n\t}\nend\nwhile(n=gets.to_i)>0\n\tsx,sy,ex,ey=gets.split.map(&:to_f)\n\ts=[Complex(sx,sy),Complex(ex,ey)]\n\tp n.times.map{\n\t\tf=0\n\t\tx1,y1,x2,y2,h=gets.split.map(&:to_f)\n\t\ta=[x1,x2].product([y1,y2]).map{|x,y|Complex(x,y)}\n\t\ta[2],a[3]=a[3],a[2]\n\t\td=4.times.map{|i|\n\t\t\tf+=cross(a[i]-s[0],a[(i+1)%4]-s[0])<EPS ? 1 : 0\n\t\t\tdistanceSS(s,[a[i],a[(i+1)%4]])\n\t\t}.min\n\t\tif f==4 #inside\n\t\t\t0\n\t\telsif d>h\n\t\t\t(h*h+d*d)/h/2\n\t\telse\n\t\t\td\n\t\tend\n\t}.min\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\n/*-----------------------------------*/\nconst EPS = 1e-7;\n\nstruct Point {\n    double x, y;\n    Point opBinary(alias op)(in Point p) const {\n        static if (op == \"+\") {\n            return Point(x + p.x, y + p.y);\n        } else if (op == \"-\") {\n            return Point(x - p.x, y - p.y);\n        }\n    }\n    Point opBinary(alias op)(double k) const {\n        static if (op == \"*\") {\n            return Point(x * k, y * k);\n        } else if (op == \"/\") {\n            return Point(x / k, y / k);\n        }\n    }\n}\ndouble norm(in Point p) {\n    return sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nint ccw(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1; \n    if (cross(b, c) < -EPS) return -1;\n    if (dot(b, c) < 0) return +2;     \n    if (b.norm < c.norm) return -2;  \n    return 0;                       \n}\n\ndouble distance(in Point a, in Point b) {\n    double dx = a.x - b.x,\n           dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\nstruct Segment {\n    Point a, b;\n}\n\ndouble length(in Segment s) {\n    return (s.b - s.a).norm;\n}\n\nbool contains(in Segment s, in Point p) {\n    Point u = s.a - p,\n          v = s.b - p;\n    return abs(cross(u, v)) < EPS && dot(u, v) < -EPS;\n}\n\nPoint projection(in Segment s, in Point p) {\n    Point u = s.b - s.a,\n          v = p - s.a;\n    double n = u.norm;\n    return s.a + u * (dot(u, v) / (n * n));\n}\n\ndouble distance(in Segment s, in Point p) {\n    auto ret = min(distance(p, s.a), distance(p, s.b));\n    Point proj = s.projection(p);\n    if (s.contains(proj)) {\n        ret = min(ret, (p - proj).norm);\n    }\n    return ret;\n}\ndouble distance(in Point p, in Segment s) {\n    return distance(s, p);\n}\n\nbool intersect(in Segment s, in Segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble distance(in Segment s, in Segment t) {\n    if (intersect(s, t)) return 0;\n    return min( distance(s.a, t), distance(s.b, t),\n                distance(s, t.a), distance(s, t.b) );\n}\n\nstruct Line {\n    Point a, b;\n}\nPoint unit(in Line l) {\n    /** l縺ョ蜊倅ス阪?繧ッ繝医Ν */\n    return l.a * (1.0 / norm(l.b - l.a));\n}\nbool intersect(in Line m, in Line n) {\n    double A = cross(m.b - m.a, n.b - n.a),\n           B = cross(m.b - m.a, m.b - n.a);\n    return (abs(A) > EPS || abs(B) < EPS);\n}\nPoint intersection(in Line m, in Line n) {\n    double A = cross(m.b - m.a, n.b - n.a),\n           B = cross(m.b - m.a, m.b - n.a);\n    if (abs(A) < EPS) {\n        if (abs(B) < EPS) return m.a;\n        else assert(0);\n    }\n    return n.a + (n.b - n.a) * B / A;\n}\n\nstruct Circle {\n    Point o;\n    double r;\n}\n\nbool contains(in Circle c, in Point p) {\n    /** 蜀?縺ォp縺悟性縺セ繧後ｋ縺? \n     *    p縺慶縺ョ蜻ィ荳翫↓縺ゅｋ縺ィ縺阪?蜷ォ縺セ繧後ｋ縺ィ縺ソ縺ェ縺?*/\n    return distance(c.o, p) <= c.r + EPS;\n}\n\nLine[2] tangent(in Circle c, in Point p) {\n    /** p繧帝?繧議縺ョ謗・邱壹ｒ霑斐☆.\n     *    霑斐ｊ蛟、縺ョ2逶エ邱嗟, m縺ォ縺、縺?※ l.a == m.a == p */\n    double l1 = distance(c.o, p);\n    double l2 = sqrt(l1 * l1 - c.r * c.r);\n    double d1 = (l2 * l2) / l1;\n    double d2 = (c.r * l2) / l1;\n    Point u = (c.o - p) / norm(c.o - p);\n    Point b = p + u * d1;\n\n    /* u縺ィ逶エ莠、縺吶ｋ蜊倅ス阪?繧ッ繝医Ν */\n    Point o1 = Point(u.y, -u.x),\n          o2 = Point(-u.y, u.x);\n\n    Point a1 = b + o1 * d2,\n          a2 = b + o2 * d2;\n    return [ Line(p, a1), Line(p, a2) ];\n}\n\nstruct Rectangle {\n    Point v[4];\n}\nbool contains(in Rectangle r, in Point p) {\n    /** 髟キ譁ケ蠖「r縺ォp縺悟性縺セ繧後ｋ縺? \n     *    r縺ョ蜻ィ荳翫↓p縺後≠繧九→縺阪?蜷ォ縺セ繧後ｋ縺ィ縺ソ縺ェ縺励※縺?↑縺?     *    蜃ク螟夊ァ貞ス「縺ォ荳?握蛹門庄閭ス */\n    int c = ccw(p, r.v[0], r.v[1]);\n    foreach (i; 0 .. 4) {\n        if (c != ccw(p, r.v[i], r.v[(i + 1) % 4])) return false;\n    }\n    return true;\n}\n\n/*-----------------------------------*/\n\nstruct R {\n    Rectangle r;\n    double h;\n}\n\nvoid main() {\n    int N;\n    Segment course;\n    Segment[] ss;\n    R[] rs;\n    double[2][] hs;\n\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        ss.destroy;\n        hs.destroy;\n        Point s, e;\n        scanf(\"%lf %lf %lf %lf\\n\", &s.x, &s.y, &e.x, &e.y);\n        rs = new R[N];\n        course = Segment(s, e);\n        foreach (ref r; rs) {\n            double minx, miny, maxx, maxy, h;\n            scanf(\"%lf %lf %lf %lf %lf\\n\", &minx, &miny, &maxx, &maxy, &h);\n            r.r.v = [\n                Point(minx, miny),\n                Point(minx, maxy),\n                Point(maxx, maxy),\n                Point(maxx, miny)\n            ];\n            r.h = h;\n        }\n        return true;\n    }\n\n    double calc() {\n        double ans = 1e3;\n        foreach (r; rs) {\n            foreach (i; 0 .. 4) {\n                auto s = Segment(r.r.v[i], r.r.v[(i + 1) % 4]);\n                double d2 = distance(s, course);\n                if (d2 <= r.h) {\n                    ans = min(ans, d2);\n                } else {\n                    ans = min(ans, (r.h * r.h + d2 * d2) / (2 * r.h));\n                }\n            }\n        }\n        return ans;\n    }\n\n    void solve() {\n        foreach (r; rs) {\n            if (r.r.contains(course.a) || r.r.contains(course.b)) {\n                writeln(0);\n                return;\n            }\n            foreach (i; 0 .. 4) {\n                auto s = Segment(r.r.v[i], r.r.v[(i + 1) % 4]);\n                if (course.intersect(s)) {\n                    writeln(0);\n                    return;\n                }\n            }\n        }\n\n        writefln(\"%.10f\", calc);\n    }\n\n    while (input) solve;\n\n}"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef _kosa(a1, a2, b1, b2):\n    x1,y1 = a1\n    x2,y2 = a2\n    x3,y3 = b1\n    x4,y4 = b2\n\n    tc = (x1-x2)*(y3-y1)+(y1-y2)*(x1-x3)\n    td = (x1-x2)*(y4-y1)+(y1-y2)*(x1-x4)\n    return tc*td < 0\n\ndef kosa(a1, a2, b1, b2):\n    return _kosa(a1,a2,b1,b2) and _kosa(b1,b2,a1,a2)\n\ndef ky(p1, p2):\n    return pow(pow(p1[0]-p2[0], 2) + pow(p1[1]-p2[1], 2), 0.5)\n\ndef distance3(p1, p2, p3):\n    x1,y1 = p1\n    x2,y2 = p2\n    x3,y3 = p3\n\n    ax = x2 - x1\n    ay = y2 - y1\n    bx = x3 - x1\n    by = y3 - y1\n\n    r = (ax*bx + ay*by) / (ax*ax + ay*ay)\n    if r <= 0:\n        return ky(p1, p3)\n    if r >= 1:\n        return ky(p2, p3)\n    pt = (x1 + r*ax, y1 + r*ay, 0)\n    return ky(pt, p3)\n\n\ndef main():\n    rr = []\n\n    def f(n):\n        sx,sy,ex,ey = LI()\n        sp = (sx,sy)\n        ep = (ex,ey)\n        a = [LI() for _ in range(n)]\n        td = collections.defaultdict(lambda: inf)\n        for x1,y1,x2,y2,h in a:\n            ps = [(x1,y1), (x1,y2), (x2,y1), (x2,y2)]\n            for p1,p2 in itertools.combinations(ps, 2):\n                if kosa(sp,ep,p1,p2):\n                    return 0\n                for p in [sp,ep]:\n                    dc = distance3(p1,p2,p)\n                    if td[h] > dc:\n                        td[h] = dc\n\n            for p in ps:\n                dc = distance3(sp,ep,p)\n                if td[h] > dc:\n                    td[h] = dc\n\n        r = 1000\n        for h,k in td.items():\n            if k < h:\n                if r > k:\n                    r = k\n                continue\n            tr = 1.0 * (h**2 + k**2) / h / 2\n            if r > tr:\n                r = tr\n\n        return '{:0.4f}'.format(r)\n\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n        # print('rr', rr[-1])\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nfrom math import sqrt\n# ??????\ndef cross(P0, P1, P2):\n    x0, y0 = P0; x1, y1 = P1; x2, y2 = P2\n    x1 -= x0; x2 -= x0\n    y1 -= y0; y2 -= y0\n    return x1*y2 - x2*y1\n# ??????\ndef dot(P0, P1, P2):\n    x0, y0 = P0; x1, y1 = P1; x2, y2 = P2\n    x1 -= x0; x2 -= x0\n    y1 -= y0; y2 -= y0\n    return x1*x2 + y1*y2\n# 2??????????????¢?????????\ndef dist2(P0, P1):\n    x0, y0 = P0; x1, y1 = P1\n    return (x1 - x0)**2 + (y1 - y0)**2\n# ????????????????????????\ndef collision(P0, P1, P2, P3):\n    return cross(P0, P1, P2)*cross(P0, P1, P3) <= 0 and cross(P2, P3, P0) * cross(P2, P3, P1) <= 0\n# ????????¨?????????????????¢\ndef dist_lp(S, E, P):\n    dd = dist2(S, E)\n    # ???????????????P?????????????????????????¢???? => 0<=sqrt(dist(S, P))*cos??<=sqrt(dist(S, E))\n    if 0 <= dot(S, E, P) <= dd:\n        # ???????????°???????????????????????????????°? => sqrt(dist(S, P))*sin??\n        return abs(cross(S, E, P))/sqrt(dd)\n    # ?????????????????°???S??¨E???????????????????????????????????¢???????°?\n    return sqrt(min(dist2(S, P), dist2(E, P)))\n# ????????¨????????????????????¢\ndef dist_ll(S0, S1, T0, T1):\n    if collision(S0, S1, T0, T1):\n        return 0\n    return min(\n            dist_lp(S0, S1, T0),\n            dist_lp(S0, S1, T1),\n            dist_lp(T0, T1, S0),\n            dist_lp(T0, T1, S1)\n            )\n# ????§???¢?????¨??????????????????\ndef contain(PS, A):\n    l = len(PS)\n    base = cross(PS[-1], PS[0], A)\n    for i in range(l-1):\n        P0 = PS[i]; P1 = PS[i+1]\n        if base * cross(PS[i], PS[i+1], A) < 0:\n            return 0\n    return 1\n\n\nwhile 1:\n    n = int(input())\n    if n == 0:\n        break\n    sx, sy, ex, ey = map(int, input().split())\n    S = sx, sy; E = ex, ey\n    cannot = 0\n    ans = 10**9\n    for i in range(n):\n        minx, miny, maxx, maxy, h = map(int, input().split())\n        PS = ((minx, miny), (minx, maxy), (maxx, maxy), (maxx, miny))\n        cannot |= contain(PS, S) or contain(PS, E)\n        for j in range(4):\n            cannot |= collision(PS[j-1], PS[j], S, E)\n            d = dist_ll(S, E, PS[j-1], PS[j])\n            ans = min(ans, (h**2+d**2)/(2*h) if h <= d else d)\n    if cannot:\n        print(0)\n    else:\n        print(\"%.08f\" % ans)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nfrom math import sqrt\n# ??????\ndef cross(P0, P1, P2):\n    x0, y0 = P0; x1, y1 = P1; x2, y2 = P2\n    x1 -= x0; x2 -= x0\n    y1 -= y0; y2 -= y0\n    return x1*y2 - x2*y1\n# ??????\ndef dot(P0, P1, P2):\n    x0, y0 = P0; x1, y1 = P1; x2, y2 = P2\n    x1 -= x0; x2 -= x0\n    y1 -= y0; y2 -= y0\n    return x1*x2 + y1*y2\n# 2??????????????¢?????????\ndef dist2(P0, P1):\n    x0, y0 = P0; x1, y1 = P1\n    return (x1 - x0)**2 + (y1 - y0)**2\n# ????????????????????????\ndef collision(S0, S1, T0, T1):\n    return cross(S0, S1, T0)*cross(S0, S1, T1) < 0 and cross(T0, T1, S0) * cross(T0, T1, S1) < 0\n# ????????¨?????????????????¢\ndef dist_lp(S, E, P):\n    dd = dist2(S, E)\n    # ???????????????P?????????????????????????¢???? => 0<=sqrt(dist(S, P))*cos??<=sqrt(dist(S, E))\n    if 0 <= dot(S, E, P) <= dd:\n        # ???????????°???????????????????????????????°? => sqrt(dist(S, P))*sin??\n        return abs(cross(S, E, P))/sqrt(dd)\n    # ?????????????????°???S??¨E???????????????????????????????????¢???????°?\n    return sqrt(min(dist2(S, P), dist2(E, P)))\n# ????????¨????????????????????¢\ndef dist_ll(S0, S1, T0, T1):\n    if collision(S0, S1, T0, T1):\n        return 0\n    return min(\n            dist_lp(S0, S1, T0),\n            dist_lp(S0, S1, T1),\n            dist_lp(T0, T1, S0),\n            dist_lp(T0, T1, S1)\n            )\n# ????§???¢?????¨??????????????????\ndef contain(PS, A):\n    l = len(PS)\n    base = cross(PS[-1], PS[0], A)\n    for i in range(l-1):\n        P0 = PS[i]; P1 = PS[i+1]\n        if base * cross(PS[i], PS[i+1], A) < 0:\n            return 0\n    return 1\n\nc = 0\nwhile 1:\n    c += 1\n    n = int(input())\n    if n == 0:\n        break\n    sx, sy, ex, ey = map(int, input().split())\n    S = sx, sy; E = ex, ey\n    cannot = 0\n    ans = 10**9\n    for i in range(n):\n        minx, miny, maxx, maxy, h = map(int, input().split())\n        PS = ((minx, miny), (minx, maxy), (maxx, maxy), (maxx, miny))\n        cannot |= contain(PS, S) or contain(PS, E)\n        for j in range(4):\n            cannot |= collision(PS[j-1], PS[j], S, E)\n            d = dist_ll(S, E, PS[j-1], PS[j])\n            ans = min(ans, (h**2+d**2)/(2*h) if h <= d else d)\n    if cannot:\n        print(0)\n    else:\n        print(\"%.08f\" % ans)"
  },
  {
    "language": "Python",
    "code": "def cross(c1, c2):\n    return c1.real * c2.imag - c1.imag * c2.real\n\ndef dot(c1, c2):\n    return c1.real * c2.real + c1.imag * c2.imag\n\ndef ccw(p0, p1, p2):\n    a = p1 - p0\n    b = p2 - p0\n    cross_ab = cross(a, b)\n    if cross_ab > 0:\n        return 1\n    elif cross_ab < 0:\n        return -1\n    elif dot(a, b) < 0:\n        return 1\n    elif abs(a) < abs(b):\n        return -1\n    else:\n        return 0\n\ndef intersect(p1, p2, p3, p4):\n    # p1 and p2 are end points of a segment.\n    # p3 and p4 are end points of the other segment.\n    if (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0) and \\\n       (ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0):\n        return True\n    else:\n        return False\n\ndef get_distance_sp(sp1, sp2, p):\n    a = sp2 - sp1\n    b = p - sp1\n    if dot(a, b) < 0:\n        return abs(b)\n    c = sp1 - sp2\n    d = p - sp2\n    if dot(c, d) < 0:\n        return abs(d)\n    return abs(cross(a, b) / a)\n\ndef solve():\n    from sys import stdin\n    lines = stdin.readlines()\n    \n    while True:\n        N = int(lines[0])\n        if N == 0:\n            break\n        sx, sy, ex, ey = map(int, lines[1].split())\n        sp = sx + sy * 1j\n        ep = ex + ey * 1j\n        R = []\n        for l in lines[2:2+N]:\n            D = []\n            x1, y1, x2, y2, h = map(int, l.split())\n            bp1 = x1 + y1 * 1j\n            bp2 = x2 + y1 * 1j\n            bp3 = x2 + y2 * 1j\n            bp4 = x1 + y2 * 1j\n            if intersect(sp, ep, bp1, bp2) or intersect(sp, ep, bp2, bp3) or \\\n            intersect(sp, ep, bp3, bp4) or intersect(sp, ep, bp4, bp1) or \\\n            (x1 <= sx <= x2 and y1 <= sy <= y2) or \\\n            (x1 <= ex <= x2 and y1 <= ey <= y2):\n                print(0)\n                break\n            else:\n                D.append(get_distance_sp(sp, ep, bp1))\n                D.append(get_distance_sp(sp, ep, bp2))\n                D.append(get_distance_sp(sp, ep, bp3))\n                D.append(get_distance_sp(sp, ep, bp4))\n                D.append(get_distance_sp(bp1, bp2, sp))\n                D.append(get_distance_sp(bp1, bp2, ep))\n                D.append(get_distance_sp(bp2, bp3, sp))\n                D.append(get_distance_sp(bp2, bp3, ep))\n                D.append(get_distance_sp(bp3, bp4, sp))\n                D.append(get_distance_sp(bp3, bp4, ep))\n                D.append(get_distance_sp(bp4, bp1, sp))\n                D.append(get_distance_sp(bp4, bp1, ep))\n                \n                d = min(D)\n                if h < d:\n                    R.append((d ** 2 + h ** 2) / (2 * h))\n                else:\n                    R.append(d)\n        else:\n            print(min(R))\n        lines = lines[2+N:]\n\nsolve()\n"
  }
]