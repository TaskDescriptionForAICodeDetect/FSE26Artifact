[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x, y;\n    int brightness;\n} Star;\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint min(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint compareBrightness(const void *a, const void *b) {\n    Star *starA = (Star *)a;\n    Star *starB = (Star *)b;\n    return (starA->brightness - starB->brightness);\n}\n\nint main() {\n    int N, d;\n    scanf(\"%d %d\", &N, &d);\n    Star stars[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d\", &stars[i].x, &stars[i].y, &stars[i].brightness);\n    }\n\n    qsort(stars, N, sizeof(Star), compareBrightness);\n\n    int maxArea = 0;\n    for (int i = 0; i < N; i++) {\n        int minBrightness = stars[i].brightness;\n        int maxBrightness = stars[i].brightness;\n        int minX = stars[i].x;\n        int maxX = stars[i].x;\n        int minY = stars[i].y;\n        int maxY = stars[i].y;\n        for (int j = i + 1; j < N; j++) {\n            minBrightness = min(minBrightness, stars[j].brightness);\n            maxBrightness = max(maxBrightness, stars[j].brightness);\n            if (maxBrightness - minBrightness > d) {\n                break;\n            }\n            minX = min(minX, stars[j].x);\n            maxX = max(maxX, stars[j].x);\n            minY = min(minY, stars[j].y);\n            maxY = max(maxY, stars[j].y);\n            int width = maxX - minX;\n            int height = maxY - minY;\n            if (width > 0 && height > 0) {\n                int area = width * height;\n                if (area > maxArea) {\n                    maxArea = area;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", maxArea);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:41:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Constellation {\n    static class Star {\n        int x, y, brightness;\n        \n        Star(int x, int y, int brightness) {\n            this.x = x;\n            this.y = y;\n            this.brightness = brightness;\n        }\n    }\n    \n    public static double calculateArea(List<Star> stars) {\n        int n = stars.size();\n        if (n < 3) return 0;\n        \n        double maxArea = 0;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    Star a = stars.get(i);\n                    Star b = stars.get(j);\n                    Star c = stars.get(k);\n                    \n                    if (Math.abs(a.brightness - b.brightness) > d ||\n                        Math.abs(b.brightness - c.brightness) > d ||\n                        Math.abs(c.brightness - a.brightness) > d) {\n                        continue;\n                    }\n                    \n                    double area = Math.abs(a.x * (b.y - c.y) + \n                                            b.x * (c.y - a.y) + \n                                            c.x * (a.y - b.y)) / 2.0;\n                    \n                    if (area > 0) {\n                        maxArea = Math.max(maxArea, area);\n                    }\n                }\n            }\n        }\n        \n        return maxArea;\n    }\n    \n    static int d;\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int n = scanner.nextInt();\n        d = scanner.nextInt();\n        \n        List<Star> stars = new ArrayList<>();\n        \n        for (int i = 0; i < n; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            int brightness = scanner.nextInt();\n            \n            stars.add(new Star(x, y, brightness));\n        }\n        \n        System.out.printf(\"%.1f%n\", calculateArea(stars));\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:42:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Point {\n    int x, y, b;\n};\n\nint maxArea(const vector<Point>& points) {\n    int max_area = 0;\n    int n = points.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (abs(points[i].b - points[j].b) > d) continue;\n            for (int k = j + 1; k < n; ++k) {\n                if (abs(points[i].b - points[k].b) > d || abs(points[j].b - points[k].b) > d) continue;\n                int x1 = points[i].x, y1 = points[i].y;\n                int x2 = points[j].x, y2 = points[j].y;\n                int x3 = points[k].x, y3 = points[k].y;\n                if ((x1 == x2 && x2 == x3) || (y1 == y2 && y2 == y3)) continue;\n                int area = abs((x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)));\n                if (area > max_area) max_area = area;\n            }\n        }\n    }\n    return max_area / 2;\n}\n\nint main() {\n    int N, d;\n    cin >> N >> d;\n    vector<Point> stars(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> stars[i].x >> stars[i].y >> stars[i].b;\n    }\n    int result = maxArea(stars);\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:42:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\ntypedef struct {\n    int x, y;\n    int brightness;\n} Star;\n\ndouble calculate_triangle_area(Star a, Star b, Star c) {\n    return fabs(0.5 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y)));\n}\n\nint is_valid_constellation(Star *stars, int size, int d) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (abs(stars[i].brightness - stars[j].brightness) > d) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int N, d;\n    scanf(\"%d %d\", &N, &d);\n\n    Star *stars = malloc(N * sizeof(Star));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d\", &stars[i].x, &stars[i].y, &stars[i].brightness);\n    }\n\n    double max_area = 0.0;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            for (int k = j + 1; k < N; k++) {\n                Star constellation[3] = {stars[i], stars[j], stars[k]};\n                \n                if (is_valid_constellation(constellation, 3, d)) {\n                    double area = calculate_triangle_area(stars[i], stars[j], stars[k]);\n                    \n                    if (area > max_area) {\n                        max_area = area;\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%.6f\\n\", max_area);\n\n    free(stars);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:42:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <limits>\n\nusing namespace std;\n\nstruct Star {\n    int x, y, brightness;\n};\n\ndouble calculateArea(const vector<Star>& constellation) {\n    if (constellation.size() <= 1) return 0;\n    \n    double minX = numeric_limits<double>::max();\n    double maxX = numeric_limits<double>::lowest();\n    double minY = numeric_limits<double>::max();\n    double maxY = numeric_limits<double>::lowest();\n    \n    for (const Star& star : constellation) {\n        minX = min(minX, (double)star.x);\n        maxX = max(maxX, (double)star.x);\n        minY = min(minY, (double)star.y);\n        maxY = max(maxY, (double)star.y);\n    }\n    \n    if (minX == maxX || minY == maxY) return 0;\n    \n    return (maxX - minX) * (maxY - minY);\n}\n\nint main() {\n    int N, d;\n    cin >> N >> d;\n    \n    vector<Star> stars(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> stars[i].x >> stars[i].y >> stars[i].brightness;\n    }\n    \n    double maxArea = 0;\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = i; j < N; ++j) {\n            vector<Star> constellation;\n            \n            for (const Star& star : stars) {\n                if (abs(star.brightness - stars[i].brightness) <= d ||\n                    abs(star.brightness - stars[j].brightness) <= d) {\n                    constellation.push_back(star);\n                }\n            }\n            \n            maxArea = max(maxArea, calculateArea(constellation));\n        }\n    }\n    \n    cout << fixed << setprecision(0) << maxArea << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:42:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Star {\n    int x, y, b;\n\n    Star(int x, int y, int b) {\n        this.x = x;\n        this.y = y;\n        this.b = b;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int d = scanner.nextInt();\n        List<Star> stars = new ArrayList<>();\n\n        for (int i = 0; i < N; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            int b = scanner.nextInt();\n            stars.add(new Star(x, y, b));\n        }\n\n        int maxArea = 0;\n\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                Star s1 = stars.get(i);\n                Star s2 = stars.get(j);\n                if (Math.abs(s1.b - s2.b) > d) {\n                    continue;\n                }\n                int minX = Math.min(s1.x, s2.x);\n                int maxX = Math.max(s1.x, s2.x);\n                int minY = Math.min(s1.y, s2.y);\n                int maxY = Math.max(s1.y, s2.y);\n                int currentArea = (maxX - minX) * (maxY - minY);\n                if (currentArea > maxArea) {\n                    maxArea = currentArea;\n                }\n            }\n        }\n\n        System.out.println(maxArea);\n    }\n}",
    "timestamp": "2025-08-05 18:43:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import itertools\n\ndef largest_constellation_area(stars, d):\n    def distance(s1, s2):\n        return ((s1[0] - s2[0]) ** 2 + (s1[1] - s2[1]) ** 2) ** 0.5\n    \n    def is_valid_constellation(stars, d):\n        for s1, s2 in itertools.combinations(stars, 2):\n            if abs(s1[2] - s2[2]) > d:\n                return False\n        return True\n\n    max_area = 0\n    for i in range(1, len(stars) + 1):\n        for constellation in itertools.combinations(stars, i):\n            if is_valid_constellation(constellation, d):\n                xs, ys = zip(*[(star[0], star[1]) for star in constellation])\n                if len(set(xs)) > 1 and len(set(ys)) > 1:\n                    area = (max(xs) - min(xs)) * (max(ys) - min(ys))\n                    max_area = max(max_area, area)\n\n    return max_area\n\n# Sample usage\nstars = [(0, 0, 3), (1, 2, 5), (2, 1, 4), (4, 4, 3)]\nd = 2\nprint(largest_constellation_area(stars, d))",
    "timestamp": "2025-08-13 00:35:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Constellation {\n    \n    static class Star {\n        int x, y, brightness;\n        Star(int x, int y, int brightness) {\n            this.x = x;\n            this.y = y;\n            this.brightness = brightness;\n        }\n    }\n    \n    public static double findLargestConstellationArea(List<Star> stars, int d) {\n        int n = stars.size();\n        if (n < 2) return 0.0;\n        \n        double maxArea = 0.0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    Star s1 = stars.get(i);\n                    Star s2 = stars.get(j);\n                    Star s3 = stars.get(k);\n                    \n                    if (Math.abs(s1.brightness - s2.brightness) <= d && \n                        Math.abs(s2.brightness - s3.brightness) <= d && \n                        Math.abs(s3.brightness - s1.brightness) <= d) {\n                        \n                        int x1 = s1.x, y1 = s1.y;\n                        int x2 = s2.x, y2 = s2.y;\n                        int x3 = s3.x, y3 = s3.y;\n                        \n                        double area = Math.abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0;\n                        \n                        if (area > 0) {\n                            maxArea = Math.max(maxArea, area);\n                        }\n                    }\n                }\n            }\n        }\n        return maxArea;\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int N = sc.nextInt();\n        int d = sc.nextInt();\n        List<Star> stars = new ArrayList<>();\n\n        for (int i = 0; i < N; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int brightness = sc.nextInt();\n            stars.add(new Star(x, y, brightness));\n        }\n        \n        System.out.println(findLargestConstellationArea(stars, d));\n    }\n}",
    "timestamp": "2025-08-13 00:35:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    int x, y, brightness;\n} Star;\n\nint comparator(const void *a, const void *b) {\n    Star *starA = (Star*)a;\n    Star *starB = (Star*)b;\n    if (starA->brightness != starB->brightness) {\n        return starA->brightness - starB->brightness;\n    } else if (starA->x != starB->x) {\n        return starA->x - starB->x;\n    } else {\n        return starA->y - starB->y;\n    }\n}\n\ndouble calculateArea(Star a, Star b, Star c) {\n    return fabs(0.5 * ((b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y)));\n}\n\ndouble findLargestConstellationArea(Star stars[], int n, int d) {\n    qsort(stars, n, sizeof(Star), comparator);\n\n    double maxArea = 0.0;\n\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            if (abs(stars[j].brightness - stars[i].brightness) > d) continue;\n\n            for (int k = j + 1; k < n; k++) {\n                if (abs(stars[k].brightness - stars[j].brightness) > d) continue;\n                if (abs(stars[k].brightness - stars[i].brightness) > d) continue;\n\n                double area = calculateArea(stars[i], stars[j], stars[k]);\n                if (area > maxArea) {\n                    maxArea = area;\n                }\n            }\n        }\n    }\n    return maxArea;\n}\n\nint main() {\n    int n, d;\n    printf(\"Enter number of stars and brightness difference(d): \");\n    scanf(\"%d %d\", &n, &d);\n\n    Star stars[n];\n    printf(\"Enter star coordinates (x y) and brightness:\\n\");\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &stars[i].x, &stars[i].y, &stars[i].brightness);\n    }\n\n    double maxConstellationArea = findLargestConstellationArea(stars, n, d);\n    printf(\"The area of the largest constellation is: %.2f\\n\", maxConstellationArea);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 00:36:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_constellation_area(N, stars):\n    max_area = 0\n    \n    for i in range(N):\n        for j in range(i+1, N):\n            for k in range(j+1, N):\n                # Check brightness difference constraint\n                brightness_diff_ij = abs(stars[i][2] - stars[j][2])\n                brightness_diff_jk = abs(stars[j][2] - stars[k][2])\n                brightness_diff_ki = abs(stars[k][2] - stars[i][2])\n                \n                if (brightness_diff_ij <= d and \n                    brightness_diff_jk <= d and \n                    brightness_diff_ki <= d):\n                    \n                    # Calculate area using shoelace formula\n                    x1, y1 = stars[i][0], stars[i][1]\n                    x2, y2 = stars[j][0], stars[j][1]\n                    x3, y3 = stars[k][0], stars[k][1]\n                    \n                    area = abs(0.5 * (x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)))\n                    \n                    # Check if stars are not aligned\n                    if area > 0:\n                        max_area = max(max_area, area)\n    \n    return max_area\n\n# Input parsing\nN, d = map(int, input().split())\nstars = []\nfor _ in range(N):\n    x, y, brightness = map(int, input().split())\n    stars.append((x, y, brightness))\n\n# Output result\nprint(f\"{calculate_constellation_area(N, stars):.1f}\")",
    "timestamp": "2025-08-13 00:36:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef max_constellation_area(N, stars, d):\n    max_area = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            brightness_diff = abs(stars[i][2] - stars[j][2])\n            if brightness_diff > d:\n                continue\n            x1, y1, _ = stars[i]\n            x2, y2, _ = stars[j]\n            if x1 == x2 or y1 == y2:\n                continue\n            area = abs((x2 - x1) * (y2 - y1))\n            if area > max_area:\n                max_area = area\n    return max_area\n\ndef main():\n    input_lines = sys.stdin.read().splitlines()\n    N, d = map(int, input_lines[0].split())\n    stars = []\n    for line in input_lines[1:N+1]:\n        x, y, b = map(int, line.split())\n        stars.append((x, y, b))\n    result = max_constellation_area(N, stars, d)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 00:36:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstruct Star {\n    int x, y, brightness;\n};\n\nbool compareBrightness(const Star &a, const Star &b) {\n    return a.brightness < b.brightness;\n}\n\ndouble calculateArea(set<int> &xSet, set<int> &ySet) {\n    if (xSet.size() < 2 || ySet.size() < 2) return 0.0;\n    int minX = *xSet.begin(), maxX = *xSet.rbegin();\n    int minY = *ySet.begin(), maxY = *ySet.rbegin();\n    return static_cast<double>((maxX - minX) * (maxY - minY));\n}\n\nint main() {\n    int N, d;\n    cin >> N >> d;\n    vector<Star> stars(N);\n\n    for (int i = 0; i < N; ++i) {\n        cin >> stars[i].x >> stars[i].y >> stars[i].brightness;\n    }\n\n    sort(stars.begin(), stars.end(), compareBrightness);\n\n    double maxArea = 0.0;\n    \n    for (int i = 0; i < N; ++i) {\n        set<int> xSet, ySet;\n        for (int j = i; j < N; ++j) {\n            if (stars[j].brightness - stars[i].brightness <= d) {\n                xSet.insert(stars[j].x);\n                ySet.insert(stars[j].y);\n                maxArea = max(maxArea, calculateArea(xSet, ySet));\n            } else {\n                break;\n            }\n        }\n    }\n\n    cout << maxArea << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 10:54:59"
  }
]