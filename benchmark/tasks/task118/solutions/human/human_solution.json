[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define in ,\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct Star {\n  int x, y, d;\n};\n\nint minX[200000 * 2 - 1] = {}, maxX[200000 * 2 - 1] = {},\nminY[200000 * 2 - 1] = {}, maxY[200000 * 2 - 1] = {};\nint n, nn = 1;\n\nvoid update(int k, int a, int c[]) {\n  k += nn - 1;\n  c[k] = a;\n\n  while(k > 0) {\n    k = (k - 1) / 2;\n    c[k] = min(c[k * 2 + 1], c[k * 2 + 2]);\n  }\n}\n\nint query(int a, int b, int k, int l, int r, int c[]) {\n  if(r <= a || b <= l) return INT_MAX;\n  if(a <= l && r <= b) return c[k];\n\n  int vl = query(a, b, k * 2 + 1, l, (l + r) / 2, c);\n  int vr = query(a, b, k * 2 + 2, (l + r) / 2, r, c);\n\n  return min(vl, vr);\n}\n\nbool asc(Star &l, Star &r) {\n  return l.d < r.d;\n}\n\nint main() {\n  ll d, ans = 0;\n  cin >> n >> d;\n  vector<Star> v(n);\n\n  while(nn < n) nn *= 2;\n\n  rep(i, 0, nn * 2 - 1) {\n    minX[i] = INT_MAX;\n    minY[i] = INT_MAX;\n    maxX[i] = INT_MAX;\n    minX[i] = INT_MAX;\n  }\n\n  rep(i, 0, n) cin >> v[i].x >> v[i].y >> v[i].d;\n\n  sort(v.begin(), v.end(), asc);\n  rep(i, 0, n) {\n    update(i, v[i].x * -1, maxX);\n    update(i, v[i].x, minX);\n    update(i, v[i].y * -1, maxY);\n    update(i, v[i].y, minY);\n  }\n\n  // rep(i, 0, n) cout << v[i].x << \" \" << v[i].y << \" \" << v[i].d << endl;;\n\n  // rep(i, 0, nn * 2 - 1) cout << minX[i] << endl;\n\n  int ld = v[0].d, lp = 0;\n  rep(i, 1, n) {\n    if(v[i].d - ld > d) {\n      rep(j, lp + 1, i + 1) {\n        if(v[i].d - v[j].d <= d) {\n          lp = j;\n          ld = v[lp].d;\n          break;\n        }\n      }\n    }\n    int hx = query(lp, i + 1, 0, 0, nn, maxX) * -1;\n    int lx = query(lp, i + 1, 0, 0, nn, minX);\n    int hy = query(lp, i + 1, 0, 0, nn, maxY) * -1;\n    int ly = query(lp, i + 1, 0, 0, nn, minY);\n    if(lp != i) ans = max(ans, ((hx - lx) * (ll)(hy - ly)));\n    // cout << lp << \" \" << i << endl;\n    // cout << hx << \" \" << lx << \" \" << hy << \" \" << ly << endl;\n    // cout << ans << endl;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define Rrep(i, m, n) for(int i=(m);i<(n);i++)\n#define All(v) v.begin(),v.end()\n#define Uniq(v) v.erase(unique(All(v)),v.end())\ntypedef pair<ll, ll> Pii;\ntypedef pair<ll, Pii> Pip;\ntypedef pair<string, int> Psi;\ntypedef vector<int> Vi;\nconst int INF = (1<<30);\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\n\nconst int MAX_N = 2000001;\n\nll n, d;\nll datx1[2 * MAX_N - 1];\nll datx2[2 * MAX_N - 1];\nll daty1[2 * MAX_N - 1];\nll daty2[2 * MAX_N - 1];\n\nvoid init(ll n_, ll dat[]) {\n  n = 1;\n  while( n < n_ ) n *= 2;\n  for(int i=0; i<2*n-1; i++) dat[i] = INT_MAX;\n}\n\nvoid update(ll k, ll a, ll dat[]) {\n  k += n - 1;\n  dat[k] = a;\n  while( k > 0 ) {\n    k = (k - 1) / 2;\n    dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n}\n\nint query(ll a, ll b, ll k, ll l, ll r, ll dat[]) {\n  if( r <= a || b <= l ) return INT_MAX;\n  if( a <= l && r <= b ) return dat[k];\n  else {\n    ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2, dat);\n    ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r, dat);\n    return min(vl, vr);\n  }\n}\n\nint main()\n{\n  cin >> n >> d;\n  ll N = n;\n  init(N+1, datx1);init(N+1, datx2);init(N+1, daty1);init(N+1, daty2);\n  vector<ll> bData;\n  vector<Pip> allData;\n  for(int i=0; i<N; i++) {\n    ll a, b, c;\n    cin >> a >> b >> c;\n    bData.pb( c );\n    allData.pb( Pip(c, Pii(a, b)) );\n  }\n\n  sort( All(allData) );\n\n  for(int i=0; i<N; i++) {\n    ll x = allData[i].sc.fr, y = allData[i].sc.sc;\n    update(i, x, datx1);\n    update(i, -x, datx2);\n    update(i, y, daty1);\n    update(i, -y, daty2);\n  }\n\n  ll s, t; s = t = 0;\n  ll ma = 0;\n  for(int i=1; i<N-1; i++) {\n    t = i;\n    while( 1 ) {\n      if( allData[t].fr - allData[s].fr <= d ) break;\n      s++;\n    }\n    ll x1 = query(s, t+1, 0, 0, n, datx1);\n    ll x2 = query(s, t+1, 0, 0, n, datx2);\n    ll y1 = query(s, t+1, 0, 0, n, daty1);\n    ll y2 = query(s, t+1, 0, 0, n, daty2);\n\n    ll tmp = ((-x2) - x1) * ((-y2) - y1);\n    if( tmp > ma ) {\n      ma = tmp;\n    }\n  }\n\n  cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define int long long int\n#define rep(a,b,c) for(int a=b;a<c;a++)\n#define repm(a,b,c) for(int a=(b-1);a>=c;a--)\n#define pb push_back\n#define str string\n#define sf(a) scanfs(\"%d\",&a)\n#define pb push_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n#define clean(used) memset(used,false,sizeof(used))\nusing namespace std;\n\nstatic const int INF = 1e18 + 9;\nstatic const int Mod = 1e9 + 7;\ninline int replac(str s){double ans=0;rep(i,0,s.length()){ans+=(s[i]-'0')*pow(10,s.length()-i-1);}return (int)ans;}\ninline string numstr(int m){str s=\"\";while(m>0){char c;int a=m/10;if(a>0)a=m%(a*10);else a=m;c=(char)('0'+a);s+=c;m/=10;}str st=\"\";for(int i=s.size()-1;i>=0;i--){st+=s[i];}return st;}\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\n\nstatic const int MAX_N = 200002;\n\nstruct Seg{\n    int n;\n    int dat[MAX_N * 2];\n    void init(int n_){\n        init(n_ , INF);\n    }\n\n    void init(int n_, int d){\n        n = 1;\n        while(n < n_)n *= 2;\n        fill(dat, dat + MAX_N * 2, d);\n    }\n};\n\nstruct SegMin : Seg {\n    int Min(int s,int t){\n        return Min(s,t,0,0,n);\n    }\n    int Min(int s, int t, int k, int l, int r){\n        if(r <= s || t <= l) return INF;\n        if(s <= l && r <= t) return dat[k];\n\n        int t1 = Min(s, t, k * 2 + 1, l, (l + r)/2);\n        int t2 = Min(s, t, k * 2 + 2, (l + r)/2, r);\n        return min(t1, t2);\n    }\n    void update(int k, int x){\n        k += n - 1;\n        dat[k] = min(dat[k], x);\n        while(0 < k){\n            k = (k - 1)/2;\n            dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n};\n\nSegMin x1,x2,y1,y2;\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int d,m;\n    cin >> m >> d;\n    x1.init(m);\n    x2.init(m);\n    y1.init(m);\n    y2.init(m);\n    int b_max = 0;\n    int x,y,b;\n    rep(i,0,m){\n        cin >> x >> y >> b;\n        x1.update(b,x);\n        x2.update(b,-x);\n        y1.update(b,y);\n        y2.update(b,-y);\n    }\n    int ans = 0,x_mi,x_ma,y_mi,y_ma;\n    rep(i,0,MAX_N){\n        x_mi = x1.Min(i,i+d+1);\n        x_ma = x2.Min(i,i+d+1);\n        y_mi = y1.Min(i,i+d+1);\n        y_ma = y2.Min(i,i+d+1);\n        ans = max(ans, abs(x_ma+x_mi)*abs(y_ma+y_mi));\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n\nclass C{\n  public:\n    int x, y, b;\n    C(){}\n    C(int xx, int yy, int bb) { x = xx; y = yy; b = bb; }\n    bool operator < (const C &c) const { return b < c.b; }\n};\n \nint main() {\n  int N, d, ans = 0; cin >>N >>d;\n  vector<C> cs(N);\n  REP(i, N) cin >>cs[i].x >>cs[i].y >>cs[i].b;\n  SORT(cs);\n  multiset<int> xs, ys;\n  for(int l = 0, r = 0; l < N; l++){\n    //cout <<cs[l].b <<endl;\n    for( ; r < N && cs[r].b - cs[l].b <= d; r++){\n      xs.insert(cs[r].x);\n      ys.insert(cs[r].y);\n      ans = max(ans, (*xs.rbegin() - *xs.begin()) * (*ys.rbegin() - *ys.begin()));\n      //cout <<cs[l].b <<\", \" <<cs[r].b <<\", \" <<ans <<endl;\n    }\n    //cout <<\"end\" <<endl;\n    xs.erase(xs.lower_bound(cs[l].x));\n    ys.erase(ys.lower_bound(cs[l].y));\n  }\n  cout <<ans <<endl;\n  return 0;\n}\n\n//1, 1, 2, 3, 4, 4, 5, 8, 12, "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <list>\n \nusing namespace std;\ntypedef long long ll;\n \n#define mod 1000000007\n#define INF 1000000000\n#define SIZE 100000\n\nbool ans[200000];\n\nstruct NODE{\n  int min_d;\n  int max_d;\n  int min_x;\n  int min_y;\n  int max_x;\n  int max_y;\n\n  NODE(){\n    min_d = INF;\n    max_d = 0;\n    min_x = INF;\n    max_x = 0;\n    min_y = INF;\n    max_y = 0;\n  }\n  \n  NODE(int a,int b,int c,int d,int e,int f){\n    min_d = a;\n    max_d = b;\n    min_x = c;\n    max_x = d;\n    min_y = e;\n    max_y = f;\n  }\n\n  NODE operator+ (const NODE &B) const{\n    int a = min(min_d,B.min_d);\n    int b = max(max_d,B.max_d);\n    int c = min(min_x,B.min_x);\n    int d = max(max_x,B.max_x);\n    int e = min(min_y,B.min_y);\n    int f = max(max_y,B.max_y);\n\n    return NODE(a,b,c,d,e,f);\n  }\n};\n\nNODE data[1 << 19];\nint segn2 = 262144;\n\n\nvoid set(int k,pair<int,pair<int,int> > p){\n  int d = p.first;\n  int x = p.second.first;\n  int y = p.second.second;\n  \n  data[k+segn2-1] = NODE(d,d,x,x,y,y);\n}\n\nvoid init(){\n  for(int i = segn2-2;i>=0;i--){\n    data[i] = data[i*2+1] + data[i*2+2];\n  }\n}\n\nNODE query(int a,int b,int k=0){\n  if(data[k].max_d < data[k].min_d) return NODE(INF,0,INF,0,INF,0);\n  if(data[k].max_d < a || b < data[k].min_d) return NODE(INF,0,INF,0,INF,0);\n\n  if(a<= data[k].min_d && data[k].max_d <= b) return data[k];\n\n  return query(a,b,k*2+1) + query(a,b,k*2+2);\n}\n\nint main(){\n  int n,d;\n  int x,y,b;\n  vector<pair<int,pair<int,int> > > in;\n\n  scanf(\"%d%d\",&n,&d);\n\n  segn2 = 1;\n  while(segn2<n) segn2*=2;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d%d%d\",&x,&y,&b);\n    in.push_back(make_pair(b,make_pair(x,y)));\n  }\n\n  sort(in.begin(),in.end());\n\n  for(int i=0;i<n;i++){\n    set(i,in[i]);\n  }\n\n  init();\n  \n  ll ans = 0;\n  \n  for(int i=0;i<n;i++){\n    NODE a = query(in[i].first,in[i].first+d);\n    ll calc = (ll)(a.max_x - a.min_x)*(a.max_y - a.min_y);\n    ans = max(ans,calc);\n  }\n\n  cerr << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define b first\n#define x second.first\n#define y second.second\nusing namespace std;\npair<int,pair<int,int> >s[200000];\nint main(){\n  int n,d,f=0;\n  long long an=0;\n  cin>>n>>d;\n  for(int i=0;i<n;i++)cin>>s[i].x>>s[i].y>>s[i].b;\n  sort(s,s+n);\n  for(int i=0;i<n;i++){\n    int xmn,xmx,ymn,ymx;\n    xmn=ymn=2000000;xmx=ymx=0;\n    for(int j=i;s[j].b-s[i].b<=d;j++){\n      xmx=max(xmx,s[j].x);\n      ymx=max(ymx,s[j].y);\n      xmn=min(xmn,s[j].x);\n      ymn=min(ymn,s[j].y);\n      if(j==n-1){f=1;break;}\n    }\n    long long w=xmx-xmn,h=ymx-ymn;\n    an=max(an,w*h);\n    if(f==1)break;\n  }\n  cout<<an<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\ntypedef long long int Int;\n\nclass C{\n  public:\n    Int x, y, b;\n    C(){}\n    C(Int xx, Int yy, Int bb) { x = xx; y = yy; b = bb; }\n    bool operator < (const C &c) const { return b < c.b; }\n};\n \nint main() {\n  Int N, d, ans = 0; cin >>N >>d;\n  vector<C> cs(N);\n  REP(i, N) cin >>cs[i].x >>cs[i].y >>cs[i].b;\n  SORT(cs);\n  multiset<Int> xs, ys;\n  for(Int l = 0, r = 0; l < N; l++){\n    //cout <<cs[l].b <<endl;\n    for( ; r < N && cs[r].b - cs[l].b <= d; r++){\n      xs.insert(cs[r].x);\n      ys.insert(cs[r].y);\n      ans = max(ans, (*xs.rbegin() - *xs.begin()) * (*ys.rbegin() - *ys.begin()));\n      //cout <<cs[l].b <<\", \" <<cs[r].b <<\", \" <<ans <<endl;\n    }\n    //cout <<\"end\" <<endl;\n    xs.erase(xs.lower_bound(cs[l].x));\n    ys.erase(ys.lower_bound(cs[l].y));\n  }\n  cout <<ans <<endl;\n  return 0;\n}\n\n//1, 1, 2, 3, 4, 4, 5, 8, 12, "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define int long long int\n#define rep(a,b,c) for(int a=b;a<c;a++)\n#define repm(a,b,c) for(int a=(b-1);a>=c;a--)\n#define pb push_back\n#define str string\n#define sf(a) scanfs(\"%d\",&a)\n#define pb push_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n#define clean(used) memset(used,false,sizeof(used))\nusing namespace std;\n\nstatic const int INF = 1e18 + 9;\nstatic const int Mod = 1e9 + 7;\ninline int replac(str s){double ans=0;rep(i,0,s.length()){ans+=(s[i]-'0')*pow(10,s.length()-i-1);}return (int)ans;}\ninline string numstr(int m){str s=\"\";while(m>0){char c;int a=m/10;if(a>0)a=m%(a*10);else a=m;c=(char)('0'+a);s+=c;m/=10;}str st=\"\";for(int i=s.size()-1;i>=0;i--){st+=s[i];}return st;}\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\n\nstatic const int MAX_N = 200002;\n\nstruct Seg{\n    int n;\n    int dat[MAX_N * 2];\n    void init(int n_){\n        init(n_ , INF);\n    }\n\n    void init(int n_, int d){\n        n = 1;\n        while(n < n_)n *= 2;\n        fill(dat, dat + MAX_N * 2, d);\n    }\n};\n\nstruct SegMin : Seg {\n    int Min(int s,int t){\n        return Min(s,t,0,0,n);\n    }\n    int Min(int s, int t, int k, int l, int r){\n        if(r <= s || t <= l) return INF;\n        if(s <= l && r <= t) return dat[k];\n\n        int t1 = Min(s, t, k * 2 + 1, l, (l + r)/2);\n        int t2 = Min(s, t, k * 2 + 2, (l + r)/2, r);\n        return min(t1, t2);\n    }\n    void update(int k, int x){\n        k += n - 1;\n        dat[k] = min(dat[k], x);\n        while(0 < k){\n            k = (k - 1)/2;\n            dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n};\n\nSegMin x_1,x_2,y_1,y_2;\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int d,m;\n    cin >> m >> d;\n    x_1.init(m);\n    x_2.init(m);\n    y_1.init(m);\n    y_2.init(m);\n    int b_max = 0;\n    int x,y,b;\n    rep(i,0,m){\n        cin >> x >> y >> b;\n        x_1.update(b,x);\n        x_2.update(b,-x);\n        y_1.update(b,y);\n        y_2.update(b,-y);\n    }\n    int ans = 0,x_mi,x_ma,y_mi,y_ma;\n    rep(i,0,MAX_N){\n        x_mi = x_1.Min(i,i+d+1);\n        x_ma = x_2.Min(i,i+d+1);\n        y_mi = y_1.Min(i,i+d+1);\n        y_ma = y_2.Min(i,i+d+1);\n        ans = max(ans, abs(x_ma+x_mi)*abs(y_ma+y_mi));\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for (int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define Cout(obj) cout << obj << endl\n#define Size(obj) (obj).size()\n#define fcout cout << fixed << setprecision(10)\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\ntemplate <typename T>\nstruct SegTreeMin\n{\n  private:\n    ll N = 1;\n    vector<T> node;\n\n  public:\n    SegTreeMin(vector<T> vec)\n    {\n        ll size = vec.size();\n\n        while (N < size)\n        {\n            N *= 2;\n        }\n\n        node.resize(2 * N - 1, iINF);\n\n        REP(i, size)\n        {\n            node[i + N - 1] = vec[i];\n        }\n\n        for (int i = N - 2; 0 <= i; i--)\n        {\n            node[i] = min(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    void update(int i, T value)\n    {\n        i += (N - 1);\n\n        node[i] = value;\n\n        while (i > 0)\n        {\n            i = (i - 1) / 2;\n\n            node[i] = min(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    T getMin(int a, int b, int i = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = N;\n        }\n\n        if (r <= a || b <= l)\n        {\n            return iINF;\n        }\n\n        if (a <= l && r <= b)\n        {\n            return node[i];\n        }\n\n        T vl = getMin(a, b, 2 * i + 1, l, (l + r) / 2);\n\n        T vr = getMin(a, b, 2 * i + 2, (l + r) / 2, r);\n\n        return min(vl, vr);\n    }\n};\n\ntemplate <typename T>\nstruct SegTreeMax\n{\n  private:\n    ll N = 1;\n    vector<T> node;\n\n  public:\n    SegTreeMax(vector<T> vec)\n    {\n        ll size = vec.size();\n\n        while (N < size)\n        {\n            N *= 2;\n        }\n\n        node.resize(2 * N - 1, -iINF);\n\n        REP(i, size)\n        {\n            node[i + N - 1] = vec[i];\n        }\n\n        for (int i = N - 2; 0 <= i; i--)\n        {\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    void update(int i, T value)\n    {\n        i += (N - 1);\n\n        node[i] = value;\n\n        while (i > 0)\n        {\n            i = (i - 1) / 2;\n\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    T getMax(int a, int b, int i = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = N;\n        }\n\n        if (r <= a || b <= l)\n        {\n            return -iINF;\n        }\n\n        if (a <= l && r <= b)\n        {\n            return node[i];\n        }\n\n        T vl = getMax(a, b, 2 * i + 1, l, (l + r) / 2);\n\n        T vr = getMax(a, b, 2 * i + 2, (l + r) / 2, r);\n\n        return max(vl, vr);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, d;\n    cin >> N >> d;\n\n    vector<tuple<ll, ll, ll>> vec(N);\n\n    SegTreeMax<ll> xMax(vector<ll>(N, -iINF)), yMax(vector<ll>(N, -iINF));\n    SegTreeMin<ll> xMin(vector<ll>(N, iINF)), yMin(vector<ll>(N, iINF));\n\n    ll ans = 0;\n\n    REP(i, N)\n    {\n        int x, y, d;\n        cin >> x >> y >> d;\n\n        vec[i] = make_tuple(d, x, y);\n    }\n\n    sort(ALL(vec));\n\n    REP(i, N)\n    {\n        int x, y, d;\n        tie(d, x, y) = vec[i];\n\n        xMax.update(i, x);\n        xMin.update(i, x);\n        yMax.update(i, y);\n        yMin.update(i, y);\n    }\n\n    REP(i, N)\n    {\n        ll start = get<0>(vec[i]);\n\n        auto itr = upper_bound(vec.begin(), vec.end(), make_tuple(d + start, iINF, iINF));\n\n        if (itr == vec.begin())\n            continue;\n        if (itr == vec.end())\n            continue;\n\n        int now = itr - vec.begin();\n\n        ll x = xMax.getMax(i, now), y = yMax.getMax(i, now);\n        ll _x = xMin.getMin(i, now), _y = yMin.getMin(i, now);\n\n        ans = max(ans, (x - _x) * (y - _y));\n    }\n\n    Cout(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\nstruct SegmentTree {\n\tint init_val;\n\tint n;\n\tvector<int> dat;\n\t\n\tSegmentTree(int _n) {\n\t\tinit_val = INF;\n\t\tn = 1;\n\t\twhile (n < _n) n *= 2;\n\t\tdat.clear();\n\t\tdat.resize(2 * n - 1, init_val);\n\t}\n\t\n\tvoid update(int k, int a) {\n\t\tk += n - 1;\n\t\tdat[k] = min(dat[k], a);\n\t\t\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = min(dat[2 * k + 1], dat[2 * k + 2]);\n\t\t}\n\t}\n\t\n\tint query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return init_val;\n\t\tif (a <= l && r <= b) return dat[k];\n\t\treturn min(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t\n\tint query(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\n\ntypedef pair<int, int> pii;\ntypedef pair<int , pii> pip;\ntypedef SegmentTree Seg;\ntypedef long long ll;\n\nint main() {\n\tint n, d;\n\tcin >> n >> d;\n\tvector<pip> stars(n);\n\tREP(i, n) {\n\t\tint x, y, b;\n\t\tscanf(\"%d %d %d\", &x, &y, &b);\n\t\tstars[i] = pip(b, pii(x, y));\n\t}\n\tsort(stars.begin(), stars.end());\n\t\n\tSeg up(n), down(n), right(n), left(n);\n\tREP(i, n) {\n\t\tint x = stars[i].second.first;\n\t\tint y = stars[i].second.second;\n\t\t\n\t\tup.update(i, -y);\n\t\tdown.update(i, y);\n\t\tright.update(i, -x);\n\t\tleft.update(i, x);\n\t}\n\t\n\tint st = 0, en = 0;\n\tll ans = -INF;\n\t\n\twhile (st < n) {\n\t\tif (en - st > 0 && stars[en].first - stars[st].first <= d) {\n\t\t\tll  s = (ll)(-up.query(st, en + 1) - down.query(st, en + 1))\n\t\t\t\t    * (-right.query(st, en + 1) - left.query(st, en + 1));\n\t\t\tans = max(ans, s);\n\t\t\t\n\t\t\tif (en == n - 1) st++;\n\t\t\telse en++;\n\t\t}\n\t\telse if (stars[en].first - stars[st].first > d) st++;\n\t\telse if (en < n - 1) en++;\n\t\telse break;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n#define N 200000\n#define F first\n#define Se second\n#define MP(i, j) make_pair((i), (j))\n#define int long long\nstruct S{\n\tint sx, lx, sy, ly;\n\tS(int isx, int ilx, int isy, int ily): sx(isx), lx(ilx), sy(isy), ly(ily){}\n\tbool operator<(const S &s) const { \n\t\treturn 1;\n\t}\n};\nint cnt;\nvoid init(int n_, int *dat){\n\tcnt = 1;\n\twhile(cnt < n_) cnt *= 2;\n\tfor(int i = 0; i < 2 * cnt - 1; i++) dat[i] = INT_MAX;\n}\nvoid update(int k, int a, int *dat){\n\tk += cnt - 1;\n\tdat[k] = a;\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nint query(int a, int b, int k, int l, int r, int *dat){\n\tif(r <= a || b <= l) return INT_MAX;\n\tif(a <= l && r <= b) return dat[k];\n\telse{\n\t\tint v1 = query(a, b, k * 2 + 1, l, (l + r) / 2, dat);\n\t\tint vr = query(a, b, k * 2 + 2, (l + r) / 2, r, dat);\n\t\treturn min(v1, vr);\n\t}\n}\ntypedef pair<int, S> PS;\ntypedef vector<PS>::iterator it;\n\nint i, j, n, d, stars[N][3], ax[2 * N], bx[2 * N], ay[2 * N], by[2 * N];\nint ans = 0;\nvector<PS> vec;\n\nvoid vdc(vector<PS> &vf, S s, int now){\n\tif(vf[now].Se.sx > s.sx)\n\t\tvf[now].Se.sx = s.sx;\n\tif(vf[now].Se.lx < s.lx)\n\t\tvf[now].Se.lx = s.lx;\n\tif(vf[now].Se.sy > s.sy)\n\t\tvf[now].Se.sy = s.sy;\n\tif(vf[now].Se.ly < s.ly)\n\t\tvf[now].Se.ly = s.ly;\n}\n\nsigned main(){\n\tcin >> n >> d;\n\tvec.push_back(MP(-1, S(0, 0, 0, 0)));\n\tfor(i = 0; i < n; i++){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tS s = S(a, a, b, b);\n\t\tit ite = lower_bound(vec.begin(), vec.end(), MP(c, s));\n\t\tif(vec[ite - vec.begin() - 1].F != c){\n\t\t\tvec.insert(ite, MP(c, s));\n\t\t}\n\t\telse{\n\t\t\tvdc(vec, s, ite - vec.begin() - 1);\n\t\t}\n\t}\n\tinit(vec.size(), ax);\n\tinit(vec.size(), bx);\n\tinit(vec.size(), ay);\n\tinit(vec.size(), by);\n\tS s = S(INT_MAX, 0, INT_MAX, 0);\n\tvec.erase(vec.begin());\n\tfor(i = 0; i < vec.size(); i++){\n\t\tupdate(i, vec[i].Se.sx, ax);\n\t\tupdate(i, -vec[i].Se.lx, bx);\n\t\tupdate(i, vec[i].Se.sy, ay);\n\t\tupdate(i, -vec[i].Se.ly, by);\n\t}\n\ti = 0; j = 0;\n\tfor(;;){\n\t\twhile(j < vec.size()){\n\t\t\tif(vec[j].F - vec[i].F <= d)\n\t\t\t\tj++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tans = max(ans, (-query(i, j, 0, 0, cnt, bx) - query(i, j, 0, 0, cnt, ax)) * (-query(i, j, 0, 0, cnt, by) - query(i, j, 0, 0, cnt, ay)));\n\t\tif(j == vec.size())\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<int,P>PP;\n\nint L[524288];\nint R[524288];\nint xmax[524288];\nint xmin[524288];\nint ymax[524288];\nint ymin[524288];\nvector<int>B;\nvoid init(){\n\tL[0]=0;\n\tR[0]=524286;\n\tfor(int i=0;i<262144;i++){\n\t\tL[i+262143]=R[i+262143]=i;\n\t\t\n\t\txmax[i+262143]=-1;\n\t\tymax[i+262143]=-1;\n\t\txmin[i+262143]=81089319;\n\t\tymin[i+262143]=81089319;\n\t\t\n\t}\n\tfor(int i=262142;i>=0;i--){\n\t\tL[i]=L[2*i+1];\n\t\tR[i]=R[2*i+2];\n\t\t\n\t\txmax[i]=-1;\n\t\tymax[i]=-1;\n\t\txmin[i]=81089319;\n\t\tymin[i]=81089319;\n\t\t\n\t\t\n\t}\n}\n\nint tmpb,tmpx;\nvoid update(int x,int y,int b){\n\tif(b>tmpb){\n\t\ttmpx++;\n\t\ttmpb=b;\n\t\tB.push_back(b);\n\t}\n\txmax[tmpx]=max(x,xmax[tmpx]);\n\txmin[tmpx]=min(x,xmin[tmpx]);\n\tymax[tmpx]=max(y,ymax[tmpx]);\n\tymin[tmpx]=min(y,ymin[tmpx]);\n\t\n\tfor(int i=(tmpx-1)/2;true;i=(i-1)/2){\n\t\txmax[i]=max(xmax[2*i+1],xmax[2*i+2]);\n\t\txmin[i]=min(xmin[2*i+1],xmin[2*i+2]);\n\t\tymax[i]=max(ymax[2*i+1],ymax[2*i+2]);\n\t\tymin[i]=min(ymin[2*i+1],ymin[2*i+2]);\n\t\tif(i==0)break;\n\t}\n\t\n}\n\nint l,r,tmp;\nstack<int>st;\nvoid xmx(int p){\n\tif(r<L[p] || l>R[p])return;\n\tif(L[p]<l || r<R[p]){\n\t\tst.push(p*2+1);\n\t\tst.push(p*2+2);\n\t\treturn;\n\t}\n\ttmp=max(tmp,xmax[p]);\n\treturn;\n}\nvoid xmn(int p){\n\tif(r<L[p] || l>R[p])return;\n\tif(L[p]<l || r<R[p]){\n\t\tst.push(p*2+1);\n\t\tst.push(p*2+2);\n\t\treturn;\n\t}\n\ttmp=min(tmp,xmin[p]);\n\treturn;\n}\nvoid ymx(int p){\n\tif(r<L[p] || l>R[p])return;\n\tif(L[p]<l || r<R[p]){\n\t\tst.push(p*2+1);\n\t\tst.push(p*2+2);\n\t\treturn;\n\t}\n\ttmp=max(tmp,ymax[p]);\n\treturn;\n}\nvoid ymn(int p){\n\tif(r<L[p] || l>R[p])return;\n\tif(L[p]<l || r<R[p]){\n\t\tst.push(p*2+1);\n\t\tst.push(p*2+2);\n\t\treturn;\n\t}\n\ttmp=min(tmp,ymin[p]);\n\treturn;\n}\n\n\nint main(){\n\t\n\tinit();\n\t\n\t\n\tint n,d;cin>>n>>d;\n\tvector<PP>V(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>V[i].second.first>>V[i].second.second>>V[i].first;\n\t}\n\tsort(V.begin(),V.end());\n\ttmpb=-1,tmpx=262142;\n\tfor(int i=0;i<n;i++)update(V[i].second.first,V[i].second.second,V[i].first);\n\t\n\tlong long ans=0;\n\t\n\tfor(int i=0,j=0;i<B.size();i++){\n\t\t\n\t\twhile(j+1<B.size()){\n\t\t\tif(d>=B[j+1]-B[i])j++;\n\t\t\telse break;\n\t\t}\n\t\tl=i;\n\t\tr=j;\n\t\t\n\t\ttmp=-1;\n\t\tst.push(0);\n\t\twhile(!st.empty()){\n\t\t\tint k=st.top();\n\t\t\tst.pop();\n\t\t\txmx(k);\n\t\t}\n\t\tlong long x=tmp;\n\t\ttmp=81089319;\n\t\tst.push(0);\n\t\twhile(!st.empty()){\n\t\t\tint k=st.top();\n\t\t\tst.pop();\n\t\t\txmn(k);\n\t\t}\n\t\tx-=tmp;\n\t\ttmp=-1;\n\t\tst.push(0);\n\t\twhile(!st.empty()){\n\t\t\tint k=st.top();\n\t\t\tst.pop();\n\t\t\tymx(k);\n\t\t}\n\t\tlong long y=tmp;\n\t\ttmp=81089319;\n\t\tst.push(0);\n\t\twhile(!st.empty()){\n\t\t\tint k=st.top();\n\t\t\tst.pop();\n\t\t\tymn(k);\n\t\t}\n\t\ty-=tmp;\n\t\t\n\t\t\n\t\tans=max(ans,x*y);\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing ll=long long int;\n\nconstexpr int MAX_N=(1<<21),INF=2*(int)1e6;\n\nusing P=std::pair<int,int>;//max,min\n\nint n,d;\n\nstd::map<int,std::set<int>> mapX,mapY;\n\nstd::vector<P> maxmin;\n\nstd::vector<int> vec,res;\n\nP calc(const P& lhs,const P& rhs){\n\n    return P(std::max(lhs.first,rhs.first),std::min(lhs.second,rhs.second));\n}\n\nP seg[MAX_N*2-1];\n\nvoid init(int _n) {\n\n    n=1;\n\n    while(n<_n)\n        n*=2;\n\n    for(int i=0;i<n*2-1;++i)\n        seg[i]=P(0,INF);\n\n    for(int i=0;i<_n;++i)\n        seg[i+n-1]=maxmin[i];\n\n    for(int i=n-2;i>=0;--i)\n        seg[i]=calc(seg[i*2+1],seg[i*2+2]);\n}\n\nP query(int a,int b,int k,int l,int r){\n\n    if(b<=l||r<=a)\n        return P(0,INF);\n    \n    if(a<=l&&r<=b)\n        return seg[k];\n    \n    return calc(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n}\n\nstd::vector<int> solve(std::map<int,std::set<int>>& map){\n\n    res.clear();\n    maxmin.clear();\n    vec.clear();\n\n    for(auto&& s : map){\n        vec.emplace_back(s.first);\n        maxmin.emplace_back(*(s.second.rbegin()),*(s.second.begin()));\n    }\n\n    init(maxmin.size());\n\n    for(int i=0;i<vec.size();++i){\n        P p=query(i,std::upper_bound(vec.begin(),vec.end(),vec[i]+d)-vec.begin(),0,0,n);\n        res.emplace_back(p.first-p.second);\n    }\n\n    return res;\n}\n\nint main() {\n\n    std::cin>>n>>d;\n\n    int x,y,b;\n\n    for(int i=0;i<n;++i){\n\n        std::cin>>x>>y>>b;\n\n        mapX[b].emplace(x);\n        mapY[b].emplace(y);\n    }\n\n    std::vector<int> ansX=solve(mapX);\n\n    std::vector<int> ansY=solve(mapY);\n\n    ll ans=0;\n\n    for(int i=0;i<ansX.size();++i)\n        ans=std::max(ans,ll(ansX[i])*ll(ansY[i]));\n\n    std::cout<<ans<<std::endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n\nclass SegmentTree\n{\nprivate:\n\tvector<int> tree;\n\tconst int INF = 99999999;\n\tint size;\n\tint init(int i)\n\t{\n\t\tif (i * 2 + 1 < tree.size()) tree[i] = init(i * 2 + 1);\n\t\tif (i * 2 + 2 < tree.size()) tree[i] = min(init(i * 2 + 2), tree[i]);\n\t\treturn tree[i];\n\t}\n\tint get(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || b <= l) return INF;\n\t\tif (a <= l && r <= b) return tree[k];\n\t\tint vl = get(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = get(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\npublic:\n\tSegmentTree(vector<int>& v)\n\t{\n\t\tsize = 1;\n\t\twhile (size < v.size()) size *= 2;\n\t\ttree.resize(size * 2 - 1);\n\t\tfill(tree.begin(), tree.end(), INF);\n\t\tfor (int i = 0; i < v.size(); i++) tree[size - 1 + i] = v[i];\n\t\tinit(0);\n\t}\n\tint get(int begin, int end)\n\t{\n\t\treturn get(begin, end, 0, 0, size);\n\t}\n};\nclass GreaterSegmentTree\n{\nprivate:\n\tvector<int> tree;\n\tconst int INF = -99999999;\n\tint size;\n\tint init(int i)\n\t{\n\t\tif (i * 2 + 1 < tree.size()) tree[i] = init(i * 2 + 1);\n\t\tif (i * 2 + 2 < tree.size()) tree[i] = max(init(i * 2 + 2), tree[i]);\n\t\treturn tree[i];\n\t}\n\tint get(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || b <= l) return INF;\n\t\tif (a <= l && r <= b) return tree[k];\n\t\tint vl = get(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = get(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\npublic:\n\tGreaterSegmentTree(vector<int>& v)\n\t{\n\t\tsize = 1;\n\t\twhile (size < v.size()) size *= 2;\n\t\ttree.resize(size * 2 - 1);\n\t\tfill(tree.begin(), tree.end(), INF);\n\t\tfor (int i = 0; i < v.size(); i++) tree[size - 1 + i] = v[i];\n\t\tinit(0);\n\t}\n\tint get(int begin, int end)\n\t{\n\t\treturn get(begin, end, 0, 0, size);\n\t}\n};\n\n\n\nclass Star\n{\npublic:\n\tlong long int x, y;\n\tint b;\n\tint boundary;\n};\nbool operator > (Star s1, Star s2)\n{\n\treturn s1.b > s2.b;\n}\nbool operator < (Star s1, Star s2)\n{\n\treturn s1.b < s2.b;\n}\n\nint n, d;\nStar star[200000];\nlong long int ans = 0;\n\nvoid calcBoundary()\n{\n\tint boundary = n - 1;\n\tstar[n - 1].boundary = boundary;\n\tfor (int i = n - 2; i >= 0; i--)\n\t{\n\t\tif (star[i + 1].b - star[i].b > d) boundary = i;\n\t\tstar[i].boundary = boundary;\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tStar s;\n\t\ts.b = star[i].b + d;\n\t\tboundary = upper_bound(star + i, star + n, s) - star - 1;\n\t\tstar[i].boundary = min(star[i].boundary, boundary);\n\t}\n}\n\nvoid solve()\n{\n\tvector<int> vx;\n\tvector<int> vy;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tvx.push_back(star[i].x);\n\t\tvy.push_back(star[i].y);\n\t}\n\tSegmentTree segX(vx), segY(vy);\n\tGreaterSegmentTree gsegX(vx), gsegY(vy);\n\n\tint boundary = star[n-1].boundary;\n\t\n\tfor (int i = n - 2; i >= 0; i--)\n\t{\n\t\tif (boundary != star[i].boundary)\n\t\t{\n\t\t\tlong long int a = (gsegX.get(i + 1, boundary + 1) - segX.get(i + 1, boundary + 1)) * (gsegY.get(i + 1, boundary + 1) - segY.get(i + 1, boundary + 1));\n\t\t\tans = max(a, ans);\n\t\t\tboundary = star[i].boundary;\n\t\t}\n\t}\n\tlong long int a = (gsegX.get(0, boundary + 1) - segX.get(0, boundary + 1)) * (gsegY.get(0, boundary + 1) - segY.get(0, boundary + 1));\n\tans = max(a, ans);\n}\n\nint main()\n{\n\tcin >> n >> d;\n\tfor (int i = 0; i < n; i++) cin >> star[i].x >> star[i].y >> star[i].b;\n\n\tsort(star, star + n);\n\tcalcBoundary();\n\tsolve();\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for (int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define Cout(obj) cout << obj << endl\n#define Size(obj) (obj).size()\n#define fcout cout << fixed << setprecision(10)\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\ntemplate <typename T>\nstruct SegTreeMin\n{\n  private:\n    ll N = 1;\n    vector<T> node;\n\n  public:\n    SegTreeMin(vector<T> vec)\n    {\n        ll size = vec.size();\n\n        while (N < size)\n        {\n            N *= 2;\n        }\n\n        node.resize(2 * N - 1, iINF);\n\n        REP(i, size)\n        {\n            node[i + N - 1] = vec[i];\n        }\n\n        for (int i = N - 2; 0 <= i; i--)\n        {\n            node[i] = min(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    void update(int i, T value)\n    {\n        i += (N - 1);\n\n        node[i] = value;\n\n        while (i > 0)\n        {\n            i = (i - 1) / 2;\n\n            node[i] = min(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    T getMin(int a, int b, int i = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = N;\n        }\n\n        if (r <= a || b <= l)\n        {\n            return iINF;\n        }\n\n        if (a <= l && r <= b)\n        {\n            return node[i];\n        }\n\n        T vl = getMin(a, b, 2 * i + 1, l, (l + r) / 2);\n\n        T vr = getMin(a, b, 2 * i + 2, (l + r) / 2, r);\n\n        return min(vl, vr);\n    }\n};\n\ntemplate <typename T>\nstruct SegTreeMax\n{\n  private:\n    ll N = 1;\n    vector<T> node;\n\n  public:\n    SegTreeMax(vector<T> vec)\n    {\n        ll size = vec.size();\n\n        while (N < size)\n        {\n            N *= 2;\n        }\n\n        node.resize(2 * N - 1, -iINF);\n\n        REP(i, size)\n        {\n            node[i + N - 1] = vec[i];\n        }\n\n        for (int i = N - 2; 0 <= i; i--)\n        {\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    void update(int i, T value)\n    {\n        i += (N - 1);\n\n        node[i] = value;\n\n        while (i > 0)\n        {\n            i = (i - 1) / 2;\n\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    T getMax(int a, int b, int i = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = N;\n        }\n\n        if (r <= a || b <= l)\n        {\n            return -iINF;\n        }\n\n        if (a <= l && r <= b)\n        {\n            return node[i];\n        }\n\n        T vl = getMax(a, b, 2 * i + 1, l, (l + r) / 2);\n\n        T vr = getMax(a, b, 2 * i + 2, (l + r) / 2, r);\n\n        return max(vl, vr);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, d;\n    cin >> N >> d;\n\n    vector<tuple<ll, ll, ll>> vec(N);\n\n    SegTreeMax<ll> xMax(vector<ll>(N, -iINF)), yMax(vector<ll>(N, -iINF));\n    SegTreeMin<ll> xMin(vector<ll>(N, iINF)), yMin(vector<ll>(N, iINF));\n\n    ll ans = -1;\n\n    REP(i, N)\n    {\n        int x, y, d;\n        cin >> x >> y >> d;\n\n        vec[i] = make_tuple(d, x, y);\n    }\n\n    sort(ALL(vec));\n\n    REP(i, N)\n    {\n        int x, y, d;\n        tie(d, x, y) = vec[i];\n\n        xMax.update(i, x);\n        xMin.update(i, x);\n        yMax.update(i, y);\n        yMin.update(i, y);\n    }\n\n    REP(i, N)\n    {\n        ll start = get<0>(vec[i]);\n\n        auto itr = upper_bound(vec.begin(), vec.end(), make_tuple(d + start, iINF, iINF));\n\n        if (itr == vec.begin())\n            continue;\n        if (itr == vec.end())\n            continue;\n\n        int now = itr - vec.begin();\n\n        ll x = xMax.getMax(i, now), y = yMax.getMax(i, now);\n        ll _x = xMin.getMin(i, now), _y = yMin.getMin(i, now);\n\n        ans = max(ans, (x - _x) * (y - _y));\n    }\n\n    Cout(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\nstruct SegmentTree {\n\tint init_val;\n\tint n;\n\tvector<int> dat;\n\t\n\tSegmentTree(int _n) {\n\t\tinit_val = INF;\n\t\tn = 1;\n\t\twhile (n < _n) n *= 2;\n\t\tdat.clear();\n\t\tdat.resize(2 * n - 1, init_val);\n\t}\n\t\n\tvoid update(int k, int a) {\n\t\tk += n - 1;\n\t\tdat[k] = min(dat[k], a);\n\t\t\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = min(dat[2 * k + 1], dat[2 * k + 2]);\n\t\t}\n\t}\n\t\n\tint query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return init_val;\n\t\tif (a <= l && r <= b) return dat[k];\n\t\treturn min(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t\n\tint query(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\n\ntypedef pair<int, int> pii;\ntypedef pair<int , pii> pip;\ntypedef SegmentTree Seg;\ntypedef long long ll;\n\nint main() {\n\tint n, d;\n\tcin >> n >> d;\n\tvector<pip> stars(n);\n\tREP(i, n) {\n\t\tint x, y, b;\n\t\tscanf(\"%d %d %d\", &x, &y, &b);\n\t\tstars[i] = pip(b, pii(x, y));\n\t}\n\tsort(stars.begin(), stars.end());\n\t\n\tSeg up(n), down(n), right(n), left(n);\n\tREP(i, n) {\n\t\tint x = stars[i].second.first;\n\t\tint y = stars[i].second.second;\n\t\t\n\t\tup.update(i, -y);\n\t\tdown.update(i, y);\n\t\tright.update(i, -x);\n\t\tleft.update(i, x);\n\t}\n\t\n\t/*\n\tputs(\"\");\n\tREP(i, n) {\n\t\tcout << stars[i].first << \" \" << stars[i].second.first << \" \" << stars[i].second.second << endl;\n\t}\n\tputs(\"\");\n\t*/\n\t\n\tint st = 0, en = 0;\n\tll ans = -INF;\n\t\n\twhile (st < n) {\n\t\tif (en - st > 0 && stars[en].first - stars[st].first <= d) {\n\t\t\tll  s = (ll)(-up.query(st, en + 1) - down.query(st, en + 1))\n\t\t\t\t    * (-right.query(st, en + 1) - left.query(st, en + 1));\n\t\t\tans = max(ans, s);\n\n\t\t\tif (en == n - 1) st++;\n\t\t\telse en++;\n\t\t\t\n\t\t}\n\t\telse if (stars[en].first - stars[st].first > d) st++;\n\t\telse if (en < n - 1) en++;\n\t\telse st++;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//{{{ seg.hpp\n#ifndef INCLUDE_SEG_HPP\n#define INCLUDE_SEG_HPP\n#include <functional>\n#include <algorithm>\n#include <iterator>\nnamespace orislib {\nnamespace ds {\nconstexpr int uprt(int k, int i=1){\n  return i < k ? uprt(k, i + i) : i;\n}\n//{{{ SegT<T, S> update, query\ntemplate<typename T, int S>\nstruct SegT {\n  typedef T seg_t;\n  const seg_t OUT;\n  static const int N = uprt(S);\n  seg_t data[N * 2];\n  std::function<seg_t(seg_t,seg_t)>ufunc;\n  template<typename F>\n  SegT(T initial, F f):OUT(initial),ufunc(f){std::fill(std::begin(data), std::end(data), initial);}\n  void update(int x, seg_t v){\n    for (data[x+=N-1]=v;x;data[x]=ufunc(data[x+x+1],data[x+x+2]))x=x-1>>1;\n  }\n  void add(int x,seg_t a){ update(x,data[x+N-1]+a); }\n  seg_t query(int a=0,int b=N,int x=0,int l=0,int r=N){\n    if (r<=a||b<=l) return OUT;\n    if (a<=l&&r<=b) return data[x];\n    return ufunc(query(a,b,x+x+1,l,l+r>>1),query(a,b,x+x+2,l+r>>1,r));\n  }\n};\n//}}}\n}\n}\n#endif\n//}}}\n\nusing namespace std;\nusing namespace orislib::ds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\n\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_ template<typename T>inline\n#define TTF_ template<typename T,typename F>inline\nTT_ T sq(T x){return x*x;}\nTT_ T In(){T x;cin>>x;return x;}\nTT_ void Out(T&x){cout<<x;}\nTT_ void sort(T&v){sort(begin(v),end(v));}\nTT_ void revs(T&v){reverse(begin(v),end(v));}\nTT_ void uniq(T&v){sort(v);v.erase(unique(begin(v),end(v)),end(v));}\nTT_ int ubnd(T&v,typename T::value_type x){return upper_bound(begin(v),end(v),x)-begin(v);}\nTT_ int lbnd(T&v,typename T::value_type x){return lower_bound(begin(v),end(v),x)-begin(v);}\nTTF_ void inpt(T&v,int n,F f){for(v.reserve(n);n--;v.emplace_back(f()));}\nTTF_ void show(T&v,F f,string d=\" \",string e=\"\\n\"){int i=0;for(auto&x:v)i++&&(cout<<d),f(x);cout<<e;}\nTT_ typename T::iterator minel(T&v){return min_element(begin(v),end(v));}\nTT_ typename T::iterator maxel(T&v){return max_element(begin(v),end(v));}\n\ninline void fast_io(){ios_base::sync_with_stdio(0);cin.tie(0);}\ninline int in(){int x;scanf(\"%d\",&x);return x;}\ninline ll pow_mod(ll a,ll k,ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\ninline ll mod_inv(ll a,ll p){return pow_mod(a,p-2,p);}\n//}}} priority_queue queue deque front stringstream max_element min_element insert count make_tuple\n\n#define int long long\n\nstruct Star {\n  int x, y, b;\n  Star(int x, int y, int b) : x(x), y(y), b(b) {}\n  bool operator<(const Star& x) const {\n    return b < x.b;\n  }\n};\n\nSegT<int, 200200> xmax(INT_MIN, [](int a, int b){ return max(a, b); });\nSegT<int, 200200> xmin(INT_MAX, [](int a, int b){ return min(a, b); });\nSegT<int, 200200> ymax(INT_MIN, [](int a, int b){ return max(a, b); });\nSegT<int, 200200> ymin(INT_MAX, [](int a, int b){ return min(a, b); });\n\nsigned main()\n{\n\n  int N = in();\n  int d = in();\n  vector<Star> vs;\n  for (int i = 0; i < N; i++){\n    int x = in();\n    int y = in();\n    int b = in();\n    vs.emplace_back(x, y, b);\n  }\n  sort(vs);\n  for (int i = 0; i < N; i++){\n    xmin.update(i, vs[i].x);\n    xmax.update(i, vs[i].x);\n    ymin.update(i, vs[i].y);\n    ymax.update(i, vs[i].y);\n  }\n\n  int maxi = 0;\n  for (int i = 0; i < N; i++){\n    int t = ubnd(vs, Star(0, 0, vs[i].b + d));\n    int xmini = xmin.query(i, t);\n    int xmaxi = xmax.query(i, t);\n    int ymini = ymin.query(i, t);\n    int ymaxi = ymax.query(i, t);\n    maxi = max(maxi, abs(xmaxi - xmini) * abs(ymaxi - ymini));\n  }\n  printf(\"%d\\n\", maxi);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint N,b;\nint maxx,maxy,maxs,kma,kmi,ks,x[200000],y[200000],cnt;\nstruct DATA{\n\tint x,y,b;\n};\nDATA data[200000];\n\nint main(){\n\tcin>>N>>b;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>data[i].x>>data[i].y>>data[i].b;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tmaxx=0;maxy=0;cnt=1;\n\t\tx[0]=data[i].x;\n\t\ty[0]=data[i].y;\n\t\tfor(int j=0;j<N;j++){\n\t\t\t\n\t\t\tif(0<=data[i].b-data[j].b&&data[i].b-data[j].b<=b){\n\t\t\t\tcnt++;\n\t\t\t\tx[cnt]=data[j].x;\n\t\t\t\ty[cnt]=data[j].y;\n\t\t\t}\n\t\t\tif(j==N-1){\n\t\t\t\tsort(x,x+cnt);\n\t\t\t\tsort(y,y+cnt);\n\t\t\t\tmaxx=x[cnt]-x[0];\n\t\t\t\tmaxy=y[cnt]-y[0];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tks=maxx*maxy;\n\t\tif(maxs<ks){maxs=ks;kma=maxx;kmi=maxy;}\n\t}\n\tcout<<maxs<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MP make_pair\n#define int long long int\nusing namespace std;\ntypedef pair<int, int> PII;\nconst int INF = 3e18;\n\nint n, d, x[200010], y[200010], b[200010];\n\nPII sorted[200010];\nint ans = 0;\n\nstruct segtree\n{\n  int tree[524288];\n  int size;\n\n  void reset(bool option = false)\n  {\n    size = 1;\n    while(size < n){\n      size <<= 1;\n    }\n\n    if(option){\n      for(int i = 0; i < size * 2 - 1; i++){\n\ttree[i] = -INF;\n      }\n    }\n  }\n\n  void update(int where, int val)\n  {\n    int now = size - 1 + where;\n    while(true){\n      tree[now] = max(val, now);\n      if(now == 0){\n\treturn;\n      }\n      now = (now - 1) / 2;\n    }\n  }\n\n  int top()\n  {\n    return tree[0];\n  }\n} xmin, xmax, ymin, ymax;\n\nsigned main(){\n  scanf(\"%lld%lld\", &n, &d);\n  for(int i = 0; i < n; i++){\n    scanf(\"%lld%lld%lld\", &x[i], &y[i], &b[i]);\n  }\n\n  for(int i = 0; i < n; i++){\n    sorted[i] = MP(b[i], i);\n  }\n\n  sort(sorted, sorted + n);\n\n  xmin.reset(true), xmax.reset(), ymin.reset(true), ymax.reset();\n\n  int start = 0, nowd = 0;\n  for(int i = 0; i < n; i++){\n    nowd = sorted[i].first;\n    xmin.update(i, -x[sorted[i].second]);\n    xmax.update(i, x[sorted[i].second]);\n    ymin.update(i, -y[sorted[i].second]);\n    ymax.update(i, y[sorted[i].second]);\n\n    while(start < n){\n      if(sorted[start].first < nowd - d){\n\txmin.update(start, -INF);\n\txmax.update(start, 0);\n\tymin.update(start, -INF);\n\tymax.update(start, 0);\n\tstart++;\n      }\n      else{\n\tbreak;\n      }\n    }\n\n    ans = max(ans, (xmax.top() + xmin.top()) * (ymax.top() + ymin.top()));\n  }\n\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint main(){\n\n\tint n,d;\n\tcin>>n>>d;\n\tint x[n],y[n],b[n];\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i]>>y[i]>>b[i];\n\t}\n\tint sx[1000][1000],sy[1000][1000],d2=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(fabs(b[j]-b[j+1])<d+i&&fabs(b[j]-b[j+1])>d2+i){\n\t\t\t\tsx[i][j]=x[j];\n\t\t\t\tsx[i][j+1]=x[j+1];\n\t\t\t\tsy[i][j]=y[j];\n\t\t\t\tsy[i][j+1]=y[j+1];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint mx,smx,my,smy;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(sx[i][j]>sx[i][j+1]){\n\t\t\t\tmx=sx[i][j];\n\t\t\t}\n\t\t\tif(sx[i][j]<sx[i][j+1]){\n\t\t\t\tsmx=sx[i][j];\n\t\t\t}\n\t\t\tif(sy[i][j]>sy[i][j+1]){\n\t\t\t\tmy=sy[i][j];\n\t\t\t}\n\t\t\tif(sy[i][j]>sy[i][j+1]){\n\t\t\t\tsmy=sy[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(mx-smx)*(my-smy)<<endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int LL\ntypedef long long LL;\nconst int INF = 2002002002;\n\nstruct DATA {\n\tint minx, miny, maxx, maxy;\n};\n\nstruct STAR {\n\tint x, y, b;\n\tbool operator < (const STAR &t) const {\n\t\treturn b < t.b;\n\t}\n};\n\nint n, d;\nSTAR star[1 << 19];\n\nint N;\nDATA data[1 << 20];\n\n\nvoid init(int n)\n{\n\tfor (N = 1; N < n; N <<= 1);\n\tfill(data, data + (1 << 20), (DATA){INF, INF, -INF, -INF});\n}\n\nvoid update(int i, STAR s)\n{\n\ti += N - 1;\n\tdata[i] = (DATA){s.x, s.y, s.x, s.y};\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tdata[i].minx = min(data[i * 2 + 1].minx, data[i * 2 + 2].minx);\n\t\tdata[i].miny = min(data[i * 2 + 1].miny, data[i * 2 + 2].miny);\n\t\tdata[i].maxx = max(data[i * 2 + 1].maxx, data[i * 2 + 2].maxx);\n\t\tdata[i].maxy = max(data[i * 2 + 1].maxy, data[i * 2 + 2].maxy);\n\t}\n}\n\nDATA query(int a, int b, int k, int l, int r)\n{\n\t//printf(\"%d %d %d %d %d\\n\", a, b, k, l, r);\n\tif (r <= a || b <= l) return (DATA){INF, INF, -INF, -INF};\n\tif (a <= l && r <= b) return data[k];\n\tDATA vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tDATA vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn (DATA){min(vl.minx, vr.minx), min(vl.miny, vr.miny), max(vl.maxx, vr.maxx), max(vl.maxy, vr.maxy)};\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tinit(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lld %lld %lld\", &star[i].x, &star[i].y, &star[i].b);\n\t\t//star[i].x; star[i].y;\n\t}\n\tfor (int i = n; i < 1 << 19; i++){\n\t\tstar[i].b = INF;\n\t}\n\t\n\tsort(star, star + n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tupdate(i, star[i]);\n\t}\n\t\n\t//printf(\"%lld\\n\", (LL)INF * INF);\n\t\n\tLL res = 0;\n\tfor (int l = 0; star[l].b != INF; ){\n\t\tint r = l;\n\t\twhile (star[r].b - star[l].b <= d) r++;\n\t\t\n\t\tDATA q = query(l, r, 0, 0, N);\n\t\tLL t = (LL)(q.maxx - q.minx) * (q.maxy - q.miny);\n\t\tres = max(res, t);\n\t\t\n\t\tdo {\n\t\t\tl++;\n\t\t} while (star[l - 1].b == star[l].b);\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> Star; \n#define SEG_SIZE (1<<18)\nint MinX[2*SEG_SIZE-1];\nint MinY[2*SEG_SIZE-1];\nint MaxX[2*SEG_SIZE-1];\nint MaxY[2*SEG_SIZE-1];\nint x[SEG_SIZE];\nint y[SEG_SIZE];\nint b[SEG_SIZE];\nint N,segN;\nvoid init(int *x,int *MinX,int *MaxX) {\n\tsegN=1;\n\twhile(N>segN) segN*=2;\n\tfor(int i=0;i<segN;i++) {\n\t\tif(i<N) {\n\t\t\tMinX[i+segN-1]=x[i];\n\t\t\tMaxX[i+segN-1]=x[i];\n\t\t}else {\n\t\t\tMinX[i+segN-1]=INT_MAX;\n\t\t\tMaxX[i+segN-1]=INT_MIN;\n\t\t}\n\t}\n\tfor(int i=segN-2;i>=0;i--) {\n\t\tMinX[i]=min(MinX[i*2+1],MinX[i*2+2]);\n\t\tMaxX[i]=max(MaxX[i*2+1],MaxX[i*2+2]);\n\t}\n}\nint min_query(int *MinX,int a,int b,int k,int l,int r) {\n\tif(a<=l&&r<=b) {\n\t\treturn MinX[k];\n\t}else if(l>=b||r<=a) {\n\t\treturn INT_MAX;\n\t}\n\treturn min(min_query(MinX,a,b,k*2+1,l,(l+r)/2),min_query(MinX,a,b,k*2+2,(l+r)/2,r));\n}\nint max_query(int *MaxX,int a,int b,int k,int l,int r) {\n\tif(a<=l&&r<=b) {\n\t\treturn MaxX[k];\n\t}else if(l>=b||r<=a) {\n\t\treturn INT_MIN;\n\t}\n\treturn max(max_query(MaxX,a,b,k*2+1,l,(l+r)/2),max_query(MaxX,a,b,k*2+2,(l+r)/2,r));\n}\nint main() {\n\tint d;\n\tscanf(\"%d %d\",&N,&d);\n\tvector<Star> V;\n\tfor(int i=0;i<N;i++) {\n\t\tint x,y,b;\n\t\tscanf(\"%d %d %d\",&x,&y,&b);\n\t\tV.push_back(Star(b,P(x,y)));\n\t}\n\tsort(V.begin(),V.end());\n\tfor(int i=0;i<N;i++) {\n\t\tx[i]=V[i].second.first;\n\t\ty[i]=V[i].second.second;\n\t\tb[i]=V[i].first;\n\t}\n\tinit(x,MinX,MaxX);\n\tinit(y,MinY,MaxY);\n\tlong long ans=0;\n\tfor(int i=0;i<N;i++) {\n\t\tint idx=upper_bound(b,b+N,b[i]+d)-b;\n\t\tint minX=min_query(MinX,i,idx,0,0,segN);\n\t\tint maxX=max_query(MaxX,i,idx,0,0,segN);\n\t\tint minY=min_query(MinY,i,idx,0,0,segN);\n\t\tint maxY=max_query(MaxY,i,idx,0,0,segN);\n\t\tans=max(ans,(long long)(maxY-minY)*(maxX-minX));\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nconst int INF=1e9,MOD=1e9+7,ohara=1e6+10;\nconst ll LINF=1e18;\nusing namespace std;\n    \n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define Size(n) (n).size()\n#define Cout(x) cout<<(x)<<endl\n#define doublecout(a) cout<<fixed<<setprecision(15)<<a<<endl;\n#define Cerr(x) cerr<<(x)<<endl\n#define fi first\n#define se second\n#define P pair<ll,ll> \n#define m_p make_pair\n#define V vector<ll> \n#define U_MAP unordered_map<ll,ll>\n#define pq priority_queue<ll>\n#define rpq priority_queue<ll,vector<ll>,greater<ll>>\n#define p_b push_back\n    \nll n,cnt,ans,a,b,c,d,tmp,tmpp,m,h,w,x,y,sum,pos,k;\nld doua;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\n//int dy[]={-1,0,1,-1,1,-1,0,1};\n//int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl;\nstruct edge{int to,cost;};\npair<ll,pair<ll,ll>> p[ohara];\n    \n//-------------------------↓↓↓↓↓↓------------------------\n    \n//------ 自分を天才だと信じる ------\n\n\nstruct SegmentTree{\n    int siz;\n    vector<ll> node;\n    SegmentTree(int n,ll init){\n        siz=1;\n        while(siz<n)siz<<=1;\n        node.assign(2*siz,init);\n    }\n \n    void update(int k,ll x){\n        k+=siz-1;\n        node[k]=x;\n        while(k>0){\n            k=(k-1)/2;\n            node[k]=min(node[2*k+1],node[2*k+2]);\n        }\n    }\n \n    ll query(int a,int b,int k=0,int l=0,int r=-1){\n        if(r<0)r=siz;\n        if(r<=a||b<=l)return LINF;\n        if(a<=l&&r<=b)return node[k];\n        ll vl=query(a,b,2*k+1,l,(l+r)/2);\n        ll vr=query(a,b,2*k+2,(l+r)/2,r);\n        return min(vl,vr);\n    }\n};\n\n\nstruct SegmentTree2{\n    int siz;\n    vector<ll> node;\n    SegmentTree2(int n,ll init){\n        siz=1;\n        while(siz<n)siz<<=1;\n        node.assign(2*siz,init);\n    }\n \n    void update(int k,ll x){\n        k+=siz-1;\n        node[k]=x;\n        while(k>0){\n            k=(k-1)/2;\n            node[k]=max(node[2*k+1],node[2*k+2]);\n        }\n    }\n \n    ll query(int a,int b,int k=0,int l=0,int r=-1){\n        if(r<0)r=siz;\n        if(r<=a||b<=l)return -LINF;\n        if(a<=l&&r<=b)return node[k];\n        ll vl=query(a,b,2*k+1,l,(l+r)/2);\n        ll vr=query(a,b,2*k+2,(l+r)/2,r);\n        return max(vl,vr);\n    }\n};\n    \nint main(void){\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>n>>d;\n    rep(i,n){\n        cin>>x>>y>>b;\n        p[i]=m_p(b,m_p(x,y));\n    }\n    SegmentTree xmi(ohara,LINF);\n    SegmentTree ymi(ohara,LINF);\n    SegmentTree2 xma(ohara,-LINF);\n    SegmentTree2 yma(ohara,-LINF);\n    sort(p,p+n);\n    rep(i,n){\n        xmi.update(i,p[i].se.fi);\n        xma.update(i,p[i].se.fi);\n        ymi.update(i,p[i].se.se);\n        yma.update(i,p[i].se.se);\n    }\n    rep(i,n){\n        //cout<<p[i].fi<<\" \"<<p[i].se.fi<<\" \"<<p[i].se.se<<\"\\n\";\n        ll lle=-1,rri=-1;\n        ll le=0,ri=n-1,mid;\n        while(ri-le>1){\n            mid=(le+ri)/2;\n            if(p[mid].fi<=p[i].fi-d)le=mid;\n            else ri=mid;\n        }\n        rrep(j,max(le-5,0LL),min(n,ri+6)){\n            if(p[j].fi<p[i].fi-d)continue;\n            lle=j;\n            break;\n        }\n        //if(lle==-1)lle=n-1;\n        /*\n        le=0,ri=n-1,mid;\n        while(ri-le>1){\n            mid=(le+ri)/2;\n            if(p[mid].fi<=p[i].fi+d)le=mid;\n            else ri=mid;\n        }\n        rrrep(j,min(ri+5,n-1),max(0LL,le-5)){\n            if(p[j].fi>p[i].fi+d)continue;\n            rri=j;\n            break;\n        }\n        */\n        //if(rri==-1)rri=0;\n        ll xxmi,xxma,yymi,yyma;\n        xxmi=xmi.query(lle,i+1);\n        xxma=xma.query(lle,i+1);\n        yymi=ymi.query(lle,i+1);\n        yyma=yma.query(lle,i+1);\n        //cout<<xxma<<\" \"<<xxmi<<\" \"<<yyma<<\" \"<<yymi<<\"\\n\";\n        cnt=(xxma-xxmi)*(yyma-yymi);\n        ans=max(ans,cnt);\n    }\n    Cout(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 2002002002;\ntypedef long long LL;\n\nstruct DATA {\n\tint minx, miny, maxx, maxy;\n};\n\nstruct STAR {\n\tint x, y, b;\n\tbool operator < (const STAR &t) const {\n\t\treturn b < t.b;\n\t}\n};\n\nint n, d;\nSTAR star[1 << 18];\n\nint N;\nDATA data[1 << 19];\n\n\nvoid init(int n)\n{\n\tfor (N = 1; N < n; N <<= 1);\n\tfill(data, data + N * 2 - 1, (DATA){INF, INF, -INF, -INF});\n}\n\nvoid update(int i, STAR s)\n{\n\ti += N - 1;\n\tdata[i].minx = min(data[i].minx, s.x);\n\tdata[i].miny = min(data[i].miny, s.y);\n\tdata[i].maxx = max(data[i].maxx, s.x);\n\tdata[i].maxy = max(data[i].maxy, s.y);\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tdata[i].minx = min(data[i].minx, s.x);\n\t\tdata[i].miny = min(data[i].miny, s.y);\n\t\tdata[i].maxx = max(data[i].maxx, s.x);\n\t\tdata[i].maxy = max(data[i].maxy, s.y);\n\t}\n}\n\nDATA query(int a, int b, int k, int l, int r)\n{\n\t//printf(\"%d %d %d %d %d\\n\", a, b, k, l, r);\n\tif (r <= a || b <= l) return (DATA){INF, INF, -INF, -INF};\n\tif (a <= l && r <= b) return data[k];\n\tDATA vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tDATA vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn (DATA){min(vl.minx, vr.minx), min(vl.miny, vr.miny), max(vl.maxx, vr.maxx), max(vl.maxy, vr.maxy)};\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tinit(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d %d\", &star[i].x, &star[i].y, &star[i].b);\n\t\t--star[i].x; --star[i].y;\n\t}\n\tstar[n].b = INF;\n\t\n\tsort(star, star + n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tupdate(i, star[i]);\n\t}\n\t\n\t//printf(\"%d\\n\", INF);\n\t\n\tLL res = 0;\n\tfor (int l = 0; l < n; l++){\n\t\tint r = l;\n\t\twhile (star[r].b - star[l].b <= d) r++;\n\t\t\n\t\tDATA q = query(l, r, 0, 0, N);\n\t\tLL t = (LL)(q.maxx - q.minx) * (q.maxy - q.miny);\n\t\tres = max(res, t);\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> Pi;\ntypedef long long int lld;\nstruct SegmentTree\n{\n  static const int INF = 1 << 30;\n  \n  vector< int > small, big, sum, add;\n  int sz;\n  \n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    small.assign(2 * sz - 1, INF);\n    big.assign(2 * sz - 1, -INF);\n    sum.assign(2 * sz - 1, 0);\n    add.assign(2 * sz - 1, 0);\n  }\n  inline void Merge(int k)\n  {\n    small[k] = min(small[2 * k + 1] + add[2 * k + 1], small[2 * k + 2] + add[2 * k + 2]);\n    big[k] = max(big[2 * k + 1] + add[2 * k + 1], big[2 * k + 2] + add[2 * k + 2]);\n    sum[k] = sum[2 * k + 1] + add[2 * k + 1] + sum[2 * k + 2] + add[2 * k + 2];\n  }\n  inline int RangeMaximumQuery(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return(-INF);\n    if(a <= l && r <= b) return(big[k] + add[k]);\n    int L = RangeMaximumQuery(a, b, 2 * k + 1, l, (l + r) >> 1);\n    int R = RangeMaximumQuery(a, b, 2 * k + 2, (l + r) >> 1, r);\n    return(max(L, R) + add[k]);\n  }\n  inline int RangeMinimumQuery(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return(INF);\n    if(a <= l && r <= b) return(small[k] + add[k]);\n    int L = RangeMinimumQuery(a, b, 2 * k + 1, l, (l + r) >> 1);\n    int R = RangeMinimumQuery(a, b, 2 * k + 2, (l + r) >> 1, r);\n    return(min(L, R) + add[k]);\n  }\n  inline int RangeSumQuery(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return(INF);\n    if(a <= l && r <= b) return(sum[k] + add[k]);\n    int L = RangeSumQuery(a, b, 2 * k + 1, l, (l + r) >> 1);\n    int R = RangeSumQuery(a, b, 2 * k + 2, (l + r) >> 1, r);\n    return(L + R + add[k]);\n  }\n  void RangeAdd(int a, int b, int x, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return;\n    if(a <= l && r <= b) {\n      add[k] += x;\n      return;\n    }\n    RangeAdd(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n    RangeAdd(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n    Merge(k);\n  }\n \n  void Update(int k, int x)\n  {\n    k += sz - 1;\n    small[k] = big[k] = sum[k] = x;\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      Merge(k);\n    }\n  }\n  int RangeMaximumQuery(int a, int b)\n  {\n    return(RangeMaximumQuery(a, b, 0, 0, sz));\n  }\n  int RangeMinimumQuery(int a, int b)\n  {\n    return(RangeMinimumQuery(a, b, 0, 0, sz));\n  }\n  int RangeSumQuery(int a, int b)\n  {\n    return(RangeSumQuery(a, b, 0, 0, sz));\n  }\n  void RangeAdd(int a, int b, int x)\n  {\n    return(RangeAdd(a, b, x, 0, 0, sz));\n  }\n};\n\nint n,d;\nPi star[200000];\nSegmentTree X(200010),Y(200010);\n\nint main(){\n  cin >> n >> d;\n  for(int i=0;i<n;i++){\n    cin >> star[i].second.first >> star[i].second.second >> star[i].first;\n  }\n  sort(star,star+n);\n  for(int i=0;i<n;i++){\n    X.Update(i,star[i].second.first);\n    Y.Update(i,star[i].second.second);\n  }\n  int idx = 0;\n  lld ans = -1;\n  for(int i=0;i<n;i++){\n    while(idx < n && star[idx].first - star[i].first <= d) idx++;\n    lld maxx = X.RangeMaximumQuery(i,idx);\n    lld minx = X.RangeMinimumQuery(i,idx);\n    lld maxy = Y.RangeMaximumQuery(i,idx);\n    lld miny = Y.RangeMinimumQuery(i,idx);\n    ans = max(ans,(maxx-minx)*(maxy-miny));\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct st { int x, y, b; }s[200000];\nint main() {\n\tint n, d; scanf(\"%d%d\", &n, &d);\n\trep(i, n)scanf(\"%d%d%d\", &s[i].x, &s[i].y, &s[i].b);\n\tsort(s, s + n, [](st a, st b) {return a.b < b.b; });\n\tmultiset<int>x, y;\n\tint t = 0, Max = 0;\n\trep(i, n) {\n\t\twhile (s[i].b - s[t].b > d) {\n\t\t\tx.erase(x.find(s[t].x));y.erase(y.find(s[t].y));\n\t\t\tt++;\n\t\t}\n\t\tx.insert(s[i].x); y.insert(s[i].y);\n\t\tMax = max(Max, (*x.rbegin() - *x.begin())*(*y.rbegin() - *y.begin()));\n\t}\n\tprintf(\"%d\\n\", Max);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nclass Star\n{\npublic:\n\tint x, y, b;\n\tint boundary;\n};\nbool operator > (Star s1, Star s2)\n{\n\treturn s1.b > s2.b;\n}\nbool operator < (Star s1, Star s2)\n{\n\treturn s1.b < s2.b;\n}\n\nint n, d;\nStar star[200000];\nint maxX = 0, maxY = 0, minX = 0, minY = 0;\nint ans = 0;\n\nvoid calcBoundary()\n{\n\tint boundary = n - 1;\n\tstar[n - 1].boundary = boundary;\n\tfor (int i = n - 2; i >= 0; i--)\n\t{\n\t\tif (star[i + 1].b - star[i].b >= 2) boundary = i;\n\t\tstar[i].boundary = boundary;\n\t}\n\t\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tStar s;\n\t\ts.b = star[i].b + d;\n\t\tboundary = upper_bound(star + i, star + n, s) - star - 1;\n\t\tstar[i].boundary = min(star[i].boundary, boundary);\n\t}\n}\n\nvoid solve()\n{\n\tint boundary = -1;\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tif (star[i].boundary != boundary)\n\t\t{\n\t\t\tboundary = star[i].boundary;\n\t\t\tans = max((minX - maxX)*(minY - maxY), ans);\n\t\t\tmaxX = star[i].x;\n\t\t\tminX = star[i].x;\n\t\t\tmaxY = star[i].y;\n\t\t\tminY = star[i].y;\n\n\t\t\tfor (int j = i + 1; j <= star[i].boundary; j++)\n\t\t\t{\n\t\t\t\tmaxX = max(star[j].x, maxX);\n\t\t\t\tmaxY = max(star[j].y, maxY);\n\t\t\t\tminX = min(star[j].x, minX);\n\t\t\t\tminY = min(star[j].y, minY);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmaxX = max(star[i].x, maxX);\n\t\t\tmaxY = max(star[i].y, maxY);\n\t\t\tminX = min(star[i].x, minX);\n\t\t\tminY = min(star[i].y, minY);\n\t\t}\n\t}\n\n\tans = max((maxX - minX)*(maxY - minY), ans);\n}\n\nint main()\n{\n\tcin >> n >> d;\n\tfor (int i = 0; i < n; i++) cin >> star[i].x >> star[i].y >> star[i].b;\n\t\n\tsort(star, star + n);\n\tcalcBoundary();\n\tsolve();\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define F first\n#define S second\n#define PB push_back\n#define INF 2000000\nll n,L,br[200005],brd[200005],x[200005],y[200005],ans;\nP sgx[1<<20],sgy[1<<20];\nvector<ll>cm;\nmap<ll,ll>pr;\nvoid upx(ll a,ll p){\n    a+=(1LL<<19)-1;\n    if(sgx[a].F<p)sgx[a].F=p;\n    if(sgx[a].S>p)sgx[a].S=p;\n    while(a>0){\n        a=(a-1)/2;\n        sgx[a].F=max(sgx[a*2+1].F,sgx[a*2+2].F);\n        sgx[a].S=min(sgx[a*2+1].S,sgx[a*2+2].S);\n    }\n}\nvoid upy(ll a,ll p){\n    a+=(1LL<<19)-1;\n    if(sgy[a].F<p)sgy[a].F=p;\n    if(sgy[a].S>p)sgy[a].S=p;\n    while(a>0){\n        a=(a-1)/2;\n        sgy[a].F=max(sgy[a*2+1].F,sgy[a*2+2].F);\n        sgy[a].S=min(sgy[a*2+1].S,sgy[a*2+2].S);\n    }\n}\nP quex(int a,int b,int l,int r,int k){\n    if(r<a||b<l)return P(0,INF);\n    if(a<=l&&r<=b)return sgx[k];\n    P s=quex(a,b,l,(l+r-1)/2,k*2+1),t=quex(a,b,(l+r+1)/2,r,k*2+2);\n    return P(max(s.F,t.F),min(s.S,t.S));\n}\nP quey(int a,int b,int l,int r,int k){\n    if(r<a||b<l)return P(0,INF);\n    if(a<=l&&r<=b)return sgy[k];\n    P s=quey(a,b,l,(l+r-1)/2,k*2+1),t=quey(a,b,(l+r+1)/2,r,k*2+2);\n    return P(max(s.F,t.F),min(s.S,t.S));\n}\nint main(void){\n    scanf(\"%lld%lld\",&n,&L);\n    for(int i=0;i<n;i++){\n        scanf(\"%lld%lld%lld\",x+i,y+i,br+i);\n        brd[i]=br[i]+L;\n        cm.PB(br[i]);\n        cm.PB(brd[i]);\n    }\n    sort(cm.begin(),cm.end());\n    cm.erase(unique(cm.begin(),cm.end()),cm.end());\n    for(int i=0;i<cm.size();i++)pr[cm[i]]=i;\n    for(int i=0;i<1<<20;i++){\n        sgx[i]=P(0,INF);\n        sgy[i]=P(0,INF);\n    }\n    for(int i=0;i<n;i++){\n        br[i]=pr[br[i]];\n        brd[i]=pr[brd[i]];\n        upx(br[i],x[i]);\n        upy(br[i],y[i]);\n    }\n    for(int i=0;i<n;i++){\n        P s=quex(br[i],brd[i],0,(1<<19)-1,0),t=quey(br[i],brd[i],0,(1<<19)-1,0);\n        ans=max(ans,(s.F-s.S)*(t.F-t.S));\n    }\n    printf(\"%lld\\n\",ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n\ntypedef pair<long long,long long> PA;\ntypedef pair<int,PA> PPA;\n\nconst long long INF = (1LL<<40);\n\nstruct SegTree{\n  \n  int size;\n  vector<long long> vec;\n  \n  void init(int n){\n    size = 1;\n    while(size < n) size <<= 1;\n    for(int i=0;i<2*size-1;i++) vec.push_back(INF);\n  }\n  \n  void update(int k,long long a){\n    k += size-1;\n    vec[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      vec[k] = min(vec[2*k+1],vec[2*k+2]);\n    }\n  }\n  long long query(int a,int b){\n    return (query(a, b, 0, 0, size - 1));\n  }\n  long long query(int a,int b,int k,int l,int r){\n    if(r < a || b < l) return INF;\n    if(a <= l && r <= b) return vec[k];\n    long long nl = query(a,b,2*k+1,l,(l+r)/2);\n    long long nr = query(a,b,2*k+2,(l+r)/2+1,r);\n    return min(nl, nr);\n  }\n  \n\n};\n\nvector<PPA> p;\nSegTree lx,rx,ly,ry;\n\nint main(){\n\n  int n,d;\n  cin >> n >> d;\n \n  lx.init(n);\n  rx.init(n);\n  ly.init(n);\n  ry.init(n);\n\n  long long x,y;\n  int b;\n  for(int i=0;i<n;i++){\n    cin >> x >> y >> b;\n    p.push_back(PPA(b,PA(x,y)));\n  }\n  \n  sort(p.begin(),p.end());\n\n  for(int i=0;i<n;i++){\n    \n    lx.update(i,p[i].second.first);\n    rx.update(i,-p[i].second.first);\n    ly.update(i,p[i].second.second);\n    ry.update(i,-p[i].second.second);\n    \n  }\n  \n  int mi = 0;\n  long long h,w,s=0;\n  for(int i=0;i<n;i++){\n    while(p[i].first-p[mi].first > d) mi++;\n   \n    w = -rx.query(mi,i) -lx.query(mi,i);\n    h = -ry.query(mi,i) -ly.query(mi,i);\n\n    s = max(s,w*h);\n  }\n  \n  cout << s << endl;\n  return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n#define int long long\n#define MAX_N 200000\n#define F first\n#define Se second\n#define MP(i, j) make_pair((i), (j))\nconst int INF = 2e18;\nstruct S{\n\tint sx, lx, sy, ly;\n\tS(int isx, int ilx, int isy, int ily): sx(isx), lx(ilx), sy(isy), ly(ily){}\n\tbool operator<(const S &s) const { \n\t\treturn 1;\n\t}\n};\ntypedef pair<int, S> PS;\ntypedef vector<PS>::iterator it;\n\nint i, j, n, d, stars[MAX_N][3];\nint ans;\nvector<PS> vec;\n\n\nvoid vdc(vector<PS> &vf, S s, int now){\n\tif(vf[now].Se.sx > s.sx)\n\t\tvf[now].Se.sx = s.sx;\n\tif(vf[now].Se.lx < s.lx)\n\t\tvf[now].Se.lx = s.lx;\n\tif(vf[now].Se.sy > s.sy)\n\t\tvf[now].Se.sy = s.sy;\n\tif(vf[now].Se.ly < s.ly)\n\t\tvf[now].Se.ly = s.ly;\n}\n\nsigned main(){\n\tcin >> n >> d;\n\tvec.push_back(MP(-1, S(0, 0, 0, 0)));\n\tfor(i = 0; i < n; i++){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tS s = S(a, a, b, b);\n\t\tit ite = lower_bound(vec.begin(), vec.end(), MP(c, s));\n\t\tif(vec[ite - vec.begin() - 1].F != c){\n\t\t\tvec.insert(ite, MP(c, s));\n\t\t}\n\t\telse{\n\t\t\tvdc(vec, s, ite - vec.begin() - 1);\n\t\t}\n\t}\n\tS s = S(INF, 0, INF, 0);\n\tvec.erase(vec.begin());\n\tfor(i = 0; i < vec.size(); i++){\n\t\tif(vec[i].F - vec[0].F > d){\n\t\t\ti = -1;\n\t\t\tvec.erase(vec.begin());\n\t\t\tans = max(ans, (s.lx - s.sx) * (s.ly - s.sy));\n\t\t\ts = S(INF, 0, INF, 0);\n\t\t}\n\t\telse{\n\t\t\ts = S(min(vec[i].Se.sx, s.sx), max(vec[i].Se.lx, s.lx), min(vec[i].Se.sy, s.sy), max(vec[i].Se.ly, s.ly));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 0302.cc: Star Watching\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 200000;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef pair<int,int> pii;\n\ntemplate <typename T, const int BUFSIZE>\nstruct Treap {\n  struct Node {\n    T key, minkey, maxkey;\n    int fix, size, cnt;\n    Node *left, *right;\n\n    void print(int k) {\n      printf(\"%d: key=%lld, minkey=%lld, maxkey=%lld, fix=%d, size=%d\\n\",\n\t     k, key, minkey, maxkey, fix, size);\n    }\n    void print() { print(0); }\n  };\n  typedef Node *node;\n\n  node root, nullnode, buf;\n  Node buf0[BUFSIZE], buf1;\n\n  const T TINF;\n  \n  Treap(T tinf): TINF(tinf) {\n    nullnode = &buf1;\n    nullnode->left = nullnode->right = nullnode;\n    nullnode->key = nullnode->minkey = TINF;\n    nullnode->maxkey = 0;\n    nullnode->fix = nullnode->size = nullnode->cnt = 0;\n    clear();\n    srand(time(NULL));\n  }\n\n  void clear() { buf = buf0; root = nullnode; }\n  \n  int size() { return root->size; }\n\n  void update(node& t) {\n    t->size = 1 + t->left->size + t->right->size;\n    t->minkey = t->maxkey = t->key;\n    if (t->minkey > t->left->minkey) t->minkey = t->left->minkey;\n    if (t->minkey > t->right->minkey) t->minkey = t->right->minkey;\n    if (t->maxkey < t->left->maxkey) t->maxkey = t->left->maxkey;\n    if (t->maxkey < t->right->maxkey) t->maxkey = t->right->maxkey;\n  }\n\n  node gen_node(T x) {\n    node t = buf++;\n    t->left = t->right = nullnode;\n    t->key = t->minkey = t->maxkey = x;\n    t->fix = rand();\n    t->size = t->cnt = 1;\n    return t;\n  }\n  \n  void rot_l(node& k1) {\n    node k2 = k1->right;\n    k1->right = k2->left;\n    k2->left = k1;\n    update(k1);\n    update(k2);\n    k1 = k2;\n  }\n\n  void rot_r(node& k1) {\n    node k2 = k1->left;\n    k1->left = k2->right;\n    k2->right = k1;\n    update(k1);\n    update(k2);\n    k1 = k2;\n  }\n\n  void insert(node& t, T x) {\n    if (t == nullnode)\n      t = gen_node(x);\n    else {\n      if (t->key == x) {\n\tt->cnt++;\n\treturn;\n      }\n      if (x < t->key) {\n\tinsert(t->left, x);\n\tupdate(t);\n\tif (t->left->fix > t->fix) rot_r(t);\n      }\n      else {\n\tinsert(t->right, x);\n\tupdate(t);\n\tif (t->right->fix > t->fix) rot_l(t);\n      }\n    }\n  }\n  void insert(T x) { insert(root, x); }\n\n  void remove_node(node& t) {\n    if (t == nullnode) return;\n    if (t->left == nullnode || t->right == nullnode) {\n      if (t->left == nullnode)\n\tt = t->right;\n      else\n\tt = t->left;\n    }\n    else {\n      if (t->left->fix < t->right->fix) {\n\trot_l(t);\n\tremove_node(t->left);\n\tupdate(t);\n      }\n      else {\n\trot_r(t);\n\tremove_node(t->right);\n\tupdate(t);\n      }\n    }\n  }\n\n  void remove(node& t, T x) {\n    if (t != nullnode) {\n      if (t->key == x) {\n\tif (--t->cnt <= 0) remove_node(t);\n      }\n      else if (x < t->key) {\n\tremove(t->left, x);\n\tupdate(t);\n      }\n      else {\n\tremove(t->right, x);\n\tupdate(t);\n      }\n    }\n  }\n  void remove(T x) { remove(root, x); }\n\n  T findat(int i) {\n    node t = root;\n    while (t != nullnode) {\n      int lsize = t->left->size;\n      if (i == lsize) return t->key;\n      if (i < lsize)\n\tt = t->left;\n      else {\n\ti -= lsize + 1;\n\tt = t->right;\n      }\n    }\n    return TINF;\n  }\n\n  void print(node t, int k, int indent) {\n    if (t == nullnode) return;\n    if (t != NULL) {\n      for (int i = 0; i < indent; i++) cout << \"  \";\n      t->print(k + t->left->size);\n      print(t->left, k, indent + 1);\n      print(t->right, k + t->left->size + 1, indent + 1);\n    }\n  }\n  void print() { print(root, 0, 0); }\n};\n\nstruct Star {\n  int x, y, b;\n  Star() {}\n  Star(int _x, int _y, int _b): x(_x), y(_y), b(_b) {}\n  bool operator<(const Star &s) const { return b < s.b; }\n  void print() { printf(\"(%d,%d):%d\\n\", x, y, b); }\n};\n\n/* global variables */\n\nTreap<int,MAX_N> xtrp(INF), ytrp(INF);\nStar sts[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n, d;\n  cin >> n >> d;\n\n  for (int i = 0; i < n; i++)\n    cin >> sts[i].x >> sts[i].y >> sts[i].b;\n  sort(sts, sts + n);\n  //for (int i = 0; i < n; i++) printf(\"%d: \", i), sts[i].print();\n  \n  int maxar = 0;\n\n  for (int i = 0, j = 0; j < n;) {\n    int maxb = sts[i].b + d;\n    while (j < n && sts[j].b <= maxb) {\n      xtrp.insert(sts[j].x);\n      ytrp.insert(sts[j].y);\n      j++;\n    }\n\n    int minx = xtrp.findat(0);\n    int maxx = xtrp.findat(xtrp.size() - 1);\n    int miny = ytrp.findat(0);\n    int maxy = ytrp.findat(ytrp.size() - 1);\n\n    int ar = (maxx - minx) * (maxy - miny);\n    if (maxar < ar) maxar = ar;\n    //printf(\"i=%d,j=%d: (%d-%d)*(%d-%d) ar=%d\\n\",\n    //i, j, minx, maxx, miny, maxy, ar);\n\n    for (int pb = sts[i].b; i < n && pb == sts[i].b; i++) {\n      xtrp.remove(sts[i].x);\n      ytrp.remove(sts[i].y);\n    }\n  }\n\n  printf(\"%d\\n\", maxar);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define INF 1e+9\nusing namespace std;\n\nint seg,segMin[2][600000],segMax[2][600000];\n\nint getMin(int a,int b,int k,int l,int r,int num){\n\tif(b <= l || r <= a) return INF;\n\tif(a <= l && r <= b) return segMin[num][k];\n\treturn min(getMin(a,b,k * 2 + 1,l,(l + r) / 2,num),getMin(a,b,k * 2 + 2,(l + r) / 2,r,num));\n}\n\nint getMax(int a,int b,int k,int l,int r,int num){\n\tif(b <= l || r <= a) return 0;\n\tif(a <= l && r <= b) return segMax[num][k];\n\treturn max(getMax(a,b,k * 2 + 1,l,(l + r) / 2,num),getMax(a,b,k * 2 + 2,(l + r) / 2,r,num));\n}\n\nvoid updMin(int i,int x,int num){\n\ti += seg - 1;\n\tsegMin[num][i] = min(x,segMin[num][i]);\n\twhile(i){\n\t\ti = (i - 1) / 2;\n\t\tsegMin[num][i] = min(segMin[num][i * 2 + 1],segMin[num][i * 2 + 2]);\n\t}\n}\n\nvoid updMax(int i,int x,int num){\n\ti += seg - 1;\n\tsegMax[num][i] = max(x,segMax[num][i]);\n\twhile(i){\n\t\ti = (i - 1) / 2;\n\t\tsegMax[num][i] = max(segMax[num][i * 2 + 1],segMax[num][i * 2 + 2]);\n\t}\n}\n\nint main(){\n\tint n,d,x[200000],y[200000],b[200000];\n\tcin >> n >> d;\n\tseg = 1;\n\twhile(seg < n) seg *= 2;\n\tfor(int i = 0;i < seg * 2 - 1;i++){\n\t\tsegMin[0][i] = INF;\n\t\tsegMin[1][i];\n\t}\n\tvector<int> vec;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x[i] >> y[i] >> b[i];\n\t\tvec.push_back(b[i]);\n\t}\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end());\n\tfor(int i = 0;i < n;i++){\n\t\tint pos = lower_bound(vec.begin(),vec.end(),b[i]) - vec.begin();\n\t\tupdMin(pos,x[i],0);\n\t\tupdMax(pos,x[i],0);\n\t\tupdMin(pos,y[i],1);\n\t\tupdMax(pos,y[i],1);\n\t}\n\tint ma = 0;\n\tfor(int i = 0;i < n;i++){\n\t\tint low = lower_bound(vec.begin(),vec.end(),b[i]) - vec.begin();\n\t\tint up = upper_bound(vec.begin(),vec.end(),b[i] + d) - vec.begin() - 1;\n\t\tma = max(ma,(getMax(low,up + 1,0,0,seg,0) - getMin(low,up + 1,0,0,seg,0)) * (getMax(low,up,0,0,seg,1) - getMin(low,up,0,0,seg,1)));\n\t}\n\tcout << ma << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct STAR {\n  int x, y, d;\n};\n\nbool asc(STAR &l, STAR &r) {\n  return l.d < r.d;\n}\n\nint main() {\n  ll n, d, ans = 0;\n  cin >> n >> d;\n  vector<STAR> v(n);\n\n  rep(i, 0, n) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    v[i].x = a;\n    v[i].y = b;\n    v[i].d = c;\n  }\n\n  sort(v.begin(), v.end(), asc);\n\n  int hx = v[0].x, lx = v[0].x, hy = v[0].y, ly = v[0].y, ld = v[0].d, lp = 0;\n  rep(i, 1, n) {\n    if(v[i].d - ld <= d) {\n      hx = max(hx, v[i].x);\n      hy = max(hy, v[i].y);\n      lx = min(lx, v[i].x);\n      ly = min(ly, v[i].y);\n    }else {\n      ans = max(ans, (ll)(abs(hx - lx) * abs(hy - ly)));\n      int klp = lp;\n      rep(j, lp + 1, i) {\n        if(v[i].d - v[j].d <= d) {\n          lp = j;\n          break;\n        }\n      }\n      if(klp == lp) lp = i;\n      hx = v[lp].x, lx = v[lp].x, hy = v[lp].y, hx = v[lp].y, ld = v[lp].d;\n      rep(j, lp + 1, i + 1) {\n        hx = max(hx, v[j].x);\n        hy = max(hy, v[j].y);\n        lx = min(lx, v[j].x);\n        ly = min(ly, v[j].y);\n      }\n    }\n  }\n\n  cout << max(ans, (ll)(abs(hx - lx) * abs(hy - ly))) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+17 + 10;\n\nconst int maxN = 200010;\n\nclass RMQ{\nprivate:\n\tint n;\n\tP dat[maxN * 4];\n\n\t//[a,b),[l,r) //(Max,Min)\n\tP rec(int a, int b, int k, int l, int r){\n\t\tif (b <= l || r <= a)return P(-infi, infi);\n\t\tif (a <= l && r <= b)return P(dat[k].first, dat[k].second);\n\t\telse {\n\t\t\tP vl = rec(a, b, 2 * k + 1, l, (l + r) / 2), vr = rec(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\t\treturn P(std::max(vl.first, vr.first), std::min(vl.second, vr.second));\n\t\t}\n\t}\n\npublic:\n\tvoid init(int x){\n\t\tn = 1;\n\t\twhile (n < x)n *= 2;\n\t\trep(i, 2 * n - 1)dat[i] = P(-infi, infi);\n\t}\n\n\tvoid update(int k, int a){\n\t\tk += n - 1;\n\t\tdat[k] = P(a, a);\n\t\twhile (k > 0){\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k].first = std::max(dat[2 * k + 1].first, dat[2 * k + 2].first);\n\t\t\tdat[k].second = std::min(dat[2 * k + 1].second, dat[2 * k + 2].second);\n\t\t}\n\t}\n\n\t//[a,b] //(Max,Min)\n\tP query(int a, int b){\n\t\treturn rec(a, b + 1, 0, 0, n);\n\t}\n};\n\nstruct Star{ int x, y, b; };\nStar star[200001];\nint n, d;\nRMQ up, right;\n\nbool comp(const Star &lhs, const Star &rhs){\n\treturn lhs.b < rhs.b;\n}\n\nint main(){\n\tstd::cin >> n >> d;\n\trep(i, n)std::cin >> star[i].x >> star[i].y >> star[i].b;\n\tstd::sort(star, star + n, comp);\n\tll ans = 0;\n\tint first = 0;\n\tup.init(n), right.init(n);\n\trep(i, n){\n\t\tup.update(i, star[i].y);\n\t\tright.update(i, star[i].x);\n\t\twhile (star[i].b - star[first].b > d)++first;\n\t\tP a = up.query(first, i), b = right.query(first, i);\n\t\tll mul = (ll)(a.first - a.second) * (b.first - b.second);\n\t\tans = std::max(ans, mul);\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\tint N, d;\n\tcin>>N>>d;\n\tvector<pair<ll, P> > h(N);\n\tset<ll> s;\n\tREP(i, N) {\n\t\tll x, y, b;\n\t\tcin>>x>>y>>b;\n\t\th[i].first = b;\n\t\th[i].second.first = x;\n\t\th[i].second.second = y;\n\t}\n\tsort(ALL(h));\n\tll ite = 0;\n\tll ans = 0;\n\tpriority_queue<P> ux;\n\tpriority_queue<P> lx;\n\tpriority_queue<P> uy;\n\tpriority_queue<P> ly;\n\tREP(i, h.size()) {\n\t\tll lbr = h[i].first;\n\t\twhile(h[ite].first <= lbr + d && ite < N) {\n\t\t\tux.push(P(h[ite].second.first, h[ite].first));\n\t\t\tlx.push(P(-(h[ite].second.first), h[ite].first));\n\t\t\tuy.push(P(h[ite].second.second, h[ite].first));\n\t\t\tly.push(P(-(h[ite].second.second), h[ite].first));\n\t\t\t++ite;\n\t\t}\n\t\tll maxx = -1, maxy = -1, minx = -1, miny = -1;\n\n\t\twhile(!ux.empty()) {\n\t\t\tP hoge = ux.top();\n\t\t\tif(hoge.second >= lbr && hoge.second <= lbr + d) {\n\t\t\t\tmaxx = hoge.first;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tux.pop();\n\t\t\t}\n\t\t} while(!lx.empty()) {\n\t\t\tP hoge = lx.top();\n\t\t\tif(hoge.second >= lbr && hoge.second <= lbr + d) {\n\t\t\t\tminx = -(hoge.first);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlx.pop();\n\t\t\t}\n\t\t} while(!uy.empty()) {\n\t\t\tP hoge = uy.top();\n\t\t\tif(hoge.second >= lbr && hoge.second <= lbr + d) {\n\t\t\t\tmaxy = hoge.first;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tuy.pop();\n\t\t\t}\n\t\t} while(!ly.empty()) {\n\t\t\tP hoge = ly.top();\n\t\t\tif(hoge.second >= lbr && hoge.second <= lbr + d) {\n\t\t\t\tminy = -(hoge.first);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tly.pop();\n\t\t\t}\n\t\t}\n\t\tans = max(ans, (maxx - minx) * (maxy - miny));\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1000000000\n#define f first\n#define s second\nusing namespace std;\ntypedef pair <int,pair <int,int> > P;\ntypedef long long ll;\nint n,d,tree[4][(1<<19)];\nP star[200001];\n \nvoid update(int i,int flg,int x){\n  i = i+(1<<18)-1;\n  tree[flg][i] = x;\n  while(i) {\n    i = (i-1)/2;\n    tree[flg][i] = max(tree[flg][i*2+1],tree[flg][i*2+2]);\n  }\n}\n \nint find(int a,int b,int ima,int L,int R,int flg){\n  if(R<=a || b<=L) return -INF;\n  if(a<=L && R<=b) return tree[flg][ima];\n  int M = (L+R)/2;\n  return max(find(a,b,ima*2+1,L,M,flg),find(a,b,ima*2+2,M,R,flg));\n}\n \nint main() {\n  cin >> n >> d;\n \n  for(int i=0;i<n;i++)cin >> star[i].s.f >> star[i].s.s >> star[i].f;\n  sort(star,star+n);  \n   \n  for(int i=0;i<4;i++) \n    for(int j=0;j<(1<<19);j++) tree[i][j] = -INF;\n   \n  for(int i=0;i<n;i++) {\n    update(i,0,star[i].s.f); // max(x);\n    update(i,1,star[i].s.s); // max(y);\n    update(i,2,-star[i].s.f); // min(x);\n    update(i,3,-star[i].s.s); // min(y);\n  }\n \n  long long S=0;\n  int ima=0;\n  for(int i=0;i<n;i++){\n    while(ima!=n && star[ima].f-star[i].f <=d) ima++;\n    ll maxx = find(i,ima,0,0,(1<<18),0);\n    ll maxy = find(i,ima,0,0,(1<<18),1);\n    ll minx = find(i,ima,0,0,(1<<18),2);\n    ll miny = find(i,ima,0,0,(1<<18),3);\n    S = max(S,((maxx+minx)*(maxy+miny)));\n  }\n  cout << S<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nusing namespace std;\n\nstruct Star{\n\tint x,y,b;\n\tbool operator<(const Star& another) const {\n\t\treturn b < another.b;\n\t}\n};\n\nclass RMQ{\npublic:\n\tll n;\n\tvector<ll> dat;\n\tRMQ(ll n_){\n\t\tn = 1; while(n < n_) n *= 2;\n\t\tdat = vector<ll>(2*n-1,INT_MAX);\n\t}\n\n\t//dat[k] -> a\n\tvoid update(int k, int a){\n\t\tk += n-1;\n\t\tdat[k] = a;\n\t\twhile(k > 0){\n\t\t\tk = (k-1)/2;\n\t\t\tdat[k] = min(dat[k*2+1], dat[k*2+2]);\n\t\t}\n\t}\n\n\tll query(int a, int b, int k, int l, ll r){\n\t\tif(r <= a || b <= l) return INT_MAX;\n\t\tif(a <= l && r <= b) return dat[k];\n\t\telse return min(query(a, b, k*2+1, l, (l+r)/2), query(a, b, k*2+2, (l+r)/2, r));\n\t}\n\n\t//[a,b) <- coution a~(b-1)\n\tll getMin(int a, int b){\n\t\treturn query(a,b,0,0,n);\n\t}\n};\n\nint N,d;\nvector<Star> s;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> d;\n\n\tfor (int i = 0;i < N;i++){\n\t\tint x,y,b; cin >> x >> y >> b;\n\t\ts.push_back((Star){x,y,b});\n\t}\n\n\tsort(s.begin(),s.end());\n\n\tRMQ minX(N);\n\tRMQ minY(N);\n\tRMQ maxX(N);\n\tRMQ maxY(N);\n\n\tfor (int i = 0;i < N;i++){\n\t\tminX.update(i,s[i].x);\n\t\tminY.update(i,s[i].y);\n\t\tmaxX.update(i,s[i].x*(-1));\n\t\tmaxY.update(i,s[i].y*(-1));\n\t}\n\n\tll ans = -1;\n\tint f = 0, t = 0;\n\n\tfor(f;f < N;f++){\n\t\twhile(t < N && s[t].b - s[f].b <= d) t++;\n\t\tll area = (maxX.getMin(f,t)*(-1)-minX.getMin(f,t)) * (maxY.getMin(f,t)*(-1)-minY.getMin(f,t));\n\t\tans = max(ans,area);\t\t\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n\nclass C{\n  public:\n    int x, y, b;\n    C(){}\n    C(int xx, int yy, int bb) { x = xx; y = yy; b = bb; }\n    bool operator < (const C &c) const { return b < c.b; }\n};\n \nint main() {\n  int N, d; cin >>N >>d;\n  vector<C> cs(N);\n  REP(i, N) cin >>cs[i].x >>cs[i].y >>cs[i].b;\n  SORT(cs);\n  int h = 0, t = 0, ans = 0;\n  multiset<int> xs{cs[0].x}, ys{cs[0].y};\n  while(h < N - 1 || t < N - 1){\n    if(cs[h].b - cs[t].b <= d)\n      ans = max(ans, (*max_element(xs.begin(), xs.end()) - *min_element(xs.begin(), xs.end())) * (*max_element(ys.begin(), ys.end()) - *min_element(ys.begin(), ys.end())));\n    if((h + 1 < N && cs[h + 1].b - cs[t].b <= d) || !(h - t)){\n      xs.insert(cs[++h].x);\n      ys.insert(cs[h].y);\n    } else{\n      xs.erase(xs.lower_bound(cs[t].x));\n      ys.erase(ys.lower_bound(cs[t++].y));\n    }\n  }\n  cout <<ans <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0302 (http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0302)\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<limits>\n#define rep(i,a) for(int i=0;i<(a);++i)\n#define all(a) (a).begin(), (a).end()\n\ntypedef long long ll;\ntypedef std::pair<ll, ll> Pt;\n\nstruct Dat\n{ \n\tll x, y, b;\n\n\tDat( ll x, ll y, ll b )\n\t:\tx(x), y(y), b(b)\n\t{}\n\n\tbool operator< ( const Dat &rhs ) const\n\t{ return b < rhs.b; }\n};\n\nPt minPt( const Pt &lhs, const Pt &rhs )\n{ return Pt( std::min( lhs.first, rhs.first ), std::min( lhs.second, rhs.second ) ); }\n\nPt maxPt( const Pt &lhs, const Pt &rhs )\n{ return Pt( std::max( lhs.first, rhs.first ), std::max( lhs.second, rhs.second ) ); }\n\nstruct Pts\n{ \n\tPt lb, rt;\n\n\tPts()\n\t{}\n\n\tPts( const Pt &lb, const Pt &rt )\n\t:\tlb(lb), rt(rt)\n\t{}\n\n\tbool operator< ( const Pts &rhs ) const\n\t{ return std::make_pair( lb, rt ) < std::make_pair( rhs.lb, rhs.rt ); }\n\n\tll area() const\n\t{ return (rt.first-lb.first)*(rt.second-lb.second); }\n};\n\nconst int MAX_N = 200000;\nconst ll INF = std::numeric_limits<ll>::max()>>2;\n\nint N, d;\nstd::vector<Dat> vs;\n\nstruct SegTree\n{\n\tstd::size_t sz;\n\tstd::vector<Pts> seg;\n\n\tSegTree( std::size_t n )\n\t{\n\t\tsz = 1;\n\t\twhile( sz < n )\n\t\t\tsz <<= 1;\n\n\t\tseg.resize( 2*sz-1 );\n\t\trep( i, seg.size() )\n\t\t{\n\t\t\tseg[i].lb = Pt( INF, INF );\n\t\t\tseg[i].rt = Pt( 0, 0 );\n\t\t}\n\t}\n\n\tvoid update( int k, const Dat &x )\n\t{\n\t\tk += sz-1;\n\t\tseg[k].lb = minPt( seg[k].lb, Pt( x.x, x.y ) );\n\t\tseg[k].rt = maxPt( seg[k].rt, Pt( x.x, x.y ) );\n\n\t\twhile( k )\n\t\t{\n\t\t\tk = k-1>>1;\n\t\t\tseg[k] = Pts( minPt( seg[2*k+1].lb, seg[2*k+2].lb ), maxPt( seg[2*k+1].rt, seg[2*k+2].rt ) );\n\t\t}\n\n\t\treturn;\n\t}\n\n\tPts query( int a, int b, int k, int l, int r )\n\t{\n\t\tif( b <= l || r <= a )\n\t\t\treturn Pts( Pt( INF, INF ), Pt( 0, 0 ) );\n\t\telse if( a <= l && r <= b )\n\t\t\treturn seg[k];\n\t\t\n\t\tPts pl = query( a, b, 2*k+1, l, l+r>>1 ),\n\t\t    pr = query( a, b, 2*k+2, l+r>>1, r );\n\n\t\treturn Pts( minPt( pl.lb, pr.lb ), maxPt( pl.rt, pr.rt ) );\n\t}\n};\n\nint main()\n{\n\tscanf( \"%d%d\", &N, &d );\n\trep( i, N )\n\t{\n\t\tll x, y, b;\n\t\tscanf( \"%lld%lld%lld\", &x, &y, &b );\n\t\tvs.push_back( Dat( x, y, b ) );\n\t}\n\n\tstd::sort( all(vs) );\n\n\tSegTree st( N );\n\t\n\trep( i, N )\n\t\tst.update( i, vs[i] );\n\n\tint s = 0, t = 0;\n\tll ans = 0;\n\n\tfor( s = 0; s < N; ++s )\n\t{\n\t\twhile( t < N && vs[t].b-vs[s].b <= d )\n\t\t\t++t;\n\t\tif( t == N-1 )\n\t\t\t++t;\n\n\t\tans = std::max( ans, st.query( s, t, 0, 0, st.sz ).area() );\n\t}\n\n\tprintf( \"%lld\\n\", ans );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n\ntypedef pair< int, int > Pi;\ntypedef pair< int, Pi > Pii;\n\nint main(){\n  int N, d;\n  Pii data[200000];\n  multiset< int > X, Y;\n  scanf(\"%d %d\", &N, &d);\n  for(int i = 0; i < N; i++){\n    scanf(\"%d %d %d\", &data[i].second.first, &data[i].second.second, &data[i].first);\n  }\n  sort( data, data + N);\n  int64 ret = 0, low = 0;\n  for(int i = 0; i < N; i++){\n    while(data[low].first < data[i].first - d){\n      X.erase( X.find(data[low].second.first));\n      Y.erase( Y.find(data[low].second.second));\n      low++;\n    }\n    X.insert( data[i].second.first);\n    Y.insert( data[i].second.second);\n\n    ret = max( ret, (int64)(*--X.end() - *X.begin()) * (*--Y.end() - *Y.begin()));\n  }\n  printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct star{int x,y,b;};\n\nbool operator<(const star& s1,const star& s2){\n    return s1.b < s2.b;\n}\n\nclass xma{\npublic:\n    bool operator()(const star& s1,const star& s2){\n        return s1.x < s2.x;\n    }\n};\n\nclass yma{\npublic:\n    bool operator()(const star& s1,const star& s2){\n        return s1.y < s2.y;\n    }\n};\n\nclass xmi{\npublic:\n    bool operator()(const star& s1,const star& s2){\n        return s1.x > s2.x;\n    }\n};\n\nclass ymi{\npublic:\n    bool operator()(const star& s1,const star& s2){\n        return s1.y > s2.y;\n    }\n};\n\nstar s[200001];\n\nint main() {\n\n    int n;\n    int d;\n\n    cin >> n >> d;\n\n    for(int i=0;i<n;i++){\n        cin >> s[i].x >> s[i].y >> s[i].b;\n    }\n\n    sort(s,s+n);\n\n    long long int ans = 0;\n\n    map<int,int> x,y;\n\n    priority_queue<star,vector<star>,xma> xmax;\n    priority_queue<star,vector<star>,yma> ymax;\n    priority_queue<star,vector<star>,xmi> xmin;\n    priority_queue<star,vector<star>,ymi> ymin;\n\n    for(int k=0;k<n;k++){\n\n        xmax.push(s[k]);\n        ymax.push(s[k]);\n        xmin.push(s[k]);\n        ymin.push(s[k]);\n\n\n        //x[s[k].x] += 1;\n        //y[s[k].y] += 1;\n\n        while(!xmax.empty() && xmax.top().b + d < s[k].b){\n            xmax.pop();\n        }\n        while(!ymax.empty() && ymax.top().b + d < s[k].b){\n            ymax.pop();\n        }\n        while(!xmin.empty() && xmin.top().b + d < s[k].b){\n            xmin.pop();\n        }\n        while(!ymin.empty() && ymin.top().b + d < s[k].b){\n            ymin.pop();\n        }\n\n        long long int dx = xmax.top().x - xmin.top().x;\n        long long int dy = ymax.top().y - ymin.top().y;\n\n        //cout << xmax.top().x << \" \"  << -xmin.top().x << \" \" << ymax.top().y << \" \" << -ymin.top().y << endl;\n\n        ans = max(ans,dx*dy);\n\n    }\n\n    cout << ans << endl;\n\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint N=0;\nlong int b=0;\nint maxx=0,maxy=0,maxs=0,ks=0,x[200000],y[200000],cnt=1;\nstruct DATA{\n\tint x,y,b;\n};\nDATA data[200000];\n\nint main(){\n\tcin>>N>>b;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>data[i].x>>data[i].y>>data[i].b;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tmaxx=0;maxy=0;cnt=1;\n\t\tx[0]=data[i].x;\n\t\ty[0]=data[i].y;\n\t\tfor(int j=0;j<N;j++){\n\t\t\t\n\t\t\tif(0<=data[i].b-data[j].b&&data[i].b-data[j].b<=b){\n\t\t\t\tcnt++;\n\t\t\t\tx[cnt]=data[j].x;\n\t\t\t\ty[cnt]=data[j].y;\n\t\t\t}\n\t\t\tif(j==N-1){\n\t\t\t\tsort(x,x+cnt);\n\t\t\t\tsort(y,y+cnt);\n\t\t\t\tmaxx=x[cnt]-x[0];\n\t\t\t\tmaxy=y[cnt]-y[0];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tks=maxx*maxy;\n\t\tif(maxs<ks){maxs=ks;}\n\t}\n\tcout<<maxs<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<climits>\nusing namespace std;\nstruct maxSegTree{\n    int n;\n    vector<int>dat;\n    void init(int n_){\n        n=1;\n        while(n<n_)n*=2;\n        dat.resize(n*2-1,INT_MIN);\n    }\n    maxSegTree(int n_){\n        init(n_);\n    }\n    void update(int x,int val){\n        x+=n-1;\n        dat[x]=val;\n        while(x){\n            x=(x-1)/2;\n            dat[x]=max(dat[x*2+1],dat[x*2+2]);\n        }\n    }\n    int getMax(int a,int b,int k=0,int l=0,int r=-1){\n        if(r==-1)r=n;\n        if(a<=l&&b>=r)return dat[k];\n        if(a>=r||b<=l)return INT_MIN;\n        int v1=getMax(a,b,k*2+1,l,(l+r)/2);\n        int v2=getMax(a,b,k*2+2,(l+r)/2,r);\n        return max(v1,v2);\n    }\n};\nstruct minSegTree{\n    int n;\n    vector<int>dat;\n    void init(int n_){\n        n=1;\n        while(n<n_)n*=2;\n        dat.resize(n*2-1,INT_MAX);\n    }\n    minSegTree(int n_){\n        init(n_);\n    }\n    void update(int x,int val){\n        x+=n-1;\n        dat[x]=val;\n        while(x){\n            x=(x-1)/2;\n            dat[x]=min(dat[x*2+1],dat[x*2+2]);\n        }\n    }\n    int getMin(int a,int b,int k=0,int l=0,int r=-1){\n        if(r==-1)r=n;\n        if(a<=l&&b>=r)return dat[k];\n        if(a>=r||b<=l)return INT_MAX;\n        int v1=getMin(a,b,k*2+1,l,(l+r)/2);\n        int v2=getMin(a,b,k*2+2,(l+r)/2,r);\n        return min(v1,v2);\n    }\n};\nint main(){\n    int n,d;\n    scanf(\"%d%d\",&n,&d);\n    vector<pair<int,pair<int,int> > >V(n);\n    vector<int>D(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d%d\",&V[i].second.first,&V[i].second.second,&V[i].first);\n        D[i]=V[i].first;\n    }\n    sort(V.begin(),V.end());\n    sort(D.begin(),D.end());\n    maxSegTree ma(n*2);\n    minSegTree mi(n*2);\n    int mav=INT_MIN;\n    for(int i=0;i<n;i++){\n        pair<int,pair<int,int> >p=V[i];\n        int x=p.second.first,y=p.second.second,b=p.first;\n        ma.update(i,x);ma.update(i+n,y);\n        mi.update(i,x);mi.update(i+n,y);\n    }\n\n    for(int i=0;i<n;i++){\n        pair<int,pair<int,int> >p=V[i];\n        int b=D[i];\n        int pos=upper_bound(D.begin(),D.end(),b+d)-D.begin();\n        int mx=ma.getMax(i,pos),my=ma.getMax(i+n,pos+n);\n        int mix=mi.getMin(i,pos),miy=mi.getMin(i+n,pos+n);\n        int m2=(mx-mix)*(my-miy);\n        mav=max(mav,m2);\n        //cout<<i<<\" \"<<pos<<\" \"<<m2<<\"**\"<<mx<<\" \"<<my<<\" \"<<mix<<\" \"<<miy<<endl;\n    }\n    printf(\"%d\\n\",mav);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<cctype>\n#include<vector>\n#include<numeric>\n#include<algorithm>\n#include<bits/std++.h>\nusing namespace std;\n/**\nvector<int>ar(3);\nfor(auto&e:ar){\n    scanf(\"%d\",&e);\n        }\nsort(ar.begin(),ar.end())\nint sum=accumulate(ar.begin(),ar.end(),0);\n**/\n//memo kyuridenamida 1237852\nint main(){\n    double pai=3.141592653589;\n    int N,d;\n    cin >> N >> d;\n    vector< array<int,3> > star;\n    for(int i = 0 ; i < N ; i++){\n        int x,y,b;\n        cin >> x >> y >> b;\n        star.push_back(array<int,3>{b,x,y});\n    }   \n    sort(star.begin(),star.end());\n    int l = 0 , r = 0;\n    multiset<int> X,Y;\n    long long ans = 0;\n    while( r != N){\n        X.insert(star[r][1]);\n        Y.insert(star[r][2]);\n        r++;\n        while( star[r-1][0] - star[l][0] > d ){\n            X.erase(X.find(star[l][1]));\n            Y.erase(Y.find(star[l][2]));\n            l++;\n        }\n        ans = max((long long)((*X.rbegin())-(*X.begin())) * ((*Y.rbegin())-(*Y.begin())),ans);\n        //cout << (*X.rbegin())-(*X.begin()) << \" \" << ((*Y.rbegin())-(*Y.begin())) << \"|\" << star[r-1][0] - star[l][0] << endl;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nstruct SegTree{\n    static const int N=1<<18;\n    int *dat;\n\n    SegTree(){\n        dat=new int[N*2-1];\n        for(int i=0;i<N*2-1;i++)dat[i]=INT_MAX;\n    }\n\n    void update(int k,int x){\n        k+=N-1;\n        dat[k]=min(dat[k],x);\n        while(k){\n            k=(k-1)/2;\n            dat[k]=min(dat[k],x);\n        }\n    }\n\n    int getMin(int a,int b,int k=0,int l=0,int r=N){\n        if(r<=a||b<=l)return INT_MAX;\n        if(r-l<=1)return dat[k];\n        int m=(l+r)/2;\n        int vl=getMin(a,b,k*2+1,l,m);\n        int vr=getMin(a,b,k*2+2,m,r);\n        return min(vl,vr);\n    }\n};\ntypedef pair<int,int>P;\ntypedef pair<int,P>PP;\n#define fi first\n#define se second\ntypedef long long ll;\n\nint N,D;\nPP Stars[200000];\nSegTree minx,miny,maxx,maxy;\n\nint main(){\n    scanf(\"%d%d\",&N,&D);\n    for(int i=0;i<N;i++){\n        int x,y,b;\n        scanf(\"%d%d%d\",&x,&y,&b);\n        Stars[i]=PP(b,P(x,y));\n    }\n\n    sort(Stars,Stars+N);\n\n    for(int i=0;i<N;i++){\n        minx.update(i,Stars[i].se.fi);\n        miny.update(i,Stars[i].se.se);\n        maxx.update(i,-Stars[i].se.fi);\n        maxy.update(i,-Stars[i].se.se);\n    }\n\n    ll ans=0;\n\n    for(int i=0;i<N;i++){\n        int j=upper_bound(Stars,Stars+N,PP(Stars[i].fi+D,P(INT_MAX,INT_MAX)))-Stars;\n        ll w=-maxx.getMin(i,j)-minx.getMin(i,j);\n        ll h=-maxy.getMin(i,j)-miny.getMin(i,j);\n        ans=max(ans,h*w);\n    }\n\n    cout<<ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int LL\ntypedef long long LL;\nconst int INF = 2000000;\n\nstruct DATA {\n\tint minx, miny, maxx, maxy;\n};\n\nstruct STAR {\n\tint x, y, b;\n\tbool operator < (const STAR &t) const {\n\t\treturn b < t.b;\n\t}\n};\n\nint n, d;\nSTAR star[1 << 18];\n\nint N;\nDATA data[1 << 19];\n\n\nvoid init(int n)\n{\n\tfor (N = 1; N < n; N <<= 1);\n\tfill(data, data + N * 2 - 1, (DATA){INF, INF, -INF, -INF});\n}\n\nvoid update(int i, STAR s)\n{\n\ti += N - 1;\n\tdata[i].minx = min(data[i].minx, s.x);\n\tdata[i].miny = min(data[i].miny, s.y);\n\tdata[i].maxx = max(data[i].maxx, s.x);\n\tdata[i].maxy = max(data[i].maxy, s.y);\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tdata[i].minx = min(data[i].minx, s.x);\n\t\tdata[i].miny = min(data[i].miny, s.y);\n\t\tdata[i].maxx = max(data[i].maxx, s.x);\n\t\tdata[i].maxy = max(data[i].maxy, s.y);\n\t}\n}\n\nDATA query(int a, int b, int k, int l, int r)\n{\n\t//printf(\"%d %d %d %d %d\\n\", a, b, k, l, r);\n\tif (r <= a || b <= l) return (DATA){INF, INF, -INF, -INF};\n\tif (a <= l && r <= b) return data[k];\n\tDATA vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tDATA vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn (DATA){min(vl.minx, vr.minx), min(vl.miny, vr.miny), max(vl.maxx, vr.maxx), max(vl.maxy, vr.maxy)};\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tinit(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d %d\", &star[i].x, &star[i].y, &star[i].b);\n\t\t--star[i].x; --star[i].y;\n\t}\n\tstar[n].b = INF;\n\t\n\tsort(star, star + n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tupdate(i, star[i]);\n\t}\n\t\n\t//printf(\"%lld\\n\", (LL)INF * INF);\n\t\n\tLL res = 0;\n\tfor (int l = 0; l < n; ){\n\t\tint r = l;\n\t\twhile (star[r].b - star[l].b <= d) r++;\n\t\t\n\t\tDATA q = query(l, r, 0, 0, N);\n\t\tLL t = (LL)(q.maxx - q.minx) * (q.maxy - q.miny);\n\t\tres = max(res, t);\n\t\t\n\t\tl++;\n\t\twhile (star[l + 1].b == star[l].b) l++;\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define in ,\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct Star {\n  ll x, y, d;\n};\n\nll minX[400000 * 2 - 1], maxX[400000 * 2 - 1],\nminY[400000 * 2 - 1], maxY[400000 * 2 - 1];\nll n, nn = 1;\n\nvoid update(ll k, ll a, ll c[]) {\n  k += nn - 1;\n  c[k] = a;\n\n  while(k > 0) {\n    k = (k - 1) / 2;\n    c[k] = min(c[k * 2 + 1], c[k * 2 + 2]);\n  }\n}\n\nll query(ll a, ll b, ll k, ll l, ll r, ll c[]) {\n  if(r <= a || b <= l) return INT_MAX;\n  if(a <= l && r <= b) return c[k];\n\n  ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2, c);\n  ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r, c);\n\n  return min(vl, vr);\n}\n\nbool asc(Star &l, Star &r) {\n  return l.d < r.d;\n}\n\nint main() {\n  ll d, ans = 0;\n  cin >> n >> d;\n  vector<Star> v(n);\n\n  while(nn < n) nn *= 2;\n\n  rep(i, 0, nn * 2 - 1) {\n    minX[i] = INT_MAX;\n    minY[i] = INT_MAX;\n    maxX[i] = INT_MAX;\n    minX[i] = INT_MAX;\n  }\n\n  rep(i, 0, n) cin >> v[i].x >> v[i].y >> v[i].d;\n\n  sort(v.begin(), v.end(), asc);\n\n  rep(i, 0, n) {\n    update(i, v[i].x * -1, maxX);\n    update(i, v[i].x, minX);\n    update(i, v[i].y * -1, maxY);\n    update(i, v[i].y, minY);\n  }\n\n  // rep(i, 0, n) cout << v[i].x << \" \" << v[i].y << \" \" << v[i].d << endl;;\n\n  // rep(i, 0, nn * 2 - 1) cout << minX[i] << endl;\n  ll ld = v[0].d, lp = 0;\n  rep(i, 1, n) {\n    if(v[i].d - ld > d) {\n      rep(j, lp, i + 1) {\n        if(v[i].d - v[j].d <= d) {\n          lp = j;\n          ld = v[lp].d;\n          break;\n        }\n      }\n    }\n    ll hx = query(lp, i + 1, 0, 0, nn, maxX) * -1;\n    ll lx = query(lp, i + 1, 0, 0, nn, minX);\n    ll hy = query(lp, i + 1, 0, 0, nn, maxY) * -1;\n    ll ly = query(lp, i + 1, 0, 0, nn, minY);\n    if(lp != i) ans = max(ans, ((hx - lx) * (ll)(hy - ly)));\n    // cout << lp << \" \" << i << endl;\n    // cout << hx << \" \" << lx << \" \" << hy << \" \" << ly << endl;\n    // cout << ans << endl;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct SegTree { // ??????min,max\n\tint n;\n\tvector<int> Max;\n\tvector<int> Min;\n\n\tvoid init(int n_)\n\t{\n\t\tn = 1;\n\t\twhile (n < n_) n *= 2;\n\n\t\tMax.resize(2 * n);\n\t\tMin.resize(2 * n);\n\n\t\tfor (int i = 0; i < 2 * n - 1; ++i) {\n\t\t\tMax[i] = -inf;\n\t\t\tMin[i] = inf;\n\t\t}\n\t}\n\n\tvoid min_update(int idx, int val)\n\t{\n\t\tidx += n - 1;\n\t\tMin[idx] = val;\n\n\t\twhile (idx > 0) {\n\t\t\tidx = (idx - 1) / 2;\n\t\t\tMin[idx] = min(Min[idx * 2 + 1], Min[idx * 2 + 2]);\n\t\t}\n\t}\n\n\tvoid max_update(int idx, int val)\n\t{\n\t\tidx += n - 1;\n\t\tMax[idx] = val;\n\n\t\twhile (idx > 0) {\n\t\t\tidx = (idx - 1) / 2;\n\t\t\tMax[idx] = max(Max[idx * 2 + 1], Max[idx * 2 + 2]);\n\t\t}\n\t}\n\n\tint get_min(int a, int b, int k = 0, int l = 0, int r = -1) // [a, b)???min\n\t{\n\t\tif (r == -1) r = n;\n\n\t\tif (r <= a || b <= l) return inf;\n\n\t\tif (a <= l && r <= b) return Min[k];\n\n\t\tint vl = get_min(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = get_min(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn min(vl, vr);\n\t}\n\n\tint get_max(int a, int b, int k = 0, int l = 0, int r = -1) // [a, b)???max\n\t{\n\t\tif (r == -1) r = n;\n\n\t\tif (r <= a || b <= l) return -inf;\n\n\t\tif (a <= l && r <= b) return Max[k];\n\n\t\tint vl = get_max(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = get_max(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn max(vl, vr);\n\t}\n};\n\nint X[200020], Y[200020];\n\nsigned main()\n{\n\tint N, d; scanf(\"%d%d\", &N, &d);\n\n\tSegTree x_seg, y_seg;\n\n\tx_seg.init(N), y_seg.init(N);\n\n\tvpii hoge;\n\n\trep(i, N) {\n\t\tint x, y, b; scanf(\"%d%d%d\", &x, &y, &b);\n\t\tX[i] = x, Y[i] = y;\n\n\t\thoge.PB(pii(b, i));\n\t}\n\n\tsort(all(hoge));\n\n\trep(i, N) {\n\t\tx_seg.min_update(i, X[hoge[i].scd]);\n\t\tx_seg.max_update(i, X[hoge[i].scd]);\n\n\t\ty_seg.min_update(i, Y[hoge[i].scd]);\n\t\ty_seg.max_update(i, Y[hoge[i].scd]);\n\t}\n\n\tll ans = -inf;\n\n\trep(i, N) {\n\t\tif (i > 0 && hoge[i].fst == hoge[i - 1].fst) continue;\n\n\t\tint b = hoge[i].fst;\n\n\t\tint idx = upper_bound(all(hoge), pii(b + d, inf)) - hoge.begin();\n\n\t\tint min_x = x_seg.get_min(i, idx);\n\t\tint max_x = x_seg.get_max(i, idx);\n\n\t\tint min_y = y_seg.get_min(i, idx);\n\t\tint max_y = y_seg.get_max(i, idx);\n\n\t\tans = max(ans, 1ll * (max_x - min_x) * (max_y - min_y));\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<unordered_set>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<algorithm>\n#define int long long\nusing namespace std;\n\nstruct star {\n\tint cost, x, y;\n};\nbool operator <(const star &a,const  star &b) {\n\treturn a.cost <= b.cost;\n}\nstar A[300000];\nmap<int, int>X;\nmap<int, int>Y;\nsigned main(){\n\tint a, b; scanf(\"%lld%lld\", &a, &b);\n\tfor (int c = 0; c < a; c++) {\n\t\tint d, e, f; scanf(\"%lld%lld%lld\", &d, &e, &f);\n\t\tA[c] = { f,d,e };\n\t}\n\tsort(A, A + a);\n\tint MAX = 0;\n\tfor (int s = 0, g = 0; g < a; g++) {\n\t\tX[A[g].x]++;\n\t\tY[A[g].y]++;\n\t\twhile (s < g&&A[s].cost + b < A[g].cost) {\n\t\t\tX[A[s].x]--;\n\t\t\tY[A[s].y]--;\n\t\t\tif (X[A[s].x] == 0) {\n\t\t\t\tX.erase(A[s].x);\n\t\t\t}\n\t\t\tif (Y[A[s].y] == 0) {\n\t\t\t\tY.erase(A[s].y);\n\t\t\t}\n\t\t\ts++;\n\t\t}\n\t\tint n = X.rbegin()->first - X.begin()->first;\n\t\tint m = Y.rbegin()->first - Y.begin()->first;\n\t\tMAX = max(MAX, n*m);\n\t}\n\tprintf(\"%lld\\n\", MAX);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define in ,\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct Star {\n  int x, y, d;\n};\n\nint minX[200001 * 2 - 1] = {}, maxX[200001 * 2 - 1] = {},\nminY[200001 * 2 - 1] = {}, maxY[200001 * 2 - 1] = {};\nint n, nn = 1;\n\nvoid update(int k, int a, int c[]) {\n  k += nn - 1;\n  c[k] = a;\n\n  while(k > 0) {\n    k = (k - 1) / 2;\n    c[k] = min(c[k * 2 + 1], c[k * 2 + 2]);\n  }\n}\n\nint query(int a, int b, int k, int l, int r, int c[]) {\n  if(r <= a || b <= l) return INT_MAX;\n  if(a <= l && r <= b) return c[k];\n\n  int vl = query(a, b, k * 2 + 1, l, (l + r) / 2, c);\n  int vr = query(a, b, k * 2 + 2, (l + r) / 2, r, c);\n\n  return min(vl, vr);\n}\n\nbool asc(Star &l, Star &r) {\n  return l.d < r.d;\n}\n\nint main() {\n  ll d, ans = 0;\n  cin >> n >> d;\n  vector<Star> v(n);\n\n  while(nn < n) nn *= 2;\n\n  rep(i, 0, nn * 2 - 1) {\n    minX[i] = INT_MAX;\n    minY[i] = INT_MAX;\n    maxX[i] = INT_MAX;\n    minX[i] = INT_MAX;\n  }\n\n  rep(i, 0, n) cin >> v[i].x >> v[i].y >> v[i].d;\n\n  sort(v.begin(), v.end(), asc);\n  rep(i, 0, n) {\n    update(i, v[i].x * -1, maxX);\n    update(i, v[i].x, minX);\n    update(i, v[i].y * -1, maxY);\n    update(i, v[i].y, minY);\n  }\n\n  // rep(i, 0, n) cout << v[i].x << \" \" << v[i].y << \" \" << v[i].d << endl;;\n\n  // rep(i, 0, nn * 2 - 1) cout << minX[i] << endl;\n\n  int ld = v[0].d, lp = 0;\n  rep(i, 1, n) {\n    if(v[i].d - ld > d) {\n      rep(j, lp + 1, i + 1) {\n        if(v[i].d - v[j].d <= d) {\n          lp = j;\n          ld = v[lp].d;\n          break;\n        }\n      }\n    }\n    int hx = query(lp, i + 1, 0, 0, nn, maxX) * -1;\n    int lx = query(lp, i + 1, 0, 0, nn, minX);\n    int hy = query(lp, i + 1, 0, 0, nn, maxY) * -1;\n    int ly = query(lp, i + 1, 0, 0, nn, minY);\n    if(lp != i) ans = max(ans, ((hx - lx) * (ll)(hy - ly)));\n    // cout << lp << \" \" << i << endl;\n    // cout << hx << \" \" << lx << \" \" << hy << \" \" << ly << endl;\n    // cout << ans << endl;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct SegTree { // ??????min,max\n\tint n;\n\tvector<int> Max;\n\tvector<int> Min;\n\n\tvoid init(int n_)\n\t{\n\t\tn = 1;\n\t\twhile (n < n_) n *= 2;\n\n\t\tMax.resize(2 * n);\n\t\tMin.resize(2 * n);\n\n\t\tfor (int i = 0; i < 2 * n - 1; ++i) {\n\t\t\tMax[i] = -inf;\n\t\t\tMin[i] = inf;\n\t\t}\n\t}\n\n\tvoid update(int idx, int val)\n\t{\n\t\tidx += n - 1;\n\t\tMin[idx] = val;\n\t\tMax[idx] = val;\n\n\t\twhile (idx > 0) {\n\t\t\tidx = (idx - 1) / 2;\n\t\t\tMin[idx] = min(Min[idx * 2 + 1], Min[idx * 2 + 2]);\n\t\t\tMax[idx] = max(Max[idx * 2 + 1], Max[idx * 2 + 2]);\n\t\t}\n\t}\n\n\tint get_min(int a, int b, int k = 0, int l = 0, int r = -1) // [a, b)???min\n\t{\n\t\tif (r == -1) r = n;\n\t\tif (r <= a || b <= l) return inf;\n\t\tif (a <= l && r <= b) return Min[k];\n\n\t\tint vl = get_min(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = get_min(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn min(vl, vr);\n\t}\n\n\tint get_max(int a, int b, int k = 0, int l = 0, int r = -1) // [a, b)???max\n\t{\n\t\tif (r == -1) r = n;\n\t\tif (r <= a || b <= l) return -inf;\n\t\tif (a <= l && r <= b) return Max[k];\n\n\t\tint vl = get_max(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = get_max(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn max(vl, vr);\n\t}\n};\n\nint X[200020], Y[200020];\n\nsigned main()\n{\n\tint N, d; scanf(\"%d%d\", &N, &d);\n\n\tSegTree x_seg, y_seg;\n\n\tx_seg.init(N), y_seg.init(N);\n\n\tvpii hoge;\n\n\trep(i, N) {\n\t\tint x, y, b; scanf(\"%d%d%d\", &x, &y, &b);\n\t\tX[i] = x, Y[i] = y;\n\n\t\thoge.PB(pii(b, i));\n\t}\n\n\tsort(all(hoge));\n\n\trep(i, N) {\n\t\tx_seg.update(i, X[hoge[i].scd]);\n\t\ty_seg.update(i, Y[hoge[i].scd]);\n\t}\n\n\tll ans = -inf;\n\n\trep(i, N) {\n\t\tif (i > 0 && hoge[i].fst == hoge[i - 1].fst) continue;\n\n\t\tint b = hoge[i].fst;\n\n\t\tint idx = upper_bound(all(hoge), pii(b + d, inf)) - hoge.begin();\n\n\t\tint min_x = x_seg.get_min(i, idx);\n\t\tint max_x = x_seg.get_max(i, idx);\n\n\t\tint min_y = y_seg.get_min(i, idx);\n\t\tint max_y = y_seg.get_max(i, idx);\n\n\t\tans = max(ans, 1ll * (max_x - min_x) * (max_y - min_y));\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nusing lint = long long;\n\nconstexpr int INF = (1 << 30) - 1;\n\nstruct star{\n    int x, y, b;\n\n    bool operator<(const star& rhs) const {\n        return b < rhs.b;\n    }\n};\n\ntemplate<typename T>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int n, d;\n    cin >> n >> d;\n\n    vector<star> v;\n    for(int i = 0 ; i < n ; ++i){\n        int x, y, b;\n        cin >> x >> y >> b;\n        v.push_back({x, y, b});\n    }\n\n    sort(v.begin(), v.end());\n\n    lint ans = 0;\n    int l = 0;\n    int r = 0;\n    multiset<int> stx;\n    multiset<int> sty;\n    while(r < n){\n        if(v[r].b - v[l].b <= d){\n            stx.insert(v[r].x);\n            sty.insert(v[r].y);\n            ++r;\n        }else{\n            chmax(ans, (lint)(*stx.rbegin() - *stx.begin()) * (*sty.rbegin() - *sty.begin()));\n            auto itx = stx.lower_bound(v[l].x);\n            auto ity = sty.lower_bound(v[l].y);\n            stx.erase(itx);\n            sty.erase(ity);\n            ++l;\n        }\n    }\n    chmax(ans, (lint)(*stx.rbegin() - *stx.begin()) * (*sty.rbegin() - *sty.begin()));\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, a) for(int64 i = 0; i < (a);i++)\n#define FOR(i, a, b) for(int64 i = (a); i < (b); i++)\n#define INF (int64)1e9\n#define INF_LL (int64)1e18\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int32_t;\nusing int64 = int64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\ntemplate<typename A, typename B> inline void chmin(A &a, B b) { if (a > b) a = b;}\ntemplate<typename A, typename B> inline void chmax(A &a, B b) { if (a < b) a = b;}\n\nint main(void) {\n  int64 N, d;\n  cin >> N >> d;\n  using T= tuple<int64, int64, int64>;\n  vector<T> star;\n  star.reserve(N);\n  REP(i, N) {\n    int64 x, y, b;\n    cin >> x >> y >> b;\n    star.emplace_back(b, x, y);\n  }\n  sort(all(star));\n\n  int64 r = 0;\n  int64 res = 0;\n  multiset<int64> x, y;\n  REP(l, N) {\n    while (r < N && abs(get<0>(star[r])-get<0>(star[l])) <= d) {\n      x.insert(get<1>(star[r]));\n      y.insert(get<2>(star[r]));\n      r++;\n    }\n    chmax(res, (*y.rbegin()-*y.begin()) * (*x.rbegin()-*x.begin()));\n    x.erase(x.find(get<1>(star[l])));\n    y.erase(y.find(get<2>(star[l])));\n  }\n  cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <numeric>\n#include <bitset>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n#define FOR(i,a,b) for (ll i = (a); i < (b); i++)\n#define REP(i,n)   FOR(i,0,n)\ntypedef pair< ll,ll > cp2;\ntypedef pair<ll,cp2 > cp3;\n#define fi first\n#define se second\n#define sec se.fi\n#define thr se.se\nconst ll mod = 1000000007;\n//              123456789\n\ntemplate<int SZ>\nclass SegMax {\n\tpublic:\n\t\tcp2 seg[2*SZ];\n\t\t\n\t\tSegMax(){\n\t\t\tfill( seg, seg+2*SZ, cp2( 0, 0 ) );\n\t\t}\n\t\t\n\t\tvoid ffill(){\n\t\t\tfill( seg, seg+2*SZ, cp2( -mod, -mod ) );\n\t\t}\n\t\t\n\t\tvoid upd( int p, cp2 value ){\n\t\t\tfor( seg[p += SZ] = value; p > 1; p >>= 1 ) seg[p>>1] = max( seg[p], seg[p^1] );\n\t\t}\n\t\t\n\t\tcp2 query( int l, int r ){\n\t\t\tcp2 res = cp2( -mod, -mod );\n\t\t\tfor( l += SZ, r += SZ; l < r; l >>= 1, r >>= 1 ){\n\t\t\t\tif( l&1 ) res = max( res, seg[l++] );\n\t\t\t\tif( r&1 ) res = max( res, seg[--r] );\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n};\n\n\n\n\nint N;\nint d;\nint x, y, b;\ncp3 P[212345];\n\nSegMax< 1<<18 >Xmin;\nSegMax< 1<<18 >Ymin;\nSegMax< 1<<18 >Xmax;\nSegMax< 1<<18 >Ymax;\n\nint B[212345];\n\nint main(){\n\t\n\tcin>>N>>d;\n\t\n\t\n\tXmin.ffill();\n\tYmin.ffill();\n\t\n\tREP( i, N ){\n\t\tscanf(\"%d %d %d\", &x, &y, &b );\t\n\t\tP[i] = cp3( b, cp2( x, y ) );\n\t\tB[i] = b;\n\t}\n\t\n\t\n\tsort( P, P+N );\n\tsort( B, B+N );\n\t\n\tREP( i, N ){\n\t\tx = P[i].thr;\n\t\ty = P[i].sec;\n\t\tXmin.upd( i, cp2( -x, 0 ) );\n\t\tXmax.upd( i, cp2(  x, 0 ) );\n\t\tYmin.upd( i, cp2( -y, 0 ) );\n\t\tYmax.upd( i, cp2( y , 0 ) );\n\t}\n\t\n\tint key;\n\tll ans = 0;\n\t\n\t\n\t\n\tREP( i, N ){\n\t\tkey = B[i];\n\t\tx = lower_bound( B, B+N, key )-B;\n\t\ty = lower_bound( B, B+N, key+d+1 )-B;\n\t\t//cout<<x<<\"-\"<<y<<endl;\n\t\tcp2 t1 = Xmin.query( x, y );\n\t\tcp2 t2 = Xmax.query( x, y );\n\t\tcp2 t3 = Ymin.query( x, y );\n\t\tcp2 t4 = Ymax.query( x, y );\n\t\t\n\t\t//printf(\"%lld %lld %lld %lld\\n\", t1.fi, t2.fi, t3.fi, t4.fi);\n\t\t\n\t\tll num = (t1.fi+t2.fi)*(t4.fi+t3.fi);\n\t\tans = max( num, ans );\n\t\t//cout<<num<<endl;\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n\nusing namespace std;\n\ntemplate<typename T>\nclass SegmentTree\n{\nprivate:\n\tusing F = function<T(T,T)>;\n\tvector<T> btree;\n\tF f, _update;\n\tT e;\n\tint n;\npublic:\n\tSegmentTree(const vector<T> &v, F f, T e, F g=[](T a,T b){return b;})\n\t\t: f(f),e(e),_update(g)\n\t{\n\t\tint _n = v.size();\n\t\tinit(_n);\n\t\tfor(int i=0; i<_n; i++) btree[i+n-1] = v[i];\n\t\tbuild();\n\t}\n\tvoid init(int _n){\n\t\tn = 1;\n\t\twhile(_n>n) n<<=1;\n\t\tbtree.resize(2*n-1, e);\n\t}\n\tvoid build(){\n\t\tfor(int i=n-2; i>=0; i--) btree[i] = f(btree[2*i+1], btree[2*i+2]);\n\t}\n\tvoid update(int k, T a){\n\t\tk += n-1;\n\t\tbtree[k] = _update(btree[k], a);\n\t\twhile(k>0){\n\t\t\t--k>>=1;\n\t\t\tbtree[k] = f(btree[2*k+1], btree[2*k+2]);\n\t\t}\n\t}\n\tT query(int a, int b){\n\t\tT L=e, R=e;\n\t\ta+=n-1; b+=n-1;\n\t\twhile(a<b){\n\t\t\tif (!(a&1)) L=f(L, btree[a++]);\n\t\t\tif (!(b&1)) R=f(btree[--b], R);\n\t\t\ta>>=1; b>>=1;\n\t\t}\n\t\treturn f(L,R);\n\t}\n\tT operator[](int k){return btree[k+n-1];}\n};\n\nconst int INF = 2000001;\n\nint main()\n{\n\tint n, D;\n\tcin >> n >> D;\n\tvector<int> x(n),y(n),d(n);\n\tfor(int i=0;i<n;i++)\n\t\tcin >> x[i] >> y[i] >> d[i];\n\t\n\tset<ll> Set;\n\tfor(int i=0; i<n; i++){\n\t\tSet.insert(d[i]);\n\t}\n\tmap<ll,int> Map;\n\tmap<int,ll> Rmap;\n\tint idx=0;\n\tfor(auto e:Set){\n\t\tMap[e] = idx;\n\t\tRmap[idx++] = e;\n\t}\n\tint sz = Set.size();\n\tvector<int> xmax(sz, 0), ymax(sz, 0);\n\tvector<int> xmin(sz, INF), ymin(sz, INF);\n\tfor(int i=0; i<n; i++){\n\t\tint ad = Map[d[i]];\n\t\txmax[ad] = max(xmax[ad], x[i]);\n\t\tymax[ad] = max(ymax[ad], y[i]);\n\t\txmin[ad] = min(xmin[ad], x[i]);\n\t\tymin[ad] = min(ymin[ad], y[i]);\n\t}\n\tfor(int i=0;i<sz;i++)\n\t{\n\t\t//cout << xmax[i] << endl;\n\t\t//cout << xmin[i] << endl;\n\t\t//cout << ymin[i] << endl;\n\t}\n\n\tSegmentTree<int> segxmax(xmax,[](int x,int y){return max(x,y);},0);\n\tSegmentTree<int> segymax(ymax,[](int x,int y){return max(x,y);},0);\n\tSegmentTree<int> segxmin(xmin,[](int x,int y){return min(x,y);},INF);\n\tSegmentTree<int> segymin(ymin,[](int x,int y){return min(x,y);},INF);\n\n\tint head=0,tail=0;\n\tlong long ans=0;\n\twhile(tail<sz)\n\t{\n\t\tint x=segxmax.query(head,tail+1)-segxmin.query(head,tail+1);\n\t\tint y=segymax.query(head,tail+1)-segymin.query(head,tail+1);\n\t\tans = max(ans, (long long)x*y);\n\t\t//cout << x << \" \" << y << endl;\n\t\ttail++;\n\t\twhile(Rmap[tail]-Rmap[head]>D)head++;\n\t}\n\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <list>\n  \nusing namespace std;\ntypedef long long ll;\n  \n#define mod 1000000007\n#define INF 1000000000\n#define SIZE 100000\n \nstruct NODE{\n  int min_d;\n  int max_d;\n  int min_x;\n  int min_y;\n  int max_x;\n  int max_y;\n \n  NODE(){\n    min_d = INF;\n    max_d = 0;\n    min_x = INF;\n    max_x = 0;\n    min_y = INF;\n    max_y = 0;\n  }\n   \n  NODE(int a,int b,int c,int d,int e,int f){\n    min_d = a;\n    max_d = b;\n    min_x = c;\n    max_x = d;\n    min_y = e;\n    max_y = f;\n  }\n \n  NODE operator+ (const NODE &B) const{\n    int a = min(min_d,B.min_d);\n    int b = max(max_d,B.max_d);\n    int c = min(min_x,B.min_x);\n    int d = max(max_x,B.max_x);\n    int e = min(min_y,B.min_y);\n    int f = max(max_y,B.max_y);\n \n    return NODE(a,b,c,d,e,f);\n  }\n};\n \nNODE data[1 << 7/*19*/];\nint segn2;\n \n \nvoid set(int k,pair<int,pair<int,int> > p){\n  int d = p.first;\n  int x = p.second.first;\n  int y = p.second.second;\n   \n  data[k+segn2-1] = NODE(d,d,x,x,y,y);\n}\n \nvoid init(){\n  for(int i = segn2-2;i>=0;i--){\n    data[i] = data[i*2+1] + data[i*2+2];\n  }\n}\n \nNODE query(int a,int b,int k=0){\n  if(b<a) return NODE();\n  if(data[k].max_d < data[k].min_d) return NODE();\n  if(data[k].max_d < a || b < data[k].min_d) return NODE();\n \n  if(a<= data[k].min_d && data[k].max_d <= b) return data[k];\n \n  return query(a,b,k*2+1) + query(a,b,k*2+2);\n}\n \nint main(){\n  int n,d;\n  int x,y,b;\n  vector<pair<int,pair<int,int> > > in;\n \n  scanf(\"%d%d\",&n,&d);\n \n  segn2 = 1;\n  while(segn2<n) segn2*=2;\n   \n  for(int i=0;i<n;i++){\n    scanf(\"%d%d%d\",&x,&y,&b);\n    in.push_back(make_pair(b,make_pair(x,y)));\n  }\n \n  sort(in.begin(),in.end());\n \n  for(int i=0;i<n;i++){\n    set(i,in[i]);\n  }\n \n  init();\n   \n  ll ans = 0;\n   \n  for(int i=0;i<n;i++){\n    NODE a = query(in[i].first,in[i].first+d);\n    if(a.max_d < a.min_d) continue;\n    ll calc = (ll)(a.max_x - a.min_x)*(a.max_y - a.min_y);\n    ans = max(ans,calc);\n  }\n \n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pi;\n#define F first\n#define S second\nconst int N=2e5+10;\nstruct star{\n    pi pos;\n    int light;\n    void in(){\n        scanf(\"%d%d%d\",&pos.F,&pos.S,&light);\n        return ;\n    }\n};\nstruct cmp{\n    bool operator()(const star &a,const star &b){\n        return a.light>b.light;\n    }\n};\nint min(int a,int b){return a>b?b:a;}\nlong long int max(long long int a,long long int b){return a>b?a:b;}\nint main(){\n    int n,d,low=0;\n    long long int ans=0;\n    star temp;\n    priority_queue<star,vector<star>,cmp> pq;\n    priority_queue<pi,vector<pi>,greater<pi>>l,b;\n    priority_queue<pi> u,r;\n    scanf(\"%d%d\",&n,&d);\n    for(int i=0;i<n;i++){\n        temp.in();\n        pq.push(temp);\n        low=min(low,temp.light);\n    }\n    low+=d;\n    while(!pq.empty()){\n        if(!pq.empty())low=pq.top().light;\n        while(pq.top().light<=low){\n            temp=pq.top();\n            pq.pop();\n            u.push({temp.pos.F,temp.light});\n            b.push({temp.pos.F,temp.light});\n            l.push({temp.pos.S,temp.light});\n            r.push({temp.pos.S,temp.light});\n            if(pq.empty())break;\n        }\n        while(!u.empty()){\n            if(u.top().S<low-d)u.pop();\n            else break;\n        }\n        \n        if(u.empty())continue;\n        while(!r.empty()){\n            if(r.top().S<low-d)r.pop();\n            else break;\n        }\n        if(r.empty())continue;\n        while(!l.empty()){\n            if(l.top().S<low-d)l.pop();\n            else break;\n        }\n        if(l.empty())continue;\n        while(!b.empty()){\n            if(b.top().S<low-d)b.pop();\n            else break;\n        }\n        if(b.empty())continue;\n        ans=max(ans,(long long int)(u.top().F-b.top().F)*(r.top().F-l.top().F));\n        \n    }\n    printf(\"%lld\\n\",ans);\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\ntypedef long long ll;\ntypedef std::tuple<int,int> T;\n\nconst int INF = 1001001001, MAX_N = 200000;\n\nclass SegmentTree{\npublic:\n    SegmentTree(){}\n    void init(const std::vector<T>& v, const int n){\n        size = 1;\n        while(size < n){\n            size *= 2;\n        }\n        \n        REP(i, size*2-1){\n            seg1[i] = INF;\n            seg2[i] = -INF;\n        }\n        REP(i, v.size()){\n            update(i, std::get<1>(v[i]));\n        }\n    }\n    void update(int k, int v){\n        k += size - 1;\n        seg1[k] = v;\n        seg2[k] = v;\n        \n        while(k > 0){\n            k = (k-1) / 2;\n            seg1[k] = std::min(seg1[k*2+1], seg1[k*2+2]);\n            seg2[k] = std::max(seg2[k*2+1], seg2[k*2+2]);\n        }\n    }\n    int queryMin(int l, int r){\n        return _queryMin(l, r, 0, 0, size);\n    }\n    int queryMax(int l, int r){\n        return _queryMax(l, r, 0, 0, size);\n    }\nprivate:\n    int _queryMax(int a, int b, int k, int l, int r){\n        if(b <= l || r <= a){return -INF;}\n        if(a <= l && r <= b){return seg2[k];}\n        return std::max(_queryMax(a, b, 2*k+1, l, (l+r)/2),\n                        _queryMax(a, b, 2*k+2, (l+r)/2, r));\n    }\n    int _queryMin(int a, int b, int k, int l, int r){\n        if(b <= l || r <= a){return INF;}\n        if(a <= l && r <= b){return seg1[k];}\n        return std::min(_queryMin(a, b, 2*k+1, l, (l+r)/2),\n                        _queryMin(a, b, 2*k+2, (l+r)/2, r));\n    }\n    int seg1[MAX_N*4], seg2[MAX_N*4], size;\n};\n\nint N, d;\nstd::vector<T> xs, ys;\nSegmentTree xt, yt;\n\nll f(const int b, const std::vector<T>& v, SegmentTree& t){\n    int lb = std::lower_bound(v.begin(), v.end(), std::make_tuple(b, -1)) - v.begin(),\n        ub = std::upper_bound(v.begin(), v.end(), std::make_tuple(b+d, INF)) - v.begin();\n    return t.queryMax(lb, ub) - t.queryMin(lb, ub);\n}\n\nint main(){\n    scanf(\"%d %d\", &N, &d);\n\n    for(int i=0;i<N;i++){\n        int x, y, b;\n        scanf(\"%d %d %d\", &x, &y, &b);\n\n        xs.push_back(std::make_tuple(b, x));\n        ys.push_back(std::make_tuple(b, y));\n    }\n\n    std::sort(xs.begin(), xs.end());\n    std::sort(ys.begin(), ys.end());\n\n    // for(const T& t : xs){\n    //     printf(\"%d, %d\\n\", std::get<0>(t), std::get<1>(t));\n    // }\n    // puts(std::string(45, '-').c_str());\n    // for(const T& t : ys){\n    //     printf(\"%d, %d\\n\", std::get<0>(t), std::get<1>(t));\n    // }\n    // puts(std::string(45, '-').c_str());\n    \n    xt.init(xs, N);\n    yt.init(ys, N);\n\n    ll res = 0ll;\n    for(int i=0,j=0;i<N;){\n        // printf(\"%d: %lld, %lld\\n\", std::get<0>(xs[i]), f(std::get<0>(xs[i]), xs, xt), f(std::get<0>(xs[i]), ys, yt));\n        res = std::max(res, f(std::get<0>(xs[i]), xs, xt) * f(std::get<0>(xs[i]), ys, yt));\n\n        while(j < N && std::get<0>(xs[j]) == std::get<0>(xs[i])){\n            j++;\n        }\n        i = j;\n    }\n    printf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<unordered_set>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<algorithm>\n#define int long long\nusing namespace std;\n\nstruct star {\n\tint cost, x, y;\n};\nbool operator <(star a, star b) {\n\treturn a.cost <= b.cost;\n}\nstar A[200000];\nsigned main(){\n\tint a, b; scanf(\"%lld%lld\", &a, &b);\n\tfor (int c = 0; c < a; c++) {\n\t\tint d, e, f; scanf(\"%lld%lld%lld\", &d, &e, &f);\n\t\tA[c] = { f,d,e };\n\t}\n\tsort(A, A + a);\n\tmap<int, int>X;\n\tmap<int, int>Y;\n\tint MAX = 0;\n\tfor (int s = 0, g = 0; g < a; g++) {\n\t\tX[A[g].x]++;\n\t\tY[A[g].y]++;\n\t\twhile (s < g&&A[s].cost + b < A[g].cost) {\n\t\t\tX[A[s].x]--;\n\t\t\tY[A[s].y]--;\n\t\t\tif (X[A[s].x] == 0) {\n\t\t\t\tX.erase(A[s].x);\n\t\t\t}\n\t\t\tif (Y[A[s].y] == 0) {\n\t\t\t\tY.erase(A[s].y);\n\t\t\t}\n\t\t\ts++;\n\t\t}\t\tint n = X.rbegin()->first - X.begin()->first;\n\t\tint m = Y.rbegin()->first - Y.begin()->first;\n\t\tMAX = max(MAX, n*m);\n\t}\n\tprintf(\"%lld\\n\", MAX);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define whole(f,x,...) ([&](decltype((x)) y) { return (f)(begin(y), end(y), ## __VA_ARGS__); })(x)\ntypedef long long ll;\nusing namespace std;\ntemplate <class T> void setmax(T & a, T const & b) { if (a < b) a = b; }\nstruct star_t { int x, y, b; };\nbool operator < (star_t p, star_t q) { return p.b < q.b; }\nint main() {\n    int n, d; scanf(\"%d%d\", &n, &d);\n    vector<star_t> s(n); repeat (i,n) scanf(\"%d%d%d\", &s[i].x, &s[i].y, &s[i].b);\n    whole(sort, s);\n    ll ans = 0;\n    map<int, int> x, y;\n    for (int i = 0, j = 0; j < n; ++ j) {\n        x[s[j].x] += 1;\n        y[s[j].y] += 1;\n        while (s[i].b + d < s[j].b) {\n            x[s[i].x] -= 1; if (not x[s[i].x]) x.erase(s[i].x);\n            y[s[i].y] -= 1; if (not y[s[i].y]) y.erase(s[i].y);\n            ++ i;\n        }\n        ll dx = x.rbegin()->first - x.begin()->first;\n        ll dy = y.rbegin()->first - y.begin()->first;\n        setmax(ans, dx * dy);\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int LL\ntypedef long long LL;\nconst int INF = 2002002002;\n\nstruct DATA {\n\tint minx, miny, maxx, maxy;\n};\n\nstruct STAR {\n\tint x, y, b;\n\tbool operator < (const STAR &t) const {\n\t\treturn b < t.b;\n\t}\n};\n\nint n, d;\nSTAR star[1 << 19];\n\nint N;\nDATA data[1 << 20];\n\n\nvoid init(int n)\n{\n\tfor (N = 1; N < n; N <<= 1);\n\tfill(data, data + (1 << 20), (DATA){INF, INF, -INF, -INF});\n}\n\nvoid update(int i, STAR s)\n{\n\ti += N - 1;\n\tdata[i] = (DATA){s.x, s.y, s.x, s.y};\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tdata[i].minx = min(data[i * 2 + 1].minx, data[i * 2 + 2].minx);\n\t\tdata[i].miny = min(data[i * 2 + 1].miny, data[i * 2 + 2].miny);\n\t\tdata[i].maxx = max(data[i * 2 + 1].maxx, data[i * 2 + 2].maxx);\n\t\tdata[i].maxy = max(data[i * 2 + 1].maxy, data[i * 2 + 2].maxy);\n\t}\n}\n\nDATA query(int a, int b, int k, int l, int r)\n{\n\t//printf(\"%d %d %d %d %d\\n\", a, b, k, l, r);\n\tif (r <= a || b <= l) return (DATA){INF, INF, -INF, -INF};\n\tif (a <= l && r <= b) return data[k];\n\tDATA vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tDATA vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn (DATA){min(vl.minx, vr.minx), min(vl.miny, vr.miny), max(vl.maxx, vr.maxx), max(vl.maxy, vr.maxy)};\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tinit(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d %d\", &star[i].x, &star[i].y, &star[i].b);\n\t\t//star[i].x; star[i].y;\n\t}\n\tfor (int i = n; i < 1 << 19; i++){\n\t\tstar[i].b = INF;\n\t}\n\t\n\tsort(star, star + n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tupdate(i, star[i]);\n\t}\n\t\n\t//printf(\"%lld\\n\", (LL)INF * INF);\n\t\n\tint pr = 0;\n\tLL res = 0;\n\tfor (int l = 0; star[l].b != INF; ){\n\t\tint r = pr;\n\t\twhile (star[r].b - star[l].b <= d) r++;\n\t\tif (r == pr){\n\t\t\tl++;\n\t\t\tcontinue;\n\t\t}\n\t\tpr = r;\n\t\t\n\t\tDATA q = query(l, r, 0, 0, N);\n\t\tLL t = (LL)(q.maxx - q.minx) * (q.maxy - q.miny);\n\t\tres = max(res, t);\n\t\t\n\t\tdo {\n\t\t\tl++;\n\t\t} while (star[l - 1].b == star[l].b);\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// -YDK- {{{\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <sstream>\n#include <numeric>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <tuple>\n#include <cmath>\n#include <queue>\n#include <regex>\n#include <set>\n#include <map>\nusing namespace std;\n#define eb emplace_back\n#define emp emplace\n#define fi first\n#define se second\n#define debug(...) fprintf(stderr, __VA_ARGS__ )\n#define outl(x) cout << (x) << '\\n'\n#define outl2(x,y) cout << (x) << ' ' << (y) << '\\n'\n#define endl '\\n'\n#define rep(i,n) for(int i=0; i<(int)(n); ++i)\n#define ALL(x) x.begin(), x.end()\n#define YES(f,y,n) cout << ((f)? (#y):(#n)) << '\\n'\n#define ODD(n) ((n)&1)\n#define EVEN(n) (!ODD(n))\ntemplate<class A, class B>inline bool chmax(A &a, B b){return b>a ? a=b,1 : 0;}\ntemplate<class A, class B>inline bool chmin(A &a, B b){return b<a ? a=b,1 : 0;}\ntemplate<class T>using MaxHeap = priority_queue< T, vector<T>, greater<T> >;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing byte= unsigned char;\ninline bool inside(int x, int y, int W, int H) { return x>=0 && y>=0 && x<W && y<H; }\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr long long LINF = 0x3f3f3f3f3f3f3f3fLL;\nconstexpr int dx[] = {1, 0, -1, 0};\nconstexpr int dy[] = {0, 1, 0, -1};\nstruct Point: public pii {\n    int &x = this->first,   &y = this->second;\n    Point(int x, int y): pii(x, y) {}\n};\n// }}}\nconstexpr int LIM = (int)2e5 + 5;\n\n#define int long long\n\nstruct Star\n{\n    int x, y, f;\n    explicit Star(int x, int y, int f): x(x), y(y), f(f) {}\n    explicit Star(): x(0), y(0), f(0) {}\n\n    bool operator < (const Star &s)const { return f < s.f; }\n    bool operator > (const Star &s)const { return f > s.f; }\n};\n\nstruct SegTree\n{\n    using Monoid = int(*)(int, int);\n\n    vector<int> dat;\n    int size;\n    const int SENTINEL; // 番兵, デフォルト値\n    Monoid f;\n\n    explicit SegTree(int n, int sntinel, const Monoid &monoid)\n        : SENTINEL(sntinel), f(monoid)\n    {\n        for(size=1; size<n; size*=2);\n        dat.assign(size*2 + 5, SENTINEL);\n    }\n\n    void update(int i, int v)\n    {\n        dat[i+=size-1] = v;\n        while (i > 0)  {\n            i = (i-1) / 2;\n            dat[i] = f(dat[i*2+1], dat[i*2+2]);\n        }\n    }\n\n    int query(int a, int b, int k, int l, int r)\n    {\n        if (r <= a || b <= l) return SENTINEL;\n        if (a <= l && r <= b) return dat[k];\n        int mid = (l + r) / 2;\n        return f( query(a,b, 2*k+1, l, mid), query(a,b, 2*k+2, mid, r) );\n    }\n\n    int query(int a, int b) { return query(a,b, 0, 0, size); }\n\n};\n\nint N, d;\nStar star[LIM];\n\nsigned main(void)\n{\n#ifndef DEBUG\n    cin.tie(nullptr), ios::sync_with_stdio(false);\n#endif\n\n    cin >> N >> d;\n    rep(i, N) {\n        int x, y, f;\n        cin >> x >> y >> f;\n        star[i] = Star(x, y, f);\n    }\n\n    sort(star, star+N);\n\n    SegTree minX(N, INF, [](int a, int b){return min(a,b);});\n    SegTree minY(N, INF, [](int a, int b){return min(a,b);});\n\n    SegTree maxX(N, 0, [](int a, int b){return max(a,b);});\n    SegTree maxY(N, 0, [](int a, int b){return max(a,b);});\n\n    rep(i, N) {\n        minX.update(i, star[i].x);\n        maxX.update(i, star[i].x);\n\n        minY.update(i, star[i].y);\n        maxY.update(i, star[i].y);\n    }\n\n#ifdef DEBUG\n    rep(i, N) {\n        printf(\"%d  (%2d, %2d)\\n\", star[i].f, star[i].x, star[i].y);\n    }\n#endif\n\n    ll ans = 0;\n\n    rep(i, N-1) {\n        int k = upper_bound(star, star+N, Star(0,0,star[i].f + d)) - star;\n\n        ll sx = minX.query(i, k);\n        ll sy = minY.query(i, k);\n        ll tx = maxX.query(i, k);\n        ll ty = maxY.query(i, k);\n\n        chmax(ans, (tx-sx) * (ty - sy));\n    }\n\n    outl(ans);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 30;\n\nconst int nmax=200010;\nint n,d;\nint x[nmax],y[nmax],b[nmax];\n\nint idx[nmax];\n\nint offset;\nint xdata[1<<19][2],ydata[1<<19][2];\n\nvoid init(int m){\n\toffset=1;\n\twhile(offset<m) offset*=2;\n\trep(i,2*offset-1){\n\t\txdata[i][0]=ydata[i][0]=inf;\n\t\txdata[i][1]=ydata[i][1]=-inf;\n\t}\n}\n\nvoid update(int data[1<<19][2],int k,int x){\n\tk+=offset-1;\n\tdata[k][0]=min(data[k][0],x);\n\tdata[k][1]=max(data[k][1],x);\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdata[k][0]=min(data[2*k+1][0],data[2*k+2][0]);\n\t\tdata[k][1]=max(data[2*k+1][1],data[2*k+2][1]);\n\t}\n\treturn;\n}\n\npii query(int data[1<<19][2],int a,int b,int k,int l,int r){\n\t// cerr << a << \" \" << b <<\" \" << k << \" \" << l << \" \" << r << endl;\n\tif(b<=l||r<=a)\n\t\treturn make_pair(inf,-inf);\n\tif(a<=l&&r<=b)\n\t\treturn make_pair(data[k][0],data[k][1]);\n\telse{\n\t\tpii vl=query(data,a,b,2*k+1,l,(l+r)/2);\n\t\tpii vr=query(data,a,b,2*k+2,(l+r)/2,r);\n\t\treturn\tmake_pair(min(vl.first,vr.first),max(vl.second,vr.second));\n\t}\n}\n\nint main(void){\n\tcin >> n >> d;\n\trep(i,n) cin >> x[i] >> y[i] >> b[i];\n\trep(i,n) idx[i]=b[i];\n\tsort(idx,idx+n);\n\tint m=unique(idx,idx+n)-idx;\n\tinit(m);\n\n\trep(i,n){\n\t\tint pos=lower_bound(idx,idx+m,b[i])-idx;\n\t\tupdate(xdata,pos,x[i]);\n\t\tupdate(ydata,pos,y[i]);\n\t}\n\n\n\tll ans=0LL;\n\trep(i,m){\n\t\tint j=upper_bound(idx,idx+m,idx[i]+d)-idx;\n\t\tpii xx=query(xdata,i,j,0,0,offset);\n\t\tpii yy=query(ydata,i,j,0,0,offset);\n\t\tans=max(ans,1LL*(xx.second-xx.first)*(yy.second-yy.first));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nclass Star\n{\npublic:\n\tlong long int x, y;\n\tint b;\n\tint boundary;\n};\nbool operator > (Star s1, Star s2)\n{\n\treturn s1.b > s2.b;\n}\nbool operator < (Star s1, Star s2)\n{\n\treturn s1.b < s2.b;\n}\n\nint n, d;\nStar star[200000];\nlong long int maxX = 0, maxY = 0, minX = 0, minY = 0;\nlong long int ans = 0;\n\nvoid calcBoundary()\n{\n\tint boundary = n - 1;\n\tstar[n - 1].boundary = boundary;\n\tfor (int i = n - 2; i >= 0; i--)\n\t{\n\t\tif (star[i + 1].b - star[i].b > d) boundary = i;\n\t\tstar[i].boundary = boundary;\n\t}\n\t\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tStar s;\n\t\ts.b = star[i].b + d;\n\t\tboundary = upper_bound(star + i, star + n, s) - star - 1;\n\t\tstar[i].boundary = min(star[i].boundary, boundary);\n\t}\n}\n\nvoid solve()\n{\n\tint boundary = -1;\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tif (star[i].boundary != boundary)\n\t\t{\n\t\t\tboundary = star[i].boundary;\n\t\t\tans = max((minX - maxX)*(minY - maxY), ans);\n\t\t\tmaxX = star[i].x;\n\t\t\tminX = star[i].x;\n\t\t\tmaxY = star[i].y;\n\t\t\tminY = star[i].y;\n\n\t\t\tfor (int j = i + 1; j <= star[i].boundary; j++)\n\t\t\t{\n\t\t\t\tmaxX = max(star[j].x, maxX);\n\t\t\t\tmaxY = max(star[j].y, maxY);\n\t\t\t\tminX = min(star[j].x, minX);\n\t\t\t\tminY = min(star[j].y, minY);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmaxX = max(star[i].x, maxX);\n\t\t\tmaxY = max(star[i].y, maxY);\n\t\t\tminX = min(star[i].x, minX);\n\t\t\tminY = min(star[i].y, minY);\n\t\t}\n\t}\n\n\tans = max((maxX - minX)*(maxY - minY), ans);\n}\n\nint main()\n{\n\tcin >> n >> d;\n\tfor (int i = 0; i < n; i++) cin >> star[i].x >> star[i].y >> star[i].b;\n\t\n\tsort(star, star + n);\n\tcalcBoundary();\n\tsolve();\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <vector>\n#include <utility>\n#include <numeric>\n#include <string>\n#include <set>\n#include <map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#define rep(i, a, n) for(int (i) = (int)(a);(i) < (int)(n);++(i))\n#define repe(i, a, n) for(int (i) = (int)(a);(i) <= (int)(n);++(i))\n#define repr(i, a, n) for(int (i) = (int)(a);(i) > (int)(n);--(i))\n#define reper(i, a, n) for(int (i) = (int)(a);(i) >= (int)(n);--(i))\n#define SIZE(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define RNG(x, n) &((x)[0]), &((x)[n])\n#define SUBIF(a, b, x) ((x) ? (b) : (a))\n#define YES cout << \"YES\" << endl\n#define NO cout << \"NO\" << endl\n#define Yes cout << \"Yes\" << endl\n#define No cout << \"No\" << endl\n#define yes cout << \"yes\" << endl;\n#define no cout << \"no\" << endl;\n#define pb push_back\n#define EPS (1e-20)\n#define INF 2147483647\n#define MOD 1000000007\nusing llint = long long;\nusing VI = std::vector<int>;\nusing PII = std::pair<int, int>;\nusing SI = std::set<int>;\nusing MII = std::map<int, int>;\nusing TIII = std::tuple<int, int, int>;\nusing namespace std;\n\n\nstruct SEG {\n\tint aryN;\n\tvector<PII> seg;\n\n\tSEG(){}\n\tSEG(const VI &v){\n\t\taryN = (int)pow(2, (int)ceil(log2(SIZE(v))));\n\t\tseg.resize(2*aryN-1, { -1, INF });\n\t\trep(i, 0, SIZE(v)) seg[i+aryN-1] = { v[i], v[i] };\n\t\treper(i, aryN-2, 0) seg[i].first = max(seg[2*i+1].first, seg[2*i+2].first), seg[i].second = min(seg[2*i+1].second, seg[2*i+2].second);\n\t}\n\tvoid update(int x, PII p){\n\t\tx += (aryN-1);\n\t\tseg[x] = p;\n\t\twhile(x > 0){\n\t\t\tx = (x-1)/2;\n\t\t\tseg[x].first = max(seg[2*x+1].first, seg[2*x+2].first);\n\t\t\tseg[x].second = min(seg[2*x+1].second, seg[2*x+2].second);\n\t\t}\n\t}\n\tint getMax(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = aryN;\n\t\tif(r <= a || b <= l) return -1;\n\t\tif(a <= l && r <= b) return seg[k].first;\n\t\tint vl = getMax(a, b, 2*k+1, l, (l+r)/2);\n\t\tint vr = getMax(a, b, 2*k+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n\tint getMin(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = aryN;\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <= b) return seg[k].second;\n\t\tint vl = getMin(a, b, 2*k+1, l, (l+r)/2);\n\t\tint vr = getMin(a, b, 2*k+2, (l+r)/2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\n\nint N, d;\nvector<TIII> s;\nint br[200010];\nSEG X, Y;\n\n\ntemplate<int N>\nVI tupleToVec(vector<TIII> vt){\n\tVI ret;\n\tfor(TIII t : vt) ret.pb(get<N>(t));\n\treturn ret;\n}\n\n\nint solve(){\n\tint ans = 0;\n\trep(i, 0, N) br[i] = get<0>(s[i]);\n\tX = SEG(tupleToVec<1>(s));\n\tY = SEG(tupleToVec<2>(s));\n\trep(i, 0, N){\n\t\tint p = upper_bound(RNG(br, N), br[i]+d)-&br[0];\n\t\tif(p == N) p = X.aryN;\n\t\tint x1 = X.getMax(i, p), x2 = X.getMin(i, p);\n\t\tint y1 = Y.getMax(i, p), y2 = Y.getMin(i, p);\n\t\tans = max(ans, (x1-x2)*(y1-y2));\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> N >> d;\n\ts = vector<TIII>(N);\n\trep(i, 0, N) cin >> get<1>(s[i]) >> get<2>(s[i]) >> get<0>(s[i]);\n\tsort(ALL(s));\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;\nconstexpr long long INF = numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourd; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, t, s, p,  last, cnt, sum, ans, d[2000][2000], a[600000], b[60000];\nstring str, ss;\nbool f[202000];\nchar c;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstruct Edge { LL to, cost1, cost2; };\nvector<Edge>vec[200000];\nvector<LL>v;\nmap<LL, LL>ma;\nmultiset<LL>st;\nstruct query {\n\tLL x, y, d;\n};\nquery q[2000000];\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nmap<LL, int> zip;\nLL unzip[300000];\nint compress(vector<LL> &x) {\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\tfor (int i = 0; i < x.size(); i++) {\n\t\tzip[x[i]] = i;\n\t\tunzip[i] = x[i];\n\t}\n\treturn x.size();\n}\t\nstruct pos {\n\tLL max_x = 0, max_y = 0, min_x = INF, min_y = INF;\n\tpos operator+=(pos p) {\n\t\tthis->max_x = max(this->max_x, p.max_x);\n\t\tthis->min_x = min(this->min_x, p.min_x);\n\t\tthis->max_y = max(this->max_y, p.max_y);\n\t\tthis->min_y = min(this->min_y, p.min_y);\n\t\treturn *this;\n\t}\n\tpos operator+(pos &p) {\n\t\tpos th = *this;\n\t\tth.max_x = max(this->max_x, p.max_x);\n\t\tth.min_x = min(this->min_x, p.min_x);\n\t\tth.max_y = max(this->max_y, p.max_y);\n\t\tth.min_y = min(this->min_y, p.min_y);\n\t\treturn th;\n\t}\n\tpos operator+=(Pll& p) {\n\t\tthis->max_x = max(this->max_x, p.first);\n\t\tthis->min_x = min(this->min_x, p.first);\n\t\tthis->max_y = max(this->max_y, p.second);\n\t\tthis->min_y = min(this->min_y, p.second);\n\t\treturn *this;\n\t}\n};\npos pos_plus(pos p1, pos p2) {\n\tpos th;\n\tth.max_x = max(p1.max_x, p2.max_x);\n\tth.min_x = min(p1.min_x, p2.min_x);\n\tth.max_y = max(p1.max_y, p2.max_y);\n\tth.min_y = min(p1.min_y, p2.min_y);\n\treturn th;\n}\nstruct Seg {\n\tLL n;\n\n\tvector<pos>node;\n\tSeg(LL n_) {\n\t\tn = 1; while (n < n_)n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t}\n\tvoid update(LL i, Pll p) {\n\t\ti = i + n - 1;\n\t\tnode[i] += p;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tnode[i] += node[i * 2 + 1];\n\t\t\tnode[i] += node[i * 2 + 2];\n\t\t}\n\t}\n\tpos find(LL i, LL a, LL b, LL l, LL r) {\n\t\tif (b < l || r < a)return pos();\n\t\tif (l <= a && b <= r)return node[i];\n\t\treturn pos_plus(find(i * 2 + 1, a, (a + b) / 2, l, r), find(i * 2 + 2, (a + b + 1) / 2, b, l, r));\n\t}\n};\n\nSeg seg(210000);\n\nint main() {\n\tcin >> n >> m;\n\n\trep(i, n) {\n\t\tLL x, y, z;\n\t\tcin >> x >> y >> z;\n\t\tq[i] = query{ x,y,z };\n\t\tv.push_back(z);\n\t}\n\tcompress(v);\n\trep(i, n) {\n\t\tseg.update(zip[q[i].d],Pll(q[i].x,q[i].y));\n\t}\n\tLL cur = 0;\n\tfor (auto i = zip.begin(); i != zip.end(); i++,cnt++) {\n\t\twhile (i->first - unzip[cur] > m &&cur != zip.size() - 1) {\n\t\t\tcur++;\n\t\t\tif (cur == zip.size() - 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tpos ANS= seg.find(0, 0, seg.n - 1,cur ,cnt );\n\t\tans = max(ans, (ANS.max_x - ANS.min_x)*(ANS.max_y-ANS.min_y));\n\t}\n\tcout << ans<< endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <vector>\n#include <utility>\n#include <numeric>\n#include <string>\n#include <set>\n#include <map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#define rep(i, a, n) for(int (i) = (int)(a);(i) < (int)(n);++(i))\n#define repe(i, a, n) for(int (i) = (int)(a);(i) <= (int)(n);++(i))\n#define repr(i, a, n) for(int (i) = (int)(a);(i) > (int)(n);--(i))\n#define reper(i, a, n) for(int (i) = (int)(a);(i) >= (int)(n);--(i))\n#define SIZE(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define RNG(x, n) &((x)[0]), &((x)[n])\n#define SUBIF(a, b, x) ((x) ? (b) : (a))\n#define YES cout << \"YES\" << endl\n#define NO cout << \"NO\" << endl\n#define Yes cout << \"Yes\" << endl\n#define No cout << \"No\" << endl\n#define yes cout << \"yes\" << endl;\n#define no cout << \"no\" << endl;\n#define pb push_back\n#define EPS (1e-20)\n#define INF 2147483647\n#define MOD 1000000007\nusing llint = long long;\nusing VI = std::vector<int>;\nusing PII = std::pair<int, int>;\nusing SI = std::set<int>;\nusing MII = std::map<int, int>;\nusing TIII = std::tuple<int, int, int>;\nusing namespace std;\n\n\nstruct SEG {\n\tint aryN;\n\tvector<PII> seg;\n\n\tSEG(){}\n\tSEG(const VI &v){\n\t\taryN = (int)pow(2, (int)ceil(log2(SIZE(v))));\n\t\tseg.resize(2*aryN-1, { -1, INF });\n\t\trep(i, 0, SIZE(v)) seg[i+aryN-1] = { v[i], v[i] };\n\t\treper(i, aryN-2, 0) seg[i].first = max(seg[2*i+1].first, seg[2*i+2].first), seg[i].second = min(seg[2*i+1].second, seg[2*i+2].second);\n\t}\n\tvoid update(int x, PII p){\n\t\tx += (aryN-1);\n\t\tseg[x] = p;\n\t\twhile(x > 0){\n\t\t\tx = (x-1)/2;\n\t\t\tseg[x].first = max(seg[2*x+1].first, seg[2*x+2].first);\n\t\t\tseg[x].second = min(seg[2*x+1].second, seg[2*x+2].second);\n\t\t}\n\t}\n\tint getMax(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = aryN;\n\t\tif(r <= a || b <= l) return -1;\n\t\tif(a <= l && r <= b) return seg[k].first;\n\t\tint vl = getMax(a, b, 2*k+1, l, (l+r)/2);\n\t\tint vr = getMax(a, b, 2*k+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n\tint getMin(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = aryN;\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <= b) return seg[k].second;\n\t\tint vl = getMin(a, b, 2*k+1, l, (l+r)/2);\n\t\tint vr = getMin(a, b, 2*k+2, (l+r)/2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\n\nint N, d;\nvector<TIII> s;\nint br[200010];\nSEG X, Y;\n\n\ntemplate<int N>\nVI tupleToVec(vector<TIII> vt){\n\tVI ret;\n\tfor(TIII t : vt) ret.pb(get<N>(t));\n\treturn ret;\n}\n\n\nint solve(){\n\tint ans = 0;\n\trep(i, 0, N) br[i] = get<0>(s[i]);\n\tX = SEG(tupleToVec<1>(s));\n\tY = SEG(tupleToVec<2>(s));\n\trep(i, 0, N){\n\t\tint p = upper_bound(RNG(br, N), br[i]+d)-&br[0];\n\t\tint x1 = X.getMax(i, p), x2 = X.getMin(i, p);\n\t\tint y1 = Y.getMax(i, p), y2 = Y.getMin(i, p);\n\t\tans = max(ans, (x1-x2)*(y1-y2));\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> N >> d;\n\ts = vector<TIII>(N);\n\trep(i, 0, N) cin >> get<1>(s[i]) >> get<2>(s[i]) >> get<0>(s[i]);\n\tsort(ALL(s));\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs front().first\nusing namespace std;\ntypedef pair<int,int> pii;\n\ntemplate<class Comp>\ninline void add(deque<pii> &q, pii nxt, Comp comp){\n  while(!q.empty() && comp(q.back(),nxt))q.pop_back();\n  q.push_back(nxt);\n}\n\ninline void del(deque<pii> &q, int p){\n  if(q.front().second == p)q.pop_front();\n}\n\nint main(){\n  int n,d;\n  scanf(\"%d%d\",&n,&d);\n  \n  vector<pii> x(n),y(n);\n  rep(i,n){\n    int X,Y,B;\n    scanf(\"%d%d%d\",&X,&Y,&B);\n    x[i] = pii(B,X); y[i] = pii(B,Y);\n  }\n  sort(all(x)); sort(all(y));\n\n  long long res = 0;\n  deque<pii> maxx, maxy, minx, miny;\n  int r = 0;\n  rep(l,n){\n    while(r<n && x[r].first-x[l].first<=d){\n      add(maxx,pii(x[r].second,r),less<pii>());\n      add(minx,pii(x[r].second,-r),greater<pii>());\n      add(maxy,pii(y[r].second,r),less<pii>());\n      add(miny,pii(y[r].second,-r),greater<pii>());\n      r++;\n    }\n\n    res = max( res, (long long)(maxx.fs - minx.fs) * (maxy.fs - miny.fs) );\n\n    del(maxx,l); del(minx,-l);\n    del(maxy,l); del(miny,-l);\n  }\n  printf(\"%lld\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct STAR {\n  int x, y, d;\n};\n\nbool asc(STAR &l, STAR &r) {\n  return l.d < r.d;\n}\n\nint main() {\n  ll n, d, ans = 0;\n  cin >> n >> d;\n  vector<STAR> v(n);\n\n  rep(i, 0, n) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    v[i].x = a;\n    v[i].y = b;\n    v[i].d = c;\n  }\n\n  sort(v.begin(), v.end(), asc);\n\n  int hx = v[0].x, lx = v[0].x, hy = v[0].y, ly = v[0].y, ld = v[0].d, lp = 0;\n  rep(i, 0, n - 1) {\n    if(v[i + 1].d - ld <= d) {\n      hx = max(hx, v[i + 1].x);\n      hy = max(hy, v[i + 1].y);\n      lx = min(lx, v[i + 1].x);\n      ly = min(ly, v[i + 1].y);\n    }else {\n      ans = max(ans, (ll)(abs(hx - lx) * abs(hy - ly)));\n      rep(j, lp + 1, i + 1) {\n        if(v[i + 1].d - v[j].d <= d) {\n          lp = j;\n          break;\n        }\n      }\n      hx = v[lp].x, lx = v[lp].x, hy = v[lp].y, hx = v[lp].y, ld = v[lp].d;\n      rep(j, lp + 1, i + 1) {\n        hx = max(hx, v[j].x);\n        hy = max(hy, v[j].y);\n        lx = min(lx, v[j].x);\n        ly = min(ly, v[j].y);\n      }\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint N=0;\nlong int b=0;\nint maxx=0,maxy=0,maxs=0,x[200000],y[200000],cnt=1;\nstruct DATA{\n\tint x,y,b;\n};\nDATA data[200000];\n\nint main(){\n\tcin>>N>>b;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>data[i].x>>data[i].y>>data[i].b;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tmaxx=0;maxy=0;cnt=1;\n\t\tx[0]=data[i].x;\n\t\ty[0]=data[i].y;\n\t\tfor(int j=0;j<N;j++){\n\t\t\t\n\t\t\tif(0<=data[i].b-data[j].b&&data[i].b-data[j].b<=b){\n\t\t\t\tcnt++;\n\t\t\t\tx[cnt]=data[j].x;\n\t\t\t\ty[cnt]=data[j].y;\n\t\t\t}\n\t\t\tif(j==N-1){\n\t\t\t\tsort(x,x+cnt);\n\t\t\t\tsort(y,y+cnt);\n\t\t\t\tmaxx=x[cnt]-x[0];\n\t\t\t\tmaxy=y[cnt]-y[0];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tks=maxx*maxy;\n\t\tif(maxs<ks){maxs=ks;}\n\t}\n\tcout<<maxs<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Q;\ntypedef pair<P, P> R;\n\nconst int inf = (int)2e6;\n\nint n, d;\nQ z[200000];\nR st[(2 << 19) - 1];\n\nR st_init(int k, int l, int r){\n\tif(r - l == 1){\n\t\treturn st[k] = R(z[l].second, z[l].second);\n\t}\n\tR p = st_init(k * 2 + 1, l, (l + r) / 2);\n\tR q = st_init(k * 2 + 2, (l + r) / 2, r);\n\treturn st[k] = R(\n\t\tP(min(p.first.first, q.first.first), min(p.first.second, q.first.second)),\n\t\tP(max(p.second.first, q.second.first), max(p.second.second, q.second.second))\n\t);\n}\n\nR st_minmax(int a, int b, int k, int l, int r){\n\tif(b <= l || r <= a){\n\t\treturn R(\n\t\t\tP(inf, inf),\n\t\t\tP(0, 0)\n\t\t);\n\t}\n\tif(a <= l && r <= b){\n\t\treturn st[k];\n\t}\n\tR p = st_minmax(a, b, k * 2 + 1, l, (l + r) / 2);\n\tR q = st_minmax(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn R(\n\t\tP(min(p.first.first, q.first.first), min(p.first.second, q.first.second)),\n\t\tP(max(p.second.first, q.second.first), max(p.second.second, q.second.second))\n\t);\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &d);\n\trep(i, n){\n\t\tint x, y, b;\n\t\tscanf(\"%d%d%d\", &x, &y, &b);\n\t\tz[i] = Q(b, P(x, y));\n\t}\n\n\tsort(z, z + n);\n\tst_init(0, 0, n);\n\n\tll ans = 0;\n\tint s = 0, t = 0;\n\twhile(t < n){\n\t\twhile(t < n && z[t].first <= z[s].first + d){\n\t\t\t++t;\n\t\t}\n\t\tR x = st_minmax(s, t, 0, 0, n);\n\t\tans = max(ans, ll(x.second.first - x.first.first) * ll(x.second.second - x.first.second));\n\t\t++s;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <limits>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntemplate<typename Type> class RMQ {\nprivate:\n\tint size_; vector<Type> dat;\n\tType query_(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return numeric_limits<Type>::max();\n\t\tif (a <= l && r <= b) return dat[k];\n\t\tint lc = query_(a, b, 2 * k, l, (l + r) / 2);\n\t\tint rc = query_(a, b, 2 * k + 1, (l + r) / 2, r);\n\t\treturn min(lc, rc);\n\t}\npublic:\n\tRMQ(int size__) {\n\t\tfor (size_ = 1; size_ < size__; size_ <<= 1); dat.resize(size_ * 2, numeric_limits<Type>::max());\n\t}\n\tRMQ(vector<Type> v) {\n\t\tfor (size_ = 1; size_ < dat.size(); size_ <<= 1); dat.resize(size_ * 2, numeric_limits<Type>::max());\n\t\tfor (int i = 0; i < v.size(); i++) dat[i + size_] = v[i];\n\t\tfor (int i = size_ - 1; i >= 1; i--) dat[i] = min(dat[2 * i], dat[2 * i + 1]);\n\t}\n\tint size() { return size_; }\n\tint ndat() { return numeric_limits<Type>::max(); }\n\tvoid update(int i, int x) {\n\t\ti += size_; dat[i] = x;\n\t\twhile (i > 1) i >>= 1, dat[i] = min(dat[2 * i], dat[2 * i + 1]);\n\t}\n\tType query(int l, int r) {\n\t\treturn query_(l, r, 1, 0, size_);\n\t}\n};\nint n, d, e[200000]; long long ret; vector<int> f[200000];\nint main() {\n\tscanf(\"%d%d\", &n, &d);\n\tfor (int i = 0; i < n; i++) f[i].resize(3), scanf(\"%d%d%d\", &f[i][1], f[i][2], f[i][0]);\n\tsort(f, f + n);\n\tfor (int i = 0; i < n; i++) e[i] = f[i][0];\n\tRMQ<int> r1(n); for (int i = 0; i < n; i++) r1.update(i, f[i][1]);\n\tRMQ<int> r2(n); for (int i = 0; i < n; i++) r2.update(i, -f[i][1]);\n\tRMQ<int> r3(n); for (int i = 0; i < n; i++) r3.update(i, f[i][2]);\n\tRMQ<int> r4(n); for (int i = 0; i < n; i++) r4.update(i, -f[i][2]);\n\tfor (int i = 0; i < n; i++) {\n\t\tint ptr = upper_bound(e, e + n, e[i] + d) - e;\n\t\tint wp = -r2.query(i, ptr) - r1.query(i, ptr);\n\t\tint hp = -r4.query(i, ptr) - r3.query(i, ptr);\n\t\tret = max(ret, 1LL * wp * hp);\n\t}\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\n#define N 200010\nstruct star{\n  ll x,y,b;\n  bool operator<(const star&key)const{\n      return this->b<key.b;\n  }  \n};\nll n,k;\nstar s[N];\nint main(){\n    cin>>n>>k;\n    for(int i=0;i<n;i++){\n\tcin>>s[i].x>>s[i].y>>s[i].b;\n    }\n    sort(s,s+n);\n    ll p=0;\n    multiset<ll> xx,yy;\n    ll ans=0;\n    for(int i=0;i<n;i++){\n\tfor(;p<n&&s[p].b<=s[i].b+k;p++){\n\t    xx.insert(s[p].x);\n\t    yy.insert(s[p].y);\n\t}\n\tauto ix=xx.end(); ix--;\n\tll dx=*ix-*xx.begin();\n\tauto iy=yy.end(); iy--;\n\tll dy=*iy-*yy.begin();\n\tans=max(ans,dx*dy);\n\txx.erase(xx.find(s[i].x));\n\tyy.erase(yy.find(s[i].y));\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1000000000\n#define f first\n#define s second\nusing namespace std;\ntypedef pair <int,pair <int,int> > P;\ntypedef long long ll;\nint n,d,tree[4][(1<<19)];\nP star[200001];\n\nvoid update(int i,int flg,int x){\n  i = i+(1<<18)-1;\n  tree[flg][i] = x;\n  while(i) {\n    i = (i-1)/2;\n    tree[flg][i] = max(tree[flg][i*2+1],tree[flg][i*2+2]);\n  }\n}\n\nint find(int a,int b,int ima,int L,int R,int flg){\n  if(R<=a || b<=L) return -INF;\n  if(a<=L && R<=b) return tree[flg][ima];\n  int M = (L+R)/2;\n  return max(find(a,b,ima*2+1,L,M,flg),find(a,b,ima*2+2,M,R,flg));\n}\n\nint main() {\n  cin >> n >> d;\n\n  for(int i=0;i<n;i++)cin >> star[i].s.f >> star[i].s.s >> star[i].f;\n  sort(star,star+n);  \n  \n  for(int i=0;i<4;i++) \n    for(int j=0;j<(1<<18);j++) tree[i][j] = -INF;\n  \n  for(int i=0;i<n;i++) {\n    update(i,0,star[i].s.f); // max(x);\n    update(i,1,star[i].s.s); // max(y);\n    update(i,2,-star[i].s.f); // min(x);\n    update(i,3,-star[i].s.s); // min(y);\n  }\n\n  long long S=0;\n  int ima=0;\n  for(int i=0;i<n;i++){\n    while(i!=n && star[ima].f-star[i].f <=d) ima++;\n    ll maxx = find(i,ima,0,0,(1<<18),0);\n    ll maxy = find(i,ima,0,0,(1<<18),1);\n    ll minx = find(i,ima,0,0,(1<<18),2);\n    ll miny = find(i,ima,0,0,(1<<18),3);\n    S = max(S,(maxx+minx)*(maxy+miny));\n  }\n  cout << S<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1<<29)\ntypedef long long ll;\n\nstruct MinSegtree\n{\n  int n;\n  int dat[1<<24];\n  MinSegtree(int _n)\n  {\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*21;i++)\n      dat[i] = INF;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n\n  int query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return INF;\n\n    if(a <= l && r <= b) return dat[k];\n    else{\n      int vl = query(a, b, k*2+1, l, (l + r) / 2);\n      int vr = query(a, b, k*2+2, (l + r) / 2, r);\n      return min(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nstruct MaxSegtree\n{\n  int n;\n  int dat[1<<24];\n  MaxSegtree(int _n){\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*2-1;i++)\n      dat[i] = -1;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n  \n  int query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return -1;\n    \n    if(a <= l && r <=b ) return dat[k];\n    else{\n      int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n      int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n      return max(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nint main()\n{\n  int n, d;\n  scanf(\"%d%d\", &n, &d);\n  MinSegtree minx(n);\n  MinSegtree miny(n);\n  MaxSegtree maxx(n);\n  MaxSegtree maxy(n);\n  \n  vector<pair<ll, pair<int, int> > >s(n);\n  vector<ll>br(n);\n  for(int i=0;i<n;i++){\n    int x, y; ll b;\n    scanf(\"%d%d%lld\", &x, &y, &b);\n    s[i] = make_pair(b, make_pair(x, y));\n    br[i] = b;\n  }\n  sort(s.begin(), s.end());\n  sort(br.begin(), br.end());\n\n\n  for(int i=0;i<n;i++){\n    minx.update(i, s[i].second.first);\n    maxx.update(i, s[i].second.first);\n    miny.update(i, s[i].second.second);\n    maxy.update(i, s[i].second.second);\n  }\n\n  br.push_back(INF);\n  ll res = 0;\n  for(int i=0;i<n;i++){\n    int pos = (int)(upper_bound(br.begin(), br.end(), br[i] + d) - br.begin());\n    int w = maxx.query(i, pos, 0, 0, maxx.size()) - minx.query(i, pos, 0, 0, minx.size());\n    int h = maxy.query(i, pos, 0, 0, maxy.size()) - miny.query(i, pos, 0, 0, miny.size());\n    res = max(res, (ll)w * (ll)h);\n  }\n\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n\nusing namespace std;\n\n//typedef\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n//container util\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << \"[L \" << __LINE__ << \"] \" << #x << \" = \" << (x) << \"\\n\";\n\nconst int INF = 1e9;\nconst int _N = 200000;\nconst int _M = 270000;\n\nstruct SEG{ // min\n\tint d[_M * 2];\n\tint m;\n\tvoid init(int m){\n\t\tthis->m = m;\n\t\tREP(i, m * 2 - 1)d[i] = INF;\n\t}\n\tvoid update(int i, int x){\n\t\ti += m - 1;\n\t\td[i] = x;\n\t\twhile(i>0){\n\t\t\ti = (i -1) / 2;\n\t\t\td[i] = min(d[i * 2 + 1], d[i * 2 + 2]);\n\t\t}\n\t}\n\tint query(int a, int b){\n\t\treturn _query(a, b, 0, 0, m);\n\t}\n\tprivate:int _query(int a, int b, int k, int l, int r){\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <=b) return d[k];\n\t\tint vl = _query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = _query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\nint n, d;\nint sizes[_N]; // sizes exist\nmap<int, int> sizeRef; // [size] = index\n\nSEG xms, xMs, yms, yMs;\ntypedef pair<int, PII> Star;\nStar stars[_N];\nbool comp(const Star& a, const Star& b){\n\treturn a.first < b.first;\n}\nint last = -1, si = -1;\nint xm = INF, xM, ym = INF, yM;\nvoid calc(){\n\tsizes[si] = last;\n\tsizeRef[last] = si;\n\tdump(xm);\n\txms.update(si, xm);\n\txMs.update(si, -xM);\n\tyms.update(si, ym);\n\tyMs.update(si, -yM);\n\txm = INF, xM = 0, ym = INF, yM = 0;\n}\n\nint main() {\n\tomajinai;\n\tcin >> n >> d;\n\n\t// segment tree initial\n\tint m=1;\n\twhile(m<n)m*=2;\n\txms.init(m);\n\txMs.init(m);\n\tyms.init(m);\n\tyMs.init(m);\n\t//\n\n\tREP(i, n){\n\t\tint x, y, b;\n\t\tcin >> x >> y >> b;\n\t\tstars[i] = MP(b, MP(x, y));\n\t}\n\tsort(stars, stars + n, comp);\n\tREP(i, n){\n\t\tint b = stars[i].first, x = stars[i].second.first, y = stars[i].second.second;\n\t\tif(b!=last){\n\t\t\tif(si > -1)calc();\n\t\t\tsi++;\n\t\t\tlast = b;\n\t\t}\n\t\txm = min(xm, x);\n\t\txM = max(xM, x);\n\t\tym = min(ym, y);\n\t\tyM = max(yM, y);\n\t}\n\tcalc();\n\n\tsi++; // to use as sizes' size\n\tint ans = 0;\n\tREP(i, n){\n\t\tint b = stars[i].first;\n\t\tint st = sizeRef[b];\n\t\tint ed = upper_bound(sizes, sizes + si, b + d) - sizes;\n\t\txm = xms.query(st, ed);\n\t\txM = -xMs.query(st, ed);\n\t\tym = yms.query(st, ed);\n\t\tyM = -yMs.query(st, ed);\n\t\tans = max(ans, (xM - xm) * (yM - ym));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P>P2;\n\nstruct RBQ{\n  int n=(1<<18),data[(1<<19)];\n  RBQ(){\n    memset(data,0,sizeof(data));\n  }\n  void update(int k,int x){\n    k+=n-1;\n    data[k]=x;\n    while(k>0){\n      k=(k-1)/2;\n      data[k]=max(data[k*2+1],data[k*2+2]);\n    }\n  }\n  int find(int a,int b,int k=0,int l=0,int r=(1<<18)){\n    if(r<=a || b<=l)return 0;\n    if(a<=l && r<=b)return data[k];\n    int v1=find(a,b,k*2+1,l,(l+r)/2);\n    int v2=find(a,b,k*2+2,(l+r)/2,r);\n    return max(v1,v2);\n  }\n};\n\nstruct RLQ{\n  int n=(1<<18),data[(1<<19)];\n  RLQ(){\n    fill(data,data+(1<<19),INT_MAX);\n  }\n  void update(int k,int x){\n    k+=n-1;\n    data[k]=x;\n    while(k>0){\n      k=(k-1)/2;\n      data[k]=min(data[k*2+1],data[k*2+2]);\n    }\n  }\n  int find(int a,int b,int k=0,int l=0,int r=(1<<18)){\n    if(r<=a || b<=l)return INT_MAX;\n    if(a<=l && r<=b)return data[k];\n    int v1=find(a,b,k*2+1,l,(l+r)/2);\n    int v2=find(a,b,k*2+2,(l+r)/2,r);\n    return min(v1,v2);\n  }\n};\n\nsigned main(){\n  int n,D;\n  cin>>n>>D;\n  RBQ X,Y;\n  RLQ x,y;\n  vector<P2>v;\n  r(i,n){\n    int x,y,z;\n    cin>>x>>y>>z;\n    v.push_back(P2(z,P(x,y)));\n  }\n  sort(v.begin(),v.end());\n  int l=0,ans=0;\n  r(r,n){\n    int d=v[r].first;\n    int nx=v[r].second.first;\n    int ny=v[r].second.second;\n    x.update(r,nx);\n    X.update(r,nx);\n    y.update(r,ny);\n    Y.update(r,ny);\n    while(d-v[l].first>D)l++;\n    int min_x=x.find(l,r+1);\n    int max_x=X.find(l,r+1);\n    int min_y=y.find(l,r+1);\n    int max_y=Y.find(l,r+1);\n    ans=max(ans,(max_x-min_x)*(max_y-min_y));\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"climits\"\n#define MAX 200000\nint star;\nint dif;\nint box_x[MAX];\nint x[MAX];\nint y[MAX];\nint box_y[MAX];\nint blight[MAX];\nint box[MAX];\nint end[MAX]={};\nint x_max=0;\nint x_min=INT_MAX;\nint y_max=0;\nint y_min=INT_MAX;\nint child;\nint fig = 1;\nint RMinQx[MAX * 4];\nint RMinQy[MAX * 4];\nint RMaxQx[MAX * 4];\nint RMaxQy[MAX * 4];\nint left[MAX * 4];\nint right[MAX * 4];\nlong long int ans=0;\n\nvoid MergeSort(int n[],int _x[],int _y[], int left, int right) {\n\tint mid;\n\tif (left == right)return;\n\tmid = (left + right) / 2;\n\tMergeSort(n,_x,_y, left, mid);\n\tMergeSort(n,_x,_y, mid + 1, right);\n\tfor (int i = left; i <= mid; i++) {\n\t\tbox[i] = n[i];\n\t\tbox_x[i] = _x[i];\n\t\tbox_y[i] = _y[i];\n\t}\n\tfor (int i = mid + 1, j = right; i <= right; i++, j--) {\n\t\tbox[i] = n[j];\n\t\tbox_x[i] = _x[j];\n\t\tbox_y[i] = _y[j];\n\t}\n\tint a = left, b = right;\n\tfor (int i = left; i <= right; i++) {\n\t\tif (box[a] <= box[b]) {\n\t\t\tn[i] = box[a];\n\t\t\t_x[i] = box_x[a];\n\t\t\t_y[i] = box_y[a++];\n\t\t}\n\t\telse {\n\t\t\tn[i] = box[b];\n\t\t\tx[i] = box_x[b];\n\t\t\ty[i] = box_y[b--];\n\t\t}\n\t}\n}\n\nint max(int a, int b) {\n\tif (a > b)return a;\n\treturn b;\n}\n\nint min(int a, int b) {\n\tif (a < b)return a;\n\treturn b;\n}\n\nint SegMax(int x[],int a) {\n\tif (a < child) {\n\t\tx[a] = max(SegMax(x,a * 2),SegMax(x, a * 2 + 1));\n\t}\n\treturn x[a];\n}\n\nint SegMin(int x[],int a) {\n\tif (a < child) {\n\t\tx[a] = min(SegMin(x, a * 2), SegMin(x, a * 2 + 1));\n\t}\n\treturn x[a];\n}\n\nint RangeL(int l[],int a) {\n\tif (a < child) {\n\t\tl[a] = min(RangeL(l, a * 2),RangeL(l,a*2+1));\n\t}\n\treturn l[a];\n}\n\nint RangeR(int r[], int a) {\n\tif (a < child) {\n\t\tr[a] = max(RangeR(r, a * 2), RangeR(r, a * 2 + 1));\n\t}\n\treturn r[a];\n}\n\nint RMinQ(int n[],int a, int b,int num) {\n\tif (a > right[num] || b < left[num])return INT_MAX;\n\tif (a <= left[num] && b >= right[num])return n[num];\n\treturn min(RMinQ(n, a, b, num * 2), RMinQ(n, a, b, num * 2 + 1));\n}\n\nint RMaxQ(int n[],int a, int b,int num) {\n\tif (a > right[num] || b < left[num])return 0;\n\tif (a <= left[num] && b >= right[num])return n[num];\n\treturn max(RMaxQ(n, a, b, num * 2), RMaxQ(n, a, b, num * 2 + 1));\n}\n\nint main() {\n\tscanf(\"%d %d\", &star, &dif);\n\tfor (int i = 0; i < star; i++) {\n\t\tscanf(\"%d %d %d\", &x[i], &y[i], &blight[i]);\n\t}\n\twhile (1) {\n\t\tif (fig >= star) {\n\t\t\tchild = fig;\n\t\t\tbreak;\n\t\t}\n\t\tfig *= 2;\n\t}\n\tMergeSort(blight,x,y, 0, star - 1);\n\tfor (int i = 0; i < star; i++) {\n\t\tRMaxQx[child + i] = x[i];\n\t\tRMinQx[child + i] = x[i];\n\t\tRMaxQy[child + i] = y[i];\n\t\tRMinQy[child + i] = y[i];\n\t}\n\tfor (int i = star; i < child; i++) {\n\t\tRMaxQx[child + i] = 0;\n\t\tRMinQx[child + i] = INT_MAX;\n\t\tRMaxQy[child + i] = 0;\n\t\tRMinQy[child + i] = INT_MAX;\n\t}\n\tSegMax(RMaxQx, 1);\n\tSegMax(RMaxQy, 1);\n\tSegMin(RMinQx, 1);\n\tSegMin(RMinQy, 1);\n\n\t//printf(\"%d %d %d %d\\n\", RMaxQx[1], RMaxQy[1], RMinQx[1], RMinQy[1]);\n\n\tfor (int i = 0; i < child; i++) {\n\t\tleft[child + i] = i;\n\t\tright[child + i] = i;\n\t}\n\n\tRangeR(right, 1);\n\tRangeL(left, 1);\n\n\t//for (int i = 1; i < child; i++) {\n\t//\tprintf(\"%d %d\\n\", left[i], right[i]);\n\t//}\n\n\tfor (int i = 1; i < star; i++) {\n\t\tif (blight[i] - blight[0] > dif) break;\n\t\tend[0] = i;\n\t}\n\tfor (int i = 1; i < star; i++) {\n\t\tfor (int j = end[i-1]; j < star; j++) {\n\t\t\tif (blight[j] - blight[i] > dif) break;\n\t\t\tend[i] = j;\t\n\t\t}\n\t//\tprintf(\"%d\\n\", end[i]);\n\t}\n\tfor (int i = 0; i < star; i++) {\n\t/*\tprintf(\"%d\\n\", RMaxQ(RMaxQx, i, end[i], 1));*/\n\t\t//printf(\"%lld\\n\", (long long int)(RMaxQ(RMaxQx, i, end[i], 1) - (long long int)RMinQ(RMinQx, i, end[i], 1))*((long long int)RMaxQ(RMaxQy, i, end[i], 1) - (long long int)RMinQ(RMinQy, i, end[i], 1)));\n\t\tif (ans < (long long int)(RMaxQ(RMaxQx, i, end[i], 1) - (long long int)RMinQ(RMinQx, i, end[i], 1))*((long long int)RMaxQ(RMaxQy, i, end[i], 1) - (long long int)RMinQ(RMinQy, i, end[i], 1))) {\n\t\t\tans = (long long int)(RMaxQ(RMaxQx, i, end[i], 1) - (long long int)RMinQ(RMinQx, i, end[i], 1))*((long long int)RMaxQ(RMaxQy, i, end[i], 1) - (long long int)RMinQ(RMinQy, i, end[i], 1));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <utility>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int INF = 1 << 30;\ntypedef pair<int, int> P1;\ntypedef pair<int, P1> P2;\nint B[200000], X[200000], Y[200000];\nstruct Seg {\n\tint *Min, *Max;\n\tint size;\n\tSeg(int n,int *X) {\n\t\tsize = 1;\n\t\twhile (n > size) size *= 2;\n\t\tMin = (int*)malloc(sizeof(int)*(2 * size - 1));\n\t\tMax = (int*)malloc(sizeof(int)*(2 * size - 1));\n\t\tfill(Min, Min + (2 * size - 1), INF);\n\t\tfill(Max, Max + (2 * size - 1), 0);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tMin[i+(size-1)] = Max[i+(size-1)] = X[i];\n\t\t}\n\t\tfor (int i = size - 2; i >= 0; i--) {\n\t\t\tMin[i] = min(Min[i * 2 + 1], Min[i * 2 + 2]);\n\t\t\tMax[i] = max(Max[i * 2 + 1], Max[i * 2 + 2]);\n\t\t}\n\t}\n\tint max_q(int a, int b, int k, int l, int r) {\n\t\tif (a <= l&&r <= b) {\n\t\t\treturn Max[k];\n\t\t}\n\t\telse if (r <= a || b <= l) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn max(max_q(a, b, k * 2 + 1, l, (l + r) / 2), max_q(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\tint min_q(int a, int b, int k, int l, int r) {\n\t\tif (a <= l&&r <= b) {\n\t\t\treturn Min[k];\n\t\t}\n\t\telse if (r <= a || b <= l) {\n\t\t\treturn INF;\n\t\t}\n\t\treturn min(min_q(a, b, k * 2 + 1, l, (l + r) / 2), min_q(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n};\nint main() {\n\tint N, d;\n\tscanf(\"%d %d\", &N, &d);\n\tvector<P2> star;\n\tfor (int i = 0; i < N; i++) {\n\t\tint x, y, b;\n\t\tscanf(\"%d %d %d\", &x, &y, &b);\n\t\tstar.push_back(P2(b, P1(x, y)));\n\t}\n\tsort(star.begin(), star.end());\n\tfor (int i = 0; i < N; i++) {\n\t\tB[i] = star[i].first;\n\t\tX[i] = star[i].second.first;\n\t\tY[i] = star[i].second.second;\n\t}\n\tSeg segX(N, X), segY(N, Y);\n\tlong long ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint pos = upper_bound(B, B + N, B[i] + d) - B;\n\t\tint minX = segX.min_q(i, pos, 0, 0, segX.size);\n\t\tint maxX = segX.max_q(i, pos, 0, 0, segX.size);\n\t\tint minY = segY.min_q(i, pos, 0, 0, segY.size);\n\t\tint maxY = segY.max_q(i, pos, 0, 0, segY.size);\n\t\tans = max(ans, (long long)(maxX - minX)*(maxY - minY));\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main(void)\n{\n\tint N=0,d=0,a=0;\n\tscanf(\"%d %d\",&N,&d);\n\tint x=0,y=0,b=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d %d %d\",&x,&y,&b);\n\t\tif(b<=d){if(x*y>a){a=x*y;}}\n\t}\n\tprintf(\"%d\\n\",a);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint N=0;\nlong int b=0;\nint maxx=0,maxy=0,maxs=0,ks=0,x[200000],y[200000],cnt=0;\nstruct DATA{\n\tint x,y,b;\n};\nDATA data[200000];\n\nint main(){\n\tcin>>N>>b;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>data[i].x>>data[i].y>>data[i].b;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tcnt=0;\n\t\tx[0]=data[i].x;\n\t\ty[0]=data[i].y;\n\t\tfor(int j=0;j<N;j++){\n\t\t\t\n\t\t\tif(0<=data[i].b-data[j].b&&data[i].b-data[j].b<=b){\n\t\t\t\tcnt++;\n\t\t\t\tx[cnt]=data[j].x;\n\t\t\t\ty[cnt]=data[j].y;\n\t\t\t}\n\t\t\tif(j==N-1&&cnt!=0){\n\t\t\t\tsort(x,x+cnt+1);\n\t\t\t\tsort(y,y+cnt+1);\n\t\t\t\tmaxx=x[cnt]-x[0];\n\t\t\t\tmaxy=y[cnt]-y[0];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tks=maxx*maxy;\n\t\tif(maxs<ks){maxs=ks;}\n\t}\n\tcout<<maxs<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n#define MAX_N 200000\n#define F first\n#define Se second\n#define MP(i, j) make_pair((i), (j))\n#define int long long\nstruct S{\n\tint sx, lx, sy, ly;\n\tS(int isx, int ilx, int isy, int ily): sx(isx), lx(ilx), sy(isy), ly(ily){}\n\tbool operator<(const S &s) const { \n\t\treturn 1;\n\t}\n};\nint cnt;\nvoid init(int n_, int *dat){\n\tcnt = 1;\n\twhile(cnt < n_) cnt *= 2;\n\tfor(int i = 0; i < 2 * cnt - 1; i++) dat[i] = INT_MAX;\n}\nvoid update(int k, int a, int *dat){\n\tk += cnt - 1;\n\tdat[k] = a;\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nint query(int a, int b, int k, int l, int r, int *dat){\n\tif(r <= a || b <= l) return INT_MAX;\n\tif(a <= l && r <= b) return dat[k];\n\telse{\n\t\tint v1 = query(a, b, k * 2 + 1, l, (l + r) / 2, dat);\n\t\tint vr = query(a, b, k * 2 + 2, (l + r) / 2, r, dat);\n\t\treturn min(v1, vr);\n\t}\n}\ntypedef pair<int, S> PS;\ntypedef vector<PS>::iterator it;\n\nint i, j, n, d, stars[MAX_N][3], ax[1 << 11], bx[1 << 11], ay[1 << 11], by[1 << 11];\nint ans = 0;\nvector<PS> vec;\n\nvoid vdc(vector<PS> &vf, S s, int now){\n\tif(vf[now].Se.sx > s.sx)\n\t\tvf[now].Se.sx = s.sx;\n\tif(vf[now].Se.lx < s.lx)\n\t\tvf[now].Se.lx = s.lx;\n\tif(vf[now].Se.sy > s.sy)\n\t\tvf[now].Se.sy = s.sy;\n\tif(vf[now].Se.ly < s.ly)\n\t\tvf[now].Se.ly = s.ly;\n}\n\nsigned main(){\n\tcin >> n >> d;\n\tvec.push_back(MP(-1, S(0, 0, 0, 0)));\n\tfor(i = 0; i < n; i++){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tS s = S(a, a, b, b);\n\t\tit ite = lower_bound(vec.begin(), vec.end(), MP(c, s));\n\t\tif(vec[ite - vec.begin() - 1].F != c){\n\t\t\tvec.insert(ite, MP(c, s));\n\t\t}\n\t\telse{\n\t\t\tvdc(vec, s, ite - vec.begin() - 1);\n\t\t}\n\t}\n\tinit(vec.size(), ax);\n\tinit(vec.size(), bx);\n\tinit(vec.size(), ay);\n\tinit(vec.size(), by);\n\tS s = S(INT_MAX, 0, INT_MAX, 0);\n\tvec.erase(vec.begin());\n\tfor(i = 0; i < vec.size(); i++){\n\t\tupdate(i, vec[i].Se.sx, ax);\n\t\tupdate(i, -vec[i].Se.lx, bx);\n\t\tupdate(i, vec[i].Se.sy, ay);\n\t\tupdate(i, -vec[i].Se.ly, by);\n\t}\n\ti = 0; j = 0;\n\tfor(;;){\n\t\twhile(j < vec.size()){\n\t\t\tif(vec[j].F - vec[i].F <= d)\n\t\t\t\tj++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tans = max(ans, (-query(i, j, 0, 0, cnt, bx) - query(i, j, 0, 0, cnt, ax)) * (-query(i, j, 0, 0, cnt, by) - query(i, j, 0, 0, cnt, ay)));\n\t\tif(j == vec.size())\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<unordered_map>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<algorithm>\n#define int long long\nusing namespace std;\n\nstruct star {\n\tint cost, x, y;\n};\nbool operator <(const star &a,const  star &b) {\n\treturn a.cost < b.cost;\n}\n\nstar A[300000];\nmap<int, int>X;\nmap<int, int>Y;\nsigned main(){\n\tint a, b; scanf(\"%lld%lld\", &a, &b);\n\tfor (int c = 0; c < a; c++) {\n\t\tint d, e, f; scanf(\"%lld%lld%lld\", &d, &e, &f);\n\t\tA[c] = { f,d,e };\n\t}\n\tsort(A, A + a);\n\tint MAX = 0;\n\tfor (int s = 0, g = 0; g < a; g++) {\n\t\tX[A[g].x]++;\n\t\tY[A[g].y]++;\n\t\twhile (s < g&&A[s].cost + b < A[g].cost) {\n\t\t\tX[A[s].x]--;\n\t\t\tY[A[s].y]--;\n\t\t\tif (X[A[s].x] == 0) {\n\t\t\t\tX.erase(A[s].x);\n\t\t\t}\n\t\t\tif (Y[A[s].y] == 0) {\n\t\t\t\tY.erase(A[s].y);\n\t\t\t}\n\t\t\ts++;\n\t\t}\n\t\tint n = X.rbegin()->first - X.begin()->first;\n\t\tint m = Y.rbegin()->first - Y.begin()->first;\n\t\tMAX = max(MAX, n*m);\n\t}\n\tprintf(\"%lld\\n\", MAX);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nclass Star\n{\npublic:\n\tint x, y, b;\n\tint boundary;\n};\nbool operator > (Star s1, Star s2)\n{\n\treturn s1.b > s2.b;\n}\nbool operator < (Star s1, Star s2)\n{\n\treturn s1.b < s2.b;\n}\n\nint n, d;\nStar star[200000];\nint maxX = 0, maxY = 0, minX = 0, minY = 0;\nint ans = 0;\n\nvoid calcBoundary()\n{\n\tint boundary = n - 1;\n\tstar[n - 1].boundary = boundary;\n\tfor (int i = n - 2; i >= 0; i--)\n\t{\n\t\tif (star[i + 1].b - star[i].b >= 2) boundary = i;\n\t\tstar[i].boundary = boundary;\n\t}\n\t\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tStar s;\n\t\ts.b = star[i].b + d;\n\t\tboundary = upper_bound(star + i, star + n, s) - star - 1;\n\t\tstar[i].boundary = min(star[i].boundary, boundary);\n\t}\n}\n\nvoid solve()\n{\n\tint boundary = -1;\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tif (star[i].boundary != boundary)\n\t\t{\n\t\t\tboundary = star[i].boundary;\n\t\t\tans = max((minX - maxX)*(minY - maxY), ans);\n\t\t\tmaxX = -2000000;\n\t\t\tmaxY = -2000000;\n\t\t\tminX = 2000000;\n\t\t\tminY = 2000000;\n\n\t\t\tfor (int j = i; j <= star[i].boundary; j++)\n\t\t\t{\n\t\t\t\tmaxX = max(star[j].x, maxX);\n\t\t\t\tmaxY = max(star[j].y, maxY);\n\t\t\t\tminX = min(star[j].x, minX);\n\t\t\t\tminY = min(star[j].y, minY);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmaxX = max(star[i].x, maxX);\n\t\t\tmaxY = max(star[i].y, maxY);\n\t\t\tminX = min(star[i].x, minX);\n\t\t\tminY = min(star[i].y, minY);\n\t\t}\n\t}\n\n\tans = max((maxX - minX)*(maxY - minY), ans);\n}\n\nint main()\n{\n\tcin >> n >> d;\n\tfor (int i = 0; i < n; i++) cin >> star[i].x >> star[i].y >> star[i].b;\n\t\n\tsort(star, star + n);\n\tcalcBoundary();\n\tsolve();\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define INF 1e9\nusing namespace std;\ntypedef long long ll;\nint n,d;\nstruct data{\n\tll x,y,c;\n};\n\nbool comp(const data& d1,const data& d2){\n\treturn d1.c<d2.c;\n};\n\ndata s[200001];\n\nstruct segtree{\n\tint val,b,s,v2;\n};\nsegtree seg[2][1<<22];\n\nvoid init(){\n\tfor(int i=0;i<(1<<22);i++)seg[0][i].s=seg[1][i].s=INF;\n\tfor(int i=1<<21;i<1<<22;i++)seg[0][i].v2=seg[1][i].v2=i-(1<<22);\n}\n\nvoid update(int upd,int x,int a){\n\tx+=(1<<21);\n\tseg[upd][x].val+=a;\n\tif(seg[upd][x].val>=1)seg[upd][x].s=seg[upd][x].b=seg[upd][x].v2;\n\telse{\n\t\tseg[upd][x].s=INF;\n\t\tseg[upd][x].b=0;\n\t}\n\twhile(x>0){\n\t\tx=(x-1)/2;\n\t\tseg[upd][x].s=min(seg[upd][x*2+1].s,seg[upd][x*2+2].s);\n\t\tseg[upd][x].b=max(seg[upd][x*2+1].b,seg[upd][x*2+2].b);\n\t}\n}\n\n\nint main(void){\n\tscanf(\"%d%d\",&n,&d);\n\tinit();\n\tfor(int i=0;i<n;i++)scanf(\"%lld%lld%lld\",&s[i].x,&s[i].y,&s[i].c);\n\tsort(s,s+n,comp);\n\tll res=0;\n\tint mc=0;\n\tfor(int i=0;i<n;i++){\n\t\tupdate(0,s[i].x,1);\n\t\tupdate(1,s[i].y,1);\n\t\twhile(s[i].c-s[mc].c>d){\n\t\t\tupdate(0,s[mc].x,-1);\n\t\t\tupdate(1,s[mc].y,-1);\n\t\t\tmc++;\n\t\t}\n\t\tres=max(res,(seg[0][0].b-seg[0][0].s)*(seg[1][0].b-seg[1][0].s));\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<stdlib.h>\n#define int long long\nusing namespace std;\n\nint n, d;\nstruct Star {\n\tint x, y, b;\n}star[200000];\n\nsigned compare(const void *s1, const void *s2) {\n\tint t1 = ((Star*)s1)->b;\n\tint t2 = ((Star*)s2)->b;\n\treturn t1 - t2;\n}\nsigned main() {\n\tint i;\n\tcin >> n >> d;\n\tfor( i = 0; i < n; i++ )\n\t\tcin >> star[i].x >> star[i].y >> star[i].b;\n\tqsort(star, n, sizeof(star[0]), compare);\n\n\tstatic multiset<int> X;\n\tstatic multiset<int> Y;\n\tmultiset<int>::iterator it;\n\tmultiset<int>::reverse_iterator rit;\n\tint ins = 0;\n\tint del = 0;\n\tint j;\n\tint ans = 0;\n\n\tfor( i = 0; i < n; i++ ) {\n\t\tins = i;\n\t\tX.insert( star[ins].x );\n\t\tY.insert( star[ins].y );\n\t\tfor(; del < n; del++ ) {\n\t\t\tif( star[del].b < star[i].b - d ) {\n\t\t\t\tit = X.find( star[del].x );\n\t\t\t\tX.erase( it );\n\t\t\t\tit = Y.find( star[del].y );\n\t\t\t\tY.erase( it );\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tit = X.begin();\n\t\tint minx = *it;\n\t\trit = X.rbegin();\n\t\tint maxx = *rit;\n\t\tit = Y.begin();\n\t\tint miny = *it;\n\t\trit = Y.rbegin();\n\t\tint maxy = *rit;\n\t\tans = max( ans, (maxx - minx) * (maxy - miny) );\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<stack>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<tuple>\n#include<utility>\n#include<set>\n#include<queue>\n#include<iomanip>\n#include<iterator>\n//#include<chrono>\n//cout<<setprecision(12)\n//fixed\n//#include<random>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\nconst llint big=1e15+100000;\nconst int mod=1e9+7;\nconst lldo eps=1e-9;\nconst long double pai=3.141592653589793238462643;\n#define mt make_tuple\n#define mp make_pair\n#define fir first\n#define sec second\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define res resize\n#define ins insert\n#define era erase\n#define dme(in) cout<<in<<endl;return 0\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nint main(void){\n\tint i,n,d,j=0;cin>>n>>d;\n\tllint ans=0;\n\tvector<tuple<llint,llint,llint>> a(n);\n\tfor(i=0;i<n;i++){cin>>get<1>(a[i])>>get<2>(a[i])>>get<0>(a[i]);}\n\tsort(a.begin(),a.end());\n\tmultiset<int>x;\n\tmultiset<int>y;\n\tfor(i=0;i<n;i++){\n\t\tx.ins(get<1>(a[i]));\n\t\ty.ins(get<2>(a[i]));\n\t\tfor(;j<n;j++){\n\t\t\tif(get<0>(a[j])>=get<0>(a[i])-d){break;}\n\t\t\tx.era(x.lower_bound(get<1>(a[j])));\n\t\t\ty.era(y.lower_bound(get<2>(a[j])));\n\t\t}\n\t\tmaxeq(ans,((*prev(x.end()))-(*x.begin()))*((*prev(y.end()))-(*y.begin())));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\n\nstruct Star{\n    int x,y,b;\n    Star(int x=0,int y=0,int b=0) :\n        x(x),y(y),b(b){}\n    bool operator<(const Star &rth) const {\n        return this->b<rth.b;\n    }\n    bool operator<(int rval) const {\n        return this->b<rval;\n    }\n};\n\nstruct SegTree {\n    int n;\n    vector<int> min_dat;\n    vector<int> max_dat;\n    SegTree(int N) {\n        n=1;\n        while(n<N) n*=2;\n        min_dat.assign(1<<19,INF);\n        max_dat.assign(1<<19,0);\n    }\n\n    void update(int k,int a) {\n        k+=n-1;\n        min_dat[k]=a;\n        max_dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            min_dat[k]=min(min_dat[k*2+1],min_dat[k*2+2]);\n            max_dat[k]=max(max_dat[k*2+1],max_dat[k*2+2]);\n        }\n    }\n\n    int min_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return INF;\n\n        if(a<=l&&r<=b) return min_dat[k];\n        else {\n            int vl=min_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=min_query(a,b,k*2+2,(l+r)/2,r);\n            return min(vl,vr);\n        }\n    }\n\n    int max_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return 0;\n\n        if(a<=l&&r<=b) return max_dat[k];\n        else {\n            int vl=max_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=max_query(a,b,k*2+2,(l+r)/2,r);\n            return max(vl,vr);\n        }\n    }\n\n    void dump() {\n        rep(i,n) cout<<max_dat[i]<<\" \";\n        cout<<endl;\n    }\n\n};\nint N,d;\n\n\nvector<Star> stars;\n\nint find(int x) {\n    int l=0;\n    int r=stars.size()-1;\n    while(r-l>1) {\n        int mid=(l+r)/2;\n        if(stars[mid].b<x) l=mid;\n        else r=mid;\n    }\n    return r;\n}\nint main() {\n    cin>>N>>d;\n    rep(i,N) {\n        Star s;\n        cin>>s.x>>s.y>>s.b;\n        stars.pb(s);\n    }\n    SegTree segTreeX(N);\n    SegTree segTreeY(N);\n\n    sort(all(stars));\n\n    rep(i,stars.size()) {\n        // printf(\"%d %d %d %d\\n\",i,stars[i].x,stars[i].y,stars[i].b);\n        segTreeX.update(i,stars[i].x);\n        segTreeY.update(i,stars[i].y);\n    }\n\n\n    int ans=0;\n    int n=segTreeX.n;\n    rep(i,stars.size()) {\n        int pos=find(stars[i].b+d);\n        int tmp=0;\n        tmp=segTreeX.max_query(i,pos+1,0,0,n)-segTreeX.min_query(i,pos+1,0,0,n);\n        tmp*=segTreeY.max_query(i,pos+1,0,0,n)-segTreeY.min_query(i,pos+1,0,0,n);\n\n        // cout<<i<<\",\"<<stars[i].b+d<<\",\"<<pos<<\",\"<<tmp<<endl;\n        ans = max(ans,tmp);\n\n    }\n\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+17 + 10;\n\nclass RMQ{\nprivate:\n\tint n;\n\tP dat[200001];\n\n\t//[a,b),[l,r) //(Max,Min)\n\tP rec(int a, int b, int k, int l, int r){\n\t\tif (b <= l || r <= a)return P(-infi, infi);\n\t\tif (a <= l && r <= b)return P(dat[k].first, dat[k].second);\n\t\telse {\n\t\t\tP vl = rec(a, b, 2 * k + 1, l, (l + r) / 2), vr = rec(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\t\treturn P(std::max(vl.first, vr.first), std::min(vl.second, vr.second));\n\t\t}\n\t}\n\npublic:\n\tvoid init(int x){\n\t\tn = 1;\n\t\twhile (n < x)n *= 2;\n\t\trep(i, 2 * n - 1)dat[i] = P(-infi, infi);\n\t}\n\n\tvoid update(int k, int a){\n\t\tk += n - 1;\n\t\tdat[k] = P(a, a);\n\t\twhile (k > 0){\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k].first = std::max(dat[2 * k + 1].first, dat[2 * k + 2].first);\n\t\t\tdat[k].second = std::min(dat[2 * k + 1].second, dat[2 * k + 2].second);\n\t\t}\n\t}\n\n\t//[a,b] //(Max,Min)\n\tP query(int a, int b){\n\t\treturn rec(a, b + 1, 0, 0, n);\n\t}\n};\n\nstruct Star{ int x, y, b; };\nStar star[200001];\nint n, d;\nRMQ up, right;\n\nbool comp(const Star &lhs, const Star &rhs){\n\treturn lhs.b < rhs.b;\n}\n\nint main(){\n\tstd::cin >> n >> d;\n\trep(i, n)std::cin >> star[i].x >> star[i].y >> star[i].b;\n\tstd::sort(star, star + n, comp);\n\tint ans = 0;\n\tint first = 0;\n\tup.init(n), right.init(n);\n\trep(i, n){\n\t\tup.update(i, star[i].y);\n\t\tright.update(i, star[i].x);\n\t\twhile (star[i].b - star[first].b > d)++first;\n\t\tP a = up.query(first, i), b = right.query(first, i);\n\t\tans = std::max(ans, (a.first - a.second) * (b.first - b.second));\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint N=0;\nlong int b=0;\nint maxx=0,maxy=0,maxs=0,ks=0,x[200000],y[200000],cnt=0;\nstruct DATA{\n\tint x,y,b;\n};\nDATA data[200000];\n\nint main(){\n\tcin>>N>>b;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>data[i].x>>data[i].y>>data[i].b;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tcnt=0;\n\t\tx[0]=data[i].x;\n\t\ty[0]=data[i].y;\n\t\tfor(int j=0;j<N;j++){\n\t\t\t\n\t\t\tif(0<=data[i].b-data[j].b&&data[i].b-data[j].b<=b){\n\t\t\t\tcnt++;\n\t\t\t\tx[cnt]=data[j].x;\n\t\t\t\ty[cnt]=data[j].y;\n\t\t\t}\n\t\t\tif(j==N-1&&cnt!=0){\n\t\t\t\tsort(x,x+cnt+1);\n\t\t\t\tsort(y,y+cnt+1);\n\t\t\t\tmaxx=x[cnt]-x[0];\n\t\t\t\tmaxy=y[cnt]-y[0];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tks=maxx*maxy;\n\t\tif(maxs<ks){maxs=ks;}\n\t}\n\tcout<<maxs<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<stdlib.h>\n#define int long long\nusing namespace std;\n\nint n, d;\t//1 <= n <= 2*10^5, 0 <= d <= 10^9\nstruct Star {\n\tint x, y, b;\n}star[200000];\n\nint compare(const void *s1, const void *s2) {\n\tint t1 = ((Star*)s1)->b;\n\tint t2 = ((Star*)s2)->b;\n\treturn t1 - t2;\n}\nsigned main() {\n\tint i;\n\tcin >> n >> d;\n\tfor( i = 0; i < n; i++ )\n\t\tcin >> star[i].x >> star[i].y >> star[i].b;\n\tqsort(star, n, sizeof(star[0]), compare);\n\n\tstatic multiset<int> X;\n\tstatic multiset<int> Y;\n\tmultiset<int>::iterator it;\n\tmultiset<int>::reverse_iterator rit;\n\tint ins = 0;\n\tint del = 0;\n\tint j;\n\tint ans = 0;\n\n\t/*for( i = 0; i < n; i++ ) {\n\t\tprintf(\"index = %d x = %d y = %d b = %d\\n\", i, star[i].x, star[i].y, star[i].b);\n\t}*/\n\n\tfor( i = 0; i < n; i++ ) {\n\t\tins = i;\n\t\tX.insert( star[ins].x );\n\t\tY.insert( star[ins].y );\n\t\tfor(; del < n; del++ ) {\n\t\t\tif( star[del].b < star[i].b - d ) {\n\t\t\t\tit = X.find( star[del].x );\n\t\t\t\tX.erase( it );\n\t\t\t\tit = Y.find( star[del].y );\n\t\t\t\tY.erase( it );\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tit = X.begin();\n\t\tint minx = *it;\n\t\trit = X.rbegin();\n\t\tint maxx = *rit;\n\t\tit = Y.begin();\n\t\tint miny = *it;\n\t\trit = Y.rbegin();\n\t\tint maxy = *rit;\n\t\tans = max( ans, (maxx - minx) * (maxy - miny) );\n\n\t\t//printf(\"ins = %d, del = %d, x[%d, %d], y[%d, %d]\\n\", ins, del, minx, maxx, miny, maxy);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define int long long\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(obj) begin(obj), end(obj)\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\n#define LOWER_BOUND(A, key) distance(A.begin(), lower_bound(ALL(A), key))\n#define UPPER_BOUND(A, key) distance(A.begin(), upper_bound(ALL(A), key))\n\nusing namespace std;\nusing ll      = long long;\nconst int MOD = (int)(1e9 + 7);\nconst int INF = (int)(1e13 + 7);\n\nint bpm(int x, unsigned int y) {\n  if (x == 0) return 0;\n  if (y == 0) return 1;\n  int ans   = 1;\n  int digit = (int)((log((double)y) / log((double)2) / 1 + 1));\n  x %= MOD;\n  for (unsigned int i = 0; i < digit; i++) {\n    if (((y >> i) & 1u) == 1) ans = ans * x % MOD;\n    x = x * x % MOD;\n  }\n  return ans;\n}\n\nsigned main() {\n  int N, d;\n  cin >> N >> d;\n  vector<vector<int>> data(N);\n  rep(i, N) {\n    int temp_x, temp_y, b;\n    cin >> temp_x >> temp_y >> b;\n    data[i] = {b, temp_x, temp_y};\n  }\n  sort(ALL(data));\n  map<int, int> x;\n  map<int, int> y;\n  x[data[0][1]] = 1;\n  y[data[0][2]] = 1;\n  int L         = 0;\n  int R         = 0;\n  int ans       = 0;\n  while (true) {\n    if (data[R][0] - data[L][0] <= d) ans = max(ans, (x.rbegin()->first - x.begin()->first) * (y.rbegin()->first - y.begin()->first));\n    if (R == N - 1) break;\n    if (data[R][0] - data[L][0] <= d) {\n      R++;\n      x[data[R][1]] += 1;\n      y[data[R][2]] += 1;\n    } else if (R == L) {\n      if (x[data[L][1]]-- == 1) {\n        x.erase(data[L][1]);\n      }\n      if (y[data[L][2]]-- == 1) {\n        y.erase(data[L][2]);\n      }\n      R++;\n      L++;\n      x[data[R][1]] += 1;\n      y[data[R][2]] += 1;\n    } else {\n      if (x[data[L][1]]-- == 1) {\n        x.erase(data[L][1]);\n      }\n      if (y[data[L][2]]-- == 1) {\n        y.erase(data[L][2]);\n      }\n      L++;\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<climits>\n#include<algorithm>\n\nconst int INF = INT_MAX;\nconst int NIL = -1;\nint leftMostBit(int x) {\n  if(x == 0) return 0;\n  x = (x & 0x55555555) << 1 | (x >> 1) & 0x55555555;\n  x = (x & 0x33333333) << 2 | (x >> 2) & 0x33333333;\n  x = (x & 0x0f0f0f0f) << 4 | (x >> 4) & 0x0f0f0f0f;\n  x = (x << 24) | ((x & 0xff00) << 8) | ((x >> 8) & 0xff00) | (x >> 24);\n  int deBruijnSequence[32] = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14};\n  return 31 - deBruijnSequence[((x & -x) * 0x076be629U) >> 27];\n}\nclass RangeMinimumQuery {\npublic:\n  RangeMinimumQuery(int s) {\n    size_ = 1 << leftMostBit(s);\n    if(size_ != s) size_ <<= 1;\n    node_ = std::vector<int>((size_ << 1) - 1, INF);\n  }\n  int find(int left, int right) const {\n    return query(left, right, 0, 0, size_ - 1);\n  }\n  void update(int index, int value) {\n    int i = index + size_ - 1;\n    node_[i] = value;\n    while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n  }\nprivate:\n  int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n  int left_child(int node) const {return (node << 1) + 1;}\n  int right_child(int node) const {return (node << 1) + 2;}\n  int query(int a, int b, int k, int l, int r) const {\n    if(b < l || r < a) return INF;\n    if(a <= l && r <= b) return node_[k];\n    int vl = query(a, b, left_child(k), l, (l + r) / 2);\n    int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n    return std::min(vl, vr);\n  }\n\n  int size_;\n  std::vector<int> node_;\n};\n\n#include<iostream>\nusing namespace std;\n\nstruct Star {int x, y, b;};\nbool operator<(const Star& lhs, const Star& rhs) {return lhs.b < rhs.b;}\n\nint main() {\n  int N, d;\n  cin >> N >> d;\n  vector<Star> star(N);\n  for(auto& s: star) cin >> s.x >> s.y >> s.b;\n  sort(begin(star), end(star));\n  RangeMinimumQuery left(N), right(N), top(N), bottom(N);\n  for(int i = 0; i < N; ++i) {\n    left.update(i, star[i].x);\n    right.update(i, -star[i].x);\n    top.update(i, star[i].y);\n    bottom.update(i, -star[i].y);\n  }\n  int answer = 0;\n  int low, high;\n  for(low = high = 0; low < N; ++low) {\n    while(high < N - 1 && star[high].b - star[low].b < d) ++high;\n    int area = -right.find(low, high) - left.find(low, high);\n    area *= -bottom.find(low, high) - top.find(low, high);\n    answer = max(answer, abs(area));\n  }\n  cout << answer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 2002002002;\ntypedef long long LL;\n\nstruct DATA {\n\tint minx, miny, maxx, maxy;\n};\n\nstruct STAR {\n\tint x, y, b;\n\tbool operator < (const STAR &t) const {\n\t\treturn b < t.b;\n\t}\n};\n\nint n, d;\nSTAR star[1 << 18];\n\nint N;\nDATA data[1 << 19];\n\n\nvoid init(int n)\n{\n\tfor (N = 1; N < n; N <<= 1);\n\tfill(data, data + N * 2 - 1, (DATA){INF, INF, -INF, -INF});\n}\n\nvoid update(int i, STAR s)\n{\n\ti += N - 1;\n\tdata[i].minx = min(data[i].minx, s.x);\n\tdata[i].miny = min(data[i].miny, s.y);\n\tdata[i].maxx = max(data[i].maxx, s.x);\n\tdata[i].maxy = max(data[i].maxy, s.y);\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tdata[i].minx = min(data[i].minx, s.x);\n\t\tdata[i].miny = min(data[i].miny, s.y);\n\t\tdata[i].maxx = max(data[i].maxx, s.x);\n\t\tdata[i].maxy = max(data[i].maxy, s.y);\n\t}\n}\n\nDATA query(int a, int b, int k, int l, int r)\n{\n\t//printf(\"%d %d %d %d %d\\n\", a, b, k, l, r);\n\tif (r <= a || b <= l) return (DATA){INF, INF, -INF, -INF};\n\tif (a <= l && r <= b) return data[k];\n\tDATA vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tDATA vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn (DATA){min(vl.minx, vr.minx), min(vl.miny, vr.miny), max(vl.maxx, vr.maxx), max(vl.maxy, vr.maxy)};\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tinit(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d %d\", &star[i].x, &star[i].y, &star[i].b);\n\t\t--star[i].x; --star[i].y;\n\t}\n\tstar[n].b = INF;\n\t\n\tsort(star, star + n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tupdate(i, star[i]);\n\t}\n\t\n\t//printf(\"%d\\n\", INF);\n\t\n\tLL res = 0;\n\tfor (int l = 0; l < n; ){\n\t\tint r = l;\n\t\twhile (star[r].b - star[l].b <= d) r++;\n\t\t\n\t\tDATA q = query(l, r, 0, 0, N);\n\t\tLL t = (LL)(q.maxx - q.minx) * (q.maxy - q.miny);\n\t\tres = max(res, t);\n\t\t\n\t\tl++;\n\t\twhile (star[l + 1].b == star[l].b) l++;\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\nint n, size_, dat[2][2][266666];//[xy][minmax][pos]\ntuple<int, int, int>x[266666];\ninline void init(int n) {\n\tfor (size_ = 1; size_ < n;) size_ *= 2;\n\tfor (int i = 0; i < 2; i++) { for (int j = 0; j < 266666; j++) { dat[i][0][j] = 1 << 30; dat[i][1][j] = -(1 << 30); } }\n}\ninline void update(int pos, int x, int p1) {\n\tpos += size_; dat[p1][0][pos] = x; dat[p1][1][pos] = x;\n\twhile (pos != 1) {\n\t\tpos >>= 1;\n\t\tdat[p1][0][pos] = min(dat[p1][0][pos * 2], dat[p1][0][pos * 2 + 1]);\n\t\tdat[p1][1][pos] = max(dat[p1][1][pos * 2], dat[p1][1][pos * 2 + 1]);\n\t}\n}\ninline int query(int a, int b, int k, int l, int r, int p1, int p2) {\n\tif (r <= a || b <= l) { if (p2 == 0)return 1 << 30; return -(1 << 30); }\n\tif (a <= l && r <= b) return dat[p1][p2][k]; k <<= 1;\n\tint lc = query(a, b, k, l, (l + r) / 2, p1, p2);\n\tint rc = query(a, b, k + 1, (l + r) / 2, r, p1, p2);\n\tif (p2 == 0)return min(lc, rc);\n\tif (p2 == 1)return max(rc, lc);\n}\ninline int rmqw(int x, int y, int p) {\n\tint V1 = query(x, y + 1, 1, 0, size_, p, 1), V2 = query(x, y + 1, 1, 0, size_, p, 0);\n\treturn V1 - V2;\n}\nint main() {\n\tcin >> n; init(n); for (int i = 1; i <= n; i++) { cin >> get<0>(x[i]) >> get<1>(x[i]) >> get<2>(x[i]); }\n\tsort(x + 1, x + n + 1); long long maxn = 0;\n\tfor (int i = 1; i <= n; i++) { update(i, get<1>(x[i]), 0); update(i, get<2>(x[i]), 1); }\n\tfor (int i = 1; i <= n; i++) {\n\t\tint R = lower_bound(x + 1, x + n + 1, make_tuple(get<0>(x[i]), 1 << 30, 1 << 30)) - x;\n\t\tmaxn = max(maxn, 1LL*rmqw(i, R, 0)*rmqw(i, R, 1));\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\n#define int long long\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\n#define fore(i,a) for(auto &i:a)\n#define REP(i,n) for(int i=0;i<n;i++)\n#define eREP(i,n) for(int i=0;i<=n;i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define eFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define SORT(c) sort((c).begin(),(c).end())\n#define rSORT(c) sort((c).rbegin(),(c).rend())\n#define LB(x,a) lower_bound((x).begin(),(x).end(),(a))\n#define UB(x,a) upper_bound((x).begin(),(x).end(),(a))\n#define INF 1000000000\n#define LLINF 9223372036854775807\n#define mod 1000000007\n//vector<vector<int> > dp;\n//vector<vector<vector<int> > > vvvi;\n//dp=vector<vector<int> >(N, vector<int>(M,0));\n//vector<pair<int,int> > v;\n//v.push_back(make_pair(x,y));\n//priority_queue<int,vector<int>, greater<int> > q2;\n\nstruct Node {\n\tint sx, tx, sy, ty;\n\tNode() { sx = LLINF; tx = -LLINF; sy = LLINF; ty = -LLINF; }\n\tNode(int sx1, int tx1, int sy1, int ty1) { sx = sx1, tx = tx1, sy = sy1, ty = ty1; }\n};\n\nusing V = Node;\n#define def Node()\n\ntemplate<int NV> struct SegTree { //[l,r)\n\tV comp(V& l, V& r) {\n\t\treturn Node(min(l.sx, r.sx), max(l.tx, r.tx), min(l.sy, r.sy), max(l.ty, r.ty));\n\t};\n\n\tvector<V> val; SegTree() { val = vector<V>(NV * 2, def); }\n\tV get(int x, int y, int l = 0, int r = NV, int k = 1) {\n\t\tif (r <= x || y <= l)return def; if (x <= l && r <= y)return val[k];\n\t\tauto a = get(x, y, l, (l + r) / 2, k * 2);\n\t\tauto b = get(x, y, (l + r) / 2, r, k * 2 + 1);\n\t\treturn comp(a, b);\n\t}\n\tvoid update(int i, V v) {\n\t\ti += NV; val[i] = v;\n\t\twhile (i > 1) i >>= 1, val[i] = comp(val[i * 2], val[i * 2 + 1]);\n\t}\n\tV operator[](int x) { return get(x, x + 1); }\n};\n\nint N, d;\nSegTree<1 << 18> st;\n\nsigned main(){\ncin.tie(0);\nios::sync_with_stdio(false);\n\n\tcin >> N >> d;\n\tVI bv(N);\n\tvector<tuple<int, int, int> >points(N);\n\tREP(i, N) {\n\t\tint x, y, b;\n\t\tcin >> x >> y >> b;\n\t\tpoints[i] = make_tuple(b, x, y);\n\t\tbv[i] = b;\n\t}\n\tSORT(points);\n\tSORT(bv);\n\t\n\tREP(i, N) {\n\t\tint x, y, b;\n\t\ttie(b, x, y) = points[i];\n\t\tst.update(i, Node(x, x, y, y));\n\t}\n\tint ans = 0;\n\tREP(i, N) {\n\t\tint L = i;\n\t\tint R = UB(bv, bv[i] + d)-bv.begin();\n\t\tauto no = st.get(L, R);\n\n\t\tint sx = no.sx;\n\t\tint tx = no.tx;\n\t\tint sy = no.sy;\n\t\tint ty = no.ty;\n\t\tans = max(ans, (tx - sx)*(ty - sy));\n\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pi;\n#define F first\n#define S second\nconst int N=2e5+10;\nstruct star{\n    pi pos;\n    int light;\n    void in(){\n        scanf(\"%d%d%d\",&pos.F,&pos.S,&light);\n        return ;\n    }\n};\nstruct cmp{\n    bool operator()(const star &a,const star &b){\n        return a.light>b.light;\n    }\n};\nint min(int a,int b){return a>b?b:a;}\nlong long int max(long long int a,long long int b){return a>b?a:b;}\nint main(){\n    int n,d,low=0;\n    long long int ans=0;\n    star temp;\n    priority_queue<star,vector<star>,cmp> pq;\n    priority_queue<pi,vector<pi>,greater<pi>>l,b;\n    priority_queue<pi> u,r;\n    scanf(\"%d%d\",&n,&d);\n    for(int i=0;i<n;i++){\n        temp.in();\n        pq.push(temp);\n        low=min(low,temp.light);\n    }\n    low+=d;\n    while(!pq.empty()){\n        while(pq.top().light<=low){\n            temp=pq.top();\n            pq.pop();\n            u.push({temp.pos.F,temp.light});\n            b.push({temp.pos.F,temp.light});\n            l.push({temp.pos.S,temp.light});\n            r.push({temp.pos.S,temp.light});\n            if(pq.empty())break;\n        }\n        while(!u.empty()){\n            if(u.top().S<low-d)u.pop();\n            else break;\n        }\n        while(!r.empty()){\n            if(r.top().S<low-d)r.pop();\n            else break;\n        }\n        while(!l.empty()){\n            if(l.top().S<low-d)l.pop();\n            else break;\n        }\n        while(!b.empty()){\n            if(b.top().S<low-d)b.pop();\n            else break;\n        }\n        ans=max(ans,(long long int)(u.top().F-b.top().F)*(r.top().F-l.top().F));\n        low=pq.top().light;\n    }\n    printf(\"%lld\\n\",ans);\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\npair<int,int> c[210000];\nint x[210000];\nint y[210000];\nint d[210000];\nint segtree[524288][4];\nint query(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c){\n\t\tif(f%2)return 0;\n\t\treturn 999999999;\n\t}\n\tif(c<=a&&b<=d){\n\t\treturn segtree[e][f];\n\t}\n\tif(f%2)return max(query(a,(a+b)/2,c,d,e*2,f),query((a+b)/2+1,b,c,d,e*2+1,f));\n\treturn min(query(a,(a+b)/2,c,d,e*2,f),query((a+b)/2+1,b,c,d,e*2+1,f));\n}\nvoid update(int a,int b,int c){\n\tb+=262144;\n\twhile(b){\n\t\tif(a%2)segtree[b][a]=max(segtree[b][a],c);\n\t\telse segtree[b][a]=min(segtree[b][a],c);\n\t\tb/=2;\n\t}\n}\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d%d\",x+i,y+i,d+i);\n\t\t//printf(\"%d %d\\n\",x[i],y[i]);\n\t\tc[i]=make_pair(d[i],i);\n\t}\n\tstd::sort(c,c+a);\n\tfor(int i=0;i<524288;i++){\n\t\tsegtree[i][0]=segtree[i][2]=999999999;\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tint t=c[i].second;\n\t\tupdate(0,i,x[t]);\n\t\tupdate(1,i,x[t]);\n\t\tupdate(2,i,y[t]);\n\t\tupdate(3,i,y[t]);\n\t}\n\tlong long ret=0;\n\tfor(int i=0;i<a;i++){\n\t\tint to=c[i].first+b;\n\t\tint at=lower_bound(c,c+a,make_pair(to+1,0))-c-1;\n\t\tint X=query(0,262143,i,at,1,1)-query(0,262143,i,at,1,0);\n\t\tint Y=query(0,262143,i,at,1,3)-query(0,262143,i,at,1,2);\n\t//\tprintf(\"%d %d: %d %d\\n\",i,at,X,Y);\n\t\tret=max(ret,(long long)X*Y);\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define in ,\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct Star {\n  ll x, y, d;\n};\n\nll minX[200001 * 2 - 1] = {}, maxX[200001 * 2 - 1] = {},\nminY[200001 * 2 - 1] = {}, maxY[200001 * 2 - 1] = {};\nll n, nn = 1;\n\nvoid update(ll k, ll a, ll c[]) {\n  k += nn - 1;\n  c[k] = a;\n\n  while(k > 0) {\n    k = (k - 1) / 2;\n    c[k] = min(c[k * 2 + 1], c[k * 2 + 2]);\n  }\n}\n\nll query(ll a, ll b, ll k, ll l, ll r, ll c[]) {\n  if(r <= a || b <= l) return INT_MAX;\n  if(a <= l && r <= b) return c[k];\n\n  ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2, c);\n  ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r, c);\n\n  return min(vl, vr);\n}\n\nbool asc(Star &l, Star &r) {\n  return l.d < r.d;\n}\n\nint main() {\n  ll d, ans = 0;\n  cin >> n >> d;\n  vector<Star> v(n);\n\n  while(nn < n) nn *= 2;\n\n  rep(i, 0, nn * 2 - 1) {\n    minX[i] = INT_MAX;\n    minY[i] = INT_MAX;\n    maxX[i] = INT_MAX;\n    minX[i] = INT_MAX;\n  }\n\n  rep(i, 0, n) cin >> v[i].x >> v[i].y >> v[i].d;\n\n  sort(v.begin(), v.end(), asc);\n  rep(i, 0, n) {\n    update(i, v[i].x * -1, maxX);\n    update(i, v[i].x, minX);\n    update(i, v[i].y * -1, maxY);\n    update(i, v[i].y, minY);\n  }\n\n  // rep(i, 0, n) cout << v[i].x << \" \" << v[i].y << \" \" << v[i].d << endl;;\n\n  // rep(i, 0, nn * 2 - 1) cout << minX[i] << endl;\n\n  ll ld = v[0].d, lp = 0;\n  rep(i, 1, n) {\n    if(v[i].d - ld > d) {\n      rep(j, lp, i + 1) {\n        if(v[i].d - v[j].d <= d) {\n          lp = j;\n          ld = v[lp].d;\n          break;\n        }\n      }\n    }\n    ll hx = query(lp, i + 1, 0, 0, nn, maxX) * -1;\n    ll lx = query(lp, i + 1, 0, 0, nn, minX);\n    ll hy = query(lp, i + 1, 0, 0, nn, maxY) * -1;\n    ll ly = query(lp, i + 1, 0, 0, nn, minY);\n    if(lp != i) ans = max(ans, ((hx - lx) * (ll)(hy - ly)));\n    // cout << lp << \" \" << i << endl;\n    // cout << hx << \" \" << lx << \" \" << hy << \" \" << ly << endl;\n    // cout << ans << endl;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 0302.cc: Star Watching\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 200000;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef long long ll;\n\ntemplate <typename T, const int BUFSIZE>\nstruct Treap {\n  struct Node {\n    T key, minkey, maxkey;\n    int fix, size, cnt;\n    Node *left, *right;\n\n    void print(int k) {\n      printf(\"%d: key=%lld, minkey=%lld, maxkey=%lld, fix=%d, size=%d\\n\",\n\t     k, key, minkey, maxkey, fix, size);\n    }\n    void print() { print(0); }\n  };\n  typedef Node *node;\n\n  node root, nullnode, buf;\n  Node buf0[BUFSIZE], buf1;\n\n  const T TINF;\n  \n  Treap(T tinf): TINF(tinf) {\n    nullnode = &buf1;\n    nullnode->left = nullnode->right = nullnode;\n    nullnode->key = nullnode->minkey = TINF;\n    nullnode->maxkey = 0;\n    nullnode->fix = nullnode->size = nullnode->cnt = 0;\n    clear();\n    srand(time(NULL));\n  }\n\n  void clear() { buf = buf0; root = nullnode; }\n  \n  int size() { return root->size; }\n\n  void update(node& t) {\n    t->size = 1 + t->left->size + t->right->size;\n    t->minkey = t->maxkey = t->key;\n    if (t->minkey > t->left->minkey) t->minkey = t->left->minkey;\n    if (t->minkey > t->right->minkey) t->minkey = t->right->minkey;\n    if (t->maxkey < t->left->maxkey) t->maxkey = t->left->maxkey;\n    if (t->maxkey < t->right->maxkey) t->maxkey = t->right->maxkey;\n  }\n\n  node gen_node(T x) {\n    node t = buf++;\n    t->left = t->right = nullnode;\n    t->key = t->minkey = t->maxkey = x;\n    t->fix = rand();\n    t->size = t->cnt = 1;\n    return t;\n  }\n  \n  void rot_l(node& k1) {\n    node k2 = k1->right;\n    k1->right = k2->left;\n    k2->left = k1;\n    update(k1);\n    update(k2);\n    k1 = k2;\n  }\n\n  void rot_r(node& k1) {\n    node k2 = k1->left;\n    k1->left = k2->right;\n    k2->right = k1;\n    update(k1);\n    update(k2);\n    k1 = k2;\n  }\n\n  void insert(node& t, T x) {\n    if (t == nullnode)\n      t = gen_node(x);\n    else {\n      if (t->key == x) {\n\tt->cnt++;\n\treturn;\n      }\n      if (x < t->key) {\n\tinsert(t->left, x);\n\tupdate(t);\n\tif (t->left->fix > t->fix) rot_r(t);\n      }\n      else {\n\tinsert(t->right, x);\n\tupdate(t);\n\tif (t->right->fix > t->fix) rot_l(t);\n      }\n    }\n  }\n  void insert(T x) { insert(root, x); }\n\n  void remove_node(node& t) {\n    if (t == nullnode) return;\n    if (t->left == nullnode || t->right == nullnode) {\n      if (t->left == nullnode)\n\tt = t->right;\n      else\n\tt = t->left;\n    }\n    else {\n      if (t->left->fix < t->right->fix) {\n\trot_l(t);\n\tremove_node(t->left);\n\tupdate(t);\n      }\n      else {\n\trot_r(t);\n\tremove_node(t->right);\n\tupdate(t);\n      }\n    }\n  }\n\n  void remove(node& t, T x) {\n    if (t != nullnode) {\n      if (t->key == x) {\n\tif (--t->cnt <= 0) remove_node(t);\n      }\n      else if (x < t->key) {\n\tremove(t->left, x);\n\tupdate(t);\n      }\n      else {\n\tremove(t->right, x);\n\tupdate(t);\n      }\n    }\n  }\n  void remove(T x) { remove(root, x); }\n\n  void print(node t, int k, int indent) {\n    if (t == nullnode) return;\n    if (t != NULL) {\n      for (int i = 0; i < indent; i++) cout << \"  \";\n      t->print(k + t->left->size);\n      print(t->left, k, indent + 1);\n      print(t->right, k + t->left->size + 1, indent + 1);\n    }\n  }\n  void print() { print(root, 0, 0); }\n};\n\nstruct Star {\n  int x, y, b;\n  Star() {}\n  Star(int _x, int _y, int _b): x(_x), y(_y), b(_b) {}\n  bool operator<(const Star &s) const { return b < s.b; }\n  void print() { printf(\"(%d,%d):%d\\n\", x, y, b); }\n};\n\n/* global variables */\n\nTreap<int,MAX_N> xtrp(INF), ytrp(INF);\nStar sts[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n, d;\n  cin >> n >> d;\n\n  for (int i = 0; i < n; i++)\n    cin >> sts[i].x >> sts[i].y >> sts[i].b;\n  sort(sts, sts + n);\n  //for (int i = 0; i < n; i++) printf(\"%d: \", i), sts[i].print();\n  \n  ll maxar = 0;\n\n  for (int i = 0, j = 0; j < n;) {\n    int maxb = sts[i].b + d;\n    while (j < n && sts[j].b <= maxb) {\n      xtrp.insert(sts[j].x);\n      ytrp.insert(sts[j].y);\n      j++;\n    }\n\n    int minx = xtrp.root->minkey;\n    int maxx = xtrp.root->maxkey;\n    int miny = ytrp.root->minkey;\n    int maxy = ytrp.root->maxkey;\n\n    ll ar = (ll)(maxx - minx) * (maxy - miny);\n    if (maxar < ar) maxar = ar;\n    //printf(\"i=%d,j=%d: (%d-%d)*(%d-%d) ar=%d\\n\",\n    //i, j, minx, maxx, miny, maxy, ar);\n\n    for (int pb = sts[i].b; i < n && pb == sts[i].b; i++) {\n      xtrp.remove(sts[i].x);\n      ytrp.remove(sts[i].y);\n    }\n  }\n\n  printf(\"%lld\\n\", maxar);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define int long long int\n#define rep(a,b,c) for(int a=b;a<c;a++)\n#define repm(a,b,c) for(int a=(b-1);a>=c;a--)\n#define pb push_back\n#define str string\n#define sf(a) scanfs(\"%d\",&a)\n#define pb push_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n#define clean(used) memset(used,false,sizeof(used))\nusing namespace std;\n\nstatic const int INF = 1e18 + 9;\nstatic const int Mod = 1e9 + 7;\ninline int replac(str s){double ans=0;rep(i,0,s.length()){ans+=(s[i]-'0')*pow(10,s.length()-i-1);}return (int)ans;}\ninline string numstr(int m){str s=\"\";while(m>0){char c;int a=m/10;if(a>0)a=m%(a*10);else a=m;c=(char)('0'+a);s+=c;m/=10;}str st=\"\";for(int i=s.size()-1;i>=0;i--){st+=s[i];}return st;}\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\n\nstatic const int MAX_N = 200002;\n\nstruct Seg{\n    int n;\n    int dat[MAX_N * 2];\n    void init(int n_){\n        init(n_ , INF);\n    }\n\n    void init(int n_, int d){\n        n = 1;\n        while(n < n_)n *= 2;\n        fill(dat, dat + MAX_N * 2, d);\n    }\n};\n\nstruct SegMin : Seg {\n    int Min(int s,int t){\n        return Min(s,t,0,0,n);\n    }\n    int Min(int s, int t, int k, int l, int r){\n        if(r <= s || t <= l) return INF;\n        if(s <= l && r <= t) return dat[k];\n\n        int t1 = Min(s, t, k * 2 + 1, l, (l + r)/2);\n        int t2 = Min(s, t, k * 2 + 2, (l + r)/2, r);\n        return min(t1, t2);\n    }\n    void update(int k, int x){\n        k += n - 1;\n        dat[k] = min(dat[k], x);\n        while(0 < k){\n            k = (k - 1)/2;\n            dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n};\n\nSegMin x1,x2,y1,y2;\nvector<pii> a[200005];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int d,m;\n    cin >> m >> d;\n    x1.init(m);\n    x2.init(m);\n    y1.init(m);\n    y2.init(m);\n    int b_max = 0;\n    int x,y,b;\n    rep(i,0,m){\n        cin >> x >> y >> b;\n        x1.update(b,x);\n        x2.update(b,-x);\n        y1.update(b,y);\n        y2.update(b,-y);\n    }\n    int ans = 0,x_mi,x_ma,y_mi,y_ma;\n    rep(i,0,MAX_N){\n        x_mi = x1.Min(i,i+d+1);\n        x_ma = x2.Min(i,i+d+1);\n        y_mi = y1.Min(i,i+d+1);\n        y_ma = y2.Min(i,i+d+1);\n        //cout << i << \" ~ \" << i+d << endl;\n        //cout << x_mi << \" \" << x_ma << \" \" << y_mi << \" \" << y_ma << endl;\n        //cout << abs(x_ma+x_mi)*abs(y_ma-y_mi) << endl;\n        ans = max(ans, abs(x_ma+x_mi)*abs(y_ma+y_mi));\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        (wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nstruct star {\n\tint x, y, b;\n\n\tbool operator <(const star &s)const {\n\t\treturn b < s.b;\n\t}\n};\n\nbool calc(const star &a,const star &b) {\n\treturn a.b < b.b;\n}\n\n\nint n, d;\nvector<star> stars;\n\nstruct SegmentTreeMax {\nprivate:\n\tint n;\n\tvector<LL> node;\npublic:\n\tSegmentTreeMax(vector<LL> v) {\n\t\tint sz = v.size();\n\t\tn = 1; while (n < sz) n *= 2;\n\t\tnode.resize(2 * n - 1,0);\n\t\tfor (int i = 0; i<sz; i++) node[i + n - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--) node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n\t}\n\n\tvoid update(int x, int val) {\n\t\tx += (n - 1);\n\t\tnode[x] = val;\n\t\twhile (x > 0) {\n\t\t\tx = (x - 1) / 2;\n\t\t\tnode[x] = max(node[2 * x + 1], node[2 * x + 2]);\n\t\t}\n\t}\n\t//[a,b)の最大値を求める\n\tLL getmax(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0) r = n;\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return node[k];\n\n\t\tLL vl = getmax(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tLL vr = getmax(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n};\n\nstruct SegmentTreeMin {\nprivate:\n\tint n;\n\tvector<LL> node;\npublic:\n\tSegmentTreeMin(vector<LL> v) {\n\t\tint sz = v.size();\n\t\tn = 1; while (n < sz) n *= 2;\n\t\tnode.resize(2 * n - 1, HINF<LL>());\n\t\tfor (int i = 0; i<sz; i++) node[i + n - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--) node[i] = min(node[2 * i + 1], node[2 * i + 2]);\n\t}\n\n\tvoid update(int x, int val) {\n\t\tx += (n - 1);\n\t\tnode[x] = val;\n\t\twhile (x > 0) {\n\t\t\tx = (x - 1) / 2;\n\t\t\tnode[x] = min(node[2 * x + 1], node[2 * x + 2]);\n\t\t}\n\t}\n\t//[a,b)の最小値を求める\n\tLL getmin(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0) r = n;\n\t\tif (r <= a || b <= l) return HINF<LL>();\n\t\tif (a <= l && r <= b) return node[k];\n\n\t\tLL vl = getmin(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tLL vr = getmin(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n\tvoid get() {\n\t\tREP(i, node.size()) {\n\t\t\tcout << node[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n};\n\n\nint main() {\n\tcin >> n >> d;\n\tREP(i, n) {\n\t\tstar s;\n\t\tcin >> s.x >> s.y >> s.b;\n\t\tstars.emplace_back(s);\n\t}\n\tsort(ALL(stars));\n\tvector<LL> xx, yy, bb;\n\tREP(i, n) {\n\t\txx.emplace_back(stars[i].x);\n\t\tyy.emplace_back(stars[i].y);\n\t\tbb.emplace_back(stars[i].b);\n\t}\n\tSegmentTreeMax xmax(xx), ymax(yy);\n\tSegmentTreeMin xmin(xx), ymin(yy);\n\t\n\tLL ans = 0LL;\n\tREP(i, n) {\n\t\tint l = i;\n\t\tint r = upper_bound(ALL(bb), bb[i] + d) - 1 - bb.begin();\n\t\t//cout << l << \" \" << r << \" \" << xmax.getmax(l, r + 1) <<\" \"<< xmin.getmin(l, r + 1)<<\" \"<<ymax.getmax(l, r + 1)<< \" \"<< ymin.getmin(l, r + 1) << endl;\n\t\tans = max(ans, (xmax.getmax(l, r + 1) - xmin.getmin(l, r + 1))*(ymax.getmax(l, r + 1) - ymin.getmin(l, r + 1)));\n\t}\n\t//system(\"pause\");\n\tcout << ans << endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef pair <int,int> P;\n#define f first\n#define s second\nint tree[4][(1<<19)];\nint n,d;\npair <int,pair <int,int> > star[(1<<18)];\n\nvoid update(int i,int x,int flg){\n  i = (1<<18)+i-1;\n  tree[flg][i] = x;\n  while(i){\n    i = (i-1)/2;\n    tree[flg][i] = max(x,tree[flg][i]);\n  }\n}\n\nint find(int a,int b,int M,int L,int R,int flg){\n  if(b <=L || a >= R) return 0;\n  if(a <=L && R <= b) return tree[flg][M];\n  int nx = (L+R)/2;\n  return max(find(a,b,M*2+1,L,nx,flg),find(a,b,M*2+2,nx,R,flg));\n}\n\nint main() {\n  cin >> n >> d;\n  for(int i=0;i<n;i++) cin >> star[i].s.f >> star[i].s.s >> star[i].f;\n  sort(star,star+n);\n  for(int i=0;i<n;i++) {\n    update(i,star[i].s.f,0); // max(x);\n    update(i,star[i].s.s,1);   // max(y);\n    update(i,-star[i].s.f,2);   // min(x);\n    update(i,-star[i].s.s,3);   // min(y);\n  }\n\n  int now = 0,minx,maxx,miny,maxy,S=0;\n  for(int i=0;i<n;i++) {\n    while(now != n && star[now].f -star[i].f <=d) now++;\n    now--;\n    maxx = find(i,now,0,0,(1<<18),0);\n    maxy = find(i,now,0,0,(1<<18),1);\n    minx = find(i,now,0,0,(1<<18),2);\n    miny = find(i,now,0,0,(1<<18),3);\n    S = max(S,(maxx+minx)*(maxy+miny));\n  }\n  cout << S <<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\nint n, d, size_, dat[2][2][266666];//[xy][minmax][pos]\ntuple<int, int, int>x[266666];\ninline void init(int n) {\n\tfor (size_ = 1; size_ < n;) size_ *= 2;\n\tfor (int i = 0; i < 2; i++) { for (int j = 0; j < 266666; j++) { dat[i][0][j] = 1 << 30; dat[i][1][j] = -(1 << 30); } }\n}\ninline void update(int pos, int x, int p1) {\n\tpos += size_; dat[p1][0][pos] = x; dat[p1][1][pos] = x;\n\twhile (pos != 1) {\n\t\tpos >>= 1;\n\t\tdat[p1][0][pos] = min(dat[p1][0][pos * 2], dat[p1][0][pos * 2 + 1]);\n\t\tdat[p1][1][pos] = max(dat[p1][1][pos * 2], dat[p1][1][pos * 2 + 1]);\n\t}\n}\ninline int query(int a, int b, int k, int l, int r, int p1, int p2) {\n\tif (r <= a || b <= l) { if (p2 == 0)return 1 << 30; return -(1 << 30); }\n\tif (a <= l && r <= b) return dat[p1][p2][k]; k <<= 1;\n\tint lc = query(a, b, k, l, (l + r) / 2, p1, p2);\n\tint rc = query(a, b, k + 1, (l + r) / 2, r, p1, p2);\n\tif (p2 == 0)return min(lc, rc);\n\tif (p2 == 1)return max(rc, lc);\n}\ninline int rmqw(int x, int y, int p) {\n\tint V1 = query(x, y + 1, 1, 0, size_, p, 1), V2 = query(x, y + 1, 1, 0, size_, p, 0);\n\treturn V1 - V2;\n}\nint main() {\n\tcin >> n >> d; init(n); for (int i = 1; i <= n; i++) { cin >> get<1>(x[i]) >> get<2>(x[i]) >> get<0>(x[i]); }\n\tsort(x + 1, x + n + 1); long long maxn = 0;\n\tfor (int i = 1; i <= n; i++) { update(i, get<1>(x[i]), 0); update(i, get<2>(x[i]), 1); }\n\tfor (int i = 1; i <= n; i++) {\n\t\tint R = lower_bound(x + 1, x + n + 1, make_tuple(get<0>(x[i]) + d, 1 << 30, 1 << 30)) - x; R--;\n\t\tmaxn = max(maxn, 1LL*rmqw(i, R, 0)*rmqw(i, R, 1));\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\n\nstruct st { int x, y, b; }s[200000];\nint main() {\n\tint n, d; scanf(\"%d%d\", &n, &d);\n\trep(i, n)scanf(\"%d%d%d\", &s[i].x, &s[i].y, &s[i].b);\n\tsort(s, s + n, [](st a, st b) {return a.b < b.b; });\n\tmultiset<int>x, y;\n\tint t = 0;\n\tll Max = 0;\n\trep(i, n) {\n\t\twhile (s[i].b - s[t].b > d) {\n\t\t\tx.erase(x.find(s[t].x));y.erase(y.find(s[t].y));\n\t\t\tt++;\n\t\t}\n\t\tx.insert(s[i].x); y.insert(s[i].y);\n\t\tMax = max(Max, ll(*x.rbegin() - *x.begin())*(*y.rbegin() - *y.begin()));\n\t}\n\tprintf(\"%lld\\n\", Max);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\nusing namespace std;\n\n\npair<pair<int, int>, int> star[200000];\n\n\nvoid clear(vector<int>& v){\n\tvector<int> emp;\n\tswap(v, emp);\n}\n\n\nint main(){\n\tint n;\n\tint d;\n\n\tcin >> n >> d;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> star[i].first.first >> star[i].first.second >> star[i].second;\n\t}\n\n\tsort(star, star+n, [](pair<pair<int, int>, int> p1, pair<pair<int, int>, int> p2){\n\t\treturn (p1.second < p2.second);\n\t});\n\n\tfor(int i = 0;i < n;i++) cout << star[i].first.first << ' ' << star[i].first.second << ' ' << star[i].second << endl;\n\n\tvector<int> xlist, ylist;\n\tint ans = 0;\n\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;star[j+i].second <= star[i].second + d;j++){\n\t\t\txlist.push_back(star[j+i].first.first);\n\t\t\tylist.push_back(star[j+i].first.second);\n\t\t}\n\t\tint x, y;\n\t\tx = ((*max_element(xlist.begin(), xlist.end())) - (*min_element(xlist.begin(), xlist.end())));\n\t\ty = ((*max_element(ylist.begin(), ylist.end())) - (*min_element(ylist.begin(), ylist.end())));\n\t\tans = max(x*y, ans);\n\t\tclear(xlist);\n\t\tclear(ylist);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//{{{ seg.hpp\n#ifndef INCLUDE_SEG_HPP\n#define INCLUDE_SEG_HPP\n#include <functional>\n#include <algorithm>\n#include <iterator>\nnamespace orislib {\nnamespace ds {\nconstexpr int uprt(int k, int i=1){\n  return i < k ? uprt(k, i + i) : i;\n}\n//{{{ SegT<T, S> update, query\ntemplate<typename T, int S>\nstruct SegT {\n  typedef T seg_t;\n  const seg_t OUT;\n  static const int N = uprt(S);\n  seg_t data[N * 2];\n  std::function<seg_t(seg_t,seg_t)>ufunc;\n  template<typename F>\n  SegT(T initial, F f):OUT(initial),ufunc(f){std::fill(std::begin(data), std::end(data), initial);}\n  void update(int x, seg_t v){\n    for (data[x+=N-1]=v;x;data[x]=ufunc(data[x+x+1],data[x+x+2]))x=x-1>>1;\n  }\n  void add(int x,seg_t a){ update(x,data[x+N-1]+a); }\n  seg_t query(int a=0,int b=N,int x=0,int l=0,int r=N){\n    if (r<=a||b<=l) return OUT;\n    if (a<=l&&r<=b) return data[x];\n    return ufunc(query(a,b,x+x+1,l,l+r>>1),query(a,b,x+x+2,l+r>>1,r));\n  }\n};\n//}}}\n}\n}\n#endif\n//}}}\n\nusing namespace std;\nusing namespace orislib::ds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\n\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_ template<typename T>inline\n#define TTF_ template<typename T,typename F>inline\nTT_ T sq(T x){return x*x;}\nTT_ T In(){T x;cin>>x;return x;}\nTT_ void Out(T&x){cout<<x;}\nTT_ void sort(T&v){sort(begin(v),end(v));}\nTT_ void revs(T&v){reverse(begin(v),end(v));}\nTT_ void uniq(T&v){sort(v);v.erase(unique(begin(v),end(v)),end(v));}\nTT_ int ubnd(T&v,typename T::value_type x){return upper_bound(begin(v),end(v),x)-begin(v);}\nTT_ int lbnd(T&v,typename T::value_type x){return lower_bound(begin(v),end(v),x)-begin(v);}\nTTF_ void inpt(T&v,int n,F f){for(v.reserve(n);n--;v.emplace_back(f()));}\nTTF_ void show(T&v,F f,string d=\" \",string e=\"\\n\"){int i=0;for(auto&x:v)i++&&(cout<<d),f(x);cout<<e;}\nTT_ typename T::iterator minel(T&v){return min_element(begin(v),end(v));}\nTT_ typename T::iterator maxel(T&v){return max_element(begin(v),end(v));}\n\ninline void fast_io(){ios_base::sync_with_stdio(0);cin.tie(0);}\ninline int in(){int x;scanf(\"%d\",&x);return x;}\ninline ll pow_mod(ll a,ll k,ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\ninline ll mod_inv(ll a,ll p){return pow_mod(a,p-2,p);}\n//}}} priority_queue queue deque front stringstream max_element min_element insert count make_tuple\n\n#define int long long\n\nstruct Star {\n  int x, y, b;\n  Star(int x, int y, int b) : x(x), y(y), b(b) {}\n  bool operator<(const Star& x) const {\n    return b < x.b;\n  }\n};\n\nSegT<int, 200200> xmax(INT_MIN, [](int a, int b){ return max(a, b); });\nSegT<int, 200200> xmin(INT_MAX, [](int a, int b){ return min(a, b); });\nSegT<int, 200200> ymax(INT_MIN, [](int a, int b){ return max(a, b); });\nSegT<int, 200200> ymin(INT_MAX, [](int a, int b){ return min(a, b); });\n\nsigned main()\n{\n\n  int N = in();\n  int d = in();\n  vector<Star> vs;\n  for (int i = 0; i < N; i++){\n    int x = in();\n    int y = in();\n    int b = in();\n    vs.emplace_back(x, y, b);\n  }\n  sort(vs);\n  for (int i = 0; i < N; i++){\n    xmin.update(i, vs[i].x);\n    xmax.update(i, vs[i].x);\n    ymin.update(i, vs[i].y);\n    ymax.update(i, vs[i].y);\n  }\n\n  int maxi = 0;\n  for (int i = 0; i < N; i++){\n    int t = ubnd(vs, Star(0, 0, vs[i].b + d));\n    int xmini = xmin.query(i, t);\n    int xmaxi = xmax.query(i, t);\n    int ymini = ymin.query(i, t);\n    int ymaxi = ymax.query(i, t);\n    maxi = max(maxi, abs(xmaxi - xmini) * abs(ymaxi - ymini));\n  }\n  cout << maxi << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int LL\ntypedef long long LL;\nconst int INF = 2002002002;\n\nstruct DATA {\n\tint minx, miny, maxx, maxy;\n};\n\nstruct STAR {\n\tint x, y, b;\n\tbool operator < (const STAR &t) const {\n\t\treturn b < t.b;\n\t}\n};\n\nint n, d;\nSTAR star[1 << 19];\n\nint N;\nDATA data[1 << 20];\n\n\nvoid init(int n)\n{\n\tfor (N = 1; N < n; N <<= 1);\n\tfill(data, data + (1 << 20), (DATA){INF, INF, -INF, -INF});\n}\n\nvoid update(int i, STAR s)\n{\n\ti += N - 1;\n\tdata[i] = (DATA){s.x, s.y, s.x, s.y};\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tdata[i].minx = min(data[i * 2 + 1].minx, data[i * 2 + 2].minx);\n\t\tdata[i].miny = min(data[i * 2 + 1].miny, data[i * 2 + 2].miny);\n\t\tdata[i].maxx = max(data[i * 2 + 1].maxx, data[i * 2 + 2].maxx);\n\t\tdata[i].maxy = max(data[i * 2 + 1].maxy, data[i * 2 + 2].maxy);\n\t}\n}\n\nDATA query(int a, int b, int k, int l, int r)\n{\n\t//printf(\"%d %d %d %d %d\\n\", a, b, k, l, r);\n\tif (r <= a || b <= l) return (DATA){INF, INF, -INF, -INF};\n\tif (a <= l && r <= b) return data[k];\n\tDATA vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tDATA vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn (DATA){min(vl.minx, vr.minx), min(vl.miny, vr.miny), max(vl.maxx, vr.maxx), max(vl.maxy, vr.maxy)};\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tinit(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d %d\", &star[i].x, &star[i].y, &star[i].b);\n\t\tstar[i].x; star[i].y;\n\t}\n\tfor (int i = n; i < 1 << 19; i++){\n\t\tstar[i].b = INF;\n\t}\n\t\n\tsort(star, star + n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tupdate(i, star[i]);\n\t}\n\t\n\t//printf(\"%lld\\n\", (LL)INF * INF);\n\t\n\tLL res = 0;\n\tfor (int l = 0; star[l].b != INF; ){\n\t\tint r = l;\n\t\twhile (star[r].b - star[l].b <= d) r++;\n\t\t\n\t\tDATA q = query(l, r, 0, 0, N);\n\t\tLL t = (LL)(q.maxx - q.minx) * (q.maxy - q.miny);\n\t\tres = max(res, t);\n\t\t\n\t\tl++;\n\t\twhile (star[l + 1].b == star[l].b) l++;\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,a,n) for(int i=a; i<n; i++)\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\n\n#define MAX_N 200010\n#define INF 2000000000\n\nvector<pair<ll, pair<ll, ll> > > st;\nll seg_mi[MAX_N * 2],seg_mx[MAX_N*2];\nll n, d;\n\nstruct RMQ\n{\n\tvoid update(ll k, ll x)\n\t{\n\t\tk += n - 1;\n\t\tseg_mi[k] = x;\n\t\tseg_mx[k] = x;\n\t\twhile (k)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\tseg_mi[k] = min(seg_mi[k * 2 + 1], seg_mi[k * 2 + 2]);\n\t\t\tseg_mx[k] = max(seg_mx[k * 2 + 1], seg_mx[k * 2 + 2]);\n\t\t}\n\t}\n\n\tll query1(ll a, ll b, ll k, ll l, ll r)\n\t{\n\t\tif (r <= a || b <= l)return INF;\n\t\telse if (a <= l && r <= b) return seg_mi[k];\n\t\telse return min(query1(a, b, k * 2 + 1, l, (l + r) / 2), query1(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\n\tll query2(ll a, ll b, ll k, ll l, ll r)\n\t{\n\t\tif (r <= a || b <= l)return INF;\n\t\telse if (a <= l && r <= b) return seg_mx[k];\n\t\telse return max(query2(a, b, k * 2 + 1, l, (l + r) / 2), query2(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n};\n\n\nint main()\n{\n\tRMQ seg_mi_x,seg_mx_x,seg_mi_y,seg_mx_y;\n\n\tcin >> n >> d;\n\tst.resize(n);\n\n\trep(i, n) {\n\t\tcin >> st[i].second.first >> st[i].second.second >> st[i].first;\n\t\tseg_mi_x.update(i,st[i].second.first);\n\t\tseg_mx_x.update(i,st[i].second.first);\n\t\tseg_mi_y.update(i, st[i].second.second);\n\t\tseg_mx_y.update(i, st[i].second.second);\n\t}\n\n\tsort(st.begin(), st.end());\n\n\tll ans = 0;\n\tfor (int left = 0, right = 1; ;) {\n\t\tif (abs(st[left].first - st[right].first) <= d) {\n\t\t\tll x = seg_mx_x.query2(0,n,left,left,right)-\n\t\t\t\tseg_mi_x.query1(0,n,left,left,right);\n\t\t\tll y = seg_mx_y.query2(0, n, left, left, right) -\n\t\t\t\tseg_mi_y.query1(0, n, left, left, right);\n\t\t\tans = max(ans, x*y);\n\t\t\tright++;\n\t\t}\n\t\telse {\n\t\t\tleft++;\n\t\t}\n\t\tif (left >= n || right >= n)break;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nlong min(long a, long b)\n{\n    return a < b ? a : b;\n}\n\nlong max(long a, long b)\n{\n    return a > b ? a : b;\n}\n\nstruct Star\n{\n    long x, y, b;\npublic:\n    Star(long x, long y, long b): x(x), y(y), b(b) {}\n    bool operator<(const Star& s)\n    {\n        return b < s.b;\n    }\n};\n\nstruct Range\n{\n    long x1, y1, x2, y2, b;\npublic:\n    Range(const Star& s): x1(s.x), y1(s.y), x2(s.x), y2(s.y), b(s.b) {}\n    void add(const Star& s)\n    {\n        x1 = min(x1, s.x);\n        y1 = min(y1, s.y);\n        x2 = max(x2, s.x);\n        y2 = max(y2, s.y);\n    }\n    void add(const Range& r)\n    {\n        x1 = min(x1, r.x1);\n        y1 = min(y1, r.y1);\n        x2 = max(x2, r.x2);\n        y2 = max(y2, r.y2);\n    }\n    long area()\n    {\n        return (x2 - x1) * (y2 - y1);\n    }\n};\n\nint main(int argc, const char *argv[])\n{\n    long N, d;\n    scanf(\"%ld %ld\", &N, &d);\n\n    std::vector<Star> stars;\n    stars.reserve(200000);\n    for (long i = 0; i < N; i++)\n    {\n        long x, y, b;\n        scanf(\"%ld %ld %ld\", &x, &y, &b);\n        stars.push_back(Star(x, y, b));\n    }\n    std::sort(stars.begin(), stars.end());\n\n    std::vector<Range> ranges;\n    ranges.push_back(Range(stars[0]));\n    for (long i = 1; i < N; i++)\n    {\n        int cur_b = ranges.back().b;\n        if (cur_b == stars[i].b)\n        {\n            ranges.back().add(stars[i]);\n        }\n        else\n        {\n            ranges.push_back(Range(stars[i]));\n        }\n    }\n\n    long max_area = 0;\n\n    for (long i = 0; i < ranges.size(); i++)\n    {\n        Range range = ranges[i];\n\n        for (long j = i; ranges[j].b - ranges[i].b <= d && j < ranges.size(); j++)\n        {\n            range.add(ranges[j]);\n        }\n\n        max_area = max(range.area(), max_area);\n    }\n\n    printf(\"%ld\\n\", max_area);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int LL\ntypedef long long LL;\nconst int INF = 2002002002;\n\nstruct DATA {\n\tint minx, miny, maxx, maxy;\n};\n\nstruct STAR {\n\tint x, y, b;\n\tbool operator < (const STAR &t) const {\n\t\treturn b < t.b;\n\t}\n};\n\nint n, d;\nSTAR star[1 << 19];\n\nint N;\nDATA data[1 << 20];\n\n\nvoid init(int n)\n{\n\tfor (N = 1; N < n; N <<= 1);\n\tfill(data, data + (1 << 20), (DATA){INF, INF, -INF, -INF});\n}\n\nvoid update(int i, STAR s)\n{\n\ti += N - 1;\n\tdata[i] = (DATA){s.x, s.y, s.x, s.y};\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tdata[i].minx = min(data[i * 2 + 1].minx, data[i * 2 + 2].minx);\n\t\tdata[i].miny = min(data[i * 2 + 1].miny, data[i * 2 + 2].miny);\n\t\tdata[i].maxx = max(data[i * 2 + 1].maxx, data[i * 2 + 2].maxx);\n\t\tdata[i].maxy = max(data[i * 2 + 1].maxy, data[i * 2 + 2].maxy);\n\t}\n}\n\nDATA query(int a, int b, int k, int l, int r)\n{\n\t//printf(\"%d %d %d %d %d\\n\", a, b, k, l, r);\n\tif (r <= a || b <= l) return (DATA){INF, INF, -INF, -INF};\n\tif (a <= l && r <= b) return data[k];\n\tDATA vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tDATA vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn (DATA){min(vl.minx, vr.minx), min(vl.miny, vr.miny), max(vl.maxx, vr.maxx), max(vl.maxy, vr.maxy)};\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tinit(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lld %lld %lld\", &star[i].x, &star[i].y, &star[i].b);\n\t\t//star[i].x; star[i].y;\n\t}\n\tfor (int i = n; i < 1 << 19; i++){\n\t\tstar[i].b = INF;\n\t}\n\t\n\tsort(star, star + n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tupdate(i, star[i]);\n\t}\n\t\n\t//printf(\"%lld\\n\", (LL)INF * INF);\n\t\n\tint pr = 0;\n\tLL res = 0;\n\tfor (int l = 0; star[l].b != INF; ){\n\t\tint r = l;\n\t\twhile (star[r].b - star[l].b <= d) r++;\n\t\tif (r == pr){\n\t\t\tl++;\n\t\t\tcontinue;\n\t\t}\n\t\tpr = r;\n\t\t\n\t\tDATA q = query(l, r, 0, 0, N);\n\t\tLL t = (LL)(q.maxx - q.minx) * (q.maxy - q.miny);\n\t\tres = max(res, t);\n\t\t\n\t\tdo {\n\t\t\tl++;\n\t\t} while (star[l - 1].b == star[l].b);\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint N,b;\nint maxx,maxy,maxs,kma,kmi,ks;\nstruct DATA{\n\tint x,y,b;\n};\nDATA data[200000];\n\nint main(){\n\tcin>>N>>b;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>data[i].x>>data[i].y>>data[i].b;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(abs(data[i].b-data[j].b)>=b){\n\t\t\t\t\n\t\t\t\tif(abs(data[i].x-data[j].x)>maxx){maxx=abs(data[i].x-data[j].x);}\n\t\t\t\tif(abs(data[i].y-data[j].y)>maxx){maxy=abs(data[i].y-data[j].y);}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<maxx*maxy<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1<<30)\n#define MAX_N 200000\ntypedef long long ll;\n\nstruct MinSegtree\n{\n  int n;\n  ll dat[2*MAX_N-1];\n  MinSegtree(int _n)\n  {\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*21;i++)\n      dat[i] = INF;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n\n  ll query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return INF;\n\n    if(a <= l && r <= b) return dat[k];\n    else{\n      ll vl = query(a, b, k*2+1, l, (l + r) / 2);\n      ll vr = query(a, b, k*2+2, (l + r) / 2, r);\n      return min(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nstruct MaxSegtree\n{\n  int n;\n  ll dat[2*MAX_N-1];\n  MaxSegtree(int _n){\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*2-1;i++)\n      dat[i] = -1;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n  \n  ll query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return -1;\n    \n    if(a <= l && r <=b ) return dat[k];\n    else{\n      ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n      ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n      return max(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nMinSegtree minx(MAX_N);\nMinSegtree miny(MAX_N);\nMaxSegtree maxx(MAX_N);\nMaxSegtree maxy(MAX_N);\n\nint main()\n{\n  int n, d;\n  scanf(\"%d%d\", &n, &d);\n  \n  vector<pair<ll, pair<ll, ll> > >s(n);\n  vector<ll>br(n);\n  for(int i=0;i<n;i++){\n    ll x, y; ll b;\n    scanf(\"%d%d%lld\", &x, &y, &b);\n    s[i] = make_pair(b, make_pair(x, y));\n    br[i] = b;\n  }\n  sort(s.begin(), s.end());\n  sort(br.begin(), br.end());\n\n\n  for(int i=0;i<n;i++){\n    minx.update(i, s[i].second.first);\n    maxx.update(i, s[i].second.first);\n    miny.update(i, s[i].second.second);\n    maxy.update(i, s[i].second.second);\n  }\n\n  br.push_back(INF);\n  ll res = 0;\n  for(int i=0;i<n;i++){\n    int pos = (int)(upper_bound(br.begin(), br.end(), br[i] + d) - br.begin());\n    ll w = maxx.query(i, pos, 0, 0, maxx.size()) - minx.query(i, pos, 0, 0, minx.size());\n    ll h = maxy.query(i, pos, 0, 0, maxy.size()) - miny.query(i, pos, 0, 0, miny.size());\n    res = max(res, w * h);\n  }\n\n  printf(\"%lld\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define repp(i,k,n) for(int i=k;i<(int)n;i++)\n#define rei(n) for(int i=0;i<(int)n;i++)\n#define rel(n) for(int l=0;l<(int)n;l++)\n#define int long long\n#define al(s) s.begin(),s.end()\n#define INT_MAX 2147483647\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> ppi;\ntypedef pair<int, ppi> pipp;\ntypedef pair<int, pi> pip;\ntypedef pair<long long, pi> llpi;\n\nstruct SegTree\n{\n\tint N;\n\tvector<int> Seg;\n\tvoid init(int n)\n\t{\n\t\tN = 1;\n\t\twhile (N < n)N *= 2;\n\t\tfor (int i = 0; i < N*2; i++)\n\t\t{\n\t\t\tSeg.push_back(INT_MAX);\n\t\t}\n\t\t\n\t}\n\t\n\tvoid update(int k, int a)\n\t{\t\n\t\tk = k - 1 + N;\n\t\tSeg[k] = a;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\tSeg[k] = min(Seg[2 * k + 1], Seg[2 * k + 2]);\n\t\t}\n\t}\n\tint find_min(int a, int b)\n\t{\n\t\treturn query(a, b, 0, 0, N);\n\t}\n\n\tint query(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || l >= b)return INT_MAX;\n\t\tif (l>=a&&r<=b)\n\t\t{\n\t\t\treturn Seg[k];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn min(query(a, b, k * 2 + 1, l, (r + l) / 2),\n\t\t\t\t\t   query(a, b, k * 2 + 2, (r + l) / 2, r));\n\t\t}\n\t}\n};\n\nSegTree ss[4];//min,max\n\nvector<llpi> a;\n//set<long long> s;\nvector<long long >s;\nsigned main()\n{\n\tlong long ans = 0;\n\tlong long n, d;\n\tcin >> n >> d;\n\trei(4)ss[i].init(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlong long b;\n\t\tint x, y;\n\t\tcin >> x >> y >> b;\n\t\ta.push_back(llpi(b, pi(x, y)));\n\t\ts.push_back(b);\n\t}\n\tsort(al(s));\n\tfor (vector<long long>::iterator i=s.begin()+1; i !=s.end(); )\n\t{\n\t\tif (*i == *(i - 1))\n\t\t{\n\t\t\ti = s.erase(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint jj = 0;\n\t\tvector<long long> ::iterator it = lower_bound(al(s),a[i].first);\n\t\tfor (vector<long long>::iterator l = s.begin(); l != it; l++)\n\t\t{\n\t\t\tjj++;\n\t\t}\n\t\t\n\t\tss[0].update(jj, min(a[i].second.first, ss[0].Seg[jj + ss[0].N - 1]));\n\t\tss[2].update(jj, min(a[i].second.first*(-1), ss[2].Seg[jj + ss[0].N - 1]));\n\n\t\tss[1].update(jj, min(a[i].second.second, ss[1].Seg[jj + ss[0].N - 1]));\n\t\tss[3].update(jj, min(a[i].second.second*(-1), ss[3].Seg[jj + ss[0].N - 1]));\n\n\t}\n\tbool end = false;\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tif(end)break;\n\t\tvector<long long>::iterator it, ne;\n\t\tit = s.begin();\n\t\tfor (int l = 0; l < i; l++)it++;\n\t\tne = upper_bound(al(s),*it + d);\n\t\tif (ne == s.end())end = true;\n\t\tne--;\n\t\tint coun = 0;\n\t\tfor (; it != ne; it++)coun++;\n\t\tcoun += i;\n\t\tcoun++;\n\t\tans = max( ans, ((-1) * ss[2].find_min(i, coun) - ss[0].find_min(i, coun)) * ((-1) * ss[3].find_min(i, coun) - ss[1].find_min(i, coun)) );\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1000000000\n#define f first\n#define s second\nusing namespace std;\ntypedef pair <int,pair <int,int> > P;\ntypedef long long ll;\nint n,d,tree[4][(1<<19)];\nP star[200001];\n\nvoid update(int i,int flg,int x){\n  i = i+(1<<18)-1;\n  tree[flg][i] = x;\n  while(i) {\n    i = (i-1)/2;\n    tree[flg][i] = max(tree[flg][i*2+1],tree[flg][i*2+2]);\n  }\n}\n\nint find(int a,int b,int ima,int L,int R,int flg){\n  if(R<=a || b<=L) return -INF;\n  if(a<=L && R<=b) return tree[flg][ima];\n  int M = (L+R)/2;\n  return max(find(a,b,ima*2+1,L,M,flg),find(a,b,ima*2+2,M,R,flg));\n}\n\nint main() {\n  cin >> n >> d;\n\n  for(int i=0;i<n;i++)cin >> star[i].s.f >> star[i].s.s >> star[i].f;\n  sort(star,star+n);  \n  \n  for(int i=0;i<4;i++) \n    for(int j=0;j<(1<<18);j++) tree[i][j] = -INF;\n  \n  for(int i=0;i<n;i++) {\n    update(i,0,star[i].s.f); // max(x);\n    update(i,1,star[i].s.s); // max(y);\n    update(i,2,-star[i].s.f); // min(x);\n    update(i,3,-star[i].s.s); // min(y);\n  }\n\n  long long S=0;\n  int ima=0;\n  for(int i=0;i<n;i++){\n    while(i!=n && star[ima].f-star[i].f <=d) ima++;\n    ll maxx = find(i,ima,0,0,(1<<18),0);\n    ll maxy = find(i,ima,0,0,(1<<18),1);\n    ll minx = find(i,ima,0,0,(1<<18),2);\n    ll miny = find(i,ima,0,0,(1<<18),3);\n    S = max(S,(maxx+minx)*(maxy+miny));\n  }\n  cout << S<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n\nclass C{\n  public:\n    int x, y, b;\n    C(){}\n    C(int xx, int yy, int bb) { x = xx; y = yy; b = bb; }\n    bool operator < (const C &c) const { return b < c.b; }\n};\n \nint main() {\n  int N, d; cin >>N >>d;\n  vector<C> cs(N);\n  REP(i, N) cin >>cs[i].x >>cs[i].y >>cs[i].b;\n  SORT(cs);\n  int h = 0, t = 0, ans = 0;\n  multiset<int> xs{cs[0].x}, ys{cs[0].y};\n  while(h < N - 1 || t < N - 1){\n    if(cs[h].b - cs[t].b <= d)\n      ans = max(ans, (*xs.rbegin() - *xs.begin()) * (*ys.rbegin() - *ys.begin()));\n    if((h + 1 < N && cs[h + 1].b - cs[t].b <= d) || !(h - t)){\n      xs.insert(cs[++h].x);\n      ys.insert(cs[h].y);\n    } else{\n      xs.erase(xs.lower_bound(cs[t].x));\n      ys.erase(ys.lower_bound(cs[t++].y));\n    }\n  }\n  cout <<ans <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconst long long INF = 5e18;\n\nstruct RMinQ {\nprivate:\n\tint n;\n\tvector< long long >node;\npublic:\n\tRMinQ(vector< long long >v) {\n\t\tint sz = v.size();\n\t\tn = 1;\n\t\twhile (n < sz)n *= 2;\n\t\tnode.resize(2 * n - 1, INF);\n\t\tfor (int i = 0;i < sz;i++)node[i + n - 1] = v[i];\n\t\tfor (int i = n - 2;i >= 0;i--)node[i] = min(node[2 * i + 1], node[2 * i + 2]);\n\t}\n\tlong long getmin(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = n;\n\t\tif (r <= a || b <= l)return INF;\n\t\tif (a <= l && r <= b)return node[k];\n\t\tlong long vl = getmin(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tlong long vr = getmin(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\nstruct RMaxQ {\nprivate:\n\tint n;\n\tvector< long long >Node;\npublic:\n\tRMaxQ(vector< long long >v) {\n\t\tint sz = v.size();\n\t\tn = 1;\n\t\twhile (n < sz)n *= 2;\n\t\tNode.resize(2 * n - 1, -1);\n\t\tfor (int i = 0;i < sz;i++)Node[i + n - 1] = v[i];\n\t\tfor (int i = n - 2;i >= 0;i--)Node[i] = max(Node[2 * i + 1], Node[2 * i + 2]);\n\t}\n\tlong long getmax(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = n;\n\t\tif (r <= a || b <= l)return -1;\n\t\tif (a <= l && r <= b)return Node[k];\n\t\tlong long vl = getmax(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tlong long vr = getmax(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n};\n\nlong long N, d, x, y, s, ans;\nvector< pair< long long, pair< long long, long long > > >v;\nvector< long long >vv, xx, yy;\n\nint main() {\n\tcin >> N >> d;\n\tv.resize(N);\n\tfor (int i = 0;i < N;i++) {\n\t\tcin >> x >> y >> s;\n\t\tv[i]=make_pair(s,make_pair(x,y));\n\t}\n\tsort(v.begin(), v.end());\n\txx.resize(N), yy.resize(N), vv.resize(N);\n\tfor (int i = 0;i < N;i++) {\n\t\tvv[i] = v[i].first;\n\t\txx[i] = v[i].second.first;\n\t\tyy[i] = v[i].second.second;\n\t}\n\tRMinQ xmn(xx), ymn(yy);\n\tRMaxQ xmx(xx), ymx(yy);\n\tfor (int i = 0;i < N;i++) {\n\t\tint it = upper_bound(vv.begin(), vv.end(), vv[i] + d) - vv.begin();\n\t\tans = max(ans, (xmx.getmax(i, it) - xmn.getmin(i, it))*(ymx.getmax(i, it) - ymn.getmin(i, it)));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef pair <int,int> P;\ntypedef long long ll;\n#define f first\n#define s second\n#define INF 1000000000\nint tree[4][(1<<19)];\nint n,d;\npair <int,pair <int,int> > star[(1<<18)];\n\nvoid update(int i,int x,int flg){\n  i = (1<<18)+i-1;\n  tree[flg][i] = x;\n  while(i){\n    i = (i-1)/2;\n    tree[flg][i] = max(tree[flg][i*2+1],tree[flg][i*2+2]);\n  }\n}\n\nint find(int a,int b,int M,int L,int R,int flg){\n  if(b <=L || a >= R) return -INF;\n  if(a <=L && R <= b) return tree[flg][M];\n  int nx = (L+R)/2;\n  return max(find(a,b,M*2+1,L,nx,flg),find(a,b,M*2+2,nx,R,flg));\n}\n\nint main() {\n  cin >> n >> d;\n  for(int i=0;i<(1<<19);i++) \n    for(int j=0;j<4;j++) tree[j][i] = -INF;\n  for(int i=0;i<n;i++) cin >> star[i].s.f >> star[i].s.s >> star[i].f;\n  sort(star,star+n);\n  for(int i=0;i<n;i++) {\n    update(i,star[i].s.f,0); // max(x);\n    update(i,star[i].s.s,1); // max(y);\n    update(i,-star[i].s.f,2); // min(x);\n    update(i,-star[i].s.s,3); // min(y);\n  }\n  ll now = 0,minx,maxx,miny,maxy,S=0;\n  for(int i=0;i<n;i++) {\n    while(now < n && star[now].f -star[i].f <=d) now++;\n    maxx = find(i,now,0,0,(1<<18),0);\n    maxy = find(i,now,0,0,(1<<18),1);\n    minx = find(i,now,0,0,(1<<18),2);\n    miny = find(i,now,0,0,(1<<18),3);\n    S = max(S,((ll)maxx+minx)*((ll)maxy+miny));\n  }\n  cout << S <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <vector>\n#include <utility>\n#include <numeric>\n#include <string>\n#include <set>\n#include <map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#define rep(i, a, n) for(int (i) = (int)(a);(i) < (int)(n);++(i))\n#define repe(i, a, n) for(int (i) = (int)(a);(i) <= (int)(n);++(i))\n#define repr(i, a, n) for(int (i) = (int)(a);(i) > (int)(n);--(i))\n#define reper(i, a, n) for(int (i) = (int)(a);(i) >= (int)(n);--(i))\n#define SIZE(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define RNG(x, n) &((x)[0]), &((x)[n])\n#define SUBIF(a, b, x) ((x) ? (b) : (a))\n#define YES cout << \"YES\" << endl\n#define NO cout << \"NO\" << endl\n#define Yes cout << \"Yes\" << endl\n#define No cout << \"No\" << endl\n#define yes cout << \"yes\" << endl;\n#define no cout << \"no\" << endl;\n#define pb push_back\n#define EPS (1e-20)\n#define INF 2147483647LL\n#define MOD 1000000007LL\nusing llint = long long;\nusing VI = std::vector<int>;\nusing PII = std::pair<int, int>;\nusing SI = std::set<int>;\nusing MII = std::map<int, int>;\nusing TIII = std::tuple<int, int, int>;\nusing namespace std;\n\n\nstruct SEG {\n\tvector<PII> seg;\n\tint aryN;\n\tint segN;\n\n\tint inToN(int i){\n\t\treturn aryN+i-1;\n\t}\n\tint p(int i){\n\t\treturn (i-1)/2;\n\t}\n\tvoid update(int n){\n\t\tif(n == 0) return;\n\t\tseg[p(n)].first = max(seg[p(n)].first, seg[n].first);\n\t\tseg[p(n)].second = min(seg[p(n)].second, seg[n].second);\n\t\tupdate(p(n));\n\t}\n\tvoid init(int n){\n\t\taryN = (int)pow(2, (int)ceil(log2(n)));\n\t\tsegN = 2*aryN-1;\n\t\tseg = vector<PII>(segN);\n\t}\n\tvoid initSEG(){\n\t\trep(i, 0, aryN) seg[i] = { 0, (int)INF };\n\t\trep(i, 0, aryN) update(inToN(i));\n\t}\n\tint getMax(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = aryN;\n\t\tif(r <= a || b <= l) return -1;\n\t\tif(a <= l && r <= b) return seg[k].first;\n\t\tint vl = getMax(a, b, 2*k+1, l, (l+r)/2);\n\t\tint vr = getMax(a, b, 2*k+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n\tint getMin(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = aryN;\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <= b) return seg[k].second;\n\t\tint vl = getMin(a, b, 2*k+1, l, (l+r)/2);\n\t\tint vr = getMin(a, b, 2*k+2, (l+r)/2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\n\nint N, d;\nTIII star[200010];\nSEG X, Y;\nint br[200010];\n\n\nvoid makeXY(){\n\tX.init(N), Y.init(N);\n\trep(i, 0, N) X.seg[X.inToN(i)] = { get<1>(star[i]), get<1>(star[i]) }, Y.seg[Y.inToN(i)] = { get<2>(star[i]), get<2>(star[i]) };\n\trep(i, N, X.aryN) X.seg[X.inToN(i)] = Y.seg[Y.inToN(i)] = { 0, (int)INF };\n\tX.initSEG(), Y.initSEG();\n}\n\n\nint solve(){\n\tint ans = 0;\n\trep(i, 0, N) br[i] = get<0>(star[i]);\n\trep(i, 0, N){\n\t\tint p = upper_bound(RNG(br, N), br[i]+d)-&br[0];\n\t\tint x1 = X.getMax(i, p), x2 = X.getMin(i, p);\n\t\tint y1 = Y.getMax(i, p), y2 = Y.getMin(i, p);\n\t\tans = max(ans, (x1-x2)*(y1-y2));\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> N >> d;\n\trep(i, 0, N) cin >> get<1>(star[i]) >> get<2>(star[i]) >> get<0>(star[i]);\n\tsort(RNG(star, N));\n\n\tmakeXY();\n\t\n\tcout << solve() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define PPB pop_back\n#define MK make_pair\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<string, int> psi;\ntypedef pair<int, pii> pipii;\n\nstatic const int INF = 1LL << 61;\n//static const int MOD = 1000000007;\nstatic const int MAX_N = 1 << 18;\n\nstruct Seg {\n    int n;\n    int dat[MAX_N * 2];\n\n    void Init(int pn, int def) {\n        n = 1;\n        while (n < pn) n *= 2;\n        fill(dat, dat + MAX_N * 2, def);\n    }\n};\n\nstruct SegMin : Seg {\n    int Min(int s, int t) {\n        return Min(s, t, 0, 0, n);\n    }\n\n    int Min(int s, int t, int k, int l, int r) {\n        if (r <= s || t <= l) return INF;\n        if (s <= l && r <= t) return dat[k];\n\n        int t1 = Min(s, t, k * 2 + 1, l, (l + r) / 2);\n        int t2 = Min(s, t, k * 2 + 2, (l + r) / 2, r);\n        return min(t1, t2);\n    }\n\n    void Update(int k, int x) {\n        k += n - 1;\n        dat[k] = x;\n        while (0 < k) {\n            k = (k - 1) / 2;\n            dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n};\n\nstruct SegMax : Seg {\n    int Max(int s, int t) {\n        return Max(s, t, 0, 0, n);\n    }\n\n    int Max(int s, int t, int k, int l, int r) {\n        if (r <= s || t <= l) return 0;\n        if (s <= l && r <= t) return dat[k];\n\n        int t1 = Max(s, t, k * 2 + 1, l, (l + r) / 2);\n        int t2 = Max(s, t, k * 2 + 2, (l + r) / 2, r);\n        return max(t1, t2);\n    }\n\n    void Update(int k, int x) {\n        k += n - 1;\n        dat[k] = x;\n        while(0 < k) {\n            k = (k - 1) / 2;\n            dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n};\n\nSegMin xmin, ymin;\nSegMax xmax, ymax;\nint n, d;\nvector<pipii> st;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n >> d;\n    for (int i = 0; i < n; ++i) {\n        int x, y, b;\n        cin >> x >> y >> b;\n        st.PB(MK(b, MK(x, y)));\n    }\n    sort(ALL(st));\n    \n    xmin.Init(n, INF);\n    ymin.Init(n, INF);\n    xmax.Init(n, 0);\n    ymax.Init(n, 0);\n    for (int i = 0; i < n; ++i) {\n        int x = st[i].second.first, y = st[i].second.second;\n        xmin.Update(i, x);\n        xmax.Update(i, x);\n        ymin.Update(i, y);\n        ymax.Update(i, y);\n    }\n\n    int ans = 0;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int b = st[i].first;\n        int s = lower_bound(ALL(st), MK(b, MK(-INF, -INF))) - st.begin();\n        int t = lower_bound(ALL(st), MK(b + d, MK(INF, INF))) - st.begin();\n\n        int lx = xmin.Min(s, t);\n        int rx = xmax.Max(s, t);\n        int by = ymin.Min(s, t);\n        int uy = ymax.Max(s, t);\n        ans = max(ans, (rx - lx) * (uy - by));\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct Star\n{\n    int x, y, d;\n    Star () {}\n    Star (int x, int y, int d) : x(x), y(y), d(d) {}\n    bool operator < (const Star &p) const { return (d < p.d); }\n};\n\nint main()\n{\n    int N, D;\n    Star data[200005];\n    set < pair < int , int > > x, y;\n    cin >> N >> D;\n    for(int i = 0; i < N; i++) {\n        int x, y, d;\n        cin >> x >> y >> d;\n        data[i] = Star(x, y, d);\n    }\n    sort(data, data + N);\n\n    int l = 0, r = 0;\n    ll maxv = 0;\n    while(l < N) {\n        while(r < N && data[r].d <= data[l].d + D) {\n            x.insert(make_pair(data[r].x, r));\n            y.insert(make_pair(data[r].y, r));\n            r++;\n        }\n        maxv = max(maxv, (ll)((x.rbegin() -> first) - (x.begin() -> first)) * ((y.rbegin() -> first) - (y.begin() -> first)));\n        x.erase(make_pair(data[l].x, l));\n        y.erase(make_pair(data[l].y, l));\n        l++;\n    }\n    cout << maxv << endl;\n    return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P>P2;\n\nstruct RBQ{\n  int n=(1<<16),data[(1<<17)];\n  RBQ(){\n    memset(data,0,sizeof(data));\n  }\n  void update(int k,int x){\n    k+=n-1;\n    data[k]=x;\n    while(k>0){\n      k=(k-1)/2;\n      data[k]=max(data[k*2+1],data[k*2+2]);\n    }\n  }\n  int find(int a,int b,int k=0,int l=0,int r=(1<<16)){\n    if(r<=a || b<=l)return 0;\n    if(a<=l && r<=b)return data[k];\n    int v1=find(a,b,k*2+1,l,(l+r)/2);\n    int v2=find(a,b,k*2+2,(l+r)/2,r);\n    return max(v1,v2);\n  }\n};\n\nstruct RLQ{\n  int n=(1<<16),data[(1<<17)];\n  RLQ(){\n    fill(data,data+(1<<17),INT_MAX);\n  }\n  void update(int k,int x){\n    k+=n-1;\n    data[k]=x;\n    while(k>0){\n      k=(k-1)/2;\n      data[k]=min(data[k*2+1],data[k*2+2]);\n    }\n  }\n  int find(int a,int b,int k=0,int l=0,int r=(1<<16)){\n    if(r<=a || b<=l)return INT_MAX;\n    if(a<=l && r<=b)return data[k];\n    int v1=find(a,b,k*2+1,l,(l+r)/2);\n    int v2=find(a,b,k*2+2,(l+r)/2,r);\n    return min(v1,v2);\n  }\n};\n\nint main(){\n  int n,D;\n  cin>>n>>D;\n  RBQ X,Y;\n  RLQ x,y;\n  vector<P2>v;\n  r(i,n){\n    int x,y,z;\n    cin>>x>>y>>z;\n    v.push_back(P2(z,P(x,y)));\n  }\n  sort(v.begin(),v.end());\n  int l=0,ans=0;\n  r(r,n){\n    int d=v[r].first;\n    int nx=v[r].second.first;\n    int ny=v[r].second.second;\n    x.update(r,nx);\n    X.update(r,nx);\n    y.update(r,ny);\n    Y.update(r,ny);\n    while(d-v[l].first>D)l++;\n    int min_x=x.find(l,r+1);\n    int max_x=X.find(l,r+1);\n    int min_y=y.find(l,r+1);\n    int max_y=Y.find(l,r+1);\n    ans=max(ans,(max_x-min_x)*(max_y-min_y));\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n\nusing namespace std;\n\n//typedef\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n//container util\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << \"[L \" << __LINE__ << \"] \" << #x << \" = \" << (x) << \"\\n\";\n\nconst int INF = 1e9;\nconst int _N = 200000;\nconst int _M = 270000;\n\nstruct SEG{ // min\n\tint d[_M * 2];\n\tint m;\n\tvoid init(int m){\n\t\tthis->m = m;\n\t\tREP(i, m * 2 - 1)d[i] = INF;\n\t}\n\tvoid update(int i, int x){\n\t\ti += m - 1;\n\t\td[i] = x;\n\t\twhile(i>0){\n\t\t\ti = (i -1) / 2;\n\t\t\td[i] = min(d[i * 2 + 1], d[i * 2 + 2]);\n\t\t}\n\t}\n\tint query(int a, int b){\n\t\treturn _query(a, b, 0, 0, m);\n\t}\n\tprivate:int _query(int a, int b, int k, int l, int r){\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <=b) return d[k];\n\t\tint vl = _query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = _query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\nint n, d;\nint sizes[_N]; // sizes exist\nmap<int, int> sizeRef; // [size] = index\n\nSEG xms, xMs, yms, yMs;\ntypedef pair<int, PII> Star;\nStar stars[_N];\nbool comp(const Star& a, const Star& b){\n\treturn a.first < b.first;\n}\nint last = -1, si = -1;\nint xm, xM, ym, yM;\nvoid calc(){\n\tsizes[si] = last;\n\tsizeRef[last] = si;\n\txms.update(si, xm);\n\txMs.update(si, -xM);\n\tyms.update(si, ym);\n\tyMs.update(si, -yM);\n\txm = INF, xM = 0, ym = INF, yM = 0;\n}\n\nint main() {\n\tomajinai;\n\tcin >> n >> d;\n\n\t// segment tree initial\n\tint m=1;\n\twhile(m<n)m*=2;\n\txms.init(m);\n\txMs.init(m);\n\tyms.init(m);\n\tyMs.init(m);\n\t//\n\n\tREP(i, n){\n\t\tint x, y, b;\n\t\tcin >> x >> y >> b;\n\t\tstars[i] = MP(b, MP(x, y));\n\t}\n\tsort(stars, stars + n, comp);\n\tREP(i, n){\n\t\tint b = stars[i].first, x = stars[i].second.first, y = stars[i].second.second;\n\t\tif(b!=last){\n\t\t\tsi++;\n\t\t\tlast = b;\n\t\t\tcalc();\n\t\t}\n\t\txm = min(xm, x);\n\t\txM = max(xM, x);\n\t\tym = min(ym, y);\n\t\tyM = max(yM, y);\n\t}\n\tsi++;\n\tcalc();\n\n\tsi++; // to use as sizes' size\n\tint ans = 0;\n\tREP(i, n){\n\t\tint b = stars[i].first;\n\t\tint st = sizeRef[b];\n\t\tint ed = upper_bound(sizes, sizes + si, b + d) - sizes;\n\t\txm = xms.query(st, ed);\n\t\txM = -xMs.query(st, ed);\n\t\tym = yms.query(st, ed);\n\t\tyM = -yMs.query(st, ed);\n\t\tans = max(ans, (xM - xm) * (yM - ym));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n\nclass C{\n  public:\n    int x, y, b;\n    C(){}\n    C(int xx, int yy, int bb) { x = xx; y = yy; b = bb; }\n    bool operator < (const C &c) const { return b < c.b; }\n};\n \nint main() {\n  int N, d; cin >>N >>d;\n  vector<C> cs(N);\n  REP(i, N) cin >>cs[i].x >>cs[i].y >>cs[i].b;\n  SORT(cs);\n  int h = 0, t = 0, ans = 0;\n  multiset<int> xs{cs[0].x}, ys{cs[0].y};\n  while(h < N - 1 || t < N - 1){\n    if(cs[h].b - cs[t].b <= d)\n      ans = max(ans, (*max_element(xs.begin(), xs.end()) - *min_element(xs.begin(), xs.end())) * (*max_element(ys.begin(), ys.end()) - *min_element(ys.begin(), ys.end())));\n    if((h + 1 < N && cs[h + 1].b - cs[t].b <= d) || !(h - t)){\n      xs.insert(cs[++h].x);\n      ys.insert(cs[h].y);\n    } else{\n      xs.erase(xs.lower_bound(cs[t].x));\n      ys.erase(ys.lower_bound(cs[t++].y));\n    }\n  }\n  cout <<ans <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, d; cin >> n >> d;\n\tvector<tuple<int,int,int>> v;\n\trep(i, n){\n\t\tint x, y, z; cin >> x >> y >> z;\n\t\tv.emplace_back(z, x, y);\n\t}\n\tsort(all(v));\n\tmap<int, int> xs, ys;\n\tll ans = 0;\n\t\n\tfor(int i = 0, j = 0; i < n; i++){\n\t\twhile(j < n && get<0>(v[i]) + (ll)d >= get<0>(v[j])){\n\t\t\txs[get<1>(v[j])]++;\n\t\t\tys[get<2>(v[j])]++;\n\t\t\tj++;\n\t\t}\n\t\tif(xs.size() && ys.size()){\n\t\t\tauto l = xs.begin(), r = xs.end(); --r;\n\t\t\tauto L = ys.begin(), R = ys.end(); --R;\n\t\t\tans = max(ans, (r->first - l->first) * (ll)(R->first - L->first));\n\t\t}\n\t\tif(--xs[get<1>(v[i])] == 0) xs.erase(get<1>(v[i]));\n\t\tif(--ys[get<2>(v[i])] == 0) ys.erase(get<2>(v[i]));\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P>P2;\n\nstruct RBQ{\n  int n=(1<<18),data[(1<<19)];\n  RBQ(){\n    memset(data,0,sizeof(data));\n  }\n  void update(int k,int x){\n    k+=n-1;\n    data[k]=x;\n    while(k>0){\n      k=(k-1)/2;\n      data[k]=max(data[k*2+1],data[k*2+2]);\n    }\n  }\n  int find(int a,int b,int k=0,int l=0,int r=(1<<18)){\n    if(r<=a || b<=l)return 0;\n    if(a<=l && r<=b)return data[k];\n    int v1=find(a,b,k*2+1,l,(l+r)/2);\n    int v2=find(a,b,k*2+2,(l+r)/2,r);\n    return max(v1,v2);\n  }\n};\n\nstruct RLQ{\n  int n=(1<<18),data[(1<<19)];\n  RLQ(){\n    fill(data,data+(1<<19),INT_MAX);\n  }\n  void update(int k,int x){\n    k+=n-1;\n    data[k]=x;\n    while(k>0){\n      k=(k-1)/2;\n      data[k]=min(data[k*2+1],data[k*2+2]);\n    }\n  }\n  int find(int a,int b,int k=0,int l=0,int r=(1<<18)){\n    if(r<=a || b<=l)return INT_MAX;\n    if(a<=l && r<=b)return data[k];\n    int v1=find(a,b,k*2+1,l,(l+r)/2);\n    int v2=find(a,b,k*2+2,(l+r)/2,r);\n    return min(v1,v2);\n  }\n};\n\nint main(){\n  int n,D;\n  cin>>n>>D;\n  RBQ X,Y;\n  RLQ x,y;\n  vector<P2>v;\n  r(i,n){\n    int x,y,z;\n    cin>>x>>y>>z;\n    v.push_back(P2(z,P(x,y)));\n  }\n  sort(v.begin(),v.end());\n  int l=0,ans=0;\n  r(r,n){\n    int d=v[r].first;\n    int nx=v[r].second.first;\n    int ny=v[r].second.second;\n    x.update(r,nx);\n    X.update(r,nx);\n    y.update(r,ny);\n    Y.update(r,ny);\n    while(d-v[l].first>D)l++;\n    int min_x=x.find(l,r+1);\n    int max_x=X.find(l,r+1);\n    int min_y=y.find(l,r+1);\n    int max_y=Y.find(l,r+1);\n    ans=max(ans,(max_x-min_x)*(max_y-min_y));\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int LL\ntypedef long long LL;\nconst int INF = 2002002002;\n\nstruct DATA {\n\tint minx, miny, maxx, maxy;\n};\n\nstruct STAR {\n\tint x, y, b;\n\tbool operator < (const STAR &t) const {\n\t\treturn b < t.b;\n\t}\n};\n\nint n, d;\nSTAR star[1 << 19];\n\nint N;\nDATA data[1 << 20];\n\n\nvoid init(int n)\n{\n\tfor (N = 1; N < n; N <<= 1);\n\tfill(data, data + (1 << 20), (DATA){INF, INF, -INF, -INF});\n}\n\nvoid update(int i, STAR s)\n{\n\ti += N - 1;\n\tdata[i].minx = min(data[i].minx, s.x);\n\tdata[i].miny = min(data[i].miny, s.y);\n\tdata[i].maxx = max(data[i].maxx, s.x);\n\tdata[i].maxy = max(data[i].maxy, s.y);\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tdata[i].minx = min(data[i * 2 + 1].minx, data[i * 2 + 2].minx);\n\t\tdata[i].miny = min(data[i * 2 + 1].miny, data[i * 2 + 2].miny);\n\t\tdata[i].maxx = max(data[i * 2 + 1].maxx, data[i * 2 + 2].maxx);\n\t\tdata[i].maxy = max(data[i * 2 + 1].maxy, data[i * 2 + 2].maxy);\n\t}\n}\n\nDATA query(int a, int b, int k, int l, int r)\n{\n\t//printf(\"%d %d %d %d %d\\n\", a, b, k, l, r);\n\tif (r <= a || b <= l) return (DATA){INF, INF, -INF, -INF};\n\tif (a <= l && r <= b) return data[k];\n\tDATA vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tDATA vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn (DATA){min(vl.minx, vr.minx), min(vl.miny, vr.miny), max(vl.maxx, vr.maxx), max(vl.maxy, vr.maxy)};\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tinit(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d %d\", &star[i].x, &star[i].y, &star[i].b);\n\t\tstar[i].x; star[i].y;\n\t}\n\tfor (int i = n; i < 1 << 19; i++){\n\t\tstar[i].b = INF;\n\t}\n\t\n\tsort(star, star + n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tupdate(i, star[i]);\n\t}\n\t\n\t//printf(\"%lld\\n\", (LL)INF * INF);\n\t\n\tLL res = 0;\n\tfor (int l = 0; star[l].b != INF; ){\n\t\tint r = l;\n\t\twhile (star[r].b - star[l].b <= d) r++;\n\t\t\n\t\tDATA q = query(l, r, 0, 0, N);\n\t\tLL t = (LL)(q.maxx - q.minx) * (q.maxy - q.miny);\n\t\tres = max(res, t);\n\t\t\n\t\tl++;\n\t\twhile (star[l + 1].b == star[l].b) l++;\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define Rrep(i, m, n) for(int i=(m);i<(n);i++)\n#define All(v) v.begin(),v.end()\n#define Uniq(v) v.erase(unique(All(v)),v.end())\ntypedef pair<ll, ll> Pii;\ntypedef pair<ll, Pii> Pip;\ntypedef pair<string, int> Psi;\ntypedef vector<int> Vi;\nconst int INF = (1<<30);\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\n\nconst int MAX_N = 1 << 17;\n\nll n, d;\nll datx1[2 * MAX_N - 1];\nll datx2[2 * MAX_N - 1];\nll daty1[2 * MAX_N - 1];\nll daty2[2 * MAX_N - 1];\n\nvoid init(ll n_, ll dat[]) {\n  n = 1;\n  while( n < n_ ) n *= 2;\n  for(int i=0; i<2*n-1; i++) dat[i] = INT_MAX;\n}\n\nvoid update(ll k, ll a, ll dat[]) {\n  k += n - 1;\n  dat[k] = a;\n  while( k > 0 ) {\n    k = (k - 1) / 2;\n    dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n}\n\nint query(ll a, ll b, ll k, ll l, ll r, ll dat[]) {\n  if( r <= a || b <= l ) return INT_MAX;\n  if( a <= l && r <= b ) return dat[k];\n  else {\n    ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2, dat);\n    ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r, dat);\n    return min(vl, vr);\n  }\n}\n\nint main()\n{\n  cin >> n >> d;\n  ll N = n;\n  init(N, datx1);init(N, datx2);init(N, daty1);init(N, daty2);\n  vector<ll> bData;\n  vector<Pip> allData;\n  for(int i=0; i<N; i++) {\n    ll a, b, c;\n    cin >> a >> b >> c;\n    bData.pb( c );\n    allData.pb( Pip(c, Pii(a, b)) );\n  }\n\n  sort( All(allData) );\n\n  for(int i=0; i<N; i++) {\n    ll x = allData[i].sc.fr, y = allData[i].sc.sc;\n    update(i, x, datx1);\n    update(i, -x, datx2);\n    update(i, y, daty1);\n    update(i, -y, daty2);\n  }\n\n  ll s, t; s = t = 0;\n  ll ma = 0;\n  for(int i=1; i<N-1; i++) {\n    t = i;\n    while( 1 ) {\n      if( allData[t].fr - allData[s].fr <= d ) break;\n      s++;\n    }\n    ll x1 = query(s, t+1, 0, 0, n, datx1);\n    ll x2 = query(s, t+1, 0, 0, n, datx2);\n    ll y1 = query(s, t+1, 0, 0, n, daty1);\n    ll y2 = query(s, t+1, 0, 0, n, daty2);\n\n    ll tmp = ((-x2) - x1) * ((-y2) - y1);\n    if( tmp > ma ) {\n      ma = tmp;\n    }\n  }\n\n  cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <list>\n \nusing namespace std;\ntypedef long long ll;\n \n#define mod 1000000007\n#define INF 1000000000\n#define SIZE 100000\n\nstruct NODE{\n  int min_d;\n  int max_d;\n  int min_x;\n  int min_y;\n  int max_x;\n  int max_y;\n\n  NODE(){\n    min_d = INF;\n    max_d = 0;\n    min_x = INF;\n    max_x = 0;\n    min_y = INF;\n    max_y = 0;\n  }\n  \n  NODE(int a,int b,int c,int d,int e,int f){\n    min_d = a;\n    max_d = b;\n    min_x = c;\n    max_x = d;\n    min_y = e;\n    max_y = f;\n  }\n\n  NODE operator+ (const NODE &B) const{\n    int a = min(min_d,B.min_d);\n    int b = max(max_d,B.max_d);\n    int c = min(min_x,B.min_x);\n    int d = max(max_x,B.max_x);\n    int e = min(min_y,B.min_y);\n    int f = max(max_y,B.max_y);\n\n    return NODE(a,b,c,d,e,f);\n  }\n};\n\nNODE data[1 << 19];\nint segn2;\n\n\nvoid set(int k,pair<int,pair<int,int> > p){\n  int d = p.first;\n  int x = p.second.first;\n  int y = p.second.second;\n  \n  data[k+segn2-1] = NODE(d,d,x,x,y,y);\n}\n\nvoid init(){\n  for(int i = segn2-2;i>=0;i--){\n    data[i] = data[i*2+1] + data[i*2+2];\n  }\n}\n\nNODE query(int a,int b,int k=0){\n  if(b<a) return NODE();\n  if(data[k].max_d < data[k].min_d) return NODE();\n  if(data[k].max_d < a || b < data[k].min_d) return NODE();\n\n  if(a<= data[k].min_d && data[k].max_d <= b) return data[k];\n\n  return query(a,b,k*2+1) + query(a,b,k*2+2);\n}\n\nint main(){\n  int n,d;\n  int x,y,b;\n  vector<pair<int,pair<int,int> > > in;\n\n  scanf(\"%d%d\",&n,&d);\n\n  segn2 = 1;\n  while(segn2<n) segn2*=2;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d%d%d\",&x,&y,&b);\n    in.push_back(make_pair(b,make_pair(x,y)));\n  }\n\n  sort(in.begin(),in.end());\n\n  for(int i=0;i<n;i++){\n    set(i,in[i]);\n  }\n\n  init();\n  \n  ll ans = 0;\n  \n  for(int i=0;i<n;i++){\n    NODE a = query(in[i].first,in[i].first+d);\n    if(a.max_d < a.min_d) continue;\n    ll calc = (ll)(a.max_x - a.min_x)*(a.max_y - a.min_y);\n    ans = max(ans,calc);\n  }\n\n  cerr << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n#define int long long\n#define MAX_N 200000\n#define F first\n#define Se second\n#define MP(i, j) make_pair((i), (j))\nconst int INF = 2e18;\nstruct S{\n\tint sx, lx, sy, ly;\n\tS(int isx, int ilx, int isy, int ily): sx(isx), lx(ilx), sy(isy), ly(ily){}\n\tbool operator<(const S &s) const { \n\t\treturn 1;\n\t}\n};\ntypedef pair<int, S> PS;\ntypedef vector<PS>::iterator it;\n\nint i, j, n, d, stars[MAX_N][3];\nint ans;\nvector<PS> vec;\n\n\nvoid vdc(vector<PS> &vf, S s, int now){\n\tif(vf[now].Se.sx > s.sx)\n\t\tvf[now].Se.sx = s.sx;\n\tif(vf[now].Se.lx < s.lx)\n\t\tvf[now].Se.lx = s.lx;\n\tif(vf[now].Se.sy > s.sy)\n\t\tvf[now].Se.sy = s.sy;\n\tif(vf[now].Se.ly < s.ly)\n\t\tvf[now].Se.ly = s.ly;\n}\n\nsigned main(){\n\tcin >> n >> d;\n\tvec.push_back(MP(0, S(0, 0, 0, 0)));\n\tfor(i = 0; i < n; i++){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tS s = S(a, a, b, b);\n\t\tit ite = lower_bound(vec.begin(), vec.end(), MP(c, s));\n\t\tif(vec[ite - vec.begin() - 1].F != c){\n\t\t\tvec.insert(ite, MP(c, s));\n\t\t}\n\t\telse{\n\t\t\tvdc(vec, s, ite - vec.begin() - 1);\n\t\t}\n\t}\n\tS s = S(INF, 0, INF, 0);\n\tvec.erase(vec.begin());\n\tfor(i = 0; i < vec.size(); i++){\n\t\tif(vec[i].F - vec[0].F > d){\n\t\t\ti = -1;\n\t\t\tvec.erase(vec.begin());\n\t\t\tans = max(ans, (s.lx - s.sx) * (s.ly - s.sy));\n\t\t\ts = S(INF, 0, INF, 0);\n\t\t}\n\t\telse{\n\t\t\ts = S(min(vec[i].Se.sx, s.sx), max(vec[i].Se.lx, s.lx), min(vec[i].Se.sy, s.sy), max(vec[i].Se.ly, s.ly));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\ntypedef pair<int, int>cdn;\ntypedef pair<int, cdn>sky;\nint x[2000000], y[2000000];\n\nint main(){\n  int N, d, i;\n  multiset<int> X, Y;\n  sky data[200000];\n  cin >> N >> d;\n  for(i=0; i<N; i++){\n    cin >> data[i].second.first >> data[i].second.second >> data[i].first;\n  }\n  sort(data, data+N);\n  long long flag=0, ans=0;\n  for(i=0; i<N; i++){\n    while(data[i].first - d > data[flag].first){\n      X.erase(X.find(data[flag].second.first));\n      Y.erase(Y.find(data[flag].second.second));\n      flag+=1;\n    }\n    X.insert(data[i].second.first);\n    Y.insert(data[i].second.second);\n    multiset<int>::iterator itr1 = X.end();\n    itr1--;\n    multiset<int>::iterator itr2 = X.begin();\n    multiset<int>::iterator itr3 = Y.end();\n    itr3--;\n    multiset<int>::iterator itr4 = Y.begin();\n    ans = max(ans, (long long)((*itr1-*itr2)*(*itr3-*itr4)));\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct SegTree { // ??????min,max\n\tint n;\n\tvector<int> Max;\n\tvector<int> Min;\n\n\tvoid init(int n_)\n\t{\n\t\tn = 1;\n\t\twhile (n < n_) n *= 2;\n\n\t\tMax.resize(2 * n);\n\t\tMin.resize(2 * n);\n\n\t\tfor (int i = 0; i < 2 * n - 1; ++i) {\n\t\t\tMax[i] = -inf;\n\t\t\tMin[i] = inf;\n\t\t}\n\t}\n\n\tvoid update(int idx, int val)\n\t{\n\t\tidx += n - 1;\n\t\tMin[idx] = val;\n\t\tMax[idx] = val;\n\n\t\twhile (idx > 0) {\n\t\t\tidx = (idx - 1) / 2;\n\t\t\tMin[idx] = min(Min[idx * 2 + 1], Min[idx * 2 + 2]);\n\t\t\tMax[idx] = max(Max[idx * 2 + 1], Max[idx * 2 + 2]);\n\t\t}\n\t}\n\n\tint get_min(int a, int b, int k = 0, int l = 0, int r = -1) // [a, b)???min\n\t{\n\t\tif (r == -1) r = n;\n\t\tif (r <= a || b <= l) return inf;\n\t\tif (a <= l && r <= b) return Min[k];\n\n\t\tint vl = get_min(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = get_min(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn min(vl, vr);\n\t}\n\n\tint get_max(int a, int b, int k = 0, int l = 0, int r = -1) // [a, b)???max\n\t{\n\t\tif (r == -1) r = n;\n\t\tif (r <= a || b <= l) return -inf;\n\t\tif (a <= l && r <= b) return Max[k];\n\n\t\tint vl = get_max(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = get_max(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn max(vl, vr);\n\t}\n};\n\nint X[200020], Y[200020];\n\nsigned main()\n{\n\tint N, d; scanf(\"%d%d\", &N, &d);\n\n\tSegTree x_seg, y_seg;\n\n\tx_seg.init(N), y_seg.init(N);\n\n\tvpii sorted;\n\n\trep(i, N) {\n\t\tint x, y, b; scanf(\"%d%d%d\", &x, &y, &b);\n\t\tX[i] = x, Y[i] = y;\n\n\t\tsorted.PB(pii(b, i));\n\t}\n\n\tsort(all(sorted));\n\n\trep(i, N) {\n\t\tx_seg.update(i, X[sorted[i].scd]);\n\t\ty_seg.update(i, Y[sorted[i].scd]);\n\t}\n\n\tll ans = -inf;\n\n\trep(i, N) {\n\t\tif (i > 0 && sorted[i].fst == sorted[i - 1].fst) continue;\n\n\t\tint b = sorted[i].fst;\n\n\t\tint idx = upper_bound(all(sorted), pii(b + d, inf)) - sorted.begin();\n\n\t\tint min_x = x_seg.get_min(i, idx);\n\t\tint max_x = x_seg.get_max(i, idx);\n\n\t\tint min_y = y_seg.get_min(i, idx);\n\t\tint max_y = y_seg.get_max(i, idx);\n\n\t\tans = max(ans, (ll)(max_x - min_x) * (max_y - min_y));\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n#define MAX_N 200000\n#define F first\n#define Se second\n#define INF int(2e9)\n#define LL long long\n#define MP(i, j) make_pair((i), (j))\nstruct S{\n\tint sx, lx, sy, ly;\n\tS(int isx, int ilx, int isy, int ily): sx(isx), lx(ilx), sy(isy), ly(ily){}\n\tbool operator<(const S &s) const { \n\t\treturn 1;\n\t}\n};\ntypedef pair<int, S> PS;\ntypedef vector<PS>::iterator it;\n\nint i, j, n, d, stars[MAX_N][3];\nLL ans;\nvector<PS> vec;\n\n\nvoid vdc(vector<PS> &vf, S s, int now){\n\tif(vf[now].Se.sx > s.sx)\n\t\tvf[now].Se.sx = s.sx;\n\tif(vf[now].Se.lx < s.lx)\n\t\tvf[now].Se.lx = s.lx;\n\tif(vf[now].Se.sy > s.sy)\n\t\tvf[now].Se.sy = s.sy;\n\tif(vf[now].Se.ly < s.ly)\n\t\tvf[now].Se.ly = s.ly;\n}\n\nint main(){\n\tcin >> n >> d;\n\tvec.push_back(MP(0, S(0, 0, 0, 0)));\n\tfor(i = 0; i < n; i++){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tS s = S(a, a, b, b);\n\t\tit ite = lower_bound(vec.begin(), vec.end(), MP(c, s));\n\t\tif(vec[ite - vec.begin() - 1].F != c){\n\t\t\tvec.insert(ite, MP(c, s));\n\t\t}\n\t\telse{\n\t\t\tvdc(vec, s, ite - vec.begin() - 1);\n\t\t}\n\t}\n\tS s = S(INF, 0, INF, 0);\n\tvec.erase(vec.begin());\n\tfor(i = 0; i < vec.size(); i++){\n\t\tif(vec[i].F - vec[0].F > d){\n\t\t\ti = -1;\n\t\t\tvec.erase(vec.begin());\n\t\t\tans = max(ans, (LL)(s.lx - s.sx) * (LL)(s.ly - s.sy));\n\t\t\ts = S(INF, 0, INF, 0);\n\t\t}\n\t\telse{\n\t\t\ts = S(min(vec[i].Se.sx, s.sx), max(vec[i].Se.lx, s.lx), min(vec[i].Se.sy, s.sy), max(vec[i].Se.ly, s.ly));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> Pii;\nPii star[200001];\nint main(){\n\tint n,d;\n\tcin >> n >> d;\n\tfor(int i=0;i<n;i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tPii t;\n\t\tt.first = c;\n\t\tt.second.first = a;\n\t\tt.second.second = b;\n\t\tstar[i] = t;\n\t}\n\tsort(star,star+n);\n\tint ans = 0;\n\tfor(int i=0;i<n;i++){\n\t\tint now = star[i].first;\n\t\tint maxx = star[i].second.first;\n\t\tint minx = star[i].second.first;\n\t\tint maxy = star[i].second.second;\n\t\tint miny = star[i].second.second;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(now + d >= star[j].first){\n\t\t\t\tmaxx = max(maxx,star[j].second.first);\n\t\t\t\tminx = min(minx,star[j].second.first);\n\t\t\t\tmaxy = max(maxy,star[j].second.second);\n\t\t\t\tminy = min(miny,star[j].second.second);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tans = max(ans,(maxx-minx)*(maxy-miny));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n\nclass SegmentTree\n{\nprivate:\n\tvector<int> tree;\n\tconst int INF = 99999999;\n\tint size;\n\tint init(int i)\n\t{\n\t\tif (i * 2 + 1 < tree.size()) tree[i] = init(i * 2 + 1);\n\t\tif (i * 2 + 2 < tree.size()) tree[i] = min(init(i * 2 + 2), tree[i]);\n\t\treturn tree[i];\n\t}\n\tint get(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || b <= l) return INF;\n\t\tif (a <= l && r <= b) return tree[k];\n\t\tint vl = get(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = get(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\npublic:\n\tSegmentTree(vector<int>& v)\n\t{\n\t\tsize = 1;\n\t\twhile (size < v.size()) size *= 2;\n\t\ttree.resize(size * 2 - 1);\n\t\tfill(tree.begin(), tree.end(), INF);\n\t\tfor (int i = 0; i < v.size(); i++) tree[size - 1 + i] = v[i];\n\t\tinit(0);\n\t}\n\tint get(int begin, int end)\n\t{\n\t\treturn get(begin, end, 0, 0, size);\n\t}\n};\nclass GreaterSegmentTree\n{\nprivate:\n\tvector<int> tree;\n\tconst int INF = -99999999;\n\tint size;\n\tint init(int i)\n\t{\n\t\tif (i * 2 + 1 < tree.size()) tree[i] = init(i * 2 + 1);\n\t\tif (i * 2 + 2 < tree.size()) tree[i] = max(init(i * 2 + 2), tree[i]);\n\t\treturn tree[i];\n\t}\n\tint get(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || b <= l) return INF;\n\t\tif (a <= l && r <= b) return tree[k];\n\t\tint vl = get(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = get(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\npublic:\n\tGreaterSegmentTree(vector<int>& v)\n\t{\n\t\tsize = 1;\n\t\twhile (size < v.size()) size *= 2;\n\t\ttree.resize(size * 2 - 1);\n\t\tfill(tree.begin(), tree.end(), INF);\n\t\tfor (int i = 0; i < v.size(); i++) tree[size - 1 + i] = v[i];\n\t\tinit(0);\n\t}\n\tint get(int begin, int end)\n\t{\n\t\treturn get(begin, end, 0, 0, size);\n\t}\n};\n\n\nclass Star\n{\npublic:\n\tlong long int x, y;\n\tint b;\n\tint boundary;\n};\nbool operator > (Star s1, Star s2)\n{\n\treturn s1.b > s2.b;\n}\nbool operator < (Star s1, Star s2)\n{\n\treturn s1.b < s2.b;\n}\n\nint n, d;\nStar star[200000];\nlong long int ans = 0;\n\nvoid calcBoundary()\n{\n\tint boundary = n - 1;\n\tstar[n - 1].boundary = boundary;\n\tfor (int i = n - 2; i >= 0; i--)\n\t{\n\t\tif (star[i + 1].b - star[i].b > d) boundary = i;\n\t\tstar[i].boundary = boundary;\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tStar s;\n\t\ts.b = star[i].b + d;\n\t\tboundary = upper_bound(star + i, star + n, s) - star - 1;\n\t\tstar[i].boundary = min(star[i].boundary, boundary);\n\t}\n}\n\nvoid solve()\n{\n\tvector<int> vx;\n\tvector<int> vy;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tvx.push_back(star[i].x);\n\t\tvy.push_back(star[i].y);\n\t}\n\tSegmentTree segX(vx), segY(vy);\n\tGreaterSegmentTree gsegX(vx), gsegY(vy);\n\n\tint boundary = star[n-1].boundary;\n\t\n\tfor (int i = n - 2; i >= 0; i--)\n\t{\n\t\tif (boundary != star[i].boundary)\n\t\t{\n\t\t\tlong long int a = ((long long int)gsegX.get(i + 1, boundary + 1) - (long long int)segX.get(i + 1, boundary + 1)) * ((long long int)gsegY.get(i + 1, boundary + 1) - (long long int)segY.get(i + 1, boundary + 1));\n\t\t\tans = max(a, ans);\n\t\t\tboundary = star[i].boundary;\n\t\t}\n\t}\n\tlong long int a = ((long long int)gsegX.get(0, boundary + 1) - (long long int)segX.get(0, boundary + 1)) * ((long long int)gsegY.get(0, boundary + 1) - (long long int)segY.get(0, boundary + 1));\n\tans = max(a, ans);\n}\n\nint main()\n{\n\tcin >> n >> d;\n\tfor (int i = 0; i < n; i++) cin >> star[i].x >> star[i].y >> star[i].b;\n\n\tsort(star, star + n);\n\tcalcBoundary();\n\tsolve();\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<climits>\n#include<algorithm>\n\nconst long long int INF = INT_MAX;\nconst long long int NIL = -1;\nint leftMostBit(int x) {\n  if(x == 0) return 0;\n  x = (x & 0x55555555) << 1 | (x >> 1) & 0x55555555;\n  x = (x & 0x33333333) << 2 | (x >> 2) & 0x33333333;\n  x = (x & 0x0f0f0f0f) << 4 | (x >> 4) & 0x0f0f0f0f;\n  x = (x << 24) | ((x & 0xff00) << 8) | ((x >> 8) & 0xff00) | (x >> 24);\n  int deBruijnSequence[32] = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14};\n  return 31 - deBruijnSequence[((x & -x) * 0x076be629U) >> 27];\n}\nclass RangeMinimumQuery {\npublic:\n  RangeMinimumQuery(int s) {\n    size_ = 1 << leftMostBit(s);\n    if(size_ != s) size_ <<= 1;\n    node_ = std::vector<long long int>((size_ << 1) - 1, INF);\n  }\n  long long int find(int left, int right) const {\n    return query(left, right, 0, 0, size_ - 1);\n  }\n  void update(int index, int value) {\n    int i = index + size_ - 1;\n    node_[i] = value;\n    while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n  }\nprivate:\n  int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n  int left_child(int node) const {return (node << 1) + 1;}\n  int right_child(int node) const {return (node << 1) + 2;}\n  long long int query(int a, int b, int k, int l, int r) const {\n    if(b < l || r < a) return INF;\n    if(a <= l && r <= b) return node_[k];\n    int vl = query(a, b, left_child(k), l, (l + r) / 2);\n    int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n    return std::min(vl, vr);\n  }\n\n  int size_;\n  std::vector<long long int> node_;\n};\n\n#include<iostream>\nusing namespace std;\n\nstruct Star {long long int x, y, b;};\nbool operator<(const Star& lhs, const Star& rhs) {return lhs.b < rhs.b;}\n\nint main() {\n  int N, d;\n  cin >> N >> d;\n  vector<Star> star(N);\n  for(auto& s: star) cin >> s.x >> s.y >> s.b;\n  sort(begin(star), end(star));\n  RangeMinimumQuery left(N), right(N), top(N), bottom(N);\n  for(int i = 0; i < N; ++i) {\n    left.update(i, star[i].x);\n    right.update(i, -star[i].x);\n    top.update(i, star[i].y);\n    bottom.update(i, -star[i].y);\n  }\n  long long int answer = 0;\n  int low, high;\n  for(low = high = 0; low < N; ++low) {\n    while(high < N - 1 && star[high + 1].b - star[low].b <= d) ++high;\n    long long int area = -right.find(low, high) - left.find(low, high);\n    area *= -bottom.find(low, high) - top.find(low, high);\n    answer = max(answer, abs(area));\n  }\n  cout << answer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct SegTree { // ??????min,max\n\tint n;\n\tvector<int> Max;\n\tvector<int> Min;\n\n\tvoid init(int n_)\n\t{\n\t\tn = 1;\n\t\twhile (n < n_) n *= 2;\n\n\t\tMax.resize(2 * n);\n\t\tMin.resize(2 * n);\n\n\t\tfor (int i = 0; i < 2 * n - 1; ++i) {\n\t\t\tMax[i] = -inf;\n\t\t\tMin[i] = inf;\n\t\t}\n\t}\n\n\tvoid min_update(int idx, int val)\n\t{\n\t\tidx += n - 1;\n\t\tMin[idx] = val;\n\n\t\twhile (idx > 0) {\n\t\t\tidx = (idx - 1) / 2;\n\t\t\tMin[idx] = min(Min[idx * 2 + 1], Min[idx * 2 + 2]);\n\t\t}\n\t}\n\n\tvoid max_update(int idx, int val)\n\t{\n\t\tidx += n - 1;\n\t\tMax[idx] = val;\n\n\t\twhile (idx > 0) {\n\t\t\tidx = (idx - 1) / 2;\n\t\t\tMax[idx] = max(Max[idx * 2 + 1], Max[idx * 2 + 2]);\n\t\t}\n\t}\n\n\tint get_min(int a, int b, int k = 0, int l = 0, int r = -1) // [a, b)???min\n\t{\n\t\tif (r == -1) r = n;\n\n\t\tif (r <= a || b <= l) return inf;\n\n\t\tif (a <= l && r <= b) return Min[k];\n\n\t\tint vl = get_min(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = get_min(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn min(vl, vr);\n\t}\n\n\tint get_max(int a, int b, int k = 0, int l = 0, int r = -1) // [a, b)???max\n\t{\n\t\tif (r == -1) r = n;\n\n\t\tif (r <= a || b <= l) return -inf;\n\n\t\tif (a <= l && r <= b) return Max[k];\n\n\t\tint vl = get_max(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = get_max(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn max(vl, vr);\n\t}\n};\n\nint X[200020], Y[200020];\n\nsigned main()\n{\n\tomajinai;\n\n\tint N, d; cin >> N >> d;\n\n\tSegTree x_seg, y_seg;\n\n\tx_seg.init(N), y_seg.init(N);\n\n\tvpii hoge;\n\n\trep(i, N) {\n\t\tint x, y, b; cin >> x >> y >> b;\n\t\tX[i] = x, Y[i] = y;\n\n\t\thoge.PB(pii(b, i));\n\t}\n\n\tsort(all(hoge));\n\n\trep(i, N) {\n\t\tx_seg.min_update(i, X[hoge[i].scd]);\n\t\tx_seg.max_update(i, X[hoge[i].scd]);\n\n\t\ty_seg.min_update(i, Y[hoge[i].scd]);\n\t\ty_seg.max_update(i, Y[hoge[i].scd]);\n\t}\n\n\tll ans = -inf;\n\n\trep(i, N) {\n\t\tif (i > 0 && hoge[i].fst == hoge[i - 1].fst) continue;\n\n\t\tint b = hoge[i].fst;\n\n\t\tint idx = upper_bound(all(hoge), pii(b + d, inf)) - hoge.begin();\n\n\t\tint min_x = x_seg.get_min(i, idx);\n\t\tint max_x = x_seg.get_max(i, idx);\n\n\t\tint min_y = y_seg.get_min(i, idx);\n\t\tint max_y = y_seg.get_max(i, idx);\n\n\t\tans = max(ans, 1ll * (max_x - min_x) * (max_y - min_y));\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int LL\ntypedef long long LL;\nconst int INF = 2002002002;\n\nstruct DATA {\n\tint minx, miny, maxx, maxy;\n};\n\nstruct STAR {\n\tint x, y, b;\n\tbool operator < (const STAR &t) const {\n\t\treturn b < t.b;\n\t}\n};\n\nint n, d;\nSTAR star[1 << 19];\n\nint N;\nDATA data[1 << 20];\n\n\nvoid init(int n)\n{\n\tfor (N = 1; N < n; N <<= 1);\n\tfill(data, data + (1 << 20), (DATA){INF, INF, -INF, -INF});\n}\n\nvoid update(int i, STAR s)\n{\n\ti += N - 1;\n\tdata[i].minx = min(data[i].minx, s.x);\n\tdata[i].miny = min(data[i].miny, s.y);\n\tdata[i].maxx = max(data[i].maxx, s.x);\n\tdata[i].maxy = max(data[i].maxy, s.y);\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tdata[i].minx = min(data[i].minx, s.x);\n\t\tdata[i].miny = min(data[i].miny, s.y);\n\t\tdata[i].maxx = max(data[i].maxx, s.x);\n\t\tdata[i].maxy = max(data[i].maxy, s.y);\n\t}\n}\n\nDATA query(int a, int b, int k, int l, int r)\n{\n\t//printf(\"%d %d %d %d %d\\n\", a, b, k, l, r);\n\tif (r <= a || b <= l) return (DATA){INF, INF, -INF, -INF};\n\tif (a <= l && r <= b) return data[k];\n\tDATA vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tDATA vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn (DATA){min(vl.minx, vr.minx), min(vl.miny, vr.miny), max(vl.maxx, vr.maxx), max(vl.maxy, vr.maxy)};\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tinit(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d %d\", &star[i].x, &star[i].y, &star[i].b);\n\t\tstar[i].x; star[i].y;\n\t}\n\tfor (int i = n; i < 1 << 19; i++){\n\t\tstar[i].b = INF;\n\t}\n\t\n\tsort(star, star + n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tupdate(i, star[i]);\n\t}\n\t\n\t//printf(\"%lld\\n\", (LL)INF * INF);\n\t\n\tLL res = 0;\n\tfor (int l = 0; star[l].b != INF; ){\n\t\tint r = l;\n\t\twhile (star[r].b - star[l].b <= d) r++;\n\t\t\n\t\tDATA q = query(l, r, 0, 0, N);\n\t\tLL t = (LL)(q.maxx - q.minx) * (q.maxy - q.miny);\n\t\tres = max(res, t);\n\t\t\n\t\tl++;\n\t\twhile (star[l + 1].b == star[l].b) l++;\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"climits\"\n#define MAX 100000\nint star;\nint dif;\nint box_x[MAX];\nint x[MAX];\nint y[MAX];\nint box_y[MAX];\nint blight[MAX];\nint box[MAX];\nint end[MAX]={};\nint x_max=0;\nint x_min=INT_MAX;\nint y_max=0;\nint y_min=INT_MAX;\nint child;\nint fig = 1;\nint RMinQx[MAX * 4];\nint RMinQy[MAX * 4];\nint RMaxQx[MAX * 4];\nint RMaxQy[MAX * 4];\nint left[MAX * 4];\nint right[MAX * 4];\nlong long int ans=0;\n\nvoid MergeSort(int n[],int _x[],int _y[], int left, int right) {\n\tint mid;\n\tif (left == right)return;\n\tmid = (left + right) / 2;\n\tMergeSort(n,_x,_y, left, mid);\n\tMergeSort(n,_x,_y, mid + 1, right);\n\tfor (int i = left; i <= mid; i++) {\n\t\tbox[i] = n[i];\n\t\tbox_x[i] = _x[i];\n\t\tbox_y[i] = _y[i];\n\t}\n\tfor (int i = mid + 1, j = right; i <= right; i++, j--) {\n\t\tbox[i] = n[j];\n\t\tbox_x[i] = _x[j];\n\t\tbox_y[i] = _y[j];\n\t}\n\tint a = left, b = right;\n\tfor (int i = left; i <= right; i++) {\n\t\tif (box[a] <= box[b]) {\n\t\t\tn[i] = box[a];\n\t\t\t_x[i] = box_x[a];\n\t\t\t_y[i] = box_y[a++];\n\t\t}\n\t\telse {\n\t\t\tn[i] = box[b];\n\t\t\tx[i] = box_x[b];\n\t\t\ty[i] = box_y[b--];\n\t\t}\n\t}\n}\n\nint max(int a, int b) {\n\tif (a > b)return a;\n\treturn b;\n}\n\nint min(int a, int b) {\n\tif (a < b)return a;\n\treturn b;\n}\n\nint SegMax(int x[],int a) {\n\tif (a < child) {\n\t\tx[a] = max(SegMax(x,a * 2),SegMax(x, a * 2 + 1));\n\t}\n\treturn x[a];\n}\n\nint SegMin(int x[],int a) {\n\tif (a < child) {\n\t\tx[a] = min(SegMin(x, a * 2), SegMin(x, a * 2 + 1));\n\t}\n\treturn x[a];\n}\n\nint RangeL(int l[],int a) {\n\tif (a < child) {\n\t\tl[a] = min(RangeL(l, a * 2),RangeL(l,a*2+1));\n\t}\n\treturn l[a];\n}\n\nint RangeR(int r[], int a) {\n\tif (a < child) {\n\t\tr[a] = max(RangeR(r, a * 2), RangeR(r, a * 2 + 1));\n\t}\n\treturn r[a];\n}\n\nint RMinQ(int n[],int a, int b,int num) {\n\tif (a > right[num] || b < left[num])return INT_MAX;\n\tif (a <= left[num] && b >= right[num])return n[num];\n\treturn min(RMinQ(n, a, b, num * 2), RMinQ(n, a, b, num * 2 + 1));\n}\n\nint RMaxQ(int n[],int a, int b,int num) {\n\tif (a > right[num] || b < left[num])return 0;\n\tif (a <= left[num] && b >= right[num])return n[num];\n\treturn max(RMaxQ(n, a, b, num * 2), RMaxQ(n, a, b, num * 2 + 1));\n}\n\nint main() {\n\tscanf(\"%d %d\", &star, &dif);\n\tfor (int i = 0; i < star; i++) {\n\t\tscanf(\"%d %d %d\", &x[i], &y[i], &blight[i]);\n\t}\n\twhile (1) {\n\t\tif (fig >= star) {\n\t\t\tchild = fig;\n\t\t\tbreak;\n\t\t}\n\t\tfig *= 2;\n\t}\n\tMergeSort(blight,x,y, 0, star - 1);\n\tfor (int i = 0; i < star; i++) {\n\t\tRMaxQx[child + i] = x[i];\n\t\tRMinQx[child + i] = x[i];\n\t\tRMaxQy[child + i] = y[i];\n\t\tRMinQy[child + i] = y[i];\n\t}\n\tfor (int i = star; i < child; i++) {\n\t\tRMaxQx[child + i] = 0;\n\t\tRMinQx[child + i] = INT_MAX;\n\t\tRMaxQy[child + i] = 0;\n\t\tRMinQy[child + i] = INT_MAX;\n\t}\n\tSegMax(RMaxQx, 1);\n\tSegMax(RMaxQy, 1);\n\tSegMin(RMinQx, 1);\n\tSegMin(RMinQy, 1);\n\n\t//printf(\"%d %d %d %d\\n\", RMaxQx[1], RMaxQy[1], RMinQx[1], RMinQy[1]);\n\n\tfor (int i = 0; i < child; i++) {\n\t\tleft[child + i] = i;\n\t\tright[child + i] = i;\n\t}\n\n\tRangeR(right, 1);\n\tRangeL(left, 1);\n\n\t//for (int i = 1; i < child; i++) {\n\t//\tprintf(\"%d %d\\n\", left[i], right[i]);\n\t//}\n\n\tfor (int i = 1; i < star; i++) {\n\t\tif (blight[i] - blight[0] > dif) break;\n\t\tend[0] = i;\n\t}\n\tfor (int i = 1; i < star; i++) {\n\t\tfor (int j = end[0]; j < star; j++) {\n\t\t\tif (blight[j] - blight[i] > dif) break;\n\t\t\tend[i] = j;\t\n\t\t}\n\t//\tprintf(\"%d\\n\", end[i]);\n\t}\n\tfor (int i = 0; i < star; i++) {\n\t/*\tprintf(\"%d\\n\", RMaxQ(RMaxQx, i, end[i], 1));*/\n\t\t//printf(\"%lld\\n\", (long long int)(RMaxQ(RMaxQx, i, end[i], 1) - (long long int)RMinQ(RMinQx, i, end[i], 1))*((long long int)RMaxQ(RMaxQy, i, end[i], 1) - (long long int)RMinQ(RMinQy, i, end[i], 1)));\n\t\tif (ans < (long long int)(RMaxQ(RMaxQx, i, end[i], 1) - (long long int)RMinQ(RMinQx, i, end[i], 1))*((long long int)RMaxQ(RMaxQy, i, end[i], 1) - (long long int)RMinQ(RMinQy, i, end[i], 1))) {\n\t\t\tans = (long long int)(RMaxQ(RMaxQx, i, end[i], 1) - (long long int)RMinQ(RMinQx, i, end[i], 1))*((long long int)RMaxQ(RMaxQy, i, end[i], 1) - (long long int)RMinQ(RMinQy, i, end[i], 1));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<stdlib.h>\n#define int long long\nusing namespace std;\n\nint n, d;\t//1 <= n <= 2*10^5, 0 <= d <= 10^9\nstruct Star {\n\tint x, y, b;\n}star[200000];\n\nsigned compare(const void *s1, const void *s2) {\n\tint t1 = ((Star*)s1)->b;\n\tint t2 = ((Star*)s2)->b;\n\treturn t1 - t2;\n}\nsigned main() {\n\tint i;\n\tcin >> n >> d;\n\tfor( i = 0; i < n; i++ )\n\t\tcin >> star[i].x >> star[i].y >> star[i].b;\n\tqsort(star, n, sizeof(star[0]), compare);\n\n\tstatic multiset<int> X;\n\tstatic multiset<int> Y;\n\tmultiset<int>::iterator it;\n\tmultiset<int>::reverse_iterator rit;\n\tint ins = 0;\n\tint del = 0;\n\tint j;\n\tint ans = 0;\n\n\t/*for( i = 0; i < n; i++ ) {\n\t\tprintf(\"index = %d x = %d y = %d b = %d\\n\", i, star[i].x, star[i].y, star[i].b);\n\t}*/\n\n\tfor( i = 0; i < n; i++ ) {\n\t\tins = i;\n\t\tX.insert( star[ins].x );\n\t\tY.insert( star[ins].y );\n\t\tfor(; del < n; del++ ) {\n\t\t\tif( star[del].b < star[i].b - d ) {\n\t\t\t\tit = X.find( star[del].x );\n\t\t\t\tX.erase( it );\n\t\t\t\tit = Y.find( star[del].y );\n\t\t\t\tY.erase( it );\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tit = X.begin();\n\t\tint minx = *it;\n\t\trit = X.rbegin();\n\t\tint maxx = *rit;\n\t\tit = Y.begin();\n\t\tint miny = *it;\n\t\trit = Y.rbegin();\n\t\tint maxy = *rit;\n\t\tans = max( ans, (maxx - minx) * (maxy - miny) );\n\n\t\t//printf(\"ins = %d, del = %d, x[%d, %d], y[%d, %d]\\n\", ins, del, minx, maxx, miny, maxy);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef vector<int> vi;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n//26\n\n//2000000\npriority_queue<P, vector<P>, greater<P> > q1[2];\npriority_queue<P> q2[2];\nstruct st{int x, y, c;};\nvector<st> vec;\nvector<P> X, Y;\n//int XX[400000], YY[400000];\nsigned main(){\n\tint n, d;\n\tscanf(\"%lld%lld\", &n, &d);\n\trep(i,n){\n\t\tint x, y, c;\n\t\tscanf(\"%lld%lld%lld\", &x, &y, &c);\n\t\tvec.push_back((st){x, y, c});\n\t\tX.push_back(P(c, x));\n\t\tY.push_back(P(c, y));\n\t}\n\tsort(all(X));sort(all(Y));\n\t\n\tint ans = 0, cnt1 = 0, cnt2 = 0, dd = 0;\n\twhile(cnt1 < n or cnt2 < n){\n\t\tP p;int f;\n\t\tif(cnt2 == n){p = X[cnt1];cnt1++;f = 0;}\n\t\telse if(cnt1 == n){p = Y[cnt2];cnt2++;f = 1;}\n\t\telse if(X[cnt1] < Y[cnt2]){p = X[cnt1];cnt1++;f = 0;}\n\t\telse {p = Y[cnt2];cnt2++;f = 1;}\n\t\tdd = p.fi;\n\t\t\n\t\tq1[f].push(P(p.se, p.fi));\n\t\tq2[f].push(P(p.se, p.fi));\n\t\trep(i,2){\n\t\t\twhile(!q1[i].empty() and dd-d > q1[i].top().se)q1[i].pop();\n\t\t\twhile(!q2[i].empty() and dd-d > q2[i].top().se)q2[i].pop();\n\t\t}\n\t\tint tmp[2] = {0, 0}, mx = -1, mn = -1;\n\t\trep(i,2){\n\t\t\tif(!q2[i].empty())mx = q2[i].top().fi;\n\t\t\tif(!q1[i].empty())mn = q1[i].top().fi;\n\t\t\tif(mx != -1 and mn != -1)tmp[i] = mx-mn;\n\t\t}\n\t\tans = max(ans, tmp[0]*tmp[1]);\n\t\t//printf(\"%lld %lld\\n\", p.fi, p.se);\n\t}\n\t//cout << p;\n\t//printf(\"%lld \", p);\n\t//if(f == 0)\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define Rrep(i, m, n) for(int i=(m);i<(n);i++)\n#define All(v) v.begin(),v.end()\n#define Uniq(v) v.erase(unique(All(v)),v.end())\ntypedef pair<ll, ll> Pii;\ntypedef pair<ll, Pii> Pip;\ntypedef pair<string, int> Psi;\ntypedef vector<int> Vi;\nconst int INF = (1<<30);\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\n\nconst int MAX_N = 1 << 17;\n\nll n, d;\nll datx1[2 * MAX_N - 1];\nll datx2[2 * MAX_N - 1];\nll daty1[2 * MAX_N - 1];\nll daty2[2 * MAX_N - 1];\n\nvoid init(ll n_, ll dat[]) {\n  n = 1;\n  while( n < n_ ) n *= 2;\n  for(int i=0; i<2*n-1; i++) dat[i] = INT_MAX;\n}\n\nvoid update(ll k, ll a, ll dat[]) {\n  k += n - 1;\n  dat[k] = a;\n  while( k > 0 ) {\n    k = (k - 1) / 2;\n    dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n}\n\nint query(ll a, ll b, ll k, ll l, ll r, ll dat[]) {\n  if( r <= a || b <= l ) return INT_MAX;\n  if( a <= l && r <= b ) return dat[k];\n  else {\n    ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2, dat);\n    ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r, dat);\n    return min(vl, vr);\n  }\n}\n\nint main()\n{\n  cin >> n >> d;\n  ll N = n;\n  init(N+1, datx1);init(N+1, datx2);init(N+1, daty1);init(N+1, daty2);\n  vector<ll> bData;\n  vector<Pip> allData;\n  for(int i=0; i<N; i++) {\n    ll a, b, c;\n    cin >> a >> b >> c;\n    bData.pb( c );\n    allData.pb( Pip(c, Pii(a, b)) );\n  }\n\n  sort( All(allData) );\n\n  for(int i=0; i<N; i++) {\n    ll x = allData[i].sc.fr, y = allData[i].sc.sc;\n    update(i, x, datx1);\n    update(i, -x, datx2);\n    update(i, y, daty1);\n    update(i, -y, daty2);\n  }\n\n  ll s, t; s = t = 0;\n  ll ma = 0;\n  for(int i=1; i<N-1; i++) {\n    t = i;\n    while( 1 ) {\n      if( allData[t].fr - allData[s].fr <= d ) break;\n      s++;\n    }\n    ll x1 = query(s, t+1, 0, 0, n, datx1);\n    ll x2 = query(s, t+1, 0, 0, n, datx2);\n    ll y1 = query(s, t+1, 0, 0, n, daty1);\n    ll y2 = query(s, t+1, 0, 0, n, daty2);\n\n    ll tmp = ((-x2) - x1) * ((-y2) - y1);\n    if( tmp > ma ) {\n      ma = tmp;\n    }\n  }\n\n  cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, D;\nint X[200000], Y[200000], B[200000];\nmultiset<int> Sx, Sy;\n\nvoid add(int x) {\n  Sx.insert(X[x]);\n  Sy.insert(Y[x]);\n}\nvoid del(int x) {\n  Sx.erase(Sx.find(X[x]));\n  Sy.erase(Sy.find(Y[x]));\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> D;\n  vector<P> xs;\n  rep(i, N) {\n    cin >> X[i] >> Y[i] >> B[i];\n    xs.pb(P(B[i], i));\n  }\n  sort(all(xs));\n  long long m = 0;\n  int r = 0;\n  for (P p : xs) {\n    int x = p._2;\n    while (r < N && xs[r]._1 <= B[x]+D) add(xs[r++]._2);\n    if (!Sx.empty()) {\n      m = max(m, 1LL*(*Sx.rbegin() - *Sx.begin()) * (*Sy.rbegin() - *Sy.begin()));\n    }\n    del(x);\n  }\n  cout << m << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<climits>\n#include<algorithm>\n\nconst long long int INF = INT_MAX;\nconst long long int NIL = -1;\nint leftMostBit(int x) {\n  if(x == 0) return 0;\n  x = (x & 0x55555555) << 1 | (x >> 1) & 0x55555555;\n  x = (x & 0x33333333) << 2 | (x >> 2) & 0x33333333;\n  x = (x & 0x0f0f0f0f) << 4 | (x >> 4) & 0x0f0f0f0f;\n  x = (x << 24) | ((x & 0xff00) << 8) | ((x >> 8) & 0xff00) | (x >> 24);\n  int deBruijnSequence[32] = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14};\n  return 31 - deBruijnSequence[((x & -x) * 0x076be629U) >> 27];\n}\nclass RangeMinimumQuery {\npublic:\n  RangeMinimumQuery(int s) {\n    size_ = 1 << leftMostBit(s);\n    if(size_ != s) size_ <<= 1;\n    node_ = std::vector<long long int>((size_ << 1) - 1, INF);\n  }\n  long long int find(int left, int right) const {\n    return query(left, right, 0, 0, size_ - 1);\n  }\n  void update(int index, int value) {\n    int i = index + size_ - 1;\n    node_[i] = value;\n    while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n  }\nprivate:\n  int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n  int left_child(int node) const {return (node << 1) + 1;}\n  int right_child(int node) const {return (node << 1) + 2;}\n  long long int query(int a, int b, int k, int l, int r) const {\n    if(b < l || r < a) return INF;\n    if(a <= l && r <= b) return node_[k];\n    int vl = query(a, b, left_child(k), l, (l + r) / 2);\n    int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n    return std::min(vl, vr);\n  }\n\n  int size_;\n  std::vector<long long int> node_;\n};\n\n#include<iostream>\nusing namespace std;\n\nstruct Star {long long int x, y, b;};\nbool operator<(const Star& lhs, const Star& rhs) {return lhs.b < rhs.b;}\n\nint main() {\n  int N, d;\n  cin >> N >> d;\n  vector<Star> star(N);\n  for(auto& s: star) cin >> s.x >> s.y >> s.b;\n  sort(begin(star), end(star));\n  RangeMinimumQuery left(N), right(N), top(N), bottom(N);\n  for(int i = 0; i < N; ++i) {\n    left.update(i, star[i].x);\n    right.update(i, -star[i].x);\n    top.update(i, star[i].y);\n    bottom.update(i, -star[i].y);\n  }\n  long long int answer = 0;\n  int low, high;\n  for(low = high = 0; low < N; ++low) {\n    while(high < N - 1 && star[high].b - star[low].b < d) ++high;\n    long long int area = -right.find(low, high) - left.find(low, high);\n    area *= -bottom.find(low, high) - top.find(low, high);\n    answer = max(answer, abs(area));\n  }\n  cout << answer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n#define N 200000\n#define F first\n#define S second\n#define MP(i, j) make_pair((i), (j))\n#define int long long\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pi;\nint cnt;\nvoid init(int n_, int *dat){\n\tcnt = 1;\n\twhile(cnt < n_) cnt *= 2;\n\tfor(int i = 0; i < 2 * cnt - 1; i++) dat[i] = INT_MAX;\n}\nvoid update(int k, int a, int *dat){\n\tk += cnt - 1;\n\tdat[k] = a;\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nint query(int a, int b, int k, int l, int r, int *dat){\n\tif(r <= a || b <= l) return INT_MAX;\n\tif(a <= l && r <= b) return dat[k];\n\telse{\n\t\tint v1 = query(a, b, k * 2 + 1, l, (l + r) / 2, dat);\n\t\tint vr = query(a, b, k * 2 + 2, (l + r) / 2, r, dat);\n\t\treturn min(v1, vr);\n\t}\n}\n\nint i, j, n, d, ax[2 * N], bx[2 * N], ay[2 * N], by[2 * N], ans;\nPi stars[N];\n\nsigned main(){\n\tcin >> n >> d;\n\tfor(i = 0; i < n; i++){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tstars[i] = MP(c, MP(a, b));\n\t}\n\tsort(stars, stars + n);\n\tinit(n, ax); init(n, bx); init(n, ay); init(n, by);\n\tfor(i = 0; i < n; i++){\n\t\tupdate(i, stars[i].S.F, ax);\n\t\tupdate(i, -stars[i].S.F, bx);\n\t\tupdate(i, stars[i].S.S, ay);\n\t\tupdate(i, -stars[i].S.S, by);\n\t}\n\ti = 0; j = 0;\n\tfor(;;){\n\t\twhile(j < n){\n\t\t\tif(stars[j].F - stars[i].F <= d)\n\t\t\t\tj++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tans = max(ans, (-query(i, j, 0, 0, cnt, bx) - query(i, j, 0, 0, cnt, ax)) * (-query(i, j, 0, 0, cnt, by) - query(i, j, 0, 0, cnt, ay)));\n\t\tif(j == n)\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> P;\ntypedef long long ll;\n\nint main(){\n    int n, D;\n    cin >> n >> D;\n    vector<pii> v;\n    vector<int> x(n), y(n), b(n);\n    for(int i = 0; i < n; i++){\n        cin >> x[i] >> y[i] >> b[i];\n        v.push_back({b[i],i});\n    }\n    sort(v.begin(), v.end());\n    vector<bool> ng(n, 0);\n    priority_queue<pii> l, r, u, d;\n    ll ans = 0;\n    for(int j = 0; j < n; j++){\n        int i = v[j].second;\n        int to = v[j].first;\n        l.push({-x[i], i}); d.push({-y[i], i});\n        r.push({x[i], i});  u.push({y[i], i});\n        bool update = true;\n        while(update){\n            update = false;\n            while(!l.empty()&&(ng[l.top().second]||abs(b[l.top().second]-to)>D)){\n                ng[l.top().second] = true;  l.pop();    update = true;\n            }\n            while(!d.empty()&&(ng[d.top().second]||abs(b[d.top().second]-to)>D)){\n                ng[d.top().second] = true;  d.pop();    update = true;\n            }\n            while(!r.empty()&&(ng[r.top().second]||abs(b[r.top().second]-to)>D)){\n                ng[r.top().second] = true;  r.pop();    update = true;\n            }\n            while(!u.empty()&&(ng[u.top().second]||abs(b[u.top().second]-to)>D)){\n                ng[u.top().second] = true;  u.pop();    update = true;\n            }\n        }\n        // printf(\"%d %d %d %d\\n\", r.top().first, l.top().first, u.top().first, d.top().first);\n        ans = max(ans, (ll)(r.top().first+l.top().first)*(u.top().first+d.top().first));\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1ll<<60)\n#define MAX_N 200000\ntypedef long long ll;\n\nstruct MinSegtree\n{\n  int n;\n  ll dat[2*MAX_N-1];\n  MinSegtree(int _n)\n  {\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*21;i++)\n      dat[i] = INF;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n\n  ll query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return INF;\n\n    if(a <= l && r <= b) return dat[k];\n    else{\n      ll vl = query(a, b, k*2+1, l, (l + r) / 2);\n      ll vr = query(a, b, k*2+2, (l + r) / 2, r);\n      return min(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nstruct MaxSegtree\n{\n  int n;\n  ll dat[2*MAX_N-1];\n  MaxSegtree(int _n){\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*2-1;i++)\n      dat[i] = -1;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n  \n  ll query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return -1;\n    \n    if(a <= l && r <=b ) return dat[k];\n    else{\n      ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n      ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n      return max(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nint main()\n{\n  int n, d;\n  scanf(\"%d%d\", &n, &d);\n  MinSegtree minx(n);\n  MinSegtree miny(n);\n  MaxSegtree maxx(n);\n  MaxSegtree maxy(n);\n  \n  vector<pair<ll, pair<ll, ll> > >s(n);\n  vector<ll>br(n);\n  for(int i=0;i<n;i++){\n    ll x, y; ll b;\n    scanf(\"%d%d%lld\", &x, &y, &b);\n    s[i] = make_pair(b, make_pair(x, y));\n    br[i] = b;\n  }\n  sort(s.begin(), s.end());\n  sort(br.begin(), br.end());\n\n\n  for(int i=0;i<n;i++){\n    minx.update(i, s[i].second.first);\n    maxx.update(i, s[i].second.first);\n    miny.update(i, s[i].second.second);\n    maxy.update(i, s[i].second.second);\n  }\n\n  br.push_back(INF);\n  ll res = 0;\n  for(int i=0;i<n;i++){\n    int pos = (int)(upper_bound(br.begin(), br.end(), br[i] + d) - br.begin());\n    ll w = maxx.query(i, pos, 0, 0, maxx.size()) - minx.query(i, pos, 0, 0, minx.size());\n    ll h = maxy.query(i, pos, 0, 0, maxy.size()) - miny.query(i, pos, 0, 0, miny.size());\n    res = max(res, w * h);\n  }\n\n  printf(\"%lld\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define b first\n#define x second.first\n#define y second.second\n#define INF 2000000\nusing namespace std;\npair<int,pair<int,int> >s[INF];\nint main(){\n  int n,d,an=0;\n  cin>>n>>d;\n  for(int i=0;i<n;i++)cin>>s[i].x>>s[i].y>>s[i].b;\n  sort(s,s+n);\n  for(int i=0;i<n;i++){\n    int xmn,xmx,ymn,ymx;\n    xmn=ymn=INF;xmx=ymx=0;\n    for(int j=i;s[j].b-s[i].b<=d&&j<n;j++){\n      xmx=max(xmx,s[j].x);\n      ymx=max(ymx,s[j].y);\n      xmn=min(xmn,s[j].x);\n      ymn=min(ymn,s[j].y);\n    }\n    if(xmn!=INF)an=max(an,(xmx-xmn)*(ymx-ymn));\n  }\n  cout<<an<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n\nclass C{\n  public:\n    int x, y, b;\n    C(){}\n    C(int xx, int yy, int bb) { x = xx; y = yy; b = bb; }\n    bool operator < (const C &c) const { return b < c.b; }\n};\n \nint main() {\n  int N, d, ans = 0; cin >>N >>d;\n  vector<C> cs(N);\n  REP(i, N) cin >>cs[i].x >>cs[i].y >>cs[i].b;\n  SORT(cs);\n  multiset<int> xs{cs[0].x}, ys{cs[0].y};\n  for(int l = 0, r = 1; l < N; l++){\n    for( ; r < N && cs[r].b - cs[l].b <= d; r++){\n      xs.insert(cs[r].x);\n      ys.insert(cs[r].y);\n      ans = max(ans, (*xs.rbegin() - *xs.begin()) * (*ys.rbegin() - *ys.begin()));\n    }\n    xs.erase(xs.lower_bound(cs[l].x));\n    ys.erase(ys.lower_bound(cs[l].y));\n  }\n  cout <<ans <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n#define MAX_N 200000\n#define F first\n#define Se second\n#define MP(i, j) make_pair((i), (j))\nstruct S{\n\tint sx, lx, sy, ly;\n\tS(int isx, int ilx, int isy, int ily): sx(isx), lx(ilx), sy(isy), ly(ily){}\n\tbool operator<(const S &s) const { \n\t\treturn 1;\n\t}\n};\nint cnt;\nvoid init(int n_, int *dat){\n\tcnt = 1;\n\twhile(cnt < n_) cnt *= 2;\n\tfor(int i = 0; i < 2 * cnt - 1; i++) dat[i] = INT_MAX;\n}\nvoid update(int k, int a, int *dat){\n\tk += cnt - 1;\n\tdat[k] = a;\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nint query(int a, int b, int k, int l, int r, int *dat){\n\tif(r <= a || b <= l) return INT_MAX;\n\tif(a <= l && r <= b) return dat[k];\n\telse{\n\t\tint v1 = query(a, b, k * 2 + 1, l, (l + r) / 2, dat);\n\t\tint vr = query(a, b, k * 2 + 2, (l + r) / 2, r, dat);\n\t\treturn min(v1, vr);\n\t}\n}\ntypedef pair<int, S> PS;\ntypedef vector<PS>::iterator it;\n\nint i, j, n, d, stars[MAX_N][3], ax[1 << 11], bx[1 << 11], ay[1 << 11], by[1 << 11];\nint ans = 0;\nvector<PS> vec;\n\nvoid vdc(vector<PS> &vf, S s, int now){\n\tif(vf[now].Se.sx > s.sx)\n\t\tvf[now].Se.sx = s.sx;\n\tif(vf[now].Se.lx < s.lx)\n\t\tvf[now].Se.lx = s.lx;\n\tif(vf[now].Se.sy > s.sy)\n\t\tvf[now].Se.sy = s.sy;\n\tif(vf[now].Se.ly < s.ly)\n\t\tvf[now].Se.ly = s.ly;\n}\n\nint main(){\n\tcin >> n >> d;\n\tvec.push_back(MP(-1, S(0, 0, 0, 0)));\n\tfor(i = 0; i < n; i++){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tS s = S(a, a, b, b);\n\t\tit ite = lower_bound(vec.begin(), vec.end(), MP(c, s));\n\t\tif(vec[ite - vec.begin() - 1].F != c){\n\t\t\tvec.insert(ite, MP(c, s));\n\t\t}\n\t\telse{\n\t\t\tvdc(vec, s, ite - vec.begin() - 1);\n\t\t}\n\t}\n\tinit(vec.size(), ax);\n\tinit(vec.size(), bx);\n\tinit(vec.size(), ay);\n\tinit(vec.size(), by);\n\tS s = S(INT_MAX, 0, INT_MAX, 0);\n\tvec.erase(vec.begin());\n\tfor(i = 0; i < vec.size(); i++){\n\t\tupdate(i, vec[i].Se.sx, ax);\n\t\tupdate(i, -vec[i].Se.lx, bx);\n\t\tupdate(i, vec[i].Se.sy, ay);\n\t\tupdate(i, -vec[i].Se.ly, by);\n\t}\n\ti = 0; j = 0;\n\tfor(;;){\n\t\twhile(j < vec.size()){\n\t\t\tif(vec[j].F - vec[i].F <= d)\n\t\t\t\tj++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tans = max(ans, (-query(i, j, 0, 0, cnt, bx) - query(i, j, 0, 0, cnt, ax)) * (-query(i, j, 0, 0, cnt, by) - query(i, j, 0, 0, cnt, ay)));\n\t\tif(j == vec.size())\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <vector>\n#include <utility>\n#include <numeric>\n#include <string>\n#include <set>\n#include <map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#define rep(i, a, n) for(int (i) = (int)(a);(i) < (int)(n);++(i))\n#define repe(i, a, n) for(int (i) = (int)(a);(i) <= (int)(n);++(i))\n#define repr(i, a, n) for(int (i) = (int)(a);(i) > (int)(n);--(i))\n#define reper(i, a, n) for(int (i) = (int)(a);(i) >= (int)(n);--(i))\n#define SIZE(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define RNG(x, n) &((x)[0]), &((x)[n])\n#define SUBIF(a, b, x) ((x) ? (b) : (a))\n#define YES cout << \"YES\" << endl\n#define NO cout << \"NO\" << endl\n#define Yes cout << \"Yes\" << endl\n#define No cout << \"No\" << endl\n#define yes cout << \"yes\" << endl;\n#define no cout << \"no\" << endl;\n#define pb push_back\n#define EPS (1e-20)\n#define INF 2147483647LL\n#define MOD 1000000007LL\nusing llint = long long;\nusing VI = std::vector<int>;\nusing PII = std::pair<int, int>;\nusing SI = std::set<int>;\nusing MII = std::map<int, int>;\nusing TIII = std::tuple<int, int, int>;\nusing namespace std;\n\n\nstruct SEG {\n\tvector<PII> seg;\n\tint aryN;\n\tint segN;\n\n\tint inToN(int i){\n\t\treturn aryN+i-1;\n\t}\n\tint p(int i){\n\t\treturn (i-1)/2;\n\t}\n\tvoid update(int n){\n\t\tif(n == 0) return;\n\t\tseg[p(n)].first = max(seg[p(n)].first, seg[n].first);\n\t\tseg[p(n)].second = min(seg[p(n)].second, seg[n].second);\n\t\tupdate(p(n));\n\t}\n\tvoid init(int n){\n\t\taryN = (int)pow(2, (int)ceil(log2(n)));\n\t\tsegN = 2*aryN-1;\n\t\tseg = vector<PII>(segN);\n\t}\n\tvoid initSEG(){\n\t\trep(i, 0, aryN) seg[i] = { 0, (int)INF };\n\t\trep(i, 0, aryN) update(inToN(i));\n\t}\n\tint getMax(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = aryN;\n\t\tif(r <= a || b <= l) return -1;\n\t\tif(a <= l && r <= b) return seg[k].first;\n\t\tint vl = getMax(a, b, 2*k+1, l, (l+r)/2);\n\t\tint vr = getMax(a, b, 2*k+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n\tint getMin(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = aryN;\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <= b) return seg[k].second;\n\t\tint vl = getMin(a, b, 2*k+1, l, (l+r)/2);\n\t\tint vr = getMin(a, b, 2*k+2, (l+r)/2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\n\nint N, d;\nTIII star[200010];\nSEG X, Y;\nint br[200010];\n\n\nvoid makeXY(){\n\tX.init(N), Y.init(N);\n\trep(i, 0, N) X.seg[X.inToN(i)] = { get<1>(star[i]), get<1>(star[i]) }, Y.seg[Y.inToN(i)] = { get<2>(star[i]), get<2>(star[i]) };\n\tX.initSEG(), Y.initSEG();\n}\n\n\nint solve(){\n\tint ans = 0;\n\trep(i, 0, N) br[i] = get<0>(star[i]);\n\trep(i, 0, N){\n\t\tint p = upper_bound(RNG(br, N), br[i]+d)-&br[0];\n\t\tint x1 = X.getMax(i, p), x2 = X.getMin(i, p);\n\t\tint y1 = Y.getMax(i, p), y2 = Y.getMin(i, p);\n\t\tans = max(ans, (x1-x2)*(y1-y2));\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> N >> d;\n\trep(i, 0, N) cin >> get<1>(star[i]) >> get<2>(star[i]) >> get<0>(star[i]);\n\tsort(RNG(star, N));\n\n\tmakeXY();\n\t\n\tcout << solve() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <vector>\n#include <utility>\n#include <numeric>\n#include <string>\n#include <set>\n#include <map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#define rep(i, a, n) for(int (i) = (int)(a);(i) < (int)(n);++(i))\n#define repe(i, a, n) for(int (i) = (int)(a);(i) <= (int)(n);++(i))\n#define repr(i, a, n) for(int (i) = (int)(a);(i) > (int)(n);--(i))\n#define reper(i, a, n) for(int (i) = (int)(a);(i) >= (int)(n);--(i))\n#define SIZE(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define RNG(x, n) &((x)[0]), &((x)[n])\n#define SUBIF(a, b, x) ((x) ? (b) : (a))\n#define YES cout << \"YES\" << endl\n#define NO cout << \"NO\" << endl\n#define Yes cout << \"Yes\" << endl\n#define No cout << \"No\" << endl\n#define yes cout << \"yes\" << endl;\n#define no cout << \"no\" << endl;\n#define pb push_back\n#define EPS (1e-20)\n#define INF 2147483647\n#define MOD 1000000007\nusing llint = long long;\nusing VI = std::vector<int>;\nusing PII = std::pair<int, int>;\nusing SI = std::set<int>;\nusing MII = std::map<int, int>;\nusing TIII = std::tuple<int, int, int>;\nusing namespace std;\n\n\nstruct SEG {\n\tint aryN;\n\tvector<PII> seg;\n\n\tSEG(){}\n\tSEG(const VI &v){\n\t\taryN = (int)pow(2, (int)ceil(log2(SIZE(v))));\n\t\tseg.resize(2*aryN-1, { -1, INF });\n\t\trep(i, 0, SIZE(v)) seg[i+aryN-1] = { v[i], v[i] };\n\t\treper(i, aryN-2, 0) seg[i].first = max(seg[2*i+1].first, seg[2*i+2].first), seg[i].second = min(seg[2*i+1].second, seg[2*i+2].second);\n\t}\n\tvoid update(int x, PII p){\n\t\tx += (aryN-1);\n\t\tseg[x] = p;\n\t\twhile(x > 0){\n\t\t\tx = (x-1)/2;\n\t\t\tseg[x].first = max(seg[2*x+1].first, seg[2*x+2].first);\n\t\t\tseg[x].second = min(seg[2*x+1].second, seg[2*x+2].second);\n\t\t}\n\t}\n\tint getMax(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = aryN;\n\t\tif(r <= a || b <= l) return -1;\n\t\tif(a <= l && r <= b) return seg[k].first;\n\t\tint vl = getMax(a, b, 2*k+1, l, (l+r)/2);\n\t\tint vr = getMax(a, b, 2*k+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n\tint getMin(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = aryN;\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <= b) return seg[k].second;\n\t\tint vl = getMin(a, b, 2*k+1, l, (l+r)/2);\n\t\tint vr = getMin(a, b, 2*k+2, (l+r)/2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\n\nint N, d;\nvector<TIII> s;\nint br[200010];\nSEG X, Y;\n\n\ntemplate<int N>\nVI tupleToVec(vector<TIII> vt){\n\tVI ret;\n\tfor(TIII t : vt) ret.pb(get<N>(t));\n\treturn ret;\n}\n\n\nint solve(){\n\tint ans = 0;\n\trep(i, 0, N) br[i] = get<0>(s[i]);\n\tX = SEG(tupleToVec<1>(s));\n\tY = SEG(tupleToVec<2>(s));\n\trep(i, 0, N){\n\t\tint p = upper_bound(RNG(br, N), br[i]+d)-&br[0];\n\t\tint x1 = X.getMax(i, p), x2 = X.getMin(i, p);\n\t\tint y1 = Y.getMax(i, p), y2 = Y.getMin(i, p);\n\t\tans = max(ans, (x1-x2)*(y1-y2));\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> N >> d;\n\ts = vector<TIII>(N);\n\trep(i, 0, N) cin >> get<1>(s[i]) >> get<2>(s[i]) >> get<0>(s[i]);\n\tsort(ALL(s));\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <vector>\n#include <utility>\n#include <numeric>\n#include <string>\n#include <set>\n#include <map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#define rep(i, a, n) for(int (i) = (int)(a);(i) < (int)(n);++(i))\n#define repe(i, a, n) for(int (i) = (int)(a);(i) <= (int)(n);++(i))\n#define repr(i, a, n) for(int (i) = (int)(a);(i) > (int)(n);--(i))\n#define reper(i, a, n) for(int (i) = (int)(a);(i) >= (int)(n);--(i))\n#define SIZE(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define RNG(x, n) &((x)[0]), &((x)[n])\n#define SUBIF(a, b, x) ((x) ? (b) : (a))\n#define YES cout << \"YES\" << endl\n#define NO cout << \"NO\" << endl\n#define Yes cout << \"Yes\" << endl\n#define No cout << \"No\" << endl\n#define yes cout << \"yes\" << endl;\n#define no cout << \"no\" << endl;\n#define pb push_back\n#define EPS (1e-20)\n#define INF 2147483647LL\n#define MOD 1000000007LL\nusing llint = long long;\nusing VI = std::vector<int>;\nusing PII = std::pair<int, int>;\nusing SI = std::set<int>;\nusing MII = std::map<int, int>;\nusing TIII = std::tuple<int, int, int>;\nusing namespace std;\n\n\nstruct SEG {\n\tvector<PII> seg;\n\tint aryN;\n\tint segN;\n\n\tint inToN(int i){\n\t\treturn aryN+i-1;\n\t}\n\tint p(int i){\n\t\treturn (i-1)/2;\n\t}\n\tvoid update(int n){\n\t\tif(n == 0) return;\n\t\tseg[p(n)].first = max(seg[p(n)].first, seg[n].first);\n\t\tseg[p(n)].second = min(seg[p(n)].second, seg[n].second);\n\t\tupdate(p(n));\n\t}\n\tvoid init(int n){\n\t\taryN = (int)pow(2, (int)ceil(log2(n)));\n\t\tsegN = 2*aryN-1;\n\t\tseg = vector<PII>(segN);\n\t}\n\tvoid initSEG(){\n\t\trep(i, 0, aryN) seg[i] = { -1, (int)INF };\n\t\trep(i, 0, aryN) update(inToN(i));\n\t}\n\tint getMax(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = aryN;\n\t\tif(r <= a || b <= l) return -1;\n\t\tif(a <= l && r <= b) return seg[k].first;\n\t\tint vl = getMax(a, b, 2*k+1, l, (l+r)/2);\n\t\tint vr = getMax(a, b, 2*k+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n\tint getMin(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = aryN;\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <= b) return seg[k].second;\n\t\tint vl = getMin(a, b, 2*k+1, l, (l+r)/2);\n\t\tint vr = getMin(a, b, 2*k+2, (l+r)/2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\n\nint N, d;\nTIII star[200010];\nSEG X, Y;\nint br[200010];\n\n\nvoid makeXY(){\n\tX.init(N), Y.init(N);\n\trep(i, 0, N) X.seg[X.inToN(i)] = { get<1>(star[i]), get<1>(star[i]) }, Y.seg[Y.inToN(i)] = { get<2>(star[i]), get<2>(star[i]) };\n\trep(i, N, X.aryN) X.seg[X.inToN(i)] = Y.seg[Y.inToN(i)] = { -1, (int)INF };\n\tX.initSEG(), Y.initSEG();\n}\n\n\nint solve(){\n\tint ans = 0;\n\trep(i, 0, N) br[i] = get<0>(star[i]);\n\trep(i, 0, N){\n\t\tint p = upper_bound(RNG(br, N), br[i]+d)-&br[0];\n\t\tint x1 = X.getMax(i, p), x2 = X.getMin(i, p);\n\t\tint y1 = Y.getMax(i, p), y2 = Y.getMin(i, p);\n\t\tans = max(ans, (x1-x2)*(y1-y2));\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> N >> d;\n\trep(i, 0, N) cin >> get<1>(star[i]) >> get<2>(star[i]) >> get<0>(star[i]);\n\tsort(RNG(star, N));\n\n\tmakeXY();\n\t\n\tcout << solve() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P2;\nstruct min_segtree{\nprivate:\n  vector<ll> node;\n  int siz;\npublic:\n  min_segtree(int n){\n    siz=1;\n    while(siz<=n) siz*=2;\n    node.resize(siz*2+1,(ll)2147483647);\n  }\n  void upd(int pos,int x){\n    pos+=siz-1;\n    node[pos]=x;\n    while(pos>0){\n      pos=(pos-1)/2;\n      node[pos]=min(node[pos*2+1],node[pos*2+2]);\n    }\n  }\n  ll get_min(int a,int b,int pos,int l,int r){\n    if(a<=l&&r<=b) return node[pos];\n    if(r<=a||b<=l) return 2147483647;\n    int mid=(l+r)/2;\n    ll lb=get_min(a,b,pos*2+1,l,mid);\n    ll rb=get_min(a,b,pos*2+2,mid,r);\n    return min(lb,rb);\n  }\n  ll min_q(int a,int b){\n    return get_min(a,b,0,0,siz);\n  }\n};\nstruct max_segtree{\nprivate:\n  vector<ll> node;\n  int siz;\npublic:\n  max_segtree(int n){\n    siz=1;\n    while(siz<=n) siz*=2;\n    node.resize(siz*2+1,0);\n  }\n  void upd(int pos,int x){\n    pos+=siz-1;\n    node[pos]=x;\n    while(pos>0){\n      pos=(pos-1)/2;\n      node[pos]=max(node[pos*2+1],node[pos*2+2]);\n    }\n  }\n  ll get_max(int a,int b,int pos,int l,int r){\n    if(a<=l&&r<=b) return node[pos];\n    if(r<=a||b<=l) return 0;\n    int mid=(l+r)/2;\n    ll lb=get_max(a,b,pos*2+1,l,mid);\n    ll rb=get_max(a,b,pos*2+2,mid,r);\n    return max(lb,rb);\n  }\n  ll max_q(int a,int b){\n    return get_max(a,b,0,0,siz);\n  }\n};\n\nint main(){\n  ll n,d;\n  cin>>n>>d;\n  vector<P2> vec;\n  vector<ll> bright;\n  for(int i=0;i<n;i++){\n    ll x,y,b;\n    cin>>x>>y>>b;\n    bright.push_back(b);\n    vec.push_back(P2(b,P(x,y)));\n  }\n  sort(bright.begin(),bright.end());\n  sort(vec.begin(),vec.end());\n  min_segtree minsegx=min_segtree(n+5),minsegy=min_segtree(n+5);\n  max_segtree maxsegx=max_segtree(n+5),maxsegy=max_segtree(n+5);\n\n  for(int i=0;i<n;i++){\n    ll x=vec[i].second.first,y=vec[i].second.second;\n    minsegx.upd(i,x);\n    maxsegx.upd(i,x);\n    minsegy.upd(i,y);\n    maxsegy.upd(i,y);\n  }\n  ll ans=0;\n  for(int i=0;i<n;i++){\n    ll jt=upper_bound(bright.begin(),bright.end(),bright[i]+d)-bright.begin();\n    ll dx=maxsegx.max_q(i,jt)-minsegx.min_q(i,jt);\n    ll dy=maxsegy.max_q(i,jt)-minsegy.min_q(i,jt);\n    ans=max(ans,dx*dy);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntypedef pair< int, int > Pi;\ntypedef pair< int, Pi > Pii;\n\nint main(){\n  int N, d;\n  Pii data[200000];\n  multiset< int > X, Y;\n  scanf(\"%d %d\", &N, &d);\n  for(int i = 0; i < N; i++){\n    scanf(\"%d %d %d\", &data[i].second.first, &data[i].second.second, &data[i].first);\n  }\n  sort( data, data + N);\n  ll ret = 0, low = 0;\n  for(int i = 0; i < N; i++){\n    while(data[low].first < data[i].first - d){\n      X.erase( X.find(data[low].second.first));\n      Y.erase( Y.find(data[low].second.second));\n      low++;\n    }\n    X.insert( data[i].second.first);\n    Y.insert( data[i].second.second);\n\n    ret = max( ret, (ll)(*--X.end() - *X.begin()) * (*--Y.end() - *Y.begin()));\n  }\n  printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<unordered_set>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<algorithm>\n#define int long long\nusing namespace std;\n\nstruct star {\n\tint cost, x, y;\n};\nbool operator <(star a, star b) {\n\treturn a.cost <= b.cost;\n}\nstar A[200000];\nmap<int, int>X;\nmap<int, int>Y;\nsigned main(){\n\tint a, b; scanf(\"%lld%lld\", &a, &b);\n\tfor (int c = 0; c < a; c++) {\n\t\tint d, e, f; scanf(\"%lld%lld%lld\", &d, &e, &f);\n\t\tA[c] = { f,d,e };\n\t}\n\tsort(A, A + a);\n\tint MAX = 0;\n\tfor (int s = 0, g = 0; g < a; g++) {\n\t\tX[A[g].x]++;\n\t\tY[A[g].y]++;\n\t\twhile (s < g&&A[s].cost + b < A[g].cost) {\n\t\t\tX[A[s].x]--;\n\t\t\tY[A[s].y]--;\n\t\t\tif (X[A[s].x] == 0) {\n\t\t\t\tX.erase(A[s].x);\n\t\t\t}\n\t\t\tif (Y[A[s].y] == 0) {\n\t\t\t\tY.erase(A[s].y);\n\t\t\t}\n\t\t\ts++;\n\t\t}\n\t\tcout << s << \" \" << g << endl;\n\t\tint n = X.rbegin()->first - X.begin()->first;\n\t\tint m = Y.rbegin()->first - Y.begin()->first;\n\t\tMAX = max(MAX, n*m);\n\t}\n\tprintf(\"%lld\\n\", MAX);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int INF = 1 << 28;\n\nstruct Point\n{\n  int x, y;\n  Point() {}\n  Point(int x, int y) : x(x), y(y) {}\n  void input() { scanf(\"%d %d\", &x, &y); }\n};\n\nstruct Maxminp\n{\n  Point maxv, minv;\n  Maxminp() {}\n  Maxminp(Point maxv, Point minv) : maxv(maxv), minv(minv) {}\n  ll area() { return ((ll)(maxv.x - minv.x) * (ll)(maxv.y  - minv.y)); }\n  void chmaxmin(Maxminp d)\n  {\n    maxv = Point(max(maxv.x, d.maxv.x), max(maxv.y, d.maxv.y)); \n    minv = Point(min(minv.x, d.minv.x), min(minv.y, d.minv.y));\n  }\n};\n\nconst Maxminp reset = Maxminp(Point(-INF, -INF), Point(INF, INF));\n\nstruct Segtree\n{\n  vector < Maxminp > data;\n  int size;\n\n  Segtree() {}\n  \n  Segtree(int sz)\n  {\n    int g = 1;\n    while(g < sz) g *= 2;\n    size = g;\n    data.assign(size * 4, reset);\n  }\n\n  void update(Point val, int p)\n  {\n    int pos = p + size - 1;\n    data[pos] = Maxminp(val, val);\n    while(pos != 0) {\n      pos = (pos - 1) >> 1;\n      data[pos].chmaxmin(data[pos * 2 + 1]);\n      data[pos].chmaxmin(data[pos * 2 + 2]);\n    }\n  }\n\n  Maxminp query(int a, int b) { return (query(a, b, 0, 0, size - 1)); }\n  Maxminp query(int a, int b, int k, int l, int r)\n  {\n    Maxminp ret = reset;\n    if(r < a || b < l) return (ret);\n    if(a <= l && r <= b) return (data[k]);\n    ret.chmaxmin(query(a, b, k * 2 + 1, l, (l + r) / 2));\n    ret.chmaxmin(query(a, b, k * 2 + 2, (l + r) / 2 + 1, r));\n    return (ret);\n  }\n};\n\nstruct Star\n{\n  Point p;\n  int b;\n  Star() {}\n  Star(Point p, int b) : p(p), b(b) {}\n  void input() { p.input(); scanf(\"%d\", &b); }\n  bool operator < (const Star d) const { return (b < d.b); }\n};\n\nint main()\n{\n  int N, D;\n  Segtree tree;\n  Star data[200005];\n  ll maxv = 0;\n  int k = 0;\n  \n  cin >> N >> D;\n  tree = Segtree(N);\n  \n  for(int i = 0; i < N; i++) data[i].input();\n  sort(data, data + N);\n  \n  for(int i = 0; i < N; i++) {\n    tree.update(data[i].p, i);\n    while(k < i && data[k].b + D < data[i].b) k++;\n    maxv = max(tree.query(k, i).area(), maxv);\n  }\n\n  cout << maxv << endl;\n\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <limits>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\ntemplate<typename Type> class RMQ {\nprivate:\n\tint size_; vector<Type> dat;\n\tType query_(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return numeric_limits<Type>::max();\n\t\tif (a <= l && r <= b) return dat[k];\n\t\tint lc = query_(a, b, 2 * k, l, (l + r) / 2);\n\t\tint rc = query_(a, b, 2 * k + 1, (l + r) / 2, r);\n\t\treturn min(lc, rc);\n\t}\npublic:\n\tRMQ(int size__) {\n\t\tfor (size_ = 1; size_ < size__; size_ <<= 1); dat.resize(size_ * 2, numeric_limits<Type>::max());\n\t}\n\tRMQ(vector<Type> v) {\n\t\tfor (size_ = 1; size_ < dat.size(); size_ <<= 1); dat.resize(size_ * 2, numeric_limits<Type>::max());\n\t\tfor (int i = 0; i < v.size(); i++) dat[i + size_] = v[i];\n\t\tfor (int i = size_ - 1; i >= 1; i--) dat[i] = min(dat[2 * i], dat[2 * i + 1]);\n\t}\n\tint size() { return size_; }\n\tint ndat() { return numeric_limits<Type>::max(); }\n\tvoid update(int i, int x) {\n\t\ti += size_; dat[i] = x;\n\t\twhile (i > 1) i >>= 1, dat[i] = min(dat[2 * i], dat[2 * i + 1]);\n\t}\n\tType query(int l, int r) {\n\t\treturn query_(l, r, 1, 0, size_);\n\t}\n};\nint n, d, e[200000]; long long ret; vector<int> f[200000];\nint main() {\n\tscanf(\"%d%d\", &n, &d);\n\tfor (int i = 0; i < n; i++) f[i].resize(3), scanf(\"%d%d%d\", &f[i][1], &f[i][2], &f[i][0]);\n\tsort(f, f + n);\n\tfor (int i = 0; i < n; i++) e[i] = f[i][0];\n\tRMQ<int> r1(n); for (int i = 0; i < n; i++) r1.update(i, f[i][1]);\n\tRMQ<int> r2(n); for (int i = 0; i < n; i++) r2.update(i, -f[i][1]);\n\tRMQ<int> r3(n); for (int i = 0; i < n; i++) r3.update(i, f[i][2]);\n\tRMQ<int> r4(n); for (int i = 0; i < n; i++) r4.update(i, -f[i][2]);\n\tfor (int i = 0; i < n; i++) {\n\t\tint ptr = upper_bound(e, e + n, e[i] + d) - e;\n\t\tint wp = -r2.query(i, ptr) - r1.query(i, ptr);\n\t\tint hp = -r4.query(i, ptr) - r3.query(i, ptr);\n\t\tret = max(ret, 1LL * wp * hp);\n\t}\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define f first\n#define s second\n#define INF 2000000\nusing namespace std;\ntypedef long long ll;\npair<int,pair<int,int> >st[1<<18];\nint tree[4][1<<19];\n\nint get(int a,int b,int n,int l,int r,int f){\n if(r<=a||b<=l)return -INF;\n if(a<=r&&l<=b)return tree[f][n];\n int m=(l+r)/2;\n return max(get(a,b,n*2+1,l,m,f),get(a,b,n*2+2,m,r,f));\n}\n\nvoid koshin(int i,int x,int f){\n i+=((1<<18)-1);\n tree[f][i]=x;\n while(i){\n   i=(i-1)/2;\n   tree[f][i]=max(tree[f][i*2+1],tree[f][i*2+2]);\n }\n}\n\nint main(){\n int n,d;\n cin>>n>>d;\n for(int i=0;i<n;i++) cin>>st[i].s.f>>st[i].s.s>>st[i].f;\n sort(st,st+n);\n for(int i=0;i<(1<<19);i++)\n   for(int j=0;j<4;j++)tree[j][i]=-INF;\n for(int i=0;i<n;i++){\n   koshin(i,st[i].s.f,0);\n   koshin(i,st[i].s.s,1);\n   koshin(i,-st[i].s.f,2);\n   koshin(i,-st[i].s.s,3);\n }\n int j=0;\n ll an=0;\n for(int i=0;i<n;i++){\n   while(st[j].f-st[i].f<=d)j++;\n   ll w=get(i,j,0,0,(1<<18),0)+get(i,j,0,0,(1<<18),2);\n   ll h=get(i,j,0,0,(1<<18),1)+get(i,j,0,0,(1<<18),3);\n   if(h>0&&w>0)an=max(an,h*w);\n }\n cout<<an<<endl;\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nenum Type{\n\tRight,\n\tLeft,\n\tTop,\n\tBottom,\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn Brightness < arg.Brightness;\n\t};\n\tll x,y,Brightness;\n};\n\nstruct RMQ{\n\tvoid set(ll arg_most_left,ll arg_most_right,ll arg_most_top,ll arg_most_bottom){\n\t\tmost_left = arg_most_left;\n\t\tmost_right = arg_most_right;\n\t\tmost_top = arg_most_top;\n\t\tmost_bottom = arg_most_bottom;\n\t}\n\tll most_left,most_right,most_top,most_bottom;\n};\n\n#define NUM 2147483647\n\nint N = 1;\nInfo* info;\nRMQ* Tree;\n\n\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid update(int index, Info new_value){\n\n\tindex += N-1;\n\n\tTree[index].most_left = min(Tree[index].most_left,new_value.x);\n\tTree[index].most_right = max(Tree[index].most_right,new_value.x);\n\tTree[index].most_top = min(Tree[index].most_top,new_value.y);\n\tTree[index].most_bottom = max(Tree[index].most_bottom,new_value.y);\n\n\tindex = (index-1)/2;\n\n\twhile(true){\n\n\t\tTree[index].most_left = min(Tree[2*index+1].most_left,Tree[2*index+2].most_left);\n\t\tTree[index].most_right = max(Tree[2*index+1].most_right,Tree[2*index+2].most_right);\n\t\tTree[index].most_top = min(Tree[2*index+1].most_top,Tree[2*index+2].most_top);\n\t\tTree[index].most_bottom = max(Tree[2*index+1].most_bottom,Tree[2*index+2].most_bottom);\n\n\t\tif(index == 0)break;\n\t\telse{\n\t\t\tindex = (index-1)/2;\n\t\t}\n\t}\n}\n\n\nll find(int search_left,int search_right,int node_id,int node_left,int node_right,Type type){\n\n\tif(search_right < node_left || search_left > node_right){\n\t\tif(type == Left || type == Top){\n\t\t\treturn NUM;\n\t\t}else{ //type == Right || type == Bottom\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif(search_left <= node_left && search_right >= node_right){\n\t\tif(type == Left){\n\t\t\treturn Tree[node_id].most_left;\n\t\t}else if(type == Right){\n\t\t\treturn Tree[node_id].most_right;\n\t\t}else if(type == Top){\n\t\t\treturn Tree[node_id].most_top;\n\t\t}else{\n\t\t\treturn Tree[node_id].most_bottom;\n\t\t}\n\t}\n\n\tif(type == Left || type == Top){\n\t\tll left_min = find(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2,type);\n\t\tll right_min = find(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right,type);\n\n\t\treturn min(left_min,right_min);\n\t}else{ //type == Right || type == Bottom\n\t\tll left_max = find(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2,type);\n\t\tll right_max = find(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right,type);\n\n\t\treturn max(left_max,right_max);\n\t}\n}\n\n\nint main(){\n\n\tint first_N;\n\tll Diff_Max;\n\n\tscanf(\"%d %lld\",&first_N,&Diff_Max);\n\n\tinit(first_N);\n\n\tinfo = (Info*)malloc(sizeof(Info)*(2*N));\n\tTree = (RMQ*)malloc(sizeof(RMQ)*(2*N));\n\n\tfor(int i = 0; i < 2*N-1; i++){\n\t\tTree[i].set(BIG_NUM,-1,BIG_NUM,-1);\n\t}\n\n\tfor(int i = 0; i < first_N; i++){\n\t\tscanf(\"%lld %lld %lld\",&info[i].x,&info[i].y,&info[i].Brightness);\n\t}\n\n\tsort(info,info+first_N);\n\n\tfor(int i = 0; i < first_N; i++){\n\t\tupdate(i,info[i]);\n\t}\n\n\tll ans = 0;\n\tint left,right,m,pre_right = 0,loc;\n\tll calc_left,calc_right,calc_top,calc_bottom;\n\n\n\tfor(int start = 0; start < first_N; start++){\n\n\t\tleft = pre_right,right = first_N-1;\n\t\tm = (left + right)/2;\n\t\tloc = -1;\n\t\twhile(left <= right){\n\t\t\tif(info[m].Brightness-info[start].Brightness <= Diff_Max){\n\t\t\t\tloc = max(loc,m);\n\t\t\t\tleft = m+1;\n\t\t\t}else{\n\t\t\t\tright = m-1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\t\tif(loc == -1)break;\n\n\t\tcalc_left = find(start,loc,0,0,N-1,Left);\n\t\tcalc_right = find(start,loc,0,0,N-1,Right);\n\t\tcalc_top = find(start,loc,0,0,N-1,Top);\n\t\tcalc_bottom = find(start,loc,0,0,N-1,Bottom);\n\n\t\tans = max(ans,(calc_right-calc_left)*(calc_bottom-calc_top));\n\n\t\tpre_right = loc;\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INT(name) int name; scanf(\"%d\",&name);\n#define VINT(name,n) vector<int> name(n); for(int i = 0;i < n;i++) scanf(\"%d\",&name[i]);\n#define ll long long\n#define ull unsigned long long\n\nusing namespace std;\n\nint main(int argc, char const *argv[]){\n\tint N,d;\n\tscanf(\"%d\",&N);\n\tscanf(\"%d\",&d);\n\tvector<int> X(N);\n\tvector<int> Y(N);\n\tvector<int> B(N);\n\n\tfor(int i = 0;i < N;i++){\n\t\tcin >> X[i] >> Y[i] >> B[i];\n\t}\n\n\tint range = 0;\n\tfor(int v : B)\n\t\tif(range < v) range = v;\n\n\tint max = 0;\n\n\tfor(int i = 0;i < range - d;i++){\n\t\tint x[2] = {INT_MAX,INT_MIN};\n\t\tint y[2] = {INT_MAX,INT_MIN};\n\n\t\tfor(int j = 0;j < N;j++){\n\t\t\tif(i <= B[j] && B[j] <= i + d){\n\t\t\t\tif(x[0] > X[j]) x[0] = X[j];\n\t\t\t\tif(x[1] < X[j]) x[1] = X[j];\n\t\t\t\tif(y[0] > Y[j]) y[0] = Y[j];\n\t\t\t\tif(y[1] < Y[j]) y[1] = Y[j];\n\t\t\t}\n\t\t}\n\n\t\tint temp = (x[1] - x[0]) * (y[1] - y[0]);\n\n\t\tif(temp > max) max = temp;\n\t}\n\n\tcout << max << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1000000000\n#define f first\n#define s second\nusing namespace std;\ntypedef pair <int,pair <int,int> > P;\ntypedef long long ll;\nint n,d,tree[4][(1<<19)];\nP star[200001];\n\nvoid update(int i,int flg,int x){\n  i = i+(1<<18)-1;\n  tree[flg][i] = x;\n  while(i) {\n    i = (i-1)/2;\n    tree[flg][i] = max(tree[flg][i*2+1],tree[flg][i*2+2]);\n  }\n}\n\nint find(int a,int b,int ima,int L,int R,int flg){\n  if(R<=a || b<=L) return -INF;\n  if(a<=L && R<=b) return tree[flg][ima];\n  int M = (L+R)/2;\n  return max(find(a,b,ima*2+1,L,M,flg),find(a,b,ima*2+2,M,R,flg));\n}\n\nint main() {\n  cin >> n >> d;\n\n  for(int i=0;i<n;i++)cin >> star[i].s.f >> star[i].s.s >> star[i].f;\n  sort(star,star+n);  \n  \n  for(int i=0;i<4;i++) \n    for(int j=0;j<(1<<19);j++) tree[i][j] = -INF;\n  \n  for(int i=0;i<n;i++) {\n    update(i,0,star[i].s.f); // max(x);\n    update(i,1,star[i].s.s); // max(y);\n    update(i,2,-star[i].s.f); // min(x);\n    update(i,3,-star[i].s.s); // min(y);\n  }\n\n  long long S=0;\n  int ima=0;\n  for(int i=0;i<n;i++){\n    while(i!=n && star[ima].f-star[i].f <=d) ima++;\n    ll maxx = find(i,ima,0,0,(1<<18),0);\n    ll maxy = find(i,ima,0,0,(1<<18),1);\n    ll minx = find(i,ima,0,0,(1<<18),2);\n    ll miny = find(i,ima,0,0,(1<<18),3);\n    S = max(S,(maxx+minx)*(maxy+miny));\n  }\n  cout << S<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair <int,int> P;\ntypedef long long ll;\n#define f first\n#define s second\n#define INF 1000000000\nint tree[4][(1<<19)];\nint n,d;\npair <int,pair <int,int> > star[(1<<18)];\n\nvoid update(int i,int x,int flg){\n  i = (1<<18)+i-1;\n  tree[flg][i] = x;\n  while(i){\n    i = (i-1)/2;\n    tree[flg][i] = max(tree[flg][i*2+1],tree[flg][i*2+2]);\n  }\n}\n\nint find(int a,int b,int M,int L,int R,int flg){\n  if(b <=L || a >= R) return -INF;\n  if(a <=L && R <= b) return tree[flg][M];\n  int nx = (L+R)/2;\n  return max(find(a,b,M*2+1,L,nx,flg),find(a,b,M*2+2,nx,R,flg));\n}\n\nint main() {\n  scanf(\"%d %d\",&n,&d);\n  for(int i=0;i<(1<<19);i++) \n    for(int j=0;j<4;j++) tree[j][i] = -INF;\n  for(int i=0;i<n;i++)\n    scanf(\"%d %d %d\",&star[i].s.f,&star[i].s.s,&star[i].f);\n  sort(star,star+n);\n  for(int i=0;i<n;i++) {\n    update(i,star[i].s.f,0); // max(x);\n    update(i,star[i].s.s,1); // max(y);\n    update(i,-star[i].s.f,2); // min(x);\n    update(i,-star[i].s.s,3); // min(y);\n  }\n  ll now = 0,minx,maxx,miny,maxy,S=0;\n  for(int i=0;i<n;i++) {\n    while(now < n && star[now].f -star[i].f <=d) now++;\n    maxx = find(i,now,0,0,(1<<18),0);\n    maxy = find(i,now,0,0,(1<<18),1);\n    minx = find(i,now,0,0,(1<<18),2);\n    miny = find(i,now,0,0,(1<<18),3);\n    S = max(S,((ll)maxx+minx)*((ll)maxy+miny));\n  }\n  printf(\"%lld\\n\",S);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1<<29)\ntypedef long long ll;\n\nstruct MinSegtree\n{\n  int n;\n  int dat[600005];\n  MinSegtree(int _n)\n  {\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*21;i++)\n      dat[i] = INF;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n\n  int query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return INF;\n\n    if(a <= l && r <= b) return dat[k];\n    else{\n      int vl = query(a, b, k*2+1, l, (l + r) / 2);\n      int vr = query(a, b, k*2+2, (l + r) / 2, r);\n      return min(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nstruct MaxSegtree\n{\n  int n;\n  int dat[600005];\n  MaxSegtree(int _n){\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*2-1;i++)\n      dat[i] = -1;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n  \n  int query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return -1;\n    \n    if(a <= l && r <=b ) return dat[k];\n    else{\n      int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n      int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n      return max(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nint main()\n{\n  int n, d;\n  scanf(\"%d%d\", &n, &d);\n  MinSegtree minx(n);\n  MinSegtree miny(n);\n  MaxSegtree maxx(n);\n  MaxSegtree maxy(n);\n  \n  vector<pair<int, pair<int, int> > >s(n);\n  vector<int>br(n);\n  for(int i=0;i<n;i++){\n    int x, y, b;\n    scanf(\"%d%d%d\", &x, &y, &b);\n    s[i] = make_pair(b, make_pair(x, y));\n    br[i] = b;\n  }\n  sort(s.begin(), s.end());\n  sort(br.begin(), br.end());\n\n\n  for(int i=0;i<n;i++){\n    minx.update(i, s[i].second.first);\n    maxx.update(i, s[i].second.first);\n    miny.update(i, s[i].second.second);\n    maxy.update(i, s[i].second.second);\n  }\n\n  br.push_back(INF);\n  ll res = 0;\n  for(int i=0;i<n;i++){\n    int pos = (int)(upper_bound(br.begin(), br.end(), br[i] + d) - br.begin());\n    int w = maxx.query(i, pos, 0, 0, maxx.size()) - minx.query(i, pos, 0, 0, minx.size());\n    int h = maxy.query(i, pos, 0, 0, maxy.size()) - miny.query(i, pos, 0, 0, miny.size());\n    res = max(res, (ll)w * (ll)h);\n  }\n\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//{{{ seg.hpp\n#ifndef INCLUDE_SEG_HPP\n#define INCLUDE_SEG_HPP\n#include <functional>\n#include <algorithm>\n#include <iterator>\nnamespace orislib {\nnamespace ds {\nconstexpr int uprt(int k, int i=1){\n  return i < k ? uprt(k, i + i) : i;\n}\n//{{{ SegT<T, S> update, query\ntemplate<typename T, int S>\nstruct SegT {\n  typedef T seg_t;\n  const seg_t OUT;\n  static const int N = uprt(S);\n  seg_t data[N * 2];\n  std::function<seg_t(seg_t,seg_t)>ufunc;\n  template<typename F>\n  SegT(T initial, F f):OUT(initial),ufunc(f){std::fill(std::begin(data), std::end(data), initial);}\n  void update(int x, seg_t v){\n    for (data[x+=N-1]=v;x;data[x]=ufunc(data[x+x+1],data[x+x+2]))x=x-1>>1;\n  }\n  void add(int x,seg_t a){ update(x,data[x+N-1]+a); }\n  seg_t query(int a=0,int b=N,int x=0,int l=0,int r=N){\n    if (r<=a||b<=l) return OUT;\n    if (a<=l&&r<=b) return data[x];\n    return ufunc(query(a,b,x+x+1,l,l+r>>1),query(a,b,x+x+2,l+r>>1,r));\n  }\n};\n//}}}\n}\n}\n#endif\n//}}}\n\nusing namespace std;\nusing namespace orislib::ds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\n\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_ template<typename T>inline\n#define TTF_ template<typename T,typename F>inline\nTT_ T sq(T x){return x*x;}\nTT_ T In(){T x;cin>>x;return x;}\nTT_ void Out(T&x){cout<<x;}\nTT_ void sort(T&v){sort(begin(v),end(v));}\nTT_ void revs(T&v){reverse(begin(v),end(v));}\nTT_ void uniq(T&v){sort(v);v.erase(unique(begin(v),end(v)),end(v));}\nTT_ int ubnd(T&v,typename T::value_type x){return upper_bound(begin(v),end(v),x)-begin(v);}\nTT_ int lbnd(T&v,typename T::value_type x){return lower_bound(begin(v),end(v),x)-begin(v);}\nTTF_ void inpt(T&v,int n,F f){for(v.reserve(n);n--;v.emplace_back(f()));}\nTTF_ void show(T&v,F f,string d=\" \",string e=\"\\n\"){int i=0;for(auto&x:v)i++&&(cout<<d),f(x);cout<<e;}\nTT_ typename T::iterator minel(T&v){return min_element(begin(v),end(v));}\nTT_ typename T::iterator maxel(T&v){return max_element(begin(v),end(v));}\n\ninline void fast_io(){ios_base::sync_with_stdio(0);cin.tie(0);}\ninline int in(){int x;scanf(\"%d\",&x);return x;}\ninline ll pow_mod(ll a,ll k,ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\ninline ll mod_inv(ll a,ll p){return pow_mod(a,p-2,p);}\n//}}} priority_queue queue deque front stringstream max_element min_element insert count make_tuple\n\nstruct Star {\n  int x, y, b;\n  Star(int x, int y, int b) : x(x), y(y), b(b) {}\n  bool operator<(const Star& x) const {\n    return b < x.b;\n  }\n};\n\nSegT<int, 200200> xmax(INT_MIN, [](int a, int b){ return max(a, b); });\nSegT<int, 200200> xmin(INT_MAX, [](int a, int b){ return min(a, b); });\nSegT<int, 200200> ymax(INT_MIN, [](int a, int b){ return max(a, b); });\nSegT<int, 200200> ymin(INT_MAX, [](int a, int b){ return min(a, b); });\n\nint main()\n{\n\n  int N = in();\n  int d = in();\n  vector<Star> vs;\n  for (int i = 0; i < N; i++){\n    int x = in();\n    int y = in();\n    int b = in();\n    vs.emplace_back(x, y, b);\n  }\n  sort(vs);\n  for (int i = 0; i < N; i++){\n    xmin.update(i, vs[i].x);\n    xmax.update(i, vs[i].x);\n    ymin.update(i, vs[i].y);\n    ymax.update(i, vs[i].y);\n  }\n\n  int maxi = 0;\n  for (int i = 0; i < N; i++){\n    int t = ubnd(vs, Star(0, 0, vs[i].b + d));\n    int xmini = xmin.query(i, t);\n    int xmaxi = xmax.query(i, t);\n    int ymini = ymin.query(i, t);\n    int ymaxi = ymax.query(i, t);\n    maxi = max(maxi, abs(xmaxi - xmini) * abs(ymaxi - ymini));\n  }\n  printf(\"%d\\n\", maxi);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        (wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nstruct star {\n\tint x, y, b;\n\n\tbool operator <(const star &s)const {\n\t\treturn b < s.b;\n\t}\n};\n\nbool calc(const star &a,const star &b) {\n\treturn a.b < b.b;\n}\n\n\nint n, d;\nvector<star> stars;\n\nstruct SegmentTreeMax {\nprivate:\n\tint n;\n\tvector<LL> node;\npublic:\n\tSegmentTreeMax(vector<LL> v) {\n\t\tint sz = v.size();\n\t\tn = 1; while (n < sz) n *= 2;\n\t\tnode.resize(2 * n - 1,0);\n\t\tfor (int i = 0; i<sz; i++) node[i + n - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--) node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n\t}\n\n\tvoid update(int x, int val) {\n\t\tx += (n - 1);\n\t\tnode[x] = val;\n\t\twhile (x > 0) {\n\t\t\tx = (x - 1) / 2;\n\t\t\tnode[x] = max(node[2 * x + 1], node[2 * x + 2]);\n\t\t}\n\t}\n\t//[a,b)の最大値を求める\n\tLL getmax(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0) r = n;\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return node[k];\n\n\t\tint vl = getmax(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tint vr = getmax(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n};\n\nstruct SegmentTreeMin {\nprivate:\n\tint n;\n\tvector<LL> node;\npublic:\n\tSegmentTreeMin(vector<LL> v) {\n\t\tint sz = v.size();\n\t\tn = 1; while (n < sz) n *= 2;\n\t\tnode.resize(2 * n - 1, HINF<LL>());\n\t\tfor (int i = 0; i<sz; i++) node[i + n - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--) node[i] = min(node[2 * i + 1], node[2 * i + 2]);\n\t}\n\n\tvoid update(int x, int val) {\n\t\tx += (n - 1);\n\t\tnode[x] = val;\n\t\twhile (x > 0) {\n\t\t\tx = (x - 1) / 2;\n\t\t\tnode[x] = min(node[2 * x + 1], node[2 * x + 2]);\n\t\t}\n\t}\n\t//[a,b)の最小値を求める\n\tint getmin(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0) r = n;\n\t\tif (r <= a || b <= l) return HINF<LL>();\n\t\tif (a <= l && r <= b) return node[k];\n\n\t\tint vl = getmin(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tint vr = getmin(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n\tvoid get() {\n\t\tREP(i, node.size()) {\n\t\t\tcout << node[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n};\n\n\nint main() {\n\tcin >> n >> d;\n\tREP(i, n) {\n\t\tstar s;\n\t\tcin >> s.x >> s.y >> s.b;\n\t\tstars.emplace_back(s);\n\t}\n\tsort(ALL(stars));\n\tvector<LL> xx, yy, bb;\n\tREP(i, n) {\n\t\txx.emplace_back(stars[i].x);\n\t\tyy.emplace_back(stars[i].y);\n\t\tbb.emplace_back(stars[i].b);\n\t}\n\tSegmentTreeMax xmax(xx), ymax(yy);\n\tSegmentTreeMin xmin(xx), ymin(yy);\n\t\n\tLL ans = 0LL;\n\tREP(i, n) {\n\t\tint l = i;\n\t\tint r = upper_bound(ALL(bb), bb[i] + d) - 1 - bb.begin();\n\t\t//cout << l << \" \" << r << \" \" << xmax.getmax(l, r + 1) <<\" \"<< xmin.getmin(l, r + 1)<<\" \"<<ymax.getmax(l, r + 1)<< \" \"<< ymin.getmin(l, r + 1) << endl;\n\t\tans = max(ans, (xmax.getmax(l, r + 1) - xmin.getmin(l, r + 1))*(ymax.getmax(l, r + 1) - ymin.getmin(l, r + 1)));\n\t}\n\t//system(\"pause\");\n\tcout << ans << endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\nstruct Node {\n    int sx, tx, sy, ty;\n    Node() { sx = inf; tx = -inf; sy = inf; ty = -inf; }\n    Node(int _sx, int _tx, int _sy, int _ty) { sx = _sx, tx = _tx, sy = _sy, ty = _ty; }\n};\nusing V = Node;\n#define def Node()\ntemplate<int NV> struct SegTree { //[l,r)\n    V comp(V& l, V& r) { \n        return Node(min(l.sx, r.sx), max(l.tx, r.tx), min(l.sy, r.sy), max(l.ty, r.ty));\n    };\n\n    vector<V> val; SegTree() { val = vector<V>(NV * 2, def); }\n    V get(int x, int y, int l = 0, int r = NV, int k = 1) {\n        if (r <= x || y <= l)return def; if (x <= l && r <= y)return val[k];\n        auto a = get(x, y, l, (l + r) / 2, k * 2);\n        auto b = get(x, y, (l + r) / 2, r, k * 2 + 1);\n        return comp(a, b);\n    }\n    void update(int i, V v) {\n        i += NV; val[i] = v;\n        while (i>1) i >>= 1, val[i] = comp(val[i * 2], val[i * 2 + 1]);\n    }\n    V operator[](int x) { return get(x, x + 1); }\n};\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　 |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nint N, d;\ntuple<int, int, int> points[201010];\nint bv[201010];\nSegTree<1 << 18> st;\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> d;\n    rep(i, 0, N) {\n        int x, y, b; cin >> x >> y >> b;\n        points[i] = make_tuple(b, x, y);\n        bv[i] = b;\n    }\n    sort(points, points + N);\n    sort(bv, bv + N);\n\n    rep(i, 0, N) {\n        int x, y, b;\n        tie(b, x, y) = points[i];\n        st.update(i, Node(x, x, y, y));\n    }\n    \n    ll ans = 0;\n    rep(i, 0, N) {\n        int L = i;\n        int R = upper_bound(bv, bv + N, bv[i] + d) - bv;\n\n        auto no = st.get(L, R);\n\n        ll sx = no.sx;\n        ll tx = no.tx;\n        ll sy = no.sy;\n        ll ty = no.ty;\n        chmax(ans, (tx - sx) * (ty - sy));\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/std++.h>\nusing namespace std;\n/**\nvector<int>ar(3);\nfor(auto&e:ar){\n    scanf(\"%d\",&e);\n        }\nsort(ar.begin(),ar.end())\nint sum=accumulate(ar.begin(),ar.end(),0);\n**/\n//memo kyuridenamida 1237852\nint main(){\n    double pai=3.141592653589;\n    int N,d;\n    cin >> N >> d;\n    vector< array<int,3> > star;\n    for(int i = 0 ; i < N ; i++){\n        int x,y,b;\n        cin >> x >> y >> b;\n        star.push_back(array<int,3>{b,x,y});\n    }   \n    sort(star.begin(),star.end());\n    int l = 0 , r = 0;\n    multiset<int> X,Y;\n    long long ans = 0;\n    while( r != N){\n        X.insert(star[r][1]);\n        Y.insert(star[r][2]);\n        r++;\n        while( star[r-1][0] - star[l][0] > d ){\n            X.erase(X.find(star[l][1]));\n            Y.erase(Y.find(star[l][2]));\n            l++;\n        }\n        ans = max((long long)((*X.rbegin())-(*X.begin())) * ((*Y.rbegin())-(*Y.begin())),ans);\n        //cout << (*X.rbegin())-(*X.begin()) << \" \" << ((*Y.rbegin())-(*Y.begin())) << \"|\" << star[r-1][0] - star[l][0] << endl;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <functional>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//===\ntemplate<class SemiLattice,\n         class Merge = function<SemiLattice(SemiLattice, SemiLattice)> >\nstruct SparseTable {\n\n    bool builded = false;\n    const int n;\n    const Merge merge;\n    vector<vector<SemiLattice>> table;\n    vector<size_t> log2;\n\n    SparseTable():n(0){}\n    SparseTable(int n, SemiLattice v, const Merge &f):\n        n(n), merge(f)\n    {\n        log2.assign(n + 1, 0);\n        for (int i = 2; i <= n; i++) log2[i] = log2[i / 2] + 1;\n        \n        table.assign(log2[n] + 1, vector<SemiLattice>(n, v));\n    };\n\n    template<class InputIterator>\n    SparseTable(InputIterator first, InputIterator last, const Merge &f):\n        n(distance(first, last)), merge(f)\n    {\n        log2.assign(n + 1, 0);\n        for (int i = 2; i <= n; i++) log2[i] = log2[i / 2] + 1;\n        \n        table.assign(log2[n] + 1, vector<SemiLattice>(first, last));\n        build();\n    };\n\n    void build(void) {\n        for (int i = 0; i < log2[n]; i++) {\n            int w = 1 << i;\n            for (int j = 0; j + (w * 2) <= n; j++) {\n                table[i + 1][j] = merge(table[i][j], table[i][j + w]);\n            }\n        }\n\n        builded = true;\n    };\n\n    void set(int k, SemiLattice dat) {\n        table[0][k] = dat;\n        builded = false;\n    };\n\n    //[l, r)\n    SemiLattice fold(int l, int r) {\n        if (!builded) build();\n\n        int k = log2[r - l];\n\n        return merge(table[k][l], table[k][r - (1 << k)]);\n    };\n\n    int size() {\n        return n;\n    };\n\n    SemiLattice operator[] (const int k) {\n        return table[0][k];\n    };\n};\n//===\n\nint RMQ(void) {\n    using ll = long long;\n\n    ll n, q;\n    ll com, x, y;\n    vector<ll> arr;\n\n    cin >> n >> q;\n    for (int i = 0; i < n; i++) {\n        cin >> x;\n        arr.push_back(x);\n    }\n\n    cout << \"building...\" << endl;\n    SparseTable<ll> st(arr.begin(), arr.end(), [](ll l, ll r){return max(l, r);});\n    cout << \"done.\" << endl;\n    while (q--) {\n        cin >> x >> y;\n        cout << st.fold(x, y) << endl;\n    }\n\n    return 0;\n}\n\nint PCK2014_pre_8(void) {\n    using ll = long long;\n    struct Star{ ll x, y, b; };\n    auto scmp = [](const Star &x, const Star &y) {\n                    if (x.b < y.b) return true;\n                    else return false;\n                };\n\n    ll ans = 0;\n    ll n, d;\n    vector<Star> s;\n    \n    cin >> n >> d;\n    s = vector<Star>(n);\n    for (int i = 0; i < n; i++) {\n        cin >> s[i].x >> s[i].y >> s[i].b;\n    }\n\n    sort(s.begin(), s.end(), scmp);\n    \n    SparseTable<ll> minX(n, 0, [](ll l, ll r){return min(l, r);});\n    SparseTable<ll> maxX(n, 0, [](ll l, ll r){return max(l, r);});\n    SparseTable<ll> minY(n, 0, [](ll l, ll r){return min(l, r);});\n    SparseTable<ll> maxY(n, 0, [](ll l, ll r){return max(l, r);});\n\n    for (int i = 0; i < n; i++) {\n        minX.set(i, s[i].x);\n        maxX.set(i, s[i].x);\n\n        minY.set(i, s[i].y);\n        maxY.set(i, s[i].y);\n    }\n\n    for (int i = 0; i < n; i++) {\n        ll l = i;\n        ll r = upper_bound(s.begin(), s.end(), (Star){0, 0, s[i].b + d}, scmp)\n            - s.begin();\n\n        ll x = maxX.fold(l, r) - minX.fold(l, r);\n        ll y = maxY.fold(l, r) - minY.fold(l, r);\n\n        ans = max(ans, x * y);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\nint main() {\n    //return RMQ();\n    return PCK2014_pre_8();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nstruct SegTree{\n    static const int N=1<<18;\n    int *dat;\n\n    SegTree(){\n        dat=new int[N*2-1];\n        for(int i=0;i<N*2-1;i++)dat[i]=INT_MAX;\n    }\n\n    void update(int k,int x){\n        k+=N-1;\n        dat[k]=min(dat[k],x);\n        while(k){\n            k=(k-1)/2;\n            dat[k]=min(dat[k],x);\n        }\n    }\n\n    int getMin(int a,int b,int k=0,int l=0,int r=N){\n        if(r<=a||b<=l)return INT_MAX;\n        if(a<=l&&r<=b)return dat[k];\n        int m=(l+r)/2;\n        int vl=getMin(a,b,k*2+1,l,m);\n        int vr=getMin(a,b,k*2+2,m,r);\n        return min(vl,vr);\n    }\n};\ntypedef pair<int,int>P;\ntypedef pair<int,P>PP;\n#define fi first\n#define se second\ntypedef long long ll;\n\nint N,D;\nPP Stars[200000];\nSegTree minx,miny,maxx,maxy;\n\nint main(){\n    scanf(\"%d%d\",&N,&D);\n    for(int i=0;i<N;i++){\n        int x,y,b;\n        scanf(\"%d%d%d\",&x,&y,&b);\n        Stars[i]=PP(b,P(x,y));\n    }\n\n    sort(Stars,Stars+N);\n\n    for(int i=0;i<N;i++){\n        minx.update(i,Stars[i].se.fi);\n        miny.update(i,Stars[i].se.se);\n        maxx.update(i,-Stars[i].se.fi);\n        maxy.update(i,-Stars[i].se.se);\n    }\n\n    ll ans=0;\n\n    for(int i=0;i<N;i++){\n        int j=upper_bound(Stars,Stars+N,PP(Stars[i].fi+D,P(INT_MAX,INT_MAX)))-Stars;\n        ll w=-maxx.getMin(i,j)-minx.getMin(i,j);\n        ll h=-maxy.getMin(i,j)-miny.getMin(i,j);\n        ans=max(ans,h*w);\n    }\n\n    cout<<ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\n#define MAX_N 1 << 20\nint n, d, size_, dat[2][2][MAX_N];//[xy][minmax][pos]\ntuple<int, int, int>x[MAX_N];\ninline void init(int n) {\n\tfor (size_ = 1; size_ <= n;) size_ *= 2;\n\tfor (int i = 0; i < 2; i++) { for (int j = 0; j < MAX_N; j++) { dat[i][0][j] = 1 << 30; dat[i][1][j] = -(1 << 30); } }\n}\ninline void update(int pos, int x, int p1) {\n\tpos += size_; dat[p1][0][pos] = x; dat[p1][1][pos] = x;\n\twhile (pos != 1) {\n\t\tpos >>= 1;\n\t\tdat[p1][0][pos] = min(dat[p1][0][pos * 2], dat[p1][0][pos * 2 + 1]);\n\t\tdat[p1][1][pos] = max(dat[p1][1][pos * 2], dat[p1][1][pos * 2 + 1]);\n\t}\n}\ninline int query(int a, int b, int k, int l, int r, int p1, int p2) {\n\tif (r <= a || b <= l) { if (p2 == 0)return 1 << 30; return -(1 << 30); }\n\tif (a <= l && r <= b) return dat[p1][p2][k]; k <<= 1;\n\tint lc = query(a, b, k, l, (l + r) / 2, p1, p2);\n\tint rc = query(a, b, k + 1, (l + r) / 2, r, p1, p2);\n\tif (p2 == 0)return min(lc, rc);\n\tif (p2 == 1)return max(rc, lc);\n}\ninline int rmqw(int x, int y, int p) {\n\tint V1 = query(x, y + 1, 1, 0, size_, p, 1), V2 = query(x, y + 1, 1, 0, size_, p, 0);\n\treturn V1 - V2;\n}\nint main() {\n\tcin >> n >> d; init(n); for (int i = 1; i <= n; i++) { cin >> get<1>(x[i]) >> get<2>(x[i]) >> get<0>(x[i]); }\n\tsort(x + 1, x + n + 1); long long maxn = 0;\n\tfor (int i = 1; i <= n; i++) { update(i, get<1>(x[i]), 0); update(i, get<2>(x[i]), 1); }\n\tfor (int i = 1; i <= n; i++) {\n\t\tint R = lower_bound(x + 1, x + n + 1, make_tuple(get<0>(x[i]) + d, 1 << 30, 1 << 30)) - x; R--;\n\t\tmaxn = max(maxn, 1LL*rmqw(i, R, 0)*rmqw(i, R, 1));\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,a,n) for(int i=a; i<n; i++)\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\n\n#define MAX_N 200010\n#define INF 2000000000\n\nvector<pair<ll, pair<ll, ll>>> st;\nll seg_mi[MAX_N * 2],seg_mx[MAX_N*2];\nll n, d;\n\nstruct RMQ\n{\n\tvoid update(ll k, ll x)\n\t{\n\t\tk += n - 1;\n\t\tseg_mi[k] = x;\n\t\tseg_mx[k] = x;\n\t\twhile (k)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\tseg_mi[k] = min(seg_mi[k * 2 + 1], seg_mi[k * 2 + 2]);\n\t\t\tseg_mx[k] = max(seg_mx[k * 2 + 1], seg_mx[k * 2 + 2]);\n\t\t}\n\t}\n\n\tll query1(ll a, ll b, ll k, ll l, ll r)\n\t{\n\t\tif (r <= a || b <= l)return INF;\n\t\telse if (a <= l && r <= b) return seg_mi[k];\n\t\telse return min(query1(a, b, k * 2 + 1, l, (l + r) / 2), query1(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\n\tll query2(ll a, ll b, ll k, ll l, ll r)\n\t{\n\t\tif (r <= a || b <= l)return INF;\n\t\telse if (a <= l && r <= b) return seg_mx[k];\n\t\telse return max(query2(a, b, k * 2 + 1, l, (l + r) / 2), query2(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n};\n\n\nint main()\n{\n\tRMQ seg_mi_x,seg_mx_x,seg_mi_y,seg_mx_y;\n\n\tcin >> n >> d;\n\tst.resize(n);\n\n\trep(i, n) {\n\t\tcin >> st[i].second.first >> st[i].second.second >> st[i].first;\n\t\tseg_mi_x.update(i,st[i].second.first);\n\t\tseg_mx_x.update(i,st[i].second.first);\n\t\tseg_mi_y.update(i, st[i].second.second);\n\t\tseg_mx_y.update(i, st[i].second.second);\n\t}\n\n\tsort(st.begin(), st.end());\n\n\tll ans = 0;\n\tfor (int left = 0, right = 1; ;) {\n\t\tif (abs(st[left].first - st[right].first) <= d) {\n\t\t\tll x = seg_mx_x.query2(0,n,left,left,right)-\n\t\t\t\tseg_mi_x.query1(0,n,left,left,right);\n\t\t\tll y = seg_mx_y.query2(0, n, left, left, right) -\n\t\t\t\tseg_mi_y.query1(0, n, left, left, right);\n\t\t\tans = max(ans, x*y);\n\t\t\tright++;\n\t\t}\n\t\telse {\n\t\t\tleft++;\n\t\t}\n\t\tif (left >= n || right >= n)break;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\n\nsigned main(){\n    int n, d;\n    cin >> n >> d;\n\n    priority_queue<tuple<int,bool,int>, vector<tuple<int,bool,int>>, greater<tuple<int,bool,int>>> que;\n    vector<int> x(n), y(n), b(n);\n    for(int i = 0; i < n; ++i){\n        cin >> x[i] >> y[i] >> b[i];\n        que.emplace(b[i], false, i);\n        que.emplace(b[i] + d, true, i);\n    }\n    i64 ans = 0;\n    multiset<int> sx, sy;\n    while(!que.empty()){\n        int idx;\n        bool is_delete;\n        tie(ignore, is_delete, idx) = que.top();\n         que.pop();\n        if(is_delete){\n            sx.erase(sx.find(x[idx]));\n            sy.erase(sy.find(y[idx]));\n        }\n        else{\n            sx.insert(x[idx]);\n            sy.insert(y[idx]);\n        }\n        if(!sx.empty()){\n            chmax(ans, 1LL * (*sx.rbegin() - *sx.begin()) * (*sy.rbegin() - *sy.begin()));\n        }\n    }\n    cout << ans << endl;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define b first\n#define x second.first\n#define y second.second\n#define INF 2000000\nusing namespace std;\npair<int,pair<int,int> >s[INF];\nint main(){\n  int n,d,an=0,f=0;\n  cin>>n>>d;\n  for(int i=0;i<n;i++)cin>>s[i].x>>s[i].y>>s[i].b;\n  sort(s,s+n);\n  for(int i=0;i<n;i++){\n    int xmn,xmx,ymn,ymx;\n    xmn=ymn=INF*10;xmx=ymx=0;\n    for(int j=i;s[j].b-s[i].b<=d;j++){\n      xmx=max(xmx,s[j].x);\n      ymx=max(ymx,s[j].y);\n      xmn=min(xmn,s[j].x);\n      ymn=min(ymn,s[j].y);\n      if(j==n-1){f=1;break;}\n    }\n    an=max(an,(xmx-xmn)*(ymx-ymn));\n    if(f==1)break;\n  }\n  cout<<an<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\nint n, size_, dat[2][2][266666];//[xy][minmax][pos]\ntuple<int, int, int>x[266666];\ninline void init(int n) {\n\tfor (size_ = 1; size_ < n;) size_ *= 2;\n\tfor (int i = 0; i < 2; i++) { for (int j = 0; j < 266666; j++) { dat[i][0][j] = 1 << 30; dat[i][1][j] = -(1 << 30); } }\n}\ninline void update(int pos, int x, int p1) {\n\tpos += size_; dat[p1][0][pos] = x; dat[p1][1][pos] = x;\n\twhile (pos != 1) {\n\t\tpos >>= 1;\n\t\tdat[p1][0][pos] = min(dat[p1][0][pos * 2], dat[p1][0][pos * 2 + 1]);\n\t\tdat[p1][1][pos] = max(dat[p1][1][pos * 2], dat[p1][1][pos * 2 + 1]);\n\t}\n}\ninline int query(int a, int b, int k, int l, int r, int p1, int p2) {\n\tif (r <= a || b <= l) { if (p2 == 0)return 1 << 30; return -(1 << 30); }\n\tif (a <= l && r <= b) return dat[p1][p2][k]; k <<= 1;\n\tint lc = query(a, b, k, l, (l + r) / 2, p1, p2);\n\tint rc = query(a, b, k + 1, (l + r) / 2, r, p1, p2);\n\tif (p2 == 0)return min(lc, rc);\n\tif (p2 == 1)return max(rc, lc);\n}\ninline int rmqw(int x, int y, int p) {\n\tint V1 = query(x, y + 1, 1, 0, size_, p, 1), V2 = query(x, y + 1, 1, 0, size_, p, 0);\n\treturn V1 - V2;\n}\nint main() {\n\tcin >> n; init(n); for (int i = 1; i <= n; i++) { cin >> get<0>(x[i]) >> get<1>(x[i]) >> get<2>(x[i]); }\n\tsort(x + 1, x + n + 1); long long maxn = 0;\n\tfor (int i = 1; i <= n; i++) { update(i, get<1>(x[i]), 0); update(i, get<2>(x[i]), 1); }\n\tfor (int i = 1; i <= n; i++) {\n\t\tint R = lower_bound(x + 1, x + n + 1, make_tuple(get<0>(x[i]), 1 << 30, 1 << 30)) - x;\n\t\tmaxn = max(maxn, 1LL*rmqw(i, R, 0)*rmqw(i, R, 1));\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef vector<int> vi;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n//26\n\nstruct st{int x, y, c;};\nvector<st> vec;\nint X[400000], Y[400000];\nsigned main(){\n\tint n, d;\n\tscanf(\"%lld%lld\", &n, &d);\n\trep(i,n){\n\t\tint x, y, c;\n\t\tscanf(\"%lld%lld%lld\", &x, &y, &c);\n\t\t//vec[i] = {}();\n\t\tvec.push_back((st){x, y, c});\n\t\tX[i] = x;Y[i] = y;\n\t}\n\tsort(X, X+n);sort(Y, Y+n);\n\t\n\t//printf(\"\\n\");\n\tint ans = 0;\n\trep(i,n){\n\t\tst S = vec[i];\n\t\tint x = S.x, y = S.y, c = S.c;\n\t\tint p[4] = {0};\n\t\tp[0] = *lower_bound(X, X+n, x-d);\n\t\tp[1] = *lower_bound(Y, Y+n, y-d);\n\t\tint xx = upper_bound(X, X+n, x+d)-X;\n\t\tint yy = upper_bound(Y, Y+n, y+d)-Y;\n\t\tp[2] = X[max(xx-1, (int)0)];\n\t\tp[3] = Y[max(yy-1, (int)0)];\n\t\tchmax(ans, (p[2]-p[0])*(p[3]-p[1]));\n\t\t//printf(\"%lld %lld %lld\\n\", x, y, c);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct STAR {\n  int x, y, d;\n};\n\nbool asc(STAR &l, STAR &r) {\n  return l.d < r.d;\n}\n\nint main() {\n  ll n, d, ans = 0;\n  cin >> n >> d;\n  vector<STAR> v(n);\n\n  rep(i, 0, n) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    v[i].x = a;\n    v[i].y = b;\n    v[i].d = c;\n  }\n\n  sort(v.begin(), v.end(), asc);\n\n  int hx = v[0].x, lx = v[0].x, hy = v[0].y, ly = v[0].y, ld = v[0].d, lp = 0;\n  rep(i, 0, n - 1) {\n    if(v[i + 1].d - ld <= d) {\n      hx = max(hx, v[i + 1].x);\n      hy = max(hy, v[i + 1].y);\n      lx = min(lx, v[i + 1].x);\n      ly = min(ly, v[i + 1].y);\n    }else {\n      ans = max(ans, (ll)(abs(hx - lx) * abs(hy - ly)));\n      rep(j, lp + 1, i + 1) {\n        if(v[i + 1].d - v[j].d <= d) {\n          lp = j;\n          break;\n        }\n      }\n      hx = v[lp].x, lx = v[lp].x, hy = v[lp].y, hx = v[lp].y;\n      rep(j, lp + 1, i + 1) {\n        hx = max(hx, v[j].x);\n        hy = max(hy, v[j].y);\n        lx = min(lx, v[j].x);\n        ly = min(ly, v[j].y);\n      }\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint N,d;\n\tcin >> N >> d;\n\tvector< array<int,3> > star;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tint x,y,b;\n\t\tcin >> x >> y >> b;\n\t\tstar.push_back({b,x,y});\n\t}\t\n\tsort(star.begin(),star.end());\n\tint l = 0 , r = 0;\n\tmultiset<int> X,Y;\n\tlong long ans = 0;\n\twhile( r != N){\n\t\tX.insert(star[r][1]);\n\t\tY.insert(star[r][2]);\n\t\tr++;\n\t\twhile( star[r-1][0] - star[l][0] > d ){\n\t\t\tX.erase(X.find(star[l][1]));\n\t\t\tY.erase(Y.find(star[l][2]));\n\t\t\tl++;\n\t\t}\n\t\tans = max((long long)((*X.rbegin())-(*X.begin())) * ((*Y.rbegin())-(*Y.begin())),ans);\n\t\t//cout << (*X.rbegin())-(*X.begin()) << \" \" << ((*Y.rbegin())-(*Y.begin())) << \"|\" << star[r-1][0] - star[l][0] << endl;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<stdlib.h>\n#define int long long\nusing namespace std;\n\nint n, d;\t//1 <= n <= 2*10^5, 0 <= d <= 10^9\nstruct Star {\n\tint x, y, b;\n}star[200000];\n\nsigned compare(const void *s1, const void *s2) {\n\tint t1 = ((Star*)s1)->b;\n\tint t2 = ((Star*)s2)->b;\n\treturn t1 - t2;\n}\nsigned main() {\n\tint i;\n\tcin >> n >> d;\n\tfor( i = 0; i < n; i++ )\n\t\tcin >> star[i].x >> star[i].y >> star[i].b;\n\tqsort(star, n, sizeof(star[0]), compare);\n\n\tstatic multiset<int> X;\n\tstatic multiset<int> Y;\n\tmultiset<int>::iterator it;\n\tmultiset<int>::reverse_iterator rit;\n\tint ins = 0;\n\tint del = 0;\n\tint j;\n\tint ans = 0;\n\n\t/*for( i = 0; i < n; i++ ) {\n\t\tprintf(\"index = %d x = %d y = %d b = %d\\n\", i, star[i].x, star[i].y, star[i].b);\n\t}*/\n\n\tfor( i = 0; i < n; i++ ) {\n\t\tins = i;\n\t\tX.insert( star[ins].x );\n\t\tY.insert( star[ins].y );\n\t\tfor(; del < n; del++ ) {\n\t\t\tif( star[del].b < star[i].b - d ) {\n\t\t\t\tit = X.find( star[del].x );\n\t\t\t\tX.erase( it );\n\t\t\t\tit = Y.find( star[del].y );\n\t\t\t\tY.erase( it );\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tit = X.begin();\n\t\tint minx = *it;\n\t\trit = X.rbegin();\n\t\tint maxx = *rit;\n\t\tit = Y.begin();\n\t\tint miny = *it;\n\t\trit = Y.rbegin();\n\t\tint maxy = *rit;\n\t\tans = max( ans, (maxx - minx) * (maxy - miny) );\n\n\t\t//printf(\"ins = %d, del = %d, x[%d, %d], y[%d, %d]\\n\", ins, del, minx, maxx, miny, maxy);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1<<29)\ntypedef long long ll;\n\nstruct MinSegtree\n{\n  int n;\n  int dat[400005];\n  MinSegtree(int _n)\n  {\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*21;i++)\n      dat[i] = INF;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n\n  int query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return INF;\n\n    if(a <= l && r <= b) return dat[k];\n    else{\n      int vl = query(a, b, k*2+1, l, (l + r) / 2);\n      int vr = query(a, b, k*2+2, (l + r) / 2, r);\n      return min(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nstruct MaxSegtree\n{\n  int n;\n  int dat[400005];\n  MaxSegtree(int _n){\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*2-1;i++)\n      dat[i] = -1;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n  \n  int query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return -1;\n    \n    if(a <= l && r <=b ) return dat[k];\n    else{\n      int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n      int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n      return max(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nint main()\n{\n  int n, d;\n  scanf(\"%d%d\", &n, &d);\n  MinSegtree minx(n);\n  MinSegtree miny(n);\n  MaxSegtree maxx(n);\n  MaxSegtree maxy(n);\n  \n  vector<pair<int, pair<int, int> > >s(n);\n  vector<int>br(n);\n  for(int i=0;i<n;i++){\n    int x, y, b;\n    scanf(\"%d%d%d\", &x, &y, &b);\n    s[i] = make_pair(b, make_pair(x, y));\n    br[i] = b;\n  }\n  sort(s.begin(), s.end());\n  sort(br.begin(), br.end());\n\n\n  for(int i=0;i<n;i++){\n    minx.update(i, s[i].second.first);\n    maxx.update(i, s[i].second.first);\n    miny.update(i, s[i].second.second);\n    maxy.update(i, s[i].second.second);\n  }\n\n  br.push_back(INF);\n  ll res = 0;\n  for(int i=0;i<n;i++){\n    int pos = (int)(upper_bound(br.begin(), br.end(), br[i] + d) - br.begin());\n    int w = maxx.query(i, pos, 0, 0, maxx.size()) - minx.query(i, pos, 0, 0, minx.size());\n    int h = maxy.query(i, pos, 0, 0, maxy.size()) - miny.query(i, pos, 0, 0, miny.size());\n    res = max(res, (ll)w * (ll)h);\n  }\n\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define repp(i,k,n) for(int i=k;i<(int)n;i++)\n#define rei(n) for(int i=0;i<(int)n;i++)\n#define rel(n) for(int l=0;l<(int)n;l++)\n//#define int long long\n#define al(s) s.begin(),s.end()\n#define INT_MAX 2147483647\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> ppi;\ntypedef pair<int, ppi> pipp;\ntypedef pair<int, pi> pip;\ntypedef pair<long long, pi> llpi;\n\nstruct SegTree\n{\n\tint N;\n\tvector<int> Seg;\n\tvoid init(int n)\n\t{\n\t\tN = 1;\n\t\twhile (N < n)N *= 2;\n\t\tfor (int i = 0; i < N*2; i++)\n\t\t{\n\t\t\tSeg.push_back(INT_MAX);\n\t\t}\n\t\t\n\t}\n\t\n\tvoid update(int k, int a)\n\t{\t\n\t\tk = k - 1 + N;\n\t\tSeg[k] = a;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\tSeg[k] = min(Seg[2 * k + 1], Seg[2 * k + 2]);\n\t\t}\n\t}\n\tint find_min(int a, int b)\n\t{\n\t\treturn query(a, b, 0, 0, N);\n\t}\n\n\tint query(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || l >= b)return INT_MAX;\n\t\tif (l>=a&&r<=b)\n\t\t{\n\t\t\treturn Seg[k];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn min(query(a, b, k * 2 + 1, l, (r + l) / 2),\n\t\t\t\t\t   query(a, b, k * 2 + 2, (r + l) / 2, r));\n\t\t}\n\t}\n};\n\nSegTree ss[4];//min,max\n\nvector<llpi> a;\n//set<long long> s;\nvector<long long >s;\nint  main()\n{\n\tlong long ans = 0;\n\tlong long n, d;\n\tcin >> n >> d;\n\trei(4)ss[i].init(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlong long b;\n\t\tint x, y;\n\t\tcin >> x >> y >> b;\n\t\ta.push_back(llpi(b, pi(x, y)));\n\t\ts.push_back(b);\n\t}\n\tsort(al(s));\n\tfor (vector<long long>::iterator i=s.begin()+1; i !=s.end(); )\n\t{\n\t\tif (*i == *(i - 1))\n\t\t{\n\t\t\ti = s.erase(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint jj = 0;\n\t\tvector<long long> ::iterator it = lower_bound(al(s),a[i].first);\n\t\tfor (vector<long long>::iterator l = s.begin(); l != it; l++)\n\t\t{\n\t\t\tjj++;\n\t\t}\n\t\t\n\t\tss[0].update(jj, min(a[i].second.first, ss[0].Seg[jj + ss[0].N - 1]));\n\t\tss[2].update(jj, min(a[i].second.first*(-1), ss[2].Seg[jj + ss[0].N - 1]));\n\n\t\tss[1].update(jj, min(a[i].second.second, ss[1].Seg[jj + ss[0].N - 1]));\n\t\tss[3].update(jj, min(a[i].second.second*(-1), ss[3].Seg[jj + ss[0].N - 1]));\n\n\t}\n\tbool end = false;\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tif(end)break;\n\t\tvector<long long>::iterator it, ne;\n\t\tit = s.begin();\n\t\tfor (int l = 0; l < i; l++)it++;\n\t\tne = upper_bound(al(s),*it + d);\n\t\tif (ne == s.end())end = true;\n\t\tne--;\n\t\tint coun = 0;\n\t\tfor (; it != ne; it++)coun++;\n\t\tcoun += i;\n\t\tcoun++;\n\t\tans = max( ans, (long long)((-1) * ss[2].find_min(i, coun) - ss[0].find_min(i, coun)) * (long long)((-1) * ss[3].find_min(i, coun) - ss[1].find_min(i, coun)) );\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint N=0;\nlong int b=0;\nint maxx=0,maxy=0,maxs=0,ks=0,x[200000],y[200000],cnt=0;\nstruct DATA{\n\tint x,y,b;\n};\nDATA data[200000];\n\nint main(){\n\tcin>>N>>b;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>data[i].x>>data[i].y>>data[i].b;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tmaxx=0;maxy=0;cnt=1;\n\t\tx[0]=data[i].x;\n\t\ty[0]=data[i].y;\n\t\tfor(int j=0;j<N;j++){\n\t\t\t\n\t\t\tif(0<=data[i].b-data[j].b&&data[i].b-data[j].b<=b){\n\t\t\t\tcnt++;\n\t\t\t\tx[cnt]=data[j].x;\n\t\t\t\ty[cnt]=data[j].y;\n\t\t\t}\n\t\t\tif(j==N-1){\n\t\t\t\tsort(x,x+cnt);\n\t\t\t\tsort(y,y+cnt);\n\t\t\t\tmaxx=x[cnt]-x[0];\n\t\t\t\tmaxy=y[cnt]-y[0];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tks=maxx*maxy;\n\t\tif(maxs<ks){maxs=ks;}\n\t}\n\tcout<<maxs<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define repp(i,k,n) for(int i=k;i<(int)n;i++)\n#define rei(n) for(int i=0;i<(int)n;i++)\n#define rel(n) for(int l=0;l<(int)n;l++)\n#define int long long\n#define al(s) s.begin(),s.end()\n#define INT_MAX 2147483647\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> ppi;\ntypedef pair<int, ppi> pipp;\ntypedef pair<int, pi> pip;\ntypedef pair<long long, pi> llpi;\n\nstruct SegTree\n{\n\tint N;\n\tvector<int> Seg;\n\tvoid init(int n)\n\t{\n\t\tN = 1;\n\t\twhile (N < n)N *= 2;\n\t\tfor (int i = 0; i < N*2; i++)\n\t\t{\n\t\t\tSeg.push_back(INT_MAX);\n\t\t}\n\t\t\n\t}\n\t\n\tvoid update(int k, int a)\n\t{\t\n\t\tk = k - 1 + N;\n\t\tSeg[k] = a;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\tSeg[k] = min(Seg[2 * k + 1], Seg[2 * k + 2]);\n\t\t}\n\t}\n\tint find_min(int a, int b)\n\t{\n\t\treturn query(a, b, 0, 0, N);\n\t}\n\n\tint query(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || l >= b)return INT_MAX;\n\t\tif (l>=a&&r<=b)\n\t\t{\n\t\t\treturn Seg[k];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn min(query(a, b, k * 2 + 1, l, (r + l) / 2),\n\t\t\t\t\t   query(a, b, k * 2 + 2, (r + l) / 2, r));\n\t\t}\n\t}\n};\n\nSegTree ss[4];//min,max\n\nvector<llpi> a;\nset<long long> s;\nsigned main()\n{\n\tlong long ans = 0;\n\tlong long n, d;\n\tcin >> n >> d;\n\trei(4)ss[i].init(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlong long b;\n\t\tint x, y;\n\t\tcin >> x >> y >> b;\n\t\ta.push_back(llpi(b, pi(x, y)));\n\t\ts.insert(b);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint jj = 0;\n\t\tset<long long> ::iterator it = s.find(a[i].first);\n\t\tfor (set<long long>::iterator l = s.begin(); l != it; l++)\n\t\t{\n\t\t\tjj++;\n\t\t}\n\t\t\n\t\tss[0].update(jj, min(a[i].second.first, ss[0].Seg[jj + ss[0].N - 1]));\n\t\tss[2].update(jj, min(a[i].second.first*(-1), ss[2].Seg[jj + ss[0].N - 1]));\n\n\t\tss[1].update(jj, min(a[i].second.second, ss[1].Seg[jj + ss[0].N - 1]));\n\t\tss[3].update(jj, min(a[i].second.second*(-1), ss[3].Seg[jj + ss[0].N - 1]));\n\n\t}\n\tbool end = false;\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tif (end)break;\n\t\tset<long long>::iterator it, ne;\n\t\tit = s.begin();\n\t\tfor (int l = 0; l < i; l++)it++;\n\t\tne = s.upper_bound(*it + d);\n\t\tif (ne == s.end())end = true;\n\t\tne--;\n\t\tint coun = 0;\n\t\tfor (; it != ne; it++)coun++;\n\t\tcoun += i;\n\t\tcoun++;\n\t\tans = max( ans, ((-1) * ss[2].find_min(i, coun) - ss[0].find_min(i, coun)) * ((-1) * ss[3].find_min(i, coun) - ss[1].find_min(i, coun)) );\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n#define N 200000\n#define F first\n#define Se second\n#define MP(i, j) make_pair((i), (j))\n#define int long long\nstruct S{\n\tint sx, lx, sy, ly;\n\tS(int isx, int ilx, int isy, int ily): sx(isx), lx(ilx), sy(isy), ly(ily){}\n\tbool operator<(const S &s) const { \n\t\treturn 1;\n\t}\n};\nint cnt;\nvoid init(int n_, int *dat){\n\tcnt = 1;\n\twhile(cnt < n_) cnt *= 2;\n\tfor(int i = 0; i < 2 * cnt - 1; i++) dat[i] = INT_MAX;\n}\nvoid update(int k, int a, int *dat){\n\tk += cnt - 1;\n\tdat[k] = a;\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nint query(int a, int b, int k, int l, int r, int *dat){\n\tif(r <= a || b <= l) return INT_MAX;\n\tif(a <= l && r <= b) return dat[k];\n\telse{\n\t\tint v1 = query(a, b, k * 2 + 1, l, (l + r) / 2, dat);\n\t\tint vr = query(a, b, k * 2 + 2, (l + r) / 2, r, dat);\n\t\treturn min(v1, vr);\n\t}\n}\ntypedef pair<int, S> PS;\ntypedef vector<PS>::iterator it;\n\nint i, j, n, d, stars[MAX_N][3], ax[2 * N], bx[2 * N], ay[2 * N], by[2 * N];\nint ans = 0;\nvector<PS> vec;\n\nvoid vdc(vector<PS> &vf, S s, int now){\n\tif(vf[now].Se.sx > s.sx)\n\t\tvf[now].Se.sx = s.sx;\n\tif(vf[now].Se.lx < s.lx)\n\t\tvf[now].Se.lx = s.lx;\n\tif(vf[now].Se.sy > s.sy)\n\t\tvf[now].Se.sy = s.sy;\n\tif(vf[now].Se.ly < s.ly)\n\t\tvf[now].Se.ly = s.ly;\n}\n\nsigned main(){\n\tcin >> n >> d;\n\tvec.push_back(MP(-1, S(0, 0, 0, 0)));\n\tfor(i = 0; i < n; i++){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tS s = S(a, a, b, b);\n\t\tit ite = lower_bound(vec.begin(), vec.end(), MP(c, s));\n\t\tif(vec[ite - vec.begin() - 1].F != c){\n\t\t\tvec.insert(ite, MP(c, s));\n\t\t}\n\t\telse{\n\t\t\tvdc(vec, s, ite - vec.begin() - 1);\n\t\t}\n\t}\n\tinit(vec.size(), ax);\n\tinit(vec.size(), bx);\n\tinit(vec.size(), ay);\n\tinit(vec.size(), by);\n\tS s = S(INT_MAX, 0, INT_MAX, 0);\n\tvec.erase(vec.begin());\n\tfor(i = 0; i < vec.size(); i++){\n\t\tupdate(i, vec[i].Se.sx, ax);\n\t\tupdate(i, -vec[i].Se.lx, bx);\n\t\tupdate(i, vec[i].Se.sy, ay);\n\t\tupdate(i, -vec[i].Se.ly, by);\n\t}\n\ti = 0; j = 0;\n\tfor(;;){\n\t\twhile(j < vec.size()){\n\t\t\tif(vec[j].F - vec[i].F <= d)\n\t\t\t\tj++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tans = max(ans, (-query(i, j, 0, 0, cnt, bx) - query(i, j, 0, 0, cnt, ax)) * (-query(i, j, 0, 0, cnt, by) - query(i, j, 0, 0, cnt, ay)));\n\t\tif(j == vec.size())\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define int long long int\n#define rep(a,b,c) for(int a=b;a<c;a++)\n#define repm(a,b,c) for(int a=(b-1);a>=c;a--)\n#define pb push_back\n#define str string\n#define sf(a) scanfs(\"%d\",&a)\n#define pb push_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n#define clean(used) memset(used,false,sizeof(used))\nusing namespace std;\n\nstatic const int INF = 1e18 + 9;\nstatic const int Mod = 1e9 + 7;\ninline int replac(str s){double ans=0;rep(i,0,s.length()){ans+=(s[i]-'0')*pow(10,s.length()-i-1);}return (int)ans;}\ninline string numstr(int m){str s=\"\";while(m>0){char c;int a=m/10;if(a>0)a=m%(a*10);else a=m;c=(char)('0'+a);s+=c;m/=10;}str st=\"\";for(int i=s.size()-1;i>=0;i--){st+=s[i];}return st;}\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\n\nstatic const int MAX_N = 200002;\n\nstruct Seg{\n    int n;\n    int dat[MAX_N * 2];\n    void init(int n_){\n        init(n_ , INF);\n    }\n\n    void init(int n_, int d){\n        n = 1;\n        while(n < n_)n *= 2;\n        fill(dat, dat + MAX_N * 2, d);\n    }\n};\n\nstruct Segment : Seg {\n    int Min(int s,int t){\n        return Min(s,t,0,0,n);\n    }\n    int Min(int s, int t, int k, int l, int r){\n        if(r <= s || t <= l) return INF;\n        if(s <= l && r <= t) return dat[k];\n\n        int t1 = Min(s, t, k * 2 + 1, l, (l + r)/2);\n        int t2 = Min(s, t, k * 2 + 2, (l + r)/2, r);\n        return min(t1, t2);\n    }\n    void update(int k, int x){\n        k += n - 1;\n        dat[k] = min(dat[k], x);\n        while(0 < k){\n            k = (k - 1)/2;\n            dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n};\n\nSegment x_1,x_2,y_1,y_2;\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int d,m;\n    cin >> m >> d;\n    x_1.init(m);\n    x_2.init(m);\n    y_1.init(m);\n    y_2.init(m);\n    int b_max = 0;\n    int x,y,b;\n    rep(i,0,m){\n        cin >> x >> y >> b;\n        x_1.update(b,x);\n        x_2.update(b,-x);\n        y_1.update(b,y);\n        y_2.update(b,-y);\n    }\n    int ans = 0,x_mi,x_ma,y_mi,y_ma;\n    rep(i,0,MAX_N-d){\n        x_mi = x_1.Min(i,i+d+1);\n        x_ma = x_2.Min(i,i+d+1);\n        y_mi = y_1.Min(i,i+d+1);\n        y_ma = y_2.Min(i,i+d+1);\n        ans = max(ans, abs(x_ma+x_mi)*abs(y_ma+y_mi));\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio> \n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n\nstruct stars\n{\n\tint maxx=0,minx=0;\n\tint maxy=0,miny=0;\n};\n\n\nsigned main()\n{\n\tmap<int, stars> data;\n\tint n, d;\n//\tscanf(\"%llu %llu\", &n, &d);\n\tscanf(\"%d%d\", &n, &d);\n\n\tstars foo; int x, y, b;\n\tfor (int i = 0; i < n; ++i)\n\t{\n//\t\tscanf(\"%llu %llu %llu\", &x, &y, &b);\n\t\tscanf(\"%d%d%d\", &x, &y, &b);\n\t\tif (data.count(b) == 0)\n\t\t{\n\n\t\t\tdata[b].maxx = x;\n\t\t\tdata[b].minx = x;\n\t\t\tdata[b].maxy = y;\n\t\t\tdata[b].miny = y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdata[b].maxx = max(data[b].maxx, x);\n\t\t\tdata[b].minx = min(data[b].minx, x);\n\t\t\tdata[b].maxy = max(data[b].maxy, y);\n\t\t\tdata[b].miny = max(data[b].miny, y);\n\t\t}\n\t}\n\n\tint ans=0;\n\tstars vec;\n//\tprintf(\"%llu\\n\", vec.maxx);\n\n\tfor (auto itr = data.begin();itr != data.end();++itr)\n\t{\n\t\tauto a = *itr;\n\t\tfor (int i = a.first; i < d; ++i)\n\t\t{\n\t\t\tif (data.count(i) == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvec.maxx = max(vec.maxx, a.second.maxx);\n\t\t\tvec.minx = min(vec.minx, a.second.minx);\n\t\t\tvec.maxy = max(vec.maxy, a.second.maxy);\n\t\t\tvec.miny = min(vec.miny, a.second.miny);\n\t\n\t\t}\n\t\tans = max(ans, (vec.maxx - vec.minx)*(vec.maxy - vec.miny));\n\t}\n\n//\tprintf(\"%I64u\\n\",ans);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<stdlib.h>\nusing namespace std;\n\nint n, d;\t//1 <= n <= 2*10^5, 0 <= d <= 10^9\nstruct Star {\n\tint x, y, b;\n}star[200000];\n\nint compare(const void *s1, const void *s2) {\n\tint t1 = ((Star*)s1)->b;\n\tint t2 = ((Star*)s2)->b;\n\treturn t1 - t2;\n}\nint main() {\n\tint i;\n\tcin >> n >> d;\n\tfor( i = 0; i < n; i++ )\n\t\tcin >> star[i].x >> star[i].y >> star[i].b;\n\tqsort(star, n, sizeof(star[0]), compare);\n\n\tstatic multiset<int> X;\n\tstatic multiset<int> Y;\n\tmultiset<int>::iterator it;\n\tmultiset<int>::reverse_iterator rit;\n\tint ins = 0;\n\tint del = 0;\n\tint j;\n\tint ans = 0;\n\n\t/*for( i = 0; i < n; i++ ) {\n\t\tprintf(\"index = %d x = %d y = %d b = %d\\n\", i, star[i].x, star[i].y, star[i].b);\n\t}*/\n\n\tfor( i = 0; i < n; i++ ) {\n\t\tins = i;\n\t\tX.insert( star[ins].x );\n\t\tY.insert( star[ins].y );\n\t\tfor(; del < n; del++ ) {\n\t\t\tif( star[del].b < star[i].b - d ) {\n\t\t\t\tit = X.find( star[del].x );\n\t\t\t\tX.erase( it );\n\t\t\t\tit = Y.find( star[del].y );\n\t\t\t\tY.erase( it );\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tit = X.begin();\n\t\tint minx = *it;\n\t\trit = X.rbegin();\n\t\tint maxx = *rit;\n\t\tit = Y.begin();\n\t\tint miny = *it;\n\t\trit = Y.rbegin();\n\t\tint maxy = *rit;\n\t\tans = max( ans, (maxx - minx) * (maxy - miny) );\n\n\t\t//printf(\"ins = %d, del = %d, x[%d, %d], y[%d, %d]\\n\", ins, del, minx, maxx, miny, maxy);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for (int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define Cout(obj) cout << obj << endl\n#define Size(obj) (obj).size()\n#define fcout cout << fixed << setprecision(10)\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\ntemplate <typename T>\nstruct SegTreeMin\n{\n  private:\n    ll N = 1;\n    vector<T> node;\n\n  public:\n    SegTreeMin(vector<T> vec)\n    {\n        ll size = vec.size();\n\n        while (N < size)\n        {\n            N *= 2;\n        }\n\n        node.resize(2 * N - 1, iINF);\n\n        REP(i, size)\n        {\n            node[i + N - 1] = vec[i];\n        }\n\n        for (int i = N - 2; 0 <= i; i--)\n        {\n            node[i] = min(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    void update(int i, T value)\n    {\n        i += (N - 1);\n\n        node[i] = value;\n\n        while (i > 0)\n        {\n            i = (i - 1) / 2;\n\n            node[i] = min(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    T getMin(int a, int b, int i = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = N;\n        }\n\n        if (r <= a || b <= l)\n        {\n            return iINF;\n        }\n\n        if (a <= l && r <= b)\n        {\n            return node[i];\n        }\n\n        T vl = getMin(a, b, 2 * i + 1, l, (l + r) / 2);\n\n        T vr = getMin(a, b, 2 * i + 2, (l + r) / 2, r);\n\n        return min(vl, vr);\n    }\n};\n\ntemplate <typename T>\nstruct SegTreeMax\n{\n  private:\n    ll N = 1;\n    vector<T> node;\n\n  public:\n    SegTreeMax(vector<T> vec)\n    {\n        ll size = vec.size();\n\n        while (N < size)\n        {\n            N *= 2;\n        }\n\n        node.resize(2 * N - 1, -iINF);\n\n        REP(i, size)\n        {\n            node[i + N - 1] = vec[i];\n        }\n\n        for (int i = N - 2; 0 <= i; i--)\n        {\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    void update(int i, T value)\n    {\n        i += (N - 1);\n\n        node[i] = value;\n\n        while (i > 0)\n        {\n            i = (i - 1) / 2;\n\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    T getMax(int a, int b, int i = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = N;\n        }\n\n        if (r <= a || b <= l)\n        {\n            return -iINF;\n        }\n\n        if (a <= l && r <= b)\n        {\n            return node[i];\n        }\n\n        T vl = getMax(a, b, 2 * i + 1, l, (l + r) / 2);\n\n        T vr = getMax(a, b, 2 * i + 2, (l + r) / 2, r);\n\n        return max(vl, vr);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll N, d;\n    cin >> N >> d;\n\n    vector<tuple<ll, ll, ll>> vec(N);\n\n    SegTreeMax<ll> xMax(vector<ll>(N, -iINF)), yMax(vector<ll>(N, -iINF));\n    SegTreeMin<ll> xMin(vector<ll>(N, iINF)), yMin(vector<ll>(N, iINF));\n\n    ll ans = 0;\n\n    REP(i, N)\n    {\n        ll x, y, d;\n        cin >> x >> y >> d;\n\n        vec[i] = make_tuple(d, x, y);\n    }\n\n    sort(ALL(vec));\n\n    REP(i, N)\n    {\n        ll x, y, d;\n        tie(d, x, y) = vec[i];\n\n        xMax.update(i, x);\n        xMin.update(i, x);\n        yMax.update(i, y);\n        yMin.update(i, y);\n    }\n\n    REP(i, N)\n    {\n        ll start = get<0>(vec[i]);\n\n        auto itr = upper_bound(vec.begin(), vec.end(), make_tuple(d + start, iINF, iINF));\n\n        if (itr == vec.begin())\n            continue;\n        if (itr == vec.end())\n            continue;\n\n        ll now = itr - vec.begin();\n\n        ll x = xMax.getMax(i, now), y = yMax.getMax(i, now);\n        ll _x = xMin.getMin(i, now), _y = yMin.getMin(i, now);\n\n        ans = max(ans, (x - _x) * (y - _y));\n    }\n\n    Cout(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include <cmath>\n#include <limits>\n#include <utility>\n#include <map>\n#include <iomanip>\n#include <queue>\n#include <cctype>\n#include <stack>\n#include <random>\n#include <list>\n#include <numeric>\n\n\n\n#define rep(i,p,q) for(ll i = p;i < q;i++)\n#define ll long long\n\nusing namespace std;\n\n//AOJ 302\n\nint main(void) {\n\tll n, d;\n\tcin >> n >> d;\n\tvector<tuple<ll, ll, ll>> stars = vector<tuple<ll, ll, ll>>(n);\n\trep(i, 0, n) {\n\t\tll x, y, b;\n\t\tcin >> x >> y >> b;\n\t\tstars[i] = make_tuple(b, x, y);\n\t}\n\tsort(stars.begin(), stars.end());\n\tpriority_queue<tuple<ll,ll>> xl, xr, yt, yu;\n\txl.push(make_tuple(get<1>(stars[0]), (ll)0));\n\txr.push(make_tuple(-1*get<1>(stars[0]), (ll)0));\n\tyt.push(make_tuple(-1*get<2>(stars[0]), (ll)0));\n\tyu.push(make_tuple(get<2>(stars[0]), (ll)0));\n\tll ans = 0;\n\tll il = 0;\n\trep(ir, 1, n) {\n\t\tauto sN = stars[ir], sB = stars[il];\n\t\tif (abs(get<0>(sN) - get<0>(sB) ) <= d) {\n\t\t\txl.push(make_tuple(get<1>(sN),ir));\n\t\t\txr.push(make_tuple(-1*get<1>(sN), ir));\n\t\t\tyu.push(make_tuple(get<2>(sN), ir));\n\t\t\tyt.push(make_tuple(-1*get<2>(sN), ir));\n\t\t}\n\n\t\tif (ir == n - 1 || abs(get<0>(sN) - get<0>(sB)) > d) {\n\t\t\tans = max(ans, (get<0>(xl.top()) + get<0>(xr.top())) * (get<0>(yt.top()) + get<0>(yu.top())));\n\t\t\twhile (il < ir && abs(get<0>(sN) - get<0>(stars[il])) > d) il++;\n\t\t\tif (ir < n - 1) {\n\t\t\t\twhile (xl.size() > 0 && get<1>(xl.top()) < il) xl.pop();\n\t\t\t\twhile (xr.size() > 0 && get<1>(xr.top()) < il) xr.pop();\n\t\t\t\twhile (yu.size() > 0 && get<1>(yu.top()) < il) yu.pop();\n\t\t\t\twhile (yt.size() > 0 && get<1>(yt.top()) < il) yt.pop();\n\n\t\t\t\txl.push(make_tuple(get<1>(sN), ir));\n\t\t\t\txr.push(make_tuple(-1 * get<1>(sN), ir));\n\t\t\t\tyu.push(make_tuple(get<2>(sN), ir));\n\t\t\t\tyt.push(make_tuple(-1 * get<2>(sN), ir));\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\n\nstruct Star{\n    int x,y,b;\n    Star(int x=0,int y=0,int b=0) :\n        x(x),y(y),b(b){}\n    bool operator<(const Star &rth) const {\n        return std::tie(b,x,y)<std::tie(rth.b,rth.x,rth.y);\n    }\n};\n\nstruct SegTree {\n    int n;\n    vector<ll> min_dat;\n    vector<ll> max_dat;\n    SegTree(int N) {\n        n=1;\n        while(n<N) n*=2;\n        min_dat.assign(1<<18,INF);\n        max_dat.assign(1<<18,0);\n    }\n\n    void update(int k,ll a) {\n        k+=n-1;\n        min_dat[k]=a;\n        max_dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            min_dat[k]=min(min_dat[k*2+1],min_dat[k*2+2]);\n            max_dat[k]=max(max_dat[k*2+1],max_dat[k*2+2]);\n        }\n    }\n\n    ll min_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return INF;\n\n        if(a<=l&&r<=b) return min_dat[k];\n        else {\n            int vl=min_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=min_query(a,b,k*2+2,(l+r)/2,r);\n            return min(vl,vr);\n        }\n    }\n\n    ll max_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return 0;\n\n        if(a<=l&&r<=b) return max_dat[k];\n        else {\n            int vl=max_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=max_query(a,b,k*2+2,(l+r)/2,r);\n            return max(vl,vr);\n        }\n    }\n\n    void dump() {\n        rep(i,n) cout<<max_dat[i]<<\" \";\n        cout<<endl;\n    }\n\n};\nint N,d;\n\n\nvector<Star> stars;\n\nint find(int x) {\n    int l=0;\n    int r=stars.size()-1;\n    while(r-l>1) {\n        int mid=(l+r)/2;\n        if(stars[mid].b<x) l=mid;\n        else r=mid;\n    }\n    return r;\n}\nint main() {\n    cin>>N>>d;\n    rep(i,N) {\n        Star s;\n        cin>>s.x>>s.y>>s.b;\n        stars.pb(s);\n    }\n    SegTree segTreeX(N);\n    SegTree segTreeY(N);\n\n    sort(all(stars));\n\n    rep(i,stars.size()) {\n        // printf(\"%d %d %d %d\\n\",i,stars[i].x,stars[i].y,stars[i].b);\n        segTreeX.update(i,stars[i].x);\n        segTreeY.update(i,stars[i].y);\n    }\n\n\n    ll ans=0;\n    int n=segTreeX.n;\n    rep(i,stars.size()) {\n        int pos=find(stars[i].b+d);\n        if(pos==i) continue;\n        ll tmp=0;\n        tmp=segTreeX.max_query(i,pos+1,0,0,n)-segTreeX.min_query(i,pos+1,0,0,n);\n        tmp*=segTreeY.max_query(i,pos+1,0,0,n)-segTreeY.min_query(i,pos+1,0,0,n);\n\n        // cout<<i<<\",\"<<stars[i].b+d<<\",\"<<pos<<\",\"<<tmp<<endl;\n        ans = max(ans,tmp);\n\n    }\n\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint N,b;\nint maxx,maxy,maxs,kma,kmi,ks;\nstruct DATA{\n\tint x,y,b;\n};\nDATA data[200000];\n\nint main(){\n\tcin>>N>>b;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>data[i].x>>data[i].y>>data[i].b;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tmaxx=0;maxy=0;\n\t\t\tif(0<=data[i].b-data[j].b&&data[i].b-data[j].b<=b){\n\t\t\t\t\n\t\t\t\tif(abs(data[i].x-data[j].x)>maxx){maxx=abs(data[i].x-data[j].x);}\n\t\t\t\tif(abs(data[i].y-data[j].y)>maxx){maxy=abs(data[i].y-data[j].y);}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tks=maxx*maxy;\n\t\tif(maxs<ks){maxs=ks;}\n\t}\n\tcout<<maxs<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MP make_pair\n#define int long long int\nusing namespace std;\ntypedef pair<int, int> PII;\nconst int INF = 3e18;\n\nint n, d, x[200010], y[200010], b[200010];\n\nPII sorted[200010];\nint ans = 0;\n\nstruct segtree\n{\n  int tree[524288];\n  int size;\n\n  void reset(bool option = false)\n  {\n    size = 1;\n    while(size < n){\n      size <<= 1;\n    }\n\n    if(option){\n      for(int i = 0; i < size * 2 - 1; i++){\n\ttree[i] = -INF;\n      }\n    }\n  }\n\n  void update(int where, int val)\n  {\n    int now = size - 1 + where;\n    tree[now] = val;\n    while(now > 0){\n      now = (now - 1) / 2;\n      tree[now] = max(tree[now * 2 + 1], tree[now * 2 + 2]);\n    }\n  }\n\n  int top()\n  {\n    return tree[0];\n  }\n} xmin, xmax, ymin, ymax;\n\nsigned main(){\n  scanf(\"%lld%lld\", &n, &d);\n  for(int i = 0; i < n; i++){\n    scanf(\"%lld%lld%lld\", &x[i], &y[i], &b[i]);\n  }\n\n  for(int i = 0; i < n; i++){\n    sorted[i] = MP(b[i], i);\n  }\n\n  sort(sorted, sorted + n);\n\n  xmin.reset(true), xmax.reset(), ymin.reset(true), ymax.reset();\n\n  int start = 0, nowd = 0;\n  for(int i = 0; i < n; i++){\n    nowd = sorted[i].first;\n    xmin.update(i, -x[sorted[i].second]);\n    xmax.update(i, x[sorted[i].second]);\n    ymin.update(i, -y[sorted[i].second]);\n    ymax.update(i, y[sorted[i].second]);\n\n    while(start < n){\n      if(sorted[start].first < nowd - d){\n\txmin.update(start, -INF);\n\txmax.update(start, 0);\n\tymin.update(start, -INF);\n\tymax.update(start, 0);\n\tstart++;\n      }\n      else{\n\tbreak;\n      }\n    }\n\n    ans = max(ans, (xmax.top() + xmin.top()) * (ymax.top() + ymin.top()));\n  }\n\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define MAX 200000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair< ll , P > PP;\npriority_queue< P, vector<P> , greater<P> > AX,AY;\npriority_queue< P > BX,BY;\nll n,d,x,y,b;\nvector< PP > t;\n\n\nP funcA(priority_queue< P , vector< P> , greater<P> > &Q,ll b){\n  P res;\n  while(1){\n    res=Q.top();\n    if(b-res.second>d)Q.pop();\n    else break;\n  }\n  return res;\n}\n\n\nP funcB(priority_queue< P > &Q,ll b){\n  P res;\n  while(1){\n    res=Q.top();\n    if(b-res.second>d)Q.pop();\n    else break;\n  }\n  return res;\n}\n\nint main(){\n  scanf(\"%lld %lld\",&n,&d);\n  t.resize(n);\n  for(ll i=0;i<n;i++){\n    scanf(\"%lld %lld %lld\",&x,&y,&b);\n    t[i]=PP(b,P(x,y));\n  }\n  sort(t.begin(),t.end());\n  ll ans=0;\n  P ax,ay,bx,by;\n  for(int i=0;i<n;i++){\n    b=t[i].first;\n    x=t[i].second.first;\n    y=t[i].second.second;\n    AX.push(P(x,b));    \n    AY.push(P(y,b));\n    BX.push(P(x,b));\n    BY.push(P(y,b));\n    ax=funcA(AX,b);\n    ay=funcA(AY,b);\n    bx=funcB(BX,b);\n    by=funcB(BY,b);\n    ans=max(ans,(bx.first-ax.first)*(by.first-ay.first));\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n\nusing namespace std;\n\n//typedef\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n//container util\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << \"[L \" << __LINE__ << \"] \" << #x << \" = \" << (x) << \"\\n\";\n\nconst int INF = 1e9;\nconst int _N = 200000;\nconst int _M = 270000;\n\nstruct SEG{ // min\n\tint d[_M * 2];\n\tint m;\n\tvoid init(int m){\n\t\tthis->m = m;\n\t\tREP(i, m * 2 - 1)d[i] = INF;\n\t}\n\tvoid update(int i, int x){\n\t\ti += m - 1;\n\t\td[i] = x;\n\t\twhile(i>0){\n\t\t\ti = (i -1) / 2;\n\t\t\td[i] = min(d[i * 2 + 1], d[i * 2 + 2]);\n\t\t}\n\t}\n\tint query(int a, int b){\n\t\treturn _query(a, b, 0, 0, m);\n\t}\n\tprivate:int _query(int a, int b, int k, int l, int r){\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <=b) return d[k];\n\t\tint vl = _query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = _query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\nint n, d;\nint sizes[_N]; // sizes exist\n\nSEG xms, xMs, yms, yMs;\ntypedef pair<int, PII> Star;\nStar stars[_N];\nbool comp(const Star& a, const Star& b){\n\treturn a.first < b.first;\n}\nint last = -1, si = -1;\nint xm = INF, xM, ym = INF, yM;\nvoid calc(){\n\tsizes[si] = last;\n\txms.update(si, xm);\n\txMs.update(si, -xM);\n\tyms.update(si, ym);\n\tyMs.update(si, -yM);\n\txm = INF, xM = 0, ym = INF, yM = 0;\n}\n// O(N log N)\nint main() {\n\tomajinai;\n\tcin >> n >> d;\n\n\t// segment tree initial\n\tint m=1;\n\twhile(m<n)m*=2;\n\txms.init(m);\n\txMs.init(m);\n\tyms.init(m);\n\tyMs.init(m);\n\t//\n\n\tREP(i, n){\n\t\tint x, y, b;\n\t\tcin >> x >> y >> b;\n\t\tstars[i] = MP(b, MP(x, y));\n\t}\n\tsort(stars, stars + n, comp);\n\tREP(i, n){\n\t\tint b = stars[i].first, x = stars[i].second.first, y = stars[i].second.second;\n\t\tif(b!=last){\n\t\t\tif(si > -1)calc();\n\t\t\tsi++;\n\t\t\tlast = b;\n\t\t}\n\t\txm = min(xm, x);\n\t\txM = max(xM, x);\n\t\tym = min(ym, y);\n\t\tyM = max(yM, y);\n\t}\n\tcalc();\n\n\tsi++; // to use as sizes' size\n\tll ans = 0; // max = 2e6 ^ 2 = 4e12\n\tREP(i, si){\n\t\tint ed = upper_bound(sizes, sizes + si, sizes[i] + d) - sizes;\n\t\txm = xms.query(i, ed);\n\t\txM = -xMs.query(i, ed);\n\t\tym = yms.query(i, ed);\n\t\tyM = -yMs.query(i, ed);\n\t\tans = max(ans, (ll)(xM - xm) * (yM - ym));\n\t\tif(ed == si)break;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    vector<array<int, 3>> v(n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d %d %d\", &v[i][1], &v[i][2], &v[i][0]);\n    }\n    sort(v.begin(),v.end());\n    int l = 0;\n    multiset<int> Y, X;\n    ll ans = 0;\n    for (int i = 0; i < n; ++i) {\n        Y.emplace(v[i][1]);\n        X.emplace(v[i][2]);\n        while(v[i][0]-v[l][0] > d){\n            Y.erase(Y.find(v[l][1]));\n            X.erase(X.find(v[l][2]));\n            l++;\n        }\n        ans = max(ans, (ll)(*X.crbegin() - *X.cbegin())*(*Y.crbegin() - *Y.cbegin()));\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<ll, int>;\n\nint main() {\n    using star = tuple<int, ll, ll>;\n    int N, d;\n    cin >> N >> d;\n    vector<star> v(N);\n    for(int i=0; i<N; ++i) {\n        int b;\n        ll x, y;\n        cin >> x >> y >> b;\n        v[i] = make_tuple(b, x, y);\n    }\n    sort(v.begin(), v.end());\n\n    ll res = 0;\n    priority_queue<P> ma_x, ma_y;\n    priority_queue<P, vector<P>, greater<P>> mi_x, mi_y;\n    int l = 0, r = 0;\n    while(true) {\n        while(r < N && get<0>(v[r]) - get<0>(v[l]) <= d) {\n            ma_x.push(P{get<1>(v[r]), r});\n            ma_y.push(P{get<2>(v[r]), r});\n            mi_x.push(P{get<1>(v[r]), r});\n            mi_y.push(P{get<2>(v[r]), r});\n            r++;\n        }\n        while(!ma_x.empty() && ma_x.top().second < l) {\n            ma_x.pop();\n        }\n        while(!ma_y.empty() && ma_y.top().second < l) {\n            ma_y.pop();\n        }\n        while(!mi_x.empty() && mi_x.top().second < l) {\n            mi_x.pop();\n        }\n        while(!mi_y.empty() && mi_y.top().second < l) {\n            mi_y.pop();\n        }\n        res = max(res, (ma_x.top().first - mi_x.top().first) * (ma_y.top().first - mi_y.top().first));\n\n        if(r == N) {\n            break;\n        }\n        l++;\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    int n,d;\n    cin >> n >> d;\n    map<int,vector<pii>> m;\n    rep(i,0,n){\n        int x,y,b;\n        cin >> x >> y >> b;\n        m[b].push_back(make_pair(x,y));\n    }\n    \n    vector<int> v1[2],v2[2],ds; //上,右、下、左\n    for(auto it=m.begin(); it!=m.end(); ++it){\n        ds.push_back(it->first);\n        int a=0,b=0,c=inf,d=inf;\n        vector<pii> &tmp=it->second;\n        rep(i,0,tmp.size()){\n            a=max(a,tmp[i].second);\n            b=max(b,tmp[i].first);\n            c=min(c,tmp[i].second);\n            d=min(d,tmp[i].first);\n        }\n        v1[0].push_back(a);\n        v1[1].push_back(b);\n        v2[0].push_back(c);\n        v2[1].push_back(d);\n    }\n    \n    int ans=0,s=0;\n    priority_queue<int,vector<int>> q1[2],del1[2];\n    priority_queue<int,vector<int>,greater<int>> q2[2],del2[2];\n    rep(t,0,ds.size()){\n        rep(i,0,2) q1[i].push(v1[i][t]);\n        rep(i,0,2) q2[i].push(v2[i][t]);\n        while(ds[t]-ds[s]>d){\n            rep(i,0,2) del1[i].push(v1[i][s]);\n            rep(i,0,2) del2[i].push(v2[i][s]);\n            ++s;\n        }\n        rep(i,0,2){\n            while(!q1[i].empty() and !del1[i].empty() and q1[i].top()==del1[i].top()){\n                q1[i].pop();\n                del1[i].pop();\n            }\n            while(!q2[i].empty() and !del2[i].empty() and q2[i].top()==del2[i].top()){\n                q2[i].pop();\n                del2[i].pop();\n            }\n        }\n        ans=max(ans,(q1[0].top()-q2[0].top())*(q1[1].top()-q2[1].top()));\n    }\n    \n    cout << ans << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define in ,\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct Star {\n  ll x, y, d;\n};\n\nll minX[200001 * 2 - 1] = {}, maxX[200001 * 2 - 1] = {},\nminY[200001 * 2 - 1] = {}, maxY[200001 * 2 - 1] = {};\nll n, nn = 1;\n\nvoid update(ll k, ll a, ll c[]) {\n  k += nn - 1;\n  c[k] = a;\n\n  while(k > 0) {\n    k = (k - 1) / 2;\n    c[k] = min(c[k * 2 + 1], c[k * 2 + 2]);\n  }\n}\n\nll query(ll a, ll b, ll k, ll l, ll r, ll c[]) {\n  if(r <= a || b <= l) return INT_MAX;\n  if(a <= l && r <= b) return c[k];\n\n  ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2, c);\n  ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r, c);\n\n  return min(vl, vr);\n}\n\nbool asc(Star &l, Star &r) {\n  return l.d < r.d;\n}\n\nint main() {\n  ll d, ans = 0;\n  cin >> n >> d;\n  vector<Star> v(n);\n\n  while(nn < n) nn *= 2;\n\n  rep(i, 0, nn * 2 - 1) {\n    minX[i] = INT_MAX;\n    minY[i] = INT_MAX;\n    maxX[i] = INT_MAX;\n    minX[i] = INT_MAX;\n  }\n\n  rep(i, 0, n) cin >> v[i].x >> v[i].y >> v[i].d;\n\n  sort(v.begin(), v.end(), asc);\n  rep(i, 0, n) {\n    update(i, v[i].x * -1, maxX);\n    update(i, v[i].x, minX);\n    update(i, v[i].y * -1, maxY);\n    update(i, v[i].y, minY);\n  }\n\n  // rep(i, 0, n) cout << v[i].x << \" \" << v[i].y << \" \" << v[i].d << endl;;\n\n  // rep(i, 0, nn * 2 - 1) cout << minX[i] << endl;\n\n  ll ld = v[0].d, lp = 0;\n  rep(i, 1, n) {\n    if(v[i].d - ld > d) {\n      rep(j, lp + 1, i + 1) {\n        if(v[i].d - v[j].d <= d) {\n          lp = j;\n          ld = v[lp].d;\n          break;\n        }\n      }\n    }\n    ll hx = query(lp, i + 1, 0, 0, nn, maxX) * -1;\n    ll lx = query(lp, i + 1, 0, 0, nn, minX);\n    ll hy = query(lp, i + 1, 0, 0, nn, maxY) * -1;\n    ll ly = query(lp, i + 1, 0, 0, nn, minY);\n    if(lp != i) ans = max(ans, ((hx - lx) * (ll)(hy - ly)));\n    // cout << lp << \" \" << i << endl;\n    // cout << hx << \" \" << lx << \" \" << hy << \" \" << ly << endl;\n    // cout << ans << endl;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct star{int x,y,b;};\n\nbool operator<(const star& s1,const star& s2){\n    return s1.b < s2.b;\n}\n\nstar ms(const star& s){\n    star tmp;\n    tmp.b = s.b;\n    tmp.x = -s.x;\n    tmp.y = -s.y;\n    return tmp;\n}\n\nstar s[200001];\n\nint main() {\n\n    int n;\n    int d;\n\n    cin >> n >> d;\n\n    for(int i=0;i<n;i++){\n        cin >> s[i].x >> s[i].y >> s[i].b;\n    }\n\n    sort(s,s+n);\n\n    long long int ans = 0;\n\n    map<int,int> x,y;\n\n    priority_queue<star> xmax,ymax,xmin,ymin;\n\n    for(int k=0,i=0;k<n;k++){\n\n        xmax.push(s[k]);\n        ymax.push(s[k]);\n        xmin.push(ms(s[k]));\n        ymin.push(ms(s[k]));\n\n\n        x[s[k].x] += 1;\n        y[s[k].y] += 1;\n\n        while(xmax.top().b + d < s[k].b){\n            xmax.pop();\n        }\n        while(ymax.top().b + d < s[k].b){\n            ymax.pop();\n        }\n        while(-xmin.top().b + d < s[k].b){\n            xmin.pop();\n        }\n        while(-ymin.top().b + d < s[k].b){\n            ymin.pop();\n        }\n\n        long long int dx = xmax.top().x - -xmin.top().x;\n        long long int dy = ymax.top().y - -ymin.top().y;\n\n        ans = max(ans,dx*dy);\n\n    }\n\n    cout << ans << endl;\n\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nstruct SegTree{\n    static const int N=1<<18;\n    vector<int>dat;\n\n    SegTree(){\n        dat=vector<int>(N*2-1,INT_MAX);\n    }\n\n    void update(int k,int x){\n        k+=N-1;\n        dat[k]=min(dat[k],x);\n        while(k){\n            k=(k-1)/2;\n            dat[k]=min(dat[k],x);\n        }\n    }\n\n    int getMin(int a,int b,int k=0,int l=0,int r=N){\n        if(r<=a||b<=l)return INT_MAX;\n        if(r-l<=1)return dat[k];\n        int m=(l+r)/2;\n        int vl=getMin(a,b,k*2+1,l,m);\n        int vr=getMin(a,b,k*2+2,m,r);\n        return min(vl,vr);\n    }\n};\ntypedef pair<int,int>P;\ntypedef pair<int,P>PP;\n#define fi first\n#define se second\ntypedef long long ll;\n\nint N,D;\nvector<PP>Stars;\nSegTree minx,miny,maxx,maxy;\n\nint main(){\n    cin>>N>>D;\n    for(int i=0;i<N;i++){\n        int x,y,b;\n        cin>>x>>y>>b;\n        Stars.push_back(PP(b,P(x,y)));\n    }\n\n    sort(Stars.begin(),Stars.end());\n\n    for(int i=0;i<N;i++){\n        minx.update(i,Stars[i].se.fi);\n        miny.update(i,Stars[i].se.se);\n        maxx.update(i,-Stars[i].se.fi);\n        maxy.update(i,-Stars[i].se.se);\n    }\n\n    ll ans=0;\n\n    for(int i=0;i<N;i++){\n        int j=upper_bound(Stars.begin(),Stars.end(),PP(Stars[i].fi,P(INT_MAX,INT_MAX)))-Stars.begin();\n        ll w=-maxx.getMin(i,j)-minx.getMin(i,j)+1;\n        ll h=-maxy.getMin(i,j)-miny.getMin(i,j)+1;\n        ans=max(ans,h*w);\n    }\n\n    cout<<ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define Rrep(i, m, n) for(int i=(m);i<(n);i++)\n#define All(v) v.begin(),v.end()\n#define Uniq(v) v.erase(unique(All(v)),v.end())\ntypedef pair<ll, ll> Pii;\ntypedef pair<ll, Pii> Pip;\ntypedef pair<string, int> Psi;\ntypedef vector<int> Vi;\nconst int INF = (1<<30);\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\n\nconst int MAX_N = 200001;\n\nll n, d;\nll datx1[2 * MAX_N - 1];\nll datx2[2 * MAX_N - 1];\nll daty1[2 * MAX_N - 1];\nll daty2[2 * MAX_N - 1];\n\nvoid init(ll n_, ll dat[]) {\n  n = 1;\n  while( n < n_ ) n *= 2;\n  for(int i=0; i<2*n-1; i++) dat[i] = INT_MAX;\n}\n\nvoid update(ll k, ll a, ll dat[]) {\n  k += n - 1;\n  dat[k] = a;\n  while( k > 0 ) {\n    k = (k - 1) / 2;\n    dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n}\n\nint query(ll a, ll b, ll k, ll l, ll r, ll dat[]) {\n  if( r <= a || b <= l ) return INT_MAX;\n  if( a <= l && r <= b ) return dat[k];\n  else {\n    ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2, dat);\n    ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r, dat);\n    return min(vl, vr);\n  }\n}\n\nint main()\n{\n  cin >> n >> d;\n  ll N = n;\n  init(N+1, datx1);init(N+1, datx2);init(N+1, daty1);init(N+1, daty2);\n  vector<ll> bData;\n  vector<Pip> allData;\n  for(int i=0; i<N; i++) {\n    ll a, b, c;\n    cin >> a >> b >> c;\n    bData.pb( c );\n    allData.pb( Pip(c, Pii(a, b)) );\n  }\n\n  sort( All(allData) );\n\n  for(int i=0; i<N; i++) {\n    ll x = allData[i].sc.fr, y = allData[i].sc.sc;\n    update(i, x, datx1);\n    update(i, -x, datx2);\n    update(i, y, daty1);\n    update(i, -y, daty2);\n  }\n\n  ll s, t; s = t = 0;\n  ll ma = 0;\n  for(int i=1; i<N-1; i++) {\n    t = i;\n    while( 1 ) {\n      if( allData[t].fr - allData[s].fr <= d ) break;\n      s++;\n    }\n    ll x1 = query(s, t+1, 0, 0, n, datx1);\n    ll x2 = query(s, t+1, 0, 0, n, datx2);\n    ll y1 = query(s, t+1, 0, 0, n, daty1);\n    ll y2 = query(s, t+1, 0, 0, n, daty2);\n\n    ll tmp = ((-x2) - x1) * ((-y2) - y1);\n    if( tmp > ma ) {\n      ma = tmp;\n    }\n  }\n\n  cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<ll, int>;\n\nint main() {\n    using star = tuple<int, ll, ll>;\n    int N, d;\n    cin >> N >> d;\n    vector<star> v(N);\n    for(int i=0; i<N; ++i) {\n        int b;\n        ll x, y;\n        cin >> x >> y >> b;\n        v[i] = make_tuple(b, x, y);\n    }\n    sort(v.begin(), v.end());\n\n    ll res = 0;\n    priority_queue<P> ma_x, ma_y;\n    priority_queue<P, vector<P>, greater<P>> mi_x, mi_y;\n    int l = 0, r = 0;\n    while(true) {\n        while(r < N && get<0>(v[r]) - get<0>(v[l]) <= d) {\n            ma_x.push(P{get<1>(v[r]), r});\n            ma_y.push(P{get<2>(v[r]), r});\n            mi_x.push(P{get<1>(v[r]), r});\n            mi_y.push(P{get<2>(v[r]), r});\n            r++;\n        }\n        while(!ma_x.empty() && ma_x.top().second < l) {\n            ma_x.pop();\n        }\n        while(!ma_y.empty() && ma_y.top().second < l) {\n            ma_y.pop();\n        }\n        while(!mi_x.empty() && mi_x.top().second < l) {\n            mi_x.pop();\n        }\n        while(!mi_y.empty() && mi_y.top().second < l) {\n            mi_y.pop();\n        }\n        res = max(res, (ma_x.top().first - mi_x.top().first) * (ma_y.top().first - mi_y.top().first));\n\n        if(r == N) {\n            break;\n        }\n        l++;\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/std++.h>\nusing namespace std;\n/**\nvector<int>ar(3);\nfor(auto&e:ar){\n    scanf(\"%d\",&e);\n        }\nsort(ar.begin(),ar.end())\nint sum=accumulate(ar.begin(),ar.end(),0);\n**/\n//memo kyuridenamida 1237852\nint main(){\n    double pai=3.141592653589;\n    int N,d;\n    cin >> N >> d;\n    vector< array<int,3> > star;\n    for(int i = 0 ; i < N ; i++){\n        int x,y,b;\n        cin >> x >> y >> b;\n        star.push_back(array<int,3>{b,x,y});\n    }   \n    sort(star.begin(),star.end());\n    int l = 0 , r = 0;\n    multiset<int> X,Y;\n    long long ans = 0;\n    while( r != N){\n        X.insert(star[r][1]);\n        Y.insert(star[r][2]);\n        r++;\n        while( star[r-1][0] - star[l][0] > d ){\n            X.erase(X.find(star[l][1]));\n            Y.erase(Y.find(star[l][2]));\n            l++;\n        }\n        ans = max((long long)((*X.rbegin())-(*X.begin())) * ((*Y.rbegin())-(*Y.begin())),ans);\n        //cout << (*X.rbegin())-(*X.begin()) << \" \" << ((*Y.rbegin())-(*Y.begin())) << \"|\" << star[r-1][0] - star[l][0] << endl;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n\nusing namespace std;\n\n//typedef\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n//container util\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << \"[L \" << __LINE__ << \"] \" << #x << \" = \" << (x) << \"\\n\";\n\nconst int INF = 1e9;\nconst int _N = 200000;\nconst int _M = 270000;\n\nstruct SEG{ // min\n\tint d[_M * 2];\n\tint m;\n\tvoid init(int m){\n\t\tthis->m = m;\n\t\tREP(i, m * 2 - 1)d[i] = INF;\n\t}\n\tvoid update(int i, int x){\n\t\ti += m - 1;\n\t\td[i] = x;\n\t\twhile(i>0){\n\t\t\ti = (i -1) / 2;\n\t\t\td[i] = min(d[i * 2 + 1], d[i * 2 + 2]);\n\t\t}\n\t}\n\tint query(int a, int b){\n\t\treturn _query(a, b, 0, 0, m);\n\t}\n\tprivate:int _query(int a, int b, int k, int l, int r){\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <=b) return d[k];\n\t\tint vl = _query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = _query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\nint n, d;\nint sizes[_N]; // sizes exist\nmap<int, int> sizeRef; // [size] = index\n\nSEG xms, xMs, yms, yMs;\ntypedef pair<int, PII> Star;\nStar stars[_N];\nbool comp(const Star& a, const Star& b){\n\treturn a.first < b.first;\n}\nint last = -1, si = -1;\nint xm = INF, xM, ym = INF, yM;\nvoid calc(){\n\tsizes[si] = last;\n\tsizeRef[last] = si;\n\txms.update(si, xm);\n\txMs.update(si, -xM);\n\tyms.update(si, ym);\n\tyMs.update(si, -yM);\n\txm = INF, xM = 0, ym = INF, yM = 0;\n}\n// O(N log N)\nint main() {\n\tomajinai;\n\tcin >> n >> d;\n\n\t// segment tree initial\n\tint m=1;\n\twhile(m<n)m*=2;\n\txms.init(m);\n\txMs.init(m);\n\tyms.init(m);\n\tyMs.init(m);\n\t//\n\n\tREP(i, n){\n\t\tint x, y, b;\n\t\tcin >> x >> y >> b;\n\t\tstars[i] = MP(b, MP(x, y));\n\t}\n\tsort(stars, stars + n, comp);\n\tREP(i, n){\n\t\tint b = stars[i].first, x = stars[i].second.first, y = stars[i].second.second;\n\t\tif(b!=last){\n\t\t\tif(si > -1)calc();\n\t\t\tsi++;\n\t\t\tlast = b;\n\t\t}\n\t\txm = min(xm, x);\n\t\txM = max(xM, x);\n\t\tym = min(ym, y);\n\t\tyM = max(yM, y);\n\t}\n\tcalc();\n\n\tsi++; // to use as sizes' size\n\tint ans = 0;\n\tREP(i, si){\n\t\tint ed = upper_bound(sizes, sizes + si, sizes[i] + d) - sizes;\n\t\txm = xms.query(i, ed);\n\t\txM = -xMs.query(i, ed);\n\t\tym = yms.query(i, ed);\n\t\tyM = -yMs.query(i, ed);\n\t\tans = max(ans, (xM - xm) * (yM - ym));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct star {\n  int x,y,b;\n  star(int x,int y,int b) {\n    this->x = x;\n    this->y = y;\n    this->b = b;\n  }\n};\n\nstruct sort_blight {\n  bool operator()(const star& st1, const star& st2)\n  {\n      return st1.b < st2.b;\n  }\n};\n\nint compute_stars_surface(vector<star>& stars,int st,int en) {\n  int minx,miny,maxx,maxy;\n  minx = maxx = stars[st].x;\n  miny = maxy = stars[st].y;\n  for(int i=st;i<=en;i++) {\n    int x = stars[i].x;\n    int y = stars[i].y;\n    minx = min(minx,x);\n    miny = min(miny,y);\n    maxx = max(maxx,x);\n    maxy = max(maxy,y);\n  }\n  return (maxx - minx) * (maxy - miny);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int N,d;\n  vector<star> stars;\n\n  cin >> N >> d;\n  while(N--) {\n    int x,y,b;\n    cin >> x >> y >> b;\n    star st(x,y,b);\n    stars.push_back(st);\n  }\n  sort(stars.begin(),stars.end(),sort_blight());\n\n  int st = 0;\n  int en = 0;\n  int max_surface = 0;\n  while(en < stars.size()) {\n    if(stars[en].b - stars[st].b <= d) {\n      max_surface = max(max_surface,compute_stars_surface(stars,st,en));\n      en++;\n    }\n    else {\n      st++;\n    }\n  }\n  cout << max_surface << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nstruct Star\n{\n    long x, y, b;\npublic:\n    Star(long x, long y, long b): x(x), y(y), b(b) {}\n    bool operator<(const Star& s)\n    {\n        return b < s.b;\n    }\n};\n\nlong min(long a, long b)\n{\n    return a < b ? a : b;\n}\n\nlong max(long a, long b)\n{\n    return a > b ? a : b;\n}\n\nint main(int argc, const char *argv[])\n{\n    long N, d;\n    scanf(\"%ld %ld\", &N, &d);\n\n    std::vector<Star> stars;\n    for (long i = 0; i < N; i++)\n    {\n        long x, y, b;\n        scanf(\"%ld %ld %ld\", &x, &y, &b);\n        stars.push_back(Star(x, y, b));\n    }\n    std::sort(stars.begin(), stars.end());\n\n    long max_area = 0;\n\n    for (long i = 0; i < N; i++)\n    {\n        long min_x, max_x, min_y, max_y;\n        min_x = stars[i].x;\n        max_x = stars[i].x;\n        min_y = stars[i].y;\n        max_y = stars[i].y;\n\n        for (long j = i; stars[j].b - stars[i].b <= d && j < N; j++)\n        {\n            min_x = min(min_x, stars[j].x);\n            max_x = max(max_x, stars[j].x);\n            min_y = min(min_y, stars[j].y);\n            max_y = max(max_y, stars[j].y);\n        }\n\n        max_area = max((max_x - min_x) * (max_y - min_y), max_area);\n\n        for (long b0 = stars[i].b; stars[i].b == b0 && i < N; i++)\n            ;\n    }\n\n    printf(\"%ld\\n\", max_area);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define int long long int\n#define rep(a,b,c) for(int a=b;a<c;a++)\n#define repm(a,b,c) for(int a=(b-1);a>=c;a--)\n#define pb push_back\n#define str string\n#define sf(a) scanfs(\"%d\",&a)\n#define pb push_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n#define clean(used) memset(used,false,sizeof(used))\nusing namespace std;\n\nstatic const int INF = 1e18 + 9;\nstatic const int Mod = 1e9 + 7;\ninline int replac(str s){double ans=0;rep(i,0,s.length()){ans+=(s[i]-'0')*pow(10,s.length()-i-1);}return (int)ans;}\ninline string numstr(int m){str s=\"\";while(m>0){char c;int a=m/10;if(a>0)a=m%(a*10);else a=m;c=(char)('0'+a);s+=c;m/=10;}str st=\"\";for(int i=s.size()-1;i>=0;i--){st+=s[i];}return st;}\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\n\nstatic const int MAX_N = 200002;\n\nstruct Seg{\n    int n;\n    int dat[MAX_N * 2];\n    void init(int n_){\n        init(n_ , INF);\n    }\n\n    void init(int n_, int d){\n        n = 1;\n        while(n < n_)n *= 2;\n        fill(dat, dat + MAX_N * 2, d);\n    }\n};\n\nstruct Segment : Seg {\n    int Min(int s,int t){\n        return Min(s,t,0,0,n);\n    }\n    int Min(int s, int t, int k, int l, int r){\n        if(r <= s || t <= l) return INF;\n        if(s <= l && r <= t) return dat[k];\n\n        int t1 = Min(s, t, k * 2 + 1, l, (l + r)/2);\n        int t2 = Min(s, t, k * 2 + 2, (l + r)/2, r);\n        return min(t1, t2);\n    }\n    void update(int k, int x){\n        k += n - 1;\n        dat[k] = min(dat[k], x);\n        while(0 < k){\n            k = (k - 1)/2;\n            dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n};\n\nSegment x_1,x_2,y_1,y_2;\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int d,m;\n    cin >> m >> d;\n    x_1.init(m);\n    x_2.init(m);\n    y_1.init(m);\n    y_2.init(m);\n    int b_max = 0;\n    int x,y,b;\n    rep(i,0,m){\n        cin >> x >> y >> b;\n        x_1.update(b,x);\n        x_2.update(b,-x);\n        y_1.update(b,y);\n        y_2.update(b,-y);\n    }\n    int ans = 0,x_mi,x_ma,y_mi,y_ma;\n    rep(i,0,MAX_N){\n        x_mi = x_1.Min(i,i+d+1);\n        x_ma = x_2.Min(i,i+d+1);\n        y_mi = y_1.Min(i,i+d+1);\n        y_ma = y_2.Min(i,i+d+1);\n        ans = max(ans, abs(x_ma+x_mi)*abs(y_ma+y_mi));\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs front().first\nusing namespace std;\ntypedef pair<int,int> pii;\n\ntemplate<class Comp>\nvoid add(deque<pii> &q, pii nxt, Comp comp){\n  while(!q.empty() && comp(q.back(),nxt))q.pop_back();\n  q.push_back(nxt);\n}\n\nvoid del(deque<pii> &q, int p){\n  if(q.front().second == p)q.pop_front();\n}\n\nint main(){\n  int n,d;\n  scanf(\"%d%d\",&n,&d);\n  \n  vector<pii> x(n),y(n);\n  rep(i,n){\n    int X,Y,B;\n    scanf(\"%d%d%d\",&X,&Y,&B);\n    x[i] = pii(B,X); y[i] = pii(B,Y);\n  }\n  sort(all(x)); sort(all(y));\n\n  long long res = 0;\n  deque<pii> maxx, maxy, minx, miny;\n  int r = 0;\n  rep(l,n){\n    while(r<n && x[r].first-x[l].first<=d){\n      add(maxx,pii(x[r].second,r),less<pii>());\n      add(minx,pii(x[r].second,-r),greater<pii>());\n      add(maxy,pii(y[r].second,r),less<pii>());\n      add(miny,pii(y[r].second,-r),greater<pii>());\n      r++;\n    }\n\n    res = max( res, (long long)(maxx.fs - minx.fs) * (maxy.fs - miny.fs) );\n\n    del(maxx,l); del(minx,-l);\n    del(maxy,l); del(miny,-l);\n  }\n  printf(\"%lld\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int LL\ntypedef long long LL;\nconst int INF = 2002002002;\n\nstruct DATA {\n\tint minx, miny, maxx, maxy;\n};\n\nstruct STAR {\n\tint x, y, b;\n\tbool operator < (const STAR &t) const {\n\t\treturn b < t.b;\n\t}\n};\n\nint n, d;\nSTAR star[1 << 19];\n\nint N;\nDATA data[1 << 20];\n\n\nvoid init(int n)\n{\n\tfor (N = 1; N < n; N <<= 1);\n\tfill(data, data + (1 << 20), (DATA){INF, INF, -INF, -INF});\n}\n\nvoid update(int i, STAR s)\n{\n\ti += N - 1;\n\tdata[i].minx = min(data[i].minx, s.x);\n\tdata[i].miny = min(data[i].miny, s.y);\n\tdata[i].maxx = max(data[i].maxx, s.x);\n\tdata[i].maxy = max(data[i].maxy, s.y);\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tdata[i].minx = min(data[i].minx, s.x);\n\t\tdata[i].miny = min(data[i].miny, s.y);\n\t\tdata[i].maxx = max(data[i].maxx, s.x);\n\t\tdata[i].maxy = max(data[i].maxy, s.y);\n\t}\n}\n\nDATA query(int a, int b, int k, int l, int r)\n{\n\t//printf(\"%d %d %d %d %d\\n\", a, b, k, l, r);\n\tif (r <= a || b <= l) return (DATA){INF, INF, -INF, -INF};\n\tif (a <= l && r <= b) return data[k];\n\tDATA vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tDATA vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn (DATA){min(vl.minx, vr.minx), min(vl.miny, vr.miny), max(vl.maxx, vr.maxx), max(vl.maxy, vr.maxy)};\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tinit(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d %d\", &star[i].x, &star[i].y, &star[i].b);\n\t\t--star[i].x; --star[i].y;\n\t}\n\tstar[n].b = INF;\n\t\n\tsort(star, star + n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tupdate(i, star[i]);\n\t}\n\t\n\t//printf(\"%lld\\n\", (LL)INF * INF);\n\t\n\tLL res = 0;\n\tfor (int l = 0; l < n; ){\n\t\tint r = l;\n\t\twhile (star[r].b - star[l].b <= d) r++;\n\t\t\n\t\tDATA q = query(l, r, 0, 0, N);\n\t\tLL t = (LL)(q.maxx - q.minx) * (q.maxy - q.miny);\n\t\tres = max(res, t);\n\t\t\n\t\tl++;\n\t\twhile (star[l + 1].b == star[l].b) l++;\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <list>\n \nusing namespace std;\ntypedef long long ll;\n \n#define mod 1000000007\n#define INF 1000000000\n#define SIZE 100000\n\nstruct NODE{\n  int min_d;\n  int max_d;\n  int min_x;\n  int min_y;\n  int max_x;\n  int max_y;\n\n  NODE(){\n    min_d = INF;\n    max_d = 0;\n    min_x = INF;\n    max_x = 0;\n    min_y = INF;\n    max_y = 0;\n  }\n  \n  NODE(int a,int b,int c,int d,int e,int f){\n    min_d = a;\n    max_d = b;\n    min_x = c;\n    max_x = d;\n    min_y = e;\n    max_y = f;\n  }\n\n  NODE operator+ (const NODE &B) const{\n    int a = min(min_d,B.min_d);\n    int b = max(max_d,B.max_d);\n    int c = min(min_x,B.min_x);\n    int d = max(max_x,B.max_x);\n    int e = min(min_y,B.min_y);\n    int f = max(max_y,B.max_y);\n\n    return NODE(a,b,c,d,e,f);\n  }\n};\n\nNODE data[1 << 19];\nint segn2;\n\nNODE query(int a,int b,int k=0){\n  if(b<a) return NODE();\n  if(data[k].max_d < data[k].min_d) return NODE();\n  if(data[k].max_d < a || b < data[k].min_d) return NODE();\n\n  if(a<= data[k].min_d && data[k].max_d <= b) return data[k];\n\n  return query(a,b,k*2+1) + query(a,b,k*2+2);\n}\n\nint main(){\n  int n,d;\n  int x,y,b;\n  vector<pair<int,pair<int,int> > > in;\n\n  scanf(\"%d%d\",&n,&d);\n\n  segn2 = 1;\n  while(segn2<n) segn2*=2;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d%d%d\",&x,&y,&b);\n    in.push_back(make_pair(b,make_pair(x,y)));\n  }\n\n  sort(in.begin(),in.end());\n\n  for(int i=0;i<n;i++){\n    int pd = in[i].first;\n    int px = in[i].second.first;\n    int py = in[i].second.second;\n  \n    data[i+segn2-1] = NODE(pd,pd,px,px,py,py);\n  }\n\n  for(int i = segn2-2;i>=0;i--){\n    data[i] = data[i*2+1] + data[i*2+2];\n  }\n\n  return 0;\n  \n  ll ans = 0;\n  \n  for(int i=0;i<n;i++){\n    NODE a = query(in[i].first,in[i].first+d);\n    if(a.max_d < a.min_d) continue;\n    ll calc = (ll)(a.max_x - a.min_x)*(a.max_y - a.min_y);\n    ans = max(ans,calc);\n  }\n\n  cerr << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <utility>\nusing namespace std;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\ntypedef long long ll;\nint main(){\n\tll n,d;\tcin>>n>>d;\n\tvector<pair<ll,pair<ll,ll> > > in;\n\trep(i,n){\n\t\tll x,y,b;\tcin>>x>>y>>b;\n\t\tin.push_back(make_pair(b,make_pair(x,y)));\n\t}\n\tsort(in.begin(),in.end());\n\tdeque<ll> left,right,up,down;\n\tint s=0;\n\tll ans=0;\n\trep(t,n){\n\t\t//left\n\t\twhile(!left.empty()&&in[t].second.first<left.back())\tleft.pop_back();\n\t\tleft.push_back(in[t].second.first);\n\t\t//right\n\t\twhile(!right.empty()&&in[t].second.first>right.back())\tright.pop_back();\n\t\tright.push_back(in[t].second.first);\n\t\t//up\n\t\twhile(!up.empty()&&in[t].second.second>up.back())\tup.pop_back();\n\t\tup.push_back(in[t].second.second);\n\t\t//down\n\t\twhile(!down.empty()&&in[t].second.second<down.back())\tdown.pop_back();\n\t\tdown.push_back(in[t].second.second);\n\t\t//????°??????????\n\t\twhile(in[t].first-in[s].first>d){\n\t\t\t//left\n\t\t\tif(left.front()==in[s].second.first)\tleft.pop_front();\n\t\t\t//right\n\t\t\tif(right.front()==in[s].second.first)\tright.pop_front();\n\t\t\t//up\n\t\t\tif(up.front()==in[s].second.second)\tup.pop_front();\n\t\t\t//down\n\t\t\tif(down.front()==in[s].second.second)\tdown.pop_front();\n\t\t\ts++;\n\t\t}\n\t\tans=max(ans,(right.front()-left.front())*(up.front()-down.front()));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INT(name) int name; scanf(\"%d\",&name);\n#define VINT(name,n) vector<int> name(n); for(int i = 0;i < n;i++) scanf(\"%d\",&name[i]);\n#define ll long long\n#define ull unsigned long long\n\nusing namespace std;\n\nint main(int argc, char const *argv[]){\n\tint N,d;\n\tscanf(\"%d\",&N);\n\tscanf(\"%d\",&d);\n\tvector<int> X(N);\n\tvector<int> Y(N);\n\tvector<int> B(N);\n\n\tfor(int i = 0;i < N;i++){\n\t\tcin >> X[i] >> Y[i] >> B[i];\n\t}\n\n\tint range = 0;\n\tfor(int v : B)\n\t\tif(range < v) range = v;\n\n\tint max = 0;\n\n\tfor(int i = 0;i < range - d;i++){\n\t\tint x[2] = {INT_MAX,INT_MIN};\n\t\tint y[2] = {INT_MAX,INT_MIN};\n\n\t\tfor(int j = 0;j < N;j++){\n\t\t\tif(i <= B[j] && B[j] <= i + d){\n\t\t\t\tif(x[0] > X[j]) x[0] = X[j];\n\t\t\t\tif(x[1] < X[j]) x[1] = X[j];\n\t\t\t\tif(y[0] > Y[j]) y[0] = Y[j];\n\t\t\t\tif(y[1] < Y[j]) y[1] = Y[j];\n\t\t\t}\n\t\t}\n\n\t\tint temp = (x[1] - x[0]) * (y[1] - y[0]);\n\n\t\tif(temp > max) max = temp;\n\t}\n\n\tcout << max << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct STAR {\n  int x, y, d;\n};\n\nint minX[200000 * 2 - 1] = {}, maxX[200000 * 2 - 1] = {},\nminY[200000 * 2 - 1] = {}, maxY[200000 * 2 - 1] = {};\nint nn = 1, n;\n\nvoid update(int k, int a, int c[], int f) {\n  k += n - 1;\n  c[k] = a;\n\n  while(k > 0) {\n    k = (k - 1) / 2;\n    if(f) c[k] = max(c[k * 2 + 1], c[k * 2 + 2]);\n    else c[k] = min(c[k * 2 + 1], c[k * 2 + 2]);\n  }\n}\n\nint query(int a, int b, int k, int l, int r, int c[], int f) {\n  if(r <= a || b <= l) return f ? 0 : INT_MAX;\n  if(a <= l && r <= b) return c[k];\n\n  int vl = query(a, b, k * 2 + 1, l, (l + r) / 2, c, f);\n  int vr = query(a, b, k * 2 + 1, (l + r) / 2, r, c, f);\n\n  return f ? max(vl, vr) : min(vl, vr);\n}\n\nbool asc(STAR &l, STAR &r) {\n  return l.d < r.d;\n}\n\nint main() {\n  ll d, ans = 0;\n  cin >> n >> d;\n  vector<STAR> v(n);\n  while(nn < n) nn *= 2;\n\n  rep(i, 0, nn * 2 - 1) {\n    minX[i] = INT_MAX;\n    minY[i] = INT_MAX;\n  }\n\n  rep(i, 0, n) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    v[i].x = a;\n    v[i].y = b;\n    v[i].d = c;\n    update(i, a, maxX, 1);\n    update(i, a, minX, 0);\n    update(i, b, maxY, 1);\n    update(i, b, minY, 0);\n  }\n\n\n  sort(v.begin(), v.end(), asc);\n\n  int hx = v[0].x, lx = v[0].x, hy = v[0].y, ly = v[0].y, ld = v[0].d, lp = 0;\n  rep(i, 1, n) {\n    if(v[i].d - ld > d) {\n      int klp = lp;\n      rep(j, lp + 1, i) {\n        if(v[i].d - v[j].d <= d) {\n          lp = j;\n          break;\n        }\n      }\n      if(klp == lp) lp = i;\n    }\n    hx = query(lp, i, 0, 0, nn, maxX, 1);\n    lx = query(lp, i, 0, 0, nn, minX, 0);\n    hy = query(lp, i, 0, 0, nn, maxY, 1);\n    hx = query(lp, i, 0, 0, nn, minY, 0);\n    ld = v[lp].d;\n    ans = max(ans, (ll)(abs(hx - lx) * abs(hy - ly)));\n\n  }\n\n  cout << max(ans, (ll)(abs(hx - lx) * abs(hy - ly))) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct star{int x,y,b;};\n\nbool operator<(const star& s1,const star& s2){\n    return s1.b < s2.b;\n}\n\nstar s[200001];\n\nint main() {\n\n    int n;\n    int d;\n\n    cin >> n >> d;\n\n    for(int i=0;i<n;i++){\n        cin >> s[i].x >> s[i].y >> s[i].b;\n    }\n\n    sort(s,s+n);\n\n    long long int ans = 0;\n\n    map<int,int> x,y;\n\n    for(int k=0,i=0;k<n;k++){\n\n        x[s[k].x] += 1;\n        y[s[k].y] += 1;\n\n        while(s[i].b + d < s[k].b){\n            x[s[i].x]--;\n            y[s[i].y]--;\n            if(x[s[i].x] == 0){\n                x.erase(s[i].x);\n            }\n            if(y[s[i].y] == 0){\n                y.erase(s[i].y);\n            }\n            i++;\n        }\n\n        long long int dx = x.rbegin()->first - x.begin()->first;\n        long long int dy = y.rbegin()->first - y.begin()->first;\n\n        ans = max(ans,dx*dy);\n\n    }\n\n    cout << ans << endl;\n\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\n\nstruct Star{\n    int x,y,b;\n    Star(int x=0,int y=0,int b=0) :\n        x(x),y(y),b(b){}\n    bool operator<(const Star &rth) const {\n        return std::tie(b,x,y)<std::tie(rth.b,rth.x,rth.y);\n    }\n};\n\nstruct SegTree {\n    int n;\n    vector<int> min_dat;\n    vector<int> max_dat;\n    SegTree(int N) {\n        n=1;\n        while(n<N) n*=2;\n        min_dat.assign(1<<19,INF);\n        max_dat.assign(1<<19,0);\n    }\n\n    void update(int k,int a) {\n        k+=n-1;\n        min_dat[k]=a;\n        max_dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            min_dat[k]=min(min_dat[k*2+1],min_dat[k*2+2]);\n            max_dat[k]=max(max_dat[k*2+1],max_dat[k*2+2]);\n        }\n    }\n\n    int min_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return INF;\n\n        if(a<=l&&r<=b) return min_dat[k];\n        else {\n            int vl=min_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=min_query(a,b,k*2+2,(l+r)/2,r);\n            return min(vl,vr);\n        }\n    }\n\n    int max_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return 0;\n\n        if(a<=l&&r<=b) return max_dat[k];\n        else {\n            int vl=max_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=max_query(a,b,k*2+2,(l+r)/2,r);\n            return max(vl,vr);\n        }\n    }\n\n    void dump() {\n        rep(i,n) cout<<max_dat[i]<<\" \";\n        cout<<endl;\n    }\n\n};\nint N,d;\n\n\nvector<Star> stars;\n\nint find(int x) {\n    int l=0;\n    int r=stars.size()-1;\n    while(r-l>1) {\n        int mid=(l+r)/2;\n        if(stars[mid].b<x) l=mid;\n        else r=mid;\n    }\n    return r;\n}\nint main() {\n    cin>>N>>d;\n    rep(i,N) {\n        Star s;\n        cin>>s.x>>s.y>>s.b;\n        stars.pb(s);\n    }\n    SegTree segTreeX(N);\n    SegTree segTreeY(N);\n\n    sort(all(stars));\n\n    rep(i,stars.size()) {\n        // printf(\"%d %d %d %d\\n\",i,stars[i].x,stars[i].y,stars[i].b);\n        segTreeX.update(i,stars[i].x);\n        segTreeY.update(i,stars[i].y);\n    }\n\n\n    int ans=0;\n    int n=segTreeX.n;\n    rep(i,stars.size()) {\n        int pos=find(stars[i].b+d);\n        int tmp=0;\n        tmp=segTreeX.max_query(i,pos+1,0,0,n)-segTreeX.min_query(i,pos+1,0,0,n);\n        tmp*=segTreeY.max_query(i,pos+1,0,0,n)-segTreeY.min_query(i,pos+1,0,0,n);\n\n        // cout<<i<<\",\"<<stars[i].b+d<<\",\"<<pos<<\",\"<<tmp<<endl;\n        ans = max(ans,tmp);\n\n    }\n\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n/**\nvector<int>ar(3);\nfor(auto&e:ar){\n    scanf(\"%d\",&e);\n        }\nsort(ar.begin(),ar.end())\nint sum=accumulate(ar.begin(),ar.end(),0);\n**/\n//memo kyuridenamida 1237852\nint main(){\n    double pai=3.141592653589;\n    int N,d;\n    cin >> N >> d;\n    vector< array<int,3> > star;\n    for(int i = 0 ; i < N ; i++){\n        int x,y,b;\n        cin >> x >> y >> b;\n        star.push_back(array<int,3>{b,x,y});\n    }   \n    sort(star.begin(),star.end());\n    int l = 0 , r = 0;\n    multiset<int> X,Y;\n    long long ans = 0;\n    while( r != N){\n        X.insert(star[r][1]);\n        Y.insert(star[r][2]);\n        r++;\n        while( star[r-1][0] - star[l][0] > d ){\n            X.erase(X.find(star[l][1]));\n            Y.erase(Y.find(star[l][2]));\n            l++;\n        }\n        ans = max((long long)((*X.rbegin())-(*X.begin())) * ((*Y.rbegin())-(*Y.begin())),ans);\n        //cout << (*X.rbegin())-(*X.begin()) << \" \" << ((*Y.rbegin())-(*Y.begin())) << \"|\" << star[r-1][0] - star[l][0] << endl;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\n\nstruct Star{\n    int x,y,b;\n    Star(int x=0,int y=0,int b=0) :\n        x(x),y(y),b(b){}\n    bool operator<(const Star &rth) const {\n        return std::tie(b,x,y)<std::tie(rth.b,rth.x,rth.y);\n    }\n};\n\nstruct SegTree {\n    int n;\n    vector<ll> min_dat;\n    vector<ll> max_dat;\n    SegTree(int N) {\n        n=1;\n        while(n<N) n*=2;\n        min_dat.assign(1<<18,INF);\n        max_dat.assign(1<<18,0);\n    }\n\n    void update(int k,ll a) {\n        k+=n-1;\n        min_dat[k]=a;\n        max_dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            min_dat[k]=min(min_dat[k*2+1],min_dat[k*2+2]);\n            max_dat[k]=max(max_dat[k*2+1],max_dat[k*2+2]);\n        }\n    }\n\n    ll min_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return INF;\n\n        if(a<=l&&r<=b) return min_dat[k];\n        else {\n            int vl=min_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=min_query(a,b,k*2+2,(l+r)/2,r);\n            return min(vl,vr);\n        }\n    }\n\n    ll max_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return 0;\n\n        if(a<=l&&r<=b) return max_dat[k];\n        else {\n            int vl=max_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=max_query(a,b,k*2+2,(l+r)/2,r);\n            return max(vl,vr);\n        }\n    }\n\n    void dump() {\n        rep(i,n) cout<<max_dat[i]<<\" \";\n        cout<<endl;\n    }\n\n};\nint N,d;\n\n\nvector<Star> stars;\n\nint find(int x) {\n    int l=0;\n    int r=stars.size()-1;\n    while(r-l>1) {\n        int mid=(l+r)/2;\n        if(stars[mid].b<x) l=mid;\n        else r=mid;\n    }\n    return r;\n}\nint main() {\n    cin>>N>>d;\n    rep(i,N) {\n        Star s;\n        cin>>s.x>>s.y>>s.b;\n        stars.pb(s);\n    }\n    SegTree segTreeX(N);\n    SegTree segTreeY(N);\n\n    sort(all(stars));\n\n    rep(i,stars.size()) {\n        // printf(\"%d %d %d %d\\n\",i,stars[i].x,stars[i].y,stars[i].b);\n        segTreeX.update(i,stars[i].x);\n        segTreeY.update(i,stars[i].y);\n    }\n\n\n    ll ans=0;\n    int n=segTreeX.n;\n    rep(i,stars.size()) {\n        // int pos=find(stars[i].b+d);\n        Star s=stars[i];\n        s.b+=d+1;\n        int pos=lower_bound(all(stars),s)-stars.begin()-1;\n        if(pos==i) continue;\n        ll tmp=0;\n        tmp=segTreeX.max_query(i,pos+1,0,0,n)-segTreeX.min_query(i,pos+1,0,0,n);\n        tmp*=segTreeY.max_query(i,pos+1,0,0,n)-segTreeY.min_query(i,pos+1,0,0,n);\n\n        // cout<<i<<\",\"<<stars[i].b+d<<\",\"<<pos<<\",\"<<tmp<<endl;\n        ans = max(ans,tmp);\n\n    }\n\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n#define Seg_Max_N (1<<18) \n\nusing Value = pair<long long int,long long int>;\nconst Value ini = (make_pair(1e18, 0));\nstruct segtree {\n\tint N;\n\tvector<int>nums;\n\tvector<Value>dat;\n\n\tsegtree() {}\n\tsegtree(int n) :dat(2 * Seg_Max_N) ,nums(2*Seg_Max_N) {\n\t\tN = 1;\n\t\twhile (N < n) N *= 2;\n\t\tfor (int i = 0; i < 2 * N - 1; i++) {\n\t\t\tdat[i] = ini;\n\t\t}\n\t}\n\t// update k th element\n\tvoid update(int k, Value a) {\n\t\tk += N - 1; // leaf\n\t\tif (a == ini) {\n\t\t\tnums[k]--;\n\t\t\tif (!nums[k])dat[k] = a;\n\t\t}\n\t\telse {\n\t\t\tnums[k]++;\n\t\t\tdat[k] = a;\n\t\t}\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tconst Value al(dat[k * 2 + 1]);\n\t\t\tconst Value ar(dat[k * 2 + 2]);\n\t\t\tdat[k] = make_pair(min(al.first,ar.first), max(al.second,ar.second));\n\t\t}\n\t}\n\t// min [a, b)\n\tValue  query(int a, int b) { return query(a, b, 0, 0, N); }\n\tValue  query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l) return ini;\n\t\tif (a <= l and r <= b) return dat[k];\n\t\tconst int m = (l + r) / 2;\n\t\tconst Value al(query(a, b, k * 2 + 1, l, m));\n\t\tconst Value ar(query(a, b, k * 2 + 2, m, r));\n\t\treturn make_pair(min(al.first, ar.first), max(al.second, ar.second));\n\t}\n};\nstruct star{\n\tint x;\n\tint y;\n\tint light;\n};\nconst int amax = 200001;\nstruct Compress {\n\tmap<int, int>mp;\n\tmap<int, int>revmp;\n\n\tCompress(vector<int>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tint aend=unique(vs.begin(), vs.end())-vs.begin();\n\t\tfor (int i = 0; i < aend; ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\tCompress(const set<int>&vs) {\n\t\tint num = 0;\n\t\tfor (auto v : vs) {\n\t\t\tmp[v] = num;\n\t\t\trevmp[num] = v;\n\t\t\tnum++;\n\t\t}\n\t}\n};\nint main() {\n\tint N, D; cin >> N >> D;\n\tvector<int>xs, ys;\n\tsegtree segx(amax), segy(amax);\n\tvector<star>stars;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y, b; cin >> x >> y >> b;\n\t\tstars.push_back(star{ x,y,b });\n\t\txs.push_back(x);\n\t\tys.push_back(y);\n\t}\n\tCompress cpx(xs), cpy(ys);\n\tsort(stars.begin(), stars.end(), [](const star&l, const star&r) {\n\t\treturn l.light < r.light;\n\t});\n\tfor (auto &sta : stars) {\n\t\tsta.x = cpx.mp[sta.x];\n\t\tsta.y = cpy.mp[sta.y];\n\t}\n\tint l = 0;\n\tint r = 0;\n\tlong long int ans = 0;\n\t{\n\t\tsegx.update(stars[0].x, make_pair(stars[0].x, stars[0].x));\n\t\tsegy.update(stars[0].y, make_pair(stars[0].y, stars[0].y));\n\t\tauto px(segx.query(0, amax));\n\t\tauto py(segy.query(0, amax));\n\t\tans = max(ans, (px.second - px.first)*(py.second - py.first));\n\t}\n\twhile (r<N-1) {\n\t\tif (stars[r+1].light <= stars[l].light+D) {\n\t\t\tr++;\n\t\t\tsegx.update(stars[r].x, make_pair(stars[r].x, stars[r].x));\n\t\t\tsegy.update(stars[r].y, make_pair(stars[r].y, stars[r].y));\n\t\t\tauto px(segx.query(0, amax));\n\t\t\tauto py(segy.query(0, amax));\n\t\t\tlong long int disx = cpx.revmp[px.second] - cpx.revmp[px.first];\n\t\t\tlong long int disy = cpy.revmp[py.second] - cpy.revmp[py.first];\n\t\t\tans = max(ans, disx*disy);\n\t\t}\n\t\telse {\n\t\t\tif (l != r) {\n\t\t\t\tsegx.update(stars[l].x, ini);\n\t\t\t\tsegy.update(stars[l].y,ini);\n\t\t\t\tl++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr++;\n\t\t\t\tsegx.update(stars[r].x, make_pair(stars[r].x, stars[r].x));\n\t\t\t\tsegy.update(stars[r].y, make_pair(stars[r].y, stars[r].y));\n\t\t\t\tsegx.update(stars[l].x, ini);\n\t\t\t\tsegy.update(stars[l].y, ini);\n\t\t\t\tl++;\n\t\t\t\tauto px(segx.query(0, amax));\n\t\t\t\tauto py(segy.query(0, amax));\n\t\t\t\tans = max(ans, (px.second - px.first)*(py.second - py.first));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    int n,d;\n    cin >> n >> d;\n    map<int,vector<pii>> m;\n    rep(i,0,n){\n        int x,y,b;\n        cin >> x >> y >> b;\n        m[b].push_back(make_pair(x,y));\n    }\n    \n    vector<int> v1[2],v2[2],ds; //上,右、下、左\n    for(auto it=m.begin(); it!=m.end(); ++it){\n        ds.push_back(it->first);\n        int a=0,b=0,c=inf,d=inf;\n        vector<pii> &tmp=it->second;\n        rep(i,0,tmp.size()){\n            a=max(a,tmp[i].second);\n            b=max(b,tmp[i].first);\n            c=min(c,tmp[i].second);\n            d=min(d,tmp[i].first);\n        }\n        v1[0].push_back(a);\n        v1[1].push_back(b);\n        v2[0].push_back(c);\n        v2[1].push_back(d);\n    }\n    \n    int ans=0,s=0;\n    priority_queue<int,vector<int>> q1[2],del1[2];\n    priority_queue<int,vector<int>,greater<int>> q2[2],del2[2];\n    rep(t,0,ds.size()){\n        rep(i,0,2) q1[i].push(v1[i][t]);\n        rep(i,0,2) q2[i].push(v2[i][t]);\n        while(ds[t]-ds[s]>d){\n            rep(i,0,2) del1[i].push(v1[i][s]);\n            rep(i,0,2) del2[i].push(v2[i][s]);\n            ++s;\n            rep(i,0,2){\n            while(!q1[i].empty() and !del1[i].empty() and q1[i].top()==del1[i].top()){\n                q1[i].pop();\n                del1[i].pop();\n            }\n            while(!q2[i].empty() and !del2[i].empty() and q2[i].top()==del2[i].top()){\n                q2[i].pop();\n                del2[i].pop();\n            }\n        }\n        }\n        ans=max(ans,(q1[0].top()-q2[0].top())*(q1[1].top()-q2[1].top()));\n    }\n    \n    cout << ans << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll LLINF = LLONG_MAX;\n\nstruct Star {\n  int x,y;\n  ll b;\n  bool operator < ( const Star &star ) const { return b < star.b; }\n};\n\nclass RMXQ{\nprivate:\n  int limit,N;\n  vector<ll> dat;\npublic:\n  void init(int n_){\n    N = n_;\n    limit = 1;\n    while(limit<n_)limit*=2;\n    dat.clear();\n    dat.resize(2*limit,-LLINF);\n  }\n  \n  ll _build(int cur,int L,int R,const vector<ll> &buf){\n    if( !( 0 <= cur && cur < 2*limit ) ) return -LLINF;\n    if( L == R-1 ) {\n      if( L >= N ) return -LLINF;\n      dat[cur] = buf[L];\n    } else {\n      ll vl = _build(cur*2+1,L,(L+R)/2,buf);\n      ll vr = _build(cur*2+2,(L+R)/2,R,buf);\n      dat[cur] = max(vl,vr);\n    }\n    return dat[cur];\n  }\n\n  void build(const vector<ll> &buf){ _build(0,0,limit,buf); };\n\n  ll _query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return -LLINF;\n    else if(a<=l && r<=b)return dat[k];\n    ll vl = _query(a,b,k*2+1,l,(l+r)/2);\n    ll vr = _query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n\n  ll query(int a,int b){ return _query(a,b,0,0,limit); }\n};\n\nclass RMNQ{\nprivate:\n  int limit,N;\n  vector<ll> dat;\npublic:\n  void init(int n_){\n    N = n_;\n    limit = 1;\n    while(limit<n_)limit*=2;\n    dat.clear();\n    dat.resize(2*limit,LLINF);\n  }\n  \n  ll _build(int cur,int L,int R,const vector<ll> &buf){\n    if( !( 0 <= cur && cur < 2*limit ) ) return LLINF;\n    if( L == R-1 ) {\n      if( L >= N ) return LLINF;\n      dat[cur] = buf[L];\n    } else {\n      ll vl = _build(cur*2+1,L,(L+R)/2,buf);\n      ll vr = _build(cur*2+2,(L+R)/2,R,buf);\n      dat[cur] = min(vl,vr);\n    }\n    return dat[cur];\n  }\n\n  void build(const vector<ll> &buf){ _build(0,0,limit,buf); };\n\n  ll _query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return LLINF;\n    else if(a<=l && r<=b)return dat[k];\n    ll vl = _query(a,b,k*2+1,l,(l+r)/2);\n    ll vr = _query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n\n  ll query(int a,int b){ return _query(a,b,0,0,limit); }\n};\n\nint n;\nll d;\n\nRMXQ rmxq_x,rmxq_y;\nRMNQ rmnq_x,rmnq_y;\n\nll getArea(int L,int R){\n  ll maxi_x = rmxq_x.query(L,R);\n  ll mini_x = rmnq_x.query(L,R);\n  ll maxi_y = rmxq_y.query(L,R);\n  ll mini_y = rmnq_y.query(L,R);\n  return ( maxi_x - mini_x ) * ( maxi_y - mini_y );\n}\n\nvoid compute(vector<Star> &vec){\n  vector<ll> arr,xs,ys;\n  rep(i,n) {\n    arr.push_back(vec[i].b);\n    xs.push_back(vec[i].x);\n    ys.push_back(vec[i].y);\n  }\n\n\n  rmxq_x.init(n);\n  rmxq_y.init(n);\n  rmnq_x.init(n);\n  rmnq_y.init(n);\n  rmxq_x.build(xs);\n  rmxq_y.build(ys);\n  rmnq_x.build(xs);\n  rmnq_y.build(ys);\n  /*\n  rep(i,n) cout << arr[i] << \" \"; puts(\"\");\n  rep(i,n) cout << vec[i].x << \" \"; puts(\"\");\n  rep(i,n) cout << vec[i].y << \" \"; puts(\"\");\n  */\n  ll maxi = 0;\n  int L = 0, R = 0;\n\n  while( R <= n ){\n    while( R < n && arr[R] - arr[L] <= d ) ++R;\n    //cout << arr[R-1] - arr[L] << \" : \" << getArea(L,R) << endl;\n    if( arr[R-1] - arr[L] <= d ) maxi = max(maxi,getArea(L,R));\n    /*\n    while( L < R && arr[R] - arr[L] <= d ) ++L;\n    */\n    ++L;\n    if( L < R && arr[R-1] - arr[L] <= d ) maxi = max(maxi,getArea(L,R));\n    if( L == R ) ++R;\n  }\n  cout << maxi << endl;\n}\n\nint main(){\n  cin >> n >> d;\n  vector<Star> vec(n);\n  rep(i,n) cin >> vec[i].x >> vec[i].y >> vec[i].b;\n  sort(vec.begin(),vec.end());\n  compute(vec);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+17 + 10;\n\nconst int maxN = 200001;\n\nclass RMQ{\nprivate:\n\tint n;\n\tP dat[maxN * 2];\n\n\t//[a,b),[l,r) //(Max,Min)\n\tP rec(int a, int b, int k, int l, int r){\n\t\tif (b <= l || r <= a)return P(-infi, infi);\n\t\tif (a <= l && r <= b)return P(dat[k].first, dat[k].second);\n\t\telse {\n\t\t\tP vl = rec(a, b, 2 * k + 1, l, (l + r) / 2), vr = rec(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\t\treturn P(std::max(vl.first, vr.first), std::min(vl.second, vr.second));\n\t\t}\n\t}\n\npublic:\n\tvoid init(int x){\n\t\tn = 1;\n\t\twhile (n < x)n *= 2;\n\t\trep(i, 2 * n - 1)dat[i] = P(-infi, infi);\n\t}\n\n\tvoid update(int k, int a){\n\t\tk += n - 1;\n\t\tdat[k] = P(a, a);\n\t\twhile (k > 0){\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k].first = std::max(dat[2 * k + 1].first, dat[2 * k + 2].first);\n\t\t\tdat[k].second = std::min(dat[2 * k + 1].second, dat[2 * k + 2].second);\n\t\t}\n\t}\n\n\t//[a,b] //(Max,Min)\n\tP query(int a, int b){\n\t\treturn rec(a, b + 1, 0, 0, n);\n\t}\n};\n\nstruct Star{ int x, y, b; };\nStar star[200001];\nint n, d;\nRMQ up, right;\n\nbool comp(const Star &lhs, const Star &rhs){\n\treturn lhs.b < rhs.b;\n}\n\nint main(){\n\tstd::cin >> n >> d;\n\trep(i, n)std::cin >> star[i].x >> star[i].y >> star[i].b;\n\tstd::sort(star, star + n, comp);\n\tint ans = 0;\n\tint first = 0;\n\tup.init(n), right.init(n);\n\trep(i, n){\n\t\tup.update(i, star[i].y);\n\t\tright.update(i, star[i].x);\n\t\twhile (star[i].b - star[first].b > d)++first;\n\t\tP a = up.query(first, i), b = right.query(first, i);\n\t\tans = std::max(ans, (a.first - a.second) * (b.first - b.second));\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define in ,\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct Star {\n  ll x, y, d;\n};\n\nll minX[200001 * 2 - 1] = {}, maxX[200001 * 2 - 1] = {},\nminY[200001 * 2 - 1] = {}, maxY[200001 * 2 - 1] = {};\nll n, nn = 1;\n\nvoid update(ll k, ll a, ll c[]) {\n  k += nn - 1;\n  c[k] = a;\n\n  while(k > 0) {\n    k = (k - 1) / 2;\n    c[k] = min(c[k * 2 + 1], c[k * 2 + 2]);\n  }\n}\n\nll query(ll a, ll b, ll k, ll l, ll r, ll c[]) {\n  if(r <= a || b <= l) return INT_MAX;\n  if(a <= l && r <= b) return c[k];\n\n  ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2, c);\n  ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r, c);\n\n  return min(vl, vr);\n}\n\nbool asc(Star &l, Star &r) {\n  return l.d < r.d;\n}\n\nll main() {\n  ll d, ans = 0;\n  cin >> n >> d;\n  vector<Star> v(n);\n\n  while(nn < n) nn *= 2;\n\n  rep(i, 0, nn * 2 - 1) {\n    minX[i] = INT_MAX;\n    minY[i] = INT_MAX;\n    maxX[i] = INT_MAX;\n    minX[i] = INT_MAX;\n  }\n\n  rep(i, 0, n) cin >> v[i].x >> v[i].y >> v[i].d;\n\n  sort(v.begin(), v.end(), asc);\n  rep(i, 0, n) {\n    update(i, v[i].x * -1, maxX);\n    update(i, v[i].x, minX);\n    update(i, v[i].y * -1, maxY);\n    update(i, v[i].y, minY);\n  }\n\n  // rep(i, 0, n) cout << v[i].x << \" \" << v[i].y << \" \" << v[i].d << endl;;\n\n  // rep(i, 0, nn * 2 - 1) cout << minX[i] << endl;\n\n  ll ld = v[0].d, lp = 0;\n  rep(i, 1, n) {\n    if(v[i].d - ld > d) {\n      rep(j, lp + 1, i + 1) {\n        if(v[i].d - v[j].d <= d) {\n          lp = j;\n          ld = v[lp].d;\n          break;\n        }\n      }\n    }\n    ll hx = query(lp, i + 1, 0, 0, nn, maxX) * -1;\n    ll lx = query(lp, i + 1, 0, 0, nn, minX);\n    ll hy = query(lp, i + 1, 0, 0, nn, maxY) * -1;\n    ll ly = query(lp, i + 1, 0, 0, nn, minY);\n    if(lp != i) ans = max(ans, ((hx - lx) * (ll)(hy - ly)));\n    // cout << lp << \" \" << i << endl;\n    // cout << hx << \" \" << lx << \" \" << hy << \" \" << ly << endl;\n    // cout << ans << endl;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <map>\n#include <climits>\n#include <stack>\n#include <string>\n#include <random>\n#include<set>\n#include <iomanip>\n#include <climits>\n#include <memory>\n\nclass Sum_bit {\n\tstd::vector<int> _array;\npublic:\n\texplicit Sum_bit(const int size) :_array(size, 0) {};\n\tvoid increment(int position, const int value) {\n\t\twhile (position < _array.size()) {\n\t\t\t_array[position] += value;\n\t\t\tposition += ~position & (position + 1);\n\t\t}\n\t}\n\tint operator[](int index) const {\n\t\tauto result = 0;\n\t\twhile (index >= 0) {\n\t\t\tresult += _array[index];\n\t\t\tindex -= ~index & (index + 1);\n\t\t}\n\t\treturn result;\n\t}\n};\nint find_first(int from, int to, const Sum_bit &bit, const int target) {\n\twhile (from < to) {\n\t\tauto mid = (from + to) / 2;\n\t\tif (bit[mid] < target) {\n\t\t\tfrom = mid + 1;\n\t\t}\n\t\telse {\n\t\t\tto = mid;\n\t\t}\n\t}\n\treturn from;\n}\nstruct Star {\n\tint x, y, bright;\n};\nint main() {\n\tint n, d; std::cin >> n >> d;\n\tstd::vector<Star> stars(n);\n\tfor (auto &star : stars) std::cin >> star.x >> star.y >> star.bright;\n\tstd::sort(stars.begin(), stars.end(), [](const Star &left, const Star &right) {return left.bright < right.bright; });\n\tSum_bit xBit(2000001), yBit(2000001);\n\tstd::queue<Star> queue;\n\tlong long int max = 0;\n\tfor (const auto star : stars) {\n\t\twhile (!queue.empty() && queue.front().bright + d < star.bright) {\n\t\t\txBit.increment(queue.front().x, -1);\n\t\t\tyBit.increment(queue.front().y, -1);\n\t\t\tqueue.pop();\n\t\t}\n\t\tqueue.push(star);\n\t\txBit.increment(star.x, 1);\n\t\tyBit.increment(star.y, 1);\n\t\tlong long int xMin = find_first(0, 2000000, xBit, 1);\n\t\tauto xMax = find_first(0, 2000000, xBit, queue.size());\n\t\tauto yMin = find_first(0, 2000000, yBit, 1);\n\t\tauto yMax = find_first(0, 2000000, yBit, queue.size());\n\t\tif (max < (xMax - xMin) * (yMax - yMin)) {\n\t\t\tmax = (xMax - xMin) * (yMax - yMin);\n\t\t}\n\t}\n\tstd::cout << max << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <functional>\n\nclass MinSegment {\n\tstd::vector<std::vector<int>> mArray;\npublic:\n\tMinSegment(const std::vector<int> &init) :mArray(std::ceil(std::log2(init.size()) + 1), std::vector<int>()) {\n\t\tmArray[0] = init;\n\t\tauto size = init.size();\n\t\tfor (auto i = 1; i < mArray.size(); ++i) {\n\t\t\tsize = (size + 1) >> 1;\n\t\t\tmArray[i] = std::vector<int>(size, INT_MAX);\n\t\t\tfor (auto j = 0; j < mArray[i - 1].size(); ++j) {\n\t\t\t\tif (mArray[i][j >> 1] > mArray[i - 1][j]) mArray[i][j >> 1] = mArray[i - 1][j];\n\t\t\t}\n\t\t}\n\t}\n\tlong long int min(int from, int to) const {\n\t\tint res = INT_MAX;\n\t\tfor (auto i = 0; i < mArray.size() && from <= to; ++i) {\n\t\t\tif (from % 2 == 1 && res > mArray[i][from]) {\n\t\t\t\tres = mArray[i][from];\n\t\t\t}\n\t\t\tif (to % 2 == 0 && res > mArray[i][to]) {\n\t\t\t\tres = mArray[i][to];\n\t\t\t}\n\t\t\tfrom = (from + 1) >> 1;\n\t\t\tto = (to - 1) >> 1;\n\t\t}\n\t\treturn res;\n\t}\n};\nclass MaxSegment {\n\tstd::vector<std::vector<int>> mArray;\npublic:\n\tMaxSegment(const std::vector<int> &init) :mArray(std::ceil(std::log2(init.size()) + 1), std::vector<int>()) {\n\t\tmArray[0] = init;\n\t\tauto size = init.size();\n\t\tfor (auto i = 1; i < mArray.size(); ++i) {\n\t\t\tsize = (size + 1) >> 1;\n\t\t\tmArray[i] = std::vector<int>(size, INT_MIN);\n\t\t\tfor (auto j = 0; j < mArray[i - 1].size(); ++j) {\n\t\t\t\tif (mArray[i][j >> 1] < mArray[i - 1][j]) mArray[i][j >> 1] = mArray[i - 1][j];\n\t\t\t}\n\t\t}\n\t}\n\tlong long int max(int from, int to) const {\n\t\tint res = INT_MIN;\n\t\tfor (auto i = 0; i < mArray.size() && from <= to; ++i) {\n\t\t\tif (from % 2 == 1 && res < mArray[i][from]) {\n\t\t\t\tres = mArray[i][from];\n\t\t\t}\n\t\t\tif (to % 2 == 0 && res < mArray[i][to]) {\n\t\t\t\tres = mArray[i][to];\n\t\t\t}\n\t\t\tfrom = (from + 1) >> 1;\n\t\t\tto = (to - 1) >> 1;\n\t\t}\n\t\treturn res;\n\t}\n};\nstruct Star {\n\tint x, y, brightness;\n};\nint main() {\n\tint n, d;\n\tstd::cin >> n >> d;\n\tstd::vector<Star> stars(n);\n\tfor (auto &star : stars) std::cin >> star.x >> star.y >> star.brightness;\n\tstd::sort(stars.begin(), stars.end(), [](const Star a, const Star b) {return a.brightness < b.brightness; });\n\tstd::vector<int> b(n);\n\tstd::vector<int> x(n);\n\tstd::vector<int> y(n);\n\tfor (auto i = 0; i < n; ++i) {\n\t\tb[i] = stars[i].brightness;\n\t\tx[i] = stars[i].x;\n\t\ty[i] = stars[i].y;\n\t}\n\tMaxSegment maxX(x);\n\tMinSegment minX(x);\n\tMaxSegment maxY(y);\n\tMinSegment minY(y);\n\tlong long int max = 0;\n\tfor (auto left = 0; left < n; ++left) {\n\t\tauto right = std::upper_bound(b.begin() + left, b.end(), b[left] + d) - 1 - b.begin();\n\t\tauto temp = (maxX.max(left, right) - minX.min(left, right)) * (maxY.max(left, right) - minY.min(left, right));\n\t\tif (max < temp) max = temp;\n\t}\n\tstd::cout << max << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n\nusing namespace std;\n\n//typedef\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n//container util\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << \"[L \" << __LINE__ << \"] \" << #x << \" = \" << (x) << \"\\n\";\n\nconst int INF = 1e9;\nconst int _N = 200000;\nconst int _M = 270000;\n\nstruct SEG{ // min\n\tint d[_M * 2];\n\tint m;\n\tvoid init(int m){\n\t\tthis->m = m;\n\t\tREP(i, m * 2 - 1)d[i] = INF;\n\t}\n\tvoid update(int i, int x){\n\t\ti += m - 1;\n\t\td[i] = x;\n\t\twhile(i>0){\n\t\t\ti = (i -1) / 2;\n\t\t\td[i] = min(d[i * 2 + 1], d[i * 2 + 2]);\n\t\t}\n\t}\n\tint query(int a, int b){\n\t\treturn _query(a, b, 0, 0, m);\n\t}\n\tprivate:int _query(int a, int b, int k, int l, int r){\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <=b) return d[k];\n\t\tint vl = _query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = _query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\nint n, d;\nint sizes[_N]; // sizes exist\n//map<int, int> sizeRef; // [size] = index\n\nSEG xms, xMs, yms, yMs;\ntypedef pair<int, PII> Star;\nStar stars[_N];\nbool comp(const Star& a, const Star& b){\n\treturn a.first < b.first;\n}\nint last = -1, si = -1;\nint xm = INF, xM, ym = INF, yM;\nvoid calc(){\n\tsizes[si] = last;\n//\tsizeRef[last] = si;\n\txms.update(si, xm);\n\txMs.update(si, -xM);\n\tyms.update(si, ym);\n\tyMs.update(si, -yM);\n\txm = INF, xM = 0, ym = INF, yM = 0;\n}\n// O(N log N)\nint main() {\n\tomajinai;\n\tcin >> n >> d;\n\n\t// segment tree initial\n\tint m=1;\n\twhile(m<n)m*=2;\n\txms.init(m);\n\txMs.init(m);\n\tyms.init(m);\n\tyMs.init(m);\n\t//\n\n\tREP(i, n){\n\t\tint x, y, b;\n\t\tcin >> x >> y >> b;\n\t\tstars[i] = MP(b, MP(x, y));\n\t}\n\tsort(stars, stars + n, comp);\n\tREP(i, n){\n\t\tint b = stars[i].first, x = stars[i].second.first, y = stars[i].second.second;\n\t\tif(b!=last){\n\t\t\tif(si > -1)calc();\n\t\t\tsi++;\n\t\t\tlast = b;\n\t\t}\n\t\txm = min(xm, x);\n\t\txM = max(xM, x);\n\t\tym = min(ym, y);\n\t\tyM = max(yM, y);\n\t}\n\tcalc();\n\n\tsi++; // to use as sizes' size\n\tll ans = 0; // max = 2e6 ^ 2 = 4e12\n\tREP(i, si){\n\t\tint ed = upper_bound(sizes, sizes + si, sizes[i] + d) - sizes;\n\t\txm = xms.query(i, ed);\n\t\txM = -xMs.query(i, ed);\n\t\tym = yms.query(i, ed);\n\t\tyM = -yMs.query(i, ed);\n\t\tans = max(ans, (ll)(xM - xm) * (yM - ym));\n\t\tif(ed == si)break;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nstruct RangeMinimumQuery {\n\tvector<T> value;\n\tint size;\n\t\n\tRangeMinimumQuery(int N, T x = numeric_limits<T>::max()){\n\t\tfor (size = 1; size < N; size *= 2){}\n\t\tvalue.assign(size * 2 - 1, x);\n\t}\n\t\n\tvoid update(int k, int x){\n\t\tk += size - 1;\n\t\tvalue[k] = x;\n\t\twhile (k > 0){\n\t\t\tk = (k - 1) / 2;\n\t\t\tvalue[k] = min(value[k * 2 + 1], value[k * 2 + 2]);\n\t\t}\n\t}\n\t\n\tT _getMin(int l, int r, int k, int a, int b){\n\t\tif (b <= l || r <= a) return numeric_limits<T>::max();\n\t\tif (l <= a && b <= r) return value[k];\n\t\tint m = (a + b) / 2;\n\t\tT vl = _getMin(l, r, k * 2 + 1, a, m);\n\t\tT vr = _getMin(l, r, k * 2 + 2, m, b);\n\t\treturn min(vl, vr);\n\t}\n\t\n\tT getMin(int l, int r){\n\t\treturn _getMin(l, r, 0, 0, size);\n\t}\n};\n\ntypedef long long lint;\ntypedef tuple<int, int, int> Star;\nconst int INF = 1 << 28;\n\nint n, d;\nStar star[200001];\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tfor (int i = 0; i < n; i++){\n\t\tint x, y, b;\n\t\tscanf(\"%d %d %d\", &x, &y, &b);\n\t\tstar[i] = Star(b, x, y);\n\t}\n\tstar[n] = Star(INT_MAX, 0, 0);\n\t\n\tsort(star, star + n);\n\t\n\tRangeMinimumQuery<int> seglx(n), segly(n);\n\tRangeMinimumQuery<int> segrx(n, -INF), segry(n, -INF);\n\tfor (int i = 0; i < n; i++){\n\t\tseglx.update(i, get<1>(star[i]));\n\t\tsegly.update(i, get<2>(star[i]));\n\t\tsegrx.update(i, -get<1>(star[i]));\n\t\tsegry.update(i, -get<2>(star[i]));\n\t}\n\t\n\tlint res = 0;\n\tfor (int left = 0, right = 0; left < n; left++){\n\t\twhile (true){\n\t\t\tint ld = get<0>(star[left]);\n\t\t\tint rd = get<0>(star[right]);\n\t\t\tif (rd - ld > d) break;\n\t\t\tright++;\n\t\t}\n\t\t\n\t\tint width = -segrx.getMin(left, right) - seglx.getMin(left, right);\n\t\tint height = -segry.getMin(left, right) - segly.getMin(left, right);\n\t\tlint area = (lint)width * height;\n\t\tres = max(res, area);\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nclass Star\n{\npublic:\n\tlong long int x, y;\n\tint b;\n\tint boundary;\n};\nbool operator > (Star s1, Star s2)\n{\n\treturn s1.b > s2.b;\n}\nbool operator < (Star s1, Star s2)\n{\n\treturn s1.b < s2.b;\n}\n\nint n, d;\nStar star[200000];\nlong long int maxX = 0, maxY = 0, minX = 0, minY = 0;\nlong long int ans = 0;\n\nvoid calcBoundary()\n{\n\tint boundary = n - 1;\n\tstar[n - 1].boundary = boundary;\n\tfor (int i = n - 2; i >= 0; i--)\n\t{\n\t\tif (star[i + 1].b - star[i].b >= 2) boundary = i;\n\t\tstar[i].boundary = boundary;\n\t}\n\t\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tStar s;\n\t\ts.b = star[i].b + d;\n\t\tboundary = upper_bound(star + i, star + n, s) - star - 1;\n\t\tstar[i].boundary = min(star[i].boundary, boundary);\n\t}\n}\n\nvoid solve()\n{\n\tint boundary = -1;\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tif (star[i].boundary != boundary)\n\t\t{\n\t\t\tboundary = star[i].boundary;\n\t\t\tans = max((minX - maxX)*(minY - maxY), ans);\n\t\t\tmaxX = star[i].x;\n\t\t\tminX = star[i].x;\n\t\t\tmaxY = star[i].y;\n\t\t\tminY = star[i].y;\n\n\t\t\tfor (int j = i + 1; j <= star[i].boundary; j++)\n\t\t\t{\n\t\t\t\tmaxX = max(star[j].x, maxX);\n\t\t\t\tmaxY = max(star[j].y, maxY);\n\t\t\t\tminX = min(star[j].x, minX);\n\t\t\t\tminY = min(star[j].y, minY);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmaxX = max(star[i].x, maxX);\n\t\t\tmaxY = max(star[i].y, maxY);\n\t\t\tminX = min(star[i].x, minX);\n\t\t\tminY = min(star[i].y, minY);\n\t\t}\n\t}\n\n\tans = max((maxX - minX)*(maxY - minY), ans);\n}\n\nint main()\n{\n\tcin >> n >> d;\n\tfor (int i = 0; i < n; i++) cin >> star[i].x >> star[i].y >> star[i].b;\n\t\n\tsort(star, star + n);\n\tcalcBoundary();\n\tsolve();\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct Star {\n  int x, y, d;\n};\n\nint minX[200000 * 2 - 1] = {}, maxX[200000 * 2 - 1] = {},\nminY[200000 * 2 - 1] = {}, maxY[200000 * 2 - 1] = {};\nint n, nn = 1;\n\nvoid update(int k, int a, int c[], int f) {\n  k += n - 1;\n  c[k] = a;\n\n  while(k > 0) {\n    k = (k - 1) / 2;\n    if(f) c[k] = max(c[k * 2 + 1], c[k * 2 + 2]);\n    else c[k] = min(c[k * 2 + 1], c[k * 2 + 2]);\n  }\n}\n\nint query(int a, int b, int k, int l, int r, int c[], int f) {\n  if(r <= a || b <= l) return f ? 0 : INT_MAX;\n  if(a <= l && r <= b) return c[k];\n\n  int vl = query(a, b, k * 2 + 1, l, (l + r) / 2, c, f);\n  int vr = query(a, b, k * 2 + 1, (l + r) / 2, r, c, f);\n\n  return f ? max(vl, vr) : min(vl, vr);\n}\n\nbool asc(Star &l, Star &r) {\n  return l.d < r.d;\n}\n\nint main() {\n  ll d, ans = 0;\n  cin >> n >> d;\n  vector<Star> v(n);\n\n  while(nn < n) nn *= 2;\n\n  rep(i, 0, nn * 2 - 1) {\n    minX[i] = INT_MAX;\n    minY[i] = INT_MAX;\n  }\n\n  rep(i, 0, n) cin >> v[i].x >> v[i].y >> v[i].d;\n\n  sort(v.begin(), v.end(), asc);\n\n  rep(i, 0, n) {\n    update(i, v[i].x, maxX, 1);\n    update(i, v[i].x, minX, 0);\n    update(i, v[i].y, maxY, 1);\n    update(i, v[i].y, minY, 0);\n  }\n\n  int hx = v[0].x, lx = v[0].x, hy = v[0].y, ly = v[0].y, ld = v[0].d, lp = 0;\n  rep(i, 1, n) {\n    if(v[i].d - ld > d) {\n      rep(j, lp + 1, i + 1) {\n        if(v[i].d - v[j].d <= d) {\n          lp = j;\n          break;\n        }\n      }\n    }\n    hx = query(lp, i, 0, 0, n, maxX, 1);\n    lx = query(lp, i, 0, 0, n, minX, 0);\n    hy = query(lp, i, 0, 0, n, maxY, 1);\n    ly = query(lp, i, 0, 0, n, minY, 0);\n    ld = v[lp].d;\n    ans = max(ans, (ll)((hx - lx) * (hy - ly)));\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for(int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define Cout(obj) cout << obj << endl\n#define Size(obj) (obj).size()\n#define fcout cout << fixed << setprecision(10)\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, d;\n    cin >> N >> d;\n\n    vector<tuple<int, int, int>> vec(N);\n\n    vector<int>  minx(N), miny(N), maxx(N), maxy(N);\n\n    REP(i, N)\n    {\n        int x, y, b;\n        cin >> x >> y >> b;\n        vec[i] = make_tuple(b, x, y);\n    }\n\n    sort(ALL(vec));\n\n    ll ans = -1;\n\n    REP(i, N)\n    {\n        int start = get<0>(vec[i]);\n\n        auto itr = upper_bound(vec.begin(), vec.end(), make_tuple(d + start, iINF, iINF));\n\n        if(itr == vec.begin()) continue;\n\n        //cout << itr - vec.begin() << endl;\n\n        int maxx = 0, maxy = 0, minx = iINF, miny = iINF;\n\n        FOR(j, i, itr - vec.begin())\n        {\n            int x = get<1>(vec[j]), y = get<2>(vec[j]);\n\n            maxx = max(maxx, x);\n            maxy = max(maxy, y);\n            minx = min(minx, x);\n            miny = min(miny, y);\n\n        }\n\n\n        ans = max(ans, (ll)((maxx - minx) * (maxy - miny)));\n    }\n\n    Cout(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int LL\ntypedef long long LL;\nconst int INF = 2002002002;\n\nstruct DATA {\n\tint minx, miny, maxx, maxy;\n};\n\nstruct STAR {\n\tint x, y, b;\n\tbool operator < (const STAR &t) const {\n\t\treturn b < t.b;\n\t}\n};\n\nint n, d;\nSTAR star[1 << 19];\n\nint N;\nDATA data[1 << 20];\n\n\nvoid init(int n)\n{\n\tfor (N = 1; N < n; N <<= 1);\n\tfill(data, data + (1 << 20), (DATA){INF, INF, -INF, -INF});\n}\n\nvoid update(int i, STAR s)\n{\n\ti += N - 1;\n\tdata[i].minx = min(data[i].minx, s.x);\n\tdata[i].miny = min(data[i].miny, s.y);\n\tdata[i].maxx = max(data[i].maxx, s.x);\n\tdata[i].maxy = max(data[i].maxy, s.y);\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tdata[i].minx = min(data[i].minx, s.x);\n\t\tdata[i].miny = min(data[i].miny, s.y);\n\t\tdata[i].maxx = max(data[i].maxx, s.x);\n\t\tdata[i].maxy = max(data[i].maxy, s.y);\n\t}\n}\n\nDATA query(int a, int b, int k, int l, int r)\n{\n\t//printf(\"%d %d %d %d %d\\n\", a, b, k, l, r);\n\tif (r <= a || b <= l) return (DATA){INF, INF, -INF, -INF};\n\tif (a <= l && r <= b) return data[k];\n\tDATA vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tDATA vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn (DATA){min(vl.minx, vr.minx), min(vl.miny, vr.miny), max(vl.maxx, vr.maxx), max(vl.maxy, vr.maxy)};\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tinit(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d %d\", &star[i].x, &star[i].y, &star[i].b);\n\t\t--star[i].x; --star[i].y;\n\t}\n\tfor (int i = n; i < 1 << 19; i++){\n\t\tstar[i].b = INF;\n\t}\n\t\n\tsort(star, star + n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tupdate(i, star[i]);\n\t}\n\t\n\t//printf(\"%lld\\n\", (LL)INF * INF);\n\t\n\tLL res = 0;\n\tfor (int l = 0; l < n; ){\n\t\tint r = l;\n\t\twhile (star[r].b - star[l].b <= d) r++;\n\t\t\n\t\tDATA q = query(l, r, 0, 0, N);\n\t\tLL t = (LL)(q.maxx - q.minx) * (q.maxy - q.miny);\n\t\tres = max(res, t);\n\t\t\n\t\tl++;\n\t\twhile (star[l + 1].b == star[l].b) l++;\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for (int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define Cout(obj) cout << obj << endl\n#define Size(obj) (obj).size()\n#define fcout cout << fixed << setprecision(10)\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\ntemplate <typename T>\nstruct SegTreeMin\n{\n  private:\n    ll N = 1;\n    vector<T> node;\n\n  public:\n    SegTreeMin(vector<T> vec)\n    {\n        ll size = vec.size();\n\n        while (N < size)\n        {\n            N *= 2;\n        }\n\n        node.resize(2 * N - 1, iINF);\n\n        REP(i, size)\n        {\n            node[i + N - 1] = vec[i];\n        }\n\n        for (int i = N - 2; 0 <= i; i--)\n        {\n            node[i] = min(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    void update(int i, T value)\n    {\n        i += (N - 1);\n\n        node[i] = value;\n\n        while (i > 0)\n        {\n            i = (i - 1) / 2;\n\n            node[i] = min(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    T getMin(int a, int b, int i = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = N;\n        }\n\n        if (r <= a || b <= l)\n        {\n            return iINF;\n        }\n\n        if (a <= l && r <= b)\n        {\n            return node[i];\n        }\n\n        T vl = getMin(a, b, 2 * i + 1, l, (l + r) / 2);\n\n        T vr = getMin(a, b, 2 * i + 2, (l + r) / 2, r);\n\n        return min(vl, vr);\n    }\n};\n\ntemplate <typename T>\nstruct SegTreeMax\n{\n  private:\n    ll N = 1;\n    vector<T> node;\n\n  public:\n    SegTreeMax(vector<T> vec)\n    {\n        ll size = vec.size();\n\n        while (N < size)\n        {\n            N *= 2;\n        }\n\n        node.resize(2 * N - 1, -iINF);\n\n        REP(i, size)\n        {\n            node[i + N - 1] = vec[i];\n        }\n\n        for (int i = N - 2; 0 <= i; i--)\n        {\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    void update(int i, T value)\n    {\n        i += (N - 1);\n\n        node[i] = value;\n\n        while (i > 0)\n        {\n            i = (i - 1) / 2;\n\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    T getMax(int a, int b, int i = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = N;\n        }\n\n        if (r <= a || b <= l)\n        {\n            return -iINF;\n        }\n\n        if (a <= l && r <= b)\n        {\n            return node[i];\n        }\n\n        T vl = getMax(a, b, 2 * i + 1, l, (l + r) / 2);\n\n        T vr = getMax(a, b, 2 * i + 2, (l + r) / 2, r);\n\n        return max(vl, vr);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, d;\n    cin >> N >> d;\n\n    vector<tuple<ll, ll, ll>> vec(N);\n\n    SegTreeMax<ll> xMax(vector<ll>(N, -iINF)), yMax(vector<ll>(N, -iINF));\n    SegTreeMin<ll> xMin(vector<ll>(N, iINF)), yMin(vector<ll>(N, iINF));\n\n    ll ans = 0;\n\n    REP(i, N)\n    {\n        ll x, y, d;\n        cin >> x >> y >> d;\n\n        vec[i] = make_tuple(d, x, y);\n    }\n\n    sort(ALL(vec));\n\n    REP(i, N)\n    {\n        ll x, y, d;\n        tie(d, x, y) = vec[i];\n\n        xMax.update(i, x);\n        xMin.update(i, x);\n        yMax.update(i, y);\n        yMin.update(i, y);\n    }\n\n    REP(i, N)\n    {\n        ll start = get<0>(vec[i]);\n\n        auto itr = upper_bound(vec.begin(), vec.end(), make_tuple(d + start, iINF, iINF));\n\n        if (itr == vec.begin())\n            continue;\n        if (itr == vec.end())\n            continue;\n\n        ll now = itr - vec.begin();\n\n        ll x = xMax.getMax(i, now), y = yMax.getMax(i, now);\n        ll _x = xMin.getMin(i, now), _y = yMin.getMin(i, now);\n\n        ans = max(ans, (x - _x) * (y - _y));\n    }\n\n    Cout(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1<<29)\ntypedef long long ll;\n\nstruct MinSegtree\n{\n  int n;\n  int dat[1<<18];\n  MinSegtree(int _n)\n  {\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*21;i++)\n      dat[i] = INF;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n\n  int query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return INF;\n\n    if(a <= l && r <= b) return dat[k];\n    else{\n      int vl = query(a, b, k*2+1, l, (l + r) / 2);\n      int vr = query(a, b, k*2+2, (l + r) / 2, r);\n      return min(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nstruct MaxSegtree\n{\n  int n;\n  int dat[1<<18];\n  MaxSegtree(int _n){\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*2-1;i++)\n      dat[i] = -1;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n  \n  int query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return -1;\n    \n    if(a <= l && r <=b ) return dat[k];\n    else{\n      int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n      int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n      return max(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nint main()\n{\n  int n, d;\n  scanf(\"%d%d\", &n, &d);\n  MinSegtree minx(n);\n  MinSegtree miny(n);\n  MaxSegtree maxx(n);\n  MaxSegtree maxy(n);\n  \n  vector<pair<ll, pair<int, int> > >s(n);\n  vector<ll>br(n);\n  for(int i=0;i<n;i++){\n    int x, y; ll b;\n    scanf(\"%d%d%lld\", &x, &y, &b);\n    s[i] = make_pair(b, make_pair(x, y));\n    br[i] = b;\n  }\n  sort(s.begin(), s.end());\n  sort(br.begin(), br.end());\n\n\n  for(int i=0;i<n;i++){\n    minx.update(i, s[i].second.first);\n    maxx.update(i, s[i].second.first);\n    miny.update(i, s[i].second.second);\n    maxy.update(i, s[i].second.second);\n  }\n\n  br.push_back(INF);\n  ll res = 0;\n  for(int i=0;i<n;i++){\n    int pos = (int)(upper_bound(br.begin(), br.end(), br[i] + d) - br.begin());\n    int w = maxx.query(i, pos, 0, 0, maxx.size()) - minx.query(i, pos, 0, 0, minx.size());\n    int h = maxy.query(i, pos, 0, 0, maxy.size()) - miny.query(i, pos, 0, 0, miny.size());\n    res = max(res, (ll)w * (ll)h);\n  }\n\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define INF 1e+17\n#define int long long\nusing namespace std;\n\nint seg,segMin[2][600000],segMax[2][600000];\n\nint getMin(int a,int b,int k,int l,int r,int num){\n\tif(b <= l || r <= a) return INF;\n\tif(a <= l && r <= b) return segMin[num][k];\n\treturn min(getMin(a,b,k * 2 + 1,l,(l + r) / 2,num),getMin(a,b,k * 2 + 2,(l + r) / 2,r,num));\n}\n\nint getMax(int a,int b,int k,int l,int r,int num){\n\tif(b <= l || r <= a) return 0;\n\tif(a <= l && r <= b) return segMax[num][k];\n\treturn max(getMax(a,b,k * 2 + 1,l,(l + r) / 2,num),getMax(a,b,k * 2 + 2,(l + r) / 2,r,num));\n}\n\nvoid updMin(int i,int x,int num){\n\ti += seg - 1;\n\tsegMin[num][i] = min(x,segMin[num][i]);\n\twhile(i){\n\t\ti = (i - 1) / 2;\n\t\tsegMin[num][i] = min(segMin[num][i * 2 + 1],segMin[num][i * 2 + 2]);\n\t}\n}\n\nvoid updMax(int i,int x,int num){\n\ti += seg - 1;\n\tsegMax[num][i] = max(x,segMax[num][i]);\n\twhile(i){\n\t\ti = (i - 1) / 2;\n\t\tsegMax[num][i] = max(segMax[num][i * 2 + 1],segMax[num][i * 2 + 2]);\n\t}\n}\n\nsigned main(){\n\tint n,d,x[200000],y[200000],b[200000];\n\tcin >> n >> d;\n\tseg = 1;\n\twhile(seg < n) seg *= 2;\n\tfor(int i = 0;i < seg * 2 - 1;i++){\n\t\tsegMin[0][i] = INF;\n\t\tsegMin[1][i];\n\t}\n\tvector<int> vec;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x[i] >> y[i] >> b[i];\n\t\tvec.push_back(b[i]);\n\t}\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end());\n\tfor(int i = 0;i < n;i++){\n\t\tint pos = lower_bound(vec.begin(),vec.end(),b[i]) - vec.begin();\n\t\tupdMin(pos,x[i],0);\n\t\tupdMax(pos,x[i],0);\n\t\tupdMin(pos,y[i],1);\n\t\tupdMax(pos,y[i],1);\n\t}\n\tint ma = 0;\n\tfor(int i = 0;i < n;i++){\n\t\tint low = lower_bound(vec.begin(),vec.end(),b[i]) - vec.begin();\n\t\tint up = upper_bound(vec.begin(),vec.end(),b[i] + d) - vec.begin() - 1;\n\t\tma = max(ma,(getMax(low,up + 1,0,0,seg,0) - getMin(low,up + 1,0,0,seg,0)) * (getMax(low,up,0,0,seg,1) - getMin(low,up,0,0,seg,1)));\n\t}\n\tcout << ma << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1<<29)\n#define MAX_N 200000\ntypedef long long ll;\n\nstruct MinSegtree\n{\n  int n;\n  int dat[2*MAX_N-1];\n  MinSegtree(int _n)\n  {\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*21;i++)\n      dat[i] = INF;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n\n  int query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return INF;\n\n    if(a <= l && r <= b) return dat[k];\n    else{\n      int vl = query(a, b, k*2+1, l, (l + r) / 2);\n      int vr = query(a, b, k*2+2, (l + r) / 2, r);\n      return min(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nstruct MaxSegtree\n{\n  int n;\n  int dat[2*MAX_N-1];\n  MaxSegtree(int _n){\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*2-1;i++)\n      dat[i] = -1;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n  \n  int query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return -1;\n    \n    if(a <= l && r <=b ) return dat[k];\n    else{\n      int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n      int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n      return max(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nint main()\n{\n  int n, d;\n  scanf(\"%d%d\", &n, &d);\n  MinSegtree minx(n);\n  MinSegtree miny(n);\n  MaxSegtree maxx(n);\n  MaxSegtree maxy(n);\n  \n  vector<pair<ll, pair<int, int> > >s(n);\n  vector<ll>br(n);\n  for(int i=0;i<n;i++){\n    int x, y; ll b;\n    scanf(\"%d%d%lld\", &x, &y, &b);\n    s[i] = make_pair(b, make_pair(x, y));\n    br[i] = b;\n  }\n  sort(s.begin(), s.end());\n  sort(br.begin(), br.end());\n\n\n  for(int i=0;i<n;i++){\n    minx.update(i, s[i].second.first);\n    maxx.update(i, s[i].second.first);\n    miny.update(i, s[i].second.second);\n    maxy.update(i, s[i].second.second);\n  }\n\n  br.push_back(INF);\n  ll res = 0;\n  for(int i=0;i<n;i++){\n    int pos = (int)(upper_bound(br.begin(), br.end(), br[i] + d) - br.begin());\n    int w = maxx.query(i, pos, 0, 0, maxx.size()) - minx.query(i, pos, 0, 0, minx.size());\n    int h = maxy.query(i, pos, 0, 0, maxy.size()) - miny.query(i, pos, 0, 0, miny.size());\n    res = max(res, (ll)w * (ll)h);\n  }\n\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//{{{ seg.hpp\n#ifndef INCLUDE_SEG_HPP\n#define INCLUDE_SEG_HPP\n#include <functional>\n#include <algorithm>\n#include <iterator>\nnamespace orislib {\nnamespace ds {\nconstexpr int uprt(int k, int i=1){\n  return i < k ? uprt(k, i + i) : i;\n}\n//{{{ SegT<T, S> update, query\ntemplate<typename T, int S>\nstruct SegT {\n  typedef T seg_t;\n  const seg_t OUT;\n  static const int N = uprt(S);\n  seg_t data[N * 2];\n  std::function<seg_t(seg_t,seg_t)>ufunc;\n  template<typename F>\n  SegT(T initial, F f):OUT(initial),ufunc(f){std::fill(std::begin(data), std::end(data), initial);}\n  void update(int x, seg_t v){\n    for (data[x+=N-1]=v;x;data[x]=ufunc(data[x+x+1],data[x+x+2]))x=x-1>>1;\n  }\n  void add(int x,seg_t a){ update(x,data[x+N-1]+a); }\n  seg_t query(int a=0,int b=N,int x=0,int l=0,int r=N){\n    if (r<=a||b<=l) return OUT;\n    if (a<=l&&r<=b) return data[x];\n    return ufunc(query(a,b,x+x+1,l,l+r>>1),query(a,b,x+x+2,l+r>>1,r));\n  }\n};\n//}}}\n}\n}\n#endif\n//}}}\n\nusing namespace std;\nusing namespace orislib::ds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\n\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_ template<typename T>inline\n#define TTF_ template<typename T,typename F>inline\nTT_ T sq(T x){return x*x;}\nTT_ T In(){T x;cin>>x;return x;}\nTT_ void Out(T&x){cout<<x;}\nTT_ void sort(T&v){sort(begin(v),end(v));}\nTT_ void revs(T&v){reverse(begin(v),end(v));}\nTT_ void uniq(T&v){sort(v);v.erase(unique(begin(v),end(v)),end(v));}\nTT_ int ubnd(T&v,typename T::value_type x){return upper_bound(begin(v),end(v),x)-begin(v);}\nTT_ int lbnd(T&v,typename T::value_type x){return lower_bound(begin(v),end(v),x)-begin(v);}\nTTF_ void inpt(T&v,int n,F f){for(v.reserve(n);n--;v.emplace_back(f()));}\nTTF_ void show(T&v,F f,string d=\" \",string e=\"\\n\"){int i=0;for(auto&x:v)i++&&(cout<<d),f(x);cout<<e;}\nTT_ typename T::iterator minel(T&v){return min_element(begin(v),end(v));}\nTT_ typename T::iterator maxel(T&v){return max_element(begin(v),end(v));}\n\ninline void fast_io(){ios_base::sync_with_stdio(0);cin.tie(0);}\ninline int in(){int x;scanf(\"%d\",&x);return x;}\ninline ll pow_mod(ll a,ll k,ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\ninline ll mod_inv(ll a,ll p){return pow_mod(a,p-2,p);}\n//}}} priority_queue queue deque front stringstream max_element min_element insert count make_tuple\n\nstruct Star {\n  int x, y, b;\n  Star(int x, int y, int b) : x(x), y(y), b(b) {}\n  bool operator<(const Star& x) const {\n    return b < x.b;\n  }\n};\n\nSegT<int, 200200> xmax(INT_MIN, [](int a, int b){ return max(a, b); });\nSegT<int, 200200> xmin(INT_MAX, [](int a, int b){ return min(a, b); });\nSegT<int, 200200> ymax(INT_MIN, [](int a, int b){ return max(a, b); });\nSegT<int, 200200> ymin(INT_MAX, [](int a, int b){ return min(a, b); });\n\nint main()\n{\n\n  int N = in();\n  int d = in();\n  vector<Star> vs;\n  for (int i = 0; i < N; i++){\n    int x = in();\n    int y = in();\n    int b = in();\n    vs.emplace_back(x, y, b);\n  }\n  sort(vs);\n  for (int i = 0; i < N; i++){\n    xmin.update(i, vs[i].x);\n    xmax.update(i, vs[i].x);\n    ymin.update(i, vs[i].y);\n    ymax.update(i, vs[i].y);\n  }\n\n  int maxi = 0;\n  for (int i = 0; i < N; i++){\n    int t = lbnd(vs, Star(0, 0, vs[i].b + d + 1));\n    int xmini = xmin.query(i, t);\n    int xmaxi = xmax.query(i, t);\n    int ymini = ymin.query(i, t);\n    int ymaxi = ymax.query(i, t);\n    maxi = max(maxi, abs(xmaxi - xmini) * abs(ymaxi - ymini));\n  }\n  printf(\"%d\\n\", maxi);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pi;\n#define F first\n#define S second\nconst int N=2e5+10;\nstruct star{\n    pi pos;\n    int light;\n    void in(){\n        scanf(\"%d%d%d\",&pos.F,&pos.S,&light);\n        return ;\n    }\n};\nstruct cmp{\n    bool operator()(const star &a,const star &b){\n        return a.light>b.light;\n    }\n};\nint min(int a,int b){return a>b?b:a;}\nlong long int max(long long int a,long long int b){return a>b?a:b;}\nint main(){\n    int n,d,low=0;\n    long long int ans=0;\n    star temp;\n    priority_queue<star,vector<star>,cmp> pq;\n    priority_queue<pi,vector<pi>,greater<pi>>l,b;\n    priority_queue<pi> u,r;\n    scanf(\"%d%d\",&n,&d);\n    for(int i=0;i<n;i++){\n        temp.in();\n        pq.push(temp);\n        low=min(low,temp.light);\n    }\n    low+=d;\n    while(!pq.empty()){\n        while(pq.top().light<=low){\n            temp=pq.top();\n            pq.pop();\n            u.push({temp.pos.F,temp.light});\n            b.push({temp.pos.F,temp.light});\n            l.push({temp.pos.S,temp.light});\n            r.push({temp.pos.S,temp.light});\n            if(pq.empty())break;\n        }\n        while(!u.empty()){\n            if(u.top().S<low-d)u.pop();\n            else break;\n        }\n        \n        if(u.empty())continue;\n        while(!r.empty()){\n            if(r.top().S<low-d)r.pop();\n            else break;\n        }\n        if(r.empty())continue;\n        while(!l.empty()){\n            if(l.top().S<low-d)l.pop();\n            else break;\n        }\n        if(l.empty())continue;\n        while(!b.empty()){\n            if(b.top().S<low-d)b.pop();\n            else break;\n        }\n        if(b.empty())continue;\n        ans=max(ans,(long long int)(u.top().F-b.top().F)*(r.top().F-l.top().F));\n        low=pq.top().light;\n    }\n    printf(\"%lld\\n\",ans);\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define Rrep(i, m, n) for(int i=(m);i<(n);i++)\n#define All(v) v.begin(),v.end()\n#define Uniq(v) v.erase(unique(All(v)),v.end())\ntypedef pair<int, int> Pii;\ntypedef pair<int, Pii> Pip;\ntypedef pair<string, int> Psi;\ntypedef vector<int> Vi;\nconst int INF = (1<<30);\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\n\nconst int MAX_N = 1 << 17;\n\nint n, d;\nint datx1[2 * MAX_N - 1];\nint datx2[2 * MAX_N - 1];\nint daty1[2 * MAX_N - 1];\nint daty2[2 * MAX_N - 1];\n\nvoid init(int n_, int dat[]) {\n  n = 1;\n  while( n < n_ ) n *= 2;\n  for(int i=0; i<2*n-1; i++) dat[i] = INT_MAX;\n}\n\nvoid update(int k, int a, int dat[]) {\n  k += n - 1;\n  dat[k] = a;\n  while( k > 0 ) {\n    k = (k - 1) / 2;\n    dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n}\n\nint query(int a, int b, int k, int l, int r, int dat[]) {\n  if( r <= a || b <= l ) return INT_MAX;\n  if( a <= l && r <= b ) return dat[k];\n  else {\n    int vl = query(a, b, k * 2 + 1, l, (l + r) / 2, dat);\n    int vr = query(a, b, k * 2 + 2, (l + r) / 2, r, dat);\n    return min(vl, vr);\n  }\n}\n\nint main()\n{\n  cin >> n >> d;\n  int N = n;\n  init(N, datx1);init(N, datx2);init(N, daty1);init(N, daty2);\n  vector<int> bData;\n  vector<Pip> allData;\n  for(int i=0; i<N; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    bData.pb( c );\n    allData.pb( Pip(c, Pii(a, b)) );\n  }\n \n  sort( All(allData) );\n\n  for(int i=0; i<N; i++) {\n    int x = allData[i].sc.fr, y = allData[i].sc.sc;\n    update(i, x, datx1);\n    update(i, -x, datx2);\n    update(i, y, daty1);\n    update(i, -y, daty2);\n  }\n\n  int s, t; s = t = 0;\n  int ma = 0;\n  for(int i=1; i<N-1; i++) {\n    t = i;\n    while( 1 ) {\n      if( allData[t].fr - allData[s].fr <= d ) break;\n      s++;\n    }\n    int x1 = query(s, t+1, 0, 0, n, datx1);\n    int x2 = query(s, t+1, 0, 0, n, datx2);\n    int y1 = query(s, t+1, 0, 0, n, daty1);\n    int y2 = query(s, t+1, 0, 0, n, daty2);\n\n    int tmp = ((-x2) - x1) * ((-y2) - y1);\n    if( tmp > ma ) {\n      ma = tmp;\n    }\n  }\n \n  cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MP make_pair\n#define int long long int\nusing namespace std;\ntypedef pair<int, int> PII;\n\nint n, d, x[200010], y[200010], b[200010];\n\nPII sorted[200010];\nint ans = 0;\n\nstruct segtree\n{\n  int tree[524288];\n  int size;\n\n  void reset()\n  {\n    size = 1;\n    while(size < n){\n      size <<= 1;\n    }\n  }\n\n  void update(int where, int val)\n  {\n    int now = size - 1 + where;\n    while(true){\n      tree[now] = max(val, now);\n      if(now == 0){\n\treturn;\n      }\n      now = (now - 1) / 2;\n    }\n  }\n\n  int top()\n  {\n    return tree[0];\n  }\n} xmin, xmax, ymin, ymax;\n\nsigned main(){\n  scanf(\"%lld%lld\", &n, &d);\n  for(int i = 0; i < n; i++){\n    scanf(\"%lld%lld%lld\", &x[i], &y[i], &b[i]);\n  }\n\n  for(int i = 0; i < n; i++){\n    sorted[i] = MP(b[i], i);\n  }\n\n  sort(sorted, sorted + n);\n\n  xmin.reset(), xmax.reset(), ymin.reset(), ymax.reset();\n\n  int start = 0, nowd = 0;\n  for(int i = 0; i < n; i++){\n    nowd = sorted[i].first;\n    xmin.update(i, -x[sorted[i].second]);\n    xmax.update(i, x[sorted[i].second]);\n    ymin.update(i, -y[sorted[i].second]);\n    ymax.update(i, y[sorted[i].second]);\n\n    while(start < n){\n      if(sorted[start].first < nowd - d){\n\txmin.update(start, 0);\n\txmax.update(start, 0);\n\tymin.update(start, 0);\n\tymax.update(start, 0);\n\tstart++;\n      }\n      else{\n\tbreak;\n      }\n    }\n\n    ans = max(ans, (xmax.top() + xmin.top()) * (ymax.top() + ymin.top()));\n  }\n\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<climits>\nusing namespace std;\nstruct maxSegTree{\n    int n;\n    vector<int>dat;\n    void init(int n_){\n        n=1;\n        while(n<n_)n*=2;\n        dat.resize(n*2-1,INT_MIN);\n    }\n    maxSegTree(int n_){\n        init(n_);\n    }\n    void update(int x,int val){\n        x+=n-1;\n        dat[x]=val;\n        while(x){\n            x=(x-1)/2;\n            dat[x]=max(dat[x*2+1],dat[x*2+2]);\n        }\n    }\n    int getMax(int a,int b,int k=0,int l=0,int r=-1){\n        if(r==-1)r=n;\n        if(a<=l&&b>=r)return dat[k];\n        if(a>=r||b<=l)return INT_MIN;\n        int v1=getMax(a,b,k*2+1,l,(l+r)/2);\n        int v2=getMax(a,b,k*2+2,(l+r)/2,r);\n        return max(v1,v2);\n    }\n};\nstruct minSegTree{\n    int n;\n    vector<int>dat;\n    void init(int n_){\n        n=1;\n        while(n<n_)n*=2;\n        dat.resize(n*2-1,INT_MAX);\n    }\n    minSegTree(int n_){\n        init(n_);\n    }\n    void update(int x,int val){\n        x+=n-1;\n        dat[x]=val;\n        while(x){\n            x=(x-1)/2;\n            dat[x]=min(dat[x*2+1],dat[x*2+2]);\n        }\n    }\n    int getMin(int a,int b,int k=0,int l=0,int r=-1){\n        if(r==-1)r=n;\n        if(a<=l&&b>=r)return dat[k];\n        if(a>=r||b<=l)return INT_MAX;\n        int v1=getMin(a,b,k*2+1,l,(l+r)/2);\n        int v2=getMin(a,b,k*2+2,(l+r)/2,r);\n        return min(v1,v2);\n    }\n};\nint main(){\n    int n,d;\n    scanf(\"%d%d\",&n,&d);\n    vector<pair<int,pair<int,int> > >V(n);\n    vector<int>D(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d%d\",&V[i].second.first,&V[i].second.second,&V[i].first);\n        D[i]=V[i].first;\n    }\n    sort(V.begin(),V.end());\n    sort(D.begin(),D.end());\n    maxSegTree ma(n*2);\n    minSegTree mi(n*2);\n    int mav=0;\n    for(int i=0;i<n;i++){\n        pair<int,pair<int,int> >p=V[i];\n        int x=p.second.first,y=p.second.first,b=p.first;\n        ma.update(i,x);ma.update(i+n,x);\n        mi.update(i,x);mi.update(i+n,y);\n    }\n    //cout<<\"latte\"<<endl;\n    for(int i=0;i<n;i++){\n        pair<int,pair<int,int> >p=V[i];\n        int x=p.second.first,y=p.second.first,b=D[i];\n        int pos=upper_bound(D.begin(),D.end(),b+d)-D.begin()-1;\n        int mx=ma.getMax(i,pos),my=ma.getMax(i+n,pos+n);\n        int mix=mi.getMin(i,pos),miy=mi.getMin(i+n,pos+n);\n        mav=max(mav,(mx-mix)*(my-miy));\n    }\n    printf(\"%d\\n\",mav);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1000000000\n#define f first\n#define s second\nusing namespace std;\ntypedef pair <int,pair <int,int> > P;\ntypedef long long ll;\nint n,d,tree[4][(1<<19)];\nP star[200001];\n\nvoid update(int i,int flg,int x){\n  i = i+(1<<18)-1;\n  tree[flg][i] = x;\n  while(i) {\n    i = (i-1)/2;\n    tree[flg][i] = max(tree[flg][i*2+1],tree[flg][i*2+2]);\n  }\n}\n\nint find(int a,int b,int ima,int L,int R,int flg){\n  if(R<=a || b<=L) return -INF;\n  if(a<=L && R<=b) return tree[flg][ima];\n  int M = (L+R)/2;\n  return max(find(a,b,ima*2+1,L,M,flg),find(a,b,ima*2+2,M,R,flg));\n}\n\nint main() {\n  cin >> n >> d;\n\n  for(int i=0;i<n;i++)cin >> star[i].s.f >> star[i].s.s >> star[i].f;\n  sort(star,star+n);  \n  \n  for(int i=0;i<4;i++) \n    for(int j=0;j<(1<<19);j++) tree[i][j] = -INF;\n  \n  for(int i=0;i<n;i++) {\n    update(i,0,star[i].s.f); // max(x);\n    update(i,1,star[i].s.s); // max(y);\n    update(i,2,-star[i].s.f); // min(x);\n    update(i,3,-star[i].s.s); // min(y);\n  }\n\n  long long S=0;\n  int ima=0;\n  for(int i=0;i<n;i++){\n    while(ima!=n && star[ima].f-star[i].f <=d) ima++;\n    ll maxx = find(i,ima,0,0,(1<<18),0);\n    ll maxy = find(i,ima,0,0,(1<<18),1);\n    ll minx = find(i,ima,0,0,(1<<18),2);\n    ll miny = find(i,ima,0,0,(1<<18),3);\n    S = max(S,((maxx+minx)*(maxy+miny)));\n  }\n  cout << S<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <vector>\n#include <utility>\n#include <numeric>\n#include <string>\n#include <set>\n#include <map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#define rep(i, a, n) for(int (i) = (int)(a);(i) < (int)(n);++(i))\n#define repe(i, a, n) for(int (i) = (int)(a);(i) <= (int)(n);++(i))\n#define repr(i, a, n) for(int (i) = (int)(a);(i) > (int)(n);--(i))\n#define reper(i, a, n) for(int (i) = (int)(a);(i) >= (int)(n);--(i))\n#define SIZE(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define RNG(x, n) &((x)[0]), &((x)[n])\n#define SUBIF(a, b, x) ((x) ? (b) : (a))\n#define YES cout << \"YES\" << endl\n#define NO cout << \"NO\" << endl\n#define Yes cout << \"Yes\" << endl\n#define No cout << \"No\" << endl\n#define yes cout << \"yes\" << endl;\n#define no cout << \"no\" << endl;\n#define pb push_back\n#define EPS (1e-20)\n#define INF 2147483647\n#define MOD 1000000007\nusing llint = long long;\nusing VI = std::vector<int>;\nusing PII = std::pair<int, int>;\nusing SI = std::set<int>;\nusing MII = std::map<int, int>;\nusing TIII = std::tuple<int, int, int>;\nusing namespace std;\n\n\nstruct SEG {\n\tint aryN;\n\tvector<PII> seg;\n\n\tSEG(){}\n\tSEG(const VI &v){\n\t\taryN = (int)pow(2, (int)ceil(log2(SIZE(v))));\n\t\tseg.resize(2*aryN-1, { -1, INF });\n\t\trep(i, 0, SIZE(v)) seg[i+aryN-1] = { v[i], v[i] };\n\t\treper(i, aryN-2, 0) seg[i].first = max(seg[2*i+1].first, seg[2*i+2].first), seg[i].second = min(seg[2*i+1].second, seg[2*i+2].second);\n\t}\n\tvoid update(int x, PII p){\n\t\tx += (aryN-1);\n\t\tseg[x] = p;\n\t\twhile(x > 0){\n\t\t\tx = (x-1)/2;\n\t\t\tseg[x].first = max(seg[2*x+1].first, seg[2*x+2].first);\n\t\t\tseg[x].second = min(seg[2*x+1].second, seg[2*x+2].second);\n\t\t}\n\t}\n\tint getMax(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = aryN;\n\t\tif(r <= a || b <= l) return -1;\n\t\tif(a <= l && r <= b) return seg[k].first;\n\t\tint vl = getMax(a, b, 2*k+1, l, (l+r)/2);\n\t\tint vr = getMax(a, b, 2*k+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n\tint getMin(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = aryN;\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <= b) return seg[k].second;\n\t\tint vl = getMin(a, b, 2*k+1, l, (l+r)/2);\n\t\tint vr = getMin(a, b, 2*k+2, (l+r)/2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\n\nint N, d;\nvector<TIII> s;\nllint br[200010];\nSEG X, Y;\n\n\ntemplate<int N>\nVI tupleToVec(vector<TIII> vt){\n\tVI ret;\n\tfor(TIII t : vt) ret.pb(get<N>(t));\n\treturn ret;\n}\n\n\nint solve(){\n\tint ans = 0;\n\trep(i, 0, N) br[i] = get<0>(s[i]);\n\tX = SEG(tupleToVec<1>(s));\n\tY = SEG(tupleToVec<2>(s));\n\trep(i, 0, N){\n\t\tint p = upper_bound(RNG(br, N), br[i]+(llint)d)-&br[0];\n\t\tint x1 = X.getMax(i, p), x2 = X.getMin(i, p);\n\t\tint y1 = Y.getMax(i, p), y2 = Y.getMin(i, p);\n\t\tans = max(ans, (x1-x2)*(y1-y2));\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> N >> d;\n\ts = vector<TIII>(N);\n\trep(i, 0, N) cin >> get<1>(s[i]) >> get<2>(s[i]) >> get<0>(s[i]);\n\tsort(ALL(s));\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for (int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define Cout(obj) cout << obj << endl\n#define Size(obj) (obj).size()\n#define fcout cout << fixed << setprecision(10)\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\ntemplate <typename T>\nstruct SegTreeMin\n{\n  private:\n    ll N = 1;\n    vector<T> node;\n\n  public:\n    SegTreeMin(vector<T> vec)\n    {\n        ll size = vec.size();\n\n        while (N < size)\n        {\n            N *= 2;\n        }\n\n        node.resize(2 * N - 1, iINF);\n\n        REP(i, size)\n        {\n            node[i + N - 1] = vec[i];\n        }\n\n        for (int i = N - 2; 0 <= i; i--)\n        {\n            node[i] = min(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    void update(int i, T value)\n    {\n        i += (N - 1);\n\n        node[i] = value;\n\n        while (i > 0)\n        {\n            i = (i - 1) / 2;\n\n            node[i] = min(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    T getMin(int a, int b, int i = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = N;\n        }\n\n        if (r <= a || b <= l)\n        {\n            return iINF;\n        }\n\n        if (a <= l && r <= b)\n        {\n            return node[i];\n        }\n\n        T vl = getMin(a, b, 2 * i + 1, l, (l + r) / 2);\n\n        T vr = getMin(a, b, 2 * i + 2, (l + r) / 2, r);\n\n        return min(vl, vr);\n    }\n};\n\ntemplate <typename T>\nstruct SegTreeMax\n{\n  private:\n    ll N = 1;\n    vector<T> node;\n\n  public:\n    SegTreeMax(vector<T> vec)\n    {\n        ll size = vec.size();\n\n        while (N < size)\n        {\n            N *= 2;\n        }\n\n        node.resize(2 * N - 1, -iINF);\n\n        REP(i, size)\n        {\n            node[i + N - 1] = vec[i];\n        }\n\n        for (int i = N - 2; 0 <= i; i--)\n        {\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    void update(int i, T value)\n    {\n        i += (N - 1);\n\n        node[i] = value;\n\n        while (i > 0)\n        {\n            i = (i - 1) / 2;\n\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    T getMax(int a, int b, int i = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = N;\n        }\n\n        if (r <= a || b <= l)\n        {\n            return -iINF;\n        }\n\n        if (a <= l && r <= b)\n        {\n            return node[i];\n        }\n\n        T vl = getMax(a, b, 2 * i + 1, l, (l + r) / 2);\n\n        T vr = getMax(a, b, 2 * i + 2, (l + r) / 2, r);\n\n        return max(vl, vr);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll N, d;\n    cin >> N >> d;\n\n    vector<tuple<ll, ll, ll>> vec(N);\n\n    SegTreeMax<ll> xMax(vector<ll>(N, -iINF)), yMax(vector<ll>(N, -iINF));\n    SegTreeMin<ll> xMin(vector<ll>(N, iINF)), yMin(vector<ll>(N, iINF));\n\n    ll ans = 0;\n\n    REP(i, N)\n    {\n        ll x, y, d;\n        cin >> x >> y >> d;\n\n        vec[i] = make_tuple(d, x, y);\n    }\n\n    sort(ALL(vec));\n\n    REP(i, N)\n    {\n        ll x, y, d;\n        tie(d, x, y) = vec[i];\n\n        xMax.update(i, x);\n        xMin.update(i, x);\n        yMax.update(i, y);\n        yMin.update(i, y);\n    }\n\n    REP(i, N)\n    {\n        ll start = get<0>(vec[i]);\n\n        auto itr = upper_bound(vec.begin(), vec.end(), make_tuple(d + start, iINF, iINF));\n\n        if (itr == vec.begin())\n            continue;\n\n        ll now = itr - vec.begin();\n\n        ll x = xMax.getMax(i, now), y = yMax.getMax(i, now);\n        ll _x = xMin.getMin(i, now), _y = yMin.getMin(i, now);\n\n        ans = max(ans, (x - _x) * (y - _y));\n    }\n\n    Cout(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\nint x[200000];\nint y[200000];\nint b[200000];\nP s[200000];\n\nlong long max(long long a,long long b){return a>b?a:b;}\n\nint main(){\n\tint n,d,i;\n\tscanf(\"%d %d\",&n,&d);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d %d\",&x[i],&y[i],&b[i]);\n\t\ts[i]=P(b[i],i);\n\t}\n\tsort(s,s+n);\n\tpriority_queue<P, vector<P>, greater<P> > que_xl;\n\tpriority_queue<P> que_xr;\n\tpriority_queue<P, vector<P>, greater<P> > que_yl;\n\tpriority_queue<P> que_yr;\n\tint r=0;\n\tlong long ans=0;\n\tfor(i=0;i<n;i++){\n\t\twhile(r<n&&s[r].first<=s[i].first+d){\n\t\t\tque_xl.push(P(x[s[r].second],s[r].second));\n\t\t\tque_xr.push(P(x[s[r].second],s[r].second));\n\t\t\tque_yl.push(P(y[s[r].second],s[r].second));\n\t\t\tque_yr.push(P(y[s[r].second],s[r].second));\n\t\t\tr++;\n\t\t}\n\t\twhile(b[que_xl.top().second]<s[i].first)que_xl.pop();\n\t\twhile(b[que_xr.top().second]<s[i].first)que_xr.pop();\n\t\twhile(b[que_yl.top().second]<s[i].first)que_yl.pop();\n\t\twhile(b[que_yr.top().second]<s[i].first)que_yr.pop();\n\t\tlong long x=que_xr.top().first-que_xl.top().first;\n\t\tlong long y=que_yr.top().first-que_yl.top().first;\n\t\tans=max(ans,x*y);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\n\nstruct Star{\n    int x,y,b;\n    Star(int x=0,int y=0,int b=0) :\n        x(x),y(y),b(b){}\n    bool operator<(const Star &rth) const {\n        return std::tie(b,x,y)<std::tie(rth.b,rth.x,rth.y);\n    }\n};\n\nstruct SegTree {\n    int n;\n    vector<ll> min_dat;\n    vector<ll> max_dat;\n    SegTree(int N) {\n        n=1;\n        while(n<N) n*=2;\n        min_dat.assign(1<<18,INF);\n        max_dat.assign(1<<18,0);\n    }\n\n    void update(int k,ll a) {\n        k+=n-1;\n        min_dat[k]=a;\n        max_dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            min_dat[k]=min(min_dat[k*2+1],min_dat[k*2+2]);\n            max_dat[k]=max(max_dat[k*2+1],max_dat[k*2+2]);\n        }\n    }\n\n    ll min_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return INF;\n\n        if(a<=l&&r<=b) return min_dat[k];\n        else {\n            int vl=min_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=min_query(a,b,k*2+2,(l+r)/2,r);\n            return min(vl,vr);\n        }\n    }\n\n    ll max_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return 0;\n\n        if(a<=l&&r<=b) return max_dat[k];\n        else {\n            int vl=max_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=max_query(a,b,k*2+2,(l+r)/2,r);\n            return max(vl,vr);\n        }\n    }\n\n    void dump() {\n        rep(i,n) cout<<max_dat[i]<<\" \";\n        cout<<endl;\n    }\n\n};\nint N,d;\n\n\nvector<Star> stars;\n\nint find(int x) {\n    int l=0;\n    int r=stars.size()-1;\n    while(r-l>1) {\n        int mid=(l+r)/2;\n        if(stars[mid].b<x) l=mid;\n        else r=mid;\n    }\n    return r;\n}\nint main() {\n    cin>>N>>d;\n    rep(i,N) {\n        Star s;\n        cin>>s.x>>s.y>>s.b;\n        stars.pb(s);\n    }\n    SegTree segTreeX(N);\n    SegTree segTreeY(N);\n\n    sort(all(stars));\n\n    rep(i,stars.size()) {\n        // printf(\"%d %d %d %d\\n\",i,stars[i].x,stars[i].y,stars[i].b);\n        segTreeX.update(i,stars[i].x);\n        segTreeY.update(i,stars[i].y);\n    }\n\n\n    ll ans=0;\n    int n=segTreeX.n;\n    rep(i,stars.size()) {\n        // int pos=find(stars[i].b+d);\n        Star s=stars[i];\n        s.b+=d;\n        s.x=s.y=-INF;\n        int pos=upper_bound(all(stars),s)-stars.begin();\n        if(pos==i) continue;\n        ll tmp=0;\n        tmp=segTreeX.max_query(i,pos+1,0,0,n)-segTreeX.min_query(i,pos+1,0,0,n);\n        tmp*=segTreeY.max_query(i,pos+1,0,0,n)-segTreeY.min_query(i,pos+1,0,0,n);\n\n        // cout<<i<<\",\"<<stars[i].b+d<<\",\"<<pos<<\",\"<<tmp<<endl;\n        ans = max(ans,tmp);\n\n    }\n\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\n#define _(_1,_2,_3,N,...)N\n#define pr(...) _(__VA_ARGS__,pr3,pr2,pr1)(__VA_ARGS__)\ntemplate<C T>void pr1(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr2(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr3(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nstruct P {int x,y,z;};\n\nclass RMQ{\npublic:\n  int n,dat[1000010];\n  void init(int _n){\n    n=1;\n    while(n<_n)n*=2;\n    fill(dat,dat+2*n-1,MAX);\n  }\n  void update(int k,int a){\n    k+=n-1;dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b){return query(a,b,0,0,n);}\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return MAX;\n    if(a<=l&&r<=b) return dat[k];\n    else {\n      int vl=query(a,b,k*2+1,l,(l+r)/2);\n      int vr=query(a,b,k*2+2,(l+r)/2,r);\n      return min(vl,vr);\n    }\n  }\n};\n\nclass RMQ2{\npublic:\n  int n,dat[1000010];\n  void init(int _n){\n    n=1;\n    while(n<_n)n*=2;\n    fill(dat,dat+2*n-1,-1);\n  }\n  void update(int k,int a){\n    k+=n-1;dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b){return query(a,b,0,0,n);}\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return -1;\n    if(a<=l&&r<=b) return dat[k];\n    else {\n      int vl=query(a,b,k*2+1,l,(l+r)/2);\n      int vr=query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    }\n  }\n};\n\nRMQ x,y;\nRMQ2 x2,y2;\n\nvoid Main() {\n  int n,d;\n  cin >> n >> d;\n  P a[n];\n  vector<int> v;\n  rep(i,n) {\n    int x,y,z;\n    cin >> x >> y >> z;\n    a[i]=(P){x,y,z};\n    v.pb(z);\n  }\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n  map<int,int> m;\n  rep(i,v.size()) m[v[i]]=i;\n  x.init(v.size());\n  y.init(v.size());\n  x2.init(v.size());\n  y2.init(v.size());\n  rep(i,n) {\n    int r=m[a[i].z];\n    x.update(r,min(x.query(r,r+1),a[i].x));\n    y.update(r,min(y.query(r,r+1),a[i].y));\n    x2.update(r,max(x2.query(r,r+1),a[i].x));\n    y2.update(r,max(y2.query(r,r+1),a[i].y));\n  }\n  ll ans=0,r=0;\n  rep(l,v.size()) {\n    while(r<v.size()&&v[r]-v[l]<=d) r++;\n    ans=max(ans,(ll)(x2.query(l,r)-x.query(l,r))*(ll)(y2.query(l,r)-y.query(l,r)));\n  }\n  pr(ans);\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define INF 1e9\nusing namespace std;\ntypedef long long ll;\nint n,d;\nstruct data{\n\tll x,y,c;\n};\n\nbool comp(const data& d1,const data& d2){\n\treturn d1.c<d2.c;\n};\n\ndata s[200001];\n\nstruct segtree{\n\tll val,b,s,v2;\n};\nsegtree seg[2][1<<23];\n\nvoid init(){\n\tfor(int i=0;i<(1<<23);i++)seg[0][i].s=seg[1][i].s=INF;\n\tfor(int i=1<<22;i<1<<23;i++)seg[0][i].v2=seg[1][i].v2=i-(1<<22);\n}\n\nvoid update(int upd,int x,int a){\n\tx+=(1<<22);\n\tseg[upd][x].val+=a;\n\tif(seg[upd][x].val>=1)seg[upd][x].s=seg[upd][x].b=seg[upd][x].v2;\n\telse{\n\t\tseg[upd][x].s=INF;\n\t\tseg[upd][x].b=0;\n\t}\n\twhile(x>0){\n\t\tx=(x-1)/2;\n\t\tseg[upd][x].s=min(seg[upd][x*2+1].s,seg[upd][x*2+2].s);\n\t\tseg[upd][x].b=max(seg[upd][x*2+1].b,seg[upd][x*2+2].b);\n\t}\n}\n\n\nint main(void){\n\tscanf(\"%d%d\",&n,&d);\n\tinit();\n\tfor(int i=0;i<n;i++)scanf(\"%lld%lld%lld\",&s[i].x,&s[i].y,&s[i].c);\n\tsort(s,s+n,comp);\n\tll res=0;\n\tint mc=0;\n\tfor(int i=0;i<n;i++){\n\t\tupdate(0,s[i].x,1);\n\t\tupdate(1,s[i].y,1);\n\t\twhile(s[i].c-s[mc].c>d){\n\t\t\tupdate(0,s[mc].x,-1);\n\t\t\tupdate(1,s[mc].y,-1);\n\t\t\tmc++;\n\t\t}\n\t\tres=max(res,(seg[0][0].b-seg[0][0].s)*(seg[1][0].b-seg[1][0].s));\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define F first\n#define S second\nconst int MAX_N = 1<<18;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> P;\n \nint n;\nint minX[2*MAX_N-1],maxX[2*MAX_N-1];\nint minY[2*MAX_N-1],maxY[2*MAX_N-1];\n \nstruct Data{\n    int x,y,b;\n    Data(){}\n    Data(int x,int y,int b) : x(x),y(y),b(b) {}\n    bool operator < (const Data &d)const{\n        return b < d.b;\n    }\n};\n \nvoid init(ll n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0 ; i < 2*n-1 ; i++){\n        minX[i] = minY[i] = INT_MAX;\n        maxX[i] = maxY[i] = INT_MIN;\n    }\n}\n \nvoid update(int k,pii p){\n    k += n - 1;\n    minX[k] = min(minX[k],p.first);\n    maxX[k] = max(maxX[k],p.first);\n    minY[k] = min(minY[k],p.second);\n    maxY[k] = max(maxY[k],p.second);\n    while(k > 0){\n        k = (k - 1) / 2;\n        minX[k] = min(minX[2*k+1],minX[2*k+2]);\n        maxX[k] = max(maxX[2*k+1],maxX[2*k+2]);\n        minY[k] = min(minY[2*k+1],minY[2*k+2]);\n        maxY[k] = max(maxY[2*k+1],maxY[2*k+2]);\n    }\n}\n \nP query(int a,int b,int k,int l,int r){\n    if(r <= a || b <= l){\n        return P(pii(INT_MAX,INT_MIN),pii(INT_MAX,INT_MIN));\n    }\n    if(a <= l && r <= b){\n        return P(pii(minX[k],maxX[k]),pii(minY[k],maxY[k]));\n    }else{\n        P vl = query(a,b,2*k+1,l,(l+r)/2);\n        P vr = query(a,b,2*k+2,(l+r)/2,r);\n        return P(pii(min(vl.F.F,vr.F.F),max(vl.F.S,vr.F.S)),\n                 pii(min(vl.S.F,vr.S.F),max(vl.S.S,vr.S.S)));\n    }\n}\n \nll getArea(P p){\n    return (ll)(p.F.S-p.F.F)*(ll)(p.S.S-p.S.F);\n}\n \nint main(){\n    int N,d,x,y,b;\n    cin >> N >> d;\n    vector<Data> v(N);\n    for(int i = 0 ; i < N ; i++){\n        cin >> x >> y >> b;\n        v[i] = Data(x,y,b);\n    }\n    sort(v.begin(),v.end());\n    init(N);\n    for(int i = 0 ; i < N ; i++){\n        update(i,pii(v[i].x,v[i].y));\n    }\n    ll res = 0;\n    for(int i = 0, j = 0 ; i < N ; i++){\n        int s = v[i].b, t = v[j].b;\n        while(j < N && t - s <= d) j++, t = v[j].b;\n        j--;\n        P p = query(i,j+1,0,0,n);\n        res = max(res,getArea(p));\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint N;\nlong int b;\nint maxx,maxy,maxs,kma,kmi,ks,x[200000],y[200000],cnt;\nstruct DATA{\n\tint x,y,b;\n};\nDATA data[200000];\n\nint main(){\n\tcin>>N>>b;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>data[i].x>>data[i].y>>data[i].b;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tmaxx=0;maxy=0;cnt=1;\n\t\tx[0]=data[i].x;\n\t\ty[0]=data[i].y;\n\t\tfor(int j=0;j<N;j++){\n\t\t\t\n\t\t\tif(0<=data[i].b-data[j].b&&data[i].b-data[j].b<=b){\n\t\t\t\tcnt++;\n\t\t\t\tx[cnt]=data[j].x;\n\t\t\t\ty[cnt]=data[j].y;\n\t\t\t}\n\t\t\tif(j==N-1){\n\t\t\t\tsort(x,x+cnt);\n\t\t\t\tsort(y,y+cnt);\n\t\t\t\tmaxx=x[cnt]-x[0];\n\t\t\t\tmaxy=y[cnt]-y[0];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tks=maxx*maxy;\n\t\tif(maxs<ks){maxs=ks;kma=maxx;kmi=maxy;}\n\t}\n\tcout<<maxs<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pi;\n#define F first\n#define S second\nconst int N=2e5+10;\nstruct star{\n    pi pos;\n    int light;\n    void in(){\n        scanf(\"%d%d%d\",&pos.F,&pos.S,&light);\n        return ;\n    }\n};\nstruct cmp{\n    bool operator()(const star &a,const star &b){\n        return a.light>b.light;\n    }\n};\nint min(int a,int b){return a>b?b:a;}\nlong long int max(long long int a,long long int b){return a>b?a:b;}\nint main(){\n    int n,d,low=0;\n    long long int ans=0;\n    star temp;\n    priority_queue<star,vector<star>,cmp> pq;\n    priority_queue<pi,vector<pi>,greater<pi>>l,b;\n    priority_queue<pi> u,r;\n    scanf(\"%d%d\",&n,&d);\n    for(int i=0;i<n;i++){\n        temp.in();\n        pq.push(temp);\n        low=min(low,temp.light);\n    }\n    low+=d;\n    while(!pq.empty()){\n        while(pq.top().light<=low){\n            temp=pq.top();\n            pq.pop();\n            u.push({temp.pos.F,temp.light});\n            b.push({temp.pos.F,temp.light});\n            l.push({temp.pos.S,temp.light});\n            r.push({temp.pos.S,temp.light});\n            if(pq.empty())break;\n        }\n        while(!u.empty()){\n            if(u.top().S<low-d)u.pop();\n            else break;\n        }\n        \n        if(u.empty())continue;\n        while(!r.empty()){\n            if(r.top().S<low-d)r.pop();\n            else break;\n        }\n        if(r.empty())continue;\n        while(!l.empty()){\n            if(l.top().S<low-d)l.pop();\n            else break;\n        }\n        if(l.empty())continue;\n        while(!b.empty()){\n            if(b.top().S<low-d)b.pop();\n            else break;\n        }\n        if(b.empty())continue;\n        ans=max(ans,(long long int)(u.top().F-b.top().F)*(r.top().F-l.top().F));\n        if(!pq.empty())low=pq.top().light;\n    }\n    printf(\"%lld\\n\",ans);\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing ll=long long int;\n\nconstexpr int MAX_N=(1<<18),INF=2*(int)1e6;\n\nusing P=std::pair<int,int>;//max,min\n\nint n,d;\n\nstd::map<int,P> mapX,mapY;\n\nstd::vector<P> maxmin;\n\nstd::vector<int> vec,res,ansX,ansY;\n\nP calc(const P& lhs,const P& rhs){\n\n    return P(std::max(lhs.first,rhs.first),std::min(lhs.second,rhs.second));\n}\n\nP seg[MAX_N*2-1];\n\nvoid init(int _n) {\n\n    n=1;\n\n    while(n<_n)\n        n*=2;\n\n    for(int i=0;i<n*2-1;++i)\n        seg[i]=P(0,INF);\n\n    for(int i=0;i<_n;++i)\n        seg[i+n-1]=maxmin[i];\n\n    for(int i=n-2;i>=0;--i)\n        seg[i]=calc(seg[i*2+1],seg[i*2+2]);\n}\n\nP query(int a,int b,int k,int l,int r){\n\n    if(b<=l||r<=a)\n        return P(0,INF);\n    \n    if(a<=l&&r<=b)\n        return seg[k];\n    \n    return calc(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n}\n\nstd::vector<int> solve(std::map<int,P>& map){\n\n    res.clear();\n    maxmin.clear();\n    vec.clear();\n\n    for(auto&& s : map){\n        vec.emplace_back(s.first);\n        maxmin.emplace_back(s.second);\n    }\n\n    init(maxmin.size());\n\n    for(int i=0;i<vec.size();++i){\n        P p=query(i,std::upper_bound(vec.begin(),vec.end(),vec[i]+d)-vec.begin(),0,0,n);\n        res.emplace_back(p.first-p.second);\n    }\n\n    return res;\n}\n\nint main() {\n\n    std::cin>>n>>d;\n\n    int x,y,b;\n\n    for(int i=0;i<n;++i) {\n\n        std::cin>>x>>y>>b;\n\n        if(!mapX.count(b)){\n            mapX[b]=P(x,x);\n            mapY[b]=P(y,y);\n        }\n        else{\n            mapX[b]=P(std::max(mapX[b].first,x),std::min(mapX[b].second,x));\n            mapY[b]=P(std::max(mapY[b].first,y),std::min(mapY[b].second,y));\n        }\n    }\n\n    ansX=solve(mapX);\n\n    ansY=solve(mapY);\n\n    ll ans=0;\n\n    for(int i=0;i<ansX.size();++i)\n        ans=std::max(ans,ll(ansX[i])*ll(ansY[i]));\n\n    std::cout<<ans<<std::endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass Data\n{\npublic:\n    int x, y, b;\n    bool operator<(const Data& d) const{\n        return b < d.b;\n    }\n};\n\nint main()\n{\n    int n, diff;\n    cin >> n >> diff;\n\n    vector<Data> d(n);\n    for(int i=0; i<n; ++i)\n        cin >> d[i].x >> d[i].y >> d[i].b;\n    sort(d.begin(), d.end());\n\n    multiset<int> x, y;\n    int k = 0;\n    long long ans = 0;\n    for(int i=0; i<n; ++i){\n        while(k < n && d[k].b - d[i].b <= diff){\n            x.insert(d[k].x);\n            y.insert(d[k].y);\n            ++ k;\n        }\n\n        long long dx = *x.rbegin() - *x.begin();\n        long long dy = *y.rbegin() - *y.begin();\n        ans = max(ans, dx * dy);\n\n        x.erase(x.find(d[i].x));\n        y.erase(y.find(d[i].y));\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nstruct SegTree{\n    static const int N=1<<18;\n    vector<int>dat;\n\n    SegTree(){\n        dat=vector<int>(N*2-1,INT_MAX);\n    }\n\n    void update(int k,int x){\n        k+=N-1;\n        dat[k]=min(dat[k],x);\n        while(k){\n            k=(k-1)/2;\n            dat[k]=min(dat[k],x);\n        }\n    }\n\n    int getMin(int a,int b,int k=0,int l=0,int r=N){\n        if(r<=a||b<=l)return INT_MAX;\n        if(r-l<=1)return dat[k];\n        int m=(l+r)/2;\n        int vl=getMin(a,b,k*2+1,l,m);\n        int vr=getMin(a,b,k*2+2,m,r);\n        return min(vl,vr);\n    }\n};\ntypedef pair<int,int>P;\ntypedef pair<int,P>PP;\n#define fi first\n#define se second\ntypedef long long ll;\n\nint N,D;\nvector<PP>Stars;\nSegTree minx,miny,maxx,maxy;\n\nint main(){\n    cin>>N>>D;\n    for(int i=0;i<N;i++){\n        int x,y,b;\n        cin>>x>>y>>b;\n        Stars.push_back(PP(b,P(x,y)));\n    }\n\n    sort(Stars.begin(),Stars.end());\n\n    for(int i=0;i<N;i++){\n        minx.update(i,Stars[i].se.fi);\n        miny.update(i,Stars[i].se.se);\n        maxx.update(i,-Stars[i].se.fi);\n        maxy.update(i,-Stars[i].se.se);\n    }\n\n    ll ans=0;\n\n    for(int i=0;i<N;i++){\n        int j=upper_bound(Stars.begin(),Stars.end(),PP(Stars[i].fi+D,P(INT_MAX,INT_MAX)))-Stars.begin();\n        ll w=-maxx.getMin(i,j)-minx.getMin(i,j);\n        ll h=-maxy.getMin(i,j)-miny.getMin(i,j);\n        ans=max(ans,h*w);\n    }\n\n    cout<<ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define Rrep(i, m, n) for(int i=(m);i<(n);i++)\n#define All(v) v.begin(),v.end()\n#define Uniq(v) v.erase(unique(All(v)),v.end())\ntypedef pair<int, int> Pii;\ntypedef pair<int, Pii> Pip;\ntypedef pair<string, int> Psi;\ntypedef vector<int> Vi;\nconst int INF = (1<<30);\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\n\nconst int MAX_N = 1 << 17;\n\nint n, d;\nint datx1[2 * MAX_N - 1];\nint datx2[2 * MAX_N - 1];\nint daty1[2 * MAX_N - 1];\nint daty2[2 * MAX_N - 1];\n\nvoid init(int n_, int dat[]) {\n  n = 1;\n  while( n < n_ ) n *= 2;\n  for(int i=0; i<2*n-1; i++) dat[i] = INT_MAX;\n}\n\nvoid update(int k, int a, int dat[]) {\n  k += n - 1;\n  dat[k] = a;\n  while( k > 0 ) {\n    k = (k - 1) / 2;\n    dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n}\n\nint query(int a, int b, int k, int l, int r, int dat[]) {\n  if( r <= a || b <= l ) return INT_MAX;\n  if( a <= l && r <= b ) return dat[k];\n  else {\n    int vl = query(a, b, k * 2 + 1, l, (l + r) / 2, dat);\n    int vr = query(a, b, k * 2 + 2, (l + r) / 2, r, dat);\n    return min(vl, vr);\n  }\n}\n\nint main()\n{\n  cin >> n >> d;\n  int N = n;\n  init(N, datx1);init(N, datx2);init(N, daty1);init(N, daty2);\n  vector<int> bData;\n  vector<Pip> allData;\n  for(int i=0; i<N; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    bData.pb( c );\n    allData.pb( Pip(c, Pii(a, b)) );\n  }\n \n  sort( All(allData) );\n\n  for(int i=0; i<N; i++) {\n    int x = allData[i].sc.fr, y = allData[i].sc.sc;\n    update(i, x, datx1);\n    update(i, -x, datx2);\n    update(i, y, daty1);\n    update(i, -y, daty2);\n  }\n\n  int s, t; s = t = 0;\n  int ma = 0;\n  for(int i=1; i<N; i++) {\n    t = i;\n    while( 1 ) {\n      if( allData[t].fr - allData[s].fr <= d ) break;\n      s++;\n    }\n    int x1 = query(s, t+1, 0, 0, n, datx1);\n    int x2 = query(s, t+1, 0, 0, n, datx2);\n    int y1 = query(s, t+1, 0, 0, n, daty1);\n    int y2 = query(s, t+1, 0, 0, n, daty2);\n\n    int tmp = ((-x2) - x1) * ((-y2) - y1);\n    if( tmp > ma ) {\n      ma = tmp;\n    }\n  }\n \n  cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n \ntypedef pair< int, int > Pi;\ntypedef pair< int, Pi > Pii;\n\nbool hoge(const Pii& a,const Pii& b) {\n  return a.first < b.first; \n}\n\n\nint main(){\n  int N, d;\n  Pii data[200000];\n  multiset< int > X, Y;\n  scanf(\"%d %d\", &N, &d);\n  for(int i = 0; i < N; i++){\n    scanf(\"%d %d %d\", &data[i].second.first, &data[i].second.second, &data[i].first);\n  }\n  sort( data, data + N, hoge);\n  int64 ret = 0, low = 0;\n  for(int i = 0; i < N; ++i){\n    while(data[low].first < data[i].first - d){\n      X.erase( X.find(data[low].second.first));\n      Y.erase( Y.find(data[low].second.second));\n      low++;\n    }\n    X.insert( data[i].second.first);\n    Y.insert( data[i].second.second);\n    ret = max( ret, (int64)(*--X.end() - *X.begin()) * (*--Y.end() - *Y.begin()));\n  }\n  printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n\nclass SegmentTree\n{\nprivate:\n\tvector<int> tree;\n\tconst int INF = 99999999;\n\tint size;\n\tint init(int i)\n\t{\n\t\tif (i * 2 + 1 < tree.size()) tree[i] = init(i * 2 + 1);\n\t\tif (i * 2 + 2 < tree.size()) tree[i] = min(init(i * 2 + 2), tree[i]);\n\t\treturn tree[i];\n\t}\n\tint get(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || b <= l) return INF;\n\t\tif (a <= l && r <= b) return tree[k];\n\t\tint vl = get(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = get(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\npublic:\n\tSegmentTree(vector<int>& v)\n\t{\n\t\tsize = 1;\n\t\twhile (size < v.size()) size *= 2;\n\t\ttree.resize(size * 2 - 1);\n\t\tfill(tree.begin(), tree.end(), INF);\n\t\tfor (int i = 0; i < v.size(); i++) tree[size - 1 + i] = v[i];\n\t\tinit(0);\n\t}\n\tint get(int begin, int end)\n\t{\n\t\treturn get(begin, end, 0, 0, size);\n\t}\n};\nclass GreaterSegmentTree\n{\nprivate:\n\tvector<int> tree;\n\tconst int INF = -99999999;\n\tint size;\n\tint init(int i)\n\t{\n\t\tif (i * 2 + 1 < tree.size()) tree[i] = init(i * 2 + 1);\n\t\tif (i * 2 + 2 < tree.size()) tree[i] = max(init(i * 2 + 2), tree[i]);\n\t\treturn tree[i];\n\t}\n\tint get(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || b <= l) return INF;\n\t\tif (a <= l && r <= b) return tree[k];\n\t\tint vl = get(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = get(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\npublic:\n\tGreaterSegmentTree(vector<int>& v)\n\t{\n\t\tsize = 1;\n\t\twhile (size < v.size()) size *= 2;\n\t\ttree.resize(size * 2 - 1);\n\t\tfill(tree.begin(), tree.end(), INF);\n\t\tfor (int i = 0; i < v.size(); i++) tree[size - 1 + i] = v[i];\n\t\tinit(0);\n\t}\n\tint get(int begin, int end)\n\t{\n\t\treturn get(begin, end, 0, 0, size);\n\t}\n};\n\n\n\nclass Star\n{\npublic:\n\tlong long int x, y;\n\tint b;\n\tint boundary;\n};\nbool operator > (Star s1, Star s2)\n{\n\treturn s1.b > s2.b;\n}\nbool operator < (Star s1, Star s2)\n{\n\treturn s1.b < s2.b;\n}\n\nint n, d;\nStar star[200000];\nlong long int ans = 0;\n\nvoid calcBoundary()\n{\n\tint boundary = n - 1;\n\tstar[n - 1].boundary = boundary;\n\tfor (int i = n - 2; i >= 0; i--)\n\t{\n\t\tif (star[i + 1].b - star[i].b > d) boundary = i;\n\t\tstar[i].boundary = boundary;\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tStar s;\n\t\ts.b = star[i].b + d;\n\t\tboundary = upper_bound(star + i, star + n, s) - star - 1;\n\t\tstar[i].boundary = min(star[i].boundary, boundary);\n\t}\n}\n\nvoid solve()\n{\n\tvector<int> vx;\n\tvector<int> vy;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tvx.push_back(star[i].x);\n\t\tvy.push_back(star[i].y);\n\t}\n\tSegmentTree segX(vx), segY(vy);\n\tGreaterSegmentTree gsegX(vx), gsegY(vy);\n\n\tint boundary = star[0].boundary;\n\tint begin = 0;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tif (boundary != star[i].boundary)\n\t\t{\n\t\t\tlong long int a = (gsegX.get(begin, i) - segX.get(begin, i)) * (gsegY.get(begin, i) - segY.get(begin, i));\n\t\t\tans = max(a, ans);\n\t\t\tboundary = star[i].boundary;\n\t\t\tbegin = i;\n\t\t}\n\t}\n\tlong long int a = (gsegX.get(begin, n) - segX.get(begin, n)) * (gsegY.get(begin, n) - segY.get(begin, n));\n\tans = max(a, ans);\n}\n\nint main()\n{\n\tcin >> n >> d;\n\tfor (int i = 0; i < n; i++) cin >> star[i].x >> star[i].y >> star[i].b;\n\n\tsort(star, star + n);\n\tcalcBoundary();\n\tsolve();\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"climits\"\n#define MAX 200000\nint star;\nint dif;\nint box_x[MAX];\nint x[MAX];\nint y[MAX];\nint box_y[MAX];\nint blight[MAX];\nint box[MAX];\nint end[MAX]={};\nint x_max=0;\nint x_min=INT_MAX;\nint y_max=0;\nint y_min=INT_MAX;\nint child;\nint fig = 1;\nint RMinQx[MAX * 4];\nint RMinQy[MAX * 4];\nint RMaxQx[MAX * 4];\nint RMaxQy[MAX * 4];\nint left[MAX * 4];\nint right[MAX * 4];\nlong long int ans=0;\n\nvoid MergeSort(int n[],int _x[],int _y[], int left, int right) {\n\tint mid;\n\tif (left == right)return;\n\tmid = (left + right) / 2;\n\tMergeSort(n,_x,_y, left, mid);\n\tMergeSort(n,_x,_y, mid + 1, right);\n\tfor (int i = left; i <= mid; i++) {\n\t\tbox[i] = n[i];\n\t\tbox_x[i] = _x[i];\n\t\tbox_y[i] = _y[i];\n\t}\n\tfor (int i = mid + 1, j = right; i <= right; i++, j--) {\n\t\tbox[i] = n[j];\n\t\tbox_x[i] = _x[j];\n\t\tbox_y[i] = _y[j];\n\t}\n\tint a = left, b = right;\n\tfor (int i = left; i <= right; i++) {\n\t\tif (box[a] <= box[b]) {\n\t\t\tn[i] = box[a];\n\t\t\t_x[i] = box_x[a];\n\t\t\t_y[i] = box_y[a++];\n\t\t}\n\t\telse {\n\t\t\tn[i] = box[b];\n\t\t\tx[i] = box_x[b];\n\t\t\ty[i] = box_y[b--];\n\t\t}\n\t}\n}\n\nint max(int a, int b) {\n\tif (a > b)return a;\n\treturn b;\n}\n\nint min(int a, int b) {\n\tif (a < b)return a;\n\treturn b;\n}\n\nint SegMax(int x[],int a) {\n\tif (a < child) {\n\t\tx[a] = max(SegMax(x,a * 2),SegMax(x, a * 2 + 1));\n\t}\n\treturn x[a];\n}\n\nint SegMin(int x[],int a) {\n\tif (a < child) {\n\t\tx[a] = min(SegMin(x, a * 2), SegMin(x, a * 2 + 1));\n\t}\n\treturn x[a];\n}\n\nint RangeL(int l[],int a) {\n\tif (a < child) {\n\t\tl[a] = min(RangeL(l, a * 2),RangeL(l,a*2+1));\n\t}\n\treturn l[a];\n}\n\nint RangeR(int r[], int a) {\n\tif (a < child) {\n\t\tr[a] = max(RangeR(r, a * 2), RangeR(r, a * 2 + 1));\n\t}\n\treturn r[a];\n}\n\nint RMinQ(int n[],int a, int b,int num) {\n\tif (a > right[num] || b < left[num])return INT_MAX;\n\tif (a <= left[num] && b >= right[num])return n[num];\n\treturn min(RMinQ(n, a, b, num * 2), RMinQ(n, a, b, num * 2 + 1));\n}\n\nint RMaxQ(int n[],int a, int b,int num) {\n\tif (a > right[num] || b < left[num])return 0;\n\tif (a <= left[num] && b >= right[num])return n[num];\n\treturn max(RMaxQ(n, a, b, num * 2), RMaxQ(n, a, b, num * 2 + 1));\n}\n\nint main() {\n\tscanf(\"%d %d\", &star, &dif);\n\tfor (int i = 0; i < star; i++) {\n\t\tscanf(\"%d %d %d\", &x[i], &y[i], &blight[i]);\n\t}\n\twhile (1) {\n\t\tif (fig >= star) {\n\t\t\tchild = fig;\n\t\t\tbreak;\n\t\t}\n\t\tfig *= 2;\n\t}\n\tMergeSort(blight,x,y, 0, star - 1);\n\tfor (int i = 0; i < star; i++) {\n\t\tRMaxQx[child + i] = x[i];\n\t\tRMinQx[child + i] = x[i];\n\t\tRMaxQy[child + i] = y[i];\n\t\tRMinQy[child + i] = y[i];\n\t}\n\tfor (int i = star; i < child; i++) {\n\t\tRMaxQx[child + i] = 0;\n\t\tRMinQx[child + i] = INT_MAX;\n\t\tRMaxQy[child + i] = 0;\n\t\tRMinQy[child + i] = INT_MAX;\n\t}\n\tSegMax(RMaxQx, 1);\n\tSegMax(RMaxQy, 1);\n\tSegMin(RMinQx, 1);\n\tSegMin(RMinQy, 1);\n\n\t//printf(\"%d %d %d %d\\n\", RMaxQx[1], RMaxQy[1], RMinQx[1], RMinQy[1]);\n\n\tfor (int i = 0; i < child; i++) {\n\t\tleft[child + i] = i;\n\t\tright[child + i] = i;\n\t}\n\n\tRangeR(right, 1);\n\tRangeL(left, 1);\n\n\t//for (int i = 1; i < child; i++) {\n\t//\tprintf(\"%d %d\\n\", left[i], right[i]);\n\t//}\n\n\tfor (int i = 1; i < star; i++) {\n\t\tif (blight[i] - blight[0] > dif) break;\n\t\tend[0] = i;\n\t}\n\tfor (int i = 1; i < star; i++) {\n\t\tfor (int j = end[0]; j < star; j++) {\n\t\t\tif (blight[j] - blight[i] > dif) break;\n\t\t\tend[i] = j;\t\n\t\t}\n\t//\tprintf(\"%d\\n\", end[i]);\n\t}\n\tfor (int i = 0; i < star; i++) {\n\t/*\tprintf(\"%d\\n\", RMaxQ(RMaxQx, i, end[i], 1));*/\n\t\t//printf(\"%lld\\n\", (long long int)(RMaxQ(RMaxQx, i, end[i], 1) - (long long int)RMinQ(RMinQx, i, end[i], 1))*((long long int)RMaxQ(RMaxQy, i, end[i], 1) - (long long int)RMinQ(RMinQy, i, end[i], 1)));\n\t\tif (ans < (long long int)(RMaxQ(RMaxQx, i, end[i], 1) - (long long int)RMinQ(RMinQx, i, end[i], 1))*((long long int)RMaxQ(RMaxQy, i, end[i], 1) - (long long int)RMinQ(RMinQy, i, end[i], 1))) {\n\t\t\tans = (long long int)(RMaxQ(RMaxQx, i, end[i], 1) - (long long int)RMinQ(RMinQx, i, end[i], 1))*((long long int)RMaxQ(RMaxQy, i, end[i], 1) - (long long int)RMinQ(RMinQy, i, end[i], 1));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define int long long int\n#define rep(a,b,c) for(int a=b;a<c;a++)\n#define repm(a,b,c) for(int a=(b-1);a>=c;a--)\n#define pb push_back\n#define str string\n#define sf(a) scanfs(\"%d\",&a)\n#define pb push_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n#define clean(used) memset(used,false,sizeof(used))\nusing namespace std;\n\nstatic const int INF = 1e18 + 9;\nstatic const int Mod = 1e9 + 7;\ninline int replac(str s){double ans=0;rep(i,0,s.length()){ans+=(s[i]-'0')*pow(10,s.length()-i-1);}return (int)ans;}\ninline string numstr(int m){str s=\"\";while(m>0){char c;int a=m/10;if(a>0)a=m%(a*10);else a=m;c=(char)('0'+a);s+=c;m/=10;}str st=\"\";for(int i=s.size()-1;i>=0;i--){st+=s[i];}return st;}\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\n\nstatic const int MAX_N = 200002;\n\nstruct Seg{\n    int n;\n    int dat[MAX_N * 2];\n    void init(int n_){\n        init(n_ , INF);\n    }\n\n    void init(int n_, int d){\n        n = 1;\n        while(n < n_)n *= 2;\n        fill(dat, dat + MAX_N * 2, d);\n    }\n};\n\nstruct Segment : Seg {\n    int Min(int s,int t){\n        return Min(s,t,0,0,n);\n    }\n    int Min(int s, int t, int k, int l, int r){\n        if(r <= s || t <= l) return INF;\n        if(s <= l && r <= t) return dat[k];\n\n        int t1 = Min(s, t, k * 2 + 1, l, (l + r)/2);\n        int t2 = Min(s, t, k * 2 + 2, (l + r)/2, r);\n        return min(t1, t2);\n    }\n    void update(int k, int x){\n        k += n - 1;\n        dat[k] = min(dat[k], x);\n        while(0 < k){\n            k = (k - 1)/2;\n            dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n};\n\nSegment x_1,x_2,y_1,y_2;\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int d,m;\n    cin >> m >> d;\n    x_1.init(m);\n    x_2.init(m);\n    y_1.init(m);\n    y_2.init(m);\n    int b_max = 0;\n    int x,y,b;\n    rep(i,0,m){\n        cin >> x >> y >> b;\n        x_1.update(b,x);\n        x_2.update(b,-x);\n        y_1.update(b,y);\n        y_2.update(b,-y);\n    }\n    int ans = 0,x_mi,x_ma,y_mi,y_ma;\n    rep(i,0,MAX_N-d-1){\n        x_mi = x_1.Min(i,i+d+1);\n        x_ma = x_2.Min(i,i+d+1);\n        y_mi = y_1.Min(i,i+d+1);\n        y_ma = y_2.Min(i,i+d+1);\n        ans = max(ans, abs(x_ma+x_mi)*abs(y_ma+y_mi));\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define repp(i,k,n) for(int i=k;i<(int)n;i++)\n#define rei(n) for(int i=0;i<(int)n;i++)\n#define rel(n) for(int l=0;l<(int)n;l++)\n//#define int long long\n#define al(s) s.begin(),s.end()\n#define INT_MAX 2147483647\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> ppi;\ntypedef pair<int, ppi> pipp;\ntypedef pair<int, pi> pip;\ntypedef pair<long long, pi> llpi;\n\nstruct SegTree\n{\n\tint N;\n\tvector<int> Seg;\n\tvoid init(int n)\n\t{\n\t\tN = 1;\n\t\twhile (N < n)N *= 2;\n\t\tfor (int i = 0; i < N * 2; i++)\n\t\t{\n\t\t\tSeg.push_back(INT_MAX);\n\t\t}\n\n\t}\n\n\tvoid update(int k, int a)\n\t{\n\t\tk = k - 1 + N;\n\t\tSeg[k] = a;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\tSeg[k] = min(Seg[2 * k + 1], Seg[2 * k + 2]);\n\t\t}\n\t}\n\tint find_min(int a, int b)\n\t{\n\t\treturn query(a, b, 0, 0, N);\n\t}\n\n\tint query(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || l >= b)return INT_MAX;\n\t\tif (l >= a&&r <= b)\n\t\t{\n\t\t\treturn Seg[k];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn min(query(a, b, k * 2 + 1, l, (r + l) / 2),\n\t\t\t\tquery(a, b, k * 2 + 2, (r + l) / 2, r));\n\t\t}\n\t}\n};\n\nSegTree ss[4];//min,max\n\nvector<llpi> s;\nvector<long long > a;\nint  main()\n{\n\tlong long ans = 0;\n\tlong long n, d;\n\tcin >> n >> d;\n\trei(4)ss[i].init(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlong long b;\n\t\tint x, y;\n\t\tcin >> x >> y >> b;\n\t\ts.push_back(llpi(b, pi(x, y)));\n\t}\n\tsort(al(s));\n\tfor (int i = 0; i < s.size(); i++)a.push_back(s[i].first);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tss[0].update(i, s[i].second.first);\n\t\tss[2].update(i, s[i].second.first*(-1));\n\n\t\tss[1].update(i, s[i].second.second);\n\t\tss[3].update(i, s[i].second.second*(-1));\n\t}\n\t//bool end = false;\n\tfor (vector<long long >::iterator i = a.begin();;)\n\t{\n\t\tvector<long long>::iterator E;\n\t\tE = upper_bound(al(a), (long long)(*i + d));\n\t\tint AA, BB;\n\t\tAA = i - a.begin();\n\t\tBB = E - a.begin();\n\t\ti = upper_bound(al(a),(long long)(*i));\n\t\t//cout << AA << \" \" << BB << endl;\n\t\tans = max(ans,\n\t\t\t(long long)((-1)*ss[2].find_min(AA, BB) - ss[0].find_min(AA, BB))\n\t\t\t*(long long)((-1)*ss[3].find_min(AA, BB) - ss[1].find_min(AA, BB)));\n\t\tif (E == a.end())break;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\nconst ll INF=1e16;\n\n\nstruct Star{\n    ll x,y,b;\n    Star(ll x=0,ll y=0,ll b=0) :\n        x(x),y(y),b(b){}\n    bool operator<(const Star &rth) const {\n        return std::tie(b,x,y)<std::tie(rth.b,rth.x,rth.y);\n    }\n};\n\nstruct SegTree {\n    ll n;\n    vector<ll> min_dat;\n    vector<ll> max_dat;\n    SegTree(ll N) {\n        n=1;\n        while(n<N) n*=2;\n        min_dat.assign(1<<18,INF);\n        max_dat.assign(1<<18,0);\n    }\n\n    void update(int k,ll a) {\n        k+=n-1;\n        min_dat[k]=a;\n        max_dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            min_dat[k]=min(min_dat[k*2+1],min_dat[k*2+2]);\n            max_dat[k]=max(max_dat[k*2+1],max_dat[k*2+2]);\n        }\n    }\n\n    ll min_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return INF;\n\n        if(a<=l&&r<=b) return min_dat[k];\n        else {\n            int vl=min_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=min_query(a,b,k*2+2,(l+r)/2,r);\n            return min(vl,vr);\n        }\n    }\n\n    ll max_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return 0;\n\n        if(a<=l&&r<=b) return max_dat[k];\n        else {\n            int vl=max_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=max_query(a,b,k*2+2,(l+r)/2,r);\n            return max(vl,vr);\n        }\n    }\n\n    void dump() {\n        rep(i,n) cout<<max_dat[i]<<\" \";\n        cout<<endl;\n    }\n\n};\nint N,d;\n\n\nvector<Star> stars;\n\nint find(int x) {\n    int l=0;\n    int r=stars.size()-1;\n    while(r-l>1) {\n        int mid=(l+r)/2;\n        if(stars[mid].b<x) l=mid;\n        else r=mid;\n    }\n    return r;\n}\nint main() {\n    cin>>N>>d;\n    rep(i,N) {\n        Star s;\n        cin>>s.x>>s.y>>s.b;\n        stars.pb(s);\n    }\n    SegTree segTreeX(N);\n    SegTree segTreeY(N);\n\n    sort(all(stars));\n\n    rep(i,stars.size()) {\n        // printf(\"%d %d %d %d\\n\",i,stars[i].x,stars[i].y,stars[i].b);\n        segTreeX.update(i,stars[i].x);\n        segTreeY.update(i,stars[i].y);\n    }\n\n\n    ll ans=0;\n    int n=segTreeX.n;\n    rep(i,stars.size()) {\n        // int pos=find(stars[i].b+d);\n        Star s=stars[i];\n        s.b+=d;\n        s.x=s.y=-INF;\n        int pos=upper_bound(all(stars),s)-stars.begin();\n        if(pos==i) continue;\n        if(pos==N) pos--;\n        ll tmp=0;\n        tmp=segTreeX.max_query(i,pos+1,0,0,n)-segTreeX.min_query(i,pos+1,0,0,n);\n        tmp*=segTreeY.max_query(i,pos+1,0,0,n)-segTreeY.min_query(i,pos+1,0,0,n);\n\n        // cout<<i<<\",\"<<stars[i].b+d<<\",\"<<pos<<\",\"<<tmp<<endl;\n        ans = max(ans,tmp);\n\n    }\n\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i <(n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nP tx[1 << 19];\nP ty[1 << 19];\n\nP update(P* t, int i, int x, int k, int l, int r){\n\tif(i < l || r <= i){\n\t\treturn t[k];\n\t}\n\tif(i <= l && r <= i + 1){\n\t\treturn t[k] = P(x, x);\n\t}\n\tint m = (l + r) / 2;\n\tP p = update(t, i, x, 2 * k + 1, l, m);\n\tP q = update(t, i, x, 2 * k + 2, m, r);\n\treturn t[k] = P(\n\t\tmin(p.first, q.first),\n\t\tmax(p.second, q.second)\n\t);\n}\nvoid update(P* t, int i, int x){\n\tupdate(t, i, x, 0, 0, 1 << 18);\n}\n\nP query(P* t, int a, int b, int k, int l, int r){\n\tif(b <= l || r <= a){\n\t\treturn P(1e7, 0);\n\t}\n\tif(a <= l && r <= b){\n\t\treturn t[k];\n\t}\n\tint m = (l + r) / 2;\n\tP p = query(t, a, b, 2 * k + 1, l, m);\n\tP q = query(t, a, b, 2 * k + 2, m ,r);\n\treturn P(\n\t\tmin(p.first, q.first),\n\t\tmax(p.second, q.second)\n\t);\n}\nP query(P* t, int a, int b){\n\treturn query(t, a, b, 0, 0, 1 << 18);\n}\n\nint n;\nint d;\nint x[200000];\nint y[200000];\nP b[200000];\n\nint main(){\n\tcin >> n >> d;\n\trep(i, n){\n\t\tint v;\n\t\tcin >> x[i] >> y[i] >> v;\n\t\tb[i] = P(v, i);\n\t}\n\tsort(b, b + n);\n\trep(i, n){\n\t\tupdate(tx, i, x[b[i].second]);\n\t\tupdate(ty, i, y[b[i].second]);\n\t}\n\tll ans = 0;\n\tint s = 0, t = 0;\n\twhile(s <  n){\n\t\twhile(t < n && b[t].first <= b[s].first + d){\n\t\t\t++t;\n\t\t}\n\t\tP p = query(tx, s, t);\n\t\tP q = query(ty, s, t);\n\t\tll dx = p.second - p.first;\n\t\tll dy = q.second - q.first;\n\t\tans = max(dx * dy, ans);\n\t\t++s;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define repp(i,k,n) for(int i=k;i<(int)n;i++)\n#define rei(n) for(int i=0;i<(int)n;i++)\n#define rel(n) for(int l=0;l<(int)n;l++)\n#define int long long\n#define al(s) s.begin(),s.end()\n#define INT_MAX 2147483647\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> ppi;\ntypedef pair<int, ppi> pipp;\ntypedef pair<int, pi> pip;\ntypedef pair<long long, pi> llpi;\n\nstruct SegTree\n{\n\tint N;\n\tvector<int> Seg;\n\tvoid init(int n)\n\t{\n\t\tN = 1;\n\t\twhile (N < n)N *= 2;\n\t\tfor (int i = 0; i < N*2; i++)\n\t\t{\n\t\t\tSeg.push_back(INT_MAX);\n\t\t}\n\t\t\n\t}\n\t\n\tvoid update(int k, int a)\n\t{\t\n\t\tk = k - 1 + N;\n\t\tSeg[k] = a;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\tSeg[k] = min(Seg[2 * k + 1], Seg[2 * k + 2]);\n\t\t}\n\t}\n\tint find_min(int a, int b)\n\t{\n\t\treturn query(a, b, 0, 0, N);\n\t}\n\n\tint query(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || l >= b)return INT_MAX;\n\t\tif (l>=a&&r<=b)\n\t\t{\n\t\t\treturn Seg[k];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn min(query(a, b, k * 2 + 1, l, (r + l) / 2),\n\t\t\t\t\t   query(a, b, k * 2 + 2, (r + l) / 2, r));\n\t\t}\n\t}\n};\n\nSegTree ss[4];//min,max\n\nvector<llpi> a;\nset<long long> s;\nsigned main()\n{\n\tlong long ans = 0;\n\tlong long n, d;\n\tcin >> n >> d;\n\trei(4)ss[i].init(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlong long b;\n\t\tint x, y;\n\t\tcin >> x >> y >> b;\n\t\ta.push_back(llpi(b, pi(x, y)));\n\t\ts.insert(b);\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint jj = 0;\n\t\tset<long long> ::iterator it = s.find(a[i].first);\n\t\tfor (set<long long>::iterator l = s.begin(); l != it; l++)\n\t\t{\n\t\t\tjj++;\n\t\t}\n\t\t\n\t\tss[0].update(jj, min(a[i].second.first, ss[0].Seg[jj + ss[0].N - 1]));\n\t\tss[2].update(jj, min(a[i].second.first*(-1), ss[2].Seg[jj + ss[0].N - 1]));\n\n\t\tss[1].update(jj, min(a[i].second.second, ss[1].Seg[jj + ss[0].N - 1]));\n\t\tss[3].update(jj, min(a[i].second.second*(-1), ss[3].Seg[jj + ss[0].N - 1]));\n\n\t}\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tset<long long>::iterator it, ne;\n\t\tit = s.begin();\n\t\tfor (int l = 0; l < i; l++)it++;\n\t\tne = s.upper_bound(*it + d);\n\t\tne--;\n\t\tint coun = 0;\n\t\tfor (; it != ne; it++)coun++;\n\t\tcoun += i;\n\t\tcoun++;\n\t\tans = max( ans, ((-1) * ss[2].find_min(i, coun) - ss[0].find_min(i, coun)) * ((-1) * ss[3].find_min(i, coun) - ss[1].find_min(i, coun)) );\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio> \n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n\nstruct stars\n{\n\tint maxx,minx;\n\tint maxy,miny;\n};\n\n\nsigned main()\n{\n\tmap<int, stars> data;\n\tint n, d;\n//\tscanf(\"%llu %llu\", &n, &d);\n\tscanf(\"%d%d\", &n, &d);\n\n\tstars foo; int x, y, b;\n\tfor (int i = 0; i < n; ++i)\n\t{\n//\t\tscanf(\"%llu %llu %llu\", &x, &y, &b);\n\t\tscanf(\"%d%d%d\", &x, &y, &b);\n\t\tif (data.count(b) == 0)\n\t\t{\n\n\t\t\tdata[b].maxx = x;\n\t\t\tdata[b].minx = x;\n\t\t\tdata[b].maxy = y;\n\t\t\tdata[b].miny = y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdata[b].maxx = max(data[b].maxx, x);\n\t\t\tdata[b].minx = min(data[b].minx, x);\n\t\t\tdata[b].maxy = max(data[b].maxy, y);\n\t\t\tdata[b].miny = max(data[b].miny, y);\n\t\t}\n\t}\n\n\tint ans=0;\n\tstars vec;\n//\tprintf(\"%llu\\n\", vec.maxx);\n\n\tfor (auto itr = data.begin();itr != data.end();++itr)\n\t{\n\t\tauto a = *itr;\n\t\tfor (int i = a.first; i < d; ++i)\n\t\t{\n\t\t\tif (data.count(i) == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvec.maxx = max(vec.maxx, a.second.maxx);\n\t\t\tvec.minx = min(vec.minx, a.second.minx);\n\t\t\tvec.maxy = max(vec.maxy, a.second.maxy);\n\t\t\tvec.miny = min(vec.miny, a.second.miny);\n\t\n\t\t}\n\t\tans = max(ans, (vec.maxx - vec.minx)*(vec.maxy - vec.miny));\n\t}\n\n//\tprintf(\"%I64u\\n\",ans);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<stack>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<tuple>\n#include<utility>\n#include<set>\n#include<queue>\n#include<iomanip>\n#include<iterator>\n//#include<chrono>\n//cout<<setprecision(12)\n//fixed\n//#include<random>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\nconst llint big=1e15+100000;\nconst int mod=1e9+7;\nconst lldo eps=1e-9;\nconst long double pai=3.141592653589793238462643;\n#define mt make_tuple\n#define mp make_pair\n#define fir first\n#define sec second\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define res resize\n#define ins insert\n#define era erase\n#define dme(in) cout<<in<<endl;return 0\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nint main(void){\n\tint i,n,d,j=0;cin>>n>>d;\n\tllint ans=0;\n\tvector<tuple<llint,llint,llint>> a(n);\n\tfor(i=0;i<n;i++){cin>>get<1>(a[i])>>get<2>(a[i])>>get<0>(a[i]);}\n\tsort(a.begin(),a.end());\n\tmultiset<llint>x;\n\tmultiset<llint>y;\n\tfor(i=0;i<n;i++){\n\t\tx.ins(get<1>(a[i]));\n\t\ty.ins(get<2>(a[i]));\n\t\tfor(;j<n;j++){\n\t\t\tif(get<0>(a[j])>=get<0>(a[i])-d){break;}\n\t\t\tx.era(x.lower_bound(get<1>(a[j])));\n\t\t\ty.era(y.lower_bound(get<2>(a[j])));\n\t\t}\n\t\tmaxeq(ans,((*prev(x.end()))-(*x.begin()))*((*prev(y.end()))-(*y.begin())));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct SegTree { // ??????min,max\n\tint n;\n\tvector<int> Max;\n\tvector<int> Min;\n\n\tvoid init(int n_)\n\t{\n\t\tn = 1;\n\t\twhile (n < n_) n *= 2;\n\n\t\tMax.resize(2 * n);\n\t\tMin.resize(2 * n);\n\n\t\tfor (int i = 0; i < 2 * n - 1; ++i) {\n\t\t\tMax[i] = -inf;\n\t\t\tMin[i] = inf;\n\t\t}\n\t}\n\n\tvoid min_update(int idx, int val)\n\t{\n\t\tidx += n - 1;\n\t\tMin[idx] = val;\n\n\t\twhile (idx > 0) {\n\t\t\tidx = (idx - 1) / 2;\n\t\t\tMin[idx] = min(Min[idx * 2 + 1], Min[idx * 2 + 2]);\n\t\t}\n\t}\n\n\tvoid max_update(int idx, int val)\n\t{\n\t\tidx += n - 1;\n\t\tMax[idx] = val;\n\n\t\twhile (idx > 0) {\n\t\t\tidx = (idx - 1) / 2;\n\t\t\tMax[idx] = max(Max[idx * 2 + 1], Max[idx * 2 + 2]);\n\t\t}\n\t}\n\n\tint get_min(int a, int b, int k = 0, int l = 0, int r = -1) // [a, b)???min\n\t{\n\t\tif (r == -1) r = n;\n\n\t\tif (r <= a || b <= l) return inf;\n\n\t\tif (a <= l && r <= b) return Min[k];\n\n\t\tint vl = get_min(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = get_min(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn min(vl, vr);\n\t}\n\n\tint get_max(int a, int b, int k = 0, int l = 0, int r = -1) // [a, b)???max\n\t{\n\t\tif (r == -1) r = n;\n\n\t\tif (r <= a || b <= l) return -inf;\n\n\t\tif (a <= l && r <= b) return Max[k];\n\n\t\tint vl = get_max(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = get_max(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn max(vl, vr);\n\t}\n};\n\nint X[200020], Y[200020];\n\nsigned main()\n{\n\tint N, d; scanf(\"%d%d\", &N, &d);\n\n\tSegTree x_seg, y_seg;\n\n\tx_seg.init(N), y_seg.init(N);\n\n\tvpii hoge;\n\n\trep(i, N) {\n\t\tint x, y, b; scanf(\"%d%d%d\", &x, &y, &b);\n\t\tX[i] = x, Y[i] = y;\n\n\t\thoge.PB(pii(b, i));\n\t}\n\n\tsort(all(hoge));\n\n\trep(i, N) {\n\t\tx_seg.min_update(i, X[hoge[i].scd]);\n\t\tx_seg.max_update(i, X[hoge[i].scd]);\n\n\t\ty_seg.min_update(i, Y[hoge[i].scd]);\n\t\ty_seg.max_update(i, Y[hoge[i].scd]);\n\t}\n\n\tll ans = -inf;\n\n\trep(i, N) {\n\t\tif (i > 0 && hoge[i].fst == hoge[i - 1].fst) continue;\n\n\t\tint b = hoge[i].fst;\n\n\t\tint idx = upper_bound(all(hoge), pii(b + d, inf)) - hoge.begin();\n\n\t\tint min_x = x_seg.get_min(i, idx);\n\t\tint max_x = x_seg.get_max(i, idx);\n\n\t\tint min_y = y_seg.get_min(i, idx);\n\t\tint max_y = y_seg.get_max(i, idx);\n\n\t\tans = max(ans, 1ll * (max_x - min_x) * (max_y - min_y));\n\t}\n\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int LL\ntypedef long long LL;\nconst int INF = 2002002002;\n\nstruct DATA {\n\tint minx, miny, maxx, maxy;\n};\n\nstruct STAR {\n\tint x, y, b;\n\tbool operator < (const STAR &t) const {\n\t\treturn b < t.b;\n\t}\n};\n\nint n, d;\nSTAR star[1 << 18];\n\nint N;\nDATA data[1 << 19];\n\n\nvoid init(int n)\n{\n\tfor (N = 1; N < n; N <<= 1);\n\tfill(data, data + N * 2 - 1, (DATA){INF, INF, -INF, -INF});\n}\n\nvoid update(int i, STAR s)\n{\n\ti += N - 1;\n\tdata[i].minx = min(data[i].minx, s.x);\n\tdata[i].miny = min(data[i].miny, s.y);\n\tdata[i].maxx = max(data[i].maxx, s.x);\n\tdata[i].maxy = max(data[i].maxy, s.y);\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tdata[i].minx = min(data[i].minx, s.x);\n\t\tdata[i].miny = min(data[i].miny, s.y);\n\t\tdata[i].maxx = max(data[i].maxx, s.x);\n\t\tdata[i].maxy = max(data[i].maxy, s.y);\n\t}\n}\n\nDATA query(int a, int b, int k, int l, int r)\n{\n\t//printf(\"%d %d %d %d %d\\n\", a, b, k, l, r);\n\tif (r <= a || b <= l) return (DATA){INF, INF, -INF, -INF};\n\tif (a <= l && r <= b) return data[k];\n\tDATA vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tDATA vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn (DATA){min(vl.minx, vr.minx), min(vl.miny, vr.miny), max(vl.maxx, vr.maxx), max(vl.maxy, vr.maxy)};\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tinit(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d %d\", &star[i].x, &star[i].y, &star[i].b);\n\t\t--star[i].x; --star[i].y;\n\t}\n\tstar[n].b = INF;\n\t\n\tsort(star, star + n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tupdate(i, star[i]);\n\t}\n\t\n\t//printf(\"%lld\\n\", (LL)INF * INF);\n\t\n\tLL res = 0;\n\tfor (int l = 0; l < n; ){\n\t\tint r = l;\n\t\twhile (star[r].b - star[l].b <= d) r++;\n\t\t\n\t\tDATA q = query(l, r, 0, 0, N);\n\t\tLL t = (LL)(q.maxx - q.minx) * (q.maxy - q.miny);\n\t\tres = max(res, t);\n\t\t\n\t\tl++;\n\t\twhile (star[l + 1].b == star[l].b) l++;\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\nstruct SegmentTree {\n\tint init_val;\n\tint n;\n\tvector<int> dat;\n\t\n\tSegmentTree(int _n) {\n\t\tinit_val = INF;\n\t\tn = 1;\n\t\twhile (n < _n) n *= 2;\n\t\tdat.clear();\n\t\tdat.resize(2 * n - 1, init_val);\n\t}\n\t\n\tvoid update(int k, int a) {\n\t\tk += n - 1;\n\t\tdat[k] = min(dat[k], a);\n\t\t\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = min(dat[2 * k + 1], dat[2 * k + 2]);\n\t\t}\n\t}\n\t\n\tint query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return init_val;\n\t\tif (a <= l && r <= b) return dat[k];\n\t\treturn min(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t\n\tint query(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\n\ntypedef pair<int, int> pii;\ntypedef pair<int , pii> pip;\ntypedef SegmentTree Seg;\ntypedef long long ll;\n\nint main() {\n\tint n, d;\n\tcin >> n >> d;\n\tvector<pip> stars(n);\n\tREP(i, n) {\n\t\tint x, y, b;\n\t\tscanf(\"%d %d %d\", &x, &y, &b);\n\t\tstars[i] = pip(b, pii(x, y));\n\t}\n\tsort(stars.begin(), stars.end());\n\t\n\tSeg up(n), down(n), right(n), left(n);\n\tREP(i, n) {\n\t\tint x = stars[i].second.first;\n\t\tint y = stars[i].second.second;\n\t\t\n\t\tup.update(i, -y);\n\t\tdown.update(i, y);\n\t\tright.update(i, -x);\n\t\tleft.update(i, x);\n\t}\n\t\n\tint st = 0, en = 0;\n\tll ans = 0;\n\t\n\twhile (st < n) {\n\t\tif (en - st > 0 && stars[en].first - stars[st].first <= d) {\n\t\t\tll  s = (ll)(-up.query(st, en + 1) - down.query(st, en + 1))\n\t\t\t\t    * (-right.query(st, en + 1) - left.query(st, en + 1));\n\t\t\tans = max(ans, s);\n\n\t\t\tif (en == n - 1) st++;\n\t\t\telse en++;\n\t\t\t\n\t\t}\n\t\telse if (stars[en].first - stars[st].first > d) st++;\n\t\telse if (en < n - 1) en++;\n\t\telse st++;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\tint N, d;\n\tcin>>N>>d;\n\tvector<P(ll, P)> h(N);\n\tpriority_queue<ll> q;\n\tset<ll> s;\n\tREP(i, N) {\n\t\tll x, y, b;\n\t\tcin>>x>>y>>b;\n\t\th[i].first = b;\n\t\th[i].second.first = x;\n\t\th[i].second.second = y;\n\t\tif(!s.count(b)) {\n\t\t\ts.insert(b);\n\t\t\tq.push(b);\n\t\t}\n\t}\n\tsort(ALL(h));\n\tll ite = 0;\n\tll ans = 0;\n\tpriority_queue<P> ux;\n\tpriority_queue<P> lx;\n\tpriority_queue<P> uy;\n\tpriority_queue<P> ly;\n\tREP(i, q.size()) {\n\t\tll lbr = q.top();\n\t\tq.pop();\n\t\twhile(h[ite].first <= lbr + d) {\n\t\t\tux.push(P(h[ite].second.first, h[ite].first));\n\t\t\tlx.push(P(-(h[ite].second.first), h[ite].first));\n\t\t\tuy.push(P(h[ite].second.second, h[ite].first));\n\t\t\tly.push(P(-(h[ite].second.second), h[ite].first));\n\t\t\t++ite;\n\t\t}\n\t\tll maxx = -1, maxy = -1, minx = -1, miny = -1;\n\n\t\twhile(!ux.empty()) {\n\t\t\tP hoge = ux.top();\n\t\t\tif(hoge.second >= lbr && hoge.second <= lbr + d) {\n\t\t\t\tmaxx = hoge.first;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tux.pop();\n\t\t\t}\n\t\t} while(!lx.empty()) {\n\t\t\tP hoge = lx.top();\n\t\t\tif(hoge.second >= lbr && hoge.second <= lbr + d) {\n\t\t\t\tminx = -(hoge.first);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlx.pop();\n\t\t\t}\n\t\t} while(!uy.empty()) {\n\t\t\tP hoge = uy.top();\n\t\t\tif(hoge.second >= lbr && hoge.second <= lbr + d) {\n\t\t\t\tmaxy = hoge.first;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tuy.pop();\n\t\t\t}\n\t\t} while(!ly.empty()) {\n\t\t\tP hoge = ux.top();\n\t\t\tif(hoge.second >= lbr && hoge.second <= lbr + d) {\n\t\t\t\tminy = -(hoge.first);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tly.pop();\n\t\t\t}\n\t\t}\n\t\tans = max(ans, (maxx - minx) * (maxy - miny));\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, d;\n  cin >> n >> d;\n  vint x(n), y(n), b(n);\n  rep(i, n) {\n    cin >> x[i] >> y[i] >> b[i];\n  }\n  vint id(n);\n  iota(all(id), 0);\n  sort(all(id), [&](int i, int j){\n      return b[i] < b[j];\n    });\n  int ans = 0;\n  priority_queue<Pi> maxX, maxY;\n  priority_queue<Pi, vector<Pi>, greater<Pi> > minX, minY;\n  for(int i : id) {\n    maxX.emplace(x[i], i);\n    minX.emplace(x[i], i);\n    maxY.emplace(y[i], i);\n    minY.emplace(y[i], i);\n    while(llabs(b[maxX.top().second]-b[i]) > d) maxX.pop();\n    while(llabs(b[minX.top().second]-b[i]) > d) minX.pop();\n    while(llabs(b[maxY.top().second]-b[i]) > d) maxY.pop();\n    while(llabs(b[minY.top().second]-b[i]) > d) minY.pop();\n    int a = maxX.top().first;\n    int b = minX.top().first;\n    int c = maxY.top().first;\n    int d = minY.top().first;\n    chmax(ans, (a-b)*(c-d));\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1<<29)\ntypedef long long ll;\n\nstruct MinSegtree\n{\n  int n;\n  int dat[800005];\n  MinSegtree(int _n)\n  {\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*21;i++)\n      dat[i] = INF;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n\n  int query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return INF;\n\n    if(a <= l && r <= b) return dat[k];\n    else{\n      int vl = query(a, b, k*2+1, l, (l + r) / 2);\n      int vr = query(a, b, k*2+2, (l + r) / 2, r);\n      return min(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nstruct MaxSegtree\n{\n  int n;\n  int dat[800005];\n  MaxSegtree(int _n){\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*2-1;i++)\n      dat[i] = -1;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n  \n  int query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return -1;\n    \n    if(a <= l && r <=b ) return dat[k];\n    else{\n      int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n      int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n      return max(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nint main()\n{\n  int n, d;\n  scanf(\"%d%d\", &n, &d);\n  MinSegtree minx(n);\n  MinSegtree miny(n);\n  MaxSegtree maxx(n);\n  MaxSegtree maxy(n);\n  \n  vector<pair<int, pair<int, int> > >s(n);\n  vector<int>br(n);\n  for(int i=0;i<n;i++){\n    int x, y, b;\n    scanf(\"%d%d%d\", &x, &y, &b);\n    s[i] = make_pair(b, make_pair(x, y));\n    br[i] = b;\n  }\n  sort(s.begin(), s.end());\n  sort(br.begin(), br.end());\n\n\n  for(int i=0;i<n;i++){\n    minx.update(i, s[i].second.first);\n    maxx.update(i, s[i].second.first);\n    miny.update(i, s[i].second.second);\n    maxy.update(i, s[i].second.second);\n  }\n\n  br.push_back(INF);\n  ll res = 0;\n  for(int i=0;i<n;i++){\n    int pos = (int)(upper_bound(br.begin(), br.end(), br[i] + d) - br.begin());\n    int w = maxx.query(i, pos, 0, 0, maxx.size()) - minx.query(i, pos, 0, 0, minx.size());\n    int h = maxy.query(i, pos, 0, 0, maxy.size()) - miny.query(i, pos, 0, 0, miny.size());\n    res = max(res, (ll)w * (ll)h);\n  }\n\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pi;\n#define F first\n#define S second\nconst int N=2e5+10;\nstruct star{\n    pi pos;\n    int light;\n    void in(){\n        scanf(\"%d%d%d\",&pos.F,&pos.S,&light);\n        return ;\n    }\n};\nstruct cmp{\n    bool operator()(const star &a,const star &b){\n        return a.light>b.light;\n    }\n};\nint min(int a,int b){return a>b?b:a;}\nlong long int max(long long int a,long long int b){return a>b?a:b;}\nint main(){\n    int n,d,low=0;\n    long long int ans=0;\n    star temp;\n    priority_queue<star,vector<star>,cmp> pq;\n    priority_queue<pi,vector<pi>,greater<pi>>l,b;\n    priority_queue<pi> u,r;\n    scanf(\"%d%d\",&n,&d);\n    for(int i=0;i<n;i++){\n        temp.in();\n        pq.push(temp);\n        low=min(low,temp.light);\n    }\n    low+=d;\n    while(!pq.empty()){\n        while(pq.top().light<=low){\n            temp=pq.top();\n            pq.pop();\n            u.push({temp.pos.F,temp.light});\n            b.push({temp.pos.F,temp.light});\n            l.push({temp.pos.S,temp.light});\n            r.push({temp.pos.S,temp.light});\n            if(pq.empty())break;\n        }\n        while(!u.empty()){\n            if(u.top().S<low-d)u.pop();\n            else break;\n        }\n        while(!r.empty()){\n            if(r.top().S<low-d)r.pop();\n            else break;\n        }\n        while(!l.empty()){\n            if(l.top().S<low-d)l.pop();\n            else break;\n        }\n        while(!b.empty()){\n            if(b.top().S<low-d)b.pop();\n            else break;\n        }\n        ans=max(ans,(long long int)(u.top().F-b.top().F)*(r.top().F-l.top().F));\n        low=pq.top().light;\n    }\n    printf(\"%lld\\n\",ans);\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int LL\ntypedef long long LL;\nconst int INF = 2002002002;\n\nstruct DATA {\n\tint minx, miny, maxx, maxy;\n};\n\nstruct STAR {\n\tint x, y, b;\n\tbool operator < (const STAR &t) const {\n\t\treturn b < t.b;\n\t}\n};\n\nint n, d;\nSTAR star[1 << 19];\n\nint N;\nDATA data[1 << 20];\n\n\nvoid init(int n)\n{\n\tfor (N = 1; N < n; N <<= 1);\n\tfill(data, data + (1 << 20), (DATA){INF, INF, -INF, -INF});\n}\n\nvoid update(int i, STAR s)\n{\n\ti += N - 1;\n\tdata[i] = (DATA){s.x, s.y, s.x, s.y};\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tdata[i].minx = min(data[i * 2 + 1].minx, data[i * 2 + 2].minx);\n\t\tdata[i].miny = min(data[i * 2 + 1].miny, data[i * 2 + 2].miny);\n\t\tdata[i].maxx = max(data[i * 2 + 1].maxx, data[i * 2 + 2].maxx);\n\t\tdata[i].maxy = max(data[i * 2 + 1].maxy, data[i * 2 + 2].maxy);\n\t}\n}\n\nDATA query(int a, int b, int k, int l, int r)\n{\n\t//printf(\"%d %d %d %d %d\\n\", a, b, k, l, r);\n\tif (r <= a || b <= l) return (DATA){INF, INF, -INF, -INF};\n\tif (a <= l && r <= b) return data[k];\n\tDATA vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tDATA vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn (DATA){min(vl.minx, vr.minx), min(vl.miny, vr.miny), max(vl.maxx, vr.maxx), max(vl.maxy, vr.maxy)};\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tinit(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lld %lld %lld\", &star[i].x, &star[i].y, &star[i].b);\n\t\tstar[i].x; star[i].y;\n\t}\n\tfor (int i = n; i < 1 << 19; i++){\n\t\tstar[i].b = INF;\n\t}\n\t\n\tsort(star, star + n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tupdate(i, star[i]);\n\t}\n\t\n\t//printf(\"%lld\\n\", (LL)INF * INF);\n\t\n\tLL res = 0;\n\tfor (int l = 0; star[l].b != INF; ){\n\t\tint r = l;\n\t\twhile (star[r].b - star[l].b <= d) r++;\n\t\t\n\t\tDATA q = query(l, r, 0, 0, N);\n\t\tLL t = (LL)(q.maxx - q.minx) * (q.maxy - q.miny);\n\t\tres = max(res, t);\n\t\t\n\t\tl++;\n\t\twhile (star[l + 1].b == star[l].b) l++;\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1<<29)\ntypedef long long ll;\n\nstruct MinSegtree\n{\n  int n;\n  int dat[500005];\n  MinSegtree(int _n)\n  {\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*21;i++)\n      dat[i] = INF;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n\n  int query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return INF;\n\n    if(a <= l && r <= b) return dat[k];\n    else{\n      int vl = query(a, b, k*2+1, l, (l + r) / 2);\n      int vr = query(a, b, k*2+2, (l + r) / 2, r);\n      return min(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nstruct MaxSegtree\n{\n  int n;\n  int dat[500005];\n  MaxSegtree(int _n){\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*2-1;i++)\n      dat[i] = -1;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n  \n  int query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return -1;\n    \n    if(a <= l && r <=b ) return dat[k];\n    else{\n      int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n      int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n      return max(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nint main()\n{\n  int n, d;\n  scanf(\"%d%d\", &n, &d);\n  MinSegtree minx(n);\n  MinSegtree miny(n);\n  MaxSegtree maxx(n);\n  MaxSegtree maxy(n);\n  \n  vector<pair<int, pair<int, int> > >s(n);\n  vector<int>br(n);\n  for(int i=0;i<n;i++){\n    int x, y, b;\n    scanf(\"%d%d%d\", &x, &y, &b);\n    s[i] = make_pair(b, make_pair(x, y));\n    br[i] = b;\n  }\n  sort(s.begin(), s.end());\n  sort(br.begin(), br.end());\n\n\n  for(int i=0;i<n;i++){\n    minx.update(i, s[i].second.first);\n    maxx.update(i, s[i].second.first);\n    miny.update(i, s[i].second.second);\n    maxy.update(i, s[i].second.second);\n  }\n\n  br.push_back(INF);\n  ll res = 0;\n  for(int i=0;i<n;i++){\n    int pos = (int)(upper_bound(br.begin(), br.end(), br[i] + d) - br.begin());\n    int w = maxx.query(i, pos, 0, 0, maxx.size()) - minx.query(i, pos, 0, 0, minx.size());\n    int h = maxy.query(i, pos, 0, 0, maxy.size()) - miny.query(i, pos, 0, 0, miny.size());\n    res = max(res, (ll)w * (ll)h);\n  }\n\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int LL\ntypedef long long LL;\nconst int INF = 2002002002;\n\nstruct DATA {\n\tint minx, miny, maxx, maxy;\n};\n\nstruct STAR {\n\tint x, y, b;\n\tbool operator < (const STAR &t) const {\n\t\treturn b < t.b;\n\t}\n};\n\nint n, d;\nSTAR star[1 << 19];\n\nint N;\nDATA data[1 << 20];\n\n\nvoid init(int n)\n{\n\tfor (N = 1; N < n; N <<= 1);\n\tfill(data, data + (1 << 20), (DATA){INF, INF, -INF, -INF});\n}\n\nvoid update(int i, STAR s)\n{\n\ti += N - 1;\n\tdata[i].minx = min(data[i].minx, s.x);\n\tdata[i].miny = min(data[i].miny, s.y);\n\tdata[i].maxx = max(data[i].maxx, s.x);\n\tdata[i].maxy = max(data[i].maxy, s.y);\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tdata[i].minx = min(data[i].minx, s.x);\n\t\tdata[i].miny = min(data[i].miny, s.y);\n\t\tdata[i].maxx = max(data[i].maxx, s.x);\n\t\tdata[i].maxy = max(data[i].maxy, s.y);\n\t}\n}\n\nDATA query(int a, int b, int k, int l, int r)\n{\n\t//printf(\"%d %d %d %d %d\\n\", a, b, k, l, r);\n\tif (r <= a || b <= l) return (DATA){INF, INF, -INF, -INF};\n\tif (a <= l && r <= b) return data[k];\n\tDATA vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tDATA vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn (DATA){min(vl.minx, vr.minx), min(vl.miny, vr.miny), max(vl.maxx, vr.maxx), max(vl.maxy, vr.maxy)};\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tinit(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d %d\", &star[i].x, &star[i].y, &star[i].b);\n\t\t--star[i].x; --star[i].y;\n\t}\n\tfor (int i = n; i < 1 << 19; i++){\n\t\tstar[i].b = INF;\n\t}\n\t\n\tsort(star, star + n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tupdate(i, star[i]);\n\t}\n\t\n\t//printf(\"%lld\\n\", (LL)INF * INF);\n\t\n\tLL res = 0;\n\tfor (int l = 0; star[l].b != INF; ){\n\t\tint r = l;\n\t\twhile (star[r].b - star[l].b <= d) r++;\n\t\t\n\t\tDATA q = query(l, r, 0, 0, N);\n\t\tLL t = (LL)(q.maxx - q.minx) * (q.maxy - q.miny);\n\t\tres = max(res, t);\n\t\t\n\t\tl++;\n\t\twhile (star[l + 1].b == star[l].b) l++;\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int LL\ntypedef long long LL;\nconst int INF = 2002002002;\n\nstruct DATA {\n\tint minx, miny, maxx, maxy;\n};\n\nstruct STAR {\n\tint x, y, b;\n\tbool operator < (const STAR &t) const {\n\t\treturn b < t.b;\n\t}\n};\n\nint n, d;\nSTAR star[1 << 19];\n\nint N;\nDATA data[1 << 20];\n\n\nvoid init(int n)\n{\n\tfor (N = 1; N < n; N <<= 1);\n\tfill(data, data + (1 << 20), (DATA){INF, INF, -INF, -INF});\n}\n\nvoid update(int i, STAR s)\n{\n\ti += N - 1;\n\tdata[i] = (DATA){s.x, s.y, s.x, s.y};\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tdata[i].minx = min(data[i * 2 + 1].minx, data[i * 2 + 2].minx);\n\t\tdata[i].miny = min(data[i * 2 + 1].miny, data[i * 2 + 2].miny);\n\t\tdata[i].maxx = max(data[i * 2 + 1].maxx, data[i * 2 + 2].maxx);\n\t\tdata[i].maxy = max(data[i * 2 + 1].maxy, data[i * 2 + 2].maxy);\n\t}\n}\n\nDATA query(int a, int b, int k, int l, int r)\n{\n\t//printf(\"%d %d %d %d %d\\n\", a, b, k, l, r);\n\tif (r <= a || b <= l) return (DATA){INF, INF, -INF, -INF};\n\tif (a <= l && r <= b) return data[k];\n\tDATA vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tDATA vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn (DATA){min(vl.minx, vr.minx), min(vl.miny, vr.miny), max(vl.maxx, vr.maxx), max(vl.maxy, vr.maxy)};\n}\n\nsigned main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tinit(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lld %lld %lld\", &star[i].x, &star[i].y, &star[i].b);\n\t\t//star[i].x; star[i].y;\n\t}\n\tfor (int i = n; i < 1 << 19; i++){\n\t\tstar[i].b = INF;\n\t}\n\t\n\tsort(star, star + n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tupdate(i, star[i]);\n\t}\n\t\n\t//printf(\"%lld\\n\", (LL)INF * INF);\n\t\n\tLL res = 0;\n\tfor (int l = 0; star[l].b != INF; ){\n\t\tint r = l;\n\t\twhile (star[r].b - star[l].b <= d) r++;\n\t\t\n\t\tDATA q = query(l, r, 0, 0, N);\n\t\tLL t = (LL)(q.maxx - q.minx) * (q.maxy - q.miny);\n\t\tres = max(res, t);\n\t\t\n\t\tdo {\n\t\t\tl++;\n\t\t} while (star[l + 1].b == star[l].b);\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\n\nstruct Star{\n    int x,y,b;\n    Star(int x=0,int y=0,int b=0) :\n        x(x),y(y),b(b){}\n    bool operator<(const Star &rth) const {\n        return std::tie(b,x,y)<std::tie(rth.b,rth.x,rth.y);\n    }\n};\n\nstruct SegTree {\n    int n;\n    vector<ll> min_dat;\n    vector<ll> max_dat;\n    SegTree(int N) {\n        n=1;\n        while(n<N) n*=2;\n        min_dat.assign(1<<18,INF);\n        max_dat.assign(1<<18,0);\n    }\n\n    void update(int k,int a) {\n        k+=n-1;\n        min_dat[k]=a;\n        max_dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            min_dat[k]=min(min_dat[k*2+1],min_dat[k*2+2]);\n            max_dat[k]=max(max_dat[k*2+1],max_dat[k*2+2]);\n        }\n    }\n\n    ll min_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return INF;\n\n        if(a<=l&&r<=b) return min_dat[k];\n        else {\n            int vl=min_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=min_query(a,b,k*2+2,(l+r)/2,r);\n            return min(vl,vr);\n        }\n    }\n\n    ll max_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return 0;\n\n        if(a<=l&&r<=b) return max_dat[k];\n        else {\n            int vl=max_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=max_query(a,b,k*2+2,(l+r)/2,r);\n            return max(vl,vr);\n        }\n    }\n\n    void dump() {\n        rep(i,n) cout<<max_dat[i]<<\" \";\n        cout<<endl;\n    }\n\n};\nint N,d;\n\n\nvector<Star> stars;\n\nint find(int x) {\n    int l=0;\n    int r=stars.size()-1;\n    while(r-l>1) {\n        int mid=(l+r)/2;\n        if(stars[mid].b<x) l=mid;\n        else r=mid;\n    }\n    return r;\n}\nint main() {\n    cin>>N>>d;\n    rep(i,N) {\n        Star s;\n        cin>>s.x>>s.y>>s.b;\n        stars.pb(s);\n    }\n    SegTree segTreeX(N);\n    SegTree segTreeY(N);\n\n    sort(all(stars));\n\n    rep(i,stars.size()) {\n        // printf(\"%d %d %d %d\\n\",i,stars[i].x,stars[i].y,stars[i].b);\n        segTreeX.update(i,stars[i].x);\n        segTreeY.update(i,stars[i].y);\n    }\n\n\n    ll ans=0;\n    int n=segTreeX.n;\n    rep(i,stars.size()) {\n        int pos=find(stars[i].b+d);\n        ll tmp=0;\n        tmp=segTreeX.max_query(i,pos+1,0,0,n)-segTreeX.min_query(i,pos+1,0,0,n);\n        tmp*=segTreeY.max_query(i,pos+1,0,0,n)-segTreeY.min_query(i,pos+1,0,0,n);\n\n        // cout<<i<<\",\"<<stars[i].b+d<<\",\"<<pos<<\",\"<<tmp<<endl;\n        ans = max(ans,tmp);\n\n    }\n\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define INF 1e+17\n#define int long long\nusing namespace std;\n\nint seg,segMin[2][600000],segMax[2][600000];\n\nint getMin(int a,int b,int k,int l,int r,int num){\n\tif(b <= l || r <= a) return INF;\n\tif(a <= l && r <= b) return segMin[num][k];\n\treturn min(getMin(a,b,k * 2 + 1,l,(l + r) / 2,num),getMin(a,b,k * 2 + 2,(l + r) / 2,r,num));\n}\n\nint getMax(int a,int b,int k,int l,int r,int num){\n\tif(b <= l || r <= a) return 0;\n\tif(a <= l && r <= b) return segMax[num][k];\n\treturn max(getMax(a,b,k * 2 + 1,l,(l + r) / 2,num),getMax(a,b,k * 2 + 2,(l + r) / 2,r,num));\n}\n\nvoid updMin(int i,int x,int num){\n\ti += seg - 1;\n\tsegMin[num][i] = min(x,segMin[num][i]);\n\twhile(i){\n\t\ti = (i - 1) / 2;\n\t\tsegMin[num][i] = min(segMin[num][i * 2 + 1],segMin[num][i * 2 + 2]);\n\t}\n}\n\nvoid updMax(int i,int x,int num){\n\ti += seg - 1;\n\tsegMax[num][i] = max(x,segMax[num][i]);\n\twhile(i){\n\t\ti = (i - 1) / 2;\n\t\tsegMax[num][i] = max(segMax[num][i * 2 + 1],segMax[num][i * 2 + 2]);\n\t}\n}\n\nsigned main(){\n\tint n,d,x[200000],y[200000],b[200000];\n\tcin >> n >> d;\n\tseg = 1;\n\twhile(seg < n) seg *= 2;\n\tfor(int i = 0;i < seg * 2 - 1;i++){\n\t\tsegMin[0][i] = INF;\n\t\tsegMin[1][i] = INF;\n\t}\n\tvector<int> vec;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x[i] >> y[i] >> b[i];\n\t\tvec.push_back(b[i]);\n\t}\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end());\n\tfor(int i = 0;i < n;i++){\n\t\tint pos = lower_bound(vec.begin(),vec.end(),b[i]) - vec.begin();\n\t\tupdMin(pos,x[i],0);\n\t\tupdMax(pos,x[i],0);\n\t\tupdMin(pos,y[i],1);\n\t\tupdMax(pos,y[i],1);\n\t}\n\tint ma = 0;\n\tfor(int i = 0;i < vec.size();i++){\n\t\tint low = lower_bound(vec.begin(),vec.end(),vec[i]) - vec.begin();\n\t\tint up = upper_bound(vec.begin(),vec.end(),vec[i] + d) - vec.begin() - 1;\n\t\t//cout << getMax(low,up + 1,0,0,seg,0) << \" \" << getMin(low,up + 1,0,0,seg,0) << \" \" << getMax(low,up + 1,0,0,seg,1) << \" \" << getMin(low,up + 1,0,0,seg,1) << endl;\n\t\tma = max(ma,(getMax(low,up + 1,0,0,seg,0) - getMin(low,up + 1,0,0,seg,0)) * (getMax(low,up + 1,0,0,seg,1) - getMin(low,up + 1,0,0,seg,1)));\n\t}\n\tcout << ma << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <utility>\ntypedef long long ll;\nusing namespace std;\n\nll min(ll a, ll b) {\n  return a < b ? a : b;\n}\n\nll max(ll a, ll b) {\n  return a > b ? a : b;\n}\n\nint main(void) {\n  ll i, j, k, n, d, sn = 1, now = 1, ans = 0;\n  scanf(\"%lld%lld\", &n, &d);\n  pair< ll, ll > sx[n], sy[n];\n  ll b[n];\n  for(i = 0; i < n; ++i) {\n    scanf(\"%lld%lld%lld\", &sx[i].second, &sy[i].second, &b[i]);\n    sy[i].first = sx[i].first = b[i];\n  }\n  sort(sx, sx + n), sort(sy, sy + n), sort(b, b + n);\n  while(sn < n) sn *= 2;\n  ll xmin[sn * 2], xmax[sn * 2], ymin[sn * 2], ymax[sn * 2], las[sn * 2];\n  for(i = 1; i < sn * 2; ++i) {\n    if(i >= now * 2) now *= 2;\n    las[i] = sn / now * (i - now + 1) - 1;\n  }\n  for(i = 0; i < sn; ++i) {\n    if(i < n) xmin[i + sn] = sx[i].second, xmax[i + sn] = sx[i].second, ymin[i + sn] = sy[i].second, ymax[i + sn] = sy[i].second;\n    else xmin[i + sn] = ymin[i + sn] = 1e9, xmax[i + sn] = ymax[i + sn] = -1;\n    if(i % 2) {\n      now = (i + sn) / 2;\n      while(now) {\n        xmin[now] = min(xmin[now * 2], xmin[now * 2 + 1]);\n        xmax[now] = max(xmax[now * 2], xmax[now * 2 + 1]);\n        ymin[now] = min(ymin[now * 2], ymin[now * 2 + 1]);\n        ymax[now] = max(ymax[now * 2], ymax[now * 2 + 1]);\n        now /= 2;\n      }\n    }\n  }\n  for(i = 0; i < n; ++i) {\n    ll l = lower_bound(b, b + n, b[i] + d + 1) - b - 1;\n    ll nxmi, nxma, nymi, nyma;\n    nxmi = nymi = 1e9, nxma = nyma = -1;\n    now = i + sn;\n    while(1) {\n      while(!(now % 2)) now /= 2;\n      while(las[now] > l) now *= 2;\n      if(nxmi > xmin[now]) nxmi = xmin[now];\n      if(nxma < xmax[now]) nxma = xmax[now];\n      if(nymi > ymin[now]) nymi = ymin[now];\n      if(nyma < ymax[now]) nyma = ymax[now];\n      if(las[now] == l) break;\n      now++;\n    }\n    if(nxma - nxmi >= 0 && nyma - nymi >= 0 && ans < (nxma - nxmi) * (nyma - nymi)) ans = (nxma - nxmi) * (nyma - nymi);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n#define Seg_Max_N (1<<21) \n\nusing Value = pair<long long int,long long int>;\nconst Value ini = (make_pair(1e18, 0));\nstruct segtree {\n\tint N;\n\tvector<int>nums;\n\tvector<Value>dat;\n\n\tsegtree() {}\n\tsegtree(int n) :dat(2 * Seg_Max_N) ,nums(2*Seg_Max_N) {\n\t\tN = 1;\n\t\twhile (N < n) N *= 2;\n\t\tfor (int i = 0; i < 2 * N - 1; i++) {\n\t\t\tdat[i] = ini;\n\t\t}\n\t}\n\t// update k th element\n\tvoid update(int k, Value a) {\n\t\tk += N - 1; // leaf\n\t\tif (a == ini) {\n\t\t\tnums[k]--;\n\t\t\tif (!nums[k])dat[k] = a;\n\t\t}\n\t\telse {\n\t\t\tnums[k]++;\n\t\t\tdat[k] = a;\n\t\t}\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tconst Value al(dat[k * 2 + 1]);\n\t\t\tconst Value ar(dat[k * 2 + 2]);\n\t\t\tdat[k] = make_pair(min(al.first,ar.first), max(al.second,ar.second));\n\t\t}\n\t}\n\t// min [a, b)\n\tValue  query(int a, int b) { return query(a, b, 0, 0, N); }\n\tValue  query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l) return ini;\n\t\tif (a <= l and r <= b) return dat[k];\n\t\tconst int m = (l + r) / 2;\n\t\tconst Value al(query(a, b, k * 2 + 1, l, m));\n\t\tconst Value ar(query(a, b, k * 2 + 2, m, r));\n\t\treturn make_pair(min(al.first, ar.first), max(al.second, ar.second));\n\t}\n};\nstruct star{\n\tint x;\n\tint y;\n\tint light;\n};\nconst int amax = 2000001;\nint main() {\n\tint N, D; cin >> N >> D;\n\tsegtree segx(amax), segy(amax);\n\tvector<star>stars;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y, b; cin >> x >> y >> b;\n\t\tstars.push_back(star{ x,y,b });\n\t}\n\tsort(stars.begin(), stars.end(), [](const star&l, const star&r) {\n\t\treturn l.light < r.light;\n\t});\n\tint l = 0;\n\tint r = 0;\n\tlong long int ans = 0;\n\t{\n\t\tsegx.update(stars[0].x, make_pair(stars[0].x, stars[0].x));\n\t\tsegy.update(stars[0].y, make_pair(stars[0].y, stars[0].y));\n\t\tauto px(segx.query(0, amax));\n\t\tauto py(segy.query(0, amax));\n\t\tans = max(ans, (px.second - px.first)*(py.second - py.first));\n\t}\n\twhile (r<N-1) {\n\t\tif (stars[r+1].light <= stars[l].light+D) {\n\t\t\tr++;\n\t\t\tsegx.update(stars[r].x, make_pair(stars[r].x, stars[r].x));\n\t\t\tsegy.update(stars[r].y, make_pair(stars[r].y, stars[r].y));\n\t\t\tauto px(segx.query(0, amax));\n\t\t\tauto py(segy.query(0, amax));\n\t\t\tans = max(ans, (px.second - px.first)*(py.second - py.first));\n\t\t}\n\t\telse {\n\t\t\tif (l != r) {\n\t\t\t\tsegx.update(stars[l].x, ini);\n\t\t\t\tsegy.update(stars[l].y,ini);\n\t\t\t\tl++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr++;\n\t\t\t\tsegx.update(stars[r].x, make_pair(stars[r].x, stars[r].x));\n\t\t\t\tsegy.update(stars[r].y, make_pair(stars[r].y, stars[r].y));\n\t\t\t\tsegx.update(stars[l].x, ini);\n\t\t\t\tsegy.update(stars[l].y, ini);\n\t\t\t\tl++;\n\t\t\t\tauto px(segx.query(0, amax));\n\t\t\t\tauto py(segy.query(0, amax));\n\t\t\t\tans = max(ans, (px.second - px.first)*(py.second - py.first));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct STAR {\n  int x, y, d;\n};\n\nint minX[200000 * 2 - 1] = {}, maxX[200000 * 2 - 1] = {},\nminY[200000 * 2 - 1] = {}, maxY[200000 * 2 - 1] = {};\nint n, nn = 1;\n\nvoid update(int k, int a, int c[], int f) {\n  k += n - 1;\n  c[k] = a;\n\n  while(k > 0) {\n    k = (k - 1) / 2;\n    if(f) c[k] = max(c[k * 2 + 1], c[k * 2 + 2]);\n    else c[k] = min(c[k * 2 + 1], c[k * 2 + 2]);\n  }\n}\n\nint query(int a, int b, int k, int l, int r, int c[], int f) {\n  if(r <= a || b <= l) return f ? 0 : INT_MAX;\n  if(a <= l && r <= b) return c[k];\n\n  int vl = query(a, b, k * 2 + 1, l, (l + r) / 2, c, f);\n  int vr = query(a, b, k * 2 + 1, (l + r) / 2, r, c, f);\n\n  return f ? max(vl, vr) : min(vl, vr);\n}\n\nbool asc(STAR &l, STAR &r) {\n  return l.d < r.d;\n}\n\nint main() {\n  ll d, ans = 0;\n  cin >> n >> d;\n  vector<STAR> v(n);\n\n  while(nn < n) nn *= 2;\n\n  rep(i, 0, nn * 2 - 1) {\n    minX[i] = INT_MAX;\n    minY[i] = INT_MAX;\n  }\n\n  rep(i, 0, n) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    v[i].x = a;\n    v[i].y = b;\n    v[i].d = c;\n  }\n\n  sort(v.begin(), v.end(), asc);\n\n  rep(i, 0, n) {\n    update(i, v[i].x, maxX, 1);\n    update(i, v[i].x, minX, 0);\n    update(i, v[i].y, maxY, 1);\n    update(i, v[i].y, minY, 0);\n  }\n\n  int hx = v[0].x, lx = v[0].x, hy = v[0].y, ly = v[0].y, ld = v[0].d, lp = 0;\n  rep(i, 1, n) {\n    if(v[i].d - ld > d) {\n      int klp = lp;\n      rep(j, lp + 1, i) {\n        if(v[i].d - v[j].d <= d) {\n          lp = j;\n          break;\n        }\n      }\n      if(klp == lp) lp = i;\n    }\n    hx = query(lp, i, 0, 0, n, maxX, 1);\n    lx = query(lp, i, 0, 0, n, minX, 0);\n    hy = query(lp, i, 0, 0, n, maxY, 1);\n    ly = query(lp, i, 0, 0, n, minY, 0);\n    ld = v[lp].d;\n    ans = max(ans, (ll)(abs(hx - lx) * abs(hy - ly)));\n  }\n\n  cout << max(ans, (ll)(abs(hx - lx) * abs(hy - ly))) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\n#define MAX_N 1 << 20\nint n, d, size_, dat[2][2][MAX_N];//[xy][minmax][pos]\ntuple<int, int, int>x[MAX_N];\ninline void init(int n) {\n\tfor (size_ = 1; size_ < n;) size_ *= 2;\n\tfor (int i = 0; i < 2; i++) { for (int j = 0; j < MAX_N; j++) { dat[i][0][j] = 1 << 30; dat[i][1][j] = -(1 << 30); } }\n}\ninline void update(int pos, int x, int p1) {\n\tpos += size_; dat[p1][0][pos] = x; dat[p1][1][pos] = x;\n\twhile (pos != 1) {\n\t\tpos >>= 1;\n\t\tdat[p1][0][pos] = min(dat[p1][0][pos * 2], dat[p1][0][pos * 2 + 1]);\n\t\tdat[p1][1][pos] = max(dat[p1][1][pos * 2], dat[p1][1][pos * 2 + 1]);\n\t}\n}\ninline int query(int a, int b, int k, int l, int r, int p1, int p2) {\n\tif (r <= a || b <= l) { if (p2 == 0)return 1 << 30; return -(1 << 30); }\n\tif (a <= l && r <= b) return dat[p1][p2][k]; k <<= 1;\n\tint lc = query(a, b, k, l, (l + r) / 2, p1, p2);\n\tint rc = query(a, b, k + 1, (l + r) / 2, r, p1, p2);\n\tif (p2 == 0)return min(lc, rc);\n\tif (p2 == 1)return max(rc, lc);\n}\ninline int rmqw(int x, int y, int p) {\n\tint V1 = query(x, y + 1, 1, 0, size_, p, 1), V2 = query(x, y + 1, 1, 0, size_, p, 0);\n\treturn V1 - V2;\n}\nint main() {\n\tcin >> n >> d; init(n); for (int i = 1; i <= n; i++) { cin >> get<1>(x[i]) >> get<2>(x[i]) >> get<0>(x[i]); }\n\tsort(x + 1, x + n + 1); long long maxn = 0;\n\tfor (int i = 1; i <= n; i++) { update(i, get<1>(x[i]), 0); update(i, get<2>(x[i]), 1); }\n\tfor (int i = 1; i <= n; i++) {\n\t\tint R = lower_bound(x + 1, x + n + 1, make_tuple(get<0>(x[i]) + d, 1 << 30, 1 << 30)) - x; R--;\n\t\tmaxn = max(maxn, 1LL*rmqw(i, R, 0)*rmqw(i, R, 1));\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct SegTree { // ??????min,max\n    int n;\n    vector<int> Max;\n    vector<int> Min;\n\n    void init(int n_)\n    {\n        n = 1;\n        while (n < n_) n *= 2;\n\n        Max.resize(2 * n);\n        Min.resize(2 * n);\n\n        for (int i = 0; i < 2 * n - 1; ++i) {\n            Max[i] = -inf;\n            Min[i] = inf;\n        }\n    }\n\n    void min_update(int idx, int val)\n    {\n        idx += n - 1;\n        Min[idx] = val;\n\n        while (idx > 0) {\n            idx = (idx - 1) / 2;\n            Min[idx] = min(Min[idx * 2 + 1], Min[idx * 2 + 2]);\n        }\n    }\n\n    void max_update(int idx, int val)\n    {\n        idx += n - 1;\n        Max[idx] = val;\n\n        while (idx > 0) {\n            idx = (idx - 1) / 2;\n            Max[idx] = max(Max[idx * 2 + 1], Max[idx * 2 + 2]);\n        }\n    }\n\n    int get_min(int a, int b, int k = 0, int l = 0, int r = -1) // [a, b)???min\n    {\n        if (r == -1) r = n;\n\n        if (r <= a || b <= l) return inf;\n\n        if (a <= l && r <= b) return Min[k];\n\n        int vl = get_min(a, b, k * 2 + 1, l, (l + r) / 2);\n        int vr = get_min(a, b, k * 2 + 2, (l + r) / 2, r);\n\n        return min(vl, vr);\n    }\n\n    int get_max(int a, int b, int k = 0, int l = 0, int r = -1) // [a, b)???max\n    {\n        if (r == -1) r = n;\n\n        if (r <= a || b <= l) return -inf;\n\n        if (a <= l && r <= b) return Max[k];\n\n        int vl = get_max(a, b, k * 2 + 1, l, (l + r) / 2);\n        int vr = get_max(a, b, k * 2 + 2, (l + r) / 2, r);\n\n        return max(vl, vr);\n    }\n};\n\nint X[200020], Y[200020];\n\nsigned main()\n{\n    omajinai;\n\n    int N, d; cin >> N >> d;\n\n    SegTree x_seg, y_seg;\n\n    x_seg.init(N), y_seg.init(N);\n\n    vpii hoge;\n\n    rep(i, N) {\n        int x, y, b; cin >> x >> y >> b;\n        X[i] = x, Y[i] = y;\n\n        hoge.PB(pii(b, i));\n    }\n\n    sort(all(hoge));\n\n    rep(i, N) {\n        x_seg.min_update(i, X[hoge[i].scd]);\n        x_seg.max_update(i, X[hoge[i].scd]);\n\n        y_seg.min_update(i, Y[hoge[i].scd]);\n        y_seg.max_update(i, Y[hoge[i].scd]);\n    }\n\n    ll ans = -inf;\n\n    rep(i, N) {\n        int b = hoge[i].fst;\n\n        int idx = upper_bound(all(hoge), pii(b + d, inf)) - hoge.begin();\n\n        int min_x = x_seg.get_min(i, idx);\n        int max_x = x_seg.get_max(i, idx);\n\n        int min_y = y_seg.get_min(i, idx);\n        int max_y = y_seg.get_max(i, idx);\n\n        ans = max(ans, 1ll * (max_x - min_x) * (max_y - min_y));\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for(int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define Cout(obj) cout << obj << endl\n#define Size(obj) (obj).size()\n#define fcout cout << fixed << setprecision(10)\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, d;\n    cin >> N >> d;\n\n    vector<tuple<ll, ll, ll>> vec(N);\n\n    vector<ll>  minx(N), miny(N), maxx(N), maxy(N);\n\n    REP(i, N)\n    {\n        ll x, y, b;\n        cin >> x >> y >> b;\n        vec[i] = make_tuple(b, x, y);\n    }\n\n    sort(ALL(vec));\n\n    ll ans = -1;\n\n    REP(i, N)\n    {\n        ll start = get<0>(vec[i]);\n\n        auto itr = upper_bound(vec.begin(), vec.end(), make_tuple(d + start, iINF, iINF));\n\n        if(itr == vec.begin()) continue;\n\n        //cout << itr - vec.begin() << endl;\n\n        ll maxx = 0, maxy = 0, minx = iINF, miny = iINF;\n\n        FOR(j, i, itr - vec.begin())\n        {\n            ll x = get<1>(vec[j]), y = get<2>(vec[j]);\n\n            maxx = max(maxx, x);\n            maxy = max(maxy, y);\n            minx = min(minx, x);\n            miny = min(miny, y);\n\n        }\n\n\n        ans = max(ans, (ll)((maxx - minx) * (maxy - miny)));\n    }\n\n    Cout(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\n\nstruct Star{\n    int x,y,b;\n    Star(int x=0,int y=0,int b=0) :\n        x(x),y(y),b(b){}\n    bool operator<(const Star &rth) const {\n        return this->b<rth.b;\n    }\n    bool operator<(int rval) const {\n        return this->b<rval;\n    }\n};\n\nstruct SegTree {\n    int n;\n    vector<int> min_dat;\n    vector<int> max_dat;\n    SegTree(int N) {\n        n=1;\n        while(n<N) n*=2;\n        min_dat.assign(1<<18,INF);\n        max_dat.assign(1<<18,0);\n    }\n\n    void update(int k,int a) {\n        k+=n-1;\n        min_dat[k]=a;\n        max_dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            min_dat[k]=min(min_dat[k*2+1],min_dat[k*2+2]);\n            max_dat[k]=max(max_dat[k*2+1],max_dat[k*2+2]);\n        }\n    }\n\n    int min_query(int a,int b,int k=0,int l=0,int r=1<<17) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return INF;\n\n        if(a<=l&&r<=b) return min_dat[k];\n        else {\n            int vl=min_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=min_query(a,b,k*2+2,(l+r)/2,r);\n            return min(vl,vr);\n        }\n    }\n\n    int max_query(int a,int b,int k=0,int l=0,int r=1<<17) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return 0;\n\n        if(a<=l&&r<=b) return max_dat[k];\n        else {\n            int vl=max_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=max_query(a,b,k*2+2,(l+r)/2,r);\n            return max(vl,vr);\n        }\n    }\n\n    void dump() {\n        rep(i,n) cout<<max_dat[i]<<\" \";\n        cout<<endl;\n    }\n\n};\nint N,d;\n\n\nvector<Star> stars;\n\nint find(int x) {\n    int l=0;\n    int r=stars.size()-1;\n    while(r-l>1) {\n        int mid=(l+r)/2;\n        if(stars[mid].b<x) l=mid;\n        else r=mid;\n    }\n    return r;\n}\nint main() {\n    cin>>N>>d;\n    rep(i,N) {\n        Star s;\n        cin>>s.x>>s.y>>s.b;\n        stars.pb(s);\n    }\n    SegTree segTreeX(N);\n    SegTree segTreeY(N);\n\n    sort(all(stars));\n\n    rep(i,stars.size()) {\n        // printf(\"%d %d %d %d\\n\",i,stars[i].x,stars[i].y,stars[i].b);\n        segTreeX.update(i,stars[i].x);\n        segTreeY.update(i,stars[i].y);\n    }\n\n\n    int ans=0;\n    int n=segTreeX.n;\n    rep(i,stars.size()) {\n        int pos=find(stars[i].b+d);\n        int tmp=0;\n        tmp=segTreeX.max_query(i,pos+1,0,0,n)-segTreeX.min_query(i,pos+1,0,0,n);\n        tmp*=segTreeY.max_query(i,pos+1,0,0,n)-segTreeY.min_query(i,pos+1,0,0,n);\n\n        // cout<<i<<\",\"<<stars[i].b+d<<\",\"<<pos<<\",\"<<tmp<<endl;\n        ans = max(ans,tmp);\n\n    }\n\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Data{\n  int x;\n  int y;\n  int d;\n\n  bool operator<(const Data& right) const{\n    return d < right.d;\n  }\n} ;\n\nint segTree[4][600000];\nint segSize;\n\nvector<Data> data;\n\nvoid init(int n){\n\n  segSize = 1;\n  while(segSize < n){\n    segSize *= 2;\n  }\n\n  for(int i = 0;i < segSize;i++){\n    if(i < n){\n      segTree[0][segSize+i-1] = data[i].x;\n      segTree[1][segSize+i-1] = data[i].x;\n      segTree[2][segSize+i-1] = data[i].y;\n      segTree[3][segSize+i-1] = data[i].y;\n    }else{\n      segTree[0][segSize+i-1] = INT_MIN;\n      segTree[1][segSize+i-1] = INT_MAX;\n      segTree[2][segSize+i-1] = INT_MIN;\n      segTree[3][segSize+i-1] = INT_MAX;\n    }\n  }\n\n  for(int i = segSize-2;i >= 0;i--){\n    segTree[0][i] = max(segTree[0][i*2+1],segTree[0][i*2+2]);\n    segTree[1][i] = min(segTree[1][i*2+1],segTree[1][i*2+2]);\n    segTree[2][i] = max(segTree[2][i*2+1],segTree[2][i*2+2]);\n    segTree[3][i] = min(segTree[3][i*2+1],segTree[3][i*2+2]);\n  }\n\n  return;\n}\n\nint x_max(int a,int b,int l, int r, int k){\n  if(r <= a || b <= l){\n    return INT_MIN;\n  }\n\n  if(a <= l && r <= b){\n    return segTree[0][k];\n  }\n\n  return max(x_max(a,b,l,(l+r)/2,k*2+1),x_max(a,b,(l+r)/2,r,k*2+2));\n}\n\nint x_min(int a,int b,int l, int r, int k){\n  if(r <= a || b <= l){\n    return INT_MAX;\n  }\n\n  if(a <= l && r <= b){\n    return segTree[1][k];\n  }\n\n  return min(x_min(a,b,l,(l+r)/2,k*2+1),x_min(a,b,(l+r)/2,r,k*2+2));\n}\n\nint y_max(int a,int b,int l, int r, int k){\n  if(r <= a || b <= l){\n    return INT_MIN;\n  }\n\n  if(a <= l && r <= b){\n    return segTree[2][k];\n  }\n\n  return max(y_max(a,b,l,(l+r)/2,k*2+1),y_max(a,b,(l+r)/2,r,k*2+2));\n}\n\nint y_min(int a,int b,int l, int r, int k){\n  if(r <= a || b <= l){\n    return INT_MAX;\n  }\n\n  if(a <= l && r <= b){\n    return segTree[3][k];\n  }\n\n  return min(y_min(a,b,l,(l+r)/2,k*2+1),y_min(a,b,(l+r)/2,r,k*2+2));\n}\n\n\nint main(){\n\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  int n,d;\n\n  cin >> n >> d;\n  data.resize(n);\n  for(int i = 0;i < n;i++){\n    cin >> data[i].x >> data[i].y >> data[i].d;\n  }\n\n  sort(data.begin(),data.end());\n\n  init(n);\n\n  int mini = 0;\n  long long ans = 0;\n  for(int i = 1;i < n;i++){\n    if(data[i].d - data[mini].d > d){\n      ans = max(ans,(long long)(x_max(mini,i,0,segSize,0)-x_min(mini,i,0,segSize,0))\n          *(long long)(y_max(mini,i,0,segSize,0)-y_min(mini,i,0,segSize,0)));\n      int j;\n      for(j = mini+1;j < i;j++){\n        if(data[i].d-data[j].d <= d){\n          break;\n        }\n      }\n      mini = j;\n    }\n  }\n  ans = max(ans,(long long)(x_max(mini,n,0,segSize,0)-x_min(mini,n,0,segSize,0))\n      *(long long)(y_max(mini,n,0,segSize,0)-y_min(mini,n,0,segSize,0)));\n\n  cout << ans << endl;\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair <int,int> P;\ntypedef long long ll;\n#define f first\n#define s second\n#define INF 1000000000\nint tree[4][(1<<19)];\nint n,d;\npair <int,pair <int,int> > star[(1<<18)];\n\nvoid update(int i,int x,int flg){\n  i = (1<<18)+i-1;\n  tree[flg][i] = x;\n  while(i){\n    i = (i-1)/2;\n    tree[flg][i] = max(tree[flg][i*2+1],tree[flg][i*2+2]);\n  }\n}\n\nint find(int a,int b,int M,int L,int R,int flg){\n  if(b <=L || a >= R) return -INF;\n  if(a <=L && R <= b) return tree[flg][M];\n  int nx = (L+R)/2;\n  return max(find(a,b,M*2+1,L,nx,flg),find(a,b,M*2+2,nx,R,flg));\n}\n\nint main() {\n  scanf(\"%d %d\",&n,&d);\n  for(int i=0;i<(1<<19);i++) \n    for(int j=0;j<4;j++) tree[j][i] = -INF;\n  for(int i=0;i<n;i++)\n    scanf(\"%d %d %d\",&star[i].s.f,&star[i].s.s,&star[i].f);\n  sort(star,star+n);\n  for(int i=0;i<n;i++) {\n    update(i,star[i].s.f,0); // max(x);\n    update(i,star[i].s.s,1); // max(y);\n    update(i,-star[i].s.f,2); // min(x);\n    update(i,-star[i].s.s,3); // min(y);\n  }\n  ll now = 0,minx,maxx,miny,maxy,S=0;\n  for(int i=0;i<n;i++) {\n    while(now < n && star[now].f -star[i].f <=d) now++;\n    maxx = find(i,now,0,0,(1<<18),0);\n    maxy = find(i,now,0,0,(1<<18),1);\n    minx = find(i,now,0,0,(1<<18),2);\n    miny = find(i,now,0,0,(1<<18),3);\n    S = max(S,((ll)maxx+minx)*((ll)maxy+miny));\n  }\n  cout << S <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint N;\nlong int d;\nint maxx,maxy,maxs,kma,kmi,ks,x[200000],y[200000],cnt;\nstruct DATA{\n\tint x,y,b;\n};\nDATA data[200000];\n\nint main(){\n\tcin>>N>>b;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>data[i].x>>data[i].y>>data[i].b;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tmaxx=0;maxy=0;cnt=1;\n\t\tx[0]=data[i].x;\n\t\ty[0]=data[i].y;\n\t\tfor(int j=0;j<N;j++){\n\t\t\t\n\t\t\tif(0<=data[i].b-data[j].b&&data[i].b-data[j].b<=b){\n\t\t\t\tcnt++;\n\t\t\t\tx[cnt]=data[j].x;\n\t\t\t\ty[cnt]=data[j].y;\n\t\t\t}\n\t\t\tif(j==N-1){\n\t\t\t\tsort(x,x+cnt);\n\t\t\t\tsort(y,y+cnt);\n\t\t\t\tmaxx=x[cnt]-x[0];\n\t\t\t\tmaxy=y[cnt]-y[0];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tks=maxx*maxy;\n\t\tif(maxs<ks){maxs=ks;kma=maxx;kmi=maxy;}\n\t}\n\tcout<<maxs<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct STAR {\n  int x, y, d;\n};\n\nbool asc(STAR &l, STAR &r) {\n  return l.d < r.d;\n}\n\nint main() {\n  ll n, d, ans = 0;\n  cin >> n >> d;\n  vector<STAR> v(n);\n\n  rep(i, 0, n) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    v[i].x = a;\n    v[i].y = b;\n    v[i].d = c;\n  }\n\n  sort(v.begin(), v.end(), asc);\n\n  int hx = v[0].x, lx = v[0].x, hy = v[0].y, ly = v[0].y, ld = v[0].d, lp = 0;\n  rep(i, 1, n) {\n    if(v[i].d - ld <= d) {\n      hx = max(hx, v[i].x);\n      hy = max(hy, v[i].y);\n      lx = min(lx, v[i].x);\n      ly = min(ly, v[i].y);\n    }else {\n      ans = max(ans, (ll)(abs(hx - lx) * abs(hy - ly)));\n      int klp = lp;\n      rep(j, lp + 1, i) {\n        if(v[i].d - v[j].d <= d) {\n          lp = j;\n          break;\n        }\n      }\n      if(klp == lp) lp = i;\n      hx = v[lp].x, lx = v[lp].x, hy = v[lp].y, hx = v[lp].y, ld = v[lp].d;\n      rep(j, lp + 1, i) {\n        hx = max(hx, v[j].x);\n        hy = max(hy, v[j].y);\n        lx = min(lx, v[j].x);\n        ly = min(ly, v[j].y);\n      }\n    }\n  }\n\n  cout << max(ans, (ll)(abs(hx - lx) * abs(hy - ly))) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nlong min(long a, long b)\n{\n    return a < b ? a : b;\n}\n\nlong max(long a, long b)\n{\n    return a > b ? a : b;\n}\n\nstruct Star\n{\n    long x, y, b;\npublic:\n    Star(long x, long y, long b): x(x), y(y), b(b) {}\n    bool operator<(const Star& s)\n    {\n        return b < s.b;\n    }\n};\n\nstruct Range\n{\n    long x1, y1, x2, y2, b;\npublic:\n    Range(const Star& s): x1(s.x), y1(s.y), x2(s.x), y2(s.y), b(s.b) {}\n    void add(const Star& s)\n    {\n        x1 = min(x1, s.x);\n        y1 = min(y1, s.y);\n        x2 = max(x2, s.x);\n        y2 = max(y2, s.y);\n    }\n    void add(const Range& r)\n    {\n        x1 = min(x1, r.x1);\n        y1 = min(y1, r.y1);\n        x2 = max(x2, r.x2);\n        y2 = max(y2, r.y2);\n    }\n    long area()\n    {\n        return (x2 - x1) * (y2 - y1);\n    }\n};\n\nint main(int argc, const char *argv[])\n{\n    long N, d;\n    scanf(\"%ld %ld\", &N, &d);\n\n    std::vector<Star> stars;\n    stars.reserve(200000);\n    for (long i = 0; i < N; i++)\n    {\n        long x, y, b;\n        scanf(\"%ld %ld %ld\", &x, &y, &b);\n        stars.push_back(Star(x, y, b));\n    }\n    std::sort(stars.begin(), stars.end());\n\n    std::vector<Range> ranges;\n    ranges.push_back(Range(stars[0]));\n    for (long i = 1; i < N; i++)\n    {\n        int cur_b = ranges.back().b;\n        if (cur_b == stars[i].b)\n        {\n            ranges.back().add(stars[i]);\n        }\n        else\n        {\n            ranges.push_back(Range(stars[i]));\n        }\n    }\n\n    long max_area = 0;\n\n    for (long i = 0; i < ranges.size(); i++)\n    {\n        Range range = ranges[i];\n\n        long j;\n        for (j = i; ranges[j].b - ranges[i].b <= d && j < ranges.size(); j++)\n        {\n            range.add(ranges[j]);\n        }\n\n        max_area = max(range.area(), max_area);\n\n        if (j == ranges.size()) break;\n        for (; ranges[j].b - d > ranges[i].b && i < ranges.size(); i++)\n            ;\n    }\n\n    printf(\"%ld\\n\", max_area);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <list>\n \nusing namespace std;\ntypedef long long ll;\n \n#define mod 1000000007\n#define INF 1000000000\n#define SIZE 100000\n\nstruct NODE{\n  int min_d;\n  int max_d;\n  int min_x;\n  int min_y;\n  int max_x;\n  int max_y;\n\n  NODE(){\n    min_d = INF;\n    max_d = 0;\n    min_x = INF;\n    max_x = 0;\n    min_y = INF;\n    max_y = 0;\n  }\n  \n  NODE(int a,int b,int c,int d,int e,int f){\n    min_d = a;\n    max_d = b;\n    min_x = c;\n    max_x = d;\n    min_y = e;\n    max_y = f;\n  }\n\n  NODE operator+ (const NODE &B) const{\n    int a = min(min_d,B.min_d);\n    int b = max(max_d,B.max_d);\n    int c = min(min_x,B.min_x);\n    int d = max(max_x,B.max_x);\n    int e = min(min_y,B.min_y);\n    int f = max(max_y,B.max_y);\n\n    return NODE(a,b,c,d,e,f);\n  }\n};\n\nNODE data[1 << 19];\nint segn2;\n\nNODE query(int a,int b,int k=0){\n  if(b<a) return NODE();\n  if(data[k].max_d < data[k].min_d) return NODE();\n  if(data[k].max_d < a || b < data[k].min_d) return NODE();\n\n  if(a<= data[k].min_d && data[k].max_d <= b) return data[k];\n\n  return query(a,b,k*2+1) + query(a,b,k*2+2);\n}\n\nint main(){\n  int n,d;\n  int x,y,b;\n  vector<pair<int,pair<int,int> > > in;\n\n  scanf(\"%d%d\",&n,&d);\n\n  segn2 = 1;\n  while(segn2<n) segn2*=2;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d%d%d\",&x,&y,&b);\n    in.push_back(make_pair(b,make_pair(x,y)));\n  }\n\n  sort(in.begin(),in.end());\n\n  for(int i=0;i<n;i++){\n    int pd = in[i].first;\n    int px = in[i].second.first;\n    int py = in[i].second.second;\n  \n    data[i+segn2-1] = NODE(pd,pd,px,px,py,py);\n  }\n\n  for(int i = segn2-2;i>=0;i--){\n    data[i] = data[i*2+1] + data[i*2+2];\n  }\n  \n  ll ans = 0,calc;\n  NODE a;\n  \n  for(int i=0;i<n;i++){\n    a = query(in[i].first,in[i].first+d);\n    if(a.max_d < a.min_d) continue;\n    calc = (ll)(a.max_x - a.min_x)*(ll)(a.max_y - a.min_y);\n    ans = max(ans,calc);\n  }\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define in ,\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct Star {\n  ll x, y, d;\n};\n\nint minX[200000 * 2 - 1] = {}, maxX[200000 * 2 - 1] = {},\nminY[200000 * 2 - 1] = {}, maxY[200000 * 2 - 1] = {};\nint n, nn = 1;\n\nvoid update(int k, int a, int c[], int f) {\n  k += n - 1;\n  c[k] = a;\n\n  while(k > 0) {\n    k = (k - 1) / 2;\n    if(f) c[k] = max(c[k * 2 + 1], c[k * 2 + 2]);\n    else c[k] = min(c[k * 2 + 1], c[k * 2 + 2]);\n  }\n}\n\nint query(int a, int b, int k, int l, int r, int c[], int f) {\n  if(r <= a || b <= l) return f ? 0 : INT_MAX;\n  if(a <= l && r <= b) return c[k];\n\n  int vl = query(a, b, k * 2 + 1, l, (l + r) / 2, c, f);\n  int vr = query(a, b, k * 2 + 1, (l + r) / 2, r, c, f);\n\n  return f ? max(vl, vr) : min(vl, vr);\n}\n\nbool asc(Star &l, Star &r) {\n  return l.d < r.d;\n}\n\nint main() {\n  ll d, ans = 0;\n  cin >> n >> d;\n  vector<Star> v(n);\n\n  while(nn < n) nn *= 2;\n\n  rep(i, 0, nn * 2 - 1) {\n    minX[i] = INT_MAX;\n    minY[i] = INT_MAX;\n  }\n\n  rep(i, 0, n) cin >> v[i].x >> v[i].y >> v[i].d;\n\n  sort(v.begin(), v.end(), asc);\n\n  rep(i, 0, n) {\n    update(i, v[i].x, maxX, 1);\n    update(i, v[i].x, minX, 0);\n    update(i, v[i].y, maxY, 1);\n    update(i, v[i].y, minY, 0);\n  }\n\n  int hx, lx, hy, ly, ld = v[0].d, lp = 0;\n  rep(i, 1, n) {\n    if(v[i].d - ld > d) {\n      rep(j, lp + 1, i + 1) {\n        if(v[i].d - v[j].d <= d) {\n          lp = j;\n          break;\n        }\n      }\n    }\n    hx = query(lp, i, 0, 0, n, maxX, 1);\n    lx = query(lp, i, 0, 0, n, minX, 0);\n    hy = query(lp, i, 0, 0, n, maxY, 1);\n    ly = query(lp, i, 0, 0, n, minY, 0);\n    ld = v[lp].d;\n    if(lp != i) ans = max(ans, ((hx - lx) * (ll)(hy - ly)));\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define F first\n#define S second\nconst int MAX_N = 1<<18;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> P;\n\nint n;\nint minX[2*MAX_N-1],maxX[2*MAX_N-1];\nint minY[2*MAX_N-1],maxY[2*MAX_N-1];\n\nstruct Data{\n    int x,y,b;\n    Data(){}\n    Data(int x,int y,int b) : x(x),y(y),b(b) {}\n    bool operator < (const Data &d)const{\n        return b < d.b;\n    }\n};\n\nvoid init(ll n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0 ; i < 2*n-1 ; i++){\n        minX[i] = minY[i] = INT_MAX;\n        maxX[i] = maxY[i] = INT_MIN;\n    }\n}\n\nvoid update(int k,pii p){\n    k += n - 1;\n    minX[k] = min(minX[k],p.first);\n    maxX[k] = max(maxX[k],p.first);\n    minY[k] = min(minY[k],p.second);\n    maxY[k] = max(maxY[k],p.second);\n    while(k > 0){\n        k = (k - 1) / 2;\n        minX[k] = min(minX[2*k+1],minX[2*k+2]);\n        maxX[k] = max(maxX[2*k+1],maxX[2*k+2]);\n        minY[k] = min(minY[2*k+1],minY[2*k+2]);\n        maxY[k] = max(maxY[2*k+1],maxY[2*k+2]);\n    }\n}\n\nP query(int a,int b,int k,int l,int r){\n    if(r <= a || b <= l){\n        return P(pii(INT_MAX,INT_MIN),pii(INT_MAX,INT_MIN));\n    }\n    if(a <= l && r <= b){\n        return P(pii(minX[k],maxX[k]),pii(minY[k],maxY[k]));\n    }else{\n        P vl = query(a,b,2*k+1,l,(l+r)/2);\n        P vr = query(a,b,2*k+2,(l+r)/2,r);\n        return P(pii(min(vl.F.F,vr.F.F),max(vl.F.S,vr.F.S)),\n                 pii(min(vl.S.F,vr.S.F),max(vl.S.S,vr.S.S)));\n    }\n}\n\nll getArea(P p){\n    return (ll)(p.F.S-p.F.F)*(ll)(p.S.S-p.S.F);\n}\n\nint main(){\n    int N,d,x,y,b;\n    cin >> N >> d;\n    vector<Data> v(N);\n    for(int i = 0 ; i < N ; i++){\n        cin >> x >> y >> b;\n        v[i] = Data(x,y,b);\n    }\n    sort(v.begin(),v.end());\n    init(N);\n    for(int i = 0 ; i < N ; i++){\n        update(i,pii(v[i].x,v[i].y));\n    }\n    ll res = 0;\n    for(int i = 0, j = 0 ; i < N ; i++){\n        int s = v[i].b, t = v[j].b;\n        while(j < N && t - s <= d) j++, t = v[j].b;\n        j--;\n        P p = query(i,j+1,0,0,n);\n        res = max(res,getArea(p));\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n#define N 200000\n#define F first\n#define S second\n#define MP(i, j) make_pair((i), (j))\n#define int long long\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pi;\nint cnt;\nvoid init(int n_, int *dat){\n\tcnt = 1;\n\twhile(cnt < n_) cnt *= 2;\n\tfor(int i = 0; i < 2 * cnt - 1; i++) dat[i] = INT_MAX;\n}\nvoid update(int k, int a, int *dat){\n\tk += cnt - 1;\n\tdat[k] = a;\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nint query(int a, int b, int k, int l, int r, int *dat){\n\tif(r <= a || b <= l) return INT_MAX;\n\tif(a <= l && r <= b) return dat[k];\n\telse{\n\t\tint v1 = query(a, b, k * 2 + 1, l, (l + r) / 2, dat);\n\t\tint vr = query(a, b, k * 2 + 2, (l + r) / 2, r, dat);\n\t\treturn min(v1, vr);\n\t}\n}\n\nint i, j, n, d, ax[3 * N], bx[3 * N], ay[3 * N], by[3 * N], ans;\nPi stars[N];\n\nsigned main(){\n\tcin >> n >> d;\n\tfor(i = 0; i < n; i++){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tstars[i] = MP(c, MP(a, b));\n\t}\n\tsort(stars, stars + n);\n\tinit(n, ax); init(n, bx); init(n, ay); init(n, by);\n\tfor(i = 0; i < n; i++){\n\t\tupdate(i, stars[i].S.F, ax);\n\t\tupdate(i, -stars[i].S.F, bx);\n\t\tupdate(i, stars[i].S.S, ay);\n\t\tupdate(i, -stars[i].S.S, by);\n\t}\n\ti = 0; j = 0;\n\tfor(;;){\n\t\twhile(j < n){\n\t\t\tif(stars[j].F - stars[i].F <= d)\n\t\t\t\tj++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tans = max(ans, (-query(i, j, 0, 0, cnt, bx) - query(i, j, 0, 0, cnt, ax)) * (-query(i, j, 0, 0, cnt, by) - query(i, j, 0, 0, cnt, ay)));\n\t\tif(j == n)\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef pair <int,int> P;\n#define f first\n#define s second\n#define INF 1000000000\nint tree[4][(1<<19)];\nint n,d;\npair <int,pair <int,int> > star[(1<<18)];\n\nvoid update(int i,int x,int flg){\n  i = (1<<18)+i-1;\n  tree[flg][i] = x;\n  while(i){\n    i = (i-1)/2;\n    tree[flg][i] = max(tree[flg][i*2+1],tree[flg][i*2+2]);\n  }\n}\n\nint find(int a,int b,int M,int L,int R,int flg){\n  if(b <=L || a >= R) return -INF;\n  if(a <=L && R <= b) return tree[flg][M];\n  int nx = (L+R)/2;\n  return max(find(a,b,M*2+1,L,nx,flg),find(a,b,M*2+2,nx,R,flg));\n}\n\nint main() {\n  cin >> n >> d;\n  for(int i=0;i<(1<<19);i++) \n    for(int j=0;j<4;j++) tree[j][i] = -INF;\n  \n  for(int i=0;i<n;i++) cin >> star[i].s.f >> star[i].s.s >> star[i].f;\n  sort(star,star+n);\n  for(int i=0;i<n;i++) {\n    update(i,star[i].s.f,0); // max(x);\n    update(i,star[i].s.s,1);   // max(y);\n    update(i,-star[i].s.f,2);   // min(x);\n    update(i,-star[i].s.s,3);   // min(y);\n  }\n\n  int now = 0,minx,maxx,miny,maxy,S=0;\n\n  /*  for(int i=0;i<n;i++){\n    cout<< star[i].f << ' ';\n  }\n  cout<<endl;*/\n\n  for(int i=0;i<n;i++) {\n    while(now < n && star[now].f -star[i].f <=d) now++;\n    \n    /*    cout<<i<<' '<<now<<endl;\n    cout<<star[i].f << ' '<<star[now].f <<endl;\n    cout<<endl;*/\n\n    maxx = find(i,now,0,0,(1<<18),0);\n    maxy = find(i,now,0,0,(1<<18),1);\n    minx = find(i,now,0,0,(1<<18),2);\n    miny = find(i,now,0,0,(1<<18),3);\n    S = max(S,(maxx+minx)*(maxy+miny));\n  }\n  cout << S <<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nstruct Star\n{\n    int x, y, b;\npublic:\n    Star(int x, int y, int b): x(x), y(y), b(b) {}\n    bool operator<(const Star& s)\n    {\n        return b < s.b;\n    }\n};\n\nint min(int a, int b)\n{\n    return a < b ? a : b;\n}\n\nint max(int a, int b)\n{\n    return a > b ? a : b;\n}\n\nint main(int argc, const char *argv[])\n{\n    int N, d;\n    scanf(\"%d %d\", &N, &d);\n\n    std::vector<Star> stars;\n    for (int i = 0; i < N; i++)\n    {\n        int x, y, b;\n        scanf(\"%d %d %d\", &x, &y, &b);\n        stars.push_back(Star(x, y, b));\n    }\n    std::sort(stars.begin(), stars.end());\n\n    int max_area = 0;\n\n    for (int i = 0; i < N; i++)\n    {\n        int min_x, max_x, min_y, max_y;\n        min_x = stars[i].x;\n        max_x = stars[i].x;\n        min_y = stars[i].y;\n        max_y = stars[i].y;\n\n        for (int j = i; stars[j].b - stars[i].b <= d && j < N; j++)\n        {\n            min_x = min(min_x, stars[j].x);\n            max_x = max(max_x, stars[j].x);\n            min_y = min(min_y, stars[j].y);\n            max_y = max(max_y, stars[j].y);\n        }\n\n        max_area = max((max_x - min_x) * (max_y - min_y), max_area);\n    }\n\n    printf(\"%d\\n\", max_area);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF (1<<30)\n#define MAX_N 200000\ntypedef long long ll;\n\nstruct MinSegtree\n{\n  int n;\n  int dat[2*MAX_N-1];\n  MinSegtree(int _n)\n  {\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*21;i++)\n      dat[i] = INF;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n\n  ll query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return INF;\n\n    if(a <= l && r <= b) return dat[k];\n    else{\n      ll vl = query(a, b, k*2+1, l, (l + r) / 2);\n      ll vr = query(a, b, k*2+2, (l + r) / 2, r);\n      return min(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nstruct MaxSegtree\n{\n  int n;\n  int dat[2*MAX_N-1];\n  MaxSegtree(int _n){\n    n = 1;\n    while(n < _n)\n      n *= 2;\n    for(int i=0;i<n*2-1;i++)\n      dat[i] = -1;\n  }\n\n  void update(int k, int a)\n  {\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n  \n  ll query(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return -1;\n    \n    if(a <= l && r <=b ) return dat[k];\n    else{\n      ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n      ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n      return max(vl, vr);\n    }\n  }\n  \n  int size()\n  {\n    return n;\n  }\n};\n\nint main()\n{\n  int n, d;\n  scanf(\"%d%d\", &n, &d);\n  MinSegtree minx(n);\n  MinSegtree miny(n);\n  MaxSegtree maxx(n);\n  MaxSegtree maxy(n);\n  \n  vector<pair<ll, pair<ll, ll> > >s(n);\n  vector<ll>br(n);\n  for(int i=0;i<n;i++){\n    ll x, y; ll b;\n    scanf(\"%d%d%lld\", &x, &y, &b);\n    s[i] = make_pair(b, make_pair(x, y));\n    br[i] = b;\n  }\n  sort(s.begin(), s.end());\n  sort(br.begin(), br.end());\n\n\n  for(int i=0;i<n;i++){\n    minx.update(i, s[i].second.first);\n    maxx.update(i, s[i].second.first);\n    miny.update(i, s[i].second.second);\n    maxy.update(i, s[i].second.second);\n  }\n\n  br.push_back(INF);\n  ll res = 0;\n  for(int i=0;i<n;i++){\n    int pos = (int)(upper_bound(br.begin(), br.end(), br[i] + d) - br.begin());\n    ll w = maxx.query(i, pos, 0, 0, maxx.size()) - minx.query(i, pos, 0, 0, minx.size());\n    ll h = maxy.query(i, pos, 0, 0, maxy.size()) - miny.query(i, pos, 0, 0, miny.size());\n    res = max(res, w * h);\n  }\n\n  printf(\"%lld\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\ntypedef pair<int, int>pi;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntypedef pair<P, P> PPP;\n\nconst ll MOD = 1e9 + 7;\nconst ll INF = 5e18;\nconst double DINF = 5e14;\nconst double eps = 1e-10;\nconst int di[4] = { 1,0,-1,0 }, dj[4] = { 0,1,0,-1 };\n\n#define ALL(x) (x).begin(),(x).end()\n#define ALLR(x) (x).rbegin(),(x).rend()\n#define pb push_back\n#define eb emplace_back\n#define fr first\n#define sc second\n\nstruct RMinQ {\nprivate:\n\tint n;\n\tvector<ll>node;\npublic:\n\tRMinQ(vector<ll>v) {\n\t\tint sz = v.size();\n\t\tn = 1;\n\t\twhile (n < sz)n *= 2;\n\t\tnode.resize(2 * n - 1, INF);\n\t\tfor (int i = 0;i < sz;i++)node[i + n - 1] = v[i];\n\t\tfor (int i = n - 2;i >= 0;i--)node[i] = min(node[2 * i + 1], node[2 * i + 2]);\n\t}\n\tll getmin(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = n;\n\t\tif (r <= a || b <= l)return INF;\n\t\tif (a <= l && r <= b)return node[k];\n\t\tll vl = getmin(a, b, 2 * k + 1, l, (l + r)/ 2);\n\t\tll vr = getmin(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\nstruct RMaxQ {\nprivate:\n\tint n;\n\tvector<ll>Node;\npublic:\n\tRMaxQ(vector<ll>v) {\n\t\tint sz = v.size();\n\t\tn = 1;\n\t\twhile (n < sz)n *= 2;\n\t\tNode.resize(2 * n - 1, -1);\n\t\tfor (int i = 0;i < sz;i++)Node[i + n - 1] = v[i];\n\t\tfor (int i = n - 2;i >= 0;i--)Node[i] = max(Node[2 * i + 1], Node[2 * i + 2]);\n\t}\n\tll getmax(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = n;\n\t\tif (r <= a || b <= l)return -1;\n\t\tif (a <= l && r <= b)return Node[k];\n\t\tll vl = getmax(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tll vr = getmax(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n};\n\nll N, d, x, y, s, ans;\nvector<PP>v;\nvector<ll>vv, xx, yy;\n\nint main() {\n\tcin >> N >> d;\n\tfor (int i = 0;i < N;i++) {\n\t\tcin >> x >> y >> s;\n\t\tv.eb(PP(s, P(x, y)));\n\t}\n\tsort(ALL(v));\n\txx.resize(N), yy.resize(N), vv.resize(N);\n\tfor (int i = 0;i < N;i++) {\n\t\tvv[i] = v[i].fr;\n\t\txx[i] = v[i].sc.fr;\n\t\tyy[i] = v[i].sc.sc;\n\t}\n\tRMinQ xmn(xx), ymn(yy);\n\tRMaxQ xmx(xx), ymx(yy);\n\tfor (int i = 0;i < N;i++) {\n\t\tint it = upper_bound(ALL(vv), vv[i] + d) - vv.begin();\n\t\tans = max(ans, (xmx.getmax(i, it) - xmn.getmin(i, it))*(ymx.getmax(i, it) - ymn.getmin(i, it)));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <vector>\n#include <utility>\n#include <numeric>\n#include <string>\n#include <set>\n#include <map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#define rep(i, a, n) for(int (i) = (int)(a);(i) < (int)(n);++(i))\n#define repe(i, a, n) for(int (i) = (int)(a);(i) <= (int)(n);++(i))\n#define repr(i, a, n) for(int (i) = (int)(a);(i) > (int)(n);--(i))\n#define reper(i, a, n) for(int (i) = (int)(a);(i) >= (int)(n);--(i))\n#define SIZE(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define RNG(x, n) &((x)[0]), &((x)[n])\n#define SUBIF(a, b, x) ((x) ? (b) : (a))\n#define YES cout << \"YES\" << endl\n#define NO cout << \"NO\" << endl\n#define Yes cout << \"Yes\" << endl\n#define No cout << \"No\" << endl\n#define yes cout << \"yes\" << endl;\n#define no cout << \"no\" << endl;\n#define pb push_back\n#define EPS (1e-20)\n#define INF 2147483647\n#define MOD 1000000007\nusing llint = long long;\nusing VI = std::vector<int>;\nusing PII = std::pair<int, int>;\nusing SI = std::set<int>;\nusing MII = std::map<int, int>;\nusing TIII = std::tuple<int, int, int>;\nusing namespace std;\n\n\nstruct SEG {\n\tint aryN;\n\tvector<PII> seg;\n\n\tSEG(){}\n\tSEG(const VI &v){\n\t\taryN = (int)pow(2, (int)ceil(log2(SIZE(v))));\n\t\tseg.resize(2*aryN-1, { -1, INF });\n\t\trep(i, 0, SIZE(v)) seg[i+aryN-1] = { v[i], v[i] };\n\t\treper(i, aryN-2, 0) seg[i].first = max(seg[2*i+1].first, seg[2*i+2].first), seg[i].second = min(seg[2*i+1].second, seg[2*i+2].second);\n\t}\n\tvoid update(int x, PII p){\n\t\tx += (aryN-1);\n\t\tseg[x] = p;\n\t\twhile(x > 0){\n\t\t\tx = (x-1)/2;\n\t\t\tseg[x].first = max(seg[2*x+1].first, seg[2*x+2].first);\n\t\t\tseg[x].second = min(seg[2*x+1].second, seg[2*x+2].second);\n\t\t}\n\t}\n\tint getMax(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = aryN;\n\t\tif(r <= a || b <= l) return -1;\n\t\tif(a <= l && r <= b) return seg[k].first;\n\t\tint vl = getMax(a, b, 2*k+1, l, (l+r)/2);\n\t\tint vr = getMax(a, b, 2*k+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n\tint getMin(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = aryN;\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <= b) return seg[k].second;\n\t\tint vl = getMin(a, b, 2*k+1, l, (l+r)/2);\n\t\tint vr = getMin(a, b, 2*k+2, (l+r)/2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\n\nint N, d;\nvector<TIII> s;\nint br[200010];\nSEG X, Y;\n\n\ntemplate<int N>\nVI tupleToVec(vector<TIII>& vt){\n\tVI ret;\n\tfor(TIII t : vt) ret.pb(get<N>(t));\n\treturn ret;\n}\n\n\nllint solve(){\n\tllint ans = 0;\n\trep(i, 0, N) br[i] = get<0>(s[i]);\n\tX = SEG(tupleToVec<1>(s));\n\tY = SEG(tupleToVec<2>(s));\n\trep(i, 0, N){\n\t\tint p = upper_bound(RNG(br, N), br[i]+d)-&br[0];\n\t\tllint x1 = X.getMax(i, p), x2 = X.getMin(i, p);\n\t\tllint y1 = Y.getMax(i, p), y2 = Y.getMin(i, p);\n\t\tans = max(ans, (x1-x2)*(y1-y2));\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> N >> d;\n\ts = vector<TIII>(N);\n\trep(i, 0, N) cin >> get<1>(s[i]) >> get<2>(s[i]) >> get<0>(s[i]);\n\tsort(ALL(s));\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <list>\n \nusing namespace std;\ntypedef long long ll;\n \n#define mod 1000000007\n#define INF 1000000000\n#define SIZE 100000\n\nstruct NODE{\n  int min_d;\n  int max_d;\n  int min_x;\n  int min_y;\n  int max_x;\n  int max_y;\n\n  NODE(){\n    min_d = INF;\n    max_d = 0;\n    min_x = INF;\n    max_x = 0;\n    min_y = INF;\n    max_y = 0;\n  }\n  \n  NODE(int a,int b,int c,int d,int e,int f){\n    min_d = a;\n    max_d = b;\n    min_x = c;\n    max_x = d;\n    min_y = e;\n    max_y = f;\n  }\n\n  NODE operator+ (const NODE &B) const{\n    int a = min(min_d,B.min_d);\n    int b = max(max_d,B.max_d);\n    int c = min(min_x,B.min_x);\n    int d = max(max_x,B.max_x);\n    int e = min(min_y,B.min_y);\n    int f = max(max_y,B.max_y);\n\n    return NODE(a,b,c,d,e,f);\n  }\n};\n\nNODE data[1 << 7/*19*/];\nint segn2;\n\n\nvoid set(int k,pair<int,pair<int,int> > p){\n  int d = p.first;\n  int x = p.second.first;\n  int y = p.second.second;\n  \n  data[k+segn2-1] = NODE(d,d,x,x,y,y);\n}\n\nvoid init(){\n  for(int i = segn2-2;i>=0;i--){\n    data[i] = data[i*2+1] + data[i*2+2];\n  }\n}\n\nNODE query(int a,int b,int k=0){\n  if(b<a) return NODE();\n  if(data[k].max_d < data[k].min_d) return NODE();\n  if(data[k].max_d < a || b < data[k].min_d) return NODE();\n\n  if(a<= data[k].min_d && data[k].max_d <= b) return data[k];\n\n  return query(a,b,k*2+1) + query(a,b,k*2+2);\n}\n\nint main(){\n  int n,d;\n  int x,y,b;\n  vector<pair<int,pair<int,int> > > in;\n\n  scanf(\"%d%d\",&n,&d);\n\n  segn2 = 1;\n  while(segn2<n) segn2*=2;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d%d%d\",&x,&y,&b);\n    in.push_back(make_pair(b,make_pair(x,y)));\n  }\n\n  sort(in.begin(),in.end());\n\n  for(int i=0;i<n;i++){\n    set(i,in[i]);\n  }\n\n  init();\n  \n  ll ans = 0;\n  \n  for(int i=0;i<n;i++){\n    NODE a = query(in[i].first,in[i].first+d);\n    if(a.max_d < a.min_d) continue;\n    ll calc = (ll)(a.max_x - a.min_x)*(a.max_y - a.min_y);\n    ans = max(ans,calc);\n  }\n\n  cerr << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<functional>\n#include<algorithm>\n#include<queue>\n#define MM 2100000000\nusing namespace std;\ntypedef pair<int,int> P;\nP px[200001],py[200001],p1;\nint main(void)\n{\n\tint n,d,i,j,x,y,b,bb,x1,x2,y1,y2;\n\tlong long s,mx;\n\tpriority_queue<P> qxmx,qymx;\n\tpriority_queue<P, vector<P> ,greater<P> > qxmn,qymn;\n\tscanf(\"%d %d\",&n,&d);\n\tfor(i=0;i<n;i++)\t{\n\t\tscanf(\"%d %d %d\",&x,&y,&b);\n\t\tpx[i].first=b;\tpx[i].second=x;\n\t\tpy[i].first=b;\tpy[i].second=y;\n\t}\n\tpx[n].first=MM;\tpx[n].second=MM;\n\tpy[n].first=MM;\tpy[n].second=MM;\n\tsort(px,px+n+1);\n\tsort(py,py+n+1);\n//\tfor(i=0;i<n+1;i++)\tprintf(\"%d %d\\n\",px[i].first,px[i].second);\n\tj=0;\n\twhile(1)\t{\n\t\tif(px[j].first<=px[0].first+d)\t{\n\t\t\tqxmn.push(P(px[j].second,px[j].first));\n\t\t\tqymn.push(P(py[j].second,py[j].first));\n\t\t\tqxmx.push(P(px[j].second,px[j].first));\n\t\t\tqymx.push(P(py[j].second,py[j].first));\n\t\t\tj++;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\tp1=qxmn.top();\tx1=p1.first;\n\tp1=qymn.top();\ty1=p1.first;\t\n\tp1=qxmx.top();\tx2=p1.first;\n\tp1=qymx.top();\ty2=p1.first;\t\n\tmx=(long long)(x2-x1)*(y2-y1);\n\tfor(i=1;i<n;i++)\t{\n\t\twhile(qxmn.size()!=0)\t{\n\t\t\tp1=qxmn.top();\t\n\t\t\tif(p1.second<px[i].first)\tqxmn.pop();\n\t\t\telse break;\n\t\t}\n\t\twhile(qymn.size()!=0)\t{\n\t\t\tp1=qymn.top();\t\n\t\t\tif(p1.second<py[i].first)\tqymn.pop();\n\t\t\telse break;\n\t\t}\t\t\n\t\twhile(qxmx.size()!=0)\t{\n\t\t\tp1=qxmx.top();\t\n\t\t\tif(p1.second<px[i].first)\tqxmx.pop();\n\t\t\telse break;\n\t\t}\t\n\t\twhile(qymx.size()!=0)\t{\n\t\t\tp1=qymx.top();\t\n\t\t\tif(p1.second<py[i].first)\tqymx.pop();\n\t\t\telse break;\n\t\t}\t\n\t\twhile(1)\t{\n\t\t\tif(px[j].first<=px[i].first+d)\t{\n\t\t\t\tqxmn.push(P(px[j].second,px[j].first));\n\t\t\t\tqymn.push(P(py[j].second,py[j].first));\n\t\t\t\tqxmx.push(P(px[j].second,px[j].first));\n\t\t\t\tqymx.push(P(py[j].second,py[j].first));\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp1=qxmn.top();\tx1=p1.first;\n\t\tp1=qymn.top();\ty1=p1.first;\t\n\t\tp1=qxmx.top();\tx2=p1.first;\n\t\tp1=qymx.top();\ty2=p1.first;\t\n\t\tmx=max(mx,(long long)(x2-x1)*(y2-y1));\n\t}\t\n\tprintf(\"%lld\\n\",mx);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nstruct RangeMinimumQuery {\n\tvector<T> value;\n\tint size;\n\t\n\tRangeMinimumQuery(int N, T x = numeric_limits<T>::max()){\n\t\tfor (size = 1; size < N; size *= 2){}\n\t\tvalue.assign(size * 2 - 1, x);\n\t}\n\t\n\tvoid update(int k, int x){\n\t\tk += size - 1;\n\t\tvalue[k] = x;\n\t\twhile (k > 0){\n\t\t\tk = (k - 1) / 2;\n\t\t\tvalue[k] = min(value[k * 2 + 1], value[k * 2 + 2]);\n\t\t}\n\t}\n\t\n\tT _getMin(int l, int r, int k, int a, int b){\n\t\tif (b <= l || r <= a) return numeric_limits<T>::max();\n\t\tif (l <= a && b <= r) return value[k];\n\t\tint m = (a + b) / 2;\n\t\tT vl = _getMin(l, r, k * 2 + 1, a, m);\n\t\tT vr = _getMin(l, r, k * 2 + 2, m, b);\n\t\treturn min(vl, vr);\n\t}\n\t\n\tT getMin(int l, int r){\n\t\treturn _getMin(l, r, 0, 0, size);\n\t}\n};\n\ntypedef long long lint;\ntypedef tuple<int, int, int> Star;\nconst int INF = 1 << 28;\n\nint n, d;\nStar star[200001];\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &d);\n\tfor (int i = 0; i < n; i++){\n\t\tint x, y, b;\n\t\tscanf(\"%d %d %d\", &x, &y, &b);\n\t\tstar[i] = Star(b, x, y);\n\t}\n\tstar[n] = Star(INT_MAX, 0, 0);\n\t\n\tsort(star, star + n);\n\t\n\tRangeMinimumQuery<int> seglx(n), segly(n);\n\tRangeMinimumQuery<int> segrx(n, -INF), segry(n, -INF);\n\tfor (int i = 0; i < n; i++){\n\t\tseglx.update(i, get<1>(star[i]));\n\t\tsegly.update(i, get<2>(star[i]));\n\t\tsegrx.update(i, -get<1>(star[i]));\n\t\tsegry.update(i, -get<2>(star[i]));\n\t}\n\t\n\tlint res = 0;\n\tfor (int left = 0, right = 0; left < n; left++){\n\t\twhile (true){\n\t\t\tint ld = get<0>(star[left]);\n\t\t\tint rd = get<0>(star[right]);\n\t\t\tif (rd - ld > d) break;\n\t\t\tright++;\n\t\t}\n\t\t\n\t\tint width = -segrx.getMin(left, right) - seglx.getMin(left, right);\n\t\tint height = -segry.getMin(left, right) - segly.getMin(left, right);\n\t\tlint area = (lint)width * height;\n\t\tres = max(res, area);\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+17 + 10;\n\nconst int maxN = 2000001;\n\nclass RMQ{\nprivate:\n\tint n;\n\tP dat[maxN * 2];\n\n\t//[a,b),[l,r) //(Max,Min)\n\tP rec(int a, int b, int k, int l, int r){\n\t\tif (b <= l || r <= a)return P(-infi, infi);\n\t\tif (a <= l && r <= b)return P(dat[k].first, dat[k].second);\n\t\telse {\n\t\t\tP vl = rec(a, b, 2 * k + 1, l, (l + r) / 2), vr = rec(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\t\treturn P(std::max(vl.first, vr.first), std::min(vl.second, vr.second));\n\t\t}\n\t}\n\npublic:\n\tvoid init(int x){\n\t\tn = 1;\n\t\twhile (n < x)n *= 2;\n\t\trep(i, 2 * n - 1)dat[i] = P(-infi, infi);\n\t}\n\n\tvoid update(int k, int a){\n\t\tk += n - 1;\n\t\tdat[k] = P(a, a);\n\t\twhile (k > 0){\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k].first = std::max(dat[2 * k + 1].first, dat[2 * k + 2].first);\n\t\t\tdat[k].second = std::min(dat[2 * k + 1].second, dat[2 * k + 2].second);\n\t\t}\n\t}\n\n\t//[a,b] //(Max,Min)\n\tP query(int a, int b){\n\t\treturn rec(a, b + 1, 0, 0, n);\n\t}\n};\n\nstruct Star{ int x, y, b; };\nStar star[200001];\nint n, d;\nRMQ up, right;\n\nbool comp(const Star &lhs, const Star &rhs){\n\treturn lhs.b < rhs.b;\n}\n\nint main(){\n\tstd::cin >> n >> d;\n\trep(i, n)std::cin >> star[i].x >> star[i].y >> star[i].b;\n\tstd::sort(star, star + n, comp);\n\tint ans = 0;\n\tint first = 0;\n\tup.init(n), right.init(n);\n\trep(i, n){\n\t\tup.update(i, star[i].y);\n\t\tright.update(i, star[i].x);\n\t\twhile (star[i].b - star[first].b > d)++first;\n\t\tP a = up.query(first, i), b = right.query(first, i);\n\t\tans = std::max(ans, (a.first - a.second) * (b.first - b.second));\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct STAR {\n  int x, y, d;\n};\n\nbool asc(STAR &l, STAR &r) {\n  return l.d < r.d;\n}\n\nint main() {\n  ll n, d, ans = 0;\n  cin >> n >> d;\n  vector<STAR> v(n);\n\n  rep(i, 0, n) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    v[i].x = a;\n    v[i].y = b;\n    v[i].d = c;\n  }\n\n  sort(v.begin(), v.end(), asc);\n\n  int hx = v[0].x, lx = v[0].x, hy = v[0].y, ly = v[0].y, ld = v[0].d, lp = 0;\n  rep(i, 0, n - 1) {\n    if(v[i + 1].d - ld <= d) {\n      hx = max(hx, v[i + 1].x);\n      hy = max(hy, v[i + 1].y);\n      lx = min(lx, v[i + 1].x);\n      ly = min(ly, v[i + 1].y);\n    }else {\n      ans = max(ans, (ll)(abs(hx - lx) * abs(hy - ly)));\n      int klp = lp;\n      rep(j, lp + 1, i + 1) {\n        if(v[i + 1].d - v[j].d <= d) {\n          lp = j;\n          break;\n        }\n      }\n      if(klp == lp) lp = i + 1;\n      hx = v[lp].x, lx = v[lp].x, hy = v[lp].y, hx = v[lp].y;\n      rep(j, lp + 1, i + 1) {\n        hx = max(hx, v[j].x);\n        hy = max(hy, v[j].y);\n        lx = min(lx, v[j].x);\n        ly = min(ly, v[j].y);\n      }\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    int n,d;\n    cin >> n >> d;\n    map<int,vector<pii>> m;\n    rep(i,0,n){\n        int x,y,b;\n        cin >> x >> y >> b;\n        m[b].push_back(make_pair(x,y));\n    }\n    \n    vector<int> v1[2],v2[2],ds; //上,右、下、左\n    for(auto it=m.begin(); it!=m.end(); ++it){\n        ds.push_back(it->first);\n        int a=0,b=0,c=inf,d=inf;\n        vector<pii> &tmp=it->second;\n        rep(i,0,tmp.size()){\n            a=max(a,tmp[i].second);\n            b=max(b,tmp[i].first);\n            c=min(c,tmp[i].second);\n            d=min(d,tmp[i].first);\n        }\n        v1[0].push_back(a);\n        v1[1].push_back(b);\n        v2[0].push_back(c);\n        v2[1].push_back(d);\n    }\n    \n    ll ans=0,s=0;\n    priority_queue<ll,vector<ll>> q1[2],del1[2];\n    priority_queue<ll,vector<ll>,greater<ll>> q2[2],del2[2];\n    rep(t,0,ds.size()){\n        rep(i,0,2) q1[i].push(v1[i][t]);\n        rep(i,0,2) q2[i].push(v2[i][t]);\n        while(ds[t]-ds[s]>d){\n            rep(i,0,2) del1[i].push(v1[i][s]);\n            rep(i,0,2) del2[i].push(v2[i][s]);\n            ++s;\n        }\n        rep(i,0,2){\n            while(!q1[i].empty() and !del1[i].empty() and q1[i].top()==del1[i].top()){\n                q1[i].pop();\n                del1[i].pop();\n            }\n            while(!q2[i].empty() and !del2[i].empty() and q2[i].top()==del2[i].top()){\n                q2[i].pop();\n                del2[i].pop();\n            }\n        }\n        ans=max(ans,(q1[0].top()-q2[0].top())*(q1[1].top()-q2[1].top()));\n    }\n    \n    cout << ans << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define f first\n#define s second\n#define INF 2000000\nusing namespace std;\ntypedef long long ll;\npair<int,pair<int,int> >st[1<<18];\nint tree[4][1<<19];\n\nint get(int a,int b,int n,int l,int r,int f){\n  if(r<=a||b<=l)return -INF;\n  if(a<=l&&r<=b)return tree[f][n];\n  int m=(l+r)/2;\n  return max(get(a,b,n*2+1,l,m,f),get(a,b,n*2+2,m,r,f));\n}\n\nvoid koshin(int i,int x,int f){\n  i+=(1<<18)-1;\n  tree[f][i]=x;\n  while(i){\n    i=(i-1)/2;\n    tree[f][i]=max(tree[f][i*2+1],tree[f][i*2+2]);\n  }\n}\n\nint main(){\n  int n,d;\n  cin>>n>>d;\n  for(int i=0;i<n;i++) cin>>st[i].s.f>>st[i].s.s>>st[i].f;\n  sort(st,st+n);\n  for(int i=0;i<(1<<19);i++)\n    for(int j=0;j<4;j++)tree[j][i]=-INF;\n  for(int i=0;i<n;i++){\n    koshin(i,st[i].s.f,0);\n    koshin(i,st[i].s.s,1);\n    koshin(i,-st[i].s.f,2);\n    koshin(i,-st[i].s.s,3);\n  }\n  int j=0;\n  ll an=0;\n  for(int i=0;i<n;i++){\n    while(j!=n&&st[j].f-st[i].f<=d)j++;\n    ll w=get(i,j,0,0,(1<<18),0)+get(i,j,0,0,(1<<18),2);\n    ll h=get(i,j,0,0,(1<<18),1)+get(i,j,0,0,(1<<18),3);\n    if(h>0&&w>0)an=max(an,h*w);\n  }\n  cout<<an<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\n\nstruct Star{\n    int x,y,b;\n    Star(int x=0,int y=0,int b=0) :\n        x(x),y(y),b(b){}\n    bool operator<(const Star &rth) const {\n        return std::tie(b,x,y)<std::tie(rth.b,rth.x,rth.y);\n    }\n};\n\nstruct SegTree {\n    int n;\n    vector<int> min_dat;\n    vector<int> max_dat;\n    SegTree(int N) {\n        n=1;\n        while(n<N) n*=2;\n        min_dat.assign(1<<18,INF);\n        max_dat.assign(1<<18,0);\n    }\n\n    void update(int k,int a) {\n        k+=n-1;\n        min_dat[k]=a;\n        max_dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            min_dat[k]=min(min_dat[k*2+1],min_dat[k*2+2]);\n            max_dat[k]=max(max_dat[k*2+1],max_dat[k*2+2]);\n        }\n    }\n\n    int min_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return INF;\n\n        if(a<=l&&r<=b) return min_dat[k];\n        else {\n            int vl=min_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=min_query(a,b,k*2+2,(l+r)/2,r);\n            return min(vl,vr);\n        }\n    }\n\n    int max_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return 0;\n\n        if(a<=l&&r<=b) return max_dat[k];\n        else {\n            int vl=max_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=max_query(a,b,k*2+2,(l+r)/2,r);\n            return max(vl,vr);\n        }\n    }\n\n    void dump() {\n        rep(i,n) cout<<max_dat[i]<<\" \";\n        cout<<endl;\n    }\n\n};\nint N,d;\n\n\nvector<Star> stars;\n\nint find(int x) {\n    int l=0;\n    int r=stars.size()-1;\n    while(r-l>1) {\n        int mid=(l+r)/2;\n        if(stars[mid].b<x) l=mid;\n        else r=mid;\n    }\n    return r;\n}\nint main() {\n    cin>>N>>d;\n    rep(i,N) {\n        Star s;\n        cin>>s.x>>s.y>>s.b;\n        stars.pb(s);\n    }\n    SegTree segTreeX(N);\n    SegTree segTreeY(N);\n\n    sort(all(stars));\n\n    rep(i,stars.size()) {\n        // printf(\"%d %d %d %d\\n\",i,stars[i].x,stars[i].y,stars[i].b);\n        segTreeX.update(i,stars[i].x);\n        segTreeY.update(i,stars[i].y);\n    }\n\n\n    int ans=0;\n    int n=segTreeX.n;\n    rep(i,stars.size()) {\n        int pos=find(stars[i].b+d);\n        int tmp=0;\n        tmp=segTreeX.max_query(i,pos+1,0,0,n)-segTreeX.min_query(i,pos+1,0,0,n);\n        tmp*=segTreeY.max_query(i,pos+1,0,0,n)-segTreeY.min_query(i,pos+1,0,0,n);\n\n        // cout<<i<<\",\"<<stars[i].b+d<<\",\"<<pos<<\",\"<<tmp<<endl;\n        ans = max(ans,tmp);\n\n    }\n\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct star {\n  int x,y,b;\n  star(int x,int y,int b) {\n    this->x = x;\n    this->y = y;\n    this->b = b;\n  }\n};\n\nstruct sort_blight {\n  bool operator()(const star& st1, const star& st2)\n  {\n      return st1.b < st2.b;\n  }\n};\n\nint compute_stars_surface(vector<star>& stars,int st,int en) {\n  int minx,miny,maxx,maxy;\n  minx = maxx = stars[st].x;\n  miny = maxy = stars[st].y;\n  for(int i=st;i<=en;i++) {\n    int x = stars[i].x;\n    int y = stars[i].y;\n    minx = min(minx,x);\n    miny = min(miny,y);\n    maxx = max(maxx,x);\n    maxy = max(maxy,y);\n  }\n  return (maxx - minx) * (maxy - miny);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int N,d;\n  vector<star> stars;\n\n  cin >> N >> d;\n  while(N--) {\n    int x,y,b;\n    cin >> x >> y >> b;\n    star st(x,y,b);\n    stars.push_back(st);\n  }\n  sort(stars.begin(),stars.end(),sort_blight());\n\n  int st = 0;\n  int en = 0;\n  int max_surface = 0;\n  while(en < stars.size()) {\n    if(stars[en].b - stars[st].b <= d) {\n      max_surface = max(max_surface,compute_stars_surface(stars,st,en));\n      en++;\n      st = 0;\n    }\n    else {\n      st++;\n    }\n  }\n  cout << max_surface << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 30;\n\nconst int nmax=200010;\nint n,d;\nint x[nmax],y[nmax],b[nmax];\n\nint index[nmax];\n\nint offset;\nint xdata[1<<19][2],ydata[1<<19][2];\n\nvoid init(int m){\n\toffset=1;\n\twhile(offset<m) offset*=2;\n\trep(i,2*offset-1){\n\t\txdata[i][0]=ydata[i][0]=inf;\n\t\txdata[i][1]=ydata[i][1]=-inf;\n\t}\n}\n\nvoid update(int data[1<<19][2],int k,int x){\n\tk+=offset-1;\n\tdata[k][0]=min(data[k][0],x);\n\tdata[k][1]=max(data[k][1],x);\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdata[k][0]=min(data[2*k+1][0],data[2*k+2][0]);\n\t\tdata[k][1]=max(data[2*k+1][1],data[2*k+2][1]);\n\t}\n\treturn;\n}\n\npii query(int data[1<<19][2],int a,int b,int k,int l,int r){\n\t// cerr << a << \" \" << b <<\" \" << k << \" \" << l << \" \" << r << endl;\n\tif(b<=l||r<=a)\n\t\treturn make_pair(inf,-inf);\n\tif(a<=l&&r<=b)\n\t\treturn make_pair(data[k][0],data[k][1]);\n\telse{\n\t\tpii vl=query(data,a,b,2*k+1,l,(l+r)/2);\n\t\tpii vr=query(data,a,b,2*k+2,(l+r)/2,r);\n\t\treturn\tmake_pair(min(vl.first,vr.first),max(vl.second,vr.second));\n\t}\n}\n\nint main(void){\n\tcin >> n >> d;\n\trep(i,n) cin >> x[i] >> y[i] >> b[i];\n\trep(i,n) index[i]=b[i];\n\tsort(index,index+n);\n\tint m=unique(index,index+n)-index;\n\tinit(m);\n\n\trep(i,n){\n\t\tint pos=lower_bound(index,index+m,b[i])-index;\n\t\tupdate(xdata,pos,x[i]);\n\t\tupdate(ydata,pos,y[i]);\n\t}\n\n\n\tll ans=0LL;\n\trep(i,m){\n\t\tint j=upper_bound(index,index+m,index[i]+d)-index;\n\t\tpii xx=query(xdata,i,j,0,0,offset);\n\t\tpii yy=query(ydata,i,j,0,0,offset);\n\t\tans=max(ans,1LL*(xx.second-xx.first)*(yy.second-yy.first));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing ll=long long int;\n\nconstexpr int MAX_N=(1<<18),INF=2*(int)1e6;\n\nusing P=std::pair<int,int>;//max,min\n\nint n,d;\n\nstd::map<int,std::set<int>> mapX,mapY;\n\nstd::vector<P> maxmin;\n\nstd::vector<int> vec,res;\n\nP calc(const P& lhs,const P& rhs){\n\n    return P(std::max(lhs.first,rhs.first),std::min(lhs.second,rhs.second));\n}\n\nP seg[MAX_N*2-1];\n\nvoid init(int _n) {\n\n    n=1;\n\n    while(n<_n)\n        n*=2;\n\n    for(int i=0;i<n*2-1;++i)\n        seg[i]=P(0,INF);\n\n    for(int i=0;i<_n;++i)\n        seg[i+n-1]=maxmin[i];\n\n    for(int i=n-2;i>=0;--i)\n        seg[i]=calc(seg[i*2+1],seg[i*2+2]);\n}\n\nP query(int a,int b,int k,int l,int r){\n\n    if(b<=l||r<=a)\n        return P(0,INF);\n    \n    if(a<=l&&r<=b)\n        return seg[k];\n    \n    return calc(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n}\n\nstd::vector<int> solve(std::map<int,std::set<int>>& map){\n\n    res.clear();\n    maxmin.clear();\n    vec.clear();\n\n    for(auto&& s : map){\n        vec.emplace_back(s.first);\n        maxmin.emplace_back(*(s.second.rbegin()),*(s.second.begin()));\n    }\n\n    init(maxmin.size());\n\n    for(int i=0;i<vec.size();++i){\n        P p=query(i,std::upper_bound(vec.begin(),vec.end(),vec[i]+d)-vec.begin(),0,0,n);\n        res.emplace_back(p.first-p.second);\n    }\n\n    return res;\n}\n\nint main() {\n\n    std::cin>>n>>d;\n\n    int x,y,b;\n\n    for(int i=0;i<n;++i){\n\n        std::cin>>x>>y>>b;\n\n        mapX[b].emplace(x);\n        mapY[b].emplace(y);\n    }\n\n    std::vector<int> ansX=solve(mapX);\n\n    std::vector<int> ansY=solve(mapY);\n\n    ll ans=0;\n\n    for(int i=0;i<ansX.size();++i)\n        ans=std::max(ans,ll(ansX[i])*ll(ansY[i]));\n\n    std::cout<<ans<<std::endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define b first\n#define x second.first\n#define y second.second\n#define INF 2000000\nusing namespace std;\npair<int,pair<int,int> >s[INF];\nint main(){\n  int n,d,an=0,f=0;\n  cin>>n>>d;\n  for(int i=0;i<n;i++)cin>>s[i].x>>s[i].y>>s[i].b;\n  sort(s,s+n);\n  for(int i=0;i<n;i++){\n    int xmn,xmx,ymn,ymx;\n    xmn=ymn=INF;xmx=ymx=0;\n    for(int j=i;s[j].b-s[i].b<=d;j++){\n      xmx=max(xmx,s[j].x);\n      ymx=max(ymx,s[j].y);\n      xmn=min(xmn,s[j].x);\n      ymn=min(ymn,s[j].y);\n      if(j==n-1){f=1;break;}\n    }\n    an=max(an,(xmx-xmn)*(ymx-ymn));\n    if(f==1)break;\n  }\n  cout<<an<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define repp(i,k,n) for(int i=k;i<(int)n;i++)\n#define rei(n) for(int i=0;i<(int)n;i++)\n#define rel(n) for(int l=0;l<(int)n;l++)\n//#define int long long\n#define al(s) s.begin(),s.end()\n#define INT_MAX 2147483647\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> ppi;\ntypedef pair<int, ppi> pipp;\ntypedef pair<int, pi> pip;\ntypedef pair<long long, pi> llpi;\n\nstruct SegTree\n{\n\tint N;\n\tvector<long long> Seg;\n\tvoid init(int n)\n\t{\n\t\tN = 1;\n\t\twhile (N < n)N *= 2;\n\t\tfor (int i = 0; i < N*2; i++)\n\t\t{\n\t\t\tSeg.push_back(INT_MAX);\n\t\t}\n\t\t\n\t}\n\t\n\tvoid update(int k, int a)\n\t{\t\n\t\tk = k - 1 + N;\n\t\tSeg[k] = a;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\tSeg[k] = min(Seg[2 * k + 1], Seg[2 * k + 2]);\n\t\t}\n\t}\n\tint find_min(int a, int b)\n\t{\n\t\treturn query(a, b, 0, 0, N);\n\t}\n\n\tint query(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || l >= b)return INT_MAX;\n\t\tif (l>=a&&r<=b)\n\t\t{\n\t\t\treturn Seg[k];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn min(query(a, b, k * 2 + 1, l, (r + l) / 2),\n\t\t\t\t\t   query(a, b, k * 2 + 2, (r + l) / 2, r));\n\t\t}\n\t}\n};\n\nSegTree ss[4];//min,max\n\nvector<llpi> a;\nset<long long> s;\nint main()\n{\n\tlong long ans = 0;\n\tlong long n, d;\n\tcin >> n >> d;\n\trei(4)ss[i].init(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlong long b;\n\t\tint x, y;\n\t\tcin >> x >> y >> b;\n\t\ta.push_back(llpi(b, pi(x, y)));\n\t\ts.insert(b);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint jj = 0;\n\t\tset<long long> ::iterator it = s.find(a[i].first);\n\t\tfor (set<long long>::iterator l = s.begin(); l != it; l++)\n\t\t{\n\t\t\tjj++;\n\t\t}\n\t\t\n\t\tss[0].update(jj, min(a[i].second.first, ss[0].Seg[jj + ss[0].N - 1]));\n\t\tss[2].update(jj, min(a[i].second.first*(-1), ss[2].Seg[jj + ss[0].N - 1]));\n\n\t\tss[1].update(jj, min(a[i].second.second, ss[1].Seg[jj + ss[0].N - 1]));\n\t\tss[3].update(jj, min(a[i].second.second*(-1), ss[3].Seg[jj + ss[0].N - 1]));\n\n\t}\n\tbool end = false;\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tif(end)break;\n\t\tset<long long>::iterator it, ne;\n\t\tit = s.begin();\n\t\tfor (int l = 0; l < i; l++)it++;\n\t\tne = s.upper_bound(*it + d);\n\t\tif (ne == s.end())end = true;\n\t\tne--;\n\t\tint coun = 0;\n\t\tfor (; it != ne; it++)coun++;\n\t\tcoun += i;\n\t\tcoun++;\n\t\tans = max( ans, ((-1) * ss[2].find_min(i, coun) - ss[0].find_min(i, coun)) * ((-1) * ss[3].find_min(i, coun) - ss[1].find_min(i, coun)) );\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n#define MAX_N 200000\n#define F first\n#define Se second\n#define MP(i, j) make_pair((i), (j))\n#define int long long\nstruct S{\n\tint sx, lx, sy, ly;\n\tS(int isx, int ilx, int isy, int ily): sx(isx), lx(ilx), sy(isy), ly(ily){}\n\tbool operator<(const S &s) const { \n\t\treturn 1;\n\t}\n};\nint cnt;\nvoid init(int n_, int *dat){\n\tcnt = 1;\n\twhile(cnt < n_) cnt *= 2;\n\tfor(int i = 0; i < 2 * cnt - 1; i++) dat[i] = INT_MAX;\n}\nvoid update(int k, int a, int *dat){\n\tk += cnt - 1;\n\tdat[k] = a;\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nint query(int a, int b, int k, int l, int r, int *dat){\n\tif(r <= a || b <= l) return INT_MAX;\n\tif(a <= l && r <= b) return dat[k];\n\telse{\n\t\tint v1 = query(a, b, k * 2 + 1, l, (l + r) / 2, dat);\n\t\tint vr = query(a, b, k * 2 + 2, (l + r) / 2, r, dat);\n\t\treturn min(v1, vr);\n\t}\n}\ntypedef pair<int, S> PS;\ntypedef vector<PS>::iterator it;\n\nint i, j, n, d, stars[MAX_N][3], ax[2 * N], bx[2 * N], ay[2 * N], by[2 * N];\nint ans = 0;\nvector<PS> vec;\n\nvoid vdc(vector<PS> &vf, S s, int now){\n\tif(vf[now].Se.sx > s.sx)\n\t\tvf[now].Se.sx = s.sx;\n\tif(vf[now].Se.lx < s.lx)\n\t\tvf[now].Se.lx = s.lx;\n\tif(vf[now].Se.sy > s.sy)\n\t\tvf[now].Se.sy = s.sy;\n\tif(vf[now].Se.ly < s.ly)\n\t\tvf[now].Se.ly = s.ly;\n}\n\nsigned main(){\n\tcin >> n >> d;\n\tvec.push_back(MP(-1, S(0, 0, 0, 0)));\n\tfor(i = 0; i < n; i++){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tS s = S(a, a, b, b);\n\t\tit ite = lower_bound(vec.begin(), vec.end(), MP(c, s));\n\t\tif(vec[ite - vec.begin() - 1].F != c){\n\t\t\tvec.insert(ite, MP(c, s));\n\t\t}\n\t\telse{\n\t\t\tvdc(vec, s, ite - vec.begin() - 1);\n\t\t}\n\t}\n\tinit(vec.size(), ax);\n\tinit(vec.size(), bx);\n\tinit(vec.size(), ay);\n\tinit(vec.size(), by);\n\tS s = S(INT_MAX, 0, INT_MAX, 0);\n\tvec.erase(vec.begin());\n\tfor(i = 0; i < vec.size(); i++){\n\t\tupdate(i, vec[i].Se.sx, ax);\n\t\tupdate(i, -vec[i].Se.lx, bx);\n\t\tupdate(i, vec[i].Se.sy, ay);\n\t\tupdate(i, -vec[i].Se.ly, by);\n\t}\n\ti = 0; j = 0;\n\tfor(;;){\n\t\twhile(j < vec.size()){\n\t\t\tif(vec[j].F - vec[i].F <= d)\n\t\t\t\tj++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tans = max(ans, (-query(i, j, 0, 0, cnt, bx) - query(i, j, 0, 0, cnt, ax)) * (-query(i, j, 0, 0, cnt, by) - query(i, j, 0, 0, cnt, ay)));\n\t\tif(j == vec.size())\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<unordered_set>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<algorithm>\n#define int long long\nusing namespace std;\n\nstruct star {\n\tint cost, x, y;\n};\nbool operator <(star a, star b) {\n\treturn a.cost <= b.cost;\n}\nstar A[200000];\nmap<int, int>X;\nmap<int, int>Y;\nsigned main(){\n\tint a, b; scanf(\"%lld%lld\", &a, &b);\n\tfor (int c = 0; c < a; c++) {\n\t\tint d, e, f; scanf(\"%lld%lld%lld\", &d, &e, &f);\n\t\tA[c] = { f,d,e };\n\t}\n\tsort(A, A + a);\n\tint MAX = 0;\n\tfor (int s = 0, g = 0; g < a; g++) {\n\t\tX[A[g].x]++;\n\t\tY[A[g].y]++;\n\t\twhile (s < g&&A[s].cost + b < A[g].cost) {\n\t\t\tX[A[s].x]--;\n\t\t\tY[A[s].y]--;\n\t\t\tif (X[A[s].x] == 0) {\n\t\t\t\tX.erase(A[s].x);\n\t\t\t}\n\t\t\tif (Y[A[s].y] == 0) {\n\t\t\t\tY.erase(A[s].y);\n\t\t\t}\n\t\t\ts++;\n\t\t}\n\t\tint n = X.rbegin()->first - X.begin()->first;\n\t\tint m = Y.rbegin()->first - Y.begin()->first;\n\t\tMAX = max(MAX, n*m);\n\t}\n\tprintf(\"%lld\\n\", MAX);\n}"
  },
  {
    "language": "C++",
    "code": "\ntypedef int  unsigned long long;\n#include <cstdio> \n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n\nstruct stars\n{\n\tint maxx=0,minx=0;\n\tint maxy=0,miny=0;\n};\n\n\nsigned main()\n{\n\tmap<int, stars> data;\n\tint n, d;\n\tscanf(\"%llu %llu\", &n, &d);\n\n\tstars foo; int x, y, b;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%llu %llu %llu\", &x, &y, &b);\n\t\tdata[b].maxx = max(data[b].maxx, x);\n\t\tdata[b].minx = min(data[b].minx, x);\n\t\tdata[b].maxy = max(data[b].maxy, y);\n\t\tdata[b].miny = max(data[b].miny, y);\n\t}\n\n\tint ans=0;\n\tstars vec;\n//\tprintf(\"%llu\\n\", vec.maxx);\n\tfor (auto a : data)\n\t{\n\t\tfor (int i = a.first; i <= d; ++i)\n\t\t{\n//\t\t\tprintf(\"%d\\n\", data.count(i) == 0? 1:0);\n\t\t\tif (data.count(i) == 0)\n\t\t\t{\n//\t\t\t\tprintf(\"%llu %llu\\n\", a.first, i);\n\t\t\t\tgoto asdfasdfasdf;\n\t\t\t}\n\t\t\tvec.maxx = max(vec.maxx, a.second.maxx);\n\t\t\tvec.minx = min(vec.minx, a.second.minx);\n\t\t\tvec.maxy = max(vec.maxy, a.second.maxy);\n\t\t\tvec.miny = max(vec.miny, a.second.miny);\n\t\tasdfasdfasdf:;\n\t\t}\n\t\tans = max(ans, (vec.maxx - vec.minx)*(vec.maxy - vec.miny));\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//{ START\nusing namespace std;\n#define int int64_t\n#define rep(i, a, n) for (int i = (a); i < (n); ++i)\n#define reps(i, a, n) for (int i = (n - 1); i > (a - 1); --i)\n#define arep(i, x) for (auto &&i : (x))\n#define irep(i, x) for (auto i = (x).begin(); i != (x).end(); ++i)\n#define rirep(i, x) for (auto i = (x).rbegin(); i != (x).rend(); ++i)\n//降順はgreater<T>()\n#define all(x) (x).begin(), (x).end()\n#define rv(s) reverse((s).begin(), (s).end())\n// gcd lcmはそのままok\n#define gcd(a, b) __gcd(a, b)\n#define bits(n) (1LL << (n))\n#define pcnt(x) __builtin_popcountll(x)\n//配列内等要素削除\n#define Unique(x) (x).erase(unique((x).begin(), (x).end()), (x).end())\n#define Fixed(n) fixed << setprecision(n)\n//総和\n#define sowa(n) (((n) * ((n) + 1)) / 2)\n#define updiv(a, b) ((a + b - 1) / b)\n#define cauto const auto &\nusing P = pair<int, int>;\nusing Graph = vector<vector<P>>;\ntemplate <class T>  //昇順\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T>  //降順\nusing max_heap = priority_queue<T>;\ntemplate <class A, class B>\nusing umap = unordered_map<A, B>;\ntemplate <class A>\nusing uset = unordered_set<A>;\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {  //多次元初期化\n  std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <class A, class B>\nbool chmax(A &a, const B &b) {  //最大値更新 返り値はbool\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class A, class B>\nbool chmin(A &a, const B &b) {  //最小値更新 返り値はbool\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\nint dx[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint dy[] = {0, 1, 0, -1, 1, 1, 1, -1, -1};\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr int LINF = 0x3f3f3f3f3f3f3f3fLL;\nconstexpr int mod1 = 1e9 + 7;\nconstexpr int mod2 = 998244353;\n//} END\n\ntemplate <typename Monoid>\nstruct SegmentTree {\n  using F = function<Monoid(Monoid, Monoid)>;\n\n  int sz;\n  vector<Monoid> seg;\n\n  const F f;\n  const Monoid M1;\n\n  SegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1) {\n    sz = 1;\n    while (sz < n) sz <<= 1;\n    seg.assign(2 * sz, M1);\n  }\n\n  void set(int k, const Monoid &x) { seg[k + sz] = x; }\n\n  void build() {\n    for (int k = sz - 1; k > 0; k--) {\n      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n    }\n  }\n\n  void update(int k, const Monoid &x) {\n    k += sz;\n    seg[k] = x;\n    while (k >>= 1) {\n      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n    }\n  }\n\n  Monoid query(int a, int b) {\n    Monoid L = M1, R = M1;\n    for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n      if (a & 1) L = f(L, seg[a++]);\n      if (b & 1) R = f(seg[--b], R);\n    }\n    return f(L, R);\n  }\n\n  Monoid operator[](const int &k) const { return seg[k + sz]; }\n\n  template <typename C>\n  int find_subtree(int a, const C &check, Monoid &M, bool type) {\n    while (a < sz) {\n      Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n      if (check(nxt))\n        a = 2 * a + type;\n      else\n        M = nxt, a = 2 * a + 1 - type;\n    }\n    return a - sz;\n  }\n\n  template <typename C>\n  int find_first(int a, const C &check) {\n    Monoid L = M1;\n    if (a <= 0) {\n      if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n      return -1;\n    }\n    int b = sz;\n    for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n      if (a & 1) {\n        Monoid nxt = f(L, seg[a]);\n        if (check(nxt)) return find_subtree(a, check, L, false);\n        L = nxt;\n        ++a;\n      }\n    }\n    return -1;\n  }\n\n  template <typename C>\n  int find_last(int b, const C &check) {\n    Monoid R = M1;\n    if (b >= sz) {\n      if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n      return -1;\n    }\n    int a = sz;\n    for (b += sz; a < b; a >>= 1, b >>= 1) {\n      if (b & 1) {\n        Monoid nxt = f(seg[--b], R);\n        if (check(nxt)) return find_subtree(b, check, R, true);\n        R = nxt;\n      }\n    }\n    return -1;\n  }\n};\n\nsigned main(void) {\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n\n  int n, d;\n  cin >> n >> d;\n  vector<tuple<int, int, int>> star;\n  auto maxf = [](int a, int b) { return max(a, b); };\n  auto minf = [](int a, int b) { return min(a, b); };\n\n  rep(i, 0, n) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    star.emplace_back(c, a, b);\n  }\n  sort(all(star));\n\n  SegmentTree<int> maxx(n, maxf, 0);\n  SegmentTree<int> minx(n, minf, LINF);\n  SegmentTree<int> maxy(n, maxf, 0);\n  SegmentTree<int> miny(n, minf, LINF);\n\n  vector<int> v(n);\n  rep(i, 0, n) {\n    int bi, xi, yi;\n    tie(bi, xi, yi) = star[i];\n    v[i] = bi;\n    maxx.set(i, xi);\n    minx.set(i, xi);\n    maxy.set(i, yi);\n    miny.set(i, yi);\n  }\n  maxx.build();\n  minx.build();\n  maxy.build();\n  miny.build();\n\n  int ans = 0;\n  rep(i, 0, n) {\n    int key = v[i] + d;\n    int r = distance(v.begin(), upper_bound(all(v), key));\n    int nowx = maxx.query(i, r) - minx.query(i, r);\n    int nowy = maxy.query(i, r) - miny.query(i, r);\n    chmax(ans, (nowx * nowy));\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\n\nstruct Star{\n    int x,y,b;\n    Star(int x=0,int y=0,int b=0) :\n        x(x),y(y),b(b){}\n    bool operator<(const Star &rth) const {\n        return std::tie(b,x,y)<std::tie(rth.b,rth.x,rth.y);\n    }\n};\n\nstruct SegTree {\n    int n;\n    vector<ll> min_dat;\n    vector<ll> max_dat;\n    SegTree(int N) {\n        n=1;\n        while(n<N) n*=2;\n        min_dat.assign(1<<18,INF);\n        max_dat.assign(1<<18,0);\n    }\n\n    void update(int k,ll a) {\n        k+=n-1;\n        min_dat[k]=a;\n        max_dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            min_dat[k]=min(min_dat[k*2+1],min_dat[k*2+2]);\n            max_dat[k]=max(max_dat[k*2+1],max_dat[k*2+2]);\n        }\n    }\n\n    ll min_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return INF;\n\n        if(a<=l&&r<=b) return min_dat[k];\n        else {\n            int vl=min_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=min_query(a,b,k*2+2,(l+r)/2,r);\n            return min(vl,vr);\n        }\n    }\n\n    ll max_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return 0;\n\n        if(a<=l&&r<=b) return max_dat[k];\n        else {\n            int vl=max_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=max_query(a,b,k*2+2,(l+r)/2,r);\n            return max(vl,vr);\n        }\n    }\n\n    void dump() {\n        rep(i,n) cout<<max_dat[i]<<\" \";\n        cout<<endl;\n    }\n\n};\nint N,d;\n\n\nvector<Star> stars;\n\nint find(int x) {\n    int l=0;\n    int r=stars.size()-1;\n    while(r-l>1) {\n        int mid=(l+r)/2;\n        if(stars[mid].b<x) l=mid;\n        else r=mid;\n    }\n    return r;\n}\nint main() {\n    cin>>N>>d;\n    rep(i,N) {\n        Star s;\n        cin>>s.x>>s.y>>s.b;\n        stars.pb(s);\n    }\n    SegTree segTreeX(N);\n    SegTree segTreeY(N);\n\n    sort(all(stars));\n\n    rep(i,stars.size()) {\n        // printf(\"%d %d %d %d\\n\",i,stars[i].x,stars[i].y,stars[i].b);\n        segTreeX.update(i,stars[i].x);\n        segTreeY.update(i,stars[i].y);\n    }\n\n\n    ll ans=0;\n    int n=segTreeX.n;\n    rep(i,stars.size()) {\n        // int pos=find(stars[i].b+d);\n        Star s=stars[i];\n        s.b+=d;\n        int pos=upper_bound(all(stars),s)-stars.begin();\n        if(pos==i) continue;\n        ll tmp=0;\n        tmp=segTreeX.max_query(i,pos+1,0,0,n)-segTreeX.min_query(i,pos+1,0,0,n);\n        tmp*=segTreeY.max_query(i,pos+1,0,0,n)-segTreeY.min_query(i,pos+1,0,0,n);\n\n        // cout<<i<<\",\"<<stars[i].b+d<<\",\"<<pos<<\",\"<<tmp<<endl;\n        ans = max(ans,tmp);\n\n    }\n\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <utility>\nusing namespace std;\n\ntypedef long long lint;\ntypedef pair<int,int> P;\ntypedef pair<lint,P> star;\n\n\nstruct SegTree\n{\n    int N;\n    vector<int> Seg;\n    void init(int n)\n    {\n        N = 1;\n        while (N < n)N *= 2;\n        for (int i = 0; i < N * 2; i++)\n        {\n            Seg.push_back(INT_MAX);\n        }\n \n    }\n \n    void update(int k, int a)\n    {\n        k = k - 1 + N;\n        Seg[k] = a;\n        while (k > 0)\n        {\n            k = (k - 1) / 2;\n            Seg[k] = min(Seg[2 * k + 1], Seg[2 * k + 2]);\n        }\n    }\n    int find_min(int a, int b)\n    {\n        return query(a, b, 0, 0, N);\n    }\n \n    int query(int a, int b, int k, int l, int r)\n    {\n        if (r <= a || l >= b)return INT_MAX;\n        if (l >= a&&r <= b)\n        {\n            return Seg[k];\n        }\n        else\n        {\n            return min(query(a, b, k * 2 + 1, l, (r + l) / 2),\n                query(a, b, k * 2 + 2, (r + l) / 2, r));\n        }\n    }\n};\n\nSegTree tree[4];\nvector<star> stars;\nvector<lint> B;\nint main()\n{\n\tint N;\n\tlint d;\n\tcin>>N>>d;\n\tfor(int i=0;i<4;i++)\n\t\ttree[i].init(N);\n\t\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tP p;\n\t\tlint b;\n\t\tcin>>p.first>>p.second>>b;\n\t\tstars.push_back(star(b,p));\n\t\tB.push_back(b);\n\t}\n\tsort(stars.begin(),stars.end());\n\tsort(B.begin(),B.end());\n\t\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tP p=stars[i].second;\n\t\t\n\t\ttree[0].update(i,p.first);\n\t\ttree[2].update(i,-p.first);\n\t\t\n\t\ttree[1].update(i,p.second);\n\t\ttree[3].update(i,-p.second);\n\t}\n\tlint ans=0;\n\tfor(auto it = B.begin();;)\n\t{\n\t\tauto E = upper_bound(B.begin(),B.end(),(lint)*it+d);\n\t\tint x=it-B.begin();\n\t\tint y=E-B.begin();\n\t\tit=upper_bound(B.begin(),B.end(),(lint)*it);\n\t\tlint tans=(lint)(-tree[2].find_min(x,y)-tree[0].find_min(x,y))*(lint)(-tree[3].find_min(x,y)-tree[1].find_min(x,y));\n\t\tans=max(ans,tans);\n\t\tif(E==B.end())break;\n\t}\n\tcout<<ans<<endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \npair<int, int> segx[1 << 19], segy[1 << 19];\nint sz = (1 << 18);\n \nvoid update(pair<int, int> *seg, int pos, int val)\n{\n    pos += sz - 1;\n    seg[pos] = make_pair(val, val);\n \n    while (pos){\n        pos = (pos - 1) / 2;\n        seg[pos].first = max(seg[pos * 2 + 1].first, seg[pos * 2 + 2].first);\n        seg[pos].second = min(seg[pos * 2 + 1].second, seg[pos * 2 + 2].second);\n    }\n}\n \npair<int, int> get(pair<int, int> *seg, int a, int b, int k = 0, int l = 0, int r = sz)\n{\n    if (b <= l || r <= a) return (make_pair(INT_MIN, INT_MAX));\n    if (a <= l && r <= b){\n        return (seg[k]);\n    }\n    pair<int, int> lf = get(seg, a, b, k * 2 + 1, l, (l + r) / 2);\n    pair<int, int> rg = get(seg, a, b, k * 2 + 2, (l + r) / 2, r);\n \n    return (make_pair(max(lf.first, rg.first), min(lf.second, rg.second)));\n}\n \nint main()\n{\n    int N, d;\n \n    scanf(\"%d %d\", &N, &d);\n \n    vector<pair<int, int> > xs, ys;\n    vector<int> xss, yss, bs;\n \n    for (int i = 0; i < N; i++){\n        int x, y, b;\n        scanf(\"%d %d %d\", &x, &y, &b);\n        xs.push_back(make_pair(b, x));\n        ys.push_back(make_pair(b, y));\n        bs.push_back(b);\n    }\n \n    sort(xs.begin(), xs.end());\n    sort(ys.begin(), ys.end());\n \n    for (int i = 0; i < N; i++){\n        xss.push_back(xs[i].first);\n        yss.push_back(ys[i].first);\n        update(segx, i, xs[i].second);\n        update(segy, i, ys[i].second);\n    }\n \n    long long ret = 0;\n \n    for (int i = 0; i < N; i++){\n        int xL = lower_bound(xss.begin(), xss.end(), bs[i])     - xss.begin(),\n            xR = upper_bound(xss.begin(), xss.end(), bs[i] + d) - xss.begin();\n        int yL = lower_bound(yss.begin(), yss.end(), bs[i])     - yss.begin(),\n            yR = upper_bound(yss.begin(), yss.end(), bs[i] + d) - yss.begin();\n \n        pair<int, int> posx = get(segx, xL, xR), posy = get(segy, yL, yR);\n        ret = max(ret, (long long)(posx.second - posx.first) * (posy.second - posy.first));\n    }\n \n    printf(\"%lld\\n\", ret);\n \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\n\nstruct Star{\n    int x,y,b;\n    Star(int x=0,int y=0,int b=0) :\n        x(x),y(y),b(b){}\n    bool operator<(const Star &rth) const {\n        return std::tie(b,x,y)<std::tie(rth.b,rth.x,rth.y);\n    }\n};\n\nstruct SegTree {\n    int n;\n    vector<int> min_dat;\n    vector<int> max_dat;\n    SegTree(int N) {\n        n=1;\n        while(n<N) n*=2;\n        min_dat.assign(1<<19,INF);\n        max_dat.assign(1<<19,0);\n    }\n\n    void update(int k,int a) {\n        k+=n-1;\n        min_dat[k]=a;\n        max_dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            min_dat[k]=min(min_dat[k*2+1],min_dat[k*2+2]);\n            max_dat[k]=max(max_dat[k*2+1],max_dat[k*2+2]);\n        }\n    }\n\n    int min_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return INF;\n\n        if(a<=l&&r<=b) return min_dat[k];\n        else {\n            int vl=min_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=min_query(a,b,k*2+2,(l+r)/2,r);\n            return min(vl,vr);\n        }\n    }\n\n    int max_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return 0;\n\n        if(a<=l&&r<=b) return max_dat[k];\n        else {\n            int vl=max_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=max_query(a,b,k*2+2,(l+r)/2,r);\n            return max(vl,vr);\n        }\n    }\n\n    void dump() {\n        rep(i,n) cout<<max_dat[i]<<\" \";\n        cout<<endl;\n    }\n\n};\nint N,d;\n\n\nvector<Star> stars;\n\nint find(int x) {\n    int l=0;\n    int r=stars.size()-1;\n    while(r-l>1) {\n        int mid=(l+r)/2;\n        if(stars[mid].b<x) l=mid;\n        else r=mid;\n    }\n    return r;\n}\nint main() {\n    cin>>N>>d;\n    rep(i,N) {\n        Star s;\n        cin>>s.x>>s.y>>s.b;\n        stars.pb(s);\n    }\n    SegTree segTreeX(N);\n    SegTree segTreeY(N);\n\n    sort(all(stars));\n\n    rep(i,stars.size()) {\n        // printf(\"%d %d %d %d\\n\",i,stars[i].x,stars[i].y,stars[i].b);\n        segTreeX.update(i,stars[i].x);\n        segTreeY.update(i,stars[i].y);\n    }\n\n\n    int ans=0;\n    int n=segTreeX.n;\n    rep(i,stars.size()) {\n        int pos=find(stars[i].b+d);\n        int tmp=0;\n        tmp=segTreeX.max_query(i,pos+1,0,0,n)-segTreeX.min_query(i,pos+1,0,0,n);\n        tmp*=segTreeY.max_query(i,pos+1,0,0,n)-segTreeY.min_query(i,pos+1,0,0,n);\n\n        // cout<<i<<\",\"<<stars[i].b+d<<\",\"<<pos<<\",\"<<tmp<<endl;\n        ans = max(ans,tmp);\n\n    }\n\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio> \n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n\nstruct stars\n{\n\tint maxx=0,minx=0;\n\tint maxy=0,miny=0;\n};\n\n\nsigned main()\n{\n\tmap<int, stars> data;\n\tint n, d;\n//\tscanf(\"%llu %llu\", &n, &d);\n\tscanf(\"%d%d\", &n, &d);\n\n\tstars foo; int x, y, b;\n\tfor (int i = 0; i < n; ++i)\n\t{\n//\t\tscanf(\"%llu %llu %llu\", &x, &y, &b);\n\t\tscanf(\"%d%d%d\", &x, &y, &b);\n\t\tif (data.count(b) == 0)\n\t\t{\n\n\t\t\tdata[b].maxx = x;\n\t\t\tdata[b].minx = x;\n\t\t\tdata[b].maxy = y;\n\t\t\tdata[b].miny = y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdata[b].maxx = max(data[b].maxx, x);\n\t\t\tdata[b].minx = min(data[b].minx, x);\n\t\t\tdata[b].maxy = max(data[b].maxy, y);\n\t\t\tdata[b].miny = max(data[b].miny, y);\n\t\t}\n\t}\n\n\tint ans=0;\n\tstars vec;\n//\tprintf(\"%llu\\n\", vec.maxx);\n\n\tfor (auto itr = data.begin();itr != data.end();++itr)\n\t{\n\t\tauto a = *itr;\n\t\tfor (int i = a.first; i < d; ++i)\n\t\t{\n\t\t\tif (data.count(i) == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvec.maxx = max(vec.maxx, a.second.maxx);\n\t\t\tvec.minx = min(vec.minx, a.second.minx);\n\t\t\tvec.maxy = max(vec.maxy, a.second.maxy);\n\t\t\tvec.miny = min(vec.miny, a.second.miny);\n\t\n\t\t}\n\t\tans = max(ans, (vec.maxx - vec.minx)*(vec.maxy - vec.miny));\n\t}\n\n//\tprintf(\"%I64u\\n\",ans);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define repp(i,k,n) for(int i=k;i<(int)n;i++)\n#define rei(n) for(int i=0;i<(int)n;i++)\n#define rel(n) for(int l=0;l<(int)n;l++)\n//#define int long long\n#define al(s) s.begin(),s.end()\n#define INT_MAX 2147483647\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> ppi;\ntypedef pair<int, ppi> pipp;\ntypedef pair<int, pi> pip;\ntypedef pair<long long, pi> llpi;\n\nstruct SegTree\n{\n\tint N;\n\tvector<int> Seg;\n\tvoid init(int n)\n\t{\n\t\tN = 1;\n\t\twhile (N < n)N *= 2;\n\t\tfor (int i = 0; i < N*2; i++)\n\t\t{\n\t\t\tSeg.push_back(INT_MAX);\n\t\t}\n\t\t\n\t}\n\t\n\tvoid update(int k, int a)\n\t{\t\n\t\tk = k - 1 + N;\n\t\tSeg[k] = a;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\tSeg[k] = min(Seg[2 * k + 1], Seg[2 * k + 2]);\n\t\t}\n\t}\n\tint find_min(int a, int b)\n\t{\n\t\treturn query(a, b, 0, 0, N);\n\t}\n\n\tint query(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || l >= b)return INT_MAX;\n\t\tif (l>=a&&r<=b)\n\t\t{\n\t\t\treturn Seg[k];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn min(query(a, b, k * 2 + 1, l, (r + l) / 2),\n\t\t\t\t\t   query(a, b, k * 2 + 2, (r + l) / 2, r));\n\t\t}\n\t}\n};\n\nSegTree ss[4];//min,max\n\nvector<llpi> a;\n//set<long long> s;\nvector<long long >s;\nint  main()\n{\n\tlong long ans = 0;\n\tlong long n, d;\n\tcin >> n >> d;\n\trei(4)ss[i].init(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlong long b;\n\t\tint x, y;\n\t\tcin >> x >> y >> b;\n\t\ta.push_back(llpi(b, pi(x, y)));\n\t\ts.push_back(b);\n\t}\n\tsort(al(s));\n\tfor (vector<long long>::iterator i=s.begin()+1; i !=s.end(); )\n\t{\n\t\tif (*i == *(i - 1))\n\t\t{\n\t\t\ti = s.erase(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint jj = 0;\n\t\tvector<long long> ::iterator it = lower_bound(al(s),a[i].first);\n\t\tjj = it - s.begin();\n\t\t/*for (vector<long long>::iterator l = s.begin(); l != it; l++)\n\t\t{\n\t\t\tjj++;\n\t\t}\n\t\t*/\n\t\t\n\t\tss[0].update(jj, min(a[i].second.first, ss[0].Seg[jj + ss[0].N - 1]));\n\t\tss[2].update(jj, min(a[i].second.first*(-1), ss[2].Seg[jj + ss[0].N - 1]));\n\n\t\tss[1].update(jj, min(a[i].second.second, ss[1].Seg[jj + ss[0].N - 1]));\n\t\tss[3].update(jj, min(a[i].second.second*(-1), ss[3].Seg[jj + ss[0].N - 1]));\n\n\t}\n\tbool end = false;\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tif(end)break;\n\t\tvector<long long>::iterator it, ne;\n\t\tit = s.begin()+i;\n\t//\tfor (int l = 0; l < i; l++)it++;\n\t\tne = upper_bound(al(s),*it + d);\n\t\tif (ne == s.end())end = true;\n\t\tne--;\n\t\tint coun = ne-it;\n\t\t//for (; it != ne; it++)coun++;\n\t\tcoun += i;\n\t\tcoun++;\n\t\tans = max( ans, (long long)((-1) * ss[2].find_min(i, coun) - ss[0].find_min(i, coun)) * (long long)((-1) * ss[3].find_min(i, coun) - ss[1].find_min(i, coun)) );\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\nconst ll INF=1e16;\n\n\nstruct Star{\n    ll x,y,b;\n    Star(ll x=0,ll y=0,ll b=0) :\n        x(x),y(y),b(b){}\n    bool operator<(const Star &rth) const {\n        return std::tie(b,x,y)<std::tie(rth.b,rth.x,rth.y);\n    }\n};\n\nstruct SegTree {\n    ll n;\n    vector<ll> min_dat;\n    vector<ll> max_dat;\n    SegTree(ll N) {\n        n=1;\n        while(n<N) n*=2;\n        min_dat.assign(1<<18,INF);\n        max_dat.assign(1<<18,0);\n    }\n\n    void update(int k,ll a) {\n        k+=n-1;\n        min_dat[k]=a;\n        max_dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            min_dat[k]=min(min_dat[k*2+1],min_dat[k*2+2]);\n            max_dat[k]=max(max_dat[k*2+1],max_dat[k*2+2]);\n        }\n    }\n\n    ll min_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return INF;\n\n        if(a<=l&&r<=b) return min_dat[k];\n        else {\n            int vl=min_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=min_query(a,b,k*2+2,(l+r)/2,r);\n            return min(vl,vr);\n        }\n    }\n\n    ll max_query(int a,int b,int k,int l,int r) {\n        //printf(\"%d %d %d %d %d\\n\",a,b,k,l,r);\n        if(r<=a||b<=l) return 0;\n\n        if(a<=l&&r<=b) return max_dat[k];\n        else {\n            int vl=max_query(a,b,k*2+1,l,(l+r)/2);\n            int vr=max_query(a,b,k*2+2,(l+r)/2,r);\n            return max(vl,vr);\n        }\n    }\n\n    void dump() {\n        rep(i,n) cout<<max_dat[i]<<\" \";\n        cout<<endl;\n    }\n\n};\nint N,d;\n\n\nvector<Star> stars;\n\nint find(int x) {\n    int l=0;\n    int r=stars.size()-1;\n    while(r-l>1) {\n        int mid=(l+r)/2;\n        if(stars[mid].b<x) l=mid;\n        else r=mid;\n    }\n    return r;\n}\nint main() {\n    cin>>N>>d;\n    rep(i,N) {\n        Star s;\n        cin>>s.x>>s.y>>s.b;\n        stars.pb(s);\n    }\n    SegTree segTreeX(N);\n    SegTree segTreeY(N);\n\n    sort(all(stars));\n\n    rep(i,stars.size()) {\n        // printf(\"%d %d %d %d\\n\",i,stars[i].x,stars[i].y,stars[i].b);\n        segTreeX.update(i,stars[i].x);\n        segTreeY.update(i,stars[i].y);\n    }\n\n\n    ll ans=0;\n    int n=segTreeX.n;\n    rep(i,stars.size()) {\n        // int pos=find(stars[i].b+d);\n        Star s=stars[i];\n        s.b+=d;\n        s.x=s.y=-INF;\n        int pos=upper_bound(all(stars),s)-stars.begin();\n        if(pos==i) continue;\n        ll tmp=0;\n        tmp=segTreeX.max_query(i,pos+1,0,0,n)-segTreeX.min_query(i,pos+1,0,0,n);\n        tmp*=segTreeY.max_query(i,pos+1,0,0,n)-segTreeY.min_query(i,pos+1,0,0,n);\n\n        // cout<<i<<\",\"<<stars[i].b+d<<\",\"<<pos<<\",\"<<tmp<<endl;\n        ans = max(ans,tmp);\n\n    }\n\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1000000000\n#define f first\n#define s second\nusing namespace std;\ntypedef pair <int,pair <int,int> > P;\ntypedef long long ll;\nint n,d,tree[4][(1<<19)];\nP star[200001];\n\nvoid update(int i,int flg,int x){\n  i = i+(1<<18)-1;\n  tree[flg][i] = x;\n  while(i) {\n    i = (i-1)/2;\n    tree[flg][i] = max(tree[flg][i*2+1],tree[flg][i*2+2]);\n  }\n}\n\nint find(int a,int b,int ima,int L,int R,int flg){\n  if(R<=a || b<=L) return -INF;\n  if(a<=L && R<=b) return tree[flg][ima];\n  int M = (L+R)/2;\n  return max(find(a,b,ima*2+1,L,M,flg),find(a,b,ima*2+2,M,R,flg));\n}\n\nint main() {\n  cin >> n >> d;\n\n  for(int i=0;i<n;i++)cin >> star[i].s.f >> star[i].s.s >> star[i].f;\n  sort(star,star+n);  \n  \n  for(int i=0;i<4;i++) \n    for(int j=0;j<(1<<19);j++) tree[i][j] = -INF;\n  \n  for(int i=0;i<n;i++) {\n    update(i,0,star[i].s.f); // max(x);\n    update(i,1,star[i].s.s); // max(y);\n    update(i,2,-star[i].s.f); // min(x);\n    update(i,3,-star[i].s.s); // min(y);\n  }\n\n  long long S=0;\n  int ima=0;\n  for(int i=0;i<n;i++){\n    while(i!=n && star[ima].f-star[i].f <=d) ima++;\n    ll maxx = find(i,ima,0,0,(1<<18),0);\n    ll maxy = find(i,ima,0,0,(1<<18),1);\n    ll minx = find(i,ima,0,0,(1<<18),2);\n    ll miny = find(i,ima,0,0,(1<<18),3);\n    S = max(S,((maxx+minx)*(maxy+miny)));\n  }\n  cout << S<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct STAR {\n  int x, y, d;\n};\n\nbool asc(STAR &l, STAR &r) {\n  return l.d < r.d;\n}\n\nint main() {\n  ll n, d, ans = 0;\n  cin >> n >> d;\n  vector<STAR> v(n);\n\n  rep(i, 0, n) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    v[i].x = a;\n    v[i].y = b;\n    v[i].d = c;\n  }\n\n  sort(v.begin(), v.end(), asc);\n\n  int hx = v[0].x, lx = v[0].x, hy = v[0].y, ly = v[0].y, ld = v[0].d, lp = 0;\n  rep(i, 0, n - 1) {\n    if(v[i + 1].d - lp <= d) {\n      hx = max(hx, v[i + 1].x);\n      hy = max(hy, v[i + 1].y);\n      lx = min(lx, v[i + 1].x);\n      ly = min(ly, v[i + 1].y);\n    }else {\n      ans = max(ans, (ll)(abs(hx - lx) * abs(hy - ly)));\n      rep(j, lp + 1, i + 1) {\n        if(v[i + 1].d - v[j].d <= d) {\n          lp = j;\n          break;\n        }\n      }\n      hx = v[lp].x, lx = v[lp].x, hy = v[lp].y, hx = v[lp].y;\n      rep(j, lp + 1, i + 1) {\n        hx = max(hx, v[j].x);\n        hy = max(hy, v[j].y);\n        lx = min(lx, v[j].x);\n        ly = min(ly, v[j].y);\n      }\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\ntemplate <typename T>\nstruct SegTreeMax{\n    vector<T> dat;\n    int n;\n    const T Default;\n    SegTreeMax(int n_, const T& def) : Default(def){init(n_);}\n    void init(int n_){\n        n = 1;\n        while(n < n_) n *= 2;\n        dat = vector<T>(2*n-1, Default);\n    }\n    T f(const T& a, const T& b) {\n    \treturn max(a, b);\n    }\n    void update(int k, const T& a){\n        k += n-1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k - 1) / 2;\n            dat[k] = f(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n    T query(int a, int b, int k, int l, int r ){\n        if(r <= a || b <= l) return Default;\n        if(a <= l && r <= b) return dat[k];\n        T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n    T query(int a, int b) {\n    \treturn query(a, b, 0, 0, n);\n    }\n};\ntemplate <typename T>\nstruct SegTreeMin{\n    vector<T> dat;\n    int n;\n    const T Default;\n    SegTreeMin(int n_, const T& def) : Default(def){init(n_);}\n    void init(int n_){\n        n = 1;\n        while(n < n_) n *= 2;\n        dat = vector<T>(2*n-1, Default);\n    }\n    T f(const T& a, const T& b) {\n    \treturn min(a, b);\n    }\n    void update(int k, const T& a){\n        k += n-1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k - 1) / 2;\n            dat[k] = f(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n    T query(int a, int b, int k, int l, int r ){\n        if(r <= a || b <= l) return Default;\n        if(a <= l && r <= b) return dat[k];\n        T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n    T query(int a, int b) {\n    \treturn query(a, b, 0, 0, n);\n    }\n};\nint main(){\n\tint n, d;\n\tcin >> n >> d;\n\tvector<pair<int, pii>> v(n);\n\trep(i, n) cin >> v[i].se.fi >> v[i].se.se >> v[i].fi;\n\tsort(all(v));\n\tSegTreeMax<int> xMax(n, -INF), yMax(n, -INF);\n\tSegTreeMin<int> xMin(n, INF), yMin(n, INF);\n\trep(i, n) {\n\t\txMax.update(i, v[i].se.fi);\n\t\txMin.update(i, v[i].se.fi);\n\t\tyMax.update(i, v[i].se.se);\n\t\tyMin.update(i, v[i].se.se);\n\t}\n\tll ans = 0LL;\n\trep(i, n) {\n\t\tint idx = upper_bound(all(v), make_pair(v[i].fi+d, make_pair(INF, INF))) - v.begin();\n\t\tll sx = xMin.query(i, idx);\n\t\tll gx = xMax.query(i, idx);\n\t\tll sy = yMin.query(i, idx);\n\t\tll gy = yMax.query(i, idx);\n\t\tans = max(ans, (gx-sx)*(gy-sy));\n\t\t// cout << sx << \" \" << gx << \" \" << sy << \" \" << gy << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define repp(i,k,n) for(int i=k;i<(int)n;i++)\n#define rei(n) for(int i=0;i<(int)n;i++)\n#define rel(n) for(int l=0;l<(int)n;l++)\n//#define int long long\n#define al(s) s.begin(),s.end()\n#define INT_MAX 2147483647\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> ppi;\ntypedef pair<int, ppi> pipp;\ntypedef pair<int, pi> pip;\ntypedef pair<long long, pi> llpi;\n\nstruct SegTree\n{\n\tint N;\n\tvector<int> Seg;\n\tvoid init(int n)\n\t{\n\t\tN = 1;\n\t\twhile (N < n)N *= 2;\n\t\tfor (int i = 0; i < N*2; i++)\n\t\t{\n\t\t\tSeg.push_back(INT_MAX);\n\t\t}\n\t\t\n\t}\n\t\n\tvoid update(int k, int a)\n\t{\t\n\t\tk = k - 1 + N;\n\t\tSeg[k] = a;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\tSeg[k] = min(Seg[2 * k + 1], Seg[2 * k + 2]);\n\t\t}\n\t}\n\tint find_min(int a, int b)\n\t{\n\t\treturn query(a, b, 0, 0, N);\n\t}\n\n\tint query(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || l >= b)return INT_MAX;\n\t\tif (l>=a&&r<=b)\n\t\t{\n\t\t\treturn Seg[k];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn min(query(a, b, k * 2 + 1, l, (r + l) / 2),\n\t\t\t\t\t   query(a, b, k * 2 + 2, (r + l) / 2, r));\n\t\t}\n\t}\n};\n\nSegTree ss[4];//min,max\n\nvector<llpi> a;\n//set<long long> s;\nvector<long long >s;\nint  main()\n{\n\tlong long ans = 0;\n\tlong long n, d;\n\tcin >> n >> d;\n\trei(4)ss[i].init(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlong long b;\n\t\tint x, y;\n\t\tcin >> x >> y >> b;\n\t\ta.push_back(llpi(b, pi(x, y)));\n\t\ts.push_back(b);\n\t}\n\tsort(al(s));\n\tfor (vector<long long>::iterator i=s.begin()+1; i !=s.end(); )\n\t{\n\t\tif (*i == *(i - 1))\n\t\t{\n\t\t\ti = s.erase(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint jj = 0;\n\t\tvector<long long> ::iterator it = lower_bound(al(s),a[i].first);\n\t\tfor (vector<long long>::iterator l = s.begin(); l != it; l++)\n\t\t{\n\t\t\tjj++;\n\t\t}\n\t\t\n\t\tss[0].update(jj, min(a[i].second.first, ss[0].Seg[jj + ss[0].N - 1]));\n\t\tss[2].update(jj, min(a[i].second.first*(-1), ss[2].Seg[jj + ss[0].N - 1]));\n\n\t\tss[1].update(jj, min(a[i].second.second, ss[1].Seg[jj + ss[0].N - 1]));\n\t\tss[3].update(jj, min(a[i].second.second*(-1), ss[3].Seg[jj + ss[0].N - 1]));\n\n\t}\n\tbool end = false;\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tif(end)break;\n\t\tvector<long long>::iterator it, ne;\n\t\tit = s.begin()+i;\n\t//\tfor (int l = 0; l < i; l++)it++;\n\t\tne = upper_bound(al(s),*it + d);\n\t\tif (ne == s.end())end = true;\n\t\tne--;\n\t\tint coun = 0;\n\t\tfor (; it != ne; it++)coun++;\n\t\tcoun += i;\n\t\tcoun++;\n\t\tans = max( ans, (long long)((-1) * ss[2].find_min(i, coun) - ss[0].find_min(i, coun)) * (long long)((-1) * ss[3].find_min(i, coun) - ss[1].find_min(i, coun)) );\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<climits>\nusing namespace std;\nstruct maxSegTree{\n    int n;\n    vector<int>dat;\n    void init(int n_){\n        n=1;\n        while(n<n_)n*=2;\n        dat.resize(n*2-1,INT_MIN);\n    }\n    maxSegTree(int n_){\n        init(n_);\n    }\n    void update(int x,int val){\n        x+=n-1;\n        dat[x]=val;\n        while(x){\n            x=(x-1)/2;\n            dat[x]=max(dat[x*2+1],dat[x*2+2]);\n        }\n    }\n    int getMax(int a,int b,int k=0,int l=0,int r=-1){\n        if(r==-1)r=n;\n        if(a<=l&&b>=r)return dat[k];\n        if(a>=r||b<=l)return INT_MIN;\n        int v1=getMax(a,b,k*2+1,l,(l+r)/2);\n        int v2=getMax(a,b,k*2+2,(l+r)/2,r);\n        return max(v1,v2);\n    }\n};\nstruct minSegTree{\n    int n;\n    vector<int>dat;\n    void init(int n_){\n        n=1;\n        while(n<n_)n*=2;\n        dat.resize(n*2-1,INT_MAX);\n    }\n    minSegTree(int n_){\n        init(n_);\n    }\n    void update(int x,int val){\n        x+=n-1;\n        dat[x]=val;\n        while(x){\n            x=(x-1)/2;\n            dat[x]=min(dat[x*2+1],dat[x*2+2]);\n        }\n    }\n    int getMin(int a,int b,int k=0,int l=0,int r=-1){\n        if(r==-1)r=n;\n        if(a<=l&&b>=r)return dat[k];\n        if(a>=r||b<=l)return INT_MAX;\n        int v1=getMin(a,b,k*2+1,l,(l+r)/2);\n        int v2=getMin(a,b,k*2+2,(l+r)/2,r);\n        return min(v1,v2);\n    }\n};\nint main(){\n    int n,d;\n    scanf(\"%d%d\",&n,&d);\n    vector<pair<int,pair<int,int> > >V(n);\n    vector<int>D(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d%d\",&V[i].second.first,&V[i].second.second,&V[i].first);\n        D[i]=V[i].first;\n    }\n    sort(V.begin(),V.end());\n    sort(D.begin(),D.end());\n    maxSegTree ma(n*2);\n    minSegTree mi(n*2);\n    long long mav=INT_MIN;\n    for(int i=0;i<n;i++){\n        pair<int,pair<int,int> >p=V[i];\n        int x=p.second.first,y=p.second.second,b=p.first;\n        ma.update(i,x);ma.update(i+n,y);\n        mi.update(i,x);mi.update(i+n,y);\n    }\n\n    for(int i=0;i<n;i++){\n        pair<int,pair<int,int> >p=V[i];\n        int b=D[i];\n        int pos=upper_bound(D.begin(),D.end(),b+d)-D.begin();\n        long long  mx=ma.getMax(i,pos),my=ma.getMax(i+n,pos+n);\n        long long  mix=mi.getMin(i,pos),miy=mi.getMin(i+n,pos+n);\n        long long m2=(mx-mix)*(my-miy);\n        mav=max(mav,m2);\n        //cout<<i<<\" \"<<pos<<\" \"<<m2<<\"**\"<<mx<<\" \"<<my<<\" \"<<mix<<\" \"<<miy<<endl;\n    }\n    printf(\"%lld\\n\",mav);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<30)\ntypedef pair<int,int> P;\ntypedef pair<int,P> Pi;\ntypedef long long int lld;\nstruct SegmentTree\n{\n \n  vector< int > small, big;\n  int sz;\n \n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    small.assign(2 * sz - 1, INF);\n    big.assign(2 * sz - 1, -INF);\n  }\n  /*\n  inline void Merge(int k)\n  {\n    small[k] = min(small[2 * k + 1] + add[2 * k + 1], small[2 * k + 2] + add[2 * k + 2]);\n    big[k] = max(big[2 * k + 1] + add[2 * k + 1], big[2 * k + 2] + add[2 * k + 2]);\n    sum[k] = sum[2 * k + 1] + add[2 * k + 1] + sum[2 * k + 2] + add[2 * k + 2];\n    }*/\n  inline int RangeMaximumQuery(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return(-INF);\n    if(a <= l && r <= b) return(big[k]);\n    int L = RangeMaximumQuery(a, b, 2 * k + 1, l, (l + r) >> 1);\n    int R = RangeMaximumQuery(a, b, 2 * k + 2, (l + r) >> 1, r);\n    return(max(L, R));\n  }\n  inline int RangeMinimumQuery(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return(INF);\n    if(a <= l && r <= b) return(small[k]);\n    int L = RangeMinimumQuery(a, b, 2 * k + 1, l, (l + r) >> 1);\n    int R = RangeMinimumQuery(a, b, 2 * k + 2, (l + r) >> 1, r);\n    return(min(L, R));\n  }\n \n  void Update(int k, int x)\n  {\n    k += sz - 1;\n    small[k] = big[k] = x;\n    while(k > 0) {\n      k = (k - 1) >> 1;\n    }\n  }\n  int RangeMaximumQuery(int a, int b)\n  {\n    return(RangeMaximumQuery(a, b, 0, 0, sz));\n  }\n  int RangeMinimumQuery(int a, int b)\n  {\n    return(RangeMinimumQuery(a, b, 0, 0, sz));\n  }\n};\n\nint main(){\n  int n,d;\n  cin >> n >> d;\n  Pi star[200010];\n  for(int i=0;i<n;i++){\n    cin >> star[i].second.first >> star[i].second.second >> star[i].first;\n  }\n  sort(star,star+n);\n  SegmentTree X(200010),Y(200010);\n  for(int i=0;i<n;i++){\n    X.Update(i,star[i].second.first);\n    Y.Update(i,star[i].second.second);\n  }\n  int idx = 0;\n  lld ans = -1;\n  for(int i=0;i<n;i++){\n    while(idx < n && star[idx].first - star[i].first <= d) idx++;\n    idx--;\n    lld maxx = X.RangeMaximumQuery(i,idx);\n    lld minx = X.RangeMinimumQuery(i,idx);\n    lld maxy = Y.RangeMaximumQuery(i,idx);\n    lld miny = Y.RangeMinimumQuery(i,idx);\n    ans = max(ans,(maxx-minx)*(maxy-miny));\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); ++(i))\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); ++(i))\nusing ll = long long;\nconst int INF = (1 << 30) + (1 << 29);\n\nstruct SegmentTree {\n    using F = function< int(int, int) >;\n    vector< int > seg;\n    int size;\n    const F func;\n    const int M1;\n    SegmentTree(int n, const F f, const int &M) : func(f), M1(M) {\n        size = 1; while (size < n) size <<= 1;\n        seg.resize(2 * size - 1, M1);\n    }\n    void set(int k, int x) {seg[k + size - 1] = x;}\n    void build() {\n        for (int i = size - 2; i >= 0; --i) seg[i] = func(seg[2 * i + 1], seg[2 * i + 2]);\n    }\n    void update(int k, int x) {\n        k += size - 1;\n        seg[k] = x;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            seg[k] = func(seg[2 * k + 1], seg[2 * k + 2]);\n        }\n    }\n    void add(int k, int x) {\n        k += size - 1;\n        seg[k] += x;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            seg[k] = func(seg[2 * k + 1], seg[2 * k + 2]);\n        }\n    }\n    int query(int a, int b, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = size;\n        if (r <= a || l >= b) return M1;\n        if (l >= a && r <= b) return seg[k];\n        int f_l = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        int f_r = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return func(f_l, f_r);\n    }\n};\n\nvector<int> brightness;\n\nsigned main() {\n\n    int N, d;\n    cin >> N >> d;\n\n    vector<tuple<int, int, int>> star;\n    REP(i, N) {\n        int x, y, b;\n        cin >> x >> y >> b;\n        star.emplace_back(b, x, y);\n        brightness.emplace_back(b);\n    }\n    sort(star.begin(), star.end());\n    sort(brightness.begin(), brightness.end());\n    brightness.emplace_back((int)2e9 + 10);\n\n    auto nxtidx = [&](int idx) -> int {\n        auto itr = upper_bound(brightness.begin(), brightness.end(), brightness[idx] + d);\n        return (int)(itr - brightness.begin());\n    };\n\n    SegmentTree seg_x_min(N + 1, [](int a, int b){return min(a, b);}, INF);\n    SegmentTree seg_x_max(N + 1, [](int a, int b){return max(a, b);}, -INF);\n    SegmentTree seg_y_min(N + 1, [](int a, int b){return min(a, b);}, INF);\n    SegmentTree seg_y_max(N + 1, [](int a, int b){return max(a, b);}, -INF);\n    REP(i, N) {\n        seg_x_min.update(i, get<1>(star[i]));\n        seg_x_max.update(i, get<1>(star[i]));\n        seg_y_min.update(i, get<2>(star[i]));\n        seg_y_max.update(i, get<2>(star[i]));\n    }\n    seg_x_min.build();\n    seg_x_max.build();\n    seg_y_min.build();\n    seg_y_max.build();\n\n    // return 0;\n\n    ll res = 0;\n    REP(frm, N) {\n        int until = nxtidx(frm);\n        ll x = seg_x_max.query(frm, until) - seg_x_min.query(frm, until);\n        ll y = seg_y_max.query(frm, until) - seg_y_min.query(frm, until);\n        ll tmp = x * y;\n        res = max(res, tmp);\n    }\n    cout << res << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<climits>\n#include<algorithm>\nconst int INF = INT_MAX;\nconst int NIL = -1;\nclass RangeMinimumQuery {\npublic:\n  RangeMinimumQuery(int s) {\n    size_ = 1;\n    while(size_ < s) size_ <<= 1;\n    node_ = std::vector<int>((size_ << 1) - 1, INF);\n  }\n  int find(int left, int right) const {\n    return query(left, right, 0, 0, size_ - 1);\n  }\n  void update(int index, int value) {\n    int i = index + size_ - 1;\n    node_[i] = value;\n    while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n  }\nprivate:\n  int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n  int left_child(int node) const {return (node << 1) + 1;}\n  int right_child(int node) const {return (node << 1) + 2;}\n  int query(int a, int b, int k, int l, int r) const {\n    if(b < l || r < a) return INF;\n    if(a <= l && r <= b) return node_[k];\n    int vl = query(a, b, left_child(k), l, (l + r) / 2);\n    int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n    return std::min(vl, vr);\n  }\n  int size_;\n  std::vector<int> node_;\n};\n\n#include<iostream>\nusing namespace std;\n\nstruct Star {long long int x, y, b;};\nbool operator<(const Star& lhs, const Star& rhs) {return lhs.b < rhs.b;}\n\nint main() {\n  int N, d;\n  cin >> N >> d;\n  vector<Star> star(N);\n  for(auto& s: star) cin >> s.x >> s.y >> s.b;\n  sort(begin(star), end(star));\n  RangeMinimumQuery left(N), right(N), top(N), bottom(N);\n  for(int i = 0; i < N; ++i) {\n    left.update(i, star[i].x);\n    right.update(i, -star[i].x);\n    top.update(i, star[i].y);\n    bottom.update(i, -star[i].y);\n  }\n  long long int answer = 0;\n  int low, high;\n  for(low = high = 0; low < N; ++low) {\n    while(high < N - 1 && star[high + 1].b - star[low].b <= d) ++high;\n    long long int area = -right.find(low, high) - left.find(low, high);\n    area *= -bottom.find(low, high) - top.find(low, high);\n    answer = max(answer, abs(area));\n  }\n  cout << answer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\nstruct SegmentTree {\n\tint init_val;\n\tint n;\n\tvector<int> dat;\n\t\n\tSegmentTree(int _n) {\n\t\tinit_val = INF;\n\t\tn = 1;\n\t\twhile (n < _n) n *= 2;\n\t\tdat.clear();\n\t\tdat.resize(2 * n - 1, init_val);\n\t}\n\t\n\tvoid update(int k, int a) {\n\t\tk += n - 1;\n\t\tdat[k] = min(dat[k], a);\n\t\t\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = min(dat[2 * k + 1], dat[2 * k + 2]);\n\t\t}\n\t}\n\t\n\tint query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return init_val;\n\t\tif (a <= l && r <= b) return dat[k];\n\t\treturn min(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t\n\tint query(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\n\ntypedef pair<int, int> pii;\ntypedef pair<int , pii> pip;\ntypedef SegmentTree Seg;\ntypedef long long ll;\n\nint main() {\n\tint n, d;\n\tcin >> n >> d;\n\tvector<pip> stars(n);\n\tREP(i, n) {\n\t\tint x, y, b;\n\t\tscanf(\"%d %d %d\", &x, &y, &b);\n\t\tstars[i] = pip(b, pii(x, y));\n\t}\n\tsort(stars.begin(), stars.end());\n\t\n\tSeg up(n), down(n), right(n), left(n);\n\tREP(i, n) {\n\t\tint x = stars[i].second.first;\n\t\tint y = stars[i].second.second;\n\t\t\n\t\tup.update(i, -y);\n\t\tdown.update(i, y);\n\t\tright.update(i, -x);\n\t\tleft.update(i, x);\n\t}\n\t\n\t/*\n\tputs(\"\");\n\tREP(i, n) {\n\t\tcout << stars[i].first << \" \" << stars[i].second.first << \" \" << stars[i].second.second << endl;\n\t}\n\tputs(\"\");\n\t*/\n\t\n\tint st = 0, en = 0;\n\tll ans = 0;\n\t\n\twhile (st < n) {\n\t\tif (en - st > 0 && stars[en].first - stars[st].first <= d) {\n\t\t\tll  s = (ll)(-up.query(st, en + 1) - down.query(st, en + 1))\n\t\t\t\t    * (-right.query(st, en + 1) - left.query(st, en + 1));\n\t\t\tans = max(ans, s);\n\n\t\t\tif (en == n - 1) st++;\n\t\t\telse en++;\n\t\t\t\n\t\t}\n\t\telse if (stars[en].first - stars[st].first > d) st++;\n\t\telse if (en < n - 1) en++;\n\t\telse st++;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <complex>\n\nusing namespace std;\n\n//typedef\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\n//container util\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define UNIQUE(a)  (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << \"[L \" << __LINE__ << \"] \" << #x << \" = \" << (x) << \"\\n\";\n\nconst int INF = 1e9;\nconst int _N = 200000;\nconst int _M = 270000;\n\nstruct SEG{ // min\n\tint d[_M * 2];\n\tint m;\n\tvoid init(int m){\n\t\tthis->m = m;\n\t\tREP(i, m * 2 - 1)d[i] = INF;\n\t}\n\tvoid update(int i, int x){\n\t\ti += m - 1;\n\t\td[i] = x;\n\t\twhile(i>0){\n\t\t\ti = (i -1) / 2;\n\t\t\td[i] = min(d[i * 2 + 1], d[i * 2 + 2]);\n\t\t}\n\t}\n\tint query(int a, int b){\n\t\treturn _query(a, b, 0, 0, m);\n\t}\n\tprivate:int _query(int a, int b, int k, int l, int r){\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <=b) return d[k];\n\t\tint vl = _query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = _query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\nint n, d;\nint sizes[_N]; // sizes exist\nmap<int, int> sizeRef; // [size] = index\n\nSEG xms, xMs, yms, yMs;\ntypedef pair<int, PII> Star;\nStar stars[_N];\nbool comp(const Star& a, const Star& b){\n\treturn a.first < b.first;\n}\nint last = -1, si = -1;\nint xm = INF, xM, ym = INF, yM;\nvoid calc(){\n\tsizes[si] = last;\n\tsizeRef[last] = si;\n\txms.update(si, xm);\n\txMs.update(si, -xM);\n\tyms.update(si, ym);\n\tyMs.update(si, -yM);\n\txm = INF, xM = 0, ym = INF, yM = 0;\n}\n\nint main() {\n\tomajinai;\n\tcin >> n >> d;\n\n\t// segment tree initial\n\tint m=1;\n\twhile(m<n)m*=2;\n\txms.init(m);\n\txMs.init(m);\n\tyms.init(m);\n\tyMs.init(m);\n\t//\n\n\tREP(i, n){\n\t\tint x, y, b;\n\t\tcin >> x >> y >> b;\n\t\tstars[i] = MP(b, MP(x, y));\n\t}\n\tsort(stars, stars + n, comp);\n\tREP(i, n){\n\t\tint b = stars[i].first, x = stars[i].second.first, y = stars[i].second.second;\n\t\tif(b!=last){\n\t\t\tif(si > -1)calc();\n\t\t\tsi++;\n\t\t\tlast = b;\n\t\t}\n\t\txm = min(xm, x);\n\t\txM = max(xM, x);\n\t\tym = min(ym, y);\n\t\tyM = max(yM, y);\n\t}\n\tcalc();\n\n\tsi++; // to use as sizes' size\n\tint ans = 0;\n\tREP(i, n){\n\t\tint b = stars[i].first;\n\t\tint st = sizeRef[b];\n\t\tint ed = upper_bound(sizes, sizes + si, b + d) - sizes;\n\t\txm = xms.query(st, ed);\n\t\txM = -xMs.query(st, ed);\n\t\tym = yms.query(st, ed);\n\t\tyM = -yMs.query(st, ed);\n\t\tans = max(ans, (xM - xm) * (yM - ym));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nstruct Star {\n  int x;\n  int y;\n  int brightness;\n  Star(int x,int y,int brightness) \n    : x(x), y(y), brightness(brightness) {}\n  bool operator>(const Star& s) const {\n    return brightness > s.brightness;\n  }\n};\n\nint main(){\n  int total_stars;\n  int brightness_limit;\n  while(~scanf(\"%d %d\",\n               &total_stars,\n               &brightness_limit)){\n\n    priority_queue<Star,vector<Star>,greater<Star> > que;\n    for(int star_i = 0; star_i < total_stars; star_i++){\n      int x;\n      int y;\n      int brightness;\n      scanf(\"%d %d %d\",&x,&y,&brightness);\n      que.push(Star(x,y,brightness));\n    }\n\n    int lower_idx = 0;\n    vector<Star> stars;\n\n    multiset<int> xs;\n    multiset<int> ys;\n\n    ll res = 0;\n    while(!que.empty()){\n      Star s = que.top();\n      que.pop();\n\n      while(lower_idx < stars.size()\n            && s.brightness - stars[lower_idx].brightness > brightness_limit){\n        xs.erase(xs.find(stars[lower_idx].x));\n        ys.erase(ys.find(stars[lower_idx].y));\n        lower_idx++;\n      }\n      xs.insert(s.x);\n      ys.insert(s.y);\n      stars.push_back(s);\n\n      res = max(res,(ll)(*(--xs.end()) - *xs.begin()) * (ll)(*(--ys.end()) - *ys.begin()));\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing ll=long long int;\n\nconstexpr int MAX_N=(1<<21),INF=2*(int)1e6;\n\nusing P=std::pair<int,int>;//max,min\n\nint n,d;\n\nstd::map<int,std::set<int>> mapX,mapY;\n\nstd::vector<P> maxmin;\n\nstd::vector<int> vec,res;\n\nP calc(const P& lhs,const P& rhs){\n\n    return P(std::max(lhs.first,rhs.first),std::min(lhs.second,rhs.second));\n}\n\nP seg[MAX_N*2-1];\n\nvoid init(int _n) {\n\n    n=1;\n\n    while(n<_n)\n        n*=2;\n\n    for(int i=0;i<n*2-1;++i)\n        seg[i]=P(0,INF);\n\n    for(int i=0;i<_n;++i)\n        seg[i+n-1]=maxmin[i];\n\n    for(int i=n-2;i>=0;--i)\n        seg[i]=calc(seg[i*2+1],seg[i*2+2]);\n}\n\nP query(int a,int b,int k,int l,int r){\n\n    if(b<=l||r<=a)\n        return P(0,INF);\n    \n    if(a<=l&&r<=b)\n        return seg[k];\n    \n    return calc(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n}\n\nstd::vector<int> solve(std::map<int,std::set<int>>& map){\n\n    res.clear();\n    maxmin.clear();\n    vec.clear();\n\n    for(auto&& s : map){\n        vec.emplace_back(s.first);\n        maxmin.emplace_back(*(s.second.rbegin()),*(s.second.begin()));\n    }\n\n    init(maxmin.size());\n\n    for(int i=0;i<vec.size();++i){\n        P p=query(i,std::upper_bound(vec.begin(),vec.end(),vec[i]+d)-vec.begin(),0,0,n);\n        res.emplace_back(p.first-p.second);\n    }\n\n    return res;\n}\n\nint main() {\n\n    std::cin>>n>>d;\n\n    int x,y,b;\n\n    for(int i=0;i<n;++i){\n\n        std::cin>>x>>y>>b;\n\n        mapX[b].emplace(x);\n        mapY[b].emplace(y);\n    }\n\n    std::cout<<'X'<<std::endl;\n\n    std::vector<int> ansX=solve(mapX);\n\n    std::cout<<'Y'<<std::endl;\n\n    std::vector<int> ansY=solve(mapY);\n\n    ll ans=0;\n\n    for(int i=0;i<ansX.size();++i)\n        ans=std::max(ans,ll(ansX[i])*ll(ansY[i]));\n\n    std::cout<<ans<<std::endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint N,d;\n\tcin >> N >> d;\n\tvector< array<int,3> > star;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tint x,y,b;\n\t\tcin >> x >> y >> b;\n\t\tstar.push_back(array<int,3>{b,x,y});\n\t}\t\n\tsort(star.begin(),star.end());\n\tint l = 0 , r = 0;\n\tmultiset<int> X,Y;\n\tlong long ans = 0;\n\twhile( r != N){\n\t\tX.insert(star[r][1]);\n\t\tY.insert(star[r][2]);\n\t\tr++;\n\t\twhile( star[r-1][0] - star[l][0] > d ){\n\t\t\tX.erase(X.find(star[l][1]));\n\t\t\tY.erase(Y.find(star[l][2]));\n\t\t\tl++;\n\t\t}\n\t\tans = max((long long)((*X.rbegin())-(*X.begin())) * ((*Y.rbegin())-(*Y.begin())),ans);\n\t\t//cout << (*X.rbegin())-(*X.begin()) << \" \" << ((*Y.rbegin())-(*Y.begin())) << \"|\" << star[r-1][0] - star[l][0] << endl;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint N=0;\nlong int b=0;\nint maxx=0,maxy=0,maxs=0,x[200000],y[200000],cnt=1;\nstruct DATA{\n\tint x,y,b;\n};\nDATA data[200000];\n\nint main(){\n\tcin>>N>>b;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>data[i].x>>data[i].y>>data[i].b;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tmaxx=0;maxy=0;cnt=1;\n\t\tx[0]=data[i].x;\n\t\ty[0]=data[i].y;\n\t\tfor(int j=0;j<N;j++){\n\t\t\t\n\t\t\tif(0<=data[i].b-data[j].b&&data[i].b-data[j].b<=b){\n\t\t\t\tcnt++;\n\t\t\t\tx[cnt]=data[j].x;\n\t\t\t\ty[cnt]=data[j].y;\n\t\t\t}\n\t\t\tif(j==N-1){\n\t\t\t\tsort(x,x+cnt);\n\t\t\t\tsort(y,y+cnt);\n\t\t\t\tmaxx=x[cnt]-x[0];\n\t\t\t\tmaxy=y[cnt]-y[0];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tks=maxx*maxy;\n\t\tif(maxs<ks){maxs=ks;kma=maxx;kmi=maxy;}\n\t}\n\tcout<<maxs<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define LL long long\n#define PB push_back\n#define MP make_pair\n\nint N;\nLL d;\nvector<pair<LL, pair<LL, LL>>> star;\nmultiset<LL> X, Y;\ndeque<pair<LL, pair<LL, LL>>> dq;\nint main(){\n\tcin >> N >> d;\n\tfor(int i=0; i<N; i++){\n\t\tLL x, y, b;\n\t\tcin >> x >> y >> b;\n\t\tstar.PB({ b,{x,y} });\n\t}\n\tsort(star.begin(), star.end());\n\tLL ans = 0;\n\tfor(int i=0; i<N; i++){\n\t\twhile(dq.size() > 0 && dq.front().first < star[i].first-d){\n\t\t\tauto itr = X.find(dq.front().second.first);\n\t\t\tX.erase(itr);\n\t\t\titr = Y.find(dq.front().second.second);\n\t\t\tY.erase(itr);\n\t\t\tdq.pop_front();\n\t\t}\n\t\tX.insert(star[i].second.first);\n\t\tY.insert(star[i].second.second);\n\t\tdq.push_back(star[i]);\n\n\t\tauto x = X.end();\n\t\tx--;\n\t\tauto y = Y.end();\n\t\ty--;\n\t\t//cout << *X.begin() << \" \" << *x << \" \" << *Y.begin() << \" \" << *y << endl;\n\t\tans = max(ans, (*x-*X.begin()) * (*y-*Y.begin()));\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n\n#define INF 1e6\n\nusing namespace std;\n\ntypedef long long ll;\nint n,d;\nstruct data{\n\tll x,y,c;\n};\n\nbool comp(const data& d1,const data& d2){\n\treturn d1.c<d2.c;\n};\n\ndata s[200001];\n\nstruct segtree{\n\tint val,b,s,v2;\n};\nsegtree seg[2][1<<19];\nvector<ll> x_d,y_d;\n\nvoid init(){\n\tfor(int i=0;i<(1<<19);i++)seg[0][i].s=seg[1][i].s=INF;\n\tfor(int i=1<<18;i<1<<19;i++)seg[0][i].v2=seg[1][i].v2=i-(1<<18);\n\tsort(x_d.begin(),x_d.end());\n\tx_d.erase(unique(x_d.begin(),x_d.end()),x_d.end());\n\tsort(y_d.begin(),y_d.end());\n\ty_d.erase(unique(y_d.begin(),y_d.end()),y_d.end());\n\tfor(int i=0;i<n;i++){\n\t\tint num=lower_bound(x_d.begin(),x_d.end(),s[i].x)-x_d.begin();\n\t\ts[i].x=num;\n\t\tnum=lower_bound(y_d.begin(),y_d.end(),s[i].y)-y_d.begin();\n\t\ts[i].y=num;\n\t}\n}\n\nvoid update(int upd,int x,int a){\n\tx+=(1<<18);\n\tseg[upd][x].val+=a;\n\tif(seg[upd][x].val>=1)seg[upd][x].s=seg[upd][x].b=seg[upd][x].v2;\n\telse{\n\t\tseg[upd][x].s=INF;\n\t\tseg[upd][x].b=0;\n\t}\n\twhile(x>0){\n\t\tx=(x-1)/2;\n\t\tseg[upd][x].s=min(seg[upd][x*2+1].s,seg[upd][x*2+2].s);\n\t\tseg[upd][x].b=max(seg[upd][x*2+1].b,seg[upd][x*2+2].b);\n\t}\n}\n\n\nint main(void){\n\tscanf(\"%d%d\",&n,&d);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lld%lld%lld\",&s[i].x,&s[i].y,&s[i].c);\n\t\tx_d.push_back(s[i].x);\n\t\ty_d.push_back(s[i].y);\n\t}\n\tinit();\n\tsort(s,s+n,comp);\n\tll res=0;\n\tint mc=0;\n\tfor(int i=0;i<n;i++){\n\t\tupdate(0,s[i].x,1);\n\t\tupdate(1,s[i].y,1);\n\t\twhile(s[i].c-s[mc].c>d){\n\t\t\tupdate(0,s[mc].x,-1);\n\t\t\tupdate(1,s[mc].y,-1);\n\t\t\tmc++;\n\t\t}\n\t\tres=max(res,(x_d[seg[0][0].b]-x_d[seg[0][0].s])*(y_d[seg[1][0].b]-y_d[seg[1][0].s]));\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\ntypedef pair<long long int,long long int> P;\ntypedef pair<long long int,P> Pii;\nPii star[200001];\nint main(){\n\tlong long int n,d;\n\tcin >> n >> d;\n\tfor(int i=0;i<n;i++){\n\t\tlong long int a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tPii t;\n\t\tt.first = c;\n\t\tt.second.first = a;\n\t\tt.second.second = b;\n\t\tstar[i] = t;\n\t}\n\tsort(star,star+n);\n\tlong long int ans = 0;\n\tfor(int i=0;i<n;i++){\n\t\tlong long int now = star[i].first;\n\t\tlong long int maxx = star[i].second.first;\n\t\tlong long int minx = star[i].second.first;\n\t\tlong long int maxy = star[i].second.second;\n\t\tlong long int miny = star[i].second.second;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(now + d >= star[j].first){\n\t\t\t\tmaxx = max(maxx,star[j].second.first);\n\t\t\t\tminx = min(minx,star[j].second.first);\n\t\t\t\tmaxy = max(maxy,star[j].second.second);\n\t\t\t\tminy = min(miny,star[j].second.second);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tans = max(ans,(maxx-minx)*(maxy-miny));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0302: Star Watching\n// 2017.12.27 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x11111111\ntypedef struct { int x, y, l; } T;\nT tbl[200001];\nint seg[4][400001], max[4];\nchar buf[30], *p;\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nvoid segtree(int id, int n)\n{\n\tint k;\n\tk = 1; while (k < n) k <<= 1;\n\tmax[id] = k;\n\tmemset(seg[id], INF, sizeof(seg[id]));\n}\n\n// update kth value to v\nvoid update(int id, int k, int v)\n{\n\tint t;\n\tk += max[id]-1;\n\tseg[id][k] = v;\n\twhile (k > 0) {\n\t\tif (!(k & 1)) k--;\n\t\tt = k, k >>= 1;\n\t\tv = seg[id][t++]; if (v > seg[id][t]) v = seg[id][t];\n\t\tseg[id][k] = v;\n\t}\n}\n\nint query2(int id, int a, int b, int k, int l, int r) \n{\n\tint m, lmin, rmin;\n\n\tif (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return seg[id][k];\n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(id, a, b, ++k, l, m);\n    rmin = query2(id, a, b, ++k, m, r);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n\n// get min in [a, b)\nint query(int id, int a, int b)\n{\n\treturn query2(id, a, b+1, 0, 0, max[id]);\n}\n\nint cmp(T *a, T *b) { return a->l - b->l; }\n\nint main()\n{\n\tint n, d, i, j;\n\tlong long ans, a;\n\n\tfgets(p=buf, 30, stdin);\n\tn = in(), d = in();\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(p=buf, 30, stdin);\n\t\ttbl[i].x = in(), tbl[i].y = in(), tbl[i].l = in();\n\t}\n\tqsort(tbl, n, sizeof(T), cmp);\n\n\tfor (i = 0; i < 4; i++) segtree(i, n);\n\tfor (i = 0; i < n; i++) {\n\t\tupdate(0, i,  tbl[i].x), update(1, i, -tbl[i].x);\n\t\tupdate(2, i,  tbl[i].y), update(3, i, -tbl[i].y);\n\t}\n\n\tans = 0;\n\tfor (j = i = 0; i < n; i++) {\n\t\twhile (j < n && tbl[j].l - tbl[i].l <= d) j++;\n\t\tj--;\n\t\t\n\t\ta = (((long long)-query(1, i, j)) - query(0, i, j)) *\n\t\t\t(((long long)-query(3, i, j)) - query(2, i, j));\n\t\tif (a > ans) ans = a;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0302: Star Watching\n// 2017.12.27 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 524290\n\n#define MIN(a,b) ((a)<=(b)?(a):(b))\n\n#define INF 0x11111111\ntypedef struct { int x, y, l; } T;\nT tbl[MAX];\nint seg[4][MAX], sz;\nchar buf[30], *p;\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\n#if 0\nvoid segtree(int id, int n)\n{\n\tint k;\n\tk = 1; while (k < n) k <<= 1;\n\tsz = k;\n\tmemset(seg[id], INF, sizeof(seg[id]));\n}\n#endif\n\n// update kth value to v\nvoid update(int id, int k, int v)\n{\n//\tint t;\n\tk += sz-1;\n\tseg[id][k] = v;\n\twhile (k > 0) {\n#if 0\n\t\tif (!(k & 1)) k--;\n\t\tt = k, k >>= 1;\n\t\tv = seg[id][t++]; if (v > seg[id][t]) v = seg[id][t];\n\t\tseg[id][k] = v;\n#else\n\t\tk = (k-1)/2;\n\t\tseg[id][k] = MIN(seg[id][k*2+1], seg[id][k*2+2]);\n#endif\n\t}\n}\n\nint query2(int id, int a, int b, int k, int l, int r) \n{\n\tint m, lmin, rmin;\n\n\tif (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return seg[id][k];\n#if 0\n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(id, a, b, ++k, l, m);\n    rmin = query2(id, a, b, ++k, m, r);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n#else\n\tm = (l + r) / 2;\n\tlmin = query2(id, a, b, k*2+1, l, m);\n    rmin = query2(id, a, b, k*2+2, m, r);\n\treturn MIN(lmin, rmin);\n#endif\n}\n\n// get min in [a, b)\nint query(int id, int a, int b)\n{\n\treturn query2(id, a, b+1, 0, 0, sz);\n}\n\nint cmp(T *a, T *b) { return a->l - b->l; }\n\nint main()\n{\n\tint n, d, i, j;\n\tlong long ans, a;\n\n\tfgets(p=buf, 30, stdin);\n\tn = in(), d = in();\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(p=buf, 30, stdin);\n\t\ttbl[i].x = in(), tbl[i].y = in(), tbl[i].l = in();\n\t}\n\tqsort(tbl, n, sizeof(T), cmp);\n\ttbl[n].l = INF;\n\n\tsz = 1; while (sz < n) sz <<= 1;\n\tmemset(seg, INF, sizeof(seg));\n\n\tfor (i = 0; i < n; i++) {\n\t\tupdate(0, i, -tbl[i].x), update(1, i, tbl[i].x);\n\t\tupdate(2, i, -tbl[i].y), update(3, i, tbl[i].y);\n\t}\n\n\tans = 0;\n\tfor (j = i = 0; i < n; i++) {\n\t\twhile (j < n && tbl[j].l - tbl[i].l <= d) j++;\n\t\tj--;\n\n\t\ta = (((long long)query(0, i, j)) + query(1, i, j)) *\n\t\t\t(((long long)query(2, i, j)) + query(3, i, j));\n\t\tif (a > ans) ans = a;\n\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0302: Star Watching\n// 2017.10.8 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct { int x, y, b; } T;\nT star[200002];\n\nint cmp(T *a, T *b) { return a->b - b->b; }\n\nlong long calc(int i, int j)\n{\n\tlong long l, r, u, d;\n\tl = r = star[i].x, u = d = star[i].y;\n\twhile (++i <= j) {\n\t\tif      (star[i].x < l) l = star[i].x;\n\t\telse if (star[i].x > r) r = star[i].x;\n\t\tif      (star[i].y < u) u = star[i].y;\n\t\telse if (star[i].y > d) d = star[i].y;\n\t}\n\treturn (r-l)*(d-u);\n}\n\nint main()\n{\n\tint n, d, i, j;\n\tlong long ans, a;\n\n\tscanf(\"%d%d\", &n, &d);\n\tfor (i = 0; i < n; i++) scanf(\"%d%d%d\", &star[i].x, &star[i].y, &star[i].b);\n\tqsort(star, n, sizeof(T), cmp);\n\tfor (ans = 0, i = j = 0; j < n; ) {\n\t\twhile (star[j].b - star[i].b > d) i++;\n\t\twhile (j < n && star[j].b - star[i].b <= d) j++;\n\t\tif ((a = calc(i, j-1)) > ans) ans = a;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0302: Star Watching\n// 2017.12.27 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 262146\n\n#define INF 0x11111111\ntypedef struct { int x, y, l; } T;\nT tbl[MAX];\nint seg[4][MAX], sz;\nchar buf[30], *p;\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\n#if 0\nvoid segtree(int id, int n)\n{\n\tint k;\n\tk = 1; while (k < n) k <<= 1;\n\tsz = k;\n\tmemset(seg[id], INF, sizeof(seg[id]));\n}\n#endif\n\n// update kth value to v\nvoid update(int id, int k, int v)\n{\n\tint t;\n\tk += sz-1;\n\tseg[id][k] = v;\n\twhile (k > 0) {\n\t\tif (!(k & 1)) k--;\n\t\tt = k, k >>= 1;\n\t\tv = seg[id][t++]; if (v > seg[id][t]) v = seg[id][t];\n\t\tseg[id][k] = v;\n\t}\n}\n\nint query2(int id, int a, int b, int k, int l, int r) \n{\n\tint m, lmin, rmin;\n\n\tif (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return seg[id][k];\n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(id, a, b, ++k, l, m);\n    rmin = query2(id, a, b, ++k, m, r);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n\n// get min in [a, b)\nint query(int id, int a, int b)\n{\n\treturn query2(id, a, b, 0, 0, sz);\n}\n\nint cmp(T *a, T *b) { return a->l - b->l; }\n\nint main()\n{\n\tint n, d, i, j;\n\tlong long ans, a;\n\n\tfgets(p=buf, 30, stdin);\n\tn = in(), d = in();\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(p=buf, 30, stdin);\n\t\ttbl[i].x = in(), tbl[i].y = in(), tbl[i].l = in();\n\t}\n\tqsort(tbl, n, sizeof(T), cmp);\n\ttbl[n].l = INF;\n\n\tsz = 1; while (sz < n) sz <<= 1;\n\tmemset(seg, INF, sizeof(seg));\n\n\tfor (i = 0; i < n; i++) {\n\t\tupdate(0, i, -tbl[i].x), update(1, i, tbl[i].x);\n\t\tupdate(2, i, -tbl[i].y), update(3, i, tbl[i].y);\n\t}\n\n\tans = 0;\n\ti = j = 0;\n\twhile (j < n) {\n\t\twhile (tbl[j].l - tbl[i].l <= d) j++;\n\n\t\ta = (((long long)query(0, i, j)) + query(1, i, j)) *\n\t\t\t(((long long)query(2, i, j)) + query(3, i, j));\n\t\tif (a > ans) ans = a;\n\n\t\twhile (i < n && tbl[j].l - tbl[i].l > d) i++;\n\t\tif (i == n) break;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0302: Star Watching\n// 2017.12.27 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 262146\n\n#define INF 0x11111111\ntypedef struct { int x, y, l; } T;\nT tbl[MAX];\nint seg[4][MAX], sz;\nchar buf[30], *p;\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\n#if 0\nvoid segtree(int id, int n)\n{\n\tint k;\n\tk = 1; while (k < n) k <<= 1;\n\tsz = k;\n\tmemset(seg[id], INF, sizeof(seg[id]));\n}\n#endif\n\n// update kth value to v\nvoid update(int id, int k, int v)\n{\n\tint t;\n\tk += sz-1;\n\tseg[id][k] = v;\n\twhile (k > 0) {\n\t\tif (!(k & 1)) k--;\n\t\tt = k, k >>= 1;\n\t\tv = seg[id][t++]; if (v > seg[id][t]) v = seg[id][t];\n\t\tseg[id][k] = v;\n\t}\n}\n\nint query2(int id, int a, int b, int k, int l, int r) \n{\n\tint m, lmin, rmin;\n\n\tif (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return seg[id][k];\n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(id, a, b, ++k, l, m);\n    rmin = query2(id, a, b, ++k, m, r);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n\n// get min in [a, b)\nint query(int id, int a, int b)\n{\n\treturn query2(id, a, b, 0, 0, sz);\n}\n\nint cmp(T *a, T *b) { return a->l - b->l; }\n\nint main()\n{\n\tint n, d, i, j;\n\tlong long ans, a;\n\n\tfgets(p=buf, 30, stdin);\n\tn = in(), d = in();\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(p=buf, 30, stdin);\n\t\ttbl[i].x = in(), tbl[i].y = in(), tbl[i].l = in();\n\t}\n\tqsort(tbl, n, sizeof(T), cmp);\n\ttbl[n].l = INF;\n\n\tsz = 1; while (sz < n) sz <<= 1;\n\tmemset(seg, INF, sizeof(seg));\n\n\tfor (i = 0; i < n; i++) {\n\t\tupdate(0, i, -tbl[i].x), update(1, i, tbl[i].x);\n\t\tupdate(2, i, -tbl[i].y), update(3, i, tbl[i].y);\n\t}\n\n\tans = 0;\n\ti = j = 0;\n\twhile (j < n) {\n\t\twhile (tbl[j].l - tbl[i].l <= d) j++;\n\n\n\t\ta = (((long long)query(0, i, j)) + query(1, i, j)) *\n\t\t\t(((long long)query(2, i, j)) + query(3, i, j));\n\t\tif (a > ans) ans = a;\n\n\t\twhile (i < n && tbl[j].l - tbl[i].l > d) i++;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0302: Star Watching\n// 2017.12.27 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 524290\n\n#define INF 0x55555555\ntypedef struct { int x, y, l; } T;\nT tbl[MAX];\nint seg[4][MAX], sz;\nchar buf[30], *p;\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\n#if 0\nvoid segtree(int id, int n)\n{\n\tint k;\n\tk = 1; while (k < n) k <<= 1;\n\tsz = k;\n\tmemset(seg[id], INF, sizeof(seg[id]));\n}\n#endif\n\n// update kth value to v\nvoid update(int id, int k, int v)\n{\n\tint t;\n\tk += sz-1;\n\tseg[id][k] = v;\n\twhile (k > 0) {\n\t\tif (!(k & 1)) k--;\n\t\tt = k, k >>= 1;\n\t\tv = seg[id][t++]; if (v > seg[id][t]) v = seg[id][t];\n\t\tseg[id][k] = v;\n\t}\n}\n\nint query2(int id, int a, int b, int k, int l, int r) \n{\n\tint m, lmin, rmin;\n\n\tif (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return seg[id][k];\n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(id, a, b, ++k, l, m);\n    rmin = query2(id, a, b, ++k, m, r);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n\n// get min in [a, b)\nint query(int id, int a, int b)\n{\n\treturn query2(id, a, b, 0, 0, sz);\n}\n\nint cmp(T *a, T *b) { return a->l - b->l; }\n\nint main()\n{\n\tint n, d, i, j;\n\tlong long ans, a;\n\n\tfgets(p=buf, 30, stdin);\n\tn = in(), d = in();\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(p=buf, 30, stdin);\n\t\ttbl[i].x = in(), tbl[i].y = in(), tbl[i].l = in();\n\t}\n\tqsort(tbl, n, sizeof(T), cmp);\n\ttbl[n].l = INF;\n\n\tsz = 1; while (sz < n) sz <<= 1;\n\tmemset(seg, INF, sizeof(seg));\n\n\tfor (i = 0; i < n; i++) {\n\t\tupdate(0, i, -tbl[i].x), update(1, i, tbl[i].x);\n\t\tupdate(2, i, -tbl[i].y), update(3, i, tbl[i].y);\n\t}\n\n\tans = 0;\n\ti = j = 0;\n\twhile (1) {\n\t\twhile (tbl[j].l - tbl[i].l <= d) j++;\n\n\t\ta = (((long long)query(0, i, j)) + query(1, i, j)) *\n\t\t\t(((long long)query(2, i, j)) + query(3, i, j));\n\t\tif (a > ans) ans = a;\n\n\t\tif (j == n) break;\n\t\twhile (i < n && tbl[j].l - tbl[i].l > d) i++;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0302: Star Watching\n// 2017.12.27 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 262146\n\n#define MIN(a,b) ((a)<=(b)?(a):(b))\n\n#define INF 0x11111111\ntypedef struct { int x, y, l; } T;\nT tbl[MAX];\nint seg[4][MAX], sz;\nchar buf[30], *p;\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\n#if 0\nvoid segtree(int id, int n)\n{\n\tint k;\n\tk = 1; while (k < n) k <<= 1;\n\tsz = k;\n\tmemset(seg[id], INF, sizeof(seg[id]));\n}\n#endif\n\n// update kth value to v\nvoid update(int id, int k, int v)\n{\n//\tint t;\n\tk += sz-1;\n\tseg[id][k] = v;\n\twhile (k > 0) {\n#if 0\n\t\tif (!(k & 1)) k--;\n\t\tt = k, k >>= 1;\n\t\tv = seg[id][t++]; if (v > seg[id][t]) v = seg[id][t];\n\t\tseg[id][k] = v;\n#else\n\t\tk = (k-1)/2;\n\t\tseg[id][k] = MIN(seg[id][k*2+1], seg[id][k*2+2]);\n#endif\n\t}\n}\n\nint query2(int id, int a, int b, int k, int l, int r) \n{\n\tint m, lmin, rmin;\n\n\tif (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return seg[id][k];\n#if 0\n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(id, a, b, ++k, l, m);\n    rmin = query2(id, a, b, ++k, m, r);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n#else\n\tm = (l + r) / 2;\n\tlmin = query2(id, a, b, k*2+1, l, m);\n    rmin = query2(id, a, b, k*2+2, m, r);\n\treturn MIN(lmin, rmin);\n#endif\n}\n\n// get min in [a, b)\nint query(int id, int a, int b)\n{\n\treturn query2(id, a, b+1, 0, 0, sz);\n}\n\nint cmp(T *a, T *b) { return a->l - b->l; }\n\nint main()\n{\n\tint n, d, i, j;\n\tlong long ans, a;\n\n\tfgets(p=buf, 30, stdin);\n\tn = in(), d = in();\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(p=buf, 30, stdin);\n\t\ttbl[i].x = in(), tbl[i].y = in(), tbl[i].l = in();\n\t}\n\tqsort(tbl, n, sizeof(T), cmp);\n\ttbl[n].l = INF;\n\n\tsz = 1; while (sz < n) sz <<= 1;\n\tmemset(seg, INF, sizeof(seg));\n\n\tfor (i = 0; i < n; i++) {\n\t\tupdate(0, i, -tbl[i].x), update(1, i, tbl[i].x);\n\t\tupdate(2, i, -tbl[i].y), update(3, i, tbl[i].y);\n\t}\n\n\tans = 0;\n\tfor (j = i = 0; i < n; i++) {\n\t\twhile (j < n && tbl[j].l - tbl[i].l <= d) j++;\n\t\tj--;\n\n\t\ta = (((long long)query(0, i, j)) + query(1, i, j)) *\n\t\t\t(((long long)query(2, i, j)) + query(3, i, j));\n\t\tif (a > ans) ans = a;\n\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0302: Star Watching\n// 2017.12.27 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 200001\n\n#define INF 0x11111111\ntypedef struct { int x, y, l; } T;\nT tbl[MAX];\nint seg[4][MAX], sz;\nchar buf[30], *p;\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\n#if 0\nvoid segtree(int id, int n)\n{\n\tint k;\n\tk = 1; while (k < n) k <<= 1;\n\tsz = k;\n\tmemset(seg[id], INF, sizeof(seg[id]));\n}\n#endif\n\n// update kth value to v\nvoid update(int id, int k, int v)\n{\n\tint t;\n\tk += sz-1;\n\tseg[id][k] = v;\n\twhile (k > 0) {\n\t\tif (!(k & 1)) k--;\n\t\tt = k, k >>= 1;\n\t\tv = seg[id][t++]; if (v > seg[id][t]) v = seg[id][t];\n\t\tseg[id][k] = v;\n\t}\n}\n\nint query2(int id, int a, int b, int k, int l, int r) \n{\n\tint m, lmin, rmin;\n\n\tif (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return seg[id][k];\n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(id, a, b, ++k, l, m);\n    rmin = query2(id, a, b, ++k, m, r);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n\n// get min in [a, b)\nint query(int id, int a, int b)\n{\n\treturn query2(id, a, b, 0, 0, sz);\n}\n\nint cmp(T *a, T *b) { return a->l - b->l; }\n\nint main()\n{\n\tint n, d, i, j;\n\tlong long ans, a;\n\n\tfgets(p=buf, 30, stdin);\n\tn = in(), d = in();\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(p=buf, 30, stdin);\n\t\ttbl[i].x = in(), tbl[i].y = in(), tbl[i].l = in();\n\t}\n\tqsort(tbl, n, sizeof(T), cmp);\n\n\tsz = 1; while (sz < n) sz <<= 1;\n\tmemset(seg, INF, sizeof(seg));\n\n\tfor (i = 0; i < n; i++) {\n\t\tupdate(0, i, -tbl[i].x), update(1, i, tbl[i].x);\n\t\tupdate(2, i, -tbl[i].y), update(3, i, tbl[i].y);\n\t}\n\n\tans = 0;\n\tfor (i = j = 0; j < n; j++) {\n\t\twhile (j < n && tbl[j].l - tbl[i].l <= d) j++;\n\t\tif (j == n) j--;\n\n\t\ta = (((long long)query(0, i, j)) + query(1, i, j)) *\n\t\t\t(((long long)query(2, i, j)) + query(3, i, j));\n\t\tif (a > ans) ans = a;\n\n\t\twhile (i < n && tbl[j].l - tbl[i].l > d) i++;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0302: Star Watching\n// 2017.12.27 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 524290\n\n#define INF 0x11111111\ntypedef struct { int x, y, l; } T;\nT tbl[MAX];\nint seg[4][MAX], sz;\nchar buf[30], *p;\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\n#if 0\nvoid segtree(int id, int n)\n{\n\tint k;\n\tk = 1; while (k < n) k <<= 1;\n\tsz = k;\n\tmemset(seg[id], INF, sizeof(seg[id]));\n}\n#endif\n\n// update kth value to v\nvoid update(int id, int k, int v)\n{\n\tint t;\n\tk += sz-1;\n\tseg[id][k] = v;\n\twhile (k > 0) {\n\t\tif (!(k & 1)) k--;\n\t\tt = k, k >>= 1;\n\t\tv = seg[id][t++]; if (v > seg[id][t]) v = seg[id][t];\n\t\tseg[id][k] = v;\n\t}\n}\n\nint query2(int id, int a, int b, int k, int l, int r) \n{\n\tint m, lmin, rmin;\n\n\tif (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return seg[id][k];\n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(id, a, b, ++k, l, m);\n    rmin = query2(id, a, b, ++k, m, r);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n\n// get min in [a, b)\nint query(int id, int a, int b)\n{\n\treturn query2(id, a, b, 0, 0, sz);\n}\n\nint cmp(T *a, T *b) { return a->l - b->l; }\n\nint main()\n{\n\tint n, d, i, j;\n\tlong long ans, a;\n\n\tfgets(p=buf, 30, stdin);\n\tn = in(), d = in();\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(p=buf, 30, stdin);\n\t\ttbl[i].x = in(), tbl[i].y = in(), tbl[i].l = in();\n\t}\n\tqsort(tbl, n, sizeof(T), cmp);\n\ttbl[n].l = INF;\n\n\tsz = 1; while (sz < n) sz <<= 1;\n\tmemset(seg, INF, sizeof(seg));\n\n\tfor (i = 0; i < n; i++) {\n\t\tupdate(0, i, -tbl[i].x), update(1, i, tbl[i].x);\n\t\tupdate(2, i, -tbl[i].y), update(3, i, tbl[i].y);\n\t}\n\n\tans = 0;\n\ti = j = 0;\n\twhile (j < n) {\n\t\twhile (tbl[j].l - tbl[i].l <= d) j++;\n\n\t\ta = (((long long)query(0, i, j)) + query(1, i, j)) *\n\t\t\t(((long long)query(2, i, j)) + query(3, i, j));\n\t\tif (a > ans) ans = a;\n\n\t\twhile (i < n && tbl[j].l - tbl[i].l > d) i++;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0302: Star Watching\n// 2017.12.27 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 200001\n\n#define INF 0x11111111\ntypedef struct { int x, y, l; } T;\nT tbl[MAX];\nint seg[4][MAX], sz;\nchar buf[30], *p;\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\n#if 0\nvoid segtree(int id, int n)\n{\n\tint k;\n\tk = 1; while (k < n) k <<= 1;\n\tsz = k;\n\tmemset(seg[id], INF, sizeof(seg[id]));\n}\n#endif\n\n// update kth value to v\nvoid update(int id, int k, int v)\n{\n\tint t;\n\tk += sz-1;\n\tseg[id][k] = v;\n\twhile (k > 0) {\n\t\tif (!(k & 1)) k--;\n\t\tt = k, k >>= 1;\n\t\tv = seg[id][t++]; if (v > seg[id][t]) v = seg[id][t];\n\t\tseg[id][k] = v;\n\t}\n}\n\nint query2(int id, int a, int b, int k, int l, int r) \n{\n\tint m, lmin, rmin;\n\n\tif (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return seg[id][k];\n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(id, a, b, ++k, l, m);\n    rmin = query2(id, a, b, ++k, m, r);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n\n// get min in [a, b)\nint query(int id, int a, int b)\n{\n\treturn query2(id, a, b, 0, 0, sz);\n}\n\nint cmp(T *a, T *b) { return a->l - b->l; }\n\nint main()\n{\n\tint n, d, i, j;\n\tlong long ans, a;\n\n\tfgets(p=buf, 30, stdin);\n\tn = in(), d = in();\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(p=buf, 30, stdin);\n\t\ttbl[i].x = in(), tbl[i].y = in(), tbl[i].l = in();\n\t}\n\tqsort(tbl, n, sizeof(T), cmp);\n\n\tsz = 1; while (sz < n) sz <<= 1;\n\tmemset(seg, INF, sizeof(seg));\n\n\tfor (i = 0; i < n; i++) {\n\t\tupdate(0, i,  -tbl[i].x), update(1, i, tbl[i].x);\n\t\tupdate(2, i,  -tbl[i].y), update(3, i, tbl[i].y);\n\t}\n\n\tans = 0;\n\tfor (i = j = 0; j < n; j++) {\n\t\twhile (j < n && tbl[j].l - tbl[i].l <= d) j++;\n\t\t\n\t\ta = (((long long)query(0, i, j)) + query(1, i, j)) *\n\t\t\t(((long long)query(2, i, j)) + query(3, i, j));\n\t\tif (a > ans) ans = a;\n\n\t\twhile (i < n && tbl[j].l - tbl[i].l > d) i++;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_INPUT 200000\n#define MAX_BRIGHT 1000000000\n#define MAX_X 200000\n#define MAX_Y 200000\n\nint StarInput;\nint BrightDiff;\nint StarIndex[MAX_INPUT];\nint Bright[MAX_INPUT];\nint X[MAX_INPUT];\nint Y[MAX_INPUT];\n\nvoid bubbleSortBright();\nvoid assignXY();\nlong long findMaxArea();\nlong long getArea(int);\n\nint main()\n{\n\tint i = 0;\n\t\n\t// Input data\n\tscanf(\"%d\", &StarInput);\n\tscanf(\"%d\", &BrightDiff);\n\tfor(i = 0; i < StarInput; i++){\n\t\tStarIndex[i] = i;\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t\tscanf(\"%d\", &Bright[i]);\n\t}\n\t\n\tbubbleSortBright();\n\tprintf(\"%lld\\n\", findMaxArea());\n\t\n\treturn 0;\n}\n\n// From small to big\nvoid bubbleSortBright(){\n\tint i, j;\n\tfor(i = 0; i < StarInput; i++){\n\t\tfor(j = i + 1; j < StarInput; j++){\n\t\t\tif(Bright[i] > Bright[j]){\n\t\t\t\tint temp = Bright[i];\n\t\t\t\tBright[i] = Bright[j];\n\t\t\t\tBright[j] = temp;\n\t\t\t\ttemp = StarIndex[i];\n\t\t\t\tStarIndex[i] = StarIndex[j];\n\t\t\t\tStarIndex[j] = temp;\n\t\t\t}\n\t\t}\n\t}\n\tassignXY();\n}\n\n// assign acctual XY after sort\nvoid assignXY(){\n\tint tempX[MAX_INPUT];\n\tint tempY[MAX_INPUT];\n\tint i;\n\t\n\tfor(i = 0; i < StarInput; i++){\n\t\ttempX[i] = X[i];\n\t\ttempY[i] = Y[i];\n\t}\n\tfor(i = 0; i < StarInput; i++){\n\t\tX[i] = tempX[StarIndex[i]];\n\t\tY[i] = tempY[StarIndex[i]];\n\t}\n}\n\nlong long findMaxArea(){\n\tlong long maxArea = getArea(Bright[0]);\n\tlong long tempArea;\n\tint i;\n\t\n\tfor(i = 0 + 1; i < StarInput; i++){\n\t\t// Already goes to last element\n\t\tif(Bright[i] + BrightDiff > Bright[StarInput - 1]) break;\n\t\t// Next is too bright\n\t\tif(Bright[i + 1] - Bright[i] > BrightDiff) break;\n\t\t// Same brightness is already count\n\t\tif(Bright[i] == Bright[i - 1]) continue;\n\t\t\n\t\ttempArea = getArea(Bright[i]);\n\t\tif (tempArea > maxArea) maxArea = tempArea;\n\t}\n\t\n\treturn maxArea;\n}\n\nlong long getArea(int startBright){\n\tint minX = MAX_X;\n\tint minY = MAX_Y;\n\tint maxX = 0;\n\tint maxY = 0;\n\tint i;\n\t\n\tfor(i = 0; i < StarInput; i++){\n\t\t// Check brightness\n\t\tif(Bright[i] < startBright) continue;\n\t\tif(Bright[i] - startBright > BrightDiff) break;\n\t\t\n\t\t// Check edge\n\t\tif(X[i] < minX)\tminX = X[i];\n\t\tif(X[i] > maxX)\tmaxX = X[i];\n\t\tif(Y[i] < minY)\tminY = Y[i];\n\t\tif(Y[i] > maxY)\tmaxY = Y[i];\n\t}\n\t\n\treturn (long long)(maxX - minX) * (maxY - minY);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void){\n\tlong int n=0,d=0,x[2000],y[2000],i,t,b[2000],bb=0,xmax=0,xmin=10000000,ymax=0,ymin=10000000,ans=0;\n\tscanf(\"%d %d\",&n,&d);\n\tfor(t=0;t<n;t++){\n\t\tscanf(\"%d %d %d\",&x[t],&y[t],&b[t]);\n\t\tif(bb<b[t]){\n\t\t\tbb=b[t];\n\t\t}\n\t}\n\tfor(t=0;t<bb-d;t++){\n\t\tfor(i=0;i<n;i++){\n\t\t\tif((b[i]>=t)&&(b[i]<=t+d)){\n\t\t\t\tif(xmax<x[i]){\n\t\t\t\t\txmax=x[i];\n\t\t\t\t}\n\t\t\t\tif(xmin>x[i]){\n\t\t\t\t\txmin=x[i]=x[i];\n\t\t\t\t}\n\t\t\t\tif(ymax<y[i]){\n\t\t\t\t\tymax=y[i];\n\t\t\t\t}\n\t\t\t\tif(ymin>y[i]){\n\t\t\t\t\tymin=y[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans<(xmax-xmin)*(ymax-ymin)){\n\t\t\tans=(xmax-xmin)*(ymax-ymin);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "\nabstract class SegmentTree<T>(val size:Int, private val array:Array<T>, private val zero:T){\n    protected abstract fun accumulator(a:T, b:T):T\n    companion object {\n        internal fun Int.toSegmentTreeSize():Int{\n            return when(this){\n                0 -> 0\n                1 -> 4\n                else -> (this shr 1).toSegmentTreeSize() shl 1\n            }\n        }\n    }\n    operator fun set(index:Int, value:T):Unit{\n        assert(index in 0 until size)\n        var start = array.size / 2 + index\n        array[start] = value\n        while (start > 1){\n            start /= 2\n            array[start] = accumulator(array[start * 2], array[start * 2 + 1])\n        }\n    }\n    operator fun get(from:Int, to:Int):T{\n        assert(from in 0 until size && to in 0 until size)\n        assert(from <= to)\n        var left = from + array.size / 2\n        var right = to + array.size / 2\n        var res = zero\n        while (left < right){\n            if (left % 2 != 0) res = accumulator(res, array[left])\n            if (right % 2 == 0) res = accumulator(res, array[right])\n            left = (left + 1) / 2\n            right = (right - 1) / 2\n        }\n        return if (left == right) accumulator(res, array[right]) else res\n\n    }\n    fun inspect():String = array.joinToString(\" \")\n}\nclass MaxSegmentTree(size:Int, defaultValue:Int = Int.MIN_VALUE):SegmentTree<Int>(size, Array(size.toSegmentTreeSize()){defaultValue}, defaultValue){\n    override fun accumulator(a: Int, b: Int): Int {\n        return if (a > b) a else b\n    }\n}\nclass MinSegmentTree(size:Int, defaultValue: Int = Int.MAX_VALUE):SegmentTree<Int>(size, Array(size.toSegmentTreeSize()){defaultValue}, defaultValue){\n    override fun accumulator(a: Int, b: Int): Int {\n        return if (a < b) a else b\n    }\n}\ndata class Star(val x:Int, val y:Int, val brightness:Int)\nfun main(args:Array<String>):Unit {\n    val (n, d) = readLine()!!.split(' ').map(String::toInt)\n    val stars = Array(n){\n        val (x, y, b) = readLine()!!.split(' ').map(String::toInt)\n        Star(x, y, b)\n    }.sortedBy(Star::brightness).toTypedArray()\n    val maxX = MaxSegmentTree(n)\n    val maxY = MaxSegmentTree(n)\n    val minX = MinSegmentTree(n)\n    val minY = MinSegmentTree(n)\n    stars.forEachIndexed{index, star ->\n        maxX[index] = star.x\n        maxY[index] = star.y\n        minX[index] = star.x\n        minY[index] = star.y\n    }\n    var left = 0\n    var right = stars.indexOfFirst { stars.first().brightness + d < it.brightness } - 1\n    var maxSize = 0L\n    while(right < n){\n        if (left < right) {\n            val tempArea = (maxX[left, right] - minX[left, right]).toLong() * (maxY[left, right] - minY[left, right]).toLong()\n            if (tempArea > maxSize) maxSize = tempArea\n        }\n        if (right == n - 1) break\n        val currentBrightness = stars[left].brightness\n        while (++left < n && stars[left].brightness == currentBrightness){}\n        if (left == n) break\n        while (++right < n && stars[right].brightness <= stars[left].brightness + d){}\n        --right\n    }\n    println(maxSize)\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\nclass Main {\n\tstatic int MAX_N = 131072 * 2;\n\tstatic int[] dat = new int[MAX_N];\n\tstatic int n;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tData[] data = new Data[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t}\n\t\tArrays.sort(data);\n\t\t\n\t\tSegTree xmin = new SegTree(n);\n\t\tSegTreeM xmax = new SegTreeM(n);\n\t\tSegTree ymin = new SegTree(n);\n\t\tSegTreeM ymax = new SegTreeM(n);\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\txmin.update(i, data[i].x);\n\t\t\txmax.update(i, data[i].x);\n\t\t\tymin.update(i, data[i].y);\n\t\t\tymax.update(i, data[i].y);\n\t\t}\n\t\tlong max = 0;\n\t\tint r = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\twhile(r+1 < n && data[i].b + d >= data[r+1].b) {\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tlong sum = 0;\n\t\t\tif(i != r) {\n\t\t\tsum = (long)(xmax.query(i, r+1) - xmin.query(i, r+1))*(ymax.query(i, r+1) - ymin.query(i, r+1));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum = 0;\n\t\t\t}\n\t\t\tmax = Math.max(sum, max);\n\t\t}\n\t\t\n\t\t\n\t\tSystem.out.println(max);\n\t}\n\t\n\tstatic class SegTreeM {\n\t\tint n, n_, m;\n\t\tint[] node;\n\t\t\n\t\tpublic SegTreeM(int n) {\n\t\t\tthis.n = n;\n\t\t\tthis.n_ = Integer.highestOneBit(Math.max(n-1,1) << 1);\n\t\t\tthis.m = 2*n_- 1;\n\t\t\tthis.node = new int[m];\n\t\t\tArrays.fill(node, Integer.MIN_VALUE);\n\t\t}\n\t\t\n\t\tvoid update(int x, int a) {\n\t\t\tx += n_ -1;\n\t\t\tnode[x] = a;\n\t\t\twhile(x > 0) {\n\t\t\t\tx = (x-1)/2;\n\t\t\t\tnode[x] = Math.max(node[2*x+1], node[2*x+2]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint query(int l, int r) {\n            return query(l,r,0,n_,0);\n        }\n \n        private int query(int l, int r, int cl, int cr, int cur) {\n            if (l <= cl && cr <= r) {\n                return node[cur];\n            }else {\n                int ret = Integer.MIN_VALUE;\n                int mid = (cl+cr)/2;\n                if (cl < r && l < mid)\n                    ret = Math.max(ret,query(l,r,cl,mid,2*cur+1));\n                if (mid < r && l < cr)\n                    ret = Math.max(ret,query(l,r,mid,cr,2*cur+2));\n                return ret;\n            }\n        }\n\t\t\n\t\t\n\t}\n\t\n\t\n\t\n\tstatic class SegTree {\n\t\tint n, n_, m;\n\t\tint[] node;\n\t\t\n\t\tpublic SegTree(int n) {\n\t\t\tthis.n = n;\n\t\t\tthis.n_ = Integer.highestOneBit(Math.max(n-1,1) << 1);\n\t\t\tthis.m = 2*n_- 1;\n\t\t\tthis.node = new int[m];\n\t\t\tArrays.fill(node, Integer.MAX_VALUE);\n\t\t}\n\t\t\n\t\tvoid update(int x, int a) {\n\t\t\tx += n_ -1;\n\t\t\tnode[x] = a;\n\t\t\twhile(x > 0) {\n\t\t\t\tx = (x-1)/2;\n\t\t\t\tnode[x] = Math.min(node[2*x+1], node[2*x+2]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint query(int l, int r) {\n            return query(l,r,0,n_,0);\n        }\n \n        private int query(int l, int r, int cl, int cr, int cur) {\n            if (l <= cl && cr <= r) {\n                return node[cur];\n            }else {\n                int ret = Integer.MAX_VALUE;\n                int mid = (cl+cr)/2;\n                if (cl < r && l < mid)\n                    ret = Math.min(ret,query(l,r,cl,mid,2*cur+1));\n                if (mid < r && l < cr)\n                    ret = Math.min(ret,query(l,r,mid,cr,2*cur+2));\n                return ret;\n            }\n        }\n\t\t\n\t\t\n\t}\n\t\n\t\n\t\n\tstatic class Data implements Comparable<Data> {\n\t\tint x;\n\t\tint y;\n\t\tint b;\n\t\t\n\t\tData(int a , int c, int d) {\n\t\t\tx = a;\n\t\t\ty = c;\n\t\t\tb = d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.b - o.b;\n\t\t}\n\t}\n \t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\nclass Main {\n    static int MAX_N = 131072 * 2;\n    static int[] dat = new int[MAX_N];\n    static int n;\n \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        int d = sc.nextInt();\n        Data[] data = new Data[n];\n        for(int i = 0; i < n; i++) {\n            data[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt());\n        }\n        Arrays.sort(data);\n         \n        SegTree xmin = new SegTree(n);\n        SegTreeM xmax = new SegTreeM(n);\n        SegTree ymin = new SegTree(n);\n        SegTreeM ymax = new SegTreeM(n);\n         \n        for(int i = 0; i < n; i++) {\n            xmin.update(i, data[i].x);\n            xmax.update(i, data[i].x);\n            ymin.update(i, data[i].y);\n            ymax.update(i, data[i].y);\n        }\n        long max = 0;\n        int r = 0;\n        for(int i = 0; i < n; i++) {\n            while(r+1 < n && data[i].b + d >= data[r+1].b) {\n                r++;\n            }\n            long sum = 0;\n            if(i != r) {\n            sum = (long)(xmax.query(i, r+1) - xmin.query(i, r+1))*(ymax.query(i, r+1) - ymin.query(i, r+1));\n            }\n            else {\n                sum = 0;\n            }\n            max = Math.max(sum, max);\n        }\n         \n         \n        System.out.println(max);\n    }\n     \n    static class SegTreeM {\n        int n, n_, m;\n        int[] node;\n         \n        public SegTreeM(int n) {\n            this.n = n;\n            this.n_ = Integer.highestOneBit(Math.max(n-1,1) << 1);\n            this.m = 2*n_- 1;\n            this.node = new int[m];\n            Arrays.fill(node, Integer.MIN_VALUE);\n        }\n         \n        void update(int x, int a) {\n            x += n_ -1;\n            node[x] = a;\n            while(x > 0) {\n                x = (x-1)/2;\n                node[x] = Math.max(node[2*x+1], node[2*x+2]);\n            }\n        }\n         \n        int query(int l, int r) {\n            return query(l,r,0,n_,0);\n        }\n  \n        private int query(int l, int r, int cl, int cr, int cur) {\n            if (l <= cl && cr <= r) {\n                return node[cur];\n            }else {\n                int ret = Integer.MIN_VALUE;\n                int mid = (cl+cr)/2;\n                if (cl < r && l < mid)\n                    ret = Math.max(ret,query(l,r,cl,mid,2*cur+1));\n                if (mid < r && l < cr)\n                    ret = Math.max(ret,query(l,r,mid,cr,2*cur+2));\n                return ret;\n            }\n        }\n         \n         \n    }\n     \n     \n     \n    static class SegTree {\n        int n, n_, m;\n        int[] node;\n         \n        public SegTree(int n) {\n            this.n = n;\n            this.n_ = Integer.highestOneBit(Math.max(n-1,1) << 1);\n            this.m = 2*n_- 1;\n            this.node = new int[m];\n            Arrays.fill(node, Integer.MAX_VALUE);\n        }\n         \n        void update(int x, int a) {\n            x += n_ -1;\n            node[x] = a;\n            while(x > 0) {\n                x = (x-1)/2;\n                node[x] = Math.min(node[2*x+1], node[2*x+2]);\n            }\n        }\n         \n        int query(int l, int r) {\n            return query(l,r,0,n_,0);\n        }\n  \n        private int query(int l, int r, int cl, int cr, int cur) {\n            if (l <= cl && cr <= r) {\n                return node[cur];\n            }else {\n                int ret = Integer.MAX_VALUE;\n                int mid = (cl+cr)/2;\n                if (cl < r && l < mid)\n                    ret = Math.min(ret,query(l,r,cl,mid,2*cur+1));\n                if (mid < r && l < cr)\n                    ret = Math.min(ret,query(l,r,mid,cr,2*cur+2));\n                return ret;\n            }\n        }\n         \n         \n    }\n     \n     \n     \n    static class Data implements Comparable<Data> {\n        int x;\n        int y;\n        int b;\n         \n        Data(int a , int c, int d) {\n            x = a;\n            y = c;\n            b = d;\n        }\n        @Override\n        public int compareTo(Data o) {\n            return this.b - o.b;\n        }\n    }\n     \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\nclass Main {\n\t\n\tstatic int[][] map;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tData[] data = new Data[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t}\n\t\tArrays.sort(data);\n\t\tint lp = 0;\n\t\tint rp = 0;\n\t\tint max = 0;\n\t\t\n\t\twhile(rp < n && lp < n ) {\n\t\t\twhile(rp+1 < n && data[lp].b + 2 >= data[rp+1].b) {\n\t\t\t\trp++;\n\t\t\t}\n\t\t\t\n\t\t\tint xmin = Integer.MAX_VALUE;\n\t\t\tint xmax = 0;\n\t\t\tint ymin = Integer.MAX_VALUE;\n\t\t\tint ymax = 0;\n\t\t\t\n\t\t\tfor(int i = lp; i <= rp; i++) {\n\t\t\t\tint x = data[i].x;\n\t\t\t\tint y = data[i].y;\n\t\t\t\t\n\t\t\t\txmin = Math.min(x, xmin);\n\t\t\t\txmax = Math.max(x, xmax);\n\t\t\t\tymin = Math.min(y, ymin);\n\t\t\t\tymax = Math.max(y, ymax);\n\t\t\t}\n\t\t\t\n\t\t\tmax = Math.max(max, (xmax - xmin)*(ymax - ymin));\n\t\t\t\n\t\t\tlp = rp;\n\t\t\trp += 1;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(max);\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tstatic class Data implements Comparable<Data> {\n\t\tint x;\n\t\tint y;\n\t\tint b;\n\t\t\n\t\tData(int a , int c, int d) {\n\t\t\tx = a;\n\t\t\ty = c;\n\t\t\tb = d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.b - o.b;\n\t\t}\n\t}\n \t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\nclass Main {\n\t\n\tstatic int[][] map;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tData[] data = new Data[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t}\n\t\tArrays.sort(data);\n\t\tint lp = 0;\n\t\tint rp = 0;\n\t\tint max = 0;\n\t\tint lastLp = -1;\n\t\tint lastRp = -1;\n\t\twhile(rp < n && lp < n) {\n\t\t\t\n\t\t\t//System.out.println(lp + \" \" + rp);\n\t\t\twhile(rp+1 < n && data[lp].b + d >= data[rp+1].b) {\n\t\t\t\tSystem.out.println(lp + \" \" + rp);\n\t\t\t\trp++;\n\t\t\t}\n\t\t\tif(lastLp == lp && lastRp == rp) {\n\t\t\t\tlp++;\n\t\t\t\trp++;\n\t\t\t}\n\t\t\t\n\t\t\tint xmin = Integer.MAX_VALUE;\n\t\t\tint xmax = 0;\n\t\t\tint ymin = Integer.MAX_VALUE;\n\t\t\tint ymax = 0;\n\t\t\t\n\t\t\tif(lp != rp) \n\t\t\tfor(int i = lp; i <= rp; i++) {\n\t\t\t\tint x = data[i].x;\n\t\t\t\tint y = data[i].y;\n\t\t\t\t\n\t\t\t\txmin = Math.min(x, xmin);\n\t\t\t\txmax = Math.max(x, xmax);\n\t\t\t\tymin = Math.min(y, ymin);\n\t\t\t\tymax = Math.max(y, ymax);\n\t\t\t}\n\t\t\telse {\n\t\t\t\txmin = 0;\n\t\t\t\txmax = 0;\n\t\t\t\tymin = 0;\n\t\t\t\txmax = 0;\n\t\t\t}\n\t\t\t\n\t\t\tmax = Math.max(max, (xmax - xmin)*(ymax - ymin));\n\t\t\t\n\t\t\tlastLp = lp;\n\t\t\tlastRp = rp;\n\t\t\t\n\t\t\tlp = rp;\n\t\t\trp = lp;\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(max);\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tstatic class Data implements Comparable<Data> {\n\t\tint x;\n\t\tint y;\n\t\tint b;\n\t\t\n\t\tData(int a , int c, int d) {\n\t\t\tx = a;\n\t\t\ty = c;\n\t\t\tb = d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.b - o.b;\n\t\t}\n\t}\n \t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\nclass Main {\n\tstatic int MAX_N = 131072 * 2;\n\tstatic int[] dat = new int[MAX_N];\n\tstatic int n;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tData[] data = new Data[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t}\n\t\tArrays.sort(data);\n\t\t\n\t\tSegTree xmin = new SegTree(n);\n\t\tSegTreeM xmax = new SegTreeM(n);\n\t\tSegTree ymin = new SegTree(n);\n\t\tSegTreeM ymax = new SegTreeM(n);\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\txmin.update(i, data[i].x);\n\t\t\txmax.update(i, data[i].x);\n\t\t\tymin.update(i, data[i].y);\n\t\t\tymax.update(i, data[i].y);\n\t\t}\n\t\tlong max = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint r = i;\n\t\t\twhile(r+1 < n && data[i].b + d >= data[r+1].b) {\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tint sum = (xmax.query(i, r+1) - xmin.query(i, r+1))*(ymax.query(i, r+1) - ymin.query(i, r+1));\n\t\t\tmax = Math.max(sum, max);\n\t\t}\n\t\t\n\t\t\n\t\tSystem.out.println(max);\n\t}\n\t\n\tstatic class SegTreeM {\n\t\tint n, n_, m;\n\t\tint[] node;\n\t\t\n\t\tpublic SegTreeM(int n) {\n\t\t\tthis.n = n;\n\t\t\tthis.n_ = Integer.highestOneBit(Math.max(n-1,1) << 1);\n\t\t\tthis.m = 2*n_- 1;\n\t\t\tthis.node = new int[m];\n\t\t\tArrays.fill(node, Integer.MIN_VALUE);\n\t\t}\n\t\t\n\t\tvoid update(int x, int a) {\n\t\t\tx += n_ -1;\n\t\t\tnode[x] = a;\n\t\t\twhile(x > 0) {\n\t\t\t\tx = (x-1)/2;\n\t\t\t\tnode[x] = Math.max(node[2*x+1], node[2*x+2]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint query(int l, int r) {\n            return query(l,r,0,n_,0);\n        }\n \n        private int query(int l, int r, int cl, int cr, int cur) {\n            if (l <= cl && cr <= r) {\n                return node[cur];\n            }else {\n                int ret = Integer.MIN_VALUE;\n                int mid = (cl+cr)/2;\n                if (cl < r && l < mid)\n                    ret = Math.max(ret,query(l,r,cl,mid,2*cur+1));\n                if (mid < r && l < cr)\n                    ret = Math.max(ret,query(l,r,mid,cr,2*cur+2));\n                return ret;\n            }\n        }\n\t\t\n\t\t\n\t}\n\t\n\t\n\t\n\tstatic class SegTree {\n\t\tint n, n_, m;\n\t\tint[] node;\n\t\t\n\t\tpublic SegTree(int n) {\n\t\t\tthis.n = n;\n\t\t\tthis.n_ = Integer.highestOneBit(Math.max(n-1,1) << 1);\n\t\t\tthis.m = 2*n_- 1;\n\t\t\tthis.node = new int[m];\n\t\t\tArrays.fill(node, Integer.MAX_VALUE);\n\t\t}\n\t\t\n\t\tvoid update(int x, int a) {\n\t\t\tx += n_ -1;\n\t\t\tnode[x] = a;\n\t\t\twhile(x > 0) {\n\t\t\t\tx = (x-1)/2;\n\t\t\t\tnode[x] = Math.min(node[2*x+1], node[2*x+2]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint query(int l, int r) {\n            return query(l,r,0,n_,0);\n        }\n \n        private int query(int l, int r, int cl, int cr, int cur) {\n            if (l <= cl && cr <= r) {\n                return node[cur];\n            }else {\n                int ret = Integer.MAX_VALUE;\n                int mid = (cl+cr)/2;\n                if (cl < r && l < mid)\n                    ret = Math.min(ret,query(l,r,cl,mid,2*cur+1));\n                if (mid < r && l < cr)\n                    ret = Math.min(ret,query(l,r,mid,cr,2*cur+2));\n                return ret;\n            }\n        }\n\t\t\n\t\t\n\t}\n\t\n\t\n\t\n\tstatic class Data implements Comparable<Data> {\n\t\tint x;\n\t\tint y;\n\t\tint b;\n\t\t\n\t\tData(int a , int c, int d) {\n\t\t\tx = a;\n\t\t\ty = c;\n\t\t\tb = d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.b - o.b;\n\t\t}\n\t}\n \t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\nclass Main {\n\t\n\tstatic int[][] map;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tData[] data = new Data[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t}\n\t\tArrays.sort(data);\n\t\tint lp = 0;\n\t\tint rp = 0;\n\t\tint max = 0;\n\t\twhile(rp < n && lp < n) {\n\t\t\t\n\t\t\t\n\t\t\twhile(rp+1 < n && data[lp].b + d >= data[rp+1].b) {\n\t\t\t\trp++;\n\t\t\t}\n\n\t\t\t\n\t\t\t\n\t\t\tint xmin = Integer.MAX_VALUE;\n\t\t\tint xmax = 0;\n\t\t\tint ymin = Integer.MAX_VALUE;\n\t\t\tint ymax = 0;\n\t\t\t\n\t\t\tfor(int i = lp; i <= rp; i++) {\n\t\t\t\tint x = data[i].x;\n\t\t\t\tint y = data[i].y;\n\t\t\t\t\n\t\t\t\txmin = Math.min(x, xmin);\n\t\t\t\txmax = Math.max(x, xmax);\n\t\t\t\tymin = Math.min(y, ymin);\n\t\t\t\tymax = Math.max(y, ymax);\n\t\t\t}\n\n\n\t\t\t\n\t\t\tmax = Math.max(max, (xmax - xmin)*(ymax - ymin));\n\t\t\twhile(lp+1 < n && data[lp].b == data[lp+1].b) {\n\t\t\t\tlp++;\n\t\t\t}\n\t\t\tlp++;\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(max);\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tstatic class Data implements Comparable<Data> {\n\t\tint x;\n\t\tint y;\n\t\tint b;\n\t\t\n\t\tData(int a , int c, int d) {\n\t\t\tx = a;\n\t\t\ty = c;\n\t\t\tb = d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.b - o.b;\n\t\t}\n\t}\n \t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Star Watching\n * PCK2014 ??????8\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint N = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tint d = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tMap<Integer, int[]> stars = new HashMap<>();//[top,buttom,rigth,left]\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tint x, y, b;\n\t\t\t\tx = parseInt(words[0]);\n\t\t\t\ty = parseInt(words[1]);\n\t\t\t\tb = parseInt(words[2]);\n\n\t\t\t\tif (!stars.containsKey(b)) {\n\t\t\t\t\tstars.put(b, new int[]{y, y, x, x});\n\t\t\t\t} else {\n\t\t\t\t\tif (y > stars.get(b)[0]) {\n\t\t\t\t\t\tstars.get(b)[0] = y;\n\t\t\t\t\t} else if (y < stars.get(b)[1]) {\n\t\t\t\t\t\tstars.get(b)[1] = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (x > stars.get(b)[2]) {\n\t\t\t\t\t\tstars.get(b)[2] = x;\n\t\t\t\t\t} else if (x < stars.get(b)[3]) {\n\t\t\t\t\t\tstars.get(b)[3] = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] brights = new int[stars.size()];\n\t\t\tint i = 0;\n\t\t\tfor (int b : stars.keySet()) {\n\t\t\t\tbrights[i] = b;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tArrays.sort(brights);\n\n\t\t\tint max = -1;\n\n\t\t\tSystem.out.println();\n\t\t} // end while\n\t} // end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\nclass Main {\n\t\n\tstatic int[][] map;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tData[] data = new Data[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t}\n\t\tArrays.sort(data);\n\t\tint lp = 0;\n\t\tint rp = 0;\n\t\tint max = 0;\n\t\t\n\t\twhile(rp < n && lp < n ) {\n\t\t\twhile(rp+1 < n && data[lp].b + d >= data[rp+1].b) {\n\t\t\t\trp++;\n\t\t\t}\n\t\t\t\n\t\t\tint xmin = Integer.MAX_VALUE;\n\t\t\tint xmax = 0;\n\t\t\tint ymin = Integer.MAX_VALUE;\n\t\t\tint ymax = 0;\n\t\t\t\n\t\t\tif(lp != rp) \n\t\t\tfor(int i = lp; i <= rp; i++) {\n\t\t\t\tint x = data[i].x;\n\t\t\t\tint y = data[i].y;\n\t\t\t\t\n\t\t\t\txmin = Math.min(x, xmin);\n\t\t\t\txmax = Math.max(x, xmax);\n\t\t\t\tymin = Math.min(y, ymin);\n\t\t\t\tymax = Math.max(y, ymax);\n\t\t\t}\n\t\t\telse {\n\t\t\t\txmin = 0;\n\t\t\t\txmax = 0;\n\t\t\t\tymin = 0;\n\t\t\t\txmax = 0;\n\t\t\t}\n\t\t\t\n\t\t\tmax = Math.max(max, (xmax - xmin)*(ymax - ymin));\n\t\t\t\n\t\t\tlp = rp;\n\t\t\trp += 1;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(max);\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tstatic class Data implements Comparable<Data> {\n\t\tint x;\n\t\tint y;\n\t\tint b;\n\t\t\n\t\tData(int a , int c, int d) {\n\t\t\tx = a;\n\t\t\ty = c;\n\t\t\tb = d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.b - o.b;\n\t\t}\n\t}\n \t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\nclass Main {\n\t\n\tstatic int[][] map;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tData[] data = new Data[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t}\n\t\tArrays.sort(data);\n\t\tint lp = 0;\n\t\tint rp = 0;\n\t\tint max = 0;\n\t\t\n\t\twhile(rp < n && lp < n ) {\n\t\t\twhile(rp+1 < n && data[lp].b + 2 >= data[rp+1].b) {\n\t\t\t\trp++;\n\t\t\t}\n\t\t\t\n\t\t\tint xmin = Integer.MAX_VALUE;\n\t\t\tint xmax = 0;\n\t\t\tint ymin = Integer.MAX_VALUE;\n\t\t\tint ymax = 0;\n\t\t\t\n\t\t\tif(lp != rp) \n\t\t\tfor(int i = lp; i <= rp; i++) {\n\t\t\t\tint x = data[i].x;\n\t\t\t\tint y = data[i].y;\n\t\t\t\t\n\t\t\t\txmin = Math.min(x, xmin);\n\t\t\t\txmax = Math.max(x, xmax);\n\t\t\t\tymin = Math.min(y, ymin);\n\t\t\t\tymax = Math.max(y, ymax);\n\t\t\t}\n\t\t\telse {\n\t\t\t\txmin = 0;\n\t\t\t\txmax = 0;\n\t\t\t\tymin = 0;\n\t\t\t\txmax = 0;\n\t\t\t}\n\t\t\t\n\t\t\tmax = Math.max(max, (xmax - xmin)*(ymax - ymin));\n\t\t\t\n\t\t\tlp = rp;\n\t\t\trp += 1;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(max);\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tstatic class Data implements Comparable<Data> {\n\t\tint x;\n\t\tint y;\n\t\tint b;\n\t\t\n\t\tData(int a , int c, int d) {\n\t\t\tx = a;\n\t\t\ty = c;\n\t\t\tb = d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.b - o.b;\n\t\t}\n\t}\n \t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\nclass Main {\n    static int MAX_N = 131072 * 2;\n    static int[] dat = new int[MAX_N];\n    static int n;\n \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        int d = sc.nextInt();\n        Data[] data = new Data[n];\n        for(int i = 0; i < n; i++) {\n            data[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt());\n        }\n        Arrays.sort(data);\n         \n        SegTree xmin = new SegTree(n);\n        SegTreeM xmax = new SegTreeM(n);\n        SegTree ymin = new SegTree(n);\n        SegTreeM ymax = new SegTreeM(n);\n         \n        for(int i = 0; i < n; i++) {\n            xmin.update(i, data[i].x);\n            xmax.update(i, data[i].x);\n            ymin.update(i, data[i].y);\n            ymax.update(i, data[i].y);\n        }\n        long max = 0;\n        int r = 0;\n        for(int i = 0; i < n; i++) {\n            while(r+1 < n && data[i].b + d >= data[r+1].b) {\n                r++;\n            }\n            long sum = 0;\n            if(i != r) {\n            sum = (long)(xmax.query(i, r+1) - xmin.query(i, r+1))*(ymax.query(i, r+1) - ymin.query(i, r+1));\n            }\n            else {\n                sum = 0;\n            }\n            max = Math.max(sum, max);\n        }\n         \n         \n        System.out.println(max);\n    }\n     \n    static class SegTreeM {\n        int n, n_, m;\n        int[] node;\n         \n        public SegTreeM(int n) {\n            this.n = n;\n            this.n_ = Integer.highestOneBit(Math.max(n-1,1) << 1);\n            this.m = 2*n_- 1;\n            this.node = new int[m];\n            Arrays.fill(node, Integer.MIN_VALUE);\n        }\n         \n        void update(int x, int a) {\n            x += n_ -1;\n            node[x] = a;\n            while(x > 0) {\n                x = (x-1)/2;\n                node[x] = Math.max(node[2*x+1], node[2*x+2]);\n            }\n        }\n         \n        int query(int l, int r) {\n            return query(l,r,0,n_,0);\n        }\n  \n        private int query(int l, int r, int cl, int cr, int cur) {\n            if (l <= cl && cr <= r) {\n                return node[cur];\n            }else {\n                int ret = Integer.MIN_VALUE;\n                int mid = (cl+cr)/2;\n                if (cl < r && l < mid)\n                    ret = Math.max(ret,query(l,r,cl,mid,2*cur+1));\n                if (mid < r && l < cr)\n                    ret = Math.max(ret,query(l,r,mid,cr,2*cur+2));\n                return ret;\n            }\n        }\n         \n         \n    }\n     \n     \n     \n    static class SegTree {\n        int n, n_, m;\n        int[] node;\n         \n        public SegTree(int n) {\n            this.n = n;\n            this.n_ = Integer.highestOneBit(Math.max(n-1,1) << 1);\n            this.m = 2*n_- 1;\n            this.node = new int[m];\n            Arrays.fill(node, Integer.MAX_VALUE);\n        }\n         \n        void update(int x, int a) {\n            x += n_ -1;\n            node[x] = a;\n            while(x > 0) {\n                x = (x-1)/2;\n                node[x] = Math.min(node[2*x+1], node[2*x+2]);\n            }\n        }\n         \n        int query(int l, int r) {\n            return query(l,r,0,n_,0);\n        }\n  \n        private int query(int l, int r, int cl, int cr, int cur) {\n            if (l <= cl && cr <= r) {\n                return node[cur];\n            }else {\n                int ret = Integer.MAX_VALUE;\n                int mid = (cl+cr)/2;\n                if (cl < r && l < mid)\n                    ret = Math.min(ret,query(l,r,cl,mid,2*cur+1));\n                if (mid < r && l < cr)\n                    ret = Math.min(ret,query(l,r,mid,cr,2*cur+2));\n                return ret;\n            }\n        }\n         \n         \n    }\n     \n     \n     \n    static class Data implements Comparable<Data> {\n        int x;\n        int y;\n        int b;\n         \n        Data(int a , int c, int d) {\n            x = a;\n            y = c;\n            b = d;\n        }\n        @Override\n        public int compareTo(Data o) {\n            return this.b - o.b;\n        }\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\nclass Main {\n\tstatic int MAX_N = 131072 * 2;\n\tstatic int[] dat = new int[MAX_N];\n\tstatic int n;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tData[] data = new Data[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t}\n\t\tArrays.sort(data);\n\t\t\n\t\tSegTree xmin = new SegTree(n);\n\t\tSegTreeM xmax = new SegTreeM(n);\n\t\tSegTree ymin = new SegTree(n);\n\t\tSegTreeM ymax = new SegTreeM(n);\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\txmin.update(i, data[i].x);\n\t\t\txmax.update(i, data[i].x);\n\t\t\tymin.update(i, data[i].y);\n\t\t\tymax.update(i, data[i].y);\n\t\t}\n\t\tlong max = 0;\n\t\tint r = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(i != 0 && data[i].b == data[i-1].b) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(r+1 < n && data[i].b + d >= data[r+1].b) {\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tlong sum = 0;\n\t\t\tif(i != r) {\n\t\t\tsum = (long)(xmax.query(i, r+1) - xmin.query(i, r+1))*(ymax.query(i, r+1) - ymin.query(i, r+1));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum = 0;\n\t\t\t}\n\t\t\tmax = Math.max(sum, max);\n\t\t}\n\t\t\n\t\t\n\t\tSystem.out.println(max);\n\t}\n\t\n\tstatic class SegTreeM {\n\t\tint n, n_, m;\n\t\tint[] node;\n\t\t\n\t\tpublic SegTreeM(int n) {\n\t\t\tthis.n = n;\n\t\t\tthis.n_ = Integer.highestOneBit(Math.max(n-1,1) << 1);\n\t\t\tthis.m = 2*n_- 1;\n\t\t\tthis.node = new int[m];\n\t\t\tArrays.fill(node, Integer.MIN_VALUE);\n\t\t}\n\t\t\n\t\tvoid update(int x, int a) {\n\t\t\tx += n_ -1;\n\t\t\tnode[x] = a;\n\t\t\twhile(x > 0) {\n\t\t\t\tx = (x-1)/2;\n\t\t\t\tnode[x] = Math.max(node[2*x+1], node[2*x+2]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint query(int l, int r) {\n            return query(l,r,0,n_,0);\n        }\n \n        private int query(int l, int r, int cl, int cr, int cur) {\n            if (l <= cl && cr <= r) {\n                return node[cur];\n            }else {\n                int ret = Integer.MIN_VALUE;\n                int mid = (cl+cr)/2;\n                if (cl < r && l < mid)\n                    ret = Math.max(ret,query(l,r,cl,mid,2*cur+1));\n                if (mid < r && l < cr)\n                    ret = Math.max(ret,query(l,r,mid,cr,2*cur+2));\n                return ret;\n            }\n        }\n\t\t\n\t\t\n\t}\n\t\n\t\n\t\n\tstatic class SegTree {\n\t\tint n, n_, m;\n\t\tint[] node;\n\t\t\n\t\tpublic SegTree(int n) {\n\t\t\tthis.n = n;\n\t\t\tthis.n_ = Integer.highestOneBit(Math.max(n-1,1) << 1);\n\t\t\tthis.m = 2*n_- 1;\n\t\t\tthis.node = new int[m];\n\t\t\tArrays.fill(node, Integer.MAX_VALUE);\n\t\t}\n\t\t\n\t\tvoid update(int x, int a) {\n\t\t\tx += n_ -1;\n\t\t\tnode[x] = a;\n\t\t\twhile(x > 0) {\n\t\t\t\tx = (x-1)/2;\n\t\t\t\tnode[x] = Math.min(node[2*x+1], node[2*x+2]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint query(int l, int r) {\n            return query(l,r,0,n_,0);\n        }\n \n        private int query(int l, int r, int cl, int cr, int cur) {\n            if (l <= cl && cr <= r) {\n                return node[cur];\n            }else {\n                int ret = Integer.MAX_VALUE;\n                int mid = (cl+cr)/2;\n                if (cl < r && l < mid)\n                    ret = Math.min(ret,query(l,r,cl,mid,2*cur+1));\n                if (mid < r && l < cr)\n                    ret = Math.min(ret,query(l,r,mid,cr,2*cur+2));\n                return ret;\n            }\n        }\n\t\t\n\t\t\n\t}\n\t\n\t\n\t\n\tstatic class Data implements Comparable<Data> {\n\t\tint x;\n\t\tint y;\n\t\tint b;\n\t\t\n\t\tData(int a , int c, int d) {\n\t\t\tx = a;\n\t\t\ty = c;\n\t\t\tb = d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.b - o.b;\n\t\t}\n\t}\n \t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Star Watching\n * PCK2014 ??????8\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint N = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tint d = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tMap<Integer, int[]> stars = new HashMap<>();//[top,buttom,rigth,left]\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tint x, y, b;\n\t\t\t\tx = parseInt(words[0]);\n\t\t\t\ty = parseInt(words[1]);\n\t\t\t\tb = parseInt(words[2]);\n\n\t\t\t\tif (!stars.containsKey(b)) {\n\t\t\t\t\tstars.put(b, new int[]{y, y, x, x});\n\t\t\t\t} else {\n\t\t\t\t\tif (y > stars.get(b)[0]) {\n\t\t\t\t\t\tstars.get(b)[0] = y;\n\t\t\t\t\t} else if (y < stars.get(b)[1]) {\n\t\t\t\t\t\tstars.get(b)[1] = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (x > stars.get(b)[2]) {\n\t\t\t\t\t\tstars.get(b)[2] = x;\n\t\t\t\t\t} else if (x < stars.get(b)[3]) {\n\t\t\t\t\t\tstars.get(b)[3] = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tList<Integer> brights = new ArrayList<>(stars.keySet());\n\t\t\tCollections.sort(brights);\n\n\t\t\tint max = -1;\n\t\t\tfor (int i = 0, j = 0; i < brights.size(); i++) {\n\t\t\t\twhile (j < brights.size() && brights.get(j) - brights.get(i) <= d) j++;\n\t\t\t\tj--;\n\n\t\t\t\tint s, t;\n\t\t\t\ts = brights.get(i);\n\t\t\t\tt = brights.get(j);\n\t\t\t\tmax = Math.max(max,\n\t\t\t\t\t\t(Math.max(stars.get(s)[0], stars.get(t)[0]) - Math.min(stars.get(s)[1], stars.get(t)[1]))\n\t\t\t\t\t\t\t\t* (Math.max(stars.get(s)[2], stars.get(t)[2]) - Math.min(stars.get(s)[3], stars.get(t)[3]))\n\t\t\t\t);\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t} // end while\n\t} // end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\nclass Main {\n\t\n\tstatic int[][] map;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tData[] data = new Data[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t}\n\t\tArrays.sort(data);\n\t\tint lp = 0;\n\t\tint rp = 0;\n\t\tint max = 0;\n\t\tint lastLp = -1;\n\t\tint lastRp = -1;\n\t\twhile(rp < n && lp < n) {\n\t\t\t\n\t\t\t//System.out.println(lp + \" \" + rp);\n\t\t\twhile(rp+1 < n && data[lp].b + d >= data[rp+1].b) {\n\t\t\t\t//System.out.println(lp + \" \" + rp);\n\t\t\t\trp++;\n\t\t\t}\n\t\t\tif(lastLp == lp && lastRp == rp) {\n\t\t\t\tlp++;\n\t\t\t\trp++;\n\t\t\t}\n\t\t\t\n\t\t\tint xmin = Integer.MAX_VALUE;\n\t\t\tint xmax = 0;\n\t\t\tint ymin = Integer.MAX_VALUE;\n\t\t\tint ymax = 0;\n\t\t\t\n\t\t\tif(lp != rp) \n\t\t\tfor(int i = lp; i <= rp; i++) {\n\t\t\t\tint x = data[i].x;\n\t\t\t\tint y = data[i].y;\n\t\t\t\t\n\t\t\t\txmin = Math.min(x, xmin);\n\t\t\t\txmax = Math.max(x, xmax);\n\t\t\t\tymin = Math.min(y, ymin);\n\t\t\t\tymax = Math.max(y, ymax);\n\t\t\t}\n\t\t\telse {\n\t\t\t\txmin = 0;\n\t\t\t\txmax = 0;\n\t\t\t\tymin = 0;\n\t\t\t\txmax = 0;\n\t\t\t}\n\t\t\t\n\t\t\tmax = Math.max(max, (xmax - xmin)*(ymax - ymin));\n\t\t\t\n\t\t\tlastLp = lp;\n\t\t\tlastRp = rp;\n\t\t\t\n\t\t\tlp = rp;\n\t\t\trp = lp;\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(max);\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tstatic class Data implements Comparable<Data> {\n\t\tint x;\n\t\tint y;\n\t\tint b;\n\t\t\n\t\tData(int a , int c, int d) {\n\t\t\tx = a;\n\t\t\ty = c;\n\t\t\tb = d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.b - o.b;\n\t\t}\n\t}\n \t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\nclass Main {\n\t\n\tstatic int[][] map;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tData[] data = new Data[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdata[i] = new Data(sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t}\n\t\tArrays.sort(data);\n\t\tint lp = 0;\n\t\tint rp = 0;\n\t\tlong max = 0;\n\t\twhile(rp < n && lp < n) {\n\t\t\t\n\t\t\twhile(rp+1 < n && data[lp].b + d >= data[rp+1].b) {\n\t\t\t\trp++;\n\t\t\t}\n\n\t\t\t\n\t\t\t\n\t\t\tint xmin = Integer.MAX_VALUE;\n\t\t\tint xmax = 0;\n\t\t\tint ymin = Integer.MAX_VALUE;\n\t\t\tint ymax = 0;\n\t\t\t\n\t\t\tfor(int i = lp; i <= rp; i++) {\n\t\t\t\tint x = data[i].x;\n\t\t\t\tint y = data[i].y;\n\t\t\t\t\n\t\t\t\txmin = Math.min(x, xmin);\n\t\t\t\txmax = Math.max(x, xmax);\n\t\t\t\tymin = Math.min(y, ymin);\n\t\t\t\tymax = Math.max(y, ymax);\n\t\t\t}\n\n\n\t\t\t\n\t\t\tmax = Math.max(max, (long)(xmax - xmin)*(ymax - ymin));\n\t\t\twhile(lp+1 < n && data[lp].b == data[lp+1].b) {\n\t\t\t\tlp++;\n\t\t\t}\n\t\t\tlp++;\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(max);\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tstatic class Data implements Comparable<Data> {\n\t\tint x;\n\t\tint y;\n\t\tint b;\n\t\t\n\t\tData(int a , int c, int d) {\n\t\t\tx = a;\n\t\t\ty = c;\n\t\t\tb = d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.b - o.b;\n\t\t}\n\t}\n \t\n}"
  },
  {
    "language": "C#",
    "code": "using System;\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var d = int.Parse(line[1]);\n        var gmax = 0; var gmin = 1000000000;\n        var stars = new int[n, 3];\n        for (int i = 0; i < n; i++)\n        {\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            stars[i, 0] = int.Parse(line2[2]);\n            stars[i, 1] = int.Parse(line2[0]);\n            stars[i, 2] = int.Parse(line2[1]);\n            var g1 = stars[i, 0];\n            if (g1 > gmax) gmax = g1;\n            if (g1 < gmin) gmin = g1;\n        }\n        var sxmax = 0; var sxmin = 1000000000; var symax = 0; var symin = 1000000000;\n        var areamax = 0;\n        var count = 0;\n        var area = 0;\n        for (int i = gmin; i < gmax - d + 1; i++)\n        {\n            count = 0;\n            sxmax = 0; sxmin = 1000000000; symax = 0; symin = 1000000000;\n            for (int j = 0; j < n; j++)\n            {\n                if (stars[j, 0] >= i && stars[j, 0] <= i + d)\n                {\n                    count++;\n                    if (stars[j, 1] > sxmax) sxmax = stars[j, 1];\n                    if (stars[j, 1] < sxmin) sxmin = stars[j, 1];\n                    if (stars[j, 2] > symax) symax = stars[j, 2];\n                    if (stars[j, 2] < symin) symin = stars[j, 2];\n                }\n            }\n            if (count == 0 | count == 1)\n            {\n                area = 0;\n                goto next;\n            }\n            area = (sxmax - sxmin) * (symax - symin);\n            if (area > areamax) areamax = area;\n            next:;\n        }\n        Console.Write(areamax);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System;\n\npublic class Star\n{\n    public int grade { get; set; }\n    public int sx { get; set; }\n    public int sy { get; set; }\n}\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var startest = new Star[n];\n        var d = int.Parse(line[1]);\n        var gmax = 0; var gmin = 1000000000;\n        for (int i = 0; i < n; i++)\n        {\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            var gbuf = int.Parse(line2[2]);\n            if (gbuf > gmax) gmax = gbuf;\n            if (gbuf < gmin) gmin = gbuf;\n            startest[i] = new Star();\n            startest[i].grade = gbuf;\n            startest[i].sx = int.Parse(line2[0]);\n            startest[i].sy = int.Parse(line2[1]);\n        }\n        var stars = startest.OrderBy(x => x.grade).ToArray();\n        var sxmax = 0; var sxmin = 1000000000; var symax = 0; var symin = 1000000000;\n        var areamax = 0; var count = 0; var area = 0;\n        var nextpoint = 0;\n        for (int i = gmin; i < gmax - d + 1; i++)    // ??????d??§???????´¢\n        {\n            count = 0; sxmax = 0; sxmin = 1000000000; symax = 0; symin = 1000000000;\n            for (int j = nextpoint; j < n; j++)\n            {\n                if (stars[j].grade == i + 1) nextpoint = i + 1;\n                if (stars[j].grade > i + d) goto loopend;\n                if (stars[j].grade >= i && stars[j].grade <= i + d)\n                {\n                    count++;\n                    if (stars[j].sx > sxmax) sxmax = stars[j].sx;\n                    if (stars[j].sx < sxmin) sxmin = stars[j].sx;\n                    if (stars[j].sy > symax) symax = stars[j].sy;\n                    if (stars[j].sy < symin) symin = stars[j].sy;\n                }\n            }\n        loopend:;\n            if (count == 0 | count == 1)\n            {\n                area = 0;\n                goto next;\n            }\n            area = (sxmax - sxmin) * (symax - symin);\n            if (area > areamax) areamax = area;\n            next:;\n        }\n        Console.WriteLine(areamax);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\n\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var d = int.Parse(line[1]);\n        var gmax = 0; var gmin = 1000000000;\n        var stars = new int[n, 3];\n        for (int i = 0; i < n; i++)\n        {\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            stars[i, 0] = int.Parse(line2[2]);\n            stars[i, 1] = int.Parse(line2[0]);\n            stars[i, 2] = int.Parse(line2[1]);\n            var g1 = stars[i, 0];\n            if (g1 > gmax) gmax = g1;\n            if (g1 < gmin) gmin = g1;\n        }\n        var sxmax = 0; var sxmin = 1000000000; var symax = 0; var symin = 1000000000;\n        var areamax = 0;\n        var count = 0;\n        var area = 0;\n        for (int i = gmin; i < gmax - d + 1; i++)\n        {\n            count = 0;\n            sxmax = 0; sxmin = 1000000000; symax = 0; symin = 1000000000;\n            for (int j = 0; j < n; j++)\n            {\n                if (stars[j, 0] >= i && stars[j, 0] <= i + d)\n                {\n                    count++;\n                    if (stars[j, 1] > sxmax) sxmax = stars[j, 1];\n                    if (stars[j, 1] < sxmin) sxmin = stars[j, 1];\n                    if (stars[j, 2] > symax) symax = stars[j, 2];\n                    if (stars[j, 2] < symin) symin = stars[j, 2];\n                }\n            }\n            if (count == 0 | count == 1)\n            {\n                area = 0;\n                goto next;\n            }\n            area = (sxmax - sxmin) * (symax - symin);\n            if (area > areamax) areamax = area;\n            next:;\n        }\n        Console.Write(areamax);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\n\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var d = int.Parse(line[1]);\n        var gmax = 0;\n        var gmin = 1000000000;\n        var stars = new int[n, 3];\n        for (int i = 0; i < n; i++)\n        {\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            stars[i, 0] = int.Parse(line2[2]);\n            stars[i, 1] = int.Parse(line2[0]);\n            stars[i, 2] = int.Parse(line2[1]);\n            var g1 = stars[i, 0];\n            if (g1 > gmax) gmax = g1;\n            if (g1 < gmin) gmin = g1;\n        }\n        var sxmax = 0;\n        var sxmin = 100;\n        var symax = 0;\n        var symin = 1000;\n        var areamax = 0;\n        var count = 0;\n        var area = 0;\n        for (int i = gmin; i < gmax - d + 1; i++)\n        {\n            count = 0;\n            sxmax = 0;\n            sxmin = 1000;\n            symax = 0;\n            symin = 1000;\n            for (int j = 0; j < n; j++)\n            {\n                if (stars[j, 0] >= i && stars[j, 0] <= i + d)\n                {\n                    count++;\n                    if (stars[j, 1] > sxmax) sxmax = stars[j, 1];\n                    if (stars[j, 1] < sxmin) sxmin = stars[j, 1];\n                    if (stars[j, 2] > symax) symax = stars[j, 2];\n                    if (stars[j, 2] < symin) symin = stars[j, 2];\n                }\n            }\n            if (count == 0 | count == 1)   area = 0;\n            else\n            {\n                area = (sxmax - sxmin) * (symax - symin);\n                if (area > areamax) areamax = area;\n            }\n        }\n        Console.Write(areamax);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing static System.Math;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public int x { get; set; }\n    public int y { get; set; }\n    public int b { get; set; }\n}\npublic class rmq\n{\n    private readonly int INTMAX = int.MaxValue;\n    private int[] dat;\n    private static int size;\n\n    public rmq(int n)\n    {\n        size = 1;\n        while (size < n) size *= 2;\n        dat = Enumerable.Repeat(INTMAX, 2 * size - 1).ToArray();\n    }\n\n    public void update(int i, int a)\n    {\n        i += size - 1;\n        dat[i] = a;\n        while (i > 0)\n        {\n            i = (i - 1) / 2;\n            dat[i] = Min(dat[i * 2 + 1], dat[i * 2 + 2]);\n        }\n    }\n\n    private int query(int a, int b, int k, int L, int r)\n    {\n        if (r <= a || b <= L) return INTMAX;\n        if (a <= L && r <= b) return dat[k];\n        else\n        {\n            int vL = query(a, b, k * 2 + 1, L, (L + r) / 2);\n            int vr = query(a, b, k * 2 + 2, (L + r) / 2, r);\n            return Min(vL, vr);\n        }\n    }\n\n    public int query(int a, int b) => query(a, b, 0, 0, size);\n\n}\n\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var d = int.Parse(line[1]);\n        var ps = new P[n];\n        for (int i = 0; i < n; i++)\n        {\n            line = Console.ReadLine().Trim().Split(' ');\n            ps[i] = new P { x = int.Parse(line[0]), y = int.Parse(line[1]), b = int.Parse(line[2]) };\n        }\n        ps = ps.OrderBy(x => x.b).ToArray();\n        getAns(n, d, ps);\n    }\n    static void getAns(int n, int d, P[] ps)\n    {\n        var res = 0L;\n        var rminx = new rmq(n);\n        var rmaxx = new rmq(n);\n        var rminy = new rmq(n);\n        var rmaxy = new rmq(n);\n\n        var ps2 = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            ps2[i] = ps[i].b;\n            rminx.update(i, ps[i].x);\n            rmaxx.update(i, -ps[i].x);\n            rminy.update(i, ps[i].y);\n            rmaxy.update(i, -ps[i].y);\n        }\n        var pre = -1;\n        var pretr = -1;\n        for (int i = 0; i < n - 1; i++)\n        {\n            var t = ps2[i];\n            if (t != pre)\n            {\n                var tmax = t + d;\n                var tr = UpperBound(ps2, tmax);\n                if (tr != pretr && tr - i >= 2)\n                {\n                    var xmin = rminx.query(i, tr);\n                    var xmax = -rmaxx.query(i, tr);\n                    var ymin = rminy.query(i, tr);\n                    var ymax = -rmaxy.query(i, tr);\n                    res = Max(res, (long)(xmax - xmin) * (ymax - ymin));\n                }\n                pretr = tr;\n            }\n            pre = ps2[i];\n        }\n        Console.WriteLine(res);\n\n\n    }\n    static int UpperBound<T>(T[] arr, int start, int end, T value, IComparer<T> comparer)\n    {\n        int low = start;\n        int high = end;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (comparer.Compare(arr[mid], value) <= 0)\n                low = mid + 1;\n            else\n                high = mid;\n        }\n        return low;\n    }\n    static int UpperBound<T>(T[] arr, T value)\n    {\n        return UpperBound(arr, 0, arr.Length, value, Comparer<T>.Default);\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\n\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var d = int.Parse(line[1]);\n        var gmax = 0;\n        var gmin = 1000000000;\n        var stars = new int[n, 3];\n        for (int i = 0; i < n; i++)\n        {\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            stars[i, 0] = int.Parse(line2[2]);\n            stars[i, 1] = int.Parse(line2[0]);\n            stars[i, 2] = int.Parse(line2[1]);\n            var g1 = stars[i, 0];\n            if (g1 > gmax) gmax = g1;\n            if (g1 < gmin) gmin = g1;\n        }\n        var sxmax = 0;\n        var sxmin = 1000000000;\n        var symax = 0;\n        var symin = 1000000000;\n        var areamax = 0;\n        var count = 0;\n        var area = 0;\n        for (int i = gmin; i < gmax - d + 1; i++)\n        {\n            count = 0;\n            sxmax = 0;\n            sxmin = 1000000000;\n            symax = 0;\n            symin = 1000000000;\n            for (int j = 0; j < n; j++)\n            {\n                if (stars[j, 0] >= i && stars[j, 0] <= i + d)\n                {\n                    count++;\n                    if (stars[j, 1] > sxmax) sxmax = stars[j, 1];\n                    if (stars[j, 1] < sxmin) sxmin = stars[j, 1];\n                    if (stars[j, 2] > symax) symax = stars[j, 2];\n                    if (stars[j, 2] < symin) symin = stars[j, 2];\n                }\n            }\n            if (count == 0 | count == 1)\n            {\n                area = 0;\n                goto next;\n            }\n            area = (sxmax - sxmin) * (symax - symin);\n            if (area > areamax) areamax = area;\n            next:;\n        }\n        Console.Write(areamax);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\n\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var d = int.Parse(line[1]);\n        var gmax = 0;\n        var gmin = 1000000000;\n        var stars = new int[n, 3];\n        for (int i = 0; i < n; i++)\n        {\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            stars[i, 0] = int.Parse(line2[2]);\n            stars[i, 1] = int.Parse(line2[0]);\n            stars[i, 2] = int.Parse(line2[1]);\n            var g1 = stars[i, 0];\n            if (g1 > gmax) gmax = g1;\n            if (g1 < gmin) gmin = g1;\n        }\n        var sxmax = 0;\n        var sxmin = 1000000000;\n        var symax = 0;\n        var symin = 1000000000;\n        var areamax = 0;\n        var count = 0;\n        var area = 0;\n        for (int i = gmin; i < gmax - d + 1; i++)\n        {\n            count = 0;\n            sxmax = 0;\n            sxmin = 1000000000;\n            symax = 0;\n            symin = 1000000000;\n            for (int j = 0; j < n; j++)\n            {\n                if (stars[j, 0] >= i && stars[j, 0] <= i + d)\n                {\n                    count++;\n                    if (stars[j, 1] > sxmax) sxmax = stars[j, 1];\n                    if (stars[j, 1] < sxmin) sxmin = stars[j, 1];\n                    if (stars[j, 2] > symax) symax = stars[j, 2];\n                    if (stars[j, 2] < symin) symin = stars[j, 2];\n                }\n            }\n            if (count == 0 | count == 1)\n            {\n                area = 0;\n                goto next;\n            }\n            area = (sxmax - sxmin) * (symax - symin);\n            if (area > areamax) areamax = area;\n            next:;\n        }\n        Console.WriteLine(areamax);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Star\n{\n    public int sx { get; set; }\n    public int sy { get; set; }\n    public int grade { get; set; }\n}\n\n\npublic class hello\n{\n    public static void Main()\n    {\n        var stars = new List<Star>();\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var d = int.Parse(line[1]);\n        var gmax = 0; var gmin = 1000000000;\n        for (int i = 0; i < n; i++)\n        {\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            var gbuf = int.Parse(line2[2]);\n            if (gbuf > gmax) gmax = gbuf;\n            if (gbuf < gmin) gmin = gbuf;\n            stars.Add(new Star { sx = int.Parse(line2[0]), sy = int.Parse(line2[1]), grade = gbuf });\n        }\n        var result = 0;\n        var res1 = 0;\n        for (int i = gmin; i < gmax - d + 1; i++)\n        {\n            var a = stars.Where(x => x.grade >= i).Where(x => x.grade <= i + d);\n            if (a.Count() <= 1)\n            {\n                res1 = 0;\n                goto next;\n            }\n            var z = a.Max(x => x.sx) - a.Min(x => x.sx);\n            var zz = a.Max(x => x.sy) - a.Min(x => x.sy);\n\n            res1 = z * zz;\n            next:;\n            if (res1 > result) result = res1;\n        }\n        Console.WriteLine(result);\n\n\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Star\n{\n    public int sx { get; set; }\n    public int sy { get; set; }\n    public int grade { get; set; }\n}\n\n\npublic class hello\n{\n    public static void Main()\n    {\n        var stars = new List<Star>();\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var d = int.Parse(line[1]);\n        var gmax = 0; var gmin = 1000000000;\n        for (int i = 0; i < n; i++)\n        {\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            var gbuf = int.Parse(line2[2]);\n            if (gbuf > gmax) gmax = gbuf;\n            if (gbuf < gmin) gmin = gbuf;\n            stars.Add(new Star { sx = int.Parse(line2[0]), sy = int.Parse(line2[1]), grade = gbuf });\n        }\n        var result = 0;\n        var res1 = 0;\n        for (int i = gmin; i < gmax - d + 1; i++)\n        {\n            var a = stars.Where(x => x.grade >= i).Where(x => x.grade <= i + d);\n            if (a.Count() <=1)\n            {\n                res1 = 0;\n                goto next;\n            }\n            var z = a.Max(x => x.sx) - a.Min(x => x.sx);\n            var zz = a.Max(x => x.sy) - a.Min(x => x.sy);\n\n            res1 = z * zz;\n        next:;\n            if (res1 > result) result = res1;\n        }\n        Console.WriteLine(result);\n\n\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System;\n\npublic class Star\n{\n    public int grade { get; set; }\n    public int sx { get; set; }\n    public int sy { get; set; }\n}\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var startest = new Star[n];\n        var d = int.Parse(line[1]);\n        var gmax = 0; var gmin = 1000000000;\n        for (int i = 0; i < n; i++)\n        {\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            var gbuf = int.Parse(line2[2]);\n            if (gbuf > gmax) gmax = gbuf;\n            if (gbuf < gmin) gmin = gbuf;\n            startest[i] = new Star();\n            startest[i].grade = gbuf;\n            startest[i].sx = int.Parse(line2[0]);\n            startest[i].sy = int.Parse(line2[1]);\n        }\n        var stars = startest.OrderBy(x => x.grade).ToArray();\n        var sxmax = 0; var sxmin = 1000000000; var symax = 0; var symin = 1000000000;\n        var areamax = 0; var count = 0; var area = 0;\n        for (int i = gmin; i < gmax - d + 1; i++)    // ??????d??§???????´¢\n        {\n            count = 0; sxmax = 0; sxmin = 1000000000; symax = 0; symin = 1000000000;\n            for (int j = 0; j < n; j++)\n            {\n                if (stars[j].grade > i + d) goto loopend;\n                if (stars[j].grade >= i && stars[j].grade <= i + d)\n                {\n                    count++;\n                    if (stars[j].sx > sxmax) sxmax = stars[j].sx;\n                    if (stars[j].sx < sxmin) sxmin = stars[j].sx;\n                    if (stars[j].sy > symax) symax = stars[j].sy;\n                    if (stars[j].sy < symin) symin = stars[j].sy;\n                }\n            }\n        loopend:;\n            if (count == 0 | count == 1)\n            {\n                area = 0;\n                goto next;\n            }\n            area = (sxmax - sxmin) * (symax - symin);\n            if (area > areamax) areamax = area;\n            next:;\n        }\n        Console.WriteLine(areamax);\n    }\n}"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nn, d = map(int, input().split())\nud, od = d // 2, (d + 1) // 2\nstars = defaultdict(set)\n\nfor _ in range(n):\n    x, y, b = map(int, input().split())\n    stars[b].add((x, y))\n\nkeys = set(stars.keys())\nmin_b, max_b = min(keys) + ud, max(keys) - od\nmax_stella = 0\n\nfor b in keys.intersection(range(min_b, max_b + 1)):\n    max_x, min_x, max_y, min_y = 0, 200001, 0, 200001\n    for bb in keys.intersection(range(b - ud, b + od + 1)):\n        for xy in stars[bb]:\n            (x, y) = xy\n            if max_x < x: max_x = x\n            if min_x > x: min_x = x\n            if max_y < y: max_y = y\n            if min_y > y: min_y = y\n    stella = (max_x - min_x) * (max_y - min_y)\n    if max_stella < stella: max_stella = stella\n\nprint(max_stella)"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\nfor j in range(len(a)):\n    astars = []\n    for k in range(len(a)):\n        while(len(astars)<=2):\n            if (a[k][2] <= a[0][2] + lightrange):\n                astars.append(a[k])\n                twostars = k\n    maxx = max(astars[0][0],astars[1][0])\n    minx = min(astars[0][0],astars[1][0])\n    maxy = max(astars[0][1],astars[1][1])\n    miny = min(astars[0][1],astars[1][1])\n    for l in range(len(a)):\n        if (a[l][2] <= a[0][2] + lightrange and (a[l][0]<minx or a[l][0]>maxx or a[l][1]<miny or a[l][1]>maxy)):\n            if(a[l][0]<minx):\n                minx=a[l][0]\n            if(a[l][0]>maxx):\n                maxx=a[l][0]\n            if(a[l][1]<miny):\n                miny=a[l][1]\n            if(a[l][1]>maxy):\n                maxy=a[l][1]\n    area = (maxx-minx)*(maxy-miny)\n    if (area > scale):\n        scale = area\n    del a[0]\n    if len(a) < 2:\n        break;\n\nprint scale"
  },
  {
    "language": "Python",
    "code": "class MinTree:\n  def __init__(self, iterable):\n    self.iter_size = self.get_size(iterable)\n    self.size = self.iter_size * 2 - 1\n    self.value = [None] * self.size\n    for i, v in enumerate(iterable):\n      self.value[self.iter_size + i - 1] = v\n    self.set_value(0)\n    self.range = [None] * self.size\n    self.set_range(0, 0, self.iter_size - 1)\n  \n  def get_size(self, iterable):\n    ret = 1\n    x = len(iterable)\n    while ret < x:\n      ret *= 2\n    return ret\n  \n  def set_range(self, x, left, right):\n    self.range[x] = (left, right)\n    if left != right:\n      self.set_range(x * 2 + 1, left, (right + left) // 2)\n      self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n  def set_value(self, x):\n    if x >= self.iter_size - 1:return self.value[x]\n    a = self.set_value(x * 2 + 1)\n    b = self.set_value(x * 2 + 2)\n    if a == None and b == None:\n      self.value[x] = None\n    elif a == None:\n      self.value[x] = b\n    elif b == None:\n      self.value[x] = a\n    else:\n      self.value[x] = min(a, b)\n    return self.value[x]\n\n  def query(self, x, left, right):\n    x_left, x_right = self.range[x]\n    if right < x_left or x_right < left:\n      return INF\n    if left <= x_left and x_right <= right:\n      return self.value[x]\n\n    return min(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n\n\nclass MaxTree:\n  def __init__(self, iterable):\n    self.iter_size = self.get_size(iterable)\n    self.size = self.iter_size * 2 - 1\n    self.value = [None] * self.size\n    for i, v in enumerate(iterable):\n      self.value[self.iter_size + i - 1] = v\n    self.set_value(0)\n    self.range = [None] * self.size\n    self.set_range(0, 0, self.iter_size - 1)\n  \n  def get_size(self, iterable):\n    ret = 1\n    x = len(iterable)\n    while ret < x:\n      ret *= 2\n    return ret\n  \n  def set_range(self, x, left, right):\n    self.range[x] = (left, right)\n    if left != right:\n      self.set_range(x * 2 + 1, left, (right + left) // 2)\n      self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n  def set_value(self, x):\n    if x >= self.iter_size - 1:return self.value[x]\n    a = self.set_value(x * 2 + 1)\n    b = self.set_value(x * 2 + 2)\n    if a == None and b == None:\n      self.value[x] = None\n    elif a == None:\n      self.value[x] = b\n    elif b == None:\n      self.value[x] = a\n    else:\n      self.value[x] = max(a, b)\n    return self.value[x]\n\n  def query(self, x, left, right):\n    x_left, x_right = self.range[x]\n    if right < x_left or x_right < left:\n      return 0\n    if left <= x_left and x_right <= right:\n      return self.value[x]\n\n    return max(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n\nfrom bisect import bisect_left as bl\n\nn, d = map(int, input().split())\nlst = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x:x[2])\nsorted_x = []\nsorted_y = []\nkeys_to_ind = {}\nfor i in range(n):\n  x, y, b = lst[i]\n  sorted_x.append(x)\n  sorted_y.append(y)\n  if b not in keys_to_ind:\n    keys_to_ind[b] = i\nkeys = list(keys_to_ind.keys())\nmxt = MinTree(sorted_x)\nMxt = MaxTree(sorted_x)\nmyt = MinTree(sorted_y)\nMyt = MaxTree(sorted_y)\n\ndef score(left, right):\n  return (Mxt.query(0, left, right) - mxt.query(0, left, right)) * \\\n         (Myt.query(0, left, right) - myt.query(0, left, right))\n\nINF = 10 ** 20\nkl = 0\nkr = bl(keys, keys[0] + d)\nend = len(keys)\nans = 0\nwhile kr < end:\n  ans = max(ans, score(keys_to_ind[keys[kl]], keys_to_ind[keys[kr]]))\n  kl += 1\n  while kr < end and keys[kl] + d >= keys[kr]:\n    kr += 1\n  kr -= 1\n  if kr == end - 1:break\n\nif kl < end and kr < end:\n  ans = max(ans, score(keys_to_ind[keys[kl]], keys_to_ind[keys[kr]]))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\ntry:\n    while(len(a)>1):\n        minx=maxx=a[0][0]\n        miny=maxy=a[0][1]\n        k=1\n        while(a[k][2]<=a[0][2] + lightrange):\n            if (a[k][0]<minx or a[k][0]>maxx or a[k][1]<miny or a[k][1]>maxy):\n                minx = min(minx,a[k][0])\n                maxx = max(maxx,a[k][0])\n                miny = min(miny,a[k][1])\n                maxy = max(maxy,a[k][1])\n            k+=1\n        area = (maxx-minx)*(maxy-miny)\n        scale = max(scale,area)\n        del a[0]\nexcept(RuntimeError):\n    pass\nprint scale"
  },
  {
    "language": "Python",
    "code": "L = sorted(L,key=lambda x:x[2])\n\ndef get_square(L):\n  if not L or len(L) == 0:return 0\n  x=[L[0][0],L[0][0]]\n  y=[L[0][1],L[0][1]]\n  for i in L:\n    if i[0] < x[0]:x[0] = i[0]\n    elif i[0] > x[1]:x[1] = i[0]\n    if i[1] < y[0]:y[0] = i[1]\n    elif i[1] > y[1]:y[1] = i[1]\n  return (x[1] - x[0]) * (y[1] - y[0])\n\nresult = 0\ni = L[0][2]\nj = L[-1][2]\nwhile True:\n  n = i + d\n  l = []\n  while i <= n:\n    l += [x[0:2] for x in L if x[2] == i]\n    i += 1\n  s = get_square(l)\n  if result < s:result = s\n  i -= d\n  if j < i + d:break\nprint(result)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\n\ndef get_square(L):\n  if not L or len(L) == 0:return 0\n  x=[L[0][0][0],L[0][0][1]]\n  y=[L[0][1][0],L[0][1][1]]\n  for i in L:\n    if i[0][0] < x[0]:x[0] = i[0][0]\n    if i[0][1] > x[1]:x[1] = i[0][1]\n    if i[1][0] < y[0]:y[0] = i[1][0]\n    if i[1][1] > y[1]:y[1] = i[1][1]\n  return (x[1] - x[0]) * (y[1] - y[0])\n\ndef get_xy(b,L):\n  if not L or len(L) == 0:return None\n  x=[L[0][0],L[0][0]]\n  y=[L[0][1],L[0][1]]\n  for i in L:\n    if i[0] < x[0]:x[0] = i[0]\n    elif i[0] > x[1]:x[1] = i[0]\n    if i[1] < y[0]:y[0] = i[1]\n    elif i[1] > y[1]:y[1] = i[1]\n  return (b,x,y)\n\nN,d = map(int,input().split())\nL = sorted(list(set([list(map(int,i.split())) for i in stdin.readlines()])),key=itemgetter(2))\nB = set([i[2] for i in L])\nD = [get_xy(n,[i for i in L if i[2] == n]) for n in B]\n\ni = 0\nresult = 0\nwhile i < len(D):\n  m = D[i][0] + d\n  L = [D[i][1:3]]\n  j = i+1\n  while j < len(D) and D[j][0] <= m:\n    L.append(D[j][1:3])\n    j += 1\n  s = get_square(L)\n  if result < s:result = s\n  i += 1\n\nprint(result)"
  },
  {
    "language": "Python",
    "code": "import math\nclass SegmentTree:\n    def __init__(self, dat, f, sentinel):\n        self.pad = 2 ** math.ceil(math.log(len(dat),2))\n        self.dat = [None] * self.pad + dat + [sentinel] * (self.pad - len(dat))\n        self.f = f\n        self.sentinel = sentinel\n        for i in range(self.pad - 1, 0, -1):\n            self.dat[i] = self.f(self.dat[i * 2:i * 2 + 2])\n        \n    def q(self,l,r):\n        return self.f(self.dat[i] for i in self.get_index(l,r))\n        \n    def get_index(self,l,r):\n        l += self.pad \n        r += self.pad + 1\n        while l < r:\n            if r & 1:\n                r -= 1\n                yield r\n            if l & 1:\n                yield l\n                l += 1\n            l >>= 1\n            r >>= 1\nimport sys\nf = sys.stdin\n\n_, d = map(int, f.readline().split())\n\nx,y = {},{}\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    if bi not in x:\n        x[bi],y[bi] = [],[]\n    x[bi].append(xi)\n    y[bi].append(yi)\n\nb = sorted(x.keys())\n\nxmax = SegmentTree([max(x[bi]) for bi in b],max,sentinel = -1)\nxmin = SegmentTree([min(x[bi]) for bi in b],min,sentinel = 2000001)\nymax = SegmentTree([max(y[bi]) for bi in b],max,sentinel = -1)\nymin = SegmentTree([min(y[bi]) for bi in b],min,sentinel = 2000001)\n\ndef get_lr(b,d):\n    l = r = 0\n    while r < len(b):\n        while b[l] + d < b[r]:\n            l += 1\n        for r in range(r,len(b)):\n            if b[l] + d < b[r]:\n                r -= 1\n                break\n        yield l,r\n        l += 1\n        r += 1\n    \nmax_size = max((xmax.q(l,r) - xmin.q(l,r)) * (ymax.q(l,r) - ymin.q(l,r)) for l,r in get_lr(b,d))\nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\nfrom itertools import takewhile\nfrom random import randint\nfrom array import array\n\nMAX = 200000000\n\nclass Point:\n  def __init__(self,x=-1,y=-1,b=-1):\n    self.x=x\n    self.y=y\n    self.b=b\n\nclass Points:\n  def __init__(self,b,points):\n    self.b=b\n    self.xmin=points[0]\n    self.xmax=points[1]\n    self.ymin=points[2]\n    self.ymax=points[3]\n\n  def set_point(self,point):\n    if self.xmin > point.x:self.xmin=point.x\n    elif self.xmax < point.x:self.xmax=point.x\n    if self.ymin > point.y:self.ymin=point.y\n    elif self.ymax < point.y:self.ymax=point.y\n\nclass Constellation:\n  def __init__(self,bmin=0,bmax=0,xmin=0,xmax=0,ymin=0,ymax=0):\n    self.D = { i:None for i in range(bmin,bmax+1) }\n    self.bmin=bmin\n    self.bmax=bmax\n    self.xmin=xmin\n    self.xmax=xmax\n    self.ymin=ymin\n    self.ymax=ymax\n\n  def set_points(self,points):\n    if points.b > self.bmax and points.b < self.bmin:\n      raise Exception\n    if self.xmin > points.xmin:self.xmin=points.xmin\n    elif self.xmax < points.xmax:self.xmax=points.xmax\n    if self.ymin > points.ymin:self.ymin=points.ymin\n    elif self.ymax < points.ymax:self.ymax=points.ymax\n\n  def square(self):\n    return (self.xmax - self.xmin) * (self.ymax - self.ymin)\n\n  def update_b(self,bmin=0,bmax=0):\n    for i in range(self.bmin,bmin):\n      del self.D[i]\n    for i in range(self.bmax+1,bmax+1):\n      self.D[i] = None\n    self.bmin = bmin\n    self.bmax = bmax\n\n\nN,d = map(int,input().split())\nL = [tuple(map(int,i.split())) for i in stdin.readlines()]\nB = sorted(set([i[2] for i in L]))\nD = {i:[] for i in B}\n[D[i[2]].append((i[0],i[1])) for i in L]\nfor k,v in D.items():\n  i = tuple(zip(*v))\n  D[k] = (min(i[0]),max(i[0]),min(i[1]),max(i[1]))\nMax = B[-1]\nresult = 0\n\nif d < 50000:\n  for i in range(len(B)):\n    b = B[i] + d\n    L2 = tuple(zip(*(D[j] for j in \n        takewhile(\n          lambda x: x <= b, \n          (B[n] for n in range(i,len(B)))\n          ))))\n    s = (max(L2[1]) - min(L2[0])) * (max(L2[3]) - min(L2[2]))\n    if result < s:result = s\n    if b > Max:break\n  print(result)\n\nelse:\n  results = 0\n  print(B[0])\n  print(B[0]+d)\n  print(D[B[0]])\n  c = Constellation(B[0],B[0]+d,*D[B[0]])\n  for k,v in D.items(): # k b, v xminmax,yminmax\n    if k <= c.bmax:\n      c.set_points(Points(k,v))\n      continue\n    s = c.square()\n    if result < s:result = s\n    c.update_b(k-d,k)\n    c.set_points(Points(k,v))\n\n  print(result)"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_right as br\n\nclass Node:\n  def __init__(self, val, sec):\n    self.val = val\n    self.sec = sec\n    self.left = sec[0]\n    self.right = sec[1]\n    self.minx = val[0]\n    self.maxx = val[1]\n    self.miny = val[2]\n    self.maxy = val[3]\n\nclass SegTree:\n  def __init__(self, num, lst):\n    num_ = 1\n    while num_ < num:\n      num_ *= 2\n    self.length = num_ * 2 - 1\n    self.arr = [None] * (num_ * 2 - 1)\n    for i in range(num):\n      self.arr[num_ - 1 + i] = Node(lst[i], (i, i))\n\n    self.make(0)\n\n  def make(self, num):\n    if num >= self.length:\n      return None\n    if self.arr[num] != None:\n      return self.arr[num]\n    else:\n      self.arr[num] = self.con(self.make(num * 2 + 1), self.make(num * 2 + 2))\n      return self.arr[num]\n  \n  def con(self, n1, n2):\n    if n1 != None and n2 != None:\n      return Node((min(n1.minx, n2.minx), max(n1.maxx, n2.maxx), min(n1.miny, n2.miny), max(n1.maxy, n2.maxy)),\n                  (n1.left, n2.right))\n    if n1 != None:\n      return n1\n    if n2 != None:\n      return n2\n    return None\n\n  def query(self, l, r, num):\n    node = self.arr[num]\n    if node == None:\n      return None\n    if l <= node.left and node.right <= r:\n      return node.val\n    elif r < node.left or node.right < l:\n      return None\n    else:\n      x1 = self.query(l, r, num * 2 + 1)\n      x2 = self.query(l, r, num * 2 + 2)\n      if x1 == None and x2 == None:\n        return None\n      if x1 == None:\n        return x2\n      if x2 == None:\n        return x1\n      return (min(x1[0], x2[0]), max(x1[1], x2[1]), min(x1[2], x2[2]), max(x1[3], x2[3]))\n\ndef main():\n  n, d = map(int, input().split())\n  stars = []\n  blst = []\n  for _ in range(n):\n    x, y, b = map(int, input().split())\n    stars.append((x, y, b))\n    blst.append(b)\n  blst.sort()\n  stars.sort(key=lambda t:t[2])\n  stars = [(x, x, y, y) for x, y, _ in stars]\n\n  tree = SegTree(n, stars)\n  ans = 0\n  for l in range(n):\n    r = br(blst, blst[l] + d)\n    if r == n:\n      r -= 1\n    elif blst[r] != blst[l] + d:\n      r -= 1\n    a = tree.query(l, r, 0)\n    ans = max((a[1] - a[0]) * (a[3] - a[2]), ans)\n  print(ans)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = [0]\nminlight = -1\nwhile(len(a)>1):\n    if a[0] == minlight:\n        del a[0]\n    else :\n        k=0\n        x=[]\n        y=[]\n        while(a[k][2]<=a[0][2] + lightrange):\n            x.append(a[k][0])\n            y.append(a[k][1])\n            k+=1\n            if(k==len(a)):\n                break\n        scale.append((max(x)-min(x))*(max(y)-min(y)))\n        minlight = a[0][2]\n        del a[0]\nprint max(scale)"
  },
  {
    "language": "Python",
    "code": "def main():\n  INF = 10 ** 20\n\n  class MinTree:\n    def __init__(self, iterable):\n      self.iter_size = self.get_size(iterable)\n      self.size = self.iter_size * 2 - 1\n      self.value = [None] * self.size\n      for i, v in enumerate(iterable):\n        self.value[self.iter_size + i - 1] = v\n      self.set_value(0)\n    \n    def get_size(self, iterable):\n      ret = 1\n      x = len(iterable)\n      while ret < x:\n        ret *= 2\n      return ret\n\n    def set_range(self, x, left, right):\n      self.range[x] = (left, right)\n      if left != right:\n        self.set_range(x * 2 + 1, left, (right + left) // 2)\n        self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n    def set_value(self, x):\n      if x >= self.iter_size - 1:return self.value[x]\n      a = self.set_value(x * 2 + 1)\n      b = self.set_value(x * 2 + 2)\n      if a == None and b == None:\n        self.value[x] = None\n      elif a == None:\n        self.value[x] = b\n      elif b == None:\n        self.value[x] = a\n      else:\n        self.value[x] = a if a < b else b\n      return self.value[x]\n  \n    def query(self, x, left, right):\n      x_left, x_right = self.range[x]\n      if right < x_left or x_right < left:\n        return INF\n      if left <= x_left and x_right <= right:\n        return self.value[x]\n      a = self.query(x * 2 + 1, left, right)\n      b = self.query(x * 2 + 2, left, right)\n      return a if a <= b else b\n \n  class MaxTree:\n    def __init__(self, iterable):\n      self.iter_size = self.get_size(iterable)\n      self.size = self.iter_size * 2 - 1\n      self.value = [None] * self.size\n      for i, v in enumerate(iterable):\n        self.value[self.iter_size + i - 1] = v\n      self.set_value(0)\n    \n    def get_size(self, iterable):\n      ret = 1\n      x = len(iterable)\n      while ret < x:\n        ret *= 2\n      return ret\n    \n    def set_range(self, x, left, right):\n      self.range[x] = (left, right)\n      if left != right:\n        self.set_range(x * 2 + 1, left, (right + left) // 2)\n        self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n    def set_value(self, x):\n      if x >= self.iter_size - 1:return self.value[x]\n      a = self.set_value(x * 2 + 1)\n      b = self.set_value(x * 2 + 2)\n      if a == None and b == None:\n        self.value[x] = None\n      elif a == None:\n        self.value[x] = b\n      elif b == None:\n        self.value[x] = a\n      else:\n        self.value[x] = a if a > b else b\n      return self.value[x]\n  \n    def query(self, x, left, right):\n      x_left, x_right = self.range[x]\n      if right < x_left or x_right < left:\n        return 0\n      if left <= x_left and x_right <= right:\n        return self.value[x]\n      a = self.query(x * 2 + 1, left, right)\n      b = self.query(x * 2 + 2, left, right)\n      return a if a >= b else b\n\n  \n  def set_range(lst, x, left, right):\n    lst[x] = (left, right)\n    if left != right:\n      set_range(lst, x * 2 + 1, left, (right + left) // 2)\n      set_range(lst, x * 2 + 2, (right + left) // 2 + 1, right)\n\n  def index_of_query(lst, x, left, right, ret):\n    x_left, x_right = lst[x]\n    if right < x_left or x_right < left:pass\n    elif left <= x_left and x_right <= right:\n      ret.append(x)\n    else:\n      index_of_query(lst, x * 2 + 1, left, right, ret)\n      index_of_query(lst, x * 2 + 2, left, right, ret)\n\n\n\n  from bisect import bisect_right as br\n\n  n, d = map(int, input().split())\n  lst = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x:x[2])\n  sorted_x = []\n  sorted_y = []\n  keys = []\n  for i in range(n):\n    x, y, b = lst[i]\n    sorted_x.append(x)\n    sorted_y.append(y)\n    keys.append(b)\n  mxt = MinTree(sorted_x)\n  Mxt = MaxTree(sorted_x)\n  myt = MinTree(sorted_y)\n  Myt = MaxTree(sorted_y)\n  lst = [None] * mxt.size\n  set_range(lst, 0, 0, mxt.iter_size - 1)\n  mxt.range = lst\n  Mxt.range = lst\n  myt.range = lst\n  Myt.range = lst\n  \n  def score(left, right):\n    return (Mxt.query(0, left, right) - mxt.query(0, left, right)) * \\\n           (Myt.query(0, left, right) - myt.query(0, left, right))\n  \n  left = 0\n  right = br(keys, keys[0] + d) - 1\n  mx = mxt.query(0, left, right)\n  Mx = Mxt.query(0, left, right)\n  my = myt.query(0, left, right)\n  My = Myt.query(0, left, right)\n  end = len(keys)\n  ans = (Mx - mx) * (My - my)\n  Mx_flag = mx_flag = My_flag = my_flag = False\n  while True:\n    right += 1\n    if right == end:break\n    \n    if sorted_x[right] > Mx:Mx = sorted_x[right]\n    if sorted_x[right] < mx:mx = sorted_x[right] \n    if sorted_y[right] > My:My = sorted_y[right]\n    if sorted_y[right] < my:my = sorted_y[right]\n    \n    while keys[left] + d < keys[right]:\n      if sorted_x[left] == Mx:Mx_flag = True\n      if sorted_x[left] == mx:mx_flag = True\n      if sorted_y[left] == My:My_flag = True\n      if sorted_y[left] == my:my_flag = True\n      left += 1\n    \n    if Mx_flag:\n      Mx = Mxt.query(0, left, right)\n      Mx_flag = False\n    if mx_flag:\n      mx = mxt.query(0, left, right)\n      mx_flag = False\n    if My_flag:\n      My = Myt.query(0, left, right)\n      My_flag = False\n    if my_flag:\n      my = myt.query(0, left, right)\n      my_flag = False\n    \n    ans = max(ans, (Mx - mx) * (My - my)) \n  \n  print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import math\nclass SegmentTree:\n    def __init__(self, dat, f, sentinel):\n        self.pad = 2 ** math.ceil(math.log(len(dat),2))\n        self.dat = [None] * self.pad + dat + [sentinel] * (self.pad - len(dat))\n        self.f = f\n        self.sentinel = sentinel\n        for i in range(self.pad - 1, 0, -1):\n            self.dat[i] = self.f(self.dat[i * 2:i * 2 + 2])\n        \n    def q(self,index):\n        return self.f(self.dat[i] for i in index)\n\n    def get_index(self,l,r):\n        l += self.pad \n        r += self.pad\n        ret = []\n        while l < r:\n            if r & 1:\n                r -= 1\n                ret.append(r)\n            if l & 1:\n                ret.append(l)\n                l += 1\n            l >>= 1\n            r >>= 1\n        return ret\nimport sys\nf = sys.stdin\n\n_, d = map(int, f.readline().split())\n\nx,y = {},{}\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    if bi not in x:\n#        x[bi],y[bi] = [],[]\n#    x[bi].append(xi)\n#    y[bi].append(yi)\n        x[bi],y[bi] = set(),set()\n    x[bi].update([xi])\n    y[bi].update([yi])\n\nb = sorted(x.keys())\n\nxmax = SegmentTree([max(x[bi]) for bi in b],max,sentinel = -1)\nxmin = SegmentTree([min(x[bi]) for bi in b],min,sentinel = 2000001)\nymax = SegmentTree([max(y[bi]) for bi in b],max,sentinel = -1)\nymin = SegmentTree([min(y[bi]) for bi in b],min,sentinel = 2000001)\n\ndef get_lr(b,d):\n    l = r = 0\n    while r < len(b):\n        while b[l] + d < b[r]:\n            l += 1\n        for r in range(r,len(b)):\n            if b[l] + d < b[r]:\n                r -= 1\n                break\n        r += 1\n        yield l,r\n        l += 1\n    \nsize = []\nfor l,r in get_lr(b,d):\n    index = xmax.get_index(l,r)\n    size.append((xmax.q(index) - xmin.q(index)) * (ymax.q(index) - ymin.q(index)))\nprint(max(size))"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\nN,d = map(int,input().split())\nL = sorted([list(map(int,i.split())) for i in stdin.readlines()],key=itemgetter(2))\n#L = [list(map(int,input().split())) for i in range(N)]\n#L = sorted(L,key=itemgetter(2,0,1))\n\ndef get_square(L):\n  if not L or len(L) == 0:return 0\n  x=[L[0][0][0],L[0][0][1]]\n  y=[L[0][1][0],L[0][1][1]]\n  for i in L:\n    if i[0][0] < x[0]:x[0] = i[0][0]\n    if i[0][1] > x[1]:x[1] = i[0][1]\n    if i[1][0] < y[0]:y[0] = i[1][0]\n    if i[1][1] > y[1]:y[1] = i[1][1]\n  return (x[1] - x[0]) * (y[1] - y[0])\n\ndef get_xy(b,L):\n  if not L or len(L) == 0:return None\n  x=[L[0][0],L[0][0]]\n  y=[L[0][1],L[0][1]]\n  for i in L:\n    if i[0] < x[0]:x[0] = i[0]\n    elif i[0] > x[1]:x[1] = i[0]\n    if i[1] < y[0]:y[0] = i[1]\n    elif i[1] > y[1]:y[1] = i[1]\n  return (b,x,y)\n\nD = []\nfor n in range(0,L[-1][2]+1):\n  xy = get_xy(n,[i for i in L if i[2] == n])\n  if xy:D.append(xy)\n\ni = 0\nresult = 0\nwhile i < len(D):\n  m = D[i][0] + d\n  L = [D[i][1:3]]\n  j = i+1\n  while j < len(D) and D[j][0] <= m:\n    L.append(D[j][1:3])\n    j += 1\n  s = get_square(L)\n  if result < s:result = s\n  i += 1\n\nprint(result)"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\nwhile(len(a)>1):\n    k=0\n    x=[]\n    y=[]\n    while(a[k][2]<=a[0][2] + lightrange):\n        x.append(a[k][0])\n        y.append(a[k][1])\n        k+=1\n        if(k==len(a)):\n            break\n    area = (max(x)-min(x))*(max(y)-min(y))\n    scale = max(scale,area)\n    del a[0]\nprint scale"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = []\nminlight = -1\nwhile(len(a)>1):\n    if a[0] == minlight:\n        del a[0]\n    else :\n        k=0\n        x=[]\n        y=[]\n        while(a[k][2]<=a[0][2] + lightrange):\n            x.append(a[k][0])\n            y.append(a[k][1])\n            k+=1\n            if(k==len(a)):\n                break\n        scale.append((max(x)-min(x))*(max(y)-min(y)))\n        minlight = a[0][2]\n        del a[0]\nprint max(scale)"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\nwhile(len(a)>1):\n    minx=maxx=a[0][0]\n    miny=maxy=a[0][1]\n    l=1\n    if (a[l][2] <= a[0][2] + lightrange):\n        if(a[l][0]<minx):\n            minx=a[l][0]\n        if(a[l][0]>maxx):\n            maxx=a[l][0]\n        if(a[l][1]<miny):\n            miny=a[l][1]\n        if(a[l][1]>maxy):\n            maxy=a[l][1]\n    area = (maxx-minx)*(maxy-miny)\n    if (area > scale):\n        scale = area\n    del a[0]\nprint scale"
  },
  {
    "language": "Python",
    "code": "from operator import itemgetter\nN,d = map(int,input().split())\nL = [list(map(int,input().split())) for i in range(N)]\nL = sorted(L,key=itemgetter(2,0,1))\n\ndef get_square(L):\n  if not L or len(L) == 0:return 0\n  x=[L[0][0][0],L[0][0][1]]\n  y=[L[0][1][0],L[0][1][1]]\n  for i in L:\n    if i[0][0] < x[0]:x[0] = i[0][0]\n    if i[0][1] > x[1]:x[1] = i[0][1]\n    if i[1][0] < y[0]:y[0] = i[1][0]\n    if i[1][1] > y[1]:y[1] = i[1][1]\n  return (x[1] - x[0]) * (y[1] - y[0])\n\ndef get_xy(b,L):\n  if not L or len(L) == 0:return None\n  x=[L[0][0],L[0][0]]\n  y=[L[0][1],L[0][1]]\n  for i in L:\n    if i[0] < x[0]:x[0] = i[0]\n    elif i[0] > x[1]:x[1] = i[0]\n    if i[1] < y[0]:y[0] = i[1]\n    elif i[1] > y[1]:y[1] = i[1]\n  return (b,x,y)\n\nD = []\nfor n in range(0,L[-1][2]+1):\n  xy = get_xy(n,[i for i in L if i[2] == n])\n  if xy:D.append(xy)\n\ni = 0\nresult = 0\nwhile i < len(D):\n  m = D[i][0] + d\n  L = [D[i][1:3]]\n  j = i+1\n  while j < len(D) and D[j][0] <= m:\n    L.append(D[j][1:3])\n    j += 1\n  s = get_square(L)\n  if result < s:result = s\n  i += 1\n\nprint(result)"
  },
  {
    "language": "Python",
    "code": "import math\nclass SegmentTree:\n    def __init__(self, dat, f, sentinel):\n        self.pad = 2 ** math.ceil(math.log(len(dat),2))\n        self.dat = [None] * self.pad + dat + [sentinel] * (self.pad - len(dat))\n        self.f = f\n        self.sentinel = sentinel\n        for i in range(self.pad - 1, 0, -1):\n            self.dat[i] = self.f(self.dat[i * 2:i * 2 + 2])\n        \n    def q(self,l,r):\n        return self.f(self.dat[i] for i in self.get_index(l,r))\n    #[l,r)\n    def get_index(self,l,r):\n        l += self.pad \n        r += self.pad\n        while l < r:\n            if r & 1:\n                r -= 1\n                yield r\n            if l & 1:\n                yield l\n                l += 1\n            l >>= 1\n            r >>= 1\n    def q2(self,index):\n        return self.f(self.dat[i] for i in index)\n\n    def get_index2(self,l,r):\n        l += self.pad \n        r += self.pad\n        ret = []\n        while l < r:\n            if r & 1:\n                r -= 1\n                ret.append(r)\n            if l & 1:\n                ret.append(l)\n                l += 1\n            l >>= 1\n            r >>= 1\n        return ret\nimport sys\nf = sys.stdin\n\n_, d = map(int, f.readline().split())\n\nx,y = {},{}\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    if bi not in x:\n        x[bi],y[bi] = [],[]\n    x[bi].append(xi)\n    y[bi].append(yi)\n\nb = sorted(x.keys())\n\nxmax = SegmentTree([max(x[bi]) for bi in b],max,sentinel = -1)\nxmin = SegmentTree([min(x[bi]) for bi in b],min,sentinel = 2000001)\nymax = SegmentTree([max(y[bi]) for bi in b],max,sentinel = -1)\nymin = SegmentTree([min(y[bi]) for bi in b],min,sentinel = 2000001)\n\ndef get_lr(b,d):\n    l = r = 0\n    while r < len(b):\n        while b[l] + d < b[r]:\n            l += 1\n        for r in range(r,len(b)):\n            if b[l] + d < b[r]:\n                r -= 1\n                break\n        r += 1\n        yield l,r\n        l += 1\n    \n#max_size = max((xmax.q(l,r) - xmin.q(l,r)) * (ymax.q(l,r) - ymin.q(l,r)) for l,r in get_lr(b,d))\nsize = []\nfor l,r in get_lr(b,d):\n    index = xmax.get_index2(l,r)\n    size.append((xmax.q2(index) - xmin.q2(index)) * (ymax.q2(index) - ymin.q2(index)))\nprint(max(size))"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = []\nminlight = -1\nwhile(len(a)>1):\n    if a[0] == minlight:\n        del a[0]\n    else :\n        k=0\n        x=[]\n        y=[]\n        while(a[k][2]<=a[0][2] + lightrange):\n            x.append(a[k][0])\n            y.append(a[k][1])\n            k+=1\n            if(k==len(a)):\n                break\n        scale.append((max(x)-min(x))*(max(y)-min(y)))\n        minlight = a[0][2]\n        del a[0]\n    if len(a)==1:\n        break\nprint max(scale)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom math import ceil, log2\nimport gc\n\n\nclass SegmentTree:\n    n2 = 0\n\n    def __init__(self, n, bounds, is_min):\n        func = min if is_min else max\n        sentinel = min_sentinel if is_min else max_sentinel\n\n        n2 = 2 ** ceil(log2(n))\n        tree = [sentinel] * (n2 - 1) + bounds + [sentinel] * (n2 - n)\n        for i in range(n2 - 2, -1, -1):\n            tree[i] = func(tree[i * 2 + 1], tree[i * 2 + 2])\n        SegmentTree.n2 = n2\n        self.tree = tree\n        self.func = func\n        self.sentinel = sentinel\n\n    @classmethod\n    def get_indexes(cls, s, t):\n        n2 = cls.n2\n        si, ti = s + n2 - 1, t + n2 - 1\n        i_set = set()\n        while si < ti:\n            if not si & 1:\n                i_set.add(si)\n                si += 1\n            if ti & 1:\n                i_set.add(ti)\n                ti -= 1\n            si = (si - 1) // 2\n            ti = (ti - 1) // 2\n        if si == ti:\n            i_set.add(si)\n\n        return i_set\n\n    def get(self, index_set):\n        return self.func(self.tree[i] for i in index_set)\n\n\nn, d = map(int, input().split())\ninput_store = defaultdict(lambda: (set(), set()))\n\nwhile n:\n    x, y, b = map(int, input().split())\n    x_set, y_set = input_store[b]\n    x_set.add(x)\n    y_set.add(y)\n    n -= 1\n\nmin_sentinel, max_sentinel = 2000001, -1\n\nmax_b = max(input_store)\nlist_length = max_b + 1\nstars_min_x = [min_sentinel] * (list_length)\nstars_min_y = [min_sentinel] * (list_length)\nstars_max_x = [max_sentinel] * (list_length)\nstars_max_y = [max_sentinel] * (list_length)\nfor b, xy_set in input_store.items():\n    x_set, y_set = xy_set\n    stars_min_x[b] = min(x_set)\n    stars_min_y[b] = min(y_set)\n    stars_max_x[b] = max(x_set)\n    stars_max_y[b] = max(y_set)\n\nst_min_x = SegmentTree(list_length, stars_min_x, True)\ndel stars_min_x\nst_min_y = SegmentTree(list_length, stars_min_y, True)\ndel stars_min_y\nst_max_x = SegmentTree(list_length, stars_max_x, False)\ndel stars_max_x\nst_max_y = SegmentTree(list_length, stars_max_y, False)\ndel stars_max_y\ngc.collect()\n\nmax_area = 0\n\nfor i in input_store:\n    if i + d > max_b:\n        break\n\n    i_set = SegmentTree.get_indexes(i, i + d)\n    min_x = st_min_x.get(i_set)\n    if min_x == min_sentinel:\n        continue\n    current_area = (st_max_x.get(i_set) - min_x) * (st_max_y.get(i_set) - st_min_y.get(i_set))\n    if max_area < current_area:\n        max_area = current_area\n\nprint(max_area)"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\nwhile(len(a)>1):\n    minx=maxx=a[0][0]\n    miny=maxy=a[0][1]\n    k=1\n    while(a[k][2]<=a[0][2] + lightrange):\n        if (a[k][0]<minx or a[k][0]>maxx or a[k][1]<miny or a[k][1]>maxy):\n            minx = min(minx,a[k][0])\n            maxx = max(maxx,a[k][0])\n            miny = min(miny,a[k][1])\n            maxy = max(maxy,a[k][1])\n        k+=1\n    area = (maxx-minx)*(maxy-miny)\n    scale = max(scale,area)\n    del a[0]\nprint scale"
  },
  {
    "language": "Python",
    "code": "def main():\n  INF = 10 ** 20\n\n  class MinTree:\n    def __init__(self, iterable):\n      self.iter_size = self.get_size(iterable)\n      self.size = self.iter_size * 2 - 1\n      self.value = [None] * self.size\n      for i, v in enumerate(iterable):\n        self.value[self.iter_size + i - 1] = v\n      self.set_value(0)\n      self.range = [None] * self.size\n      self.set_range(0, 0, self.iter_size - 1)\n \n    \n    def get_size(self, iterable):\n      ret = 1\n      x = len(iterable)\n      while ret < x:\n        ret *= 2\n      return ret\n\n    def set_range(self, x, left, right):\n      self.range[x] = (left, right)\n      if left != right:\n        self.set_range(x * 2 + 1, left, (right + left) // 2)\n        self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n    def set_value(self, x):\n      if x >= self.iter_size - 1:return self.value[x]\n      a = self.set_value(x * 2 + 1)\n      b = self.set_value(x * 2 + 2)\n      if a == None and b == None:\n        self.value[x] = None\n      elif a == None:\n        self.value[x] = b\n      elif b == None:\n        self.value[x] = a\n      else:\n        self.value[x] = a if a < b else b\n      return self.value[x]\n  \n    def query(self, x, left, right):\n      x_left, x_right = self.range[x]\n      if right < x_left or x_right < left:\n        return INF\n      if left <= x_left and x_right <= right:\n        return self.value[x]\n  \n      return min(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n  \n  \n  class MaxTree:\n    def __init__(self, iterable):\n      self.iter_size = self.get_size(iterable)\n      self.size = self.iter_size * 2 - 1\n      self.value = [None] * self.size\n      for i, v in enumerate(iterable):\n        self.value[self.iter_size + i - 1] = v\n      self.set_value(0)\n      self.range = [None] * self.size\n      self.set_range(0, 0, self.iter_size - 1)\n    \n    def get_size(self, iterable):\n      ret = 1\n      x = len(iterable)\n      while ret < x:\n        ret *= 2\n      return ret\n    \n    def set_range(self, x, left, right):\n      self.range[x] = (left, right)\n      if left != right:\n        self.set_range(x * 2 + 1, left, (right + left) // 2)\n        self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n\n    def set_value(self, x):\n      if x >= self.iter_size - 1:return self.value[x]\n      a = self.set_value(x * 2 + 1)\n      b = self.set_value(x * 2 + 2)\n      if a == None and b == None:\n        self.value[x] = None\n      elif a == None:\n        self.value[x] = b\n      elif b == None:\n        self.value[x] = a\n      else:\n        self.value[x] = a if a > b else b\n      return self.value[x]\n  \n    def query(self, x, left, right):\n      x_left, x_right = self.range[x]\n      if right < x_left or x_right < left:\n        return 0\n      if left <= x_left and x_right <= right:\n        return self.value[x]\n  \n      return max(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n  \n  from bisect import bisect_right as br\n\n  n, d = map(int, input().split())\n  lst = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x:x[2])\n  sorted_x = []\n  sorted_y = []\n  keys = []\n  for i in range(n):\n    x, y, b = lst[i]\n    sorted_x.append(x)\n    sorted_y.append(y)\n    keys.append(b)\n  mxt = MinTree(sorted_x)\n  Mxt = MaxTree(sorted_x)\n  myt = MinTree(sorted_y)\n  Myt = MaxTree(sorted_y)\n  \n  def score(left, right):\n    return (Mxt.query(0, left, right) - mxt.query(0, left, right)) * \\\n           (Myt.query(0, left, right) - myt.query(0, left, right))\n  \n  left = 0\n  right = br(keys, keys[0] + d) - 1\n  mx = mxt.query(0, left, right)\n  Mx = Mxt.query(0, left, right)\n  my = myt.query(0, left, right)\n  My = Myt.query(0, left, right)\n  end = len(keys)\n  ans = (Mx - mx) * (My - my)\n  while True:\n    right += 1\n    if right == end:break\n    \n    if sorted_x[right] > Mx:Mx = sorted_x[right]\n    if sorted_x[right] < mx:mx = sorted_x[right] \n    if sorted_y[right] > My:My = sorted_y[right]\n    if sorted_y[right] < my:my = sorted_y[right]\n    \n    Mx_flag = mx_flag = My_flag = my_flag = False\n    while keys[left] + d <= keys[right]:\n      if sorted_x[left] == Mx:Mx_flag = True\n      if sorted_x[left] == mx:mx_flag = True\n      if sorted_y[left] == My:My_flag = True\n      if sorted_y[left] == my:my_flag = True\n      left += 1\n    left -= 1\n    \n    if Mx_flag:Mx = Mxt.query(0, left, right)\n    if mx_flag:mx = mxt.query(0, left, right)\n    if My_flag:My = Myt.query(0, left, right)\n    if my_flag:my = myt.query(0, left, right)\n    \n    ans = max(ans, (Mx - mx) * (My - my)) \n  \n  print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\nwhile(len(a)>1):\n    minx=maxx=a[0][0]\n    miny=maxy=a[0][1]\n    l=1\n    while (a[l][2] <= a[0][2] + lightrange):\n        if(a[l][0]<minx):\n            minx=a[l][0]\n        if(a[l][0]>maxx):\n            maxx=a[l][0]\n        if(a[l][1]<miny):\n            miny=a[l][1]\n        if(a[l][1]>maxy):\n            maxy=a[l][1]\n        l+=1\n    area = (maxx-minx)*(maxy-miny)\n    if (area > scale):\n        scale = area\n    del a[0]\nprint scale"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\nfrom itertools import takewhile\nfrom random import randint\nfrom array import array\n\ndef make_data(n):\n  return [str(randint(0,2000000))+' '+str(randint(0,2000000))+' '+str(randint(0,1e9))\n      for i in range(n)]\n\ndef get_square(x_min,x_max,y_min,y_max):\n  return (x_max - x_min) * (y_max - y_min)\n\nN,d = map(int,input().split())\n#L = [tuple(map(int,i.split())) for i in stdin.readlines()]\nL = [tuple(map(int,i.split())) for i in make_data(N)]\nB = sorted(set([i[2] for i in L]))\nD = {i:[] for i in B}\n[D[i[2]].append((i[0],i[1])) for i in L]\nfor k,v in D.items():\n  i = tuple(zip(*v))\n  D[k] = array('L',(min(i[0]),max(i[0]),min(i[1]),max(i[1])))\nprint('test1')\nMax = B[-1]\nresult = 0\n\nfor i in range(len(B)):\n  b = B[i] + d\n  L2 = (D[j] for j in \n      takewhile(\n        lambda x: x <= b, \n        (B[n] for n in range(i,len(B)))\n        ))\n  L3 = tuple(zip(*L2))\n  s = get_square(min(L3[0]),max(L3[1]),min(L3[2]),max(L3[3]))\n  #s = (max(L3[1]) - min(L3[0])) * (max(L3[3]) - min(L3[2]))\n  if result < s:result = s\n  if b > Max:break\nprint(result)"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\nfor j in range(len(a)):\n    astars = []\n    for k in range(len(a)):\n        while(len(astars)<=2):\n            if (a[k][2] <= a[0][2] + lightrange):\n                astars.append(a[k])\n                twostars = k\n    maxx = max(astars[0][0],astars[1][0])\n    minx = min(astars[0][0],astars[1][0])\n    maxy = max(astars[0][1],astars[1][1])\n    miny = min(astars[0][1],astars[1][1])\n    for l in range(len(a)):\n        if (a[l][2] <= a[0][2] + lightrange and (a[l][0]<minx or a[l][0]>maxx or a[l][1]<miny or a[l][1]>maxy)):\n            if(a[l][0]<minx):\n                minx=a[l][0]\n            if(a[l][0]>maxx):\n                maxx=a[l][0]\n            if(a[l][1]<miny):\n                miny=a[l][1]\n            if(a[l][0]>maxy):\n                maxy=a[l][1]\n    area = (maxx-minx)*(maxy-miny)\n    if (area > scale):\n        scale = area\n    del a[0]\n    if len(a) < 2:\n        break;\n\nprint scale"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_right as br\nclass Node:\n  def __init__(self, val, sec):\n    self.val = val\n    self.sec = sec\n    self.left = sec[0]\n    self.right = sec[1]\n    self.minx = val[0]\n    self.maxx = val[1]\n    self.miny = val[2]\n    self.maxy = val[3]\n\nclass SegTree:\n  def __init__(self, num, lst):\n    num_ = 1\n    while num_ < num:\n      num_ *= 2\n    self.length = num_ * 2 - 1\n    self.arr = [None] * (num_ * 2 - 1)\n    for i in range(num):\n      self.arr[num_ - 1 + i] = Node(lst[i], (i, i))\n\n    self.make(0)\n\n  def make(self, num):\n    if num >= self.length:\n      return None\n    if self.arr[num] != None:\n      return self.arr[num]\n    else:\n      self.arr[num] = self.con(self.make(num * 2 + 1), self.make(num * 2 + 2))\n      return self.arr[num]\n  \n  def con(self, n1, n2):\n    if n1 != None and n2 != None:\n      return Node((min(n1.minx, n2.minx), max(n1.maxx, n2.maxx), min(n1.miny, n2.miny), max(n1.maxy, n2.maxy)),\n                  (n1.left, n2.right))\n    if n1 != None:\n      return n1\n    if n2 != None:\n      return n2\n    return None\n\n  def query(self, l, r, num):\n    node = self.arr[num]\n    if node == None:\n      return None\n    if l <= node.left and node.right <= r:\n      return node\n    elif r < node.left or node.right < l:\n      return None\n    else:\n      return self.con(self.query(l, r, num * 2 + 1), self.query(l, r, num * 2 + 2))\n\ndef main():\n  n, d = map(int, input().split())\n  stars = []\n  blst = []\n  for _ in range(n):\n    x, y, b = map(int, input().split())\n    stars.append((x, y, b))\n    blst.append(b)\n  blst.sort()\n  stars.sort(key=lambda t:t[2])\n  stars = [(x, x, y, y) for x, y, _ in stars]\n\n  tree = SegTree(n, stars)\n  ans = 0\n  for l in range(n):\n    r = br(blst, blst[l] + d)\n    if r == n:\n      r -= 1\n    elif blst[r] != blst[l] + d:\n      r -= 1\n    a = tree.query(l, r, 0).val\n    ans = max((a[1] - a[0]) * (a[3] - a[2]), ans)\n  print(ans)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef segmentTree(dat, f, sentinel):\n        pad = 2 ** math.ceil(math.log(len(dat),2))\n        dat = [None] * pad + dat + [sentinel] * (pad - len(dat))\n        for i in range(pad - 1, 0, -1):\n            dat[i] = f(dat[i * 2:i * 2 + 2])\n        return dat\n\nimport sys\nf = sys.stdin\n\n_, d = map(int, f.readline().split())\n\nx,y = {},{}\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    if bi not in x:\n        x[bi],y[bi] = [],[]\n    x[bi].append(xi)\n    y[bi].append(yi)\n\nb = sorted(x.keys())\n\nxmax = segmentTree([max(x[bi]) for bi in b],max,sentinel = -1)\nxmin = segmentTree([min(x[bi]) for bi in b],min,sentinel = 2000001)\nymax = segmentTree([max(y[bi]) for bi in b],max,sentinel = -1)\nymin = segmentTree([min(y[bi]) for bi in b],min,sentinel = 2000001)\n\ndef get_lr(b,d):\n    l = r = 0\n    while r < len(b):\n        while b[l] + d < b[r]:\n            l += 1\n        for r in range(r,len(b)):\n            if b[l] + d < b[r]:\n                r -= 1\n                break\n        r += 1\n        yield l,r\n        l += 1\n    \nsize = []\npad = len(xmax) // 2\nfor l,r in get_lr(b,d):\n    # 参照するsegmentのindexを生成　※速度のためインライン展開\n    l += pad \n    r += pad\n    index = []\n    while l < r:\n        if r & 1:\n            r -= 1\n            index.append(r)\n        if l & 1:\n            index.append(l)\n            l += 1\n        l >>= 1\n        r >>= 1\n\n    size.append((max(xmax[i] for i in index)\n                 - min(xmin[i] for i in index))\n                * (max(ymax[i] for i in index)\n                   - min(ymin[i] for i in index)))\nprint(max(size))"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_right as br\n\ndef make(arr, length, num):\n  if num >= length:\n    return None\n  if arr[num] != None:\n    return arr[num]\n  else:\n    arr[num] = con(make(arr, length, num * 2 + 1), make(arr, length, num * 2 + 2))\n    return arr[num]\n  \ndef con(n1, n2):\n  if n1 != None and n2 != None:\n    r0, r1, r2, r3 = get_min(n1[:4], n2[:4])\n    return (r0, r1, r2, r3, n1[4], n2[5])\n  if n1 != None:\n    return n1\n  if n2 != None:\n    return n2\n  return None\n\ndef query(arr, l, r, num):\n  node = arr[num]\n  if node == None:\n    return None\n  ln, rn = node[4], node[5]\n  if l <= ln and rn <= r:\n    return node[:4]\n  elif r < ln or rn < l:\n    return None\n  else:\n    x1 = query(arr, l, r, num * 2 + 1)\n    x2 = query(arr, l, r, num * 2 + 2)\n    if x1 == None and x2 == None:\n      return None\n    if x1 == None:\n      return x2\n    if x2 == None:\n      return x1\n    return get_min(x1, x2)\n  \ndef get_min(t1, t2):\n  t10, t11, t12, t13 = t1\n  t20, t21, t22, t23 = t2\n  if t10 < t20:\n    r0 = t10\n  else:\n    r0 = t20\n  if t11 < t21:\n    r1 = t21\n  else:\n    r1 = t11\n  if t12 < t22:\n    r2 = t12\n  else:\n    r2 = t22\n  if t13 < t23:\n    r3 = t23\n  else:\n    r3 = t13\n  return (r0, r1, r2, r3)\n\n\n\n\ndef main():\n  n, d = map(int, input().split())\n  stars = []\n  blst = []\n  for _ in range(n):\n    x, y, b = map(int, input().split())\n    stars.append((b, x, y))\n    blst.append(b)\n  blst.sort()\n  stars.sort()\n  \n  length = 1\n  while length < n:\n    length *= 2\n  arr = [None] * (length * 2 - 1)\n  for i, star in enumerate(stars):\n    x = star[1]\n    y = star[2]\n    arr[length - 1 + i] = (x, x, y, y, i, i)\n  make(arr, length * 2 - 1, 0)\n\n  ans = 0\n  min_l = -1\n  max_r = 0\n  for l in range(n):\n    if min_l == l:\n      continue\n    min_l = l\n    r = br(blst, blst[l] + d)\n    if r == n:\n      r -= 1\n    elif blst[r] != blst[l] + d:\n      r -= 1\n    if r > max_r:\n      a = query(arr, l, r, 0)\n      score = (a[1] - a[0]) * (a[3] - a[2])\n      if score > ans:\n        ans = score\n      max_r = r\n  print(ans)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "N,d = map(int,input().split())\nL = [list(map(int,input().split())) for i in range(N)]\nL = sorted(L,key=lambda x:x[2])\n\ndef get_square(L):\n  if not L or len(L) == 0:return 0\n  x=[L[0][0],L[0][0]]\n  y=[L[0][1],L[0][1]]\n  for i in L:\n    if i[0] < x[0]:x[0] = i[0]\n    if i[0] > x[1]:x[1] = i[0]\n    if i[1] < y[0]:y[0] = i[1]\n    if i[1] > y[1]:y[1] = i[1]\n  return (x[1] - x[0]) * (y[1] - y[0])\n\nresult = 0\ni = L[0][2]\nj = L[-1][2]\nwhile True:\n  n = i + d\n  l = []\n  while i <= n:\n    l += [x[0:2] for x in L if x[2] == i]\n    i += 1\n  s = get_square(l)\n  if result < s:result = s\n  i -= d\n  if j < i + d:break\nprint(result)"
  },
  {
    "language": "Python",
    "code": "import math\ndef segmentTree(dat, f, sentinel):\n        pad = 2 ** math.ceil(math.log(len(dat),2))\n        dat = [0] * pad + dat + [sentinel] * (pad - len(dat))\n        for i in range(pad - 1, 0, -1):\n            dat[i] = f(dat[i * 2:i * 2 + 2])\n        return dat\n\ndef get_lr(b,d):\n    l = r = 0\n    while r < len(b):\n        while b[l] + d < b[r]:\n            l += 1\n        for r in range(r,len(b)):\n            if b[l] + d < b[r]:\n                r -= 1\n                break\n        r += 1\n        yield l,r\n        l += 1\n    \nimport sys\nf = sys.stdin\n\n_, d = map(int, f.readline().split())\n\nxyb = []\nfor line in f:\n    xyb.append(tuple(map(int, line.split())))\nfrom operator import itemgetter\nxyb.sort(key=itemgetter(2))\n\nx = [xybi[0] for xybi in xyb]\ny = [xybi[1] for xybi in xyb]\nb = [xybi[2] for xybi in xyb]\n\nxmax = segmentTree(x,max,sentinel = 0)\nxmin = segmentTree(x,min,sentinel = 2000000)\nymax = segmentTree(y,max,sentinel = 0)\nymin = segmentTree(y,min,sentinel = 2000000)\n\n\nsize = []\nsa = size.append #万単位で呼び出す場合は若干早くなる\npad = len(xmax) // 2\nfor l,r in get_lr(b,d):\n    # 参照するsegmentのindexを生成　※速度のためインライン展開\n    l += pad \n    r += pad\n    index = []\n    ia = index.append\n    while l < r:\n        if r & 1:\n            r -= 1\n            ia(r)\n        if l & 1:\n            ia(l)\n            l += 1\n        l >>= 1\n        r >>= 1\n\n    sa((max(xmax[i] for i in index)\n                 - min(xmin[i] for i in index))\n                * (max(ymax[i] for i in index)\n                   - min(ymin[i] for i in index)))\nprint(max(size))"
  },
  {
    "language": "Python",
    "code": "answer=[]\ninfo = list(map(int,raw_input().split()))\nall_list=[] # This list include information of all stars.\nfor i in range (info[0]):\n\tall_list.append(list(map(int,raw_input().split())))\ndark_star=min(all_list, key=lambda x: x[2])[2]\nbright_star=max(all_list, key=lambda x:x[2])[2]\n\nfor i in range (dark_star,bright_star+1):\n\tli_xyd=[]\n\tli_x=[]\n\tli_y=[]\n\tfor j in range (i,i+info[1]+1):\n\t\tadd_list=list(filter(lambda x:x[2]==j,all_list))\n\t\tif add_list != []:\n\t\t\tli_xyd+=add_list[:]\n\t\telse:\n\t\t\tpass\n\tfor j in li_xyd:\n\t\tli_x.append(j[0])\n\t\tli_y.append(j[1])\n\tif li_x==[]:\n\t\tli_x=[0]\n\tif li_y==[]:\n\t\tli_y=[0]\n\tnum = (max(li_x)-min(li_x))*(max(li_y)-min(li_y))\n\tanswer.append(num)\nprint(max(answer))\n\t\t\n\t"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\nfor j in range(len(a)):\n    minlight = a[0][2]\n    astars = []\n    for k in range(len(a)):\n        if (a[k][2] >= minlight and a[k][2] <= minlight + lightrange):\n            astars.append(a[k])\n    astarsx = [astars[l][0] for l in range(len(astars))]\n    astarsy = [astars[m][1] for m in range(len(astars))]\n    p = max(astarsx)\n    q = min(astarsx)\n    r = max(astarsy)\n    s = min(astarsy)\n    pqrs = (p - q) * (r - s)\n    if (pqrs > scale):\n        scale = pqrs\n    del a[0]\n    if len(a) < 4:\n        break;\n\nprint scale"
  },
  {
    "language": "Python",
    "code": "def main():\n  INF = 10 ** 20\n\n  class MinTree:\n    def __init__(self, iterable):\n      self.iter_size = self.get_size(iterable)\n      self.size = self.iter_size * 2 - 1\n      self.value = [None] * self.size\n      for i, v in enumerate(iterable):\n        self.value[self.iter_size + i - 1] = v\n      self.set_value(0)\n    \n    def get_size(self, iterable):\n      ret = 1\n      x = len(iterable)\n      while ret < x:\n        ret *= 2\n      return ret\n\n    def set_range(self, x, left, right):\n      self.range[x] = (left, right)\n      if left != right:\n        self.set_range(x * 2 + 1, left, (right + left) // 2)\n        self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n    def set_value(self, x):\n      if x >= self.iter_size - 1:return self.value[x]\n      a = self.set_value(x * 2 + 1)\n      b = self.set_value(x * 2 + 2)\n      if a == None and b == None:\n        self.value[x] = None\n      elif a == None:\n        self.value[x] = b\n      elif b == None:\n        self.value[x] = a\n      else:\n        self.value[x] = a if a < b else b\n      return self.value[x]\n  \n    def query(self, x, left, right):\n      x_left, x_right = self.range[x]\n      if right < x_left or x_right < left:\n        return INF\n      if left <= x_left and x_right <= right:\n        return self.value[x]\n      a = self.query(x * 2 + 1, left, right)\n      b = self.query(x * 2 + 2, left, right)\n      return a if a <= b else b\n \n  class MaxTree:\n    def __init__(self, iterable):\n      self.iter_size = self.get_size(iterable)\n      self.size = self.iter_size * 2 - 1\n      self.value = [None] * self.size\n      for i, v in enumerate(iterable):\n        self.value[self.iter_size + i - 1] = v\n      self.set_value(0)\n    \n    def get_size(self, iterable):\n      ret = 1\n      x = len(iterable)\n      while ret < x:\n        ret *= 2\n      return ret\n    \n    def set_range(self, x, left, right):\n      self.range[x] = (left, right)\n      if left != right:\n        self.set_range(x * 2 + 1, left, (right + left) // 2)\n        self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n    def set_value(self, x):\n      if x >= self.iter_size - 1:return self.value[x]\n      a = self.set_value(x * 2 + 1)\n      b = self.set_value(x * 2 + 2)\n      if a == None and b == None:\n        self.value[x] = None\n      elif a == None:\n        self.value[x] = b\n      elif b == None:\n        self.value[x] = a\n      else:\n        self.value[x] = a if a > b else b\n      return self.value[x]\n  \n    def query(self, x, left, right):\n      x_left, x_right = self.range[x]\n      if right < x_left or x_right < left:\n        return 0\n      if left <= x_left and x_right <= right:\n        return self.value[x]\n      a = self.query(x * 2 + 1, left, right)\n      b = self.query(x * 2 + 2, left, right)\n      return a if a >= b else b\n\n  \n  def set_range(lst, x, left, right):\n    lst[x] = (left, right)\n    if left != right:\n      set_range(lst, x * 2 + 1, left, (right + left) // 2)\n      set_range(lst, x * 2 + 2, (right + left) // 2 + 1, right)\n\n  def index_of_query(lst, x, left, right, ret):\n    x_left, x_right = lst[x]\n    if right < x_left or x_right < left:pass\n    elif left <= x_left and x_right <= right:\n      ret.append(x)\n    else:\n      index_of_query(lst, x * 2 + 1, left, right, ret)\n      index_of_query(lst, x * 2 + 2, left, right, ret)\n\n\n\n  from bisect import bisect_right as br\n\n  n, d = map(int, input().split())\n  lst = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x:x[2])\n  sorted_x = []\n  sorted_y = []\n  keys = []\n  for i in range(n):\n    x, y, b = lst[i]\n    sorted_x.append(x)\n    sorted_y.append(y)\n    keys.append(b)\n  mxt = MinTree(sorted_x)\n  Mxt = MaxTree(sorted_x)\n  myt = MinTree(sorted_y)\n  Myt = MaxTree(sorted_y)\n  lst = [None] * mxt.size\n  set_range(lst, 0, 0, mxt.iter_size - 1)\n  mxt.range = lst\n  Mxt.range = lst\n  myt.range = lst\n  Myt.range = lst\n  \n  def score(left, right):\n    return (Mxt.query(0, left, right) - mxt.query(0, left, right)) * \\\n           (Myt.query(0, left, right) - myt.query(0, left, right))\n  \n  left = 0\n  right = br(keys, keys[0] + d) - 1\n  mx = mxt.query(0, left, right)\n  Mx = Mxt.query(0, left, right)\n  my = myt.query(0, left, right)\n  My = Myt.query(0, left, right)\n  end = len(keys)\n  ans = (Mx - mx) * (My - my)\n  Mx_flag = mx_flag = My_flag = my_flag = False\n  while True:\n    right += 1\n    if right == end:break\n    \n    if sorted_x[right] > Mx:Mx = sorted_x[right]\n    if sorted_x[right] < mx:mx = sorted_x[right] \n    if sorted_y[right] > My:My = sorted_y[right]\n    if sorted_y[right] < my:my = sorted_y[right]\n    \n    while keys[left] + d < keys[right]:\n      if sorted_x[left] == Mx:Mx_flag = True\n      if sorted_x[left] == mx:mx_flag = True\n      if sorted_y[left] == My:My_flag = True\n      if sorted_y[left] == my:my_flag = True\n      left += 1\n    \n    ret = []\n    index_of_query(lst, 0, left, right, ret)\n    if Mx_flag:\n      #Mx = Mxt.query(0, left, right)\n      Mx = max(Mxt.value[i] for i in ret)\n      Mx_flag = False\n    if mx_flag:\n      #mx = mxt.query(0, left, right)\n      mx = min(mxt.value[i] for i in ret)\n      mx_flag = False\n    if My_flag:\n      #My = Myt.query(0, left, right)\n      My = max(Myt.value[i] for i in ret)\n      My_flag = False\n    if my_flag:\n      my = myt.query(0, left, right)\n      my = min(myt.value[i] for i in ret)\n      my_flag = False\n    \n    ans = max(ans, (Mx - mx) * (My - my)) \n  \n  print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left as bl\n\nclass Node:\n  def __init__(self, val, sec):\n    self.val = val\n    self.sec = sec\n    self.left = sec[0]\n    self.right = sec[1]\n    self.minx = val[0]\n    self.maxx = val[1]\n    self.miny = val[2]\n    self.maxy = val[3]\n\nclass SegTree:\n  def __init__(self, num, lst):\n    num_ = 1\n    while num_ < num:\n      num_ *= 2\n    self.length = num_ * 2 - 1\n    self.arr = [None] * (num_ * 2 - 1)\n    for i in range(num):\n      self.arr[num_ - 1 + i] = Node(lst[i], (i, i))\n\n    self.make(0)\n\n  def make(self, num):\n    if num >= self.length:\n      return None\n    if self.arr[num] != None:\n      return self.arr[num]\n    else:\n      self.arr[num] = self.con(self.make(num * 2 + 1), self.make(num * 2 + 2))\n      return self.arr[num]\n  \n  def con(self, n1, n2):\n    if n1 != None and n2 != None:\n      return Node((min(n1.minx, n2.minx), max(n1.maxx, n2.maxx), min(n1.miny, n2.miny), max(n1.maxy, n2.maxy)),\n                  (n1.left, n2.right))\n    if n1 != None:\n      return n1\n    if n2 != None:\n      return n2\n    return None\n\n  def query(self, l, r, num):\n    node = self.arr[num]\n    if l <= node.left and node.right <= r:\n      return node\n    elif r < node.left or node.right < l:\n      return None\n    else:\n      return self.con(self.query(l, r, num * 2 + 1), self.query(l, r, num * 2 + 2))\n\ndef main():\n  n, d = map(int, input().split())\n  stars = []\n  blst = []\n  for _ in range(n):\n    x, y, b = map(int, input().split())\n    stars.append((x, y, b))\n    blst.append(b)\n  blst.sort()\n  stars.sort(key=lambda t:t[2])\n  stars = [(x, x, y, y) for x, y, _ in stars]\n\n  tree = SegTree(n, stars)\n  ans = 0\n  for l in range(n):\n    r = bl(blst, blst[l] + d)\n    if r >= n:\n      r -= 1\n    a = tree.query(l, r, 0).val\n    ans = max((a[1] - a[0]) * (a[3] - a[2]), ans)\n  print(ans)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom math import ceil, log2\n\n\nclass SegmentTree:\n    n2 = 0\n\n    def __init__(self, n, bounds, is_min):\n        func = min if is_min else max\n        sentinel = min_sentinel if is_min else max_sentinel\n\n        n2 = 2 ** ceil(log2(n))\n        tree = [sentinel] * (n2 - 1) + bounds + [sentinel] * (n2 - n)\n        for i in range(n2 - 2, -1, -1):\n            tree[i] = func(tree[i * 2 + 1], tree[i * 2 + 2])\n        SegmentTree.n2 = n2\n        self.tree = tree\n        self.func = func\n        self.sentinel = sentinel\n\n    @classmethod\n    def get_indexes(cls, s, t):\n        n2 = cls.n2\n        si, ti = s + n2 - 1, t + n2 - 1\n        i_set = set()\n        while si < ti:\n            if not si & 1:\n                i_set.add(si)\n                si += 1\n            if ti & 1:\n                i_set.add(ti)\n                ti -= 1\n            si = (si - 1) // 2\n            ti = (ti - 1) // 2\n        if si == ti:\n            i_set.add(si)\n\n        return i_set\n\n    def get(self, index_set):\n        return self.func(self.tree[i] for i in index_set)\n\n\nn, d = map(int, input().split())\ninput_store = defaultdict(lambda: (set(), set()))\n\nwhile n:\n    x, y, b = map(int, input().split())\n    x_set, y_set = input_store[b]\n    x_set.add(x)\n    y_set.add(y)\n    n -= 1\n\nmin_sentinel, max_sentinel = 2000001, -1\n\nmax_b = max(input_store)\nlist_length = max_b + 1\nstars_min_x = [min_sentinel] * (list_length)\nstars_min_y = [min_sentinel] * (list_length)\nstars_max_x = [max_sentinel] * (list_length)\nstars_max_y = [max_sentinel] * (list_length)\nfor b, xy_set in input_store.items():\n    x_set, y_set = xy_set\n    stars_min_x[b] = min(x_set)\n    stars_min_y[b] = min(y_set)\n    stars_max_x[b] = max(x_set)\n    stars_max_y[b] = max(y_set)\n\nst_min_x = SegmentTree(list_length, stars_min_x, True)\nst_min_y = SegmentTree(list_length, stars_min_y, True)\nst_max_x = SegmentTree(list_length, stars_max_x, False)\nst_max_y = SegmentTree(list_length, stars_max_y, False)\n\nmax_area = 0\n\nfor i in input_store:\n    if i + d > max_b:\n        break\n\n    i_set = SegmentTree.get_indexes(i, i + d)\n    min_x = st_min_x.get(i_set)\n    if min_x == min_sentinel:\n        continue\n    current_area = (st_max_x.get(i_set) - min_x) * (st_max_y.get(i_set) - st_min_y.get(i_set))\n    if max_area < current_area:\n        max_area = current_area\n\nprint(max_area)"
  },
  {
    "language": "Python",
    "code": "n, d = map(int, input().split())\nud, od = d // 2, (d + 1) // 2\nstars = dict()\n\nfor _ in range(n):\n    x, y, b = map(int, input().split())\n    xys = stars.setdefault(b, [x, x, y, y])\n    if xys[0] < x: xys[0] = x\n    if xys[1] > x: xys[1] = x\n    if xys[2] < y: xys[2] = y\n    if xys[3] > y: xys[3] = y\n\nkeys = set(stars.keys())\nmin_b, max_b = min(keys) + ud, max(keys) - od\nmax_stella = 0\n\nfor b in range(min_b, max_b + 1):\n    bbs = keys.intersection(range(b - ud, b + od + 1))\n    if not bbs: continue\n    max_x, min_x, max_y, min_y = 0, 200001, 0, 200001\n    for bb in bbs:\n        xys = stars[bb]\n        if max_x < xys[0]: max_x = xys[0]\n        if min_x > xys[1]: min_x = xys[1]\n        if max_y < xys[2]: max_y = xys[2]\n        if min_y > xys[3]: min_y = xys[3]\n    else:\n        stella = (max_x - min_x) * (max_y - min_y)\n        if max_stella < stella: max_stella = stella\n\nprint(max_stella)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\nfrom itertools import takewhile\nfrom random import randint\n\ndef make_data(n):\n  return [str(randint(0,2000000))+' '+str(randint(0,2000000))+' '+str(randint(0,1e9))\n      for i in range(n)]\n\ndef get_square(x_min,x_max,y_min,y_max):\n  return (x_max - x_min) * (y_max - y_min)\n\nN,d = map(int,input().split())\nL = [tuple(map(int,i.split())) for i in stdin.readlines()]\n#L = [tuple(map(int,i.split())) for i in make_data(N)]\nB = sorted(set([i[2] for i in L]))\nD = {i:[] for i in B}\n[D[i[2]].append((i[0],i[1])) for i in L]\nfor k,v in D.items():\n  i = tuple(zip(*v))\n  D[k] = (min(i[0]),max(i[0]),min(i[1]),max(i[1]))\n\nMax = B[-1]\nresult = 0\n\ni = 0\nwhile i < len(B):\n  b = B[i] + d\n  L2 = (D[j] for j in \n      takewhile(\n        lambda x: x <= b, \n        (B[n] for n in range(i,len(B)))\n        ))\n  L3 = tuple(zip(*L2))\n  s = get_square(min(L3[0]),max(L3[1]),min(L3[2]),max(L3[3]))\n  if result < s:result = s\n  if B[i]+d > Max:break\n  i += 1\nprint(result)"
  },
  {
    "language": "Python",
    "code": "import sys\nf = sys.stdin\n\ndef mix(a,b):\n    return (min(a[0],b[0]),min(a[1],b[1]),max(a[2],b[2]),max(a[3],b[3]))\n\ns = {}\n\nn, d = map(int, f.readline().split())\nfor _ in range(n):\n    x, y, b = map(int, f.readline().split())\n    s[b] = mix(s[b],(x,y,x,y)) if b in s else (x,y,x,y)\n\nmax_size = 0\nb = sorted(s.keys())\nfor i in range(len(b)):\n    xy = s[b[i]]\n    for j in range(i + 1,len(b)):\n        if b[i] + d < b[j]:\n            break\n        xy = mix(xy,s[b[j]])\n    max_size = max(max_size,((xy[2] - xy[0]) * (xy[3] - xy[1])))\nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "from functools import reduce\n\n\nclass Bound:\n    min_x = 2000001\n    min_y = 2000001\n    max_x = -1\n    max_y = -1\n\n    def add(self, x, y):\n        if self.min_x > x: self.min_x = x\n        if self.min_y > y: self.min_y = y\n        if self.max_x < x: self.max_x = x\n        if self.max_y < y: self.max_y = y\n\n    def expand(self, bound):\n        if self.min_x > bound.min_x: self.min_x = bound.min_x\n        if self.min_y > bound.min_y: self.min_y = bound.min_y\n        if self.max_x < bound.max_x: self.max_x = bound.max_x\n        if self.max_y < bound.max_x: self.max_y = bound.max_y\n        return self\n\n    def area(self):\n        return (self.max_x - self.min_x) * (self.max_y - self.min_y) if self.max_x > -1 else 0\n\n\nn, d = map(int, input().split())\ninput_store = set()\nmax_b = -1\n\nwhile n:\n    x, y, b = map(int, input().split())\n    input_store.add((x, y, b))\n    if b > max_b: max_b = b\n    n -= 1\n\nstars = [Bound() for _ in range(max_b + 1)]\nfor x, y, b in input_store:\n    stars[b].add(x, y)\n\nd = min(d, max_b)\n\nprint(max(reduce(Bound.expand, stars[i + 1:i + d + 1], stars[i]).area() for i in range(max_b - d + 1)))"
  },
  {
    "language": "Python",
    "code": "N,d = map(int,input().split())\nL = [list(map(int,input().split())) for i in range(N)]\nL = sorted(L,key=lambda x:x[2])\n\ndef get_square(L):\n  if not L:return 0\n  x=[L[0][0],L[0][0]]\n  y=[L[0][1],L[0][1]]\n  for i in L:\n    if i[0] < x[0]:x[0] = i[0]\n    if i[0] > x[1]:x[1] = i[0]\n    if i[1] < y[0]:y[0] = i[1]\n    if i[1] > y[1]:y[1] = i[1]\n  return (x[1] - x[0]) * (y[1] - y[0])\n\nresult = 0\ni = L[0][2]\nj = L[-1][2]\nwhile True:\n  n = i + d\n  l = []\n  while i <= n:\n    l += [x for x in L if x[2] == i]\n    i += 1\n  s = get_square(l)\n  if result < s:result = s\n  i -= d\n  if j < i + d:break\nprint(result)"
  },
  {
    "language": "Python",
    "code": "import math\ndef segmentTree(dat, f, sentinel):\n        pad = 2 ** math.ceil(math.log(len(dat),2))\n        dat = [0] * pad + dat + [sentinel] * (pad - len(dat))\n        for i in range(pad - 1, 0, -1):\n            dat[i] = f(dat[i * 2],dat[i * 2 + 1])\n        return dat\n\ndef get_lr(b,d):\n    l = r = 0\n    while r < len(b):\n        while b[l] + d < b[r]:\n            l += 1\n        for r in range(r,len(b)):\n            if b[l] + d < b[r]:\n                r -= 1\n                break\n        r += 1\n        yield l,r\n        l += 1\n    \nimport sys\nf = sys.stdin\n\n_, d = map(int, f.readline().split())\n\nxyb = []\nfor line in f:\n    xyb.append(tuple(map(int, line.split())))\nfrom operator import itemgetter\nxyb.sort(key=itemgetter(2))\n\nx = [xybi[0] for xybi in xyb]\ny = [xybi[1] for xybi in xyb]\nb = [xybi[2] for xybi in xyb]\n\nxmax = segmentTree(x,max,sentinel = 0)\nxmin = segmentTree(x,min,sentinel = 2000000)\nymax = segmentTree(y,max,sentinel = 0)\nymin = segmentTree(y,min,sentinel = 2000000)\n\n\npad = len(xmax) // 2\nmax_size = 0\ndef create_index(l,r):\n    index = []\n    ia = index.append\n    while l < r:\n        if r & 1:\n            r -= 1\n            ia(r)\n        if l & 1:\n            ia(l)\n            l += 1\n        l >>= 1\n        r >>= 1\n    return index\n\nfor l,r in get_lr(b,d):\n    l += pad \n    r += pad\n    index = create_index(l,r)\n\n    now_xmax = max(xmax[i] for i in index)\n    now_ymax = max(ymax[i] for i in index)\n    if max_size < now_xmax * now_ymax:\n        max_size = max(max_size,((now_xmax - min(xmin[i] for i in index)) * (now_ymax - min(ymin[i] for i in index))))\nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\nfor j in range(len(a)):\n    minlight = a[0][2]\n    astars = []\n    for k in range(len(a)):\n        while(len(astars)<=2):\n            if (a[k][2] >= minlight and a[k][2] <= minlight + lightrange):\n                astars.append(a[k])\n                twostars = k\n    maxx = max(astars[0][0],astars[1][0])\n    minx = min(astars[0][0],astars[1][0])\n    maxy = max(astars[0][1],astars[1][1])\n    miny = min(astars[0][1],astars[1][1])\n    for l in range(twostars+1,len(a)):\n        if (a[l][2] >= minlight and a[l][2] <= minlight + lightrange and (a[l][0]<minx or a[l][0]>maxx or a[l][1]<miny or a[l][1]>maxy)):\n            if(a[l][0]<minx):\n                minx=a[l][0]\n            if(a[l][0]>maxx):\n                maxx=a[l][0]\n            if(a[l][1]<miny):\n                miny=a[l][1]\n            if(a[l][0]>maxy):\n                maxy=a[l][1]\n    area = (maxx-minx)*(maxy-miny)\n    if (area > scale):\n        scale = area\n    del a[0]\n    if len(a) < 2:\n        break;\n\nprint scale"
  },
  {
    "language": "Python",
    "code": "import math\nclass sqrt_tree:\n    def __init__(self,dat,f):\n        self.dat = dat\n        self.sq = int(len(dat) ** 0.5)\n        self.f = f\n        self.baqet = [self.f(dat[i * self.sq:(i + 1) * self.sq]) for i in range(len(dat) // self.sq)]\n    \n    #query\n    def q(self,l,r):\n        r += 1\n        if math.ceil(l / self.sq) >= r // self.sq:\n            return self.f(self.dat[l:r])\n        ret = []\n        if math.ceil(l / self.sq) < len(self.baqet):\n            ret.append(self.f(self.baqet[math.ceil(l / self.sq):r // self.sq]))\n        if l % self.sq:\n            ret.append(self.f(self.dat[l:l + self.sq]))\n        if r % self.sq:\n            ret.append(self.f(self.dat[r - r % self.sq:r]))\n        return self.f(ret)\n\nimport sys\nf = sys.stdin\n\n_, d = map(int, f.readline().split())\n\nx,y = {},{}\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    if bi not in x:\n        x[bi],y[bi] = [],[]\n    x[bi].append(xi)\n    y[bi].append(yi)\n\nb = sorted(x.keys())\n\nxmax = sqrt_tree([max(x[bi]) for bi in b],max)\nxmin = sqrt_tree([min(x[bi]) for bi in b],min)\nymax = sqrt_tree([max(y[bi]) for bi in b],max)\nymin = sqrt_tree([min(y[bi]) for bi in b],min)\n\ndef get_lr(b,d):\n    l = r = 0\n    while r < len(b):\n        while b[l] + d < b[r]:\n            l += 1\n        for k in range(r,len(b)):\n            if b[l] + d < b[k]:\n                break\n            r = k\n        yield l,r\n        r += 1\n        l += 1\n    \nmax_size = max((xmax.q(l,r) - xmin.q(l,r)) * (ymax.q(l,r) - ymin.q(l,r)) for l,r in get_lr(b,d))\nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "import math\n\nclass SegmentTree(object):\n    __slots__ = [\"elem_size\", \"tree\", \"default\", \"op\"]\n\n    def __init__(self, a: list, default: int, op):\n        real_size = len(a)\n        self.elem_size = elem_size = 1 << math.ceil(math.log2(real_size))\n        self.tree = tree = [default] * (elem_size * 2)\n        tree[elem_size:elem_size+real_size] = a\n        self.default = default\n        self.op = op\n\n        for i in range(elem_size - 1, 0, -1):\n            tree[i] = op(tree[i<<1], tree[(i<<1)+1])\n\n    def get_value(self, x: int, y: int) -> int:\n        l, r = x + self.elem_size, y + self.elem_size\n        tree, result, op = self.tree, self.default, self.op\n        while l < r:\n            if l & 1:\n                result = op(tree[l], result)\n                l += 1\n            if r & 1:\n                r -= 1\n                result = op(tree[r], result)\n            l, r = l >> 1, r >> 1\n\n        return result\n\n    def set_value(self, i: int, value: int) -> None:\n        k = self.elem_size + i\n        self.tree[k] = value\n        self.update(k)\n\n    def update(self, i: int) -> None:\n        op, tree = self.op, self.tree\n        while i > 1:\n            i >>= 1\n            tree[i] = op(tree[i<<1], tree[(i<<1) + 1])\n\nif __name__ == \"__main__\":\n    import sys\n    from bisect import bisect_right\n\n    N, d = map(int, sys.stdin.readline().split())\n    b_l, x_l, y_l = zip(*sorted([(b, x, y) for l in sys.stdin.readlines() for x, y, b in (map(int, l.split()),)]))\n    inf, minf = float(\"inf\"), float(\"-inf\")\n    x_min = SegmentTree(x_l, inf, min)\n    x_max = SegmentTree(x_l, minf, max)\n    y_min = SegmentTree(y_l, inf, min)\n    y_max = SegmentTree(y_l, minf, max)\n\n    ans = 0\n    for l, (b, _) in enumerate(zip(b_l, [-1]+list(b_l))):\n        if b == _:\n            continue\n        r = bisect_right(b_l, b+d)\n        x1, x2 = x_min.get_value(l, r), x_max.get_value(l, r)\n        y1, y2 = y_min.get_value(l, r), y_max.get_value(l, r)\n        ans = max(ans, (x2-x1)*(y2-y1))\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "from functools import reduce\nfrom math import ceil, sqrt\nfrom copy import copy\n\n\nclass Bound:\n    min_x = 2000001\n    min_y = 2000001\n    max_x = -1\n    max_y = -1\n    added = False\n\n    def add(self, x, y):\n        self.added = True\n        if self.min_x > x: self.min_x = x\n        if self.min_y > y: self.min_y = y\n        if self.max_x < x: self.max_x = x\n        if self.max_y < y: self.max_y = y\n\n    def expand(self, bound):\n        if bound.added:\n            if not self.added:\n                return bound.clone()\n            if self.min_x > bound.min_x: self.min_x = bound.min_x\n            if self.min_y > bound.min_y: self.min_y = bound.min_y\n            if self.max_x < bound.max_x: self.max_x = bound.max_x\n            if self.max_y < bound.max_y: self.max_y = bound.max_y\n        return self\n\n    def area(self):\n        return (self.max_x - self.min_x) * (self.max_y - self.min_y) if self.max_x > -1 else 0\n\n    @classmethod\n    def expand_list(cls, bounds):\n        return reduce(cls.expand, bounds[1:], bounds[0].clone())\n\n    def clone(self):\n        return copy(self)\n\n    def __str__(self):\n        return '({},{},{},{})'.format(self.min_x, self.min_y, self.max_x, self.max_y)\n\n\nclass Bucket:\n    def __init__(self, bounds, unit):\n        self.unit = unit\n        self.bucket = [self.create_unit(bounds, i, i + unit) for i in range(0, max_b + 1, unit)]\n\n    @staticmethod\n    def create_unit(bounds, s, t):\n        b = bounds[s:t]\n        return (Bound.expand_list(b), b)\n\n    def get_range(self, s, t):\n        unit = self.unit\n        sd, sm = s // unit, s % unit\n        td, tm = t // unit, t % unit\n        if sd == td:\n            return Bound.expand_list(self.bucket[sd][1][sm:tm + 1])\n        else:\n            b_list = [b[0] for b in self.bucket[sd + 1:td]]\n            bound = Bound.expand_list(b_list) if b_list else Bound()\n            s_list = self.bucket[sd][1][sm:]\n            if s_list:\n                bound = bound.expand(Bound.expand_list(s_list))\n            t_list = self.bucket[td][1][:tm + 1]\n            if t_list:\n                bound = bound.expand(Bound.expand_list(t_list))\n            return bound\n\n\nn, d = map(int, input().split())\ninput_store = set()\nmax_b = -1\n\nwhile n:\n    x, y, b = map(int, input().split())\n    input_store.add((x, y, b))\n    if b > max_b: max_b = b\n    n -= 1\n\nstars = [Bound() for _ in range(max_b + 1)]\nfor x, y, b in input_store:\n    stars[b].add(x, y)\n\nif d > max_b:\n    print(reduce(Bound.expand, stars[1:], stars[0]).area())\nelse:\n    unit = ceil(sqrt(d + 1))\n    if unit < 2:\n        print(max(Bound.expand_list(stars[i:i + d + 1]).area() for i in range(max_b - d + 1)))\n    else:\n        star_buckets = Bucket(stars, unit)\n        print(max(star_buckets.get_range(i, i + d + 1).area() for i in range(max_b - d + 1)))"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\nwhile(len(a)>1):\n    minx=maxx=a[0][0]\n    miny=maxy=a[0][1]\n    k=1\n    while(a[k][2]<=a[0][2] + lightrange):\n        if (a[k][0]<minx or a[k][0]>maxx or a[k][1]<miny or a[k][1]>maxy):\n            minx = min(minx,a[k][0])\n            maxx = max(maxx,a[k][0])\n            miny = min(miny,a[k][1])\n            maxy = max(maxy,a[k][1])\n        k+=1\n    area = (maxx-minx)*(maxy-miny)\n    #scale = max(scale,area)\n    if(area>scale):\n        scale = area\n    del a[0]\nprint scale"
  },
  {
    "language": "Python",
    "code": "from math import ceil\nclass sqrt_tree:\n    def __init__(self,dat,f):\n        self.dat = dat\n        self.sq = int(len(dat) ** 0.5)\n        self.f = f\n        self.baqet = [self.f(dat[i * self.sq:(i + 1) * self.sq]) for i in range(self.sq)]\n    \n    #query\n    def q(self,l,r):\n        r += 1\n        if ceil(l / self.sq) >= r // self.sq:\n            return self.f(self.dat[l:r])\n        ret = self.f(self.baqet[ceil(l / self.sq):r // self.sq])\n        if l % self.sq:\n            ret = self.f(ret,self.f(self.dat[l:l + self.sq]))\n        if r % self.sq:\n            ret = self.f(ret,self.f(self.dat[r - r % self.sq:r]))\n        return ret\n\nimport sys\nf = sys.stdin\n\n_, d = map(int, f.readline().split())\n\nx,y = {},{}\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    if bi not in x:\n        x[bi],y[bi] = [],[]\n    x[bi].append(xi)\n    y[bi].append(yi)\n\nb = sorted(x.keys())\n\nxmax = sqrt_tree([max(x[bi]) for bi in b],max)\nxmin = sqrt_tree([min(x[bi]) for bi in b],min)\nymax = sqrt_tree([max(y[bi]) for bi in b],max)\nymin = sqrt_tree([min(y[bi]) for bi in b],min)\n\ndef get_lr(b,d):\n    l = r = 0\n    while r < len(b) - 1:\n        while b[l] + d < b[r]:\n            l += 1\n        for k in range(l,len(b)):\n            if b[l] + d < b[k]:\n                break\n            r = k\n        yield l,r\n        r += 1\n        l += 1\n   \nmax_size = max((xmax.q(l,r) - xmin.q(l,r)) * (ymax.q(l,r) - ymin.q(l,r)) for l,r in get_lr(b,d))\nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "from functools import reduce\n\n\nclass Bound:\n    min_x = 2000001\n    min_y = 2000001\n    max_x = -1\n    max_y = -1\n\n    def add(self, x, y):\n        if self.min_x > x: self.min_x = x\n        if self.min_y > y: self.min_y = y\n        if self.max_x < x: self.max_x = x\n        if self.max_y < y: self.max_y = y\n\n    def expand(self, bound):\n        if self.min_x > bound.min_x: self.min_x = bound.min_x\n        if self.min_y > bound.min_y: self.min_y = bound.min_y\n        if self.max_x < bound.max_x: self.max_x = bound.max_x\n        if self.max_y < bound.max_x: self.max_y = bound.max_y\n        return self\n\n    def area(self):\n        return (self.max_x - self.min_x) * (self.max_y - self.min_y) if self.max_x > -1 else 0\n\n\nn, d = map(int, input().split())\ninput_store = set()\nmax_b = -1\n\nwhile n:\n    x, y, b = map(int, input().split())\n    input_store.add((x, y, b))\n    if b > max_b: max_b = b\n    n -= 1\n\nstars = [Bound() for _ in range(max_b + 1)]\nfor x, y, b in input_store:\n    stars[b].add(x, y)\n\nprint(max(reduce(Bound.expand, stars[i + 1:i + d + 1], stars[i]).area() for i in range(max_b - d + 1)))"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter as it\nD={}\nresult=[]\nN,d=map(int,input().split())\nfor i in stdin.readlines():\n    x,y,b=map(int,i.split())\n    if b not in D:D[b]=[]\n    D[b].append((x,y))\nfor i in range(max(D)-d+1):\n    l=[]\n    for s in range(d+1):\n        if i+s in D:l+=D[i+s]\n    if len(l)>1:\n        x=max(map(it(0),l))-min(map(it(0),l))\n        y=max(map(it(1),l))-min(map(it(1),l))\n        result.append(x*y)\nprint(0 if 0==len(result) else max(result))"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\nwhile(len(a)>1):\n    minx=maxx=a[0][0]\n    miny=maxy=a[0][1]\n    k=1\n    while(a[k][2]<=a[0][2] + lightrange):\n        if (a[k][0]<minx or a[k][0]>maxx or a[k][1]<miny or a[k][1]>maxy):\n            minx = min(minx,a[k][0])\n            maxx = max(maxx,a[k][0])\n            miny = min(miny,a[k][1])\n            maxy = max(maxy,a[k][1])\n        if k==len(a)-1:\n            break;\n        k+=1\n    area = (maxx-minx)*(maxy-miny)\n    scale = max(scale,area)\n    del a[0]\nprint scale"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\n\ndef get_square(L):\n  if not L or len(L) == 0:return 0\n  x=[L[0][0][0],L[0][0][1]]\n  y=[L[0][1][0],L[0][1][1]]\n  for i in L:\n    if i[0][0] < x[0]:x[0] = i[0][0]\n    if i[0][1] > x[1]:x[1] = i[0][1]\n    if i[1][0] < y[0]:y[0] = i[1][0]\n    if i[1][1] > y[1]:y[1] = i[1][1]\n  return (x[1] - x[0]) * (y[1] - y[0])\n\ndef get_xy(b,L):\n  if not L or len(L) == 0:return None\n  x=[L[0][0],L[0][0]]\n  y=[L[0][1],L[0][1]]\n  for i in L:\n    if i[0] < x[0]:x[0] = i[0]\n    elif i[0] > x[1]:x[1] = i[0]\n    if i[1] < y[0]:y[0] = i[1]\n    elif i[1] > y[1]:y[1] = i[1]\n  return (b,x,y)\n\nN,d = map(int,input().split())\nL = sorted(set([tuple(map(int,i.split())) for i in stdin.readlines()]),key=itemgetter(2))\nB = set([i[2] for i in L])\nD = [get_xy(n,[i for i in L if i[2] == n]) for n in B]\n\ni = 0\nresult = 0\nwhile i < len(D):\n  m = D[i][0] + d\n  L = [D[i][1:3]]\n  j = i+1\n  while j < len(D) and D[j][0] <= m:\n    L.append(D[j][1:3])\n    j += 1\n  s = get_square(L)\n  if result < s:result = s\n  i += 1\n\nprint(result)"
  },
  {
    "language": "Python",
    "code": "class MinTree:\n  def __init__(self, iterable):\n    self.iter_size = self.get_size(iterable)\n    self.size = self.iter_size * 2 - 1\n    self.value = [None] * self.size\n    for i, v in enumerate(iterable):\n      self.value[self.iter_size + i - 1] = v\n    self.set_value(0)\n    self.range = [None] * self.size\n    self.set_range(0, 0, self.iter_size - 1)\n  \n  def get_size(self, iterable):\n    ret = 1\n    x = len(iterable)\n    while ret < x:\n      ret *= 2\n    return ret\n  \n  def set_range(self, x, left, right):\n    self.range[x] = (left, right)\n    if left != right:\n      self.set_range(x * 2 + 1, left, (right + left) // 2)\n      self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n  def set_value(self, x):\n    if x >= self.iter_size - 1:return self.value[x]\n    a = self.set_value(x * 2 + 1)\n    b = self.set_value(x * 2 + 2)\n    if a == None and b == None:\n      self.value[x] = None\n    elif a == None:\n      self.value[x] = b\n    elif b == None:\n      self.value[x] = a\n    else:\n      self.value[x] = min(a, b)\n    return self.value[x]\n\n  def query(self, x, left, right):\n    x_left, x_right = self.range[x]\n    if right < x_left or x_right < left:\n      return INF\n    if left <= x_left and x_right <= right:\n      return self.value[x]\n\n    return min(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n\n\nclass MaxTree:\n  def __init__(self, iterable):\n    self.iter_size = self.get_size(iterable)\n    self.size = self.iter_size * 2 - 1\n    self.value = [None] * self.size\n    for i, v in enumerate(iterable):\n      self.value[self.iter_size + i - 1] = v\n    self.set_value(0)\n    self.range = [None] * self.size\n    self.set_range(0, 0, self.iter_size - 1)\n  \n  def get_size(self, iterable):\n    ret = 1\n    x = len(iterable)\n    while ret < x:\n      ret *= 2\n    return ret\n  \n  def set_range(self, x, left, right):\n    self.range[x] = (left, right)\n    if left != right:\n      self.set_range(x * 2 + 1, left, (right + left) // 2)\n      self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n  def set_value(self, x):\n    if x >= self.iter_size - 1:return self.value[x]\n    a = self.set_value(x * 2 + 1)\n    b = self.set_value(x * 2 + 2)\n    if a == None and b == None:\n      self.value[x] = None\n    elif a == None:\n      self.value[x] = b\n    elif b == None:\n      self.value[x] = a\n    else:\n      self.value[x] = max(a, b)\n    return self.value[x]\n\n  def query(self, x, left, right):\n    x_left, x_right = self.range[x]\n    if right < x_left or x_right < left:\n      return 0\n    if left <= x_left and x_right <= right:\n      return self.value[x]\n\n    return max(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n\nfrom bisect import bisect_left as bl\n\nn, d = map(int, input().split())\nlst = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x:x[2])\nsorted_x = []\nsorted_y = []\nkeys_to_ind = {}\nfor i in range(n):\n  x, y, b = lst[i]\n  sorted_x.append(x)\n  sorted_y.append(y)\n  if b not in keys_to_ind:\n    keys_to_ind[b] = i\nkeys = list(keys_to_ind.keys())\nmxt = MinTree(sorted_x)\nMxt = MaxTree(sorted_x)\nmyt = MinTree(sorted_y)\nMyt = MaxTree(sorted_y)\n\ndef score(left, right):\n  return (Mxt.query(0, left, right) - mxt.query(0, left, right)) * \\\n         (Myt.query(0, left, right) - myt.query(0, left, right))\n\nINF = 10 ** 20\nkl = 0\nkr = bl(keys, keys[0] + d)\nend = len(keys)\nans = 0\nwhile kr < end:\n  ans = max(ans, score(keys_to_ind[keys[kl]], keys_to_ind[keys[kr]]))\n  kl += 1\n  while kr < end and keys[kl] + d >= keys[kr]:\n    kr += 1\n  kr -= 1\n  if kr == end - 1:break\n\nans = max(ans, score(keys_to_ind[keys[kl]], keys_to_ind[keys[kr]]))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\nfrom itertools import takewhile\nfrom random import randint\nfrom array import array\n\nMAX = 200000000\n\nclass Point:\n  def __init__(self,x=-1,y=-1,b=-1):\n    self.x=x\n    self.y=y\n    self.b=b\n\nclass Points:\n  def __init__(self,b,points):\n    self.b=b\n    self.xmin=points[0]\n    self.xmax=points[1]\n    self.ymin=points[2]\n    self.ymax=points[3]\n\n  def set_point(self,point):\n    if self.xmin > point.x:self.xmin=point.x\n    elif self.xmax < point.x:self.xmax=point.x\n    if self.ymin > point.y:self.ymin=point.y\n    elif self.ymax < point.y:self.ymax=point.y\n\nclass Constellation:\n  def __init__(self,bmin=0,bmax=0,xmin=0,xmax=0,ymin=0,ymax=0):\n    self.D = { i:None for i in range(bmin,bmax+1) }\n    self.bmin=bmin\n    self.bmax=bmax\n    self.xmin=xmin\n    self.xmax=xmax\n    self.ymin=ymin\n    self.ymax=ymax\n\n  def set_points(self,points):\n    if points.b > self.bmax and points.b < self.bmin:\n      raise Exception\n    if self.xmin > points.xmin:self.xmin=points.xmin\n    elif self.xmax < points.xmax:self.xmax=points.xmax\n    if self.ymin > points.ymin:self.ymin=points.ymin\n    elif self.ymax < points.ymax:self.ymax=points.ymax\n\n  def square(self):\n    return (self.xmax - self.xmin) * (self.ymax - self.ymin)\n\n  def update_b(self,bmin=0,bmax=0):\n    for i in range(self.bmin,bmin):\n      del self.D[i]\n    for i in range(self.bmax+1,bmax+1):\n      self.D[i] = None\n    self.bmin = bmin\n    self.bmax = bmax\n\n\nN,d = map(int,input().split())\nL = [tuple(map(int,i.split())) for i in stdin.readlines()]\nB = sorted(set([i[2] for i in L]))\nD = {i:[] for i in B}\n[D[i[2]].append((i[0],i[1])) for i in L]\nfor k,v in D.items():\n  i = tuple(zip(*v))\n  D[k] = (min(i[0]),max(i[0]),min(i[1]),max(i[1]))\nMax = B[-1]\nresult = 0\n\nif d < 50000:\n  for i in range(len(B)):\n    b = B[i] + d\n    L2 = tuple(zip(*(D[j] for j in \n        takewhile(\n          lambda x: x <= b, \n          (B[n] for n in range(i,len(B)))\n          ))))\n    #L3 = tuple(zip(*L2))\n    s = (max(L3[1]) - min(L3[0])) * (max(L3[3]) - min(L3[2]))\n    if result < s:result = s\n    if b > Max:break\n  print(result)\n\nelse:\n  results = 0\n  print(B[0])\n  print(B[0]+d)\n  print(D[B[0]])\n  c = Constellation(B[0],B[0]+d,*D[B[0]])\n  for k,v in D.items(): # k b, v xminmax,yminmax\n    if k <= c.bmax:\n      c.set_points(Points(k,v))\n      continue\n    s = c.square()\n    if result < s:result = s\n    c.update_b(k-d,k)\n    c.set_points(Points(k,v))\n\n  print(result)"
  },
  {
    "language": "Python",
    "code": "n,d = map(int,input().split())\nstar = []\nfor i in range(n):\n    x,y,b = map(int,input().split())\n    star.append((b,x,y))\nstar.sort()\n\nINF = 10**9\nq1 = []\nq2 = []\nminmax1 = [(INF,INF,-INF,-INF)]\nminmax2 = [(INF,INF,-INF,-INF)]\nr = 0\nans = 0\n\ndef add(que, dat):\n    xmin, ymin, xmax, ymax = que[-1]\n    x, y = dat\n    if x < xmin:\n        xmin = x\n    if x > xmax:\n        xmax = x\n    if y < ymin:\n        ymin = y\n    if y > ymax:\n        ymax = y\n    que.append((xmin, ymin, xmax, ymax))\n\nfor s in star:\n    while r < n and star[r][0]-s[0] <= d:\n        br, xr, yr = star[r]\n        xy = (xr,yr)\n        q2.append(xy)\n        add(minmax2,xy)\n        r += 1\n    xmin = min(minmax1[-1][0], minmax2[-1][0])\n    ymin = min(minmax1[-1][1], minmax2[-1][1])\n    xmax = max(minmax1[-1][2], minmax2[-1][2])\n    ymax = max(minmax1[-1][3], minmax2[-1][3])\n    area = (xmax-xmin)*(ymax-ymin)\n    if area > ans:\n        ans = area\n    if len(q1) == 0:\n        while len(q2) > 0:\n            xy = q2.pop()\n            minmax2.pop()\n            q1.append(xy)\n            add(minmax1, xy)\n    q1.pop()\n    minmax1.pop()\n\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef segmentTree(dat, f, sentinel):\n        pad = 2 ** math.ceil(math.log(len(dat),2))\n        dat = [0] * pad + dat + [sentinel] * (pad - len(dat))\n        for i in range(pad - 1, 0, -1):\n            dat[i] = f(dat[i * 2:i * 2 + 2])\n        return dat\n\ndef get_lr(b,d):\n    l = r = 0\n    while r < len(b):\n        while b[l] + d < b[r]:\n            l += 1\n        for r in range(r,len(b)):\n            if b[l] + d < b[r]:\n                r -= 1\n                break\n        r += 1\n        yield l,r\n        l += 1\n    \nimport sys\nf = sys.stdin\n\n_, d = map(int, f.readline().split())\n\nxyb = []\nfor line in f:\n    xyb.append(tuple(map(int, line.split())))\nfrom operator import itemgetter\nxyb.sort(key=itemgetter(2))\n\nx = [xybi[0] for xybi in xyb]\ny = [xybi[1] for xybi in xyb]\nb = [xybi[2] for xybi in xyb]\n\nxmax = segmentTree(x,max,sentinel = 0)\nxmin = segmentTree(x,min,sentinel = 2000000)\nymax = segmentTree(y,max,sentinel = 0)\nymin = segmentTree(y,min,sentinel = 2000000)\n\n\nsize = []\nsa = size.append #万単位で呼び出す場合は若干早くなる\npad = len(xmax) // 2\nmax_size = 0\nm = pad\npre_xmax,pre_xmin,pre_ymax,pre_ymin=0,0,0,0\ndef create_index(l,r):\n    index = []\n    ia = index.append\n    while l < r:\n        if r & 1:\n            r -= 1\n            ia(r)\n        if l & 1:\n            ia(l)\n            l += 1\n        l >>= 1\n        r >>= 1\n    return index\n\nfor l,r in get_lr(b,d):\n    l += pad \n    r += pad\n    index = create_index(m,r)\n\n    now_xmax = max(xmax[i] for i in index)\n    now_xmin = min(xmin[i] for i in index)\n    now_ymax = max(ymax[i] for i in index)\n    now_ymin = min(ymin[i] for i in index)\n    \n    if pre_xmax < now_xmax or pre_xmin > now_xmin or pre_ymax < now_ymax or pre_ymin > now_ymin:\n        if l < m:\n            index = create_index(l,m)\n            now_xmax = max(now_xmax,max(xmax[i] for i in index))\n            now_xmin = min(now_xmin,min(xmin[i] for i in index))\n            now_ymax = max(now_ymax,max(ymax[i] for i in index))\n            now_ymin = min(now_ymin,min(ymin[i] for i in index))\n\n        sa((now_xmax - now_xmin) * (now_ymax - now_ymin))\n    pre_xmax,pre_xmin,pre_ymax,pre_ymin=now_xmax,now_xmin,now_ymax,now_ymin\n    m = r\nprint(max(size))"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_right as br\n\ndef make(arr, length, num):\n  if num >= length:\n    return None\n  if arr[num] != None:\n    return arr[num]\n  else:\n    num_ = num * 2\n    arr[num] = con(make(arr, length, num_ + 1), make(arr, length, num_ + 2))\n    return arr[num]\n  \ndef con(n1, n2):\n  if n1 != None and n2 != None:\n    r0, r1, r2, r3 = get_min(n1[:4], n2[:4])\n    return (r0, r1, r2, r3, n1[4], n2[5])\n  if n1 != None:\n    return n1\n  if n2 != None:\n    return n2\n  return None\n\ndef query(arr, l, r, num):\n  node = arr[num]\n  if node == None:\n    return None\n  ln, rn = node[4], node[5]\n  if l <= ln and rn <= r:\n    return node[:4]\n  elif r < ln or rn < l:\n    return None\n  else:\n    num_ = num * 2\n    n1 = query(arr, l, r, num_ + 1)\n    n2 = query(arr, l, r, num_ + 2)\n    if n1 == None and n2 == None:\n      return None\n    if n1 == None:\n      return n2\n    if n2 == None:\n      return n1\n    return get_min(n1, n2)\n  \ndef get_min(t1, t2):\n  t10, t11, t12, t13 = t1\n  t20, t21, t22, t23 = t2\n  if t10 < t20:\n    r0 = t10\n  else:\n    r0 = t20\n  if t11 < t21:\n    r1 = t21\n  else:\n    r1 = t11\n  if t12 < t22:\n    r2 = t12\n  else:\n    r2 = t22\n  if t13 < t23:\n    r3 = t23\n  else:\n    r3 = t13\n  return (r0, r1, r2, r3)\n\n\n\n\ndef main():\n  n, d = map(int, input().split())\n  star_dic = {}\n  blst = []\n  for _ in range(n):\n    x, y, b = map(int, input().split())\n    if b in star_dic:\n      star_dic[b] = get_min(star_dic[b], (x, x, y, y))\n    else:\n      star_dic[b] = (x, x, y, y)\n      blst.append(b)\n  stars = sorted(list(star_dic.items()))\n  blst.sort()\n  blen = len(blst)\n  \n  length = 1\n  while length < blen:\n    length *= 2\n  arr = [None] * (length * 2 - 1)\n  for i, star in enumerate(stars):\n    x1, x2, y1, y2 = star[1]\n    arr[length - 1 + i] = (x1, x2, y1, y2, i, i)\n  make(arr, length * 2 - 1, 0)\n\n  ans = 0\n  max_r = 0\n  for l in range(blen):\n    r = br(blst, blst[l] + d)\n    if r == blen or blst[r] != blst[l] + d:\n      r -= 1\n    if r > max_r:\n      x1, x2, y1, y2 = query(arr, l, r, 0)\n      score = (x2 - x1) * (y2 - y1)\n      if score > ans:\n        ans = score\n      max_r = r\n  print(ans)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  INF = 10 ** 20\n\n  class MinTree:\n    def __init__(self, iterable):\n      self.iter_size = self.get_size(iterable)\n      self.size = self.iter_size * 2 - 1\n      self.value = [None] * self.size\n      for i, v in enumerate(iterable):\n        self.value[self.iter_size + i - 1] = v\n      self.set_value(0)\n      #self.range = [None] * self.size\n      #self.set_range(0, 0, self.iter_size - 1)\n    \n    def get_size(self, iterable):\n      ret = 1\n      x = len(iterable)\n      while ret < x:\n        ret *= 2\n      return ret\n\n    def set_range(self, x, left, right):\n      self.range[x] = (left, right)\n      if left != right:\n        self.set_range(x * 2 + 1, left, (right + left) // 2)\n        self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n    def set_value(self, x):\n      if x >= self.iter_size - 1:return self.value[x]\n      a = self.set_value(x * 2 + 1)\n      b = self.set_value(x * 2 + 2)\n      if a == None and b == None:\n        self.value[x] = None\n      elif a == None:\n        self.value[x] = b\n      elif b == None:\n        self.value[x] = a\n      else:\n        self.value[x] = a if a < b else b\n      return self.value[x]\n  \n    def query(self, x, left, right):\n      x_left, x_right = self.range[x]\n      if right < x_left or x_right < left:\n        return INF\n      if left <= x_left and x_right <= right:\n        return self.value[x]\n      a = self.query(x * 2 + 1, left, right)\n      b = self.query(x * 2 + 2, left, right)\n      return a if a <= b else b\n \n  class MaxTree:\n    def __init__(self, iterable):\n      self.iter_size = self.get_size(iterable)\n      self.size = self.iter_size * 2 - 1\n      self.value = [None] * self.size\n      for i, v in enumerate(iterable):\n        self.value[self.iter_size + i - 1] = v\n      self.set_value(0)\n      #self.range = [None] * self.size\n      #self.set_range(0, 0, self.iter_size - 1)\n    \n    def get_size(self, iterable):\n      ret = 1\n      x = len(iterable)\n      while ret < x:\n        ret *= 2\n      return ret\n    \n    def set_range(self, x, left, right):\n      self.range[x] = (left, right)\n      if left != right:\n        self.set_range(x * 2 + 1, left, (right + left) // 2)\n        self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n    def set_value(self, x):\n      if x >= self.iter_size - 1:return self.value[x]\n      a = self.set_value(x * 2 + 1)\n      b = self.set_value(x * 2 + 2)\n      if a == None and b == None:\n        self.value[x] = None\n      elif a == None:\n        self.value[x] = b\n      elif b == None:\n        self.value[x] = a\n      else:\n        self.value[x] = a if a > b else b\n      return self.value[x]\n  \n    def query(self, x, left, right):\n      x_left, x_right = self.range[x]\n      if right < x_left or x_right < left:\n        return 0\n      if left <= x_left and x_right <= right:\n        return self.value[x]\n      a = self.query(x * 2 + 1, left, right)\n      b = self.query(x * 2 + 2, left, right)\n      return a if a >= b else b\n  \n  def set_range(lst, x, left, right):\n    lst[x] = (left, right)\n    if left != right:\n      set_range(lst, x * 2 + 1, left, (right + left) // 2)\n      set_range(lst, x * 2 + 2, (right + left) // 2 + 1, right)\n \n\n\n  from bisect import bisect_right as br\n\n  n, d = map(int, input().split())\n  lst = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x:x[2])\n  sorted_x = []\n  sorted_y = []\n  keys = []\n  for i in range(n):\n    x, y, b = lst[i]\n    sorted_x.append(x)\n    sorted_y.append(y)\n    keys.append(b)\n  mxt = MinTree(sorted_x)\n  Mxt = MaxTree(sorted_x)\n  myt = MinTree(sorted_y)\n  Myt = MaxTree(sorted_y)\n  lst = [None] * mxt.size\n  set_range(lst, 0, 0, mxt.iter_size - 1)\n  mxt.range = lst\n  Mxt.range = lst\n  myt.range = lst\n  Myt.range = lst\n  \n  def score(left, right):\n    return (Mxt.query(0, left, right) - mxt.query(0, left, right)) * \\\n           (Myt.query(0, left, right) - myt.query(0, left, right))\n  \n  left = 0\n  right = br(keys, keys[0] + d) - 1\n  mx = mxt.query(0, left, right)\n  Mx = Mxt.query(0, left, right)\n  my = myt.query(0, left, right)\n  My = Myt.query(0, left, right)\n  end = len(keys)\n  ans = (Mx - mx) * (My - my)\n  Mx_flag = mx_flag = My_flag = my_flag = False\n  while True:\n    right += 1\n    if right == end:break\n    \n    if sorted_x[right] > Mx:Mx = sorted_x[right]\n    if sorted_x[right] < mx:mx = sorted_x[right] \n    if sorted_y[right] > My:My = sorted_y[right]\n    if sorted_y[right] < my:my = sorted_y[right]\n    \n    while keys[left] + d < keys[right]:\n      if sorted_x[left] == Mx:Mx_flag = True\n      if sorted_x[left] == mx:mx_flag = True\n      if sorted_y[left] == My:My_flag = True\n      if sorted_y[left] == my:my_flag = True\n      left += 1\n    \n    if Mx_flag:\n      Mx = Mxt.query(0, left, right)\n      Mx_flag = False\n    if mx_flag:\n      mx = mxt.query(0, left, right)\n      mx_flag = False\n    if My_flag:\n      My = Myt.query(0, left, right)\n      My_flag = False\n    if my_flag:\n      my = myt.query(0, left, right)\n      my_flag = False\n    \n    ans = max(ans, (Mx - mx) * (My - my)) \n  \n  print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nf = sys.stdin\n\n_, d = map(int, f.readline().split())\n\nx,y,b = [],[],set()\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    x.append((xi,bi))\n    y.append((yi,bi))\n    b.update([bi])    \nx = sorted(x)\ny = sorted(y)\nb = sorted(b)\n\n\ndef search(target,bmin,bmax):\n    tmax,tmin = None,None\n    for i in range(len(target)):\n        if bmin <= target[i][1] <= bmax:\n            tmin = target[i][0]\n            break\n    for i in range(len(target) - 1, -1, -1):\n        if bmin <= target[i][1] <= bmax:\n            tmax = target[i][0]\n            break\n    return tmax,tmin\n    \n\nmax_size = i = j = 0\nwhile j < len(b) - 1:\n    for k in range(j,-1,-1):\n        if b[k] + d < b[j]:\n            break\n        i = k\n    for k in range(i,len(b)):\n        if b[i] + d < b[k]:\n            break\n        j = k\n\n    xmax,xmin = search(x,b[i],b[j])\n    ymax,ymin = search(y,b[i],b[j])\n    \n    max_size = max(max_size,(xmax - xmin) * (ymax - ymin))\n    j+=1\n    \nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "import sys\nf = sys.stdin\n\ndef q(t,i,s,e,func):\n    if s == e:\n        return t[s][i]\n    else:\n        return func(q(t,i,s,(s+e)//2,func),q(t,i,(s+e)//2 + 1,e,func))\n\n_, d = map(int, f.readline().split())\n\nb = []\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    b.append((bi,xi,yi))\nb = sorted(b)\n\nmax_size = i = j = 0\nwhile j < len(b) - 1:\n    for k in range(j,-1,-1):\n        if b[k][0] + d < b[j][0]:\n            break\n        i = k\n    for k in range(i,len(b)):\n        if b[i][0] + d < b[k][0]:\n            break\n        j = k\n\n    max_size = max(max_size,(q(b,1,i,j,max) - q(b,1,i,j,min)) * (q(b,2,i,j,max) - q(b,2,i,j,min)))\n    j+=1\n    \nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = []\nwhile(len(a)>1):\n    k=0\n    x=[]\n    y=[]\n    while(a[k][2]<=a[0][2] + lightrange):\n        x.append(a[k][0])\n        y.append(a[k][1])\n        k+=1\n        if(k==len(a)):\n            break\n    scale.append((max(x)-min(x))*(max(y)-min(y)))\n    del a[0]\nprint max(scale)"
  },
  {
    "language": "Python",
    "code": "import math\nclass SegmentTree:\n    def __init__(self, dat, f, sentinel):\n        self.pad = 2 ** math.ceil(math.log(len(dat),2))\n        self.dat = [None] * self.pad + dat + [sentinel] * (self.pad - len(dat))\n        self.f = f\n        self.sentinel = sentinel\n        for i in range(self.pad - 1, 0, -1):\n            self.dat[i] = self.f(self.dat[i * 2:i * 2 + 2])\n        \n    def q(self,l,r):\n        return self._q(self.pad + l,self.pad + r,1,self.pad,len(self.dat) - 1)\n    def _q(self,a,b,k,l,r):\n        if b < l or r < a:\n            return self.sentinel\n        elif a <= l and r <= b:\n            return self.dat[k]\n        else:\n            vl = self._q(a,b,k * 2,l,(l+r)//2)\n            vr = self._q(a,b,k * 2 + 1,(l+r)//2 + 1,r)\n            return self.f(vl,vr)\n        \nimport sys\nf = sys.stdin\n\n_, d = map(int, f.readline().split())\n\nx,y = {},{}\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    if bi not in x:\n        x[bi],y[bi] = [],[]\n    x[bi].append(xi)\n    y[bi].append(yi)\n\nb = sorted(x.keys())\n\nxmax = SegmentTree([max(x[bi]) for bi in b],max,sentinel = -1)\nxmin = SegmentTree([min(x[bi]) for bi in b],min,sentinel = 2000001)\nymax = SegmentTree([max(y[bi]) for bi in b],max,sentinel = -1)\nymin = SegmentTree([min(y[bi]) for bi in b],min,sentinel = 2000001)\n\ndef get_lr(b,d):\n    l = r = 0\n    while r < len(b):\n        while b[l] + d < b[r]:\n            l += 1\n        for r in range(r,len(b)):\n            if b[l] + d < b[r]:\n                r -= 1\n                break\n        yield l,r\n        l += 1\n        r += 1\n    \nmax_size = max((xmax.q(l,r) - xmin.q(l,r)) * (ymax.q(l,r) - ymin.q(l,r)) for l,r in get_lr(b,d))\nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_right as br\n\ndef make(arr, length, num):\n  if num >= length:\n    return None\n  if arr[num] != None:\n    return arr[num]\n  else:\n    arr[num] = con(make(arr, length, num * 2 + 1), make(arr, length, num * 2 + 2))\n    return arr[num]\n  \ndef con(n1, n2):\n  if n1 != None and n2 != None:\n    r0, r1, r2, r3 = get_min(n1[:4], n2[:4])\n    return (r0, r1, r2, r3, n1[4], n2[5])\n  if n1 != None:\n    return n1\n  if n2 != None:\n    return n2\n  return None\n\ndef query(arr, l, r, num):\n  node = arr[num]\n  if node == None:\n    return None\n  ln, rn = node[4], node[5]\n  if l <= ln and rn <= r:\n    return node[:4]\n  elif r < ln or rn < l:\n    return None\n  else:\n    x1 = query(arr, l, r, num * 2 + 1)\n    x2 = query(arr, l, r, num * 2 + 2)\n    if x1 == None and x2 == None:\n      return None\n    if x1 == None:\n      return x2\n    if x2 == None:\n      return x1\n    return get_min(x1, x2)\n  \ndef get_min(t1, t2):\n  t10, t11, t12, t13 = t1\n  t20, t21, t22, t23 = t2\n  if t10 < t20:\n    r0 = t10\n  else:\n    r0 = t20\n  if t11 < t21:\n    r1 = t21\n  else:\n    r1 = t11\n  if t12 < t22:\n    r2 = t12\n  else:\n    r2 = t22\n  if t13 < t23:\n    r3 = t23\n  else:\n    r3 = t13\n  return (r0, r1, r2, r3)\n\n\n\n\ndef main():\n  n, d = map(int, input().split())\n  star_dic = {}\n  blst = []\n  for _ in range(n):\n    x, y, b = map(int, input().split())\n    if b in star_dic:\n      x1, x2, y1, y2 = star_dic[b]\n      star_dic[b] = get_min((x1, x2, y1, y2), (x, x, y, y))\n    else:\n      star_dic[b] = (x, x, y, y)\n      blst.append(b)\n  stars = sorted(list(star_dic.items()))\n  blst.sort()\n  blen = len(blst)\n  \n  length = 1\n  while length < blen:\n    length *= 2\n  arr = [None] * (length * 2 - 1)\n  for i, star in enumerate(stars):\n    x1, x2, y1, y2 = star[1]\n    arr[length - 1 + i] = (x1, x2, y1, y2, i, i)\n  make(arr, length * 2 - 1, 0)\n\n  ans = 0\n  max_r = 0\n  for l in range(blen):\n    r = br(blst, blst[l] + d)\n    if r == blen or blst[r] != blst[l] + d:\n      r -= 1\n    if r > max_r:\n      a = query(arr, l, r, 0)\n      score = (a[1] - a[0]) * (a[3] - a[2])\n      if score > ans:\n        ans = score\n      max_r = r\n  print(ans)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter as it\nD={}\nresult=[]\nN,d=map(int,input().split())\nfor i in stdin.readlines():\n    x,y,b=map(int,i.split())\n    if b not in D:D[b]=[]\n    D[b].append((x,y))\nfor i in range(max(D)-d+1):\n    l=[]\n    for s in range(d+1):\n        if i+s in D:l+=D[i+s]\n    if len(l)>1:\n        x=max(map(it(0),l))-min(map(it(0),l))\n        y=max(map(it(1),l))-min(map(it(1),l))\n        result.append(x*y)\nprint(0 if len==(result) else max(result))"
  },
  {
    "language": "Python",
    "code": "n, d = map(int, input().split())\nud, od = d // 2, (d + 1) // 2\nstars = dict()\n\nfor _ in range(n):\n    x, y, b = map(int, input().split())\n    xys = stars.setdefault(b, [x, x, y, y])\n    if xys[0] < x: xys[0] = x\n    if xys[1] > x: xys[1] = x\n    if xys[2] < y: xys[2] = y\n    if xys[3] > y: xys[3] = y\n\nkeys = set(stars.keys())\nmin_b, max_b = min(keys) + ud, max(keys) - od\nmax_stella = 0\n\nfor b in range(min_b, max_b + 1):\n    if b + od not in stars: continue\n    bbs = keys.intersection(range(b - ud, b + od + 1))\n    if not bbs: continue\n    max_x, min_x, max_y, min_y = 0, 200001, 0, 200001\n    for bb in bbs:\n        (ax, ix, ay, iy) = stars[bb]\n        if max_x < ax: max_x = ax\n        if min_x > ix: min_x = ix\n        if max_y < ay: max_y = ay\n        if min_y > iy: min_y = iy\n    else:\n        stella = (max_x - min_x) * (max_y - min_y)\n        if max_stella < stella: max_stella = stella\n\nprint(max_stella)"
  },
  {
    "language": "Python",
    "code": "import sys\nf = sys.stdin\n\n_, d = map(int, f.readline().split())\n\nx,y = {},{}\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    if bi not in x:\n        x[bi],y[bi] = [],[]\n    x[bi].append(xi)\n    y[bi].append(yi)\n\nb = sorted(x.keys())\n\nxmin,xmax,ymin,ymax = [None for _ in range(len(b))],[None for _ in range(len(b))],[None for _ in range(len(b))],[None for _ in range(len(b))]\nfor i in range(len(b)):\n    xmin[i],xmax[i],ymin[i],ymax[i] = min(x[b[i]]),max(x[b[i]]),min(y[b[i]]),max(y[b[i]])\n\nmax_size = i = j = 0\nwhile j < len(b) - 1:\n    for k in range(j,-1,-1):\n        if b[k] + d < b[j]:\n            break\n        i = k\n    for k in range(i,len(b)):\n        if b[i] + d < b[k]:\n            break\n        j = k\n    size = (max(xmax[i:j + 1]) - min(xmin[i:j + 1])) * (max(ymax[i:j + 1]) - min(ymin[i:j + 1]))\n    max_size = max(max_size,size)\n    j+=1\n    \nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "import sys\nf = sys.stdin\n\ndef q(t,s,e,func):\n    if s == e:\n        return t[s]\n    else:\n        return func(q(t,s,(s+e)//2,func),q(t,(s+e)//2 + 1,e,func))\n\n_, d = map(int, f.readline().split())\n\nb = []\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    b.append((bi,xi,yi))\nb = sorted(b)\nx = tuple(xi for _,xi,_ in b)\ny = tuple(yi for _,_,yi in b)\n\nmax_size = i = j = 0\nwhile j < len(b) - 1:\n    for k in range(j,-1,-1):\n        if b[k][0] + d < b[j][0]:\n            break\n        i = k\n    for k in range(i,len(b)):\n        if b[i][0] + d < b[k][0]:\n            break\n        j = k\n\n    max_size = max(max_size,(q(x,i,j,max) - q(x,i,j,min)) * (q(y,i,j,max) - q(y,i,j,min)))\n    j+=1\n    \nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\nfrom itertools import takewhile\nfrom random import randint\nfrom array import array\n\ndef make_data(n):\n  return [str(randint(0,2000000))+' '+str(randint(0,2000000))+' '+str(randint(0,1e9))\n      for i in range(n)]\n\ndef get_square(x_min,x_max,y_min,y_max):\n  return (x_max - x_min) * (y_max - y_min)\n\nN,d = map(int,input().split())\nL = [tuple(map(int,i.split())) for i in stdin.readlines()]\n#L = [tuple(map(int,i.split())) for i in make_data(N)]\nB = sorted(set([i[2] for i in L]))\nD = {i:[] for i in B}\n[D[i[2]].append((i[0],i[1])) for i in L]\nfor k,v in D.items():\n  i = tuple(zip(*v))\n  D[k] = array('L',(min(i[0]),max(i[0]),min(i[1]),max(i[1])))\nprint('test1')\nMax = B[-1]\nresult = 0\n\nfor i in range(len(B)):\n  b = B[i] + d\n  L2 = (D[j] for j in \n      takewhile(\n        lambda x: x <= b, \n        (B[n] for n in range(i,len(B)))\n        ))\n  L3 = tuple(zip(*L2))\n  s = get_square(min(L3[0]),max(L3[1]),min(L3[2]),max(L3[3]))\n  #s = (max(L3[1]) - min(L3[0])) * (max(L3[3]) - min(L3[2]))\n  if result < s:result = s\n  if b > Max:break\nprint(result)"
  },
  {
    "language": "Python",
    "code": "from functools import reduce\nfrom math import ceil, sqrt\nfrom copy import copy\n\n\nclass Bound:\n    min_x = 2000001\n    min_y = 2000001\n    max_x = -1\n    max_y = -1\n    added = False\n\n    def add(self, x, y):\n        self.added = True\n        if self.min_x > x: self.min_x = x\n        if self.min_y > y: self.min_y = y\n        if self.max_x < x: self.max_x = x\n        if self.max_y < y: self.max_y = y\n\n    def expand(self, bound):\n        if bound.added:\n            if not self.added:\n                return copy(bound)\n            if self.min_x > bound.min_x: self.min_x = bound.min_x\n            if self.min_y > bound.min_y: self.min_y = bound.min_y\n            if self.max_x < bound.max_x: self.max_x = bound.max_x\n            if self.max_y < bound.max_y: self.max_y = bound.max_y\n        return self\n\n    def area(self):\n        return (self.max_x - self.min_x) * (self.max_y - self.min_y) if self.max_x > -1 else 0\n\n    @classmethod\n    def expand_list(cls, bounds):\n        return reduce(cls.expand, bounds[1:], copy(bounds[0]))\n\n    def __str__(self):\n        return '({},{},{},{})'.format(self.min_x, self.min_y, self.max_x, self.max_y)\n\n\nclass Bucket:\n    def __init__(self, bounds, unit):\n        self.unit = unit\n        self.bucket = [self.create_unit(bounds, i, i + unit) for i in range(0, max_b + 1, unit)]\n\n    @staticmethod\n    def create_unit(bounds, s, t):\n        b = bounds[s:t]\n        return (Bound.expand_list(b), b)\n\n    def get_range(self, s, t):\n        unit = self.unit\n        sd, sm = s // unit, s % unit\n        td, tm = t // unit, t % unit\n        if sd == td:\n            return Bound.expand_list(self.bucket[sd][1][sm:tm + 1])\n        else:\n            b_list = [b[0] for b in self.bucket[sd + 1:td]]\n            bound = Bound.expand_list(b_list) if b_list else Bound()\n            s_list = self.bucket[sd][1][sm:]\n            if s_list:\n                bound = bound.expand(Bound.expand_list(s_list))\n            t_list = self.bucket[td][1][:tm + 1]\n            if t_list:\n                bound = bound.expand(Bound.expand_list(t_list))\n            return bound\n\n\nn, d = map(int, input().split())\ninput_store = set()\nmax_b = -1\n\nwhile n:\n    x, y, b = map(int, input().split())\n    input_store.add((x, y, b))\n    if b > max_b: max_b = b\n    n -= 1\n\nstars = [Bound() for _ in range(max_b + 1)]\nfor x, y, b in input_store:\n    stars[b].add(x, y)\n\nif d > max_b:\n    print(reduce(Bound.expand, stars[1:], stars[0]).area())\nelse:\n    unit = ceil(sqrt(d + 1))\n    if unit < 2:\n        print(max(Bound.expand_list(stars[i:i + d + 1]).area() for i in range(max_b - d + 1)))\n    else:\n        star_buckets = Bucket(stars, unit)\n        print(max(star_buckets.get_range(i + 1, i + d + 1).area() for i in range(max_b - d + 1)))"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_right as br\nclass SegTree:\n  def __init__(self, num, lst):\n    num_ = 1\n    while num_ < num:\n      num_ *= 2\n    self.length = num_ * 2 - 1\n    self.arr = [None] * (num_ * 2 - 1)\n    for i in range(num):\n      x1, x2, y1, y2 = lst[i]\n      self.arr[num_ - 1 + i] = (x1, x2, y1, y2, i, i)\n\n    self.make(0)\n\n  def make(self, num):\n    if num >= self.length:\n      return None\n    if self.arr[num] != None:\n      return self.arr[num]\n    else:\n      self.arr[num] = self.con(self.make(num * 2 + 1), self.make(num * 2 + 2))\n      return self.arr[num]\n  \n  def con(self, n1, n2):\n    if n1 != None and n2 != None:\n      r0, r1, r2, r3 = self.get_min(n1[:4], n2[:4])\n      return (r0, r1, r2, r3, n1[4], n2[5])\n    if n1 != None:\n      return n1\n    if n2 != None:\n      return n2\n    return None\n\n  def query(self, l, r, num):\n    node = self.arr[num]\n    if node == None:\n      return None\n    if l <= node[4] and node[5] <= r:\n      return node[:4]\n    elif r < node[4] or node[5] < l:\n      return None\n    else:\n      x1 = self.query(l, r, num * 2 + 1)\n      x2 = self.query(l, r, num * 2 + 2)\n      if x1 == None and x2 == None:\n        return None\n      if x1 == None:\n        return x2\n      if x2 == None:\n        return x1\n      return self.get_min(x1, x2)\n  \n  def get_min(self, t1, t2):\n    t10, t11, t12, t13 = t1\n    t20, t21, t22, t23 = t2\n    if t10 < t20:\n      r0 = t10\n    else:\n      r0 = t20\n    if t11 < t21:\n      r1 = t21\n    else:\n      r1 = t11\n    if t12 < t22:\n      r2 = t12\n    else:\n      r2 = t22\n    if t13 < t23:\n      r3 = t23\n    else:\n      r3 = t13\n    return (r0, r1, r2, r3)\n\n\n\n\ndef main():\n  n, d = map(int, input().split())\n  stars = []\n  blst = []\n  for _ in range(n):\n    x, y, b = map(int, input().split())\n    stars.append((b, x, y))\n    blst.append(b)\n  blst.sort()\n  stars.sort()\n  stars = [(x, x, y, y) for _,x, y in stars]\n\n  tree = SegTree(n, stars)\n  ans = 0\n  min_l = -1\n  max_r = 0\n  for l in range(n):\n    if min_l == l:\n      continue\n    min_l = l\n    r = br(blst, blst[l] + d)\n    if r == n:\n      r -= 1\n    elif blst[r] != blst[l] + d:\n      r -= 1\n    if r > max_r:\n      a = tree.query(l, r, 0)\n      ans = max((a[1] - a[0]) * (a[3] - a[2]), ans)\n      max_r = r\n  print(ans)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_right as br\n\ndef make_arr(num, lst):\n  num_ = 1\n  while num_ < num:\n    num_ *= 2\n  length = num_ * 2 - 1\n  arr = [None] * (num_ * 2 - 1)\n  for i in range(num):\n    x1, x2, y1, y2 = lst[i]\n    arr[num_ - 1 + i] = (x1, x2, y1, y2, i, i)\n\n  make(arr, length, 0)\n  return arr\n\ndef make(arr, length, num):\n  if num >= length:\n    return None\n  if arr[num] != None:\n    return arr[num]\n  else:\n    arr[num] = con(make(arr, length, num * 2 + 1), make(arr, length, num * 2 + 2))\n    return arr[num]\n  \ndef con(n1, n2):\n  if n1 != None and n2 != None:\n    r0, r1, r2, r3 = get_min(n1[:4], n2[:4])\n    return (r0, r1, r2, r3, n1[4], n2[5])\n  if n1 != None:\n    return n1\n  if n2 != None:\n    return n2\n  return None\n\ndef query(arr, l, r, num):\n  node = arr[num]\n  if node == None:\n    return None\n  ln, rn = node[4], node[5]\n  if l <= ln and rn <= r:\n    return node[:4]\n  elif r < ln or rn < l:\n    return None\n  else:\n    x1 = query(arr, l, r, num * 2 + 1)\n    x2 = query(arr, l, r, num * 2 + 2)\n    if x1 == None and x2 == None:\n      return None\n    if x1 == None:\n      return x2\n    if x2 == None:\n      return x1\n    return get_min(x1, x2)\n  \ndef get_min(t1, t2):\n  t10, t11, t12, t13 = t1\n  t20, t21, t22, t23 = t2\n  if t10 < t20:\n    r0 = t10\n  else:\n    r0 = t20\n  if t11 < t21:\n    r1 = t21\n  else:\n    r1 = t11\n  if t12 < t22:\n    r2 = t12\n  else:\n    r2 = t22\n  if t13 < t23:\n    r3 = t23\n  else:\n    r3 = t13\n  return (r0, r1, r2, r3)\n\n\n\n\ndef main():\n  n, d = map(int, input().split())\n  stars = []\n  blst = []\n  for _ in range(n):\n    x, y, b = map(int, input().split())\n    stars.append((b, x, y))\n    blst.append(b)\n  blst.sort()\n  stars.sort()\n  stars = [(x, x, y, y) for _, x, y in stars]\n\n  arr = make_arr(n, stars)\n  ans = 0\n  min_l = -1\n  max_r = 0\n  for l in range(n):\n    if min_l == l:\n      continue\n    min_l = l\n    r = br(blst, blst[l] + d)\n    if r == n:\n      r -= 1\n    elif blst[r] != blst[l] + d:\n      r -= 1\n    if r > max_r:\n      a = query(arr, l, r, 0)\n      ans = max((a[1] - a[0]) * (a[3] - a[2]), ans)\n      max_r = r\n  print(ans)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\n\ndef get_square(L):\n  if not L or len(L) == 0:return 0\n  x=[L[0][0][0],L[0][0][1]]\n  y=[L[0][1][0],L[0][1][1]]\n  for i in L:\n    if i[0][0] < x[0]:x[0] = i[0][0]\n    if i[0][1] > x[1]:x[1] = i[0][1]\n    if i[1][0] < y[0]:y[0] = i[1][0]\n    if i[1][1] > y[1]:y[1] = i[1][1]\n  return (x[1] - x[0]) * (y[1] - y[0])\n\ndef get_xy(b,L):\n  if not L or len(L) == 0:return None\n  x=[L[0][0],L[0][0]]\n  y=[L[0][1],L[0][1]]\n  for i in L:\n    if i[0] < x[0]:x[0] = i[0]\n    elif i[0] > x[1]:x[1] = i[0]\n    if i[1] < y[0]:y[0] = i[1]\n    elif i[1] > y[1]:y[1] = i[1]\n  return (b,x,y)\n\nN,d = map(int,input().split())\nL = sorted([list(map(int,i.split())) for i in stdin.readlines()],key=itemgetter(2))\nB = set([i[2] for i in L])\nD = [get_xy(n,[i for i in L if i[2] == n]) for n in B]\n\ni = 0\nresult = 0\nwhile i < len(D):\n  m = D[i][0] + d\n  L = [D[i][1:3]]\n  j = i+1\n  while j < len(D) and D[j][0] <= m:\n    L.append(D[j][1:3])\n    j += 1\n  s = get_square(L)\n  if result < s:result = s\n  i += 1\n\nprint(result)"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_right as br\n\nclass Node:\n  def __init__(self, val, sec):\n    self.val = val\n    self.sec = sec\n    self.left = sec[0]\n    self.right = sec[1]\n    self.minx = val[0]\n    self.maxx = val[1]\n    self.miny = val[2]\n    self.maxy = val[3]\n\nclass SegTree:\n  def __init__(self, num, lst):\n    num_ = 1\n    while num_ < num:\n      num_ *= 2\n    self.length = num_ * 2 - 1\n    self.arr = [None] * (num_ * 2 - 1)\n    for i in range(num):\n      self.arr[num_ - 1 + i] = Node(lst[i], (i, i))\n\n    self.make(0)\n\n  def make(self, num):\n    if num >= self.length:\n      return None\n    if self.arr[num] != None:\n      return self.arr[num]\n    else:\n      self.arr[num] = self.con(self.make(num * 2 + 1), self.make(num * 2 + 2))\n      return self.arr[num]\n  \n  def con(self, n1, n2):\n    if n1 != None and n2 != None:\n      return Node((min(n1.minx, n2.minx), max(n1.maxx, n2.maxx), min(n1.miny, n2.miny), max(n1.maxy, n2.maxy)),\n                  (n1.left, n2.right))\n    if n1 != None:\n      return n1\n    if n2 != None:\n      return n2\n    return None\n\n  def query(self, l, r, num):\n    node = self.arr[num]\n    if node == None:\n      return None\n    if l <= node.left and node.right <= r:\n      return node.val\n    elif r < node.left or node.right < l:\n      return None\n    else:\n      x1 = self.query(l, r, num * 2 + 1)\n      x2 = self.query(l, r, num * 2 + 2)\n      if x1 == None and x2 == None:\n        return None\n      if x1 == None:\n        return x2\n      if x2 == None:\n        return x1\n      return (min(x1[0], x2[0]), max(x1[1], x2[1]), min(x1[2], x2[2]), max(x1[3], x2[3]))\n\ndef main():\n  n, d = map(int, input().split())\n  stars = []\n  blst = []\n  for _ in range(n):\n    x, y, b = map(int, input().split())\n    stars.append((x, y, b))\n    blst.append(b)\n  blst.sort()\n  stars.sort(key=lambda t:t[2])\n  stars = [(x, x, y, y) for x, y, _ in stars]\n\n  tree = SegTree(n, stars)\n  ans = 0\n  max_r = 0\n  for l in range(n):\n    r = br(blst, blst[l] + d)\n    if r == n:\n      r -= 1\n    elif blst[r] != blst[l] + d:\n      r -= 1\n    if r > max_r:\n      a = tree.query(l, r, 0)\n      ans = max((a[1] - a[0]) * (a[3] - a[2]), ans)\n      max_r = r\n  print(ans)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import math\nimport array\ndef segmentTree(dat, f, sentinel):\n        pad = 2 ** math.ceil(math.log(len(dat),2))\n        dat = array.array('L',[0] * pad + dat + [sentinel] * (pad - len(dat)))\n        for i in range(pad - 1, 0, -1):\n            dat[i] = f(dat[i * 2:i * 2 + 2])\n        return dat\n\nimport sys\nf = sys.stdin\n\n\n_, d = map(int, f.readline().split())\n\nx,y = {},{}\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    try:#if key not in dict よりtry exceptの方が早い\n        x[bi].append(xi)\n        y[bi].append(yi)\n    except KeyError:\n        x[bi],y[bi] = [xi],[yi]\n\nb = sorted(x.keys())\n\nxmax = segmentTree([max(x[bi]) for bi in b],max,sentinel = 0)\nxmin = segmentTree([min(x[bi]) for bi in b],min,sentinel = 2000000)\nymax = segmentTree([max(y[bi]) for bi in b],max,sentinel = 0)\nymin = segmentTree([min(y[bi]) for bi in b],min,sentinel = 2000000)\n\ndef get_lr(b,d):\n    l = r = 0\n    while r < len(b):\n        while b[l] + d < b[r]:\n            l += 1\n        for r in range(r,len(b)):\n            if b[l] + d < b[r]:\n                r -= 1\n                break\n        r += 1\n        yield l,r\n        l += 1\n    \nsize = []\nsa = size.append #万単位で呼び出す場合は若干早くなる\npad = len(xmax) // 2\nfor l,r in get_lr(b,d):\n    # 参照するsegmentのindexを生成　※速度のためインライン展開\n    l += pad \n    r += pad\n    index = []\n    ia = index.append\n    while l < r:\n        if r & 1:\n            r -= 1\n            ia(r)\n        if l & 1:\n            ia(l)\n            l += 1\n        l >>= 1\n        r >>= 1\n\n    sa((max(xmax[i] for i in index)\n                 - min(xmin[i] for i in index))\n                * (max(ymax[i] for i in index)\n                   - min(ymin[i] for i in index)))\nprint(max(size))"
  },
  {
    "language": "Python",
    "code": "from math import ceil\nclass sqrt_tree:\n    def __init__(self,dat,f):\n        self.dat = dat\n        self.sq = int(len(dat) ** 0.5)\n        self.f = f\n        self.baqet = [self.f(dat[i * self.sq:(i + 1) * self.sq]) for i in range(self.sq)]\n    \n    #query\n    def q(self,l,r):\n        r += 1\n        if ceil(l / self.sq) >= r // self.sq:\n            return self.f(self.dat[l:r])\n        ret = self.f(self.baqet[ceil(l / self.sq):r // self.sq])\n        if l % self.sq:\n            ret = self.f(ret,self.f(self.dat[l:l + self.sq]))\n        if r % self.sq:\n            ret = self.f(ret,self.f(self.dat[r - r % self.sq:r]))\n        return ret\n\nimport sys\nf = sys.stdin\n\n_, d = map(int, f.readline().split())\n\nx,y = {},{}\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    if bi not in x:\n        x[bi],y[bi] = [],[]\n    x[bi].append(xi)\n    y[bi].append(yi)\n\nb = sorted(x.keys())\n\nxmax = sqrt_tree([max(x[bi]) for bi in b],max)\nxmin = sqrt_tree([min(x[bi]) for bi in b],min)\nymax = sqrt_tree([max(y[bi]) for bi in b],max)\nymin = sqrt_tree([min(y[bi]) for bi in b],min)\n\ndef get_lr(b,d):\n    l = r = 0\n    while r < len(b) - 1:\n        for k in range(r,-1,-1):\n            if b[k] + d < b[r]:\n                break\n            l = k\n        for k in range(l,len(b)):\n            if b[l] + d < b[k]:\n                break\n            r = k\n        yield l,r\n        r += 1\n   \nmax_size = max((xmax.q(l,r) - xmin.q(l,r)) * (ymax.q(l,r) - ymin.q(l,r)) for l,r in get_lr(b,d))\nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "import math\nclass SegmentTree:\n    def __init__(self, dat, func, sentinel):\n        self.pad = 2 ** math.ceil(math.log(len(dat),2)) - 1\n        self.dat = [None] * self.pad + dat + [sentinel] * (self.pad + 1 - len(dat))\n        self.func = func\n        self.sentinel = sentinel\n        for i in range(self.pad - 1, -1, -1):\n            self.dat[i] = self.func(self.dat[i * 2 + 1],self.dat[i * 2 + 2])\n        \n    def q(self,s,e):\n        return self._q(self.pad + s,self.pad + e,0,self.pad,len(self.dat) - 1)\n    def _q(self,a,b,k,l,r):\n        if b < l or r < a:\n            return self.sentinel\n        elif a <= l and r <= b:\n            return self.dat[k]\n        else:\n            vl = self._q(a,b,k * 2 + 1,l,(l+r)//2)\n            vr = self._q(a,b,k * 2 + 2,(l+r)//2 + 1,r)\n            return self.func(vl,vr)\nimport sys\nf = sys.stdin\n\n_, d = map(int, f.readline().split())\n\nb = []\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    b.append((bi,xi,yi))\nb = sorted(b)\nx = [xi for _,xi,_ in b]\ny = [yi for _,_,yi in b]\n\n\n        \nminx = SegmentTree(x,min,sentinel = 2000001)\nmaxx = SegmentTree(x,max,sentinel = -1)\nminy = SegmentTree(y,min,sentinel = 2000001)\nmaxy = SegmentTree(y,max,sentinel = -1)\n\n\nmax_size = i = j = 0\nwhile j < len(b) - 1:\n    for k in range(j,-1,-1):\n        if b[k][0] + d < b[j][0]:\n            break\n        i = k\n    for k in range(i,len(b)):\n        if b[i][0] + d < b[k][0]:\n            break\n        j = k\n    \n    max_size = max(max_size,(maxx.q(i,j) - minx.q(i,j)) * (maxy.q(i,j) - miny.q(i,j)))\n    j+=1\n    \nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\n\ndef get_square(L):\n  if not L or len(L) == 0:return 0\n  x=[L[0][0][0],L[0][0][1]]\n  y=[L[0][1][0],L[0][1][1]]\n  for i in L:\n    if i[0][0] < x[0]:x[0] = i[0][0]\n    if i[0][1] > x[1]:x[1] = i[0][1]\n    if i[1][0] < y[0]:y[0] = i[1][0]\n    if i[1][1] > y[1]:y[1] = i[1][1]\n  return (x[1] - x[0]) * (y[1] - y[0])\n\ndef get_xy(b,L):\n  if not L or len(L) == 0:return None\n  x=[L[0][0],L[0][0]]\n  y=[L[0][1],L[0][1]]\n  for i in L:\n    if i[0] < x[0]:x[0] = i[0]\n    elif i[0] > x[1]:x[1] = i[0]\n    if i[1] < y[0]:y[0] = i[1]\n    elif i[1] > y[1]:y[1] = i[1]\n  return (b,x,y)\n\nN,d = map(int,input().split())\nL = set([tuple(map(int,i.split())) for i in stdin.readlines()])\nB = set([i[2] for i in L])\nD = [get_xy(n,[i for i in L if i[2] == n]) for n in B]\n\ni = 0\nresult = 0\nwhile i < len(D):\n  m = D[i][0] + d\n  L = [D[i][1:3]]\n  j = i+1\n  while j < len(D) and D[j][0] <= m:\n    L.append(D[j][1:3])\n    j += 1\n  s = get_square(L)\n  if result < s:result = s\n  i += 1\n\nprint(result)"
  },
  {
    "language": "Python",
    "code": "import math\ndef segmentTree(dat, f, sentinel):\n        pad = 2 ** math.ceil(math.log(len(dat),2))\n        dat = [None] * pad + dat + [sentinel] * (pad - len(dat))\n        for i in range(pad - 1, 0, -1):\n            dat[i] = f(dat[i * 2:i * 2 + 2])\n        return dat\nimport sys\nf = sys.stdin\n\n_, d = map(int, f.readline().split())\n\nx,y = {},{}\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    try:#if key not in dict よりtry exceptの方が早い\n        x[bi].append(xi)\n        y[bi].append(yi)\n    except KeyError:\n        x[bi],y[bi] = [xi],[yi]\n\nb = sorted(x.keys())\n\nxmax = segmentTree([max(x[bi]) for bi in b],max,sentinel = -1)\nxmin = segmentTree([min(x[bi]) for bi in b],min,sentinel = 2000001)\nymax = segmentTree([max(y[bi]) for bi in b],max,sentinel = -1)\nymin = segmentTree([min(y[bi]) for bi in b],min,sentinel = 2000001)\n\ndef get_lr(b,d):\n    l = r = 0\n    while r < len(b):\n        while b[l] + d < b[r]:\n            l += 1\n        for r in range(r,len(b)):\n            if b[l] + d < b[r]:\n                r -= 1\n                break\n        r += 1\n        yield l,r\n        l += 1\n\nsize = []\nsa = size.append #万単位で呼び出す場合は若干早くなる\npad = len(xmax) // 2\nfor l,r in get_lr(b,d):\n    # 参照するsegmentのindexを生成　※速度のためインライン展開\n    l += pad \n    r += pad\n    index = []\n    ia = index.append\n    while l < r:\n        if r & 1:\n            r -= 1\n            ia(r)\n        if l & 1:\n            ia(l)\n            l += 1\n        l >>= 1\n        r >>= 1\n\n    sa((max(xmax[i] for i in index)\n                 - min(xmin[i] for i in index))\n                * (max(ymax[i] for i in index)\n                   - min(ymin[i] for i in index)))\nprint(max(size))    "
  },
  {
    "language": "Python",
    "code": "import sys\nf = sys.stdin\n\n\ndef memoize(f):\n  memo = {}\n  def inner(v1,v2,v3,v4):\n      if not (v1,v2,v3,v4) in memo:\n        memo[v1,v2,v3,v4] = f(v1,v2,v3,v4)\n      return memo[v1,v2,v3,v4]\n  return inner\n\n@memoize\ndef q(t,s,e,func):\n    if s == e:\n        return t[s]\n    else:\n        return func(q(t,s,(s+e)//2,func),q(t,(s+e)//2 + 1,e,func))\n\n_, d = map(int, f.readline().split())\n\nb = []\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    b.append((bi,xi,yi))\nb = sorted(b)\nx = tuple(xi for _,xi,_ in b)\ny = tuple(yi for _,_,yi in b)\n\nmax_size = i = j = 0\nwhile j < len(b) - 1:\n    for k in range(j,-1,-1):\n        if b[k][0] + d < b[j][0]:\n            break\n        i = k\n    for k in range(i,len(b)):\n        if b[i][0] + d < b[k][0]:\n            break\n        j = k\n\n    max_size = max(max_size,(q(x,i,j,max) - q(x,i,j,min)) * (q(y,i,j,max) - q(y,i,j,min)))\n    j+=1\n    \nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\nfrom itertools import takewhile\nfrom random import randint\n\ndef make_data(n):\n  return [str(randint(0,2000000))+' '+str(randint(0,2000000))+' '+str(randint(0,1e9))\n      for i in range(n)]\n\ndef get_square(x_min,x_max,y_min,y_max):\n  return (x_max - x_min) * (y_max - y_min)\n\nN,d = map(int,input().split())\nL = [tuple(map(int,i.split())) for i in stdin.readlines()]\n#L = [tuple(map(int,i.split())) for i in make_data(N)]\nB = sorted(set([i[2] for i in L]))\nD = {i:[] for i in B}\n[D[i[2]].append((i[0],i[1])) for i in L]\nfor k,v in D.items():\n  i = tuple(zip(*v))\n  D[k] = (min(i[0]),max(i[0]),min(i[1]),max(i[1]))\n\nMax = B[-1]\nresult = 0\n\ni = 0\nwhile i < len(B):\n  b = B[i] + d\n  L2 = [D[j] for j in \n      takewhile(\n        lambda x: x <= b, \n        (B[n] for n in range(i,len(B)))\n        ) ]\n  L3 = tuple(zip(*L2))\n  s = get_square(min(L3[0]),max(L3[1]),min(L3[2]),max(L3[3]))\n  if result < s:result = s\n  if B[i]+d > Max:break\n  i += 1\nprint(result)"
  },
  {
    "language": "Python",
    "code": "import operator\nfrom collections import deque\nN, d = map(int, input().split())\nP = [list(map(int, input().split())) for i in range(N)]\nP.sort(key=operator.itemgetter(2))\nxd_min = deque()\nxd_max = deque()\nyd_min = deque()\nyd_max = deque()\ns = -1; t = 0\nans = 0\nwhile t < N:\n    t0 = t\n    while t < N-1 and P[t][2] == P[t+1][2]:\n        t += 1\n    b = P[t][2]\n    while b - P[s+1][2] > d:\n        s += 1\n\n    while xd_min and xd_min[0][0] <= s:\n        xd_min.popleft()\n    while xd_max and xd_max[0][0] <= s:\n        xd_max.popleft()\n    while yd_min and yd_min[0][0] <= s:\n        yd_min.popleft()\n    while yd_max and yd_max[0][0] <= s:\n        yd_max.popleft()\n\n    for i in range(t0, t+1):\n        x, y, b = P[i]\n        while xd_min and x <= xd_min[-1][1]:\n            xd_min.pop()\n        xd_min.append((i, x))\n        while xd_max and xd_max[-1][1] <= x:\n            xd_max.pop()\n        xd_max.append((i, x))\n        while yd_min and y <= yd_min[-1][1]:\n            yd_min.pop()\n        yd_min.append((i, y))\n        while yd_max and yd_max[-1][1] <= y:\n            yd_max.pop()\n        yd_max.append((i, y))\n\n    r = (xd_max[0][1] - xd_min[0][1]) * (yd_max[0][1] - yd_min[0][1])\n    ans = max(ans, r)\n\n    t += 1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  INF = 10 ** 20\n\n  class MinTree:\n    def __init__(self, iterable):\n      self.iter_size = self.get_size(iterable)\n      self.size = self.iter_size * 2 - 1\n      self.value = [None] * self.size\n      for i, v in enumerate(iterable):\n        self.value[self.iter_size + i - 1] = v\n      self.set_value(0)\n      self.range = [None] * self.size\n      self.set_range(0, 0, self.iter_size - 1)\n \n    \n    def get_size(self, iterable):\n      ret = 1\n      x = len(iterable)\n      while ret < x:\n        ret *= 2\n      return ret\n\n    def set_range(self, x, left, right):\n      self.range[x] = (left, right)\n      if left != right:\n        self.set_range(x * 2 + 1, left, (right + left) // 2)\n        self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n    def set_value(self, x):\n      if x >= self.iter_size - 1:return self.value[x]\n      a = self.set_value(x * 2 + 1)\n      b = self.set_value(x * 2 + 2)\n      if a == None and b == None:\n        self.value[x] = None\n      elif a == None:\n        self.value[x] = b\n      elif b == None:\n        self.value[x] = a\n      else:\n        self.value[x] = a if a < b else b\n      return self.value[x]\n  \n    def query(self, x, left, right):\n      x_left, x_right = self.range[x]\n      if right < x_left or x_right < left:\n        return INF\n      if left <= x_left and x_right <= right:\n        return self.value[x]\n  \n      return min(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n  \n  \n  class MaxTree:\n    def __init__(self, iterable):\n      self.iter_size = self.get_size(iterable)\n      self.size = self.iter_size * 2 - 1\n      self.value = [None] * self.size\n      for i, v in enumerate(iterable):\n        self.value[self.iter_size + i - 1] = v\n      self.set_value(0)\n      self.range = [None] * self.size\n      self.set_range(0, 0, self.iter_size - 1)\n    \n    def get_size(self, iterable):\n      ret = 1\n      x = len(iterable)\n      while ret < x:\n        ret *= 2\n      return ret\n    \n    def set_range(self, x, left, right):\n      self.range[x] = (left, right)\n      if left != right:\n        self.set_range(x * 2 + 1, left, (right + left) // 2)\n        self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n\n    def set_value(self, x):\n      if x >= self.iter_size - 1:return self.value[x]\n      a = self.set_value(x * 2 + 1)\n      b = self.set_value(x * 2 + 2)\n      if a == None and b == None:\n        self.value[x] = None\n      elif a == None:\n        self.value[x] = b\n      elif b == None:\n        self.value[x] = a\n      else:\n        self.value[x] = a if a > b else b\n      return self.value[x]\n  \n    def query(self, x, left, right):\n      x_left, x_right = self.range[x]\n      if right < x_left or x_right < left:\n        return 0\n      if left <= x_left and x_right <= right:\n        return self.value[x]\n  \n      return max(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n  \n  from bisect import bisect_right as br\n\n  n, d = map(int, input().split())\n  lst = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x:x[2])\n  sorted_x = []\n  sorted_y = []\n  keys = []\n  for i in range(n):\n    x, y, b = lst[i]\n    sorted_x.append(x)\n    sorted_y.append(y)\n    keys.append(b)\n  mxt = MinTree(sorted_x)\n  Mxt = MaxTree(sorted_x)\n  myt = MinTree(sorted_y)\n  Myt = MaxTree(sorted_y)\n  \n  def score(left, right):\n    return (Mxt.query(0, left, right) - mxt.query(0, left, right)) * \\\n           (Myt.query(0, left, right) - myt.query(0, left, right))\n  \n  left = 0\n  right = br(keys, keys[0] + d) - 2\n  mx = mxt.query(0, left, right)\n  Mx = Mxt.query(0, left, right)\n  my = myt.query(0, left, right)\n  My = Myt.query(0, left, right)\n  mxf = Mxf = myf = Myf = False\n  end = len(keys)\n  ans = 0\n  while True:\n    right += 1\n    if right == end:break\n    \n    if sorted_x[right] > Mx:Mx = sorted_x[right]\n    if sorted_x[right] < mx:mx = sorted_x[right] \n    if sorted_y[right] > My:My = sorted_y[right]\n    if sorted_y[right] < my:my = sorted_y[right]\n    \n    Mx_flag = mx_flag = My_flag = my_flag = False\n    while keys[left] + d <= keys[right]:\n      if sorted_x[left] == Mx:Mx_flag = True\n      if sorted_x[left] == mx:mx_flag = True\n      if sorted_y[left] == My:My_flag = True\n      if sorted_y[left] == my:my_flag = True\n      left += 1\n    left -= 1\n    \n    if Mx_flag:Mx = Mxt.query(0, left, right)\n    if mx_flag:mx = mxt.query(0, left, right)\n    if My_flag:My = Myt.query(0, left, right)\n    if my_flag:my = myt.query(0, left, right)\n    \n    ans = max(ans, (Mx - mx) * (My - my)) \n  \n  if left < end and right < end:\n    ans = max(ans, score(left, right))\n  print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\nfrom itertools import takewhile\nfrom random import randint\nfrom array import array\n\ndef get_square(x_min,x_max,y_min,y_max):\n  return (x_max - x_min) * (y_max - y_min)\n\nN,d = map(int,input().split())\nL = [tuple(map(int,i.split())) for i in make_data(N)]\nB = sorted(set([i[2] for i in L]))\nD = {i:[] for i in B}\n[D[i[2]].append((i[0],i[1])) for i in L]\nfor k,v in D.items():\n  i = tuple(zip(*v))\n  D[k] = array('L',(min(i[0]),max(i[0]),min(i[1]),max(i[1])))\nprint('test1')\nMax = B[-1]\nresult = 0\n\nfor i in range(len(B)):\n  b = B[i] + d\n  L2 = (D[j] for j in \n      takewhile(\n        lambda x: x <= b, \n        (B[n] for n in range(i,len(B)))\n        ))\n  L3 = tuple(zip(*L2))\n  s = get_square(min(L3[0]),max(L3[1]),min(L3[2]),max(L3[3]))\n  if result < s:result = s\n  if b > Max:break\nprint(result)"
  },
  {
    "language": "Python",
    "code": "class MinTree:\n  def __init__(self, iterable):\n    self.iter_size = self.get_size(iterable)\n    self.size = self.iter_size * 2 - 1\n    self.value = [None] * self.size\n    for i, v in enumerate(iterable):\n      self.value[self.iter_size + i - 1] = v\n    self.set_value(0)\n    self.range = [None] * self.size\n    self.set_range(0, 0, self.iter_size - 1)\n  \n  def get_size(self, iterable):\n    ret = 1\n    x = len(iterable)\n    while ret < x:\n      ret *= 2\n    return ret\n  \n  def set_range(self, x, left, right):\n    self.range[x] = (left, right)\n    if left != right:\n      self.set_range(x * 2 + 1, left, (right + left) // 2)\n      self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n  def set_value(self, x):\n    if x >= self.iter_size - 1:return self.value[x]\n    a = self.set_value(x * 2 + 1)\n    b = self.set_value(x * 2 + 2)\n    if a == None and b == None:\n      self.value[x] = None\n    elif a == None:\n      self.value[x] = b\n    elif b == None:\n      self.value[x] = a\n    else:\n      self.value[x] = min(a, b)\n    return self.value[x]\n\n  def query(self, x, left, right):\n    x_left, x_right = self.range[x]\n    if right < x_left or x_right < left:\n      return INF\n    if left <= x_left and x_right <= right:\n      return self.value[x]\n\n    return min(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n\n\nclass MaxTree:\n  def __init__(self, iterable):\n    self.iter_size = self.get_size(iterable)\n    self.size = self.iter_size * 2 - 1\n    self.value = [None] * self.size\n    for i, v in enumerate(iterable):\n      self.value[self.iter_size + i - 1] = v\n    self.set_value(0)\n    self.range = [None] * self.size\n    self.set_range(0, 0, self.iter_size - 1)\n  \n  def get_size(self, iterable):\n    ret = 1\n    x = len(iterable)\n    while ret < x:\n      ret *= 2\n    return ret\n  \n  def set_range(self, x, left, right):\n    self.range[x] = (left, right)\n    if left != right:\n      self.set_range(x * 2 + 1, left, (right + left) // 2)\n      self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n  def set_value(self, x):\n    if x >= self.iter_size - 1:return self.value[x]\n    a = self.set_value(x * 2 + 1)\n    b = self.set_value(x * 2 + 2)\n    if a == None and b == None:\n      self.value[x] = None\n    elif a == None:\n      self.value[x] = b\n    elif b == None:\n      self.value[x] = a\n    else:\n      self.value[x] = max(a, b)\n    return self.value[x]\n\n  def query(self, x, left, right):\n    x_left, x_right = self.range[x]\n    if right < x_left or x_right < left:\n      return 0\n    if left <= x_left and x_right <= right:\n      return self.value[x]\n\n    return max(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n\nfrom bisect import bisect_left as bl\n\nn, d = map(int, input().split())\nlst = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x:x[2])\nsorted_x = []\nsorted_y = []\nkeys_to_ind = {}\nfor i in range(n):\n  x, y, b = lst[i]\n  sorted_x.append(x)\n  sorted_y.append(y)\n  keys_to_ind[b] = i\nkeys = list(keys_to_ind.keys())\n\nmxt = MinTree(sorted_x)\nMxt = MaxTree(sorted_x)\nmyt = MinTree(sorted_y)\nMyt = MaxTree(sorted_y)\n\ndef score(left, right):\n  return (Mxt.query(0, left, right) - mxt.query(0, left, right)) * \\\n         (Myt.query(0, left, right) - myt.query(0, left, right))\n\nINF = 10 ** 20\nkl = 0\nkr = bl(keys, keys[0] + d)\nend = len(keys)\nans = 0\nwhile kr < end:\n  ans = max(ans, score(keys_to_ind[keys[kl]], keys_to_ind[keys[kr]]))\n  kl += 1\n  while keys[kl] + d >= keys[kr]:\n    kr += 1\n    if kr == end:break\n  else:\n    kr -= 1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter as it\nD={}\nresult=[]\nN,d=map(int,input().split())\nfor i in stdin.readlines():\n    x,y,b=map(int,i.split())\n    if b not in D:D[b]=[]\n    D[b].append((x,y))\nfor i in range(max(D)-d+1):\n    l=[]\n    for s in range(d+1):\n        if i+s in D:l+=D[i+s]\n    if len(l)>1:result.append((max(map(it(0),l))-min(map(it(0),l)))*(max(map(it(1),l))-min(map(it(1),l))))\nprint(max(result))"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\nx = [a[p][0] for p in range(stars)]\ny = [a[q][1] for q in range(stars)]\nlight = [a[r][2] for r in range(stars)]\nx.sort()\ny.sort()\nlight.sort()\nX=Y=[]\nk=scale=0\nfor j in range(stars):\n    while(a[k][2] < a[j][2]-lightrange):\n        X.remove(x[k])\n        Y.remove(y[k])\n        k+=1\n    X.append(x[j])\n    Y.append(y[j])\n    scale = max(scale, (X[len(X)-1]-X[0])*(Y[len(Y)-1]-Y[0]))\nprint scale"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom math import ceil, log2\n\n\nclass SegmentTree:\n    left, right = None, None\n\n    def __init__(self, n, bounds, is_min):\n        func = min if is_min else max\n        sentinel = min_sentinel if is_min else max_sentinel\n\n        n2 = 2 ** ceil(log2(n))\n        tree = [sentinel] * (n2 - 1) + bounds + [sentinel] * (n2 - n)\n        for i in range(n2 - 2, -1, -1):\n            tree[i] = func(tree[i * 2 + 1], tree[i * 2 + 2])\n        self.tree = tree\n        self.func = func\n        self.sentinel = sentinel\n        self.create_lr(n2)\n\n    @classmethod\n    def create_lr(cls, n2):\n        if cls.left and cls.right:\n            return\n        left = [0] * (n2 - 1) + list(range(n2))\n        right = [0] * (n2 - 1) + list(range(n2))\n        for i in range(n2 - 2, -1, -1):\n            left[i] = left[i * 2 + 1]\n            right[i] = right[i * 2 + 2]\n        cls.left = left\n        cls.right = right\n\n    @classmethod\n    def get_indexes(cls, s, t, i=0):\n        l, r = cls.left[i], cls.right[i]\n        if l >= s and r <= t:\n            return {i}\n        if l > t or r < s:\n            return set()\n        return cls.get_indexes(s, t, i * 2 + 1) | cls.get_indexes(s, t, i * 2 + 2)\n\n    def get(self, index_set):\n        return self.func(self.tree[i] for i in index_set)\n\n\nn, d = map(int, input().split())\ninput_store = defaultdict(lambda: (set(), set()))\n\nwhile n:\n    x, y, b = map(int, input().split())\n    x_set, y_set = input_store[b]\n    x_set.add(x)\n    y_set.add(y)\n    n -= 1\n\nmin_sentinel, max_sentinel = 2000001, -1\n\nmax_b = max(input_store)\nlist_length = max_b + 1\nstars_min_x = [min_sentinel] * (list_length)\nstars_min_y = [min_sentinel] * (list_length)\nstars_max_x = [max_sentinel] * (list_length)\nstars_max_y = [max_sentinel] * (list_length)\nfor b, xy_set in input_store.items():\n    x_set, y_set = xy_set\n    stars_min_x[b] = min(x_set)\n    stars_min_y[b] = min(y_set)\n    stars_max_x[b] = max(x_set)\n    stars_max_y[b] = max(y_set)\n\nst_min_x = SegmentTree(list_length, stars_min_x, True)\nst_min_y = SegmentTree(list_length, stars_min_y, True)\nst_max_x = SegmentTree(list_length, stars_max_x, False)\nst_max_y = SegmentTree(list_length, stars_max_y, False)\n\nmax_area = 0\n\nfor i in input_store:\n    if i + d > max_b:\n        break\n    i_set = SegmentTree.get_indexes(i, i + d)\n    current_area = (st_max_x.get(i_set) - st_min_x.get(i_set)) * (st_max_y.get(i_set) - st_min_y.get(i_set))\n    if max_area < current_area:\n        max_area = current_area\n\nprint(max_area)"
  },
  {
    "language": "Python",
    "code": "from math import ceil\nclass sqrt_tree:\n    def __init__(self,dat,f):\n        self.dat = dat\n        self.sq = int(len(dat) ** 0.5)\n        self.baqet = {}\n        for fi in f:\n            self.baqet[fi] = [fi(dat[i * self.sq:(i + 1) * self.sq]) for i in range(self.sq)]\n    \n    #query\n    def q(self,f,l,r):\n        r += 1\n        if ceil(l / self.sq) >= r // self.sq:\n            return f(self.dat[l:r])\n        ret = f(self.baqet[f][ceil(l / self.sq):r // self.sq])\n        if l % self.sq:\n            ret = f(ret,f(self.dat[l:l + self.sq]))\n        if r % self.sq:\n            ret = f(ret,f(self.dat[r - r % self.sq:r]))\n        return ret\n\nimport sys\nf = sys.stdin\n\n_, d = map(int, f.readline().split())\n\nb = sorted([tuple(map(int,line.split()))[::-1] for line in f])\n\nx = sqrt_tree([bi[2] for bi in b],[min,max])\ny = sqrt_tree([bi[1] for bi in b],[min,max])\n\nmax_size = i = j = 0\nwhile j < len(b) - 1:\n    for k in range(j,-1,-1):\n        if b[k][0] + d < b[j][0]:\n            break\n        i = k\n    for k in range(i,len(b)):\n        if b[i][0] + d < b[k][0]:\n            break\n        j = k\n\n    max_size = max(max_size,(x.q(max,i,j) - x.q(min,i,j)) * (y.q(max,i,j) - y.q(min,i,j)))\n    j+=1\n    \nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "def main():\n  INF = 10 ** 20\n\n  class MinTree:\n    def __init__(self, iterable):\n      self.iter_size = self.get_size(iterable)\n      self.size = self.iter_size * 2 - 1\n      self.value = [None] * self.size\n      for i, v in enumerate(iterable):\n        self.value[self.iter_size + i - 1] = v\n      self.set_value(0)\n    \n    def get_size(self, iterable):\n      ret = 1\n      x = len(iterable)\n      while ret < x:\n        ret *= 2\n      return ret\n\n    def set_range(self, x, left, right):\n      self.range[x] = (left, right)\n      if left != right:\n        self.set_range(x * 2 + 1, left, (right + left) // 2)\n        self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n    def set_value(self, x):\n      if x >= self.iter_size - 1:return self.value[x]\n      a = self.set_value(x * 2 + 1)\n      b = self.set_value(x * 2 + 2)\n      if a == None and b == None:\n        self.value[x] = None\n      elif a == None:\n        self.value[x] = b\n      elif b == None:\n        self.value[x] = a\n      else:\n        self.value[x] = a if a < b else b\n      return self.value[x]\n  \n    def query(self, x, left, right):\n      x_left, x_right = self.range[x]\n      if right < x_left or x_right < left:\n        return INF\n      if left <= x_left and x_right <= right:\n        return self.value[x]\n      a = self.query(x * 2 + 1, left, right)\n      b = self.query(x * 2 + 2, left, right)\n      return a if a <= b else b\n \n  class MaxTree:\n    def __init__(self, iterable):\n      self.iter_size = self.get_size(iterable)\n      self.size = self.iter_size * 2 - 1\n      self.value = [None] * self.size\n      for i, v in enumerate(iterable):\n        self.value[self.iter_size + i - 1] = v\n      self.set_value(0)\n    \n    def get_size(self, iterable):\n      ret = 1\n      x = len(iterable)\n      while ret < x:\n        ret *= 2\n      return ret\n    \n    def set_range(self, x, left, right):\n      self.range[x] = (left, right)\n      if left != right:\n        self.set_range(x * 2 + 1, left, (right + left) // 2)\n        self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n    def set_value(self, x):\n      if x >= self.iter_size - 1:return self.value[x]\n      a = self.set_value(x * 2 + 1)\n      b = self.set_value(x * 2 + 2)\n      if a == None and b == None:\n        self.value[x] = None\n      elif a == None:\n        self.value[x] = b\n      elif b == None:\n        self.value[x] = a\n      else:\n        self.value[x] = a if a > b else b\n      return self.value[x]\n  \n    def query(self, x, left, right):\n      x_left, x_right = self.range[x]\n      if right < x_left or x_right < left:\n        return 0\n      if left <= x_left and x_right <= right:\n        return self.value[x]\n      a = self.query(x * 2 + 1, left, right)\n      b = self.query(x * 2 + 2, left, right)\n      return a if a >= b else b\n\n  \n  def set_range(lst, x, left, right):\n    lst[x] = (left, right)\n    if left != right:\n      set_range(lst, x * 2 + 1, left, (right + left) // 2)\n      set_range(lst, x * 2 + 2, (right + left) // 2 + 1, right)\n\n  def index_of_query(lst, x, left, right, ret):\n    x_left, x_right = lst[x]\n    if right < x_left or x_right < left:pass\n    elif left <= x_left and x_right <= right:\n      ret.append(x)\n    else:\n      index_of_query(lst, x * 2 + 1, left, right, ret)\n      index_of_query(lst, x * 2 + 2, left, right, ret)\n\n\n\n  from bisect import bisect_right as br\n\n  n, d = map(int, input().split())\n  lst = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x:x[2])\n  sorted_x = []\n  sorted_y = []\n  keys = []\n  for i in range(n):\n    x, y, b = lst[i]\n    sorted_x.append(x)\n    sorted_y.append(y)\n    keys.append(b)\n  mxt = MinTree(sorted_x)\n  Mxt = MaxTree(sorted_x)\n  myt = MinTree(sorted_y)\n  Myt = MaxTree(sorted_y)\n  lst = [None] * mxt.size\n  set_range(lst, 0, 0, mxt.iter_size - 1)\n  mxt.range = lst\n  Mxt.range = lst\n  myt.range = lst\n  Myt.range = lst\n  \n  def score(left, right):\n    return (Mxt.query(0, left, right) - mxt.query(0, left, right)) * \\\n           (Myt.query(0, left, right) - myt.query(0, left, right))\n  \n  left = 0\n  right = br(keys, keys[0] + d) - 1\n  mx = mxt.query(0, left, right)\n  Mx = Mxt.query(0, left, right)\n  my = myt.query(0, left, right)\n  My = Myt.query(0, left, right)\n  end = len(keys)\n  ans = (Mx - mx) * (My - my)\n  Mx_flag = mx_flag = My_flag = my_flag = False\n  while True:\n    right += 1\n    if right == end:break\n    \n    if sorted_x[right] > Mx:Mx = sorted_x[right]\n    if sorted_x[right] < mx:mx = sorted_x[right] \n    if sorted_y[right] > My:My = sorted_y[right]\n    if sorted_y[right] < my:my = sorted_y[right]\n    \n    while keys[left] + d < keys[right]:\n      if sorted_x[left] == Mx:Mx_flag = True\n      if sorted_x[left] == mx:mx_flag = True\n      if sorted_y[left] == My:My_flag = True\n      if sorted_y[left] == my:my_flag = True\n      left += 1\n    \n    ret = []\n    index_of_query(lst, 0, left, right, ret)\n    if Mx_flag:\n      Mx = max(Mxt.value[i] for i in ret)\n      Mx_flag = False\n    if mx_flag:\n      mx = min(mxt.value[i] for i in ret)\n      mx_flag = False\n    if My_flag:\n      My = max(Myt.value[i] for i in ret)\n      My_flag = False\n    if my_flag:\n      my = min(myt.value[i] for i in ret)\n      my_flag = False\n    \n    ans = max(ans, (Mx - mx) * (My - my)) \n  \n  print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from operator import itemgetter\nN,d = map(int,input().split())\nL = [list(map(int,input().split())) for i in range(N)]\nL = sorted(L,key=itemgetter(2,0,1))\n\ndef get_square(L):\n  if not L or len(L) == 0:return 0\n  x=[L[0][0],L[0][0]]\n  y=[L[0][1],L[0][1]]\n  for i in L:\n    if i[0] < x[0]:x[0] = i[0]\n    elif i[0] > x[1]:x[1] = i[0]\n    if i[1] < y[0]:y[0] = i[1]\n    elif i[1] > y[1]:y[1] = i[1]\n  return (x[1] - x[0]) * (y[1] - y[0])\n\nresult = 0\ni = L[0][2]\nj = L[-1][2]\nwhile True:\n  n = i + d\n  l = []\n  while i <= n:\n    l += [x[0:2] for x in L if x[2] == i]\n    i += 1\n  s = get_square(l)\n  if result < s:result = s\n  i -= d\n  if j < i + d:break\nprint(result)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\n\ndef get_square(L):\n  if not L or len(L) == 0:return 0\n  x=[L[0][0][0],L[0][0][1]]\n  y=[L[0][1][0],L[0][1][1]]\n  for i in L:\n    if i[0][0] < x[0]:x[0] = i[0][0]\n    if i[0][1] > x[1]:x[1] = i[0][1]\n    if i[1][0] < y[0]:y[0] = i[1][0]\n    if i[1][1] > y[1]:y[1] = i[1][1]\n  return (x[1] - x[0]) * (y[1] - y[0])\n\ndef get_xy(b,L):\n  if not L or len(L) == 0:return None\n  print('test1')\n  print(L)\n  x = (min(L[0]),max(L[0]))\n  y = (min(L[1]),max(L[1]))\n#  x=[L[0][0],L[0][0]]\n#  y=[L[0][1],L[0][1]]\n#  for i in L:\n#    if i[0] < x[0]:x[0] = i[0]\n#    elif i[0] > x[1]:x[1] = i[0]\n#    if i[1] < y[0]:y[0] = i[1]\n#    elif i[1] > y[1]:y[1] = i[1]\n  return (b,x,y)\n\nN,d = map(int,input().split())\nL = set([tuple(map(int,i.split())) for i in stdin.readlines()])\nB = set([i[2] for i in L])\nprint(L)\nprint(B)\n\nD = [get_xy(n,list(zip(*[i[0:2] for i in L if i[2] == n]))) for n in B]\n\ni = 0\nresult = 0\nwhile i < len(D):\n  m = D[i][0] + d\n  L = [D[i][1:3]]\n  j = i+1\n  while j < len(D) and D[j][0] <= m:\n    L.append(D[j][1:3])\n    j += 1\n  s = get_square(L)\n  if result < s:result = s\n  i += 1\n\nprint(result)"
  },
  {
    "language": "Python",
    "code": "from functools import reduce\nfrom math import ceil, sqrt\nfrom copy import copy\n\n\nclass Bound:\n    min_x = 2000001\n    min_y = 2000001\n    max_x = -1\n    max_y = -1\n    added = False\n\n    def add(self, x, y):\n        self.added = True\n        if self.min_x > x: self.min_x = x\n        if self.min_y > y: self.min_y = y\n        if self.max_x < x: self.max_x = x\n        if self.max_y < y: self.max_y = y\n\n    def expand(self, bound):\n        if bound.added:\n            if not self.added:\n                return bound.clone()\n            if self.min_x > bound.min_x: self.min_x = bound.min_x\n            if self.min_y > bound.min_y: self.min_y = bound.min_y\n            if self.max_x < bound.max_x: self.max_x = bound.max_x\n            if self.max_y < bound.max_y: self.max_y = bound.max_y\n        return self\n\n    def area(self):\n        return (self.max_x - self.min_x) * (self.max_y - self.min_y) if self.max_x > -1 else 0\n\n    @classmethod\n    def expand_list(cls, bounds):\n        return reduce(cls.expand, bounds[1:], bounds[0].clone())\n\n    def clone(self):\n        return copy(self)\n\n    def __str__(self):\n        return '({},{},{},{})'.format(self.min_x, self.min_y, self.max_x, self.max_y)\n\n\nclass Bucket:\n    def __init__(self, bounds, unit):\n        self.unit = unit\n        self.bucket = [self.create_unit(bounds, i, i + unit) for i in range(0, max_b + 1, unit)]\n\n    @staticmethod\n    def create_unit(bounds, s, t):\n        b = bounds[s:t]\n        return (Bound.expand_list(b), b)\n\n    def get_range(self, s, t):\n        unit = self.unit\n        sd, sm = s // unit, s % unit\n        td, tm = t // unit, t % unit\n        if sd == td:\n            return Bound.expand_list(self.bucket[sd][1][sm:tm + 1])\n        else:\n            b_list = [b[0] for b in self.bucket[sd + 1:td]]\n            bound = Bound.expand_list(b_list) if b_list else Bound()\n            s_list = self.bucket[sd][1][sm:]\n            if s_list:\n                bound = bound.expand(Bound.expand_list(s_list))\n            t_list = self.bucket[td][1][:tm + 1]\n            if t_list:\n                bound = bound.expand(Bound.expand_list(t_list))\n            return bound\n\n\nn, d = map(int, input().split())\ninput_store = set()\nmax_b = -1\n\nwhile n:\n    x, y, b = map(int, input().split())\n    input_store.add((x, y, b))\n    if b > max_b: max_b = b\n    n -= 1\n\nstars = [Bound() for _ in range(max_b + 1)]\nfor x, y, b in input_store:\n    stars[b].add(x, y)\n\nif d > max_b:\n    print(reduce(Bound.expand, stars[1:], stars[0]).area())\nelse:\n    unit = ceil(sqrt(d + 1))\n    if unit < 2:\n        print(max(Bound.expand_list(stars[i:i + d + 1]).area() for i in range(max_b - d + 1)))\n    else:\n        star_buckets = Bucket(stars, unit)\n        print(max(star_buckets.get_range(i, i + d).area() for i in range(max_b - d + 1)))"
  },
  {
    "language": "Python",
    "code": "N,d = map(int,input().split())\nL = [list(map(int,input().split())) for i in range(N)]\nL = sorted(L,key=lambda x:x[2])\n\ndef get_square(L):\n  if not L or len(L) == 0:return 0\n  x=[L[0][0],L[0][0]]\n  y=[L[0][1],L[0][1]]\n  for i in L:\n    if i[0] < x[0]:x[0] = i[0]\n    if i[0] > x[1]:x[1] = i[0]\n    if i[1] < y[0]:y[0] = i[1]\n    if i[1] > y[1]:y[1] = i[1]\n  return (x[1] - x[0]) * (y[1] - y[0])\n\nresult = 0\ni = L[0][2]\nj = L[-1][2]\nwhile True:\n  n = i + d\n  l = []\n  while i <= n:\n    l += [x[0:1] for x in L if x[2] == i]\n    i += 1\n  s = get_square(l)\n  if result < s:result = s\n  i -= d\n  if j < i + d:break\nprint(result)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\nfrom itertools import takewhile\nfrom random import randint\nfrom array import array\n\ndef make_data(n):\n  return [str(randint(0,2000000))+' '+str(randint(0,2000000))+' '+str(randint(0,1e9))\n      for i in range(n)]\n\ndef get_square(x_min,x_max,y_min,y_max):\n  return (x_max - x_min) * (y_max - y_min)\n\nN,d = map(int,input().split())\nL = [tuple(map(int,i.split())) for i in stdin.readlines()]\n#L = [tuple(map(int,i.split())) for i in make_data(N)]\nB = sorted(set([i[2] for i in L]))\nD = {i:[] for i in B}\n[D[i[2]].append((i[0],i[1])) for i in L]\nfor k,v in D.items():\n  i = tuple(zip(*v))\n  D[k] = array('L',(min(i[0]),max(i[0]),min(i[1]),max(i[1])))\nMax = B[-1]\nresult = 0\n\nfor i in range(len(B)):\n  b = B[i] + d\n  L2 = (D[j] for j in \n      takewhile(\n        lambda x: x <= b, \n        (B[n] for n in range(i,len(B)))\n        ))\n  L3 = tuple(zip(*L2))\n  s = get_square(min(L3[0]),max(L3[1]),min(L3[2]),max(L3[3]))\n  #s = (max(L3[1]) - min(L3[0])) * (max(L3[3]) - min(L3[2]))\n  if result < s:result = s\n  if b > Max:break\nprint(result)"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda z:(z[2],z[0]))\nx = [a[p][0] for p in range(stars)]\ny = [a[q][1] for q in range(stars)]\nlight = [a[r][2] for r in range(stars)]\nX=[]\nY=[]\nk=0\nscale=0\nfor j in range(stars):\n    while(a[k][2] < a[j][2]-lightrange):\n        X.remove(x[k])\n        Y.remove(y[k])\n        k+=1\n    X.append(x[j])\n    Y.append(y[j])\n    scale = max(scale, (max(X)-min(X))*(max(Y)-min(Y)))\nprint scale"
  },
  {
    "language": "Python",
    "code": "class MinTree:\n  def __init__(self, iterable):\n    self.iter_size = self.get_size(iterable)\n    self.size = self.iter_size * 2 - 1\n    self.value = [None] * self.size\n    for i, v in enumerate(iterable):\n      self.value[self.iter_size + i - 1] = v\n    self.set_value(0)\n    self.range = [None] * self.size\n    self.set_range(0, 0, self.iter_size - 1)\n  \n  def get_size(self, iterable):\n    ret = 1\n    x = len(iterable)\n    while ret < x:\n      ret *= 2\n    return ret\n  \n  def set_range(self, x, left, right):\n    self.range[x] = (left, right)\n    if left != right:\n      self.set_range(x * 2 + 1, left, (right + left) // 2)\n      self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n  def set_value(self, x):\n    if x >= self.iter_size - 1:return self.value[x]\n    a = self.set_value(x * 2 + 1)\n    b = self.set_value(x * 2 + 2)\n    if a == None and b == None:\n      self.value[x] = None\n    elif a == None:\n      self.value[x] = b\n    elif b == None:\n      self.value[x] = a\n    else:\n      self.value[x] = min(a, b)\n    return self.value[x]\n\n  def query(self, x, left, right):\n    x_left, x_right = self.range[x]\n    if right < x_left or x_right < left:\n      return INF\n    if left <= x_left and x_right <= right:\n      return self.value[x]\n\n    return min(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n\n\nclass MaxTree:\n  def __init__(self, iterable):\n    self.iter_size = self.get_size(iterable)\n    self.size = self.iter_size * 2 - 1\n    self.value = [None] * self.size\n    for i, v in enumerate(iterable):\n      self.value[self.iter_size + i - 1] = v\n    self.set_value(0)\n    self.range = [None] * self.size\n    self.set_range(0, 0, self.iter_size - 1)\n  \n  def get_size(self, iterable):\n    ret = 1\n    x = len(iterable)\n    while ret < x:\n      ret *= 2\n    return ret\n  \n  def set_range(self, x, left, right):\n    self.range[x] = (left, right)\n    if left != right:\n      self.set_range(x * 2 + 1, left, (right + left) // 2)\n      self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n  def set_value(self, x):\n    if x >= self.iter_size - 1:return self.value[x]\n    a = self.set_value(x * 2 + 1)\n    b = self.set_value(x * 2 + 2)\n    if a == None and b == None:\n      self.value[x] = None\n    elif a == None:\n      self.value[x] = b\n    elif b == None:\n      self.value[x] = a\n    else:\n      self.value[x] = max(a, b)\n    return self.value[x]\n\n  def query(self, x, left, right):\n    x_left, x_right = self.range[x]\n    if right < x_left or x_right < left:\n      return 0\n    if left <= x_left and x_right <= right:\n      return self.value[x]\n\n    return max(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n\nfrom bisect import bisect_right as br\n\nn, d = map(int, input().split())\nlst = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x:x[2])\nsorted_x = []\nsorted_y = []\nkeys = []\nfor i in range(n):\n  x, y, b = lst[i]\n  sorted_x.append(x)\n  sorted_y.append(y)\n  keys.append(b)\nmxt = MinTree(sorted_x)\nMxt = MaxTree(sorted_x)\nmyt = MinTree(sorted_y)\nMyt = MaxTree(sorted_y)\n\ndef score(left, right):\n  return (Mxt.query(0, left, right) - mxt.query(0, left, right)) * \\\n         (Myt.query(0, left, right) - myt.query(0, left, right))\n\nINF = 10 ** 20\nkl = 0\nkr = br(keys, keys[0] + d) - 1\nend = len(keys)\nans = 0\nwhile kr < end:\n  ans = max(ans, score(kl, kr))\n  kl += 1\n  while kr < end and keys[kl] + d >= keys[kr]:\n    kr += 1\n  kr -= 1\n  if kr == end - 1:break\n\nif kl < end and kr < end:\n  ans = max(ans, score(kl, kr))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter as it\nD={}\nresult=[]\n_,d=map(int,input().split())\nfor i in stdin.readlines():\n    x,y,b=map(int,i.split())\n    if b not in D:D[b]=[]\n    D[b].append((x,y))\nfor i in range(max(D)-d+1):\n    l=[]\n    for s in range(d+1):\n        if i+s in D:l+=D[i+s]\n    if len(l)>1:\n        x=max(map(it(0),l))-min(map(it(0),l))\n        y=max(map(it(1),l))-min(map(it(1),l))\n        result.append(x*y)\nprint(max(result))"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\nwhile(len(a)>1):\n    minx=maxx=a[0][0]\n    miny=maxy=a[0][1]\n    k=1\n    while(a[k][2]<=a[0][2] + lightrange):\n        if (a[k][0]<minx or a[k][0]>maxx or a[k][1]<miny or a[k][1]>maxy):\n            minx = min(minx,a[k][0])\n            maxx = max(maxx,a[k][0])\n            miny = min(miny,a[k][1])\n            maxy = max(maxy,a[k][1])\n        k+=1\n    area = (maxx-minx)*(maxy-miny)\n    scale = max(scale,area)\n    del a[0]\nprint scale"
  },
  {
    "language": "Python",
    "code": "answer=[]\ninfo = list(map(int,raw_input().split()))\nall_list=[] # This list include information of all stars.\nfor i in range (info[0]):\n\tall_list.append(list(map(int,raw_input().split())))\ndark_star=min(all_list, key=lambda x: x[2])[2]\nbright_star=max(all_list, key=lambda x:x[2])[2]\nfor i in range (dark_star,bright_star+1):\n\tli=filter(lambda x: i<=x[2]<=i+info[1],all_list)\n\tif li !=[]:\n\t\tanswer.append((max(li,key=lambda x:x[0])[0]-min(li,key=lambda x:x[0])[0])*(max(li,key=lambda x:x[1])[1]-min(li,key=lambda x:x[1])[1]))\nprint max(answer)"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\nfor j in range(len(a)):\n    astars = []\n    for k in range(len(a)):\n        while(len(astars)<=2):\n            if (a[k][2] <= a[0][2] + lightrange):\n                astars.append(a[k])\n                twostars = k\n    maxx = max(astars[0][0],astars[1][0])\n    minx = min(astars[0][0],astars[1][0])\n    maxy = max(astars[0][1],astars[1][1])\n    miny = min(astars[0][1],astars[1][1])\n    for l in range(len(a)):\n        if (a[l][2] <= a[0][2] + lightrange):\n            if(a[l][0]<minx):\n                minx=a[l][0]\n            if(a[l][0]>maxx):\n                maxx=a[l][0]\n            if(a[l][1]<miny):\n                miny=a[l][1]\n            if(a[l][1]>maxy):\n                maxy=a[l][1]\n    area = (maxx-minx)*(maxy-miny)\n    if (area > scale):\n        scale = area\n    del a[0]\n    if len(a) < 2:\n        break;\n\nprint scale"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\n\ndef get_square(L):\n  if not L or len(L) == 0:return 0\n  x=[L[0][0][0],L[0][0][1]]\n  y=[L[0][1][0],L[0][1][1]]\n  for i in L:\n    if i[0][0] < x[0]:x[0] = i[0][0]\n    if i[0][1] > x[1]:x[1] = i[0][1]\n    if i[1][0] < y[0]:y[0] = i[1][0]\n    if i[1][1] > y[1]:y[1] = i[1][1]\n  return (x[1] - x[0]) * (y[1] - y[0])\n\ndef get_xy(b,L):\n  if not L or len(L) == 0:return None\n  x=[L[0][0],L[0][0]]\n  y=[L[0][1],L[0][1]]\n  for i in L:\n    if i[0] < x[0]:x[0] = i[0]\n    elif i[0] > x[1]:x[1] = i[0]\n    if i[1] < y[0]:y[0] = i[1]\n    elif i[1] > y[1]:y[1] = i[1]\n  return (b,x,y)\n\nN,d = map(int,input().split())\nL = sorted(set([list(map(int,i.split())) for i in stdin.readlines()]),key=itemgetter(2))\nB = set([i[2] for i in L])\nD = [get_xy(n,[i for i in L if i[2] == n]) for n in B]\n\ni = 0\nresult = 0\nwhile i < len(D):\n  m = D[i][0] + d\n  L = [D[i][1:3]]\n  j = i+1\n  while j < len(D) and D[j][0] <= m:\n    L.append(D[j][1:3])\n    j += 1\n  s = get_square(L)\n  if result < s:result = s\n  i += 1\n\nprint(result)"
  },
  {
    "language": "Python",
    "code": "import sys\nf = sys.stdin\n\ndef mix(a,b):\n    return (min(a[0],b[0]),min(a[1],b[1]),max(a[2],b[2]),max(a[3],b[3]))\n\ns = {}\n\nn, d = map(int, f.readline().split())\nfor _ in range(n):\n    x, y, b = map(int, f.readline().split())\n    s[b] = mix(s[b],(x,y,x,y)) if b in s else (x,y,x,y)\n\nmax_size = 0\nb = sorted(s.keys())\ni = j = 0\nwhile j < len(b) - 1:\n    for k in range(j,-1,-1):\n        if b[k] + d < b[j]:\n            break\n        i = k\n    for k in range(i,len(b)):\n        if b[i] + d < b[k]:\n            break\n        j = k\n    \n    xy = s[b[i]]\n    for k in range(i + 1, j + 1):\n        xy = mix(xy,s[b[k]])\n    \n    max_size = max(max_size,((xy[2] - xy[0]) * (xy[3] - xy[1])))\n    j+=1\n    \nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\nwhile(len(a)>1):\n    minx=maxx=a[0][0]\n    miny=maxy=a[0][1]\n    k=1\n    while(a[k][2]<=a[0][2] + lightrange):\n        if (a[k][0]<minx or a[k][0]>maxx or a[k][1]<miny or a[k][1]>maxy):\n            minx = min(minx,a[k][0])\n            maxx = max(maxx,a[k][0])\n            miny = min(miny,a[k][1])\n            maxy = max(maxy,a[k][1])\n        k+=1\n    area = (maxx-minx)*(maxy-miny)\n    scale = max(scale,area)\n    del a[0]\n    if(len(a)<2):\n        break;\nprint scale"
  },
  {
    "language": "Python",
    "code": "def main():\n  INF = 10 ** 20\n\n  class MinTree:\n    def __init__(self, iterable):\n      self.iter_size = self.get_size(iterable)\n      self.size = self.iter_size * 2 - 1\n      self.value = [None] * self.size\n      for i, v in enumerate(iterable):\n        self.value[self.iter_size + i - 1] = v\n      self.set_value(0)\n      self.range = [None] * self.size\n      self.set_range(0, 0, self.iter_size - 1)\n \n    \n    def get_size(self, iterable):\n      ret = 1\n      x = len(iterable)\n      while ret < x:\n        ret *= 2\n      return ret\n\n    def set_range(self, x, left, right):\n      self.range[x] = (left, right)\n      if left != right:\n        self.set_range(x * 2 + 1, left, (right + left) // 2)\n        self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n    def set_value(self, x):\n      if x >= self.iter_size - 1:return self.value[x]\n      a = self.set_value(x * 2 + 1)\n      b = self.set_value(x * 2 + 2)\n      if a == None and b == None:\n        self.value[x] = None\n      elif a == None:\n        self.value[x] = b\n      elif b == None:\n        self.value[x] = a\n      else:\n        self.value[x] = a if a < b else b\n      return self.value[x]\n  \n    def query(self, x, left, right):\n      x_left, x_right = self.range[x]\n      if right < x_left or x_right < left:\n        return INF\n      if left <= x_left and x_right <= right:\n        return self.value[x]\n  \n      return min(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n  \n  \n  class MaxTree:\n    def __init__(self, iterable):\n      self.iter_size = self.get_size(iterable)\n      self.size = self.iter_size * 2 - 1\n      self.value = [None] * self.size\n      for i, v in enumerate(iterable):\n        self.value[self.iter_size + i - 1] = v\n      self.set_value(0)\n      self.range = [None] * self.size\n      self.set_range(0, 0, self.iter_size - 1)\n    \n    def get_size(self, iterable):\n      ret = 1\n      x = len(iterable)\n      while ret < x:\n        ret *= 2\n      return ret\n    \n    def set_range(self, x, left, right):\n      self.range[x] = (left, right)\n      if left != right:\n        self.set_range(x * 2 + 1, left, (right + left) // 2)\n        self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n\n    def set_value(self, x):\n      if x >= self.iter_size - 1:return self.value[x]\n      a = self.set_value(x * 2 + 1)\n      b = self.set_value(x * 2 + 2)\n      if a == None and b == None:\n        self.value[x] = None\n      elif a == None:\n        self.value[x] = b\n      elif b == None:\n        self.value[x] = a\n      else:\n        self.value[x] = a if a > b else b\n      return self.value[x]\n  \n    def query(self, x, left, right):\n      x_left, x_right = self.range[x]\n      if right < x_left or x_right < left:\n        return 0\n      if left <= x_left and x_right <= right:\n        return self.value[x]\n  \n      return max(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n  \n  from bisect import bisect_right as br\n\n  n, d = map(int, input().split())\n  lst = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x:x[2])\n  sorted_x = []\n  sorted_y = []\n  keys = []\n  for i in range(n):\n    x, y, b = lst[i]\n    sorted_x.append(x)\n    sorted_y.append(y)\n    keys.append(b)\n  mxt = MinTree(sorted_x)\n  Mxt = MaxTree(sorted_x)\n  myt = MinTree(sorted_y)\n  Myt = MaxTree(sorted_y)\n  \n  def score(left, right):\n    return (Mxt.query(0, left, right) - mxt.query(0, left, right)) * \\\n           (Myt.query(0, left, right) - myt.query(0, left, right))\n  \n  left = 0\n  right = br(keys, keys[0] + d) - 1\n  mx = mxt.query(0, left, right)\n  Mx = Mxt.query(0, left, right)\n  my = myt.query(0, left, right)\n  My = Myt.query(0, left, right)\n  end = len(keys)\n  ans = (Mx - mx) * (My - my)\n  while True:\n    right += 1\n    if right == end:break\n    \n    if sorted_x[right] > Mx:Mx = sorted_x[right]\n    if sorted_x[right] < mx:mx = sorted_x[right] \n    if sorted_y[right] > My:My = sorted_y[right]\n    if sorted_y[right] < my:my = sorted_y[right]\n    \n    Mx_flag = mx_flag = My_flag = my_flag = False\n    while keys[left] + d < keys[right]:\n      if sorted_x[left] == Mx:Mx_flag = True\n      if sorted_x[left] == mx:mx_flag = True\n      if sorted_y[left] == My:My_flag = True\n      if sorted_y[left] == my:my_flag = True\n      left += 1\n    \n    if Mx_flag:Mx = Mxt.query(0, left, right)\n    if mx_flag:mx = mxt.query(0, left, right)\n    if My_flag:My = Myt.query(0, left, right)\n    if my_flag:my = myt.query(0, left, right)\n    \n    ans = max(ans, (Mx - mx) * (My - my)) \n  \n  print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef segmentTree(dat, f, sentinel):\n        pad = 2 ** math.ceil(math.log(len(dat),2))\n        dat = [0] * pad + dat + [sentinel] * (pad - len(dat))\n        for i in range(pad - 1, 0, -1):\n            dat[i] = f(dat[i * 2:i * 2 + 2])\n        return dat\n\ndef get_lr(b,d):\n    l = r = 0\n    while r < len(b):\n        while b[l] + d < b[r]:\n            l += 1\n        for r in range(r,len(b)):\n            if b[l] + d < b[r]:\n                r -= 1\n                break\n        r += 1\n        yield l,r\n        l += 1\n    \nimport sys\nf = sys.stdin\n\n\n_, d = map(int, f.readline().split())\n\nxyb = []\nfor line in f:\n    xyb.append(tuple(map(int, line.split())))\nfrom operator import itemgetter\nxyb.sort(key=itemgetter(2))\n\nx = [xybi[0] for xybi in xyb]\ny = [xybi[1] for xybi in xyb]\nb = [xybi[2] for xybi in xyb]\n\nxmax = segmentTree(x,max,sentinel = 0)\nxmin = segmentTree(x,min,sentinel = 2000000)\nymax = segmentTree(y,max,sentinel = 0)\nymin = segmentTree(y,min,sentinel = 2000000)\n\n\nsize = []\nsa = size.append #万単位で呼び出す場合は若干早くなる\npad = len(xmax) // 2\nmax_size = 0\nm = pad\npre_xmax,pre_xmin,pre_ymax,pre_ymin=0,0,0,0\ndef create_index(l,r):\n    index = []\n    ia = index.append\n    while l < r:\n        if r & 1:\n            r -= 1\n            ia(r)\n        if l & 1:\n            ia(l)\n            l += 1\n        l >>= 1\n        r >>= 1\n    return index\n\nfor l,r in get_lr(b,d):\n    # 参照するsegmentのindexを生成　※速度のためインライン展開\n    l += pad \n    r += pad\n    index = create_index(m,r)\n\n    now_xmax = max(xmax[i] for i in index)\n    now_xmin = min(xmin[i] for i in index)\n    now_ymax = max(ymax[i] for i in index)\n    now_ymin = min(ymin[i] for i in index)\n    \n    if pre_xmax < now_xmax or pre_xmin > now_xmin or pre_ymax < now_ymax or pre_ymin > now_ymin:\n        if l < m:\n            index = create_index(l,m)\n            now_xmax = max(now_xmax,max(xmax[i] for i in index))\n            now_xmin = min(now_xmin,min(xmin[i] for i in index))\n            now_ymax = max(now_ymax,max(ymax[i] for i in index))\n            now_ymin = min(now_ymin,min(ymin[i] for i in index))\n\n        size = (now_xmax - now_xmin) * (now_ymax - now_ymin)\n        if max_size < size:\n            max_size = size\n            pre_xmax,pre_xmin,pre_ymax,pre_ymin=now_xmax,now_xmin,now_ymax,now_ymin\n    m = r\nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappop, heappush\nfrom operator import itemgetter\n\nN, d = map(int, sys.stdin.readline().split())\nx_max, x_min, y_max, y_min = [], [], [], []\n\nans = 0\nfor x, y, b in sorted([list(map(int, l.split())) for l in sys.stdin.readlines()], key=itemgetter(2)):\n    heappush(x_max, (-x, b))\n    heappush(x_min, (x, b))\n    heappush(y_max, (-y, b))\n    heappush(y_min, (y, b))\n    for _a in (x_max, x_min, y_max, y_min):\n        while _a[0][1] < b-d:\n            heappop(_a)\n\n    area = (-x_max[0][0]-x_min[0][0])*(-y_max[0][0]-y_min[0][0])\n    if area > ans:\n        ans = area\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nf = sys.stdin\n\ndef memoize(f):\n  memo = {}\n  def inner(v0,v1,v2,v3,v4):\n      if not (v1,v2,v3,v4) in memo:\n        memo[v1,v2,v3,v4] = f(v0,v1,v2,v3,v4)\n      return memo[v1,v2,v3,v4]\n  return inner\n\n@memoize\ndef q(t,i,s,e,func):\n    if s == e:\n        return t[s][i]\n    else:\n        return func(q(t,i,s,(s+e)//2,func),q(t,i,(s+e)//2 + 1,e,func))\n\n_, d = map(int, f.readline().split())\n\nb = []\nfor line in f:\n    xi, yi, bi = map(int, line.split())\n    b.append((bi,xi,yi))\nb = sorted(b)\n\nmax_size = i = j = 0\nwhile j < len(b) - 1:\n    for k in range(j,-1,-1):\n        if b[k][0] + d < b[j][0]:\n            break\n        i = k\n    for k in range(i,len(b)):\n        if b[i][0] + d < b[k][0]:\n            break\n        j = k\n\n    max_size = max(max_size,(q(b,1,i,j,max) - q(b,1,i,j,min)) * (q(b,2,i,j,max) - q(b,2,i,j,min)))\n    j+=1\n    \nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\nfor j in range(len(a)):\n    minlight = a[0][2]\n    astars = []\n    for k in range(len(a)):\n        if (a[k][2] >= minlight and a[k][2] <= minlight + lightrange):\n            astars.append(a[k])\n    #astarsx = [astars[l][0] for l in range(len(astars))]\n    #astarsy = [astars[m][1] for m in range(len(astars))]\n    length = len(astars)\n    #print astars\n    astars.sort(key=lambda x:x[0])\n    #p = max(astarsx)\n    #q = min(astarsx)\n    #r = max(astarsy)\n    #s = min(astarsy)\n    p = astars[length-1][0]\n    q = astars[0][0]\n    astars.sort(key=lambda x:x[1])\n    r = astars[length-1][1]\n    s = astars[0][1]\n    pqrs = (p - q) * (r - s)\n    if (pqrs > scale):\n        scale = pqrs\n    del a[0]\n    if len(a) < 4:\n        break;\n\nprint scale"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_right as br\n\nclass SegTree:\n  def __init__(self, num, lst):\n    num_ = 1\n    while num_ < num:\n      num_ *= 2\n    self.length = num_ * 2 - 1\n    self.arr = [None] * (num_ * 2 - 1)\n    for i in range(num):\n      x1, x2, y1, y2 = lst[i]\n      self.arr[num_ - 1 + i] = (x1, x2, y1, y2, i, i)\n\n    self.make(0)\n\n  def make(self, num):\n    if num >= self.length:\n      return None\n    if self.arr[num] != None:\n      return self.arr[num]\n    else:\n      self.arr[num] = self.con(self.make(num * 2 + 1), self.make(num * 2 + 2))\n      return self.arr[num]\n  \n  def con(self, n1, n2):\n    if n1 != None and n2 != None:\n      return ((min(n1[0], n2[0]), max(n1[1], n2[1]), min(n1[2], n2[2]), max(n1[3], n2[3]), n1[4], n2[5]))\n    if n1 != None:\n      return n1\n    if n2 != None:\n      return n2\n    return None\n\n  def query(self, l, r, num):\n    node = self.arr[num]\n    if node == None:\n      return None\n    if l <= node[4] and node[5] <= r:\n      return node[:4]\n    elif r < node[4] or node[5] < l:\n      return None\n    else:\n      x1 = self.query(l, r, num * 2 + 1)\n      x2 = self.query(l, r, num * 2 + 2)\n      if x1 == None and x2 == None:\n        return None\n      if x1 == None:\n        return x2\n      if x2 == None:\n        return x1\n      return (min(x1[0], x2[0]), max(x1[1], x2[1]), min(x1[2], x2[2]), max(x1[3], x2[3]))\n\ndef main():\n  n, d = map(int, input().split())\n  stars = []\n  blst = []\n  for _ in range(n):\n    x, y, b = map(int, input().split())\n    stars.append((x, y, b))\n    blst.append(b)\n  blst.sort()\n  stars.sort(key=lambda t:t[2])\n  stars = [(x, x, y, y) for x, y, _ in stars]\n\n  tree = SegTree(n, stars)\n  ans = 0\n  max_r = 0\n  for l in range(n):\n    r = br(blst, blst[l] + d)\n    if r == n:\n      r -= 1\n    elif blst[r] != blst[l] + d:\n      r -= 1\n    if r > max_r:\n      a = tree.query(l, r, 0)\n      ans = max((a[1] - a[0]) * (a[3] - a[2]), ans)\n      max_r = r\n  print(ans)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\nfor j in range(len(a)):\n    astars = []\n    for k in range(len(a)):\n        while(len(astars)<=2):\n            if (a[k][2] <= a[0][2] + lightrange):\n                astars.append(a[k])\n                twostars = k\n    maxx = max(astars[0][0],astars[1][0])\n    minx = min(astars[0][0],astars[1][0])\n    maxy = max(astars[0][1],astars[1][1])\n    miny = min(astars[0][1],astars[1][1])\n    for l in range(len(a)):\n        if (a[l][2] <= a[0][2] + lightrange):\n            if(a[l][0]<minx):\n                minx=a[l][0]\n            if(a[l][0]>maxx):\n                maxx=a[l][0]\n            if(a[l][1]<miny):\n                miny=a[l][1]\n            if(a[l][1]>maxy):\n                maxy=a[l][1]\n    area = (maxx-minx)*(maxy-miny)\n    if (area > scale):\n        scale = area\n    del a[0]\n    if len(a) < 2:\n        break;\n\nprint scale"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left as bl\n\nclass Node:\n  def __init__(self, val, sec):\n    self.val = val\n    self.sec = sec\n    self.left = sec[0]\n    self.right = sec[1]\n    self.minx = val[0]\n    self.maxx = val[1]\n    self.miny = val[2]\n    self.maxy = val[3]\n\nclass SegTree:\n  def __init__(self, num, lst):\n    num_ = 1\n    while num_ < num:\n      num_ *= 2\n    self.length = num_ * 2 - 1\n    self.arr = [None] * (num_ * 2 - 1)\n    for i in range(num):\n      self.arr[num_ - 1 + i] = Node(lst[i], (i, i))\n\n    self.make(0)\n\n  def make(self, num):\n    if num >= self.length:\n      return None\n    if self.arr[num] != None:\n      return self.arr[num]\n    else:\n      self.arr[num] = self.con(self.make(num * 2 + 1), self.make(num * 2 + 2))\n      return self.arr[num]\n  \n  def con(self, n1, n2):\n    if n1 != None and n2 != None:\n      return Node((min(n1.minx, n2.minx), max(n1.maxx, n2.maxx), min(n1.miny, n2.miny), max(n1.maxy, n2.maxy)),\n                  (n1.left, n2.right))\n    if n1 != None:\n      return n1\n    if n2 != None:\n      return n2\n    return None\n\n  def query(self, l, r, num):\n    node = self.arr[num]\n    if node == None:\n      return None\n    if l <= node.left and node.right <= r:\n      return node\n    elif r < node.left or node.right < l:\n      return None\n    else:\n      return self.con(self.query(l, r, num * 2 + 1), self.query(l, r, num * 2 + 2))\n\ndef main():\n  n, d = map(int, input().split())\n  stars = []\n  blst = []\n  for _ in range(n):\n    x, y, b = map(int, input().split())\n    stars.append((x, y, b))\n    blst.append(b)\n  blst.sort()\n  stars.sort(key=lambda t:t[2])\n  stars = [(x, x, y, y) for x, y, _ in stars]\n\n  tree = SegTree(n, stars)\n  ans = 0\n  for l in range(n):\n    r = bl(blst, blst[l] + d)\n    if r >= n:\n      r -= 1\n    a = tree.query(l, r, 0).val\n    ans = max((a[1] - a[0]) * (a[3] - a[2]), ans)\n  print(ans)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from functools import reduce\n\n\nclass Bound:\n    min_x = 2000001\n    min_y = 2000001\n    max_x = -1\n    max_y = -1\n\n    def add(self, x, y):\n        if self.min_x > x: self.min_x = x\n        if self.min_y > y: self.min_y = y\n        if self.max_x < x: self.max_x = x\n        if self.max_y < y: self.max_y = y\n\n    def expand(self, bound):\n        if self.min_x > bound.min_x: self.min_x = bound.min_x\n        if self.min_y > bound.min_y: self.min_y = bound.min_y\n        if self.max_x < bound.max_x: self.max_x = bound.max_x\n        if self.max_y < bound.max_y: self.max_y = bound.max_y\n        return self\n\n    def area(self):\n        return (self.max_x - self.min_x) * (self.max_y - self.min_y) if self.max_x > -1 else 0\n\n\nn, d = map(int, input().split())\ninput_store = set()\nmax_b = -1\n\nwhile n:\n    x, y, b = map(int, input().split())\n    input_store.add((x, y, b))\n    if b > max_b: max_b = b\n    n -= 1\n\nstars = [Bound() for _ in range(max_b + 1)]\nfor x, y, b in input_store:\n    stars[b].add(x, y)\n\nd = min(d, max_b)\n\nprint(max(reduce(Bound.expand, stars[i + 1:i + d + 1], stars[i]).area() for i in range(max_b - d + 1)))"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter as it\nD={}\nresult=[]\nN,d=map(int,input().split())\nfor i in stdin.readlines():\n    x,y,b=map(int,i.split())\n    if b not in D:D[b]=[]\n    D[b].append((x,y))\nfor i in range(max(D)-d+1):\n    l=[]\n    for s in range(d+1):\n        if i+s in D:l+=D[i+s]\n    if len(l)>1:\n        if len(l)>1:result.append((max(map(it(0),l))-min(map(it(0),l)))*(max(map(it(1),l))-min(map(it(1),l))))\nprint(0 if 0==len(result) else max(result))"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\nscale = []\nfor j in range(len(a)):\n    minlight = a[j][2]\n    astars = []\n    for k in range(len(a)):\n        if (a[k][2] >= minlight and a[k][2] <= minlight + lightrange):\n            astars.append(a[k])\n    astarsx = [astars[l][0] for l in range(len(astars))]\n    astarsy = [astars[m][1] for m in range(len(astars))]\n    p = max(astarsx)\n    q = min(astarsx)\n    r = max(astarsy)\n    s = min(astarsy)\n    scale.append((p-q)*(r-s))\nprint max(scale)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappop, heappush\n\nN, d = map(int, sys.stdin.readline().split())\na = sorted([(b, x, y) for l in sys.stdin.readlines() for x, y, b in (map(int, l.split()),)])\nx_max, x_min, y_max, y_min = [], [], [], []\n\nans = 0\nfor b, x, y in a:\n    heappush(x_max, (-x, b))\n    heappush(x_min, (x, b))\n    heappush(y_max, (-y, b))\n    heappush(y_min, (y, b))\n    for _a in (x_max, x_min, y_max, y_min):\n        while _a[0][1] < b-d:\n            heappop(_a)\n\n    ans = max(ans, (-x_max[0][0]-x_min[0][0])*(-y_max[0][0]-y_min[0][0]))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter as it\nD={}\nresult=[]\n_,d=map(int,input().split())\nfor i in stdin.readlines():\n    x,y,b=map(int,i.split())\n    if b not in D:D[b]=[]\n    D[b].append((x,y))\nfor i in range(max(D)-d+1):\n    l=[]\n    for s in range(d+1):\n        if i+s in D:l+=D[i+s]\n    if len(l)>1:\n        x=max(map(it(0),l))-min(map(it(0),l))\n        y=max(map(it(1),l))-min(map(it(1),l))\n        result.append(x*y)\nprint(max(result))"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\n\ndef get_square(L):\n  if not L or len(L) == 0:return 0\n  x=[L[0][0][0],L[0][0][1]]\n  y=[L[0][1][0],L[0][1][1]]\n  for i in L:\n    if i[0][0] < x[0]:x[0] = i[0][0]\n    if i[0][1] > x[1]:x[1] = i[0][1]\n    if i[1][0] < y[0]:y[0] = i[1][0]\n    if i[1][1] > y[1]:y[1] = i[1][1]\n  return (x[1] - x[0]) * (y[1] - y[0])\n\ndef get_xy(b,L):\n  if not L or len(L) == 0:return None\n  x = (min(L[0]),max(L[0]))\n  y = (min(L[1]),max(L[1]))\n#  x=[L[0][0],L[0][0]]\n#  y=[L[0][1],L[0][1]]\n#  for i in L:\n#    if i[0] < x[0]:x[0] = i[0]\n#    elif i[0] > x[1]:x[1] = i[0]\n#    if i[1] < y[0]:y[0] = i[1]\n#    elif i[1] > y[1]:y[1] = i[1]\n  return (b,x,y)\n\nN,d = map(int,input().split())\nL = set([tuple(map(int,i.split())) for i in stdin.readlines()])\nB = set([i[2] for i in L])\n\nD = [get_xy(n,list(zip(*[i[0:2] for i in L if i[2] == n]))) for n in B]\n\ni = 0\nresult = 0\nwhile i < len(D):\n  m = D[i][0] + d\n  L = [D[i][1:3]]\n  j = i+1\n  while j < len(D) and D[j][0] <= m:\n    L.append(D[j][1:3])\n    j += 1\n  s = get_square(L)\n  if result < s:result = s\n  i += 1\n\nprint(result)"
  },
  {
    "language": "Python",
    "code": "class MinTree:\n  def __init__(self, iterable):\n    self.iter_size = self.get_size(iterable)\n    self.size = self.iter_size * 2 - 1\n    self.value = [None] * self.size\n    for i, v in enumerate(iterable):\n      self.value[self.iter_size + i - 1] = v\n    self.set_value(0)\n    self.range = [None] * self.size\n    self.set_range(0, 0, self.iter_size - 1)\n  \n  def get_size(self, iterable):\n    ret = 1\n    x = len(iterable)\n    while ret < x:\n      ret *= 2\n    return ret\n  \n  def set_range(self, x, left, right):\n    self.range[x] = (left, right)\n    if left != right:\n      self.set_range(x * 2 + 1, left, (right + left) // 2)\n      self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n  def set_value(self, x):\n    if x >= self.iter_size - 1:return self.value[x]\n    a = self.set_value(x * 2 + 1)\n    b = self.set_value(x * 2 + 2)\n    if a == None and b == None:\n      self.value[x] = None\n    elif a == None:\n      self.value[x] = b\n    elif b == None:\n      self.value[x] = a\n    else:\n      self.value[x] = min(a, b)\n    return self.value[x]\n\n  def query(self, x, left, right):\n    x_left, x_right = self.range[x]\n    if right < x_left or x_right < left:\n      return INF\n    if left <= x_left and x_right <= right:\n      return self.value[x]\n\n    return min(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n\n\nclass MaxTree:\n  def __init__(self, iterable):\n    self.iter_size = self.get_size(iterable)\n    self.size = self.iter_size * 2 - 1\n    self.value = [None] * self.size\n    for i, v in enumerate(iterable):\n      self.value[self.iter_size + i - 1] = v\n    self.set_value(0)\n    self.range = [None] * self.size\n    self.set_range(0, 0, self.iter_size - 1)\n  \n  def get_size(self, iterable):\n    ret = 1\n    x = len(iterable)\n    while ret < x:\n      ret *= 2\n    return ret\n  \n  def set_range(self, x, left, right):\n    self.range[x] = (left, right)\n    if left != right:\n      self.set_range(x * 2 + 1, left, (right + left) // 2)\n      self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n  def set_value(self, x):\n    if x >= self.iter_size - 1:return self.value[x]\n    a = self.set_value(x * 2 + 1)\n    b = self.set_value(x * 2 + 2)\n    if a == None and b == None:\n      self.value[x] = None\n    elif a == None:\n      self.value[x] = b\n    elif b == None:\n      self.value[x] = a\n    else:\n      self.value[x] = max(a, b)\n    return self.value[x]\n\n  def query(self, x, left, right):\n    x_left, x_right = self.range[x]\n    if right < x_left or x_right < left:\n      return 0\n    if left <= x_left and x_right <= right:\n      return self.value[x]\n\n    return max(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n\nfrom bisect import bisect_right as br\n\nn, d = map(int, input().split())\nlst = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x:x[2])\nsorted_x = []\nsorted_y = []\nkeys = []\nfor i in range(n):\n  x, y, b = lst[i]\n  sorted_x.append(x)\n  sorted_y.append(y)\n  keys.append(b)\nmxt = MinTree(sorted_x)\nMxt = MaxTree(sorted_x)\nmyt = MinTree(sorted_y)\nMyt = MaxTree(sorted_y)\n\ndef score(left, right):\n  return (Mxt.query(0, left, right) - mxt.query(0, left, right)) * \\\n         (Myt.query(0, left, right) - myt.query(0, left, right))\n\nINF = 10 ** 20\nkl = 0\nkr = br(keys, keys[0] + d) - 1\nend = len(keys)\nans = 0\nwhile True:\n  ans = max(ans, score(kl, kr))\n  kl += 1\n  if kl == end:break\n  while kr < end and keys[kl] + d >= keys[kr]:\n    kr += 1\n  kr -= 1\n  if kr == end - 1:break\n\nif kl < end and kr < end:\n  ans = max(ans, score(kl, kr))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  INF = 10 ** 20\n\n  class MinTree:\n    def __init__(self, iterable):\n      self.iter_size = self.get_size(iterable)\n      self.size = self.iter_size * 2 - 1\n      self.value = [None] * self.size\n      for i, v in enumerate(iterable):\n        self.value[self.iter_size + i - 1] = v\n      self.set_value(0)\n      self.range = [None] * self.size\n      self.set_range(0, 0, self.iter_size - 1)\n \n    \n    def get_size(self, iterable):\n      ret = 1\n      x = len(iterable)\n      while ret < x:\n        ret *= 2\n      return ret\n\n    def set_range(self, x, left, right):\n      self.range[x] = (left, right)\n      if left != right:\n        self.set_range(x * 2 + 1, left, (right + left) // 2)\n        self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n    def set_value(self, x):\n      if x >= self.iter_size - 1:return self.value[x]\n      a = self.set_value(x * 2 + 1)\n      b = self.set_value(x * 2 + 2)\n      if a == None and b == None:\n        self.value[x] = None\n      elif a == None:\n        self.value[x] = b\n      elif b == None:\n        self.value[x] = a\n      else:\n        self.value[x] = a if a < b else b\n      return self.value[x]\n  \n    def query(self, x, left, right):\n      x_left, x_right = self.range[x]\n      if right < x_left or x_right < left:\n        return INF\n      if left <= x_left and x_right <= right:\n        return self.value[x]\n  \n      return min(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n  \n  \n  class MaxTree:\n    def __init__(self, iterable):\n      self.iter_size = self.get_size(iterable)\n      self.size = self.iter_size * 2 - 1\n      self.value = [None] * self.size\n      for i, v in enumerate(iterable):\n        self.value[self.iter_size + i - 1] = v\n      self.set_value(0)\n      self.range = [None] * self.size\n      self.set_range(0, 0, self.iter_size - 1)\n    \n    def get_size(self, iterable):\n      ret = 1\n      x = len(iterable)\n      while ret < x:\n        ret *= 2\n      return ret\n    \n    def set_range(self, x, left, right):\n      self.range[x] = (left, right)\n      if left != right:\n        self.set_range(x * 2 + 1, left, (right + left) // 2)\n        self.set_range(x * 2 + 2, (right + left) // 2 + 1, right)\n\n\n    def set_value(self, x):\n      if x >= self.iter_size - 1:return self.value[x]\n      a = self.set_value(x * 2 + 1)\n      b = self.set_value(x * 2 + 2)\n      if a == None and b == None:\n        self.value[x] = None\n      elif a == None:\n        self.value[x] = b\n      elif b == None:\n        self.value[x] = a\n      else:\n        self.value[x] = a if a > b else b\n      return self.value[x]\n  \n    def query(self, x, left, right):\n      x_left, x_right = self.range[x]\n      if right < x_left or x_right < left:\n        return 0\n      if left <= x_left and x_right <= right:\n        return self.value[x]\n  \n      return max(self.query(x * 2 + 1, left, right), self.query(x * 2 + 2, left, right))\n  \n  from bisect import bisect_right as br\n\n  n, d = map(int, input().split())\n  lst = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x:x[2])\n  sorted_x = []\n  sorted_y = []\n  keys = []\n  for i in range(n):\n    x, y, b = lst[i]\n    sorted_x.append(x)\n    sorted_y.append(y)\n    keys.append(b)\n  mxt = MinTree(sorted_x)\n  Mxt = MaxTree(sorted_x)\n  myt = MinTree(sorted_y)\n  Myt = MaxTree(sorted_y)\n  \n  def score(left, right):\n    return (Mxt.query(0, left, right) - mxt.query(0, left, right)) * \\\n           (Myt.query(0, left, right) - myt.query(0, left, right))\n  \n  left = 0\n  right = br(keys, keys[0] + d) - 2\n  mx = mxt.query(0, left, right)\n  Mx = Mxt.query(0, left, right)\n  my = myt.query(0, left, right)\n  My = Myt.query(0, left, right)\n  end = len(keys)\n  ans = (Mx - mx) * (My - my)\n  while True:\n    right += 1\n    if right == end:break\n    \n    if sorted_x[right] > Mx:Mx = sorted_x[right]\n    if sorted_x[right] < mx:mx = sorted_x[right] \n    if sorted_y[right] > My:My = sorted_y[right]\n    if sorted_y[right] < my:my = sorted_y[right]\n    \n    Mx_flag = mx_flag = My_flag = my_flag = False\n    while keys[left] + d <= keys[right]:\n      if sorted_x[left] == Mx:Mx_flag = True\n      if sorted_x[left] == mx:mx_flag = True\n      if sorted_y[left] == My:My_flag = True\n      if sorted_y[left] == my:my_flag = True\n      left += 1\n    left -= 1\n    \n    if Mx_flag:Mx = Mxt.query(0, left, right)\n    if mx_flag:mx = mxt.query(0, left, right)\n    if My_flag:My = Myt.query(0, left, right)\n    if my_flag:my = myt.query(0, left, right)\n    \n    ans = max(ans, (Mx - mx) * (My - my)) \n  \n  print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter\n\ndef get_square(L):\n  if not L or len(L) == 0:return 0\n  x=[L[0][0][0],L[0][0][1]]\n  y=[L[0][1][0],L[0][1][1]]\n  for i in L:\n    if i[0][0] < x[0]:x[0] = i[0][0]\n    if i[0][1] > x[1]:x[1] = i[0][1]\n    if i[1][0] < y[0]:y[0] = i[1][0]\n    if i[1][1] > y[1]:y[1] = i[1][1]\n  return (x[1] - x[0]) * (y[1] - y[0])\n\ndef get_xy(b,L):\n  if not L or len(L) == 0:return None\n  x=[L[0][0],L[0][0]]\n  y=[L[0][1],L[0][1]]\n  for i in L:\n    if i[0] < x[0]:x[0] = i[0]\n    elif i[0] > x[1]:x[1] = i[0]\n    if i[1] < y[0]:y[0] = i[1]\n    elif i[1] > y[1]:y[1] = i[1]\n  return (b,x,y)\n\nN,d = map(int,input().split())\nL = sorted(list(map([list(map(int,i.split())) for i in stdin.readlines()])),key=itemgetter(2))\nB = set([i[2] for i in L])\nD = [get_xy(n,[i for i in L if i[2] == n]) for n in B]\n\ni = 0\nresult = 0\nwhile i < len(D):\n  m = D[i][0] + d\n  L = [D[i][1:3]]\n  j = i+1\n  while j < len(D) and D[j][0] <= m:\n    L.append(D[j][1:3])\n    j += 1\n  s = get_square(L)\n  if result < s:result = s\n  i += 1\n\nprint(result)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import itemgetter as it\nD={}\nresult=[]\nN,d=map(int,input().split())\nfor i in stdin.readlines():\n    x,y,b=map(int,i.split())\n    if b not in D:D[b]=[]\n    D[b].append((x,y))\nfor i in range(max(D)-d+1):\n    l=[]\n    for s in range(d+1):\n        if i+s in D:l+=D[i+s]\n    if len(l)>1:\n        if len(l)>1:\n            x,y=it(0),it(1)\n            result.append((max(map(x,l))-min(map(x,l)))*(max(map(y,l))-min(map(y,l))))\nprint(0 if 0==len(result) else max(result))"
  },
  {
    "language": "Python",
    "code": "n, d = map(int, input().split())\nud, od = d // 2, (d + 1) // 2\nstars = dict()\n\nfor _ in range(n):\n    x, y, b = map(int, input().split())\n    xys = stars.setdefault(b, [x, x, y, y])\n    if xys[0] < x: xys[0] = x\n    if xys[1] > x: xys[1] = x\n    if xys[2] < y: xys[2] = y\n    if xys[3] > y: xys[3] = y\n\nkeys = set(stars.keys())\nmin_b, max_b = min(keys) + ud, max(keys) - od\nmax_stella = 0\n\nfor b in range(min_b, max_b + 1):\n    bbs = keys.intersection(range(b - ud, b + od + 1))\n    if not bbs: continue\n    max_x, min_x, max_y, min_y = 0, 200001, 0, 200001\n    for bb in bbs:\n        (ax, ix, ay, iy) = stars[bb]\n        if max_x < ax: max_x = ax\n        if min_x > ix: min_x = ix\n        if max_y < ay: max_y = ay\n        if min_y > iy: min_y = iy\n    else:\n        stella = (max_x - min_x) * (max_y - min_y)\n        if max_stella < stella: max_stella = stella\n\nprint(max_stella)"
  },
  {
    "language": "Python",
    "code": "import math\nclass SegmentTree:\n    def __init__(self, dat, func, sentinel):\n        self.pad = 2 ** math.ceil(math.log(len(dat),2)) - 1\n        self.dat = [None] * self.pad + dat + [sentinel] * (self.pad + 1 - len(dat))\n        self.func = func\n        self.sentinel = sentinel\n        for i in range(self.pad - 1, -1, -1):\n            self.dat[i] = self.func(self.dat[i * 2 + 1],self.dat[i * 2 + 2])\n        \n    def q(self,s,e):\n        return self._q(self.pad + s,self.pad + e,0,self.pad,len(self.dat) - 1)\n    def _q(self,a,b,k,l,r):\n        if b < l or r < a:\n            return self.sentinel\n        elif a <= l and r <= b:\n            return self.dat[k]\n        else:\n            vl = self._q(a,b,k * 2 + 1,l,(l+r)//2)\n            vr = self._q(a,b,k * 2 + 2,(l+r)//2 + 1,r)\n            return self.func(vl,vr)\nimport sys\nf = sys.stdin\n\n\n_, d = map(int, f.readline().split())\n\n#内包表記にしないと速度不足\nb = sorted([list(map(int, line.split()))[::-1] for line in f])\nx = [bi[2] for bi in b]\ny = [bi[1] for bi in b]\n\n\n        \nminx = SegmentTree(x,min,sentinel = 2000001)\nmaxx = SegmentTree(x,max,sentinel = -1)\nminy = SegmentTree(y,min,sentinel = 2000001)\nmaxy = SegmentTree(y,max,sentinel = -1)\n\nmax_size = i = j = 0\nwhile j < len(b) - 1:\n    for k in range(j,-1,-1):\n        if b[k][0] + d < b[j][0]:\n            break\n        i = k\n    for k in range(i,len(b)):\n        if b[i][0] + d < b[k][0]:\n            break\n        j = k\n    \n    max_size = max(max_size,(maxx.q(i,j) - minx.q(i,j)) * (maxy.q(i,j) - miny.q(i,j)))\n    j+=1\n    \nprint(max_size)"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = [0]\nwhile(len(a)>1):\n    k=0\n    x=[]\n    y=[]\n    while(a[k][2]<=a[0][2] + lightrange):\n        x.append(a[k][0])\n        y.append(a[k][1])\n        k+=1\n        if(k==len(a)):\n            break\n    scale.append((max(x)-min(x))*(max(y)-min(y)))\n    del a[0]\nprint max(scale)"
  },
  {
    "language": "Python",
    "code": "data = map(int, raw_input().split())\nstars = data[0]\nlightrange = data[1]\na = []\nfor i in range(stars):\n    a.append(map(int, raw_input().split()))\na.sort(key=lambda x:x[2])\nscale = 0\nwhile(len(a)>1):\n    if(a[0][2] + lightrange < a[1][2]):\n        break;\n    minx=maxx=a[0][0]\n    miny=maxy=a[0][1]\n    k=1\n    while(a[k][2]<=a[0][2] + lightrange):\n        if (a[k][0]<minx or a[k][0]>maxx or a[k][1]<miny or a[k][1]>maxy):\n            minx = min(minx,a[k][0])\n            maxx = max(maxx,a[k][0])\n            miny = min(miny,a[k][1])\n            maxy = max(maxy,a[k][1])\n        if k==len(a)-1:\n            break;\n        print \"!\"\n        k+=1\n    area = (maxx-minx)*(maxy-miny)\n    scale = max(scale,area)\n    del a[0]\n    print \"?\"\nprint scale"
  },
  {
    "language": "Python",
    "code": "from math import ceil, log2\n\n\nclass SegmentTree:\n    def __init__(self, n, bounds):\n        n2 = 2 ** ceil(log2(n))\n        tree = [None] * (n2 - 1) + bounds + [None] * (n2 - n)\n        left = [0] * (n2 - 1) + list(range(n2))\n        right = [0] * (n2 - 1) + list(range(n2))\n        for i in range(n2 - 2, -1, -1):\n            tree[i] = bound_expand(tree[i * 2 + 1], tree[i * 2 + 2])\n            left[i] = left[i * 2 + 1]\n            right[i] = right[i * 2 + 2]\n        self.tree = tree\n        self.left = left\n        self.right = right\n\n    def get(self, s, t, i=0):\n        l, r = self.left[i], self.right[i]\n        if l >= s and r <= t:\n            return self.tree[i]\n        if l > t or r < s:\n            return None\n        return bound_expand(self.get(s, t, i * 2 + 1), self.get(s, t, i * 2 + 2))\n\n\ndef bound_expand(b1, b2):\n    if b1:\n        if b2:\n            return tuple(f(xy1, xy2) for f, xy1, xy2 in zip((min, min, max, max), b1, b2))\n        return b1\n    return b2\n\n\ndef bound_area(b):\n    return (b[2] - b[0]) * (b[3] - b[1])\n\n\nn, d = map(int, input().split())\ninput_store = set()\nmax_b = -1\n\nwhile n:\n    x, y, b = map(int, input().split())\n    input_store.add((x, y, b))\n    if b > max_b: max_b = b\n    n -= 1\n\nstars = [None] * (max_b + 1)\nfor x, y, b in input_store:\n    stars[b] = bound_expand(stars[b], (x, y, x, y))\n\nst = SegmentTree(max_b + 1, stars)\n\nprint(max(bound_area(st.get(i, i + d)) for i, b in enumerate(stars) if b))"
  }
]