[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Python",
    "code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(N, K, A):\n    best_divisor = 1\n    for d in range(1, min(A) + 1):\n        if all(x % d == 0 for x in A):\n            possible_moves = 0\n            B = A.copy()\n            for i in range(N):\n                for j in range(N):\n                    if i != j:\n                        while B[i] % d != 0 or B[j] % d != 0:\n                            if possible_moves >= K:\n                                break\n                            B[i] += 1\n                            B[j] -= 1\n                            possible_moves += 1\n                        if possible_moves > K:\n                            break\n                if possible_moves > K:\n                    break\n            \n            if all(x % d == 0 for x in B) and possible_moves <= K:\n                best_divisor = max(best_divisor, d)\n    \n    return best_divisor\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nprint(solve(N, K, A))",
    "timestamp": "2025-08-05 17:32:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Python",
    "code": "import math\n\ndef solve():\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    total = sum(A)\n    \n    # Find all divisors of total\n    divisors = set()\n    for d in range(1, int(math.isqrt(total)) + 1):\n        if total % d == 0:\n            divisors.add(d)\n            divisors.add(total // d)\n    \n    max_gcd = 1\n    for d in sorted(divisors, reverse=True):\n        if d == 0:\n            continue\n        mods = [a % d for a in A]\n        mods.sort()\n        sum_pos = sum(mods)\n        sum_neg = 0\n        min_operations = float('inf')\n        # The split point is where the mods[i] are kept as is (sum_pos) vs converted to (mods[i] - d) (sum_neg)\n        # The sum_pos decreases by d for each element moved to sum_neg\n        # The total operations is sum_neg (since sum_pos + sum_neg = N * d - sum_pos)\n        # Wait, no. sum_neg is sum (d - mods[i]) for some i's.\n        # We need to find the optimal split where sum mods[i] (for some i's) = sum (d - mods[j]) for the rest.\n        # Or equivalently, sum mods[i] (left part) = (d * t - sum mods) / 2? Not sure.\n        # Alternative approach: for each possible d, sum mods is S = sum (mods[i])\n        # The required sum is S = t * d, where t is the number of operations (each operation contributes +1 -1 = 0 net change)\n        # Wait, the sum of mods must be divisible by d. Which it is, since sum mods[i] = sum (a_i % d) = (sum a_i) % d = total % d = 0.\n        # So sum mods is a multiple of d. Let sum_mod = sum mods = m * d. Then the minimal operations is sum_{i < m} (d - mods_sorted[i]) or sum_{i >= N - m} mods_sorted[i]\n        mods_sorted = sorted(mods)\n        sum_mod = sum(mods_sorted)\n        m = sum_mod // d\n        # The minimal operations is the sum of the smallest (sum_mod // d) elements (d - mod) or sum of largest (sum_mod // d) mods?\n        # No, it's the sum of the (sum_mod // d) elements (d - mod) for the smallest mods (since mod is small, d - mod is large, but we want to minimize the sum of the required (d - mod) for the smallest mods? No.\n        # The correct approach is to take the sum of the (sum_mod // d) smallest (d - mods_sorted[i]) or the sum of the (sum_mod // d) largest mods_sorted[i].\n        # But since sum_mod = m * d, the sum of (d - mods_sorted[i]) for i in first m elements is m*d - sum_{i < m} mods_sorted[i] = sum_mod - sum_{i < m} mods_sorted[i] = sum_{i >= m} mods_sorted[i]\n        # So the minimal operations is min(sum_{i < m} (d - mods_sorted[i]), sum_{i >= m} mods_sorted[i]) = min(sum_{i >= m} mods_sorted[i], sum_{i < m} (d - mods_sorted[i]))\n        # But sum_{i < m} (d - mods_sorted[i]) = m*d - sum_{i < m} mods_sorted[i] = sum_mod - sum_{i < m} mods_sorted[i] = sum_{i >= m} mods_sorted[i]\n        # So both are equal. Thus, the minimal operations is sum_{i >= m} mods_sorted[i]\n        operations_needed = sum(mods_sorted[-m:]) if m !=0 else 0\n        if operations_needed <= K:\n            max_gcd = d\n            break\n    print(max_gcd)\n\nsolve()",
    "timestamp": "2025-08-05 17:33:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\n\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\ndef maximum_divisor(N, K, A):\n    total_sum = sum(A)\n    \n    # Possible divisors are between 1 and total_sum\n    possible_divisors = []\n\n    for d in range(1, int(total_sum**0.5) + 1):\n        if total_sum % d == 0:\n            possible_divisors.append(d)\n            if d != total_sum // d:\n                possible_divisors.append(total_sum // d)\n\n    possible_divisors.sort(reverse=True)\n\n    for d in possible_divisors:\n        remain = [a % d for a in A]\n        remain.sort(reverse=True)\n        \n        sum_remain = sum(remain)\n        min_operations = sum_remain // d\n        \n        if min_operations <= K:\n            return d\n    \n    return 1\n\nprint(maximum_divisor(N, K, A))",
    "timestamp": "2025-08-12 21:53:47"
  }
]