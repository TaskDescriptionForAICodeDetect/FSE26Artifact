[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_TOWNS 100\n\ntypedef struct {\n    int x, y;\n} Town;\n\nint parent[MAX_TOWNS];\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unionSet(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    if (px != py)\n        parent[px] = py;\n}\n\nint minCost(Town towns[], int n) {\n    for (int i = 0; i < n; i++)\n        parent[i] = i;\n\n    int edges[MAX_TOWNS * MAX_TOWNS][3];\n    int edgeCount = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int cost = abs(towns[i].x - towns[j].x);\n            cost = (cost < abs(towns[i].y - towns[j].y)) ? cost : abs(towns[i].y - towns[j].y);\n            \n            edges[edgeCount][0] = cost;\n            edges[edgeCount][1] = i;\n            edges[edgeCount][2] = j;\n            edgeCount++;\n        }\n    }\n\n    for (int i = 0; i < edgeCount - 1; i++) {\n        for (int j = 0; j < edgeCount - i - 1; j++) {\n            if (edges[j][0] > edges[j+1][0]) {\n                int temp[3];\n                temp[0] = edges[j][0];\n                temp[1] = edges[j][1];\n                temp[2] = edges[j][2];\n                \n                edges[j][0] = edges[j+1][0];\n                edges[j][1] = edges[j+1][1];\n                edges[j][2] = edges[j+1][2];\n                \n                edges[j+1][0] = temp[0];\n                edges[j+1][1] = temp[1];\n                edges[j+1][2] = temp[2];\n            }\n        }\n    }\n\n    int totalCost = 0;\n    int connectedEdges = 0;\n\n    for (int i = 0; i < edgeCount; i++) {\n        int u = edges[i][1];\n        int v = edges[i][2];\n        int cost = edges[i][0];\n\n        if (find(u) != find(v)) {\n            unionSet(u, v);\n            totalCost += cost;\n            connectedEdges++;\n\n            if (connectedEdges == n - 1)\n                break;\n        }\n    }\n\n    return totalCost;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Town towns[MAX_TOWNS];\n    for (int i = 0; i < n; i++)\n        scanf(\"%d %d\", &towns[i].x, &towns[i].y);\n\n    printf(\"%d\\n\", minCost(towns, n));\n    return 0;\n}",
    "timestamp": "2025-08-05 23:19:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x, y;\n} Town;\n\ntypedef struct {\n    int u, v;\n    int cost;\n} Edge;\n\nint compareEdges(const void *a, const void *b) {\n    Edge *edgeA = (Edge *)a;\n    Edge *edgeB = (Edge *)b;\n    return edgeA->cost - edgeB->cost;\n}\n\nint findParent(int parent[], int i) {\n    if (parent[i] == i)\n        return i;\n    return findParent(parent, parent[i]);\n}\n\nvoid unionSets(int parent[], int rank[], int x, int y) {\n    int xroot = findParent(parent, x);\n    int yroot = findParent(parent, y);\n\n    if (rank[xroot] < rank[yroot])\n        parent[xroot] = yroot;\n    else if (rank[xroot] > rank[yroot])\n        parent[yroot] = xroot;\n    else {\n        parent[yroot] = xroot;\n        rank[xroot]++;\n    }\n}\n\nint minCostToConnect(Town towns[], int N) {\n    if (N == 0) return 0;\n\n    int totalEdges = N * (N - 1) / 2;\n    Edge *edges = (Edge *)malloc(totalEdges * sizeof(Edge));\n    int edgeCount = 0;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int dx = abs(towns[i].x - towns[j].x);\n            int dy = abs(towns[i].y - towns[j].y);\n            edges[edgeCount].u = i;\n            edges[edgeCount].v = j;\n            edges[edgeCount].cost = dx < dy ? dx : dy;\n            edgeCount++;\n        }\n    }\n\n    qsort(edges, edgeCount, sizeof(Edge), compareEdges);\n\n    int *parent = (int *)malloc(N * sizeof(int));\n    int *rank = (int *)malloc(N * sizeof(int));\n\n    for (int i = 0; i < N; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n\n    int minCost = 0;\n    int connected = 0;\n\n    for (int i = 0; i < edgeCount && connected < N - 1; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int cost = edges[i].cost;\n\n        int uroot = findParent(parent, u);\n        int vroot = findParent(parent, v);\n\n        if (uroot != vroot) {\n            minCost += cost;\n            unionSets(parent, rank, uroot, vroot);\n            connected++;\n        }\n    }\n\n    free(edges);\n    free(parent);\n    free(rank);\n\n    return minCost;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Town *towns = (Town *)malloc(N * sizeof(Town));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &towns[i].x, &towns[i].y);\n    }\n    printf(\"%d\\n\", minCostToConnect(towns, N));\n    free(towns);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:19:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nstruct Edge {\n    int u, v, cost;\n    Edge(int u, int v, int cost) : u(u), v(v), cost(cost) {}\n};\n\nbool compareEdges(const Edge &a, const Edge &b) {\n    return a.cost < b.cost;\n}\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\npublic:\n    UnionFind(int size) {\n        parent.resize(size);\n        rank.resize(size, 0);\n        for (int i = 0; i < size; ++i)\n            parent[i] = i;\n    }\n    int find(int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY])\n                parent[rootY] = rootX;\n            else {\n                parent[rootX] = rootY;\n                if (rank[rootX] == rank[rootY])\n                    rank[rootY]++;\n            }\n        }\n    }\n};\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pair<int, int>> towns(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> towns[i].first >> towns[i].second;\n    }\n\n    vector<Edge> edges;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            int dx = abs(towns[i].first - towns[j].first);\n            int dy = abs(towns[i].second - towns[j].second);\n            edges.emplace_back(i, j, min(dx, dy));\n        }\n    }\n\n    sort(edges.begin(), edges.end(), compareEdges);\n\n    UnionFind uf(N);\n    int totalCost = 0;\n    for (const Edge &e : edges) {\n        if (uf.find(e.u) != uf.find(e.v)) {\n            uf.unite(e.u, e.v);\n            totalCost += e.cost;\n        }\n    }\n\n    cout << totalCost << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:20:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge implements Comparable<Edge> {\n    int u, v;\n    int cost;\n\n    Edge(int u, int v, int cost) {\n        this.u = u;\n        this.v = v;\n        this.cost = cost;\n    }\n\n    @Override\n    public int compareTo(Edge other) {\n        return Integer.compare(this.cost, other.cost);\n    }\n}\n\nclass UnionFind {\n    private int[] parent;\n    private int[] rank;\n\n    UnionFind(int size) {\n        parent = new int[size];\n        rank = new int[size];\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootX] = rootY;\n                if (rank[rootX] == rank[rootY]) {\n                    rank[rootY]++;\n                }\n            }\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[][] towns = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            towns[i][0] = scanner.nextInt();\n            towns[i][1] = scanner.nextInt();\n        }\n\n        List<Edge> edges = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int dx = Math.abs(towns[i][0] - towns[j][0]);\n                int dy = Math.abs(towns[i][1] - towns[j][1]);\n                int cost = Math.min(dx, dy);\n                edges.add(new Edge(i, j, cost));\n            }\n        }\n\n        Collections.sort(edges);\n        UnionFind uf = new UnionFind(N);\n        int totalCost = 0;\n        for (Edge edge : edges) {\n            if (uf.find(edge.u) != uf.find(edge.v)) {\n                uf.union(edge.u, edge.v);\n                totalCost += edge.cost;\n            }\n        }\n\n        System.out.println(totalCost);\n    }\n}",
    "timestamp": "2025-08-05 23:20:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    static class Town {\n        int x, y;\n        Town(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static class Edge implements Comparable<Edge> {\n        int u, v, cost;\n        Edge(int u, int v, int cost) {\n            this.u = u;\n            this.v = v;\n            this.cost = cost;\n        }\n\n        public int compareTo(Edge other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n\n    static int[] parent;\n\n    static int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    static void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            parent[rootX] = rootY;\n        }\n    }\n\n    public static int minimumCost(int N, int[][] coordinates) {\n        Town[] towns = new Town[N];\n        for (int i = 0; i < N; i++) {\n            towns[i] = new Town(coordinates[i][0], coordinates[i][1]);\n        }\n\n        List<Edge> edges = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int cost = Math.min(Math.abs(towns[i].x - towns[j].x), \n                                    Math.abs(towns[i].y - towns[j].y));\n                edges.add(new Edge(i, j, cost));\n            }\n        }\n\n        Collections.sort(edges);\n        parent = new int[N];\n        for (int i = 0; i < N; i++) {\n            parent[i] = i;\n        }\n\n        int totalCost = 0;\n        int edgesUsed = 0;\n\n        for (Edge edge : edges) {\n            if (find(edge.u) != find(edge.v)) {\n                union(edge.u, edge.v);\n                totalCost += edge.cost;\n                edgesUsed++;\n\n                if (edgesUsed == N - 1) {\n                    break;\n                }\n            }\n        }\n\n        return totalCost;\n    }\n}",
    "timestamp": "2025-08-05 23:20:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\n\npublic:\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        iota(parent.begin(), parent.end(), 0);\n    }\n\n    int find(int x) {\n        if (parent[x] != x) \n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    bool unionSet(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return false;\n\n        if (rank[px] < rank[py]) \n            swap(px, py);\n        \n        parent[py] = px;\n        if (rank[px] == rank[py]) \n            rank[px]++;\n        \n        return true;\n    }\n};\n\nint minimumCost(vector<pair<int, int>>& towns) {\n    int n = towns.size();\n    vector<tuple<int, int, int>> edges;\n\n    // Generate x-coordinate based edges\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int cost = abs(towns[i].first - towns[j].first);\n            edges.push_back({cost, i, j});\n        }\n    }\n\n    // Generate y-coordinate based edges\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int cost = abs(towns[i].second - towns[j].second);\n            edges.push_back({cost, i, j});\n        }\n    }\n\n    // Sort edges by cost\n    sort(edges.begin(), edges.end());\n\n    // Kruskal's algorithm\n    UnionFind uf(n);\n    int totalCost = 0;\n    int connectedEdges = 0;\n\n    for (auto& [cost, u, v] : edges) {\n        if (uf.unionSet(u, v)) {\n            totalCost += cost;\n            connectedEdges++;\n            if (connectedEdges == n - 1) break;\n        }\n    }\n\n    return totalCost;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<int, int>> towns(n);\n\n    for (int i = 0; i < n; i++) {\n        cin >> towns[i].first >> towns[i].second;\n    }\n\n    cout << minimumCost(towns) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:20:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class UnionFind:\n    def __init__(self, size):\n        self.root = list(range(size))\n        self.rank = [1] * size\n    \n    def find(self, x):\n        if self.root[x] != x:\n            self.root[x] = self.find(self.root[x])\n        return self.root[x]\n    \n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            if self.rank[rootX] > self.rank[rootY]:\n                self.root[rootY] = rootX\n            elif self.rank[rootX] < self.rank[rootY]:\n                self.root[rootX] = rootY\n            else:\n                self.root[rootY] = rootX\n                self.rank[rootX] += 1\n            return True\n        return False\n\ndef min_cost_to_connect_towns(towns):\n    n = len(towns)\n    edges = []\n\n    x_sorted = sorted(range(n), key=lambda i: towns[i][0])\n    y_sorted = sorted(range(n), key=lambda i: towns[i][1])\n\n    for i in range(n - 1):\n        a, b = x_sorted[i], x_sorted[i + 1]\n        edges.append((min(abs(towns[a][0] - towns[b][0]), abs(towns[a][1] - towns[b][1])), a, b))\n        \n        c, d = y_sorted[i], y_sorted[i + 1]\n        edges.append((min(abs(towns[c][0] - towns[d][0]), abs(towns[c][1] - towns[d][1])), c, d))\n\n    edges.sort()\n    uf = UnionFind(n)\n    total_cost = 0\n    edge_count = 0\n\n    for cost, u, v in edges:\n        if uf.union(u, v):\n            total_cost += cost\n            edge_count += 1\n            if edge_count == n - 1:\n                break\n\n    return total_cost\n\n# Example:\n# towns = [(0, 0), (2, 2), (3, 10), (5, 2), (7, 0)]\n# print(min_cost_to_connect_towns(towns))",
    "timestamp": "2025-08-13 14:46:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MinRoadsCost {\n    private static class Edge implements Comparable<Edge> {\n        int from, to, cost;\n\n        Edge(int from, int to, int cost) {\n            this.from = from;\n            this.to = to;\n            this.cost = cost;\n        }\n\n        @Override\n        public int compareTo(Edge other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n\n    private static class UnionFind {\n        private int[] parent, rank;\n\n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) parent[i] = i;\n        }\n\n        int find(int x) {\n            if (x != parent[x]) parent[x] = find(parent[x]);\n            return parent[x];\n        }\n\n        boolean union(int x, int y) {\n            int rootX = find(x), rootY = find(y);\n            if (rootX == rootY) return false;\n            if (rank[rootX] > rank[rootY]) parent[rootY] = rootX;\n            else if (rank[rootX] < rank[rootY]) parent[rootX] = rootY;\n            else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            return true;\n        }\n    }\n\n    public static int minCostToConnectTowns(int[][] towns) {\n        int n = towns.length;\n        List<Edge> edges = new ArrayList<>();\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int cost = Math.min(Math.abs(towns[i][0] - towns[j][0]), \n                                    Math.abs(towns[i][1] - towns[j][1]));\n                edges.add(new Edge(i, j, cost));\n            }\n        }\n\n        Collections.sort(edges);\n        \n        UnionFind uf = new UnionFind(n);\n        int totalCost = 0;\n        int edgesUsed = 0;\n        \n        for (Edge edge : edges) {\n            if (uf.union(edge.from, edge.to)) {\n                totalCost += edge.cost;\n                edgesUsed++;\n                if (edgesUsed == n - 1) break;\n            }\n        }\n\n        return totalCost;\n    }\n\n    public static void main(String[] args) {\n        int[][] towns = {{0, 0}, {2, 2}, {3, 10}, {5, 2}, {7, 0}};\n        System.out.println(minCostToConnectTowns(towns)); // Replace with actual test cases\n    }\n}",
    "timestamp": "2025-08-13 14:46:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n    int index;\n} Town;\n\ntypedef struct {\n    int u, v, cost;\n} Edge;\n\nint compareEdges(const void* a, const void* b) {\n    return ((Edge*)a)->cost - ((Edge*)b)->cost;\n}\n\nint compareX(const void* a, const void* b) {\n    return ((Town*)a)->x - ((Town*)b)->x;\n}\n\nint compareY(const void* a, const void* b) {\n    return ((Town*)a)->y - ((Town*)b)->y;\n}\n\nint find(int parent[], int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent, parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unionSets(int parent[], int rank[], int x, int y) {\n    int rootX = find(parent, x);\n    int rootY = find(parent, y);\n\n    if (rootX != rootY) {\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n}\n\nint minimumCost(int N, Town towns[]) {\n    Edge* edges = (Edge*)malloc(2 * N * sizeof(Edge));\n    int edgeCount = 0;\n\n    qsort(towns, N, sizeof(Town), compareX);\n    for (int i = 0; i < N - 1; i++) {\n        int cost = abs(towns[i + 1].x - towns[i].x);\n        edges[edgeCount++] = (Edge){towns[i].index, towns[i + 1].index, cost};\n    }\n\n    qsort(towns, N, sizeof(Town), compareY);\n    for (int i = 0; i < N - 1; i++) {\n        int cost = abs(towns[i + 1].y - towns[i].y);\n        edges[edgeCount++] = (Edge){towns[i].index, towns[i + 1].index, cost};\n    }\n\n    qsort(edges, edgeCount, sizeof(Edge), compareEdges);\n\n    int* parent = (int*)malloc(N * sizeof(int));\n    int* rank = (int*)malloc(N * sizeof(int));\n\n    for (int i = 0; i < N; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n\n    int result = 0;\n    for (int i = 0; i < edgeCount; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int cost = edges[i].cost;\n\n        if (find(parent, u) != find(parent, v)) {\n            unionSets(parent, rank, u, v);\n            result += cost;\n        }\n    }\n\n    free(edges);\n    free(parent);\n    free(rank);\n\n    return result;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Town* towns = (Town*)malloc(N * sizeof(Town));\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &towns[i].x, &towns[i].y);\n        towns[i].index = i;\n    }\n\n    int result = minimumCost(N, towns);\n    printf(\"%d\\n\", result);\n\n    free(towns);\n    return 0;\n}",
    "timestamp": "2025-08-13 14:46:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v, cost;\n    \n    // Sort edges by cost\n    bool operator<(const Edge &other) const {\n        return cost < other.cost;\n    }\n};\n\nint find(vector<int> &parent, int a) {\n    if (parent[a] == a)\n        return a;\n    return parent[a] = find(parent, parent[a]);\n}\n\nvoid unite(vector<int> &parent, vector<int> &rank, int a, int b) {\n    a = find(parent, a);\n    b = find(parent, b);\n    if (a != b) {\n        if (rank[a] < rank[b])\n            swap(a, b);\n        parent[b] = a;\n        if (rank[a] == rank[b])\n            rank[a]++;\n    }\n}\n\nint minimum_cost_to_connect_towns(vector<pair<int, int>> &town_coordinates) {\n    int n = town_coordinates.size();\n    \n    vector<Edge> edges;\n    \n    // Create edges by sorting towns by x and y coordinates\n    for (int coord = 0; coord <= 1; ++coord) {\n        vector<pair<int, int>> points;\n        for (int i = 0; i < n; ++i) {\n            points.emplace_back(town_coordinates[i].first * (coord == 0) + town_coordinates[i].second * (coord == 1), i);\n        }\n        sort(points.begin(), points.end());\n        for (int i = 0; i < n - 1; ++i) {\n            int u = points[i].second;\n            int v = points[i + 1].second;\n            int cost = min(abs(town_coordinates[u].first - town_coordinates[v].first), abs(town_coordinates[u].second - town_coordinates[v].second));\n            edges.push_back({u, v, cost});\n        }\n    }\n    \n    // Kruskal's algorithm to find MST\n    sort(edges.begin(), edges.end());\n    vector<int> parent(n), rank(n, 0);\n    for (int i = 0; i < n; ++i) parent[i] = i;\n    \n    int mst_cost = 0, edges_used = 0;\n    for (const auto &edge : edges) {\n        if (find(parent, edge.u) != find(parent, edge.v)) {\n            unite(parent, rank, edge.u, edge.v);\n            mst_cost += edge.cost;\n            if (++edges_used == n - 1)\n                break;\n        }\n    }\n    \n    return mst_cost;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<int, int>> town_coordinates(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> town_coordinates[i].first >> town_coordinates[i].second;\n    }\n    \n    cout << minimum_cost_to_connect_towns(town_coordinates) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:47:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_minimum_road_cost(towns):\n    n = len(towns)\n    towns.sort()\n    \n    def find(parent, x):\n        if parent[x] != x:\n            parent[x] = find(parent, parent[x])\n        return parent[x]\n    \n    def union(parent, rank, x, y):\n        px, py = find(parent, x), find(parent, y)\n        if px == py:\n            return False\n        if rank[px] < rank[py]:\n            px, py = py, px\n        parent[py] = px\n        if rank[px] == rank[py]:\n            rank[px] += 1\n        return True\n    \n    edges = []\n    for i in range(n):\n        for j in range(i+1, n):\n            cost = min(abs(towns[i][0] - towns[j][0]), abs(towns[i][1] - towns[j][1]))\n            edges.append((cost, i, j))\n    \n    edges.sort()\n    \n    parent = list(range(n))\n    rank = [0] * n\n    total_cost = 0\n    connected_edges = 0\n    \n    for cost, u, v in edges:\n        if union(parent, rank, u, v):\n            total_cost += cost\n            connected_edges += 1\n            if connected_edges == n - 1:\n                break\n    \n    return total_cost",
    "timestamp": "2025-08-13 14:47:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef find(parent, i):\n    if parent[i] != i:\n        parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    x_root = find(parent, x)\n    y_root = find(parent, y)\n    if rank[x_root] < rank[y_root]:\n        parent[x_root] = y_root\n    elif rank[x_root] > rank[y_root]:\n        parent[y_root] = x_root\n    else:\n        parent[y_root] = x_root\n        rank[x_root] += 1\n\ndef minimum_cost_to_connect(N, towns):\n    edges = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            x1, y1 = towns[i]\n            x2, y2 = towns[j]\n            cost = min(abs(x1 - x2), abs(y1 - y2))\n            edges.append((cost, i, j))\n    \n    edges.sort()\n    parent = [i for i in range(N)]\n    rank = [0] * N\n    total_cost = 0\n    for cost, u, v in edges:\n        u_root = find(parent, u)\n        v_root = find(parent, v)\n        if u_root != v_root:\n            total_cost += cost\n            union(parent, rank, u_root, v_root)\n    return total_cost\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    towns = []\n    for _ in range(N):\n        x = int(input[ptr])\n        y = int(input[ptr + 1])\n        towns.append((x, y))\n        ptr += 2\n    print(minimum_cost_to_connect(N, towns))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 14:47:17"
  }
]